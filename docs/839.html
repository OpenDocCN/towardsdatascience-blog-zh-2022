<html>
<head>
<title>Fuzzing Tests in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋模糊测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fuzzing-tests-in-go-96eb08b7694d#2022-01-31">https://towardsdatascience.com/fuzzing-tests-in-go-96eb08b7694d#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="0711" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">围棋模糊测试</h1></div><div class=""><h2 id="6d69" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模糊化是一种自动为函数生成输入值来查找bug的技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f27e429af90e923b68509eeafc20e6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skeuHKluH_S4e3kyBHw6aQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go中的Fuzzing允许我们测试随机生成的函数输入。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="2d86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Fuzzing是作为Go 1.18中标准库的一部分发布的。这是一种很酷的方法，可以定位你从未想到的代码中的错误。我知道很多bug是使用第三方fuzzers的人在Go的标准库中发现的。</p><p id="91f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模糊化将是常规<code class="fe lu lv lw lx b">testing</code>库的一部分，因为它是一种测试。它也可以和来自<code class="fe lu lv lw lx b">testing</code>的其他工具一起使用，这很好。</p><p id="e52a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将学习如何使用新的fuzzer，以及fuzzer我们已经建立的HTTP处理程序。</p><p id="8146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，你需要确保你运行的至少是Go 1.18，你可以在我对1.18的修改中看到如何安装它。</p><div class="ly lz gp gr ma mb"><a href="https://medium.com/@percybolmer/go-1-18-comes-with-many-amazing-changes-d33ac0afd6ee" rel="noopener follow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">Go 1.18带来了许多惊人的变化</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">期待已久的Go 1.18即将到来，它可能是很长一段时间以来讨论最多的Go更新…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">medium.com</p></div></div><div class="mk l"><div class="ml l mm mn mo mk mp ks mb"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这篇关于编程的文章的视频格式是Youtube</p></figure><h2 id="7c1c" class="ms mt it bd mu mv mw dn mx my mz dp na lh nb nc nd ll ne nf ng lp nh ni nj nk bi translated">设置模糊</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d7ce5de5d4c7f7f80cda1fd72f1384e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s0qawrHKRsi8j5_mRPZjSA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向fuzzer添加语料库种子，以允许它基于它生成数据。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="94ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了开始fuzzing，我创建了一个新项目，并初始化一个模块，我们将在里面工作。我们还需要一个以<code class="fe lu lv lw lx b">_test.go</code>为后缀的文件，在我的例子中，我初始化了一个名为Fuzzy的模块和一个<code class="fe lu lv lw lx b">main_test.go</code></p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="8baf" class="ms mt it lx b gy np nq l nr ns">mkdir fuzzy<br/>go mod init programmingpercy.tech/fuzzy<br/>touch main_test.go</span></pre><p id="48e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们模糊之前，我们需要一些模糊的东西。让我们创建一个处理程序来计算一个整型切片中的最大值。<br/>我们将在处理程序中引入一个错误，看看我们如何通过fuzzing找到它，错误将是任何等于50的结果都会导致它失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有已知错误的简单HTTP处理程序</p></figure><h2 id="d5b1" class="ms mt it bd mu mv mw dn mx my mz dp na lh nb nc nd ll ne nf ng lp nh ni nj nk bi translated">这些模糊的东西是什么</h2><p id="058c" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">是时候开始学习如何使用模糊器了。</p><p id="a061" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你熟悉Go测试，这可能会非常容易。Go中的测试是通过创建一个以<code class="fe lu lv lw lx b">Test</code>为前缀的函数并接受输入参数<code class="fe lu lv lw lx b">t *testing.T</code>来定义的。</p><p id="e43f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样的模式被用于模糊化，但是以<code class="fe lu lv lw lx b">Fuzz</code>为前缀并接受新的<code class="fe lu lv lw lx b">f *testing.F</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">定义模糊器很简单，只需使用*testing。f作为输入而不是*测试。T</p></figure><p id="c657" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要做的第一件事是为<code class="fe lu lv lw lx b">testing.F</code>提供一个<code class="fe lu lv lw lx b">Seed Corpus</code>，您应该将它视为示例数据。这是fuzzer将使用的数据，并将其修改为尝试的新输入。</p><p id="6cdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">种子应该尽可能地反映出函数的输入应该是什么样子，以获得模糊器的最佳结果。</p><p id="5b66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">添加种子是由接受以下数据类型的<code class="fe lu lv lw lx b">f.Add()</code>完成的。</p><ul class=""><li id="bd19" class="nz oa it la b lb lc le lf lh ob ll oc lp od lt oe of og oh bi translated">字符串，[]字节，符文</li><li id="4b10" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">int，int8，int16，int32，int64</li><li id="35d2" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">uint，uint8，unit16，uint32，uint64</li><li id="b0b5" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">浮动32，浮动64</li><li id="8f43" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt oe of og oh bi translated">弯曲件</li></ul><p id="9c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，您不能添加多种数据类型，如果您首先运行<code class="fe lu lv lw lx b">f.Add("hello")</code>，然后运行<code class="fe lu lv lw lx b">f.Add(10)</code>，它将会死机。</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="73bb" class="ms mt it lx b gy np nq l nr ns">mismatched types in corpus entry: [int], want [string]</span></pre><blockquote class="on oo op"><p id="b579" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">等等，但是我的函数需要多个输入参数？—愤怒的反Fuzzer</p></blockquote><p id="5d81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果需要多个输入参数，<code class="fe lu lv lw lx b">f.Add()</code>接受可变数量的输入。因此，您可以添加许多示例数据输入，只需确保示例种子与您的函数输入参数的顺序相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模糊多个输入参数</p></figure><p id="86f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道了如何添加种子，让我们为处理程序和<code class="fe lu lv lw lx b">Add</code>创建示例数据。我们将希望添加带有JSON数据的<code class="fe lu lv lw lx b">[]byte</code>,因为我们正在模糊一个HTTP处理程序。</p><p id="d702" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将首先设置一个HTTP服务器来托管我们正在模糊化的处理程序，并创建一些示例片段来提供给<code class="fe lu lv lw lx b">Seed Corpus</code>。然后，我们将切片整理成适当的JSON，并将它们添加到fuzzer中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托管HTTP处理程序并添加种子语料库。</p></figure><p id="30d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是时候实现模糊目标了。</p><p id="44f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始模糊化，我们必须使用<code class="fe lu lv lw lx b">f.Fuzz()</code>，它接受一个函数作为输入。该函数是模糊目标，应该检查错误，准备数据，并触发我们正在模糊的函数。</p><p id="4010" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到<code class="fe lu lv lw lx b">Fuzz</code>的输入函数必须接受<code class="fe lu lv lw lx b">testing.T</code>作为第一个参数，随后是添加到语料库的输入数据类型，以同样的顺序接受<strong class="la iu">。</strong></p><p id="db0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的例子中，我们只需要传递<code class="fe lu lv lw lx b">testing.T, []byte</code>，因为我们只给种子添加了一个[]字节。但是如果你添加了更多的输入，它们也需要在这里声明。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多个输入的外观示例</p></figure><p id="77bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们添加模糊目标。我们将想要做以下事情</p><ol class=""><li id="f955" class="nz oa it la b lb lc le lf lh ob ll oc lp od lt ou of og oh bi translated">将数据发送给我们的处理程序</li><li id="1d44" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt ou of og oh bi translated">检查响应状态</li><li id="35aa" class="nz oa it la b lb oi le oj lh ok ll ol lp om lt ou of og oh bi translated">检查响应是否为int。</li></ol><p id="0701" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会想，我们应该检查返回值是否正确，如果你有另一个已知有效的函数，你可以这样做。但是大多数时候你不知道预期收益，因为你不知道模糊器产生了什么输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模糊器的初稿</p></figure><p id="fc25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">终于到了运行fuzzer的时候了。为了启动fuzzer，我们运行常规的<code class="fe lu lv lw lx b">go test</code>命令，但是添加了<code class="fe lu lv lw lx b">--fuzz=Fuzz</code>标志，标志值将被用作前缀，并以Fuzz开始所有方法。你可以把它变成你想要的，只匹配某些方法签名。</p><p id="6d7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，要开始模糊化我们的<code class="fe lu lv lw lx b">FuzzTestHTTPHandler</code>,您可以运行下面的代码。</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="a43e" class="ms mt it lx b gy np nq l nr ns">go test --fuzz=FuzzTestHTTPHandler</span></pre><p id="3595" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是有用的，当你在未来有多个模糊功能。</p><p id="11c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模糊化与常规测试有点不同，<strong class="la iu">的默认行为是一直运行，直到出现故障，</strong>所以你要么需要取消模糊化，要么等到出现错误。还有第三个选项，添加<code class="fe lu lv lw lx b">-fuzztime</code>标志会在设定时间后取消。</p><p id="4fce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以要跑10秒钟，你会跑</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="da53" class="ms mt it lx b gy np nq l nr ns">go test --fuzz=Fuzz -fuzztime=10s</span></pre><p id="8202" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确保运行fuzzer，并等到它失败。您应该会看到类似于我的输出，但是因为输出是生成的，所以可能不一样。</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="2c09" class="ms mt it lx b gy np nq l nr ns">--- FAIL: FuzzTestHTTPHandler (0.51s)<br/>    --- FAIL: FuzzTestHTTPHandler (0.00s)<br/>        main_test.go:80: Expected status code 200, got 400<br/>        main_test.go:87: Error: invalid character 'j' looking for beginning of value</span><span id="fdb9" class="ms mt it lx b gy ov nq l nr ns">Failing input written to testdata\fuzz\FuzzTestHTTPHandler\582528ddfad69eb57775199a43e0f9fd5c94bba343ce7bb6724d4ebafe311ed4<br/>    To re-run:<br/>    go test -run=FuzzTestHTTPHandler/582528ddfad69eb57775199a43e0f9fd5c94bba343ce7bb6724d4ebafe311ed4</span></pre><p id="a1d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当fuzzer期间出现错误时，它将取消并将导致失败的输入参数写入文件。所有故障都被写入<code class="fe lu lv lw lx b">testdata\fuzz\NameOfYourFuzz\inputID</code>。</p><p id="843f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，JSON封送处理似乎失败了，让我们查看fuzzer文件的内容。</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="b452" class="ms mt it lx b gy np nq l nr ns">go test fuzz v1<br/>[]byte("0")</span></pre><p id="f61f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一行是关于fuzzer及其版本的信息。第二行是我们发送给HTTP处理程序的生成的有效负载。<br/>这次失败了，因为fuzzer发送了一个原始的0，这没什么，因为那不是正确的JSON。</p><p id="8478" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您编写第一个fuzzer时，这种情况并不少见，所以让我们将fuzzer数据做得更好。我们只想测试有效载荷何时是真正的JSON，因为我们已经知道任何错误的JSON有效载荷都会失败，并且应该失败。</p><p id="eebb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用<code class="fe lu lv lw lx b">t.Skip("reason of skipping")</code>跳过不正确的有效载荷，这在模糊化时很有用。我们将使用<code class="fe lu lv lw lx b">json.Valid</code>函数来确保我们只将正确的JSON传递给处理程序。</p><p id="f570" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在只检查json。有效是不够的，“0”是有效的JSON。然而，我们可以尝试将数据解组到一个<code class="fe lu lv lw lx b">ValuesRequest</code>结构，并跳过任何失败的有效载荷。这是一个过滤掉不良生成的有效载荷的好方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt mr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有有效载荷验证的最终模糊器，以确保只测试真实数据</p></figure><p id="0a98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行模糊器</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="fda6" class="ms mt it lx b gy np nq l nr ns">go test -v --fuzz=Fuzz</span></pre><p id="776c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让它运行一段时间，最终，你应该得到一个新的失败文件。该文件将向您显示检测到的错误，任何值50都会导致失败。</p><pre class="kj kk kl km gt nl lx nm nn aw no bi"><span id="31ea" class="ms mt it lx b gy np nq l nr ns">go test fuzz v1</span><span id="0955" class="ms mt it lx b gy ov nq l nr ns">[]byte("{\"vAlues\":[50]}")</span></pre><h2 id="4772" class="ms mt it bd mu mv mw dn mx my mz dp na lh nb nc nd ll ne nf ng lp nh ni nj nk bi translated">结论</h2><p id="69cf" class="pw-post-body-paragraph ky kz it la b lb nu ju ld le nv jx lg lh nw lj lk ll nx ln lo lp ny lr ls lt im bi translated">好了，你现在可以写你的模糊了。我们使用的例子可能看起来很荒谬，因为你知道<code class="fe lu lv lw lx b">value == 50</code>错误是由一个简单的if语句产生的。然而，为您的HTTP处理程序或任何其他方法编写fuzzers是检测难以发现的错误的好方法。</p><p id="3a58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模糊器通常可以找到单元测试遗漏的bug，因为单元测试通常只包含您输入的可能会导致失败的值。</p><p id="257e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在示例中看到的，为HTTP处理程序编写fuzzer的代码并不多，而且一旦您做了几次，就可以很快实现新的代码，使您的代码堆栈更加健壮且没有错误。</p><p id="c4db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你还在等什么，出去吧！</p><p id="a0df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于Go 1.18的变化，你可以在我的另一篇文章中阅读如何使用新的泛型。</p><div class="ly lz gp gr ma mb"><a href="https://medium.com/@percybolmer/learning-generics-in-go-318f53752ccd" rel="noopener follow" target="_blank"><div class="mc ab fo"><div class="md ab me cl cj mf"><h2 class="bd iu gy z fp mg fr fs mh fu fw is bi translated">在围棋中学习泛型</h2><div class="mi l"><h3 class="bd b gy z fp mg fr fs mh fu fw dk translated">泛型在更新1.18(将于2022年2月发布)中推出，带有一系列其他闪亮的新功能。你可以…</h3></div><div class="mj l"><p class="bd b dl z fp mg fr fs mh fu fw dk translated">medium.com</p></div></div><div class="mk l"><div class="ow l mm mn mo mk mp ks mb"/></div></div></a></div></div></div>    
</body>
</html>