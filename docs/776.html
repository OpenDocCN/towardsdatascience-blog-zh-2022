<html>
<head>
<title>Create a Custom Model Card with Google’s Model Card Toolkit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用谷歌的模型卡工具包创建一个定制的模型卡</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-a-custom-model-card-with-googles-model-card-toolkit-a1e89a7887b5#2022-01-27">https://towardsdatascience.com/create-a-custom-model-card-with-googles-model-card-toolkit-a1e89a7887b5#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="90dc" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用谷歌的模型卡工具包创建一个定制的模型卡</h1></div><div class=""><h2 id="cd72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将您自己的字段添加到Tensorflow模型卡工具包模式中，以便自动生成自定义机器学习模型文档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07b8c2eda5fbfaead888c4ce9b5fe02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGsf7C-OoV6p16BPwDV7OA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这份文档并不老，而是“老古董”(图片由作者提供。)</p></figure><p id="7da9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着算法决策的快速采用，模型透明性变得越来越重要。帮助解决这个透明性问题的一个提议的解决方案是<a class="ae lu" href="https://modelcards.withgoogle.com/about" rel="noopener ugc nofollow" target="_blank">模型卡</a>，它提供了带有模型性能度量和重要考虑事项的简明的便笺或备忘单风格的文档。准确和最新的文档很难获得，但像谷歌的开源Tensorflow <a class="ae lu" href="https://github.com/tensorflow/model-card-toolkit" rel="noopener ugc nofollow" target="_blank">模型卡工具包</a> (MCT)这样的新工具可以通过在执行建模脚本时以编程方式自动生成文档并直接插入模型性能指标和图形来提供帮助。</p><p id="76a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然MCT为模型卡内容提供了一个很好的模板，但我在使用它时犹豫了，因为我真的需要能够添加额外的信息来适当地记录我的一些用例的工作。对我来说，所提供的模式(在<a class="ae lu" href="https://github.com/tensorflow/model-card-toolkit/tree/master/model_card_toolkit/proto" rel="noopener ugc nofollow" target="_blank"> protobuf </a>中定义)是一个真正的限制因素。此外，Python数据类目前是在模型卡工具包的安装步骤 期间从所提供的模式中生成的<strong class="la iu"> <em class="lv">。</em></strong></p><p id="fd4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，如果模式是在安装中硬编码的，我如何扩展模型卡模板模式来添加关于我的模型的更详细的信息呢？我四处查看了一下，找到了所有需要修改的地方，以便添加模型卡内容，并构建了我自己的安装。因为我下周会忘记如何做这件事，除非我今天把它完整地记录下来，所以我想我会把细节以博客的形式发布出来。(嗯，感觉这里面有什么教训……)</p><h1 id="46e0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="7013" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">所有材料都可以在我的GitHub <a class="ae lu" href="https://github.com/mtpatter/model-card-demo" rel="noopener ugc nofollow" target="_blank">模型-卡片-演示</a> repo中获得。接下来，将repo克隆到您的本地环境中。你可以只在你的系统上运行Docker的例子，而不需要在本地安装任何东西，它将会与你当前拥有的任何版本的MCT隔离开来。在下面列出的文件中，我已经标记了在默认MCT模式中添加自定义字段所做的更改。只需搜索“自定义字段”</p><p id="771f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回购有几个不同的组成部分:</p><ul class=""><li id="6223" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">一个<a class="ae lu" href="https://github.com/mtpatter/model-card-demo/blob/main/Dockerfile" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>，可用于构建本教程的Docker映像。你也可以用它来使用一般的MCT(我发现它很难自己安装。)</li><li id="f60a" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">一个<a class="ae lu" href="https://github.com/mtpatter/model-card-demo/blob/main/data/custom_card_template.proto" rel="noopener ugc nofollow" target="_blank"> protobuf模式</a>，从最初的MCT模式修改而来，提供了一个额外的定制字段</li><li id="22e8" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">修改后的<a class="ae lu" href="https://github.com/mtpatter/model-card-demo/blob/main/custom_model_card_toolkit.py" rel="noopener ugc nofollow" target="_blank">custom _ model _ card _ toolkit . py文件</a>，定义了MCT类</li><li id="8646" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">修改后的<a class="ae lu" href="https://github.com/mtpatter/model-card-demo/blob/main/custom_model_card.py" rel="noopener ugc nofollow" target="_blank"> custom_model_card.py文件</a>，定义模型卡数据类</li><li id="1591" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">一个<a class="ae lu" href="https://github.com/mtpatter/model-card-demo/blob/main/template/html/my_template.html.jinja" rel="noopener ugc nofollow" target="_blank"> jinja模板</a>将在卡片中呈现额外的字段</li><li id="3d2f" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">一个示例端到端<a class="ae lu" href="https://github.com/mtpatter/model-card-demo/blob/main/make_card.py" rel="noopener ugc nofollow" target="_blank"> Python脚本</a>训练一个scikit-learn模型并生成带有附加字段的定制模型卡</li></ul><p id="2710" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成模型卡的Python脚本借用了Google Cloud的例子<a class="ae lu" href="https://cloud.google.com/blog/products/ai-machine-learning/create-a-model-card-with-scikit-learn" rel="noopener ugc nofollow" target="_blank">如何在云中创建和部署scikit-learn模型卡</a>。Google的例子是基于colab或Jupyter的笔记本，并在笔记本中渲染模型卡。我已经去掉了重要的部分，这样定制的模型卡就作为。您可以单独查看的html文件。</p><h1 id="360f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">方向</h1><p id="6a1a" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">先克隆repo，换到根目录。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="04ea" class="nm lx it ni b gy nn no l np nq">git clone https://github.com/mtpatter/model-card-demo.git<br/>cd model-card-demo</span></pre><p id="d6f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，构建一个安装了修改后的MCT的Docker映像。此图像基于TensorFlow提供的Docker图像。因为MCT工具包在安装时编译Python数据类(不是我的错！)，无论何时对原型模式字段进行更改，都需要重新生成映像来重新安装模型卡工具包。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4bdd" class="nm lx it ni b gy nn no l np nq">docker build -t "cards" .</span></pre><p id="60c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">训练模型，生成模型卡。请注意:下面的命令将运行一个Docker容器，该容器在本地挂载，对本地目录具有写访问权限，以便写入结果。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="ea82" class="nm lx it ni b gy nn no l np nq">docker run \<br/>  -u $(id -u):$(id -g) \<br/>  --rm \<br/>  -v $PWD/:/user/cards cards python make_card.py</span></pre><p id="d0b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果被本地写入。<code class="fe nr ns nt ni b">model_cards</code>目录下的html文件。</p><p id="9179" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然最初的模型卡看起来像是<a class="ae lu" href="https://github.com/tensorflow/model-card-toolkit/tree/v1.2.0" rel="noopener ugc nofollow" target="_blank">这个</a>，但是新生成的定制模型卡在第二行有一个额外的框，我在那里添加了更多的信息。在本例中，它是“需要知道的事情”，我在其中插入了另一个标题“干预”，以及一个包含字符串“评估”的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/4ce3b271ca3f8eee646bdeddf84d1fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W43iMw4kWFIWrQ6Gh5r2WA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结果代码生成的模型卡。(图片由作者提供，修改自<a class="ae lu" href="https://github.com/tensorflow/model-card-toolkit/tree/v1.2.0" rel="noopener ugc nofollow" target="_blank"> Tensorflow MCT </a>示例输出。)</p></figure><h1 id="fd3e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">粗糙的细节</h1><p id="63cf" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我不得不做一些改变，下面描述一下。</p><p id="293c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">旁白:这应该有助于更好地理解MCT如何用protobuf格式构造和保存模型卡，proto buf格式是一种序列化为文件的结构化数据格式(有点类似于数据库)。使用protobuf有很多好处，包括能够保留数据类型(int、str等)的特性。)当数据被保存并且能够传递与语言无关的数据时。如果你关注我的任何工作，你会知道我更喜欢Apache Avro，原因我会在另一篇博文中写。</p><ol class=""><li id="9869" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt nv mz na nb bi translated">模板。proto文件需要额外的字段——这里我添加了<em class="lv"> Thingstoknow </em>和<em class="lv"> Intervention </em>。安装时，会生成一个包含Python数据类的新文件，该文件是在工具包的其余部分中导入的，所以不要直接接触它。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供。)</p></figure><p id="4813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.工具包本身需要在update_model_card()函数中进行编辑。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供。)</p></figure><p id="02d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.模型卡模块本身需要更多的数据类和更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供。)</p></figure><p id="7307" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.jinja模板需要修改，以便在html中插入一个新的div。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供。)</p></figure><p id="6e55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.现在模型卡有了一个定制属性，<em class="lv">model _ card . thingstoknow . intervention</em>，它可以在您的模型卡生成脚本中定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供。)</p></figure><p id="11f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能看起来有点粗糙(因为确实如此)，但它确实有效。四处探索也有助于更好地揭示工具包的工作方式，这对于它的protobuf序列化组件来说尤其有趣。这些信息在任何地方都没有真正描述过，但它似乎是模型卡的整个基础…无论如何，请继续关注未来的协议缓冲区博客帖子！</p></div></div>    
</body>
</html>