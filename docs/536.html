<html>
<head>
<title>Fool-Proof Formula to Extracting Strings With SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SQL提取字符串的简单公式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fool-proof-formula-to-extracting-strings-with-sql-9b35c57de224#2022-01-18">https://towardsdatascience.com/fool-proof-formula-to-extracting-strings-with-sql-9b35c57de224#2022-01-18</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""><h1 id="a3d8" class="pw-post-title it iu iv bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">用SQL提取字符串的简单公式</h1></div><div class=""><h2 id="a6c5" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">解决讨厌的字符串问题的分步示例</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/0fc83c64af6e983a456bb462ed6146f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2_LMRPmCXx0BhIOsx04-w.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">在<a class="ae la" href="https://unsplash.com/s/photos/string?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae la" href="https://unsplash.com/@bkaraivanov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Bozhin karivanov</a>拍摄的照片</p></figure><p id="7785" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你有没有遇到过一个字符串提取问题，几个小时后却发现自己快疯了？人们很容易迷失在所有潜在的字符串函数中。</p><p id="a465" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">字符串是我最不喜欢使用SQL的数据类型。对于模式匹配，您需要了解许多不同的函数和字符。但是，当你正确使用它们时，我在本文中向你展示的方法是相当简单的。</p><p id="0f3f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我写这篇文章的目的是让字符串不那么烦人。从我的错误和许多小时的挫折中吸取教训！我将向您介绍我正在研究的问题、我的解决方案中的关键功能以及解决方案本身。到本文结束时，您将成为使用SQL提取字符串的专家。</p><h1 id="71c5" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">问题是</h1><p id="e809" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">我最近受命为营销团队重新创建一个数据模型。很大一部分逻辑是从活动链接中提取utm信息。当您在Google上做广告时，会使用utm信息创建特殊链接，如媒体、出版商、活动和来源。这些都组合在一起形成一个链接，看起来像这样:</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="6d8a" class="mz ly iv mv b gy na nb l nc nd"><a class="ae la" href="https://www.etsy.com/market/lamp_shades?utm_source=google&amp;utm_medium=cpc&amp;utm_term=etsy%20lamp%20shades_p&amp;utm_campaign=Search_US_Brand_GGL_ENG_Home_General_All&amp;utm_ag=Lamp+Shades&amp;utm_custom1=_k_Cj0KCQiAt8WOBhDbARIsANQLp94WN__lDzNNnwS6yptN8pqbeU09mUzcKN9-5hHMFTWbS4msnQJqh4YaAtaOEALw_wcB_k_&amp;utm_content=go_6518959416_125883546672_536666915699_aud-459688891835:kwd-308153672827_c_&amp;utm_custom2=6518959416&amp;gclid=Cj0KCQiAt8WOBhDbARIsANQLp94WN__lDzNNnwS6yptN8pqbeU09mUzcKN9-5hHMFTWbS4msnQJqh4YaAtaOEALw_wcB" rel="noopener ugc nofollow" target="_blank">https://www.etsy.com/market/lamp_shades?utm_source=google&amp;utm_medium=cpc&amp;utm_term=etsy%20lamp%20shades_p&amp;utm_campaign=Search_US</a></span></pre><p id="06bb" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">关键是识别模式。不只是一种模式，而是所有可能的模式。你可能认为你已经找到了一个有效的模式。但是，随后会出现一个特殊的用例，您也需要将它构建到您的逻辑中。找出您正在处理的字符串列中的所有模式。相信我，越早找到他们越好。将这些模式写在列表中，如下所示:</p><ul class=""><li id="8ed2" class="ne nf iv ld b le lf lh li lk ng lo nh ls ni lw nj nk nl nm bi translated">utm_source位于“utm_source”之后和“&amp;”之前</li><li id="1fee" class="ne nf iv ld b le nn lh no lk np lo nq ls nr lw nj nk nl nm bi translated">utm_medium位于“utm_medium”之后和“&amp;”之前</li><li id="8435" class="ne nf iv ld b le nn lh no lk np lo nq ls nr lw nj nk nl nm bi translated">utm_campaign位于“utm_campaign=”之后</li></ul><p id="4f9a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">一旦你找到了字符串中的模式，你就可以把它们翻译成代码。开始用文字而不是代码编写逻辑要容易得多。有了字符串提取，你的代码会变得非常混乱，非常快。几乎到了无法阅读的程度…</p><p id="9556" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">提示:</strong>边走边注释你的代码。这不仅有助于你在编写代码时更好地理解它，也有助于阅读你的代码的人。</p><h1 id="4fbf" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">SQL字符串函数</h1><h2 id="1109" class="mz ly iv bd lz ns nt dn md nu nv dp mh lk nw nx mj lo ny nz ml ls oa ob mn oc bi translated">CHARINDEX()</h2><p id="8e79" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在处理字符串时，我喜欢使用两种不同的函数。第一个是<strong class="ld iw"> CHARINDEX() </strong>函数。这会返回您提供给它的字符串的索引。它有两个输入，您正在搜索的字符串和您在中搜索的列<em class="od">。因此，如果我在<code class="fe oe of og mv b">campaign_link</code>列中寻找‘UTM _ medium ’,我会将其写成:</em></p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="8c0d" class="mz ly iv mv b gy na nb l nc nd">charindex('utm_medium', campaign_link)</span></pre><p id="16cd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这段代码将返回“utm_medium”在该列值中所处位置的索引。如果它不在列值中，函数将返回0。</p><h2 id="9e1e" class="mz ly iv bd lz ns nt dn md nu nv dp mh lk nw nx mj lo ny nz ml ls oa ob mn oc bi translated">子字符串()</h2><p id="a909" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">我要使用的下一个函数是<strong class="ld iw"> SUBSTRING() </strong>函数。这需要您想要定位字符串的列和两个索引——一个用于字符串的开头，一个用于结尾。它返回所提供的列中这两个索引之间的字符串。</p><p id="ec39" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果我知道字符串“utm_medium”在索引5和10之间，我会编写如下所示的代码:</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="4fdf" class="mz ly iv mv b gy na nb l nc nd">substring(campaign_link, 5, 10)</span></pre><p id="ac14" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这将返回<code class="fe oe of og mv b">campaign_link</code>列中索引5和10之间的字符串。</p><h1 id="f565" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">其他有用的SQL命令</h1><h2 id="c7bc" class="mz ly iv bd lz ns nt dn md nu nv dp mh lk nw nx mj lo ny nz ml ls oa ob mn oc bi translated">选择语句</h2><p id="6c24" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated"><strong class="ld iw"> CASE </strong>语句总是很方便，但在处理字符串时更是如此。它帮助我们处理我们在数据中发现的所有奇怪的一次性场景。<strong class="ld iw"> CASE </strong>语句遵循一个简单的“<em class="od">当这种情况发生时，则执行这个</em>模式。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="739b" class="mz ly iv mv b gy na nb l nc nd">CASE <br/>    WHEN utm_medium='Facebook' THEN 'Social'<br/>    ELSE <br/>END AS marketing_category</span></pre><p id="f141" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您还可以在<strong class="ld iw"> CASE </strong>语句中添加一个<code class="fe oe of og mv b">ELSE</code>来处理其他可能破坏代码的场景。并且，用<code class="fe oe of og mv b">END</code>结束你的案例陈述！</p><h2 id="a7d3" class="mz ly iv bd lz ns nt dn md nu nv dp mh lk nw nx mj lo ny nz ml ls oa ob mn oc bi translated">LIKE运算符</h2><p id="76b5" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated"><strong class="ld iw"> LIKE </strong>操作符对于在字符串中搜索模式特别有用。虽然它不能像<code class="fe oe of og mv b">CHARINDEX()</code>和<code class="fe oe of og mv b">SUBSTRING()</code>那样帮助提取那些模式，但它在<strong class="ld iw"> CASE </strong>语句中特别有用。它们通常由我写的案例陈述中的“<em class="od"> when </em>部分组成。</p><p id="6076" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当像使用一样使用<strong class="ld iw">时，你指定一个你正在搜索的字符串。根据您希望它在要搜索的列中的位置，您需要使用特殊的运算符。</strong></p><ul class=""><li id="8e72" class="ne nf iv ld b le lf lh li lk ng lo nh ls ni lw nj nk nl nm bi translated">_代表单个字符</li><li id="740c" class="ne nf iv ld b le nn lh no lk np lo nq ls nr lw nj nk nl nm bi translated">%代表一个、一个或多个字符</li></ul><p id="9b98" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我通常在要查找的字符串的开头和结尾使用%。只要字符串出现在列值中的任何位置，这将被证明是正确的。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="dd8a" class="mz ly iv mv b gy na nb l nc nd">CASE <br/>    WHEN campaign_link LIKE '%facebook%' THEN 'Social'<br/>    ELSE <br/>END AS marketing_category</span></pre><p id="84f9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请注意，我用单引号括起了要搜索的字符串，并用%号括起来。</p><h1 id="9c05" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">解决方案</h1><p id="acb2" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">现在，让我们进入解决问题的解决方案，并利用我刚才提到的这些功能。请记住，我是在反复试验之后才得出这个结论的。重要的是，如果你发现有什么不对劲的地方，就要不断地检查你的代码，并反复强调。</p><p id="cb29" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当我写字符串提取代码的时候，我是分几部分来做的。首先，我使用了<code class="fe oe of og mv b">CHARINDEX()</code>函数来查找我正在寻找的字符串部分的索引。这将返回utm_medium中“u”的索引，所以我们要将这个字符串的长度加到index函数中。这将返回=之后的字符串的索引。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="47d2" class="mz ly iv mv b gy na nb l nc nd">charindex('utm_medium=', campaign_link) + 11</span></pre><p id="f89b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我将它与<code class="fe oe of og mv b">SUBSTRING()</code>函数结合使用，以获取字符串索引右侧的所有内容(我通过在函数100中创建第二个索引来实现这一点)。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="a67b" class="mz ly iv mv b gy na nb l nc nd">substring(campaign_link, charindex('utm_medium=', campaign_link) + 11, 100)</span></pre><p id="6d33" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">之后，我添加了另一个<code class="fe oe of og mv b">CHARINDEX()</code>函数来查找下一个字符左边的字符串。为此，从索引中减去1，因为它是字符串的结尾，只有1个字符长。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="7e3d" class="mz ly iv mv b gy na nb l nc nd">substring(campaign_link, charindex('utm_medium', campaign_link) + 11, charindex('&amp;', campaign_link) - 1)</span></pre><p id="7787" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，我在这个逻辑中添加了一个CASE函数。但是，这只是在我意识到并非每个活动链接都有utm_source、utm_medium、utm_publisher等时才添加的。我需要一个案例来处理这些字符串后面没有“&amp;”的情况，就像我逻辑中的最后一个要点。</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="cd62" class="mz ly iv mv b gy na nb l nc nd">substring(campaign_link, </span><span id="2f7b" class="mz ly iv mv b gy oh nb l nc nd">          # starting with the index of utm_medium in the link<br/>          charindex('utm_medium', campaign_link) + 11, </span><span id="9eac" class="mz ly iv mv b gy oh nb l nc nd">          # if this string contains an &amp; then return that index<br/>          # if not, return 100 as the ending index<br/>          CASE <br/>              WHEN substring(campaign_link, charindex('utm_medium', campaign_link) LIKE '%&amp;%' THEN charindex('&amp;', campaign_link) - 1<br/>              ELSE 100 <br/>          END<br/>)</span></pre><p id="2b46" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看到事情变得多混乱了吗？在逻辑中添加CASE语句会使代码变得难以阅读，这就是为什么注释代码很重要的原因。阅读它的人需要很长时间才能意识到它在做什么。</p><p id="6fa2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让事情变得更加复杂的是，我们需要将它添加到另一个case语句中，如果utm_medium出现在<code class="fe oe of og mv b">campaign_link</code>中，这个语句将只提取它。这看起来像这样:</p><pre class="kl km kn ko gt mu mv mw mx aw my bi"><span id="8a80" class="mz ly iv mv b gy na nb l nc nd">CASE<br/># check if the link contains a utm_medium<br/>    WHEN campaign_link LIKE '%utm_medium%' THEN <br/># return the string after utm_medium=<br/>substring(campaign_link, charindex('utm_medium=', campaign_link) + 11,<br/># if this extract link contains an &amp;, find the index of that<br/>CASE <br/>    WHEN substring(campaign_link, charindex('utm_medium=', campaign_link) LIKE '%&amp;%' THEN charindex('&amp;', campaign_link) - 1<br/># if it doesn't, return 100 as the ending index<br/>    ELSE 100 <br/>END<br/>)<br/># if it doesn't contain utm_medium, return null <br/>    ELSE NULL<br/>END AS utm_medium</span></pre><h1 id="4596" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">结论</h1><p id="7d69" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">我发现字符串提取的关键是要有耐心。不要试图一口气写完整段代码。编写各个部分，验证它们是否如您所期望的那样工作，然后将它们集成在一起。虽然这看起来像是更多的工作，但从长远来看，它最终会花费更少的时间。如果你一头扎进去，肯定会出错，你会花更多的时间来调试你的代码。</p><p id="04b3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果您的工具箱中有这些函数和操作符，您将很快用SQL提取字符串。记住，注释你的代码！下次再来看看“<a class="ae la" rel="noopener" target="_blank" href="/3-sql-swaps-to-write-better-code-f8d304699cde"> 3个SQL交换以写出更好的代码</a>”和“<a class="ae la" rel="noopener" target="_blank" href="/how-to-use-these-6-unusual-sql-functions-b912e454afb0">如何使用这6个不寻常的SQL函数</a>”。</p></div></div>    
</body>
</html>