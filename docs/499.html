<html>
<head>
<title>Numerical Integration using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python进行数值积分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-numerically-integrate-dynamics-problems-w-python-85d9783aa088#2022-01-17">https://towardsdatascience.com/how-to-numerically-integrate-dynamics-problems-w-python-85d9783aa088#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="d988" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">使用Python进行数值积分</h1></div><div class=""><h2 id="6a3a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中数值积分方程和可视化结果的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2b7d855e2c1ca0b6a40ce075f58ab41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cr_6IIy1nAFLUeOf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿诺·弗朗西斯卡在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ce8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你是工程师、物理学家，还是一个动力学爱好者，你都有可能接触过常微分方程形式的运动方程。对于那些不熟悉的人来说，常微分方程是由一个独立变量的一个或多个函数及其导数组成的方程。在动力学问题中，独立变量通常是时间，或<em class="lv"> t </em>，方程通常与目标质量的位置、速度和加速度相关。</p><p id="a456" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然解析求解具有挑战性，而且通常是不可能的，但使用数值方法可以以很高的精度近似求解常微分方程。在计算机时代之前，这是一项艰巨的任务，但我们已经走过了漫长的道路，所以不要担心。现在，大多数编程语言都有可用的ODE解算器。通常，他们甚至有不止一个解算器，所以不缺少选项。Python本身有许多选项可供选择，但是在本演示中我们将集中讨论其中一个。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/a80baf9028f7f857b6850936a9984577.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*78D3IGa4kAM3lIfIiQr6pw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单摆问题[图片由作者提供]</p></figure><p id="2bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们将使用单摆作为例子来指导我们完成这个过程。质量<em class="lv"> m </em>(见下面的方程)的运动方程相对简单，所以它可以作为一个很好的例子。然而，代码的原理对于所有的运动方程都是一样的，所以你可以用它来解决各种各样的问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/f1a926479b10b51193d51868e44d4e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:196/1*YGOSfPlA6Soe-OmIi9QzCw.gif"/></div></figure><p id="301a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对这个方程是如何推导出来的感兴趣，请阅读下面的链接。</p><div class="mf mg gp gr mh mi"><a href="https://medium.com/@zackfizell10/using-lagrangian-mechanics-to-solve-dynamics-problems-663460cbf94e" rel="noopener follow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd iu gy z fp mn fr fs mo fu fw is bi translated">如何利用拉格朗日力学解决动力学问题</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">一个优雅简单的一步一步的过程来解决保守动力学问题</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">medium.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw ks mi"/></div></div></a></div><p id="414a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入研究代码之前，最好先了解一下ode求解器是如何工作的。在这个特殊的例子中，我们要解决一个初值问题，或者说IVP。对于IVP，ODE求解器从初始时间和初始条件开始(稍后将介绍)，逐步通过一个时间间隔，并在每个时间步长计算一个解。这是一个高层次的解释，所以如果你想了解更多，我鼓励你做你的研究。</p><p id="37c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">常微分方程求解器要求我们的运动方程建立为一个一阶微分方程系统。在当前状态下，由于对<em class="lv"> ϕ </em>的二阶时间导数，我们的运动方程是二阶微分方程。为了改变这一点，我们对<em class="lv"> y₁ </em>和<em class="lv"> y₂ </em>进行了“变量改变”,将得到两个一阶微分方程。我们的新方程组是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/bccdc9dba5d2e4a0ccefc57b01f67f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/1*Qt86LeQ2IPo9_u3FWy8zcQ.gif"/></div></figure><p id="c6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了新的微分方程组，下一步是定义一个起点，或者初始条件。它们采用上述等式中的<em class="lv"> y </em>向量的形式。我们还不需要<em class="lv">y’</em>向量；我们稍后会用到它。我们的初始条件通常是起始位置和速度。在我们的例子中，它是我们的初始角度，<em class="lv"> ϕ </em>，以及它的角速度。</p><p id="3e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以任意将角度设置为15或π/12弧度，将角速度设置为0弧度每秒(您可以更改这些值，但您的结果将与文章底部的图不同)。我们的<em class="lv"> y </em>向量上的下标0表示初始时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8adc4babbb22da53eb4862d14c58ed97.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/1*yEVFhqqUpPQUWBluyddZUw.gif"/></div></figure><p id="a4c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从代码开始，我们需要从Python导入必要的包。NumPy是一个非常强大的Python包，用于科学计算。为了便于调用，我们将其定义为<em class="lv"> np </em>。此外，我们需要来自<em class="lv"> SciPy </em>包的<em class="lv"> odeint </em>函数。这将用于对我们的ode进行数值积分。最后，我们需要从<em class="lv"> Matplotlib </em>中包含<em class="lv"> Pyplot </em>来可视化我们解决的系统。和<em class="lv"> NumPy </em>一样，为了方便调用，我们将<em class="lv"> Pyplot </em>定义为<em class="lv"> plt </em>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="1e5e" class="ne nf it na b gy ng nh l ni nj"># Importing Packages<br/>import numpy as np<br/>from scipy.integrate import odeint<br/>import matplotlib.pyplot as plt</span></pre><p id="97d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要为<em class="lv"> odeint </em>函数定义几个参数。在我们的代码中，它有三个输入:模型(或者我们新的一阶微分方程，<em class="lv">y’</em>向量)，初始条件，以及我们想要积分的时间数组。先定义我们的模型函数，<em class="lv"> model(t，y) </em>。下面是我们代码中的内容:</p><ul class=""><li id="08f0" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><em class="lv"> g </em> =重力常数(9.81米/秒)</li><li id="32b5" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><em class="lv"> l </em> =无质量杆的长度(1米)</li><li id="23c0" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><em class="lv"> y </em> =当前时间步长下我们的角度和角速率的向量(在文章前面定义)</li><li id="733d" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><em class="lv"> dydt </em> =矢量<em class="lv"> y </em>的时间导数(在文章前面有定义)</li></ul><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="491a" class="ne nf it na b gy ng nh l ni nj"># Model<br/>def model(y,t):<br/>    g = 9.81<br/>    l = 1</span><span id="8443" class="ne nf it na b gy ny nh l ni nj">    phi = y[0]<br/>    phi_dot = y[1]<br/>    phi_ddot = -g/l*np.sin(phi)<br/>    dydt = [phi_dot, phi_ddot]<br/>    return dydt</span></pre><p id="2519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<em class="lv"> odeint </em>函数需要的第二项是我们的初始条件。我们已经说明了这些是什么，所以让我们也说明我们感兴趣的时间间隔。假设我们想观察摆的质量在20秒内的表现。我们可以使用来自<em class="lv"> NumPy </em> ( <em class="lv"> np </em>)的<em class="lv"> linspace </em>函数来创建一个从0到20秒的时间点数组。我使用了1000的增量来确保我从ODE解算器得到一个平滑的输出。使用的增量越多，结果就越精确。在某种程度上，增量的数量不会带来什么好处，所以在未来的项目中使用它时，请使用您的最佳判断。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8ca8" class="ne nf it na b gy ng nh l ni nj"># Initial Conditions<br/>y0 = [np.pi/12, 0]</span><span id="0d9c" class="ne nf it na b gy ny nh l ni nj"># Time Array<br/>t = np.linspace(0, 20, 1000)</span></pre><p id="a371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们只需要用我们的模型、初始条件和时间数组运行ODE求解器。我们应该将它设置为等于另一个变量，<em class="lv"> sol </em>，这样我们就可以使用<em class="lv"> Pyplot </em> ( <em class="lv"> plt </em>)来操纵可视化数据。我们可以通过索引<em class="lv"> sol </em>的第一和第二列的整体(例如，对于第一列sol[:，0])，来提取我们的角度和角速率时间历史。历史是以弧度为单位的，所以为了更好的理解，我们可以把它转换成度数。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8025" class="ne nf it na b gy ng nh l ni nj"># Solving ODE<br/>sol = odeint(model, y0, t)<br/>phi_radians = sol[:, 0]<br/>phidot_radians_s = sol[:, 1]</span><span id="9b1c" class="ne nf it na b gy ny nh l ni nj"># Converting Radians to Degrees<br/>phi_degrees = phi_radians*180/np.pi<br/>phidot_degrees_s = phidot_radians_s*180/np.pi</span></pre><p id="a5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了可视化数据，我们可以使用<em class="lv"> plt </em>来创建我们感兴趣的数据的图表。使用<em class="lv"> Pyplot </em>有很多定制选项，所以如果你不喜欢默认设置，你可以很容易地改变你的线条和绘图的外观。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b89d" class="ne nf it na b gy ng nh l ni nj"># Plotting Results<br/>plt.plot(t, phi_degrees)<br/>plt.title('$\Phi$(t)')<br/>plt.xlabel('Time [s]')<br/>plt.ylabel('$\Phi$ [$^o$]')<br/>plt.show()<br/><br/>X = np.sin(phi_radians)<br/>Y = -np.cos(phi_radians)<br/>plt.plot(X, Y)<br/>plt.title('Spatial Motion')<br/>plt.xlabel('X [m]')<br/>plt.ylabel('Y [m]')<br/>plt.axis('equal')<br/>plt.show()</span></pre><p id="8588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行完所有代码后，您的绘图应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/435d0065218f60c57c29f086e0629b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*0aGqJHGnZHfLgurd1_fF1g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">角度时间历程[图片由作者提供]</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/64a68a7fd22c8ae78b4c63051d7ff96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ddv32OqmhWH5UBUSvzdYAQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">钟摆质量的运动[图片由作者提供]</p></figure><p id="ec83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的两个图显示了我们的质量如何在选定的时间间隔内移动。第一张图显示了ϕ在我们的时间间隔内是如何演变的。因为我们看到的是一个没有摩擦力的支点，我们期望质量在最大角度的+/-之间振荡，这个角度恰好是我们的起始角度15度(因为我们没有初始角速度)。第二个图显示了质量在20秒间隔内的轨迹。直觉上，这个运动是有意义的，所以我们可以合理地假设我们的ODE求解器和方程设置正确。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="123b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是这个例子的全部内容。如果你有任何问题，请随时评论。我非常乐意帮忙。如果这以任何方式帮助了你，请给它一个赞并跟随。谢谢大家！</p></div></div>    
</body>
</html>