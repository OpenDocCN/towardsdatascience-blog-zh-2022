<html>
<head>
<title>Exploring Python Type Hints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Python类型提示</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-python-type-hints-6520f478b6a#2022-01-17">https://towardsdatascience.com/exploring-python-type-hints-6520f478b6a#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/a1f8a2222d28cd22cfb147bc7d1dfe02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOnjQzUWXC1ryestxGUX_A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">马蒂亚斯·马尔卡在<a class="ae jg" href="https://unsplash.com/s/photos/java-and-python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""><h1 id="e2ac" class="pw-post-title jh ji jj bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">探索Python类型提示</h1></div><div class=""><h2 id="52ab" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">如何让您的代码经得起未来的考验</h2></div><p id="6985" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最近在Python中发现了一些有趣的功能，我已经开始尝试在日常编程中更多地使用这些功能。在这篇文章中，我想介绍Python类型提示，并讨论为什么我认为它们是你编程工作流程中真正强大的补充。</p><p id="34b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你是一个狂热的Python用户，你可能会发现最初的类型提示非常奇怪，甚至可能是不和谐的，但是希望在这篇文章结束时，我会让你相信事实并非如此，实际上它们真的可以改善你的代码库，并从长远来看使你的生活更容易。</p><p id="42ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了了解它们为什么有用，让我们看下面的代码片段，它定义了一个将两个数相加的函数。我们可以看到，当我们输入一个字符串，并尝试将它与一个整数相加时，我们会得到一个可爱的TypeError。现在，这是一个超级简单的例子，但是如果我们使用一个更大的代码库，我们可能不会注意到这个错误，直到我们真正尝试运行代码。这通常会很成问题。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="975e" class="md me jj lz b gy mf mg l mh mi">def add_two_numbers(a, b):<br/>   return a+b</span><span id="0df9" class="md me jj lz b gy mj mg l mh mi">&gt;&gt;&gt; add_two_numbers(1, '3')</span><span id="5b02" class="md me jj lz b gy mj mg l mh mi">Traceback (most recent call last):</span><span id="500d" class="md me jj lz b gy mj mg l mh mi">File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><span id="2eba" class="md me jj lz b gy mj mg l mh mi">TypeError: unsupported operand type(s) for +: 'int' and 'str'</span></pre><h1 id="5e1f" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">静态与动态类型</h1><p id="8d6c" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">上面我们提供了一个简单的类型错误的例子。让我们简单讨论一下为什么Python中会出现这个问题。为此，我们需要讨论静态和动态类型。如果你曾经使用过像C或Java这样的编程语言，你会知道你需要为你创建的变量声明数据类型。在Java中，我们可以使用下面的代码创建一个字符串变量。这些变量类型不允许改变。也就是说，如果我们试图将一个整型变量重新赋值给字符串变量，我们会得到一个错误。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b965" class="md me jj lz b gy mf mg l mh mi">String string_variable;<br/>string_variable = "This is a string";</span></pre><p id="d45b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ng">静态类型</em> </strong>的第二个重要方面是当类型错误被捕获时。因为像java这样的编程语言是编译的，所以编译器会在运行任何代码之前检查代码的正确性。如果你的代码中有类型错误，那么这就是它们被发现的时候。这提供了一些优于Python等解释型语言的优势。特别是，尽早捕捉错误可以避免在调试代码上花费大量时间。</p><p id="12e5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而Python是<strong class="la jk"> <em class="ng">动态类型化的。这意味着我们不必显式声明我们的变量类型。这也意味着Python会在代码运行时检查任何类型错误。例如，如果我们在if-else逻辑中嵌入了这些类型的错误，如果条件不满足，它就不会被捕获。以上面的字符串变量为例，如果我们试图给它重新赋值一个int，代码会运行得很好，我们的string_variable现在是int类型。</em></strong></p><h1 id="7b40" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">鸭子打字</h1><p id="2e95" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">另一个与动态类型化和Python密切相关的概念是<strong class="la jk"> <em class="ng"> duck typing。</em> </strong>我听你问鸭子打字到底是什么神？嗯，我同意，这是一个奇怪的名字，但它来自短语:<em class="ng">如果它看起来像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那么它可能</em>就是<em class="ng">鸭子。我们不一定关心对象的参数类型，我们关心的是对象的行为。如果它的行为像一只鸭子，那么实际上我们可以认为它是一只鸭子。</em></p><p id="3d93" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们举个例子来了解一下鸭子打字是怎么回事。因为我是一名数据科学家，所以我想看一个使用sklearn的实际例子。例如，如果我们想在一个建模管道中编码一些定制的转换，我们可以在sklearn中创建一个定制的转换器</p><p id="9c30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk"> <em class="ng">“由于Scikit-Learn依赖于duck typing(不是继承)，所以你需要做的就是创建一个类，实现三个方法:fit()(返回自我)、transform()、fit _ transform()”(Geron 2019)。</em>T11】</strong></p><p id="65f6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我们写一个自定义的转换器来估算数字数据。我们可以看到，只要我们实现了fit和transform方法，这将与sklearn完全兼容，并且可以与其他sklearn转换器一起用于管道中。这是通过duck typing实现的，因为python只关心我们的类是否具有与transformer相同的行为，也就是说，如果它有transform和fit_transform方法，那么它就会工作。Btw，下面没有fit_transform方法我们从TransformerMixin类继承时得到这个方法。<a class="ae jg" href="https://github.com/ageron/handson-ml/issues/391" rel="noopener ugc nofollow" target="_blank">这里的</a>很好地解释了这种行为。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="853a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="ng">注意:这并不意味着所有动态类型的语言都被解释，所有静态类型的语言都被编译。例如，我们可以拥有动态类型的解释语言，尽管据我所知，它们并不常见。</em></p><h1 id="c281" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">什么是Python类型提示，我为什么要关心？</h1><p id="9c44" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">好了，我们已经解释了动态、静态类型和鸭子类型之间的区别，但是为什么这很重要，这和类型提示有什么关系呢？尽管Python是一种动态类型语言，但我们可以使用类型提示来获得静态类型语言的一些好处。</p><p id="a686" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型提示(也称为类型注释)最初是在<a class="ae jg" href="https://www.python.org/dev/peps/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP 484 </a>中引入的，它允许我们模仿静态类型语言的行为。我说mimic是因为python解释器完全忽略了类型提示。相反，类型提示依赖于用户使用mypy之类的工具单独运行检查，稍后会详细介绍。</p><p id="8cf6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么我们实际上如何利用类型提示呢？文档详细介绍了使用类型提示的所有不同方式，但我将讨论一些您最常使用的方式。类型提示的语法非常简单和直观，如果你曾经用静态类型语言编写过代码，那么这对你来说并不陌生。如果您想开始使用类型提示，您将与之交互的主要模块是类型模块。它包含了我们将要用到的许多类型，比如列表、字典和元组等等。下面举个简单的例子，我们声明了一些变量，并说明了库中的一些类型。如果我们看一下<strong class="la jk"> <em class="ng"> process_data </em> </strong>中稍微做作的例子，我们可以看到我们有两个输入，一个字符串列表和一个整数列表。我们也知道我们的输出应该是包含字符串和整数的元组列表。在我看来，这使得理解代码变得非常容易，而且实现起来也不需要太多额外的努力。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="25ad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我们可以使用嵌套类型提示，这可能非常有用，但如果我们需要两层或三层嵌套，也可能非常笨拙。在这种情况下，我们实际上可以给一个变量分配一个类型提示，如下所示(类型别名)。恰当地使用变量可以大大提高代码的可读性，同时保持类型提示的优势。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6f82" class="md me jj lz b gy mf mg l mh mi">years = Tuple[str, int]<br/>year_list = List[years]</span></pre><h1 id="b323" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">重访我们的定制变压器</h1><p id="1d38" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">下面我们更新上面写的代码，加入类型提示。大多数类型提示应该是清楚的。我们可以看到，我们也可以使用来自pandas的类型，这显然非常有用，因为python中的大多数数据分析都以某种方式使用pandas。您可能想知道为什么我们将“CustomImputer”作为字符串包含在fit方法的返回中。这里有一个很好的理由来讨论<a class="ae jg" href="https://www.python.org/dev/peps/pep-0484/#id28" rel="noopener ugc nofollow" target="_blank"/>。它被称为前向引用，因为我们引用的是尚未创建的类型。将它作为字符串文字包含在内可以解决这个问题。除此之外，代码应该非常清晰，希望比原始代码片段更清晰。</p><p id="f20a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望您会同意，显式声明数据类型会使代码立即变得更清晰。当我们有大型复杂的代码库时，这样做的优势会更加明显，但是请相信我，如果您需要重构别人的代码或者需要在将来重新访问您自己的代码，您会感谢自己花时间添加类型提示。</p><figure class="lu lv lw lx gt iv"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="2754" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">Mypy:静态类型检查器</h1><p id="c34f" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">Mypy是Python的静态类型检查器。它允许我们在实际运行之前检查代码中常见的类型错误。这个库和类型提示结合在一起，将Java等静态类型语言的优势带到了Python中。</p><p id="b2f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们举一个mypy文档中概述的非常简单的例子。我们可以定义一个非常简单的函数，它接受一个字符串，并输出hello，后跟我们的字符串输入。如果我们传入一个字符串并运行类型检查器，我们会正确地看到没有错误。但是，如果我们传递一个int或任何其他数据类型，我们会立即看到一个错误消息。同样，当我们处理较大的项目时，这个功能特别有用。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fac6" class="md me jj lz b gy mf mg l mh mi">def main(name: str) -&gt; str:</span><span id="d501" class="md me jj lz b gy mj mg l mh mi">    return 'Hello ' + name</span><span id="137b" class="md me jj lz b gy mj mg l mh mi">if __name__=='__main__':<br/>    main('John')</span><span id="d80e" class="md me jj lz b gy mj mg l mh mi"><br/>mypy program.py<br/>&gt;&gt; Success: no issues found in 1 source file</span><span id="8ad5" class="md me jj lz b gy mj mg l mh mi">def main(name: str) -&gt; str:</span><span id="c017" class="md me jj lz b gy mj mg l mh mi">    return 'Hello ' + name</span><span id="5f84" class="md me jj lz b gy mj mg l mh mi">if __name__=='__main__':<br/>    main(10)</span><span id="d53d" class="md me jj lz b gy mj mg l mh mi">mypy program.py<br/>&gt;&gt; program.py:7: error: Argument 1 to "main" has incompatible type "int"; expected "str"<br/>Found 1 error in 1 file (checked 1 source file)</span></pre><p id="f937" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">mypy的一个缺点是它不能与外部库一起工作。如果你更倾向于使用numpy和pandas，那么探索一下<a class="ae jg" href="https://pypi.org/project/data-science-types/" rel="noopener ugc nofollow" target="_blank">数据科学类型</a>和<a class="ae jg" href="https://pypi.org/project/pandas-stubs/" rel="noopener ugc nofollow" target="_blank"> pandas-stub </a>可能是值得的，它们允许你运行更多数据科学相关库的类型检查，比如pandas、numpy和matplotlib。然而，数据科学类型库仍在开发中，所以它没有涵盖这些库中可用的所有类型。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e975" class="md me jj lz b gy mf mg l mh mi">pip install pandas-stub<br/>pip install data-science-types</span></pre><h1 id="b702" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">类型提示的优点和缺点</h1><p id="3fb3" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">虽然我是类型提示的粉丝，使用它们有很多好处，但是它们也有一些缺点。就优势而言，我认为最大的优势之一是</p><ul class=""><li id="d58b" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">它迫使你思考你的函数输入和输出:</strong>也就是说，一般来说，它让你更多地思考你的代码以及它是如何被设计使用的。对我来说，更深入地思考我正在编写的代码有助于提高我的编程技能。我认为仅仅这个理由就足够让我们开始使用它们了。</li></ul><p id="7f05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，使用类型提示非常重要，这意味着您的代码</p><ul class=""><li id="bae2" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">清晰的文档。清晰的文档使你的代码更容易阅读，不仅对你自己，对其他人也是如此。如果你曾经接手过别人的代码，并且认为，我不知道这些代码在做什么，你就会明白这有多重要。拥有清晰记录的代码在数据科学中似乎并不常见，但应该如此。</strong></li><li id="1a29" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><strong class="la jk">调试更容易:</strong>如果到现在还不清楚，现在应该清楚了。使用类型提示可以使调试代码中的问题变得容易得多，并且在很多情况下可以完全避免一些错误，特别是在使用像mypy这样的静态类型检查器时。</li></ul><p id="fbf6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型提示的另一个优点是，它们</p><ul class=""><li id="211e" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated"><strong class="la jk">可以逐步实现:</strong>您可能认为，与您习惯的相比，这将在编写代码的时间方面增加大量开销，您可能是对的。好消息是，您不需要一次性重构整个代码库。类型提示可以逐步实现。</li></ul><p id="9463" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好吧，那么缺点是什么？即使你可以逐步实现类型提示，它们仍然可能是一个</p><ul class=""><li id="dc52" class="nj nk jj la b lb lc le lf lh nl ll nm lp nn lt no np nq nr bi translated">大量的时间投入:虽然类型提示的基础非常简单，但是还有很多我在这篇文章中没有涉及到的内容。除了学习曲线之外，使用类型提示显然涉及到编写更多的代码，因此最初可能会导致开发时间增加。然而，通过减少调试花费的时间，这可以完全不在现场。我没有这方面的经验证据，但我完全可以相信，特别是对于更大更复杂的项目。</li><li id="49b0" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><strong class="la jk">它是否背离了python的简单和漂亮？</strong>这与其说是一个明显的缺点，不如说是一个公开的问题，但是那些铁杆than爱好者可能不愿意用类型提示来亵渎他们美丽的代码。</li></ul><h1 id="7811" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">建议和要点</h1><p id="0790" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">应该使用类型提示吗？最终这取决于你，但希望这篇文章能给你一些启发，如果你还在犹豫不决，会让你更容易做出决定。就我个人而言，我喜欢类型提示，所以我尽量使用它们。我的建议是，如果你只是在Jupyter笔记本上做一些快速和肮脏的数据分析，使用它们的缺点可能大于优点，所以我可能不会打扰。然而，如果你正在做更大的项目和产品代码，我建议你试一试，看看它们是否能改善你的工作流程。</p><h1 id="fb3c" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">资源</h1><ul class=""><li id="f2a0" class="nj nk jj la b lb nb le nc lh nx ll ny lp nz lt no np nq nr bi translated">【https://www.python.org/dev/peps/pep-0484/ T4】</li><li id="7443" class="nj nk jj la b lb ns le nt lh nu ll nv lp nw lt no np nq nr bi translated"><a class="ae jg" href="https://mypy.readthedocs.io/en/stable/introduction.html" rel="noopener ugc nofollow" target="_blank">https://mypy.readthedocs.io/en/stable/introduction.html</a></li></ul><h1 id="610c" class="mk me jj bd ml mm mn mo mp mq mr ms mt kp mu kq mv ks mw kt mx kv my kw mz na bi translated">我的其他一些帖子你可能会感兴趣</h1><div class="is it gp gr iu oa"><a rel="noopener follow" target="_blank" href="/building-machine-learning-pipelines-using-snowflake-and-dask-10ae5e7fff0f"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jk gy z fp of fr fs og fu fw ji bi translated">使用雪花和Dask构建机器学习管道</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">介绍</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ja oa"/></div></div></a></div><div class="is it gp gr iu oa"><a rel="noopener follow" target="_blank" href="/lets-build-a-streaming-data-pipeline-e873d671fc57"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jk gy z fp of fr fs og fu fw ji bi translated">让我们建立一个流数据管道</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">用于实时数据管道的Apache Beam和数据流</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ja oa"/></div></div></a></div><div class="is it gp gr iu oa"><a rel="noopener follow" target="_blank" href="/a-bayesian-approach-to-time-series-forecasting-d97dd4168cb7"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jk gy z fp of fr fs og fu fw ji bi translated">时间序列预测的贝叶斯方法</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">今天，我们将从头开始在R中实现贝叶斯线性回归，并使用它来预测美国的GDP增长…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="oq l ol om on oj oo ja oa"/></div></div></a></div></div></div>    
</body>
</html>