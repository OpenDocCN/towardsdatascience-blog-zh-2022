<html>
<head>
<title>Assembly, Compilers and the x86 Instruction Set</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">汇编、编译器和x86指令集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/assembly-compilers-and-the-x86-instruction-set-9a945c72d136#2022-01-31">https://towardsdatascience.com/assembly-compilers-and-the-x86-instruction-set-9a945c72d136#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="3269" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">汇编、编译器和x86指令集</h1></div><div class=""><h2 id="c1ef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍汇编语言及其在x86微处理器系列中的使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/971d6b02a264185c59c42d84086f9571.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EvciHTh9hAFrebcO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Vishnu Mohanan 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a71d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" rel="noopener" target="_blank" href="/back-to-bit-sics-bits-pointers-and-memory-8c0eb125a0b7">上一篇</a>文章中，我讨论了我目前是如何通过斯坦福大学的<a class="ae ky" href="https://web.stanford.edu/class/archive/cs/cs107/cs107.1222/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">计算机组织与系统(CS107) </strong> </a> <strong class="lb iu">。本课程旨在揭开硬件和软件之间交互的神秘面纱，让你更好地欣赏和理解你的代码实际上在做什么。在本文中，我们将解释课程后半部分的一些概念，我认为每个数据科学家都应该了解这些概念！</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b41" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">机器码和编译器</h1><p id="e5d3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">作为数据科学家，我们普遍使用Python、R或者Julia，但是大多数是用Python。Python语言被普遍认为是一种解释型语言<strong class="lb iu">。这意味着当你运行你的脚本时，它被转换成<strong class="lb iu">字节码</strong>，然后由虚拟机</strong>上的<strong class="lb iu"> Python解释器执行。这意味着只要你安装了Python解释器，你就可以在任何计算机上使用Python。最常见的解释器是<strong class="lb iu"> CPython </strong>。</strong></p><p id="fed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而其他语言如<strong class="lb iu"> C、C++和FORTRAN </strong>则被称为<strong class="lb iu">编译语言</strong>。要运行你的脚本，你必须使用<strong class="lb iu">编译器编译程序，该编译器将你的“高级”可理解的人类代码翻译成机器代码</strong>。编译器的需要使得计算机只能读取二进制指令。<strong class="lb iu">中央处理器(CPU) </strong>不理解命令<strong class="lb iu"><em class="mz">printf(" Hello World ")</em></strong>但却理解类似<strong class="lb iu"> 10111010101011等。因此，要执行你的代码，它需要被翻译成机器语言，一堆0和1，因为那是它唯一能理解的语言。</strong></p><p id="65d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们不用机器语言来写呢？ </p><p id="d697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题半频繁地被问到，答案是这个问题太难了。想象一下试图编写一串0和1的代码，或者更糟的是，读取别人的0和1的字符串。因此，我们用人类可以理解的<strong class="lb iu">‘高级’</strong>语言编写，并编译(翻译)成机器代码。</p><h1 id="d4a1" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">装配</h1><p id="b7bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">目前，世界上大约有700种编程语言。这确实包括那些有着非常特殊用途的晦涩难懂的语言，但其数量仍然令人印象深刻。这些语言从计算机物理硬件的实际运行中抽象出<strong class="lb iu"/>。例如，C被认为比Python更<strong class="lb iu">【低级】</strong>，主要是因为它的手动<strong class="lb iu">内存管理</strong>规范。然而，也许人类最容易理解的语言是汇编语言。</p><p id="9411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">汇编语言</strong>可以被认为是从机器码中删除了一次，它用<strong class="lb iu">助记符</strong>代替了二进制数，使其更具可读性。汇编代码仍然只是字节，<strong class="lb iu">没有数据类型，没有类型检查</strong>但是一些二进制指令是字/符号。它是机器代码的精确缩写。</p><p id="2079" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">助记符的例子包括:</p><ul class=""><li id="dffc" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu">MOV</strong>——将字节(数据)从内存的一个区域移到另一个区域</li><li id="7bd8" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><strong class="lb iu">加法</strong>——将内存中的值加在一起</li><li id="4410" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><strong class="lb iu"> CMP </strong> -比较内存中的两个值</li></ul><p id="db1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令中有很多是由叫做<strong class="lb iu">寄存器的东西执行的。</strong>寄存器是CPU中保存变量值的<strong class="lb iu">快速读/写内存槽</strong>。</p><p id="2c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">汇编与机器码有一一对应的关系，可以用<strong class="lb iu">汇编器</strong>转换成机器语言。汇编器是继编译器和解释器之后的第三种翻译器，只为汇编语言工作。有趣的是，编译器如<strong class="lb iu"> GCC </strong>首先编译成汇编，然后再编译成机器码。</p><p id="3a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">汇编和机器码是迄今为止最快的语言，因为它们是计算机的语言。然而，由于计算机的配置不同，汇编和机器语言<strong class="lb iu">在计算机</strong>之间有所不同，因为它们<strong class="lb iu">绑定到特定的CPU </strong>。然而，像Python和C这样的语言是T42可移植的，可以在任何机器上运行，但结果是牺牲了速度。</p><h1 id="d5ab" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">x86指令集</h1><p id="0d14" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">众所周知，计算机以二进制工作，例如，这些0和1的特定组合告诉计算机进行加减运算。让计算机做事情的所有众多二进制组合的总集合被称为<strong class="lb iu">指令集</strong>。使用最广泛的指令集是<strong class="lb iu">英特尔的x86家族</strong>。这套系统源自于1978年的<strong class="lb iu">英特尔8086微处理器，然而经过几十年的发展，它已经<strong class="lb iu">扩展和发展</strong>以适应<strong class="lb iu">更高的位架构</strong>和<strong class="lb iu">更强大的微处理器</strong>。为了简单起见，英特尔没有对基于1978年的原始处理器的后续处理器进行重命名，而是将整个家族称为x86。</strong></p><p id="1e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相似指令集的使用使得<strong class="lb iu">更容易维护</strong>和<strong class="lb iu">随着计算机的进步和不同制造商之间的兼容性</strong>。比如我的2014款Macbook Air用的是<strong class="lb iu">x86–64</strong>指令集。如果您的设备是基于unix的，您可以通过在终端/shell中运行以下命令来检查计算机的指令集:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="2e46" class="ny md it nu b gy nz oa l ob oc">uname -m</span></pre><p id="4139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.statista.com/statistics/735904/worldwide-x86-intel-amd-market-share/" rel="noopener ugc nofollow" target="_blank">2021年最后一个季度，60.5%的x86计算机处理器来自英特尔处理器，39.3%来自AMD处理器。</a>因此，到目前为止，x86系列指令集架构是市场上最具优势的产品。</p><p id="20d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的一年里，苹果已经脱离了x86指令集，推出了新的<strong class="lb iu"> M1芯片。</strong>这会见证x86的衰落吗？我们会看到…</p><h1 id="8952" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">摘要</h1><p id="cbcb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我希望你喜欢这篇关于编译器、汇编和指令集的文章。作为数据科学家，我们可能永远不会那么频繁地用汇编或C之类的低级语言编码。然而，这里涵盖的概念可以提高您对计算和数据科学的总体理解。</p><h1 id="9ae5" class="mc md it bd me mf na mh mi mj nb ml mm jz nc ka mo kc nd kd mq kf ne kg ms mt bi translated">和我联系！</h1><ul class=""><li id="ca40" class="nf ng it lb b lc mu lf mv li od lm oe lq of lu nk nl nm nn bi translated">要在媒体上阅读无限的故事，请务必在这里注册！  <em class="mz"> </em>💜</li><li id="9786" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="/subscribe/@egorhowell" rel="noopener ugc nofollow" target="_blank">T31<em class="mz">T33】😀</em></a></li><li id="b8dc" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://www.linkedin.com/in/egor-howell-092a721b3/" rel="noopener ugc nofollow" target="_blank"><em class="mz">LinkedIn</em></a><em class="mz"/>👔</li><li id="a7a0" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://twitter.com/EgorHowell" rel="noopener ugc nofollow" target="_blank"> <em class="mz">推特</em> </a> <em class="mz"> </em> 🖊</li><li id="fb18" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://github.com/egorhowell" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> GitHub </em> </a> <em class="mz"> </em> 🖥</li><li id="87b0" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://www.kaggle.com/egorphysics" rel="noopener ugc nofollow" target="_blank"><em class="mz"/></a><em class="mz"/>🏅</li></ul><blockquote class="og oh oi"><p id="83b5" class="kz la mz lb b lc ld ju le lf lg jx lh oj lj lk ll ok ln lo lp ol lr ls lt lu im bi translated">(所有表情符号都是由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank"> OpenMoji </a>设计的——开源的表情符号和图标项目。许可证:<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 4.0 </a></p></blockquote></div></div>    
</body>
</html>