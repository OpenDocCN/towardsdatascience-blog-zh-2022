<html>
<head>
<title>What On Earth Are Closures?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">闭包到底是什么？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-on-earth-are-closures-a4f9c7c652d2#2022-01-25">https://towardsdatascience.com/what-on-earth-are-closures-a4f9c7c652d2#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="ef5d" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">闭包到底是什么？</h1></div><div class=""><h2 id="ca72" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">闭包函数及其使用方法概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a74b307f2fd6b4b9d8c7b7ba2e4e0985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1OfKVHYGCx8h76maniitsQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由Pixabay 上的<a class="ae ky" href="https://pixabay.com/images/id-428549/" rel="noopener ugc nofollow" target="_blank"> jarmoluk提供)</a></p></figure><h1 id="cc29" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="58df" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">如果有一样东西对每一种编程语言都很重要，不管那种语言的范例是什么，那就是函数。函数是从一种语言传到另一种语言的普遍概念，这很有意义。甚至当我们用汇编语言进行低级编程时，我们仍然在使用本质上的函数。虽然我不确定它们是否一定被称为函数，因为我一直认为它们是子例程(或者是例程，如果它是jmped并且没有被调用的话)。如果你不知道我刚才到底在说什么，不要担心…</p><blockquote class="mw"><p id="912f" class="mx my it bd mz na nb nc nd ne nf mm dk translated">这与闭包无关。</p></blockquote><p id="82b0" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">我的观点是:函数在编程中是通用的。无论何时你开始学习一门新的编程语言，你首先应该了解的事情之一就是如何用这门语言编写函数。在某些情况下，函数也可以非常灵活，当然这因语言而异。在某些情况下，某些语法是可能的，而在其他情况下则不可能。计算机编程中一个惊人强大的概念是闭包函数的概念。今天我想回顾一下闭包函数到底是什么，以及为什么我认为它们是非常有用的技术。正如长期读者所料，今天我将使用Julia，但是闭包函数在许多其他语言中也是完全可能的，包括(但不限于):</p><ul class=""><li id="905d" class="nl nm it lt b lu nn lx no ma np me nq mi nr mm ns nt nu nv bi translated">计算机编程语言</li><li id="d203" class="nl nm it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">C</li><li id="7ca2" class="nl nm it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">C++</li></ul><p id="1d96" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">哦，对了，还有SML，一种我只是模糊地熟悉的语言；不过，这种实现可能有点过火，因为到处都有函数定义。此外，如果您想看我努力安装这种语言，然后在编程时努力完成每一步，甚至到了我不知道如何将两个整数相除的地步，我实际上已经写了一篇关于尝试这种语言的文章，您可以在这里阅读:</p><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/getting-introduced-to-sml-a-weird-polymorphic-language-originated-in-1983-797ff9d6622e"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">SML入门:一种起源于1983年的怪异多态语言</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">尝试用SML语言编写和编译一些基本代码</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><blockquote class="ow ox oy"><p id="6ce6" class="lr ls oz lt b lu nn ju lw lx no jx lz pa ob mc md pb oc mg mh pc od mk ml mm im bi translated">请不要嘲笑我的绝望。</p></blockquote></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="dcb4" class="kz la it bd lb lc pk le lf lg pl li lj jz pm ka ll kc pn kd ln kf po kg lp lq bi translated">什么是闭包函数？</h1><p id="cbae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了开始理解为什么闭包函数如此重要——特别是对于数据科学，我们可能应该从定义一个闭包函数开始。如果你在谷歌上搜索这个词，你可能会得到类似于</p><blockquote class="mw"><p id="20e8" class="mx my it bd mz na nb nc nd ne nf mm dk translated">"闭包是与第一类函数绑定的词汇范围的名称."</p></blockquote><p id="8963" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">如果你不理解什么是词法范围，或者什么是一级函数，那么这种描述是没有用的。幸运的是，这些只是计算机编程中简单概念的大名字。好吧，也许这些概念在引擎盖下不那么容易理解，但是通过查看代码比通过描述更容易理解。词汇范围意味着函数能够访问传统上不可用的范围。考虑典型的功能范围，</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="d1ea" class="pu la it pq b gy pv pw l px py">function example_of_scope(x, y)<br/>    mu = mean([x, y])<br/>    x += 5</span><span id="5acb" class="pu la it pq b gy pz pw l px py">end</span></pre><p id="08f5" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">函数定义有一个<strong class="lt iu">私有</strong>范围。它可以访问它上面的作用域，在这个例子中是全局作用域，在Julia中是“Main”这是因为首先它是该作用域的子作用域，其次全局模块Main的作用域总是公共的。也就是说，如果我们移动到这个函数下面，并试图调用这个函数的值，我们会得到一个错误:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="3697" class="pu la it pq b gy pv pw l px py">function example_of_scope(x, y)<br/>    mu = mean([x, y])<br/>    x += 5</span><span id="e268" class="pu la it pq b gy pz pw l px py">end</span></pre><p id="7e84" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">范围从顶级范围(在本例中是主模块)一直限制到我们的函数，每个部分包含越来越多的定义。例如，假设我们在Main中有一个名为“Tacos”的模块来保存我们的函数，那么我们的作用域应该是这样的:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="1661" class="pu la it pq b gy pv pw l px py">module Main<br/># |Main scope<br/>  | module Tacos<br/>   # Tacos scope<br/>     |<br/>      function example_of_scope(x,y)...</span><span id="fa75" class="pu la it pq b gy pz pw l px py">end</span></pre><p id="7c3c" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">这是词法作用域，所以基本上——你可能用过的大多数语言都使用词法作用域，另一种方法是动态作用域，这通常意味着所有的名称绑定都是全局的。我们可以从example_of_scope访问Main和Tacos中定义的定义，但是不能从Tacos或Main访问example_of_scope(x，y)中定义的定义。请记住，这些术语通常特指函数，在大多数情况下，使用一种非词汇范围的语言可能会很烦人。</p><p id="d104" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">这是拼图的一部分，那么什么是一级函数呢？第一类函数只是一个可以被当作参数的函数。在Julia中，我们可以很容易地传递type::函数，并将函数作为参数。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="c1b0" class="pu la it pq b gy pv pw l px py">example(f::Function, x::Int64) = f(x)</span></pre><p id="fdc1" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">闭包函数是词法范围和更像常规类型对待函数的组合。在Julia中，这是非常流畅地完成的，并且使用了一些非常容易识别的语法，所以它实际上是一种很好的语言来演示这一点。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="4de8" class="pu la it pq b gy pv pw l px py">function example2(n)<br/>    h = function hello()<br/>        blahblahblah<br/>    end</span><span id="eec6" class="pu la it pq b gy pz pw l px py">end</span></pre><p id="b1e6" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">所以现在我们有了h的函数作用域，它是在example2的函数作用域内定义的。记住，闭包函数实际上被称为闭包函数的一个重要部分是，这个作用域需要是词法性的。这意味着hello可以访问example2的范围。来自所述范围的所有值都保存在函数的定义中。例如，我们可以从hello函数中访问n。</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="6c36" class="pu la it pq b gy pv pw l px py">function example2(n)<br/>    h = function hello()<br/>        println(n)<br/>    end</span><span id="64b5" class="pu la it pq b gy pz pw l px py">    h<br/>end</span><span id="31de" class="pu la it pq b gy pz pw l px py">ourfunc = example2(5)<br/>ourfunc()</span><span id="b2f2" class="pu la it pq b gy pz pw l px py">5</span></pre><p id="088c" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">闭包函数也是我的包OddFrames.jl中面向对象语法的主干，如果您想查看在该包中使用它们的上下文，可以在这里查看构造函数的源代码:</p><div class="oe of gp gr og oh"><a href="https://github.com/ChifiSource/OddFrames.jl/blob/last-0.0.7-patch/src/type/frame.jl" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">OddFrames.jl/frame.jl终于-0 . 0 . 7-补丁ChifiSource/OddFrames.jl</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="qa l os ot ou oq ov ks oh"/></div></div></a></div><h1 id="5d0d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">不同语言的实现</h1><p id="c705" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经了解了闭包函数的基本知识，以及它们的技术定义，让我们看一些用不同语言实现闭包函数的例子。我们列表中的第一个是Python，这有点奇怪。与Java类似，Python使用lambda语法来定义匿名函数，这非常方便。只要想想作为一名数据科学家，您在另一个函数中编写匿名函数的频率，就可以看出这些函数有多有用。另外，我将要展示的所有代码都可以在我的随机代码库中的文件中找到，这里有一个链接:</p><div class="oe of gp gr og oh"><a href="https://github.com/emmettgb/Random_Code/tree/main/closure_examples" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">主emmettgb/Random_Code上的Random_Code/closure_examples</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">只是一堆随机的斑点。在GitHub上创建一个帐户，为emmettgb/Random_Code开发做贡献。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="qb l os ot ou oq ov ks oh"/></div></div></a></div><p id="7c2e" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">无论如何，这是我们之前用Python复制的例子:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="ffec" class="pu la it pq b gy pv pw l px py">def example2(n):<br/>    h = lambda : print(n)</span><span id="f89d" class="pu la it pq b gy pz pw l px py">    return(h)</span><span id="313b" class="pu la it pq b gy pz pw l px py">ourfunc = example2(5)<br/>ourfunc()</span><span id="3178" class="pu la it pq b gy pz pw l px py">5</span></pre><p id="b10d" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">这个例子很容易理解。我们用lambda创建函数h，然后返回它。Python让这变得非常简单，只需理解lambda就能理解这种语法。顺便说一句，如果你对lambda没有很好的理解，我确实写了一整篇关于它的文章！这里有个链接！：</p><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/scientific-python-with-lambda-b207b1ddfcd1"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">带Lambda的科学Python</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">Python Lambda函数的正确用法:Python科学编程的最佳语法。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="qc l os ot ou oq ov ks oh"/></div></div></a></div><p id="12bf" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">基本上，lambda为Python做的就是允许语言创建匿名函数。朱莉娅也有这种能力，可能有更多的方法来创造它们，但这里有两个例子:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="d97b" class="pu la it pq b gy pv pw l px py">f = () -&gt; 5<br/>f()</span><span id="6bab" class="pu la it pq b gy pz pw l px py">5</span><span id="edd2" class="pu la it pq b gy pz pw l px py">begin<br/>     5</span><span id="e345" class="pu la it pq b gy pz pw l px py">end</span></pre><p id="e8da" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">begin块将把函数返回给放在它前面的任何东西，这是一件需要注意的重要事情。我有一整篇文章是关于匿名函数的概念的，如果你想详细说明这一点，当在另一个函数的上下文中使用时，匿名函数本身通常是闭包:</p><p id="ec96" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/what-on-earth-is-an-anonymous-function-f8043eb845f3">https://towards data science . com/what-on-earth-is-an-anonymous-function-f 8043 EB 845 f 3</a></p><p id="64f3" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">不幸的是，当谈到在C中做同样的事情时，我们会很快意识到，确定返回类型有些困难。然而，这可以通过使用<a class="ae ky" href="https://savannah.gnu.org/projects/libffcall/" rel="noopener ugc nofollow" target="_blank"> GNU FFCALL </a>变得简单一些。然而，有一种方法不需要FFCALL就可以实现，而且也很简单，最大的问题是获取返回类型。这是我们的函数，这次是用C语言复制的:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="6c86" class="pu la it pq b gy pv pw l px py">#include &lt;stdio.h&gt;<br/>typedef int (*fptr)();</span><span id="4215" class="pu la it pq b gy pz pw l px py">fptr example2 (int n)<br/>{<br/>  void h ()<br/>    { printf("%d", n); }<br/>    return h;<br/>}</span><span id="b7d7" class="pu la it pq b gy pz pw l px py">int main()<br/>{<br/>    fptr h = example2(5);<br/>    h();<br/>    return 0;<br/>}</span></pre><p id="09aa" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">请允许我在这里解释一下代码。我们首先创建一个函数指针，*fptr，然后我们使用它作为返回类型，所以我们返回一个指向函数h的指针。这样做很好，并且有效地在C中创建了一个闭包。有趣的是，很多人使用苹果的C编译器的“block”语法，并使用FFCALL甚至GCC扩展来实现这个指针定义可以实现的功能。我不确定是否有必要更进一步，因为其他语言中的许多例子都将与前两个非常相似，只是要么有更多的语法，要么有不同的调用结构(除了像SML这样的函数式语言，但是……<strong class="lt iu">没有</strong>)。)</p><h1 id="befa" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">真实世界的用例</h1><p id="3a15" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们已经不再将闭包视为一个概念，那么请允许我向您展示一个实例，我在Julia中使用闭包做了一些非常棒的事情。我将要展示的代码是我的Toolips.jl项目的一部分。这个项目现在还很早，因为我现在有太多事情要做，而且我在空闲时间还在做的其他开源包的数量<strong class="lt iu">多得令人应接不暇。</strong>该项目旨在成为一个模块化的网络开发框架，既作为后端工具又作为前端工具，但通过元编程功能JavaScript完成所有前端工作。无论如何，如果你有兴趣观看这个项目或者给它一颗星(我很感激！)下面是Github资源库的链接:</p><div class="oe of gp gr og oh"><a href="https://github.com/ChifiSource/Toolips.jl" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GitHub - ChifiSource/Toolips.jl:一个基于Julia的JavaScript兼容性Web开发框架</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">toolips.js构建在一个功能性编程的反应式可观察库之上，该库通过JavaScript表达式进行评估…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="qd l os ot ou oq ov ks oh"/></div></div></a></div><p id="49f6" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">无论如何，我想用这个包来描绘两个核心思想，我认为它们都是网络开发的好主意。</p><ul class=""><li id="6bfb" class="nl nm it lt b lu nn lx no ma np me nq mi nr mm ns nt nu nv bi translated">数据和回报应该功能化，</li><li id="da34" class="nl nm it lt b lu nw lx nx ma ny me nz mi oa mm ns nt nu nv bi translated">应该存储发电机类型，并为每个服务单独调用。</li></ul><p id="bdf9" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">根据我在这里提出的第一点，函数被大量用作数据应该是很明显的。这里有一个与我在OddFrames.jl中使用的技术类似的技术，这里使用了一些私有方法，这些方法也是闭包函数，这就是我展示它们的原因:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="454b" class="pu la it pq b gy pv pw l px py">mutable struct ToolipServer<br/>    ip::String<br/>    port::Integer<br/>    routes::AbstractVector<br/>    remove::Function<br/>    add::Function<br/>    start::Function<br/>    function ToolipServer(ip::String, port::Int64)<br/>        routes = []<br/>        <strong class="pq iu">add, remove, start = funcdefs(routes, ip, port)</strong><br/>        new(ip, port, routes, remove, add, start)<br/>    end</span><span id="271c" class="pu la it pq b gy pz pw l px py">function ToolipServer()<br/>        port = 8001<br/>        ip = "127.0.0.1"<br/>        ToolipServer(ip, port)<br/>    end<br/>end</span></pre><p id="4780" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">这里有很多要看的，但是重要的部分是我加粗的部分。该部分通过调用funcdefs()创建闭包函数，如下所示:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="04c9" class="pu la it pq b gy pv pw l px py">function funcdefs(routes::AbstractVector, ip::String, port::Integer)<br/>    add(r::Route) = push!(routes, r)<br/>    remove(i::Int64) = deleteat!(routes, i)<br/>    <strong class="pq iu">start() = _start(routes, ip, port)</strong><br/>    return(add, remove, start)<br/>end</span></pre><p id="2dcd" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">因为这些是闭包函数，在它们各自的定义中，我们能够使用调用它的原始函数中定义的所有值。这就是ip、端口和路由都作为参数提供的原因。代码中引用我们下一个函数的部分再次以粗体显示，下面是这个函数:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="3e79" class="pu la it pq b gy pv pw l px py">function _start(routes::AbstractVector, ip::String, port::Integer)<br/>    server = Sockets.listen(Sockets.InetAddr(parse(IPAddr, ip), port))<br/>    println("Starting server on port ", string(port))<br/>    <strong class="pq iu">routefunc = generate_router(routes, server)</strong><br/>    <a class="ae ky" href="http://twitter.com/async" rel="noopener ugc nofollow" target="_blank"><strong class="pq iu">@async</strong></a><strong class="pq iu"> HTTP.listen(routefunc, ip, port; server = server)</strong><br/>    println("Successfully started Toolips server on port ", port, "\n")<br/>    println("You may visit it now at http://" * string(ip) * ":" * string(port))<br/>    return(server)<br/>end</span></pre><p id="b51b" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">目前，这个服务器还很简单，但是你已经可以看到它的结构是如何发展的了。这里最重要的是generate_router()调用和HTTP.listen()调用。在HTTP.listen()中，我们提供routefunc作为参数，它是generate_router的返回。单单这个名字routefunc就可以帮助人们设想它实际上是做什么的。routefunc是函数的返回，而不是函数。这是因为函数不是静态的，它需要根据提供给它的数据而变化。下面是这种情况的具体表现:</p><pre class="kj kk kl km gt pp pq pr ps aw pt bi"><span id="bbf6" class="pu la it pq b gy pv pw l px py">function generate_router(routes::AbstractVector, server)<br/>    route_paths = Dict([route.path =&gt; route.page for route in routes])<br/> <strong class="pq iu">   routeserver = function serve(http)</strong><br/>     HTTP.setheader(http, "Content-Type" =&gt; "text/html")<br/>     full_path = split(http.message.target, '?')<br/>     args = ""<br/>     if length(full_path) &gt; 1<br/>         args = full_path[2]<br/>     end<br/>     if fullpath[1] ! in keys(route_paths)<br/>         write(http, generate(route_paths["404"]), args)<br/>     else<br/>         write(http, generate(route_paths[fullpath[1]]), args)<br/>     end<br/> end # serve()<br/> <strong class="pq iu">   return(routeserver)</strong><br/>end</span></pre><p id="bd7f" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">我将routeserver的返回和定义都用粗体显示，以便于查看。该函数在每次发出请求时运行，HTTP I/O流由HTTP作为该函数的参数提供。之后，这个函数所做的就是生成与某人请求的uri相对应的页面。从表面上看，它很简单，但从外表上看，它变得非常强大。我认为这是闭包函数的一个很好的用法，此外，我认为这是解决管理路线和事物问题的一个很酷的方法。我知道有些人可能会好奇为什么我决定使用这种技术，而不是使用HTTP。路由器，或者更进一步说，为什么我想首先开发一个网络服务器。</p><p id="df41" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">要回答第一个问题，用HTTP.Router处理许多独立的路由要困难得多。此外，流的处理不可能像在这个上下文中那样干净，在某些情况下，定制流甚至根本不可能。为了回答第二个问题，老实说，在Julia的web开发框架方面，我们真的很有限。对于Julia中的这个任务，我们可以选择Mux.jl和Genie.jl。以下是Mux的文档:</p><div class="oe of gp gr og oh"><a href="https://docs.juliahub.com/Mux/cs9xb/0.7.4/" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Mux.jl</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">Mux.jl为您的Julia web服务提供了一些闭包。Mux允许您根据高度模块化和…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">docs.juliahub.com</p></div></div></div></a></div><blockquote class="mw"><p id="2e9f" class="mx my it bd mz na qe qf qg qh qi mm dk translated">对，没错，就是这样。</p></blockquote><p id="5fd5" class="pw-post-body-paragraph lr ls it lt b lu ng ju lw lx nh jx lz ma ni mc md me nj mg mh mi nk mk ml mm im bi translated">有一段时间，Mux.jl也被弃用了，我想——或者可能是其他什么包。无论如何，当谈到web交互性时，虽然我们有一个很好的WebIO/Interact.jl连接，但是WebIO mimes评估起来有点慢，这完全可以理解——但是很烦人。他们也更倾向于科学互动，老实说，这是我认为Interact.jl的归属。Interact真的真的很擅长<strong class="lt iu">那个</strong>。这是软件包应用程序。虽然已经有一些网络应用程序，比如Pluto.jl，是建立在这个基础上的，但是我认为Interact的目标从来就不是成为一个全功能网络应用程序的后端(或者可能是，我不确定？)</p><p id="54a1" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">事实上，我是Genie.jl的早期用户。Genie可能是目前Julia网络开发的最佳选择，只是有些事情我希望它有所不同。其中最大的问题是，整个文件系统是一个很难做到轻量级的系统。这让我想起了Django与Flask的争论，说用Flask制作API比用Django要容易得多，但用Django制作web应用程序比用Flask容易得多。Mux.jl非常注重成为一个反应式前端工具，我认为它在那个应用程序中做得相当好。也就是说，我们没有任何真正微观的微观框架。也就是说，我试图创造这一点——以及一定程度的模块化，这将允许它建立在附加功能的基础上。</p></div><div class="ab cl pd pe hx pf" role="separator"><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi pj"/><span class="pg bw bk ph pi"/></div><div class="im in io ip iq"><h1 id="80a2" class="kz la it bd lb lc pk le lf lg pl li lj jz pm ka ll kc pn kd ln kf po kg lp lq bi translated">结论</h1><p id="04f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在讨论Toolips.jl时，我们可能有点跑题了，但重点仍然存在，闭包函数非常有用。我认为它们对我如此有用的部分原因是因为Julia有非常好的语法表达式和函数语法。这使得把这些定义拿出来并很好地使用它们变得容易多了。此外，你可以在任何地方使用函数作为参数，计算和表达式化字符串，Julia代码，等等，所有这些加起来就是一个非常健壮的接口来编写这种性质的函数。我也喜欢Python的实现，我确信作为数据科学家，我们以前都使用过lambda，它在处理数据时非常方便，如果你曾经在另一个函数中使用过它，那么你实际上是在编写一个闭包函数。</p><p id="9e62" class="pw-post-body-paragraph lr ls it lt b lu nn ju lw lx no jx lz ma ob mc md me oc mg mh mi od mk ml mm im bi translated">我希望这篇文章对阐述闭包函数这个主题有所帮助。它们真的很酷，在很多不同的情况下肯定会派上用场。它们对于函数式编程也非常有用，我想这是一个我在这里没有过多涉及的话题，但是我认为它的含义是非常清楚的。总的来说，这肯定是需要了解并加以利用的。因此，我很高兴我能与你详细地分享它！感谢您阅读本文，祝您在将所有代码转化为函数的过程中愉快！</p></div></div>    
</body>
</html>