<html>
<head>
<title>How to build a data lake from scratch — Part 2: Connecting the components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从零开始构建数据湖—第2部分:连接组件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-data-lake-from-scratch-part-2-connecting-the-components-1bc659cb3f4f#2022-01-23">https://towardsdatascience.com/how-to-build-a-data-lake-from-scratch-part-2-connecting-the-components-1bc659cb3f4f#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="7e34" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">如何从零开始构建数据湖—第2部分:连接组件</h1></div><div class=""><h2 id="9587" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何利用流行技术构建数据工程沙盒的完整教程</h2></div><p id="a97b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这一系列文章中，我将指导您建立自己的数据湖基础设施作为数据工程沙箱。在这一部分中，我将展示如何连接我们的数据湖基础设施的各种服务。在第一部分中，我已经展示了如何用docker托管必要的服务，并解释了各个配置选项。</p><p id="6bf7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦组件“相互对话”，您将能够实施自己的数据工作流，并将技术和大数据方法用于自我测试！您将能够利用该平台来了解设置、实施附带项目、概念验证、使用案例或使用这些技术来学习其他教程。大多数数据任务可以通过这种基础设施实现自动化。在“生产”环境中，服务也可以作为docker化的服务托管在AWS EC2实例上，但是对于我们的沙箱，使用docker在本地托管它们就足够了。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/d13eb4c493edbc3a1caf8eb81eb46a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WzjbwvkUO_TGyQZh"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图片由Unsplash.com的加勒特·西尔斯拍摄</p></figure><p id="9960" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用以下技术组合:</p><ul class=""><li id="7587" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">Apache NiFi来处理和分发数据。</li><li id="ee1c" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">Apache NiFi Registry用于存储、管理和版本控制NiFi资源。</li><li id="c078" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">Apache Airflow以编程方式创作、安排和监控工作流。</li><li id="0e21" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">Postgres作为一个对象关系数据库。</li><li id="b289" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">pgAdmin作为postgres数据库的管理和开发平台。</li><li id="96e7" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">MinIO作为本地托管的、S3兼容的对象存储。</li><li id="908b" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">码头工人来主持我们的服务。</li></ul><p id="069c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">著名的<code class="fe mg mh mi mj b">Hello world!</code>最早是在Brian Kernigsham的《语言B入门教程》一书中提到的，后来因《C编程语言》一书而出名(<a class="ae lb" href="https://www.thesoftwareguild.com/blog/the-history-of-hello-world/" rel="noopener ugc nofollow" target="_blank">来源</a>)。如今，许多教程仍然使用将<code class="fe mg mh mi mj b">Hello world!</code>写入终端的任务来检查用户是否已经完成了设置阶段，并准备好投入编码挑战。</p><p id="294d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将实现服务间通信的<code class="fe mg mh mi mj b">Hello world!</code>:通过设置服务交互的超级简单的例子。我将指导您为每一对需要相互通信的服务建立连接。之后，您将能够继续自己的工作，充分利用数据湖基础设施的全部功能。</p><p id="2129" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您还没有设置docker容器，也还没有运行您的组件，那么请继续阅读本系列的<a class="ae lb" rel="noopener" target="_blank" href="/how-to-build-a-data-lake-from-scratch-part-1-the-setup-34ea1665a06e">第1部分。我们将从停止的地方继续:我们将</a><a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件从这里</a>复制到我们的本地计算机，并使用<code class="fe mg mh mi mj b">docker-compose up</code>启动服务。</p><p id="ca41" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们的服务仍未连接，但是我们的目标基础设施将如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/d55ddda66c567ffdd169851e5d98f021.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*jNNaCW8L5L9epoNC.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">数据湖组件—由作者创建的图像。维基百科的图标。</p></figure><p id="e51e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在以下章节中，我们将连接:</p><ol class=""><li id="7c20" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">postgres数据库的pgAdmin</li><li id="e170" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">Apache NiFi到NiFi注册表(反之亦然)</li><li id="a600" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">Apache NiFi到postgres数据库</li><li id="5c56" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">阿帕奇NiFi到MinIO</li><li id="cce7" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">到postgres数据库的Apache气流</li><li id="c494" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">阿帕奇气流到阿帕奇尼菲</li><li id="b076" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">阿帕奇气流到MinIO</li></ol><p id="eeca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们直接进入pgAdmin的设置吧！</p><h1 id="da41" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">pgAdmin</h1><p id="8b24" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">服务运行后，您可以在浏览器中访问pg admin:<a class="ae lb" href="http://localhost:5050/" rel="noopener ugc nofollow" target="_blank">http://localhost:5050/</a></p><p id="9c86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在启动docker容器后第一次访问该服务，它会要求您设置一个主密码。选择一个你能记住的密码。</p><p id="d35d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想通过连接到postgres数据库并对该数据库运行一个简单的查询来从pgAdmin对其说<code class="fe mg mh mi mj b">Hello world!</code>。</p><h1 id="7d1b" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">pgAdmin:你好，postgres数据库</h1><p id="0565" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">单击页面中间“快速链接”下的“添加新服务器”，或者右键单击左上角的“服务器”，然后选择“创建”-&gt;“服务器…”。</p><p id="21f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要配置连接细节以添加新的数据库服务器:</p><ol class=""><li id="7402" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">在<strong class="kh ir">常规选项卡</strong>中:为您的数据库服务器选择一个名称，例如<code class="fe mg mh mi mj b">postgres_db</code></li><li id="ed2a" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">在<strong class="kh ir">连接选项卡</strong>中:“主机名/地址”是<strong class="kh ir">而不是</strong>“本地主机”,而是<em class="nj">postgres容器</em>的IP地址——因为容器需要通过docker网络相互通信。因为我们在一个用户定义的网络(<code class="fe mg mh mi mj b">dataworld</code>)上，我们可以只使用主机名<code class="fe mg mh mi mj b">mypostgres</code>而不是固定的IP地址，让docker在后台处理DNS解析。</li><li id="6b74" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">在<strong class="kh ir">连接页签</strong>中:端口是postgres数据库的标准应用端口— <code class="fe mg mh mi mj b">5432</code>。</li><li id="a7d6" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">在<strong class="kh ir">连接选项卡</strong>中:用户名和密码在<code class="fe mg mh mi mj b">docker-compose.yml</code>中被指定为postgres服务的环境变量(如果还没有更改的话，则为<code class="fe mg mh mi mj b">postgres</code>和<code class="fe mg mh mi mj b">postgres</code>)。</li></ol><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2289746ceb211fb6d41f196bb1bd5fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/0*-aNWxNuery3Fog5P.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">连接设置—由作者创建的图像。</p></figure><p id="56b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了使用主机名，我们还可以通过获取postgres容器的ID并检查它以检索其IP地址来标识我们的数据库:</p><p id="77a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取容器ID:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d0b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查容器，将返回的行过滤为IP地址为:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c580" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是相当麻烦的，特别是因为每当我们重启我们的容器时，我们将不得不重新开始，因为docker网络中容器的IP地址可能会改变。使用主机名并让Docker在我们在<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a>中定义的用户定义的网络中解析它要容易得多。</p><p id="4981" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接到数据库后，我们现在可以运行查询了。右击数据库，选择<strong class="kh ir">查询工具</strong>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/cee1b80e4ec2c512d4bc3c3b0dd29301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*a39w48RaE-D2xEgc.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">pgAdmin中的查询工具—由作者创建的图像。</p></figure><p id="6135" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了测试一切是否正常，让我们运行下面的查询来检查连接——我们自己的小版本<strong class="kh ir">“hello world！”。sql </strong>:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6ba7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！PgAdmin现在连接到postgres数据库了！</p><h1 id="6a61" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">阿帕奇尼菲</h1><p id="5c0d" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">如果您的docker服务正在运行，您将能够通过<a class="ae lb" href="http://localhost:8091/nifi/" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/NiFi/</a>联系到NiFi。注意:您可能会看到消息<code class="fe mg mh mi mj b">The Flow Controller is initializing the Data Flow</code>。NiFi将需要一分钟(在您启动服务之后)才能到达应用程序，因为领导者选举周期需要首先完成。</p><p id="14c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望连接到:</p><ul class=""><li id="120c" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">NiFi注册表</li><li id="218d" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">postgres数据库</li><li id="56be" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">米尼奥</li></ul><h1 id="003c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">你好，NiFi注册中心</h1><p id="43ef" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为了将NiFi连接到registry，我们首先需要在registry中创建一个“bucket”来存储和组织我们的数据流。继续操作并打开位于<a class="ae lb" href="http://localhost:18080/nifi-registry/" rel="noopener ugc nofollow" target="_blank">http://localhost:18080/nifi-registry/</a>的注册表。</p><ol class=""><li id="f93e" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">单击窗口右上角的扳手符号。</li><li id="dfb3" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">点击右侧的“新桶”。</li><li id="7a83" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">为您的存储桶输入一个名称，例如<code class="fe mg mh mi mj b">myfirstbucket</code>。</li></ol><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi no"><img src="../Images/fd987d16f5e1c7468caccaffecbbfaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kJTbIPgDQalfsuye.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi注册表—创建新的存储桶—图片由作者创建。</p></figure><p id="5d3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以将NiFi的流程组和流程存储在新创建的bucket中。</p><p id="2486" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，默认情况下没有配置任何权限。在这个实例中，有权访问注册表的每个人都可以查看、创建和修改存储桶。有关保护系统的信息，请参见<a class="ae lb" href="https://nifi.apache.org/docs/nifi-registry-docs/html/administration-guide.html" rel="noopener ugc nofollow" target="_blank">系统管理员指南</a>。</p><p id="c352" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前往<a class="ae lb" href="http://localhost:8091/nifi/" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/nifi/</a>，点击右上角的<code class="fe mg mh mi mj b">three bars</code>进入<code class="fe mg mh mi mj b">controller setting</code>。然后点击选项卡<code class="fe mg mh mi mj b">registry client</code>和右侧的<code class="fe mg mh mi mj b">plus-symbol</code>。</p><p id="357b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择任何你喜欢的名字，并添加以下网址:<code class="fe mg mh mi mj b">http://myregistry:18080</code>。Docker将再次在docker网络上将主机名解析为容器的IP地址。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2d9479f3cd2ae1827419ebff7e868c83.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/0*rW1N4OrfunEedZU_.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">Nifi —添加注册中心客户端—由作者创建的图像。</p></figure><p id="759d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们已经向NiFi添加了注册客户机，那么让我们测试它的功能:创建一个新的进程组，其中包含一个或两个虚拟处理器。</p><p id="54d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">右键点击流程组，选择<code class="fe mg mh mi mj b">Version</code>-&gt;-<code class="fe mg mh mi mj b">Start version control</code>:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nq"><img src="../Images/3e29990bc820d70ddd87d6f9137210fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aSdOKTn_puL_wPxi.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">Nifi —启动过程组的版本控制—由作者创建的图像。</p></figure><p id="e908" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们能够选择我们想要使用哪个注册中心和存储桶来进行版本控制(如果我们已经配置/创建了多个的话),以及在注册中心中应该以哪个名称对流程组进行版本控制。输入名称，还可以选择输入描述和版本注释。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nr"><img src="../Images/0658254dc00d2682c75e61e8fc44495a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YEfSb9fGIuNVI5_f.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —将流文件版本保存到由作者创建的注册表图像中。</p></figure><p id="4958" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单击“保存”后，您会注意到流程组的左上角有一个绿色复选标记。这意味着组的当前状态被保存到桶中！如果我们更改了内部的某些内容，例如将处理器移动到另一个位置、更改某些配置或添加/删除处理器，复选标记将会被一个灰色的星号取代。这个星号象征着对底层流程的一些未提交的更改。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9476b55b2021e57b97b3282233faabe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/0*b3X7DZ4V25FPQtTY.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —过程组版本控制状态的变化—由作者创建的图像。</p></figure><p id="4a4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在注册表的桶中存储最新的更改，右键单击处理器组，然后单击<code class="fe mg mh mi mj b">Version</code> - &gt; <code class="fe mg mh mi mj b">Commit local changes</code>。绿色复选标记将再次出现。如果我们想要放弃更改，我们可以选择<code class="fe mg mh mi mj b">Revert local changes</code>，过程组将被重置为保存到注册表的最新版本。Local(在注册表的上下文中)是指Nifi实例，而不是您的本地计算机。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/9def730ba6ba6b8ad2a24f998cdfb78f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/0*mjMtzN6Ylv_DedKE.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —提交本地更改—图片由作者创建。</p></figure><p id="f849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经有了Apache NiFi数据流和ETL管道的完整版本控制系统！我们可以检查本地更改，将它们提交到注册表中，或者从注册表中取出最新版本的进程组。对我们的工作进行版本控制，并且能够跟踪变更，这极大地改善了我们的开发工作！</p><p id="3607" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建一个新的进程组时，我们甚至可以从注册表中导入一个存储的进程组的特定版本(作为一个模板):</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nu"><img src="../Images/162716d8cd9de9149404921c92a79d66.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/0*CeceQO_kUtFkWd1A.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —从注册表导入模板—由作者创建的图像。</p></figure><p id="ef7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的几章中，当我们连接到其他服务时，请随意使用这个特性！</p><h1 id="d312" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">Apache NiFi:你好postgres数据库</h1><p id="9b66" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为了能够查询postgres数据库，我们需要配置:</p><ul class=""><li id="1cb3" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">一个<code class="fe mg mh mi mj b">DBCPConnectionPool</code>，它包含数据库的连接细节</li><li id="90c4" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">微型工作流程:</li></ul><ol class=""><li id="e00b" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">第一个处理器创建一个空的流文件来触发后续的处理器</li><li id="122c" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">第二处理器执行对数据库的查询</li><li id="3c8d" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">第三个处理器用于在查询执行后查看队列中的数据。</li></ol><h2 id="dfdb" class="nv mn iq bd mo nw nx dn ms ny nz dp mw ko oa ob my ks oc od na kw oe of nc og bi translated">JDBC控制器postgres</h2><p id="8c86" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">当创建控制器服务时，总是在需要它们的最顶层进程组中创建它们——甚至可能是根进程组。控制器服务只能在创建它们的组以及所有后续子组中访问。</p><p id="5262" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了能够设置连接到postgres数据库的控制器服务，我们需要下载postgres的当前JDBC驱动程序，例如从<a class="ae lb" href="https://jdbc.postgresql.org/download.html" rel="noopener ugc nofollow" target="_blank">这里</a>。下载完成后，将<code class="fe mg mh mi mj b">postgresql-42.3.1.jar</code>文件(或您使用的任何版本)复制到docker挂载的目录<code class="fe mg mh mi mj b">/nifi/jdbc/</code>。这个过程对于任何其他数据库都是一样的，我们总是需要将NiFi指向jdbc-driver jar-file。</p><p id="1003" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过左侧当前过程组的<code class="fe mg mh mi mj b">gear-symbol</code>按钮进入NiFi中的控制器配置。在<code class="fe mg mh mi mj b">Controller services</code>选项卡中，点击右侧的<code class="fe mg mh mi mj b">plus-symbol</code>添加一个新控制器。从可用控制器的长列表中选择<code class="fe mg mh mi mj b">DBCPConnectionPool</code>并点击<code class="fe mg mh mi mj b">Add</code>。</p><p id="58a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编辑新创建的控制器的属性，如下所示:</p><ul class=""><li id="a1d5" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">数据库连接URL: <code class="fe mg mh mi mj b">jdbc:postgresql://mypostgres:5432/postgres</code></li><li id="815f" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">数据库驱动类名:<code class="fe mg mh mi mj b">org.postgresql.Driver</code></li><li id="d117" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">数据库驱动位置:<code class="fe mg mh mi mj b">/opt/nifi/nifi-current/jdbc/postgresql-42.3.1.jar</code>(注意，我们配置的是docker容器内部的路径，而不是本地机器上的路径！)</li><li id="0c68" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">数据库用户:<code class="fe mg mh mi mj b">postgres</code>(或您在设置过程中更改的任何名称)</li><li id="53c6" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">密码:<code class="fe mg mh mi mj b">postgres</code>(或您在设置过程中更改的任何密码)</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oh"><img src="../Images/d67b02a71db2dc02ecd533774fac0ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vklQYdxS1Pd5lTcr.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi—JDBC控制器的属性—微型工作流程:</p></figure><p id="a177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<code class="fe mg mh mi mj b">Apply</code>并通过选择描述新创建的控制器的线的<code class="fe mg mh mi mj b">lightning-symbol</code>并在打开的窗口中选择<code class="fe mg mh mi mj b">Enable</code>来启用服务。</p><h2 id="e4a5" class="nv mn iq bd mo nw nx dn ms ny nz dp mw ko oa ob my ks oc od na kw oe of nc og bi translated">处理器</h2><p id="fd7d" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为此版本的<code class="fe mg mh mi mj b">Hello world!</code>创建三个处理器:</p><ol class=""><li id="d53f" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">处理器:GenerateFlowFile——作为我们数据流的起点。</li><li id="e430" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">处理器:ExecuteSQL —在postgres数据库上执行查询。</li><li id="dd7a" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">Processor: RouteOnAttribute —作为一个虚拟处理器，这样我们可以查看队列中的流文件。</li></ol><p id="f2b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe mg mh mi mj b">success</code>流程按顺序连接处理器。</p><h2 id="28ba" class="nv mn iq bd mo nw nx dn ms ny nz dp mw ko oa ob my ks oc od na kw oe of nc og bi translated">生成流文件</h2><p id="6825" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在<code class="fe mg mh mi mj b">GenerateFlowFile</code>处理器中，将调度选项<code class="fe mg mh mi mj b">Run Schedule</code>更改为<code class="fe mg mh mi mj b">60 sec</code>，并将调度选项<code class="fe mg mh mi mj b">Execution</code>更改为<code class="fe mg mh mi mj b">Primary node</code>。这样，我们可以确保无论何时启动处理器<strong class="kh ir">时，主节点都会创建一个流文件，从而触发我们的ETL管道。每隔60秒就会创建另一个流文件——除非我们事先停止了处理器。这是一个简单的技巧，可以精确地触发我们的流水线一次:在调度时间再次完成之前启动然后停止<code class="fe mg mh mi mj b">GenerateFlowFile</code>处理器。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/44ea02f1a351b2a72abd2e55fcf69f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/0*W-4hrDR4t7KtV9GC.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —调度处理器—图片由作者创建。</p></figure><h2 id="c4c9" class="nv mn iq bd mo nw nx dn ms ny nz dp mw ko oa ob my ks oc od na kw oe of nc og bi translated">执行SQL</h2><p id="9b43" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在<code class="fe mg mh mi mj b">ExecuteSQL</code>处理器中，选中主配置中<code class="fe mg mh mi mj b">failure</code>旁边的复选框，以便在查询失败时自动终止进程。在<code class="fe mg mh mi mj b">properties</code>选项卡中，将<code class="fe mg mh mi mj b">Database Connection Pooling Service</code>属性更改为新创建的<code class="fe mg mh mi mj b">postgresql_connectionpool</code>，并将字段<code class="fe mg mh mi mj b">SQL select query</code>编辑为数据库连接的测试查询。一个例子可能是:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1499" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的DBCPConnectionPool没有出现在可用的控制器服务列表中，请确保您已经在同一个处理器组或其上的任何处理器组中创建了DBCPConnectionPool。不能选择当前组之外或之下的流程组的控制器服务！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oj"><img src="../Images/25ed2979d10b1ae0788aad2f0fa4624c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6qx076spjFfmigZr.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —配置executeSQL处理器—图片由作者创建。</p></figure><p id="7d5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要配置最后一个处理器，因为我们只是将它作为一个替身来使用，以便能够检查通向它的队列中创建的流文件。您的处理器流程应该如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/5b78c762323ec906d92eeab0e7c64190.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*Vo4vRQhVIjVqyWXH.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —处理器流程—图片由作者创建。</p></figure><p id="c255" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦启动了前两个处理器，就会创建一个流文件，并触发ExecuteSQL处理器。ExecuteSQL处理器之后的流文件现在将包含我们从数据库中查询的数据。您可以通过右击队列并选择<code class="fe mg mh mi mj b">List queue</code>来检查数据。您可以下载队列中的每个项目，或者通过单击右侧的符号在浏览器中查看其内容。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/c30bf788c18a834ed2aeb7ff59dc44ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/0*jmx6tqVWQhQxBg4C.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —检查队列的流文件—作者创建的图像。</p></figure><p id="8958" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浏览器检查(格式化视图)中的流文件内容如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cd07c009f59251f18d6fb5f7b8355bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/0*nmECVIs-xQ7wuXmN.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —队列中的文件内容—作者创建的图像。</p></figure><p id="1910" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们已经成功地从NiFi查询了数据库！我们离全功能数据湖架构又近了一步！</p><h1 id="9032" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">阿帕奇·尼菲:你好，米尼奥</h1><p id="0b14" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在我们连接NiFi之前，我们必须配置MinIO。您可以在浏览器中的<a class="ae lb" href="http://localhost:9001/dashboard" rel="noopener ugc nofollow" target="_blank">http://localhost:9001/dashboard</a>下访问该服务。用户名和密码通过环境参数<code class="fe mg mh mi mj b">MINIO_ACCESS_KEY</code>和<code class="fe mg mh mi mj b">MINIO_SECRET_KEY</code>在<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件</a>中配置。除非您在创建容器之前更改了它们，否则它们是<code class="fe mg mh mi mj b">minio_admin</code>和<code class="fe mg mh mi mj b">minio_password</code>。</p><h2 id="e139" class="nv mn iq bd mo nw nx dn ms ny nz dp mw ko oa ob my ks oc od na kw oe of nc og bi translated">配置MinIO</h2><p id="c00d" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">点击左侧导航栏中的<code class="fe mg mh mi mj b">Buckets</code>，点击右上角的<code class="fe mg mh mi mj b">Create Bucket</code>。为您的存储桶选择一个名称，例如<code class="fe mg mh mi mj b">miniobucket</code>，保留默认配置并点击<code class="fe mg mh mi mj b">Save</code>。请注意如何命名您的存储桶，名称必须在3到63个字符之间，并且只能由小写字母、数字、点和连字符组成！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi on"><img src="../Images/a8011940a8e55ff9a2b0719769609c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/0*5iQ4viblwHTlghOw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">MinIO bucket —作者创建的图像。</p></figure><p id="5c70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建bucket后，在本地创建一个名为<code class="fe mg mh mi mj b">minio_testfile.txt</code>的新文件，内容为<code class="fe mg mh mi mj b">This is the content of a testfile from MinIO.</code>。</p><p id="98df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择您的桶并点击<code class="fe mg mh mi mj b">Browse</code>。创建一个名为<code class="fe mg mh mi mj b">test</code>的新目录，并在其中点击<code class="fe mg mh mi mj b">Upload file</code>符号上传<code class="fe mg mh mi mj b">minio_testfile.txt</code>。在下一步中，我们将配置NiFi从MinIO中检索这个文件！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a1cb2bc2b33e60435f09015d3c9cedce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*4O4GYuBbREzxmpaR.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">MinIO桶内容—由作者创建的图像。</p></figure><h1 id="4d5c" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">配置NiFi</h1><p id="f393" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为了能够在NiFi中创建从MinIO检索文件的管道，我们还需要配置NiFi。在本地绑定挂载的目录<code class="fe mg mh mi mj b">/nifi/credentials/</code>中创建一个名为<code class="fe mg mh mi mj b">credentials.properties</code>的文件。</p><p id="2ce5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该文件的内容是MinIO的环境变量的值——如果您没有在您的<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件</a>中更改它们，<code class="fe mg mh mi mj b">credentials.properties</code>文件的内容将是:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="009d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如有必要，更改键值。</p><p id="954a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转到<a class="ae lb" href="http://localhost:8091/nifi/" rel="noopener ugc nofollow" target="_blank">http://localhost:8091/nifi/</a>并创建一个新的进程组。在组内，为<code class="fe mg mh mi mj b">GenerateFlowFile</code>、<code class="fe mg mh mi mj b">FetchS3Object</code>和<code class="fe mg mh mi mj b">RouteOnAttribute</code>类型各创建一个处理器。用<code class="fe mg mh mi mj b">success</code>关系连接处理器。由于MinIO与S3兼容，我们可以将NiFi的所有S3处理器与MinIO端点一起使用！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi op"><img src="../Images/5a0c18c2a7b8ebc4428adff5e940fd1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/0*oTAdJUtRosQ-D-XR.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —处理器流程—图片由作者创建。</p></figure><p id="4b9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次更改<code class="fe mg mh mi mj b">GenerateFlowFile</code>处理器的调度选项<code class="fe mg mh mi mj b">Run Schedule</code>到<code class="fe mg mh mi mj b">60 sec</code>以及调度选项<code class="fe mg mh mi mj b">Execution</code>到<code class="fe mg mh mi mj b">Primary node</code>。这样，我们可以确保无论何时启动处理器，都会创建一个流文件，触发我们的ETL管道。</p><p id="5bf0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mg mh mi mj b">FetchS3Object</code>处理器中，勾选复选框以自动终止<code class="fe mg mh mi mj b">failure</code>上的关系，并配置以下属性:</p><ul class=""><li id="d6a4" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">桶:<code class="fe mg mh mi mj b">miniobucket</code></li><li id="8829" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">对象键:<code class="fe mg mh mi mj b">test/testfile.txt</code>(我们需要配置桶内的完整路径，包括目录)</li><li id="9eec" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">端点覆盖URL: <code class="fe mg mh mi mj b">http://myminio:9000</code>(用我们的私有MinIO实例之一覆盖AWS S3的端点)</li><li id="4498" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">凭证文件:<code class="fe mg mh mi mj b">/opt/nifi/nifi-current/credentials/credentials.properties</code>(容器内指定的路径)</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/0c8c838724d74b29e9aedc26253f42ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/0*NgZYkDLCHsDMYqRp.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi—fetchs 3对象处理器配置—图片由作者创建。</p></figure><p id="ff1d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想为NiFi创建一个单独的技术MinIO用户，您只需更新本地目录中的<code class="fe mg mh mi mj b">credentials.properties</code>文件。</p><p id="0172" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行您的管道——您可以通过启动和停止<code class="fe mg mh mi mj b">GenerateFlowFile</code>处理器或右键单击它并选择“恰好运行一次”选项来完成此操作。通过右键单击通向<code class="fe mg mh mi mj b">RouteOnAttribute</code>处理器的队列，我们可以检查流文件。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi or"><img src="../Images/6e2646e893d440e54b31970d0a144313.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/0*wK4huS-yyItAoABy.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —检查队列的流文件—作者创建的图像。</p></figure><p id="109d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以验证我们的文件确实被NiFi检索和加载了:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi os"><img src="../Images/80d65a1f74063c37a17285d25c057841.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/0*26BslOtjJnjsg8Nx.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi —流文件内容—由作者创建的图像。</p></figure><p id="8408" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜，我们又连接了两个服务！我们现在可以从MinIO和postgres数据库中检索和写入数据。如果我们以后从MinIO切换到实际的S3存储，我们只需删除被覆盖的端点URL并更新我们的凭证文件。</p><h1 id="efd7" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">气流</h1><p id="e5e3" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为了让Airflow能够连接到MinIO(以及S3或其他S3兼容的存储设备),我们需要在Airflow服务上安装一个python包。我们可以通过挂载一个<code class="fe mg mh mi mj b">requirements.txt</code>文件来做到这一点。在本地挂载的目录(<code class="fe mg mh mi mj b">./airflow/requirements/requirements.txt</code>)中创建以下文件，内容如下:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="aa82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建文件后，我们需要重启docker服务。启动时，Airflow会自动安装文件中提到的所有软件包。当docker检查必要的包时，这可能会使启动延迟几秒钟，但不会太长。</p><p id="e571" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你完成了这个准备步骤，让我们到达气流中的<code class="fe mg mh mi mj b">Hello world!</code>。</p><h1 id="c456" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">阿帕奇气流:你好postgres数据库</h1><p id="6dd9" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在我们创建任何代码之前，我们需要在Airflow中配置连接细节。在<a class="ae lb" href="http://localhost:8085/admin/" rel="noopener ugc nofollow" target="_blank">http://localhost:8085/admin/</a>的浏览器中打开服务，点击顶栏中的<code class="fe mg mh mi mj b">Admin</code> - &gt; <code class="fe mg mh mi mj b">Connections</code>。默认情况下，Airflow附带了许多连接，但是让我们为我们的目的创建一个新的连接。</p><p id="6775" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<code class="fe mg mh mi mj b">Create</code>，填写必要的详细信息:</p><ul class=""><li id="3486" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Conn Id</code> : <code class="fe mg mh mi mj b">mypostgres_connection</code> -稍后我们可以用它来检索连接细节的ID。</li><li id="559b" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Conn Type</code> : <code class="fe mg mh mi mj b">Postgres</code> -从下拉菜单中选择。</li><li id="3b24" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Host</code> : <code class="fe mg mh mi mj b">mypostgres</code> - Docker将解析主机名。</li><li id="6f99" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Schema</code> : <code class="fe mg mh mi mj b">postgres</code> -数据库名称(该标签具有误导性)</li><li id="b724" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Login</code> : <code class="fe mg mh mi mj b">postgres</code> -或者您在<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件</a>中设置的用户名。</li><li id="30b6" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Password</code> : <code class="fe mg mh mi mj b">postgres</code> -或者您在<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件</a>中设置的任何密码。</li><li id="d16d" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Port</code>:<code class="fe mg mh mi mj b">5432</code>-docker网络中数据库的标准端口。</li></ul><p id="11fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击保存:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/985ae769fb771e75505ec9f3a888348b.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*t3voTBrZiRlkorv9.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">气流连接-由autor创建的图像。</p></figure><p id="56b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以开始写DAG了。DAG(有向无环图)是气流的核心概念，它定义了任务、它们的依赖关系和时间表(<a class="ae lb" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/dags.html" rel="noopener ugc nofollow" target="_blank">在这里阅读更多内容</a>)。</p><p id="b954" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DAG指定任务，更重要的是，指定任务应该执行的顺序。我们甚至可以将任务配置为仅在一个(或多个)先前任务失败时执行。Airflow附带了许多所谓的任务“操作符”——这意味着我们可以用Python、Bash、Druid、Hive、MSSQL甚至PostgreSQL等等编写任务！所有Dag都是Python文件，但是操作符中的代码取决于操作符的类型。</p><p id="153e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用<a class="ae lb" href="https://airflow.apache.org/docs/apache-airflow-providers-postgres/stable/_api/airflow/providers/postgres/operators/postgres/index.html#module-airflow.providers.postgres.operators.postgres" rel="noopener ugc nofollow" target="_blank"> postgres操作符</a>来执行postgres数据库中的SQL代码。或者，我们可以使用<a class="ae lb" href="https://airflow.apache.org/docs/apache-airflow/stable/_api/airflow/operators/python/index.html" rel="noopener ugc nofollow" target="_blank"> python操作符</a>编写一个小的python程序，该程序反过来在数据库上执行查询。我们选择哪种方案取决于我们的用例。为了这个<code class="fe mg mh mi mj b">Hello postgres database!</code>，让我们创建一个简单的postgres操作符，它将在我们的数据库中创建一个空表。</p><p id="7c23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:根据您的Airflow版本，您需要不同的导入路径。本文的<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件</a>中使用的docker映像使用了旧版本<code class="fe mg mh mi mj b">1.10.9</code>。我在代码摘录中包含了新的Airflow版本的导入路径。</p><p id="c226" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本地挂载的目录下创建一个文件:<code class="fe mg mh mi mj b">airflow/dags/hello_postgres.py</code>，内容如下:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b737" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了能够多次执行DAG，我们在DAG中有两个任务:第一个任务删除已经存在的表，第二个任务创建表。如果我们不包括第一个任务，DAG将在第二次和任何后续执行中失败，因为它无法成功执行创建查询。通过参数<code class="fe mg mh mi mj b">postgres_conn_id</code>传递连接细节，我们不必担心代码中的主机名、用户名或密码。</p><p id="330d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保存文件，等待它出现在你的网页浏览器的<code class="fe mg mh mi mj b">DAGS</code>视图中。根据您的DAG，这可能需要一些时间。一旦它被列出，在左边激活它，并点击“触发DAG”在右手边。</p><p id="4dbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以在pgadmin的界面中验证创建的表:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d8e7ef8e0f19aec106be0ee12a2afc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/0*968mheKwoNFIIhcO.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">pgAdmin —表格的验证—由作者创建的图像。</p></figure><p id="ccd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！我们现在能够从Airflow调度任务来执行数据库上的代码！</p><h1 id="3071" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">阿帕奇气流:你好阿帕奇尼菲</h1><p id="f924" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">从Airflow DAG连接到NiFi使我们能够更新处理器属性、更改处理器的内容(如sql语句)、启动或停止处理器、列出/更改/启动控制器等等。Apache NiFi为多种配置目的提供了一个深入的REST-API。我们可以检索和配置对象，如控制器、流、处理器、处理器组、端口、标签、漏斗、策略，甚至将事务提交到特定的输入端口。对于我们的<code class="fe mg mh mi mj b">Hello world!</code>目的，我们将创建一个简单的GET请求。您是使用API的包装库，如<a class="ae lb" href="https://pypi.org/project/nipyapi/" rel="noopener ugc nofollow" target="_blank"> nipyapi </a>还是使用<a class="ae lb" href="https://nifi.apache.org/docs/nifi-docs/rest-api/index.html" rel="noopener ugc nofollow" target="_blank">官方REST-API </a>编写自己的逻辑和请求，取决于您的用例。我个人喜欢直接使用REST API，因为它的文档非常详细。</p><p id="5fc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们为NiFi服务创建一个气流连接，如下所示:</p><ul class=""><li id="f53d" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Conn ID</code> : <code class="fe mg mh mi mj b">mynifi_connection</code></li><li id="2302" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Conn Type</code> : <code class="fe mg mh mi mj b">Postgres</code>由于没有<code class="fe mg mh mi mj b">NiFi</code>连接类型，因此我们使用postgres作为替身。</li><li id="bedc" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Host</code> : <code class="fe mg mh mi mj b">http://mynifi</code></li><li id="88b6" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Port</code> : <code class="fe mg mh mi mj b">8080</code>这是网络内部的<em class="nj">端口，不是我们对外映射的那个！</em></li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/561b023e1d0fcbe4ce1dbf05554e84fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*2QxpWAcpZlQ9pZsn.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">气流连接-由autor创建的图像。</p></figure><p id="e2ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个DAG。我利用<a class="ae lb" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank">请求库</a>来创建对<code class="fe mg mh mi mj b">GET /nifi-api/processors/{id}</code> REST-API端点的请求。在<a class="ae lb" href="https://nifi.apache.org/docs/nifi-docs/rest-api/index.html" rel="noopener ugc nofollow" target="_blank">文档</a>中我们可以看到必要的URI和预期的回报——一个ProcessorEntity JSON对象:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ow"><img src="../Images/43ec6e798a22a191cef347bd2f4c71ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Oj1TIDCc18RjN-Zd.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">NiFi REST API文档—由autor创建的图像。</p></figure><p id="95cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检索连接细节并在脚本中构建我们的URI，我们使用了Airflow的BaseHook模块，并将我们的连接ID ( <code class="fe mg mh mi mj b">mynifi_connection</code>)传递给它。如果您使用下面的脚本，不要忘记将processor_id字符串改为您自己的！</p><p id="9da5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据您在生产中的设置，您将首先需要通过端点<code class="fe mg mh mi mj b">POST /nifi-api/access/token</code>检索带有用户名/密码组合的访问令牌。之后，您必须在下面的代码中添加不记名令牌。幸运的是，在我们简化的设置中，这是不必要的。我们可以对REST API进行未经验证的调用，如下所示:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="13c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您按照说明操作，您将能够在DAG的日志中看到以下信息行:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7f59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么恭喜您，我们连接了服务！您现在可以基于这个<code class="fe mg mh mi mj b">Hello world!</code>构建工具和API调用来配置处理器或启动/停止处理器。如果您有进一步的兴趣，<a class="ae lb" rel="noopener" target="_blank" href="/interconnecting-airflow-with-a-nifi-etl-pipeline-8abea0667b8a">查看我的文章，了解如何通过执行以下模式将气流与成熟的ETL管道连接起来</a>:</p><ol class=""><li id="6273" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">预定气流DAG执行准备任务，</li><li id="841f" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">气流触发了Apache NiFi中的处理器，</li><li id="362e" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">NiFi执行一个ETL过程，</li><li id="7b46" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">气流等待NiFi完成，</li><li id="c196" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">气流继续执行其他任务。</li></ol><p id="adab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是够了，下一章在等着你！我们就要完成了，所以如果你已经走了这么远，<strong class="kh ir">感谢你的关注！我不会耽搁你太久——让我们一起完成这个项目和我们的下一(也是最后一)章吧！</strong></p><h1 id="5e73" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">阿帕奇气流:你好米尼奥/S3</h1><p id="aec6" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">Airflow提供了一个S3Hook，我们可以使用它无缝连接到S3或S3兼容的存储设备，如MinIO！如前所述，为了使用钩子，我们需要在我们的Airflow服务上安装包<code class="fe mg mh mi mj b">boto3</code>，方法是在我们的本地<code class="fe mg mh mi mj b">airflow/requirements/requirements.txt</code>文件中添加一行<code class="fe mg mh mi mj b">boto3</code>，并重启Airflow docker服务。虽然我们不会直接导入<code class="fe mg mh mi mj b">boto3</code>，但如果没有它，我们将无法使用Airflow的<code class="fe mg mh mi mj b">airflow.hooks.S3_hook</code>模块。</p><p id="2f3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重启气流后，在<code class="fe mg mh mi mj b">Admin</code>-&gt;-<code class="fe mg mh mi mj b">Connections</code>GUI下建立新的连接:</p><ul class=""><li id="f1de" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Conn ID</code> : <code class="fe mg mh mi mj b">myminio_connection</code></li><li id="6e58" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Conn Type</code> : <code class="fe mg mh mi mj b">S3</code>由于没有<code class="fe mg mh mi mj b">NiFi</code>连接类型，因此我们使用postgres作为替身。</li><li id="7009" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><code class="fe mg mh mi mj b">Extra</code>:由以下JSON组成:</li></ul><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="626a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记用您自己的密钥替换访问密钥，您可能已经在您的<a class="ae lb" href="https://gist.github.com/CribberSix/bfc8d6fdb30660467305f8e4288f213e" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml文件</a>中覆盖了这些密钥。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/2117736c9f9b5947fa30a197fa4f4d27.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/0*nVPvznJXwTduqp30.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">气流连接——图片由作者创作。</p></figure><p id="c656" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了最初在MinIO中与文件交互，我们将实现两个简单的操作:将文件写入MinIO和从MinIO中的文件读取。为此，S3Hook 提供了两个简单易用的函数:<code class="fe mg mh mi mj b">load_file</code>和<code class="fe mg mh mi mj b">read_key</code>。</p><p id="5cc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的本地<code class="fe mg mh mi mj b">airflow/dags</code>存储库中创建一个新的DAG(例如，名为<code class="fe mg mh mi mj b">hello_minio.py</code>)并复制粘贴下面的代码。第一个任务将把一个名为<code class="fe mg mh mi mj b">my-test-upload-file.txt</code>的文件上传到我们的MinIO bucket中的<code class="fe mg mh mi mj b">test</code>目录。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c9c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行DAG，完成后，检查操作是否成功:</p><ol class=""><li id="8aa9" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la ml ly lz ma bi translated">在MinIO中，您应该在<code class="fe mg mh mi mj b">test</code>目录的<code class="fe mg mh mi mj b">miniobucket</code>桶中找到一个新文件。</li><li id="3038" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la ml ly lz ma bi translated">在任务的气流日志中，您应该能够看到下面的行<code class="fe mg mh mi mj b">File contents: 'This is the content of a testfile from MinIO.'.</code>，描述了之前测试文件的文件内容。请注意，我们在这里使用的文件与我们在前面的Hello-MinIO-from-NiFi示例中为NiFi使用的文件相同。</li></ol><p id="c65b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">连接设置完成后，我们现在可以开始使用连接的组件了！</p><h1 id="a786" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">回顾和总结想法</h1><p id="2b29" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在这篇文章中，我们了解到</p><ul class=""><li id="bc0b" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">如何配置我们的服务，</li><li id="47a0" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">如何把我们的服务互相连接起来，</li><li id="b708" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">如何利用整体基础设施和</li><li id="3ea9" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">服务之间如何交互和通信。</li></ul><p id="c998" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我邀请您在这个超级简单但广泛的基础设施上进行测试、试验和实现概念验证。大多数数据工程任务都可以使用现有的工具来实现！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ce24cd3efcfb24f27e097d6f24f23644.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*woJDWujNiQyTpYib.png"/></div></figure><p id="dba0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个快速提醒，我们可以使用</p><ul class=""><li id="5b02" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><strong class="kh ir"> Apache NiFi </strong>处理和分发数据。</li><li id="f8e8" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir"> Apache NiFi Registry </strong>用于存储、管理和版本控制NiFi资源。</li><li id="7c10" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir"> Apache Airflow </strong>以编程方式创作、安排和监控工作流。</li><li id="72da" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir"> PostgreSQL </strong>作为对象关系数据库。</li><li id="f08c" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">作为PostgreSQL的管理和开发平台。</li><li id="9b36" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><strong class="kh ir"> MinIO </strong>作为对象存储——向来自<a class="ae lb" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> minIO </a>的人们大声疾呼，因为他们的社区版拥有标准版和企业版的所有功能！</li><li id="4799" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">主持我们的服务。</li></ul><p id="bbfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往，我们永远不会停止学习，所以如果您想了解更多，请随时查看以下链接</p><ul class=""><li id="bf8a" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated"><a class="ae lb" rel="noopener" target="_blank" href="/how-to-build-a-data-lake-from-scratch-part-1-the-setup-34ea1665a06e">这个系列的第一部分</a></li><li id="c45f" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://docs.docker.com/network/bridge/" rel="noopener ugc nofollow" target="_blank"> Docker的自定义桥</a></li><li id="1398" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://docs.docker.com/network/links/#the-importance-of-naming" rel="noopener ugc nofollow" target="_blank">码头工人的集装箱及其命名的重要性</a></li><li id="15f2" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://docs.docker.com/config/containers/start-containers-automatically/" rel="noopener ugc nofollow" target="_blank"> Docker的重启策略</a></li><li id="5046" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://docs.docker.com/compose/environment-variables/" rel="noopener ugc nofollow" target="_blank"> Docker的环境变量在compose </a></li><li id="acdf" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/42809096/difference-in-boto3-between-resource-client-and-session" rel="noopener ugc nofollow" target="_blank">资源、客户端和会话之间的boto3差异</a>。</li><li id="db83" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" rel="noopener" target="_blank" href="/interconnecting-airflow-with-a-nifi-etl-pipeline-8abea0667b8a">如何将气流与NiFi ETL管道连接</a></li><li id="831d" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇气流</a></li><li id="6c42" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://nifi.apache.org/" rel="noopener ugc nofollow" target="_blank">阿帕奇尼菲</a></li><li id="1e4c" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://nifi.apache.org/registry.html" rel="noopener ugc nofollow" target="_blank"> Apache NiFi注册表</a></li><li id="358e" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://nifi.apache.org/docs/nifi-registry-docs/html/administration-guide.html" rel="noopener ugc nofollow" target="_blank"> Nifi注册管理机构的系统管理员指南</a></li><li id="4014" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a></li><li id="46b6" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://www.pgadmin.org/" rel="noopener ugc nofollow" target="_blank"> pgAdmin </a></li><li id="8e09" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated"><a class="ae lb" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> MinIO </a></li></ul></div></div>    
</body>
</html>