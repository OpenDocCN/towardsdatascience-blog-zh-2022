<html>
<head>
<title>Kernel Density Estimation for Anomaly Detection in Python: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中异常检测的核密度估计:第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kernel-density-estimation-for-anomaly-detection-in-python-part-1-452c5d4c32ec#2022-01-04">https://towardsdatascience.com/kernel-density-estimation-for-anomaly-detection-in-python-part-1-452c5d4c32ec#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="3653" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Python中异常检测的核密度估计:第1部分</h1></div><div class=""><h2 id="bad2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将经典方法与深度学习相结合以获得更好的表示</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/57bf1aef58ed6cd7e5fe15817f6e4b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nkrkm4JUUWC8Pbkt"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@mullyadii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">穆利亚迪</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">金融数据集中的欺诈检测、网络流量中的罕见事件检测、建筑物和道路监控的视觉图像检查以及生产线中的缺陷检测:这些都是非常常见的问题，在这些问题中，用于异常检测的机器学习技术会有所帮助。</p><blockquote class="ls lt lu"><p id="98bd" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">简而言之，异常检测是一个研究领域，旨在发现数据集中的异常观察。</p></blockquote><p id="bbe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个问题设置，我们假设我们有两种类型的数据点:<strong class="ky ir">正常</strong>和<strong class="ky ir">异常</strong>。大多数情况下，这是一个高度不平衡的数据集，因为异常数据点比正常数据点积累得少。在不同的场景中，变态这个词可以有不同的含义。例如，当我们得到的数据点不同于以前所有其他类型的异常时，它可以被称为<strong class="ky ir">新颖性</strong>，或者当它是非常罕见但已知的原因时，我们可以将其称为<strong class="ky ir">异常值</strong>[1]。</p><p id="bf32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管有定义和用例，我们可以将所有这些类型的问题归纳为异常检测。</p><p id="fd0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PCA、SVM或核密度估计是用于发现异常观察的经典机器学习技术。如今，许多深度学习技术被用于异常检测，如GANs、自动编码器等。</p><p id="cfe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图像中异常检测的一种非常常见的方法是<em class="lv">一类分类结合自监督学习</em>。它被称为一类分类，因为我们只使用正态数据来拟合模型。粗略地说，我们强迫模型学习正常数据点的良好表示。当我们使用正常和异常数据点组合的测试集时，这可能有助于看到微小的差异。这些技术成为异常检测的最新技术。</p><p id="f536" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的第一部分将介绍使用核密度估计检测异常数据的经典方法，接下来我们将深入探讨用于改进KDE的自我监督技术。为了更实际的描述，我们将更深入地研究谷歌最近的一篇论文CutPaste [2],它结合了一种新颖的自我监督技术和KDE。</p><h2 id="d0e1" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">核密度估计</strong></h2><p id="ec5a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">核密度估计(KDE)是一种无监督学习技术，有助于以非参数方式估计随机变量的PDF。它与直方图有关，但使用了数据平滑技术。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2b91af6a7eb34013ccb4c60c9f10ba87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/0*zTOzin8kKywY0dOi"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">直方图和KDE可视化:<a class="ae kv" href="https://scikit-learn.org/stable/modules/density.html" rel="noopener ugc nofollow" target="_blank">图像源</a></p></figure><p id="ee8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在上面的例子中看到的，我们使用相同的数据来绘制直方图。然而，移动直方图中的柱会导致可视化的巨大差异。为了平滑分布，可以使用不同的内核。在上面的例子中，使用了Tophat和Gaussian核。输出是平滑的密度估计。那么，如何得到这个分布呢？</p><p id="d7a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KDE的通用公式如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/2e89aa591b3f7ca30b429a5274bde94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/0*vAm7sZfXn08EVkx7"/></div></figure><p id="44a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<em class="lv"> K </em>是核，<em class="lv"> h </em>是负责平滑度的带宽参数。如果我们为<em class="lv"> h </em>选择一个更高的数字，我们将得到更平滑的分布。<em class="lv"> y </em>是给定的估计值，而<em class="lv"> xi </em>是样本数据集中的一个点。</p><p id="cf85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，K是一个内核，我们有多种选择，如高斯，托法特，Epanechnikov等。对于异常检测，我们将使用高斯核估计，其中我们使用以下公式计算密度:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7c9bf7347d1efbb168d133a65f9c9f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/0*UqXA9A9o1eA8gbGj"/></div></figure><p id="8ae2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据剪贴纸[2]，我们使用上面的公式计算异常分数。</p><p id="b1df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下步骤描述了使用高斯密度估计的异常检测过程:</p><p id="134f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤1:拟合从火车分裂到GDE的正常数据点</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码来自:<a class="ae kv" href="https://github.com/LilitYolyan/CutPaste" rel="noopener ugc nofollow" target="_blank">https://github.com/LilitYolyan/CutPaste</a></p></figure><p id="2c1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤2:从测试数据集中计算异常分数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码来自:<a class="ae kv" href="https://github.com/LilitYolyan/CutPaste" rel="noopener ugc nofollow" target="_blank">https://github.com/LilitYolyan/CutPaste</a></p></figure><p id="9976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤3:如果异常分数小于预定义的阈值，则您有一个异常数据点，否则，您没有异常</p><h2 id="dc8f" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">异常检测的ROCAUC指标</strong></h2><p id="c0f2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在基准测试中，ROCAUC用于比较不同的模型。MVTec数据集是最常见的异常检测基准数据集。</p><p id="f584" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算模型的准确性，绘制<strong class="ky ir">接收器工作特性(ROC)曲线</strong>并计算曲线下面积(AUC)。为了计算ROC和AUC，我们使用异常和正常示例的测试数据，如果我们在AUC上获得更高的结果，我们可以更好地检测缺陷。</p><div class="kg kh ki kj gt ab cb"><figure class="nc kk nd ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/4e55f07221be16d4b3e16a1d455a5b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tz93CYq3Z9jg8QG5TOxzgA.jpeg"/></div></figure><figure class="nc kk nd ne nf ng nh paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/d22bbd338319b8dce1dc3f541e6ce3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*H1aiMkRMy1k1nUEiMuA8kg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ni di nj nk translated">训练模型后的ROC曲线示例:图片来自作者</p></figure></div><p id="92b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要计算ROC曲线和AUC <em class="lv">可使用sklearn </em>软件包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码来自:<a class="ae kv" href="https://github.com/LilitYolyan/CutPaste" rel="noopener ugc nofollow" target="_blank">https://github.com/LilitYolyan/CutPaste</a></p></figure><h2 id="4779" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><strong class="ak">自我监督设置</strong></h2><p id="72e5" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们看到了如何实现用于异常检测的GDA。然而，很难在图像上得到好的结果。如果我们从图像中检索到好的表示，我们可以在GDE上得到更好的结果。为了达到这一点，在文章的第二部分，我们创建了一个自我监督的模型，它具有独特的预处理任务，可以改善GDE的结果。</p><h2 id="9dbd" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated">参考</h2><p id="8558" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">[1]拉夫、卢卡斯&amp;考夫曼、雅各布&amp;范德穆伦、罗伯特&amp;蒙塔冯、格雷瓜尔&amp;萨梅克、沃伊切赫&amp;克洛夫特、马里乌斯&amp;迪特里希、托马斯&amp;穆勒、克劳斯-罗伯特。(2021).<a class="ae kv" href="https://arxiv.org/abs/2009.11732" rel="noopener ugc nofollow" target="_blank">深浅异常检测的统一综述</a>。IEEE会议录。第1-40页。10.1109/jproc . 20221 . 386386363636</p><p id="ad62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]李、孙春良、基赫和尹、金松和普菲斯特、托马斯。(2021).用于异常检测和定位的自我监督学习。</p><h2 id="ed09" class="lz ma iq bd mb mc md dn me mf mg dp mh lf mi mj mk lj ml mm mn ln mo mp mq mr bi translated"><a class="ae kv" href="https://github.com/LilitYolyan/CutPaste" rel="noopener ugc nofollow" target="_blank">来自Github的代码</a></h2></div></div>    
</body>
</html>