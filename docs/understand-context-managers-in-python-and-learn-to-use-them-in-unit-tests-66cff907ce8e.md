# 理解 Python 中的上下文管理器，并学习在单元测试中使用它们

> 原文：<https://towardsdatascience.com/understand-context-managers-in-python-and-learn-to-use-them-in-unit-tests-66cff907ce8e>

## 使用上下文管理器使你的代码更加健壮，更加 Pythonic 化

![](img/5a84e2361c2420b4c7d5ff0022e380ce.png)

图片由 [BUMIPUTRA](https://pixabay.com/photos/poster-wall-mockup-interior-frame-2899095/) 在 Pixabay 拍摄

我们已经使用了关键字`with`和函数`open`来创建一个上下文，它将在我们读/写完之后关闭文件。然而，Python 中的上下文管理器并不局限于管理外部资源，如文件描述符、数据库连接、线程锁等，它们可以用于提供所有类型的上下文，这些上下文需要在执行主代码块之前和之后进行一些设置和拆卸操作。在本帖中，我们将通过简单的代码片段解释所有的技术机制，来揭开 Python 中的上下文管理器的神秘面纱。我们还将介绍如何在大量使用上下文管理器的 Python 单元测试中使用模拟/补丁。

## 将上下文管理器与 try/finally 语句进行比较

当用于管理外部资源时，`with`上下文管理器可以被看作是`try/finally`语句的语法糖。无论主代码成功与否，两者都将在最后关闭外部资源。以下使用`with`上下文管理器和`try/finally`语句的代码片段是等效的:

正如我们所看到的，有了上下文管理器，代码可以更加简洁。

## 创建自定义上下文管理器

现在让我们创建一个定制的上下文管理器，以便理解场景背后的技术机制。

为了创建上下文管理器，我们可以创建一个实现`__enter__()`和`__exit__()`魔法方法的类。`__enter__()`包括上下文的设置代码，将在创建上下文时执行。它可以返回一个值，该值将被赋给`with … as <var>`语句中的变量。另一方面，`__exit__()`包括当上下文退出时将被执行的拆卸代码，不管主代码块是否引发异常。如果主代码块中出现异常，异常类型、异常值和回溯将分别传递给`exc_type`、`exc_value`和`exc_tb`。

现在，定制上下文管理器应该以与内置`open`函数相同的方式工作:

## 使用生成器函数创建自定义上下文管理器

上面我们使用经典的基于类的协议创建了一个定制的上下文管理器，它实现了`__enter__()`和`__exit__()`方法。类似于[迭代器](/demystify-iterators-and-generators-in-python-f21878c9897)，我们可以使用生成器函数以更简洁的方式创建一个上下文管理器。为此，我们只需要用`contextlib`库中的`[contextmanager](http://twitter.com/contextmanager)` [装饰器](https://lynn-kwong.medium.com/understand-and-master-the-decorator-in-python-481aa444933f)来装饰生成器函数:

现在，我们可以将生成器函数用作上下文管理器:

正如我们所见，`yield`语句前后的代码分别对应于`__enter__()`和`__exit__()`方法。产生的值(如果有的话)被绑定到`with … as <var>`语句中的变量。注意，如果什么都没有产生，那么`yield`语句也应该存在，否则它就不是一个生成器函数。这种情况很快就会有一个例子。

## 用上下文管理器模拟一个函数

有了上下文管理器，我们可以在上下文中改变函数的行为，并在它退出上下文时重置它。这实际上是单元测试中修补工作的机制。让我们用上下文管理器模拟一下`datetime.now()`函数:

主题演讲:

*   我们必须将`datetime.now`函数对象赋给一个新变量，否则，它不能被赋一个新值来改变它在上下文管理器中的行为。稍后你会看到我们可以使用`unittest.mock`中特殊的 ***补丁*** 函数非常方便地模仿任何函数/方法，而不需要创建新的中间变量。
*   这里创建了一个基于生成器的上下文管理器，您也可以创建一个基于类的上下文管理器，这应该非常简单。只需将`yield`语句前后的代码分别复制到`__enter__()`和`__exit__()`方法中。
*   在生成器函数中，我们必须使用`global`关键字来声明`now`是一个全局变量，否则就无法在那里访问。它被保存到一个新变量`saved_now`中，以便以后可以重置。
*   然后给`now`变量分配一个新的 lambda 函数，该函数总是返回同一个`datetime`对象。这样，`now()`函数的行为在上下文中被改变。
*   在这个上下文管理器中，什么都没有产生，但是我们仍然需要显式地产生，以使它成为一个有效的生成器函数。
*   我们已经知道，`yield`语句后的代码是拆机部分。我们应该把`now()`重置回原来的`datetime.now()`。

让我们使用这个上下文管理器来检查上下文内外的`now()`函数的结果:

我们可以看到,`now()`函数的行为在上下文中被模仿，当它退出上下文时又被重置回正常状态。

## 在单元测试中模拟 datetime.now()

大部分功能都可以直接嘲讽。但是，我们不能直接嘲讽`datetime.now()`，否则，我们会看到下面的`TypeError`:

我们需要模拟`datetime`模块。请务必小心下面的代码，这里很容易出错:

主题演讲:

*   您需要安装`pytest`模块来运行单元测试:

*   由于`datetime.now()`函数不能直接打补丁，我们需要打`datetime`模块的补丁。注意，我们需要修补当前测试文件中导入的`datetime`模块，而不是内置`datetime`库中的模块。如果将`test_mock_now.datetime`改为`datetime.datetime`，测试将失败。这是因为，随着这个改变，被嘲笑的是`datetime.datetime`，而不是当前测试文件中导入的`datetime`模块。因此，第 10 行和第 11 行的断言会失败。一定要自己尝试一下，这样你才能更好地理解它。

## 单元测试中的 Mock requests.get()

实际上，在 Python 单元测试中，模仿非常简单。只是来自`datetime`库的`datetime.now()`函数有点特殊。让我们修补单元测试中更常用的`requests.get()`函数，以模拟一些 HTTP 请求的响应:

这次`requests.get()`函数可以直接打补丁，代码也简单很多。

模拟在单元测试中非常重要，它可以让你的测试代码独立于外部资源工作，让你专注于代码的逻辑和健壮性。几乎所有东西都可以在单元测试中被嘲笑。我们刚刚在本帖中介绍了函数的模拟。更多的例子将会在一篇更专门的单元测试文章中介绍。

在这篇文章中，我们介绍了上下文管理器的基础知识以及用 Python 实现它们的不同方法。上下文管理器可以用基于类或基于生成器的协议来实现，后者更简洁。上下文管理器可以使您的代码更加健壮，因为资源肯定是关闭的。此外，上下文管理器可以用来改变上下文中某些函数的行为，这使得它们在单元测试中被广泛使用，因为它们可以让您的测试代码独立于外部资源工作。

相关文章:

*   [解开 Python 中迭代器和生成器的神秘面纱](/demystify-iterators-and-generators-in-python-f21878c9897)