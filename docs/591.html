<html>
<head>
<title>SQL Ranking Window Function Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL排名窗口功能指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-ranking-window-function-guide-b9aee35d5931#2022-01-20">https://towardsdatascience.com/sql-ranking-window-function-guide-b9aee35d5931#2022-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="3813" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">SQL排名窗口功能指南</h1></div><p id="c336" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">排数()、排名()、密集排名()、实体()、百分比排名()、CUME DIST()</p><p id="d7ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SQL查询的世界中，我们经常发现自己需要创建某种排序来更好地理解我们的数据。幸运的是，排序函数是窗口函数下的主要领域之一，并且很容易实现！</p><p id="50ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">六种类型的排名函数是:</p><ul class=""><li id="d001" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">ROW_NUMBER()</li><li id="8d12" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">排名()</li><li id="0f8f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">密集等级()</li><li id="c60e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">百分比排名()</li><li id="3247" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">NTILE()</li><li id="4d16" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">DIST CUME()</li></ul><p id="398c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们进入每个排名函数的细节之前，我们应该看看这些函数通常是如何写出的:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="8434" class="li lj iq le b gy lk ll l lm ln">[Ranking Function]() OVER([specific operation] column_name)</span></pre><p id="bd8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在实践中，SQL命令看起来像这样:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d30c" class="li lj iq le b gy lk ll l lm ln">SELECT *, ROW_NUMBER() OVER(PARTITION BY column1 ORDER BY column2 DESC)<br/>FROM table</span></pre><p id="5f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们选择了表中的所有行，并按照列1的每个值划分的列2的降序排列输出。当我们深入到每个排名函数的描述和示例时，这将更有意义。</p><p id="129d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据:<br/> </strong>本文使用的数据仅供演示之用，并不代表所描绘数字的任何准确表述。数据有三列，c_name —城市名称，c_state —城市所在的州，&amp; coffee_shop_num —该城市的咖啡店数量。*下面只显示了部分数据*</p><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lo"><img src="../Images/b3d97a96466a136edc39a2cc97c908eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4kNU2mxGAGy78Ia2Z4CFg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="0fff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">ROW _ NUMBER:<br/></strong>ROW _ NUMBER()排名函数根据给定分区内的行数对该分区进行顺序排名。如果两行具有相同的信息，该函数将根据OVER()语句中提供的信息确定哪一行排名第一。使用Row_Number ranking给定分区中的每一行都有自己的排名，没有重复或跳过的数字。该函数的一个示例如下:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="163e" class="li lj iq le b gy lk ll l lm ln">SELECT *, <br/>ROW_NUMBER() OVER(PARTITION BY c_state ORDER BY coffee_shop_num DESC) as rank<br/>FROM city</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/4929cfb5fb498fbb09e8afcb73b22c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae9axeLNgk_Ss8P2xeKcIQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="a11b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们看到rank列对州分区内的每个城市进行排序，对应于ties的城市是随机选择的，用于特定的排序位置。</p><p id="cac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">RANK</strong>:<br/>RANK()ranking函数提供了与ROW_NUMBER()函数类似的结果，但是，在RANK()函数中，平局被赋予相同的值，后续值被跳过。使用RANK()函数可以在一个分区中获得重复的排名，并且可以获得不连续的排名，因为在平局之后数字会被跳过。下面是RANK()函数的一个例子。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="8269" class="li lj iq le b gy lk ll l lm ln">SELECT *, <br/>RANK() OVER(PARTITION BY c_state ORDER BY coffee_shop_num DESC) as rank<br/>FROM city</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/2559063fdc21e90fd08f5e4e8acb293b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifL60nCRp3VexoNcDejx0Q.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="3e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的结果中可以看出，圣地亚哥和马里布在咖啡店数量上并列，都被评为3级，接下来的排名跃升至5级，也正好是并列。类似地，利斯堡和里士满在咖啡店数量上打成平手，都得了第4名，而下一个城市布莱克斯堡得了第6名。</p><p id="1a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">DENSE _ RANK:</strong><br/>DENSE _ RANK()排名函数充当RANK()和ROW_NUMBER()之间的混合体，因为该函数允许分区内的联系，但也提供跟随联系的顺序排名。例如，分区内的排名顺序可能是1、2、3、3、4、4、5。这可以在下面的示例代码和输出中看到，圣地亚哥和马里布再次并列第三，下面的城市排名第四。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="89ab" class="li lj iq le b gy lk ll l lm ln">SELECT *, <br/>DENSE_RANK() OVER(PARTITION BY c_state ORDER BY coffee_shop_num DESC) as rank<br/>FROM city</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mb"><img src="../Images/157110ab75debc27d0e00d8cc5527bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mYQuUt67Ntk3oqw26JEq1w.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="a984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NTILE:<br/>NTILE()排名函数的工作方式与我们已经看到的三个函数不同。该函数按照指定的分割数分割分区中的行。然后，根据这些行的等级将它们分配到这些组中的一个，从1开始，一直到指定的组数。使用下面的示例代码和输出，我们看到我们在NTILE()函数中传递了数字5，这意味着我们将每个分区分成5组。我们可以看到，每一行都被分配到1-5之间的等级，一些组包含不止一行，这是在每个分区中有超过5个城市的情况下所预期的。在这种情况下，领带可以在同一个组内，也可以像Calexico和La Jolla那样分开。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="76c2" class="li lj iq le b gy lk ll l lm ln">SELECT *, <br/>NTILE(5) OVER(PARTITION BY c_state ORDER BY coffee_shop_num DESC) as rank<br/>FROM city</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi ma"><img src="../Images/8b05a617aba312c51e74366886424ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IjeLD8esIu02x9lma7xc-g.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="4565" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> PERCENT_RANK: </strong>最低等级从0开始，一直到1，每个间隔值等于1/(n-1)，其中n是给定分区中的行数。在下面的代码示例中，我们看到洛杉矶是值为0的最低百分位数(最高排名)，在洛杉矶之后，每一行都对应于值1/(7–1)= 0.1666，平局的工作方式与RANK()函数相同。从下面可以看出，Calexico和La Jolla拥有相同的等级百分位数，但因为它们共同代表0.166+0.166，所以在La Jolla之后，Irvine的下一个百分位数为1。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="2125" class="li lj iq le b gy lk ll l lm ln">SELECT *, <br/>PERCENT_RANK() OVER(PARTITION BY c_state ORDER BY coffee_shop_num DESC) as percentile<br/>FROM city</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mc"><img src="../Images/e96b8bf6b192351a1b08c6bb8139f29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eCYeviTLfz9Ax8RQCzW2gg.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="8a60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> CUME_DIST: </strong> <br/>我们的最终排名函数是CUME_DIST()，它的作用类似于PERCENT_RANK()函数，但不是从0开始并继续1/(n-1)，CUME_DIST()从值1/n开始并继续1/n，直到给定分区内的最终值1。DIST CUME()内的联系与PERCENT_RANK()内的联系被同等对待。如下面的示例代码和输出所示，Los Angeles从值0.143开始，每一行的百分位数对应于大约0.143的加法，平局对应于平局行数的聚合。最终，分区以百分位数1结束。</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="647f" class="li lj iq le b gy lk ll l lm ln">SELECT *, <br/>CUME_DIST() OVER(PARTITION BY c_state ORDER BY coffee_shop_num DESC) as percentile<br/>FROM city</span></pre><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi mc"><img src="../Images/25d6301c853c342ec740e33a3f9f8469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7jdxY11b-gW-F71fvBQ55g.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure><p id="2067" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论</strong> : <br/>这六个排名窗口函数有很多用例，是需要掌握的必备技能。许多函数都是相似的，只有几个不同的方面，这可能会在开始时使事情变得混乱，但是经过一些练习后，您将确切地知道在任何给定的场景中使用哪个函数。我希望这篇指南对你有所帮助，并且一如既往地感谢你花时间阅读这篇文章。如果您想阅读更多我的文章，请关注我的帐户，以便在其他数据科学文章发布时得到通知。</p><figure class="kz la lb lc gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi md"><img src="../Images/2c86a615cefcb550371c4aefdd7caf24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12piAP2JrI99yutcx-CLyQ.png"/></div></div><p class="lw lx gj gh gi ly lz bd b be z dk translated">作者图片</p></figure></div></div>    
</body>
</html>