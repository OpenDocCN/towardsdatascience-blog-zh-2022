<html>
<head>
<title>Iterables vs Iterators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的Iterables vs迭代器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-iterables-vs-iterators-688907fd755f#2022-01-11">https://towardsdatascience.com/python-iterables-vs-iterators-688907fd755f#2022-01-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""><h1 id="dee4" class="pw-post-title is it iu bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">Python中的Iterables vs迭代器</h1></div><div class=""><h2 id="bcd1" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">理解Python中Iterables和迭代器的区别</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d75823e57f14b4d42578978cea93c6c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4BW-pnYmTAGqmmnSlj7bZg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">亨利&amp;公司在<a class="ae kz" href="https://unsplash.com/s/photos/loop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="1346" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="0cbe" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">术语<strong class="ly iv"> iterable </strong>和<strong class="ly iv"> iterator </strong>经常(错误地)互换使用，以描述支持迭代的对象，即允许迭代其元素的对象。事实上，Python中的迭代器和可迭代对象是两个截然不同的概念，通常会引起混淆，尤其是对新手而言。</p><p id="1552" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将讨论Python中的迭代协议，以及迭代器和可迭代对象如何参与其实现。此外，我们将探索iterable和iterator对象之间的主要区别，并提供一个示例来帮助您理解iterable和iterator对象是如何工作的。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="b515" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python中的迭代协议</h2><p id="02f0" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Python中的<strong class="ly iv">所有迭代工具</strong>使用迭代协议，并通过各种对象类型(如for循环、综合、映射等)实现。本质上，协议由两种对象类型组成，即<strong class="ly iv"> iterable </strong>和<strong class="ly iv"> iterator </strong>。</p><ul class=""><li id="82ac" class="nb nc iu ly b lz mp mc mq lj nd ln ne lr nf mo ng nh ni nj bi translated"><strong class="ly iv"> iterable </strong>对象是您<strong class="ly iv">迭代</strong>其元素的对象</li><li id="b626" class="nb nc iu ly b lz nk mc nl lj nm ln nn lr no mo ng nh ni nj bi translated"><strong class="ly iv">迭代器</strong>对象是<strong class="ly iv">在迭代</strong>过程中产生值的对象，也是由可迭代对象返回的<strong class="ly iv"/></li></ul><p id="35a3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在接下来的部分中，我们将详细了解这两种对象类型是如何工作的，以及它们需要实现什么来满足迭代协议。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="af8b" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是可迭代的</h2><p id="927f" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在Python中，Iterable是一个对象，它由<strong class="ly iv">实现</strong> <code class="fe np nq nr ns b"><strong class="ly iv">__iter__()</strong></code>方法，由<strong class="ly iv">返回一个iterator对象</strong>或者实现<code class="fe np nq nr ns b">__getitem__()</code>方法的对象(并且应该在索引用尽时引发一个<code class="fe np nq nr ns b">IndexError</code>)。内置的可迭代对象包括<strong class="ly iv">列表、集合和字符串</strong>，因为这样的序列可以在一个for循环中迭代。</p><p id="2ba9" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">注意<strong class="ly iv">在最近的Python版本中，实现Iterables的首选方式是通过实现</strong> <code class="fe np nq nr ns b"><strong class="ly iv">__iter__()</strong></code> <strong class="ly iv">方法</strong>。<code class="fe np nq nr ns b">__getitem__()</code>方法是一种在现代迭代器之前使用的遗留功能。但是Python仍然认为实现了<code class="fe np nq nr ns b">__getitem__()</code>方法的对象是可迭代的。这意味着如果没有定义<code class="fe np nq nr ns b">__iter__()</code>，Python解释器将使用<code class="fe np nq nr ns b">__getitem__()</code>。更多详情可以参考<a class="ae kz" href="https://www.python.org/dev/peps/pep-0234/" rel="noopener ugc nofollow" target="_blank"> PEP-234 </a>。</p><p id="6cf2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">总而言之，Python中的Iterable是任何对象，只要它</p><ul class=""><li id="c654" class="nb nc iu ly b lz mp mc mq lj nd ln ne lr nf mo ng nh ni nj bi translated">可以迭代(例如，可以迭代一个字符串的字符或一个文件的行)</li><li id="b699" class="nb nc iu ly b lz nk mc nl lj nm ln nn lr no mo ng nh ni nj bi translated">实现<code class="fe np nq nr ns b">__iter__()</code>方法(或<code class="fe np nq nr ns b">__getitem__</code>)，因此可以用返回迭代器的<code class="fe np nq nr ns b">iter()</code>调用它</li><li id="5d04" class="nb nc iu ly b lz nk mc nl lj nm ln nn lr no mo ng nh ni nj bi translated">可以出现在for循环的右边(<code class="fe np nq nr ns b">for i in myIterable:</code>)</li></ul></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="59b4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是迭代器</h2><p id="1f3c" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">另一方面，Python中的迭代器是<strong class="ly iv">以某种方式实现</strong> <code class="fe np nq nr ns b"><strong class="ly iv">__next__()</strong></code> <strong class="ly iv">方法</strong>的对象</p><ul class=""><li id="d82b" class="nb nc iu ly b lz mp mc mq lj nd ln ne lr nf mo ng nh ni nj bi translated">返回iterable对象的下一个值，更新迭代器的状态，使其指向下一个值</li><li id="4b30" class="nb nc iu ly b lz nk mc nl lj nm ln nn lr no mo ng nh ni nj bi translated">当iterable对象的元素用尽时引发一个<code class="fe np nq nr ns b">StopIteration</code></li></ul><p id="551b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，<strong class="ly iv">迭代器本身也是可迭代的，因为它还必须实现</strong> <code class="fe np nq nr ns b"><strong class="ly iv">__iter__()</strong></code> <strong class="ly iv">方法</strong>，其中它只是返回<code class="fe np nq nr ns b">self</code>。</p><blockquote class="nt"><p id="be4e" class="nu nv iu bd nw nx ny nz oa ob oc mo dk translated">每个迭代器也是可迭代的，但不是每个可迭代的都是迭代器</p></blockquote></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="b1f6" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python中的可迭代对象和迭代器</h2><p id="56b4" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">正如我们已经提到的，Python List是可迭代的内置对象类型之一。现在让我们假设我们有下面的整数列表，如下所示:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="a5ad" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; my_lst = [5, 10, 15]</span></pre><p id="dec4" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">由于<code class="fe np nq nr ns b">my_lst</code>是一个iterable，我们可以运行<code class="fe np nq nr ns b">iter()</code>方法来从iterable中获得一个iterator对象:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="8c42" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; my_iter = iter(my_lst)</span></pre><p id="76f0" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">我们可以验证<code class="fe np nq nr ns b">my_iter</code>是否属于<code class="fe np nq nr ns b">list_iterator</code>类型:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="0bbb" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; type(my_iter)<br/>list_iterator</span></pre><p id="7306" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在由于<code class="fe np nq nr ns b">my_iter</code>是一个迭代器，因此它实现了<code class="fe np nq nr ns b">__next__()</code>方法，该方法将返回列表iterable的下一个元素:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="9f1c" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; my_iter.__next__()<br/>5</span></pre><p id="92c5" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">一旦迭代器在<code class="fe np nq nr ns b">__next__()</code>调用后返回下一个值，它应该改变它的状态，以便它现在指向下一个元素:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="39ed" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; my_iter.__next__()<br/>10</span></pre><p id="52ba" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">注意，<code class="fe np nq nr ns b">next(iter_name)</code>也是一个有效的语法，相当于<code class="fe np nq nr ns b">iter_name.__next__()</code>:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="743d" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; next(my_iter)<br/>15</span></pre><p id="fc0e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在我们到达了最后一个元素，对<code class="fe np nq nr ns b">__next__()</code>方法的下一次调用应该会产生一个<code class="fe np nq nr ns b">StopIteration</code>，这是实现<code class="fe np nq nr ns b">__next__()</code>方法的迭代器必须满足的一个要求:</p><pre class="kk kl km kn gu od ns oe of aw og bi"><span id="7dfc" class="la lb iu ns b gz oh oi l oj ok">&gt;&gt;&gt; my_iter.__next__()</span><span id="8de9" class="la lb iu ns b gz ol oi l oj ok">Traceback (most recent call last):<br/>  File "/usr/local/lib/python3.7/site-packages/IPython/core/interactiveshell.py", line 3331, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;ipython-input-8-56d779eb7d74&gt;", line 1, in &lt;module&gt;<br/>    my_iter.__next__()<br/><strong class="ns iv">StopIteration</strong></span></pre></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="39e6" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="e4f6" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了Python中的迭代协议，以及迭代中如何涉及迭代和迭代器。此外，我们讨论了可迭代和迭代器的主要特征，并介绍了它们的主要区别。最后，我们展示了Iterable和Iterator对象是如何工作的。</p><p id="fc12" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在我的下一篇文章中，我将讨论如何创建用户定义的迭代器，以使用户定义的类可迭代。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="d507" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="om on gq gs oo op"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd iv gz z fq ou fs ft ov fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd kt op"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="om on gq gs oo op"><a rel="noopener follow" target="_blank" href="/python-linked-lists-c3622205da81"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd iv gz z fq ou fs ft ov fv fx it bi translated">如何在Python中实现链表</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">探索如何使用Python从头开始编写链表和节点对象</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd kt op"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu op"><a rel="noopener follow" target="_blank" href="/switch-statements-python-e99ea364fde5"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd iv gz z fq ou fs ft ov fv fx it bi translated">如何用Python编写Switch语句</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">了解如何使用模式匹配或字典在Python中编写switch语句</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd kt op"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu op"><a rel="noopener follow" target="_blank" href="/augmented-assignments-python-caa4990811a0"><div class="oq ab fp"><div class="or ab os cl cj ot"><h2 class="bd iv gz z fq ou fs ft ov fv fx it bi translated">Python中的扩充赋值</h2><div class="ow l"><h3 class="bd b gz z fq ou fs ft ov fv fx dk translated">了解增强赋值表达式在Python中的工作方式，以及为什么在使用它们时要小心…</h3></div><div class="ox l"><p class="bd b dl z fq ou fs ft ov fv fx dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pg l pa pb pc oy pd kt op"/></div></div></a></div></div></div>    
</body>
</html>