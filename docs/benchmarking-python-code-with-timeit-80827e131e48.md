# 用 timeit 对 Python 代码进行基准测试

> 原文：<https://towardsdatascience.com/benchmarking-python-code-with-timeit-80827e131e48>

## 作为 Python 代码时间基准测试最流行的工具，内置的 timeit 模块提供了比大多数 Python 爱好者所知道的更多的东西

![](img/1f4180cbed77651896efbf2b11f97bc1.png)

timeit 模块是 Python 的秒表。照片由 [Tsvetoslav Hristov](https://unsplash.com/@tsvetoslav?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

标杆管理很少是为了好玩而做的，即使它确实很有趣。除了这种乐趣之外，它还可以帮助您:

*   理解 Python 行为；你可以学习什么更快，什么更慢，这反过来可以帮助你理解语言；
*   优化您的代码。

如果您认为您花了太多时间对一些随机代码片段进行基准测试，不要担心。我去过那里。老实说，我仍然经常这样做。不要为此感到羞耻:基准测试有助于您理解语言的复杂性。随着时间的推移，你会注意到你可以猜测一个特定的片段应该有多快或多慢。然而，时不时地，甚至你的“标杆鼻子”也会误导你，所以标杆通常是值得花时间的。编程毕竟很有趣，不是吗？

就执行时间而言，Python 中最流行的代码片段基准测试模块可能是`[timeit](https://docs.python.org/3/library/timeit.html)`模块。Python 还提供了其他与时间相关的基准测试工具，但是`timeit`绝对应该是您的第一步，原因如下:

*   这是 Python 中与时间相关的基准测试工具中最流行的一个；
*   它是标准库的一部分，不用安装；和
*   其他工具通常是`timeit`的包装。

因此，我认为如果你想使用这些工具，你应该首先学会如何使用`timeit`并解释它的结果。这篇文章旨在帮助你。我将向您展示这个模块的一个鲜为人知的特性:基准函数而不是代码片段。我还会告诉你`timeit`结果可能会误导人的情况。

# 使用 timeit

大多数用户不知道`timeit`模块提供了两个 API，这就是为什么你会发现主要使用其中的一个。这两个 API 如下:

*   *基于代码片段的 API* 。大多数人提到`timeit`都会想到这个 API。它有两个优点:相对容易使用，而且几乎可以对任何东西进行基准测试，因为它对代码片段进行基准测试。
*   基于可调用的 API 。大多数人实际上并不知道这个 API。它旨在为可赎回债券设定基准。不幸的是，它的语法不如基于代码片段的 API 自然，但在某些情况下还是很有用的。我将在本文后面展示这种情况。

这两个 API 使用相同的函数，但有所不同。你应该知道的两个函数是`timeit.timeit()`和`timeit.repeat()`。事实是，我几乎总是使用后者，因为它只是简单地运行几次前者，并提供`timeit.timeit()`的单独结果，所以你会得到更稳定的结果。我建议你也这样做。为此，我将讨论`timeit.repeat()`函数；`timeit.timeit()`的 API 非常相似，只有一点不同:缺少`repeat`参数。

最简单的用法如下:

就是这样！它将测量以字符串形式提供的代码片段的执行时间。在我们的例子中，它是`[_ for _ in range(10)]`，这意味着我们将测量 Python 使用列表理解*一百万次*来创建一个列表所用的时间。这一百万次是`number`参数的默认值。记住该命令的每百万次调用都是在同一个会话中一个接一个、*进行的*；正如我稍后将展示的，这在某些情况下可能会很棘手。**

让我们来分析函数的签名:

*   `stmt`是您想要进行基准测试的代码片段，以字符串形式提供；
*   `number`是在一个会话中`stmt`被调用的次数；，以整数形式提供；默认为`1_000_000`；
*   `setup`是运行`stmt`次`number`之前要运行的代码，以字符串形式提供；每个会话只运行一次，在会话开始时；
*   `timer`是使用的定时器；默认的是`perf_counter()`，由于它目前被认为是最好的内置定时器，大多数情况下最好不要碰它；
*   `repeat`是要运行的会话数，每个会话由对`stmt`的`number`调用组成；你会得到所有这些会议的结果；作为整数提供，默认为 5；
*   `globals`是要提供的全局字典；可以代替`setup`使用，也可以随同使用。

对于小而快的代码片段，没有必要改变`number`和`repeat`，除非您希望您的基准提供非常稳定的结果。如果这样做，您应该增加这些数字，这取决于您希望结果有多稳定，以及您希望基准运行多长时间。

然而，对于耗时较长的代码片段，您可能希望减少`number`和`repeat`，或者两者都减少，否则基准测试可能会花费太多时间。但是，您会注意到，这样做之后，也就是说，如果`number`和`repeat`的值太小，结果可能会变得不稳定。

上面，我们使用了基于片段的 API。是时候讨论一下鲜为人知的基于可调用的 API 了:

您可能认为上面两个对`timeit.repeat()`的调用应该提供相似的结果，因为它们测试的是同一件事，即使用长度为 10 的`range`对象的列表理解创建一个列表。但这不是真的:第一个确实以这种方式创建了一个列表，但后者不是，或者说不仅仅是。这是因为后者还包括运行`make_list()`函数的开销，有时这种开销会相当大。实际上，我们可以这样分析:

上述调用中的第一个相当于`timeit.repeat(make_list)`，但是它使用与第二个相同的 API。因此，如果我们看到`t1`和`t2`之间的差异，那将是由于调用一个函数一百万次的开销。

在我的机器上(32 GB，四个物理和八个逻辑内核，在 WSL 1 中运行)，我得到了以下结果:

差别相当小，不是吗？考虑到这个基准测试用了这么短的时间，我们能信任它吗？让我们用`number=10_000_000`和`repeat=10`重新运行基准测试，以防万一。再次，`best(t1)`更大，与`4.1292`对`3.7315`的`best(t2)`。然而，你必须记住，这些基准测试并没有那么长…它们总共用了 78 秒，下一次我运行它们时，我得到了`3.9846`对`3.8373`的结果。因此，如果您想确定您的基准，请使用更大的`number`和`repeat`值。但是，当两个(或更多)代码段的执行时间差异很大时，您不必使用大的值。

至于两个 API 的对比，记住:

> 这两个 API——基于代码片段的和基于可调用的——即使在对做同样事情的代码进行基准测试时，也会产生不同的结果。这是因为基于可调用 API 的结果还包括调用可调用 API 的开销时间。

选哪个？看情况吧。如果您想比较两个函数的执行时间，这正是创建基于可调用 API 的目的。或者，当你在代码中对一个函数做了一些事情(例如，分配一个列表，如上)时，那么基于可调用的 API 将更好地反映实际情况。尽管如此，如果你只是想比较两个片段，没有必要为此使用函数。但是，请记住，关于范围。当您将代码封装在一个函数中时，所有这些都将在这个函数的局部作用域和命名空间中完成。正如我稍后将展示的那样，这可能会有所不同。

# *示例:创建空字典*

现在，假设我们想要对创建空字典的两种方法进行基准测试:`{}`和`dict()`。我们可以用下面的方法来做:

你的猜测是什么？

如果你投票支持字面意思更快，那你答对了。在我的机器上，`best(literal)`给了`0.0183`，而`best(func)`给了`0.0600`，所以差别很大。我们可以分析这两种方法的字节码，看看这种性能差异来自哪里:

如您所见，`dict()`使用了另外一个字节码操作，在这个操作中它调用了一个`dict()`函数；文字可能更快，因为它不需要这样做。如果你看到了与前一个例子的相似之处，你就对了；我们看到了调用`dict()`函数的开销。

有趣的是，如果你创建自己的函数如下:

你会发现它比`dict()`功能本身更快。我让你检查这作为一个练习。(这就是我上面跟你说的对标的乐趣！)

# **为什么是最小值？**

您可能想知道为什么我使用最小值而不是平均值来比较两个基准测试结果(参见上面的`best()`函数)。为什么不把均值作为主要的趋势度量，而把方差(或标准差，或其他不同的度量)作为变异的度量？

这是因为标杆管理不是一种正常情况，所以我们不应该应用典型的统计方法来分析其结果。在最好的情况下，相同代码(不包括随机性)的所有运行应该花费相同的时间。但是，在基准测试期间，操作系统会执行许多不同的任务，因此后续的基准测试会花费不同的时间。请记住，这不是因为代码本身，而是因为操作系统的进程。

因此，我们应该取最小值，因为它最接近实际执行时间，没有任何中断。同样的，我们不应该注意运行结果的变化。它们不度量这个特定代码片段的实际执行时间的可变性；其实应该是几乎没有变异的。相反，这种变化度量的是操作系统运行的*其他*进程的变化程度；那么，这些过程对基准测试结果的影响有多大呢？这就是为什么分析基准与分析其他类型的数据如此不同，这也是为什么最小值是比任何集中趋势度量更好的表示基准结果的度量。

# **另一个例子**

让我们考虑一个更复杂的场景。这一次，我们将使用`setup`来设置环境。

同样，在运行代码之前，分析它并尝试猜测哪个函数应该更快。(这次没那么简单，因为你需要知道`array`模块是如何工作的。)

请注意，您可以稍微简化一下上面的代码。这种简化是有意义的，尤其是当您有更多片段要比较时:

在这里，`foo_array()`比`foo_list()`几乎慢了五倍，差别很大。

之前，我答应过你展示一个基于调用的 API 比基于代码片段的 API 更有意义的例子。*这是这样一种情况*。注意，这次使用函数看起来比使用代码片段更自然，因为上面的代码片段只是调用函数。

这些函数带有一个参数，这使得使用基于可调用的 API 变得有点棘手。我们需要使用`lambda`，这是这个 API 的一个小缺点:

我们不需要使用`setup`，因为我们导入了`array`模块。当我们使用基于可调用的 API 时，我们在当前环境中运行基准，除非你通过改变`timeit.repeat()`的`globals`参数来影响它。因此，如果环境中有大量大对象，基准测试实际上可能会比几乎空无一物的环境中的性能更差。

你应该知道`timeit.repeat()`返回的值是什么。列表的长度等于`number`，每个值代表运行代码片段/callable 的`number`调用的总时间，以秒为单位。您可以计算运行代码段的平均时间；例如，`sum(results["array"]) / (number*repeat)`将给出调用`foo_array()`函数的平均次数，以秒为单位。

# 小心！

你要记住我之前提到的:`timeit`函数在同一个会话中一个接一个地运行同一个命令。这在处理可变对象时尤其重要，但不仅限于此。

让我们考虑一个例子。假设您想要将一个生成器表达式与相应的列表进行比较。比方说，您将在一个`for`循环中使用这两个项目，但是什么也不做——这样，您就可以比较使用这两种对象的开销。举个例子，

我们得到了生成器表达式的`0.016`和列表的`0.669`。这是一个惊人的结果！创建一个包含 100 个元素的列表比一个生成器表达式慢 42 倍？！

或者……是吗？

每当你看到如此疯狂的结果，请仔细检查代码。我并不是说这样的结果永远不会发生；而是您应该确保代码是正确的。

您发现代码中的问题了吗？如果没有，再分析一次。它有毛病。

问题是由使用发电机引起的。发电机只能用一次，然后就空了。所以，在这段代码中，它只迭代一次，然后就不再迭代了，原因很简单，因为它是空的。然而，该列表每次都会被迭代。

这就是为什么相应的代码片段花费这么多时间:在第一次调用期间，`for`循环只在`x_gen`上循环一次，然后由于`x_gen`为空，所以什么也不做。但是，对于列表，每次调用代码片段时，它都会循环遍历列表。因此有所不同。

我们可以用一种简单的方法来解决它，使用`timeit.repeat()`:我们可以使用`number=1`和一个很大的`repeat`值。这样，每个重复(会话)将实际上迭代生成器表达式，因为它将在每个后续会话中重新创建。

我将结果乘以`repeat`,因为否则它们会非常小，代表迭代一个`for`循环的时间。

现在我们用`15.400`表示生成器表达式，用`0.900`表示列表。这一次——当我们使用正确的方法时——列表比生成器表达式快 17 倍。

当您操作一个可变对象时，类似的情况也会发生:如果它在每次调用中都受到影响，那么下一次调用将使用这个对象的更新版本，而不是原始版本。因此，每个调用使用不同的对象。一个例子可以是基准测试`append`如何为列表工作。每次你添加一个条目到一个列表中，列表都会变长，所以后面的添加是不可比较的。玩这个来看看它是如何工作的，纯粹是为了基准测试的乐趣。

# **替代品**

Python 提供了各种时间基准替代方案。我想指出的其中三点是

*   `[cProfile](https://docs.python.org/3/library/profile.html)`，内置 Python profiler 对于任何重视性能的人来说，这是一个非常有用的工具；
*   `[perftester](https://github.com/nyggus/perftester)`，在执行时间和内存使用方面进行性能测试的包，它还提供了基准测试和分析工具；和
*   `[ycecream](https://github.com/salabim/ycecream)`，Python 代码甜蜜调试和基准测试的包。

# **结论**

`timeit`模块可能是测试代码最简单的方法。这是一个内置的解决方案，其 API 相对容易使用。我绝对推荐它，但是考虑用`timeit.repeat()`函数代替`timeit.timeit()`。

随着时间的推移，您会注意到，代码是否在每个细节上都进行了优化并不重要。例如，当代码持续 10 小时时，找到节省 10 毫秒的方法真的重要吗？有时这可能是有意义的，但是我们必须记住提高性能通常是有代价的，比如可读性更差的代码。

总结一下:

*   在关键时刻优化性能。否则，努力提高代码的可读性。
*   尝试在代码复杂性和性能之间找到正确的平衡。
*   代码优化需要时间。为了每月节省一秒钟，花 10 个小时优化代码值得吗？通常，答案是“视情况而定”，但是永远记得问自己(和团队中的其他人)这个问题。
*   `timeit`模块提供了基准执行时间的内置方法。它使用起来非常简单，但是您应该将它视为基准测试工具，而不是分析工具。
*   当你知道一个函数比另一个更快，可读性一样好，并且在代码中使用它不会花费更多的时间时，就使用它。在这种情况下，你究竟为什么要使用较慢的函数/方法呢？
*   如果你想学习各种错综复杂的 Python，`timeit`可以帮助很大。结合其他工具，它可以帮助您理解 Python 是如何工作的。
*   如果你想了解更多关于 Python 中的代码优化、概要分析和相关主题，Gorelick 和 Ozsvald 的书(2020)是你的朋友。

感谢阅读。我希望你喜欢这篇文章和`timeit`模块。如果您这样做了，请注意这并不是故事的结尾:在后面的文章中，我将讨论其他基准测试工具。

# 资源

*   [https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html)
*   [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)
*   [https://github.com/nyggus/perftester](https://github.com/nyggus/perftester)
*   [https://github.com/salabim/ycecream](https://github.com/salabim/ycecream)
*   Gorelick，m .，Ozsvald，I. (2020 年)。*高性能 Python:人类实用的高性能编程*。第二版。奥莱利媒体。