<html>
<head>
<title>Multi-threading and Multi-processing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多线程和多处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multithreading-multiprocessing-python-180d0975ab29#2022-01-21">https://towardsdatascience.com/multithreading-multiprocessing-python-180d0975ab29#2022-01-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""><h1 id="2d5b" class="pw-post-title is it iu bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">Python中的多线程和多处理</h1></div><div class=""><h2 id="7676" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">深入探讨Python中的多线程和多处理，以及它们与并发性和并行性的关系</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/920e8469f789ab18db786d7ac591badb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajSwGDgJm1hjaJSQKREOVw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">奥斯曼·拉纳在<a class="ae kz" href="https://unsplash.com/s/photos/lines?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="511f" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="83f9" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">线程和多处理是编程中两个最基本的概念。如果你已经写了一段时间的代码，你应该已经遇到过一些用例，在这些用例中，你想要在你的代码的某些部分中加速特定的操作。Python支持各种机制，使得各种任务能够(几乎)同时执行。</p><p id="776e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在本教程中，我们将理解<strong class="ly iv">多线程</strong>和<strong class="ly iv">多处理</strong>，并在实践中了解如何在Python中实现这些技术。我们还将根据应用程序是由<em class="mu"> I/O </em>还是<em class="mu"> CPU </em> <em class="mu">绑定</em>来讨论使用哪种技术。</p><p id="a37c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在讨论线程和多处理之前，理解这两个经常互换使用的术语很重要。<strong class="ly iv">并发</strong>和<strong class="ly iv">并行</strong>是密切<em class="mu">相关</em>但<em class="mu">截然不同的</em>概念。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="a08e" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">并发性和并行性</h2><p id="c5d9" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在许多情况下，我们可能需要加速代码库中的一些操作，以提高执行的性能。这通常可以通过并行或并发执行多个任务来实现(即，通过在多个任务之间交错)。您能否利用并发性或并行性实际上取决于您的代码，但也取决于运行它的机器。</p><p id="449c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在<strong class="ly iv">并发执行中，</strong>两个或多个任务可以在重叠的时间段内开始、执行和完成。因此，这些任务不一定要同时运行——它们只需要以重叠的方式取得进展。</p><blockquote class="nc"><p id="9e6a" class="nd ne iu bd nf ng nh ni nj nk nl mo dk translated">并发性:至少有两个线程正在进行的情况。一种更通用的并行形式，可以将时间片作为虚拟并行的一种形式。</p><p id="5bcc" class="nd ne iu bd nf ng nh ni nj nk nl mo dk translated">— <a class="ae kz" href="http://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html" rel="noopener ugc nofollow" target="_blank">孙的多线程编程指南</a></p></blockquote><p id="c769" class="pw-post-body-paragraph lw lx iu ly b lz nm jv mb mc nn jy me lj no mg mh ln np mj mk lr nq mm mn mo in bi translated">现在让我们考虑一个用例，我们有一台带有单核CPU的计算机。这意味着需要作为应用程序的一部分执行的任务不能在完全相同的时间进行，因为处理器一次只能处理一个任务。并发运行多个任务意味着处理器执行上下文切换，以便多个任务可以同时进行。</p><p id="ab86" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">并发性的主要目标之一是当其中一个任务被迫等待(比如等待来自外部资源的响应)时，通过来回切换来防止任务相互阻塞。例如，任务A进行到某个点时，CPU停止处理任务A，切换到任务B并开始处理一段时间，然后它可以切换回任务A完成它，最后返回到任务B，直到它也完成这个任务。</p><p id="e90a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">下图显示了一个由两个任务组成的应用，这两个任务在一个内核中同时执行。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/56e3150174b0eecdc36296f4a3fc1e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*0_KY5zM4OlYpEdxpMqjEmQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">并发执行—来源:作者</p></figure><p id="5c5f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">另一方面，在<strong class="ly iv">并行性</strong>中，多个任务(或者甚至一个任务的几个组件)<strong class="ly iv">实际上可以同时运行</strong>(例如，在一个多核处理器或者一台有多个CPU的机器上)。因此，在具有单个处理器和单核的机器上不可能有并行性。</p><blockquote class="nc"><p id="8089" class="nd ne iu bd nf ng nh ni nj nk nl mo dk translated">并行性:当至少两个线程同时执行时出现的情况。</p><p id="c4e1" class="nd ne iu bd nf ng nh ni nj nk nl mo dk translated">— <a class="ae kz" href="http://docs.oracle.com/cd/E19455-01/806-5257/6je9h032b/index.html" rel="noopener ugc nofollow" target="_blank">孙的多线程编程指南</a></p></blockquote><p id="ea99" class="pw-post-body-paragraph lw lx iu ly b lz nm jv mb mc nn jy me lj no mg mh ln np mj mk lr nq mm mn mo in bi translated">借助并行技术，我们能够最大限度地利用硬件资源。考虑一下我们有16个CPU内核的情况，启动多个进程或线程来利用所有这些内核可能比只依赖一个内核而其余15个内核处于空闲状态更明智。</p><p id="9c82" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在多核环境中，每个内核可以同时执行一项任务，如下图所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ns"><img src="../Images/b65643b4511207c7a6519fbf2d10ba8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*iuM9nenj01Tv-mfQ36c_1g.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">平行——来源:作者</p></figure><p id="a317" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">概括来说，并发性可以被视为系统或程序的<strong class="ly iv">属性</strong>，指的是单个CPU(内核)如何在看似<strong class="ly iv">的同时(即并发地)处理多个任务</strong>，而并行性是实际的<strong class="ly iv">运行时行为</strong>，即几乎同时并行执行至少两个任务。此外，需要强调的是<strong class="ly iv">在任务执行过程中，并发性和并行性可以结合在一起</strong>。事实上，我们可以有各种各样的组合；</p><ul class=""><li id="76de" class="nt nu iu ly b lz mp mc mq lj nv ln nw lr nx mo ny nz oa ob bi translated"><strong class="ly iv">既不并发，也不并行</strong>:这也称为<em class="mu">顺序</em> <strong class="ly iv"> </strong> <em class="mu">执行</em> <strong class="ly iv"> </strong>任务严格地一个接一个地执行。</li><li id="9415" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated"><strong class="ly iv">并发，但不并行</strong>:这意味着任务看似同时进行<em class="mu">但实际上系统在并发进行的各种任务之间切换，直到全部执行完毕。因此，没有真正的并行性，因此没有两个任务在完全相同的时间被执行。</em></li><li id="93e6" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated"><strong class="ly iv">并行，但不并发</strong>:这是一个相当罕见的场景，在任何给定的时间只有一个任务被执行，但任务本身被分解成并行处理的子任务。但是，每一个任务都必须在下一个任务被拾取和执行之前完成。</li><li id="0463" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated"><strong class="ly iv">并发和并行</strong>:这可能以两种方式发生；第一种是简单的并行和并发执行，应用程序启动多个线程在多个CPU和/或内核上执行。实现这一点的第二种方式是当应用程序能够同时处理多个任务，但同时它也将每个单独的任务分解成子任务，以便这些子任务最终可以并行执行。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nr"><img src="../Images/e7139b9e1e790c3b086ba9c3dd176ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*dNdE7O8exRHD0NKnq3eWJQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">并行与并发——来源:作者</p></figure><p id="c1fe" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，我们已经对并发和并行的工作原理有了基本的了解，让我们使用Python中的一些例子来探索多处理和多线程。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="1474" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python中的线程</h2><p id="338a" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">线程是在进程上下文中执行的一系列指令。一个进程可以产生多个线程，但是所有的线程都将共享相同的内存。</p><p id="a415" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">当在Python中对CPU受限的任务进行多线程实验时，您最终会注意到执行并没有得到优化，甚至在使用多线程时会运行得更慢。通常，在多核机器上使用多线程代码应该能够充分利用可用的内核，从而提高整体性能。</p><p id="78c1" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">事实上，Python进程不能并行运行线程，但它可以在I/O绑定操作期间通过上下文切换来并发运行它们。</strong></p><p id="02f2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这一限制实际上是由GIL实施的。Python全局解释器锁 (GIL)防止同一进程中的线程同时执行。</p><blockquote class="nc"><p id="06b9" class="nd ne iu bd nf ng nh ni nj nk nl mo dk translated">GIL是一个互斥体，保护对Python对象的访问，防止多个线程同时执行Python字节码— <a class="ae kz" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"> Python Wiki </a></p></blockquote><p id="e291" class="pw-post-body-paragraph lw lx iu ly b lz nm jv mb mc nn jy me lj no mg mh ln np mj mk lr nq mm mn mo in bi translated">GIL是必要的，因为Python的解释器<strong class="ly iv">不是线程安全的</strong>。每当我们试图访问线程中的Python对象时，这个全局锁就会被强制执行。在任何给定时间，只有一个线程可以获取特定对象的锁。因此，受CPU限制的代码不会因为Python多线程而获得性能提升。</p><blockquote class="oh oi oj"><p id="c474" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated"><strong class="ly iv"> CPython实现细节:</strong></p><p id="d3e9" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated">在CPython中，由于<a class="ae kz" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>，一次只有一个线程可以执行Python代码(尽管某些面向性能的库可能会克服这一限制)。</p><p id="0e95" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated">如果你想让你的应用更好的利用多核机器的计算资源，建议你使用<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank"><em class="iu">multiprocessing</em></a></code>或者<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="iu">concurrent.futures.ProcessPoolExecutor</em></a></code>。</p><p id="d2d6" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated">- <a class="ae kz" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></blockquote><p id="9756" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">您可以在我最近的一篇文章中<a class="ae kz" rel="noopener" target="_blank" href="/python-gil-e63f18a08c65">阅读更多关于Python的全局解释器锁的内容，但是现在提供的信息应该足以理解全局解释器锁如何限制Python中多线程应用程序的能力(以及潜在的为什么它是“必需的”)。</a></p><p id="496a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，我们已经了解了Python中多线程应用程序的工作原理，让我们编写一些代码并利用这一技术。</p><p id="b65e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在Python中，线程可以通过使用<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank"><strong class="ly iv">threading</strong></a></code>模块来实现。现在让我们考虑一个用于下载图像的函数——这显然是一个I/O绑定的任务:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">示例CPU绑定函数—来源:作者</p></figure><p id="f190" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">然后，让我们尝试使用下面的代码片段从Unsplash下载一些图像。请注意，为了更清楚地展示线程化的效果，我们有意尝试下载这些图像5次(参见<code class="fe on oo op oq b">for</code>循环):</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Python从Unsplash下载图像(I/O绑定任务)—来源:作者</p></figure><p id="b686" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">因此，我们的小应用程序运行良好，但我们肯定可以做得更好，并通过利用线程优化代码(不要忘记，下载多个图像是一个I/O绑定的任务)。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从带线程的Unsplash下载图像—来源:作者</p></figure><p id="12e8" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">概括地说，Python中的线程化允许在单个进程中创建多个线程，但是由于GIL，它们不会完全同时运行。<strong class="ly iv">在并发运行多个I/O绑定任务时，线程仍然是一个非常好的选择</strong>。现在，如果您想要利用多核机器上的计算资源，那么多处理是一条可行之路。</p><p id="6e1b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">您还应该注意到，线程化伴随着与管理线程相关的开销，因此您应该避免将它们用于基本任务。此外，它们还增加了程序的复杂性，这意味着调试可能会变得有点棘手。因此，只有在有明确价值时才使用线程。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="78b8" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python中的多重处理</h2><p id="ce8e" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">现在，如果我们想要利用多核系统并最终在真正并行的环境中运行任务，我们需要执行多处理而不是多线程。</p><p id="bdcc" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在Python中，可以使用<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"><strong class="ly iv">multiprocessing</strong></a></code>模块(<em class="mu">或</em> <code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank"><em class="mu">concurrent.futures.ProcessPoolExecutor</em></a></code>)来实现多处理，该模块可用于生成多个操作系统进程。因此，Python中的<strong class="ly iv">多重处理避开了GIL </strong>和由此产生的限制，因为现在每个进程都有自己的解释器，从而拥有自己的GIL。</p><blockquote class="oh oi oj"><p id="48b5" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated"><code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank"><em class="iu">multiprocessing</em></a></code>是一个支持使用类似于<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/threading.html#module-threading" rel="noopener ugc nofollow" target="_blank"><em class="iu">threading</em></a></code>模块的API来生成进程的包。</p><p id="070e" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated"><code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank"><em class="iu">multiprocessing</em></a></code>包提供了本地和远程并发，通过使用子进程而不是线程，有效地避开了<a class="ae kz" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>。</p><p id="ade1" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated">因此，<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank"><em class="iu">multiprocessing</em></a></code>模块允许程序员充分利用给定机器上的多个处理器。它可以在Unix和Windows上运行。</p><p id="baf9" class="lw lx mu ly b lz mp jv mb mc mq jy me ok mr mg mh ol ms mj mk om mt mm mn mo in bi translated">- <a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank"> Python文档</a></p></blockquote><p id="401a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在上一节中，我们讨论了线程化，我们看到线程化根本不能改善CPU受限的任务。这可以通过使用多重处理来实现。让我们使用与前一节相同的函数<code class="fe on oo op oq b">append_to_list()</code>，但这次我们将使用<code class="fe on oo op oq b">multiprocessing</code>而不是<code class="fe on oo op oq b">threading</code>，以便利用我们的多核机器。</p><p id="eb50" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们<strong class="ly iv">考虑一个CPU受限的操作</strong>，它涉及一个将多个随机整数追加到一个列表中的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">受CPU限制的任务——来源:作者</p></figure><p id="9172" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们假设我们想要运行这个函数两次，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">没有多重处理的CPU受限任务——来源:作者</p></figure><p id="417f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">让我们<code class="fe on oo op oq b">time</code>这个执行并检查结果。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="2b81" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们稍微重构一下我们的代码，现在使用两个不同的进程，以便每个函数调用都在它自己的进程中执行:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">CPU受限任务的多重处理——来源:作者</p></figure><p id="d8cd" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">最后让我们来看一下<code class="fe on oo op oq b">time</code>以及执行和检查结果:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="1c66" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">我们可以清楚地看到(尽管<code class="fe on oo op oq b">user</code>和<code class="fe on oo op oq b">sys</code>时间保持大致相同)，但是<code class="fe on oo op oq b">real</code>时间下降了一倍，甚至比两倍还多(这是意料之中的，因为我们实际上将负载分配给了两个不同的进程，以便它们可以并行运行)。</p><p id="f684" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">总的来说，当我们需要利用多核系统的计算能力时，可以使用Python中的多处理。事实上，多处理模块允许您在<strong class="ly iv">并行</strong>中运行多个任务和进程。与线程相比，<code class="fe on oo op oq b">multiprocessing</code>通过使用子进程而不是线程来避开GIL，因此多个进程可以同时运行。这种技术最适合CPU密集型任务。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="9820" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="e7f5" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们介绍了编程中的两个最基本的概念，即并发性和并行性，以及它们在执行时如何区别甚至组合。此外，我们还讨论了线程和多处理，探讨了它们的主要优点和缺点，以及一些最终可以帮助您了解何时使用其中一个的用例。最后，我们展示了如何用Python实现线程或多处理应用程序。</p><p id="ab17" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">概括一下，</p><p id="ca9a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">穿线</strong></p><ul class=""><li id="3e3e" class="nt nu iu ly b lz mp mc mq lj nv ln nw lr nx mo ny nz oa ob bi translated">线程共享相同的内存，可以读写共享的变量</li><li id="9260" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">由于Python全局解释器锁，两个线程不会同时执行，而是并发执行(例如上下文切换)</li><li id="979f" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">对受I/O限制的任务有效</li><li id="dc90" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">可以用<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/threading.html#module-threading" rel="noopener ugc nofollow" target="_blank">threading</a></code>模块实现</li></ul><p id="2346" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">多处理</strong></p><ul class=""><li id="beaa" class="nt nu iu ly b lz mp mc mq lj nv ln nw lr nx mo ny nz oa ob bi translated">每个进程都有自己的内存空间</li><li id="9289" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">每个进程可以包含一个或多个子进程/线程</li><li id="2f88" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">由于进程可以在不同的CPU内核上运行，因此可以通过利用多核机器来实现并行性</li><li id="e888" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">对CPU受限的任务有效</li><li id="7eed" class="nt nu iu ly b lz oc mc od lj oe ln of lr og mo ny nz oa ob bi translated">可以用<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code> <em class="mu"> </em>模块(或<code class="fe on oo op oq b"><a class="ae kz" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank">concurrent.futures.ProcessPoolExecutor</a></code>)实现</li></ul></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><p id="3a31" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="ot ou gq gs ov ow"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kt ow"/></div></div></a></div></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="ot ou gq gs ov ow"><a rel="noopener follow" target="_blank" href="/python-gil-e63f18a08c65"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">什么是Python全局解释器锁(GIL)？</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">理解Python中全局解释器锁的用途以及它如何影响多线程</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk kt ow"/></div></div></a></div></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ow"><a rel="noopener follow" target="_blank" href="/augmented-assignments-python-caa4990811a0"><div class="ox ab fp"><div class="oy ab oz cl cj pa"><h2 class="bd iv gz z fq pb fs ft pc fv fx it bi translated">Python中的扩充赋值</h2><div class="pd l"><h3 class="bd b gz z fq pb fs ft pc fv fx dk translated">了解增强赋值表达式在Python中的工作方式，以及为什么在使用它们时要小心…</h3></div><div class="pe l"><p class="bd b dl z fq pb fs ft pc fv fx dk translated">towardsdatascience.com</p></div></div><div class="pf l"><div class="pm l ph pi pj pf pk kt ow"/></div></div></a></div></div></div>    
</body>
</html>