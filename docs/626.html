<html>
<head>
<title>The Power of SQL Aggregate Window Functions with Disney Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迪士尼数据的SQL聚合窗口函数的强大功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-power-of-sql-aggregate-window-functions-with-disney-data-9c92ebbf2540#2022-01-21">https://towardsdatascience.com/the-power-of-sql-aggregate-window-functions-with-disney-data-9c92ebbf2540#2022-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="be60" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">迪士尼数据的SQL聚合窗口函数的强大功能</h1></div><p id="5dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AVG()，计数()，最大值()，最小值()，总和()</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9206a04ddea6207da95f8deafaf61b1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQhWPihAjrLN5ecUbJ1bZQ.jpeg"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">Travis Gergen在Unsplash上拍摄的照片</p></figure><p id="6a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">窗口函数允许我们在每一行上执行操作并显示结果，这与基于查询组合多行的普通SQL操作相反。普通的SQL聚合函数对于将多行分解成解决方案是必不可少的。例如，这些函数可以显示多行的平均值并输出单个数值，或者显示一组行中的实例数。在聚合窗口函数中，我们可以将这个聚合结果应用于数据的每一行。这使我们能够轻松地创建有用且高效的结果，例如累积和、特定行输出与所有行平均值的比较。</p><p id="4972" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">五种类型的聚合窗口函数是:</p><ul class=""><li id="d001" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">AVG()</li><li id="10a5" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">计数()</li><li id="c981" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">最大()</li><li id="5841" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">最小值()</li><li id="3c79" class="lb lc iq jp b jq lk ju ll jy lm kc ln kg lo kk lg lh li lj bi translated">总和()</li></ul><p id="2f2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们进入每个聚合窗口函数的细节之前，我们应该看看这些函数通常是如何写出的:</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="8434" class="lu lv iq lq b gy lw lx l ly lz">[Aggregate Function]([column]) OVER([specific operation] column_name)</span></pre><p id="bd8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，一个示例SQL命令如下所示:</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="d30c" class="lu lv iq lq b gy lw lx l ly lz">SELECT *, SUM(column_x) OVER(PARTITION BY column_y ORDER BY column_z)<br/>FROM table</span></pre><p id="5f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*请注意，x、y和z列可以相同，也可以不同*</p><p id="56b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">数据:<br/> </strong>本文中使用的数据最初由Rashik Rahman发布到Kaggle，授权为CC0: Public Domain。拉西克的Kaggle个人资料的链接可以在这里找到(<a class="ae ma" href="https://www.kaggle.com/rashikrahmanpritom/disney-movies-19372016-total-gross" rel="noopener ugc nofollow" target="_blank">这里</a>)。该数据由1937年至2016年的迪士尼电影组成，并显示以下变量名称:电影名称、电影上映日期、类型、mpaa评级、总票房和通货膨胀调整后的票房。出于本文的目的，我将主要使用“标题”、“发行日期”、“流派”和“总收入”。此外，我将重点关注2015年上映的电影，以简化结果输出。数据示例如下:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/b7f6cd85ed3a616abfd6fe28537cb6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUwZx-PXkksuoqAFrrFGKw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="ad23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*这些数据将仅用于演示我们的聚合窗口函数，不应被视为这些电影的完整和准确的来源。</p><p id="d6ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">基本用例:<br/> </strong>如前所述，聚合窗口函数的工作方式与普通聚合函数相同，但它不提供合并输出，而是将输出反映在表中的每一行上。例如，AVG()窗口函数完全按照您的预期工作，它创建给定分区中值的平均值，并将该值输出到数据的每一行。下面的SQL代码演示了这一点:</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="3d2f" class="lu lv iq lq b gy lw lx l ly lz">SELECT title, genre, total_gross, <br/>ROUND(AVG(total_gross) OVER(PARTITION BY genre),0) as average <br/>FROM disney<br/>WHERE release_date &gt;= '2015-01-01' AND release_date &lt; '2016-01-01'</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mc"><img src="../Images/ea93230908cb492a17046c4e624ae99c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94h4WOQxNb21FiVgGq0TZQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="8ab7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">新的“平均”栏按类型划分，显示了每种类型的平均总票房收入。使用相同的概念和实践，我们可以使用所有五个聚合函数运行相似的指标。</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="71d8" class="lu lv iq lq b gy lw lx l ly lz">SELECT title, genre, total_gross, <br/>ROUND(AVG(total_gross) OVER(PARTITION BY genre),0) as average,<br/>ROUND(COUNT(*) OVER(PARTITION BY genre),0) as total_count,<br/>ROUND(MAX(total_gross) OVER(PARTITION BY genre),0) as max_gross,<br/>ROUND(MIN(total_gross) OVER(PARTITION BY genre),0) as min_gross,<br/>ROUND(SUM(total_gross) OVER(PARTITION BY genre),0) as total_sum<br/>FROM disney<br/>WHERE release_date &gt;= '2015-01-01' AND release_date &lt; '2016-01-01'</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi md"><img src="../Images/239e7ca10118ac9b49452de35c580dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QibosIQC30lOv6XCxtbgag.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="5641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们看到了所使用的每个聚合函数及其输出。虽然获得这些信息会有所帮助，但是这种类型的操作也可以在没有窗口函数的情况下完成，而是使用连接到原始数据集的普通聚合嵌套查询来完成。下面是AVG()函数的一个例子:</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="68ea" class="lu lv iq lq b gy lw lx l ly lz">SELECT title, d.genre, total_gross, ROUND(average,0)<br/>FROM disney d LEFT JOIN </span><span id="5ab4" class="lu lv iq lq b gy me lx l ly lz">(SELECT genre, AVG(total_gross) as average <br/> FROM disney<br/> WHERE release_date &gt;= '2015-01-01' AND release_date &lt; '2016-01-01'<br/> GROUP BY genre) a</span><span id="03d4" class="lu lv iq lq b gy me lx l ly lz">ON d.genre = a.genre</span><span id="61ab" class="lu lv iq lq b gy me lx l ly lz">WHERE release_date &gt;= '2015-01-01' AND release_date &lt; '2016-01-01'<br/>ORDER BY genre</span></pre><p id="150d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述代码块的结果与我们的窗口函数完全相同，但是上述代码块需要一个更复杂的语句。</p><p id="de75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">累积案例:</strong> <br/>在我看来，这些聚合窗函数最大的好处就是当它们被用来寻找累积值的时候。要对现有的代码块进行这种更改，我们需要做的就是在OVER()语句中添加ORDER BY子句。能够在几个步骤中添加累积值有助于为这些聚合窗口函数增加巨大的力量。下面是一个使用SUM()函数的例子。</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="c329" class="lu lv iq lq b gy lw lx l ly lz">SELECT title, genre, total_gross, <br/>ROUND(SUM(total_gross) OVER(PARTITION BY genre ORDER BY release_date),0) as cumulative_sum<br/>FROM disney<br/>WHERE release_date &gt;= '2015-01-01' AND release_date &lt; '2016-01-01'</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/d741f926e4943ca2ca89845ec2d4b1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*87fYbly2zVv8lLWXhJNt6w.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="33e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们看到了每个分区的total_gross列的累积方面。我们可以使用下面的代码块将同样的方法应用于所有函数:</p><pre class="km kn ko kp gt lp lq lr ls aw lt bi"><span id="5ad1" class="lu lv iq lq b gy lw lx l ly lz">SELECT title, genre, total_gross, </span><span id="a51c" class="lu lv iq lq b gy me lx l ly lz">ROUND(AVG(total_gross) OVER(PARTITION BY genre ORDER BY release_date),0) as cumulative_average,</span><span id="b9c0" class="lu lv iq lq b gy me lx l ly lz">ROUND(COUNT(*) OVER(PARTITION BY genre ORDER BY release_date),0) as cumulative_count,</span><span id="ebf9" class="lu lv iq lq b gy me lx l ly lz">ROUND(MAX(total_gross) OVER(PARTITION BY genre ORDER BY release_date),0) as max_gross,</span><span id="ebee" class="lu lv iq lq b gy me lx l ly lz">ROUND(MIN(total_gross) OVER(PARTITION BY genre ORDER BY release_date),0) as min_gross,</span><span id="d42e" class="lu lv iq lq b gy me lx l ly lz">ROUND(SUM(total_gross) OVER(PARTITION BY genre ORDER BY release_date),0) as cumulative_sum</span><span id="d1d8" class="lu lv iq lq b gy me lx l ly lz">FROM disney<br/>WHERE release_date &gt;= '2015-01-01' AND release_date &lt; '2016-01-01'</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/e2c77091108be89dad7b78efefb5fc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*84G6x-_5H8AzQnep51t0tQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure><p id="79c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">利用这些函数的累积特性，我们现在可以看到一些有趣的结果。以“动作片”为例，我们可以看到，第一部《复仇者联盟:奥创时代》上映后，平均票房为4.59亿美元，而在《蚁人》上映后，平均票房降至3.2亿美元。cumulative_count列只是计算行数并显示结果。我们看到两部电影的max_gross栏都保持在4.59亿美元，因为第一部电影的票房比第二部高，相反，当我们看min_gross时，我们看到它从4.59亿美元开始，然后在《蚁人》上映后下降到1.8亿美元。最后，cumulative_sum的工作方式和我们之前解释的一样，在分区中添加每部电影的total_gross。</p><p id="32a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">结论:</strong> <br/>使用聚合窗口函数可以帮助我们创建有用的信息指标，同时还可以帮助我们节省编写查询的时间。聚合窗口函数只是窗口函数的一个分支，你可以在这里找到我之前关于窗口函数排名的文章<a class="ae ma" rel="noopener" target="_blank" href="/sql-ranking-window-function-guide-b9aee35d5931"/>。感谢您花时间阅读本文，更多数据科学相关内容请关注我！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mh"><img src="../Images/6a6957934b8c106022f12d769ea5eace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dn-O5uEEscV_OgzZvlIWTw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">作者图片</p></figure></div></div>    
</body>
</html>