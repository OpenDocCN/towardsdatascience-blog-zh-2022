<html>
<head>
<title>Profiling and Analyzing Performance of Python Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析和分析Python程序的性能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/profiling-and-analyzing-performance-of-python-programs-3bf3b41acd16#2022-01-04">https://towardsdatascience.com/profiling-and-analyzing-performance-of-python-programs-3bf3b41acd16#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="11d8" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">剖析和分析Python程序的性能</h1></div><div class=""><h2 id="14e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">快速找到Python程序中的所有瓶颈并修复它们的工具和技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eafb7d4ffcb55298615ce8b7d4717161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqGEcRBs4piwURDLlhWykA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@alexas_fotos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alexas_Fotos </a>拍摄的照片</p></figure><p id="f97d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析对于任何代码和性能优化都是不可或缺的。如果不知道在哪里应用，您可能已经拥有的任何性能优化经验和技能都不会非常有用。因此，找到应用程序中的瓶颈可以帮助您快速解决性能问题，而不需要花费太多精力。</p><p id="7522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨一些工具和技术，它们可以帮助我们缩小关注范围，找到CPU和内存消耗的瓶颈，以及如何在即使目标明确的代码更改也无济于事的情况下，实现简单(几乎不费力气)的性能问题解决方案。</p><h1 id="baf6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">识别瓶颈</h1><p id="f1dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">性能优化的时候偷懒是好事。我们不需要试图找出代码库的哪一部分使应用程序变慢，我们可以使用分析工具来找到需要注意或进一步挖掘的地方。</p><p id="8e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python开发人员最常用的工具是<code class="fe ms mt mu mv b">cProfile</code>。它是一个内置模块，可以测量代码中每个函数的执行时间。</p><p id="0c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑下面这个(缓慢地)计算<code class="fe ms mt mu mv b">e</code>的<code class="fe ms mt mu mv b">X</code>次方的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们针对上面缓慢的代码运行<code class="fe ms mt mu mv b">cProfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c49b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用<code class="fe ms mt mu mv b">-s cumulative</code>按照每个函数的累积时间对输出进行排序，这样更容易找到输出中有问题的代码区域。我们可以看到，在单次调用期间，几乎所有的时间(~2.764秒)都花在了<code class="fe ms mt mu mv b">exp</code>函数上。</p><p id="ef39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种剖析可能是有用的，但不幸的是可能并不总是足够的。<code class="fe ms mt mu mv b">cProfile</code>只给出关于函数调用的信息，而不是关于单个代码行的信息——如果你在不同的地方调用某个特定的函数，比如<code class="fe ms mt mu mv b">append</code>,那么它将在<code class="fe ms mt mu mv b">cProfile</code>输出中全部聚集成一行。我们上面使用的脚本也是一样——它包含一个只被调用一次的函数，所以没有什么需要<code class="fe ms mt mu mv b">cProfile</code>报告的。</p><p id="8a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，我们没有能力在本地分析这些麻烦的代码，或者当生产环境中出现性能问题时，我们可能需要即时分析。在这些情况下，我们可以利用<code class="fe ms mt mu mv b">py-spy</code>,它是一个分析器，可以检查已经运行的程序，例如生产环境或任何远程系统中的应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="521d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们首先安装<code class="fe ms mt mu mv b">py-spy</code>，然后在后台运行我们长期运行的Python程序。这将自动显示PID号，但是如果我们不知道，那么我们可以使用<code class="fe ms mt mu mv b">ps</code>命令来查找。最后，我们在PID中传递的<code class="fe ms mt mu mv b">top</code>模式下运行<code class="fe ms mt mu mv b">py-spy</code>。这将产生终端视图，模拟Linux <code class="fe ms mt mu mv b">top</code>实用程序的自动更新输出，类似于下面的截图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/92924fff6df6d4e7c1dd4c1805bcbd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ClpkMZ20eQPgRwtu8TEtLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">py-间谍上衣</p></figure><p id="447e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上并没有给我们提供太多的信息，因为这个脚本只有一个长期运行的函数，但是在真实的场景中，您很可能会看到许多函数共享CPU时间，这可能有助于了解程序正在发生的性能问题。</p><h1 id="16b0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">深入挖掘</h1><p id="1100" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上面的分析器应该可以帮助您找到导致性能问题的函数，但是如果这还不足以缩小关注范围，让您知道应该修复什么，那么我们可以转向在更细粒度级别上运行的分析器。</p><p id="58f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是<code class="fe ms mt mu mv b">line_profiler</code>,顾名思义，它可以用来深入了解每一行代码所花费的时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ac4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">line_profiler</code>库与<code class="fe ms mt mu mv b">kernprof</code> CLI(以Robert Kern命名)一起发布，用于有效地分析测试运行的结果。通过对我们的代码运行这个实用程序，我们产生一个带有代码分析的<code class="fe ms mt mu mv b">.lprof</code>文件以及上面的输出(当使用<code class="fe ms mt mu mv b">-v</code>时)。这个输出清楚地显示了我们在函数中花费时间最多的地方，这对于发现和修复性能问题非常有帮助。在输出中，您还会注意到<code class="fe ms mt mu mv b">@profile</code>装饰器被添加到了<code class="fe ms mt mu mv b">exp</code>函数中——这是必要的，以便<code class="fe ms mt mu mv b">line_profiler</code>知道我们想要分析文件中的哪个函数。</p><p id="f74b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在逐行运行分析时，也可能不清楚性能问题的罪魁祸首是什么。这样的例子可以是由多个表达式组成的<code class="fe ms mt mu mv b">while</code>或<code class="fe ms mt mu mv b">if</code>条件。在这种情况下，将特定行重写为多行以获得更全面的分析结果是有意义的。</p><p id="6f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你真的是一个懒惰的开发者(像我一样)，并且阅读CLI文本输出太难了，那么另一个选择是使用<code class="fe ms mt mu mv b">pyheat</code>。这是一个基于<code class="fe ms mt mu mv b">pprofile</code>的分析器——另一个受<code class="fe ms mt mu mv b">line_profiler</code>启发的逐行分析器——它生成一个占用最多时间的代码行/区域的热图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7f221e6a6eba01a3d791d255e0c1574e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*ug-tXe6M_2zp16682UMMEw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pyheat热图</p></figure><p id="46c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到我们使用的示例代码的简单性，前面的<code class="fe ms mt mu mv b">kernprof</code>的CLI输出已经很清楚了，但是上面的热图使得函数中的瓶颈更加明显。</p><p id="6bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经讨论了CPU概要，但是CPU的使用可能并不总是我们所关心的。RAM很便宜，所以我们通常不会考虑它的用途，至少在用完之前不会。</p><p id="625f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使您没有耗尽RAM，分析您的应用程序的内存使用情况仍然是有意义的，这样可以发现您是否可以优化代码以节省内存，或者您是否可以添加更多的内存来提高代码的性能。为了分析内存使用情况，我们可以使用名为<code class="fe ms mt mu mv b">memory_profiler</code>的工具，它模拟了前面显示的<code class="fe ms mt mu mv b">line_profiler</code>的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个测试，我们选择了一段稍微不同的代码。<code class="fe ms mt mu mv b">memory_intensive</code>函数创建和删除大型Python列表，以清楚地展示<code class="fe ms mt mu mv b">memory_profiler</code>如何有助于分析内存使用。与<code class="fe ms mt mu mv b">kernprof</code>分析一样，这里我们也必须添加<code class="fe ms mt mu mv b">@profile</code>在文本下运行，以便<code class="fe ms mt mu mv b">memory_profiler</code>识别我们想要分析的代码部分。</p><p id="2db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明，仅仅为了一个简单的<code class="fe ms mt mu mv b">None</code>值列表，就分配了100多MB。但是请记住，这个输出并没有显示内存的真实使用情况，而是显示了每行上的函数调用分配了多少内存。在这种情况下，这意味着列表变量实际上并没有存储那么多内存，只是Python <code class="fe ms mt mu mv b">list</code>可能会过度分配内存来适应变量的预期增长。</p><p id="a2dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们从上面看到的，Python列表经常会消耗数百兆甚至数千兆字节的内存，一个快速的优化方法是切换到普通的<code class="fe ms mt mu mv b">array</code>对象，这样可以更有效地存储原始数据类型，比如<code class="fe ms mt mu mv b">int</code>或<code class="fe ms mt mu mv b">float</code>。此外，您还可以通过使用<code class="fe ms mt mu mv b">typecode</code>参数选择较低精度类型来限制内存使用，使用<code class="fe ms mt mu mv b">help(array)</code>查看有效选项及其大小的表格。</p><p id="2a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些更具体、更细粒度的工具还不足以找到代码中的瓶颈，那么您可以尝试反汇编它，看看Python解释器使用的实际字节码。即使反汇编不能帮助您解决手头的问题，它仍然有助于您更好地了解和理解每次调用某个特定函数时Python在后台执行了哪些操作。记住这些事实可能有助于您将来编写更高性能的代码。</p><p id="780d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将函数/代码/模块传递给<code class="fe ms mt mu mv b">dis.dis(...)</code>，可以使用内置的<code class="fe ms mt mu mv b">dis</code>模块生成代码反汇编。这将生成并打印该函数执行的字节码指令列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ea12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在整篇文章中，我们一直在使用非常慢的<code class="fe ms mt mu mv b">e</code>到<code class="fe ms mt mu mv b">X</code>的幂的实现，所以我们在上面定义了快速实现的平凡函数，这样我们就可以比较它们的反汇编。试图把它们都拆开，会产生完全不同的输出，这就更加明显地说明了为什么一个要比另一个慢得多。</p><p id="03b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最快的一个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9f84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">旧的，缓慢的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="757d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解上面的输出中实际发生了什么，我推荐阅读<a class="ae ky" href="https://stackoverflow.com/a/47529318" rel="noopener ugc nofollow" target="_blank"> this StackOverflow answer </a>，它解释了输出中的所有列。</p><h1 id="9dfa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解决方案</h1><p id="b18d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在某种程度上，对你的代码和算法做额外的调整将开始提供递减的回报。此时，将注意力转向外部工具来提供一些额外的性能提升是一个好主意。</p><p id="7bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提高代码速度的一个可靠方法是将其编译成c语言，这可以使用各种工具来完成，例如PyPy或Cython。前者是一个JIT(实时)编译器，可以用来替代CPython。它可以不费吹灰之力提供显著的性能提升，让您轻松、快速地赢得胜利。您需要做的就是下载归档文件，解压并运行您的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="05cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了向您证明我们不费吹灰之力就能获得立竿见影的性能提升，让我们用CPython和PyPy快速检查一下脚本的运行时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了上面提到的好处，PyPy还不需要对代码做任何修改，并且支持所有内置模块和函数。</p><p id="afc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很神奇，但是使用PyPy也有一些利弊。它支持需要C绑定的项目，比如<code class="fe ms mt mu mv b">numpy</code>，但是这会产生很大的开销，使得库明显变慢，实际上抵消了任何其他的性能提升。在使用外部库或与数据库交互的情况下，它也不能解决性能问题。同样，你也不能指望I/O相关的程序有很大的性能提升。</p><p id="aa39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果PyPy没有成功，那么您可以尝试使用cy thon——一种使用类似C的类型注释(<em class="na">而不是</em> Python类型提示)来创建编译后的Python扩展模块的编译器。Cython还使用AOT(提前)编译，这可以通过避免应用程序<em class="na">冷启动</em>来带来更大的性能增益。然而，使用它需要您重写代码以使用Cython语法，这反过来增加了代码的复杂性。</p><p id="3697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不介意切换到Python稍微不同的语法，那么你可能也想看看<a class="ae ky" href="https://github.com/zanellia/prometeo" rel="noopener ugc nofollow" target="_blank">prometeo</a>——一种基于Python的嵌入式领域特定语言，专门针对科学计算。Prometeo程序可转换为纯C代码，其性能可与手写C代码相媲美。</p><p id="7891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果上述解决方案都不能满足性能要求，那么您可能需要用C或Fortran编写优化的代码，并使用外部函数接口(FFI)从Python中调用代码。可以帮助你的库的例子是C代码的<code class="fe ms mt mu mv b">ctypes</code>或<code class="fe ms mt mu mv b">cffi</code>和Fortran的<code class="fe ms mt mu mv b">f2py</code>。</p><h1 id="0174" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="6e0b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">优化的第一条规则是<em class="na">不做</em>。如果你真的必须这么做，那么就在适当的地方进行优化。使用上面的分析工具来寻找瓶颈，这样你就不会浪费时间去优化一些无关紧要的代码。为您试图优化的代码创建一个<em class="na">可重复的</em>基准也是有用的，这样您就可以测量实际的改进。</p><p id="2e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将帮助您找到性能问题的根源。然而，解决这个问题是完全不同的话题，在我以前的文章<a class="ae ky" rel="noopener" target="_blank" href="/making-python-programs-blazingly-fast-c1cd79bd1b32">让Python程序快得惊人</a>中可以找到一些让你的Python代码明显更快的简单方法。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="7301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/64?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_64" rel="noopener ugc nofollow" target="_blank"><em class="na">martinheinz . dev</em></a></p><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/speeding-up-container-image-builds-with-remote-cache-c72577317886"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">使用远程缓存加速容器映像构建</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">使用这些缓存技术可以轻松地优化CI/CD管道中的容器映像构建</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/the-unknown-features-of-pythons-operator-module-1ad9075d9536"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">Python的运算符模块的未知特性</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">借助Python鲜为人知的操作符模块，使您的代码更快、更简洁、可读性更强、功能更强大</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz ks nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/functools-the-power-of-higher-order-functions-in-python-8e6e61c6e4e4"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">func tools——Python中高阶函数的威力</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">浏览Python的functools模块，了解如何使用它的高阶函数来实现缓存…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="ob l nw nx ny nu nz ks nl"/></div></div></a></div></div></div>    
</body>
</html>