<html>
<head>
<title>Tackling the Take-Home Challenge</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应对带回家的挑战</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tackling-the-take-home-challenge-7c2148fb999e#2022-01-25">https://towardsdatascience.com/tackling-the-take-home-challenge-7c2148fb999e#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="0bf4" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">应对带回家的挑战</h1></div><div class=""><h2 id="bb36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python和Jupyter笔记本电脑的EDA挑战示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0950c9376c0aa421e370f1167a42048e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NjJ0bxRPFWJm-uYRiyNJ1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/ZTcfIKLmMKM" rel="noopener ugc nofollow" target="_blank">照片</a>由Elisa Ventur通过Unsplash拍摄</p></figure><p id="d496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个流行的数据职位的家庭作业包括探索性数据分析或EDA。给你一个或三个数据集，让你分析这些数据。</p><p id="e7c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一家公司可能会给你这种任务，以洞察你的思维过程。他们想看看你如何处理一个新的数据集，当然也想确保你具备他们所需的技术技能。</p><p id="38ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然开放式挑战可以让你展示自己的优势和创造力，但却很难知道从哪里开始。</p><p id="6228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们经常说你可以使用任何你喜欢的技术。使用一种你熟悉的语言，并且你面试的公司也在使用这种语言，这是有意义的。</p><p id="1188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何时候我都可以选择使用Python和Jupyter笔记本。</p><p id="a7e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jupyter笔记本可以让您轻松展示自己的思考过程，并以一种易于呈现的格式记录您的过程。</p><p id="b82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要记住的重要一点是，如果公司决定继续进行，成功完成带回家的挑战之后通常会讨论你的工作。重要的是能够解释你的思维过程，并且在后续的采访中能够自如地谈论你的代码。</p><p id="0af6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将完成一个带回家的挑战示例。</p><h1 id="f91e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">挑战</h1><p id="32b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个挑战中，公司给了我们一个非常开放的任务:探索一些数据。</p><p id="151f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然获得一个灵活的任务是一个突出我们优势的好方法，也许可以避免我们的弱点，但是没有明确的目标开始也是一个挑战。</p><p id="389d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在这里使用的数据集是我们在<a class="ae ky" rel="noopener" target="_blank" href="/generating-fake-data-with-python-c7a32c631b2a">这篇文章</a>中创建的小部件工厂数据集，在这里我们通过Python生成假数据。</p><p id="560d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的示例挑战，我们有一个带说明的降价文件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/da3216e3656313d3ed5ffe0283b43e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cPIlx_0g-6BdMRH9KiEVJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们带回家挑战的说明</p></figure><p id="0d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">markdown文件对于了解我们将要处理的数据类型非常有帮助。它包括数据定义和一个非常开放的指令。</p><p id="0949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为本质上没有限制，我们将使用Python和Jupyter笔记本。</p><h1 id="67aa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第0步——为成功做准备</h1><p id="a35a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我在电脑上有一个目录，里面包含了我在求职中完成的每一个带回家的挑战。在这个目录中，我有子目录，里面有我完成任务的每家公司的名称。</p><p id="1960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢保留旧代码。很多次我回到一个或另一个笔记本，知道我在过去做过类似的事情，并且能够为当前的任务修改它。</p><p id="640e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，让我们为我们的挑战创建一个<code class="fe mt mu mv mw b">widget_factory</code>目录，并将所有文件移动到其中，以便于访问和组织。</p><h1 id="583d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">开始—读入数据并询问基本问题</h1><p id="bf6a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我喜欢采取的第一步是读入数据，并针对每个数据集分别提出简单的问题:</p><ul class=""><li id="9438" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">我有多少数据？</li><li id="57e3" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">是否存在缺失值？</li><li id="59f0" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">数据类型有哪些？</li></ul><p id="e5f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探索我们的数据集:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="e299" class="np lw it mw b gy nq nr l ns nt"># read in worker data<br/>worker_df = pd.read_csv('data/workers.csv')<br/>print(worker_df.shape)<br/>worker_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/fb3e3c83829fe33a50554b6f5c2513b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*ISCHTyCMtDQQfQXBnhjCSg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作数据集:示例</p></figure><p id="3dd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们将所有文件都移动到了我们的<code class="fe mt mu mv mw b">widget_factory</code>目录中，所以我们可以使用相对路径来读入数据。</p><p id="b69b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢在编码任务中使用相对路径，原因如下:</p><ul class=""><li id="105c" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">它使代码看起来干净整洁。</li><li id="106d" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">审阅者将无法辨别您使用的是Mac还是PC。</li><li id="c7da" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我倾向于认为，让评审者无需更改路径就能简单地运行您的代码，您会得到加分。</li></ul><p id="a591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们读入文件，检查形状，并打印样本。我想马上采取的一些其他步骤是检查数据类型、唯一值的数量以及检查空值。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="d182" class="np lw it mw b gy nq nr l ns nt"># check number of unique values in the dataset<br/>for i in list(worker_df.columns):<br/>    print(f'Unique {i}: {worker_df[i].nunique()}')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/dd754feb14fcb4c7f7586ae411aa9ffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*JGj0eGINoLDg1o5qIF8xbA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作数据集:按列列出的唯一值</p></figure><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="4af1" class="np lw it mw b gy nq nr l ns nt"># checking for null values<br/>worker_df.isnull().sum()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e765ec11a7226110a0988a8548ed2989.png" data-original-src="https://miro.medium.com/v2/resize:fit:316/format:webp/1*ENrdEc61Gx7HvUd_Y6HriQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作数据集:空值</p></figure><p id="bc90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个相对干净的数据集，没有缺失值。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="69dc" class="np lw it mw b gy nq nr l ns nt"># statistics about numerical data<br/>### 'Worker ID' is the only numerical column  - this column is an identity column according to the readme<br/>worker_df.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a090c12fcc94cdfd98165968ffe243d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*-fBg247S_lwj2owYGZwqzg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作数据集:数字数据描述</p></figure><p id="c83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们唯一的数字列是<code class="fe mt mu mv mw b">Worker ID</code>，它是一个标识列。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="728b" class="np lw it mw b gy nq nr l ns nt"># checking column types<br/>###### 'Hire Date' column isn't a date - we'll need to fix <br/>worker_df.info()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/38379f43f5ecbac2b3c3421c837ef7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*b4t11dRmC2J0Vz-S_tK5dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工人数据集:信息</p></figure><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="8ad3" class="np lw it mw b gy nq nr l ns nt"># convert 'Hire Date' to datetime<br/>worker_df['Hire Date'] = pd.to_datetime(worker_df['Hire Date'])</span><span id="18cf" class="np lw it mw b gy nz nr l ns nt"># check that it worked<br/>print(worker_df.info())</span><span id="99ff" class="np lw it mw b gy nz nr l ns nt"># check date range of dataset<br/>print(f"Min Date: {worker_df['Hire Date'].min()}")<br/>print(f"Max Date: {worker_df['Hire Date'].max()}")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/38379f43f5ecbac2b3c3421c837ef7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*b4t11dRmC2J0Vz-S_tK5dw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作数据集:将“雇用日期”列转换为日期时间后的信息</p></figure><p id="4ce0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于小部件数据集，我们遵循与上面相同的步骤。这些步骤的代码可以在Github上的完整笔记本中找到。</p><h1 id="b3fa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">绘图-可视化数据</h1><p id="38e8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在回答了关于数据的简单问题后，下一步是可视化。</p><p id="8acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢从更基本的可视化开始。对我来说，这意味着一次处理一个变量，然后探索特征之间的关系。</p><p id="7d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的工作数据集包含五个要素。让我们分别研究一下每个特性。</p><p id="74b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe mt mu mv mw b">readme</code>文件中知道<code class="fe mt mu mv mw b">Worker ID</code>是一个标识列。我们在检查唯一值时也证实了这一点。由于每行都有一个唯一的值，我们可以安全地跳过这个列的可视化。</p><p id="bfa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe mt mu mv mw b">Worker Name</code>只有4820个唯一值，但我认为这也是一个标识列。我们可以说，查看哪些工人有相同的名字，或者检查可能的重复记录可能是有趣的，我们现在将跳过对这个特性的进一步探索。</p><p id="dcbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的下一个功能是<code class="fe mt mu mv mw b">Hire Date</code>。在这里，我们可以绘制最常见的雇用日期，以探索员工是否有共同的雇用日期。</p><p id="57a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，首先我们需要计算唯一日期的数量。虽然有很多方法可以实现这一点，但我喜欢使用<code class="fe mt mu mv mw b">Counter</code>。</p><p id="efc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae ky" href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noopener ugc nofollow" target="_blank"> Python文档中，</a> <code class="fe mt mu mv mw b">Counter</code>创建一个字典“其中元素存储为字典键，它们的计数存储为字典值”。这将很容易创建一个条形图来显示我们的计数。</p><p id="b2f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得计数后，我们可以使用Seaborn创建一个柱状图。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="08ea" class="np lw it mw b gy nq nr l ns nt"># visualize hire date<br/># first Count all unique dates</span><span id="92f6" class="np lw it mw b gy nz nr l ns nt">from collections import Counter</span><span id="7791" class="np lw it mw b gy nz nr l ns nt">hire_dates = Counter(worker_df['Hire Date'].dt.date)</span><span id="53d3" class="np lw it mw b gy nz nr l ns nt"># get dates and date counts<br/>common_dates = [d[0] for d in hire_dates.most_common(15)]<br/>common_counts = [d[1] for d in hire_dates.most_common(15)]</span><span id="323d" class="np lw it mw b gy nz nr l ns nt"># <a class="ae ky" href="https://stackoverflow.com/questions/43214978/seaborn-barplot-displaying-values" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/43214978/seaborn-barplot-displaying-values</a><br/># function to show values on bars<br/>def show_values_on_bars(axs):<br/>    def _show_on_single_plot(ax):        <br/>        for p in ax.patches:<br/>            _x = p.get_x() + p.get_width() / 2<br/>            _y = p.get_y() + p.get_height()<br/>            value = '{:.0f}'.format(p.get_height())<br/>            ax.text(_x, _y, value, ha="center")</span><span id="a050" class="np lw it mw b gy nz nr l ns nt">if isinstance(axs, np.ndarray):<br/>        for idx, ax in np.ndenumerate(axs):<br/>            _show_on_single_plot(ax)<br/>    else:<br/>        _show_on_single_plot(axs)</span><span id="ee36" class="np lw it mw b gy nz nr l ns nt"># plot most common hire dates<br/>fig, ax = plt.subplots()<br/>g = sns.barplot(common_dates, common_counts, palette='colorblind')<br/>g.set_yticklabels([])</span><span id="25dd" class="np lw it mw b gy nz nr l ns nt"># show values on the bars to make the chart more readable and cleaner <br/>show_values_on_bars(ax)</span><span id="9a60" class="np lw it mw b gy nz nr l ns nt">sns.despine(left=True, bottom=True)<br/>plt.xlabel('')<br/>plt.ylabel('')<br/>plt.title('Most Common Hire Dates', fontsize=30)<br/>plt.tick_params(axis='x', which='major', labelsize=15)<br/>fig.autofmt_xdate()<br/>plt.show()</span></pre><p id="5201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在为任何演示文稿创建可视化效果时，我喜欢通过删除不需要的标签和线条来保持图表的整洁。</p><p id="d61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还确保使用一致的调色板——这里我们用的是Seaborn的色盲调色板。</p><p id="5e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在带回家挑战中，可能是小细节让你的作业脱颖而出！确保您的图表有合适的标题和标签！</p><p id="ed4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个图之后，我喜欢用一个标记单元格来标注任何可以得出的关键观察结果。即使这些观察很简单，创建一个简短的有意义的标题也可以帮助你的EDA看起来完整且经过深思熟虑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a56246b96dc8124060b66c9dbdb33972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UdYGWjD3dh2TGG9vf_Yx7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">员工数据集:常见聘用日期条形图</p></figure><p id="7a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的柱状图我们可以看出，工人经常是单独被雇佣，而不是成群被雇佣。</p><p id="9ec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以探索常见的雇佣月份和年份，以确定雇佣日期是否有任何模式。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="d618" class="np lw it mw b gy nq nr l ns nt"># visualize hire date<br/># first Count all unique dates<br/>hire_dates = Counter(worker_df['Hire Date'].dt.year)</span><span id="fb0f" class="np lw it mw b gy nz nr l ns nt"># get dates and date counts<br/>common_dates = [d[0] for d in hire_dates.most_common()]<br/>common_counts = [d[1] for d in hire_dates.most_common()]</span><span id="4a56" class="np lw it mw b gy nz nr l ns nt"># plot 20 most common hire dates<br/>fig, ax = plt.subplots()<br/>g = sns.barplot(common_dates, common_counts, palette='colorblind')<br/>g.set_yticklabels([])</span><span id="88b3" class="np lw it mw b gy nz nr l ns nt"># show values on the bars to make the chart more readable and cleaner <br/>show_values_on_bars(ax)</span><span id="c085" class="np lw it mw b gy nz nr l ns nt">sns.despine(left=True, bottom=True)<br/>plt.xlabel('')<br/>plt.ylabel('')<br/>plt.title('Workers by Year Hired', fontsize=30)<br/>plt.tick_params(axis='x', which='major', labelsize=15)<br/>fig.autofmt_xdate()<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0afbe44f6ab741750bc7483c1906432f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qByQqVQY-isXrnqAY75YUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工人数据集:按年雇用的工人</p></figure><p id="b512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到按年雇佣的工人。我们看到雇佣人数最少的年份是数据集的第一年和最后一年。上面，当我们检查数据的日期范围时，我们发现最小日期是1991-07-11，最大日期是2021-07-08，这解释了雇用人数较少的原因。</p><p id="5730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续进行<code class="fe mt mu mv mw b">Worker Status</code>。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="0555" class="np lw it mw b gy nq nr l ns nt">#visualize status feature<br/>fig, ax = plt.subplots()<br/>g = sns.countplot(x=worker_df['Worker Status'], order = worker_df['Worker Status'].value_counts().index, palette='colorblind')<br/>g.set_yticklabels([])</span><span id="317f" class="np lw it mw b gy nz nr l ns nt"># show values on the bars to make the chart more readable and cleaner <br/>show_values_on_bars(ax)</span><span id="da3d" class="np lw it mw b gy nz nr l ns nt">plt.title('Workers by Worker Status')<br/>sns.despine(left=True, bottom=True)<br/>plt.xlabel('')<br/>plt.ylabel('')<br/>plt.tick_params(axis='x', which='major', labelsize=15)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/848112b1fcd7923d3ad719caa1617244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TsXYFcDW2PHr5BwfBrNrIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">员工数据集:按状态列出的员工</p></figure><p id="60d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到大多数工人是全职的。我们有更少的工人被归类为兼职和每日津贴。</p><p id="d275" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们来探索团队特征。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="1f5d" class="np lw it mw b gy nq nr l ns nt">#visualize team feature<br/>sns.countplot(y=worker_df['Team'], order = worker_df['Team'].value_counts().index, palette='colorblind')<br/>sns.despine(left=True, bottom=True)<br/>plt.title('Workers by Team')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/436268c5a27ef704bdd1377d1a161856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3_OasPiuxm4VhffOaSzaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">员工数据集:按团队列出的员工</p></figure><p id="631c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始询问有关数据的问题可能会有所帮助。一个特征和我们拥有的另一个特征有联系吗？</p><p id="d826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到团队的规模相似。午夜蓝成员最多，深红成员最少。探索团队是如何分配的可能会很有趣。可能是基于职位、地点或工人身份吗？</p><p id="5784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以开始处理功能组了。让我们通过员工状态来可视化团队。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="aad0" class="np lw it mw b gy nq nr l ns nt">#visualize team by worker status<br/>fig, ax = plt.subplots()<br/>g = sns.countplot(x=worker_df['Team'], hue=worker_df['Worker Status'], palette='colorblind')<br/>g.set_yticklabels([])</span><span id="aae9" class="np lw it mw b gy nz nr l ns nt">show_values_on_bars(ax)</span><span id="276c" class="np lw it mw b gy nz nr l ns nt"># position the legend so that it doesn't cover any bard<br/>leg = plt.legend( loc = 'upper right')<br/>plt.draw()<br/> <br/># Get the bounding box of the original legend<br/>bb = leg.get_bbox_to_anchor().inverse_transformed(ax.transAxes)<br/># Change location of the legend. <br/>xOffset = 0.1<br/>bb.x0 += xOffset<br/>bb.x1 += xOffset<br/>leg.set_bbox_to_anchor(bb, transform = ax.transAxes)</span><span id="628f" class="np lw it mw b gy nz nr l ns nt">sns.despine(left=True, bottom=True)<br/>plt.title('Workers by Team and Worker Status')<br/>plt.ylabel('')<br/>plt.xlabel('')<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/088384a5a15815aecfcc7590fbbe399f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9Lt77mKDRlrna_W_kQ9MA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">员工数据集:按小组和员工状态列出的员工</p></figure><p id="dbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到，根据员工状态，员工在团队中的分布相对均衡。这表明工人不是根据他们的身份被分配到团队的。</p><p id="fb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就完成了我们的工人数据集！让我们转到小部件数据集。</p><p id="e281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建数值数据的直方图:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="1871" class="np lw it mw b gy nq nr l ns nt"># create histograms of all numerical data<br/># we know worker id is an identity column <br/># so removing it from this visualization<br/>widget_df_hist = widget_df[['Step 1', 'Step 2', 'Step 3']]</span><span id="b8fc" class="np lw it mw b gy nz nr l ns nt">widget_df_hist.hist()<br/>sns.despine(left=True, bottom=True)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/419cd22c1d792d1e178280ed3656b582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sqoa2Ztdu1jbbYcogmqROQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">微件数据集:步骤1、2和3的直方图</p></figure><p id="6b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到了小部件制作过程中每个步骤的直方图。</p><p id="5d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第1步和第3步，看起来大多数工人很快就完成了这些步骤，并且有长尾现象，任务需要更长的时间才能完成。长尾可能是由于记录数据时的错误，或者是由于工人在完成这些步骤时遇到了困难。这将是有趣的进一步探索。</p><p id="1934" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤2看起来具有正态分布。在小部件制作过程中，步骤2是否更容易完成或自动化程度更高？</p><p id="2425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经成功探索了两个数据集中的所有功能！虽然我们可以就此打住，但这并不是最有用或最有趣的分析。</p><p id="6152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步，我们将合并数据集，以探索要素之间的关系。</p><h1 id="cc3a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">走得更远—组合数据集</h1><p id="8bc8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的下一步是将我们的worker和widget数据集结合在一起。这证明了我们合并数据集的能力——这是任何数据工作的关键技能。</p><p id="f609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将合并<code class="fe mt mu mv mw b">Worker ID</code>上的数据集，因为这是数据之间的共同特征:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="cebf" class="np lw it mw b gy nq nr l ns nt"># merge dataframes together<br/>merged_df = pd.merge(worker_df, <br/>                     widget_df, <br/>                     how='inner', <br/>                     on='Worker ID')<br/>print(merged_df.shape)<br/>merged_df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/3f6ff392b924e921880b00c39e75609d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_b--MjyFt8TzSmHf_nM9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集</p></figure><p id="b4cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据成功合并后，我们可以继续绘图。让我们按团队绘制物品计数图:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="36bf" class="np lw it mw b gy nq nr l ns nt">#visualize item count by team<br/>fig, ax = plt.subplots()<br/>g = sns.countplot(x=merged_df['Team'], <br/>                  order = merged_df['Team'].value_counts().index, <br/>                  palette='colorblind')<br/>g.set_yticklabels([])</span><span id="2c0e" class="np lw it mw b gy nz nr l ns nt"># show values on the bars to make the chart more readable and cleaner <br/>show_values_on_bars(ax)</span><span id="8c05" class="np lw it mw b gy nz nr l ns nt">plt.title('Item Count by Team')<br/>sns.despine(left=True, bottom=True)<br/>plt.xlabel('')<br/>plt.ylabel('')<br/>plt.tick_params(axis='x', which='major', labelsize=15)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/3cb5b8cd6a63a938b5971bded69afd0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiCdXShnGco3KQcxf9afqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集:按团队的项目计数</p></figure><p id="ea25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">午夜蓝队创造的物品最多，深红队创造的最少。我们可以推断这与分配给每个团队的工人数量有关。上面我们发现午夜蓝是最大的队伍，深红是最小的。</p><p id="e823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以按员工状态查看物料数量:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="0f84" class="np lw it mw b gy nq nr l ns nt">#visualize item count by worker<br/>fig, ax = plt.subplots()<br/>g = sns.countplot(x=merged_df['Worker Status'], <br/>                  order = merged_df['Worker Status'].value_counts().index, <br/>                  palette='colorblind')<br/>g.set_yticklabels([])</span><span id="abcc" class="np lw it mw b gy nz nr l ns nt"># show values on the bars to make the chart more readable and cleaner <br/>show_values_on_bars(ax)</span><span id="cf20" class="np lw it mw b gy nz nr l ns nt">plt.title('Item Count by Worker Status')<br/>sns.despine(left=True, bottom=True)<br/>plt.xlabel('')<br/>plt.ylabel('')<br/>plt.tick_params(axis='x', which='major', labelsize=15)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9457955480d1fda06fe0ce97f4165f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZdh4drB0JAYCzaxbMWJJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集:按员工状态列出的项目计数</p></figure><p id="a9d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以看到按工人状态统计的物料数量。正如所料，全职工人创造了最多的项目。</p><p id="2af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以通过单个工人来研究项目计数。这可以显示最高和最低生产力的工人。让我们看看物品数量最少的工人:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="1b4d" class="np lw it mw b gy nq nr l ns nt">#visualize workers with lowest item counts<br/># first create temporary df <br/>tmp = grouped_df.sort_values(by='Item Number Count', <br/>                             ascending=True).head(20)</span><span id="3da4" class="np lw it mw b gy nz nr l ns nt">fig, ax = plt.subplots()<br/>g = sns.barplot(y=tmp['Worker Name'], <br/>                x=tmp['Item Number Count'], <br/>                palette='colorblind')</span><span id="4e8e" class="np lw it mw b gy nz nr l ns nt">plt.title('Workers with Lowest Item Count')<br/>sns.despine(left=True, bottom=True)<br/>plt.xlabel('')<br/>plt.ylabel('')<br/>plt.tick_params(axis='x', which='major', labelsize=15)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/90c5b9576e847e758b3c8fcf0290a034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ba0WzqhE-TERalpgwgnh-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集:具有最低项目计数的工人</p></figure><p id="bc79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到了物品数量最少的20名工人。探究这些工人的工人身份将是有趣的。他们是兼职还是每日津贴？如果我们有与休息时间或工作时间相关的数据，探索是否有任何相关性将是有趣的。</p><p id="3794" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完整性，我们可以通过打印出我们为绘图和目视检查创建的完整的<code class="fe mt mu mv mw b">tmp</code>数据帧来检查绘图工人的工人状态。</p><p id="97e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个更简洁的选项是使用<code class="fe mt mu mv mw b">value_counts()</code>来获得<code class="fe mt mu mv mw b">Worker Status</code>列的唯一值的计数。</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="f741" class="np lw it mw b gy nq nr l ns nt"># check the values for worker status for the workers plotted above<br/>tmp['Worker Status'].value_counts()</span><span id="3269" class="np lw it mw b gy nz nr l ns nt">&gt;&gt;&gt; Per Diem    20<br/>&gt;&gt;&gt; Name: Worker Status, dtype: int64</span></pre><p id="bd9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到生产最少产品的工人都是按日计算的。这里一个合乎逻辑的假设是，这些工人可能工作的班次或小时数最少，因为按日计算的工人通常是根据需要使用的。</p><p id="c103" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们排除每日津贴，并探讨全职和兼职员工在小部件制作流程中各步骤的分布情况:</p><pre class="kj kk kl km gt nl mw nm nn aw no bi"><span id="d731" class="np lw it mw b gy nq nr l ns nt"># create temp df with only part and full time<br/>tmp = merged_df.loc[merged_df['Worker Status'].isin(<br/>    ['Full Time','Part Time'])]</span><span id="10f3" class="np lw it mw b gy nz nr l ns nt"># list of steps to loop over<br/>steps = ['Step 1', 'Step 2', 'Step 3']</span><span id="5c29" class="np lw it mw b gy nz nr l ns nt"># create a plot for each step<br/>for step in steps:<br/>    fig, ax = plt.subplots()<br/>    g = sns.violinplot(x='Team', <br/>                   y=step, <br/>                   hue='Worker Status', <br/>                   split=True, data=tmp)</span><span id="774a" class="np lw it mw b gy nz nr l ns nt">    sns.despine(left=True, bottom=True)<br/>    plt.xlabel('')<br/>    plt.ylabel('Time')</span><span id="d83f" class="np lw it mw b gy nz nr l ns nt">    plt.title(f'{step} by Worker Status', fontsize=20)</span><span id="b828" class="np lw it mw b gy nz nr l ns nt">    plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/c33a67caddc82392f5c1f25ebe14cb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DP16035jWzrz5sEafHY0DQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集:步骤1小提琴图</p></figure><p id="47b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于第一步，我们看到全职和兼职员工的类似分布。所有分布都有长尾。这可能是由于实际的步骤完成时间缓慢或可能的数据收集错误。这可能是有趣的进一步探索。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/fa2f39443dacdbf54e888536f67ea6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lofZsrc9DSlt3YSiIQVNsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集:步骤2小提琴图</p></figure><p id="9108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步的分布呈正态分布。所有团队的全职和兼职员工第二步的时间类似于一条钟形曲线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/691b6efa75b15716bf3a06e2e75e5650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*25hol6zzNbLt8dBs9I9UdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合并数据集:步骤3小提琴图</p></figure><p id="cb57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第三步，我们可以看到所有组都有很长的尾巴。看起来这个步骤通常很快完成，少数异常值需要更长的时间。</p><p id="68b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有步骤中，我们看不到小提琴情节中各组之间的任何主要差异。这表明所有团队的全职和兼职员工在制作小部件的时间上基本一致。</p><p id="5db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以注意到的一个限制是我们没有时间步长的时间单位。在我们的指令文件中，只注意到这些列中的值是时间，但没有给出任何单位。</p><p id="2e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们并没有探索所有可能的数据可视化，但我们已经完成了彻底的探索性分析，并将在这里开始总结这一挑战。</p><h1 id="8901" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">总结—结论、局限性和进一步的探索</h1><p id="d305" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在完成任何带回家的作业时，增加一个简短的结论部分是个好主意。我想在这里谈三个方面:</p><ul class=""><li id="4c5c" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">结论</li><li id="871b" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">限制</li><li id="ba81" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">进一步探索</li></ul><p id="8cee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能从数据中得出什么结论吗？我们注意到了数据的哪些局限性？如果我们有更多的时间或数据，有什么值得进一步探索的？</p><p id="9269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一部分不需要很长，每个主题几个句子就足够了。</p><h2 id="ea2b" class="np lw it bd lx on oo dn mb op oq dp mf li or os mh lm ot ou mj lq ov ow ml ox bi translated">结论</h2><p id="6a72" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们发现MidnightBlue团队拥有最多的工人，也创建了最多的小部件。成员数量最少的Crimson创建了数量最少的widgets。</p><p id="2ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于该数据集的时间范围，创建的小部件数量似乎与团队成员相关。</p><p id="6df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还发现，创建最少部件的员工都处于每日津贴状态。这表明日工的工作时间可能比兼职和全职员工少。</p><p id="b7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有团队中的全职和兼职员工在创建小部件的时间上似乎是相似的。</p><h2 id="733a" class="np lw it bd lx on oo dn mb op oq dp mf li or os mh lm ot ou mj lq ov ow ml ox bi translated">限制</h2><p id="a437" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这里给出的数据不包括数据收集期的时间范围。我们只能及时地将数据作为单个快照进行分析，而不能探究小部件的创建如何随时间而变化。</p><p id="ffa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，我们不知道小部件表中数据的时间单位。</p><h2 id="5f0a" class="np lw it bd lx on oo dn mb op oq dp mf li or os mh lm ot ou mj lq ov ow ml ox bi translated">进一步探索</h2><p id="c377" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">随着时间的推移，探索小部件的创建会很有趣。拥有最多员工的团队总是创建最多的小部件吗？</p><p id="627c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以进一步探索小部件创建步骤的时间安排。观察这种情况是否会随着时间的推移而改变，或者探索任何潜在的异常值，将会很有意思。</p><p id="2358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我想做的最后一件事是重启我的笔记本，从上到下运行所有单元格。这显示了对细节的关注，也许更重要的是确保了笔记本的正常运行。</p><p id="3091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果审查者试图运行我们的笔记本，我们希望确信它将按顺序运行，没有错误！</p><h1 id="7f8b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="0878" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这里，我们从头到尾完成了一个带回家挑战的样本面试。</p><p id="a4b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从阅读数据和问简单的问题开始。</p><ul class=""><li id="bdc4" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">我们有离群值吗？</li><li id="0412" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们是否缺少价值观？</li><li id="8729" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">我们有什么类型的数据？</li><li id="e65f" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">数据是什么样的？</li></ul><p id="5fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们继续绘图，首先可视化单个特征，然后继续探索特征之间的关系。</p><p id="8e07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过操纵数据、合并数据和创建可视化，我们能够展示我们的Python和数据探索技能。</p><p id="4bc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的笔记本可以在<a class="ae ky" href="https://github.com/terrah27/ml_guides/blob/main/widget_factory/eda_challenge.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>找到。</p><p id="65b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你下次带回家挑战好运！</p></div></div>    
</body>
</html>