<html>
<head>
<title>Distinguish 4 Ranking Functions in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区分SQL中的4个排名函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/distinguish-4-ranking-functions-in-sql-37db99107c05#2022-01-08">https://towardsdatascience.com/distinguish-4-ranking-functions-in-sql-37db99107c05#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="8c9d" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">区分SQL中的4个排名函数</h1></div><div class=""><h2 id="6001" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不同排名函数的备忘单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4feb24ce90ace4b6f96371f0161eaf7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sJDmsRtkffYGwtMC"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">埃里克·普劳泽特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="8064" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="b0b0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">SQL中有一些排名函数，有时区分它们的用法令人沮丧。这就是为什么在这篇文章中，我想和你分享我在处理不同排名函数时的备忘单。希望在查询结果的时候能节省你一些时间。</p><p id="2f87" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">总的来说，当谈到等级函数时，会有四种类型的函数:</p><ul class=""><li id="f68f" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">排名()</li><li id="0082" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">密集等级()</li><li id="62a5" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">ROW_NUMBER()</li><li id="cfc4" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">NTILE()</li></ul><p id="9a59" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们在下面的例子中看看这四个。</p><h1 id="6805" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据集</h1><p id="78ca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们开始每个函数之前，让我们创建一个用于操作的数据集。这些数据显示了学生在三个科目上的最终成绩:数学、化学和历史。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e63a" class="nl la it nh b gy nm nn l no np">data = {'student_id':[123,123,123,241,241,241,466,466,466],<br/>        'subject':['Maths','Chemistry','History','Maths', 'Chemistry','History','Maths','Chemistry','History'],<br/>        'final_score':[8,4,5,6,8,7,5,9,2]}<br/>df = pd.DataFrame(data)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7aab2cf1f44ae9202058314cce5a7b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*Y8omJEB7QKC_tWf0atqCJQ.png"/></div></figure><h1 id="1c3a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">句法</h1><p id="6c70" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu"> RANK、DENSE_RANK、</strong>和<strong class="lt iu"> ROW_NUMBER </strong>函数的语法实际上非常相似。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="1336" class="nl la it nh b gy nm nn l no np">RANK_FUNCTION() OVER (<br/>   [PARTITION BY expression, ]<br/>   ORDER BY expression (ASC | DESC) );</span></pre><p id="d6b8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">同时，<strong class="lt iu"> NTILE </strong>函数的语法与这三个略有不同:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="243b" class="nl la it nh b gy nm nn l no np">NTILE(number of groups) OVER (<br/>   [PARTITION BY expression, ] <br/>   ORDER BY expression [ASC | DESC]); </span></pre><p id="4bed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以这样解释这些论点:</p><ul class=""><li id="5062" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><strong class="lt iu"> RANK_FUNCTION: </strong> <code class="fe nr ns nt nh b">ROW_NUMBER</code>，<code class="fe nr ns nt nh b">RANK</code>，<code class="fe nr ns nt nh b">DENSE_RANK</code></li><li id="7c9a" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><strong class="lt iu">分区由<em class="nu"> : </em> </strong>非强制参数。它将输出分成多个分区。</li><li id="fba9" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><strong class="lt iu"> ORDER BY: </strong>指定排序后如何将排名数字应用于结果集。</li><li id="a972" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><strong class="lt iu">组数:</strong>要生成的组数。</li></ul><h1 id="7d60" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">行数</h1><p id="3031" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是最基本的排名功能。基于每个分区的OVER子句中所述的顺序，按顺序返回每行的等级(例如，1、2、3…)。需要注意的一点是，在具有相同值的行中，我们不会有相同的排名。</p><p id="495d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">例1(无分区):</strong>我想根据学生在所有科目上的总分对他们进行排名。输出如图1所示。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="abdc" class="nl la it nh b gy nm nn l no np">SELECT *, <br/>ROW_NUMBER() OVER(ORDER BY total_score DESC) RowNumber<br/>   FROM (SELECT student_id, SUM(final_score) AS total_score<br/>            FROM df <br/>            GROUP BY student_id)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/a705da03b43893968d87aac17c19027a.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*3fWhuyWlH54XRmnh64EC7Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:基于总分的排名——按作者排序的图片</p></figure><p id="ad82" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">例2(带分区):</strong>学生各科成绩排名</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e061" class="nl la it nh b gy nm nn l no np">SELECT *, <br/>ROW_NUMBER() OVER(PARTITION BY subject ORDER BY final_score DESC) RowNumber<br/>   FROM df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/27e897bfaa7fec338591d58f00e04c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*mLdOrTe7-6U86d5Pwu8Kbw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:分区排名——作者图片</p></figure><p id="4bd7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如图2所示，通过<code class="fe nr ns nt nh b">PARTITION BY</code><strong class="lt iu">“主题】，</strong>排名是基于每个主题内的分数决定的。</p><h1 id="79f6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">等级</h1><p id="039b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">基本上，<code class="fe nr ns nt nh b">RANK</code>和<code class="fe nr ns nt nh b">ROW_NUMBER</code>的作用是一样的。唯一的区别是，<code class="fe nr ns nt nh b">ROW_NUMBER</code>避免了排名结果的重复，而<code class="fe nr ns nt nh b">RANK</code>给予相同的值相同的排名数字。因此，排名数字不是唯一的。</p><p id="1b14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">例3 </strong>:找出谁的最终分数最高，不分科目。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="cf0e" class="nl la it nh b gy nm nn l no np">SELECT *, <br/>RANK() OVER(ORDER BY final_score DESC) Rank<br/>   FROM df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/3a07bfeba66874678d9a372df52df055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*Vg5A3LNpm7P6h3KBBOUwvA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:应用等级函数</p></figure><p id="655a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">图3显示，与避免排名数字重复的<code class="fe nr ns nt nh b">ROW_NUMBER</code>不同，<code class="fe nr ns nt nh b">RANK</code>将最终分数相似的学生放在同一排名中。学生123和242在数学和化学上得了8分，所以他们都排名第二，因为他们有第二高的分数。</p><h1 id="3b01" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">密集_秩</h1><p id="3a61" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在图3中，<code class="fe nr ns nt nh b">RANK</code>将两个最终得分相同的学生放在第二位，然后跳过第三位继续第四位。另一方面，如果<code class="fe nr ns nt nh b">DENSE_RANK</code>处于相同的情况，则等级号不会跳到4，而是继续等级号3。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6195" class="nl la it nh b gy nm nn l no np">SELECT *, <br/>RANK() OVER(ORDER BY final_score DESC) Rank, <br/>ROW_NUMBER() OVER(ORDER BY final_score DESC) RowNumber, <br/>DENSE_RANK() OVER(ORDER BY final_score DESC) Dense_Rank <br/>   FROM df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/cfafc71119aae148e9d065c0b4cd74ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*6phgHJZtyVIorl4Vf8tmFg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:应用密集等级——按作者排序的图像</p></figure><h1 id="929a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">恩蒂莱</h1><p id="aeee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">函数有助于将行分组。根据提供的标准为每个行组分配一个等级。组数在<code class="fe nr ns nt nh b">NTILE()</code>功能中指定。</p><p id="b798" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">例4: </strong>根据学生各科成绩，对学生进行排名，分为2组。</p><p id="3bb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如图5所示，对于每个科目，分数最高的学生被分到一组，分数较低的学生被分到第二组。因此，有了<code class="fe nr ns nt nh b">NTILE</code>，我们可以根据学生在每门学科的表现将他们分成不同的组。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="130e" class="nl la it nh b gy nm nn l no np">SELECT *, <br/> NTILE(2) OVER(PARTITION BY subject ORDER BY final_score DESC) Ntile <br/>   FROM df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/3a9ad5d4f294b91c3ee26b4af3972a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*kGVyok43SSgl3DCQ2huyLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5: NTILE排名并将排名分为两组</p></figure><h1 id="0460" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">总结</h1><h2 id="8d25" class="nl la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">行数</h2><p id="4daf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">基于每个分区的OVER子句中所述的顺序，按顺序返回每行的等级(例如，1、2、3…)。排名数字没有重复。</p><h2 id="e5fc" class="nl la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">军阶</h2><p id="b00f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">类似于<code class="fe nr ns nt nh b">ROW_NUMBER</code>，它为每一行分配一个递增的排名号。不过和<code class="fe nr ns nt nh b">ROW_NUMBER</code>有一点不同的是<code class="fe nr ns nt nh b">RANK</code>把相同的排名数赋予了相等的值。然后，该函数在复制后跳过下一个排名号。</p><h2 id="d307" class="nl la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated"><strong class="ak">密集_等级</strong></h2><p id="fa22" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与<code class="fe nr ns nt nh b">RANK</code>类似，<code class="fe nr ns nt nh b">DENSE_RANK</code>为相同的值分配相同的等级编号，但它不像<code class="fe nr ns nt nh b">RANK</code>那样跳过等级编号。</p><h2 id="3f73" class="nl la it bd lb oa ob dn lf oc od dp lj ma oe of ll me og oh ln mi oi oj lp ok bi translated">恩蒂莱</h2><p id="7c3b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该函数有助于对值进行排序和分组。</p><h1 id="be82" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="ce51" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以上文章是我对排名函数区别的解释。我希望我能让你明白。</p></div></div>    
</body>
</html>