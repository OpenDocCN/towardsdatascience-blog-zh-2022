# 面试问题:从文件中随机选择一行(Python 中)

> 原文：<https://towardsdatascience.com/interview-question-select-a-random-line-from-a-file-in-python-4756eac40075>

## 一个很酷很有用的算法解释和扩展

卡尔·m·卡迪和克里斯托弗·米克

![](img/9314162bb380abd2a3ac994409eaff5c.png)

从文件中随机选择一行文本的 python 来源:【https://openai.com/dall-e-2/ 

如果我(卡尔)面试你在微软的工作，我可能会问你这个问题:

> 如何从未知长度的文本文件中随机选择一行？

我在微软研究院，在最初的反垃圾邮件团队，在一个办公室机器学习/数据科学小组，都问过这个问题。我们喜欢这个问题，因为它涉及概率、算法和系统问题。

即使已经从微软退休，我们仍然会思考随机线问题。例如，我们最近学习了`[bytecount](https://lib.rs/crates/bytecount)`。这是一个 Rust crate，它使用 SIMD CPU 指令来加速计算文件中的行数。正如我们稍后将描述的，我们对板条箱的学习间接导致了我们对随机线问题最喜欢的解决方案的改进。

我们将这篇文章组织成一系列的问题和提示。如果你愿意，在看到我们的回答之前，你可以试着自己回答问题。

> 在本文中，我们将用 Python 给出答案。Rust 中的答案见本文的 [Rust 版。你可能也喜欢阅读这两个版本，作为比较两种语言的一种方式。](/interview-question-select-a-random-line-from-a-file-in-rust-c0a8cddcddfb)

对于白板面试，我们给了受访者以下建议:

*   请随意提出澄清性问题。(在本文的上下文中，您可以进一步阅读，看看我们是否提供了澄清。)
*   首先从正确的算法开始，即使它可能不是最佳的。如果我们想要一个更好的算法，我们会用后续问题来提示您。
*   不要担心精确的语法。例如，我们不关心你是否记得产生随机数的确切方法。(在本文中，我们将用 Python 给出答案。)
*   如果你卡住了，我们可以提供一些提示。(还是那句话，在这篇文章的上下文中，读远一点寻找提示。)

让我们从问题开始:

## 问:如何从未知长度的文本文件中随机选择一行？

**答:**我们首先要明确一个“随机线”的含义。我们的意思是文本文件中的每一行都有相等的机会被返回。换句话说，我们希望算法通过均匀分布在这些线中进行选择。

这个要求意味着你**不能**使用这个算法，我们称之为`AlgoRandomSeek`:

*   向文件系统询问文件的长度。
*   随机选择一个文件位置并查找到该位置。
*   在位置附近返回一条线。

**Sub Q:**`AlgoRandomSeek`怎么了？

**Sub A** :虽然该算法可以返回文件中的任何行，但它返回较长行的概率高于较短行，因此不会通过均匀分布选择行。

> 旁白:我们喜欢被要求澄清。它将“随机”的日常含义与统计学、数据科学、决策理论和机器学习中使用的技术含义区分开来。

**提示:**如果你在用 Python 编程，需要快速(但正确地)解决随机线问题，你会怎么做？

我们向 GitHub Copilot 寻求解决方案，它给了我们这段代码。称之为`AlgoReadAll`:

这显然是正确和快速的。另外，它使用`with open(file_name) as f:`在上下文管理器中打开文件，这是很好的实践。为了获得额外的好处，您可以提到代码在空文件上抛出一个异常。

不利的一面是，这段代码将整个文件读入内存，因此不能处理大文件。另外(次要一点)，`f.read().splitlines()`可以换成`f.readlines()`。

> 旁白:你可以用一行代码编写这个算法:`random.choice(open(file_name).readlines())`。然而，我们不喜欢伤害可读性的单行解决方案。

接下来，让我们询问一个适用于大型文件的解决方案:

## 问:使用很少的内存，如何从未知长度的文本文件中随机选择一行？

**答:**首先要明确“小内存”。对于这个问题，假设您可以存储文件中的任何一行，或者几行，但不是所有的行。

`AlgoTwoPass`用 1 解决问题。计算文件中的行数，2。随机选择一个行索引，3 .返回带有该索引的行。(在本文中，“索引 0”是一个从 0 开始计数的索引。如果一个索引从 1 开始计数，我们称之为“index1”。)

在我的机器上，这将输出:

`100,989 of 146,933: made in 1875 and the number of patents soon rapidly increased;`

`AlgoTwoPass`正确。我还要给这段代码加分，因为:

*   使用带有显式种子的随机数生成器—机器学习和数据科学通常需要再现性，即使是来自随机性。
*   【非常小】使用 Python 格式字符串，包括千位分隔符。
*   提到它在应用于空文件时返回`None` 。

不是必需的，但有趣的是这个更具功能性的实现:

> 旁白 1: **背景信息**:这段代码使用了 [Python 迭代器](https://docs.python.org/3/glossary.html#term-iterator)。当`next()`应用于 Python 迭代器时，返回序列中的下一个值，或者，如果序列完成，抛出异常。`itertools.islice`函数可以在不返回值的情况下在迭代器中向前跳转。表达式`open(file_name)`返回一个对象，该对象是文件中各行的迭代器。`enumerate()`函数接受一个迭代器并返回一个新的迭代器，这样每次调用新迭代器上的`next()`都会返回一个从 0 开始的索引和一个来自原始迭代器的值。
> 
> 旁白 2:我们不会因为某人用`rng.randint`或`itertools.islice`犯了一个一分的错误而惩罚他。然而，我们可能会问，如何测试代码来检查这样的错误。

接下来，我们要求一个更快的算法:

## 问:在*一次*中，你能从未知长度的文本文件中随机选择一行吗？

**答:**经过提示，我们将通过一系列子问题开发一个算法。

**提示:**递归地想想这个。

**Sub Q:** 把自己放在程序的位置上。如果我们向您保证文件只包含一行，您应该怎么做？

如果文件只包含一行，就输出它。

**子问:**呜呜，我们骗了你。该文件可能只包含一行或两行，但没有其他数量的行。你该怎么办？

**Sub A:** 用概率 0.5，替换我们要输出的结果，用第二行。

**子问:**对不起，我们又说谎了！该文件可能只包含一行、两行或三行。你该怎么办？每条线的入选概率是多少？这怎么能一概而论呢？

用概率⅓，用第三行替换我们要输出的结果。

每行的选择概率为:

*   第一行:1 × × ⅔= ⅓
*   第二行:× ⅔= ⅓
*   三线:⅓= ⅓

所以，概率分布是均匀的。我们可以将其概括为`AlgoOnePass`:

> **先不说:**我(Carl)回忆起一位受访者开始通过归纳法证明这个算法的正确性。我可以告诉他们很容易做到这一点，所以我阻止了他们，继续前进。他们获得了奖金。

**奖金 Q:** 我们在面试中从来没有问过这个，但是你能递归地写`AlgoOnePass`吗？

**奖金 A:** 这里是`AlgoOnePassRecurse`:

Python 的可选参数可以很好地处理递归。可悲的是，如果递归超过几千次，Python 就会崩溃。这段代码使用包[尾递归](https://pypi.org/project/tail-recursive/)来避免崩溃。然而，即使如此，这种递归代码的运行速度比迭代代码慢几百倍。

> 旁白:实际思考一下，一次通过比两次通过重要吗？往往不会。如果你能为一条随机的线等待 20 秒，你大概能等待 20 到 40 秒。另一方面，有些数据——“流数据”——不能被访问两次，所以`AlgoOnePass`具有实用价值。

对`*AlgoOnePass*`的一个简单概括是选择多条随机线，而不仅仅是一条线，我们不会讨论这个。维基百科在其关于[储层采样:简单算法 R](https://en.wikipedia.org/wiki/Reservoir_sampling#Simple:_Algorithm_R) 的文章中描述了(或多或少)`*AlgoOnePass*`和这一概括。

在采访中，这通常是我们说到“从文件中随机抽取一行”的地方。然而，我们最近了解到了锈箱`[bytecount](https://lib.rs/crates/bytecount)`。这个`[bytecount](https://lib.rs/crates/bytecount)`板条箱使用 SIMD CPU 指令来加速计算文件中的行数。这让我们再次玩起了这个问题。这导致了一种新的方法和一种改进的算法。新算法不使用`[bytecount](https://lib.rs/crates/bytecount)`。然而，在返回一个随机行的特定情况下，它确实优于维基百科中描述的更一般的 [Optimal: Algorithm L](https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L) 。

> 旁白:我们称之为“新算法”，但它可能早就被发现了。无论如何，我们希望你会对这个算法和它的发展感兴趣。

和以前一样，我们将通过一系列问题和提示来展示新算法。然而，我们从未向受访者提出过这些问题。

## 问:在一次传递中，你能从一个未知长度的文本文件中选择一个随机行，使得随机数发生器的调用比行数 n 少得多吗？

**答:**我们必须澄清“少很多”。我们的意思是对随机数生成器的调用次数小于 O( *n* )【参见[大 O 标注—维基百科](https://en.wikipedia.org/wiki/Big_O_notation)】。换句话说，将通话次数减少一次或一半是不够的。所需调用的随机数应该与 log( *n* )或 sqrt( *n* )成比例增长。

**提示:**首先修改`AlgoOnePass`打印分配给`result`的每一项的索引。称之为“保持指数”。比如说，对 100 万个项目运行代码。

产出:

```
1 36 41 187 226 403 2,608 5,756 20,162 48,750 912,566 922,409
```

这表示当我们以随机种子 0 运行时，第一项(索引 1)被保留为可能的结果。那么没有项目被保留到第 36 个项目，然后是第 41 个项目。如果迭代器包含 922，409 到 1，000，000 项，那么第 922，409 项将是最后一项，因此将被返回。

keep 指数似乎大致呈指数增长。如果该猜想为真，那么 keep 索引数为 O(log *n* )，其中 *n* 是迭代器中项的个数。

子问题:我们可以直接随机生成 keep 索引序列吗？

**Sub A:** 是的！我们在一篇简短的在线技术论文中详细介绍了我们的解决方案[Meek & Kadie，[Streaming Random Selection Using the Attenuated Geometric Distribution](https://cm1x.github.io/static/Attenuated_Geometric_Distribution.pdf)，2022]。我们称 keep 指数的分布为“衰减几何分布”。我们证明，如果`index1`是一个 keep 索引号，那么我们可以生成下一个:

```
r = rng.random()
index1 = index1 + max(ceil(r * index1 / (1.0 — r)),1)
```

其中`rng.random()`生成 0 .0(含)到 1.0(不含)之间的统一浮点值。奖金:`max(…,1)`处理随机生成 0.0 的非常，非常不可能的情况。此外，回想一下我们的约定，即“index1”是从 1 而不是从 0 开始计数的索引。

我们现在可以利用这种洞察力来创建`AlgoOnePassSkip`:

我们可以通过使用代码在 0(包括)和 100(不包括)之间挑选一个数字，100，000 次，来获得一些信心。

输出图应该看起来一致。他们确实这样做了:

![](img/391933e09291266d5565be5154165258.png)

这个算法与 [Optimal: Algorithm L](https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L) (维基百科推荐)有两个重要的区别。

*   `AlgoOnePassSkip`只能选择一个随机项，而算法 L 可以选择任意指定数量的随机项。
*   当只需要一个随机项时，`AlgoOnePassSkip`每个 keep 索引需要一个随机数，而算法 L 需要两个。

因此，对于我们只想要一个随机物品的特殊情况，`AlgoOnePassSkip`使用的随机抽取数量是算法 l 的一半

# 摘要

我们已经看到了从未知长度的序列中随机选择一个项目的四种方法。在文本文件的上下文中，第一种解决方案要求文件适合内存。下一个解决方案使用较少的内存，但需要两次通过文件。然后，我们使用概率计算将此减少到一遍。这种一次通过的解决方案需要每行一个随机数。最后一个解决方案需要的随机数比直线少得多。它使用的随机数也是“最优”(更一般)算法的一半。

我们的代码都没有使用系统级的方法，比如`[bytecount](https://lib.rs/crates/bytecount)`来加速文件的线性传递。添加系统级优化将是一个有趣的扩展。

*请* [*跟随卡尔上中*](https://medium.com/@carlmkadie) *。我写的是 Rust 和 Python 的科学编程、机器学习和统计学。我倾向于每月写一篇文章。*