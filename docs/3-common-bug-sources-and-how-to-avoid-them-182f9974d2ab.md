# 3 种常见的错误来源以及如何避免它们

> 原文：<https://towardsdatascience.com/3-common-bug-sources-and-how-to-avoid-them-182f9974d2ab>

## 有些编码模式更容易隐藏 bug。编写高质量的代码并了解我们的大脑是如何工作的，有助于大幅减少它们的数量。

![](img/41f0800fedf4584d1bfc90f268c52306.png)

德米特里·布汉佐夫在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

错误是生活中不可避免的一部分，对代码来说更是如此。软件项目的复杂性通常增长很快，导致微妙的逻辑错误(也称为 bug ),破坏了软件部分的正确功能。

尽管不可避免，我们仍然可以采取一些措施来减少它们的数量，或者至少在它们发生时使它们更容易被发现。毕竟，我们花在捕获 bug 上的时间越多，我们能花在真正向客户交付价值上的时间就越少。

好消息是，有一些常见的虫子藏身的模式，我们可以避开它们，给我们的虫子更少的藏身空间。

这些模式各不相同，但是它们有一个共同的重要因素:当代码的复杂性超出我们的认知能力时，它们就会出现。现代心理学同意存在一种[工作记忆](https://www.psychologytoday.com/us/basics/memory/working-memory)，我们用它来推理我们正在执行的认知任务，就它所能包含的项目而言，它也是相当小的。幸运的是，有像[分块](https://psychology.fandom.com/wiki/Chunking)这样的工具帮助我们处理复杂的信息。

Python 核心开发人员 Raymond Hettinger 在下面的视频中非常有效地解释了这些概念如何与我们的日常工作相关联:

但是现在回到我们的故事，是时候看看模式了。

**请注意**，这个故事中的代码示例是故意非常简单的。我不做数据验证，我使用浮点数来表示货币，以及其他在生产就绪代码库中是错误的东西。这里我只对展示讨论的相关部分感兴趣。
代码示例是用 Python 编写的，但是这里的建议并不局限于这种语言。

# 模式 1:重复条件句

当同一个条件语句(if-else，switch 语句)在代码中重复多次时，bug 可能以多种方式隐藏在那里。

首先，我们没有一个单一的地方可以看到同一分支的所有出现，然后检查它们的一致性。

第二，出于同样的原因，当修改一个或多个分支中的代码时，我们可能会忘记更新所有的事件。

第三，如果没有一个清晰的接口，我们可能会添加一些分支，但只是添加到条件代码的某些部分，而不是所有适当的位置。

示例:假设我们正在为一家公司编写一个人力资源应用程序，该公司的员工级别(为简单起见)从 1 到 3。

很容易看出，这里的问题是同一个 switch 语句(if…elif…else)在不同函数的代码中重复了几次。我们没有工具在代码处于这种状态时，对发生分支的所有代码部分进行强制检查。幸运的是，一些重构可以帮助我们解决这个问题:

[](https://betterprogramming.pub/my-top-takeaways-from-refactoring-part-2-55efe6c547b8)  

## 解决方案:多态性

第一个解决方案是使 Employee 数据类成为一个多态类。为此，我们首先使 Employee 成为一个抽象类(如果使用 Python 或 C++等语言，一个与 Java、C#或 Go 的接口)。然后，我们为每个等级创建一个具体的类。上面写的每个函数都成为抽象类中的抽象方法，然后在具体类中强制实现。

对要实现的方法的自动控制意味着我们不能忘记为一个类添加功能，同样也不能忘记为一个分支添加功能。此外，如果完全相同的多分支代码在代码的不同部分重复，现在该功能在其自己的方法中只出现一次。

根据上面的描述，实现是不完整的，因为我们仍然需要实例化具体的类。工厂方法模式拯救了我们。它将对象的创建集中在一个点上，这是我们需要编写等级切换的唯一点。一旦创建了对象，就决定了它的行为，不再需要检查它的类型。

这种模式的一个特殊例子是，相同的条件在同一个函数中出现两次或更多次。例如，让我们假设我们正在编写深度学习代码，我们有一个在两个不同任务之间共享参数的模型:一个接收文本输入，一个接收音频输入。共享参数前有一部分，共享参数后有一部分，这取决于输入的维数:

在这种特定的情况下，通过为每种输入类型使用不同的函数来编写重复的文字`x = self.trunk_encode(x)`可能比上面的代码更好。事实上，我们增加了毫无意义的复杂性，导致读者的高认知开销。此外，具有多个分支的代码在修改过程中更容易出错(在我的皮肤上试过)。

具有多个函数的一个变体，可以是只写一次条件而不是多次，并且一起写属于一个分支的所有代码。DRY(不要重复自己)原则不适用于这里重复的代码(在这里是 `x = self.trunk_encode(x)`)，因为它增加了复杂性。此外，DRY 是关于集中知识，而不是编写更少的代码，这里的知识已经在 trunk_encode 方法内部了。

[](https://annageller.com/blog/dont-repeat-yourself-is-beneficial-not-only-in-software-engineering)  

# 模式 2:可变状态

面向对象编程中经常提到的一个问题是，数据和对数据的操作(方法)被打包在一个类中。这些方法作用于状态，并以“受控”的方式改变它，也就是说，外部代码不能直接访问表示状态的内部属性，而必须使用类的公共接口。

这一切都是好的和合理的，除了它仍然会导致微妙的错误。的确，所有由可变状态构成的代码都很容易导致 bug。让我们考虑这个例子

这里的 bug 很明显，discounted_items 与 bill.items 是完全相同的列表，当打印最后两行时，值将是相同的，完整的价格将会丢失。

在这种情况下，我们考虑的是一小段代码，很容易发现，但是在复杂的代码库中，我们可能会将 bill 对象传递给一个方法，该方法调用 apply_discount(并且不将它写在 docstring 中)。在这种情况下，我们将在没有注意到的情况下修改价格。

这种类型的错误确实很烦人，而且很难发现，但是幸运的是有一个明确的解决方案:不变性。

## 解决方案:不变性

当把我们的对象传递给我们不信任的代码时，模拟不变性的一个简单方法是使用**防御副本**。尽管名字像打仗一样，但它只是意味着在将对象作为参数传递给函数之前复制一个对象。副本应该是递归的(或者 python 中的 deepcopy ),因为副本的内部容器应该与原始容器没有任何共同之处，否则防御性副本将不起作用。回到我们的例子，浅层拷贝只会拷贝对 self.items 的引用，所以对拷贝的修改在原始拷贝中也是可见的。

这就是在我们的例子中如何实现防御性复制

另一个更简单的方法是不要用包含折扣价格的新列表替换 self.items，而是创建一个新列表并返回它。这不会影响我们的内部状态。

错误的另一个来源可能是 add_item 方法，如果我们对账单中的项目数量有预期，但这些项目并不匹配，因为有人在某个地方调用了 add_item。

在这种情况下，我们可以使用另一种技术来防止我们的对象发生变异。它被称为**写时复制**，包括每次我们写可变对象时创建并返回一个新对象。

回到我们的例子:

在这种情况下，我们从不就地修改我们的 bill 对象。我们总是创建一个新的对象并重新分配变量。这当然会带来性能开销，但是除非数据非常大，否则您可能不会真正感觉到这一点。另一方面，它减少了错误的发生，因为对代码进行推理变得更容易，因为您不必担心可能的数据更改。

当您的不可变对象作为参数传递给不属于您的代码时，您仍然可以确保它们的状态在外部代码终止期间和之后是相同的。

# 模式 3:复杂的控制流

编写复杂代码的另一种方式是使用嵌套的 if-else 条件和循环来创建复杂的控制流，所有这些都放在多个缩进层中。

例如，假设我们有一个电子商务，营销部门决定发布一个促销活动。他们希望对选定的产品应用折扣:库存超过 10000 件的电子产品将有 20%的折扣，对于所有其他类别，促销针对库存超过 500 件的所有产品。价格低于 1000 美元的商品享受 50%的折扣，价格高于 500 美元的商品享受 30%的折扣。

直接翻译成 python 应该是这样的:

尽管逻辑并不特别复杂，但要理解上面的代码可能很难，因为我们需要跟踪所有可能的路径。由于我们需要记住所有的条件，所以在到达终点之前，我们的[工作记忆](https://www.psychologytoday.com/us/basics/memory/working-memory)将被完全占用。如果增加更多分支，情况只会变得更糟。

当我们对代码进行推理的可能性被它的复杂性所阻碍时，我们努力识别我们逻辑中的错误，并最终识别代码错误。

## 解决方案:拆分代码

我们的问题是我们需要记住大量的信息来理解代码。发生这种情况是因为有一个函数将关于产品类别的代码和概念放在一起，直到一个项目的结构。这是由多个循环丰富的，这些循环本身就很复杂。

然后，在实现细粒度的实现之前，我们可以使用分块来提高代码的抽象级别，使其更具可读性。

通常容易遵循的一条规则是将循环和条件放在它们自己的函数中:

这段代码看起来比前一段长了 10 行代码(最初的 15 行)，但需要注意的是，其中 6 行是由 [PEP8](https://pep8.org/) 强加的空白 likes，3 行是额外的函数签名，逻辑代码根本没有增加。

我们在这段代码中所做的是，首先提取一个类别中所有项目的循环，注意到它在两个分支中都是相同的:我们总是循环该类别中的所有项目，然后根据条件决定是否将一个项目添加到我们的列表中(使用折扣率)。然后，我们提取条件和关联贴现率，并将它们放入每个分行的一个函数中。

我们实现的是隔离每个功能的逻辑。第一个函数是非常高级的，它告诉我们要扫描所有产品，以检查电子产品和其他产品是否有两种不同的促销方式。然后，我们看到这种扫描只是简单地遍历所有产品，并对每个产品应用一个函数，将我们的促销列表作为一个附加值传递。最后，在最后两个函数中，我们隔离了将两个类别的商品添加到促销中的逻辑。

有了这样一个清晰划分不同抽象层次的结构，对代码进行推理就变得更加容易，因为每时每刻都有更少的信息需要记住，因此发现错误也变得更加容易。

# 结论

我们经常听到“这只是一个实现细节”的说法，但是编程都是关于实现细节的。用另一个符号改变一个符号，用一个相似的符号改变一个变量名，代码行为就偏离了初衷。

因此，逻辑错误(也称为 bug)不可能从任何足够复杂的代码库中消除。我们可以成为世界上最好的程序员，但是代码库将包含太多的信息，我们在给定的时间里只能记住这些信息。信息过载阻碍了我们对代码做出全意识的决定，这通常是错误产生的原因。

在本文中，我们回顾了复杂代码的三种模式，它们可以长期隐藏错误:重复的条件、可变的状态和深度嵌套的控制流。

在第一种模式中，当同一个分支在一个函数中多次出现时(或者更糟，在一个模块中的所有函数中，或者在一个类中的所有方法中)，我们必须记住该怎么做，此外，当我们修改代码时，我们需要记住更新分支出现的所有地方。

在第二种模式中，我们读取假定状态为某些值的代码，但是某些东西在我们没有注意到的情况下改变了状态。

在第三种模式中，我们有多个控制流语句在多个标识级别中相互嵌套，当我们阅读代码时，我们会感到脑袋塞满了东西，因为有太多的信息需要记住。

在所有情况下，解决方案都是降低复杂性，要么抽象出循环或条件分支，使用多态性对与类型相关的方法进行分组，要么防止我们的对象发生意外变异。

这些保持代码简单的技术将帮助您减少在日常工作中产生的错误，并使您的代码对您的同事更具可读性。

我知道，这是一个漫长的过程。谢谢你一直读到最后！

# 参考

设计模式最全面的介绍可以在 Gamma Erich，Helm Richard，Johnson Ralph，Vlissides John 的**设计模式:可重用面向对象软件的元素**中找到。

代码重构的技巧可以在马丁·福勒的书中找到，这本书介绍了概念**重构:改进现有代码的设计**，他实际上写了关于这个主题的博士论文。

Eric Normand 所著的《追求简单性:用函数式思维驯服复杂软件》一书提倡通过使用函数式编程中的不可变性和其他技术来实现基于代码简单性的方法。

# 更多来自我

[](/parse-dont-validate-f559372cca45)  [](/machine-translation-evaluation-with-cometinho-c89880731409)  [](/pick-your-deep-learning-tool-d01fcfb86845) 