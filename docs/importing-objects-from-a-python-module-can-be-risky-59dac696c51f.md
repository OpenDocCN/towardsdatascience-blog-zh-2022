# 从 Python 模块导入对象可能有风险

> 原文：<https://towardsdatascience.com/importing-objects-from-a-python-module-can-be-risky-59dac696c51f>

## 您是否知道在导入原始对象后，您是否会处理它们？或许用他们的复制品？也许有些是原创，有些是复制品？

![](img/33c19bcc9500e5256af3734be6789461.png)

哪匹马是原作，哪匹是复制品？太难说了！来源:图片由作者提供。

您应该导入模块(`import module`)还是从模块(`from module import obj1, obj2`)导入对象并不是一个新问题。在这篇文章中，我不打算重新发明轮子。我们知道导入一个模块有更多的优点，但是在某些情况下，直接从一个模块导入对象也很好；可以让一个 app 快一点，代码可以短一点。如果你想更多地了解这个话题，马克·卢茨的书(Lutz 2013)提供了很好的阅读材料。

关于进口，有一个事实很容易忘记。这两个方法*中的一个不从另一个模块导入* *对象*，而是由*创建它们的副本*。虽然通常这不会造成很大的差别，但有时会，而且差别会很大。

在本文中，我比较了从模块中复制对象和导入对象。我将展示*导入一个模块*相对于*从一个模块*导入对象的一个优点，这个优点有时可以省去你很多麻烦。

# 导入模块:原始对象的作用

假设我们有一个由三个模块组成的应用程序:

*   `helpers`，包含主应用中使用的变量和函数；
*   `action`，包含应用的主要功能；
*   `__main__`，负责运行应用程序。

这是`helpers`的内容:

我尽可能让它简单。现在`action`:

所以，`run_app()`是应用程序的主要功能。它将在负责运行应用程序的`__main__` 模块中被调用。当然，在我们的例子中，`__main__`也过于简化了:

这符合预期。当我们导入`helpers`模块时，我们可以使用它的`foo()`函数和`helpers_value`全局变量。注意`helpers_value`不是大写，因为它不是常数；它只是一个全局变量。这里，“全局”是指模块的全局；但这是意料之中的:这就是 Python 中范围的工作方式(Lutz 2013，拉马尔霍 2022)。然后，我们改变`helpers.helpers_value`和`helpers.foo`，这个改变反映在原来的位置，也就是在`helpers`里。我们可以通过调用`action.run_app()`看到这一点，这个函数调用`helpers.helpers_value`和`helpers.foo`。

# 从模块导入:实际复制

现在，让我们改变在`__main__`中导入`helpers`对象的方式:

那是相当不同的！发生了什么事？

我们更改了`helpers_value`和`foo`，但这并不影响位于`helpers`的原始对象。这是因为`import from`创建了导入对象的副本。这一点至关重要，所以让我强调一下:

> `import from`创建导入对象的副本。

因此，虽然我们对`helpers_value`和`foo()`的更改影响了这些副本，但它们不影响来自`helpers`模块的原始值。`action.run_app()`功能不使用这些副本；它使用来自`helpers`的原始对象，这就是为什么我们在两种情况下观察到不同的行为。

# ***这是什么意思？***

这意味着很多，也改变了很多。幸运的是，在大多数情况下，这些都不重要，因为我们很少在一个模块中改变另一个模块中的对象。然而，有时我们会，然后我们必须小心。

为了使事情变得更加复杂，我们需要考虑两种情况:从模块中导入不可变对象和导入可变对象。

## 不可变对象

当您从一个模块中导入一个不可变的对象时，就像在`from helpers import helpers_value`中一样，创建了该对象的一个副本。因此，您的全局名称空间现在将包含两个名为`helpers_value` : `helpers.helpers_value`和`__main__.helpers_value`的对象。你预料到会发生这种事吗？

同理，`foo()`功能也没有在原地改动:导入后有两个`foo()`功能:`helpers.foo()`和`__main__.foo()`。

因此，当我们导入一个模块(`import helpers`)时，我们直接从模块中使用原始的(不可变的)对象；当它们改变时，我们使用改变的对象。

尽管如此，当我们直接从一个模块(`from helpers import foo, helpers_value`)导入不可变对象时，Python 会制作它们的副本，我们使用这些副本——而不是原始对象。因此，当原始对象在模块中改变时，这不会影响我们正在使用的对象——因为我们正在使用它们的副本。

## 可变对象

可变对象不能被复制，对其原始对象的任何更改或所谓的副本都是对原始对象进行的。这是因为 Python 不会创建可变对象的副本；相反，会创建一个引用原始对象的新名称。

可变对象的这个特性影响了导入的工作方式。

让我们简化我们的应用程序。现在它将只包含一个对象，一个字典，这是一个可变的 Python 对象。所以，`helpers`如下:

`action`模块包含`run_app()`函数，它现在简单地返回`helpers_value`字典:

这是`__main__`模块:

你看到发生了什么吗？这一次，虽然我们从`helpers`导入了`helpers_value`，但是我们得到了一个不同的结果:原来的对象被就地改变了。

这是可变对象的典型行为。Python 不会创建它们的副本；相反，它会创建指向同一对象的不同名称。因此，更改分配给这些名称中任何一个的对象的值都会产生相同的效果:原始对象会受到影响。

# 合并导入

结合这两种类型的导入不会改变任何事情。不可变对象的行为类似于不可变对象，可变对象的行为类似于可变对象。让我们看看它是如何工作的。你可以把它当作一次练习。

这一次，我们将只使用两个模块，`helpers`和`__main__`。前者将定义两个对象，一个不可变，一个可变:

在`__main__`中，我们将以两种方式导入它们，然后改变对象。在继续之前，尝试猜测下面代码片段的输出。在每个`print()`之后，我在你应该猜测输出的地方添加了引号。

这是输出结果:

我希望你没弄错。理解导入对象和模块的这个方面将帮助您避免当您的应用程序包含几个具有某种依赖层次结构的模块时可能发生的奇怪错误(例如，`module1`导入`module2`，后者导入`module3`)。

# 摘要

正如我上面提到的，理解 Python 导入的这些复杂性应该有助于您在由几个模块组成的应用程序中避免错误。请记住:

*   `import module`使您能够将该模块中的对象用作`module.obj`。这意味着你使用*原始对象*，位于`module`的那个。因此，对这个对象的任何更改，在代码中的任何地方作为`module.obj = …`完成，都将反映在对`module.obj`的调用中。
*   在*不可变对象*的情况下，`from module import obj`创建对象的副本。这意味着该副本位于模块范围内(在您导入`obj`的模块中)。改变这个副本的值(即`obj`)不会影响原对象(`module.obj`)。
*   在*可变对象*的情况下，`from module import obj`仅创建对象的新名称。因此，改变它的值(即`obj = …`)会影响原来的对象(`module.obj`)。
*   因此，导入模块(`import module`)而不是从中导入对象(`from module import obj`)更安全。这是因为您总是在直接位于模块中的对象上工作，而不会创建它们的副本。因此，跟踪原始对象(位于`module`的对象)发生的事情就足够了，无论其他各种模块对这个对象做什么，它们都会对原始对象这样做。当你需要创建一个副本时，你可以在你需要的地方显式地做。

最后一点也许是最关键的。当你确实需要一个副本时，创建它，但是在你需要这个副本的地方明确地做它。通过特定的导入方式来创建副本，肯定是隐性的、间接的、不明确的。初学者甚至一些中级 python 爱好者可能会忘记，或者根本不知道，`from module import obj`创建了`module.obj`的副本或新名称，并且`__main__`模块的作用域现在包含两个对象:

*   在不可变对象的情况下，`module.obj`和`obj`对象；
*   在可变对象的情况下，它实际上是一个有两个名字的对象:`module.obj`和`obj.`

当然，当您在一个模块中更改另一个模块中的对象时，所有这些都很重要。那你一定要小心，这是我们讨论的所有这些事情都可能发生的时候。

我认为通过导入来避免创建对象副本的混乱要好得多。这就是为什么，至少在这种情况下，导入一个模块比从它导入对象更安全。

# 资源

*   Lutz M. (2013 年)。*学习 Python* 。第五版。奥莱利媒体。
*   拉马尔霍湖(2022 年)。*流畅的 Python。清晰、简洁、有效的编程*。第二。版本。奥赖利。