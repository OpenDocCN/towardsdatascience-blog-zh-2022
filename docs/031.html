<html>
<head>
<title>Visualization in Python: Finding Routes between Points</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的可视化:寻找点与点之间的路径</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualization-in-python-finding-routes-between-points-2d97d4881996#2022-01-03">https://towardsdatascience.com/visualization-in-python-finding-routes-between-points-2d97d4881996#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="e283" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Python中的可视化:寻找点与点之间的路径</h1></div><div class=""><h2 id="616c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何对您的位置进行地理编码，并根据距离、出行模式和时间计算两点之间的最短路径</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1daaad06276cdbb943888b8b65e59116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BQxD9sAy4ll3Zlx_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蒂莫·维林克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章中，我谈到了使用leav库可视化您的地理空间数据。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/visualization-in-python-visualizing-geospatial-data-122bf85d128f"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python中的可视化-可视化地理空间数据</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解如何使用Learn轻松显示地图和标记</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="551e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员经常必须使用地理空间数据执行的另一项任务是绘制各种兴趣点之间的路由路径。因此，在这篇文章中，我将向您展示如何:</p><ul class=""><li id="632c" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">对您的位置进行地理编码</li><li id="8f34" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">查找两个位置之间的最短距离</li></ul><h1 id="b818" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">安装OSMnx</h1><p id="d8d2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">布线的第一步是安装<strong class="lb iu"> OSMnx </strong>包。</p><blockquote class="ny nz oa"><p id="f615" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated"><strong class="lb iu"> OSMnx </strong>是一个Python包，允许您从OpenStreetMap下载地理空间数据，并对现实世界的街道网络和任何其他地理空间几何图形进行建模、投影、可视化和分析。</p></blockquote><p id="9a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装OSMnx包有点棘手——在执行通常的<code class="fe of og oh oi b">pip/conda install</code>之前，您必须使用以下步骤:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="494e" class="on nc it oi b gy oo op l oq or">$ <strong class="oi iu">conda config --prepend channels conda-forge</strong><br/>$ conda install osmnx</span></pre><blockquote class="ny nz oa"><p id="b1af" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意:如果<code class="fe of og oh oi b">conda install osmnx</code>失效，使用<code class="fe of og oh oi b">pip install osmnx</code></p></blockquote><p id="ad1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦执行了上述步骤，OSMnx现在应该可以使用了。</p><h1 id="6990" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">寻找最短的路线</h1><p id="9c09" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">您现在可以使用<strong class="lb iu"> OSMnx </strong>包和<strong class="lb iu"> NetworkX </strong>包来查找两点之间的路线。</p><blockquote class="ny nz oa"><p id="dac0" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">NetworkX是一个Python包，用于创建、操作和研究复杂网络的结构、动态和功能。</p></blockquote><p id="08e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段查找旧金山两个地点之间的最短步行距离:</p><blockquote class="ny nz oa"><p id="9264" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated"><strong class="lb iu">以下代码已更新，可使用最新版本的OSMnx (1.3.0) </strong></p></blockquote><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="ae59" class="on nc it oi b gy oo op l oq or">import osmnx as ox<br/>import networkx as nx</span><span id="0cd8" class="on nc it oi b gy os op l oq or">ox.settings.log_console=True<br/>ox.settings.use_cache=True</span><span id="8012" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># define the start and end locations in latlng</strong><br/>start_latlng = (37.78497,-122.43327)<br/>end_latlng = (37.78071,-122.41445)</span><span id="74ae" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># location where you want to find your route</strong><br/>place     = 'San Francisco, California, United States'</span><span id="b6e5" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># find shortest route based on the mode of travel</strong><br/>mode      = 'walk'        # 'drive', 'bike', 'walk'</span><span id="6d2f" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># find shortest path based on distance or time</strong><br/>optimizer = 'time'        # 'length','time'</span><span id="561f" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># create graph from OSM within the boundaries of some <br/># geocodable place(s)</strong><br/>graph = ox.graph_from_place(place, network_type = mode)</span><span id="5153" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># find the nearest node to the start location</strong><br/>orig_node = ox.distance.nearest_nodes(graph, start_latlng[1],<br/>                                      start_latlng[0])</span><span id="016d" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># find the nearest node to the end location</strong><br/>dest_node = ox.distance.nearest_nodes(graph, end_latlng[1],<br/>                                      end_latlng[0])</span><span id="7c14" class="on nc it oi b gy os op l oq or"><strong class="oi iu">#  find the shortest path</strong><br/>shortest_route = nx.shortest_path(graph,<br/>                                  orig_node,<br/>                                  dest_node,<br/>                                  weight=optimizer)</span></pre><blockquote class="ny nz oa"><p id="fe5b" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">寻找最短路径的默认方法是“<code class="fe of og oh oi b">dijkstra</code>”。您可以通过将<code class="fe of og oh oi b">shortest_path()</code>功能的<code class="fe of og oh oi b">method</code>参数设置为“<code class="fe of og oh oi b">bellman-ford</code>”来进行更改。</p></blockquote><p id="3466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">shortest_route</code>变量现在保存了在最短的<em class="ob">时间内</em>从一点走到另一点的<em class="ob">路径的集合:</em></p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="833d" class="on nc it oi b gy oo op l oq or">[5287124093,<br/> 65314192,<br/> 258759765,<br/> 65314189,<br/> 5429032435,<br/> 65303568,<br/> 65292734,<br/> 65303566,<br/> 2220968863,<br/> 4014319583,<br/> 65303561,<br/> 65303560,<br/> 4759501665,<br/> 65303559,<br/> 258758548,<br/> 4759501667,<br/> 65303556,<br/> 65303554,<br/> 65281835,<br/> 65303553,<br/> 65303552,<br/> 65314163,<br/> 65334128,<br/> 65317951,<br/> 65333826,<br/> 65362158,<br/> 65362154,<br/> 5429620634,<br/> 65308268,<br/> 4064226224,<br/> 7240837048,<br/> 65352325,<br/> 7240837026,<br/> 7240837027]</span></pre><h1 id="7bf8" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">绘制路径</h1><p id="0a9a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">显然，拥有一个路径列表本身并没有多大用处。解释结果的更有意义的方法是使用<code class="fe of og oh oi b">plot_route_folium()</code>函数绘制路径:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="84ed" class="on nc it oi b gy oo op l oq or">shortest_route_map = ox.<strong class="oi iu">plot_route_folium</strong>(graph, shortest_route)<br/>shortest_route_map</span></pre><p id="6586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">plot_route_folium()</code>函数返回一个树叶地图(<code class="fe of og oh oi b">folium.folium.Map</code>)。当显示在Jupyter笔记本上时，它看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/0ffab5a4e2e956992b0796e52fc29b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSOkHEiU1-8qdeTGzzVR5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="59aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的默认tileset是<code class="fe of og oh oi b">cartodbpositron</code>。如果您想要更改它，您可以将<code class="fe of og oh oi b">tiles</code>参数设置为您想要使用的tileset。以下代码片段显示了使用<code class="fe of og oh oi b">openstreetmap</code> tileset显示的地图:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="3438" class="on nc it oi b gy oo op l oq or">shortest_route_map = ox.plot_route_folium(graph, shortest_route, <br/>                                          <strong class="oi iu">tiles='openstreetmap'</strong>)<br/>shortest_route_map</span></pre><p id="0512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是使用<code class="fe of og oh oi b">openstreetmap</code> tileset显示的地图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/5d8ce9a08b5cc1af2345e58581e5d2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlLEZGjud-JGviPVyY8G4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想让用户在运行时选择他们的首选tileset，请使用下面的代码片段:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="8cb0" class="on nc it oi b gy oo op l oq or">import folium</span><span id="e051" class="on nc it oi b gy os op l oq or">folium.TileLayer('openstreetmap').add_to(shortest_route_map)<br/>folium.TileLayer('Stamen Terrain').add_to(shortest_route_map)<br/>folium.TileLayer('Stamen Toner').add_to(shortest_route_map)<br/>folium.TileLayer('Stamen Water Color').add_to(shortest_route_map)<br/>folium.TileLayer('cartodbpositron').add_to(shortest_route_map)<br/>folium.TileLayer('cartodbdark_matter').add_to(shortest_route_map)</span><span id="1c1d" class="on nc it oi b gy os op l oq or">folium.LayerControl().add_to(shortest_route_map)</span><span id="4a3e" class="on nc it oi b gy os op l oq or">shortest_route_map</span></pre><p id="859f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户现在可以选择自己的tileset来显示地图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/0b04050ca46d6632d03385760d174ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xjr5y9LDKuCeDN_UcH6oKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="a57d" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">改变出行模式和优化器</h1><p id="ee13" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">除了寻找步行的最短路径，您还可以绘制驾驶的最短路径:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="3d02" class="on nc it oi b gy oo op l oq or"># find shortest route based on the mode of travel<br/>mode      = '<strong class="oi iu">drive</strong>'       # 'drive', 'bike', 'walk'</span><span id="ea38" class="on nc it oi b gy os op l oq or"># find shortest path based on distance or time<br/>optimizer = 'time'        # 'length','time'</span></pre><p id="88f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是驾驶路径:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8ef4c21c20420ad1c3ffc093059d238f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsZUiVDsRU6blkMtlpcWmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="446c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骑自行车怎么样？</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="2343" class="on nc it oi b gy oo op l oq or"># find shortest route based on the mode of travel<br/>mode      = '<strong class="oi iu">bike</strong>'       # 'drive', 'bike', 'walk'</span><span id="f689" class="on nc it oi b gy os op l oq or"># find shortest path based on distance or time<br/>optimizer = 'time'       # 'length','time'</span></pre><p id="33b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是骑自行车的最短路径:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/2a855e77e9b4abf0db809aacdf183597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*toe-Kd91LI2p18oPNanWhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以根据距离而不是时间来查找最短路径:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="79d2" class="on nc it oi b gy oo op l oq or"># find shortest route based on the mode of travel<br/>mode      = 'bike'       # 'drive', 'bike', 'walk'</span><span id="70d2" class="on nc it oi b gy os op l oq or"># find shortest path based on distance or time<br/>optimizer = '<strong class="oi iu">length</strong>'     # 'length','time'</span></pre><p id="f572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是骑自行车的最短距离:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/b75408d259eb894d2102b2351edf08d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oV70LiQfDWC6pjwwCJ-HVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会把剩下的组合留给你去尝试。</p><h1 id="0dd9" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">地理编码您的位置</h1><p id="a565" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在两点之间查找路径时，指定位置的纬度和经度并不方便(除非您的数据集中已经有了坐标)。相反，指定它们的友好名称要容易得多。您实际上可以使用<strong class="lb iu"> geopy </strong>模块来执行这个步骤(称为<em class="ob">地理编码</em>)。</p><blockquote class="ny nz oa"><p id="71f3" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated"><strong class="lb iu">地理编码</strong>是将地址转换成其坐标的过程。<strong class="lb iu">反向地理编码</strong>则是将一对坐标变成一个友好的地址。</p></blockquote><p id="a3d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装<strong class="lb iu"> geopy </strong>模块，在终端中键入以下命令:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="b565" class="on nc it oi b gy oo op l oq or">$ <strong class="oi iu">pip install geopy</strong></span></pre><p id="2b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段为OpenStreetMap数据创建了一个<code class="fe of og oh oi b">Nominatim</code>地理编码器类的实例。然后它调用<code class="fe of og oh oi b">geocode()</code>方法对<em class="ob">金门大桥</em>的位置进行地理编码。使用地理编码位置，您现在可以提取位置的纬度和经度:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="5195" class="on nc it oi b gy oo op l oq or">from geopy.geocoders import Nominatim</span><span id="8e33" class="on nc it oi b gy os op l oq or">locator = Nominatim(user_agent = "myapp")<br/>location = locator.geocode("Golden Gate Bridge")</span><span id="0341" class="on nc it oi b gy os op l oq or">print(location.latitude, location.longitude)<br/># 37.8303213 -122.4797496</span><span id="6973" class="on nc it oi b gy os op l oq or">print(location.point)<br/># 37 49m 49.1567s N, 122 28m 47.0986s W</span><span id="2bd1" class="on nc it oi b gy os op l oq or">print(type(location.point))<br/># &lt;class 'geopy.point.Point'&gt;</span></pre><p id="dac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以到<a class="ae ky" href="https://www.google.com/maps" rel="noopener ugc nofollow" target="_blank">https://www.google.com/maps</a>验证结果，并将经纬度粘贴到搜索框中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/1c277038ca4f82f3802f582be9e2041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7_NhnuEOJfFTe2OKNCaGw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们修改我们的原始代码，以便我们可以对起点和终点进行地理编码:</p><blockquote class="ny nz oa"><p id="8dc8" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated"><strong class="lb iu">以下代码已更新，可使用最新版本的OSMnx (1.3.0) </strong></p></blockquote><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="9ff3" class="on nc it oi b gy oo op l oq or">import osmnx as ox<br/>import networkx as nx</span><span id="05e8" class="on nc it oi b gy os op l oq or">ox.settings.log_console=True<br/>ox.settings.use_cache=True</span><span id="8aec" class="on nc it oi b gy os op l oq or"><strong class="oi iu">from geopy.geocoders import Nominatim<br/>locator = Nominatim(user_agent = "myapp")</strong></span><span id="5099" class="on nc it oi b gy os op l oq or"># define the start and end locations in latlng<br/><strong class="oi iu"># </strong>start_latlng = (37.78497,-122.43327)<br/><strong class="oi iu"># </strong>end_latlng = (37.78071,-122.41445)</span><span id="e62f" class="on nc it oi b gy os op l oq or"><strong class="oi iu">start_location = "Hilton San Francisco Union Square"<br/>end_location = "Golden Gateway Tennis &amp; Swim Club"</strong></span><span id="4686" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># stores the start and end points as geopy.point.Point objects<br/>start_latlng = locator.geocode(start_location).point<br/>end_latlng = locator.geocode(end_location).point</strong></span><span id="7e10" class="on nc it oi b gy os op l oq or"># location where you want to find your route<br/>place     = 'San Francisco, California, United States'</span><span id="0171" class="on nc it oi b gy os op l oq or"># find shortest route based on the mode of travel<br/>mode      = 'bike'       # 'drive', 'bike', 'walk'</span><span id="7e45" class="on nc it oi b gy os op l oq or"># find shortest path based on distance or time<br/>optimizer = 'length'        # 'length','time'</span><span id="95d3" class="on nc it oi b gy os op l oq or"># create graph from OSM within the boundaries of some <br/># geocodable place(s)<br/>graph = ox.graph_from_place(place, network_type = mode)</span><span id="a737" class="on nc it oi b gy os op l oq or"># find the nearest node to the start location<br/>orig_node = ox.distance.nearest_nodes(graph, <strong class="oi iu">start_latlng[1], <br/>                                      start_latlng[0]</strong>)</span><span id="d8af" class="on nc it oi b gy os op l oq or"># find the nearest node to the end location<br/>dest_node = ox.distance.nearest_nodes(graph, <strong class="oi iu">end_latlng[1],<br/>                                      end_latlng[0]</strong>)</span><span id="2310" class="on nc it oi b gy os op l oq or">...</span></pre><blockquote class="ny nz oa"><p id="23cd" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意，<code class="fe of og oh oi b">get_nearest_node()</code>函数可以接受位置坐标，或者是包含纬度和经度的元组，或者是一个<code class="fe of og oh oi b">geopy.point.Point</code>对象。</p></blockquote><p id="8b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是从联合广场<em class="ob">希尔顿酒店</em><em class="ob"/>到旧金山<em class="ob">黄金门户网球&amp;游泳俱乐部</em>的最短骑行距离:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/35d38a6479c349ea9f19ede1be841e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5isL5FQrsyB741uGG2PoOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="dd98" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">显示起点和终点的标记</h1><p id="f8a7" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果你能显示指示起点和终点的标记，那就更清楚了。正如我在上一篇文章中所描述的，您可以使用follow中的<code class="fe of og oh oi b">Marker</code>类来显示带有弹出窗口的标记。</p><p id="c993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段显示了两个标记，绿色表示起点，红色表示终点:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="1dda" class="on nc it oi b gy oo op l oq or">import folium</span><span id="fb94" class="on nc it oi b gy os op l oq or"><strong class="oi iu"># Marker class only accepts coordinates in tuple form</strong><br/>start_latlng = (start_latlng[0],start_latlng[1])<br/>end_latlng   = (end_latlng[0],end_latlng[1])</span><span id="62a0" class="on nc it oi b gy os op l oq or">start_marker = folium.Marker(<br/>            location = start_latlng,<br/>            popup = start_location,<br/>            icon = folium.Icon(color='green'))</span><span id="1dd1" class="on nc it oi b gy os op l oq or">end_marker = folium.Marker(<br/>            location = end_latlng,<br/>            popup = end_location,<br/>            icon = folium.Icon(color='red'))</span><span id="a5dd" class="on nc it oi b gy os op l oq or"># add the circle marker to the map<br/>start_marker.add_to(shortest_route_map)<br/>end_marker.add_to(shortest_route_map)</span><span id="0f14" class="on nc it oi b gy os op l oq or">shortest_route_map</span></pre><blockquote class="ny nz oa"><p id="a2bf" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated">注意<code class="fe of og oh oi b">Marker</code>类只接受元组形式的坐标。因此，您需要修改<code class="fe of og oh oi b">start_latlng</code>和<code class="fe of og oh oi b">end_latlng</code>成为包含纬度和经度的元组。</p></blockquote><p id="b366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是指示路径起点和终点的两个标记:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/2c055d430b03247358d66f29c686277a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSAa5b0wJ5Zcj0O92AIV8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="4861" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">绘制静态图</h1><p id="170e" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在前面的部分中，您使用了<code class="fe of og oh oi b">plot_route_folium()</code>函数在一张树叶地图上绘制两点的最短路径:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="6e84" class="on nc it oi b gy oo op l oq or">shortest_route_map = ox.<strong class="oi iu">plot_route_folium</strong>(graph, shortest_route)<br/>shortest_route_map</span></pre><p id="95df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个你可能会感兴趣的功能——<code class="fe of og oh oi b">plot_graph_route()</code>。它不是输出交互式地图，而是生成静态图形。如果你想制作一个海报/图像显示两点的路径，这是很有用的。</p><p id="5835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段使用上一节中使用的点生成了一个静态图:</p><blockquote class="ny nz oa"><p id="4eb9" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated"><strong class="lb iu">以下代码已更新，可使用最新版本的OSMnx (1.3.0) </strong></p></blockquote><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="adab" class="on nc it oi b gy oo op l oq or">import osmnx as ox<br/>import networkx as nx</span><span id="257d" class="on nc it oi b gy os op l oq or">ox.settings.log_console=True<br/>ox.settings.use_cache=True</span><span id="8693" class="on nc it oi b gy os op l oq or">graph = ox.graph_from_place(place, network_type = mode)</span><span id="6a1e" class="on nc it oi b gy os op l oq or">orig_node = ox.distance.nearest_nodes(graph, start_latlng[1],<br/>                                      start_latlng[0])<br/>dest_node = ox.distance.nearest_nodes(graph, end_latlng[1],<br/>                                      end_latlng[0])</span><span id="4c8d" class="on nc it oi b gy os op l oq or">shortest_route = nx.shortest_path(graph, <br/>                                  orig_node, <br/>                                  dest_node, <br/>                                  weight=optimizer)</span><span id="8f25" class="on nc it oi b gy os op l oq or">fig, ax = <strong class="oi iu">ox.plot_graph_route</strong>(graph,<br/>                              shortest_route,<br/>                              save=True)</span></pre><p id="5b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/d0e34befc71ce3e4bf41e4ba4ff20fb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*ns4ioymT7osl5BHw6jIFSQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="e573" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">摘要</h1><p id="37cf" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我希望你从这篇文章中找到灵感，并开始使用它来创建兴趣点的路线。您可能希望让用户输入他们的当前位置，然后绘制路线，向他们显示如何到达目的地。无论如何，玩得开心！</p><div class="lv lw gp gr lx ly"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">weimenglee.medium.com</p></div></div><div class="mh l"><div class="pb l mj mk ml mh mm ks ly"/></div></div></a></div><blockquote class="ny nz oa"><p id="fefc" class="kz la ob lb b lc ld ju le lf lg jx lh oc lj lk ll od ln lo lp oe lr ls lt lu im bi translated"><strong class="lb iu">参考文献</strong>:波音，G. 2017。<a class="ae ky" href="https://geoffboeing.com/publications/osmnx-complex-street-networks/" rel="noopener ugc nofollow" target="_blank"> OSMnx:获取、构建、分析和可视化复杂街道网络的新方法</a>。<em class="it">计算机、环境和城市系统</em> 65，126–139。doi:10.1016/j . compenurbsys . 2017 . 05 . 004</p></blockquote></div></div>    
</body>
</html>