<html>
<head>
<title>Survival Analysis in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的生存分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/survival-analysis-in-python-a-quick-guide-to-the-weibull-analysis-5babd4f137f6#2022-01-19">https://towardsdatascience.com/survival-analysis-in-python-a-quick-guide-to-the-weibull-analysis-5babd4f137f6#2022-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="0ec3" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Python中的生存分析</h1></div><div class=""><h2 id="4b39" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">威布尔分析快速指南</h2></div><p id="e95e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">威布尔分析因其灵活性和直观性在可靠性工程师中非常流行。本指南将通过示例代码演示威布尔分析的基本概念。为了进行威布尔分析，我们将使用开源Python包<a class="ae lb" href="https://pypi.org/project/predictr/" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lc"/></strong></a><em class="lc">。</em></p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/a3cf37841c7f4609e31c9d5fcf21bfc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S8nzsYDiUYQpBCriYTPa_g.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fefe" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">目录</h1><ol class=""><li id="d15d" class="ms mt iq kh b ki mu kl mv ko mw ks mx kw my la mz na nb nc bi translated"><a class="ae lb" href="#3bf2" rel="noopener ugc nofollow">安装和使用<strong class="kh ir"> <em class="lc">预测</em> </strong> </a></li><li id="34c5" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae lb" href="#2931" rel="noopener ugc nofollow">威布尔图</a></li><li id="fb61" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae lb" href="#4837" rel="noopener ugc nofollow">参数估计:MRR vs. MLE </a></li><li id="36df" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae lb" href="#c6b3" rel="noopener ugc nofollow">置信区间</a></li><li id="ff39" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae lb" href="#1829" rel="noopener ugc nofollow">偏差修正</a></li><li id="77e8" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae lb" href="#cc4a" rel="noopener ugc nofollow">综合地块</a></li><li id="2c73" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated"><a class="ae lb" href="#d5c4" rel="noopener ugc nofollow">结论</a></li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3bf2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">安装和使用<strong class="ak">和<em class="ni">预测器</em>和</strong></h1><p id="28fe" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">您需要安装Python 3(版本&gt; 3.5)。如果您是Python的新手，只需下载<a class="ae lb" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> anaconda </a>并根据<a class="ae lb" href="https://docs.anaconda.com/" rel="noopener ugc nofollow" target="_blank"> anaconda文档</a>建立一个虚拟环境，例如将这段代码分别粘贴到终端(macOS，Linux)和命令(Windows)中:</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="536f" class="nr mb iq nn b gy ns nt l nu nv">conda create -n my_env python=3.10</span></pre><p id="3a0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码用Python 3.10创建了一个名为<em class="lc"> my_env </em>的新虚拟环境。请随意更改名称和Python版本。</p><p id="d995" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步包括在终端(或命令)中使用<a class="ae lb" href="https://pip.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> pip </a>进行安装预测:</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="2bf0" class="nr mb iq nn b gy ns nt l nu nv">conda activate my_env<br/>pip install predictr</span></pre><p id="086a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在您选择的IDE或文本编辑器中使用predictr，只需在python文件中导入<em class="lc"> predictr </em>模块:</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="5527" class="nr mb iq nn b gy ns nt l nu nv">import predictr</span></pre><p id="258a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" href="https://pypi.org/project/predictr/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lc">预测</em> </strong> </a>有两个类:<em class="lc">分析</em>用于威布尔分析，而<em class="lc"> PlotAll </em>用于详细绘图。关于<em class="lc">预测</em>的综合文档，包含许多示例，请查看<a class="ae lb" href="https://tvtoglu.github.io/predictr/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2931" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">威布尔图</h1><p id="38f8" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">概率图允许掌握当前数据的概念，并相互比较回归线，即故障模式和故障数据。在威布尔分析中，该图称为威布尔概率图。理解剧情至关重要。通常，情节包括…</p><ul class=""><li id="e469" class="ms mt iq kh b ki kj kl km ko nw ks nx kw ny la nz na nb nc bi translated">双对数y轴(不可靠性)，</li><li id="0b36" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la nz na nb nc bi translated">对数x轴(无故障时间，例如循环次数)，</li><li id="1601" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la nz na nb nc bi translated">威布尔线(威布尔形状和尺度参数的参数估计)和给定数据的中间等级，</li><li id="e8fe" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la nz na nb nc bi translated">和置信界限(单侧或双侧)。</li></ul><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi oa"><img src="../Images/e60b2f733ecfc1f6cbfd1bcd36f93b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofcmBQ79oNJHD7RJ6ckxIw.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">威布尔概率图(图片由作者提供)</p></figure><p id="33fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图例是可选的，但是建议显示以下信息:样本大小n(=失败次数f +暂停次数s)、正在使用的参数估计方法(最大似然估计(MLE)或中值秩回归(MRR)或其他)、实际估计的威布尔参数(β和η)、正在使用的置信界限方法(费希尔界限、似然比界限、Bootstrap界限、β-二项式界限、蒙特卡罗关键界限等)以及置信水平。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="4837" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">参数估计:MRR与最大似然估计</h1><p id="006f" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">极大似然估计和MRR都可以用来估计威布尔形状和尺度参数。在本教程中，我们认为威布尔位置参数为零，即双参数威布尔分布:</p><ul class=""><li id="a20f" class="ms mt iq kh b ki kj kl km ko nw ks nx kw ny la nz na nb nc bi translated">形状参数β代表威布尔线的斜率，描述了故障模式(-&gt;著名的<em class="lc">浴盆曲线</em></li><li id="49e1" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la nz na nb nc bi translated">比例参数η定义为不可靠性为63.2 %时的x轴值</li></ul><p id="a46c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们从测试中收集了以下II型右删失数据:</p><ol class=""><li id="4de1" class="ms mt iq kh b ki kj kl km ko nw ks nx kw ny la mz na nb nc bi translated">失败次数:0.4508831，0.68564703，0.76826143，0.88231395，1.48287253，1.62876357(共6次失败)</li><li id="bf28" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">停牌:1.62876357，1.62876357，1.62876357，1.62876357(共4次停牌)</li></ol><p id="c098" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的数据被审查，因此我们必须处理暂停。悬架是指在测试过程中没有出现故障的装置。MRR和MLE处理这些信息的方式不同。</p><h2 id="445a" class="nr mb iq bd mc ob oc dn mg od oe dp mk ko of og mm ks oh oi mo kw oj ok mq ol bi translated">维护、修理和更换</h2><p id="f321" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">中位秩回归使用所谓的中位秩和最小二乘法来确定威布尔参数。中间等级是每次故障的不可靠性(或可靠性)估计值(MRR不能考虑截尾时间，只能考虑暂停的总次数)。更准确地说，MRR估计是基于单个故障时间的中间等级，而不是实际故障时间值。</p><p id="4848" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<em class="lc">预测</em>中的分析类来进行威布尔分析。</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="b9d8" class="nr mb iq nn b gy ns nt l nu nv">from predictr import Analysis</span><span id="0d64" class="nr mb iq nn b gy om nt l nu nv"># Data from testing<br/># Failures and suspensions are lists containing the values</span><span id="2585" class="nr mb iq nn b gy om nt l nu nv">failures = [0.4508831,  0.68564703, 0.76826143, 0.88231395, 1.48287253, 1.62876357]<br/>suspensions = [1.62876357, 1.62876357, 1.62876357, 1.62876357]</span><span id="4232" class="nr mb iq nn b gy om nt l nu nv"># Weibull Analysis<br/>x = Analysis(<em class="lc">df</em>=failures, ds=suspensions, <em class="lc">show</em>=True)<br/>x.mrr()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi on"><img src="../Images/ba8ed8a15ffb37f69d8186cd56a02415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*_tGhnxg3Ypk2ORhUpz8IAg.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">MRR给定数据(图片由作者提供)</p></figure><h2 id="ac4e" class="nr mb iq bd mc ob oc dn mg od oe dp mk ko of og mm ks oh oi mo kw oj ok mq ol bi translated">MLE</h2><p id="2174" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">与MRR相比，MLE考虑实际故障和暂停时间。增加悬架的数量主要增加威布尔尺度参数，形状参数估计没有显著变化。我们对相同的数据执行MLE(注意:<em class="lc">分析</em>已经导入):</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="4973" class="nr mb iq nn b gy ns nt l nu nv"># Data from testing<br/># Failures and suspensions are lists containing the values</span><span id="ba89" class="nr mb iq nn b gy om nt l nu nv">failures = [0.4508831,  0.68564703, 0.76826143, 0.88231395, 1.48287253, 1.62876357]<br/>suspensions = [1.62876357, 1.62876357, 1.62876357, 1.62876357]</span><span id="5afa" class="nr mb iq nn b gy om nt l nu nv"># Weibull Analysis<br/>x = Analysis(<em class="lc">df</em>=failures, ds=suspensions, <em class="lc">show</em>=True)<br/>x.mle()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi on"><img src="../Images/9a5efced1614c08aedbece67bdf81453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*wlFTLByHuFm8KFNFaQ8HdQ.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">给定数据的MLE(图片由作者提供)</p></figure><p id="6f73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">统计值被存储为<em class="lc">分析中对象的所谓属性。因此，我们可以打印和/或保存它们。查看predictr的官方文档，了解所有对象属性的概况。</em></p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="86d6" class="nr mb iq nn b gy ns nt l nu nv"># We are using f-strings<br/># x and y are the names of the class objects we created (see code above)<br/># beta and eta are the attributes we want to access and print<br/># Just type <em class="lc">object</em>.<em class="lc">attribute to access them<br/># e.g. for the object x type the following: x.beta or x.eta</em></span><span id="9ea1" class="nr mb iq nn b gy om nt l nu nv">print(f'MRR: beta={x.beta:2f}, eta={x.eta:2f}\nMLE: beta={y.beta:2f}, eta={y.eta:2f}\n')</span><span id="be4e" class="nr mb iq nn b gy om nt l nu nv"># Output<br/>&gt;&gt;&gt; MRR: beta=1.760834, eta=1.759760<br/>    MLE: beta=2.003876, eta=1.707592</span></pre><h1 id="c6b3" class="ma mb iq bd mc md oo mf mg mh op mj mk jw oq jx mm jz or ka mo kc os kd mq mr bi translated">置信区间</h1><p id="cc6c" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">仅仅使用点估计是有风险的，特别是当你只有少量测试失败的单元时。假设估计的样本统计量(例如威布尔参数)接近或者甚至等于总体统计量将可能导致错误的安全感。<strong class="kh ir">通常建议</strong>在威布尔分析中使用置信界限方法。通过使用置信区间，我们可以有把握地假设实际真实总体(或基础事实)威布尔线位于该区间内。因此，我们不太可能高估我们系统的可靠性。典型的置信区间是90%，这意味着置信下限<strong class="kh ir">可以设为5%，置信上限设为95%。界限也可以设置为1%和91%。如你所见，区间仅由上下界之差定义，不必对称。</strong></p><p id="e98a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，有两种界限:</p><ol class=""><li id="7b86" class="ms mt iq kh b ki kj kl km ko nw ks nx kw ny la mz na nb nc bi translated">故障时间轴上固定不可靠性/可靠性值的界限(例如R(t)=80%)，例如下限:5000小时，上限:7000小时。</li><li id="b115" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">不可靠性/可靠性轴上的固定故障时间(例如t= 6000小时)值的界限，例如下限:R(t)=20%，上限:R(t)=38%。</li></ol><p id="3933" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有大量的置信界限方法可供选择。我将很快发表后续媒体文章，介绍在何种情况下选择何种方法。下表列出了<em class="lc"> predictr </em>支持的置信界限方法。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ot"><img src="../Images/ce9940f1d617e14230f33fcda78f6251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUTAXHrk2NWXqoheAIP1NA.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">predictr中支持的置信界限方法概述(图片由作者提供)</p></figure><p id="48e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以选择双面(2s)和单面(1sl:单面下；1su:单侧上)置信界限。除了β-二项式界限以外，所有方法都使用固定不可靠性/可靠性值的界限。通过更改参数值，可以自定义威布尔分析。</p><p id="0bba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对已经使用过的相同数据使用β-二项式界限:</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="2ad0" class="nr mb iq nn b gy ns nt l nu nv">from predictr import Analysis</span><span id="6924" class="nr mb iq nn b gy om nt l nu nv"># Data from testing<br/>failures = [0.4508831,  0.68564703, 0.76826143, 0.88231395, 1.48287253, 1.62876357]<br/>suspensions = [1.62876357, 1.62876357, 1.62876357, 1.62876357]</span><span id="824f" class="nr mb iq nn b gy om nt l nu nv"># Weibull Analysis with two-sided bounds and a plot<br/>x = Analysis(<em class="lc">df</em>=failures, <em class="lc">ds</em>=suspensions, <em class="lc">show</em>=True, <em class="lc">bounds</em>='bbb', <em class="lc">bounds_type</em>='2s')<br/>x.mrr()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8b485148f3e60ea67beddedb2d22f948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*a-eK0-TUwu97eFWGBoGzwg.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">MRR与贝塔二项式界限(图片由作者提供)</p></figure><p id="3192" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们进行最大似然估计，并对相同的数据使用双侧似然比界限:</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="277f" class="nr mb iq nn b gy ns nt l nu nv">from predictr import Analysis</span><span id="bb9a" class="nr mb iq nn b gy om nt l nu nv"># Data from testing<br/>failures = [0.4508831,  0.68564703, 0.76826143, 0.88231395, 1.48287253, 1.62876357]<br/>suspensions = [1.62876357, 1.62876357, 1.62876357, 1.62876357]</span><span id="b5ff" class="nr mb iq nn b gy om nt l nu nv"># Weibull Analysis<br/>x = Analysis(<em class="lc">df</em>=failures, <em class="lc">ds</em>=suspensions, <em class="lc">show</em>=True, <em class="lc">bounds</em>='lrb', <em class="lc">bounds_type</em>='2s')<br/>x.mle()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi on"><img src="../Images/37dceaa2ec6f89365e9fe2c52d73a24d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*maMxo7e7ciaYMr9BdYenEA.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">具有似然比界限的MLE(图片由作者提供)</p></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1829" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">偏差校正</h1><p id="dbee" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">小样本量或失败次数会导致有偏差的威布尔参数估计。对于足够小或足够大的样本量，没有明确定义的硬性限制。模拟数据显示，无论使用哪种参数估计和置信界限方法，样本大小等于或大于20往往会导致更精确的估计。但在实践中，可靠性工程师经常不得不处理小得多的样本量。因此，偏差校正方法的使用相当普遍。<em class="lc">预测器</em>支持<em class="lc"> </em>以下偏差校正方法:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ou"><img src="../Images/8e6603c5968c882dd66260ae5dd74d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZgalPheZ87-Hy96XsE52OQ.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">predictr中支持的偏差校正方法概述(图片由作者提供)</p></figure><blockquote class="ov ow ox"><p id="ac19" class="kf kg lc kh b ki kj jr kk kl km ju kn oy kp kq kr oz kt ku kv pa kx ky kz la ij bi translated">偏差修正影响威布尔参数的估计以及置信界限。使用偏差修正方法精确估计威布尔参数不会自动产生更精确的置信界限！并非所有的置信界限对偏差修正都同样敏感。关于这个话题的更多信息，你可以查看我关于偏差修正的出版物。</p></blockquote><p id="3c45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解有偏差估计的影响以及偏差修正是如何工作的，让我们进行一个蒙特卡罗(MC)研究。我们将从预先确定的威布尔分布(β =2，η=1，也就是我们的基本事实)中反复抽取<strong class="kh ir">个随机样本</strong>(样本大小n=6，未经审查)，并对每个样本进行威布尔分析。对于每个样本，生成的威布尔线将绘制在威布尔概率图中。MC试验次数设置为10，000次。所有随机抽取的样本都用蓝线表示，而地面真实颜色设置为红色。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi on"><img src="../Images/5c7f848a6c121e2411bd21ea19debf0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*lYS6rv6NBo1lvs3SUernjA.png"/></div></figure><p id="7305" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从图中可以看出，尽管样本来自相同的威布尔分布，但对于n=6，估计的威布尔参数变化很大。这表明小样本量会产生有偏差的估计。将样本量增加到40会降低估计值的偏差(绘制的威布尔线通常更接近实际情况)。这是意料之中的，因为MLE是渐近无偏的。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8fe23f9f33b756ba04da0a0cf29a1f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*tpXijAYOT_1MSW4h8d45nw.png"/></div></figure><p id="47ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了所有10，000个估计威布尔参数的直方图。对于小样本量，形状参数往往被高估，并且不是对称分布的(与尺度参数相反)。这就是为什么几乎所有的偏差校正方法只关注形状参数并试图减小它的原因。大多数偏倚校正是从MC研究的基础事实和样本均值(或样本中值)之间的差异中得出一个校正因子。请记住，当实际估计值已经被低估时，这些偏差修正可能会错误地向下调整估计值。但总的来说，偏差修正方法应该按照预期的方式发挥作用。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi pb"><img src="../Images/5e203f12ec0be7f83d388607b0d85198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VpgJpQo21PfDy0_RQY0pA.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">作者图片</p></figure><p id="d6fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lc">预测</em>中，<em class="lc"> bcm </em>参数设置偏差校正。我们将从双参数威布尔分布中随机抽取一个未经审查的样本，并对估计值进行偏差修正。</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="70b4" class="nr mb iq nn b gy ns nt l nu nv"># Needed imports<br/>from scipy.stats import weibull_min<br/>from predictr import Analysis<br/>import numpy as np</span><span id="5a35" class="nr mb iq nn b gy om nt l nu nv"># Draw one random sample with a set seed for reproducibility np.random.seed<em class="lc">(seed</em>=42)<br/>sample = np.sort(weibull_min.rvs(2, <em class="lc">loc</em> = 0, <em class="lc">scale</em> = 1, <em class="lc">size </em>= 4))</span><span id="46e8" class="nr mb iq nn b gy om nt l nu nv">x = Analysis(<em class="lc">df</em>=sample, <em class="lc">bcm</em>='c4', <em class="lc">bounds</em>='fb', <em class="lc">show</em>=True)<br/>x.mle()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi pc"><img src="../Images/13f12ad9cce1edc06c3e3a235662a256.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*LAZivXmbUf0i0tULK6PDZw.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">作者图片</p></figure><p id="38d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">图例显示了未校正MLE的估计值(虚线)。使用C4校正，校正后的形状参数估计值为2.4，更接近地面真实值2.0。在<em class="lc">预测</em>中尝试其他偏差校正方法并比较结果！</p><h1 id="cc4a" class="ma mb iq bd mc md oo mf mg mh op mj mk jw oq jx mm jz or ka mo kc os kd mq mr bi translated">综合地块</h1><p id="9f68" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated"><em class="lc"> PlotAll </em>是<em class="lc"> predictr </em>中的另一个类，让你创建和保存有洞察力的情节。它使用在<em class="lc">分析中创建的对象及其属性。</em>以下方法目前集成在<em class="lc"> PlotAll </em>中:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi pd"><img src="../Images/9c6b21e5753ed4fcccf14233990530d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SGWF_Ad6egE5tJdVD09NTw.png"/></div></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">PlotAll中的方法(图片由作者提供)</p></figure><p id="6180" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了比较两个或多个设计(本例中的原型)，您可以使用<em class="lc"> PlotAll: </em>中的<em class="lc"> mult_weibull </em>方法</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="d0c5" class="nr mb iq nn b gy ns nt l nu nv">from predictr import Analysis, PlotAll</span><span id="89b9" class="nr mb iq nn b gy om nt l nu nv"># Create new objects, e.g. name them prototype_a and prototype_b<br/>failures_a = [0.30481336314657737, 0.5793918872111126, 0.633217732127894, 0.7576700925659532, 0.8394342818048925, 0.9118100898948334, 1.0110147142055477, 1.0180126386295232, 1.3201853093496474, 1.492172669340363]</span><span id="1046" class="nr mb iq nn b gy om nt l nu nv">prototype_a = Analysis(<em class="lc">df</em>=failures_a, <em class="lc">bounds</em>='lrb', <em class="lc">bounds_type</em>='2s')<br/>prototype_a.mle()</span><span id="9d73" class="nr mb iq nn b gy om nt l nu nv">failures_b = [1.8506941739639076, 2.2685555679846954, 2.380993183650987, 2.642404955035375, 2.777082863078587, 2.89527127055147, 2.9099992138728927, 3.1425481097241, 3.3758727398694406, 3.8274990886889997]</span><span id="f491" class="nr mb iq nn b gy om nt l nu nv">prototype_b = Analysis(<em class="lc">df</em>=failures_b, <em class="lc">bounds</em>='pbb', <em class="lc">bounds_type</em>='2s')<br/>prototype_b.mle()</span><span id="c2c3" class="nr mb iq nn b gy om nt l nu nv"># Create dictionary with Analysis objects<br/># Keys will be used in figure legend. Name them as you please.</span><span id="fb80" class="nr mb iq nn b gy om nt l nu nv">objects = {fr'proto_a: <em class="lc">$\w</em>idehat<em class="lc">\b</em>eta<em class="lc">$</em>={prototype_a.beta:4f} | <em class="lc">$\w</em>idehat\eta<em class="lc">$</em>={prototype_a.eta:4f}': prototype_a, fr'proto_b: <em class="lc">$\w</em>idehat<em class="lc">\b</em>eta<em class="lc">$</em>={prototype_b.beta:4f} | <em class="lc">$\w</em>idehat\eta<em class="lc">$</em>={prototype_b.eta:4f}': prototype_b}</span><span id="1d52" class="nr mb iq nn b gy om nt l nu nv"># Use mult_weibull() method<br/>PlotAll(objects).mult_weibull()</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/ff551dc705d161cfbbefa8054ce2865b.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*eK7UoHjO3-7_yQkkV37PCA.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">作者图片</p></figure><p id="90d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了绘制密度函数，使用<em class="lc">威布尔_pdf </em>方法:</p><pre class="le lf lg lh gt nm nn no np aw nq bi"><span id="3635" class="nr mb iq nn b gy ns nt l nu nv">from predictr import Analysis, PlotAll</span><span id="cf91" class="nr mb iq nn b gy om nt l nu nv"># Use analysis for the parameter estimation<br/>failures1 = [3, 3, 3, 3, 3, 3, 4, 4, 9]<br/>failures2 = [3, 3, 5, 6, 6, 4, 9]<br/>failures3 = [5, 6, 6, 6, 7, 9]</span><span id="72ba" class="nr mb iq nn b gy om nt l nu nv">a = Analysis(df=failures1, bounds='lrb', bounds_type='2s', show = False, unit= 'min')<br/>a.mle()</span><span id="b184" class="nr mb iq nn b gy om nt l nu nv">b = Analysis(df=failures1, ds = failures2, bounds='fb', bounds_type='2s', show = False, unit= 'min')<br/>b.mle()</span><span id="1d4f" class="nr mb iq nn b gy om nt l nu nv">c = Analysis(df=failures3, bounds='lrb', bcm='hrbu', bounds_type='2s', show = False, unit= 'min')<br/>c.mle()</span><span id="da2e" class="nr mb iq nn b gy om nt l nu nv"># Use weibull_pdf method in PlotAll to plot the Weibull pdfs<br/># beta contains the Weibull shape parameters, which were estimated using Analysis class. Do the same for the Weibull scale parameter eta.<br/># Cusomize the path directory in order to use this code<br/>PlotAll().weibull_pdf(beta = [a.beta, b.beta, c.beta], eta = [a.eta, b.eta, c.eta], linestyle=['-', '--', ':'], labels = ['A', 'B', 'C'], x_bounds=[0, 20, 100], plot_title = 'Comparison of three Prototypes', x_label='Time to Failure', y_label='Density Function', save=False, color=['black', 'black', 'black'])</span></pre><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/c4f1d1bf0dedbd0b9dd7f1ba8e51971b.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*cxH65xn_jXiH5VCUAT_FYQ.png"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">作者图片</p></figure><p id="236a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请查看<a class="ae lb" href="https://tvtoglu.github.io/predictr/classes/" rel="noopener ugc nofollow" target="_blank">官方文档</a>以获取更多示例和代码的详细描述。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d5c4" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="83f3" class="pw-post-body-paragraph kf kg iq kh b ki mu jr kk kl mv ju kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">现在，您可以使用<a class="ae lb" href="https://pypi.org/project/predictr/" rel="noopener ugc nofollow" target="_blank">预测</a>利用基本<em class="lc"> </em>统计概念的知识进行自己的威布尔分析。尝试测试数据、参数估计、置信界限和偏差修正的不同组合，以感受相互依赖关系。</p><h2 id="23dc" class="nr mb iq bd mc ob oc dn mg od oe dp mk ko of og mm ks oh oi mo kw oj ok mq ol bi translated">参考</h2><ol class=""><li id="6dfa" class="ms mt iq kh b ki mu kl mv ko mw ks mx kw my la mz na nb nc bi translated">T.Tevetoglu和B. Bertsche，“关于偏差修正的置信界限的覆盖概率”，<em class="lc"> 2020年亚太高级可靠性和维护建模国际研讨会</em>，2020，第1–6页，doi:10.1109/APARM。20607.868686866616</li><li id="bdab" class="ms mt iq kh b ki nd kl ne ko nf ks ng kw nh la mz na nb nc bi translated">T.Tevetoglu和B. Bertsche，“<em class="lc">偏差修正的威布尔参数估计和对置信界限的影响”</em>。Esrel2020-PSAM15，2020 doi:10.3850/978–981–14–8593–0 _ 3925-CD。</li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h2 id="7c34" class="nr mb iq bd mc ob oc dn mg od oe dp mk ko of og mm ks oh oi mo kw oj ok mq ol bi translated">我希望这个快速指南对你有所帮助。关注我了解更多！您可以在<a class="ae lb" href="https://github.com/tvtoglu/predictr" rel="noopener ugc nofollow" target="_blank"> github </a>上或评论中联系我关于<em class="ni">预测</em>的反馈或功能需求。</h2></div></div>    
</body>
</html>