<html>
<head>
<title>Machine Learning Serverlessly Using AWS Lambda, Docker, ECR, S3 and API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda、Docker、ECR、S3和API Gateway的无服务器机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-serverlessly-1a532685fa7c#2022-01-24">https://towardsdatascience.com/machine-learning-serverlessly-1a532685fa7c#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="d03d" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用AWS Lambda、Docker、ECR、S3和API Gateway的无服务器机器学习</h1></div><div class=""><h2 id="cdff" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">如何在AWS上无服务器地构建复杂的机器学习web应用</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e94d761d625d0f91f3611c69c66e85bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*iC88HAvkVlG-4MCj.gif"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者GIF</p></figure><p id="a5c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大量的工作和努力投入到生产基于机器学习的产品中。我们最近完成了一个<a class="ae ln" href="https://share.streamlit.io/gitskim/aqa_streamlit/main/main.py" rel="noopener ugc nofollow" target="_blank">网络应用</a>的开发，用来预测奥运会跳水运动员的表现。给定一个奥运跳水运动员的视频，该网络应用程序预测人类裁判会给出什么分数，并输出分数。ML模型已经在内部进行了训练，我们必须将它们部署并生产成服务。我们选择了无服务器架构，这样我们就不必供应、运行和维护服务器，而是专注于开发用户友好的应用程序。下面是实现无服务器架构的React web应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lo"><img src="../Images/aaf401b9199ba7ee5c187350db08186f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*karsS_nGt7ao2NVlYiy7Gw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="d96a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我们将介绍我们在AWS上托管的一个简单但“复杂”的机器学习web应用程序的部署设计和实现。这是一个非常简单的项目，只有一个功能，从一个用户上传的视频潜水动作的预测得分。但是我们确实认为这个项目“复杂”,原因如下:</p><ol class=""><li id="fd88" class="lt lu iq kt b ku kv kx ky la lv le lw li lx lm ly lz ma mb bi translated">web应用程序需要接收用户上传的视频作为输入，该视频相对较大(高达200MB)。</li><li id="3dd9" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">预测过程中涉及的机器学习模型相对较大(564MB)。</li><li id="aed9" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">web应用程序需要等待预测过程，这需要相当长的时间(可能超过几分钟)才能完成。</li></ol><p id="8e12" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们预测过程的机器学习部分背后的理论，如果你感兴趣，可以在本文中找到更多<a class="ae ln" href="https://medium.com/@logicdevildotcom/training-ai-to-score-olympic-events-649b41574160" rel="noopener">。这里我们将只介绍我们的部署设计，并详细讨论我们使用的工具。下面是我们的云架构设计图，我们将在下面详细讨论架构的每个部分。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mh"><img src="../Images/479aa8140a56ec1a88f27afea8aa7c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MMyJAhzbtTpzcwEo"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="608b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，我们的前端React服务托管在AWS Amplify中，它与连接到AWS Lambda、AWS简单存储服务(S3)和AWS DynamoDB的AWS API网关端点进行交互。</p><h1 id="0c42" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">我们如何处理(大量)用户上传的数据？</h1><p id="aefc" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">用户通过我们的前端React服务上传一个视频文件作为输入。由于视频文件很大，在前端处理它并不容易。在我们的例子中，用户可以一次上传一个视频，每个文件必须小于200 MB。红色箭头(#1 — #8)描述了对来自客户端的输入文件的处理，这就是我们将在下面描述的内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mh"><img src="../Images/0208869ea4f95aab705ca0f56f10dd94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ZHN71Wu3HuZRQ46"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="71a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当用户上传一个大文件时，在前端处理它的最好方法是不要上传。我们遵循了AWS 关于如何将视频直接发送到S3的文档，它会在检测到新上传的视频时通知我们的后端。视频文件源自用户的计算机，我们的前端代码将文件上传到S3桶中(箭头1到7)；S3桶上有一个触发器(箭头8)，这样一旦上传完成，包含模型的lambda就会在新的视频输入上被调用(箭头9)。</p><p id="c46f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，我们的前端做这两件事:</p><ol class=""><li id="4631" class="lt lu iq kt b ku kv kx ky la lv le lw li lx lm ly lz ma mb bi translated">当接收到一个视频时，前端向我们的HTTP API(箭头1)和它后面的lambda函数发送一个GET请求，以获取存储所有用户上传视频的S3桶的预签名URL(箭头2和3)。</li><li id="57eb" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">在获得预签名的URL(箭头4、5和6)之后，前端向该URL发送PUT请求，其中视频以二进制数据的形式包含在正文中，该请求被存放到S3桶中(箭头7)。一旦数据被上传到桶中，一个触发器被触发，警告模型lambda新数据准备好了(箭头8)。</li></ol><p id="2df5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的教程足够详细，可以让你理解它的基础。但是有时根据我们自己的特定需求调整教程仍然是一个挑战。因此，我们将在这里链接我们的代码库<a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="9d53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个lambda函数，它从S3生成一个预签名的URL。</p><p id="244c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/main/getSignedURL/app.py" rel="noopener ugc nofollow" target="_blank">https://github . com/yumyumqing/AQA _ S3 _ pre signed _ URL/blob/main/getSignedURL/app . py</a></p><p id="43e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们为这个lambda函数和它前面的HTTP API准备的<a class="ae ln" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank"> SAM </a>模板。</p><p id="732e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/main/template.yaml#L6-L70" rel="noopener ugc nofollow" target="_blank">https://github . com/yumyumqing/AQA _ S3 _ pre signed _ URL/blob/main/template . YAML # L6-L70</a></p><p id="ded1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以看到，我们为前端应用程序实现了一个AWS API网关，以获得一个预签名的URL <a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/main/template.yaml#L65" rel="noopener ugc nofollow" target="_blank">这里是</a>。当您使用<strong class="kt ir"><em class="nf">SAM deploy-guided</em></strong>部署堆栈时，按照AWS 的<a class="ae ln" href="https://aws.amazon.com/blogs/compute/uploading-to-amazon-s3-directly-from-a-web-or-mobile-application/" rel="noopener ugc nofollow" target="_blank">文档，您可能会遇到AWS SAM CLI错误:</a></p><blockquote class="ng nh ni"><p id="4a18" class="kr ks nf kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated">"不满足安全约束。"当您对这个问题回答“否:HelloWorldFunction可能没有定义授权，这样可以吗？[是/否]。您可以在此找到修复问题<a class="ae ln" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-deploying.html" rel="noopener ugc nofollow" target="_blank">的详细信息。</a></p></blockquote><p id="d000" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置所有这些似乎有点复杂(这意味着我们需要先学习所有这些工具！)我们可以将视频从前端直接发送到运行推理代码的主机。然而，在这种情况下，我们将负责更多的操作细节:大视频的多部分传输，等待大文件的到达，编码，检查，这些数据的临时和永久存储处理，以及许多我们甚至没有想到的事情。</p><h1 id="fedc" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">如何无服务器部署大型机器学习模型</h1><p id="90a9" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">接下来，用户数据在AWS lambda中得到处理。AWS Lambda是“一种无服务器的事件驱动计算服务，让您无需配置或管理服务器即可运行代码。”它几乎是一个抽象的后端，你可以像实现一个函数一样实现它。AWS Lambda代表客户管理扩展，并支持高可用性和容错。Lambda部署包是一个zip文件，其中包含代码、库和依赖项。然而，lambda的包大小限制妨碍了我们，因为我们要部署的文件和ML模型的总大小至少是564MB，但是Lambda施加了以下大小限制:</p><blockquote class="ng nh ni"><p id="5a60" class="kr ks nf kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated">压缩文件的部署包大小限制:50MB</p></blockquote><p id="439e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2020年12月，AWS开始支持将Docker容器映像部署为lambda函数的功能。你可以在这里查看Docker的更多信息(https://www.docker.com/)。这意味着docker容器映像可以部署到lambda，而不是zip文件。我们只需要确保容器映像是基于linux的。对我们来说，对Lambda使用docker映像的好处是它提供了更多的空间。我们的模型甚至没有接近Lambda允许的50 MB，但确实符合当您将Docker映像部署到Lambda时得到的限制。这些限制处理起来有点复杂，但是仍然为你的模型提供了更多的空间。</p><p id="2f59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">至于模型的无服务器部署，没有太多可用的选项，lambda容器是我们能够包含5g模型的最佳选择。与Sagemaker不同，lambda docker不需要管理端点和端点配置等多项内容。最重要的是，lambda提供了一个真正的无服务器解决方案，无需选择特定的实例进行部署。Lambda容器部署有以下限制，记住这些限制很重要:</p><blockquote class="ng nh ni"><p id="7b19" class="kr ks nf kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated">lambda容器映像的部署包大小限制:10GB</p><p id="fa36" class="kr ks nf kt b ku kv jr kw kx ky ju kz nj lb lc ld nk lf lg lh nl lj lk ll lm ij bi translated">/tmp上的临时文件系统存储:512 MB</p></blockquote><p id="7f85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上信息对于确定ML模型的归属非常重要。我们考虑了两个选项:(1) S3，以及(2)用推理代码文件将模型附加到容器映像。对于选项#1，ML模型需要从S3加载到容器映像中。从其他地方(比如S3)加载的任何额外文件都被写入临时文件存储区/tmp，这是外部文件下载的唯一路径。可写入该路径的最大文件大小为512 MB。然而，我们的模型的总大小是564MB，这超过了临时文件系统存储的限制。因此，我们选择了选项#2，将我们的模型作为一个代码文件附加到容器映像中。</p><h2 id="d445" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">第一步。写一个Dockerfile </strong></h2><p id="7eb8" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">在我们的示例中，我们从公共aws存储库中提取一个映像，并用lambda python 3.7设置基本映像。将基础映像设置为lambda基础映像非常重要。大多数docker文件以FROM指令开始，图像可以是任何有效的图像。然后，lambda的推理代码包被复制到工作目录，以便该代码可用于后续指令。由于我们有了一个全新的映像，我们正在安装必要的库，并在运行后设置变量，这将执行docker映像中的命令。Requirements.txt包含了我们希望安装在全新映像中的所有库。最后，CMD执行一个命令行来调用lambda处理程序，并指定lambda处理程序所在文件的名称。</p><h2 id="892b" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">第二步。编写推理逻辑</strong></h2><ul class=""><li id="3a88" class="lt lu iq kt b ku na kx nb la ny le nz li oa lm ob lz ma mb bi translated"><strong class="kt ir">模型位置</strong></li></ul><p id="f06d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们考虑将我们的ML模型放在S3并下载它们，但是这次我们将模型附加到docker容器中。这意味着当我们打包我们的容器时，我们将模型作为文件留给我们的推理逻辑来直接使用模型。这里，我们在部署中附加了模型及其权重文件。</p><ul class=""><li id="92c5" class="lt lu iq kt b ku kv kx ky la lv le lw li lx lm ob lz ma mb bi translated"><strong class="kt ir">处理程序文件</strong></li></ul><p id="7522" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在docker文件中指定的处理函数名称下，您可以添加您的推理逻辑。对于处理程序，建议使用以下模板:</p><p id="5c33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="nf"> def handler_name(事件，上下文):</em> </strong></p><p id="df84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以选择返回值或不返回值。在我们的例子中，我们返回一个预测值，以便客户端应用程序可以显示该预测值。</p><h2 id="bb0e" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">第三步。添加云形成模板</strong></h2><p id="b2ed" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/main/template.yaml#L75" rel="noopener ugc nofollow" target="_blank">https://github . com/yumyumqing/AQA _ S3 _ pre signed _ URL/blob/main/template . YAML # L75</a></p><p id="e72e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以为云的形成配置您的lambda容器，以自动化部署。确保类型为“AWS::Serverless::Function ”,包类型为“Image ”,以表明它是lambda docker图像容器。您可以从这里获得更多信息:<a class="ae ln" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-images.html#configuration-images-cloudformation" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/lambda/latest/DG/configuration-images . html # configuration-images-cloud formation</a>此外，您还可以轻松集成lambda函数，以便在S3发生变化时得到通知。正如Events部分所提到的，我们让S3在创建或删除对象时向lambda函数发送一个事件。</p><h2 id="d8a0" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">第四步。本地测试:验证功能</strong></h2><p id="2c38" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">为了在本地测试其功能，我们将通过运行<em class="nf"> sam build </em>进行测试。在本地测试docker之前，请确保下载并运行它。然后，确保sample_data.json中有正确的样本数据信息。在我们的例子中，我们使用s3中的视频文件，所以我们在sample_data.json中有我们的视频和s3信息。然后运行sam本地调用&lt;函数名&gt; -e &lt;样本事件文件&gt;</p><p id="cad1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nf"> sam本地调用" ProcessPredictFunction "-e getPredScore/sample _ event . JSON</em></p><p id="9c72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有一种方法可以在本地测试你的lambda函数，这种方法不涉及aws sam，它是AWS Lambda运行时接口仿真器(RIE)。你可以在这里得到更多信息<a class="ae ln" href="https://docs.aws.amazon.com/lambda/latest/dg/images-test.html" rel="noopener ugc nofollow" target="_blank"/>，但是我发现使用SAM来测试我的lambda函数要容易得多。</p><h2 id="31fc" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">第五步。使用sam构建进行部署</strong></h2><p id="db02" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">然后，您可以再次使用sam部署应用程序。简单来说就是<strong class="kt ir"> <em class="nf"> sam部署——制导</em> </strong>。部署结束后，您将看到docker映像被部署到AWS弹性容器注册中心(ECR ), lambda函数引用ECR中的映像。</p><p id="40a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Lambda docker容器映像为无服务器启动我们的ML模型提供了一个有趣的解决方案。将模型作为代码附加并部署在打包的容器中是很简单的。S3与lambda的方便集成提供了一个更加独立和安全的解决方案。它是独立的，因为我们的前端应用只需将输入的视频数据放入S3，而无需触及架构的其他部分，我们的lambda函数会自动触发，以处理输入视频并对其进行预测。它是安全的，因为前端应用程序在尝试直接调用lambda函数时不需要包含任何身份验证信息。</p><h2 id="79c3" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">如何处理长的预测请求？</strong></h2><p id="3dd4" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">机器学习预测有时需要相当长的时间来处理。我们现在将描述我们如何处理来自机器学习模型的预测结果，该过程在图中用红色箭头表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mh"><img src="../Images/37b545e4fb1b895ce3f962cc7f31fe29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AWeabmhkccdt7poR"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="e217" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们没有让我们的前端等待和监听缓慢的响应，而是加入了DynamoDB来存储从后端发送的结果，并让我们的React前端每五秒钟ping一次数据库，以检查结果是否就绪，并用最新状态刷新浏览器。这样，我们使用更多的pings来避免长时间的开放连接。</p><p id="8ef3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们进行预测的lambda函数中，每当分数准备好了，我们就将其发送到DynamoDB表中，您可以在这里看到代码<a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/e5e23e16cab7dad246f300e39c31d28b097576fe/getPredScore/process_predict.py#L93-L109" rel="noopener ugc nofollow" target="_blank"/>。我们的前端一直ping一个与lambda函数相关的HTTP Api，该函数与我们的DynamoDB表进行对话。<a class="ae ln" href="https://github.com/yumyumqing/aqa_frontend/blob/main/src/App.js#L108" rel="noopener ugc nofollow" target="_blank">这里是</a>为预测结果可用性持续pinging的前端实现。</p><p id="d802" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">还可以查看一下背后的HTTP Api和lambda函数</strong>:</p><p id="7187" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/e5e23e16cab7dad246f300e39c31d28b097576fe/template.yaml#L100-L118" rel="noopener ugc nofollow" target="_blank">https://github . com/yumyumqing/AQA _ S3 _ pre signed _ URL/blob/e 5e 23 e 16 cab 7 dad 246 f 300 e 39 c 31d 28 b 097576 Fe/template . YAML # L100-L118</a></p><p id="9ac8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/yumyumqing/AQA_s3_presigned_url/blob/e5e23e16cab7dad246f300e39c31d28b097576fe/fetchScore/app.py" rel="noopener ugc nofollow" target="_blank">https://github . com/yumyumqing/AQA _ S3 _ pre signed _ URL/blob/e 5e 23 e 16 cab 7 dad 246 f 300 e 39 c 31d 28 b 097576 Fe/fetchScore/app . py</a></p><p id="64b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">我们的前端部署(AWS Amplify)。</strong></p><p id="70d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用AWS Amplify来部署我们的前端代码。它有很好的持续部署功能，因为我们的代码库驻留在AWS CodeCommit上，每当我们推出新的更改，它都会默认重建和重新部署我们的应用程序，而不会使我们的网站宕机。AWS Amplify还可以很好地检测React应用程序，以便直接获取我们的配置文件并开始自行工作。这里有更多关于如何在AWS Amplify上部署React应用程序的<a class="ae ln" href="https://aws.amazon.com/getting-started/hands-on/build-react-app-amplify-graphql/module-one/?e=gs2020&amp;p=build-a-react-app-intro" rel="noopener ugc nofollow" target="_blank">信息</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mh"><img src="../Images/b7c0560daaf431bb190897ca7d4978c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hQH6WM-DxpGT6Qw7"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><h2 id="f6f2" class="nm mj iq bd mk nn no dn mo np nq dp ms la nr ns mu le nt nu mw li nv nw my nx bi translated"><strong class="ak">结论</strong></h2><p id="bdf4" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">我们为我们的机器学习服务演示了一个无服务器架构设计。设计并不像我们服务的功能听起来那么简单。使用了多个AWS组件，包括AWS Amplify、HTTP API Gateway、Lambda、简单存储服务(S3)、弹性容器注册中心(ECR)和DynamoDB。</p><p id="089a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nf">这是与</em> <a class="ae ln" href="https://www.linkedin.com/in/yanqing-dai-2001948a/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">延庆戴</em> </a>的协同工作</p><h1 id="3e0a" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">注意</h1><p id="658e" class="pw-post-body-paragraph kr ks iq kt b ku na jr kw kx nb ju kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated"><a class="ae ln" href="https://www.linkedin.com/in/yanqing-dai-2001948a/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">延庆戴</em></a><em class="nf"/>我开始了我们的自由职业生涯。我们接受专注于生产机器学习服务、数据工程和分布式系统的自由职业者的工作。</p></div></div>    
</body>
</html>