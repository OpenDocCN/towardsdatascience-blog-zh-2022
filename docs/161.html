<html>
<head>
<title>Linear Algebra — Survival Kit for Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性代数——机器学习的生存工具包</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/linear-algebra-survival-kit-for-machine-learning-94901a62465e#2022-01-06">https://towardsdatascience.com/linear-algebra-survival-kit-for-machine-learning-94901a62465e#2022-01-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="5e38" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">基本原则</h2><div class=""><h1 id="a277" class="pw-post-title jc jd iu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">线性代数——机器学习的生存工具包</h1></div><div class=""><h2 id="92ad" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">NumPy中带有示例的最常见概念的快速参考指南</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/d76b6a39bf2816115aa3f730428fd14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L3-CCaqSvxBIF0Wg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">克里斯汀·沃克在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0d55" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di"> L </span>线性代数通常被认为是数据的数学<em class="mo"/>和机器学习的基本支柱之一。然而，这是一个广阔的领域，包含着太快掉进兔子洞的危险。</p><p id="30f5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在接下来的章节中，我们将介绍一些与机器学习相关的最常见的线性代数概念，以便建立强大的直觉和坚实的基础。我们不仅会讨论基础理论，还会学习如何使用NumPy在python中实现一些计算。</p><blockquote class="mp mq mr"><p id="eb8d" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">免责声明</strong>:这篇文章和所涵盖的主题的唯一目的是提供一个通用的指导方针——一个快速的参考——关于机器学习的相关概念。因此，理论有时只是简单地解释一下，一些概念就被完全回避了。如果有必要，我们总是可以更深入，使用本文作为要涵盖的主题的路线图。</p></blockquote></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="f5cd" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">数学对象</h1><h2 id="3d67" class="nu nd iu bd ne nv nw dn ni nx ny dp nm ls nz oa no lw ob oc nq ma od oe ns ja bi translated">标量</h2><p id="3ca4" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">标量只是一个单一的数字。之所以这样称呼它，是因为它在不改变方向的情况下拉伸或缩放矢量或矩阵。</p><p id="da4e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以用python中的一个简单变量来表示一个标量。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><h2 id="3002" class="nu nd iu bd ne nv nw dn ni nx ny dp nm ls nz oa no lw ob oc nq ma od oe ns ja bi translated">向量</h2><p id="90a7" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">从几何学上来说，我们可以把向量想象成一条线，由大小(长度)和方向来定义。然而，向量的定义不包括它的开始或结束位置。</p><p id="32cb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">例如，一个向量v=[1，2]只告诉我们，它在第一个维度上走了一个单位，在第二个维度上走了两个单位。按照惯例，我们通常认为一个向量在<em class="mo">标准位置</em>——这意味着它的尾部位于原点[0，0]。</p><p id="d166" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们也可以把向量想象成一组数字。这样想可以让我们用NumPy表示一个向量，如下所示:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj om"><img src="../Images/fccf1790fb73ff2b9ecc033f50aa2905.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*bJNuh9XvbVFEDof7m6iwQA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">向量[1，2]绘制的示例[图片由作者提供]</p></figure><h2 id="dc2b" class="nu nd iu bd ne nv nw dn ni nx ny dp nm ls nz oa no lw ob oc nq ma od oe ns ja bi translated">矩阵</h2><p id="9805" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">矩阵是数字的二维数组。不严格地说，我们也可以把矩阵想象成一组相邻的列向量。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj on"><img src="../Images/6925268a605369f57a8cf706fab4b6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/0*t-7Qr_GZA-m43Fp5"/></div></figure><p id="4792" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">假设我们的示例矩阵(A)包含实数值，我们想要描述它的形状。我们可以通过以下方式做到这一点:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/0bdbbd678074084a13cf850e0a76667a.png" data-original-src="https://miro.medium.com/v2/resize:fit:220/0*MWGrv5uEwLbOLMyc"/></div></figure><p id="6aae" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">其中<em class="mo"> m </em>定义了一个矩阵的高度(行),而<em class="mo"> n </em>告诉我们一个矩阵的宽度(列)。在我们的例子中，<em class="mo"> m </em>和<em class="mo"> n </em>都等于3，因此我们有一个3乘3的矩阵。</p><p id="fba2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以使用NumPy以多种方式定义一个矩阵，在下面的代码中可以看到一些有用的方法。我们也可以使用<code class="fe op oq or os b">numpy.shape(a)</code>打印矩阵尺寸</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><blockquote class="mp mq mr"><p id="2efb" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">注</strong>:轴数可变的高维矩阵称为张量。</p></blockquote><p id="9ec3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">矩阵有多种不同的用途，其中包括:</p><ol class=""><li id="d4c5" class="ot ou iu ll b lm ln lp lq ls ov lw ow ma ox me oy oz pa pb bi translated">线性变换的表示</li><li id="8924" class="ot ou iu ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">方程组的表示</li><li id="de8a" class="ot ou iu ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">存储和表示数据(观察x特征)</li><li id="9c57" class="ot ou iu ll b lm pc lp pd ls pe lw pf ma pg me oy oz pa pb bi translated">存储例如卷积中使用的核</li></ol></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="c44d" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">移调</h1><p id="de07" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">转置操作的概念可以被认为如下:<em class="mo">用行交换列，反之亦然。</em></p><p id="e468" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我们转置一个列向量时，我们得到一个行向量。如果我们转置一个矩阵，我们得到主对角线上的镜像。</p><p id="2ac6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们形象化一些例子来获得更好的理解。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ph"><img src="../Images/d4d3b2375eda5b612348e24888bc3851.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/0*Eobw0MbAkUIzwgCg"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">一个载体换位的例子。</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pi"><img src="../Images/580639e5a31a09590ab9ee05e2fd6791.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/0*_Fvadf6NzbiQT-G6"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">一个把2×3矩阵转置成3×2矩阵的例子。</p></figure><p id="d5d5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">转置操作直接应用于代码中。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="f988" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">矩阵加法</h1><p id="399a" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">矩阵加法相当简单，我们基本上只需将两个矩阵中的每个对应元素相加或相减即可。我们也可以称之为基于元素的操作。然而，我们必须记住的一件事是，两个矩阵需要具有相同的形状。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pj"><img src="../Images/66b6fe09d5bdfea090adecf9e0e02291.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/0*4BlxWFaEorInEprD"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pk"><img src="../Images/2e655f43ffef4cffd6308ea3fc7911a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/0*9d6LR2zzJU-wXcCN"/></div></figure><blockquote class="mp mq mr"><p id="d965" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">注意</strong>:我们也可以添加两个向量——概念与矩阵加法相同。</p></blockquote><p id="28b7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在NumPy中执行矩阵加法可以通过使用基本算术运算符或函数<code class="fe op oq or os b">numpy.add(a,b)</code>来完成。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><p id="aaf5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们也可以在矩阵中增加或减少一个标量。标量将简单地按元素相加。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pl"><img src="../Images/8cf65240a89c35461b4b42cb21afe0f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:456/0*yGLHewb7aaCYi9MW"/></div></figure><p id="5775" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在某些情况下，我们允许矩阵向量相加，尽管两个形状并不完全相同。因此，通过<em class="mo">隐式复制</em>或<em class="mo">广播</em>，向量将被添加到矩阵的每一行。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><blockquote class="mp mq mr"><p id="f671" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">注意</strong>:向量的长度必须与矩阵中的列数相同。否则不能播放。</p></blockquote></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="9dae" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">矩阵和向量相乘</h1><p id="a74b" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">现在，我们完成了最重要的运算之一:两个矩阵的乘法。</p><p id="70bf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在深入计算细节之前，让我们先了解一些有用的属性:</p><p id="6fb7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">矩阵乘法是<em class="mo">分配的(1)、结合的(2)、</em>和<em class="mo">不可交换的(3): </em></p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pm"><img src="../Images/e6cbd5cb68a41105dce6c59a0c53a0f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*_K8uvqxVowWpaNO0"/></div></figure><p id="7306" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了使矩阵乘法成为有效的运算，必须匹配“内部维度”<em class="mo">【n】</em>。生成的矩阵将由“外部尺寸”定义<em class="mo"> (m，p) </em>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pn"><img src="../Images/db856a085d1868d56d6963eb7897d745.png" data-original-src="https://miro.medium.com/v2/resize:fit:446/0*v8Qlv4FJu6fNPnHU"/></div></figure><p id="5b86" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们想一个例子来更好地理解这一点。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj po"><img src="../Images/bd66526487814b7eec17cf71de0a844a.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/0*cuHixkZhGw5xN3di"/></div></figure><p id="4bf4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">矩阵(A)由形状(2×3)定义，而矩阵(B)包含3行和2列，因此是形状(3×2)。因为“内部维度”匹配，所以定义了矩阵乘法，结果将是一个2乘2的矩阵。</p><p id="5e9b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">既然我们已经知道了一些基本的性质，以及矩阵乘法何时有效，我们仍然需要知道如何执行计算。</p><p id="505f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们基本上可以把矩阵乘法想成左矩阵的一个行向量和右矩阵的一个列向量的点积。我们可以将该机制形象化如下:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pp"><img src="../Images/e8db6f75830b37c2a2e3fc508bd0d881.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*gslcagDeP4dbQ9TypcdiNw.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">矩阵乘法可视化[图片由作者提供]</p></figure><p id="56d9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们通过一个数字例子来加深我们的理解。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pq"><img src="../Images/0e0b7e6befcb071018b48c61f9ce8d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/0*KE91kgn88QJJdmmb"/></div></figure><blockquote class="mp mq mr"><p id="d316" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">注意</strong>:矩阵乘法不是按元素执行的。这种操作被称为<a class="ae li" href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)" rel="noopener ugc nofollow" target="_blank">哈达玛乘积</a>，通常被称为⨀ B</p></blockquote><p id="8878" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">矩阵乘法可以通过内置的NumPy函数以多种方式执行，如下面的代码示例所示。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><p id="8190" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">矩阵向量乘法也被定义并遵循相同的概念，允许我们以更紧凑的方式表示方程组。</p><p id="9cbd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以下面的等式为例</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pr"><img src="../Images/3b275a73176ad27eb42a6823bdd31fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:154/0*4AdwWn91YQrE4zT_"/></div></figure><p id="2411" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它可以被重写为多个方程，但是不那么密集和优雅。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ps"><img src="../Images/4dcc8ebb8497b65249dd38a914f0eea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/0*M6wZi_mi9Xq-I4zq"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="fbee" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">逆矩阵和单位矩阵</h1><p id="7b76" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">矩阵的逆矩阵允许我们解出方程<em class="mo"> Ax = b </em>解析解<em class="mo"> x. </em>但是首先，我们需要知道什么是单位矩阵。</p><p id="e9c2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">单位矩阵不会通过乘法来改变向量或矩阵。主对角线上的元素只有1，而非对角线上的元素只有0。此外，单位矩阵始终是正方形<em class="mo"> (MxM) </em>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pt"><img src="../Images/edc3c83a67ed59c71217213f1f4398b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/0*LCScM5wQ1q21_XXD"/></div></div></figure><p id="e6ab" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">可视化一个2乘2的单位矩阵，我们得到如下结果:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pj"><img src="../Images/500978cbde1b6797a434cb0d65f2354a.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/0*_JiWL2xUsMIDevYX"/></div></figure><p id="9f0b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">另一方面，矩阵的逆矩阵是一个矩阵，当与原始矩阵相乘时，产生单位矩阵。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/f4d5bafd345dab568360398b9915cd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:220/0*7ycAl397Q7o-CG8F"/></div></figure><p id="105b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由于矩阵除法不存在，我们现在可以使用矩阵求逆来求解我们的方程<em class="mo"> x </em>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pu"><img src="../Images/2741afe2fd4012ed4a86ecf132244b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/0*JmXZMnDd0Sh5MAjo"/></div></figure><blockquote class="mp mq mr"><p id="0bb0" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">注意</strong>:我们只能使用矩阵的逆矩阵，如果它被定义的话。对于一个有逆矩阵的矩阵，它必须是平方的和满秩的。</p></blockquote><p id="ee26" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以利用NumPy的内置函数来创建任意大小的单位矩阵，并计算矩阵的逆矩阵。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="ac69" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">线性相关性和跨度</h1><p id="a75f" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">在上一节中，我们计算了矩阵的逆矩阵，以求解<em class="mo"> x </em>的<em class="mo"> Ax=b </em>。</p><p id="bfa8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了定义矩阵的逆矩阵，每个<em class="mo"> b必须正好有一个解。然而</em>该方程也可能没有或定义了多个解。</p><p id="3cf8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果我们把矩阵(A)的列想象成空间中不同的方向，我们可以算出有多少种方法可以到达<em class="mo"> b </em>。我们例子中的向量(x)定义了我们在每个方向上要走多远。</p><p id="071f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一组向量的跨度——矩阵(A)的列——定义了可通过线性组合<em class="mo"> Ax获得的所有点。</em>因此询问<em class="mo"> Ax=b </em>是否有解，基本上与询问<em class="mo"> b </em>是否在跨度内是一回事。向量所跨越的子空间称为列空间。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pv"><img src="../Images/bc58562b84fbf636e3498f763fb167c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*7Xfnxe3tavH17y1Q6UuY2g.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">两个向量跨度的例子[图片由作者提供]</p></figure><p id="4ee0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在，想象其中一个向量是另一个向量的线性组合，从而形成一条直线。如果<em class="mo"> b </em>正好位于那条线上，则生成的子空间现在减少到一维，并且<em class="mo"> Ax=b </em>只有一个解。如果<em class="mo"> b </em>不在那条线上，我们就没有办法到达它。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pw"><img src="../Images/74ca24dfdf544906bdccec67740b7cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*AoKIAuiv69Jj_KMkLcnUVQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">两个线性相关向量的例子[图片由作者提供]</p></figure><p id="4966" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果一组向量中至少有一个向量可以表示为其他向量的线性组合，那么这组向量就是线性相关的——这正是我们在例子中所得到的。</p><p id="faee" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">另一方面，线性无关是完全相反的——没有一个向量可以用其他向量的线性组合来表示。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="4804" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">规范</h1><p id="5401" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">不严格地说，范数衡量的是向量的大小或长度。更正式地说，范数可以被解释为将向量映射到非负值的函数。</p><p id="6ce2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一种常用的范数是欧几里德或ℓ2范数:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj px"><img src="../Images/62702e9f712a3d71b228019bf13f0151.png" data-original-src="https://miro.medium.com/v2/resize:fit:346/0*WV-jBBn_M22bDR8w"/></div></figure><p id="b4be" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">其他有用规范的例子包括ℓ1规范、ℓ∞规范或弗罗贝纽斯规范。</p><p id="2087" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在代码中，我们可以使用函数<code class="fe op oq or os b"><a class="ae li" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html" rel="noopener ugc nofollow" target="_blank">numpy.linalg.norm()</a></code>并通过参数<code class="fe op oq or os b">ord=None</code>指定范数的阶数</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><blockquote class="mp mq mr"><p id="2e78" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated"><strong class="ll je">注</strong>:默认情况下，我们会计算矩阵的弗罗贝纽斯范数和向量的ℓ2范数。</p></blockquote></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="9bba" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">特殊矩阵和向量</h1><p id="d4b4" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">有些矩阵的元素或形状是特殊的，因此特别有用。</p><p id="8e35" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">除了主对角线上的元素，对角矩阵只包含零。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj py"><img src="../Images/9d42917ddf2fc7c05a02253fd4d0f6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/0*caP95u9K4V7Fnctx"/></div></figure><p id="a59f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我们学习单位矩阵时，我们已经遇到了对角矩阵。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pj"><img src="../Images/92aa75379953b720e8a1dceb3b4aed00.png" data-original-src="https://miro.medium.com/v2/resize:fit:244/0*_ATJxl4pOrDRRN7G"/></div></figure><p id="d43e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对角矩阵是有用的，因为它们计算效率高。例如，为了计算逆，我们只需要计算主对角线的倒数。</p><p id="fe80" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以通过指定一个向量来构建一个对角矩阵，并简单地应用函数<code class="fe op oq or os b">numpy.diag(v)</code></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><p id="3bc2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对称矩阵是任何与其转置矩阵相等的矩阵，这意味着</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pz"><img src="../Images/f61b40b58270b0fbde80bfa3d2215e73.png" data-original-src="https://miro.medium.com/v2/resize:fit:174/0*gZErJQaG63pxW5Fn"/></div></figure><p id="41a3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以考虑一个矩阵示例，如下所示:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qa"><img src="../Images/da969d7f5729943ac9c38ca2a68818fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/0*9uWYj5dEsY2Hsfs_"/></div></figure><p id="6ee4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们假设我们有一个矢量<em class="mo"> v </em>和一个矢量<em class="mo">w。</em>现在想象这两个矢量运行在不同的方向——事实上，它们是垂直的，角度为90°。那些向量也可以被称为<em class="mo">正交的</em>——如果两个向量都有单位范数，长度为1，则它们被称为<em class="mo">正交的</em>。</p><p id="8956" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">另一方面，正交矩阵是行和列相互正交的正方形矩阵。这意味着两个有用的属性</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qb"><img src="../Images/322b5241262947ca7241e1a1e577ee08.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/0*Rf6Pb78FZy8oopZZ"/></div></figure><p id="7bd8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">正交矩阵是有趣的，因为它允许我们非常便宜和有效地计算逆矩阵，因为它是由其转置定义的。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="4775" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">特征分解</h1><p id="bf79" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">分解或者不严格地说，将一个数学对象分解开来，有时可以让我们通过揭示不明显的属性来更好地理解它。</p><p id="3164" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">特征分解将矩阵分解成特征值和特征向量。对于旋转不变的特征向量向我们显示了矩阵的方向，而特征值是比例因子，描述了特征向量的大小。</p><div class="qc qd gq gs qe qf"><a rel="noopener follow" target="_blank" href="/decomposing-eigendecomposition-f68f48470830"><div class="qg ab fp"><div class="qh ab qi cl cj qj"><h2 class="bd je gz z fq qk fs ft ql fv fx jd bi translated">分解特征分解</h2><div class="qm l"><h3 class="bd b gz z fq qk fs ft ql fv fx dk translated">特征向量和特征值的温和介绍</h3></div><div class="qn l"><p class="bd b dl z fq qk fs ft ql fv fx dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="qp l qq qr qs qo qt lc qf"/></div></div></a></div><p id="7735" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以借助内置的NumPy函数来检索特征值和特征向量。为了重构原始矩阵，我们只需要计算特征向量、对角化的特征值和特征向量的逆的乘积。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qu"><img src="../Images/41db64c80b4d50e774663a6ecd61ce9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/0*2XUnqJJM76pr2JGT"/></div></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure><p id="4929" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">特征分解是有用的，因为它是主成分分析中的关键元素。</p><div class="qc qd gq gs qe qf"><a rel="noopener follow" target="_blank" href="/implementing-pca-from-scratch-fb434f1acbaa"><div class="qg ab fp"><div class="qh ab qi cl cj qj"><h2 class="bd je gz z fq qk fs ft ql fv fx jd bi translated">从头开始实施PCA</h2><div class="qm l"><h3 class="bd b gz z fq qk fs ft ql fv fx dk translated">仅用Python和NumPy来提高您的线性代数技能</h3></div><div class="qn l"><p class="bd b dl z fq qk fs ft ql fv fx dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="qv l qq qr qs qo qt lc qf"/></div></div></a></div></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="02c5" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">奇异值分解</h1><p id="c04a" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">奇异值分解(SVD)和特征分解密切相关，因为在这两种情况下，我们分解或因式分解矩阵。</p><p id="1ec4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，奇异值分解具有更广泛的适用性。例如，如果矩阵不是正方形的，则不定义特征分解，而仍然可以应用SVD。</p><p id="9e28" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">奇异值分解将矩阵分解成奇异值和奇异向量。应用时，我们将单个矩阵分解为三个特殊矩阵的乘积。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qw"><img src="../Images/2075e112bd567ad3a25c70646fa7c609.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/0*Pqx3H7EMLEJKfJZw"/></div></figure><p id="a511" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">矩阵(U)和(V)都是正交的，并且分别包含左奇异向量和右奇异向量。矩阵(D)是对角矩阵，包含主对角线上的奇异值。</p><p id="2948" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">SVD是有用的，因为它允许我们比特征分解更普遍地应用矩阵分解，并且它还使我们能够部分地将矩阵求逆推广到非方矩阵。</p><p id="1441" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们可以依靠使用<code class="fe op oq or os b"><a class="ae li" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.svd.html" rel="noopener ugc nofollow" target="_blank">numpy.linalg.svd(a)</a></code>来应用SVD。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="4edc" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">Moore-Penrose伪逆</h1><p id="1ce2" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">没有为非方阵定义矩阵逆矩阵。然而，Moore-Penrose伪逆允许我们计算或近似高且宽的矩阵的逆。</p><p id="e8ec" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当计算伪逆时，实际算法依赖于SVD。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qx"><img src="../Images/88290ebf7f8fd15dcbab836eedf2b2ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/0*v1VVxqcdcCGzWc0J"/></div></figure><p id="d52f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">上面的等式应该看起来很熟悉，因为它检索与SVD相同的三个矩阵，对角矩阵(D)的伪逆是通过计算非零元素的倒数并对结果矩阵进行转置获得的。</p><p id="1c6c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在代码中，我们可以简单地利用NumPy函数来计算伪逆。由于矩阵与逆矩阵相乘应该产生单位矩阵，我们可以用这个事实来检查我们的结果。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="4d23" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">跟踪运算符</h1><p id="fd1d" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">一个矩阵的所有对角线元素的和可以通过追踪算子来计算。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qy"><img src="../Images/3bd8a2382e181beaec7fae1de6578d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/0*iVwMsJu1A9p6pV3C"/></div></figure><p id="fad0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">trace运算符很有用，因为它允许更简单的符号。例如，Frobenius范数可以使用trace运算符表示如下:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj qz"><img src="../Images/72db5d3242e073d6a7c38942646db66a.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/0*phc_7-THaHFq9kB4"/></div></figure><p id="48da" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">假设，我们有一个5x 5的单位矩阵。所有对角线元素的总和应该等于5，并且可以使用NumPy来计算，正如我们在下面的代码示例中看到的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="704f" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">行列式</h1><p id="0d0f" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">行列式基本上是将矩阵映射到标量的函数，由所有特征值的乘积定义。</p><p id="9476" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它在几何学上也可以分别解释为面积或体积。不严格地说，行列式给出了一个度量，即乘以一个矩阵可以扩大或缩小多少空间。</p><div class="qc qd gq gs qe qf"><a rel="noopener follow" target="_blank" href="/discovering-the-matrix-determinant-11b56616d99a"><div class="qg ab fp"><div class="qh ab qi cl cj qj"><h2 class="bd je gz z fq qk fs ft ql fv fx jd bi translated">发现矩阵行列式</h2><div class="qm l"><h3 class="bd b gz z fq qk fs ft ql fv fx dk translated">解开特征分解的关键元素</h3></div><div class="qn l"><p class="bd b dl z fq qk fs ft ql fv fx dk translated">towardsdatascience.com</p></div></div><div class="qo l"><div class="ra l qq qr qs qo qt lc qf"/></div></div></a></div><p id="b059" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">可以使用内置的NumPy函数<code class="fe op oq or os b"><a class="ae li" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.det.html" rel="noopener ugc nofollow" target="_blank">numpy.linalg.det(a)</a></code>计算行列式</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ok ol l"/></div></figure></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h1 id="622d" class="nc nd iu bd ne nf ng nh ni nj nk nl nm kj nn kk no km np kn nq kp nr kq ns nt bi translated">结论</h1><p id="17b6" class="pw-post-body-paragraph lj lk iu ll b lm of ke lo lp og kh lr ls oh lu lv lw oi ly lz ma oj mc md me in bi translated">在这篇文章中，我们试图涵盖很多内容。我们简要概述了与机器学习相关的一些最常见的线性代数概念背后的理论。此外，在NumPy的帮助下，我们已经用python实现了大多数概念。</p><p id="44d3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们的目标是提供一个通用的指南和一个重要主题的简要概述。因此，我们要么必须完全回避，要么只能触及线性代数的某些方面。</p><p id="1c8f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，手头的这篇文章应该为我们提供建立第一直觉的方法，并有一个主题路线图，我们可以在必要时进一步探索。</p><p id="8e52" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我们在实践中学习、应用和实现机器学习算法时，理解线性代数的基础和良好的直觉将被证明是非常宝贵的。</p><blockquote class="mp mq mr"><p id="c117" class="lj lk mo ll b lm ln ke lo lp lq kh lr ms lt lu lv mt lx ly lz mu mb mc md me in bi translated">感谢您的阅读！确保保持联系&amp;在<a class="ae li" href="https://medium.com/@marvinlanhenke" rel="noopener"> Medium </a>、<a class="ae li" href="https://www.kaggle.com/mlanhenke" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上关注我，或者在<a class="ae li" href="https://www.linkedin.com/in/marvin-lanhenke-11b902211/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上说声“嗨”</p></blockquote></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><p id="84a8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">喜欢这篇文章吗？成为 <a class="ae li" href="https://medium.com/@marvinlanhenke/membership" rel="noopener"> <em class="mo">中等会员</em> </a> <em class="mo">继续无限学习。如果你使用下面的链接，我会收到你的一部分会员费，不需要你额外付费。</em></p><div class="qc qd gq gs qe qf"><a href="https://medium.com/@marvinlanhenke/membership" rel="noopener follow" target="_blank"><div class="qg ab fp"><div class="qh ab qi cl cj qj"><h2 class="bd je gz z fq qk fs ft ql fv fx jd bi translated">通过我的推荐链接加入Medium-Marvin Lanhenke</h2><div class="qm l"><h3 class="bd b gz z fq qk fs ft ql fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qn l"><p class="bd b dl z fq qk fs ft ql fv fx dk translated">medium.com</p></div></div><div class="qo l"><div class="rb l qq qr qs qo qt lc qf"/></div></div></a></div><p id="93ae" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">参考资料/更多资料:</strong></p><ul class=""><li id="ad05" class="ot ou iu ll b lm ln lp lq ls ov lw ow ma ox me rc oz pa pb bi translated">深度学习(Ian J. Goodfellow，Yoshua Bengio和Aaron库维尔)，第二章，麻省理工学院出版社，2016年。</li><li id="05eb" class="ot ou iu ll b lm pc lp pd ls pe lw pf ma pg me rc oz pa pb bi translated">迈克·科恩博士。线性代数:理论，直觉，代码。</li></ul></div></div>    
</body>
</html>