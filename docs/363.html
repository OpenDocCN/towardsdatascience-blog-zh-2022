<html>
<head>
<title>Multilabel Classification With PyTorch In 5 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyTorch在5分钟内进行多标记分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multilabel-classification-with-pytorch-in-5-minutes-a4fa8993cbc7#2022-01-13">https://towardsdatascience.com/multilabel-classification-with-pytorch-in-5-minutes-a4fa8993cbc7#2022-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="3382" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用PyTorch在5分钟内进行多标记分类</h1></div><div class=""><h2 id="0e87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您自己的分类任务蓝图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/de9e11f0e38c4924ae250090b363f8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqJqVSta6yrmC3rs6YnjGg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·苏普伦在<a class="ae ky" href="https://unsplash.com/s/photos/cars?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6d0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">当处理图像分类时，人们通常从对一个类别中的一个或多个类别进行分类开始。例如，如果您想对汽车进行分类，您可以区分它是否是敞篷车。这是二元分类的一个例子。更复杂的任务可能是区分几个类别。它是奥迪、宝马、奔驰还是福特？汽车品牌中有不止一个类别。如果我们想把两个例子结合起来呢？我们可以<strong class="lb iu">一次对显示车辆的每张图像的多个特征进行分类</strong>，例如品牌、车型和制造年份。一种方法是训练三个独立的分类器<strong class="lb iu">，但是也有可能将所有东西集成到一个模型</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/64e4212e0c932325097f89f399370317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyCqhOOHiFm_LqikPcAUdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分类任务(由作者完成)</p></figure><p id="7ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将与出于教育目的免费使用的<a class="ae ky" href="https://ai.stanford.edu/~jkrause/cars/car_dataset.html" rel="noopener ugc nofollow" target="_blank">斯坦福汽车数据集</a>一起完成这项工作。我们开始吧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fb56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们创建了两个函数来a)下载和提取图像本身，b)存储相应的元数据(包含关于品牌和型号的信息)。在下一步中，我们创建一个类，该类合并两种信息并提取总共三个相关特征:</p><blockquote class="mh mi mj"><p id="4e42" class="kz la mk lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">数据集中所有超过1000张图片的<strong class="lb iu">品牌</strong>。我们将所有其他品牌归入“其他”类别。</p><p id="21ce" class="kz la mk lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">我们区分<strong class="lb iu">不同类型的车辆</strong>:敞篷车、轿跑、SUV、面包车。所有不涉及车型的车型，我们都归纳为“其他”类别。</p><p id="066c" class="kz la mk lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">我们将拼车分成<strong class="lb iu">两个时间相关的队列</strong>:2009年及更早发布的所有汽车和2010年及更晚发布的所有汽车。</p></blockquote><p id="ddb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们有三个不同类别的目标，我们希望同时预测其中的每一个。我们可以从元数据中提取所有需要的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d8e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如类的文档字符串中所述，我们可以传递包含类的类别的字典:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们得到了一个列表，其中包含三个类别(品牌、类型、年份)的三个数字特性列表。这些是我们的培训标签。我们可以稍后使用字典重新分配它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="203f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，每个类都有足够的案例。我们确实有偏斜的分布，但是我们可以通过<a class="ae ky" href="https://discuss.pytorch.org/t/passing-the-weights-to-crossentropyloss-correctly/14731/10" rel="noopener ugc nofollow" target="_blank">加权</a>来减轻。我们让这些类保持原样，并为我们的自定义数据集创建一个字典。我们为每个文件名分配相应的训练标签:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d1fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将创建自定义数据集。更深入的介绍，你可以看看我的这篇文章。基本上还没什么特别的。<strong class="lb iu">唯一的不同是，我们为每个样本</strong>加载三个训练标签，而不是一个，并将所有三个标签传递到我们的训练循环中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用数据加载器加载一个样本并查看它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="bd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的定制数据集和数据加载器按预期工作。我们每批得到一个字典，包含图像和3个目标标签。这样我们就有了多标记分类器的先决条件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/2a3f0ff96d599768f849cd7eb2d57b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqEcUsDI5fmSbjTCzLWMeA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义多标签分类器(由作者提供)</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们加载<strong class="lb iu">一个预训练的ResNet34 </strong>并显示最后3个子元素。首先是顺序块，然后是池操作，最后是线性层。这会得到512个特征作为输入，并给出1000个特征作为输出。我们<strong class="lb iu">想要删除这最后一层，并用新的层</strong>替换它。我们已经知道，我们各有512个内特征，需要a) 6个品牌外特征，b) 5个车型外特征，c) 2个时代外特征。我们可以通过将所有子元素放入一个列表并删除最后一个元素来删除最后一层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="82b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在没有分类器头的情况下使用ResNet处理输出，并查看各自的张量形状:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ed75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果我们得到一个格式为[16，512，1，1]的张量。我们的批次中有16个样本，每个图像有512个特征。第三和第四个维度的大小为1，可以通过<em class="mk"> torch.flatten() </em>进行平滑。现在，我们可以将此输出传递给新的分类器层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是我们想要的。在我们的批次中，每个样品有6个对数。我们现在可以像往常一样使用训练循环中的损失函数来处理这些。现在，我们添加另外两个分类器层，并将所有内容放在一个自定义模型中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建了一个灵活的训练程序，考虑了我们模型的所有输出。因此，我们是否有2个、3个或例如5个分级机头并不重要。对于多分类任务，我们简单地使用传统的损失函数。我们计算每个头部的<strong class="lb iu"> <em class="mk">交叉弯曲</em> </strong>并合计损失。这样，我们可以通过一个优化步骤来优化所有三个头的权重:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还编写了验证例程，以便我们可以传递灵活数量的类别进行分类。我们计算每个类别的总绩效和每个类别的绩效:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><h2 id="1f02" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">结论</h2><blockquote class="mh mi mj"><p id="6f7e" class="kz la mk lb b lc ld ju le lf lg jx lh ml lj lk ll mm ln lo lp mn lr ls lt lu im bi translated">每一类大约90%的准确率，我们能够做出很好的预测。我们看到，我们可以用一个模型对多个类<strong class="lb iu">进行分类，而不需要多个模型或运行。在我们的例子中，我们使用PyTorch，并且看到我们可以使用定制数据集和定制模型快速创建定制训练例程。此外，尽管任务很复杂，我们还是利用了<strong class="lb iu">迁移学习</strong>来快速获得好的结果。在现实世界中，有很多这样的应用领域。<strong class="lb iu">想象一下，你运行一个二手车平台，想要直接从图像中提取关于单个车辆特征的建议。在我们的例子中，我们离这并不远。</strong>还有另一种形式的多标签分类。例如，想想社交网络中的图像标签。这里，我们也给出了某些类，但并不是每个图像都被强制分配给每个类。我们将在下一章讨论这个问题。感谢阅读！</strong></p></blockquote><h1 id="4de6" class="ni mq it bd mr nj nk nl mu nm nn no mx jz np ka na kc nq kd nd kf nr kg ng ns bi translated">进一步阅读</h1><p id="7139" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><strong class="lb iu">笔记本:</strong><a class="ae ky" href="https://jovian.ai/droste-benedikt/02-article-pytorch-multilabel-classification" rel="noopener ugc nofollow" target="_blank">https://jovian . ai/droste-benedikt/02-article-py torch-multi label-classification</a><br/><strong class="lb iu">关于多类:</strong><a class="ae ky" href="https://scikit-learn.org/stable/modules/multiclass.html" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/stable/modules/multiclass.html</a></p><h1 id="b6d1" class="ni mq it bd mr nj nk nl mu nm nn no mx jz np ka na kc nq kd nd kf nr kg ng ns bi translated">数据集信用</h1><p id="e0a2" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><strong class="lb iu">用于细粒度分类的3D对象表示</strong> <br/> Jonathan Krause，Michael Stark，Jia Deng，李菲菲<br/> <em class="mk">第四届IEEE表示和识别研讨会，ICCV 2013</em><strong class="lb iu">(3 drr-13)</strong>。澳大利亚悉尼。2013年12月8日。<br/><a class="ae ky" href="https://ai.stanford.edu/~jkrause/papers/3drr13.pdf" rel="noopener ugc nofollow" target="_blank">【pdf】</a><a class="ae ky" href="https://ai.stanford.edu/~jkrause/papers/3drr13.bib" rel="noopener ugc nofollow" target="_blank">【BibTex】</a><a class="ae ky" href="https://ai.stanford.edu/~jkrause/papers/3drr_talk.pdf" rel="noopener ugc nofollow" target="_blank">【幻灯片】</a></p><div class="ny nz gp gr oa ob"><a href="https://ai.stanford.edu/~jkrause/cars/car_dataset.html" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">汽车数据集</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">概述汽车数据集包含196类汽车的16，185幅图像。数据被分成8，144个训练图像…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">ai.stanford.edu</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><p id="1c45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@droste.benedikt/membership" rel="noopener">如果您喜欢中级数据科学，并且还没有注册，请随时使用我的推荐链接加入社区。</a></p></div></div>    
</body>
</html>