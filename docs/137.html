<html>
<head>
<title>Feature Engineering for Machine Learning in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R语言中机器学习的特征工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-engineering-for-machine-learning-in-r-2ed684727566#2022-01-05">https://towardsdatascience.com/feature-engineering-for-machine-learning-in-r-2ed684727566#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="6f49" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">R语言中机器学习的特征工程</h1></div><div class=""><h2 id="31e7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从数据集中提取有价值信息的重要过程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6ebd557dd36f531905f1f4bd90920b61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FJKTLTIEJaUknnJB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@rodlong" rel="noopener ugc nofollow" target="_blank">杆长</a>在<a class="ae ky" href="https://unsplash.com/photos/ldsCiYoExvk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><blockquote class="kz la lb"><p id="cb4d" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本文是故事<a class="ae ky" href="https://www.analyticsvidhya.com/blog/2021/10/master-the-basics-of-r-programming/" rel="noopener ugc nofollow" target="_blank">掌握R编程基础</a>的续篇。在第一篇文章中，我介绍了R的构建模块，它将帮助你了解这门语言。理解和学习真的很直观。在这篇文章中，我将重点关注特征处理，它代表了任何数据科学项目的相关部分。如果没有干净的数据，任何机器学习模型的努力都将是徒劳的。让我们开始这段旅程吧！</p></blockquote><h2 id="2e60" class="lz ma it bd mb mc md dn me mf mg dp mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">目录:</h2><ol class=""><li id="8463" class="mv mw it lf b lg mx lj my mi mz mm na mq nb ly nc nd ne nf bi translated"><a class="ae ky" href="#5d92" rel="noopener ugc nofollow"> <strong class="lf iu">转换为因子</strong> </a></li><li id="4efe" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly nc nd ne nf bi translated"><a class="ae ky" href="#91e1" rel="noopener ugc nofollow"> <strong class="lf iu">添加和删除列</strong> </a></li><li id="86d7" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly nc nd ne nf bi translated"><a class="ae ky" href="#name=&quot;282d&quot;" rel="noopener ugc nofollow"> <strong class="lf iu">从连续特征到分类特征</strong> </a></li><li id="cc25" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly nc nd ne nf bi translated"><a class="ae ky" href="#bec0" rel="noopener ugc nofollow"> <strong class="lf iu">查找缺失值</strong> </a></li><li id="fe6c" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly nc nd ne nf bi translated"><a class="ae ky" href="#0250" rel="noopener ugc nofollow"> <strong class="lf iu">处理缺失值</strong> </a></li></ol></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="ae2a" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka ml kc oa kd mp kf ob kg mt oc bi translated">要求</h1><p id="3914" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">在之前的帖子里，我建议你同时安装<strong class="lf iu"> R </strong>和<strong class="lf iu"> R studio </strong>。R是一门语言，而R studio是一个IDE，允许以一种更简单的方式使用R。</p><h1 id="4a92" class="ns ma it bd mb nt og nv me nw oh ny mh jz oi ka ml kc oj kd mp kf ok kg mt oc bi translated">介绍</h1><p id="0c8c" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">让我们从从Kaggle导入数据集<a class="ae ky" href="https://www.kaggle.com/sanjanavoona1043/bank-churn/version/1" rel="noopener ugc nofollow" target="_blank">银行流失模型</a>开始，并可视化前六行[1]。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="7db4" class="lz ma it om b gy oq or l os ot">df &lt;- read.csv('Bank_churn_modelling.csv',header = T)<br/>head(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/dbd92f62cb43f6d3c44978d99b29a119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUxZtPAxKFWEjk3rrOPDnw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="7463" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">你能注意到的第一件事(如果你以前使用过Python)是我们不需要导入任何库，很漂亮，不是吗？让我们尝试查看有关数据集的其他统计数据和信息:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="e30a" class="lz ma it om b gy oq or l os ot"> summary(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/2b2be2b0115858a473f7789c1bab9335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDWuCGiXtvp9gq04GCen0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="34a5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated"><code class="fe ow ox oy om b">summary</code>是用于打印所有特性的描述性统计的功能。从输出来看，值得注意的是:</p><ul class=""><li id="58f1" class="mv mw it lf b lg lh lj lk mi oz mm pa mq pb ly pc nd ne nf bi translated">大多数变量被认为是数字。但是像Excited和HasCrCard这样的变量，范围在0到1之间。然后，要把这些特征转化为因子。</li><li id="d7c2" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated">姓氏、地域、性别是性格变量。因此，输出会显示其他信息，包括样本数量(长度)、类的类型和模式。我们也应该把地理和性别转换成因素变量。</li></ul><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="fab3" class="lz ma it om b gy oq or l os ot">str(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/992cab6a5c9b9c72969cce88256da041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rNbq4X5XDXgTalRrBq817Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="485e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated"><code class="fe ow ox oy om b">str</code>提供了一个更紧凑的输出，总结了数据集的结构。它告诉我们有1000行和14列。大多数变量包含数值/整数值，而其余的特征是字符变量。</p><h1 id="5d92" class="ns ma it bd mb nt og nv me nw oh ny mh jz oi ka ml kc oj kd mp kf ok kg mt oc bi translated">1.转换为因子</h1><p id="3d63" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">正如我们在上一段中看到的，我们必须进行更改，将一些变量转换为因子。你可能想知道是什么因素。在R语言中，因子是专门用于将元素分类的向量类型。换句话说，因素是分类变量，可以有两个或更多的层次。这些级别可以包含字符串和整数。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="f5e5" class="lz ma it om b gy oq or l os ot">df$Geography &lt;- as.factor(Geography)<br/>df$Gender &lt;- as.factor(Gender)<br/>df$HasCrCard &lt;- as.factor(HasCrCard)<br/>df$IsActiveMember &lt;- as.factor(IsActiveMember)<br/>df$Exited &lt;- as.factor(Exited)<br/>str(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/9c4ea1dc443ccff4469f210277556a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Cdo20JYgDwsvO1Y4yDHZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="479f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">如果我们再次使用<code class="fe ow ox oy om b">str</code>函数很好地转换了变量，我们可以很容易地检查。为了可视化因子的级别，我们可以使用levels函数:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="b7fa" class="lz ma it om b gy oq or l os ot">levels(Geography)<br/># "France"  "Germany" "Spain"</span></pre><p id="4126" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">该数据集仅包含法国、德国和西班牙的客户。</p><h1 id="91e1" class="ns ma it bd mb nt og nv me nw oh ny mh jz oi ka ml kc oj kd mp kf ok kg mt oc bi translated">2.添加和删除列</h1><p id="ab0e" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">添加新列的更简单的方法是给整个新变量分配一个值。例如，让我们创建一个用NA填充的新列，NA是一个逻辑常数，表示r中缺少的值。</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="b987" class="lz ma it om b gy oq or l os ot">df$newcol &lt;- NA<br/>df[1:5,8:15]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/4f5b3e14ba27109ffd558a9eb6a7a77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pyclblxx54e3AK4QJVbzsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="59a2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">为了更容易可视化，我选择了数据集的一个子集，前5行和后8列。添加列的另一种方法是使用以下语法:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="2eaf" class="lz ma it om b gy oq or l os ot">df['newcol'] &lt;- NA</span></pre><p id="2351" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">因此，我们可以在方括号中指定变量，而不是使用$运算符。要删除一个列，我们可以将其设置为NULL，这表示R:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="09e1" class="lz ma it om b gy oq or l os ot">df$newcol &lt;- NULL<br/># alternative df['newcol'] &lt;- NULL<br/>head(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/963d579cd349922a9d0ca436c03e54f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OCULLW0f2tIQx0mMv6tn9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="f186" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">我们打印了前五行以检查是否删除了该列。真的消失了！</p><h1 id="282d" class="ns ma it bd mb nt og nv me nw oh ny mh jz oi ka ml kc oj kd mp kf ok kg mt oc bi translated"><strong class="ak"> 3。将连续变量重新编码为分类变量</strong></h1><p id="bc08" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">假设我想基于EstimatedSalary的值创建一个新变量。目标是将估计工资的范围可视化为区间。这可以通过使用<code class="fe ow ox oy om b">cut</code>功能来实现:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="2ffd" class="lz ma it om b gy oq or l os ot">df$estsalaryclass&lt;-cut(df$EstimatedSalary,breaks = seq(0,max(df$EstimatedSalary)+1,len=4))<br/>levels(df$estsalaryclass)<br/># [1] "(11.6,6.67e+04]"     "(6.67e+04,1.33e+05]" "(1.33e+05,2e+05]"<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/168485586fbae0c4dc73f025f4edfa88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U0ozQMcUu_AE-g0P5F42-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="09c2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">为了创建间隔，应用seq函数来创建三个不同的级别。它接受序列的起始值、结束值和长度作为输入。</p><p id="4174" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">我们还可以向指定参数标签的箱添加标签:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="eeb5" class="lz ma it om b gy oq or l os ot">df$estsalaryclass&lt;-cut(df$EstimatedSalary,breaks = seq(0,max(df$EstimatedSalary)+1,len=4),<br/>                       labels = c('poor','middle','rich'))<br/>levels(df$estsalaryclass)<br/># [1] "poor"   "middle" "rich"<br/>df[1:5,c('EstimatedSalary','estsalaryclass')]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/fa36ea840ba5f54f0d71c4797ce60acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Go8IerdmgjsetiGjk6h3Bw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="0934" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">从图中，您可以推断出因子级别的名称是在指定界限后创建的。</p><p id="ac79" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">我们还可以注意到，默认情况下，<em class="le">间隔在左边打开，在右边</em>关闭。这意味着只有较高的值包含在界限中，而最低的值被排除。</p><p id="42a8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">如果我们希望区间在左边关闭，在右边打开，我们需要将参数right设置为FALSE:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="3b1d" class="lz ma it om b gy oq or l os ot">df$estsalaryclass&lt;-cut(df$EstimatedSalary,breaks = seq(0,max(df$EstimatedSalary)+1,len=4),right = FALSE)<br/>levels(df$estsalaryclass)<br/>[1] "[11.6,6.67e+04)"     "[6.67e+04,1.33e+05)" "[1.33e+05,2e+05)"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/8b7c8839a0c363685b61d7d05a8399dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TlOJ-WjpatNHvPhaGSrIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><h1 id="bec0" class="ns ma it bd mb nt og nv me nw oh ny mh jz oi ka ml kc oj kd mp kf ok kg mt oc bi translated">4.查找缺少的值</h1><p id="d3a8" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">r语言提供了<code class="fe ow ox oy om b">is.na</code>函数来检查数据集中是否有缺失值。要计算数据集的缺失值，我们可以对它们求和:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="2bb4" class="lz ma it om b gy oq or l os ot">sum(is.na(df))<br/># [1] 0</span></pre><p id="5cbe" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">由于数据框不包含缺失值，我们可以手动添加它作为练习:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="1124" class="lz ma it om b gy oq or l os ot">df[5,'Age'] = NA<br/>sum(is.na(df))<br/># [1] 1</span></pre><p id="390b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">你大概在想<code class="fe ow ox oy om b">is.na</code>功能到底在做什么？让我们打印这个函数的输出:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="dcd1" class="lz ma it om b gy oq or l os ot">head(is.na(df))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/8fb7c625d37cf83be94b7ffbec911d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Vf2HI_MpDVfSnYt2zCzfQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="b01d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">它返回一个包含表示缺失值的布尔值的数据框，其中TRUE表示我们有一个NA值。要返回每列缺失值的数量，我们可以使用<code class="fe ow ox oy om b">for</code>和<code class="fe ow ox oy om b">cat</code>函数:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="bd5a" class="lz ma it om b gy oq or l os ot">for (i in 1:length(df))<br/>{cat(c(colnames(df[i]),':',sum(is.na(df[,i])),"\n"))}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/a6bc58d0ad19fd6895a763cc7ac34154.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*kRsFvQE7MpH023nqQefZUw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="620f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated"><code class="fe ow ox oy om b">for</code>用于迭代列，而<code class="fe ow ox oy om b">cat</code>用于打印输出。在这种情况下，cat函数更适合打印，因为它允许在同一行显示多个值。从输出中，我们可以很容易地看到，只有年龄列中缺少一个值。</p><p id="091d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">为了显示包含NA值的列的行索引，我们可以使用<code class="fe ow ox oy om b">which</code>函数:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="841d" class="lz ma it om b gy oq or l os ot">which(is.na(df[,'Age']))<br/>#[1] 5</span></pre><p id="438b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">该函数给出逻辑向量中真实元素的<strong class="lf iu">位置。出于这个原因，我们只指定列向量作为输入，而不是整个数据帧。</strong></p><h1 id="0250" class="ns ma it bd mb nt og nv me nw oh ny mh jz oi ka ml kc oj kd mp kf ok kg mt oc bi translated">5.处理缺失值</h1><p id="50c4" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">处理缺失值的更简单的方法是删除包含NA值的行:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="f414" class="lz ma it om b gy oq or l os ot">df_notna&lt;-na.omit(df)<br/>sum(is.na(df_notna))<br/># [1] 0</span></pre><p id="970b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated"><code class="fe ow ox oy om b">na.omit</code>轻松删除有NA的行，返回一个没有丢失值的数据帧。</p><p id="ecab" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">但是删除丢失的值并不总是最好的解决方案。另一种方法是用列的平均值代替NA值:</p><pre class="kj kk kl km gt ol om on oo aw op bi"><span id="2cf4" class="lz ma it om b gy oq or l os ot">avg_age &lt;- round(mean(df$Age,na.rm=TRUE))<br/>df$Age&lt;-ifelse(is.na(df$Age),avg_age,df$Age)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/9cf5530bde241cd94ffd2079887a19f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8oslG_Pqe01WRr0f_9iug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者插图</p></figure><p id="4859" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated"><code class="fe ow ox oy om b">ifelse(test,yes,no)</code>返回一个与年龄变量形状相同的向量。如果测试的条件为真，则该列的值将被年龄的平均值替换。否则，返回值将与作为输入的列中的值相同。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="55d2" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka ml kc oa kd mp kf ob kg mt oc bi translated">摘要</h1><ul class=""><li id="6cc8" class="mv mw it lf b lg mx lj my mi mz mm na mq nb ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">str</code>和<code class="fe ow ox oy om b">summary</code>用于可视化关于数据帧的信息</li><li id="a626" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">print</code>和<code class="fe ow ox oy om b">cat</code>都有助于显示输出。</li><li id="4b6d" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">as.factor</code>用于将变量转换成因子</li><li id="fdce" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">cut</code>通过将特征范围划分为区间，将连续变量转换为分类变量</li><li id="5de3" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">is.na</code>返回包含布尔值的数据帧，其中TRUE表示单元格中存在NA</li><li id="eaa8" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">which</code>显示矢量中包含的真实元素的位置</li><li id="38f9" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">na.omit</code>删除数据帧中带有NA的行</li><li id="13e9" class="mv mw it lf b lg ng lj nh mi ni mm nj mq nk ly pc nd ne nf bi translated"><code class="fe ow ox oy om b">ifelse(test,yes,no)</code>是一种更简洁、更快速的if-else语句。</li></ul></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="f261" class="ns ma it bd mb nt nu nv me nw nx ny mh jz nz ka ml kc oa kd mp kf ob kg mt oc bi translated">最终想法:</h1><p id="419b" class="pw-post-body-paragraph lc ld it lf b lg mx ju li lj my jx ll mi od lo lp mm oe ls lt mq of lw lx ly im bi translated">我希望这篇教程对你有用。我发现有必要写这篇文章，因为没有很多资源讨论r的特性工程。我没有涵盖所有的方面，因为我将在接下来的文章中涵盖其余的方面。感谢阅读！祝你有愉快的一天。</p><p id="ecf6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated"><strong class="lf iu">参考文献:</strong></p><p id="c13c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">[1]<a class="ae ky" href="https://www.kaggle.com/sanjanavoona1043/bank-churn/version/1" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/sanjanavoona 1043/bank-churn/version/1</a></p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><p id="7057" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll mi ln lo lp mm lr ls lt mq lv lw lx ly im bi translated">你喜欢我的文章吗？<a class="ae ky" href="https://eugenia-anello.medium.com/membership" rel="noopener"> <em class="le">成为会员</em> </a> <em class="le">每天无限获取数据科学新帖！这是一种间接的支持我的方式，不会给你带来任何额外的费用。如果您已经是会员，</em> <a class="ae ky" href="https://eugenia-anello.medium.com/subscribe" rel="noopener"> <em class="le">订阅</em> </a> <em class="le">每当我发布新的数据科学和python指南时，您都会收到电子邮件！</em></p></div></div>    
</body>
</html>