<html>
<head>
<title>Self-Supervised Learning for Anomaly Detection in Python: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中异常检测的自我监督学习:第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/self-supervised-learning-for-anomaly-detection-in-python-part-2-5c918b12a1bc#2022-01-06">https://towardsdatascience.com/self-supervised-learning-for-anomaly-detection-in-python-part-2-5c918b12a1bc#2022-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="a0bf" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Python中异常检测的自监督学习:第二部分</h1></div><div class=""><h2 id="5073" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">CutPaste:作为核密度估计改进的自我监督学习</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e4da8b9a5c48488f1c7256f352340d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xK8sGpycrpwzHkxg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">兰迪·法特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="95a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/review-on-self-supervised-contrastive-learning-93171f695140">自我监督学习</a>是现代深度学习研究中最热门的领域之一。正如Yann Lecun喜欢说的<a class="ae kv" href="https://ai.facebook.com/blog/self-supervised-learning-the-dark-matter-of-intelligence/" rel="noopener ugc nofollow" target="_blank">自我监督学习是智能的暗物质</a>和在人工智能系统中创造常识的方法。这种范式的思想和技术吸引了许多研究者尝试将自我监督学习的应用扩展到新的研究领域。当然，异常检测也不例外。</p><p id="f446" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" rel="noopener" target="_blank" href="/kernel-density-estimation-for-anomaly-detection-in-python-part-1-452c5d4c32ec"> <strong class="ky ir">在本文的第1部分</strong> </a>中，我们讨论了异常检测的定义和一种称为核密度估计的技术。KDE是发现数据集中异常数据点的最流行和最简单的方法之一。它适用于表格数据。然而，我们对图像的实现感兴趣。视觉检测是一种非常受欢迎的应用，其重点是发现我们感兴趣的物体中的缺陷或异常值。</p><p id="4ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">那么，我们如何在不损失太多信息的情况下，通过降低计算成本对图像进行KDE呢？</em></p><p id="3c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对许多人来说，答案可能是显而易见的:找到一个好的主干，它可以为我们提供图像的良好表示。然后我们可以用这些表象来指挥KDE。</p><p id="a1e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">针对特定用例微调主干的最佳方式是自我监督学习。最近，世界上许多研究人员致力于将自监督学习技术与经典异常检测技术相结合。此外，研究人员提出了全新的转换方法，以改善用于异常检测的自监督学习的托词任务。</p><p id="7639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文章的这一部分，我们将讨论Google的一种新的自我监督技术CutPaste[1]，并了解一种新的创造性的数据转换方法如何提高训练结果。</p><p id="7688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剪切膏的主要成分包括:</p><ol class=""><li id="9d16" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">新改进的借口任务</li><li id="dd86" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">自监督模型结构</li></ol><h2 id="6b84" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated"><strong class="ak">剪贴和疤痕剪贴</strong></h2><p id="d402" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">一种非常流行的自我监督的借口任务被称为Cutout。顾名思义，它从一幅图像中随机剪切出一小块矩形区域。这在许多自我监督的环境中工作得很好，并作为数据扩充。这似乎是异常检测用例的一个很好的模拟。</p><p id="27db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该论文的研究人员提出了这种技术的一种新变体，称为CatPaste，它从图像中复制一小部分，并将其替换到其他地方。它产生局部不规则性，这似乎与异常检测问题设置完全一致。</p><p id="4c66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种托辞任务的另一种变体叫做剪切疤痕，它是对原始疤痕剪切技术的改进。在最初的疤痕剪切中，我们从图像中取出一个细长的矩形块，并用随机颜色替换它。在这种情况下，我们从图像中使用一个类似疤痕的矩形补丁，并再次将其随机插入图像中的其他位置。</p><p id="6183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/LilitYolyan/CutPaste/blob/main/cutpaste.py" rel="noopener ugc nofollow" target="_blank">点击GitHub链接查看PyTorch中的CutPaste和Scar-CutPaste实现。</a></p><p id="5373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来像是托词任务定义的一个小变化。然而，实验结果表明，该方法提高了最终异常检测的结果。下图展示了一些剪贴和疤痕剪贴的例子。我们可以注意到，在某些情况下，它可能看起来像是物体中的真正缺陷。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/d6a2188b02583b699bf6afb1c21f4c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DydynHSdcvNZtFPm"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源于论文[1]。参见参考文献</p></figure><p id="8d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是否意味着从剪切粘贴中创建的缺陷是对原始缺陷的良好模拟？为了回答这个问题，作者展示了切割糊、疤痕切割糊、正常和异常样品的t-SNE图。下图显示，在大多数情况下，借口任务不会与异常重叠，因此我们可以说它不是真实异常的良好模拟。然而，训练结果表明，尽管存在分布差异，但这些变换有助于为异常检测创建更好的表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/fb36a65f3ce92149a958a93ff5990b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wArW87rWkti_DzIR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正常、异常、切割糊和疤痕切割糊样本的t-SNE图。图片来源于论文[1]。参见参考文献</p></figure><h2 id="2b01" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated"><strong class="ak">自监督模型结构</strong></h2><p id="7a87" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">最初使用ResNet-18来创建模型。接下来，添加MLP投影头，然后是输出表示的最后一个线性层。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码来自:【https://github.com/LilitYolyan/CutPaste T4】</p></figure><p id="23d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进行了两种类型的实验:二元分类和三元分类。</p><p id="1fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一种情况下，模型使用原始图像，并使用CutPaste或CutPaste-Scar随机变换它。然后，原始图像和变换后的图像成为两个不同的类别，我们在此基础上进行二值分类。</p><p id="3ca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，是三向分类技术，其中我们不是随机使用Cutpaste和CutPaste-Scar，而是将两者作为单独的类使用，并且我们添加normal类作为第三个类。最后，我们把它分为三类。</p><p id="a610" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们的CutPaste对象可以根据分类类型返回转换后的图像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">代码来自:<a class="ae kv" href="https://github.com/LilitYolyan/CutPaste" rel="noopener ugc nofollow" target="_blank">https://github.com/LilitYolyan/CutPaste</a></p></figure><p id="879c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">损失是交叉熵，其中CP(.)是图像的剪切粘贴变换。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/22ca6e1b3ae23a36e7d19e0eadd55162.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/0*nwGh91y4M9YGtsVb"/></div></figure><h1 id="b8d8" class="nk mi iq bd mj nl nm nn mm no np nq mp jw nr jx ms jz ns ka mv kc nt kd my nu bi translated">参考</h1><p id="e288" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">[1]李，孙春亮，Kihyuk和Yoon，Jinsung和Pfister，托马斯.(2021).<a class="ae kv" href="https://arxiv.org/abs/2104.04015" rel="noopener ugc nofollow" target="_blank"> CutPaste:用于异常检测和定位的自我监督学习。</a></p><h2 id="3422" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">点击Github 的<a class="ae kv" href="https://github.com/LilitYolyan/CutPaste" rel="noopener ugc nofollow" target="_blank">代码链接</a></h2><h2 id="f242" class="mh mi iq bd mj mk ml dn mm mn mo dp mp lf mq mr ms lj mt mu mv ln mw mx my mz bi translated">在这里可以找到文章的第1部分:<a class="ae kv" rel="noopener" target="_blank" href="/kernel-density-estimation-for-anomaly-detection-in-python-part-1-452c5d4c32ec">Python中异常检测的核密度估计</a></h2></div></div>    
</body>
</html>