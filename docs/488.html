<html>
<head>
<title>The M4 Time Series Forecasting Competition with ThymeBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用百里香增强软件进行M4时间序列预测竞赛</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-m4-time-series-forecasting-competition-with-thymeboost-b31196fc319#2022-01-17">https://towardsdatascience.com/the-m4-time-series-forecasting-competition-with-thymeboost-b31196fc319#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="3c42" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">用百里香增强软件进行M4时间序列预测竞赛</h1></div><div class=""><h2 id="3387" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:每周数据集</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/67316582b24d235d164f58ef823aefdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Y-YXXBryiJfMx8XxbhPPw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔恩·泰森来自<a class="ae kv" href="https://unsplash.com/photos/FlHdnPO6dlw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>的图片</p></figure><p id="8e71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> TLDR: </strong>在本文中，我们来看看百里香的一些不同实现，看看它在M4竞赛中的竞争力如何。主要的竞争是ES-RNN模型(获胜)和Theta模型，后者是表现最好的基准。在每周数据集之后，某些ThymeBoost实现脱颖而出。</p><p id="8936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要百里香的介绍，看看这篇<a class="ae kv" rel="noopener" target="_blank" href="/thymeboost-a0529353bf34">文章</a>。</p><p id="52bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/tblume1992/ThymeBoost" rel="noopener ugc nofollow" target="_blank">百里香增强GitHub </a></p><h1 id="3219" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍</h1><p id="5550" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">M4比赛是过去40年来定期举行的M比赛中的又一个参赛项目。几十年来，他们一直被期待作为时间序列预测方法的基准，M4竞赛也不例外。它由100k个时间序列组成，跨越几个领域和频率，提供了一个不错的基准。虽然，一些频率被低估，这可能有利于某些方法。在讨论基准测试时，我将继续让您知道这并不意味着对百里香增强进行基准测试，相反，这是对百里香增强功能的回顾。我会将学到的知识应用到“自动调整”预测方法中。与ARIMA或其他传统方法不同，增强时间序列分解方法没有指南，我希望找到几个问题的答案，例如:</p><ol class=""><li id="7f3d" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">哪些趋势方法有效？</li><li id="88a4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">什么方法在框架中作为“生成器”工作得很好？</li><li id="8be5" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">组件学习率呢，它们有什么作用吗？</li></ol><p id="c0cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">带着这些问题，让我们开始吧。</p><h1 id="f140" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据</h1><p id="5874" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这些数据集都是开源的，并且在M-competitions <a class="ae kv" href="https://github.com/Mcompetitions/M4-methods/tree/master/Dataset" rel="noopener ugc nofollow" target="_blank"> github </a>上直播。它被标准训练和测试分割，因此我们将使用训练csv进行拟合，而测试仅用于使用SMAPE进行评估。让我们继续将数据和百里香一起导入，如果您还没有安装它，请从pip中获取它。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="c77a" class="ni lt iq ne b gy nj nk l nl nm">pip install ThymeBoost</span></pre><p id="c3ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有频繁的更新，所以即使你以前安装了它，你可能想继续下去，并更新！</p><p id="a3a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了百里香和数据集，让我们开始编码。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="065d" class="ni lt iq ne b gy nj nk l nl nm">import matplotlib.pyplot as plt<br/>import numpy as np<br/>from tqdm import tqdm<br/>import pandas as pd<br/>from ThymeBoost  import ThymeBoost as tb</span><span id="2658" class="ni lt iq ne b gy nn nk l nl nm">train_df = pd.read_csv(r'm4-weekly-train.csv')<br/>test_df = pd.read_csv(r'm4-weekly-test.csv')<br/>train_df.index = train_df['V1']<br/>train_df = train_df.drop('V1', axis = 1)<br/>test_df.index = test_df['V1']<br/>test_df = test_df.drop('V1', axis = 1)</span></pre><p id="2b16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们只需导入所有必需的包，并将数据作为标准数据帧读入。接下来，让我们创建SMAPE函数，该函数将返回给定预测和实际值的SMAPE:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1931" class="ni lt iq ne b gy nj nk l nl nm">def smape(A, F):<br/>    return 100/len(A) * np.sum(2 * np.abs(F - A) / (np.abs(A) +       np.abs(F)))</span></pre><p id="d671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的实验中，我们将采用所有时间序列的平均值来与其他模型进行比较。对于健全性检查，我们还将获得“幼稚”的平均得分，以确保我们所做的与竞争中所做的一致。也就是说，我们将简单地遍历数据帧并进行惰性拟合和预测。代码可以通过<strong class="ky ir">而不是</strong>执行for循环来优化，但是这样做也很好！</p><h1 id="bb86" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现#1:简单</h1><p id="3087" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一个参数设置集中于使用趋势估计器的“生成器”变量。这意味着我们将在每一轮中改变趋势估计值，并在提供的列表中循环。通过:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="cac3" class="ni lt iq ne b gy nj nk l nl nm">trend_estimator=['linear', 'ses']</span></pre><p id="bf1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这往往做得很好，它有一个非常“theta-ey”的外观。第一轮(不是初始化轮)符合一条简单的趋势线。接下来是简单的指数平滑。全拟合函数将如下所示:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="7ff8" class="ni lt iq ne b gy nj nk l nl nm">output = boosted_model.fit(y.values,<br/>                                seasonal_period=[0, 52],<br/>                                trend_estimator=['linear', 'ses'],<br/>                                seasonal_estimator='fourier',<br/>                                fit_type='global',<br/>                                global_cost='mse',<br/>                                seasonality_lr=.9,<br/>                                additive=False,<br/>                                )</span></pre><p id="06d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该设置的另一个有趣部分是为“季节性周期”传递的“生成器”变量。这与trend_estimator的工作原理相同，在trend _ estimator中，第一轮使用<strong class="ky ir"> no </strong>季节性，然后使用周期52，然后回到0，以此类推。参数“加法”为假基本上意味着采用了对数，最后对季节性进行了一点调整，达到了0.9。</p><p id="b70c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，这个实现将用于一个简单循环中的每个系列。让我们继续运行它:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8f49" class="ni lt iq ne b gy nj nk l nl nm">seasonality = 52<br/>smapes = []<br/>naive_smape = []<br/>j = tqdm(range(len(train_df)))<br/>for row in j:<br/>    y = train_df.iloc[row, :].dropna()<br/>    y = y.iloc[-(3*seasonality):]<br/>    y_test = test_df.iloc[row, :].dropna()<br/>    j.set_description(f'{np.mean(smapes)}, {np.mean(naive_smape)}')</span><span id="d5be" class="ni lt iq ne b gy nn nk l nl nm">    boosted_model = tb.ThymeBoost(verbose=0,<br/>                                  normalize_seasonality=True)<br/>    output = boosted_model.fit(y.values,<br/>                                seasonal_period=[0, 52],<br/>                                trend_estimator=['linear', 'ses'],<br/>                                seasonal_estimator='fourier',<br/>                                fit_type='global',<br/>                                global_cost='mse',<br/>                                seasonality_lr=.9,<br/>                                additive=False,<br/>                                )<br/>    predicted_output = boosted_model.predict(output,<br/>                                             len(y_test),<br/>                                             trend_penalty=True)<br/>    smapes.append(smape(y_test.values, predicted_output['predictions'].clip(lower=0)))<br/>    naive_smape.append(smape(y_test.values, np.tile(y.iloc[-1], len(y_test))))<br/>print(f'Weekly {np.mean(smapes)}')<br/>print(f'Naive {np.mean(naive_smape)}')</span></pre><p id="3c80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b2af" class="ni lt iq ne b gy nj nk l nl nm">Weekly 7.780101701503696<br/>Naive 9.161286913982</span></pre><p id="3b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">平均SMAPE是7.78，这实际上是对ES-RNN和Theta的改进:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/795c79dc3d8c1887882b8d25fb7c8739.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*HjaOeBQ95Zwm-sl3kdIVFg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a4d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过稍微改变季节周期来获得更多的收益:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9a08" class="ni lt iq ne b gy nj nk l nl nm">seasonal_period=[0, 52, 52]</span></pre><p id="17df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有点奇怪，所以肯定不是一个可以广泛使用的设置。</p><p id="eb36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用简单线性回归和简单指数平滑的这种来回推进看起来对该数据做得不合理地好。请记住，这个提升过程将适合每个趋势近似值之间的季节性，因此它不像只是去趋势化并将其交给简单的指数平滑器那么简单。但是，它也没有明显更复杂，所以拟合是相当爽快的。</p><h1 id="e271" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现#2:集成</h1><p id="18d7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们可以做的另一件事是平均多个预测。这可以在ThymeBoost中通过将所有内容作为一个列表传递给“ensemble”方法来实现。让我们仔细看看我们将尝试的内容:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5c6e" class="ni lt iq ne b gy nj nk l nl nm">trend_estimator=[['linear', 'ses'],<br/>                 ['linear', 'damped_des'],<br/>                 ['linear', 'des']]<br/>output = boosted_model.ensemble(y.values,<br/>                                seasonal_period=[[0, 52]],<br/>                                global_cost=['mse'],<br/>                                fit_type=['global'],<br/>                                additive=[False],<br/>                                seasonality_lr=[.9],<br/>                                seasonal_estimator=['fourier']<br/>                                )</span></pre><p id="b4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意所有的东西都是作为一个列表传递的！为了在这个方法中使用一个“生成器”变量，就像我们之前在fit方法中所做的一样，我们现在必须将它作为一个列表列表来传递。在这种情况下，trend_estimator由3个“生成器”变量组成。在这里，我们注意到了以前行之有效的方法以及M4竞赛中的“基准”方法。这种方法是简单双指数平滑法和阻尼双指数平滑法的平均值。</p><p id="5493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行这个循环的完整代码块，看看它是如何工作的:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="c64a" class="ni lt iq ne b gy nj nk l nl nm">smapes = []<br/>naive_smape = []<br/>j = tqdm(range(len(train_df)))<br/>seasonality = 52<br/>trend_estimator=[['linear', 'ses'],<br/>                 ['linear', 'damped_des'],<br/>                 ['linear', 'des']]<br/>for row in j:<br/>    y = train_df.iloc[row, :].dropna()<br/>    y = y.iloc[-(3*seasonality):]<br/>    y_test = test_df.iloc[row, :].dropna()<br/>    j.set_description(f'{np.mean(smapes)}, {np.mean(naive_smape)}')<br/>    boosted_model = tb.ThymeBoost(verbose=0,<br/>                                  normalize_seasonality=True)<br/>    output = boosted_model.ensemble(y.values,<br/>                                    seasonal_period=[[0, 52]],<br/>                                    trend_estimator=trend_estimator,<br/>                                    global_cost=['mse'],<br/>                                    fit_type=['global'],<br/>                                    additive=[False],<br/>                                    seasonality_lr=[.9],<br/>                                    seasonal_estimator=['fourier']<br/>                                    )<br/>    predicted_output = boosted_model.predict(output,<br/>                                             len(y_test),<br/>                                             trend_penalty=True)<br/>    smapes.append(smape(y_test.values, predicted_output['predictions'].clip(lower=0)))<br/>    naive_smape.append(smape(y_test.values, np.tile(y.iloc[-1], len(y_test))))<br/>print(f'Weekly {np.mean(smapes)}')<br/>print(f'Naive {np.mean(naive_smape)}')</span></pre><p id="b0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出是:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="33f4" class="ni lt iq ne b gy nj nk l nl nm">Weekly 7.660902293272987<br/>Naive 9.161286913982</span></pre><p id="418d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比ES-RNN和Theta有更大的改进，尽管这样的集合会增加计算时间。</p><p id="a75c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当前结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d42465abc4b622b7036ccea26ae58329.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*03mENweIpLERvydeCj7hqA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="f4f3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实施#3:优化</h1><p id="78c0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">到目前为止，我们已经看了一个简单的百里香增强配置和一个更复杂的平均3个输出的集合方法。下一步是选择使用哪种方法，并希望找到“最佳”方法。为此，我们将使用百里香优化方法。这个方法非常简单，它接受一个标准拟合参数列表(就像ensemble一样)，但这次它将根据维持精度选择一个输出。您可以选择“维持”或“滚动”优化策略，其中滚动利用时序交叉验证。这意味着将有几轮装配和测试。</p><p id="5679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在运行完整的循环之前，让我们仔细看看这个优化方法:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="92d6" class="ni lt iq ne b gy nj nk l nl nm">trend_estimator=[['linear', 'ses'],<br/>                 ['linear', 'damped_des'],<br/>                 ['linear', 'des']]<br/>output = boosted_model.optimize(y.values,<br/>                            seasonal_period=[[0, 52], 0],<br/>                            trend_estimator=[['linear', 'ses'],    boosted_model.combine(trend_estimator)],<br/>                            seasonal_estimator=['fourier'],<br/>                            fit_type=['global'],<br/>                            global_cost=['mse'],<br/>                            seasonality_lr=[.9, .1],<br/>                            additive=[False],<br/>                            optimization_steps=4,<br/>                            optimization_strategy='rolling',<br/>                            lag=28,<br/>                            verbose=0,<br/>                            )</span></pre><p id="5465" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，对于季节性周期，我们将使用上次运行良好的[0，52]以及0，表示完全没有季节性。此外，我们将尝试通过0.9的学习率进行<strong class="ky ir">轻度</strong>季节性调整，以及通过0.1进行<strong class="ky ir">重度</strong>调整。最有趣的是这种“组合”方法被混合使用。这只是意味着百里香增强将使用该设置作为一个整体，同时优化。除了这些设置，我们还看到了新的优化相关参数，这些参数表示如何对每种方法进行分级。在这里，我们将进行4轮拟合和测试，总共维持过去28个周期(显然，您应该根据数据频率来改变这一点)。这意味着4轮中的每一轮都将测试7个数据点，并通过28的整个维持延迟。</p><p id="f405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说了这么多，让我们看看完整的代码和输出:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a031" class="ni lt iq ne b gy nj nk l nl nm">smapes = []<br/>naive_smape = []<br/>j = tqdm(range(len(train_df)))<br/>seasonality = 52<br/>trend_estimator=[['linear', 'ses'],<br/>                 ['linear', 'damped_des'],<br/>                 ['linear', 'des']]<br/>for row in j:<br/>    y = train_df.iloc[row, :].dropna()<br/>    y = y.iloc[-(3*seasonality):]<br/>    y_test = test_df.iloc[row, :].dropna()<br/>    j.set_description(f'{np.mean(smapes)}, {np.mean(naive_smape)}')</span><span id="15db" class="ni lt iq ne b gy nn nk l nl nm">    boosted_model = tb.ThymeBoost(verbose=0,<br/>                                  normalize_seasonality=True)</span><span id="1956" class="ni lt iq ne b gy nn nk l nl nm">    output = boosted_model.optimize(y.values,<br/>                                seasonal_period=[[0, 52], 0],<br/>                                trend_estimator=[['linear', 'ses'], boosted_model.combine(trend_estimator)],<br/>                                seasonal_estimator=['fourier'],<br/>                                fit_type=['global'],<br/>                                global_cost=['mse'],<br/>                                seasonality_lr=[.9, .1],<br/>                                additive=[False],<br/>                                optimization_steps=4,<br/>                                optimization_strategy='rolling',<br/>                                lag=28,<br/>                                verbose=0,<br/>                                )</span><span id="5389" class="ni lt iq ne b gy nn nk l nl nm">    predicted_output = boosted_model.predict(output,<br/>                                             len(y_test),<br/>                                             trend_penalty=True)<br/>    smapes.append(smape(y_test.values, predicted_output['predictions'].clip(lower=0)))<br/>    naive_smape.append(smape(y_test.values, np.tile(y.iloc[-1], len(y_test))))<br/>print(f'Weekly {np.mean(smapes)}')<br/>print(f'Naive {np.mean(naive_smape)}')</span></pre><p id="8a70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和打印报表:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0a16" class="ni lt iq ne b gy nj nk l nl nm">Weekly 7.235682291017231<br/>Naive 9.161286913982</span></pre><p id="32c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们看到了相对于之前实现的另一个改进，但是在计算方面又一次付出了巨大的代价。对于每个时间序列，我们拟合了几种不同类型的模型，并在优化时做了4次。</p><p id="d221" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该数据集的最终排名:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/19122989f2222b7d4b4de69f57649bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*3mzJwj6dXskUmfadOWoDcw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ba44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相对于之前的百里香增强实现，我们确实看到了另一个改进。</p><h1 id="6641" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="d26b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">显然，这整个“促进时间序列分解”的想法是有道理的。主要瓶颈是参数空间巨大。当我们浏览M4数据集时，我的目标之一是想出有意义的测试来尝试在autofit方法中使用。一个必要的测试是为了限制参数空间的季节性，但我仍然不知道什么类型的数据适合什么类型的趋势估计。时间序列的哪些特征与增强的平滑器相关？一辆增压ARIMA怎么样？</p><p id="a4db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不知道，但是可以肯定的说，smoothers在这个框架中做得很好。</p><p id="3e65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在以后的文章中，我们将继续浏览不同的数据集和有趣的百里香增强实现，包括在增强循环中利用外源估计器。</p><p id="d126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果你在使用百里香的过程中发现了什么有趣的东西，一定要让我知道！</p></div></div>    
</body>
</html>