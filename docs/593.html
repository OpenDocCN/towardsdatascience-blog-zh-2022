<html>
<head>
<title>An End-to-End Machine Learning Project: Heart Failure Prediction, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端机器学习项目:心力衰竭预测，第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-end-to-end-machine-learning-project-heart-failure-prediction-part-2-4518d2596421#2022-01-20">https://towardsdatascience.com/an-end-to-end-machine-learning-project-heart-failure-prediction-part-2-4518d2596421#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="9c29" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">端到端机器学习项目:心力衰竭预测，第2部分</h1></div><div class=""><h2 id="871e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">web应用程序中的模型部署</h2></div><p id="c189" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">欢迎来到端到端机器学习项目系列的第二部分！在<a class="ae le" rel="noopener" target="_blank" href="/an-end-to-end-machine-learning-project-heart-failure-prediction-part-1-ccad0b3b468a">第一篇文章</a>中，我们训练、验证、调整并保存了一个使用患者信息来预测心力衰竭概率的机器学习模型。在本文中，我们将开发一个web应用程序，任何人都可以通过它与我们的模型进行交互。应用程序的前端将由HTML、CSS和JavaScript处理，后端将使用Flask用python编写。和往常一样，文章中使用的所有代码都可以在<a class="ae le" href="https://github.com/hfhoffman1144/Heart-Disease-Prediction" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。应用程序的部署版本可以在<a class="ae le" href="https://hf-predictor.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e44991c875e42f0b950a19eed6032995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*PS3yCRghh58DGvAqRufvZQ.gif"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">心力衰竭预测应用程序。图片作者。</p></figure><h1 id="fb07" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">目录结构</h1><p id="d147" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">让我们首先检查这个应用程序的目录结构:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="d03e" class="mx lw it mt b gy my mz l na nb">-/ flaskapp<br/>   -/ models<br/>     - heart_disease_model_2021-12-28<br/>   -/ services<br/>     - model_utils.py<br/>   -/ static<br/>     -/css<br/>     -/ fonts<br/>     -/ img<br/>     -/ js<br/>   -/ templates<br/>     - index.html<br/>   - api_routes.py<br/>   - app.py <br/>-/ notebooks<br/>requirements.txt</span></pre><p id="b145" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个项目的两个主要目录是“flaskapp”和“notebooks”。“笔记本”目录包含我们在上一篇文章中用来训练模型的代码。“flaskapp”目录包含将托管心力衰竭模型的web应用程序的所有代码。我们可以通过将“flaskapp”目录分成前端和后端组件来考虑它的内容。所有的<a class="ae le" href="https://frontendmasters.com/guides/front-end-handbook/2018/what-is-a-FD.html" rel="noopener ugc nofollow" target="_blank">前端</a>组件都包含在“静态”和“模板”目录中。目录的其余部分包含<a class="ae le" href="https://en.wikipedia.org/wiki/Frontend_and_backend" rel="noopener ugc nofollow" target="_blank">后端</a>代码和文件。</p><h1 id="cc99" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">前端</h1><h2 id="d077" class="mx lw it bd lx nc nd dn mb ne nf dp mf kr ng nh mh kv ni nj mj kz nk nl ml nm bi translated">模板</h2><p id="f756" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">“模板”目录的目的是存储应用程序中使用的所有HTML文件。这个特殊的应用程序只有一个页面，这个页面的结构是由index.html决定的。让我们从主要标题开始，浏览一些主要部分:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nn"><img src="../Images/484155e60bd576fcab4f2de8dd8f13ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8NMVl_7u43PxnCQikwKMTA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">主标题。图片作者。</p></figure><p id="ff02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了显示这一点，我们简单地将“h1”标记包装在“nav”标记中，如下所示:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="b21d" class="mx lw it mt b gy my mz l na nb">&lt;!-- Navbar --&gt;</span><span id="3a2d" class="mx lw it mt b gy no mz l na nb">&lt;nav class="navbar navbar-main navbar-expand-lg px-0 mx-4 shadow-none border-radius-xl" id="navbarBlur" navbar-scroll="true"&gt;</span><span id="3655" class="mx lw it mt b gy no mz l na nb">     &lt;h1&gt;Heart Failure Prediction&lt;/h1&gt;</span><span id="c383" class="mx lw it mt b gy no mz l na nb">&lt;/nav&gt;</span></pre><p id="e251" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在‘nav’标签中，我们首先指定一个决定导航条样式的类——我将在下一节解释这个类的来源。接下来，我们指定一个id，允许我们通过JavaScript或HTML的其他部分访问navbar的任何属性。最后一个参数“navbar-scroll”决定了当用户滚动时，navbar是否固定在屏幕上。通过将navbar-scroll设置为true，我们可以确保用户在滚动时总能看到navbr。</p><p id="7c8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">向下移动页面，我们有接受用户输入的部分:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi np"><img src="../Images/04d51bac395924bcc461a0c9e70a9f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2yPvvYpBp6Wft_9AfQgRg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">用户输入部分。图片作者。</p></figure><p id="31c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以说是HTML文件最关键的部分，因为这些输入将通过我们的机器学习模型运行。为了创建这个部分，我们将利用<a class="ae le" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank">Bootstrap</a>——一个前端框架，允许开发人员轻松创建现代响应应用程序。特别是，我们将实现自举<a class="ae le" href="https://getbootstrap.com/docs/4.0/layout/grid/" rel="noopener ugc nofollow" target="_blank">网格系统</a>，它允许我们将页面布局组织成行和列。为了说明这一点，让我们看看第一行输入:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nq"><img src="../Images/5188dd54e3942e600d0aa570797d4958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0paImyfwE7Qg0o3wpvAig.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">第一个输入行。图片作者。</p></figure><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="9f7d" class="mx lw it mt b gy my mz l na nb">&lt;div class="row"&gt;</span><span id="6571" class="mx lw it mt b gy no mz l na nb">  &lt;div class="col-lg-4"&gt;</span><span id="c450" class="mx lw it mt b gy no mz l na nb">   &lt;p style="color: white;"&gt;Sex&lt;/p&gt;</span><span id="ccc0" class="mx lw it mt b gy no mz l na nb">   &lt;select class='form-control' name="sex" id="sex" style="width:100%;"&gt;</span><span id="00e1" class="mx lw it mt b gy no mz l na nb">      &lt;option value="M"&gt;Male&lt;/option&gt;</span><span id="5f4e" class="mx lw it mt b gy no mz l na nb">      &lt;option value="F"&gt;Female&lt;/option&gt;</span><span id="3391" class="mx lw it mt b gy no mz l na nb">    &lt;/select&gt;</span><span id="22e3" class="mx lw it mt b gy no mz l na nb">   &lt;/div&gt;</span><span id="98aa" class="mx lw it mt b gy no mz l na nb">   &lt;div class="col-lg-4"&gt;</span><span id="f796" class="mx lw it mt b gy no mz l na nb">    &lt;p style="color: white;"&gt;Resting ECG&lt;/p&gt;</span><span id="5b60" class="mx lw it mt b gy no mz l na nb">    &lt;select class='form-control' name="restingECG" id="restingECG" style="width:100%;"&gt;</span><span id="b16c" class="mx lw it mt b gy no mz l na nb">       &lt;option value="Normal"&gt;Normal&lt;/option&gt;</span><span id="f8e5" class="mx lw it mt b gy no mz l na nb">       &lt;option value="ST"&gt;ST&lt;/option&gt;</span><span id="f1da" class="mx lw it mt b gy no mz l na nb">       &lt;option value="LVH"&gt;LVH&lt;/option&gt;</span><span id="32cf" class="mx lw it mt b gy no mz l na nb">     &lt;/select&gt;</span><span id="90d6" class="mx lw it mt b gy no mz l na nb">    &lt;/div&gt;</span><span id="787b" class="mx lw it mt b gy no mz l na nb">    &lt;div class="col-lg-4"&gt;</span><span id="5808" class="mx lw it mt b gy no mz l na nb">     &lt;p style="color: white;"&gt;Chest Pain Type&lt;/p&gt;</span><span id="1dc9" class="mx lw it mt b gy no mz l na nb">     &lt;select class='form-control' name="chestPainType" id="chestPainType" style="width:100%;"&gt;</span><span id="8537" class="mx lw it mt b gy no mz l na nb">       &lt;option value="ATA"&gt;ATA&lt;/option&gt;</span><span id="0132" class="mx lw it mt b gy no mz l na nb">       &lt;option value="NAP"&gt;NAP&lt;/option&gt;</span><span id="f920" class="mx lw it mt b gy no mz l na nb">       &lt;option value="ASY"&gt;ASY&lt;/option&gt;</span><span id="99cd" class="mx lw it mt b gy no mz l na nb">       &lt;option value="TA"&gt;TA&lt;/option&gt;</span><span id="66c5" class="mx lw it mt b gy no mz l na nb">     &lt;/select&gt;</span><span id="4598" class="mx lw it mt b gy no mz l na nb">&lt;/div&gt;</span><span id="6e9c" class="mx lw it mt b gy no mz l na nb">&lt;/div&gt;</span></pre><p id="49df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先用类“row”创建一个div。紧随行div之后，我们创建第一个列div，它包含第一个下拉输入。请注意，该类是“col-lg-4”。每个引导行最多可以包含12列；通过将类命名为“col-lg-4”，我们确保了这个div将使用父行中12个可用列空间中的4个。在该列中，我们指定输入的名称，然后用该特性的所有惟一值创建一个select标记。例如，以下HTML对应于“胸痛类型”下拉列表:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="52eb" class="mx lw it mt b gy my mz l na nb">&lt;p style="color: white;"&gt;Chest Pain Type&lt;/p&gt;</span><span id="fc79" class="mx lw it mt b gy no mz l na nb">&lt;select class='form-control' name="chestPainType" id="chestPainType" style="width:100%;"&gt;</span><span id="fee5" class="mx lw it mt b gy no mz l na nb">     &lt;option value="ATA"&gt;ATA&lt;/option&gt;</span><span id="6541" class="mx lw it mt b gy no mz l na nb">     &lt;option value="NAP"&gt;NAP&lt;/option&gt;</span><span id="da6b" class="mx lw it mt b gy no mz l na nb">     &lt;option value="ASY"&gt;ASY&lt;/option&gt;</span><span id="a28c" class="mx lw it mt b gy no mz l na nb">     &lt;option value="TA"&gt;TA&lt;/option&gt;</span><span id="2988" class="mx lw it mt b gy no mz l na nb">&lt;/select&gt;</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b3d203b7fe6bbb164657dd27e91ae8f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*H9bEQ87T-xTVqhs4lRc1QQ.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片作者。</p></figure><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9a37cc158a73bbedebdfef8bbc2b6716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*824RKgxMZXziQBrRaw0ATw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片作者。</p></figure><p id="056d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，我们给每个“select”标签一个名称和一个id。我们稍后在JavaScript中访问下拉列表的值时会用到这些字段。</p><p id="69b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过简单地使用“input”标签并将类型指定为“number”来创建数字输入。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="d777" class="mx lw it mt b gy my mz l na nb">&lt;div class="col-lg-4"&gt;</span><span id="7889" class="mx lw it mt b gy no mz l na nb">    &lt;p style="color: white;"&gt;Age&lt;/p&gt;</span><span id="80af" class="mx lw it mt b gy no mz l na nb">    &lt;input class='form-control' type="number" id="age" name="age"     value="40" min="0" max="120" style="width:100%;"&gt;</span><span id="c535" class="mx lw it mt b gy no mz l na nb">&lt;/div&gt;</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7b5cc90c3adf913d75d5eeaff054cd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*CC6BtQHtp2gcybL9jzxIDA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">输入患者年龄。图片作者。</p></figure><p id="cdce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们将默认年龄设置为40，最小年龄设置为0，最大年龄设置为120。对于年龄来说，这些是非常容易的选择，但是，一般来说，我们可以使用每个数字输入的分布来确定默认值、最小值和最大值。</p><p id="730c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">index.html文件中最后一个主要组件是“运行模型”按钮。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="48c3" class="mx lw it mt b gy my mz l na nb">&lt;div class="col-lg-4"&gt;</span><span id="9be0" class="mx lw it mt b gy no mz l na nb">    &lt;p style="color: white;"&gt;Calculate Heart Failure Probability&lt;/p&gt;</span><span id="d9d3" class="mx lw it mt b gy no mz l na nb">    &lt;button id='makePred' class="btn btn-outline-primary btn-md mb-0" style="width:100%; background-color: white;"&gt;Run model&lt;/button&gt;</span><span id="1afe" class="mx lw it mt b gy no mz l na nb">&lt;/div&gt;</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b9129903cceee18065f52873bbdec86b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*OWbz14g19EVEejejQzhdjw.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">运行模型按钮。图片作者。</p></figure><p id="e164" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们必须给这个按钮一个id，以便它可以在以后用来触发事件。</p><h2 id="4374" class="mx lw it bd lx nc nd dn mb ne nf dp mf kr ng nh mh kv ni nj mj kz nk nl ml nm bi translated">静态— CSS</h2><p id="b2a5" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">层叠样式表(CSS)是一个设计网页样式的框架，这也是为什么我们有漂亮的网页，看起来不像是在1990年写的。我不会假装自己是CSS专家，但我知道的足够多，足以给出这个应用程序的CSS要求的概述。</p><p id="30a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这款应用的风格改编自<a class="ae le" href="https://demos.creative-tim.com/soft-ui-dashboard/pages/dashboard.html" rel="noopener ugc nofollow" target="_blank">创意蒂姆</a>提供的开源HTML、CSS和JavaScript模板；所有文件都可以在“static/css”目录下找到。为了说明样式是如何工作的，让我们看一下<em class="nu"> soft-ui-dashboard.css </em>中的“表单控制”类:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="1574" class="mx lw it mt b gy my mz l na nb">.form-control {</span><span id="332c" class="mx lw it mt b gy no mz l na nb">display: block;<br/>width: 100%;<br/>padding: 0.5rem 0.75rem;<br/>font-size: 0.875rem;<br/>font-weight: 400;<br/>line-height: 1.4rem;<br/>color: #495057;<br/>background-color: #fff;<br/>background-clip: padding-box;<br/>border: 1px solid #d2d6da;<br/>appearance: none;<br/>border-radius: 0.5rem;<br/>transition: box-shadow 0.15s ease, border-color 0.15s ease;</span><span id="8247" class="mx lw it mt b gy no mz l na nb">}</span></pre><p id="3318" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“form-control”类负责进行这种史前输入:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nv"><img src="../Images/3330375450dbbc5141e62bfa0cf45c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*8ZtbgbjGSU2cvjhi57S6yw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">史前的HTML输入。图片作者。</p></figure><p id="5a5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来像来自现代网络应用程序的输入:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b3433c2e434d4e8c524071db456dd568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*d5ifrn_efxkDek-SZ2gohA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">风格化输入。图片作者。</p></figure><p id="67b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们感觉很狂野，希望我们的输入有一个橙色的背景。只需在CSS文件中进行以下更改:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="9654" class="mx lw it mt b gy my mz l na nb">.form-control {</span><span id="5666" class="mx lw it mt b gy no mz l na nb">display: block;<br/>width: 100%;<br/>padding: 0.5rem 0.75rem;<br/>font-size: 0.875rem;<br/>font-weight: 400;<br/>line-height: 1.4rem;<br/>color: #495057;<br/><strong class="mt iu"><em class="nu">background-color: rgb(250, 186, 11); </em></strong>/* Change the background color */<br/>background-clip: padding-box;<br/>border: 1px solid #d2d6da;<br/>appearance: none;<br/>border-radius: 0.5rem;<br/>transition: box-shadow 0.15s ease, border-color 0.15s ease;</span><span id="20ce" class="mx lw it mt b gy no mz l na nb">}</span></pre><p id="e6fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了喷雾鞣制的投入:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5bc2d8ab928947604a65aedc68cc8ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*8BvFd1PlxPwSY00yvwL9DA.png"/></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">用橙色背景色输入。图片作者。</p></figure><p id="a060" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何浏览过该项目的repo的人都会注意到CSS文件相当广泛。对于任何有兴趣学习更多CSS知识的人来说，这里有大量的资源。</p><h2 id="0a41" class="mx lw it bd lx nc nd dn mb ne nf dp mf kr ng nh mh kv ni nj mj kz nk nl ml nm bi translated">静态— JavaScript</h2><p id="896a" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">JavaScript是世界上最流行的编程语言，负责管理网页上发生的所有操作。JavaScript在这个项目中的主要应用是充当前端(所有HTML、CSS和JavaScript代码)和后端(用Flask编写的服务器端代码)之间的桥梁。我们将使用<a class="ae le" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>，一个流行的经过时间考验的JavaScript库，向Flask发送请求。这些请求将包含心力衰竭模型进行预测所需的所有输入。该模型将使用请求输入进行预测，Flask将把预测(以及我们需要的任何其他数据)发送回jQuery。JQuery将解析预测，并将它们发送回index.html文件供用户查看。</p><p id="874a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在深入研究jQuery代码之前，我们必须在index.html文件中进行三次导入:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="0103" class="mx lw it mt b gy my mz l na nb">&lt;!-- Jquery CDN --&gt;<br/>&lt;script src="https://code.jquery.com/jquery-3.6.0.js" integrity="sha256-H+K7U5CnXl1h5ywQfKtSj8PCmoN9aaq30gDh27Xc0jk=" crossorigin="anonymous"&gt;&lt;/script&gt;</span><span id="e2ab" class="mx lw it mt b gy no mz l na nb">&lt;!-- JS file to get predictions from server --&gt;<br/>&lt;script src="../static/js/api.js"&gt;&lt;/script&gt;</span><span id="4b44" class="mx lw it mt b gy no mz l na nb">&lt;!-- Plotly CDN--&gt;<br/>&lt;script src="https://cdn.plot.ly/plotly-latest.min.js"&gt;&lt;/script&gt;</span></pre><p id="103a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一次导入允许我们通过jQuery内容交付网络(CDN)使用jQuery。这是一个包含jQuery库的公共JavaScript文件。接下来，我们导入将与Flask交互并返回预测的本地JavaScript文件。最后，导入<a class="ae le" href="https://plotly.com/javascript/" rel="noopener ugc nofollow" target="_blank"> plotly.js </a> CDN，这样我们就可以在页面上显示图形。</p><p id="5b45" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在是有趣的部分。所有的操作都使用了50行jQuery:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="91c2" class="mx lw it mt b gy my mz l na nb">$(document).ready(function(e) {</span><span id="20a3" class="mx lw it mt b gy no mz l na nb">   $('#makePred').click(function() {</span><span id="8d6c" class="mx lw it mt b gy no mz l na nb">      $('#hfProb').empty();<br/>      $('#hfPred').empty();<br/>      <br/>      var sex = $('#sex').val();</span><span id="52ed" class="mx lw it mt b gy no mz l na nb">      var restingECG = $('#restingECG').val();</span><span id="dd80" class="mx lw it mt b gy no mz l na nb">      var cpt = $('#chestPainType').val();</span><span id="7c41" class="mx lw it mt b gy no mz l na nb">      var exerciseAngina = $('#exerciseAngina').val();</span><span id="3ed4" class="mx lw it mt b gy no mz l na nb">      var sts = $('#stSlope').val();</span><span id="9a52" class="mx lw it mt b gy no mz l na nb">      var age = $('#age').val();</span><span id="96da" class="mx lw it mt b gy no mz l na nb">      var bp = $('#restingBP').val();</span><span id="352e" class="mx lw it mt b gy no mz l na nb">      var chol = $('#cholesterol').val();</span><span id="4348" class="mx lw it mt b gy no mz l na nb">      var bs = $('#fastingBS').val();</span><span id="92b7" class="mx lw it mt b gy no mz l na nb">      var maxHR = $('#maxHR').val();</span><span id="99b4" class="mx lw it mt b gy no mz l na nb">      var oldpeak = $('#oldpeak').val();<br/>      <br/>      var inputData = {</span><span id="90a5" class="mx lw it mt b gy no mz l na nb">      'sex': sex,</span><span id="2ca0" class="mx lw it mt b gy no mz l na nb">      'restingECG': restingECG,</span><span id="c00f" class="mx lw it mt b gy no mz l na nb">      'cpt': cpt,</span><span id="9b94" class="mx lw it mt b gy no mz l na nb">      'exerciseAngina': exerciseAngina,</span><span id="c50f" class="mx lw it mt b gy no mz l na nb">      'sts': sts,</span><span id="d5bc" class="mx lw it mt b gy no mz l na nb">      'age': age,</span><span id="6493" class="mx lw it mt b gy no mz l na nb">      'bp': bp,</span><span id="37b7" class="mx lw it mt b gy no mz l na nb">      'chol': chol,</span><span id="2a61" class="mx lw it mt b gy no mz l na nb">      'bs': bs,</span><span id="2ff1" class="mx lw it mt b gy no mz l na nb">      'maxHR': maxHR,</span><span id="301a" class="mx lw it mt b gy no mz l na nb">      'oldpeak': oldpeak };</span><span id="ed8b" class="mx lw it mt b gy no mz l na nb">   $.ajax({</span><span id="da4a" class="mx lw it mt b gy no mz l na nb">      url: 'main/api/make_prediction',</span><span id="1675" class="mx lw it mt b gy no mz l na nb">      data: inputData,</span><span id="1f93" class="mx lw it mt b gy no mz l na nb">      type: 'post',</span><span id="ac66" class="mx lw it mt b gy no mz l na nb">      success: function(response) {</span><span id="0857" class="mx lw it mt b gy no mz l na nb">      $('#hfProb').append(`&lt;p style="color:white;"&gt;Patient has a   ${response['pred']} probability of heart failure&lt;/p&gt;`)</span><span id="d0d5" class="mx lw it mt b gy no mz l na nb">      var figure = JSON.parse(response['plot']);</span><span id="2705" class="mx lw it mt b gy no mz l na nb">      Plotly.newPlot('hfPlot', figure.data, figure.layout, {</span><span id="f6d7" class="mx lw it mt b gy no mz l na nb">                      displayModeBar: false,</span><span id="bcee" class="mx lw it mt b gy no mz l na nb">                      responsive: true });  </span><span id="1d85" class="mx lw it mt b gy no mz l na nb">      }</span><span id="b97d" class="mx lw it mt b gy no mz l na nb">    })</span><span id="4d61" class="mx lw it mt b gy no mz l na nb">   });</span><span id="6880" class="mx lw it mt b gy no mz l na nb">});</span></pre><p id="b74d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们必须告诉jQuery在执行任何操作之前让整个网页呈现出来。我们使用下面的代码行来实现这一点:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="e64b" class="mx lw it mt b gy my mz l na nb">$(document).ready(function(e) {   });</span></pre><p id="c38d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们创建一个事件监听器来监视“运行模型”按钮。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="c343" class="mx lw it mt b gy my mz l na nb">$('#makePred').click(function() {</span><span id="fbc7" class="mx lw it mt b gy no mz l na nb">});</span></pre><p id="24ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回想一下“#makePred”是index.html“运行模型”按钮的id。每次单击“运行模型”时，这个事件监听器将执行花括号内的任何代码。在我们的例子中，我们希望将患者数据发送到服务器并获得预测结果。为此，我们必须首先访问输入的值。例如，下面的块将把病人的年龄和血压存储为JavaScript变量:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="fb04" class="mx lw it mt b gy my mz l na nb">var age = $('#age').val();<br/>var bp = $('#restingBP').val();</span></pre><p id="2164" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们重复这个过程，然后将所有变量存储在一个类似于字典的JavaScript对象中:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="0ef1" class="mx lw it mt b gy my mz l na nb">var inputData = {</span><span id="7378" class="mx lw it mt b gy no mz l na nb">'sex': sex,</span><span id="d732" class="mx lw it mt b gy no mz l na nb">'restingECG': restingECG,</span><span id="a954" class="mx lw it mt b gy no mz l na nb">'cpt': cpt,</span><span id="9f86" class="mx lw it mt b gy no mz l na nb">'exerciseAngina': exerciseAngina,</span><span id="5aa4" class="mx lw it mt b gy no mz l na nb">'sts': sts,</span><span id="8add" class="mx lw it mt b gy no mz l na nb">'age': age,</span><span id="1c81" class="mx lw it mt b gy no mz l na nb">'bp': bp,</span><span id="b038" class="mx lw it mt b gy no mz l na nb">'chol': chol,</span><span id="517e" class="mx lw it mt b gy no mz l na nb">'bs': bs,</span><span id="0d03" class="mx lw it mt b gy no mz l na nb">'maxHR': maxHR,</span><span id="9593" class="mx lw it mt b gy no mz l na nb">'oldpeak': oldpeak };</span></pre><p id="8d83" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“inputData”变量是将被转换为<a class="ae le" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a>并发送给服务器的对象。最后一步是通过AJAX请求将患者的数据发送到服务器。通俗地说，AJAX允许我们在不刷新网页的情况下与服务器进行交互。让我们分解我们的AJAX请求:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="64e4" class="mx lw it mt b gy my mz l na nb">$.ajax({</span><span id="9644" class="mx lw it mt b gy no mz l na nb">url: 'main/api/make_prediction',</span><span id="a588" class="mx lw it mt b gy no mz l na nb">data: inputData,</span><span id="c80d" class="mx lw it mt b gy no mz l na nb">type: 'post',</span><span id="7108" class="mx lw it mt b gy no mz l na nb">success: function(response) {</span><span id="f4db" class="mx lw it mt b gy no mz l na nb">$('#hfProb').append(`&lt;p style="color:white;"&gt;Patient has a   ${response['pred']} probability of heart failure&lt;/p&gt;`)</span><span id="c6ac" class="mx lw it mt b gy no mz l na nb">var figure = JSON.parse(response['plot']);</span><span id="f193" class="mx lw it mt b gy no mz l na nb">Plotly.newPlot('hfPlot', figure.data, figure.layout, {</span><span id="e846" class="mx lw it mt b gy no mz l na nb">displayModeBar: false,</span><span id="e37c" class="mx lw it mt b gy no mz l na nb">responsive: true });</span><span id="4527" class="mx lw it mt b gy no mz l na nb">}</span><span id="22af" class="mx lw it mt b gy no mz l na nb">})</span><span id="7c55" class="mx lw it mt b gy no mz l na nb">});</span></pre><p id="cfcb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AJAX主体中的“url”参数告诉jQuery我们试图访问的资源在服务器上的位置；我们将在下一节在Flask中对此进行定义。“数据”参数是包含患者信息/模型输入的对象。通过将“type”指定为“post”，我们告诉服务器我们正在向它发送数据以进行处理(患者数据)。“url”、“数据”和“类型”参数都是我们发出请求所需要的。</p><p id="814a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦服务器处理了请求并返回了结果，我们就可以告诉jQuery如何处理返回的数据。这是通过在AJAX主体中填充“success”参数来实现的:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="9e61" class="mx lw it mt b gy my mz l na nb">success: function(response) {</span><span id="b605" class="mx lw it mt b gy no mz l na nb">$('#hfProb').append(`&lt;p style="color:white;"&gt;Patient has a   ${response['pred']} probability of heart failure&lt;/p&gt;`)</span><span id="11f6" class="mx lw it mt b gy no mz l na nb">var figure = JSON.parse(response['plot']);</span><span id="48c5" class="mx lw it mt b gy no mz l na nb">Plotly.newPlot('hfPlot', figure.data, figure.layout, {</span><span id="bcf6" class="mx lw it mt b gy no mz l na nb">displayModeBar: false,</span><span id="b97c" class="mx lw it mt b gy no mz l na nb">responsive: true });</span><span id="9ab9" class="mx lw it mt b gy no mz l na nb">}</span></pre><p id="f4d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们正在传入一个函数，该函数接受一个变量“response”。该变量包含从服务器发回的数据，可能如下所示:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ny"><img src="../Images/8821a9d49da524c7a1d8a0ef8bc68cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94VW7KM-8aMLlD76g-5_fA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">来自服务器的响应对象。图片作者。</p></figure><p id="9f13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，响应对象有一个用于模型预测的条目和一个用于风险因素图的条目(这将在下一节中解释)。现在我们可以对数据做任何我们想做的事情！</p><p id="2a35" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在我们的网页上显示患者心力衰竭的概率，我们可以使用“附加”方法:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="fda7" class="mx lw it mt b gy my mz l na nb">$('#hfProb').append(`&lt;p style="color:white;"&gt;Patient has a   ${response['pred']} probability of heart failure&lt;/p&gt;`)</span></pre><p id="5637" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大概是这样的:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nz"><img src="../Images/2a5f82ed2113a9fcbac9755a15a4c16f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oGwW8ysoE1d0mcmQivnig.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片作者。</p></figure><p id="c235" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以使用plotly.js呈现风险系数图:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="c7ba" class="mx lw it mt b gy my mz l na nb">var figure = JSON.parse(response['plot']);</span><span id="2841" class="mx lw it mt b gy no mz l na nb">Plotly.newPlot('hfPlot', figure.data, figure.layout, {</span><span id="4509" class="mx lw it mt b gy no mz l na nb">displayModeBar: false,</span><span id="0823" class="mx lw it mt b gy no mz l na nb">responsive: true });</span></pre><p id="46b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oa"><img src="../Images/ba455e03e5a24f3c4b2bc1794f2b9999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzIOvSwQmQBz5duvc_CCxw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片作者。</p></figure><h1 id="038e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">后端</h1><h2 id="540c" class="mx lw it bd lx nc nd dn mb ne nf dp mf kr ng nh mh kv ni nj mj kz nk nl ml nm bi translated">瓶</h2><p id="204d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">Flask 是驱动这个应用后端功能的主力。在我们的上下文中，后端的主要目的是从前端接收患者数据，转换数据，通过心力衰竭模型运行数据，并将预测返回给前端。作为复习，让我们看一下Flask应用程序的目录结构:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="33a6" class="mx lw it mt b gy my mz l na nb">-/ flaskapp<br/>   -/ models<br/>     - heart_disease_model_2021-12-28<br/>   -/ services<br/>     - model_utils.py<br/>   -/ static<br/>     -/css<br/>     -/ fonts<br/>     -/ img<br/>     -/ js<br/>   -/ templates<br/>     - index.html<br/>   - api_routes.py<br/>   - app.py</span></pre><p id="562c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">经训练的心力衰竭模型存储在“模型”目录中；这不要与来自<a class="ae le" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC框架</a>的模型概念相混淆。“服务”目录包含允许我们模块化心力衰竭模型使用的代码。实际的烧瓶代码包含在“api_routes.py”和“app.py”中。</p><h2 id="86e9" class="mx lw it bd lx nc nd dn mb ne nf dp mf kr ng nh mh kv ni nj mj kz nk nl ml nm bi translated">让应用程序运行</h2><p id="e8fc" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我们先来看看“app.py”:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="09b5" class="mx lw it mt b gy my mz l na nb">from flask import Flask, render_template<br/>from api_routes import bp1</span><span id="8c4d" class="mx lw it mt b gy no mz l na nb">app = Flask(__name__)<br/>app.register_blueprint(bp1)</span><span id="8e90" class="mx lw it mt b gy no mz l na nb">@app.route('/')<br/>def index():<br/>  return render_template('index.html')</span><span id="4624" class="mx lw it mt b gy no mz l na nb">if __name__ == "__main__":<br/>  app.run(debug=True)</span></pre><p id="7ebc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，Flask抽象出了服务器端代码的许多复杂性。这意味着我们只需要几行代码就可以让我们的应用程序运行起来！我们从导入一些基本的依赖关系开始:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="f42e" class="mx lw it mt b gy my mz l na nb">from flask import Flask, render_template<br/>from api_routes import bp1</span></pre><p id="ed02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导入“flask”类是为了创建一个app实例，而“render_template”函数是Flask用来定位和显示HTML文件的。“bp1”导入是一个烧瓶<a class="ae le" href="https://flask.palletsprojects.com/en/2.0.x/blueprints/" rel="noopener ugc nofollow" target="_blank">蓝图</a>。诚然，蓝图可能有点难以把握。然而，对于这个应用程序，蓝图是一种隔离和模块化API代码的方法。当更多的页面和功能被添加到一个应用程序时，这就很方便了。接下来的两行代码创建Flask应用程序并注册API蓝图:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="cc8b" class="mx lw it mt b gy my mz l na nb">app = Flask(__name__)<br/>app.register_blueprint(bp1)</span></pre><p id="e088" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们定义一个名为“index”的函数，该函数将“index.html”文件呈现到主目录(“/”)中。这意味着“index.html”是我们在访问基本url时看到的页面。</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="1caa" class="mx lw it mt b gy my mz l na nb">@app.route('/')<br/>def index():<br/>  return render_template('index.html')</span></pre><p id="f940" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“app.py”的最后一步是运行应用程序:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="871c" class="mx lw it mt b gy my mz l na nb">if __name__ == "__main__":<br/>  app.run(debug=True)</span></pre><p id="0578" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们让应用程序运行所需的一切！只需在终端中运行“python app.py ”,应该会出现类似如下的内容:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ob"><img src="../Images/5abef9d77dcae1ca0e883b9ce9d144dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oup2y0KyRhGP8Fe84Afeug.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">运行终端的Flask应用程序。图片作者。</p></figure><p id="e5db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，当我们点击“http://127.0.0.1:5000/”时，我们可以看到我们的应用程序正在运行:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oc"><img src="../Images/4617576e5ce9c8554fd784a9e3293f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAT1RmjtHrePaKna58BgNQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">Flask呈现的网页。图片作者。</p></figure><h2 id="d976" class="mx lw it bd lx nc nd dn mb ne nf dp mf kr ng nh mh kv ni nj mj kz nk nl ml nm bi translated">与前端交互</h2><p id="4b7b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这是橡胶与路面真正相遇的地方。最后两个文件决定了数据如何流经后端并返回前端。从“model_utils.py”开始，我们导入依赖项并将心力衰竭模型加载到Catboost对象中:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="d2bf" class="mx lw it mt b gy my mz l na nb">import numpy as np<br/>import pandas as pd<br/>from catboost import CatBoostClassifier, Pool<br/>import plotly.graph_objects as go</span><span id="6a66" class="mx lw it mt b gy no mz l na nb"># Global variable that stores trained model instance<br/>MODEL = CatBoostClassifier().load_model('models/heart_disease_model_2021-12-28')</span></pre><p id="aaa0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们创建一个字典，将前端特征名称转换为模型能够理解的特征名称:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="872f" class="mx lw it mt b gy my mz l na nb"># Dictionary that converts frontend feature names to names understood by model</span><span id="5a01" class="mx lw it mt b gy no mz l na nb">display_to_model = {'age':'Age', 'sex':'Sex', 'cpt':'ChestPainType', 'bp':'RestingBP','chol':'Cholesterol', 'bs':'FastingBS', 'restingECG':'RestingECG','maxHR':'MaxHR', 'exerciseAngina':'ExerciseAngina', 'oldpeak':'Oldpeak','sts':'ST_Slope'}</span></pre><p id="6b19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，在大多数生产软件中，字符串映射是用<a class="ae le" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">枚举</a>处理的；对我们来说，字典映射完成了工作。在此之后，我们定义一个接受患者数据、重命名特征并返回模型的心力衰竭概率预测的函数:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="2a4f" class="mx lw it mt b gy my mz l na nb">def predict_hf(data:pd.DataFrame):</span><span id="e936" class="mx lw it mt b gy no mz l na nb">   # Make sure column names are correct<br/>   data_predict = data.rename(display_to_model, axis=1)</span><span id="0f6c" class="mx lw it mt b gy no mz l na nb">   # Make sure columns are in the correct order<br/>   data_predict = data_predict[MODEL.feature_names_]</span><span id="7a87" class="mx lw it mt b gy no mz l na nb">   return MODEL.predict_proba(data_predict)</span></pre><p id="def2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来的两个函数用于根据SHAP值生成风险因素图:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="4c1b" class="mx lw it mt b gy my mz l na nb">def get_shap_df(data:pd.DataFrame):</span><span id="a477" class="mx lw it mt b gy no mz l na nb">   # Make sure column names are correct<br/>   data_predict = data.rename(display_to_model, axis=1)</span><span id="b903" class="mx lw it mt b gy no mz l na nb">   # Make sure columns are in the correct order<br/>   data_predict = data_predict[MODEL.feature_names_]</span><span id="ca43" class="mx lw it mt b gy no mz l na nb">   data_pool = Pool(data_predict,  cat_features=MODEL.get_cat_feature_indices())</span><span id="ca20" class="mx lw it mt b gy no mz l na nb">   shap_values = MODEL.get_feature_importance(data_pool,  type='ShapValues')</span><span id="d2c1" class="mx lw it mt b gy no mz l na nb">   shap_values = shap_values[:,:-1].reshape(shap_values.shape[0], len(MODEL.feature_names_))</span><span id="f960" class="mx lw it mt b gy no mz l na nb">   shap_df = pd.DataFrame(shap_values, columns=MODEL.feature_names_).T</span><span id="3b4e" class="mx lw it mt b gy no mz l na nb">   shap_df.columns = ['feature']</span><span id="d9f7" class="mx lw it mt b gy no mz l na nb">   shap_df['AbsVal'] = np.abs(shap_df['feature'])</span><span id="0c48" class="mx lw it mt b gy no mz l na nb">   shap_df.sort_values('AbsVal', ascending=False, inplace=True)</span><span id="eea2" class="mx lw it mt b gy no mz l na nb">   return shap_df</span><span id="fe90" class="mx lw it mt b gy no mz l na nb">def plot_shap_values(data:pd.DataFrame):</span><span id="37d6" class="mx lw it mt b gy no mz l na nb">   shap_df = get_shap_df(data)</span><span id="4f6d" class="mx lw it mt b gy no mz l na nb">   fig = go.Figure()<br/>   fig.add_trace(go.Bar(x=shap_df.index, y=shap_df.feature))<br/>   fig.update_layout(title='Patient Risk Factors')</span><span id="edf6" class="mx lw it mt b gy no mz l na nb">   return fig.to_json()</span></pre><p id="3723" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们转到“api_routes.py”文件:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="e7ea" class="mx lw it mt b gy my mz l na nb">import pandas as pd<br/>from flask import Blueprint, request<br/>from services.model_utils import predict_hf, plot_shap_values</span><span id="6c62" class="mx lw it mt b gy no mz l na nb">bp1 = Blueprint('main', __name__, url_prefix='/main')</span><span id="4595" class="mx lw it mt b gy no mz l na nb">@bp1.route('/api/make_prediction', methods=['POST'])<br/>def make_prediction():</span><span id="fa98" class="mx lw it mt b gy no mz l na nb">   # Read in the patient data from the frontend and convert to df<br/>   form_df:pd.DataFrame = pd.DataFrame(request.form, index=[0])</span><span id="66c4" class="mx lw it mt b gy no mz l na nb">   # Make heart failure prediction  <br/>   pred = predict_hf(form_df)<br/>   pred_class_1 = pred[0][1]</span><span id="83cf" class="mx lw it mt b gy no mz l na nb">   # Get risk factor plot<br/>   plot = plot_shap_values(form_df)<br/>   <br/>   # Return prediction and plot back to frontend <br/>   return {'pred':round(pred_class_1, 2), 'plot':plot}</span></pre><p id="4b9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该文件导入依赖项，包括我们编写的用于进行预测和风险因素绘图的函数:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="382a" class="mx lw it mt b gy my mz l na nb">import pandas as pd<br/>from flask import Blueprint, request<br/>from services.model_utils import predict_hf, plot_shap_values</span></pre><p id="c026" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们创建前面讨论过的蓝图:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="e33f" class="mx lw it mt b gy my mz l na nb">bp1 = Blueprint('main', __name__, url_prefix='/main')</span></pre><p id="06d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们创建一个对应于“API/make _ prediction”URL的Flask API路由:</p><pre class="lg lh li lj gt ms mt mu mv aw mw bi"><span id="4a10" class="mx lw it mt b gy my mz l na nb">@bp1.route('/api/make_prediction', methods=['POST'])<br/>def make_prediction():</span><span id="af4b" class="mx lw it mt b gy no mz l na nb">   # Read in the patient data from the frontend and convert to df<br/>   form_df:pd.DataFrame = pd.DataFrame(request.form, index=[0])</span><span id="4b8d" class="mx lw it mt b gy no mz l na nb">   # Make heart failure prediction  <br/>   pred = predict_hf(form_df)<br/>   pred_class_1 = pred[0][1]</span><span id="9f43" class="mx lw it mt b gy no mz l na nb">   # Get risk factor plot<br/>   plot = plot_shap_values(form_df)<br/>   <br/>   # Return prediction and plot back to frontend <br/>   return {'pred':round(pred_class_1, 2), 'plot':plot}</span></pre><p id="dc80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“request.form”对象包含从前端传递的所有患者信息。这个对象被转换成一个数据帧，并通过预测和绘图功能。预测和情节作为字典传递回前端(Flask将其转换为JSON)。</p><h1 id="c826" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="2b47" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">本文涵盖了心力衰竭应用程序的所有组件。我们展示了数据如何从前端流向后端，以及机器学习模型如何嵌入到web应用程序中。我希望这篇文章给读者一个机器学习模型部署的高层次概述，我完全意识到这还远远不够全面。感谢您的阅读！<a class="ae le" href="https://hf-predictor.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://hf-predictor.herokuapp.com/</a>。</p></div></div>    
</body>
</html>