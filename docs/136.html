<html>
<head>
<title>LeetCode Two Sum With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用围棋对两个和进行编码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/leetcode-two-sum-with-go-67d24e5a53f3#2022-01-05">https://towardsdatascience.com/leetcode-two-sum-with-go-67d24e5a53f3#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="febd" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用围棋对两个和进行编码</h1></div><div class=""><h2 id="8241" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python用户Golang入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/699737a63b6bdbd87a649da177667020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UPSo4zLYQhViHLPo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡拉·埃尔南德斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8dc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢用LeetCode来入门新语言。这是在复习数据结构和算法的同时熟悉新语法的简单方法。我主要是一个Python用户，我想强调一些您需要理解的新概念，以帮助您将Python知识转化为Go。</p><p id="0af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程不会详细介绍go中的每个特性或数据结构，因为它旨在为您提供解决LeetCode Two Sum问题的基本工具。</p><h2 id="c1e7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题是</h2><p id="b54a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">给定一个整数数组和一个目标，返回两个元素的索引，两者之和等于目标。每个数字只能使用一次，返回的索引顺序无关紧要。你可以假设只有一个解决方案。</p><p id="6368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0377" class="lv lw it mu b gy my mz l na nb">arr: [1,2,3,4,5]<br/>target: 3<br/>answer: [0,1] or [1,0]</span></pre><p id="13d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是LeetCode上问题的链接:</p><div class="nc nd gp gr ne nf"><a href="https://leetcode.com/problems/two-sum" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">两个总和代码</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">给定一个整数num数组和一个整数target，返回这两个数字的索引，使它们加起来等于…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">leetcode.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><h2 id="4d3d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">该算法</h2><p id="f854" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这个问题的最佳解决方案是使用哈希表将数组的每个元素映射到它的索引。对于数组中的每个元素，您将从目标中减去它以获得补数。然后您将检查补码是否是哈希表中的一个键。如果它在哈希表中，您可以将解作为包含当前索引和补码索引的数组返回。否则，向哈希表添加一个新元素，其中键是当前数字，值是它的索引。循环继续，直到找到解决方案。</p><p id="2a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一个Python解决方案:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="e91b" class="nx lw it mu b be ny nz l oa nb">class Solution:<br/>    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br/>        complements = {}<br/>        for idx, num in enumerate(nums):<br/>            complement = target - num<br/>            if complement in complements:<br/>                return [complements.get(complement), idx]<br/>            complements.update({num: idx})  </span></pre><h2 id="9d0f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">开始熟悉围棋</h2><p id="7c9c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使用Python算法作为模板，这里有一个快速检查表，列出了在Go中求解两个和需要学习的主要概念:</p><ol class=""><li id="867b" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">变量</li><li id="c3d6" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">部分</li><li id="35c1" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">条件式</li><li id="147b" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">地图</li><li id="4f12" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">环</li><li id="d49a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">功能</li></ol><h2 id="57ef" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">变量</h2><p id="34ad" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Go是一种静态类型的语言，在处理变量的时候是有区别的。</p><p id="e6fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">声明和初始化:</strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="e1a1" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    var a int<br/>    fmt.Println(a)<br/>}</span></pre><p id="b3b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，第6行声明了一个整数变量<code class="fe op oq or mu b">a</code>。由于代码没有显式初始化<code class="fe op oq or mu b">a</code>，它被初始化为<code class="fe op oq or mu b">0</code>。如果要在声明时初始化变量，可以这样做:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="1b7a" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    var a int = 12<br/>    fmt.Println(a)<br/>}</span></pre><p id="bea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go也可以暗示变量类型:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="8978" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import (<br/>    "fmt"<br/>    "reflect"<br/>)<br/><br/>func main() {<br/>    var a = 12<br/>    fmt.Println(reflect.TypeOf(a))<br/>}</span></pre><p id="dac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段打印了<code class="fe op oq or mu b">int</code>，即使在声明中没有明确定义<code class="fe op oq or mu b">a</code>的类型。</p><p id="4d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简短的赋值语句</strong></p><p id="3946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go还有一个简短的赋值语句，去掉了<code class="fe op oq or mu b">var</code>关键字，并隐含了type。这里有一个例子:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="cdd5" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    a := 12<br/>    fmt.Println(a)<br/>}</span></pre><p id="828b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的例子不同，短赋值语句只能在函数内部使用。</p><h2 id="dd21" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">部分</h2><p id="384e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一个<code class="fe op oq or mu b">slice</code>是一个<code class="fe op oq or mu b">array</code>的特定元素的视图。与数组不同，它们是动态调整大小的。在Go中，你可能会在Python中使用<code class="fe op oq or mu b">list</code>的地方使用<code class="fe op oq or mu b">slice</code>。</p><p id="79b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个快速入门<code class="fe op oq or mu b">slices</code>的例子:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="c07d" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    a := 12<br/>    fmt.Println(a)<br/>}</span></pre><p id="7dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第6行显示了如何声明一个<code class="fe op oq or mu b">slice</code>。第7行向<code class="fe op oq or mu b">slice</code>追加一个整数，该整数在第9行打印出来。这类似于下面的Python片段:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c5fc" class="lv lw it mu b gy my mz l na nb">a = []<br/>a.append(1)<br/>print(a)</span></pre><p id="9846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第10行展示了如何用一个<code class="fe op oq or mu b">slice</code>文本初始化一个变量。第12行显示了如何在特定索引处更改<code class="fe op oq or mu b">slice</code>中的值，这与您在Python <code class="fe op oq or mu b">list</code>中使用的语法相同。虽然本教程不涉及<code class="fe op oq or mu b">array</code>数据结构，但是您应该知道，更改<code class="fe op oq or mu b">slice</code>的值将会修改底层的<code class="fe op oq or mu b">array</code>。</p><h2 id="5163" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">条件式</h2><p id="53e5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Python用户应该对Go中的条件语句非常熟悉。Go使用花括号而不是空格来分隔块，并且去掉了冒号。</p><p id="6274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Python: </strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="1ae6" class="nx lw it mu b be ny nz l oa nb">def main():<br/>    a = 12<br/><br/>    if a &gt; 20:<br/>        print('a is greater than 20')<br/>    else:<br/>        print('a is not greater than 20')</span></pre><p id="4409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">去:</strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="2cdb" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    a := 12<br/><br/>    if a &gt; 20 {<br/>        fmt.Println("a is greater than 20")<br/>    } else {<br/>        fmt.Println("a is not greater than 20")<br/>    }<br/>}</span></pre><p id="9c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go还允许缩短条件语句:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="dbaf" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    a := 12<br/><br/>    if b := a + 2; b &gt; 20 {<br/>        fmt.Println("a + 2 is greater than 20")<br/>    } else {<br/> fmt.Println("a + 2 is not greater than 20")<br/>    }<br/>}</span></pre><p id="b478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，<code class="fe op oq or mu b">a + 2</code>在<code class="fe op oq or mu b">if</code>语句中被赋值给<code class="fe op oq or mu b">b</code>。您可以通过下面的代码片段在Python中实现类似的功能:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="85c6" class="nx lw it mu b be ny nz l oa nb">def main():<br/>    a = 12<br/>    <br/>    if (b := a + 2) &gt; 20:<br/>        print('a + 2 is greater than 20')<br/>    else:<br/>        print('a + 2 is not greater than 20')</span></pre><p id="dc7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go和Python代码片段之间的主要区别在于作用域，下面的代码片段可以更好地解释这一点:</p><p id="1ecd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Python: </strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="7f73" class="nx lw it mu b be ny nz l oa nb">def main():<br/>    a = 12<br/>    b = 'hello'<br/>    <br/>    if (b := a + 2) &gt; 20:<br/>        print('a + 2 is greater than 20')<br/>        print(f'b = {b}')<br/>    else:<br/>        print('a + 2 is not greater than 20')<br/>        print(f'b = {b}')<br/><br/>    print(f'b = {b}')</span></pre><p id="0f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python函数打印以下内容:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="64dc" class="lv lw it mu b gy my mz l na nb">a + 2 is not greater than 20<br/>b = 14<br/>b = 14</span></pre><p id="dbe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe op oq or mu b">b</code>在第3行被初始化为“hello ”,然后在第5行的条件中被覆盖。也就是说，条件语句在函数范围内修改<code class="fe op oq or mu b">b</code>，因此<code class="fe op oq or mu b">b</code>在第12行打印为14而不是“hello”。</p><p id="918a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">去:</strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="294e" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import (<br/>    "fmt"<br/>    "io"<br/>    "os"<br/>)<br/><br/>func main() {<br/>    a := 12<br/>    b := "hello"<br/><br/>    if b := a + 2; b &gt; 20 {<br/>      fmt.Println("a + 2 is greater than 20")<br/>      out := fmt.Sprintf("b = %d \n", b)<br/>      io.WriteString(os.Stdout, out)<br/>    } else {<br/>      fmt.Println("a + 2 is not greater than 20")<br/>      out := fmt.Sprintf("b = %d \n", b)<br/>      io.WriteString(os.Stdout, out)<br/>    }<br/><br/>    out := fmt.Sprintf("b = %s", b)<br/>    io.WriteString(os.Stdout, out)<br/>}</span></pre><p id="c6fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go函数返回以下内容:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c336" class="lv lw it mu b gy my mz l na nb">a + 2 is not greater than 20<br/>b = 14 <br/>b = hello</span></pre><p id="ea14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Go中，条件语句中初始化的变量是条件块的局部变量。在上面的代码中，变量<code class="fe op oq or mu b">b</code>在条件结束后超出范围，因此对<code class="fe op oq or mu b">b</code>的第二次调用在外部范围中访问它的值。</p><h2 id="e870" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">地图</h2><p id="99e1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在Go中，你可以在Python中使用<code class="fe op oq or mu b">dict</code>的地方使用<code class="fe op oq or mu b">map</code>。要实现上述算法，您需要能够执行以下操作:</p><ol class=""><li id="cf3c" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">声明/初始化一个<code class="fe op oq or mu b">map</code></li><li id="a58f" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">添加键值对</li><li id="59ec" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">检查特定的键是否存在</li></ol><p id="a5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个入门示例:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="b333" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>var m map[string]int<br/><br/>func main() {<br/>    m = make(map[string]int)<br/>    m["a"] = 2<br/>    fmt.Println(m)<br/>}</span></pre><p id="709a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第3行声明了一个变量<code class="fe op oq or mu b">m</code>，它是一个<code class="fe op oq or mu b">nil</code> <code class="fe op oq or mu b">map</code>，其中键的类型是<code class="fe op oq or mu b">string</code>，值的类型是<code class="fe op oq or mu b">int</code>。此时，<code class="fe op oq or mu b">map</code>没有键值数据，不能添加任何东西。</p><p id="7214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第6行中，调用了<code class="fe op oq or mu b">make</code>函数，该函数初始化一个<code class="fe op oq or mu b">map</code>并将它分配给<code class="fe op oq or mu b">m</code>。第7行向<code class="fe op oq or mu b">m</code>添加了一个新元素，其中键是“a”，值是2，这也是更新a <code class="fe op oq or mu b">dict</code>的有效Python语法。</p><p id="d88a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是练习短变量赋值的好地方，如下所示:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="a3bf" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    m := make(map[string]int)<br/>    m["a"] = 2<br/>    fmt.Println(m)<br/>}This example deletes the variable declaration step, by using the := operator. This helps to make the code less verbose.</span></pre><p id="575c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现两个和算法，您需要检查给定的补码是否出现在<code class="fe op oq or mu b">map</code>中。下面是一个在围棋中如何做到这一点的例子:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="ce97" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    m := map[string]int{"a": 1, "b": 2, "c": 3}<br/>    if val, ok := m["a"]; ok {<br/>        fmt.Println(val)<br/>    } else {<br/>        fmt.Println("not in m")<br/>    }<br/>}</span></pre><p id="f0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段创建了一个<code class="fe op oq or mu b">map</code>文本，并检查<code class="fe op oq or mu b">a</code>是否是<code class="fe op oq or mu b">map</code>中的一个键。如果键在<code class="fe op oq or mu b">map</code>中，<code class="fe op oq or mu b">val</code>将被设置为该值，<code class="fe op oq or mu b">ok</code>将被设置为<code class="fe op oq or mu b">true</code>。</p><h2 id="0e2e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">环</h2><p id="b1a4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Go中的For循环接近C风格的for循环:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="49b4" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    for i := 0; i &lt; 10; i++ {<br/>        fmt.Println(i)<br/>    }<br/>}</span></pre><p id="aae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要遍历一个数组并访问索引和值，您可以在Python中尝试这样做:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="c6d3" class="nx lw it mu b be ny nz l oa nb">def main():<br/>    nums = [10, 22, 33, 44, 52]<br/>  <br/>    for i, v in enumerate(nums):<br/>        print(i)<br/>        print(v)</span></pre><p id="6e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是您在Go中的操作方法:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="8f37" class="nx lw it mu b be ny nz l oa nb">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>    nums := []int{10, 22, 33, 44, 52}<br/>    for i, v := range nums {<br/>        fmt.Println(i)<br/>        fmt.Println(v)<br/>    }<br/>}</span></pre><p id="33b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你在Go中使用带有<code class="fe op oq or mu b">range</code>的for循环时，它完成的事情类似于在Python中使用<code class="fe op oq or mu b">enumerate</code>。迭代变量为<code class="fe op oq or mu b">i</code>和<code class="fe op oq or mu b">v</code>，其中<code class="fe op oq or mu b">i</code>为索引，<code class="fe op oq or mu b">v</code>为<code class="fe op oq or mu b">nums</code>在索引<code class="fe op oq or mu b">i</code>处的值。</p><p id="95dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Go中的条件一样，for循环中初始化的变量是循环块的局部变量。因此，如果你试图在Go循环后打印<code class="fe op oq or mu b">i</code>或<code class="fe op oq or mu b">v</code>，你会得到一个错误。在Python中，在循环中初始化的变量仍然存在于外部作用域中。</p><h2 id="2c19" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能</h2><p id="6d9a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你习惯用Python中的类型提示来定义函数，那么Go中的函数会感觉非常相似。下面的片段大概是LeetCode为你提供的开始使用Two Sum的内容。这两个函数都有两个参数，<code class="fe op oq or mu b">nums</code>和<code class="fe op oq or mu b">target</code>，它们返回一个整数数组。</p><p id="4490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Python: </strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="d51e" class="nx lw it mu b be ny nz l oa nb">def twoSum(nums: List[int], target: int) -&gt; List[int]:</span></pre><p id="4616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不习惯在Python中使用类型提示，它们只是定义了参数和返回值应该是什么样子。在上面的函数定义中，<code class="fe op oq or mu b">nums</code>应该是一个<code class="fe op oq or mu b">list</code>，其中每个元素都是一个<code class="fe op oq or mu b">int</code>，而<code class="fe op oq or mu b">target</code>是一个<code class="fe op oq or mu b">int</code>。返回值被指定为<code class="fe op oq or mu b">-&gt;</code>右边的部分，是一个<code class="fe op oq or mu b">List</code>，其中每个元素都是一个<code class="fe op oq or mu b">int</code>。</p><p id="9df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">去:</strong></p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="f03e" class="nx lw it mu b be ny nz l oa nb">func twoSum(nums []int, target int) []int {<br/>    <br/>}</span></pre><p id="53b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go功能的设置方式相同。<code class="fe op oq or mu b">nums</code>参数和返回值都是包含<code class="fe op oq or mu b">int</code>类型元素的<code class="fe op oq or mu b">slice</code>，这就是<code class="fe op oq or mu b">[]int</code>的含义。</p><p id="784b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Python不同，为参数和返回值指定类型不是可选的。同样与Python不同的是，如果用户传递参数或生成不符合函数定义的返回值，将会出现错误。</p><h2 id="7055" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">把它们放在一起解两个和</h2><p id="eece" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下面是Go中两个和算法的实现:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="d1e4" class="nx lw it mu b be ny nz l oa nb">func twoSum(nums []int, target int) []int {<br/>    m := make(map[int]int)<br/>    var ans []int<br/>    <br/>    for idx, num := range nums {<br/>        complement := target - num<br/>        <br/>        if c, ok := m[complement]; ok {<br/>            ans = []int{c, idx}<br/>            break<br/>        }<br/>        m[num] = idx<br/>    }<br/>    return ans     <br/>}</span></pre><p id="653f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第2行用类型<code class="fe op oq or mu b">int</code>的键和值初始化<code class="fe op oq or mu b">map</code>。第3行声明了<code class="fe op oq or mu b">ans</code>，它是一个<code class="fe op oq or mu b">int</code>类型的<code class="fe op oq or mu b">slice</code>。</p><p id="dd0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环从第5行开始，使用<code class="fe op oq or mu b">range</code>以便索引和值都可用。循环的第一步计算<code class="fe op oq or mu b">complement</code>，然后检查它是否是<code class="fe op oq or mu b">m</code>中的一个键。如果<code class="fe op oq or mu b">ok</code>为真，<code class="fe op oq or mu b">ans</code>被设置为等于包含<code class="fe op oq or mu b">nums</code>和<code class="fe op oq or mu b">idx</code>中的<code class="fe op oq or mu b">complement</code>的索引的<code class="fe op oq or mu b">slice</code>文字。然后循环中断，函数返回<code class="fe op oq or mu b">ans</code>。如果<code class="fe op oq or mu b">ok</code>为假，则向<code class="fe op oq or mu b">m</code>添加新元素，其中键为<code class="fe op oq or mu b">num</code>，值为<code class="fe op oq or mu b">idx</code>。</p><p id="89d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe op oq or mu b">ans</code>的值是在条件语句中确定的，并且需要被返回，所以<code class="fe op oq or mu b">ans</code>在函数范围中被声明。如果您想避免这种情况，可以尝试以下实现方式:</p><pre class="kj kk kl km gt mt mu nu bn nv nw bi"><span id="4c05" class="nx lw it mu b be ny nz l oa nb">func twoSum(nums []int, target int) []int {<br/>    m := make(map[int]int)<br/>    <br/>    for idx, num := range nums {<br/>        complement := target - num<br/>        <br/>        if c, ok := m[complement]; ok {<br/>            return []int{c, idx}<br/>        }<br/>        m[num] = idx<br/>    }<br/>    return []int{}    <br/>}</span></pre><p id="c2ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用把要返回的值保存在变量中，可以直接返回<code class="fe op oq or mu b">slice</code>。为了使用LeetCode提供的结构来实现这一点，您需要在底部返回一个空的<code class="fe op oq or mu b">slice</code>。第12行只在无解的情况下执行，这超出了这个问题的范围。</p><h2 id="495f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">一般提示</h2><ol class=""><li id="a607" class="ob oc it lb b lc mo lf mp li os lm ot lq ou lu og oh oi oj bi translated">在Python中我经常用单引号表示<code class="fe op oq or mu b">str</code>值，但是Go需要双引号。</li><li id="973a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">Go对空值使用<code class="fe op oq or mu b">nil</code>，这类似于Python中的<code class="fe op oq or mu b">None</code>。</li><li id="210a" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">Go有一个很棒的基于网络的IDE，你可以在这里找到:<a class="ae ky" href="https://go.dev/play/" rel="noopener ugc nofollow" target="_blank">https://go.dev/play/</a></li><li id="1acc" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">这可能是最好的入门教程:<a class="ae ky" href="https://go.dev/tour/list" rel="noopener ugc nofollow" target="_blank">https://go.dev/tour/list</a></li></ol><h2 id="81dd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="acf2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">你刚刚学习了如何用围棋解两个和。如果您是一名使用Python的用户，那么您应该已经注意到了这两种语言之间的一些关键差异。这只是皮毛，但我希望它对你有所帮助。</p></div></div>    
</body>
</html>