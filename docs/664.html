<html>
<head>
<title>K-Means Clustering: Explain It To Me Like I’m 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k-均值聚类:把它解释给我听，就像我10岁一样</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/k-means-clustering-explain-it-to-me-like-im-10-e0badf10734a#2022-01-24">https://towardsdatascience.com/k-means-clustering-explain-it-to-me-like-im-10-e0badf10734a#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="8fb4" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">k-均值聚类:把它解释给我听，就像我10岁一样</h1></div><div class=""><h2 id="2209" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个长期流行的聚类算法的友好介绍</h2></div><p id="fbc1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将是<strong class="kk iu">向一个10岁的</strong>系列解释机器学习算法的第二个<em class="le">系列</em>(只是因为这一系列听起来比文章更有趣)。你可以在这里  找到XGBoost分类文章<a class="ae lf" rel="noopener" target="_blank" href="/xgboost-regression-explain-it-to-me-like-im-10-2cf324b0bbdb"> <strong class="kk iu"> <em class="le">。今天我将向一个10岁的孩子或者基本上是ML算法世界的任何新手解释K-Means聚类，一个非常流行的聚类算法。我将试图消除血淋淋的，数学细节，并解释背后的简单直觉。</em></strong></a></p><p id="4009" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始学习算法之前，我们先了解一下什么是聚类。聚类包括自动发现数据中的自然分组。通常，当我们得到可以可视化的数据时(二维甚至三维数据)，人眼可以很容易地形成不同的集群。但是机器要做到这一点就有点难了。这就是聚类算法发挥作用的地方。这也可以推广到更高的维度来聚集数据，这甚至是人眼无法做到的。现在我们已经解决了这个问题，k代表我们开始了！</p><p id="2a90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有19个数据点，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/14a296ca2a062b4b09fdb10c66240d94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8dnhu9agXtgbFc_0m1jdw.png"/></div></div></figure><p id="d575" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在假设我们知道这些数据属于3个相对明显的类别，如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ls"><img src="../Images/b55af4c67488ff2431d0f495170be70a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkGSZ68gSEhvGNtXweca_w.png"/></div></div></figure><p id="da82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的任务是使用k-means聚类算法来进行分类。</p><h1 id="02b0" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">步骤1:选择聚类数k</h1><p id="836a" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><em class="le">我们要识别的聚类数就是k-means聚类中的k</em>。在这种情况下，由于我们假设有3个集群，k = 3。</p><h1 id="368f" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">第二步:随机选择k个点</h1><p id="e3d2" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们通过选择3个随机点(不一定是我们的数据点)开始寻找聚类的过程。这些点现在将作为<em class="le">质心、</em>或中心，我们将制作:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mq"><img src="../Images/862adf4699c81ec26b424324ac54bd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yE8zcudjdOQVUVu0mF4oA.png"/></div></div></figure><h1 id="82c6" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">步骤3:创建k个集群</h1><p id="91ff" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">为了形成聚类，我们从测量每个数据点到3个质心的距离开始。我们把这些点分配给离它最近的聚类。因此，对于一个样本点，距离如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mr"><img src="../Images/b907c8344a16d90ce622a62ea1d821c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Pj0dohiarRWoBMkqXNKjQ.png"/></div></div></figure><p id="16de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只看它，我们看到从该点到绿色质心的距离是最小的，所以我们将该点分配给绿色簇。</p><p id="28e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在二维空间中，计算两点间距离的公式是:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/edf81376edff7c2bfe3dbd7f90431ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*kJWPzjij69PU9IQXcq_GHQ.png"/></div></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mt"><img src="../Images/c732db2b88b752a7d65528fa1796cecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GH0eeH8JizrdNbZc1gF4rg.png"/></div></div></figure><p id="a4ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用上面的公式，我们对其余的点重复这个过程，聚类将看起来像这样:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mu"><img src="../Images/d5f772c8be37946c42441c74099c1c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6DDNl6pdQSXamKNylhY2A.png"/></div></div></figure><h1 id="c89b" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">步骤4:计算每个聚类的新质心</h1><p id="b709" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">现在我们有了3个簇，我们找到了它们各自形成的新的质心。例如，我们计算蓝色星团质心坐标的方法是:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mv"><img src="../Images/efcf52b37289d0b410db8a36da10cff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcrNokoIxW3Z5LNB2tpkXw.png"/></div></div></figure><p id="b6a9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中x1、x2和x3是蓝色簇中3个点的x坐标。y1、y2和y3是蓝色群集的3个点中的每一个的y坐标。我们将坐标之和除以3，因为蓝色集群中有3个数据点。类似地，粉色和绿色星团的质心坐标为:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mw"><img src="../Images/f5d1179e521457167ea413d72fa2a23b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OuiLoZOWCTlP5sxGe23yLQ.png"/></div></div></figure><p id="25ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的质心看起来像这样:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mx"><img src="../Images/5550cefe3b180540fa914839999d3694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4xqOb_WWEXk58JlvwmDqcA.png"/></div></div></figure><h1 id="19fa" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">步骤5:评估每个集群的质量</h1><p id="c142" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">因为k-means不能像我们一样看到聚类，所以它通过找到所有聚类中的变化来测量质量。k-means聚类背后的基本思想是定义聚类，以便最小化聚类内的变化。我们通过计算所谓的<strong class="kk iu"/>(WCSS)来量化这个方差:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi my"><img src="../Images/75a733360c502630bf1dcde004aff83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*biO17tpwcVM8_5fVa04TcA.png"/></div></figure><blockquote class="mz na nb"><p id="10a6" class="ki kj le kk b kl km ju kn ko kp jx kq nc ks kt ku nd kw kx ky ne la lb lc ld im bi translated"><em class="it">这是一个看起来很吓人的公式，所以如果你没有真正理解它，没关系；试着去理解背后的直觉就好。</em></p></blockquote><p id="8382" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于简化的目的，让我们像这样直观地表示变化:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nf"><img src="../Images/f2e277c9edd2e8b135e15dafbb255785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7N7EnD8TZrRc-AW_18mWTg.png"/></div></div></figure><h1 id="1128" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">步骤6:重复步骤3-5</h1><p id="7522" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">一旦我们有了以前的聚类和存储的变化，我们就从头开始。但是只有这一次，我们使用先前计算的质心来生成3个新的聚类，重新计算新聚类的中心，并计算所有聚类内的变化的总和。</p><p id="6b1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们假设接下来的4次迭代如下所示:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b61ade64b7370b92479b8f81ae624743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*bAh55dR4dh3YcydQJHbMJQ.png"/></div></figure><p id="80aa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从最后两次迭代中，我们看到集群没有改变。这意味着算法已经<em class="le">收敛</em>，我们停止聚类过程。然后，我们选择具有最小WCSS的集群。这也恰好是最后两次迭代的那些。因此，它们将是我们最后的集群。</p><h2 id="fbd4" class="nh lu it bd lv ni nj dn lz nk nl dp md kr nm nn mf kv no np mh kz nq nr mj ns bi translated">我们如何选择k？</h2><p id="1cea" class="pw-post-body-paragraph ki kj it kk b kl ml ju kn ko mm jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在我们的例子中，我们很方便地知道我们需要3个集群。但是如果我们不知道我们有多少个簇，那么我们如何选择k呢？</p><p id="31cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们尝试多个k值并计算WCSS。</p><p id="cbb8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">k=1:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nt"><img src="../Images/6debc39933e2fc950ef41544794ec357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2SInsRo6AxoBdwXkbYrwg.png"/></div></div></figure><p id="8fd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">k=2:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nu"><img src="../Images/1cc29abebc47ce3e13fad6244017c72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JEtqdcbVwpdohP4kYXNS_Q.png"/></div></div></figure><p id="2648" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">k=3:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nv"><img src="../Images/88bdf5d6249fdea008671b5835d3cd1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ds85ub0ixE8GevIM063m0g.png"/></div></div></figure><p id="03fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">k=4:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nw"><img src="../Images/2e4c0b722eb2aa3b73c1a4a8c55d0fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UG-P99F1Oqo5gTjS4a3tcg.png"/></div></div></figure><p id="7133" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们注意到，每次我们添加一个新的集群，每个集群内的总变化都比以前小。而当每个聚类只有一个点时，变差= 0。</p><p id="fdbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们需要使用一种叫做<em class="le">肘图</em>的东西来寻找最佳k。它绘制了WCSS与聚类数或k的关系</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nx"><img src="../Images/11c74d98e1e161af5a5098018a11dacc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mogYVjAzETYsqKUJw0-_Pg.png"/></div></div><p class="ny nz gj gh gi oa ob bd b be z dk translated">作者图片</p></figure><p id="e5f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这被称为肘形图，因为我们可以通过找到图的“肘”来找到最佳k值，即3。直到3，你可以注意到变化的巨大减少，但在那之后，变化不会很快下降。</p><p id="5da4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大概就是这样。一个简单但有效的聚类算法！</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="45f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想支持我的工作，可以考虑使用<a class="ae lf" href="https://medium.com/@shreya.rao/membership" rel="noopener">我的链接注册一个媒体订阅</a>！(每月5美元，随时取消)</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="b251" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对10岁的孩子需要理解的其他算法有什么建议，请随时通过LinkedIn联系我，或者给我发电子邮件到shreya.statistics@gmail.com。</p></div></div>    
</body>
</html>