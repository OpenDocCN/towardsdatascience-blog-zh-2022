# 解决 IBM 的量子开放科学奖

> 原文：<https://towardsdatascience.com/towards-solving-ibms-quantum-open-science-prize-cb6688878779>

## 今天，我们满足了参赛条件

量子机器学习要不要入门？看看 [**动手量子机器学习用 Python**](https://www.pyqml.com/page?ref=medium_towpart&dest=/) **。**

如何发现是否从事量子计算的职业？大约三个月前，我声称最好的方法是研究 IBM 的量子开放科学奖。

这正是我们所做的。在我之前的文章中，我们讨论了这个挑战的本质细节。IBM 希望我们使用 Trotterization 在 IBM Quantum 的 7 量子位雅加达系统上模拟一个三粒子系统的海森堡模型哈密顿量。首先，我们了解到[真正的挑战不是模拟一个三粒子系统的海森堡模型哈密顿量。相反，它是关于如何在一个嘈杂的设备上做它](/a-first-glimpse-at-ibms-quantum-open-science-price-challenge-de4a2f41987e)。因此，我们建立了[我们的开发环境](https://pyqml.medium.com/how-to-set-up-jupyterlab-to-participate-in-ibms-quantum-open-science-prize-1a9d44b95bf6)，查看了[如何使用真正的量子计算机](/how-to-run-code-on-a-real-quantum-computer-c1fc61ff5b4)，并且[向我们介绍了量子错误缓解方法](https://pyqml.medium.com/how-to-tackle-ibms-quantum-open-science-prize-e6c7fc594154)。

我们选择了 [Clifford 数据回归(CDR)方法](https://pyqml.medium.com/mitigating-quantum-errors-using-clifford-data-regression-98ab663bf4c6)。在 CDR 中，我们使用可以经典模拟的量子电路来训练噪声模型。这个噪声模型让我们从有噪声的值中预测无噪声的值。

![](img/0ee80ec90f3b7602543af4f1a2f4edcc.png)

作者图片

我们用 Qiskit 和 Mitiq 实现了这种方法，在[本地模拟](/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c)和[真实量子计算机](/practical-error-mitigation-on-a-real-quantum-computer-41a99dddf740)上，结果都很有希望。不幸的是，我们认识到[我们不能使用 CDR 方法，除非我们重写 IBM 评估我们解决方案性能的方式](/just-another-ordinary-day-in-the-life-of-a-quantum-software-engineer-24689cd962ff)。我们没有这样做，因为这可能会取消我们提交的资格。相反，我们决定改变我们的方法。

因此，我们研究了[如何减轻噪声以满足 IBM 的期望](/towards-quantum-measurement-error-mitigation-e6f134883f34)和【在测量级别减轻噪声】。

所以，我们现在准备把它放在一起。

从概念上讲，我们遵循 CDR 方法的方法。

1.  生成培训数据
2.  训练一个噪声模型
3.  从有噪声的测量值预测无噪声的测量值

# 生成培训数据

我们的训练数据由成对的测量值组成。每对由同一量子电路的有噪和无噪测量组成。为了创建这些训练数据，我们需要各自的运行时环境。

*   无噪声(经典)模拟器
*   一个嘈杂的量子设备或一个嘈杂的模拟器

今天，我们使用 Qiskit 的`QasmSimulator`作为两种环境。首先，我们初始化没有任何参数的`QasmSimulator` Python 类，以获得无噪声模拟器。第二，我们使用我们的 IBM Quantum 帐户创建一个基于 Jakarta 设备噪声特征的模拟后端。

下一步，我们需要准备量子训练电路。这里的挑战是使用代表问题的电路，但经典的模拟。最初的 CDR 方法通过建立电路的有噪声和无噪声期望值之间的线性关系来实现可表示性。此外，它使用由 Clifford 门组成的电路。这些是经典的可模拟的门。

不幸的是，我们不能使用期望值，但我们需要减轻测量级别的噪声。我们不能在有噪声和无噪声值之间建立线性关系。此外，海森堡哈密顿模拟的问题是它的潜在规模。因此，即使它完全由 Clifford gates 组成，对于任何给定特定大小的经典计算机来说，整个电路都变得难以处理。因此，虽然一个三粒子的海森堡哈密顿量是小菜一碟，但一个五十粒子的海森堡哈密顿量是不可能经典模拟的。

因此，我们需要重新思考我们的训练数据。我们从 IBM 提供的 trotter 化算法开始。该算法包含至少四个三态门。在之前的帖子中，我们了解到，trotterization 门越多，无噪声性能越好。然而，我们使用越多的 trotterization 门，算法对噪声就变得越敏感。如果不采取缓解措施，噪声的负面影响将超过性能提升。但是对于缓解，使用多于最小数量的四个三态门可能是有意义的。

然而，对于训练来说，即使是四个 trotterization 门也太大了。我们需要更短的线路。幸运的是，每个 trotter gate 由三个子电路组成，`XX`、`YY`和`ZZ`门。因此，我们的计划是构建一个训练电路，在一个 tterization 门中只包含三个子电路中的两个子电路。

下面的函数为我们提供了这些电路。

总的来说，这是 IBM 不变的 trotter 化电路。`get_circuit`函数提供了一个可参数化的接口，以从中创建训练电路。这个想法是，我们可以通过参数`X`、`Y`和`Z`定制我们想要包含的子电路。除非我们包括所有三个子电路，否则我们只增加一个 tterization 门。例如，如果我们有`XX`和`YY`门，该函数用这些门为单个 trotter 步骤创建一个电路。有必要提一下，我们需要使用预定的量子化步骤数，因为我们使用这个数作为量子位旋转的参数化。所以，具有不同快步数的电路是完全不同的。

我们现在准备创建训练回路。让我们用 12 个快步。如果你喜欢，你可以玩不同数量的步骤。

我们创建了三组电路。这些电路具有

*   `XX`和`YY`闸门
*   `YY`和`ZZ`闸门
*   `ZZ`和`XX`门

当然，你也可以玩门的组合。

此外，我们不是每个都创建一个单独的电路，而是 27 个！原因是 IBM 用来评估我们的模拟性能的量子态断层扫描。量子态层析成像通过从所有专有角度观察量子系统来重建量子态。对于三量子位系统，这些是 3^3=27 角。每个角度都会导致稍微不同的量子电路。但是这些微小的差异会显著影响测量结果。本质上，我们分别对待这些电路。

因此，在下面的步骤中，我们为每个指定的组合创建了 27 个回路。

在执行所有这些电路之前，我们创建了两个辅助函数。简而言之，`sorted_counts`函数对来自已执行电路的测量计数进行排序，并确保所有可能的状态都存在，即使它们的计数为零。

`get_modifiers`函数获取一个电路，在我们的无噪声和有噪声模拟器上执行，并计算一个修改量列表。我们的电路可以产生八分之一的状态。这些范围从`000`到`111`。每个值都有一个修饰符。因此，每个电路有八个修改器。修改量是一个数字，当我们乘以它时，它将噪声计数变为正确的无噪声计数。

通过应用`get_modifiers`功能，我们将所有电路转换成各自的修改器。变量`modifiers_xy`、`modifiers_yz`和`modifiers_zx`分别是 27 个电路的列表。每个元素是八个修饰符的列表。

我们`zip`将这些放入一个单独的列表(`modifiers_zipped`)。结果是包含 8 个修饰符的三项元组的 27 个回路的列表。

在下一步中，我们计算每个回路的最终修改量。我们在`mult`函数中这样做。该函数采用上述回路修饰符的元组。通过压缩这些元组，我们得到一个包含八个条目的列表，每个条目对应三个修饰符。实际上，我们对修饰符进行了排序，使它们都在一个对应于特定计数的列表中。

我们将最终修饰符计算为这样一个列表中所有修饰符到 trotter 步骤一半的乘积。

综上所述，我们创建了三个小型经典可仿真电路，代表我们想要降低其测量值的整体电路。对于这三个电路中的每一个，我们都计算出一个修正因子列表，告诉我们有噪计数与无噪计数的偏差。最后，我们将对应于一个计数的所有修饰符相乘，从而将它们组合起来。

总的来说，每个小回路都有三分之二的快步步。所以，这三个小电路结合起来表示两个快步走。为了计算与整个电路相对应的修改量，我们需要多次进行乘法运算。这是快步数除以二。

最后，我们没有单个整体电路，而是 27 个电路，因为我们的目标是使用状态层析成像。

让我们看看我们的最终修改器有多好。我们重用了前几篇文章中创建的两个助手。这些是`OwnResult` Python 类和基于该类计算最终状态层析的`state_tomo`函数(参见本文)。

```
noisy state tomography fidelity = 0.2861 ± 0.0000
noise-free state tomography fidelity = 0.9699 ± 0.0000
mitigated state tomography fidelity = 0.7518 ± 0.0000
```

总体结果显示出显著的改善。有了 12 个快步，最好的状态层析成像保真度大约是`0.97`。这就是无噪声量子计算机所能达到的目标。

然而，由于未减轻的(模拟的)噪声，状态层析成像下降到`0.29`。但是一旦我们用我们的修改器减轻噪声，我们就得到一个`0.75`的状态层析成像保真度。参加 IBM 量子开放科学奖的参赛标准是`0.3`的保真度。所以，我想说我们很好。

查看统计数据可以发现我们方法的有效性。我们减少了大约 68%的噪音。

```
Error (unmitigated): 0.6838963295732885
Error (mitigated): 0.21813650699579556
Relative error (unmitigated): 0.7050850779029165
Relative error (mitigatedR): 0.22489489909174665
Error reduction: 68.1%.
```

量子机器学习要不要入门？看看 [**动手用 Python**](https://www.pyqml.com/page?ref=medium_towpart&dest=/) **学习量子机器。**

![](img/c3892c668b9d47f57e47f1e6d80af7b6.png)

在这里免费获得前三章。