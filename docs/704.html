<html>
<head>
<title>Metaprogramming in Julia: A Full Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia中的元编程:全面概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/metaprogramming-in-julia-a-full-overview-2b4e811f1f77#2022-01-25">https://towardsdatascience.com/metaprogramming-in-julia-a-full-overview-2b4e811f1f77#2022-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="4168" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Julia中的元编程:全面概述</h1></div><div class=""><h2 id="7f75" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Julia中用几种不同的技术看元编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/663a0c9862f09cf198388a79fdcf34d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Vt3v_GlyEtTCiGtQpbHww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://pixabay.com/images/id-6497416/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/users/3lloi_koteika-21641593/" rel="noopener ugc nofollow" target="_blank"> 3Lloi_KoteikA </a>提供)</p></figure><h1 id="9928" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="db19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">传统函数式编程语言最著名的事情之一可能是一个叫做元编程的概念。元编程本质上只是用数据编程，而不是用代码——或者更确切地说，是从代码中创建数据或从数据中创建代码。历史上，元编程的实现一直围绕着列表和符号，Julia的元编程实现与这些历史实现既相似又不同。</p><p id="1d81" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">尽管有一些细微的差别，并且缺乏关于Julia元编程的全面教程，Julian系统实际上真的很棒。如果你碰巧有过其他语言的元编程经验，这个实现可能会让你感到惊讶和兴奋，因为我认为Julia处理这个的方式非常棒，就像Julia中的许多其他特性一样！如果您想更深入地了解我在本文中使用的代码和数据代码，这里有一个链接指向我在本文中使用的笔记本！：</p><div class="ms mt gp gr mu mv"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Julia%20metaprogramming.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Emmetts-DS-NoteBooks/Julia meta programming . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><blockquote class="nk nl nm"><p id="a401" class="lr ls nn lt b lu mn ju lw lx mo jx lz no mp mc md np mq mg mh nq mr mk ml mm im bi translated">顺便说一下，这个存储库非常庞大，现在总共包含132个项目。那可是好多笔记本啊！</p></blockquote></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="8c08" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">一切都是象征</h1><p id="f917" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在开始元编程之前，你需要了解的第一件事是，Julia中的一切都是一个符号。也就是说，everything的类型不是Symbol()，而是对Julia内部的每个现有名称都有一个查找。我们实际上可以通过符号以及它们的别名来索引单个作用域，别名通常只是转换成字符串的符号。正如我刚才所说的，这可以在语言的任何单独范围内完成。换句话说，如果我们使用一个构造函数来创建一个新的类型，那么这个类型现在就有了自己的作用域，在这个作用域中，我们可以访问新定义的符号。获得这样的值的一个很好的方法是通过Julia保守得最好的秘密之一getfield()方法。</p><p id="6754" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以在Julia中任何有作用域的东西上使用getfield方法。这可以是我们的全局环境，在Julia中称为Main，一个模块，一个类型——任何可以存储作用域的东西——当然没有属性的作用域除外，比如方法，循环等等。考虑以下值x:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8546" class="oi la it oe b gy oj ok l ol om">x = 5</span></pre><p id="9d3c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个x现在被全局定义为64位整数5。我们可以通过调用Main中的5来访问它，正如人们可能期望的那样:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="137e" class="oi la it oe b gy oj ok l ol om">println(x)</span><span id="725e" class="oi la it oe b gy on ok l ol om">5</span></pre><p id="38dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，我们也可以直接调用它作为主模块的子模块:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3148" class="oi la it oe b gy oj ok l ol om">Main.x</span><span id="b25f" class="oi la it oe b gy on ok l ol om">5</span></pre><p id="6dc4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">查看一个get字段，我们只需将名称更改为其“字符串”别名的符号表示。我们还需要提供类型、模块或我们正在处理的任何东西作为第一个位置参数，这样方法就知道从哪里获取字段:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="7b52" class="oi la it oe b gy oj ok l ol om">getfield(Main, :x)</span><span id="40e7" class="oi la it oe b gy on ok l ol om">5</span></pre><p id="2c47" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我有一整篇关于getfield和Julian自省主题的文章，如果这不是很有意义，或者可能有人想了解更多关于这种方法和其他类似方法的信息，那么它可能值得一读:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/runtime-introspection-julias-most-powerful-best-kept-secret-bf845e282367"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">运行时自省:Julia最强大、保守得最好的秘密</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在Julia中使用内省处理类型</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="oo l ng nh ni ne nj ks mv"/></div></div></a></div><h1 id="d2d9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">公式</h1><p id="15ee" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据类型的字段也不是唯一可以用符号表示的东西。一个表达式本质上是一个可以被求值的符号，它比一个典型的符号有更多的属性。我们可以用碱。Meta.parse以便将字符串转换为表达式，例如:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3016" class="oi la it oe b gy oj ok l ol om">helloworld = Base.Meta.parse("println(\"Hello World!\")")</span><span id="3848" class="oi la it oe b gy on ok l ol om">:(println("Hello World!"))</span></pre><p id="a6b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将成为Expr类型:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="911d" class="oi la it oe b gy oj ok l ol om">println(typeof(helloworld))</span><span id="f467" class="oi la it oe b gy on ok l ol om">Expr</span></pre><p id="7b10" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们可以使用eval()方法计算这样的表达式。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="f58d" class="oi la it oe b gy oj ok l ol om">eval(helloworld)</span><span id="fcd8" class="oi la it oe b gy on ok l ol om">Hello World!</span></pre><p id="3e6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">表达式也有自己的字段，这些字段比我们想象的要方便得多，我们将在后面的例子中详述。不过现在，让我们用一种内省的方法来看看这些字段，我在前面提到的文章中也提到了这种方法。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="f5df" class="oi la it oe b gy oj ok l ol om">fieldnames(Expr)</span><span id="1f89" class="oi la it oe b gy on ok l ol om">(:head, :args)</span></pre><p id="83f0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以看到这些如何适合我们刚刚使用循环和getfield评估的示例helloworld表达式:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="b93d" class="oi la it oe b gy oj ok l ol om">for field in fieldnames(Expr)<br/>    println(getfield(helloworld, field))<br/>end</span><span id="285f" class="oi la it oe b gy on ok l ol om">call<br/>Any[:println, "Hello World!"]</span></pre><p id="0e96" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">head字段通知Julia我们正在使用哪种表达式。如果我们是元编程正则Julia，就像我们在这里一样，这将永远是:call。在大多数情况下，很可能是:call，所以现在我们将忽略这一点，转到:args字段。:args是arguments的缩写，后面是作为符号的方法调用，例如:println，后面是它们的参数。求值器知道方法的参数何时结束，因为它遇到了一个新的符号，这个符号也是一个方法调用。换句话说，我们可以把这个符号包装成“Hello World！”就像我们上面写的那样。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3497" class="oi la it oe b gy oj ok l ol om">println("Hello World!")</span></pre><h1 id="5ba6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">宏指令</h1><p id="e87e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">从最终用户的角度来看，将常规代码与这些表达式联系起来的是宏。宏允许我们计算10，或\n，或return之前的所有内容，无论你想在运行中调用什么，然后处理这个表达式。这里有一些有趣的细微差别，老实说，有些你无法从阅读Julia文档中找到——我认为这是不幸的，所以我将为你提供一些关于宏的信息，以及一种有趣的方法来查看Julia，如果这是使用方法错误的情况。此外，如果不把这一节写得很长，我就不可能表达关于宏语法和插值的每一件事情，所以如果你想了解更多关于宏的知识，这里有一个关于宏的Julia文档的链接:</p><div class="ms mt gp gr mu mv"><a href="https://docs.julialang.org/en/v1/manual/metaprogramming/#man-macros" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">元编程</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Julia语言中Lisp最强的遗产是它的元编程支持。像Lisp一样，Julia代表它自己的…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">docs.julialang.org</p></div></div></div></a></div><p id="175d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无论如何，让我们定义一个我们可以使用的宏。如你所料，我们只需使用关键字宏就可以做到。除此之外，宏的结构通常很像函数，尽管你绝对不应该使用宏作为函数，我们将在创建一个宏之后解释为什么会这样。我们的宏将被用来打印出一个循环要进行多长时间。这样，我们可以很好地了解如何使用宏来修改语法，但也不会太深入，以至于在我们进入下一个更复杂的代码部分之前我会失去你。为了证明我之前所说的，我们无法从文档中获得的信息，我将通过提供宏无法接收的参数来故意导致方法错误。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="ff2e" class="oi la it oe b gy oj ok l ol om">macro howmany(s::String, b::Int64)<br/>    <br/>end</span></pre><p id="2eb8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，这些并不是我想要使用的实际参数，我只是想说明有时方法错误实际上可以成为学习方法的很好的输出。我将使用我们之前在getfield中使用的小循环来定义一个循环来使用这个宏。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="8d61" class="oi la it oe b gy oj ok l ol om"><a class="ae ky" href="http://twitter.com/howmany" rel="noopener ugc nofollow" target="_blank">@howmany</a> for field in  fieldnames(Expr)<br/>    println(field)<br/>end</span><span id="ff55" class="oi la it oe b gy on ok l ol om">LoadError: MethodError: no method matching var"@howmany"(::LineNumberNode, ::Module, ::Expr)<br/>Closest candidates are:<br/>  var"@howmany"(::LineNumberNode, ::Module) at In[12]:1<br/>  var"@howmany"(::LineNumberNode, ::Module, ::String, ::Int64) at In[13]:1<br/>in expression starting at In[14]:1</span></pre><p id="4129" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里文档没有告诉你的是::LineNumberNode和::Module在默认情况下总是会被提供。我们实际上从来不需要使用LineNumberNode，因为我怀疑这更像是一个内部的东西，因为我们确实收到了宏之后的其余行作为表达式，这实际上应该是传递给我们的唯一参数。但是，还要注意提供了模块，这是调用宏的模块。我们可以使用__module__在代码中访问它，这是一个全局定义，正如你所看到的:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="1995" class="oi la it oe b gy oj ok l ol om">__module__</span><span id="10cf" class="oi la it oe b gy on ok l ol om">UndefVarError: __module__ not defined</span></pre><p id="9d15" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，如果我们仅将表达式作为参数来修改宏，我们可以将该参数打印出来:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="7246" class="oi la it oe b gy oj ok l ol om">macro howmany(exp::Expr)<br/>    println(__module__)<br/>end</span><span id="1d96" class="oi la it oe b gy on ok l ol om"><a class="ae ky" href="http://twitter.com/howmany" rel="noopener ugc nofollow" target="_blank">@howmany</a> for field in  fieldnames(Expr)<br/>    println(field)<br/>end</span><span id="064e" class="oi la it oe b gy on ok l ol om">Main</span></pre><p id="2a67" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也就是说，论点是完全不可见的——你不会从阅读文档中知道它的存在，这也可能支持我关于行号的理论——因为也许这也是更内在的。</p><p id="b525" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一般来说，编写宏时的最佳实践是做任何你必须做的事情，然后引用一个函数。出现这种情况有很多原因，这在过去确实让我感到困惑——人们告诉我这是使用宏的一种更好的方式，从而帮助了我，所以现在我将这一信息传递给你。现在，如果我们在args字段中打印出可索引的第一个参数，我们会得到</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="3cc0" class="oi la it oe b gy oj ok l ol om">macro howmany(exp::Expr)<br/>    println(exp.args[1])<br/>end</span><span id="e135" class="oi la it oe b gy on ok l ol om">field = fieldnames(Expr)</span></pre><p id="32d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于这个表达式的性质，假设它是一个for循环，处理这个问题的最好方法可能是拆分一个字符串——这并不总是如此，但在某些情况下，重新解析是必要的，否则就没有办法获得这些参数名。记住这一点，我将继续传递这个表达式的字符串版本，通过一个新的方法，它将为我们计算这个值的长度。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="c3af" class="oi la it oe b gy oj ok l ol om">macro howmany(exp::Expr)<br/>    statement = exp.args[1]<br/>    howmany(string(exp))<br/>end</span></pre><p id="0f26" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们新的howmany()方法中，我们将首先把我们的字符串分割成子字符串，然后因为我们的参数在这个例子中的位置保持一致，我们不需要做任何进一步的工作。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="63c2" class="oi la it oe b gy oj ok l ol om">function howmany(exp::String)<br/>    d = split(exp, ' ')<br/>end</span></pre><p id="ba68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">非常简单的东西，我将获取我们的值的位置，然后解析它并在length()方法周围求值，就像这样:</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="d4b1" class="oi la it oe b gy oj ok l ol om">function howmany(exp::String)<br/>    d = split(exp, ' ')<br/>    value = d[4]<br/>    n = eval(Base.Meta.parse("length(" * value * ")"))<br/>    println("COUNT: " * string(n))<br/>end</span><span id="6fb3" class="oi la it oe b gy on ok l ol om"><a class="ae ky" href="http://twitter.com/howmany" rel="noopener ugc nofollow" target="_blank">@howmany</a> for field in fieldnames(Expr)<br/>    <br/>end</span><span id="f2ea" class="oi la it oe b gy on ok l ol om">COUNT: 2</span></pre><p id="52e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，有一个问题仍然没有答案；为什么我决定采用这种方法？在宏内部计算一个返回将会导致很多作用域的问题。尽管模块被传递到宏中，但是从外部调用方法要简单得多，因为在所有诚实的宏中，在Julia中有一些处理范围的有趣方法。也就是说，你也可以查看下面的替代方案，它比系统化的方法要多得多的代码来完成一项任务。</p><pre class="kj kk kl km gt od oe of og aw oh bi"><span id="5c1e" class="oi la it oe b gy oj ok l ol om">"""<br/>## <a class="ae ky" href="http://twitter.com/each" rel="noopener ugc nofollow" target="_blank">@each</a> exp::Expr -&gt; ::Bool<br/>Determines whether each element of an iterable meets a certain condition. Returns a boolean, true if all of the elements meet a condition, false if otherwise.<br/>Used in conditional contexts.<br/>### example<br/>```<br/>x = [5, 10, 15, 20]<br/>if <a class="ae ky" href="http://twitter.com/each" rel="noopener ugc nofollow" target="_blank">@each</a> x % 5 == 0<br/>   println("They are!")<br/>end<br/>They are!<br/>if <a class="ae ky" href="http://twitter.com/each" rel="noopener ugc nofollow" target="_blank">@each</a> x &gt; 25<br/>    println("They are!")<br/>end<br/>if <a class="ae ky" href="http://twitter.com/each" rel="noopener ugc nofollow" target="_blank">@each</a> x &lt; 25<br/>    println("They are!")<br/>end<br/>They are!<br/>```<br/>"""<br/>macro each(exp::Expr)<br/>    x = exp.args[2]<br/>    xname = ""<br/>    if contains(string(x), '[')<br/>        xname = eval(x)<br/>    else<br/>        xname = getfield(__module__, Symbol(x))<br/>    end<br/>    if length(exp.args) == 2<br/>        for value in xname<br/>            state = eval(Meta.parse(string(exp.args[1], "(", value, ")")))<br/>            if state != true<br/>                return(false)<br/>            end<br/>        end<br/>    end</span><span id="f65a" class="oi la it oe b gy on ok l ol om">for value in xname<br/>        state = eval(Meta.parse(string(value," ", exp.args[1], " ", exp.args[3])))<br/>        if state != true<br/>            return(false)<br/>        end<br/>    end<br/>    return(true)<br/>end</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><h1 id="bf78" class="kz la it bd lb lc ny le lf lg nz li lj jz oa ka ll kc ob kd ln kf oc kg lp lq bi translated">结论</h1><p id="2dff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia中有很多关于元编程的内容，但是希望这个基本介绍非常适合那些对这个主题感兴趣但是可能不知道从哪里开始的人。我认为Julian实现可能是我使用过的最好的实现之一，除了像Lisp这样评估数组的语言。也就是说，像Lisp这样的语言有它们自己的缺点，并且没有Julia那样漂亮的语法。我发现在Lisp中计算括号有点烦人。也就是说，这肯定是元编程在一种语言中较好的实现之一，其伟大之处就在于它允许您做多少事情。这些宏中的许多被用来在一个全新的层面上与代码进行交互，通过提高性能、计时等类似的事情，这使得许多事情有始有终。这真的非常非常酷。我喜欢在一个符号下有一个固定名称的概念，类似于利用这些元编程概念的其他语言。感谢您阅读我的文章，我希望这是对朱莉娅的一个有趣的方面的一个有趣的观察，我以前没有太多接触过。感谢您的阅读！</p></div></div>    
</body>
</html>