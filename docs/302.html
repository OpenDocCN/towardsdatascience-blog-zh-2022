<html>
<head>
<title>Long Callbacks in Dash Web Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dash Web应用程序中的长时间回调</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/long-callbacks-in-dash-web-apps-72fd8de25937#2022-01-11">https://towardsdatascience.com/long-callbacks-in-dash-web-apps-72fd8de25937#2022-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="47b6" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Dash Web应用程序中的长时间回调</h1></div><div class=""><h2 id="f4b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">如何处理Python Dash web应用回调函数中耗时的代码</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/0b567b719789a427ffcbffd4f952ddf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpkv3b__d3HD__gRaYUDZQ.jpeg"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">图片由作者提供，基于<a class="ae kz" href="https://pixabay.com/de/users/moritz320-1260270/" rel="noopener ugc nofollow" target="_blank"> moritz320 </a> (Pixabay)的<a class="ae kz" href="https://pixabay.com/de/photos/zeitlicher-abstand-chronometer-dauer-1990035/" rel="noopener ugc nofollow" target="_blank">股票图片</a>。</p></figure><p id="866a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你用Python开发web应用，有耗时的代码要运行？要从数据库中查询大量记录，要执行复杂的评估，要创建复杂的可视化？那么Dash 2.0引入的长时间回调可能正是你所需要的。</p><p id="49d8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于长回调，web服务器的超时设置(在许多情况下为30秒)在执行耗时的代码时不会给你带来任何问题。长回调在一个单独的进程中运行，并带有额外的选项，允许您提高应用程序的响应能力，例如，通过阻止触发它的按钮或通过可视化回调的进度。</p><h1 id="0f0f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">长时间回调与正常回调</h1><p id="f96e" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">在Dash中，回调是通过将回调装饰器<code class="fe mt mu mv mw b">@app.callback(...)</code>放在相应的函数之上来声明的。对于长回调，也是一样的，只是使用了稍微不同的装饰器，提供了额外的功能。以下是长时间回调和普通回调之间的区别:</p><ul class=""><li id="05f2" class="mx my it lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated">长回调在单独的进程中运行，不会导致超时错误。</li><li id="a139" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">为了让长回调生效，您必须安装一些您可能不需要的包(见下一节)。</li><li id="b7d8" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">@app.long_callback(...)</code>是声明长回调时必须使用的装饰器。</li><li id="2434" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">running</code>、<code class="fe mt mu mv mw b">cancel</code>、<code class="fe mt mu mv mw b">progress</code>:除了<code class="fe mt mu mv mw b">Input</code>、<code class="fe mt mu mv mw b">Output</code>和<code class="fe mt mu mv mw b">State</code>参数之外，这些可选参数在长回调装饰器的括号内。我稍后将讨论这些新特性。</li><li id="1ce3" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">在有多个输入的情况下，用于标识触发回调的组件的<code class="fe mt mu mv mw b">dash.callback_context</code>在长回调中不受支持。如果您需要这个功能，我将向您展示一个变通方法。</li><li id="5d66" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">raise PreventUpdate</code>(从<code class="fe mt mu mv mw b">dash.exceptions</code>导入)不应该和<code class="fe mt mu mv mw b">running</code>参数一起使用，因为它会让你的应用无限期地保持在<code class="fe mt mu mv mw b">running</code>选项定义的状态(直到页面重新加载)。</li></ul><h1 id="477d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">准备好</h1><p id="6818" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">如果你是Dash新手，我强烈建议你看一下<a class="ae kz" href="https://dash.plotly.com/introduction" rel="noopener ugc nofollow" target="_blank">文档</a>。在开始玩长时间回调之前，你至少应该熟悉<a class="ae kz" href="https://dash.plotly.com/basic-callbacks" rel="noopener ugc nofollow" target="_blank">回调基础</a>。本文中的代码需要以下Python包:</p><ul class=""><li id="4223" class="mx my it lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">dash</code>(2 . 0 . 0版本；早期版本不支持长回调)</li><li id="5eae" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">dash_bootstrap_components</code>(版本1.0.0)</li><li id="0db2" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">diskcache</code></li><li id="7c35" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">multiprocess</code></li><li id="1605" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">psutil</code></li></ul><p id="9429" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">都安装好了吗？很好，现在让我们看看如何使用长回调。</p><h1 id="174f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">开始编码</h1><p id="3bba" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">我们将从一些进口开始。我们可以不用<a class="ae kz" href="https://dash-bootstrap-components.opensource.faculty.ai/docs/quickstart/" rel="noopener ugc nofollow" target="_blank"> Dash Bootstrap组件</a>来构建应用程序，但我喜欢它们，因为它们可以轻松创建整洁且响应迅速的布局。<code class="fe mt mu mv mw b">time</code>包只需要模拟耗时代码的执行。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ce47" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我在<code class="fe mt mu mv mw b">main()</code>函数中设置了应用程序的布局及其回调，该函数在脚本的最后一行被调用。我们做的第一件事是创建一个回调管理器对象和Dash应用程序对象，它将回调管理器作为一个参数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f6e3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，我们使用的是一个<a class="ae kz" href="http://www.grantjenks.com/docs/diskcache/tutorial.html" rel="noopener ugc nofollow" target="_blank"> DiskCache </a>回调管理器，这对于开发来说非常好，而Dash的开发者推荐<a class="ae kz" href="https://docs.celeryproject.org/en/stable/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank">芹菜</a> / <a class="ae kz" href="https://redis.io/documentation" rel="noopener ugc nofollow" target="_blank"> Redis </a>用于生产。在这个例子中，回调管理器将在包含Python脚本的目录中创建一个名为<code class="fe mt mu mv mw b">cache</code>的文件夹。</p><p id="efc2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">接下来，我们添加所有的GUI组件，即一行文本(<code class="fe mt mu mv mw b">html.Div</code>)、一个数字输入字段(<code class="fe mt mu mv mw b">dbc.Input</code>)、两个按钮(<code class="fe mt mu mv mw b">dbc.Button</code>)和另一个名为<code class="fe mt mu mv mw b">hidden</code>的<code class="fe mt mu mv mw b">html.Div</code>元素，它是不可见的(我一会儿会解释)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ee52" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用<code class="fe mt mu mv mw b">dash_bootstrap_components</code>，布局被构建为行的集合(<code class="fe mt mu mv mw b">dbc.Row</code>)，每一行可以包含几列(<code class="fe mt mu mv mw b">dbc.Col</code>)。最后，所有行都放在一个<code class="fe mt mu mv mw b">dbc.Container</code>对象中，该对象被插入到Dash应用程序对象的<code class="fe mt mu mv mw b">layout</code>属性中。生成的web应用程序GUI如下面的屏幕截图所示。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/db3843c72e6c39f3fabb111bc41c6e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*-6e5mpiTl-KX-Y_I10RY8Q.jpeg"/></div></figure><p id="821d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在是时候将按钮链接到回调了。我们在这个例子中使用两个按钮的原因是我想告诉你如何找出哪个组件触发了长回调，尽管我们不能在长回调中使用<code class="fe mt mu mv mw b">dash.callback_context</code>。我使用的解决方法是编写一个普通的回调函数，将两个按钮作为输入，不可见的<code class="fe mt mu mv mw b">html.Div</code>元素<code class="fe mt mu mv mw b">hidden</code>作为输出。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7c3b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这个普通的回调函数中，我们可以获得触发回调函数的组件的ID，如上面的代码所示。基于这个ID，我们设置了<code class="fe mt mu mv mw b">hidden</code>组件的<code class="fe mt mu mv mw b">children</code>属性。我还在这里演示了<code class="fe mt mu mv mw b">PreventUpdate</code>的使用，这在回调应该保持输出属性不变的情况下很有用。</p><p id="adb0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">区分这两个按钮的诀窍在于，<code class="fe mt mu mv mw b">hidden</code>组件的更新(其<code class="fe mt mu mv mw b">children</code>属性现在包含被单击按钮的名称)触发长回调。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2dcd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了提供按钮名称的<code class="fe mt mu mv mw b">hidden</code>组件，长回调使用数字输入字段作为输入。然而，为此我们使用了<code class="fe mt mu mv mw b">State</code>而不是<code class="fe mt mu mv mw b">Input</code>，这样可以防止输入字段值的改变触发回调。<code class="fe mt mu mv mw b">running</code>参数需要一个元组列表，每个元组控制一个组件属性的行为。该组件属性是元组的第一个元素，回调运行时它的值是第二个元素，结束时它的值是第三个元素。<code class="fe mt mu mv mw b">prevent_initial_call=True</code>参数确保在加载应用程序的布局时(在用户做任何事情之前)不会执行长回调。</p><p id="ef71" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">装饰器的可选参数<code class="fe mt mu mv mw b">cancel</code>在示例中没有使用，但是当您希望能够中断长时间回调的执行时，它可能会派上用场。语法是<code class="fe mt mu mv mw b">cancel=[Input('component', 'property')]</code>，对指定组件属性的任何更改都将取消回调的执行。</p><p id="8319" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在长回调函数中，你可以执行耗时的代码。在这个例子中，我们调用<code class="fe mt mu mv mw b">time_consuming_function(number)</code>，它接收数字输入字段的值作为参数。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="eb4a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个函数使用<code class="fe mt mu mv mw b">time.sleep(seconds)</code>来模拟耗时代码的执行，然后返回传递给它的数的平方根。</p><p id="cd13" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当您单击两个按钮中的一个时，会有一个延迟(在代码示例中为2秒)，之后,<code class="fe mt mu mv mw b">html.Div</code>元素<code class="fe mt mu mv mw b">txt_status</code>将用结果(数字输入字段的平方根)和您单击的按钮的名称进行更新。执行回调时，两个按钮都被禁用。恭喜你，你刚刚成功使用了Dash的长回调逻辑！</p><h1 id="61a2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">显示进度</h1><p id="8fbe" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">当您的web应用程序执行耗时的代码时，让用户了解进度是有意义的。方便的是，长回调带有一个<code class="fe mt mu mv mw b">progress</code>参数，该参数接受一个<code class="fe mt mu mv mw b">html.Progress</code>组件，从而允许您从长回调中更新进度条的值。你可以在Dash的<a class="ae kz" href="https://dash.plotly.com/long-callbacks" rel="noopener ugc nofollow" target="_blank">长回调文档</a>中找到解释这个功能的教程(例4)。</p><p id="eda2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在这里，我将向您展示一种不同的方法。假设您的长回调调用了另一个模块中的一个函数，该函数最初是在不同的上下文中编写的，例如，您在控制台环境中用于数据操作的脚本。这个脚本很可能已经使用了<code class="fe mt mu mv mw b">tqdm</code>或者可以很容易地修改成这样(并且很可能从这样的修改中受益)。如果你不熟悉<code class="fe mt mu mv mw b">tqdm</code>包，我强烈建议你看一下<a class="ae kz" href="https://tqdm.github.io/" rel="noopener ugc nofollow" target="_blank">文档</a>。简而言之，它允许你通过显示一个可以在各种环境下工作的进度条来度量任何类型迭代的进度。</p><p id="b5a5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是如何在不编辑现有代码的情况下，将现有代码中的<code class="fe mt mu mv mw b">tqdm</code>进度跟踪链接到web应用程序中的长回调:</p><ul class=""><li id="7a87" class="mx my it lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated">将<code class="fe mt mu mv mw b">tqdm</code>输出重定向到一个文件。</li><li id="eb2d" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">编写一个定时器触发的回调函数，定期读取这个文件。</li><li id="21eb" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">从文件中提取最近的百分比值，并相应地更新进度条。</li></ul><p id="cff4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要设置这个功能，我们需要三个额外的导入:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b440" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们修改<code class="fe mt mu mv mw b">row_3 = ...</code>行下面的<code class="fe mt mu mv mw b">main()</code>函数的代码如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="464d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这段代码向我们的布局添加了第四行，其中包含一个进度条和一个计时器(不可见)，它每秒“滴答”一次。当它这样做时，它触发下面的回调函数，您可以将它添加到其他两个回调函数的下面。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="152c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe mt mu mv mw b">try-except-finally</code>语句用于确保即使文件<code class="fe mt mu mv mw b">progress.txt</code>不存在或者其内容不符合预期，代码也能工作。如果文件包含正确的<code class="fe mt mu mv mw b">tqdm</code>输出，代码将找到最后一个非空行，并提取该行开头的百分比值。然后，该函数将该值返回给<code class="fe mt mu mv mw b">dbc.Progress</code>组件的<code class="fe mt mu mv mw b">value</code>属性，并将相应的文本返回给其<code class="fe mt mu mv mw b">label</code>属性。</p><p id="696a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了将<code class="fe mt mu mv mw b">tqdm</code>的输出重定向到文件<code class="fe mt mu mv mw b">progress.txt</code>，我们需要修改长回调中的代码，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="38fd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">默认情况下，<code class="fe mt mu mv mw b">tqdm</code>将其输出写入<code class="fe mt mu mv mw b">sys.stderr</code>。上面显示的代码保存当前的<code class="fe mt mu mv mw b">sys.stderr</code>设置，然后将其更改为文件<code class="fe mt mu mv mw b">progress.txt</code>，执行耗时函数，最后恢复<code class="fe mt mu mv mw b">sys.stderr</code>的原始设置。</p><p id="7ad8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了测试这个功能，我们修改了这个耗时的函数，这样它就包含了一个由<code class="fe mt mu mv mw b">tqdm</code>跟踪的迭代:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7bb3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这就是你将<code class="fe mt mu mv mw b">tqdm</code>链接到你的网络应用的进度条所需要做的一切！当您完成代码修改后，在运行脚本并单击按钮时，您应该会看到类似这样的内容:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi no"><img src="../Images/8e558131e93725d97b7cc2f258b13a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/1*pqr0QEu7qSLFDjZN_RoWPQ.gif"/></div></figure></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="706b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我想用一个简短的回顾来结束我的发言。你刚刚才知道</p><ul class=""><li id="37d3" class="mx my it lc b ld le lg lh lj mz ln na lr nb lv nc nd ne nf bi translated">多头回调在哪些方面不同于标准回调。</li><li id="969e" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">使用长回调的先决条件是什么。</li><li id="dcc0" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">如何实现一个长回调的基本结构，这个回调知道它是由哪个组件触发的。</li><li id="5f3f" class="mx my it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">如何访问<code class="fe mt mu mv mw b">tqdm</code>的输出来跟踪可能属于另一个模块的代码的执行进度。</li></ul><p id="793e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢您的阅读。如果你觉得这篇文章很有趣，请考虑<a class="ae kz" href="https://thomas-baumgartner.medium.com/subscribe" rel="noopener">订阅</a>以在未来获得更多这样的内容。如果你还没有中级会员，你可以在这里得到一个<a class="ae kz" href="https://thomas-baumgartner.medium.com/membership" rel="noopener"/>。</p></div></div>    
</body>
</html>