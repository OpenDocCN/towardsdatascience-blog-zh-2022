<html>
<head>
<title>Build a Q&amp;A App with PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch构建问答应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-q-a-app-with-pytorch-cb599480e29#2022-01-10">https://towardsdatascience.com/build-a-q-a-app-with-pytorch-cb599480e29#2022-01-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="ec0c" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">使用PyTorch构建问答应用程序</h1></div><div class=""><h2 id="7c4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Docker和FastAPI轻松部署QA HuggingFace模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/195f116ecba7a340e2609eff5ba770ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZF16pBmYo6j1vUHWsZZRKg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Pexels的<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> pixabay </a>拍摄。</p></figure><h1 id="a73d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">目录</h1><ol class=""><li id="6643" class="lr ls it lt b lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">介绍</li><li id="a133" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">定义搜索上下文数据集</li><li id="6152" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">构建质量保证嵌入模型</li><li id="a57f" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">使用Docker和FastAPI部署模型</li><li id="a429" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">结论</li><li id="8ccb" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">参考</li></ol><h1 id="c287" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ce78" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">在过去的几年里，从计算机视觉到自然语言处理，大量的预训练模型已经可用，其中一些最知名的聚合器是<a class="ae ky" href="https://modelzoo.co/" rel="noopener ugc nofollow" target="_blank"> Model Zoo </a>、<a class="ae ky" href="https://tfhub.dev/" rel="noopener ugc nofollow" target="_blank"> Tensorflow Hub </a>和<a class="ae ky" href="https://huggingface.co/models" rel="noopener ugc nofollow" target="_blank"> HuggingFace </a>。</p><p id="785a" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如此大的一组预训练模型的可用性允许开发人员重用这些模型，而无需花费大量的时间和金钱来训练它们。例如，使用Tesla V100实例训练一个GPT-3模型将花费超过460万美元。</p><p id="3615" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">在本帖中，我们将讨论:</p><ol class=""><li id="60c9" class="lr ls it lt b lu nb lw nc ly ng ma nh mc ni me mf mg mh mi bi translated">如何使用HuggingFace上提供的预训练PyTorch模型创建问答(QA)模型；</li><li id="9a21" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">如何使用Docker和FastAPI部署我们的定制模型？</li></ol><h1 id="2733" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">定义搜索上下文数据集</h1><p id="6534" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">有两种主要类型的QA模型。第一种方法将领域特定知识的大型语料库编码到模型中，并基于学习到的知识生成答案。第二种方法利用给定的上下文，从上下文中提取最佳段落/答案。</p><p id="161d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">第二种方法更容易推广到不同的领域，无需重新训练或微调原始模型。因此，在这篇文章中，我们将重点讨论这种方法。</p><p id="5e4c" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">要使用基于上下文的QA模型，我们首先需要定义我们的“上下文”。这里，我们将使用<em class="nj">斯坦福问答数据集</em> 2.0。要下载该数据集，请点击<a class="ae ky" href="https://rajpurkar.github.io/SQuAD-explorer/dataset/train-v2.0.json" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="7f10" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">下载这个文件后，用Python打开它，检查它的结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2eb4" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">观察到的结构应该类似于下面提供的结构。根据这些数据，我们将关注主题为<code class="fe nm nn no np b">Premier League</code>的<code class="fe nm nn no np b">question</code>和<code class="fe nm nn no np b">answers</code>字段。这将为我们提供具体问题的确切答案。如果您想从上下文段落中提取答案，请查看<code class="fe nm nn no np b">context</code>字段。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="7328" class="nu la it np b gy nv nw l nx ny">'data': [<br/>  'topic1': {<br/>    'title': str,<br/>    'paragraphs': [<br/>      'paragraph1':{<br/>        'qas': [<br/>          'qa1':{<br/>            'id': str,<br/>            'is_impossible': bool,<br/>            '<strong class="np iu">question</strong>': str,<br/>            '<strong class="np iu">answers</strong>': [<br/>              'answer1':{<br/>                'text': str,<br/>                'answer_start': int<br/>              }<br/>              ...<br/>            ],<br/>          },<br/>          ...        <br/>        ]<br/>      },<br/>      ...<br/>    ],<br/>  'context': str<br/>}</span></pre><p id="0494" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">为了获得<code class="fe nm nn no np b">questions</code>和<code class="fe nm nn no np b">answers</code>，定义并运行以下函数<code class="fe nm nn no np b">get_qa</code>。这将返回一组357对问题和答案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h1 id="0953" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">构建质量保证嵌入模型</h1><p id="8de4" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">简而言之，我们的模型将通过比较来自用户的新问题和我们的上下文集中的问题集，然后提取相应的答案来工作。</p><p id="43d3" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">由于我们无法比较原始格式(文本)的问题，因此在执行任何相似性评估之前，我们需要将上下文问题和来自用户的未知问题转换到一个公共空间。</p><p id="71e3" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">为此，我们将定义一个新的文本嵌入类，用于将上下文和用户的未知问题从文本转换为数字向量。</p><h2 id="a5ee" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">1.下载预训练的嵌入模型</h2><p id="8997" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">如“简介”部分所述，从头开始训练一个模型既费时又费钱。因此，让我们使用一个已经在HuggingFace上训练好的模型。</p><p id="76b7" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">将下面的脚本保存到一个名为<code class="fe nm nn no np b">download_model.sh</code>的文件中，在带有<code class="fe nm nn no np b">bash download_model.sh</code>的终端中运行，下载所需的模型文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="74aa" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">2.在本地测试嵌入模型</h2><p id="ab3c" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">如果你没有<code class="fe nm nn no np b">transformers</code>包，用pip安装它。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="ec86" class="nu la it np b gy nv nw l nx ny">pip install transformers[torch]</span></pre><p id="2e41" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">然后，在新的笔记本单元格中定义并运行下面的<code class="fe nm nn no np b">get_model</code>函数。如果所有文件都已正确下载，并且所有依赖项都已满足，那么运行起来应该没有问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a324" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">现在让我们在一个上下文问题的样本上运行我们的嵌入模型。为此，请运行以下指令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7760" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">上面的脚本应该打印出我们新的<code class="fe nm nn no np b">embeddings</code>向量的形状。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="74bc" class="nu la it np b gy nv nw l nx ny">Embeddings shape: torch.Size([3, 384]</span></pre><h2 id="96c0" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">3.测试上下文与新问题的相似性</h2><p id="d052" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">让我们从检查之前的样题开始:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="4f5c" class="nu la it np b gy nv nw l nx ny">[<br/>  'How many club members are there?',<br/>  'How many matches does each team play?',<br/>  'What days are most games played?'<br/>]</span></pre><p id="7e40" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">然后，将最后一条解释为:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="6155" class="nu la it np b gy nv nw l nx ny">'Which days have the most events played at?'</span></pre><p id="fbed" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">最后，嵌入我们的新问题，计算<code class="fe nm nn no np b">new_embedding</code>和<code class="fe nm nn no np b">embeddings</code>之间的欧氏距离。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f54d" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">上面的脚本应该输出以下距离，表明我们样本中的最后一个问题确实是距离我们的新问题最近的(最小的距离)。</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="11b6" class="nu la it np b gy nv nw l nx ny">tensor([71.4029, 59.8726, 23.9430])</span></pre><h1 id="f955" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用Docker和FastAPI部署模型</h1><p id="1a5d" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">上一节介绍了定义QA搜索模型的所有构件。要使其在生产环境中可用，我们需要:</p><ol class=""><li id="3660" class="lr ls it lt b lu nb lw nc ly ng ma nh mc ni me mf mg mh mi bi translated">将前面的函数包装在一个或多个易于使用的类中；</li><li id="73e2" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">定义一个app，通过HTTP调用需要的类方法；</li><li id="c17b" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">将整个应用程序和依赖项包装在一个容器中，以便于扩展。</li></ol><h2 id="133e" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">1.定义QA搜索模型</h2><p id="661a" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">让我们将前面介绍的概念包装成两个新的类:<code class="fe nm nn no np b">QAEmbedder</code>和<code class="fe nm nn no np b">QASearcher</code>。</p><p id="60b7" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><code class="fe nm nn no np b">QAEmbedder</code>将定义如何从磁盘加载模型(<code class="fe nm nn no np b">get_model</code>)并返回给定一组问题(<code class="fe nm nn no np b">get_embeddings</code>)的一组嵌入。注意为了效率<code class="fe nm nn no np b">get_embeddings</code>会一次嵌入一批问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="704b" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><code class="fe nm nn no np b">QASearcher</code>将设置相应问题和答案的上下文(<code class="fe nm nn no np b">set_context_qa</code>)，并将我们上下文中最相似问题的答案返回给用户新的未看到的问题(<code class="fe nm nn no np b">get_answers</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="17d6" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">2.定义FastAPI应用程序</h2><p id="5cf4" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">我们的应用程序应该包含2个POST端点，一个用于设置上下文(<code class="fe nm nn no np b">set_context</code>)，一个用于获取给定的未知问题的答案(<code class="fe nm nn no np b">get_answer</code>)。</p><p id="17c2" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><code class="fe nm nn no np b">set_context</code>端点将接收包含2个字段(<code class="fe nm nn no np b">questions</code>和<code class="fe nm nn no np b">answers</code>)的字典，并更新<code class="fe nm nn no np b">QASearcher</code>。</p><p id="3ca6" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><code class="fe nm nn no np b">get_answer</code>端点将接收具有1个字段(<code class="fe nm nn no np b">questions</code>)的字典，并返回具有原始问题(<code class="fe nm nn no np b">orig_q</code>)、上下文中最相似的问题(<code class="fe nm nn no np b">best_q</code>)和相关答案(<code class="fe nm nn no np b">best_a</code>)的字典。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="9fd3" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">3.构建Docker容器</h2><p id="0ae7" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">最后一步是将我们的应用程序包装在Docker容器中，以便更容易地分发和扩展。在我们的docker文件中，我们需要:</p><ol class=""><li id="2472" class="lr ls it lt b lu nb lw nc ly ng ma nh mc ni me mf mg mh mi bi translated">安装<code class="fe nm nn no np b">wget</code>和所需的Python库<code class="fe nm nn no np b">transformers</code>、<code class="fe nm nn no np b">uvicorn</code>和<code class="fe nm nn no np b">fastapi</code>；</li><li id="9d5e" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">从HuggingFace下载预先训练好的QA模型；</li><li id="88df" class="lr ls it lt b lu mj lw mk ly ml ma mm mc mn me mf mg mh mi bi translated">将所有应用程序文件(此处可用<a class="ae ky" href="https://github.com/andreRibeiro1989/medium/tree/main/qa_model/app" rel="noopener ugc nofollow" target="_blank">)复制到Docker镜像并运行uvicorn应用程序。</a></li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4d72" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">要测试我们的新应用程序，使用以下命令构建并运行Docker映像:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="8d07" class="nu la it np b gy nv nw l nx ny">docker build . -t qamodel &amp;&amp;\<br/>  docker run -p 8000:8000 qamodel</span></pre><p id="fd51" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果一切顺利，您应该会收到以下消息:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="3a62" class="nu la it np b gy nv nw l nx ny">INFO:     Started server process [1]<br/>INFO:     Waiting for application startup.<br/>INFO:     Application startup complete.<br/>INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)</span></pre><h2 id="4455" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">4.测试正在运行的应用程序</h2><p id="30e0" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">为了测试我们的应用程序，我们可以简单地使用<code class="fe nm nn no np b">requests</code>来设置上下文，然后检索给定的新的看不见的问题的最佳答案。</p><p id="0e2f" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">要测试<code class="fe nm nn no np b">set_context</code>端点，请运行以下脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a556" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这应该会返回以下消息:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="109b" class="nu la it np b gy nv nw l nx ny">{'message': 'Search context set'}</span></pre><p id="4499" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">要测试<code class="fe nm nn no np b">get_answer</code>端点，请运行以下脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9160" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">这将返回以下消息:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="2d25" class="nu la it np b gy nv nw l nx ny">orig_q : How many teams compete in the Premier League ?<br/>best_q : How many clubs are currently in the Premier League?<br/>best_a : 20<br/><br/>orig_q : When does the Premier League starts and finishes ?<br/>best_q : When does the Premier League have its playing season?<br/>best_a : During the course of a season (from August to May)<br/><br/>orig_q : Who has the highest number of goals in the Premier League ?<br/>best_q : Who has the record for most goals in the Premier League?<br/>best_a : Newcastle United striker Alan Shearer holds the record for most Premier League goals with 260</span></pre><h2 id="ba1c" class="nu la it bd lb nz oa dn lf ob oc dp lj ly od oe ll ma of og ln mc oh oi lp oj bi translated">完成脚本</h2><p id="0f1c" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">如需完整的脚本，请点击以下链接进入我的GitHub页面:</p><div class="ok ol gp gr om on"><a href="https://github.com/andreRibeiro1989/medium/tree/main/qa_model" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">中型/QA _ main和Ribeiro1989型/中型</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用transformers、Docker和FastAPI的问答app。</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><h1 id="e116" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="1632" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">通过利用免费提供的预训练模型，构建强大的计算机视觉和自然语言处理模型正变得越来越容易。</p><p id="35d5" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">在本文中，我介绍了使用HuggingFace、Docker和FastAPI构建自己的问答应用程序的基本构件。请注意，这一系列步骤并不特定于问答，但确实可以用于大多数计算机视觉和自然语言处理解决方案。</p><p id="9f38" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果你对以无服务器方式部署这个应用感兴趣，可以看看我以前的文章“<a class="ae ky" rel="noopener" target="_blank" href="/build-a-serverless-api-with-amazon-lambda-and-api-gateway-dfd688510436">用Amazon Lambda和API Gateway </a>构建无服务器API”⁴.</p><p id="b393" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果您刚刚开始了解PyTorch，并希望快速了解它，那么这篇文章可能会让您感兴趣"<a class="ae ky" rel="noopener" target="_blank" href="/getting-started-with-pytorch-2819d7aeb87c">py torch入门</a> "⁵.</p></div><div class="ab cl pc pd hx pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="im in io ip iq"><p id="1142" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated"><a class="ae ky" href="https://andrefsr.medium.com/subscribe" rel="noopener"> <strong class="lt iu">加入我的邮件列表，我一发布新内容，你就能收到新内容！</strong> </a></p><p id="4303" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑报名成为一名媒体成员。每月5美元，让你可以无限制地访问Python、机器学习和数据科学文章。如果你使用<a class="ae ky" href="https://andrefsr.medium.com/membership" rel="noopener">我的链接</a>注册，我会赚一小笔佣金，不需要你额外付费。</p><div class="ok ol gp gr om on"><a href="https://andrefsr.medium.com/membership" rel="noopener follow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">通过我的推荐链接加入Medium-andréRibeiro</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">andrefsr.medium.com</p></div></div><div class="ow l"><div class="pj l oy oz pa ow pb ks on"/></div></div></a></div><h1 id="c865" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="c570" class="pw-post-body-paragraph mo mp it lt b lu lv ju mq lw lx jx mr ly ms mt mu ma mv mw mx mc my mz na me im bi translated">[1]https://lambdalabs.com/blog/demystifying-gpt-3/<em class="nj">李川【OpenAI的GPT-3语言模型:技术概述】</em></p><p id="3bc0" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">[2] Pranav Rajpurkar等著《<em class="nj">小队:机器理解文本的10万+问题</em>》(2016)，arXiv<br/>https://arxiv.org/abs/1606.05250v3</p><p id="d4a0" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">[3] <em class="nj"> </em> Stanford问答数据集(SQUAD)——在<a class="ae ky" href="http://creativecommons.org/licenses/by-sa/4.0/legalcode" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 4.0 </a>许可下发布——可在https://rajpurkar.github.io/SQuAD-explorer/获得</p><p id="feb9" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">[4]里贝罗。"<em class="nj">用亚马逊Lambda和API网关</em>构建无服务器API "<br/>https://towardsdatascience . com/Build-a-server less-API-with-Amazon-Lambda-and-API-Gateway-DFD 688510436</p><p id="54b5" class="pw-post-body-paragraph mo mp it lt b lu nb ju mq lw nc jx mr ly nd mt mu ma ne mw mx mc nf mz na me im bi translated">[5]里贝罗。"<em class="nj">py torch入门"<br/></em>https://towardsdatascience . com/Getting-started-with-py torch-2819 D7 aeb 87 c</p></div></div>    
</body>
</html>