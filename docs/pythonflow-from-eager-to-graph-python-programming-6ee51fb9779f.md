# Pythonflow:从渴望到图形 Python 编程

> 原文：<https://towardsdatascience.com/pythonflow-from-eager-to-graph-python-programming-6ee51fb9779f>

## Spotify 库概述

![](img/43aa38a5a3a3cac1afcc3611a57a34cb.png)

照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [Clément Hélardot](https://unsplash.com/@clemhlrdt?utm_source=medium&utm_medium=referral) 拍摄

正如开发者在官方[文档](https://pythonflow.readthedocs.io/en/latest/index.html)、**中所报道的，Pythonflow** 是一个数据流编程的 Python 库，其语法与 **Tensorflow** 在图形类型上非常相似。这个库，简单但在我看来极其强大，是为人工智能模型预处理流程(管道)而设计的。在最初的目标中，出现了:

*   ✅ **管理**特别繁重的逻辑和数学运算链
*   ✅能够执行图中包含的子操作，具有强大的**调试**和计算优化潜力
*   ✅并行化、**分布式计算**，以及跨多台机器的工作负载分割

但是让我们后退一步，理解我是如何以及为什么会遇到这个工具的。

## 图形执行和数据流编程:为什么

我遇到这个工具是一种需要的结果。作为一名 Python/AI 工程师和开发人员，经常需要优化自己的工作流程。

在为工程界开发人工智能算法的过程中，肯定会遇到一些这样的问题:

*   ⏰**优化**开发计算时间
*   💻保存过去完成的工作，并在新的问题上利用它
*   🎯**管理源自点云、视频流、图像的大型数据集**

工作流水线可以被解释为一系列相互连接的连续操作，其中每个操作都是独立的，能够读取输入数据流并输出多个输出。从脚本优化的角度来看，数据流编程允许轻松地将工作管道从一个项目转移到另一个项目，只改变一些输入参数(我称之为**占位符**和**常量**)或链的一个或多个操作。

就**开发时间**而言，处理大量数据可能是一个大问题，这个问题在初始开发阶段最为明显，在此期间，在远程机器或云上启动我们的批处理工作管道之前，操作将被一个接一个地调试以验证其有效性。使用图形，我们可以完全简化编程、导出和整个图形，并仅在需要时部分或完全执行它。

此外，**连接多个图形**的可能性成倍地增加了这种编程的通用性。

> 目标是开发**我的管道**，通过一次编程，然后在未来的新项目中重用它们，简单地使用过去制作的子图组装一个新的整体图，旨在作为一系列工作的、独立的和互连的操作。

![](img/1169ed4d40e9fa0bfc223ec3ed6a9387.png)

照片由 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的 [Thibault Penin](https://unsplash.com/@thibaultpenin?utm_source=medium&utm_medium=referral) 拍摄

语法，正如我们将看到的，非常简单，但我认为这个库的真正有效性可能来自它的图形包装(我正在研究，将来会告诉你)。它的脚本使用被开发人员变得非常简单和直观，但是对于复杂工作流的参数化实现来说，语法往往变得沉重和乏味，特别是如果像我一样，您需要连接几十个不同的图形。

## Pythonflow 库:主要特性

安装非常简单:作为 pip 上的一个包，准备好我们的 python/conda 环境(或 Colab 笔记本)就足够了。

```
(venv) >>> pip install pythonflow
```

我预料到了我基于数据流进行 python 编程的原因。但是，这涉及到编程模式的改变，可以总结为两个步骤:

*   📈定义定义我们工作流的操作的 **DAG** (直接非循环图)
*   🏃🏼‍♂️ **通过给占位符赋值来评估图形。**

图( **DAG** )由一系列用边连接的节点(操作)组成。

[](https://en.wikipedia.org/wiki/Directed_acyclic_graph#/media/File:Tred-G.svg) [## 有向无环图-维基百科

### 在数学中，特别是图论和计算机科学中，有向无环图(dag 或 DAG)是一个有向无环图。

en.wikipedia.org](https://en.wikipedia.org/wiki/Directed_acyclic_graph#/media/File:Tred-G.svg) 

> 当 Pythonflow 对一个操作求值时，它会检查当前的`context`是否为该操作提供了一个值，如果可能就立即返回。如果当前的`context`没有为操作提供值，Pythonflow 将评估操作的依赖关系，评估感兴趣的操作，将计算出的值存储在上下文中，并返回该值。

在该图中，可以实例化**操作**、**占位符、**或**常量**，每一个都用唯一自动生成的标识符或我们指定的名称进行唯一标识。

> Pythonflow 将强制要求名称确实是唯一的。

*   ⚖️ A **常量**是我们图形中的一个参数，我们不希望通过外部调用以任何方式改变它
*   💡一个**占位符**是一个我们希望在调用我们的图形时动态变化的参数
*   🐍一个**操作**是任何 Python 函数、语句、类...

这最后一点在我看来是最有趣的。可以执行简单的 Python 构建，也可以包装任何库(甚至是人工智能库，如 Tensorflow 或 Pytorch ),并创建复杂的类和宏来组成我们的图。

## Pythonflow 的多功能性

该库允许我们用三种不同的复杂程度包装 python 代码。

> 我们可以使用`pf.func_op`类从一个可调用对象创建一个操作。

必须考虑的一个方面是，操作只执行一次，然后保存在缓存中。这一方面极大地优化了我们的代码，尤其是在运算量很大的情况下。

同时，如果我们需要包装我们的一个函数，可以使用一个[](https://peps.python.org/pep-0318/)****。`opmethod`的参数不是强制性的:指定`length`参数可以解包操作。****

****我认为这是这个库的真正潜力，也就是将我们的图形片段组合成一系列复杂静态操作的可能性。为此，我们需要执行 pf.operation 类的子类化，如下例所示。****

****在这个简单的例子中，我创建了一个操作，将来自 **TensorFlow 的模板作为参数传递。Keras.models.Model** ，然后用指定的设置进行编译。****

****在工作流程的开发中，根据我们指定的参数(占位符)，可能需要执行图形的一部分或另一部分。Pythonflow 允许您使用 *pf.conditional* 处理条件操作，只执行您需要完成的那部分图形。****

****就像在我们的日常代码中一样，我们将需要**处理异常**，并且只在某些部分执行失败时才执行部分代码****

****如上所述，该库自动且有效地定义了要执行的操作序列。然而，在某些情况下，指定依赖链可能是有用的。例如，官方文档中的示例显示了如何使用该功能进行调试。****

****让我们来谈谈**断言:**你要确保一切都按预期运行。让我们再次检查一下官方文档示例:****

****对我来说，执行代码的一个关键方面是监控执行时间和瓶颈。为此，该库实现了几个方便的分析系统。这些回调(上下文管理器)必须接受两个参数:被分析的操作和上下文。****

# ****创建管道:使用 Tensorflow 进行培训****

****在这一节中，我提出了一个非常简单的例子，这个例子是我为我们的人工智能管道应用 Pythonflow 而做的，展示了我认为的优势。****

****你可以在这里找到完整的示例代码。目标是展示如何创建一个简单的 DAG(带有一些额外的功能)专门用于人工智能，生成一个参数序列模型，并使用 Keras Functional API 对一些简单数据进行训练。****

****[](https://github.com/GitMarco27/TMML/blob/main/Notebooks/012_pythonflow.ipynb) [## TMML/012_pythonflow.ipynb 在主 GitMarco27/TMML

### 3 分钟机器学习。通过在 GitHub 上创建帐户，为 GitMarco27/TMML 的发展做出贡献。

github.com](https://github.com/GitMarco27/TMML/blob/main/Notebooks/012_pythonflow.ipynb) 

和往常一样，我使用 Google Colab 创建简短的代码和示例。默认情况下不会安装 Pythonflow，所以您需要安装这个依赖项。

## 定制模块化张量流运算

如上所述，利用 Pythonflow 开发者提供的不同语法，有可能以几种方式实现我们的直接非循环操作图。在这个例子中，我使用了 pf 的继承。操作类来实现我的工作流链中的三个基本操作:

*   创建参数化 Keras 模型(带有密集层)
*   编译模型
*   对一系列时期的(虚拟)数据进行训练

注意，需要多次指定我们自定义操作的参数:在 **__init__** 中，在 **super、**中，然后在 **_evaluate** 函数中。然而，在后者中，可以用我们熟悉的 Python 语法指定任何操作链。

*   第一个函数允许将一个 [**密集**](https://keras.io/api/layers/core_layers/dense/) 层添加到传入的通用模型中，具有指定数量的神经元和激活函数。
*   第二个类**用默认参数编译**我们的模型:优化器(Adam)和损失函数(mse)。
*   最后一个以参数化的方式执行通用模型的**训练**:它读入特征、标签、训练时间和批量。

这个琐碎的例子是可以优化改进的，但是在我看来，一个致胜的理念浮现出来了:e **非常定制的操作，做好了就是独立。它读取一组输入(依赖项)并返回一组输出，在几个工作链中变得可重用。**

## 图形生成

对于 **DAG** 的生成，有必要定义一组占位符、操作、常量以及它们之间的交互。显然，没有必要为占位符指定一个值，因为只有在执行图形时才会给它们赋值。

由于 *pf.func_op* ，输入层被实例化，这是一种特别方便包装单个可调用程序的语法，而 Tensorflow 模型(Keras)的生成、编译和训练的剩余部分是通过前面介绍的自定义操作来执行的。

在这个简单的例子中，数据是在图中生成的(使用 numpy 随机生成输入/输出集)。

> **注意**:一个优点是可以生成整个图，但是调用图内的任何中间对象总是可以的。Pythonflow 将确定依赖关系链，并且在计算上只高效地执行获得该值所必需的操作。

## **Extra n 1** :嵌套图。

在给出的代码中，输入数据的大小是通过**另一个图**指定的:这允许我展示如何以一种**递归方式**链接操作图，释放与我们工作链的模块化相关的大量潜力。

## 运行我们的图表

要执行该图，必须指定要提取的值(通过在图生成期间指定的名称)、依赖链中所需占位符的值以及任何分析器和回调。

让我们检查一下模型摘要:

或者开始虚拟数据的训练:

## 额外的 n 2: pickle 并重新加载图表

这个库使得使用 **pickle** 导出我们的图形变得容易。

 [## pickle - Python 对象序列化- Python 3.10.4 文档

### 编辑描述

docs.python.org](https://docs.python.org/3/library/pickle.html) 

我发现这非常有用:例如，让我们考虑在我们的本地机器上创建一个复杂的模块化操作图:我们可以**导出图**并且**使用简单的命令在**远程机器**上执行**。

## 额外的 n 3:在单独的线程上运行

Pythonflow 允许您在一个**外部线程**上运行您的图形，从而允许您利用进程**并行化**和**避免在运行长工作链时冻结**我们的应用程序。

在上面的例子中，我们在一个单独的线程上运行简单的基于密集的模型的生成、编译和简单训练，监视进程的数量。如果需要，我们可以存储进程的 PID 来处理它。

# 总结

在本文中，我们已经讨论了 **Pythonflow** ，它的潜力，语法，并且我们已经从官方文档中看到了一些例子。然后，我们看到了一个生成人工智能工作流的简单示例和一些在我们日常工作中有用的额外功能。

📚在我的[个人资料](https://marcosanguineti.medium.com/)上阅读更多文章

📨成为电子邮件订阅者，了解最新动态

💻加入媒体没有阅读限制

✏️对疑点或新内容的评论

下次见，马可****