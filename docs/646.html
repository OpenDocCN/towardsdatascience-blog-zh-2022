<html>
<head>
<title>RNN: Recurrent Neural Networks — How to Successfully Model Sequential Data in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RNN:递归神经网络——如何在Python中成功地对序列数据建模</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rnn-recurrent-neural-networks-how-to-successfully-model-sequential-data-in-python-5a0b9e494f92#2022-01-23">https://towardsdatascience.com/rnn-recurrent-neural-networks-how-to-successfully-model-sequential-data-in-python-5a0b9e494f92#2022-01-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="de9d" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">神经网络</h2><div class=""><h1 id="ea9f" class="pw-post-title jc jd iu bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">RNN:递归神经网络——如何在Python中成功地对序列数据建模</h1></div><div class=""><h2 id="70b5" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">rnn的可视化解释和使用Keras和Tensorflow Python库构建它们的逐步指南</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/d1bedd4529eecdad9cad838d641bd73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcSfOV1EQet0EeFY1m1jPA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">递归神经网络。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h1 id="d5ff" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated"><strong class="ak">简介</strong></h1><p id="7b87" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">对序列数据进行建模和预测需要一种不同于标准回归或分类的方法。幸运的是，一种被称为递归神经网络(RNNs)的特殊类型的神经网络就是为此目的而专门设计的。</p><p id="4d97" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在本文中，我将介绍RNNs的结构，并给出一个完整的例子，说明如何在Python中使用Keras和Tensorflow构建一个简单的RNN。</p><p id="65ab" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果你不熟悉神经网络的基本结构，你可能更愿意先熟悉一下<a class="ae li" rel="noopener" target="_blank" href="/feed-forward-neural-networks-how-to-successfully-build-them-in-python-74503409d99a">前馈</a>和<a class="ae li" rel="noopener" target="_blank" href="/deep-feed-forward-neural-networks-and-the-advantage-of-relu-activation-function-ff881e58a635">深度前馈</a> NNs。</p><h1 id="9517" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">内容</h1><ul class=""><li id="6eb4" class="nc nd iu md b me mf mh mi mk ne mo nf ms ng mw nh ni nj nk bi translated">看看机器学习的世界</li><li id="3868" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">递归神经网络的体系结构</li><li id="0291" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">如何建立和训练你自己的RNN的Python例子</li></ul><h1 id="2eb3" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">看看机器学习的世界</h1><p id="9e3d" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">虽然神经网络最常以监督的方式使用带标签的训练数据，但我觉得它们独特的机器学习方法值得单独归类。</p><p id="0c70" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">递归神经网络有自己的子分支，由简单RNNs、LSTMs(长短期记忆)和GRUs(门控递归单元)组成。</p><p id="0588" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">下图是<strong class="md je">交互式的，</strong>所以请点击不同的类别来<strong class="md je">放大并展示更多的</strong>👇。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">机器学习算法分类。由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>创作的互动图表。</p></figure><p id="c72e" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你喜欢数据科学和机器学习</em> </strong> <em class="ns">，请</em> <a class="ae li" href="https://solclover.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <em class="ns">订阅</em> </a> <em class="ns">获取我的新文章邮件。</em></p><h1 id="d293" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">递归神经网络的结构</h1><p id="68ce" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">首先，让我们提醒自己典型的前馈神经网络是什么样子的。请注意，它可以包含任意数量的输入节点、隐藏节点和输出节点。下面的2–3–2结构纯粹是为了说明。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nt"><img src="../Images/86dc090103cca5d3773ee9236c483369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BYChMVYqzMKgQlZm7sWow.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">简单的前馈神经网络结构。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="0661" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，如果我们看看RNN，我们会注意到一个细微的差别。RNN内部的隐藏单元有一个内置的反馈回路，使信息能够多次传回同一个节点。这些隐藏单元通常被称为<strong class="md je">循环单元</strong>。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nu"><img src="../Images/52219d7e4585900c9695f3205af6e827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88v6lf17GqXSIPnQNA5ktQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">简单递归神经网络结构。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="d7fa" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">递归单元处理预定数量的<strong class="md je">时间步长</strong>的信息，每次通过激活功能传递该特定时间步长的隐藏状态和输入。</p><blockquote class="nv"><p id="7f01" class="nw nx iu bd ny nz oa ob oc od oe mw dk translated"><strong class="ak">时间步长</strong> —通过循环单元对输入进行单次处理。例如，如果您只有一个时间步长，那么您的输入将只被处理一次(相当于常规的隐藏节点)。如果您有七个时间步长，那么您的输入将被处理七次。</p></blockquote><p id="bbd6" class="pw-post-body-paragraph mb mc iu md b me of ke mg mh og kh mj mk oh mm mn mo oi mq mr ms oj mu mv mw in bi translated">请参见下图，该图显示了循环单元内部的反馈回路:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ok"><img src="../Images/3183c76ab4a60e55476cb7a90b7d496a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EazeM37LTXIh_xyOW4tHg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">时间步长t处的循环单元操作。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="518c" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">注意，在初始时间步，隐藏状态h0被初始化为0。接下来，输出<strong class="md je">(在<em class="ns"> t+1 </em>处的隐藏状态<em class="ns">h</em>)</strong>被传递回递归单元，并与以下输入一起被再次处理:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ol"><img src="../Images/8fd9b8236f8cdc7a4a05c4e4baa28e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rIM1dp9cGq0nMP1Qvk1iw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">时间步长t+1的循环单元操作。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="4e76" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">重复该过程，直到达到指定的时间步长数。</p><p id="f162" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们把所有这些联系起来，看看一个简单的RNN有一个输入、一个隐藏节点(包含三个时间步长)和一个输出会是什么样子。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj om"><img src="../Images/88e59ab13f5fac9ac2e4947b7efcd40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_uC3OI1LxRSYTfURDyuLg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">递归单元的展开。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="367c" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">为了更详细地解释发生了什么，让我们看一个简单的例子。</p><p id="e3f2" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">假设您想根据过去三天的气温序列来预测明天的气温。然后:</p><ul class=""><li id="64ad" class="nc nd iu md b me mx mh my mk on mo oo ms op mw nh ni nj nk bi translated"><strong class="md je">输入</strong> —虽然您可能只有一个输入节点，但您必须传递三个数字的序列作为您的输入，因为这是递归层所需要的，即[x0，x1，x2]，…，[x_{n-2}，x_{n-1}，x_{n}]。</li><li id="5b27" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">递归层</strong> —在典型的前馈神经网络中，隐藏节点有两个参数:权重和偏差。然而，递归层有三个参数<strong class="md je">需要优化:输入权重、隐藏单元权重和偏差。注意，即使你有十个时间步长，它仍然是三个参数。</strong></li><li id="5309" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><strong class="md je">训练</strong> —使用反向传播算法训练典型的前馈神经网络。与此同时，训练RNN使用稍微修改的反向传播版本，其中包括及时展开来训练网络的权重。该算法基于计算梯度向量，简称为<strong class="md je">时间反向传播</strong>或<strong class="md je"> BPTT </strong>。</li></ul><p id="f554" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在您已经熟悉了一个简单RNN的架构，让我们来看一个Python示例。</p><div class="kt ku kv kw gu ab cb"><figure class="oq kx or os ot ou ov paragraph-image"><a href="https://solclover.com/membership"><img src="../Images/63320331b74bd98eea6402472b4209ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qkXay39OnVc2IosW6rkxtw.png"/></a></figure><figure class="oq kx or os ot ou ov paragraph-image"><a href="https://www.linkedin.com/in/saulius-dobilas/"><img src="../Images/60fb21d1cb2701bfb6b71f61c99403e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vabxOXtQ4T034N_mscHSmQ.png"/></a></figure></div><h1 id="d780" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">如何建立和训练你自己的RNN的Python例子</h1><h2 id="560a" class="ow lk iu bd ll ox oy dn lp oz pa dp lt mk pb pc lv mo pd pe lx ms pf pg lz ja bi translated">设置</h2><p id="7e80" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们需要以下数据和库:</p><ul class=""><li id="5bd7" class="nc nd iu md b me mx mh my mk on mo oo ms op mw nh ni nj nk bi translated"><a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank">来自Kaggle </a>的澳大利亚天气数据(许可:<a class="ae li" href="http://www.bom.gov.au/other/copyright.shtml?ref=ftr" rel="noopener ugc nofollow" target="_blank">知识共享</a>，数据原始来源:<a class="ae li" href="http://www.bom.gov.au/climate/data/" rel="noopener ugc nofollow" target="_blank">澳大利亚联邦气象局</a>)。</li><li id="8051" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用于数据操作的<a class="ae li" href="https://pandas.pydata.org/docs/" rel="noopener ugc nofollow" target="_blank">熊猫</a>和<a class="ae li" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a></li><li id="5c32" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>用于数据可视化</li><li id="042d" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://www.tensorflow.org/api_docs/python/tf" rel="noopener ugc nofollow" target="_blank">用于递归神经网络的Tensorflow/Keras </a></li><li id="cbb2" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn库</a>，用于将数据拆分为<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html?highlight=train_test_split#sklearn.model_selection.train_test_split" rel="noopener ugc nofollow" target="_blank">训练测试</a>样本，用于数据缩放(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank">最小最大缩放器</a>)，以及用于附加模型评估(<a class="ae li" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.mean_squared_error.html" rel="noopener ugc nofollow" target="_blank">均方误差</a>)</li></ul><p id="70e1" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们导入所有的库:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><p id="784f" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上面的代码打印了本例中使用的包版本:</p><pre class="kt ku kv kw gu pi pj pk pl aw pm bi"><span id="c135" class="ow lk iu pj b gz pn po l pp pq">Tensorflow/Keras: 2.7.0<br/>pandas: 1.3.4<br/>numpy: 1.21.4<br/>sklearn: 1.0.1<br/>plotly: 5.4.0</span></pre><p id="d3b9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们下载并获取澳大利亚的天气数据(来源:<a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>)。我们还执行一些简单的数据操作，并导出一个新的变量(中间温度)供我们使用。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pr"><img src="../Images/fb79d977e5fe8401df04d215d5ac1669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyNHscXSi2MQCtPthd6fnQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">一小段<a class="ae li" href="https://www.kaggle.com/jsphyg/weather-dataset-rattle-package" rel="noopener ugc nofollow" target="_blank"> Kaggle的澳大利亚天气数据</a>做了一些修改。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="d9c9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">假设数据包含澳大利亚多个地方的天气信息，让我们选择一个城市(堪培拉)并在图表上绘制每日中值温度。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ps"><img src="../Images/f94afe9aebf8d9c9f1337335b98cbb8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emphrFrroTrXKKZiw_SI1w.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">堪培拉的日平均气温。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h2 id="59db" class="ow lk iu bd ll ox oy dn lp oz pa dp lt mk pb pc lv mo pd pe lx ms pf pg lz ja bi translated">训练和评估递归神经网络(RNN)</h2><p id="af19" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在我们训练和评估我们的递归神经网络之前，我们需要创建一个函数来帮助我们重塑数据，以遵循所需的格式。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><p id="f836" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上述函数可以重构任意数量时间步长的数据。例如，由于我使用了七个时间步长(即，一系列7天的温度来预测第二天的气温)，它将像这样分割数据:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pt"><img src="../Images/59f6817091a36108682d9f941682a868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5gBrwymD4RDCmy66pASyg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">说明如何为RNN重新构建顺序数据。图片来自<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="8732" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在我们可以训练和评估我们的RNN。我们在这个例子中使用了一个极其简单的神经网络，它有四层，每层只有一个节点。通过添加额外的层、节点或改变激活函数，您可以随意进行试验。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pu"><img src="../Images/492a14e1301f2067d3377ddcf2c168cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLC4GIlT2PhFV2Y2IPgNAA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">示例中使用的RNN的结构。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="28f9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我对下面的代码做了大量的注释，以便让您清楚地理解每个部分的作用。因此，我不会在文章正文中重复同样的内容。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><p id="7fd4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上述代码为我们的递归神经网络打印了以下摘要和评估指标:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pv"><img src="../Images/8bf1883917d2296c4c8518901a48963a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nf4_mfe9joFV2lIcFY_WFg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">递归神经网络性能。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="f85b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在让我们将结果绘制在图表上，并比较实际值和预测值。注意，我们使用<strong class="md je"> inverse_transform </strong>函数将目标和预测从缩放(我们在训练RNN之前使用了MinMaxScaler)转换到原始值范围。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pw"><img src="../Images/2582781af507814dae5f83935a66d8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjIvyKUbWctqjINbC7hI5w.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">RNN模型对试验数据的预测。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="05de" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">以上结果是针对测试数据集的。预测看起来相当准确，但是请记住，我们在每种情况下都取7个先前的数据点，并且只预测下一个。因此，如果我们试图预测未来的多个时间点，这个特定模型的结果会不太准确，我将在后面的示例中展示这一点。</p><h2 id="6b47" class="ow lk iu bd ll ox oy dn lp oz pa dp lt mk pb pc lv mo pd pe lx ms pf pg lz ja bi translated"><strong class="ak">使用RNN生成预测</strong></h2><p id="e0c2" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您会记得，在上述模型的训练和预测过程中，我们将序列中的每第8个观察值作为目标。但是，如果我们想用这个模型为我们的数据框架中的每一项(每一天)生成预测呢？下面的代码正是这样做的:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><p id="3ef4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">因为我们将模型预测添加到了原始数据框架中，所以我们可以使用它来绘制结果。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj px"><img src="../Images/20b26092ae08b4fe140672b99b71b466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKHKznBGUAa-Uoj6L0k49g.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">整个数据样本的RNN模型预测。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="bdde" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">再次，相当不错的结果记住，我们只预测未来一天的温度。</p><p id="4a29" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果我们试图预测未来365天的温度，一次预测一天的温度，会怎么样？我们将尝试在7天序列中反复添加新的预测，同时从序列中删除最早的预测。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ph nr l"/></div></figure><p id="cd0a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">最后，我们重用上一步中的图表绘制代码来显示过去两年的结果和未来365天的预测。</p><pre class="kt ku kv kw gu pi pj pk pl aw pm bi"><span id="f24c" class="ow lk iu pj b gz pn po l pp pq">replace:<br/>x=dfCan['Date'] → x=dfCan2['Date'][-730:] # for both traces<br/>y=dfCan['MedTemp'] → y=dfCan2['MedTemp'][-730:] # for first trace<br/>y=dfCan['MedTemp_prediction'] → y=dfCan2['MedTemp_prediction'][-730:] # for second trace</span></pre><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj py"><img src="../Images/7cc3abb7a73bcb523ac9241dbee322e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b4eudxvRIZj3sSNQyO9gQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">RNN模型对未来365天的预测。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="66b9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我们可以看到，使用现有的RNN模型进行任何长于<em class="ns">日+1 </em>的预测都是不明智的。这种结果的原因是，我们设计它只是为了提前一天进行预测，并且部分受到具有相对“短记忆”的RNNs的影响。</p><p id="9d4d" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在即将到来的文章中，我将分析更高级版本的递归神经网络，如<strong class="md je"> LSTM(长短期记忆)</strong>和<strong class="md je"> GRU(门控递归单元)</strong>，所以不要忘记<a class="ae li" href="https://solclover.com/subscribe" rel="noopener ugc nofollow" target="_blank">订阅</a>不要错过它们。</p><h1 id="58d3" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">结束语</h1><p id="244d" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我真诚地希望你喜欢阅读这篇文章，并获得一些新的知识。</p><p id="0597" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">请使用本文提供的代码来构建您自己的递归神经网络。你可以在我的<a class="ae li" href="https://github.com/SolClover/Art043_NN_Recurrent_Neural_Networks" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到完整的Jupyter笔记本。</p><p id="fae4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在我努力让我的文章对读者更有用的时候，如果你能让我知道是什么驱使你阅读这篇文章，以及它是否给了你想要的答案，我将不胜感激。如果不是，缺少什么？</p><p id="1889" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">干杯！👏<br/> <strong class="md je">索尔·多比拉斯</strong></p></div><div class="ab cl pz qa hy qb" role="separator"><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe"/></div><div class="in io ip iq ir"><p id="41a6" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你已经花光了这个月的学习预算，下次请记得我。</em> </strong> <em class="ns">我的个性化链接加盟媒介:</em></p><div class="qg qh gq gs qi qj"><a href="https://solclover.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="qk ab fp"><div class="ql ab qm cl cj qn"><h2 class="bd je gz z fq qo fs ft qp fv fx jd bi translated">通过我的推荐链接加入Medium索尔·多比拉斯</h2><div class="qq l"><h3 class="bd b gz z fq qo fs ft qp fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qr l"><p class="bd b dl z fq qo fs ft qp fv fx dk translated">solclover.com</p></div></div><div class="qs l"><div class="qt l qu qv qw qs qx lc qj"/></div></div></a></div></div><div class="ab cl pz qa hy qb" role="separator"><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe qf"/><span class="qc bw bk qd qe"/></div><div class="in io ip iq ir"><p id="04c8" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">您可能感兴趣的其他文章:</p><div class="qg qh gq gs qi qj"><a rel="noopener follow" target="_blank" href="/feed-forward-neural-networks-how-to-successfully-build-them-in-python-74503409d99a"><div class="qk ab fp"><div class="ql ab qm cl cj qn"><h2 class="bd je gz z fq qo fs ft qp fv fx jd bi translated">前馈神经网络——如何在Python中成功构建它们</h2><div class="qq l"><h3 class="bd b gz z fq qo fs ft qp fv fx dk translated">使用真实数据的Python示例对神经网络进行了详细的图形说明</h3></div><div class="qr l"><p class="bd b dl z fq qo fs ft qp fv fx dk translated">towardsdatascience.com</p></div></div><div class="qs l"><div class="qy l qu qv qw qs qx lc qj"/></div></div></a></div><div class="qg qh gq gs qi qj"><a rel="noopener follow" target="_blank" href="/deep-feed-forward-neural-networks-and-the-advantage-of-relu-activation-function-ff881e58a635"><div class="qk ab fp"><div class="ql ab qm cl cj qn"><h2 class="bd je gz z fq qo fs ft qp fv fx jd bi translated">深度前馈神经网络及其再激活函数的优势</h2><div class="qq l"><h3 class="bd b gz z fq qo fs ft qp fv fx dk translated">如何使用Tensorflow Keras API在Python中构建深度前馈(DFF)神经网络，以及如何在…</h3></div><div class="qr l"><p class="bd b dl z fq qo fs ft qp fv fx dk translated">towardsdatascience.com</p></div></div><div class="qs l"><div class="qz l qu qv qw qs qx lc qj"/></div></div></a></div><div class="qg qh gq gs qi qj"><a rel="noopener follow" target="_blank" href="/lle-locally-linear-embedding-a-nifty-way-to-reduce-dimensionality-in-python-ab5c38336107"><div class="qk ab fp"><div class="ql ab qm cl cj qn"><h2 class="bd je gz z fq qo fs ft qp fv fx jd bi translated">LLE:局部线性嵌入Python中降维的好方法</h2><div class="qq l"><h3 class="bd b gz z fq qo fs ft qp fv fx dk translated">详细介绍了LLE的工作原理，以及它与Isomap等类似算法的比较</h3></div><div class="qr l"><p class="bd b dl z fq qo fs ft qp fv fx dk translated">towardsdatascience.com</p></div></div><div class="qs l"><div class="ra l qu qv qw qs qx lc qj"/></div></div></a></div></div></div>    
</body>
</html>