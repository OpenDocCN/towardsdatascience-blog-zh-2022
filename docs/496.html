<html>
<head>
<title>Boosting Machine Learning Workflows with GPU-Accelerated Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">借助GPU加速库提升机器学习工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/boosting-machine-learning-workflows-with-gpu-accelerated-libraries-1f95feef68d4#2022-01-17">https://towardsdatascience.com/boosting-machine-learning-workflows-with-gpu-accelerated-libraries-1f95feef68d4#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/228295b8f64c1c867f4ce3710e101ad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OSL8VpAbP8V930yWunCyA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">专题图片(图片来源:<a class="ae jd" href="https://unsplash.com/photos/A1blvxJxGU0" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/photos/A1blvxJxGU0</a></p></figure><div class=""><h1 id="2155" class="pw-post-title je jf jg bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">借助GPU加速库提升机器学习工作流</h1></div><div class=""><h2 id="8eac" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">在Pagerank上测试RAPIDS套件以获得推荐</h2></div><p id="718a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lr">摘要:在本文中，我们演示了如何使用RAPIDS库来改进基于机器学习CPU的库，如pandas、sklearn和NetworkX。我们使用一个推荐研究案例，在运行PageRank算法时，它在基于GPU的库中的执行速度提高了44倍，在个性化PageRank中的执行速度提高了39倍。</em></p><h1 id="ba85" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">急流简介</h1><p id="30d6" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Scikit-learn和Pandas是大多数数据科学家工具箱的一部分，因为它们友好的API和广泛的有用资源——从模型实现到数据转换方法。然而，许多这样的库仍然依赖于CPU处理，并且，就<a class="ae jd" href="https://scikit-learn.org/stable/faq.html#will-you-add-gpu-support" rel="noopener ugc nofollow" target="_blank">这个线程</a>而言，像Scikit-learn这样的库并不打算扩展到GPU处理或者扩展到集群处理。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9fa80ad312d19980b5a3b06986ed2b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*NXTz7u61CH1tUmiTGWtAOA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">编程语言的层次(图片由作者提供)。</p></figure><p id="dce0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了克服这个缺点，<a class="ae jd" href="https://rapids.ai/" rel="noopener ugc nofollow" target="_blank"> RAPIDS </a>提供了一套Python开源库，采用这些广泛使用的数据科学解决方案，并通过包含GPU加速的实现来提升它们，同时仍然提供类似的API。因此，你可以继续呆在你的Python舒适区，使用他们的高级编程接口，而不是一路学习C/C++或CUDA这样的低级语言。</p><p id="9d02" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一些属于RAPIDS的库和它们基于CPU的对应物(可用API的完整列表在这里<a class="ae jd" href="https://docs.rapids.ai/api" rel="noopener ugc nofollow" target="_blank">提供</a>):</p><ul class=""><li id="457a" class="mu mv jg kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated">熊猫</li><li id="9961" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">cuML (Sklearn)</li><li id="dc68" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">cuGraph(网络x)</li><li id="ac52" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">客户空间(地理信息系统)</li></ul><p id="065c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以这篇文章的目的是让你对一些RAPIDS包能做什么有一点了解，并对它们进行测试以检查它们有多快。所以让我们看看他们有什么！</p><h1 id="569d" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">为推荐引擎测试RAPIDS</h1><p id="8426" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们将通过构建一个推荐引擎来展示RAPIDS的功能，该引擎可以推荐类似于目标标题的电影——您可能已经在您最喜欢的流媒体服务中的某个地方看到了“<em class="lr">谁观看了…也观看了… </em>”类型的推荐。为此，让我们使用PageRank算法！</p><blockquote class="ni nj nk"><p id="7909" class="kv kw lr kx b ky kz kh la lb lc kk ld nl lf lg lh nm lj lk ll nn ln lo lp lq ij bi translated">简而言之，PageRank算法通过在其结构中执行随机行走并计算给定节点被访问的次数来估计图中节点的重要性，并且我们使用该重要性分数来对推荐系统中的项目进行排名。</p></blockquote><p id="0f64" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">互联网上有很多理解PageRank算法的资料，但是对于本文来说，重要的是:其中涉及到大量的数学知识，主要是大量的<strong class="kx jh">矩阵运算</strong>。猜猜什么在解决矩阵运算时会派上用场？没错，pal:<strong class="kx jh">GPU</strong>！</p><p id="8e1f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此我们可以创建一个图表，其中:</p><ul class=""><li id="d025" class="mu mv jg kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated">节点是电影</li><li id="f3cb" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">边将电影与普通用户消费(观看电影A和B的用户)联系起来，其中用户数量可以是边的权重。</li></ul><p id="72a3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的图让我们对图表的表示有所了解:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/c585a5838f27a4ffb5b72ada06b71bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9ER-w-v1lBqneXX7rDicg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">按共有用户数量链接的电影图表。电影“614”和电影“50”共有92个用户(图片由作者提供)。</p></figure><p id="63e0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了概念图的模型，让我们深入一些数据，看看一些行动正在发生！</p><h2 id="43e2" class="np lt jg bd lu nq nr dn ly ns nt dp mc le nu nv me li nw nx mg lm ny nz mi oa bi translated">cuDF</h2><p id="58eb" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae jd" href="https://docs.rapids.ai/api/cudf/stable/" rel="noopener ugc nofollow" target="_blank"> cuDF </a>是一种针对熊猫的GPU加速方法，它的开发是为了尽可能平滑地进行代码转换。我们可以从<a class="ae jd" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank"> MovieLens </a>数据集加载一些数据，如下例所示:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">cuDF和pandas方法读取csv文件的比较。</p></figure><p id="fb6b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们加载了两个数据集:一个包含用户-项目交互(使用cudf并存储在<code class="fe od oe of og b">df</code>中)，另一个包含项目的元数据(使用pandas并存储在<code class="fe od oe of og b">df_metadata</code>中)。数据合并和聚合也可以使用熊猫传统的<code class="fe od oe of og b">merge</code>和<code class="fe od oe of og b">groupby</code>方法来完成:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">代码:使用cuDF执行数据合并和聚合</p></figure><p id="0d9c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于那些熟悉Pandas API的人来说，你可以检查一下这些接口有多熟悉，这样从基于CPU的库到基于GPU的库的迁移会快得多！这些转换的结果创建了以下邻接表:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图形邻接表</p></figure><p id="a156" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">邻接表指示节点<code class="fe od oe of og b">item_id_from</code>通过共有<code class="fe od oe of og b">n_users</code>而连接到节点<code class="fe od oe of og b">item_id_to</code>。</p><p id="70ea" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经存储了图形数据，让我们构建一些对象来表示它们！</p><h2 id="3979" class="np lt jg bd lu nq nr dn ly ns nt dp mc le nu nv me li nw nx mg lm ny nz mi oa bi translated">cuGraph</h2><p id="6d2d" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">就像cuDF与熊猫配对一样，<a class="ae jd" href="https://docs.rapids.ai/api/cugraph/stable/" rel="noopener ugc nofollow" target="_blank"> cuGraph </a>是NetworkX的GPU加速版本，NetworkX是一个基于CPU的库，具有大量从图形中提取信息的算法。</p><p id="20b6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了比较它们的实现，让我们为每个库创建一个graph对象，如下面的代码所示:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">使用cuGraph和NetworkX创建图形实例的比较。</p></figure><p id="5083" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，<code class="fe od oe of og b">G</code>是我们的cugraph。图形对象和<code class="fe od oe of og b">Gnx</code>是我们的networkx。图形对象。注意，当创建<code class="fe od oe of og b">Gnx</code>时，我们从包含邻接表的cuDF数据帧<code class="fe od oe of og b">df_items</code>中调用<code class="fe od oe of og b">.to_pandas()</code>方法(第9行)。这是因为NetworkX接受Pandas的数据帧作为输入，cuDF为我们提供了一些将数据对象从GPU移动到CPU内存的转换方法。</p><p id="69f3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经创建了图形实例，让我们通过使用它们的<code class="fe od oe of og b">pagerank</code>方法来比较算法实现！为了公平比较，我们将为这两种方法设置相同的参数:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">为每个库实现执行多次PageRank算法。电脑设置:Nvidia GeForce GTX 1060 (6GB内存)，CPU英特尔7700和32 GB内存。</p></figure><p id="69dd" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过执行算法10次(每次10个循环)并取其平均执行时间，我们得到以下性能图:</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/0298cc322f1dcebc18016374542c94fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*31tw1FG0KPrLHYvzHwuDIw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">图:NetworkX和cuGraph的执行时间(毫秒)性能—越低越好。</p></figure><p id="767a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是啊是啊，我知道！<strong class="kx jh"> cuGraph的实施平均运行时间为30毫秒，而NetworkX的运行时间为1350毫秒，执行时间提高了45倍</strong>…但我们还没有完全实现！标准的PageRank算法确实估计了图中一个节点的重要性，但是记住我们正在尝试解决“<em class="lr">谁看了…也看了… </em>”类型的推荐？如果我们使用到目前为止获得的pagerank分数，我们将对所有推荐列表有相同的分数！因此，我们需要更多地搅动事物，让推荐更加……<strong class="kx jh">个性化</strong>。</p><h2 id="9e7e" class="np lt jg bd lu nq nr dn ly ns nt dp mc le nu nv me li nw nx mg lm ny nz mi oa bi translated">个性化页面排名的测试平台</h2><p id="1c68" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">还记得我们之前对PageRank算法的(超级浓缩的)解释中，我们在图中执行随机行走吗？在随机漫步的开始，我们随机选择一个节点作为起点，让自然去做它的工作——但所有节点都有相等的概率成为起点。如果一些节点有更高的概率成为起点呢？如果我们时不时地回到那个节点，从头再来，又会怎么样呢？</p><p id="b2c2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是个性化PageRank算法背后的主要思想，我们可以用它来计算与特定目标节点相关的pagerank，在我们的例子中，这是一部pivot电影。因此，我们总是可以重新启动随机漫步机，并设置100%的概率从我们选择的节点开始。</p><p id="7769" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们可以对目录中的每部电影执行PageRank算法，但在整个算法执行过程中，将从该电影开始的概率设置为100%,如下面的代码所示:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">代码:个性化PageRank:我们设定100%的概率从一个目标item_id开始。</p></figure><p id="1f1a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法的问题是，我们必须为目录中的每个项目运行该算法，因此pagerank执行时间在这种情况下起着关键作用。为了测试这种影响，下面的代码为每个项目调用pagerank，并多次执行该过程:</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="ob oc l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">代码:使用cuGraph和NetworkX对每个项目(存储在df_metadata中)执行PageRank。</p></figure><p id="e9db" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到<strong class="kx jh">对于cuGraph实施，循环遍历整个目录平均花费了1分钟5秒，而NetworkX的实施平均花费了39分钟8秒</strong><strong class="kx jh">——因此我们在执行时间上有了39倍的改进。</strong></p><p id="ad0c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">除了<strong class="kx jh">用GPU扩展</strong>你的工作流程，RAPIDS还促进了与<strong class="kx jh"> Dask </strong>到<strong class="kx jh">横向扩展</strong>到多台机器的集成。因此，如果您的数据集不适合您的GPU和内存，您可以使用多个GPU的能力来扩展您的内存可用性并克服硬件限制。如果你想了解更多，你可以查看这篇文章。</p><h1 id="1dd5" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">(次要)缺点</h1><p id="caa1" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">通过对广泛使用的ML算法提供GPU加速的改进，RAPIDS似乎是数据科学家工具包的一个有前途的替代方案。但是，有几点值得注意。</p><p id="0211" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您在Google Cloud或Amazon Web Services等平台上运行作业，让GPU实例运行您的算法对项目成本起着至关重要的作用——特别是如果您打算在Dask中使用多GPU进程。因为这个问题，有些人甚至不会想到设置这些实例，但是我想说这里最重要的事情是:分析权衡！也许让您的流程运行速度加快40倍会节省一些实例正常运行时间，这样额外的成本就不会那么大了。</p><p id="8a59" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，请记住，有些算法还没有在RAPIDS套件中实现，所以在某些情况下，您仍然需要依赖基于CPU的库。然而，我想说，弥合这些差距只是时间问题。事实上，根据他们的<a class="ae jd" href="https://docs.rapids.ai/overview" rel="noopener ugc nofollow" target="_blank">文档</a>，他们力争每6周发布一次更新，所以希望随着时间的推移，我们会有越来越多的解决方案。</p><h1 id="76b2" class="ls lt jg bd lu lv lw lx ly lz ma mb mc km md kn me kp mf kq mg ks mh kt mi mj bi translated">参考</h1><p id="9332" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果您想了解他们的最新版本或用例，您可以关注<a class="ae jd" href="https://medium.com/rapids-ai" rel="noopener"> RAPIDS medium profile </a>或查看我在下面列出的一些参考资料:</p><ul class=""><li id="8b85" class="mu mv jg kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><a class="ae jd" href="https://youtu.be/T2AU0iVbY5A" rel="noopener ugc nofollow" target="_blank">激流勇进</a></li><li id="1293" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">雅各布·汤姆林森关于急流和达斯克的<a class="ae jd" href="https://jacobtomlinson.dev/posts/" rel="noopener ugc nofollow" target="_blank">博客文章</a>和<a class="ae jd" href="https://www.youtube.com/watch?v=KHiPWQlppWQ&amp;ab_channel=TechExeter" rel="noopener ugc nofollow" target="_blank">视频</a></li><li id="0586" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">NVIDIA <a class="ae jd" href="https://developer.nvidia.com/nvidia-merlin" rel="noopener ugc nofollow" target="_blank"> Merlin </a>框架构建大规模推荐系统</li></ul></div></div>    
</body>
</html>