<html>
<head>
<title>Shortest path algorithm with OSM walking network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OSM步行网络的最短路径算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/shortest-path-algorithm-with-osm-walking-network-6d2863ae96be#2022-01-04">https://towardsdatascience.com/shortest-path-algorithm-with-osm-walking-network-6d2863ae96be#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="add0" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">基于OSM步行网络的最短路径算法</h1></div><div class=""><h2 id="0c14" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用爱沙尼亚塔尔图的OSM数据寻找最短步行路径</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fd24432d94adcaec19e21bc7ca10493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bm4-P08Bh6NWp99NN5DQ-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。OSM网络行走路线数据。从亲吻学生到塔尔图市的咖啡馆。</p></figure><p id="c1e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我终于回到了爱沙尼亚的文化之都塔尔图。美好思想之城神奇而辉煌。到处都是咖啡馆、酒吧、餐厅、文化活动和绿地。塔尔图为国际学生提供了一个舒适的城市校园，充满活力的氛围，我最喜欢的是，你可以步行到达大多数地方。令人惊讶的是，通过使用城市自行车、螺栓踏板车或仅仅通过步行，在城市中的移动是如此顺畅。</p><p id="2c5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个城市有很多地方可以参观，我决定用OSM步行网络来量化它。在这个故事中，我将解释如何在塔尔图的OSM步行网络中使用最短路径算法。主要的想法是量化从主要聚会点<strong class="la iu"> <em class="lu">、接吻的学生</em> </strong>到从OSM数据中提取的所有咖啡馆的距离。</p><p id="b596" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看这个故事的结局。</p><ul class=""><li id="34dd" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><a class="ae me" href="https://bryanvallejo16.github.io/shortest-walking-path-tartu/" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">最终网络地图</strong> </a></li><li id="8b98" class="lv lw it la b lb mf le mg lh mh ll mi lp mj lt ma mb mc md bi translated"><a class="ae me" href="https://github.com/bryanvallejo16/shortest-walking-path-tartu" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">仓库代码</strong> </a></li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/6cadde316d25d2d7a023026c028fb44c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IioicqdtwDoZmVbmMnHzNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。带有OSM步行网络和最短路径的最终地图</p></figure><h1 id="a9f0" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">最短路径算法代码</h1><p id="de8a" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">要应用最短路径算法，你需要起点和终点。这些功能已经实现自动化，并在<a class="ae me" href="https://medium.com/geospatial-analytics" rel="noopener">地理空间分析</a>中发布。查看下面的文章，我是从哪里获取这些函数的。它们可用于OSM网络类型，如驾驶、自行车和步行。</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/geospatial-analytics/shortest-path-algorithm-used-in-osm-street-network-33e0f864f34b" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">最短路径算法在OSM街道网中的应用</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">针对汽车、自行车和行人的最短路径分析的GIS自动化提示</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com/geospatial-analytics</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div><p id="28e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最短路径算法在由Geoff Boeing 开发的python库OSMnx中实现，它获取开放的街道地图数据。</p><h1 id="b676" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">OSM数据许可证</h1><ul class=""><li id="0f1b" class="lv lw it la b lb nd le ne lh oc ll od lp oe lt ma mb mc md bi translated"><strong class="la iu">打开街道地图数据。</strong>根据<a class="ae me" href="https://opendatacommons.org/licenses/odbl/" rel="noopener ugc nofollow" target="_blank">开放数据共享开放数据库许可证(ODbl) </a>或归属许可证获得许可。用户可以自由复制、分发、传输和改编这些数据，只要这些数据属于作者，就像<a class="ae me" href="https://www.openstreetmap.org/copyright" rel="noopener ugc nofollow" target="_blank"> OpenStreetMap </a>的贡献者一样。</li></ul><p id="3372" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于从OSM获取数据的回顾可以在下一篇文章中回顾:</p><div class="ni nj gp gr nk nl"><a href="https://medium.com/geekculture/fetching-green-areas-from-osm-data-a6ff835c40dc" rel="noopener follow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">从OSM数据中提取绿色区域</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">如何使用OSMnx以几何图形的形式检索公园</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">medium.com</p></div></div><div class="nu l"><div class="of l nw nx ny nu nz ks nl"/></div></div></a></div><h1 id="cfd5" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">编码实践</h1><p id="d97c" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">我们开始吧。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="97e6" class="ol mm it oh b gy om on l oo op"><strong class="oh iu">import </strong>pandas <strong class="oh iu">as </strong>pd<br/><strong class="oh iu">import </strong>geopandas <strong class="oh iu">as </strong>gpd<br/><strong class="oh iu">from </strong>shapely.geometry <strong class="oh iu">import </strong>LineString, Point<br/><strong class="oh iu">import </strong>osmnx <strong class="oh iu">as </strong>ox<br/><strong class="oh iu">import </strong>networkx <strong class="oh iu">as </strong>nx<br/><strong class="oh iu">import </strong>matplotlib.pyplot <strong class="oh iu">as </strong>plt</span></pre><p id="9d21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有步行路线的起点将是接吻学生纪念碑。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="5c4c" class="ol mm it oh b gy om on l oo op"><strong class="oh iu"># creating the origin from Kissing Students<br/></strong>origin = gpd.GeoDataFrame(columns = [‘name’, ‘geometry’], crs = 4326, geometry = ‘geometry’)<br/>origin.at[0, ‘geometry’] = Point(26.722181, 58.380073)<br/>origin.at[0, ‘name’] = ‘Kissing students’</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d7a7ed835d939db784208eb0a665594c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUzFzl9r_trwLwm1hwiqmA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。亲吻学生纪念碑。</p></figure><p id="c932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们要去塔尔图城所有的咖啡馆。我们将使用这些位置作为最短路径分析的目的地。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="0a50" class="ol mm it oh b gy om on l oo op"><strong class="oh iu"># fetching cafes as the destinations from OSM</strong></span><span id="e8ec" class="ol mm it oh b gy or on l oo op"><strong class="oh iu"># Specify the name that is used to seach for the data<br/></strong>place_name = ‘Tartu, Tartu linn, Tartu maakond, Estonia’</span><span id="360c" class="ol mm it oh b gy or on l oo op"><strong class="oh iu"># Fetch OSM street network from the location<br/></strong>graph = ox.graph_from_place(place_name)</span><span id="53f9" class="ol mm it oh b gy or on l oo op"><strong class="oh iu"># Get place boundary related to the place name as a geodataframe<br/></strong>area = ox.geocode_to_gdf(place_name)</span><span id="58f7" class="ol mm it oh b gy or on l oo op"><strong class="oh iu"># Plot the streets<br/></strong>fig, ax = ox.plot_graph(graph)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/107f5fe08a293a4dbba2f47a76457c1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*fAYZKqhuAZs6wxPXgMcpAQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。塔尔图的OSM图。</p></figure><p id="4ea1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从Tartu区域获取数据。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="8e71" class="ol mm it oh b gy om on l oo op"><strong class="oh iu"># List key-value pairs for tags<br/></strong>tags = {'amenity': 'cafe'}</span><span id="99a6" class="ol mm it oh b gy or on l oo op"><strong class="oh iu"># Get the data<br/></strong>cafes = ox.geometries_from_place(place_name, tags)</span><span id="ba42" class="ol mm it oh b gy or on l oo op">cafes = cafes[['name', 'geometry']]<br/>cafes = cafes.reset_index(drop=True)</span><span id="f95e" class="ol mm it oh b gy or on l oo op"><strong class="oh iu"># getting centroids from polygons to avoid polygon geometric objects<br/></strong>cafes['geometry'] = [geom.centroid for geom in cafes['geometry']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ac60d677e8861dc702d0656cd19f9bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uytaqyq-ryaT98t4yzaQ-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。根据OSM的数据，塔尔图市有43家咖啡馆</p></figure><p id="c8f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我定义了在有起点和终点的步行网络中应用最短路径的函数。该函数是从<a class="ae me" href="https://medium.com/geospatial-analytics/shortest-path-algorithm-used-in-osm-street-network-33e0f864f34b" rel="noopener"> <strong class="la iu"> <em class="lu">条最短路径算法得到的，用于OSM街道网络</em> </strong> </a> <strong class="la iu"> <em class="lu">。</em> </strong>做查看Github repo这个故事的查看功能。该分析直接返回UTM投影中的路线。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="b367" class="ol mm it oh b gy om on l oo op">def <strong class="oh iu">shortest_path</strong>(origin, destination, network = ‘drive’):<br/> ‘’’<br/><strong class="oh iu">origin and destination &lt;GeoDataFrame&gt; crs 4326, network &lt;str&gt; drive, bike, walk<br/>RETURN shortest path &lt;GeoDataFrame&gt;</strong><br/> ‘’’<br/> <br/> <strong class="oh iu"># creating a frame for fetching OSM data</strong><br/> combined = origin.append(destination)<br/> <br/> convex = combined.unary_union.convex_hull<br/> <br/> graph_extent = convex.buffer(0.02)<br/> <br/> <strong class="oh iu"># fetching graph</strong><br/> graph = ox.graph_from_polygon(graph_extent, network_type= network)<br/> <br/> <strong class="oh iu"># Reproject the graph</strong><br/> graph_proj = ox.project_graph(graph)<br/> <br/> <strong class="oh iu"># Get the edges as GeoDataFrame</strong><br/> edges = ox.graph_to_gdfs(graph_proj, nodes=False)<br/> <br/> <strong class="oh iu"># Get CRS info UTM</strong><br/> CRS = edges.crs<br/> <br/> <strong class="oh iu"># Reproject all data</strong><br/> origin_proj = origin.to_crs(crs=CRS)<br/> destination_proj = destination.to_crs(crs=CRS)<br/> <br/> <strong class="oh iu"># routes of shortest path</strong><br/> routes = gpd.GeoDataFrame()<br/> <br/> <strong class="oh iu"># Get nodes from the graph</strong><br/> nodes = ox.graph_to_gdfs(graph_proj, edges=False)<br/> <br/> <strong class="oh iu"># Iterate over origins and destinations</strong><br/> for oidx, orig in origin_proj.iterrows():<br/> <br/>   <strong class="oh iu"># Find closest node from the graph → point = (latitude, longitude)</strong><br/>   closest_origin_node = ox.get_nearest_node(G=graph_proj, point=(orig.geometry.y, orig.geometry.x), method=’euclidean’)<br/> <br/><strong class="oh iu">   # Iterate over targets<br/></strong>    for tidx, target in destination_proj.iterrows():<br/>      <strong class="oh iu"># Find closest node from the graph → point = (latitude, longitude)</strong><br/>      closest_target_node = ox.get_nearest_node(graph_proj, point=(target.geometry.y, target.geometry.x), method=’euclidean’)      <strong class="oh iu"># Check if origin and target nodes are the same → if they are → skip</strong><br/>      if closest_origin_node == closest_target_node:<br/>          print(“Same origin and destination node. Skipping ..”)<br/>          continue<br/> <br/><strong class="oh iu">       # Find the shortest path between the points<br/></strong>       route = nx.shortest_path(graph_proj, <br/> source=closest_origin_node, <br/> target=closest_target_node, weight=’length’)<br/> <br/><strong class="oh iu">       # Extract the nodes of the route<br/></strong>       route_nodes = nodes.loc[route]<br/> <br/><strong class="oh iu">       # Create a LineString out of the route<br/></strong>       path = LineString(list(route_nodes.geometry.values))<br/> <br/><strong class="oh iu">       # Append the result into the GeoDataFrame<br/></strong>       routes = routes.append([[path]], ignore_index=True)<strong class="oh iu"> # Add a column name<br/></strong> routes.columns = [‘geometry’]<br/> <br/><strong class="oh iu"> # Set coordinate reference system<br/></strong> routes.crs = nodes.crs<strong class="oh iu"> # Set geometry<br/></strong> routes = routes.set_geometry(‘geometry’)<br/> <br/> <strong class="oh iu">return </strong>routes</span></pre><p id="5700" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们就应用它。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="5d46" class="ol mm it oh b gy om on l oo op">routes = shortest_path(origin, cafes, network = 'walk')</span></pre><p id="9c65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将返回一个包含43条路线的地理数据框架，我们可以在其中计算距离。</p><pre class="kj kk kl km gt og oh oi oj aw ok bi"><span id="70eb" class="ol mm it oh b gy om on l oo op">routes['distance'] = routes['geometry'].length</span></pre><p id="891d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一张柱状图中，我们可以观察到咖啡馆是如何集中在行走的前1.000m。大约20分钟的路程？它有一些例外，有些咖啡馆离得很远，也可以在地图上看到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/3953146c232ca11a2e0857f1d030782a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*90rmVkX1PsDKtyDSZRUxeQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。从接吻的学生到咖啡馆的步行距离直方图</p></figure><p id="87e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一张地图显示了距离的强度。红色是最长的步行路线。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/e9bd79f757bf17ed19947c10eab3427b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5WxkUzpW70WTsUvk2uf1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。从接吻的学生到咖啡馆的步行路线按距离分类</p></figure><p id="b942" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想回顾行走的网络。请检查一下这个故事的笔记本，看看它是如何被提取的。下一张地图显示了提取的步行网络的广度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/e18d9054d8c233688e02df22dd6300a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7Y0EzRI052PtYpqXy-EGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。围绕使用的起点和终点的步行网络。</p></figure><h1 id="c31d" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="9275" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">塔尔图是一座步行的城市。如果你在市中心附近，在最近的500米到1000米范围内，你会有很多咖啡馆可供选择。因此，在接下来的5分钟、10分钟、20分钟内，你会看到坐下来喝杯咖啡的选项。上面的直方图可以从接吻的学生开始给出一个快速概览。python库OSMnx在分析咖啡馆等服务的可访问性时很有用。可达性可以通过步行、驾车或骑自行车的距离来衡量。如果在OSM数据中没有找到所有服务，或者如果您希望不仅通过距离而且通过时间来分析可达性，则会发现局限性。</p></div></div>    
</body>
</html>