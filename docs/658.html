<html>
<head>
<title>Playing Moneyball: Creating an efficient NBA team with linear programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">玩钱球:用线性规划创建一个高效的NBA团队</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/playing-moneyball-creating-an-efficient-nba-team-with-linear-programming-ef14f6383861#2022-01-23">https://towardsdatascience.com/playing-moneyball-creating-an-efficient-nba-team-with-linear-programming-ef14f6383861#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a2343e6926e24fb9662637ae5a639e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMPJrTtK-3GSDXAfJAeDTA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">鸣谢:<a class="ae jd" href="https://unsplash.com/photos/XmYSlYrupL8" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@jcgellidon" rel="noopener ugc nofollow" target="_blank"> JC Gellidon </a>(照片在Unsplash许可下免费使用)</p></figure><div class=""><h1 id="1933" class="pw-post-title je jf jg bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated"><strong class="ak">玩钱球:用线性规划打造一支高效的NBA球队</strong></h1></div><p id="0d73" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于任何热衷于分析的体育迷来说，班尼特·米勒执导的2011年美国体育剧《T2》是一部必看的电影。根据<a class="ae jd" href="https://www.imdb.com/title/tt1210166/" rel="noopener ugc nofollow" target="_blank"> IMDB </a>中的描述，在这里我们可以看到“奥克兰运动家队总经理比利·比恩通过使用计算机生成的分析来获得新球员，成功地尝试以精简的预算组建一支棒球队”的故事。即使没有在专业运动队担任数据科学家的工作(肯定是我梦想的工作之一)，我们也可以用这部电影来学习线性编程。</p><p id="b4dd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://www.britannica.com/science/linear-programming-mathematics" rel="noopener ugc nofollow" target="_blank">大英百科全书</a>将线性规划定义为“一种数学建模技术，其中一个线性函数在受到各种约束时被最大化或最小化”。因此，我们将尝试优化一个线性函数(我们称之为目标函数)。但是，我们的解决方案必须有一定的条件，称为约束(重要的是要提到，这些约束也将是线性函数)。考虑到这一点，我们可以说线性规划是在<strong class="kf jh">规定分析</strong>中使用的一种方法，因为它明确地告诉我们哪一个是我们可以优化特定指标的最佳解决方案。由于目标函数和约束都将由决策变量组成(每个变量代表一个要做出的单独决策)，为了解决我们的问题，我们将有三个步骤:变量定义、约束创建和目标函数定义。</p><h2 id="2cf8" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">问题和变量定义</strong></h2><p id="8b9b" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们将尝试使用从basketball-reference.com检索的<a class="ae jd" href="https://www.basketball-reference.com/leagues/NBA_2021_per_game.html" rel="noopener ugc nofollow" target="_blank">标准统计数据</a>、<a class="ae jd" href="https://www.basketball-reference.com/leagues/NBA_2021_advanced.html" rel="noopener ugc nofollow" target="_blank">高级统计数据</a>和<a class="ae jd" href="https://www.basketball-reference.com/contracts/players.html" rel="noopener ugc nofollow" target="_blank">工资信息</a>，并使用谷歌开发的开源优化库OR Tools，来建立一支高效的NBA球队，而不是建立一支棒球队。然而，在开始定义我们的相关变量之前，我们做了一些数据预处理，创建了一个字典，其中包含每个球员的重要信息，包括他的姓名、位置、三分球命中率、工资、每场比赛的得分和per(根据维基百科，这是“霍林格的全能篮球评级，试图将球员的所有贡献归结为一个数字”)，以及一个包含每个位置上的球员信息的字典。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4ea8" class="lc ld jg mf b gy mj mk l ml mm"><em class="lb"># We import the libraries we will use</em><br/><strong class="mf jh">import</strong> os <br/><strong class="mf jh">from</strong> ortools.linear_solver <strong class="mf jh">import</strong> pywraplp<br/><strong class="mf jh">import</strong> pandas <strong class="mf jh">as</strong> pd<br/><strong class="mf jh">import</strong> numpy <strong class="mf jh">as</strong> np</span><span id="ec42" class="lc ld jg mf b gy mn mk l ml mm"><em class="lb"># We will use three DFs: one containing "advanced" NBA stats, one that will have "standard" stats and </em><br/><em class="lb"># one that has salaries information</em><br/>cwd <strong class="mf jh">=</strong> os<strong class="mf jh">.</strong>getcwd()<br/>cwd <strong class="mf jh">=</strong> cwd<strong class="mf jh">.</strong>replace("code", "data")<br/><br/>df_advanced <strong class="mf jh">=</strong> pd<strong class="mf jh">.</strong>read_csv(f"{cwd}/nba_2021_advanced_stats.csv", sep<strong class="mf jh">=</strong>";")<br/>df_standard <strong class="mf jh">=</strong> pd<strong class="mf jh">.</strong>read_csv(f"{cwd}/nba_2021_standard_stats.csv", sep<strong class="mf jh">=</strong>";")<br/>df_salaries <strong class="mf jh">=</strong> pd<strong class="mf jh">.</strong>read_csv(f"{cwd}/nba_2022_salaries.csv", sep<strong class="mf jh">=</strong>";")</span><span id="53f2" class="lc ld jg mf b gy mn mk l ml mm"><em class="lb"># We filter relevant columns</em><br/>df_advanced <strong class="mf jh">=</strong> df_advanced[["Player", "Code", "Pos", "PER"]]<br/>df_standard <strong class="mf jh">=</strong> df_standard[["Player", "Code", "G", "MP", "3P%", "PTS"]]<br/>df_salaries <strong class="mf jh">=</strong> df_salaries[["Player", "Code", "2021-22"]]<strong class="mf jh">.</strong>rename(columns<strong class="mf jh">=</strong>{"2021-22": "Salary"})</span><span id="4bf9" class="lc ld jg mf b gy mn mk l ml mm"><em class="lb"># We merge all dataframes</em><br/>df <strong class="mf jh">=</strong> pd<strong class="mf jh">.</strong>merge(df_advanced, df_standard, how<strong class="mf jh">=</strong>"inner", on<strong class="mf jh">=</strong>["Player", "Code"])<br/>df <strong class="mf jh">=</strong> pd<strong class="mf jh">.</strong>merge(df, df_salaries, how<strong class="mf jh">=</strong>"inner", on<strong class="mf jh">=</strong>["Player", "Code"])<br/>df <strong class="mf jh">=</strong> df<strong class="mf jh">.</strong>drop_duplicates()<strong class="mf jh">.</strong>reset_index(drop<strong class="mf jh">=True</strong>)</span><span id="aea8" class="lc ld jg mf b gy mn mk l ml mm"><em class="lb"># We filter rows, keeping players that played at least ten matches, and played at least 5 minutes per game</em><br/>df <strong class="mf jh">=</strong> df[(df["G"] <strong class="mf jh">&gt;=</strong> 10) <strong class="mf jh">&amp;</strong> (df["MP"] <strong class="mf jh">&gt;=</strong> 5)]</span><span id="c7ce" class="lc ld jg mf b gy mn mk l ml mm"><em class="lb"># We create an index column and filter Pos column</em><br/>df["idx"] <strong class="mf jh">=</strong> df<strong class="mf jh">.</strong>index<br/>df["Pos"] <strong class="mf jh">=</strong> df["Pos"]<strong class="mf jh">.</strong>str<strong class="mf jh">.</strong>slice(stop<strong class="mf jh">=</strong>2)<br/>df["Pos"] <strong class="mf jh">=</strong> df["Pos"]<strong class="mf jh">.</strong>str<strong class="mf jh">.</strong>replace('-','')</span><span id="3c59" class="lc ld jg mf b gy mn mk l ml mm"><em class="lb"># We create a dictionary that has information about the players, with a key indicating the index in df</em><br/><em class="lb"># Also, we create a dictionary that has information on each player's position</em><br/>players_dict <strong class="mf jh">=</strong> {}<br/>positions_dict <strong class="mf jh">=</strong> {}<br/><br/><em class="lb"># We fill information on players and positions</em><br/><strong class="mf jh">for</strong> index, row <strong class="mf jh">in</strong> df<strong class="mf jh">.</strong>iterrows():<br/>    players_dict[row["idx"]] <strong class="mf jh">=</strong> {<br/>        "name": row["Player"],<br/>        "Pos": row["Pos"],<br/>        "PER": row["PER"],<br/>        "3P%": row["3P%"],<br/>        "PTS": row["PTS"],<br/>        "Salary": row["Salary"]<br/>    }<br/>    pos <strong class="mf jh">=</strong> row["Pos"]<br/>    <strong class="mf jh">if</strong> pos <strong class="mf jh">not</strong> <strong class="mf jh">in</strong> positions_dict<strong class="mf jh">.</strong>keys():<br/>        positions_dict[pos] <strong class="mf jh">=</strong> [row["idx"]]<br/>    <strong class="mf jh">else</strong>:<br/>        positions_dict[pos]<strong class="mf jh">.</strong>append(row["idx"])</span></pre><p id="13e7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了建立我们的团队，我们将决定哪些球员包括在内。因此，<strong class="kf jh">我们的决策变量，称为<em class="lb"> xi </em>，将是布尔型的，并且如果玩家<em class="lb"> i </em>被选入我们的团队</strong>的话，将等于1。既然我们已经定义了它，我们可以创建我们的求解器并创建一个字典，我们将在其中保存我们的布尔决策变量:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b585" class="lc ld jg mf b gy mj mk l ml mm"><em class="lb"># We create our variables and add it to a dictionary</em><br/><strong class="mf jh">def</strong> create_solver_and_player_assignment_variable(df):<br/>    <em class="lb"># We create the solver</em><br/>    solver <strong class="mf jh">=</strong> pywraplp<strong class="mf jh">.</strong>Solver('simple_mip_program',<br/>                             pywraplp<strong class="mf jh">.</strong>Solver<strong class="mf jh">.</strong>CBC_MIXED_INTEGER_PROGRAMMING)<br/>    <em class="lb"># We create the variables</em><br/>    x_var_dict <strong class="mf jh">=</strong> {}<br/>    <strong class="mf jh">for</strong> index, row <strong class="mf jh">in</strong> df<strong class="mf jh">.</strong>iterrows():<br/>        x_var_dict[row['idx']] <strong class="mf jh">=</strong> solver<strong class="mf jh">.</strong>BoolVar(str('x_'<strong class="mf jh">+</strong>str(row['idx'])))<br/>    <strong class="mf jh">return</strong> x_var_dict, solver</span></pre><h2 id="583c" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">约束创建</strong></h2><p id="b31e" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在我们已经创建了线性规划问题和与之相关的变量，我们将定义我们的解决方案必须满足的条件或约束。记住这些<strong class="kf jh">约束必须是线性的</strong>，所以变量只能乘以一个常数，而不能平方，等等。</p><p id="d97a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们必须拥有所需的总玩家数量，在13到15人之间。在数学上，这可以用下面的等式来表示:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/75396be907e2d998fd5ac77782074769.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*1Byip6gY6P8LnPAP5Bps1g.png"/></div></figure><p id="e154" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个方程中，我们可以确定方程的三个不同的“部分”:一个下限(13)，一个上限(15)，以及决策变量的线性组合。当我们使用OR工具创建约束时，我们分两步完成:首先，我们定义约束，选择边界，并可选地选择约束的名称，然后我们“填充”决策变量的线性组合，选择变量和相关系数(这里，由于每个变量都是直接添加的，因此该系数等于1)。这可以在下面的代码中看到:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="bb09" class="lc ld jg mf b gy mj mk l ml mm"><strong class="mf jh">def</strong> total_players_constraint(solver, x_var_dict):<br/>    ct <strong class="mf jh">=</strong> solver<strong class="mf jh">.</strong>Constraint(13, 15, 'TotalPlayers')<br/>    <strong class="mf jh">for</strong> x <strong class="mf jh">in</strong> x_var_dict<strong class="mf jh">.</strong>keys():<br/>        ct<strong class="mf jh">.</strong>SetCoefficient(x_var_dict[x], 1)<br/>    <strong class="mf jh">return</strong> solver</span></pre><p id="647a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我们拥有所需数量的球员，我们也必须为所有位置配备球员。假设对于每个位置，我们必须至少有两个球员。因此，我们可以用数学方法来表达这一点，例如，对于在控卫位置上打球的一组球员<em class="lb"> PG、</em>:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/e3f1531b2e134ae8e7a5516ad91d6bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*PLdbNMdD9RBDxMrj4SbKsg.png"/></div></figure><p id="2628" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，这里我们没有像前一个例子那样的上限。但是，由于我们的玩家不能超过15人，我们将使用该数字作为上限:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2d60" class="lc ld jg mf b gy mj mk l ml mm"><strong class="mf jh">def</strong> players_per_position(solver, x_var_dict, positions_dict):<br/>    <strong class="mf jh">for</strong> position <strong class="mf jh">in</strong> positions_dict<strong class="mf jh">.</strong>keys():<br/>        ct <strong class="mf jh">=</strong> solver<strong class="mf jh">.</strong>Constraint(2, 15, f'Players_Pos_{position}')<br/>        <strong class="mf jh">for</strong> x <strong class="mf jh">in</strong> positions_dict[position]:<br/>            ct<strong class="mf jh">.</strong>SetCoefficient(x_var_dict[x], 1)<br/>    <strong class="mf jh">return</strong> solver</span></pre><p id="ed8d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们在总数和每个位置上都有了所需的球员数量。然而，由于NBA有工资帽，球员工资总额不能超过1.124亿美元。由于这是我们团队必须满足的一个条件，我们将把它包含在我们的模型中，并以数学方式表示如下:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/cc48aca24aac947b5533741e86a8268e.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*ciXTh6mzdTYH0zKl-K0dfw.png"/></div></div></figure><p id="849b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，当我们创建此约束时，与每个决策变量相关联的系数并不像前面的情况那样是1，而是每个玩家的薪金，如下面的代码所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d79d" class="lc ld jg mf b gy mj mk l ml mm"><strong class="mf jh">def</strong> total_salary(solver, x_var_dict, players_dict):<br/>    ct <strong class="mf jh">=</strong> solver<strong class="mf jh">.</strong>Constraint(0, 112400000, 'TotalSalary')<br/>    <strong class="mf jh">for</strong> x <strong class="mf jh">in</strong> x_var_dict<strong class="mf jh">.</strong>keys():<br/>        ct<strong class="mf jh">.</strong>SetCoefficient(x_var_dict[x], players_dict[x]["Salary"])<br/>    <strong class="mf jh">return</strong> solver</span></pre><p id="be7e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有了所有的约束，让我们建立一个有效的团队。然而，线性规划的一个积极的方面是，由于它是一个实际问题的数学抽象，它非常灵活，如果我们想的话，它允许我们轻松地包含新的和定制的约束。例如，考虑到近年来，三分球在联盟中变得越来越重要，让我们假设我们希望我们的球队中至少有4名优秀的三分球射手(假设优秀的三分球射手是投篮命中率大于40%的人)。如果这个三分射手在set <em class="lb"> T </em>中，我们可以用数学方法来表示:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/181b11b43a80963bc4c3009ff331e93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*0sUr3Js1NG4_ga3Q4C0eLQ.png"/></div></figure><p id="fe59" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该约束将按如下方式实现:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="23b7" class="lc ld jg mf b gy mj mk l ml mm"><strong class="mf jh">def</strong> three_points_shooters(solver, x_var_dict, players_dict):<br/>    ct <strong class="mf jh">=</strong> solver<strong class="mf jh">.</strong>Constraint(4, 15, 'ThreePointsShooters')<br/>    <strong class="mf jh">for</strong> x <strong class="mf jh">in</strong> x_var_dict<strong class="mf jh">.</strong>keys():<br/>        <strong class="mf jh">if</strong> players_dict[x]["3P%"] <strong class="mf jh">&gt;</strong> 0.4:<br/>            ct<strong class="mf jh">.</strong>SetCoefficient(x_var_dict[x], 1)<br/>    <strong class="mf jh">return</strong> solver</span></pre><h2 id="e844" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">建立我们的目标函数</strong></h2><p id="bc00" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">既然我们已经具备了解决方案必须满足的条件(三个必须具备，一个可选)，那么我们就可以定义我们的目标了。请记住，我们正努力打造一支尽可能高效的团队。回想一下，每个玩家都有一个与其相关联的PER，这是一个总结其表现的单一指标。考虑到更大的PER会导致更高的预期效率，我们应该尝试拥有一个PER尽可能高的团队。这可以用以下方式进行数学表达:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/cd13cf027841c37558ff3aff7dbac5a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*KbPEBT1E_aJSv_GXnpfTuw.png"/></div></figure><p id="af76" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用或工具实现这一点，过程将类似于我们在定义约束时执行的过程，只是做了一些修改。首先，我们将定义目标函数，并用决策变量和相关系数(这里是每个玩家的PER)填充它。最后，我们将定义我们正在尝试做的事情，即最大化目标函数(在其他一些情况下，例如，当我们在目标函数中表示成本时，我们将尝试最小化它)。这可以在下面的代码中看到:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b12b" class="lc ld jg mf b gy mj mk l ml mm"><strong class="mf jh">def</strong> set_obj_function(solver, x_var_dict, players_dict):<br/>    objective <strong class="mf jh">=</strong> solver<strong class="mf jh">.</strong>Objective()<br/>    <strong class="mf jh">for</strong> x <strong class="mf jh">in</strong> x_var_dict<strong class="mf jh">.</strong>keys():<br/>        objective<strong class="mf jh">.</strong>SetCoefficient(x_var_dict[x], players_dict[x]["PER"])<br/>    objective<strong class="mf jh">.</strong>SetMaximization()<br/>    solver<strong class="mf jh">.</strong>Solve()<br/>    <strong class="mf jh">return</strong> solver, x_var_dict, objective</span></pre><h2 id="f16c" class="lc ld jg bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated"><strong class="ak">分析我们的解决方案和结束语</strong></h2><p id="b95b" class="pw-post-body-paragraph kd ke jg kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">现在我们已经定义了一切，我们可以解决我们的模型，并获得我们的完美团队！为了让事情变得更有趣，我们将运行模型的两个版本:一个不包含需要4个三分射手的约束，另一个包含。首先，让我们来看看这支不要求三分射手最低数量的球队:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/eb4f30a92921303dedbb54b6eafbce8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*2BxZt7aIQB88uAYjs1ulIw.png"/></div></figure><p id="20a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到NBA的最高工资约为4500万美元，我们可以看到我们的团队由两个主要群体组成:年轻的明星球员，他们的工资通常低于其他全明星球员(如锡安·威廉森、卢卡·东契奇和特雷·扬)，以及固定角色球员(如德维恩·戴德蒙和伊内斯·坎特)。唯一的“异数”是尼古拉·约基奇，他的薪水最高(也是最高的PER值)。</p><p id="dc8d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，当我们“激活”我们的三分射手限制时，我们的团队发生了一点变化:</p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/991db8d9301e5ef6d9761764fca15ea4.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*yrCPk0QSVgoi6GXE67cujw.png"/></div></figure><p id="dcd0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的新团队中，Paul Reed被Drew Eubanks取代，因此总PER从349.7和346.4降低。这是一个重要的见解:当我们在创建我们团队的约束时要求更高(我们不仅仅想要一个有效的团队，我们还想要一个至少有三分射手的团队)，合乎逻辑的是我们的解决方案的客观价值恶化。</p><p id="c4f0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，我们已经了解了线性编程问题的基础，并用python和OR工具构建了一个与体育相关的实现。我们还学习了这种方法的灵活性，并分析了带有和不带有定制约束的解决方案。最后，我留给您一个存储库，您可以在其中找到我用来构建它的代码和数据:</p><div class="ip iq gp gr ir mv"><a href="https://github.com/nicogarciaara/nba_moneyball" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jh gy z fp na fr fs nb fu fw jf bi translated">GitHub-nicogarciaara/NBA _ money ball</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ix mv"/></div></div></a></div></div></div>    
</body>
</html>