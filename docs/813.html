<html>
<head>
<title>Top 8 SQL Functions to Clean Raw Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理原始数据的8大SQL函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/top-8-sql-functions-to-clean-raw-data-2b6141de06a#2022-01-30">https://towardsdatascience.com/top-8-sql-functions-to-clean-raw-data-2b6141de06a#2022-01-30</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""><h1 id="a042" class="pw-post-title it iu iv bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">清理原始数据的8大SQL函数</h1></div><div class=""><h2 id="4e01" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">因为垃圾数据进来意味着垃圾数据出去。</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/2100f7969a9795e7113fb688abef8256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTV5zJRFM0XKgbYmPNNqrw.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated"><a class="ae la" href="https://unsplash.com/@uniqueton?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安东</a>在<a class="ae la" href="https://unsplash.com/s/photos/cleaning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="a46e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在一个完美的世界里，我们的数据从一开始就是干净的。不会有丢失的值。列将被转换为正确的类型。我们将能够执行聚合并在模型中使用数据，而无需做任何工作。</p><p id="910d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">不幸的是，原始数据可能非常混乱。如果在模型中使用数据之前，您从未需要对数据进行大量转换，那么您应该感到幸运。每个分析工程师都知道，为我们的分析师提供干净的数据是我们工作的一个关键部分。</p><p id="cebf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">混乱的数据输入意味着混乱的数据输出。您的数据模型的有效性和简洁程度取决于您加载到其中的数据。</p><p id="b661" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在本文中，我将简要介绍如何使用Airbyte轻松地从业务API中提取原始数据，并将它们接收到数据仓库中。然后，我将展示从Google Sheets提取原始数据到数据仓库时一些常见的数据质量问题。最后，我将向您介绍一些流行的SQL字符串函数来清理这些数据，并准备好供您的分析师使用。</p><h1 id="8fd9" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">将原始数据从Google Sheets加载到雪花</h1><p id="c420" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在转换原始数据之前，我们需要使用Airbyte提供的100个<a class="ae la" href="https://docs.airbyte.io/integrations" rel="noopener ugc nofollow" target="_blank">连接器中的一个来接收数据。确保你按照指示</a><a class="ae la" href="https://docs.airbyte.com/quickstart/deploy-airbyte" rel="noopener ugc nofollow" target="_blank">在本地设置Airbyte】并创建你的第一个数据连接器。</a></p><p id="9dad" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您还需要设置目的地，或者您希望将数据加载到的仓库。Airbyte在这里有关于如何做这个<a class="ae la" href="https://docs.airbyte.io/quickstart/add-a-destination" rel="noopener ugc nofollow" target="_blank">的详细说明。</a></p><p id="aa01" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当将数据加载到目的地时，您会注意到选择“基本规范化”的选项。通过选择此项，您将允许Airbyte创建适合您的数据及其目的地的模式和表。如果不选择规范化，您的数据将以JSON blob的形式作为一列上传。JSON blob只需要在我们这边做进一步的转换。让我们接受帮助，让Airbyte让我们的工作变得更容易！</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mu"><img src="../Images/5aa0a6e92d2cf2a8e8083fc42897d32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vEgiA9PWuVTeU76ESclm4g.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="ac63" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">值得注意的是，这个模式及其表将始终作为原始数据存在，由Airbyte直接接收。我们不会将我们的转换直接应用于这些表，而是将它们写在SQL文件中，用dbt运行。我们将在下一篇文章中详细介绍如何设置dbt源文件和基本模型。</p><p id="0b88" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，要知道你总是希望有一个数据库只是为了原始数据。这样，如果您需要更改您的转换，您可以这样做，而不必从Airbyte源连接器重新吸收数据。</p><p id="558f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">正如Airbyte的文件中所写的，</p><blockquote class="mv mw mx"><p id="ed29" class="lb lc my ld b le lf jw lg lh li jz lj mz ll lm ln na lp lq lr nb lt lu lv lw io bi translated">“ELT理念的一个核心原则是，数据在E和L阶段移动时应该保持不变，以便原始数据始终可以访问。”</p></blockquote><p id="e044" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在建立数据仓库时，请记住这一点。您应该有两个独立的数据库，一个用于原始数据，一个用于转换后的数据。</p><h1 id="c3ba" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">转换和清理原始数据</h1><p id="277f" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在本教程中，我从Google Sheet向Snowflake获取数据。你可以在<a class="ae la" href="https://docs.airbyte.com/integrations/sources/google-sheets" rel="noopener ugc nofollow" target="_blank"> Google Sheets source文档</a>和<a class="ae la" href="https://docs.airbyte.com/integrations/destinations/snowflake" rel="noopener ugc nofollow" target="_blank"> Snowflake destination文档</a>中找到更多关于设置Airbyte数据连接器的信息。</p><p id="8365" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">虽然Google sheets不是自动化和跟踪数据的最佳方式，但它们被经常使用。当你在一家小公司工作时，有时这是你必须跟踪不同信息的唯一解决方案，如营销预算、有影响力的联系人或产品成本。</p><p id="facd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">也就是说，来自Google sheets的数据是最难处理的数据之一。与Shopify和脸书等其他应用程序不同，这里没有检查。Google sheets容易出现大量人为错误。我曾多次遇到有人以错误的格式填写值，导致我们整个数据管道中断的情况。</p><p id="f084" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里有一个加载到雪花的Google Sheets数据集的例子，我将在本教程中使用:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nc"><img src="../Images/7830e06ace66258bf7bacec59da28286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sFBk4SdCiViwUWWrOwmcrw.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="cc4d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让我们看看我们在原始数据中看到的一些常见场景，以及我们如何将它们转换成可以在模型中使用的数据。内置的SQL字符串函数帮助您清理来自原始数据的字符串，以便在数据仓库中查询它们。</p><h1 id="c578" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">重命名列</h1><p id="8653" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">清理任何数据时，您要做的第一件事是将列名更改为对您的分析最有意义的名称。在这里，<strong class="ld iw"> date </strong>是一个跨表使用的常见关键字，所以您会希望将其更改为更具描述性。</p><p id="0a6c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">此外，我们希望将列名<strong class="ld iw">活动链接</strong>更改为没有空格或大写字母的名称。这将使我们的分析顺利。列名中的空格可能会导致将来的查询出现问题。我推荐使用大小写，或者单词间的下划线。您可以使用<code class="fe nd ne nf ng b">AS</code>语句轻松地重命名表列。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="ba42" class="nl ly iv ng b gy nm nn l no np">select<br/>  LCV AS lifetime_value,<br/>  date AS activation_date,<br/>  name,<br/>  email,<br/>  phone,<br/>  "Campaign Link" AS campaign_link<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="0d4d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">太棒了，现在我们可以轻松地在转换中使用这些列了！</p><h1 id="e3cc" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">将一列拆分为多列</h1><p id="b8de" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">让我们从查看<strong class="ld iw"> customer_name </strong>列开始。如您所见，它包含了名和姓。我们希望使用该列创建两个单独的列，<strong class="ld iw">名字</strong>和<strong class="ld iw">姓氏</strong>。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/15b940a86a01c3ebab8c68c6d79a98af.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*mFyJUA67Hzg50ajnTrsjBQ.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="eaa7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这就是<code class="fe nd ne nf ng b">split_part()</code>字符串函数派上用场的地方。我们指定要拆分的列、要拆分的字符，以及要将字符串放在该字符的右边还是左边。</p><p id="c955" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">1将给出空间左边的字符串，而-1将给出空间右边的字符串。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="f77a" class="nl ly iv ng b gy nm nn l no np">select<br/>  split_part(name, ' ', 1) AS first_name,<br/>  split_part(name, ' ', -1)    AS last_name<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="5aef" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们现在有两个单独的列，一个用于客户的名，一个用于客户的姓。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/47e38cf1599a71b17579f6ce34d4bb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*Qi3mDpyQQdVyQFZ2GtS47g.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><h1 id="ee57" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">改变案例</h1><p id="c8a0" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">现在，注意仍然有一些大写问题。为了便于分析，所有字符串都小写是有意义的。这样，在过滤或比较值时，您就不必担心字符串会成为问题。</p><p id="7a62" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们可以通过使用<code class="fe nd ne nf ng b">lower()</code>字符串函数来做到这一点。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="d52f" class="nl ly iv ng b gy nm nn l no np">select<br/>  lower(split_part(name, ' ', 1)) AS first_name,<br/>  lower(split_part(name, ' ', -1)) AS last_name<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_CUSTOMER_DETAILS;</span></pre><p id="3750" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">该查询会产生以下结果:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/d282e5369f37665a460fb19bc04a8eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*InxUElaKaZTRrZPQXFex8g.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="5701" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们的<strong class="ld iw">名字</strong>和<strong class="ld iw">姓氏</strong>列都是小写的。</p><h1 id="7a42" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">从字符串中提取值</h1><p id="3793" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">再来看看<strong class="ld iw"> campaign_link </strong>栏目。本专栏遵循从Google或Bing广告生成的典型链接的结构。这在市场营销中屡见不鲜，提取起来可能有点痛苦。</p><p id="a30a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">像这样从URL中提取字符串的关键是识别模式。在某些情况下，同一列中会有一些不同的模式。幸运的是，在这里，它是统一的。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0b088e80fc745d1097e9d53a77d43a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*3z5MlH_himq4zF0zGd7QSQ.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="16b4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们可以看到<strong class="ld iw"> utm_source </strong>总是在a之后？而在一个&amp;之前。<strong class="ld iw"> utm_medium </strong>跟在此&amp;之后，在另一个&amp;之前。最后，<strong class="ld iw"> utm_campaign </strong>跟在最后一个&amp;后面。我们需要使用<code class="fe nd ne nf ng b">split_part()</code>函数编写一些SQL代码，该函数使用这种模式提取每个值。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="d02d" class="nl ly iv ng b gy nm nn l no np">select<br/>  split_part(split_part("Campaign Link", 'utm_source=', -1), '&amp;', 1) AS utm_source,<br/>  split_part(split_part("Campaign Link", 'utm_medium=', -1), '&amp;', 1) AS utm_medium,<br/>  split_part(split_part("Campaign Link", 'utm_campaign=', -1), '&amp;', 1) AS utm_campaign<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_CUSTOMER_DETAILS;</span></pre><p id="22a9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当我们使用前面提到的相同的<code class="fe nd ne nf ng b">split_part()</code>字符串函数时，我们可以从包围它们的字符之间提取源、媒介和活动字符串。我们使用内部的<code class="fe nd ne nf ng b">split_part()</code>函数提取每个=右边的值，然后使用另一个函数提取下一个字符左边的值。</p><p id="b387" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这会产生三个新列:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nu"><img src="../Images/a02d7f5c3a5a42165752f4d7ba3a2f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnO-OPM4NqzU9l7fCqBlxw.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="4ba4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，原始活动链接的每个部分都有单独的列。</p><h1 id="408d" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">设置列条件</h1><p id="fe2a" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">再来看<strong class="ld iw"> lifetime_value </strong>一栏。我们知道该列必须包含数值，而不包含文本。然而，有一栏输入了随机的字母。为了进一步清理这个列，我们需要首先删除这个字符串值。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/81387718408335d3e61b1f517a32223e.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*f5vmyr843FAeNo55AnbfNA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="de6c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">Snowflake SQL dialect有一个名为<code class="fe nd ne nf ng b"><a class="ae la" href="https://docs.snowflake.com/en/sql-reference/functions/try_to_decimal.html" rel="noopener ugc nofollow" target="_blank">TRY_TO_NUMBER()</a></code>的方便的字符串函数，如果值是数字，它将值转换为数字，如果不是，则返回空值。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="e29e" class="nl ly iv ng b gy nm nn l no np">SELECT<br/> try_to_number(lifetime_value)<br/>FROM AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/01a43c39b03b551ee4f7e67f6830bcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:258/format:webp/1*TJbZ133CgBP3m_w-NwQVKw.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="e325" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">注意这个SQL函数是如何消除原始值中的小数位的。因此，我们只想在case语句中使用它来检查空值。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="8546" class="nl ly iv ng b gy nm nn l no np">select<br/>    case <br/>        when try_to_number(lifetime_value) is NULL then NULL else lifetime_value<br/>    end as lifetime_value <br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4d828cbdd323b04821f78028c5e8d7af.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*-6MNuSs8z1RxrEJBpy1CSQ.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="f307" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们还可以看到小数的格式不统一，有些是负数。为了清理数据，我们不希望该列中有任何负值。相反，我们希望用0代替负数。</p><p id="4c20" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们可以使用<code class="fe nd ne nf ng b">iff()</code>函数来测试一个列中的条件。首先，指定条件。然后，如果它是false，它将返回指定的第一个值。如果为true，将返回指定的第二个值。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="ddf9" class="nl ly iv ng b gy nm nn l no np">select<br/>    case <br/>        when try_to_number(LCV) is NULL then NULL else IFF(LCV&lt;0, 0, ROUND(LCV,2))<br/>    end as lifetime_value <br/>from<br/>AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="46ec" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这里，我测试一下<strong class="ld iw"> lifetime_value </strong>是否小于0。如果是，函数将返回0。如果不是，我就使用<code class="fe nd ne nf ng b">round()</code>函数将数值四舍五入到两位小数。这个函数非常适合舍入货币值或任何小数。指定要舍入的列，然后指定小数位数。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b52a3890ec2050e27252d75223722e5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*FFBs5Kv5njyJoQQsYbRUlg.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><h1 id="1556" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">检查长度</h1><p id="f92a" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">再来看<strong class="ld iw">电话</strong>栏目。我们可以看到其中一些电话号码实际上根本不是电话号码。我们希望最大限度地减少不准确数据的数量，所以让我们看看是否可以向该列添加一个条件。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/b8011cb8f3cd46de6c0eaada0106d399.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*r5n9CWucUQKPh77rckLoow.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="43b8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们知道电话号码最多只能是11位，如果不包括国家代码，可能是10位。为了限制表中虚假数据的数量，让我们删除所有没有10位或11位数字的电话号码。更好的办法是，在不满足这个条件的情况下，让列值为NULL。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="b4af" class="nl ly iv ng b gy nm nn l no np">SELECT<br/>  IFF(len(phone) IN (10, 11), phone, null) AS phone<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="e254" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里我再次使用一个<code class="fe nd ne nf ng b">IFF()</code>函数来检查列中的值是否满足某个条件。我使用<code class="fe nd ne nf ng b">len()</code>函数来检查列值中的字符。如果电话号码不是10或11个字符，我们将用空值替换它。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/b18592aec36050b30f373f0be8bbc558.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*ud6Syd2brYrkFkmzNosAAA.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="039d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，我们只有一个电话号码，但至少我们知道它是准确的！干净数据比脏数据好，即使脏数据更少。质量重于数量。</p><h1 id="6f41" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">检查字符</h1><p id="67f0" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">与电话号码一样，我们希望确保<strong class="ld iw">电子邮件</strong>列包含准确的电子邮件地址。我们可以进行一些检查来确保这些信息的准确性。其中之一是确保这些值包含@字符，这是所有电子邮件都有的字符。</p><p id="13fc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们可以通过使用charindex()字符串函数来实现这一点。这个函数返回指定字符在字符串中的位置。如果字符串中不存在该字符，函数将返回0。</p><p id="d4a7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里，我们在电子邮件列中搜索@符号。我们使用case语句来检查这个函数的结果是否是0以外的数字。如果不是0，它必须包含一个@。如果它是0，它不是一个正确的电子邮件地址，我们用null替换这个值。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="d482" class="nl ly iv ng b gy nm nn l no np">select<br/>  case<br/>     when charindex('@', email) != 0 then email<br/>     else null<br/>  end AS email<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="5edf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">新电子邮件将如下所示:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/aab6abff6e94b49cf5ff6bfb8424a774.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*dDHZkQ3xUcxeCau5.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="fbf9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">类似于<strong class="ld iw">电话</strong>列，<strong class="ld iw">电子邮件</strong>列现在具有空值，而以前的值不满足指定的条件。</p><h1 id="ca67" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">检查子字符串</h1><p id="66f0" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">除了@符号之外，电子邮件地址必须以“.”结尾。com”。我们可以检查以确保该电子邮件列中的值都以该字符串结尾。如果不是，我们可以用一个空值来代替它。</p><p id="f553" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里，我们将使用<code class="fe nd ne nf ng b">LIKE</code>语句来确保它包含这个子串。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="6135" class="nl ly iv ng b gy nm nn l no np">select<br/>  case<br/>     when email LIKE '%.com' then email<br/>     else null<br/>  end AS email<br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="8009" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">%符号表示任何字符串都可以出现在“.”之前。com”。但是，既然我们没有一个%的结尾”。该值必须在它之后结束。像麦迪逊这样的价值观。comgmail不准确，将被NULL代替。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/638da5aebf8e4a948b5d0d032aed0852.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/0*_TwVFclx8-jeMZi0.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="fdb8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因为我们所有的电子邮件都符合这个条件，所以我们得到的表看起来是一样的。</p><h1 id="8996" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">铸造日期</h1><p id="bd46" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">将日期输入电子表格有许多不同的方式。我在使用Google sheets作为数据源时经常遇到这个问题。每当一个新的人将数据输入到表单中时，列的格式就会改变！如您所见，日期的输入方式不同，有些用斜线，有些用连字符。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3e1798dbaa6658dc520afd5c4928ced0.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/0*XNuoFxtWOdA4EoWw.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><p id="e69d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">幸运的是，有一个SQL函数<code class="fe nd ne nf ng b">to_date()</code>可以将字符串转换成日期。第一次接收数据时，带有日期的列的数据类型为varchar。使用此函数对它们进行转换会将它们转换为数据类型为date的日期，从而使该列为分析做好准备。</p><pre class="kl km kn ko gt nh ng ni nj aw nk bi"><span id="6964" class="nl ly iv ng b gy nm nn l no np">select <br/>  to_date(activation_date) AS activation_date <br/>from AIRBYTE_DATABASE.AIRBYTE_SCHEMA.GOOGLE_SHEETS_CUSTOMER_DETAILS;</span></pre><p id="3429" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这将产生一个日期如下所示的列:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d7d88c438a37a4fcc396a9a6b08252f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/0*qDuy1ZuEcYNOqwNG.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</p></figure><h1 id="d958" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">结论</h1><p id="501c" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">现在，我们的原始数据已经被清理成我们的数据分析师可以实际使用的数据！这些SQL清理函数对于创建可用的数据模型至关重要。你会一遍又一遍地使用它们，所以理解它们是如何工作的很重要。</p><p id="272d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下面是我们今天学习的SQL字符串函数的概述:</p><ul class=""><li id="721f" class="of og iv ld b le lf lh li lk oh lo oi ls oj lw ok ol om on bi translated"><strong class="ld iw"> split_part() </strong>按字符分割字符串</li><li id="f6a8" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> lower() </strong>删除字符串中的所有大写</li><li id="b20c" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> try_to_number() </strong>将值转换为数字</li><li id="7f82" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> iff() </strong>为测试条件</li><li id="1d7b" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> round() </strong>将一个数四舍五入到一定的小数位数</li><li id="8e78" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> len() </strong>检查字符串的长度</li><li id="d0e0" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> char_index() </strong>查找字符串中某个字符的索引</li><li id="2591" class="of og iv ld b le oo lh op lk oq lo or ls os lw ok ol om on bi translated"><strong class="ld iw"> to_date() </strong>将字符串转换为日期</li></ul><p id="58f9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下一步是在SQL文件中编写代码，供dbt使用和自动化。该代码与dbt一起将创建一个自动化系统，在该系统中，当您的分析师需要数据时，您的数据总是干净的和可用的。这就是数据驱动型公司和数据驱动型公司的区别。但是我们将在另一篇文章中讨论这个问题。数据清理快乐！</p><p id="120d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><a class="ae la" href="https://mailchi.mp/e04817c8e57e/learn-analytics-engineering" rel="noopener ugc nofollow" target="_blank">通过订阅我的电子邮件列表，了解更多关于SQL和分析工程师使用的其他工具的</a>。</p></div></div>    
</body>
</html>