# 如何编写异常函数

> 原文：<https://towardsdatascience.com/how-to-write-exceptional-functions-c809bc58761a>

## 我用来使函数编写更容易和更好的技术

![](img/b5f65845179528012062f2c2af7d7f3a.png)

(图片由 [geralt](https://pixabay.com/images/id-607479/) 在 [Pixabay](http://pixabay.com) 上提供)

# 介绍

> 功能。

T 他们是编程世界中的一股巨大力量，也是数学和高级计算的基础构件之一。函数允许我们定义一组指令供计算机执行，有时通过它们传递不同的数据，然后在我们需要的任何时候调用该函数。从这个意义上来说，函数是计算的核心组成部分，但是制作它们肯定是具有挑战性的。函数总是寻求解决一个问题，有时这些问题很难解决。

由于软件工程是使数据科学成为数据科学的重要组成部分，所以认为更好的功能有助于更好的数据科学是很有意义的。数据科学也带来了机器学习，在这种情况下，性能是一个问题，写得不好的函数性能很差。此外，任何科学的一个重要部分都是可复制的，当要复制的代码看起来糟糕透顶时，事情就变得不那么可复制了。我们经常处理复杂的数学和线性代数，如果没有组织的话，会很混乱。如果有一个领域中编写伟大的函数是一个伟大的想法，我会认为这是一个很好的例子，特别是在数据科学中编写易读且性能良好的函数。

尽管在试图创建一个函数时很容易迷失方向，但是有一些有用的方法可以使编写函数变得更容易。虽然函数一开始可能令人生畏，但它们通常只是输入和输出的基本操作。我使用了一些很棒的技术来编写看起来很棒、功能也很棒的函数。这些通常伴随着更多的经验，但我认为分享其中的一些可能是有意义的，因为它们在我编写函数的过程中经常会派上用场。如果您想查看我在本文中为演示这些内容而编写的函数的代码，笔记本在这里:

<https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Better%20functions.ipynb>  

# 开始一项功能

所有功能都是从一个目的地开始实现的。我们无法在不知道函数输出的情况下编写函数。如果我们不知道函数的回报是什么，那么我们怎么给它命名呢？记住，当着手编写一个令人生畏的函数时，我们首先需要考虑的是输出。我们希望从函数中得到什么。下一个问题是，我们需要在函数中输入什么，才能得到这样一个东西？对于这个例子，我将编写一个 r 函数，这是一个常用于数据科学领域的连续机器学习模型的验证指标。计算起来有点麻烦，所以它非常适合概述在编写函数时应该做什么和不应该做什么。在统计学中，r 代表(皮尔逊)相关系数。因此，我们需要得到相关系数，并平方它。这是相关系数的公式

![](img/d91bbd66e1b52b7c4fe069c4ac5d270f.png)

这里有些值我们需要计算，

*   n
*   xy、x、y、x 和 y 的总和

我们需要提供这些值中的哪些作为参数，这是我们在启动函数时首先需要考虑的..所有其他的值，n，x，xy 等等。，它们都是可以计算的，但是我们至少需要一个 x 和一个 y，记住这一点，我们将构造我们的函数来模拟它。一个我深信不疑的信念是，写一个坏函数比写一个好函数要容易得多。也就是说，很多程序员开始会被一个好的函数所困扰。只要你的功能正常，以后还可以重新运行。文本并不是静态的，所以编写函数的第一个目标应该是获得输出，而不一定是最有效的最漂亮的函数——至少在函数实际工作之前是这样。

```
function r2(x, y)end
```

因为我使用的是 Julia，所以我还会确保传递每个参数的类型，这样这个方法在不同的上下文中都是可扩展和可用的。顺便说一下，这些好处是在文档和方法错误的好处之上的。如果这些听起来都不熟悉，但您希望如此，我有一整篇文章讨论 MethodError 及其各种功能，因此您可以在这里了解更多信息:

</the-beauty-of-the-methoderror-e5bb2f3e2678>  

```
function r2(x::Array, y::Array)end
```

接下来，我们需要获得公式中使用的计算值。一旦我们有了这些值，将它们代入这个公式实际上应该是相对简单的。表示的一个小技巧是 x 的和与 x 的平方和的差。它们读出来完全一样，但是括号意味着求和需要在前面发生。换句话说，

> σx！=(σx)

为了开始这个函数，我将得到 n 和 xy 的值，这只是 x 和 y 之间的元素乘法。

```
n = length(x)
xy = x .* y
```

我将得到这三者的和。

```
sx = sum(x)
sy = sum(y)
sxy = sum(xy)
```

然后我要对 x 和 y 求平方，像之前一样得到总和。

```
x2 = x .^ 2
y2 = y .^ 2
sx2 = sum(x2)
sy2 = sum(y2)
```

获得相关系数的最后一步，基本上就是现在用这些值将公式编码。

```
((n*sxy) - (sx * sy)) / (sqrt((((n*sx2)-(sx^2)) * ((n*sy2)-(sy^2)))))
```

这将给我们相关系数。为了使相关系数平方，我们当然只是平方它。所有这些合在一起就形成了这样一个函数:

```
function r2(x::Array,y::Array)
    n = length(x)
    xy = x .* y
    sx = sum(x)
    sy = sum(y)
    sxy = sum(xy)
    x2 = x .^ 2
    y2 = y .^ 2
    sx2 = sum(x2)
    sy2 = sum(y2)
    ((n*sxy) - (sx * sy)) / (sqrt((((n*sx2)-(sx^2)) * ((n*sy2)-(sy^2))))) ^ 2
end
```

# 提取，血统

这个函数需要做的第一件也是最明显的事情是提取。我们这里的 r 函数是计算 r 的整体，我们需要考虑，我们完全有可能需要在其他地方使用 r。通过计算这个值，并且只在这个函数中使用它，我们将不得不重写这段代码，或者对这个函数的结果求平方根——这是没有意义的。更明智的做法是在不同的函数中计算 r，然后用 r 调用该函数，这将变成一个非常简单的内嵌函数。使用提取技术，我将提取这段代码中负责计算相关系数的部分。

```
function r(x::Array, y::Array)
    n = length(x)
    xy = x .* y
    sx = sum(x)
    sy = sum(y)
    sxy = sum(xy)
    x2 = x .^ 2
    y2 = y .^ 2
    sx2 = sum(x2)
    sy2 = sum(y2)
    ((n*sxy) - (sx * sy)) / (sqrt((((n*sx2)-(sx^2)) * ((n*sy2)-(sy^2)))))
endr2(x::Array, y::Array) = r(x, y) ^ 2
```

这项技术非常有用，它的使用展示了一些需要理解的关于函数的东西。函数应该简单直接，并且只有一个目的。当然，总有这样的情况，你可能调用带有很多参数的函数，或者可能没有输出，事情可能会略有不同，但在大多数情况下应该是这样的。无论如何，虽然在这种特殊情况下，函数看起来可能不会更好，但这仍然会使我们辛辛苦苦编写的代码更加适用和有用。实际上，我也有一整篇关于提取的文章，非常简洁；所以这里有一个链接！：

</more-methods-means-better-code-1d3b237f6cf2> [## 更多的方法意味着更好的代码

towardsdatascience.com](/more-methods-means-better-code-1d3b237f6cf2) 

# 修订本

好了，现在你的函数已经写好了，可以运行了。你把它发给你的朋友，他取笑你做了一件比你应该做的更复杂的事情。这就是下一步要做的，修改。修订步骤通常是对代码进行审查和修改，以使其更加美观和高效。在这个例子中，调用非常简单直接。在这个特定函数的情况下，可能适合的一件事是减少获取公式值的行数。

```
function r(x::Array, y::Array)
    n , xy = length(x), x .* y
    sx,sy, sxy = sum(x), sum(y), sum(xy)
    x2, y2 = x .^ 2, y .^ 2
    sx2, sy2 = sum(x2), sum(y2) 
    ((n*sxy) - (sx * sy)) / (sqrt((((n*sx2)-(sx^2)) * ((n*sy2)-(sy^2)))))
end
```

我认为这个版本看起来更好，但这取决于个人喜好。这里您可能想做的另一件事是添加您的文档。那里也可能有一些性能上的调整，因为我的函数相当简单，对我来说可能不是这样。

# 结论

编写函数可能是一项令人望而生畏的任务，尤其是对于那些编程新手来说。幸运的是，有一些思考问题的方法和编写函数的方法实际上对编写函数非常有帮助。这些是我在这方面的一些方法，我希望它们能在您的软件之旅中很好地为您服务。感谢您的阅读！