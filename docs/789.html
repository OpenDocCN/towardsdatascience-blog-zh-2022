<html>
<head>
<title>How to Predict Risk-Proportional Intervals with Conformal Quantile Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用共形分位数回归预测风险比例区间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-predict-risk-proportional-intervals-with-conformal-quantile-regression-175775840dc4#2022-01-28">https://towardsdatascience.com/how-to-predict-risk-proportional-intervals-with-conformal-quantile-regression-175775840dc4#2022-01-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="d74b" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">如何用共形分位数回归预测风险比例区间</h1></div><div class=""><h2 id="d01f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这种算法-由斯坦福大学学者于2019年发表-结合了分位数回归和保形预测。下面是如何用Python实现的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f98d7ee57490d1e7435955c70c26ac99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e4nkKUNqc6KbYYFw63i0Sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">[图片由作者提供]</p></figure><p id="4a99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">我们公司要求你建立一个模型来预测拍卖物品的销售价格。该公司的目标是私下购买这些物品，并以更高的价格出售(根据您的模型预测)。</p><p id="7302" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，假设你有两件东西:西班牙艺术家胡安·米罗的一幅画和一栋位于三藩市的房子。您的模型做出以下预测:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/46de4e45c99f4ade7adbf62dc0647e98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHoMhjW3DcB16cdtvYpA7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预测模型做出的点预测。[图片由作者提供]</p></figure><p id="3409" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你的公司可以用75万美元买下这幅画，也可以用75万美元买下这处房产。他们应该买哪一个？你的预测不足以回答这个问题。</p><p id="4f9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设米罗艺术品的价格最近波动很大，而旧金山的房地产市场却相当稳定。因此，如果您可以预测可能的销售价格的区间，而不是单个值，您将获得如下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/d94fc51d7ecac8402b20576246c5dfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iMAXkaB5rZ-qif043mRzUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">区间预测(95%置信度)。红十字是预测点。[图片由作者提供]</p></figure><p id="1d09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在同样的置信度(95%)下，与米罗画作相关的区间<strong class="la iu">更宽</strong>，这意味着与三藩市的财产相比，这个物体本来就有<strong class="la iu">更大的风险</strong>。因此，根据你公司的风险厌恶程度，你可能更愿意买房子，即使它与较低的预期利润相关。</p><p id="c950" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种输出，即<strong class="la iu">预测区间，其长度实际上与和预测</strong>相关的风险成比例，可以通过一种叫做<strong class="la iu">共形分位数回归</strong>(CQR)的算法获得。</p><p id="a6f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将解释CQR是如何工作的，以及如何用Python实现它。</p><h1 id="ef7d" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">什么是CQR</h1><p id="a887" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated"><strong class="la iu">共形分位数回归</strong>是由<strong class="la iu">斯坦福</strong>学者团队在<strong class="la iu"> 2019 </strong>中提出的算法，在一篇自题论文中(<a class="ae nb" href="https://arxiv.org/pdf/1905.03222.pdf" rel="noopener ugc nofollow" target="_blank">链接</a>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/445e1096a34bb542835e5d3b6e0b117f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S89MgOgJmZ6QYMHSKQqUoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自ArXiv的纸头截图。[ <a class="ae nb" href="https://arxiv.org/pdf/1905.03222.pdf" rel="noopener ugc nofollow" target="_blank">链接</a></p></figure><p id="cba7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顾名思义，<strong class="la iu">共形分位数回归是共形预测和分位数回归的并集</strong>。这是一种尝试，从两种方法中取长补短。</p><p id="11ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你读了我以前的一篇关于Python的MAPIE库的文章，你已经知道了关于保形预测的主要批评:预测的区间有恒定的(或者只是稍微变化的)宽度。</p><p id="6842" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，分位数回归模型(如随机森林)在新数据的错误预测百分比方面可能不太精确。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/dcaaf812b7fc6afe298cfb2f64f5cb21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0oOgRrSaCr8xFEzoBYkRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">共形预测和分位数回归的利弊。[图片由作者提供]</p></figure><p id="c496" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是在深入研究CQR之前，让我们先回顾一下什么是分位数回归。</p><h1 id="8c3e" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">我们所说的分位数回归是什么意思？</h1><p id="8d45" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">为了形象化起见，我将使用单变量模型——这意味着只有一个特征——但请记住，相同的推理适用于任何数量的特征。假设我们有一项任务，根据个人的年龄来预测他们的收入。我将使用Python中生成的一些假数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9727285c6d243c5d40769a4c1eb4b735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*penfGPHCgq1_DAVZnwQXtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">假数据点。[图片由作者提供]</p></figure><p id="862f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您在<strong class="la iu">默认模式下使用来自Scikit-learn、XGBoost、LightGBM、CatBoost或Keras等流行Python库的预测模型时，您是在隐式预测目标变量的平均值，给定观察到的特性</strong>。例如:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="49e1" class="nk mf it ng b gy nl nm l nn no">from sklearn.ensemble import GradientBoostingRegressor</span><span id="3bbd" class="nk mf it ng b gy np nm l nn no">GradientBoostingRegressor().fit(X_train, y_train).predict(X_test)</span></pre><p id="2088" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/c947f27baacac52abee5b067e0fe690f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rE9NNcPkOXVgtywiC0UDOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">梯度推进回归器(默认模式)对虚假数据进行的预测。[图片由作者提供]</p></figure><p id="6025" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，所有的库也都配备了<strong class="la iu">来预测目标值</strong>的特定分位数。这是通过改变损失类型实现的。例如，对于Scikit-learn的GradientBoostingRegressor，这可以通过设置<code class="fe nr ns nt ng b">loss="quantile"</code>和<code class="fe nr ns nt ng b">alpha=quantile</code>来实现，其中<code class="fe nr ns nt ng b">quantile</code>是一个介于0和1之间的数字，它是您想要预测的分位数。例如:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="bb3f" class="nk mf it ng b gy nl nm l nn no">from sklearn.ensemble import GradientBoostingRegressor</span><span id="cdbe" class="nk mf it ng b gy np nm l nn no">GradientBoostingRegressor(loss="quantile", alpha=.95).fit(X_train, y_train).predict(X_test)</span></pre><p id="f1f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对不同的分位数重复这一过程会产生以下预测:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/b2fc6d4eb2e2c4fc07733d05f0994f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtSmiULDpGIHy3nptKOn9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过梯度推进回归器(设置不同的分位数)对虚假数据进行预测。[图片由作者提供]</p></figure><p id="1195" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在的问题是，这些分位数预测在新数据上往往不准确。为了弥补这一点，CQR对分位数回归预测的区间应用了一个修正因子。</p><h1 id="3bfd" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">CQR在实践中是如何工作的？</h1><p id="029c" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">共形分位数回归是一种旨在<strong class="la iu">校正您的分位数回归模型提供的区间的方法，以使新数据上观察到的错误数量非常接近您设置的容差</strong>。容差——通常称为<code class="fe nr ns nt ng b">alpha</code>——是你愿意接受的错误百分比(即超出预测区间的观察值)。</p><p id="8f38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CQR需要三组数据:</p><ul class=""><li id="0453" class="nv nw it la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated"><strong class="la iu">训练数据</strong>:分位数回归模型学习的数据。</li><li id="7664" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><strong class="la iu">校准数据</strong>:CQR校准间隔的数据。</li><li id="df77" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><strong class="la iu">测试数据</strong>:评估区间优劣的数据。</li></ul><p id="c9d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该算法包括6个步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/cad674112b1b0cce1056f117096d6d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfHlK0ZNoNFi4R7GKjHFtQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">共形分位数回归算法。[图片由作者提供]</p></figure><p id="6fb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">具体来说，这些步骤是:</p><ol class=""><li id="633f" class="nv nw it la b lb lc le lf lh nx ll ny lp nz lt ok ob oc od bi translated">对训练数据拟合分位数回归模型。</li><li id="a978" class="nv nw it la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">使用上一步获得的模型预测校准数据的间隔。</li><li id="fb80" class="nv nw it la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">根据上一步获得的校准数据和间隔计算<strong class="la iu">一致性分数</strong>。</li><li id="40e1" class="nv nw it la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">从上一点获得的一致性分数分布中获得1- <code class="fe nr ns nt ng b">alpha</code>分位数。</li><li id="4b0e" class="nv nw it la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">使用步骤1中获得的模型对测试数据进行预测。</li><li id="8d91" class="nv nw it la b lb oe le of lh og ll oh lp oi lt ok ob oc od bi translated">通过将第4步获得的分位数减去(加上)第5点获得的预测值，计算区间的左(右)端。</li></ol><p id="a75c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有些步骤一开始看起来有点晦涩，不要担心。整个算法只用几行Python代码就能翻译出来。</p><blockquote class="ol om on"><p id="0437" class="ky kz oo la b lb lc ju ld le lf jx lg op li lj lk oq lm ln lo or lq lr ls lt im bi translated">注意:作为分位数回归模型，我将使用来自<code class="fe nr ns nt ng b">skgarden</code>的<code class="fe nr ns nt ng b">RandomForestQuantileRegressor</code>，但是您可以使用分位数损失用任何回归模型替换它。</p></blockquote><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="0b6b" class="nk mf it ng b gy nl nm l nn no">import numpy as np<br/>from skgarden import RandomForestQuantileRegressor</span><span id="4bab" class="nk mf it ng b gy np nm l nn no">alpha = .05</span><span id="1676" class="nk mf it ng b gy np nm l nn no"><strong class="ng iu"># 1. Fit quantile regression model on training data<br/></strong>model = RandomForestQuantileRegressor().fit(X_train, y_train)</span><span id="2f64" class="nk mf it ng b gy np nm l nn no"><strong class="ng iu"># 2. Make prediction on calibration data</strong><br/>y_cal_interval_pred = np.column_stack([<br/>    model.predict(X_cal, quantile=(alpha/2)*100), <br/>    model.predict(X_cal, quantile=(1-alpha/2)*100)])</span><span id="aaf7" class="nk mf it ng b gy np nm l nn no"><strong class="ng iu"># 3. Compute conformity scores on calibration data<br/></strong>y_cal_conformity_scores = np.maximum(<br/>    y_cal_interval_pred[:,0] - y_cal, <br/>    y_cal - y_cal_interval_pred[:,1])</span><span id="d0a6" class="nk mf it ng b gy np nm l nn no"><strong class="ng iu"># 4. Get 1-alpha quantile from the distribution of conformity scores<br/>#    Note: this is a single number</strong><br/>quantile_conformity_scores = np.quantile(<br/>    y_cal_conformity_scores, 1-alpha)</span><span id="fa7a" class="nk mf it ng b gy np nm l nn no"><strong class="ng iu"># 5. Make prediction on test data<br/></strong>y_test_interval_pred = np.column_stack([<br/>    model.predict(X_test, quantile=(alpha/2)*100), <br/>    model.predict(X_test, quantile=(1-alpha/2)*100)])</span><span id="0a72" class="nk mf it ng b gy np nm l nn no"><strong class="ng iu"># 6. Compute left (right) end of the interval by<br/>#    subtracting (adding) the quantile to the predictions</strong><br/>y_test_interval_pred_cqr = np.column_stack([<br/>    y_test_interval_pred[:,0] - quantile_conformity_scores,<br/>    y_test_interval_pred[:,1] + quantile_conformity_scores])</span></pre><p id="d08e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，该算法围绕校准数据计算的一致性分数(步骤3)。但是<strong class="la iu">符合性分数的意义是什么？</strong></p><p id="3a79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一致性分数表示每个观察值和最近的区间极值之间的<strong class="la iu">(带符号)距离。符号由点的位置给出，无论它落在区间内还是区间外。<strong class="la iu">当点位于区间内时，一致性分数的符号为负，当点位于区间外时，符号为正</strong>。因此，只有当该点恰好位于一个区间极值上时，得分为零。</strong></p><p id="f977" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们取一个介于2和8之间的预测区间。对于目标变量的一些不同值，这些将是各自的一致性分数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/41a3c708687659da2568437a9ccc4ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIJ6U3sIYkpdc4cxiemU6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同观察值在2到8之间的一致性分数。红叉是[作者图片]</p></figure><p id="42a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是<strong class="la iu">计算一致性分数的分位数并把它加在区间两边有什么意义呢？</strong></p><p id="45f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我给你举两个例子。</p><p id="a110" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设一致性分数的分位数是1000美元，给定<code class="fe nr ns nt ng b">alpha</code> =5%。这意味着95%的观测值距离相应的间隔不超过1000美元。因此，通过将两边的所有间隔扩大1000美元，我们期望实现95%的观测值将落在它们的间隔内的目标。</p><p id="5b7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一致性分数的分位数是负的，这也是有效的。例如，给定一个-500美元的分位数，这意味着区间太宽。事实上，通过将两边的所有间隔“削减”500美元，我们将再次获得期望的错误数量。</p><h1 id="2916" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">真实数据上的CQR</h1><p id="9f50" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">不幸的是，我不知道有哪个Python包能够像Scikit-learn那样方便用户地执行一致化分位数回归。然而，<a class="ae nb" href="https://github.com/scikit-learn-contrib/MAPIE" rel="noopener ugc nofollow" target="_blank"> MAPIE </a>的作者最近表示，他们正在他们的库中实现它，当这种情况发生时，我将更新这一段。</p><p id="5d4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论如何，好消息是实现CQR非常容易，因为它只需要几行代码。</p><p id="a8e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个例子，我将使用“钻石”数据集，它可以从<a class="ae nb" href="https://github.com/mwaskom/seaborn" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>包中下载，使用<a class="ae nb" href="https://github.com/mwaskom/seaborn/blob/master/LICENSE" rel="noopener ugc nofollow" target="_blank"> BSD许可证</a>。目标是预测每颗钻石的售价(从326美元到18，823美元不等)，特征是钻石的一些特征，如克拉、颜色、长度、宽度、深度等。例如，这些是数据集的前5颗钻石:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/504346bc61a5aa5ccf0721c5a9fabd79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P_BFG7yVASd5rSNJOgdvUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">钻石数据集的前5个观察值。[图片由作者提供]</p></figure><p id="7199" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个实验，我将把<code class="fe nr ns nt ng b">alpha</code>设置为5%。</p><p id="7ec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比较CQR、分位数回归和简单保形预测的性能很有意思。我们可以使用上面看到的代码来获得分位数回归预测(<code class="fe nr ns nt ng b">y_test_interval_pred</code>)和CQR预测(<code class="fe nr ns nt ng b">y_test_interval_pred_cqr</code>)。此外，让我们使用MAPIE来获得简单的保形间隔:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="bd7a" class="nk mf it ng b gy nl nm l nn no">from sklearn.ensemble import RandomForestRegressor<br/>from mapie import MapieRegressor</span><span id="3cd4" class="nk mf it ng b gy np nm l nn no">estimator = RandomForestRegressor().fit(X_train, y_train)</span><span id="8724" class="nk mf it ng b gy np nm l nn no">mapie = MapieRegressor(estimator=estimator, cv="prefit").fit(X_cal, y_cal)</span><span id="a6aa" class="nk mf it ng b gy np nm l nn no">y_test_interval_pred_mapie = mapie.predict(X_test, alpha=.05)[1].reshape(-1,2)</span></pre><p id="0b0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用的性能指标非常简单:</p><ul class=""><li id="bf72" class="nv nw it la b lb lc le lf lh nx ll ny lp nz lt oa ob oc od bi translated"><strong class="la iu">误覆盖率</strong>，即超出预测区间的测试观测值的百分比。希望该数值尽可能接近用户设定的容差，在这种情况下为5%。</li><li id="5409" class="nv nw it la b lb oe le of lh og ll oh lp oi lt oa ob oc od bi translated"><strong class="la iu">平均区间长度</strong>，区间宽度的平均值。希望间隔的长度尽可能小，因此越小越好。</li></ul><p id="d9f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0b173219a23ea0047054e8b0e36e3eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USf1wNE0crSVG0TDwFT6GA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较MAPIE(简单保形预测)、RandomForestQuantileRegressor(分位数回归)和CQR。[图片由作者提供]</p></figure><p id="80af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">MAPIE有许多错误(4.99%)，非常接近我们设置的容差(5%)，但是间隔的平均长度相当高(2，327.28美元)。</p><p id="8bb8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，随机森林分位数回归器产生了紧密的区间(平均为1，173.41美元)，但这是无用的，因为误差百分比(17.71%)远远高于容差。</p><p id="401e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CQR是三个中最好的。事实上，它的误报率(4.98%)非常接近容差(5%)，并且与MAPIE相比间隔更小(1，763.41美元对2，327.28美元)。</p><p id="9245" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，我们已经看到MAPIE(“prefit”模式)产生等长的间隔，所以在这种情况下，所有预测的间隔正好是2，327.28 $宽。CQR怎么样？让我们看看CQR得出的区间长度的一些分位数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/6a62ef84ef5f58fed8418618238919ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MUWaDS_wfAO596PEZ170Qw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CQR预测的区间长度的一些百分位数。[图片由作者提供]</p></figure><p id="a47d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所希望的，有一个广泛的可变性，反映了这样一个事实，即时间间隔实际上与每个钻石价格相关的风险成比例。</p><p id="8ad7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于很多数据集的更多例子，可以参考上面提到的斯坦福学者的论文。但是，总的来说，我们展示的结果是<strong class="la iu">一个经验证据，表明CQR实际上将最佳的共形预测和最佳的分位数回归结合在一起</strong>。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><blockquote class="ol om on"><p id="59fb" class="ky kz oo la b lb lc ju ld le lf jx lg op li lj lk oq lm ln lo or lq lr ls lt im bi translated"><em class="it">感谢您的阅读！我希望你喜欢这篇文章。如果你愿意，</em> <a class="ae nb" href="https://www.linkedin.com/in/samuelemazzanti/" rel="noopener ugc nofollow" target="_blank"> <em class="it">在Linkedin上加我</em> </a> <em class="it">！</em></p></blockquote></div></div>    
</body>
</html>