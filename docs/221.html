<html>
<head>
<title>Dockerizing Jupyter Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对接Jupyter项目</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dockerizing-jupyter-projects-39aad547484a#2022-01-08">https://towardsdatascience.com/dockerizing-jupyter-projects-39aad547484a#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="85b0" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">对接Jupyter项目</h1></div><div class=""><h2 id="6eef" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将您的项目和conda环境容器化的简单方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d06bfe3e015d56153e4ad0ecb8bcc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PPqFLodKDFBfjI_a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@live_for_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">滕玉红</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ea91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker是一个虚拟化工具，比<a class="ae ky" href="https://www.youtube.com/watch?v=5GanJdbHlAA" rel="noopener ugc nofollow" target="_blank">虚拟机</a>更精简。在本教程中，我将讨论在<code class="fe lv lw lx ly b">conda</code>环境中容器化Jupyter笔记本。</p><p id="b704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都源于我的研究和分析更加开放和透明的动机。我一直在尝试将我的脚本容器化，以便其他人更容易地重新创作我的作品。</p><p id="fd76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，集装箱化并不是唯一的解决方案。人们可以用需求文件(<code class="fe lv lw lx ly b">conda env -f requirements.yaml</code>)重建您的环境，然后下载您的脚本/数据来重建您的分析。集装箱化包装了一切。</p><p id="53a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我将解释适合我的方法，希望它能帮助你更深入地理解这种方法。</p><p id="dabb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将带您一步一步地从提取基础映像到将最终映像推送到存储库。我正在找出在这个工作流程中最有效的方法，欢迎并鼓励提出意见。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1a7f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">先决条件</h1><p id="4509" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您对Docker完全陌生，请按照这里的说明安装它</p><div class="nd ne gp gr nf ng"><a href="https://docs.docker.com/get-docker/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">获取码头工人</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">更新Docker桌面术语Docker桌面在大型组织中的专业使用(超过250名员工…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">docs.docker.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="becf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基本图像</h1><p id="e78b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最佳实践是从官方Docker基础映像开始。由于我使用的是<a class="ae ky" href="https://docs.conda.io/en/latest/miniconda.html" rel="noopener ugc nofollow" target="_blank"> miniconda </a>，我将从Dockerhub 上的<a class="ae ky" href="https://hub.docker.com/r/continuumio/miniconda3/tags" rel="noopener ugc nofollow" target="_blank"> Continuumio基本图像开始。</a></p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="f7e0" class="nz mh it ly b gy oa ob l oc od">docker pull continuumio/miniconda3:4.10.3p1</span></pre><p id="0364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oe">另一种方法是从Linux OS镜像开始，自己安装miniconda。</em></p><p id="533d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提取后，您可以在如下容器中运行映像:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="ba8e" class="nz mh it ly b gy oa ob l oc od">docker run -it <!-- -->continuumio/miniconda3:4.10.3p1<!-- --> /bin/bash</span></pre><p id="5baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在一个带有bash shell的交互式终端中运行Docker映像。<code class="fe lv lw lx ly b">-it</code>是<code class="fe lv lw lx ly b">--interactive --tty</code>的简写，它告诉Docker在容器内分配一个交互式虚拟终端会话。我只是认为<code class="fe lv lw lx ly b">-it</code>的意思是“我与T21的终端互动”</p><p id="4214" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，您可以访问基本Unix命令(<code class="fe lv lw lx ly b">ls</code>、<code class="fe lv lw lx ly b">pwd</code>、<code class="fe lv lw lx ly b">mkdir</code>等)。)以及<code class="fe lv lw lx ly b">conda</code>命令。</p><p id="cccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要验证是否安装了<code class="fe lv lw lx ly b">conda</code>，您可以运行:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="370f" class="nz mh it ly b gy oa ob l oc od">which conda</span></pre><p id="144b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了conda，你可以安装所有你喜欢的软件包</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="4df7" class="nz mh it ly b gy oa ob l oc od">conda install numpy pandas matplotlib jupyterlab</span></pre><p id="4b6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们安装了JupyterLab，我们可以启动一个服务器:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="fb51" class="nz mh it ly b gy oa ob l oc od">jupyter-lab --ip=0.0.0.0 --no-browser --allow-root</span></pre><p id="0d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过将提示链接复制到浏览器中来访问Jupyterlab。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/fc9fe9fa11c0fd0174b2a012f98164e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7izricg0lK9yRz31HYaZg@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">朱庇特实验室输出。将黄色框中的链接复制到您的浏览器中，以访问JupyterLab(图片由作者提供，使用<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank"> carbon.now.sh </a>创建)</p></figure><p id="7e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，按Ctrl-c停止服务器和<code class="fe lv lw lx ly b">exit</code>容器。</p><p id="70ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做有一个陷阱，你做的任何事情都不会持久。一旦关闭容器，您创建的每个笔记本都将丢失。Docker volumes将解决这个问题，我将很快讨论这个问题。</p><p id="df3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管容器中没有任何数据，但我们可以使用<code class="fe lv lw lx ly b">wget</code>或<code class="fe lv lw lx ly b">scp</code>来获取一些数据。例如，<code class="fe lv lw lx ly b">wget <a class="ae ky" href="https://www.ncei.noaa.gov/pub/data/cmb/ersst/v5/netcdf/ersst.v5.185401.nc" rel="noopener ugc nofollow" target="_blank">https://www.ncei.noaa.gov/pub/data/cmb/ersst/v5/netcdf/ersst.v5.185401.nc</a></code>将下载1854年1月的海面温度。同样，一旦关闭容器，这些数据将会丢失。</p><p id="a64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，预装一些数据或笔记本不是很好吗？我们也能做到！坚持住。</p><p id="796f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从miniconda基础映像开始，并在它的基础上构建我们的映像。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9a56" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创造你自己的形象</h1><p id="a922" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们上面所做的一切都可以是一个映像，所以我们不必每次都安装软件包并输入jupyterLab的run命令。</p><p id="4e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们创建了一个<code class="fe lv lw lx ly b">Dockerfile</code>，它是一个图像的蓝图，定义了如何创建我们的图像。</p><p id="8ec6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下内容复制到名为<code class="fe lv lw lx ly b">Dockerfile</code> ( <strong class="lb iu">不要添加扩展名</strong>)的文件中</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="56e2" class="nz mh it ly b gy oa ob l oc od">FROM continuumio/miniconda3:4.10.3p1</span><span id="0ff9" class="nz mh it ly b gy og ob l oc od">RUN conda install \<br/>    xarray \ <br/>    netCDF4 \ <br/>    bottleneck \<br/>    numpy \<br/>    pandas \<br/>    matplotlib \<br/>    jupyterlab</span><span id="7657" class="nz mh it ly b gy og ob l oc od">CMD ["jupyter-lab","--ip=0.0.0.0","--no-browser","--allow-root"]</span></pre><ul class=""><li id="e3e4" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><code class="fe lv lw lx ly b">FROM</code>表示我们正在构建的基础图像</li><li id="db9a" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><code class="fe lv lw lx ly b">RUN</code>表示我们希望在基础映像中运行的命令</li><li id="2d9b" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><code class="fe lv lw lx ly b">CMD</code>表示容器启动时我们想要运行的命令</li></ul><h2 id="1a3a" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">建立形象</h2><p id="aaed" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">然后我们可以建立我们自己的形象，并给它一个名字。(我把我的命名为<code class="fe lv lw lx ly b">jupyterlab</code>，标记为<code class="fe lv lw lx ly b">latest</code>)</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="9866" class="nz mh it ly b gy oa ob l oc od">docker build -t jupyterlab:latest .</span></pre><p id="03a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，<code class="fe lv lw lx ly b">-t</code>是<code class="fe lv lw lx ly b">--tag</code>的简写。这使用了<code class="fe lv lw lx ly b">name:tag</code>格式，其中name是您想要的图像标题，tag提供任何附加信息(例如版本号)。<code class="fe lv lw lx ly b">.</code>和end指定<code class="fe lv lw lx ly b">dockerfile</code>在当前目录下。</p><p id="83db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的机器上，构建过程花了大约2分钟。构建完成后，您可以列出所有可用的图像以确保其可用。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="1096" class="nz mh it ly b gy oa ob l oc od">docker image ls</span></pre><p id="aea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要删除该图像，这提供了诸如<code class="fe lv lw lx ly b">IMAGE_ID</code>和图像的<code class="fe lv lw lx ly b">SIZE</code>的信息。我们看到这张图片的大小略大于1GB。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/cf5b0d96989f10ff433ce757d36fbf7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZIAox1HNQTaVMRvmN180g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker图片ls(图片由作者提供，使用<a class="ae ky" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank"> carbon.now.sh </a>创建)</p></figure><h2 id="c64b" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">运行映像</h2><p id="b2bf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一旦构建了映像，我们可以像这样运行它:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="01e6" class="nz mh it ly b gy oa ob l oc od">docker run --rm -it -p 8888:8888 jupyterlab:latest</span></pre><p id="64bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们正在启动一个Jupyerlab服务器，所以我们必须告诉<code class="fe lv lw lx ly b">docker</code>服务器正在哪个端口上运行，这就是<code class="fe lv lw lx ly b">-p 8888:8888</code>所做的。</p><p id="369e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行容器时，会提示一个URL，您可以从web浏览器访问JupyterLab。</p><p id="4c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将学习如何向图像添加数据。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="960d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用数据预装容器</h1><p id="c93b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您使用图像来共享您的分析，那么您将需要包括脚本和数据。让我们假设您有以下目录结构，包括一个笔记本、一个数据集和一个自述文件。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="2b60" class="nz mh it ly b gy oa ob l oc od">.<br/>├── Dockerfile<br/>├── README.md<br/>├── data<br/>│   └── dataset.txt<br/>└── notebooks<br/>    └── my_analysis.ipynb</span></pre><p id="f2ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过添加下面一行到我们的<code class="fe lv lw lx ly b">Dockerfile</code>来添加一个<code class="fe lv lw lx ly b">/project</code>目录到图像中</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="852c" class="nz mh it ly b gy oa ob l oc od">WORKDIR /project</span></pre><p id="4c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个目录还不存在的话，Docker会很聪明地创建它。</p><p id="3a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">COPY</code>命令让我们(你猜对了)将数据复制到我们的映像中。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="d754" class="nz mh it ly b gy oa ob l oc od">COPY ./README.md /project<br/>COPY ./data /project/data<br/>COPY ./notebooks /project/notebooks</span></pre><p id="5fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的语法是:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="ec4c" class="nz mh it ly b gy oa ob l oc od">COPY /path/on/host /path/in/container</span></pre><p id="8982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们改装的<code class="fe lv lw lx ly b">Dockerfile</code>看起来是这样的:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="3507" class="nz mh it ly b gy oa ob l oc od">FROM continuumio/miniconda3:4.10.3p1</span><span id="1be0" class="nz mh it ly b gy og ob l oc od">WORKDIR /project</span><span id="00e5" class="nz mh it ly b gy og ob l oc od">RUN conda install \<br/>    xarray \<br/>    netCDF4 \<br/>    bottleneck \<br/>    numpy \<br/>    pandas \<br/>    matplotlib \<br/>    jupyterlab</span><span id="fb1a" class="nz mh it ly b gy og ob l oc od">COPY ./README.md /project<br/>COPY ./data /project/data<br/>COPY ./notebooks /project/notebooks</span><span id="6069" class="nz mh it ly b gy og ob l oc od">CMD ["jupyter-lab","--ip=0.0.0.0","--no-browser","--allow-root"]</span></pre><p id="8d1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们构建并运行我们的容器时，我们启动<code class="fe lv lw lx ly b">/project</code>目录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/cd99d3784478b97708cac042817c35d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ztapfptZTMoz2b0AieJeg@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">jupyterlab在容器中运行的截图(图片由作者提供)</p></figure><p id="c904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！现在，我们有了一种将数据从主机文件系统放入容器的方法。在这个阶段，我们可以将我们的图像推送到Dockerhub这样的存储库中，这样其他人就可以获取并运行它。这个我会在最后讨论。</p><p id="9e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们想象有人拉我们的形象，他们做了一些改变。他们可能希望这些变化持续下去。码头工人卷来救援！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="283c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Docker卷(基础)</h1><p id="6b1b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们开始将卷连接到我们的容器之前，了解什么是卷以及我们可以连接到卷的不同方式是很重要的。</p><p id="2b1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卷有助于在容器重新启动时保存数据。因此，它们允许数据在容器关闭后继续存在。</p><p id="38ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是将主机操作系统上的文件系统连接到容器中的虚拟文件系统。主机上的文件系统可以是已经存在的路径(例如<code class="fe lv lw lx ly b">~/Documents</code>)或者是Docker创建的新路径。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/c8d09e89797061960ab8ef997c5a3a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOgwkTB8mGa_1ehz7ZekBA@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将主机文件系统连接到虚拟文件系统的示意图(图片由作者提供)</p></figure><p id="22c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种类型的卷:</p><ol class=""><li id="ca6c" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu pj on oo op bi translated">主机卷</li><li id="6962" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu pj on oo op bi translated">匿名卷</li><li id="c485" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu pj on oo op bi translated">命名(匿名)卷</li></ol><p id="ff53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们连接卷的方式是在指定我们想要运行的映像之前使用<code class="fe lv lw lx ly b">docker run</code> <strong class="lb iu">中的<code class="fe lv lw lx ly b">-v</code>标志</strong></p><h2 id="0016" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">主机卷</h2><p id="3592" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于主机卷，我们将主机文件系统上的路径显式连接到容器中的路径。例如，这可能是您的<code class="fe lv lw lx ly b">~/Documents</code>文件夹中的路径。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="7745" class="nz mh it ly b gy oa ob l oc od">docker run -v /dir/on/host/data:/dir/in/container/data imageName</span></pre><p id="4389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主机卷提供了主机和容器之间的简单连接。您在主机文件系统中所做的任何更改都会在容器中看到，反之亦然。这种类型的卷在主机和容器之间提供了一个通道，非常适合在两者之间移动数据。</p><p id="ba2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，主机卷并不是数据持久性的最佳解决方案。为此，我建议匿名或命名卷</p><h2 id="becc" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">匿名卷</h2><p id="bcf1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于匿名卷，我们只需指定希望卷装载在容器上的位置，而它在主机上的位置由Docker负责。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="c8f2" class="nz mh it ly b gy oa ob l oc od">docker run -v /dir/in/container/data imageName</span></pre><p id="d3f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此示例中，在<code class="fe lv lw lx ly b">/dir/in/container/data</code>时在容器中创建虚拟文件系统，而在<code class="fe lv lw lx ly b">/var/lib/docker/volumes/</code>时在主机上自动创建文件系统。</p><p id="0ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于在容器关闭后保存您在容器中所做的更改非常有用，从而解决了数据持久性问题。</p><p id="e6c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，对于从主机向容器中获取数据来说并不太好，并且不能像主机卷那样很好地发挥管道的作用。</p><h2 id="1bcb" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">命名(匿名)卷</h2><p id="c2af" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">匿名卷和命名卷之间的唯一区别是，对于命名卷，您可以指定一个唯一的名称供以后参考。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="f854" class="nz mh it ly b gy oa ob l oc od">docker run -v name:/dir/in/container/data</span></pre><p id="ef65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的名称使我们能够轻松地将该卷连接到其他容器。</p><h2 id="ee0e" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">列出您的卷</h2><p id="ed86" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要列出您的卷，您可以使用<code class="fe lv lw lx ly b">ls</code></p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="1657" class="nz mh it ly b gy oa ob l oc od">docker volume ls</span></pre><h2 id="1ea3" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">创建命名卷</h2><p id="808c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您可以在使用之前创建一个空的命名卷，如下所示:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="9ee9" class="nz mh it ly b gy oa ob l oc od">docker volume create volume-name</span></pre><h2 id="c149" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">主机上的匿名/命名卷数据在哪里？</h2><p id="150b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您所有的卷宗都可以在<code class="fe lv lw lx ly b">/var/bin/docker/volumes</code>查看</p><p id="9a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在macOS上，它存储在一个虚拟机中。将文件移动到主机操作系统的一种方法是通过Docker仪表板。从Docker控制面板中，您可以导航到卷→单击您的命名卷→数据→然后在最右侧单击“另存为”将文件复制到您的主机操作系统。我知道这很复杂。</p><p id="6215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看这个<a class="ae ky" href="https://stackoverflow.com/questions/38532483/where-is-var-lib-docker-on-mac-os-x#:~:text=Once%20run%2C%20go%20to%20%2Fvar,you'll%20find%20your%20volumes." rel="noopener ugc nofollow" target="_blank">堆栈溢出线程</a>了解更多细节，如果有更简单的方法，请告诉我。</p><p id="5eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想要查看macOS虚拟机上存储的<code class="fe lv lw lx ly b">/var/bin/docker/volumes</code>吗？下面是步骤(谢谢<a class="ae ky" href="https://stackoverflow.com/questions/38532483/where-is-var-lib-docker-on-mac-os-x#:~:text=Once%20run,%20go%20to%20/var,you'll%20find%20your%20volumes." rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>)</p><ol class=""><li id="d70b" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu pj on oo op bi translated">运行以下容器</li></ol><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="4dc3" class="nz mh it ly b gy oa ob l oc od">docker run -it --privileged --pid=host debian nsenter -t 1 -m -u -n -i sh</span></pre><p id="e192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.导航到卷目录</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="c3a7" class="nz mh it ly b gy oa ob l oc od">cd /var/lib/docker/volumes</span></pre><p id="93f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe lv lw lx ly b">ls</code>此目录和列表导航到您的命名卷</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d5fc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将卷连接到容器</h1><p id="88b4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经了解了卷以及主机卷和命名卷之间的权衡，让我们将卷连接到容器。</p><p id="f7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我将使用一个命名卷，因为我想保留我在容器中所做的更改。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="a1d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将名为<code class="fe lv lw lx ly b">my_volume</code>到<code class="fe lv lw lx ly b">/project</code>的卷连接到运行<code class="fe lv lw lx ly b">jupyterlab:latest</code>映像的容器。因为我们在<code class="fe lv lw lx ly b">/project</code>目录中预装了数据，所以我们所做的任何更改都将保存在<code class="fe lv lw lx ly b">my_volume</code>上，即使在容器关闭后，我们也可以从停止的地方继续。</p><p id="ae3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以将该卷连接到运行不同映像的不同容器。还记得我们刚开始连接到我们的基础映像时，映像中什么也没有吗？现在尝试将<code class="fe lv lw lx ly b">my_volume</code>连接到它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pk pl l"/></div></figure><p id="2f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以从运行基本映像的容器中访问<code class="fe lv lw lx ly b">my_volume</code>中的数据了！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4784" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用Docker compose进一步简化</h1><p id="f93d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用端口和卷键入运行容器的命令有点麻烦。我们可以做的一件事是在一个<code class="fe lv lw lx ly b"> docker-compose.yaml</code>文件中定义所有的东西，这样我们所要做的就是用一个连接的卷启动预加载的Jupyterlab服务器</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="353b" class="nz mh it ly b gy oa ob l oc od">docker-compose up</span></pre><p id="d13c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，创建一个文件<code class="fe lv lw lx ly b">docker-compose.yaml</code>并将以下内容复制到其中</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="cf8f" class="nz mh it ly b gy oa ob l oc od">version: "3"</span><span id="1925" class="nz mh it ly b gy og ob l oc od">services:<br/>  jupyter:<br/>    image: jupyterlab:latest<br/>    ports:<br/>      - 8888:8888<br/>    volumes:<br/>      - my_volume:/project</span><span id="7beb" class="nz mh it ly b gy og ob l oc od">volumes:<br/>  my_volume:<br/>    external: true</span></pre><h2 id="1cd5" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">docker-compose文件剖析</h2><ul class=""><li id="dbd5" class="oh oi it lb b lc my lf mz li pm lm pn lq po lu om on oo op bi translated"><strong class="lb iu">版本:</strong>定义docker-compose的版本</li><li id="11c7" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">服务:</strong>这定义了容器。<code class="fe lv lw lx ly b">jupyter</code>可以改名为任何东西。然后，我们提供映像名称、我们正在连接的端口和我们正在连接的卷</li><li id="7a7c" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">卷:</strong>我们所连接的卷的名称，并声明它是外部的</li></ul><p id="d5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要启动我们的jupyterLab服务器，我们只需运行</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="5394" class="nz mh it ly b gy oa ob l oc od">docker-compose up</span></pre><p id="7132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您与docker-compose文件在同一个目录中。</p><p id="6620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您收到一条错误消息，指出您的外部卷不存在，那么您需要首先创建一个命名卷。使用docker-compose，您必须在连接之前确保该卷存在。</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="8729" class="nz mh it ly b gy oa ob l oc od">docker volume create conda-work</span></pre><h2 id="07cd" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">自定义JupyterLab令牌</h2><p id="a9da" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">要制作您自己的令牌，您只需将以下内容添加到<code class="fe lv lw lx ly b">services:</code></p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="8200" class="nz mh it ly b gy oa ob l oc od">environment:<br/>      JUPYTER_TOKEN: "docker"</span></pre><p id="c813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在从浏览器访问JupyterLab将永远是</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="b295" class="nz mh it ly b gy oa ob l oc od">localhost:8888/lab?token=docker</span></pre><h2 id="63ea" class="nz mh it bd mi ov ow dn mm ox oy dp mq li oz pa ms lm pb pc mu lq pd pe mw pf bi translated">想了解更多？</h2><p id="52aa" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个视频帮助我理解docker-compose</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pp pl l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6efd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">共享您的图像</h1><p id="a132" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这里，我将展示如何将您的映像推送到Docker Hub存储库。</p><p id="daf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，在Docker Hub上创建一个帐户</p><div class="nd ne gp gr nf ng"><a href="https://hub.docker.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">Docker Hub容器图像库|应用容器化</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">编辑描述</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">hub.docker.com</p></div></div></div></a></div><p id="d3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您构建映像时，它必须符合以下命名约定，以便推送至docker hub:</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="8f61" class="nz mh it ly b gy oa ob l oc od">docker_ID/image_name:tag</span></pre><ul class=""><li id="23b4" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><code class="fe lv lw lx ly b">docker_ID</code>是您注册Docker Hub时选择的名称</li><li id="36cd" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><code class="fe lv lw lx ly b">image_name</code>是您想要的图像名称吗</li><li id="a47b" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><code class="fe lv lw lx ly b">tag</code> is提供附加信息(新版本、不同架构等。)</li></ul><p id="22f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在从命令行登录Docker Hub</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="ad8f" class="nz mh it ly b gy oa ob l oc od">docker login -u docker_ID docker.io</span></pre><p id="3efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你将被提示输入密码(我强烈推荐<a class="ae ky" href="https://docs.docker.com/docker-hub/2fa/#:~:text=To%20enable%20two%2Dfactor%20authentication,to%20download%20an%20authenticator%20app." rel="noopener ugc nofollow" target="_blank">启用2FA </a>，因为安全很重要)</p><p id="fb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录后，只需将您的图像推送到回购</p><pre class="kj kk kl km gt nv ly nw nx aw ny bi"><span id="3396" class="nz mh it ly b gy oa ob l oc od">docker push docker_ID/image_name:tag</span></pre><p id="45ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，任何人都可以使用<code class="fe lv lw lx ly b">docker pull</code>来拉你的图像并运行它！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="76aa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="860f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我很喜欢Docker，认为这是与同事分享数据分析和透明分析的好方法。因为运行脚本所需的一切都打包在一起，所以减少了提取脚本和运行脚本之间的摩擦。</p><p id="c4cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个项目完成时，分析代码应该存储在一个代码库中，如GitHub或GitLab，并且应该创建一个Docker映像来轻松地重新创建结果。通过这种方式，代码是开放的，可以免费获得，并且分析可以通过Docker映像重现。</p><p id="bcb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我自己仍在学习这项技术，但我希望这篇文章能给你一些如何将自己的项目容器化的想法。一如既往，欢迎并鼓励提出意见和建议。</p><p id="8ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于如何缩小你的docker图片尺寸的建议，请看这个<a class="ae ky" href="https://jcristharif.com/conda-docker-tips.html" rel="noopener ugc nofollow" target="_blank">博客</a>。一些Docker最佳实践可以在<a class="ae ky" href="https://www.youtube.com/watch?v=8vXoMqWgbQQ&amp;list=PLy7NrYWoggjwk5fAX1q8gBNYrisYeHRxz" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我在这篇文章中描述的类似解决方案可以在<a class="ae ky" href="https://linuxhandbook.com/dockerize-python-apps/" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="762d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读和支持媒体作家</p><div class="nd ne gp gr nf ng"><a href="https://lukegloege.medium.com/membership" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">通过我的推荐链接加入Medium-Luke Gloege博士</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">lukegloege.medium.com</p></div></div><div class="np l"><div class="pq l nr ns nt np nu ks ng"/></div></div></a></div></div></div>    
</body>
</html>