# Python 函数的副作用

> 原文：<https://towardsdatascience.com/side-effects-of-python-functions-822fae38295e>

## 什么时候一个函数改变了一个定义在它自己作用域之外的变量？

您是否想知道 Python 函数如何改变在其作用域之外定义的变量？这可能会让来自其他语言的开发人员感到困惑，但是一旦您理解了一些基本原则，预测副作用就很简单了。

![](img/03e4e50403f8b67f3dd61cb48bcf7b01.png)

照片由[在](https://unsplash.com/@jannerboy62?utm_source=medium&utm_medium=referral) [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的刻痕拍摄

函数副作用可能很难调试，而且大多数时候都不是有意的。相反，从函数中返回对象最好使用带有单个对象或元组的 return 语句。在 Python 中，副作用可能以两种方式出现:

*   改变可变对象的值
*   更改在本地命名空间之外定义的变量的绑定

我们将通过一组例子来研究这些方面。在此之前，我们将重温 Python 如何向函数传递参数。

# 在 Python 中向函数传递参数

如果您使用过其他编程语言，您可能听说过按值传递和按引用传递这两个术语。按值传递意味着将参数的副本传递给函数，而按引用传递意味着函数接收对参数的引用。您可能会惊讶地听到 Python 没有使用以上两者。当我开始使用 Python 时，我感到完全困惑，因为我认为只有两种选择，而 Python 函数显然都不适合。

在使用 Python 传递函数参数的机制之前，让我们快速回顾一下 Python 中的名称绑定。考虑以下代码:

第一条语句做了两件事。首先，它创建一个字符串对象，然后将这个对象绑定到变量`a`。第二条语句将另一个变量`b`绑定到绑定到`a`的对象。第三条语句创建了另一个字符串对象并将变量`b`重新绑定到它，而`a`仍然绑定到字符串`'hello'`。假设仍然有一个变量绑定到字符串`'hello'`，它不会被垃圾收集。这看似琐碎，但要注意用词。我们没有使用诸如“将内存分配给一个字符串变量`a`并将字符串`'hello'`存储在其中”这样的表达式。相反，我们谈论创建对象并将变量绑定到它们。

那么可变对象呢，比如一个列表？以上同样适用于可变对象。然而，有一个警告。请看下面的代码:

那会打印

```
a -> 2199273128320 [10, 2, 3]
b -> 2199273128320 [10, 2, 3]
```

改变绑定到`a`的列表中的一个元素也会改变`b`。事实上，这种表达是有误导性的。只有一个列表，`a`和`b`都绑定到它，这可以从`id()`函数返回的内存位置中看出。

接下来让我们看一个函数:

这张照片

```
outside function x -> 140731263354656, 5
inside function x_f -> 140731263354656, 5
{'x_f': 5}
inside function x_f -> 140731263354816, 10
{'x_f': 10}
outside function x -> 140731263354656, 5
```

这是怎么回事？在调用该函数之前，我们创建了一个整数对象并将变量`x`绑定到它。然后将参数传递给函数。我们可以看到函数参数`x_f`被初始化到函数外部变量`x`所指向的相同内存位置。这反映在由`locals()`函数返回的函数的本地名称空间中。在函数内部，我们创建了一个新的 integer 对象，其值为`10`，被反弹到局部变量`x_f`。这不影响在函数外绑定到`x`的对象。我们可以通过`id()`函数返回的内存位置和显示变量`x`继续绑定到整数`5`的最终打印语句来确认这一点。

这是什么意思？我们显然没有通过引用传递参数，因为函数没有改变绑定到`x`的值。我们也没有通过值传递参数，因为最初`x_f`与`x`指向相同的内存位置。向 Python 函数传递参数遵循某种混合模式。我们可以说我们传递了一个引用，但是这个引用是通过值传递的，也就是所谓的通过赋值传递。一旦理解了 Python 中的变量绑定，这有点令人难以置信，但却是可以预见的。

# 改变可变对象的值

根据上一节，人们可能认为 Python 函数根本不能改变传递的参数。这是部分正确的。Python 函数不能完全改变参数，因为参数不能整体指向内存中的不同位置。如果函数内部的参数被绑定到一个新的对象，那么函数外部的参数就没有关系。然而，参数可以部分或全部改变，这是函数在 Python 中产生副作用的方式之一。让我们看一个例子:

那会打印

```
outside function x -> 2199273130560, [1, 2, 3]
inside function x_f -> 2199273130560, [1, 2, 3]
{'x_f': [1, 2, 3]}
inside function x_f -> 2199273130560, [1, 10, 3]
{'x_f': [1, 10, 3]}
outside function x -> 2199273130560, [1, 10, 3]
```

该函数有副作用，因为它改变了传递的参数数组的第二个元素。如果我们记住上面介绍的基本原则，这种行为是完全可以预测的。函数在函数外部定义的同一个数组上操作，正如我们从`id()`函数的输出中看到的，它总是打印相同的内存地址。

我们能改变数组的全部内容吗？下面的例子表明我们可以:

那会打印

```
outside function x -> 2199272856256, [1, 2, 3]
inside function x_f -> 2199272856256, [1, 2, 3]
{'x_f': [1, 2, 3]}
inside function x_f -> 2199272856256, [10, 20, 30, 40]
{'x_f': [10, 20, 30, 40]}
outside function x -> 2199272856256, [10, 20, 30, 40]
```

我们不仅改变了数组中所有元素的值，甚至还改变了它的长度。但是我们没有改变它的地址。当对象作为参数传递时，这是 Python 函数无法做到的。但是这可以通过第二种机制来实现，在第二种机制中，函数会引入副作用，我们将在下一节中看到。但在此之前，我想提一下，有一些方法可以在函数内部创建数组的本地副本，这样可以避免副作用，如下所示:

那会打印

```
outside function x -> 2199273194880, [1, 2, 3]
inside function x_f -> 2199273194880, [1, 2, 3]
{'x_f': [1, 2, 3]}
inside function x_f -> 2199272856256, [1, 10, 3]
{'x_f': [1, 10, 3]}
outside function x -> 2199273194880, [1, 2, 3]
```

我们可以看到，在函数中创建数组的副本防止了副作用。通过简单地将`x`的副本传递给函数，也就是用`f(x[:])`调用函数，也可以达到同样的效果。

但是在嵌套数组的情况下，事情仍然可能出错:

那会打印

```
outside function x -> 2199272857344, [1, [-1, -2, -3], 3]
inside function x_f -> 2199272857344, [1, [-1, -2, -3], 3]
inside function x_f -> 2199273194240, ['we guard against this side effect', [-1, 'we do not guard against this side effect', -3], 3]
outside function x -> 2199272857344, [1, [-1, 'we do not guard against this side effect', -3], 3]
```

上述行为可以用同样的基本原理来理解。在函数中复制数组意味着数组中不可变的元素在被改变时会被反弹。所有的元素都是不可变的，除了数组的第二个元素像以前一样绑定到同一个数组。我们可以用`id()`函数来验证这一点:

那会打印

```
outside function x
2199273306608, 1000
2199273249088, [-1000, -2000, -3000]
.. 2199273307216, -1000
.. 2199273307280, -2000
.. 2199273306448, -3000
2199273306384, 3000inside function x_f
2199273306608, 1000
2199273249088, [-1000, -2000, -3000]
.. 2199273307216, -1000
.. 2199273307280, -2000
.. 2199273306448, -3000
2199273306384, 3000inside function x_f
2199272920720, we guard against this side effect
2199273249088, [-1000, 'we do not guard against this side effect', -3000]
.. 2199273307216, -1000
.. 2199273257072, we do not guard against this side effect
.. 2199273306448, -3000
2199273306384, 3000outside function x
2199273306608, 1000
2199273249088, [-1000, 'we do not guard against this side effect', -3000]
.. 2199273307216, -1000
.. 2199273257072, we do not guard against this side effect
.. 2199273306448, -3000
2199273306384, 3000
```

使用`copy`模块的`deepcopy()`功能实际上是避免副作用的最安全的方法。

# 更改在本地命名空间之外定义的变量的绑定

使用变量时，Python 会在四个名称空间中进行搜索:局部、封闭、全局和内置。按照这个顺序搜索名称空间，直到找到名称，如果没有找到，Python 会抛出一个`NameError`异常。我们不会涉及名称空间的所有讨厌的细节(如果你好奇的话，请参阅本教程[和](https://realpython.com/python-namespaces-scope/)),而是把重点放在全局和局部名称空间上。让我们看一个例子:

印刷品

```
{'x': 'local'}
global
```

原因是我们在函数内部创建了一个新的 string 对象，并将一个名为`x`的局部变量绑定到它，正如`locals()`函数的输出所示。正如我们所预期的，全局变量`x`被绑定到字符串`'global'`。将以上内容与以下内容进行对比:

那会打印

```
{}
local
```

我们可以看到，函数外部的变量`x`现在被绑定到函数内部创建的 string 对象。这是一个副作用，也是应该避免的事情的主要例子。同样可以通过直接访问全局字典来实现。事实上，在调用函数之前，甚至没有必要绑定变量`x`:

那会打印

```
{}
local
```

这实际上是可怕的做法。没有看过函数内部的读者会感到困惑。与`global`类似，在嵌套函数中使用`nonlocal`也会产生副作用。

有副作用的函数会导致难以发现的错误。如果副作用是有意的，则需要在函数 docstring 中彻底记录。但即使这样也不理想，因为为有副作用的函数编写测试可能更难。通常，很少需要在局部范围之外修改变量，通常有更好的方法来达到相同的结果。每当传递可变参数时，都要仔细考虑函数可能会无意中对它们做什么，并采取预防措施来防止意外的副作用。