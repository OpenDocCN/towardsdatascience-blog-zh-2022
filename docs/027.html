<html>
<head>
<title>Harnessing programming techniques to improve R scripts:</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用编程技术改进R脚本:</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/harnessing-programming-techniques-to-improve-r-scripts-e28d09fa0489#2022-01-02">https://towardsdatascience.com/harnessing-programming-techniques-to-improve-r-scripts-e28d09fa0489#2022-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="1836" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">利用编程技术改进R脚本:</h1></div><div class=""><h2 id="2212" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用循环和函数自动化重复性任务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04157dc69a9f4380e1c90ec9badb6d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dk0xNd-lAUfMS2v85lvTEw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自Pexels的Quang Nguyen Vinh</p></figure><p id="84a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多R用户是从统计学背景而不是编程/软件工程背景进入R编程的，他们以前使用过SPSS、Excel等软件。因此，他们可能不了解一些可以用来改进代码的编程技术。这可以包括使代码更加模块化，从而更容易发现和解决错误，但也可以用于自动化重复的任务，如制作表格和绘图等。</p><p id="d3d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇短文包括一些基本的编程技术，可以用来提高R脚本的质量和可维护性。如果你执行的是重复的任务，而这些重复的任务只有很小的不同，那么这也会节省你大量的时间。我们假设您对用r编写简单的脚本有基本的了解。</p><p id="ec56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从一个简单的例子开始。假设我们有几个不同小组的数据。在这种情况下，有3种动物(老虎、天鹅和獾)，我们收集了一些与此相关的数据(某种分数和数值)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/63a7cee067feaf9cb17ff28761574b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*luZluOf7-TUh0BZB5YqnYg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="d933" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以将它作为CSV文件读入R，或者将其重新创建为数据帧，如下所示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8094" class="lx ly iq lt b gy lz ma l mb mc">df &lt;- data.frame(group = rep(c("tiger","swan","badger"), 6), <br/> score = c(12,32,43,53,26,56,56,32,23,53,24,65,23,78,23,56,25,75), <br/> val = c(24,67,32,21,21,56,54,21,35,67,34,23,32,36,74,24,24,74))</span></pre><p id="5016" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用r中的向量来表示值的列表/列。这是通过使用<code class="fe md me mf lt b">c</code>函数将这些值放在逗号分隔的列表中来实现的，该函数用于将值组合成一个向量。例如数字1到4:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8c93" class="lx ly iq lt b gy lz ma l mb mc">my_list &lt;- c(1,2,3,4)</span></pre><p id="eb2b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们通过输入列表的名称来输出列表:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="35fb" class="lx ly iq lt b gy lz ma l mb mc">my_list</span></pre><p id="a331" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哪些输出:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8667" class="lx ly iq lt b gy lz ma l mb mc">[1] 1 2 3 4</span></pre><p id="299b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们用它来为列<code class="fe md me mf lt b">score</code>和<code class="fe md me mf lt b">val</code>提供数据框中的值。我们可以对<code class="fe md me mf lt b">group</code>列做同样的事情，添加6批“老虎”、“天鹅”和“獾”。相反，我们使用<code class="fe md me mf lt b">rep</code>(复制)函数将这些值重复6次。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b38f" class="lx ly iq lt b gy lz ma l mb mc">rep(c("tiger","swan","badger"), 6)</span></pre><p id="6125" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据框中每一列的值的数量需要相同，否则R将产生错误。</p><p id="7b3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用几种方法查看R中的数据帧。我们可以输入数据帧的名称:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ab27" class="lx ly iq lt b gy lz ma l mb mc">df</span></pre><p id="f9d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哪些输出:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a017" class="lx ly iq lt b gy lz ma l mb mc">  group score val<br/>1 tiger    12  24<br/>2 swan     32  67<br/>3 badger   43  32<br/>4 tiger    53  21<br/>5 swan     26  21<br/>6 badger   56  56<br/>7 tiger    56  54<br/>8 swan     32  21<br/>9 badger   23  35<br/>10 tiger   53  67<br/>11 swan    24  34<br/>12 badger  65  23<br/>13 tiger   23  32<br/>14 swan    78  36<br/>15 badger  23  74<br/>16 tiger   56  24<br/>17 swan    25  24<br/>18 badger  75  74</span></pre><p id="68da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你用的是R studio。查看功能(大写V)将在新选项卡中打开数据框，并以表格格式显示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5e4b" class="lx ly iq lt b gy lz ma l mb mc">View(df)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/09a6a0e5140ca5fca42d624b142deeea.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*Ca3yBXuCnrWt95uKlAU97A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“查看”功能的输出。作者图片</p></figure><p id="8004" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以通过单击向上/向下箭头对列进行排序。<code class="fe md me mf lt b">utils</code>包中还有另一个视图功能(包含实用功能)，可以这样访问:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="612b" class="lx ly iq lt b gy lz ma l mb mc">utils::View(df)</span></pre><p id="59ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将在弹出窗口中打开数据框，如下图所示。当您想要在不切换标签的情况下同时比较代码和数据时，这很有用。这也将显示比其他<code class="fe md me mf lt b">View</code>功能更多的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/63a7cee067feaf9cb17ff28761574b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*luZluOf7-TUh0BZB5YqnYg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">“utils”中“View”函数的输出。作者图片</p></figure><p id="3c28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设现在我们有一些数据，我们想要绘制三个组中每个组的分数和值。</p><p id="9b33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先我们可以导入一些有用的库。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f7bf" class="lx ly iq lt b gy lz ma l mb mc">library(ggplot2)<br/>library(tidyverse)</span></pre><p id="756a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe md me mf lt b">ggplot2</code>库用于制作出版质量图。<code class="fe md me mf lt b">tidyverse</code>库有一些有用的功能，可以过滤和传输来自数据集的数据。例如，我们可以从数据帧中选择与特定组相对应的数据，例如“老虎”。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="df6a" class="lx ly iq lt b gy lz ma l mb mc">selected_group &lt;- df %&gt;% filter(group == "tiger")</span></pre><p id="4000" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们将数据<code class="fe md me mf lt b">%&gt;%</code>从数据帧传输到名为<code class="fe md me mf lt b">selected_group</code>的变量中，通过选择对应于“tiger”的组值来过滤组名。接下来，我们可以创建一个简单的散点图，如下所示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1f91" class="lx ly iq lt b gy lz ma l mb mc">plt1 &lt;- selected_group %&gt;% ggplot(aes(x = val, y = score)) +<br/>    geom_point(size=2) +<br/>    labs(x = "Val", y = "Score") +<br/>    ggtitle("Plot of score/val for tiger group")</span></pre><p id="62c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe md me mf lt b">ggplot</code>包的工作原理是用不同的信息向图表添加图层，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/d07a537b827077cb4e6c59b6d8772db8.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*pckWJ_qW4HNjhZre0BqFjA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">绘制图层。作者图片</p></figure><p id="a130" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们添加了一个美学(aes)来定义x和y轴的值。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a8bb" class="lx ly iq lt b gy lz ma l mb mc">ggplot(aes(x = val, y = score))</span></pre><p id="050a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们添加点(圆点)，设置它们的大小为2。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1dc5" class="lx ly iq lt b gy lz ma l mb mc">geom_point(size=2)</span></pre><p id="ee97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们添加轴标签:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b035" class="lx ly iq lt b gy lz ma l mb mc">labs(x = "Val", y = "Score")</span></pre><p id="3806" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有一个剧情标题:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="50c2" class="lx ly iq lt b gy lz ma l mb mc">ggtitle("Plot of score/val for tiger group")</span></pre><p id="aa10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以输出该图:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="60ed" class="lx ly iq lt b gy lz ma l mb mc">plt1</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/fd38145b5eaeeded9c15f39b6e8ae2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*A2VB-ywO0FBWM6x6XPC3dg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示分数和价值的老虎组图(图片由作者提供)</p></figure><p id="3a8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以简单地剪切和粘贴这些内容，并针对不同的组进行修改:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="43be" class="lx ly iq lt b gy lz ma l mb mc">selected_group &lt;- df %&gt;% filter(group == "tiger")</span><span id="625b" class="lx ly iq lt b gy mj ma l mb mc">plt1 &lt;- selected_group %&gt;% ggplot(aes(x = val, y = score)) +<br/>    geom_point(size=2) +<br/>    labs(x = "Val", y = "Score") +<br/>    ggtitle("Plot of score/val for tiger group")<br/>plt1</span><span id="4d6d" class="lx ly iq lt b gy mj ma l mb mc">selected_group &lt;- df %&gt;% filter(group == "swan")</span><span id="dd8e" class="lx ly iq lt b gy mj ma l mb mc">plt2 &lt;- selected_group %&gt;% ggplot(aes(x = val, y = score)) +<br/>    geom_point(size=2) +<br/>    labs(x = "Val", y = "Score") +<br/>    ggtitle("Plot of score/val for swan group")<br/>plt2</span><span id="67b3" class="lx ly iq lt b gy mj ma l mb mc">selected_group &lt;- df %&gt;% filter(group == "badger")</span><span id="30a4" class="lx ly iq lt b gy mj ma l mb mc">plt3 &lt;- selected_group %&gt;% ggplot(aes(x = val, y = score)) +<br/>    geom_point(size=2) +<br/>    labs(x = "Val", y = "Score") +<br/>    ggtitle("Plot of score/val for badger group")<br/>plt3</span></pre><p id="6d64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这样做可行，但是存在不必要的代码重复。想象你有更多的小组，10个，100个，更多？这种方法是不可扩展的，任何改变都需要应用于每个图(例如，改变点的大小需要应用于所有图)。理想情况下，您希望尽可能多地重用代码。这减少了维护工作，并扩展了您的代码以处理任何数量的潜在组。</p><h2 id="0c52" class="lx ly iq bd mk ml mm dn mn mo mp dp mq le mr ms mt li mu mv mw lm mx my mz na bi translated">使用循环</h2><p id="55c9" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">改善这种情况的一种方法是使用“循环”。循环是一种编程结构，它允许我们重复一定次数的代码块，或者直到满足特定的条件。为了将代码重复设定的次数，通常使用一个<code class="fe md me mf lt b">for</code>循环。</p><p id="f560" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将创建一个包含3个组的名称的向量:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3c7d" class="lx ly iq lt b gy lz ma l mb mc">groups &lt;- c("tiger","swan","badger")</span></pre><p id="fd28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们可以创建一个从1开始重复3次的循环(每组一次)。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="4718" class="lx ly iq lt b gy lz ma l mb mc">for(i in 1:3)<br/>{<br/>}</span></pre><p id="c007" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大括号({ })之间的每一行代码重复3次。我们还有一个叫做<code class="fe md me mf lt b">i</code>的循环计数器。每次执行循环内容时，这个值都会自动增加。在编程中，传统的做法是将循环计数器命名为I，j，k，x，y等。尽管你可以用任何你喜欢的名字来命名你的循环计数器。</p><p id="bfa9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，您需要考虑如何修改原始代码块，使其在循环中工作。哪些位是所有组通用的，哪些位需要更改以反映不同的组？主要的变化在于我们筛选的分组和图表标题。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a901" class="lx ly iq lt b gy lz ma l mb mc">selected_group &lt;- df %&gt;% filter(group == groups[i])</span></pre><p id="15ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以在我们的<code class="fe md me mf lt b">groups</code>向量中改变所选的组，使其被感兴趣的组过滤。循环计数器<code class="fe md me mf lt b">i</code>可以用来指向从1 (tiger)开始的向量中不同的组名。接下来，我们可以为标题创建一个变量，并使用<code class="fe md me mf lt b">paste0</code>函数将文本的标题字符串连接起来，更新它以显示相关组的名称:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9949" class="lx ly iq lt b gy lz ma l mb mc">group_title &lt;- paste0("Plot of score/val for ", groups[i], "group")</span></pre><p id="a259" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成的循环图如下所示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="900f" class="lx ly iq lt b gy lz ma l mb mc">groups &lt;- c("tiger","swan","badger")</span><span id="ddde" class="lx ly iq lt b gy mj ma l mb mc">for(i in 1:3)<br/>{<br/>    selected_group &lt;- df %&gt;% filter(group == groups[i])<br/>    group_title &lt;- paste0("Plot of score/val for ", groups[i], "group")<br/>    plt &lt;- selected_group %&gt;% ggplot(aes(x = val, y = score)) +  <br/>    geom_point(size=2) +<br/>    labs(x = "Val", y = "Score") +<br/>    ggtitle(group_title)</span><span id="8031" class="lx ly iq lt b gy mj ma l mb mc">    print(plt)<br/>}</span></pre><p id="9012" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一的变化是使用<code class="fe md me mf lt b">print</code>功能来显示图表。由于某种原因，如果在循环和函数中没有使用打印功能，则不会显示图形。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/7712c685ed13de0293794038f5928644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmrLXDiqz4u6HpPj4wHuAw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用循环输出的三个图(图片由作者提供)</p></figure><p id="25fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一种使其更加健壮的方法是，不要“硬编码”循环应该运行的次数，因为将来组的列表可能会扩展，或者相反，项目会被删除。相反，我们可以使用<code class="fe md me mf lt b">length</code>函数返回组向量中的项目数。这样，如果从vector中添加或删除项目，它将始终工作。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f308" class="lx ly iq lt b gy lz ma l mb mc">for(i in 1:length(groups))<br/>{<br/>    …<br/>}</span></pre><p id="db3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们还可以使用在groups列中查找所有唯一组名的功能来更改vector中的显式组名。这对于3个组来说似乎没什么大不了的，但是再一次考虑这对于更大数量的组和/或更大的数据集来说如何更有用，以确保没有组被遗漏。</p><p id="7ebb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将改变这一点:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="858b" class="lx ly iq lt b gy lz ma l mb mc">groups &lt;- c("tiger","swan","badger")</span></pre><p id="7f7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">变成这样:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3c82" class="lx ly iq lt b gy lz ma l mb mc">groups &lt;- unique(df$group)</span></pre><p id="b7c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这实际上返回了数据框的group列中所有唯一项的向量，因此您最终会得到一个更健壮的原始版本，它会自动选取数据框中添加/删除的新组。</p><h2 id="2060" class="lx ly iq bd mk ml mm dn mn mo mp dp mq le mr ms mt li mu mv mw lm mx my mz na bi translated">使用函数</h2><p id="931a" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">可以进一步改进的另一种方法是将这段代码放入一个函数中。函数允许你模块化你的代码，使得追踪问题、阅读代码以及以一种逻辑的方式将功能组合在一起变得更加容易。代码块可以放在函数中，只在函数被调用时运行(执行)。数据可以传递给函数进行处理，函数也可以返回数据，尽管您不需要向所有函数提供数据，也不是所有函数都返回数据。这方面的一个例子是将一个数字向量传递给一个函数，该函数计算这些数字的平均值，然后返回计算结果。</p><p id="3f0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们创建了一个名为<code class="fe md me mf lt b">generateGroupScatterPlots</code>的函数，使用变量<code class="fe md me mf lt b">current_group</code>传入数据帧和感兴趣的组，更新代码以使用我们传入的组。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="66fe" class="lx ly iq lt b gy lz ma l mb mc">generateGroupScatterPlots &lt;- function(df, current_group)<br/>{<br/>    selected_group &lt;- df %&gt;% filter(group == current_group)<br/>    group_title &lt;- paste0("Plot of score/val for ", current_group, "group")</span><span id="399f" class="lx ly iq lt b gy mj ma l mb mc">    plt &lt;- selected_group %&gt;% ggplot(aes(x = val, y = score)) +<br/>        geom_point(size=2) +<br/>        labs(x = "Val", y = "Score") +<br/>        ggtitle(group_title)</span><span id="91df" class="lx ly iq lt b gy mj ma l mb mc">    print(plt)<br/>}</span></pre><p id="49ea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该函数在被调用之前不会运行。为了执行这个函数，我们需要调用它的名字并传入任何可能需要的参数。我们调用循环中的函数，传递数据帧和感兴趣的组<code class="fe md me mf lt b">groups[i]</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="34c1" class="lx ly iq lt b gy lz ma l mb mc">groups &lt;- unique(df$group)</span><span id="e4f1" class="lx ly iq lt b gy mj ma l mb mc">for(i in 1:length(groups))<br/>{<br/>    generateGroupScatterPlots(df, groups[i])<br/>}</span></pre><p id="a2dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当试图利用循环和函数时，人们经常遇到的另一个问题是动态访问数据帧中的列。例如，假设我们想要对包含数字数据的列求和，您通常会通过指定dataframe来访问R中的列，然后指定用美元符号<code class="fe md me mf lt b">$</code>分隔的列名:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="39f6" class="lx ly iq lt b gy lz ma l mb mc">df$score</span></pre><p id="9424" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以使用打印功能或查看功能之一来查看该列:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3d43" class="lx ly iq lt b gy lz ma l mb mc">utils::View(df$score)</span></pre><p id="752d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们如何修改它来使用一个变量呢？在R中做同样事情的另一种方法是使用列表符号，它由一组双方括号组成:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="bf64" class="lx ly iq lt b gy lz ma l mb mc">df[["score"]]</span></pre><p id="d9f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将给出与使用美元符号相同的结果。然后，我们可以创建一个变量来指向不同的列名，我们可以使用这种符号，但不使用双引号。例如:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="09f3" class="lx ly iq lt b gy lz ma l mb mc">score_col &lt;- "score"<br/>utils::View(df[[score_col]])</span></pre><p id="70a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以使用一个循环对所有感兴趣的列求和。同样，在本例中，只有两个，因此这没问题:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="767c" class="lx ly iq lt b gy lz ma l mb mc">print(sum(df$score))<br/>print(sum(df$val))</span></pre><p id="388d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，假设您有更多的列，并且您可能还想计算其他指标，如标准差、平均值、总和等。这就是循环的威力所在。首先，我们需要存储感兴趣的列的名称。我们可以做:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8ca7" class="lx ly iq lt b gy lz ma l mb mc">col_names &lt;- c("score", "val")</span></pre><p id="1762" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一种方法是使用<code class="fe md me mf lt b">colnames</code>函数，并通过数字(即数字2和3，忽略组名的第一列)指定我们想要保留的列名。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="cd28" class="lx ly iq lt b gy lz ma l mb mc">col_names &lt;- colnames(df)[2:3]</span></pre><p id="31a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以对输出总和、平均值和标准差的列进行循环:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c419" class="lx ly iq lt b gy lz ma l mb mc">for(i in 1:length(col_names))<br/>{<br/>    col &lt;- col_names[i]<br/>    cat("\n\nColumn: ", col, "\n")<br/>    print(sum(df[[col]]))<br/>    print(mean(df[[col]]))<br/>    print(sd(df[[col]]))<br/>}</span></pre><p id="8f84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它产生以下输出:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7218" class="lx ly iq lt b gy lz ma l mb mc">Column: score<br/>[1] 755<br/>[1] 41.94444<br/>[1] 19.99551</span><span id="12df" class="lx ly iq lt b gy mj ma l mb mc">Column: val<br/>[1] 719<br/>[1] 39.94444<br/>[1] 19.65428</span></pre><p id="b6e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，我们取列名，并将其存储在名为<code class="fe md me mf lt b">col</code>的变量中。然后，我们使用列表符号[[ ]]添加变量名<code class="fe md me mf lt b">col</code>，每次循环运行指向向量中的下一列时，变量名都会更新。<code class="fe md me mf lt b">cat</code>函数(concatenate and print)用于显示输出中的列名。<code class="fe md me mf lt b">\n</code>表示我们需要一个新行(回车)来防止文本出现在同一行。</p><p id="6713" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们以最后一个例子来结束，把这些想法放在一起。假设我们有一个不同的数据集，看起来像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e9be6d70771ea599eed3d3084d30ebc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*By5yGPwxb5NzhDfQ9OUjUA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="04d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们有5名不同疾病分类的参与者，例如心脏问题、呼吸问题和代谢问题。1表示他们有那一类的情况，0表示他们没有。同样，死亡列中的1表示他们已经死亡，0表示他们仍然活着(或者在收集数据时仍然活着)。你可以想象有更多的参与者和更多的疾病分类。假设我们想要获取死于各种疾病的人数。同样，在这种情况下，只需查看表就可以相对容易地做到这一点，但我们希望编写可扩展的代码，以处理更大的数据集和具有许多行和列的问题。</p><p id="0169" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们编写一些代码来输出每个类别中死亡的人数。我们将从计算每个类别中的死亡人数的函数开始:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a3b6" class="lx ly iq lt b gy lz ma l mb mc">deathsPerCategory &lt;- function(df, col_name)<br/>{<br/>    cols_to_keep &lt;- c("id", "death", col_name)<br/>    selected_col &lt;- df %&gt;% select(cols_to_keep)<br/>    filtered_col &lt;- subset(selected_col, selected_col[[col_name]] == 1 &amp; selected_col$death == 1)<br/>    table &lt;- filtered_col %&gt;% group_by(death) %&gt;% summarise(n=n(), .groups = ‘drop’)<br/>    <br/>    return(table$n)<br/>}</span></pre><p id="d345" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与前面的例子类似，我们传入数据帧和感兴趣的列的名称。接下来，我们创建一个向量，其中包含我们希望保留在数据框中的列。这是<code class="fe md me mf lt b">id</code>和<code class="fe md me mf lt b">death</code>列以及感兴趣的列。接下来，我们使用<code class="fe md me mf lt b">select</code>函数从数据帧中选择这些列。然后，我们使用<code class="fe md me mf lt b">subset</code>函数进一步对其进行子集划分，以过滤数据，从而在死亡列和感兴趣的疾病类别列中都需要有“1”。接下来，我们通过按<code class="fe md me mf lt b">death</code>分组并汇总死亡人数来生成一个表格。最后，我们返回这个汇总值进行输出。</p><p id="ee5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们可以在一个循环中使用这个函数来输出3个疾病类别的摘要。首先，我们需要从列名中获取疾病类别名称:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="33fb" class="lx ly iq lt b gy lz ma l mb mc">col_names &lt;- colnames(df)[2:4]</span></pre><p id="9876" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们可以在循环中使用它来输出每个类别的列名和死亡人数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="865b" class="lx ly iq lt b gy lz ma l mb mc">for (i in 1:length(col_names)) <br/>{<br/>    cat("\n", col_names[i], "deaths = ", deathsPerCategory(df, col_names[i]), "\n")<br/>}</span></pre><p id="71fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将产生以下输出，我们可以通过查看该表来确认:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="54fd" class="lx ly iq lt b gy lz ma l mb mc">cardiac deaths = 1</span><span id="9c98" class="lx ly iq lt b gy mj ma l mb mc">respiratory deaths = 1</span><span id="95ca" class="lx ly iq lt b gy mj ma l mb mc">metabolic deaths = 2</span></pre><p id="c515" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整代码:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ea51" class="lx ly iq lt b gy lz ma l mb mc">library(tidyverse)</span><span id="3dda" class="lx ly iq lt b gy mj ma l mb mc">deathsPerCategory &lt;- function(df, col_name)<br/>{<br/>    cols_to_keep &lt;- c("id", "death", col_name)<br/>    selected_col &lt;- df %&gt;% select(cols_to_keep)<br/>    filtered_col &lt;- subset(selected_col, selected_col[[col_name]] == 1 &amp; selected_col$death == 1)<br/>    table &lt;- filtered_col %&gt;% group_by(death) %&gt;% summarise(n=n(), .groups = "drop")</span><span id="99ec" class="lx ly iq lt b gy mj ma l mb mc">    return(table$n)<br/>}</span><span id="8c38" class="lx ly iq lt b gy mj ma l mb mc">col_names &lt;- colnames(df)[2:4]</span><span id="04fe" class="lx ly iq lt b gy mj ma l mb mc">for (i in 1:length(col_names)) <br/>{<br/>    cat("\n", col_names[i], "deaths = ", deathsPerCategory(df, col_names[i]), "\n")<br/>}</span></pre><p id="537f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管这里给出的例子使用的是小数据集，但希望您能够看到考虑和构建扩展代码以处理更大数据集和更复杂问题的能力的优势。这使得代码更易于管理、维护和修改，而不必重复不必要的代码。数据科学家的技能之一是能够在分析中利用编程技术，以使用Excel等软件无法处理的方式处理大量数据。如果您正从其他更直观的电子表格风格的软件转向R，那么使用R和Python之类的工具的主要优势之一就是能够以这种方式扩展您的代码。例如，我通常会先编写代码来生成一个单独的图或计算，检查我是否得到了正确的/期望的输出，然后使用函数、循环等来重构代码。来处理剩余的任务。开始时可能看起来更复杂，但随着时间的推移，对于大型数据集，从长远来看，这将为您节省更多时间，因为单个更改可以级联到所有的图、表、计算中，从而使更改变得简单快捷。</p></div></div>    
</body>
</html>