<html>
<head>
<title>30 Very Useful Pandas Functions for Everyday Data Analysis Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">30个非常有用的熊猫函数，用于日常数据分析任务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/30-very-useful-pandas-functions-for-everyday-data-analysis-tasks-f1eae16409af#2022-01-04">https://towardsdatascience.com/30-very-useful-pandas-functions-for-everyday-data-analysis-tasks-f1eae16409af#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b8a57006bb23a9d1cfbca17f1252a420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jpQsM-g5l4CBAcxg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">卢卡斯·森奇尼在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""><h1 id="f2ac" class="pw-post-title jh ji jj bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">30个非常有用的熊猫函数，用于日常数据分析任务</h1></div><div class=""><h2 id="890b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">熊猫小型张</h2></div><p id="4365" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python的Pandas库是Python中使用最广泛的库。因为这是数据分析或机器学习的每个方面都需要的数据操作库。即使你正在进行数据可视化或机器学习，一些数据操作仍然会存在。在本文中，我将列出日常使用所必需的Pandas函数，这些函数可能足以执行常规的数据操作任务。</p><p id="313d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将使用来自Kaggle的公共数据集FIFA dataset。</p><p id="8562" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">这里提到的用户许可是</em><a class="ae jg" href="https://www.kaggle.com/stefanoleone992/fifa-21-complete-player-dataset/metadata" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a><em class="lu">。</em></p><p id="294e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意从这里下载数据集:</p><div class="is it gp gr iu lv"><a href="https://github.com/rashida048/Datasets/blob/master/fifa.csv" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">master rashida048/Datasets上的Datasets/fifa.csv</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在GitHub上创建一个帐户，为rashida048/Datasets开发做出贡献。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ja lv"/></div></div></a></div><p id="5941" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好戏开始了！</p><p id="cd17" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我正在导入必要的包和数据集:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6a2b" class="mt mu jj mp b gy mv mw l mx my">import numpy as np<br/>import pandas as pd<br/>pd.set_option('display.max_columns', 100)</span></pre><p id="6f3c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始讨论功能:</p><h2 id="cffe" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">1.pd.read_csv，pd.read_excel</h2><p id="b480" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">首先要提到的函数是read_csv或者read_excel。到目前为止，我在每个项目中至少使用了其中一个函数。这些函数已经不言自明了。它们用于将CSV或excel文件读取为pandas DataFrame格式。这里我使用read_csv函数来读取FIFA数据集:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="368b" class="mt mu jj mp b gy mv mw l mx my">df = pd.read_csv("fifa.csv")</span></pre><p id="7bd6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有一个关于read_csv函数的详细视频。它有几个很好的参数，可以帮助您在读取数据集时稍微清理一下数据集。我这里有一篇详细的文章:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/import-csv-files-as-pandas-dataframe-with-skiprows-skipfooter-usecols-index-col-and-header-fbf67a2f92a"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">导入CSV文件为Pandas DataFrame，带有skiprows、skipfooter、usecols、index_col和header…</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">学习使用read_csv函数及其提供的一些非常有用的参数</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="nv l mg mh mi me mj ja lv"/></div></div></a></div><p id="6c4f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">答。txt文件也可以使用。read_csv()函数使用以下语法:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="791a" class="mt mu jj mp b gy mv mw l mx my">data = pd.read_csv(file.txt, sep=" ")</span></pre><blockquote class="nw nx ny"><p id="68c1" class="ky kz lu la b lb lc kk ld le lf kn lg nz li lj lk oa lm ln lo ob lq lr ls lt im bi translated">如果您有一个excel文件而不是csv文件，您将使用pd.read_excel。</p></blockquote><p id="2c11" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也是常用的。head()函数在read_csv或read_excel后查看数据帧。默认情况下，它显示数据帧的前5行。在这里，我展示了上面数据帧df的前五行:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="63e2" class="mt mu jj mp b gy mv mw l mx my">df.head()</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/c806686594e57b61cba1cc95cfd9b9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kg45KL80gse3I4I71fZUyA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="8712" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想要特定的行数而不是5行，您可以指定。如果我想要7行，我会在。head()函数作为参数。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8ea8" class="mt mu jj mp b gy mv mw l mx my">df.head(7)</span></pre><h2 id="acb5" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">2.df.columns</h2><p id="0a8e" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">当你有这么大的数据集时，很难看到所有的列。使用。columns函数，可以打印出数据集的所有列:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a303" class="mt mu jj mp b gy mv mw l mx my">df.columns</span></pre><p id="206c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="07ed" class="mt mu jj mp b gy mv mw l mx my">Index(['Unnamed: 0', 'sofifa_id', 'player_url', 'short_name', 'long_name', 'age', 'dob', 'height_cm', 'weight_kg', 'nationality', 'club_name', 'league_name', 'league_rank', 'overall', 'potential', 'value_eur', 'wage_eur', 'player_positions', 'preferred_foot', 'international_reputation', 'weak_foot', 'skill_moves', 'work_rate', 'body_type', 'real_face', 'release_clause_eur', 'player_tags', 'team_position', 'team_jersey_number', 'loaned_from', 'joined', 'contract_valid_until', 'nation_position', 'nation_jersey_number', 'pace', 'shooting', 'passing', 'dribbling', 'defending', 'physic', 'gk_diving', 'gk_handling', 'gk_kicking', 'gk_reflexes', 'gk_speed', 'gk_positioning', 'player_traits', 'attacking_crossing', 'attacking_finishing', 'attacking_heading_accuracy', 'attacking_short_passing', 'attacking_volleys', 'skill_dribbling', 'skill_curve', 'skill_fk_accuracy', 'skill_long_passing', 'skill_ball_control', 'movement_acceleration', 'movement_sprint_speed', 'movement_agility', 'movement_reactions', 'movement_balance', 'power_shot_power', 'power_jumping', 'power_stamina', 'power_strength', 'power_long_shots', 'mentality_aggression', 'mentality_interceptions', 'mentality_positioning', 'mentality_vision', 'mentality_penalties',<br/>'mentality_composure', 'defending_marking', 'defending_standing_tackle', 'defending_sliding_tackle', 'goalkeeping_diving', 'goalkeeping_handling', 'goalkeeping_kicking', 'goalkeeping_positioning', 'goalkeeping_reflexes'], dtype='object')</span></pre><h2 id="876d" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">3.df.drop()</h2><p id="db02" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">您可以使用df.drop()删除一些不必要的列。在这个数据集中，我们有如此多的列，我们不打算在本教程中使用它们。所以，我们可以很容易地放弃一些:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5379" class="mt mu jj mp b gy mv mw l mx my">df = df.drop(columns=['Unnamed: 0', 'weak_foot', 'real_face'])</span></pre><p id="f2f2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我只是掉了这三列:‘未命名:0’，‘弱_足’，‘真_脸’。</p><h2 id="0478" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">4.。len()</h2><p id="ab63" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">为提供数据帧的长度。让我们看一个例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="cfb2" class="mt mu jj mp b gy mv mw l mx my">len(df)</span></pre><p id="a7cd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="488e" class="mt mu jj mp b gy mv mw l mx my">16155</span></pre><p id="a593" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个数据帧有16155行数据。</p><h2 id="b925" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated"><a class="ae jg" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.query.html" rel="noopener ugc nofollow" target="_blank"> 5。df.query() </a></h2><p id="080c" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">您可以使用布尔表达式进行过滤或查询。在这个例子中，我将使用“射门”和“传球”列。在这里，我检查哪些行“射门”大于“传球”。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b951" class="mt mu jj mp b gy mv mw l mx my">df.query("shooting &gt; passing")</span></pre><p id="db62" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将只返回投篮大于传球的行。</p><h2 id="e350" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">6.df.iloc()</h2><p id="aa0e" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">该函数将行和列索引作为参数，并相应地给出数据帧的子集。这里我取前10行数据，索引第5到第10列:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c2cd" class="mt mu jj mp b gy mv mw l mx my">df.iloc[:10, 5:10]</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/904f26ade38166922695d2776e571c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*X07Q2hmMHoX67-z1UL66GQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="8f0f" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">7.df.loc()</h2><p id="054e" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">这个函数的操作与。iloc()函数。但是在这里，我们可以准确地指定我们想要的行索引，以及我们希望在子集中包含的列的名称。这里有一个例子:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="528f" class="mt mu jj mp b gy mv mw l mx my">df.loc[[3, 10, 14, 23], ['nationality', 'weight_kg', "height_cm"]]</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/68c55399ec2a095a3794285b77fda616.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*SKl1nx-kg_DGG-K5YIGqdQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="0df4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看行索引。我们只有第3、10、14和23排。另一方面，对于列，我们只有指定的列。</p><h2 id="37cb" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">8.df['']。数据类型</h2><p id="445b" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">另一个非常基本和广泛使用的功能。因为在我们深入分析、可视化或预测建模之前，有必要知道变量的数据类型。我正在使用获取“height_cm”列的数据类型。此处的dtypes函数:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c44b" class="mt mu jj mp b gy mv mw l mx my">df.height_cm.dtypes</span></pre><p id="9d2d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="20c4" class="mt mu jj mp b gy mv mw l mx my">dtype('int64')</span></pre><p id="aebd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以选择使用以下语法获取每一列的数据类型:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3422" class="mt mu jj mp b gy mv mw l mx my">df.dtypes</span></pre><p id="9702" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fe80" class="mt mu jj mp b gy mv mw l mx my">height_cm                     int64<br/>weight_kg                     int64<br/>nationality                  object<br/>random_col                    int32<br/>club_name                    object<br/>league_name                  object<br/>league_rank                 float64<br/>overall                       int64<br/>potential                     int64<br/>value_eur                     int64<br/>wage_eur                      int64<br/>player_positions             object<br/>preferred_foot               object<br/>international_reputation      int64<br/>skill_moves                   int64<br/>work_rate                    object<br/>body_type                    object<br/>team_position                object<br/>team_jersey_number          float64<br/>nation_position              object<br/>nation_jersey_number        float64<br/>pace                        float64<br/>shooting                    float64<br/>passing                     float64<br/>dribbling                   float64<br/>defending                   float64<br/>physic                      float64<br/>cumsum_2                      int64<br/>rank_calc                   float64<br/>dtype: object</span></pre><h2 id="146d" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">9.df.select_dtypes()</h2><p id="fa5a" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">您可以使用此函数选择特定数据类型的变量或列。例如，我只想选择数据类型为“int64”的列。下面是如何做到这一点:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9e42" class="mt mu jj mp b gy mv mw l mx my">df.select_dtypes(include='int64')</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/c4a622506d699c6346f2f59162d02c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP7i5NXqIBbfLHjtcK2BGw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="768e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到了所有数据类型为“int64”的列。如果我们在' select_dtypes '函数中使用' exclude '而不是' include ',我们将得到不具有数据类型' int64 '的列:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="71a3" class="mt mu jj mp b gy mv mw l mx my">df.select_dtypes(exclude='int64')</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/a6a5745ff26a2b9e373d5fa386e052fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0nXRQ-riI4izAGZqOdXS9w.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="fada" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是输出的一部分。看，变量不是整数。你可能认为‘random _ col’列是整数。但是如果你检查它的数据类型，你会发现它看起来是整数，但是它的数据类型是不同的。请随意检查。</p><h2 id="7887" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated"><a class="ae jg" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.insert.html" rel="noopener ugc nofollow" target="_blank"> 10。df.insert() </a></h2><p id="3359" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">顾名思义，该函数在指定位置插入一列。为了说明这一点，我将首先创建一个长度与数据帧相同的随机数数组:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c765" class="mt mu jj mp b gy mv mw l mx my">random_col = np.random.randint(100, size=len(df))</span></pre><p id="1c49" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将把这个数组作为一列插入数据帧df的第3列。记住，列索引从零开始。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="aad7" class="mt mu jj mp b gy mv mw l mx my">df.insert(3, 'random_col', random_col)</span></pre><p id="e03f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是数据帧的一部分:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d2d6" class="mt mu jj mp b gy mv mw l mx my">df.head()</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/1ec5f64f4b36a9f2da689dca80507ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iReZ7AV6WRQ8S3IEesrzPw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="873a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看，列“random_col”被插入到第三个位置。</p><h2 id="bdd6" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated"><a class="ae jg" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.cumsum.html" rel="noopener ugc nofollow" target="_blank"> 11。df['']。累计值()</a></h2><p id="2954" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">它为你提供了累计的总和。我举个例子解释一下。在本例中，我将使用“value_eur”和“wage_eur”列。代码如下:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6a2e" class="mt mu jj mp b gy mv mw l mx my">df[['value_eur', 'wage_eur']].cumsum()</span></pre><p id="93db" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ad8ba6d7107bf09cd9db56ea4c10cddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*gqhKwOAYiWUn5NPqvHCf3Q.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="f8c7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您在每一行中看到的，它为您提供了前面各行中所有值的累积和。</p><h2 id="e007" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">12.df.sample()</h2><p id="7749" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">当数据集太大时，您可以从中选取一个有代表性的样本来执行分析和预测建模。那可能会节省你一些时间。此外，过多的数据有时可能会破坏可视化。我们可以用这个函数得到一定数量的数据点或者某个分数或者数据点。在这里，我从国际足联的数据集中抽取了200个数据点。它随机抽取样本。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="745f" class="mt mu jj mp b gy mv mw l mx my">df.sample(n = 200)</span></pre><p id="799b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里取了国际足联数据集的25%:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c6a8" class="mt mu jj mp b gy mv mw l mx my">df.sample(frac = 0.25)</span></pre><h2 id="0a02" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">13.df['']。哪里()</h2><p id="7fd6" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">此函数帮助您基于布尔条件查询数据集。举个例子，我们之前做的random_col的取值范围是从0到100。下面是我们如何制作一个系列，看看它们中哪些大于50。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7086" class="mt mu jj mp b gy mv mw l mx my">df['random_col'].where(df['random_col'] &gt; 50)</span></pre><p id="22a0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="af27" class="mt mu jj mp b gy mv mw l mx my">0         NaN<br/>1         NaN<br/>2        56.0<br/>3         NaN<br/>4         NaN<br/>         ... <br/>16150    65.0<br/>16151     NaN<br/>16152     NaN<br/>16153    57.0<br/>16154     NaN<br/>Name: random_col, Length: 16155, dtype: float64</span></pre><p id="dea1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果值不满足条件，即值不大于50，则返回NaN。我们可以使用以下语法将NaN替换为0或任何其他值:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5bea" class="mt mu jj mp b gy mv mw l mx my">df['random_col'].where(df['random_col'] &gt; 50, 0)</span></pre><p id="9f1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5f5b" class="mt mu jj mp b gy mv mw l mx my">0         0<br/>1         0<br/>2        56<br/>3         0<br/>4         0<br/>         ..<br/>16150    65<br/>16151     0<br/>16152     0<br/>16153    57<br/>16154     0<br/>Name: random_col, Length: 16155, dtype: int32</span></pre><h2 id="3910" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">14.df['']。唯一()</h2><p id="1db8" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">这在我们有分类变量的地方非常有用。它用于找出分类列的唯一值。让我们看看FIFA数据集中“skill_moves”列的唯一值是什么:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a60a" class="mt mu jj mp b gy mv mw l mx my">df.skill_moves.unique()</span></pre><p id="2d8f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b778" class="mt mu jj mp b gy mv mw l mx my">array([4, 5, 1, 3, 2], dtype=int64)</span></pre><p id="4ad9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在skill_moves列中有五个唯一值。如果我们打印出数据集的头部来检查列的值，您可能看不到其中所有的唯一值。所以，要知道所有的唯一值。unique()函数非常方便。</p><h2 id="33f5" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">15.df['']。努尼克</h2><p id="e916" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">另一个受欢迎的功能。这个函数让你知道一列中有多少个唯一值。例如，如果您想查看这个数据集中有多少不同的国籍，您可以使用下面这行简单的代码</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c55e" class="mt mu jj mp b gy mv mw l mx my">df.nationality.nunique()</span></pre><p id="1e42" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="6a71" class="mt mu jj mp b gy mv mw l mx my">149</span></pre><p id="be51" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最棒的是，这个函数还可以用于总数据集，以了解每列中唯一值的数量:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4e3d" class="mt mu jj mp b gy mv mw l mx my">df.nunique()</span></pre><p id="cc0c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f387" class="mt mu jj mp b gy mv mw l mx my">height_cm                      48<br/>weight_kg                      54<br/>nationality                   149<br/>random_col                    100<br/>club_name                     577<br/>league_name                    37<br/>league_rank                     4<br/>overall                        53<br/>potential                      49<br/>value_eur                     161<br/>wage_eur                       41<br/>player_positions              907<br/>preferred_foot                  2<br/>international_reputation        5<br/>skill_moves                     5<br/>work_rate                       9<br/>body_type                       3<br/>team_position                  29<br/>team_jersey_number             99<br/>nation_position                28<br/>nation_jersey_number           26<br/>pace                           74<br/>shooting                       70<br/>passing                        67<br/>dribbling                      67<br/>defending                      69<br/>physic                         63<br/>cumsum_2                    14859<br/>rank_calc                     161<br/>dtype: int64</span></pre><p id="c0bd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们有每列中唯一值的数量。</p><h2 id="cb47" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">16.df['']。排名()</h2><p id="0356" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">该函数为您提供基于某一列的排名。在FIFA数据集中，如果我们想根据“value_eur”列对球员进行排名，下面是其语法:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3ea1" class="mt mu jj mp b gy mv mw l mx my">df['rank_calc'] = df["value_eur"].rank()</span></pre><p id="11bf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用上面的代码行，我创建了一个名为“rank_calc”的新列。这个新的栏目会根据“价值欧元”给你每个玩家的排名。默认情况下，该列将被添加到末尾。请自行运行该行代码进行检查。</p><h2 id="e879" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">17.。isin()</h2><p id="34ec" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">我将制作一个数据集的子集，其中只包含一些使用。isin()函数。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5040" class="mt mu jj mp b gy mv mw l mx my">nationality = ["Argentina", "Portugal", "Sweden", "England"]<br/>df[df.nationality.isin(nationality)]</span></pre><p id="eef9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您运行这段代码，您会看到我们得到的数据集只包含上面列表中提到的几个国家。你可以在这里看到数据集的一部分:</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/e5dd0e5ef8c41aea670b24d6ad9c8d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TwZYn_dRaG1ZrW-MrRlmDQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="6acd" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">18.df.replace()</h2><p id="843a" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">它确实像它听起来那样。它替换列的值。当我们只需要替换一个列的唯一值时，我们只需要传递旧值和新值。想象一下，我们刚刚发现‘league _ rank’1.0现在需要换成1.1。下面是如何做到这一点:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8b66" class="mt mu jj mp b gy mv mw l mx my">df.replace(1.0, 1.1)</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/667cb8c2ef00de8f35dbecbfe18a829e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HH2Ny4TYRO4EcS1zxLhjQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="abfd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再看现在数据集中的league_rank列，1.0换成了1.1。如果我们需要更改多个值，我们可以向replace函数传递一个字典，其中键应该是原始值，值应该是替换值。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3999" class="mt mu jj mp b gy mv mw l mx my">df.replace({1.0: 1.1,  4.0: 4.1, 3.0: 3.1})</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/7c5ce13eb40f52527ad2bd81710f56b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXjpZ-RrU9bcL-Ca69AfVw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="b6f8" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">19.df.rename()</h2><p id="1440" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">它用于重命名列。在这里，我将“体重_千克”和“身高_厘米”列更改为“体重(千克)”和“身高(厘米)”:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a7e9" class="mt mu jj mp b gy mv mw l mx my">df.rename(columns = {"weight_kg": "Weight (kg)", "height_cm": "Height (cm)"})</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/125cddcc11c826032b9ba548c1fa7444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCWug9QLJKfH-XqtHfRVeA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="765e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非常简单有用！</p><h2 id="977a" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">20.。菲尔娜</h2><p id="50f0" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">现实生活中无论什么时候你会收到一个大的数据集，大多数情况下都会有一些空值。很难得到一个完美的数据集。因此，如果您是数据分析师或数据科学家，填充空值是您日常任务的一部分。这个功能。fillna()用您选择的其他值替换空值。以下是国际足联数据集末尾的一些栏目:</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/925109f8ac71ec11ed8644d150253534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwb72O1aDymjZo5rx4Bnzg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="5708" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你看，投篮，传球，防守，还有其他一些栏目都有空值。在开始进行任何预测建模和其他数据科学任务之前，我们确实需要用一些兼容数据类型的值来替换这些空值。否则，我们可能会出错。例如，在“步速”列中，值应该是数字，但在这里和那里您会看到NaN值。最普通但不太有效的方法是用零替换那些NaN值。以下是用零更改“pace”列的所有NaN值的方法:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0177" class="mt mu jj mp b gy mv mw l mx my">df['pace'].fillna(0, inplace=True)</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/a891f230cce27bcfc1615c5a0ef746b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-yTiuBTM4A97ztZXib9uw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="6f35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你注意到，在速度栏中的NaN现在是零。在总起搏栏中，如果有更多的NaN值，也应将其替换为零。</p><p id="dc25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我之前提到的，用零替换可能不是最有效的方法。您可以用自己选择的其他值来替换它。用平均值或中值替换值也很常见。如果我们想用空间平均值列替换pace列的NaN值，我们应该使用下面这行代码:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f7bd" class="mt mu jj mp b gy mv mw l mx my">df['pace'].fillna(df['pace'].mean(), inplace = True)</span></pre><h2 id="07b9" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">21.df.groupby()</h2><p id="23db" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">这是最流行的数据汇总功能。您可以按照某个变量对数据进行分组，并找出关于这些组的有用信息。例如，我在这里按国籍对数据进行分组，并计算每个国籍的总“价值欧元”:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0e49" class="mt mu jj mp b gy mv mw l mx my">df.groupby("nationality")['value_eur'].sum()</span></pre><p id="e796" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4b0a" class="mt mu jj mp b gy mv mw l mx my">nationality<br/>Albania                25860000<br/>Algeria                70560000<br/>Angola                  6070000<br/>Antigua &amp; Barbuda       1450000<br/>Argentina            1281372000<br/>                        ...    <br/>Uzbekistan              7495000<br/>Venezuela              41495000<br/>Wales                 113340000<br/>Zambia                  4375000<br/>Zimbabwe                6000000<br/>Name: value_eur, Length: 149, dtype: int64</span></pre><p id="3c8e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">阿尔巴尼亚所有球员的总价值为25860000欧元。</p><p id="b39b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也可以通过几个变量进行分组，并使用几个集合函数。我们将看到每个国籍和每个联赛级别的平均值欧元、中值欧元、平均工资欧元和中值工资欧元。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d095" class="mt mu jj mp b gy mv mw l mx my">df.groupby(['nationality', 'league_rank'])['value_eur', 'wage_eur'].agg([np.mean, np.median])</span></pre><p id="fdf0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/06bcbd71c5608524066214b155b8827f.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*x-vuOBX-JxCZPGGpMpuGYg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="2ff8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用“分组依据”功能，您可以做更多的事情。我这里有一篇详细的文章:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/efficient-data-summarizing-and-analysis-using-pandas-groupby-function-7b2cc9eff186"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">使用Pandas的Groupby功能进行有效的数据汇总和分析</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">学习使用聚合函数，数据转换，过滤，映射，在数据框架中应用</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="op l mg mh mi me mj ja lv"/></div></div></a></div><h2 id="acb1" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">22.。pct_change()</h2><p id="bf85" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">你可以从变量的前一个值得到百分比变化。在本演示中，我将使用value_eur列，并获取每行数据相对于之前的百分比变化。第一行将是NaN，因为之前没有要比较的值。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ad2a" class="mt mu jj mp b gy mv mw l mx my">df.value_eur.pct_change()</span></pre><p id="e92b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d308" class="mt mu jj mp b gy mv mw l mx my">0             NaN<br/>1       -0.213930<br/>2       -0.310127<br/>3       -0.036697<br/>4        0.209524<br/>           ...   <br/>16150    0.000000<br/>16151    0.500000<br/>16152   -0.500000<br/>16153    0.000000<br/>16154   -1.000000<br/>Name: value_eur, Length: 16155, dtype: float64</span></pre><p id="ec36" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个数据集中，你可能觉得这并不重要。</p><blockquote class="oq"><p id="e434" class="or os jj bd ot ou ov ow ox oy oz lt dk translated">但是想想一些财务数据。特别是当你每天都有股票市值的时候。看到每天价值的百分比变化该有多好。</p></blockquote><h2 id="3646" class="mt mu jj bd mz na pa dn nc nd pb dp nf lh pc nh ni ll pd nk nl lp pe nn no np bi translated">23.df.count()</h2><p id="06ba" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">它提供数据帧中指定方向的数据数量。当方向为0时，它提供列中的数据数:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9dcb" class="mt mu jj mp b gy mv mw l mx my">df.count(0)</span></pre><p id="7ef0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3a42" class="mt mu jj mp b gy mv mw l mx my">Unnamed: 0                 16155<br/>sofifa_id                  16155<br/>player_url                 16155<br/>short_name                 16155<br/>long_name                  16155<br/>                           ...  <br/>goalkeeping_diving         16155<br/>goalkeeping_handling       16155<br/>goalkeeping_kicking        16155<br/>goalkeeping_positioning    16155<br/>goalkeeping_reflexes       16155<br/>Length: 81, dtype: int64</span></pre><p id="d8c5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到每列中的数据数量。</p><p id="658c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当方向为1时，它提供行中的数据数量:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="059d" class="mt mu jj mp b gy mv mw l mx my">df.count(1)</span></pre><p id="e98a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d0ef" class="mt mu jj mp b gy mv mw l mx my">0        72<br/>1        72<br/>2        72<br/>3        72<br/>4        71<br/>         ..<br/>16150    68<br/>16151    68<br/>16152    68<br/>16153    68<br/>16154    69<br/>Length: 16155, dtype: int64</span></pre><p id="1577" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，每一行都有不同数量的数据。如果仔细观察数据集，您会发现它在几列中有许多空值。</p><h2 id="f018" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">24.df['']。值计数()</h2><p id="406d" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">我们可以使用这个函数获得每个类别的值计数。在这里，我得到了每个等级中有多少个值。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8099" class="mt mu jj mp b gy mv mw l mx my">df['league_rank'].value_counts()</span></pre><p id="0621" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8c3d" class="mt mu jj mp b gy mv mw l mx my">1.0    11738<br/>2.0     2936<br/>3.0      639<br/>4.0      603<br/>Name: league_rank, dtype: int64</span></pre><p id="fcbd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它返回默认排序的结果。如果希望结果以升序排列，只需设置ascending=True:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7363" class="mt mu jj mp b gy mv mw l mx my">df['league_rank'].value_counts(ascending=True)</span></pre><p id="26f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="621d" class="mt mu jj mp b gy mv mw l mx my">4.0      603<br/>3.0      639<br/>2.0     2936<br/>1.0    11738<br/>Name: league_rank, dtype: int64</span></pre><h2 id="21d6" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">25.pd.crosstab()</h2><p id="2136" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">它给出了一个频率表，是两个变量的交叉列表。我在这里做一个联赛排名和国际声誉的交叉列表:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="cb3e" class="mt mu jj mp b gy mv mw l mx my">pd.crosstab(df['league_rank'], df['international_reputation'])</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/2a8c5f56fd074f5bb5a3fd7e8c49bbeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*0C5YKB7UeA1Z4um8qLWaOg.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="9bd1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，我们得到了联赛排名和国际声誉的所有组合的数量。我们可以看到，大多数球员的国际声誉和联赛排名都是1。</p><p id="e684" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以进一步改进。我们可以在两个方向上添加边距，这将是总和，如果需要，我们还可以获得归一化值:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="caa6" class="mt mu jj mp b gy mv mw l mx my">pd.crosstab(df['league_rank'], df['international_reputation'], <br/>            margins = True,<br/>            margins_name="Total",<br/>            normalize = True)</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/ce5952684c19704d0cff62fa83cccdcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*F-E15Hwm1wgP35BHeAGRCQ.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="1e12" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是关于count、value_counts和crosstab方法的详细教程:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/three-very-useful-functions-of-pandas-to-summarize-the-data-491b64db9370"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">熊猫总结数据的三个非常有用的功能</h2><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="ph l mg mh mi me mj ja lv"/></div></div></a></div><h2 id="c6c8" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">26.pd.qcut()</h2><p id="5183" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">该函数根据数据的分布对数据进行分类或分段。所以，我们得到了每个玩家的范围。在这里，我将把value_eur分成5个部分，并得出哪个玩家属于哪个部分:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="4b12" class="mt mu jj mp b gy mv mw l mx my">pd.qcut(df['value_eur'], q = 5)</span></pre><p id="42e8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a40c" class="mt mu jj mp b gy mv mw l mx my">0        (1100000.0, 100500000.0]<br/>1        (1100000.0, 100500000.0]<br/>2        (1100000.0, 100500000.0]<br/>3        (1100000.0, 100500000.0]<br/>4        (1100000.0, 100500000.0]<br/>                   ...           <br/>16150          (-0.001, 100000.0]<br/>16151          (-0.001, 100000.0]<br/>16152          (-0.001, 100000.0]<br/>16153          (-0.001, 100000.0]<br/>16154          (-0.001, 100000.0]<br/>Name: value_eur, Length: 16155, dtype: category<br/>Categories (5, interval[float64]): [(-0.001, 100000.0] &lt; (100000.0, 230000.0] &lt; (230000.0, 500000.0] &lt; (500000.0, 1100000.0] &lt; (1100000.0, 100500000.0]]</span></pre><p id="2c6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用上面代码行中的value_counts来查看玩家属于哪个范围:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7d0b" class="mt mu jj mp b gy mv mw l mx my">pd.qcut(df['value_eur'], q = 5).value_counts()</span></pre><p id="0e34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="61c3" class="mt mu jj mp b gy mv mw l mx my">(-0.001, 100000.0]          3462<br/>(230000.0, 500000.0]        3305<br/>(100000.0, 230000.0]        3184<br/>(500000.0, 1100000.0]       3154<br/>(1100000.0, 100500000.0]    3050<br/>Name: value_eur, dtype: int64</span></pre><p id="40e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，数字非常接近。默认情况下，qcut试图平均分配它们。但在现实生活中，它并不想总是平等的。因为大部分时间分布并不均匀。</p><h2 id="3a3b" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">27.pd.cut()</h2><p id="7700" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">宁滨的另一种方法。如果我们想使用cut创建5个箱，它会将整个value_eur范围分成相等的五个部分，每个箱中的人口也会相应地增加。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="1c75" class="mt mu jj mp b gy mv mw l mx my">pd.cut(df['value_eur'], bins = 5).value_counts()</span></pre><p id="c529" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0e2f" class="mt mu jj mp b gy mv mw l mx my">(-100500.0, 20100000.0]      16102 <br/>(20100000.0, 40200000.0]        40 <br/>(40200000.0, 60300000.0]        10 <br/>(60300000.0, 80400000.0]         2 <br/>(80400000.0, 100500000.0]        1 <br/>Name: value_eur, dtype: int64</span></pre><p id="d16f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个范围内的间隔是相等的。但是每个群体中的人口是非常不同的。</p><p id="d941" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我有一篇关于使用cut和qcut方法的数据宁滨的详细文章。请随意看一看:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/sort-and-segment-your-data-into-bins-to-get-sorted-ranges-pandas-cut-and-qcut-7785931bbfde"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">数据宁滨与熊猫削减或Qcut方法</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">当你在寻找一个范围而不是一个确切的数值，一个等级而不是一个分数</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="pi l mg mh mi me mj ja lv"/></div></div></a></div><h2 id="fbc7" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">28.df['']。描述()</h2><p id="6d77" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">这是一个伟大的功能，提供了一些基本的统计措施。在这里，我对wage_eur列使用了describe函数:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="390e" class="mt mu jj mp b gy mv mw l mx my">df['wage_eur'].describe()</span></pre><p id="ce02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="608e" class="mt mu jj mp b gy mv mw l mx my">count     16155.000000<br/>mean      13056.453110<br/>std       23488.182571<br/>min           0.000000<br/>25%        2000.000000<br/>50%        5000.000000<br/>75%       10000.000000<br/>max      550000.000000<br/>Name: wage_eur, dtype: float64</span></pre><p id="479f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如输出所示，我们有八个不同的度量。每一个都非常重要。</p><h2 id="1d7e" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">29.最大和最小</h2><p id="4942" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">这将为您提供具有指定变量的n个最大值或最小值的数据集。例如，我想获得工资最高的5行:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c730" class="mt mu jj mp b gy mv mw l mx my">df.nlargest(5, "wage_eur")</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/59f1af65b5781aea9dc0cb4474de83a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-lfj9cO6SshkZGHAnE9rQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="877a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我可以用5个最小的wage_eur数据创建数据集的子集:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="3c81" class="mt mu jj mp b gy mv mw l mx my">df.nsmallest(5, "wage_eur")</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/638f07731ae4394ee4e0e256a7e42920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EtTlN6ZsGgtx4g0EDMX2rw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="c614" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">30.df.explode()</h2><p id="212b" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">当您在某些行中有一个数据列表时，分解会很有用。当一些列中有整数，一些列中有列表时，很难分析、可视化或执行一些预测建模。Explode有助于分解这些列表。例如，看这个数据帧:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c61a" class="mt mu jj mp b gy mv mw l mx my">df1 = pd.DataFrame({"city": ['A', 'B', 'C'],<br/>                   "day1": [22, 25, 21],<br/>                   'day2':[31, 12, 67],<br/>                   'day3': [27, 20, 15],<br/>                   'day4': [34, 37, [41, 45, 67, 90, 21]],<br/>                   'day5': [23, 54, 36]})<br/>df1</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/4a67a712e46f3470816f111db907667b.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*3qrFAjLVh0s0mihi64lEXA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="19e4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们展开d4列:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="16a7" class="mt mu jj mp b gy mv mw l mx my">df1.explode(jupyter notebook<br/>'day4').reset_index(drop=True)</span></pre><figure class="mk ml mm mn gt iv gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/491cbfd8897d233598c01591defc1253.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*HQzH854YWCsyQJsx4y4KwA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="d96e" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">结论</h2><p id="08a6" class="pw-post-body-paragraph ky kz jj la b lb nq kk ld le nr kn lg lh ns lj lk ll nt ln lo lp nu lr ls lt im bi translated">Python的熊猫库好大。功能那么多。我选择一些日常生活中的重要功能。如果您非常了解这些，您将能够成功地执行大多数分析任务。熊猫还有一个非常有用的功能，我在这里没有提到。plot()函数。你只能用熊猫来绘图。熊猫在后端使用Matplotlib，为你返回剧情。我这里有一个详细的教程:</p><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/an-ultimate-cheat-sheet-for-data-visualization-in-pandas-f7bc239c9937"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">熊猫数据可视化的终极备忘单</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">熊猫所有的基本视觉类型和一些非常高级的视觉…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="pn l mg mh mi me mj ja lv"/></div></div></a></div><p id="eac0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望这篇文章是有帮助的。</p><p id="1244" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随时在<a class="ae jg" href="https://twitter.com/rashida048" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae jg" href="https://www.facebook.com/Regenerative-149425692134498" rel="noopener ugc nofollow" target="_blank">脸书页面</a>上关注我，并查看我的新<a class="ae jg" href="https://www.youtube.com/channel/UCzJgOvsJJPCXWytXWuVSeXw" rel="noopener ugc nofollow" target="_blank"> YouTube。频道</a>。</p><h2 id="acf5" class="mt mu jj bd mz na nb dn nc nd ne dp nf lh ng nh ni ll nj nk nl lp nm nn no np bi translated">更多阅读</h2><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/exploratory-data-analysis-with-some-cool-visualizations-in-pythons-matplotlib-and-seaborn-library-99dde20d98bf"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">利用Python的Matplotlib和Seaborn库中一些很酷的可视化工具进行探索性的数据分析</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">探索国际足联数据集</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="po l mg mh mi me mj ja lv"/></div></div></a></div><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/a-complete-anomaly-detection-algorithm-from-scratch-in-python-step-by-step-guide-4c115e65d54e"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">Python中从头开始的完整异常检测算法:分步指南</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">基于概率的异常检测算法</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="pp l mg mh mi me mj ja lv"/></div></div></a></div><div class="is it gp gr iu lv"><a rel="noopener follow" target="_blank" href="/all-the-datasets-you-need-to-practice-data-science-skills-and-make-a-great-portfolio-74f2eb53b38a"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">练习数据科学技能和制作优秀投资组合所需的所有数据集</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">大量不同种类的数据集</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="pq l mg mh mi me mj ja lv"/></div></div></a></div><div class="is it gp gr iu lv"><a href="https://pub.towardsai.net/a-complete-guide-to-confidence-interval-t-test-and-z-test-in-r-for-data-scientists-cd16dd2d0eec" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jk gy z fp ma fr fs mb fu fw ji bi translated">数据科学家置信区间、t检验和z检验完全指南</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">大量的实践练习</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">pub.towardsai.net</p></div></div><div class="me l"><div class="pr l mg mh mi me mj ja lv"/></div></div></a></div></div></div>    
</body>
</html>