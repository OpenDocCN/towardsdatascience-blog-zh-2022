<html>
<head>
<title>Building an Analytics API with GraphQL: The Next Level of Data Engineering?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GraphQL构建分析API:数据工程的下一个层次？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-analytics-api-with-graphql-the-next-level-of-data-engineering-6a8aea32ba72#2022-01-22">https://towardsdatascience.com/building-an-analytics-api-with-graphql-the-next-level-of-data-engineering-6a8aea32ba72#2022-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="c5aa" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用GraphQL构建分析API:数据工程的下一个层次？</h1></div><div class=""><h2 id="a3ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拥有一个高性能、安全、可靠的数据端点是实实在在的挑战。尤其是选择每个人都同意的准确的度量和尺寸，对吗？让我们解决这个问题。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/486eb8497df26d5fbb5e43b73a1e23d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gpWKgTA0V7rxOVD_.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@adibbehrooz" rel="noopener ugc nofollow" target="_blank">穆罕默德·巴盖里·阿迪布·贝鲁斯</a>在<a class="ae ky" href="https://unsplash.com/photos/XHI-S_xWK28" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="80aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问，为什么数据工程师要用GraphQL？GraphQL解决了为每个客户端提供不同接口的问题，它为所有客户端(如web、移动和web应用程序)统一了一个API。我们现在在数据领域面临着同样的挑战，我们将多个客户端与众多后端系统集成在一起。</p><p id="72ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么GraphQL是什么呢？在微服务和web应用程序的世界中，GraphQL是一种流行的查询语言，并充当数据层。它本质上是API的类固醇SQL。在本文中，我们将介绍如何将来自所有服务的数据组合成一个统一的API。</p><h1 id="5613" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么为数据工程师选择GraphQL？</h1><h1 id="55f3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">GraphQL是什么？</h1><p id="a50d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">先说GraphQL。在2015年公开发布之前，它是由脸书在2012年内部开发的。本质上是为了更好地为他们的移动应用服务，所有的API都针对网络进行了优化，拥有更大的客户端和更快的数据连接。他们没有为移动设备复制所有现有的API端点，而是很快意识到他们需要另一种解决方案。这个解决方案被称为GraphQL。如果你想知道更多关于它是如何开始的，我推荐你去看网飞式的<a class="ae ky" href="https://youtu.be/783ccP__No8" rel="noopener ugc nofollow" target="_blank">纪录片</a>。</p><p id="a692" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">本质上，GraphQL是API的类固醇SQL</strong>。最棒的是，它基于与REST相同的技术，支持GET或POST请求。但是，不是有多个<em class="ms">哑</em>端点，而是有一个能够接受复杂查询的<em class="ms">智能</em>端点。假设您的所有用例都有数百个API端点。GraphQL允许您组合它们，但是只选择您需要的列(<code class="fe mt mu mv mw b">SELECT columns FROM ...</code>)和行(<code class="fe mt mu mv mw b">WHERE ...</code>)。这些选项可以减少API调用和数据负载，因为您可以将几个REST调用合并成一个。这也增强了前端开发人员的能力，因为他们更少依赖后端开发人员。</p><h1 id="6166" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">(查询)界面</h1><p id="54f6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下图展示了使用GitHub<a class="ae ky" href="https://docs.github.com/en/graphql/overview/explorer" rel="noopener ugc nofollow" target="_blank">public graph QL endpoint</a>的简单查询。你可以自己尝试下面的查询。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d7a2" class="nb lw it mw b gy nc nd l ne nf">query {<br/>  repository(owner: "sspaeti-com", name: "practical-data-engineering") {<br/>    name<br/>    description<br/>    owner {<br/>      login<br/>    }<br/>    homepageUrl<br/>    visibility<br/>    createdAt<br/>  }<br/>}</span></pre><p id="6ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应如下所示:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="0050" class="nb lw it mw b gy nc nd l ne nf">{<br/>  "data": {<br/>    "repository": {<br/>      "name": "practical-data-engineering",<br/>      "description": "Real estate dagster pipeline",<br/>      "owner": {<br/>        "login": "sspaeti-com"<br/>      },<br/>      "homepageUrl": "https://www.sspaeti.com/blog/data-engineering-project-in-twenty-minutes/",<br/>      "visibility": "PUBLIC",<br/>      "createdAt": "2020-11-18T21:15:37Z"<br/>    }<br/>  }<br/>}</span></pre><h1 id="ad68" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么GraphQL如此适合？</h1><p id="e70b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">大多数关于GraphQL的讨论都集中在数据获取上，但是任何<strong class="lb iu">完整的数据平台也需要一种方法来修改服务器端数据</strong>。这就是内置<code class="fe mt mu mv mw b">mutation</code>发挥作用的地方，我们稍后在分析API中利用它们。在<a class="ae ky" href="https://graphql.org/learn/queries/" rel="noopener ugc nofollow" target="_blank">查询和突变</a>下找到更多信息。</p><p id="7ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">维护简单。GraphQL本质上是一个端点<code class="fe mt mu mv mw b">/graphql</code>(可以随意命名)，而不是通过创建更多端点来增加复杂性。它还增加了它的可扩展性和可维护性。</p><p id="28bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">类型验证</strong>内置于<a class="ae ky" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"> GraphQL模式语言</a>中，用于预先验证GraphQL查询。这些允许服务器和客户端在有无效查询时有效地通知开发者<strong class="lb iu">，而不依赖于运行时检查</strong>。</p><p id="9d98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">自证！</strong>当您用列和类型构建您的接口时，您记录了代码，通过使用像GraphQL这样的工具进行自省，这些代码自动对客户端可用。对于构建API的开发者和使用它的人来说，这是一个巨大的时间节省。</p><p id="86ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个大问题是你的<strong class="lb iu"> API模式与你的数据库模式的解耦</strong>。例如，你今天使用<a class="ae ky" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>函数在你的后端查询<a class="ae ky" href="https://cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> Google Big Query </a>，你想要或者必须换成其他的东西比如<a class="ae ky" href="https://www.sspaeti.com/blog/open-source-data-warehousing-druid-airflow-superset/#druid---the-data-store" rel="noopener ugc nofollow" target="_blank"> Apache Druid </a>。您可以在不干扰用户的情况下进行切换，因为GraphQL充当了您的语义层。想象一下相反的情况，您将web应用程序与Big Query的API紧密集成。迁移和重写所有的前端代码需要付出很大的努力。</p><p id="e7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">💡注意:除了查询和变异，操作<code class="fe mt mu mv mw b"><strong class="lb iu">subscription</strong></code> <strong class="lb iu">对于更新下游事件和防止轮询</strong>也很方便。服务器会将更改推送给所有订阅者。这对于基于事件或实时的应用程序来说很方便。订阅本身可以是GraphQL使用<a class="ae ky" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> Websockets </a>在服务器和客户端之间保持开放连接的<code class="fe mt mu mv mw b">update</code>、<code class="fe mt mu mv mw b">delete</code>或<code class="fe mt mu mv mw b">insert</code>。</p><p id="89b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个成功的方面是<strong class="lb iu">标准化规格表。无论如何，成为一个规范意味着更好的工具、更容易的使用和服务间更全面的互操作性都更容易实现。我认为仅此一点就让GraphQL难以避免。</strong></p><h1 id="6c18" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">GraphQL不是什么</h1><p id="0ebb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它不是一个能为您提供所有必要服务的成熟解决方案。它是一个框架的一部分，这个框架提供了适当的边界和工具来为您的业务实现合适的逻辑，否则您将不得不构建这些逻辑。但是没有创建查询接口、权限、验证等的麻烦。把所有东西粘在一起。</p><p id="cb4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不是<a class="ae ky" href="https://blog.stackpath.com/yaml/" rel="noopener ugc nofollow" target="_blank"> YAML </a>，也不是JSON，虽然非常接近，但它是它的格式，如上面的<a class="ae ky" href="https://www.sspaeti.com/blog/graphql-the-next-level-of-data-engineering/#the-query-interface" rel="noopener ugc nofollow" target="_blank">接口部分</a>所示。你可以在文章<a class="ae ky" href="https://www.moesif.com/blog/technical/graphql/REST-vs-GraphQL-APIs-the-good-the-bad-the-ugly/#problems-with-graphql" rel="noopener ugc nofollow" target="_blank">REST vs graph QL API中找到其他潜在的问题，好的，坏的，丑陋的</a>。</p><h1 id="e1b7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是分析API？</h1><p id="4776" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，我们已经看到了GraphQL可以做什么，我们讨论<strong class="lb iu">构建一个通向下一级数据工程的API</strong>，在本文中我称之为<em class="ms">分析API </em>。该API将使所有利益相关者能够以一致和分离的语义方式使用<strong class="lb iu">单一来源访问分析数据</strong>(如果您知道更好的名称，请告诉我！).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/1b9cddd018e590eb69005f8549a8b55c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mAvvmZEBKkNql_1r.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用GraphQL | Image的单端点分析API架构</p></figure><p id="1843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析API由五个主要组件组成，其中GraphQL是网关API和查询接口的最佳选择。除此之外，SQL Connector还可以连接以SQL为母语的遗留或传统BI系统。指标或业务逻辑，也叫<a class="ae ky" href="https://cube.dev/blog/introducing-cube-sql/" rel="noopener ugc nofollow" target="_blank">指标存储</a>或<a class="ae ky" href="https://basecase.vc/blog/headless-bi" rel="noopener ugc nofollow" target="_blank">无头BI </a>存储在指标存储中。假设你在一个有很多变化的大型组织中。在这种情况下，有一个数据目录会很有帮助，它可以帮助发现您的数据，并向数据集添加所有者、评论、评级和其他信息，以便在它们之间导航。orchestrator持续可靠地更新数据存储中的内容。稍后将详细介绍每个组件。</p><h1 id="b578" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据团队如何努力构建分析API</h1><p id="e101" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">云架构比以往任何时候都更加复杂，尤其是随着工具和技术的最新发展。如今，每个数据团队都希望公司的决策者能够随时获得数据。无论是数据分析师、产品经理、数据科学家、业务人员还是数据分析师，都很难提供一个单一的接口来抽象所有异构数据存储，并让他们查询所有数据。最重要的是，新的原则和架构正在接受旧的想法，例如，<a class="ae ky" href="https://cnr.sh/essays/what-the-heck-data-mesh" rel="noopener ugc nofollow" target="_blank">数据网格</a>中分散的数据产品和集中的云数据仓库。</p><p id="7cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/adevinta-tech-blog/building-a-data-mesh-to-support-an-ecosystem-of-data-products-at-adevinta-4c057d06824d" rel="noopener">ade vinta</a>的Xavier Gumara Rigol表示，如果需要更复杂的处理，每个数据集应该至少有两个与<strong class="lb iu"> SQL的接口，作为快速访问和通过笔记本</strong>的编程访问。</p><p id="cdbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果您只有一个Postgres数据库或任何其他简化的架构，那么通过分析API构建和路由它可能没有意义。让我们看一看当今不同的数据团队，以及他们目前面临的挑战:</p><ul class=""><li id="d516" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><strong class="lb iu">机器学习人员</strong>想要一个API来试验Jupyter笔记本中的特定数据。</li><li id="b943" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">商业智能用户</strong>需要报告公司如何使用他们选择的仪表板工具。他们需要一个SQL连接器。响应时间必须在几秒钟之内，因为他们希望实时切片并在会议上演示数字。如果可能的话，公司范围内的KPI已经预先计算好，随时可以使用。</li><li id="8e2d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">超级用户</strong>想要更新和修复一些不正确的数据。他们需要一个界面或清晰的文档来说明如何操作。更重要的是，他们是否在数据湖、<a class="ae ky" href="https://www.sspaeti.com/blog/olap-whats-coming-next/" rel="noopener ugc nofollow" target="_blank"> OLAP </a>立方体、配置等环境中进行。，应该没关系。</li><li id="37df" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">应用具有不同需求的产品逻辑的内部应用和管道</strong>包括摄取新数据、修复无效状态、自动维护，例如压缩海量数据源或实现复杂的业务逻辑。</li><li id="3e09" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">外部客户</strong>想要为他们的数据仓库提取数据。</li><li id="87bb" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">经理们</strong>想一目了然地看到整体数字。</li></ul><p id="4313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这些涉众有不同的用例和技能，很难支持他们所有人。通过现场验证的标准化GraphQL界面和记录在案的内置界面，我们拥有了当今最好的方法。这也是一个使更新保持一致并保存的机会，而不是直接与人联系🚒。</p><p id="32be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">授权和认证</strong>值得注意，而不是在每个系统中创建新的组和用户。必须一次实施。但是如果你没有这样的API，这是非常困难的。当然，您可以集成您的身份和访问管理解决方案，但是内置在中央API和GraphQL中是一种实用而优雅的方式。</p><h1 id="4d67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">分析API的组件</h1><p id="0d7c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在让我们更详细地看看每个组件，以及它们有效地做了什么。</p><h1 id="b06f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">API和查询引擎</h1><p id="2c2b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">分析API的第一个组件是界面和查询引擎。这个接口是所有工具都可以访问的单一GraphQL端点。称之为代理、路由器或网关，它将每个<code class="fe mt mu mv mw b">query</code>、<code class="fe mt mu mv mw b">mutation</code>或<code class="fe mt mu mv mw b">subscription</code>转发到正确的服务或管道。</p><p id="4354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有中央计算度量或任何不支持SQL的数据存储，查询引擎会有所帮助，您可以将GraphQL查询翻译成特定的查询语言。与SQL连接器的一个关键区别是使用高级和更通用的模式来查询数据。例如，代替<code class="fe mt mu mv mw b">SELECT COUNT(DISTINCT userid) AS distinct_users FROM customers</code>，我们可以更概括地说:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="06d3" class="nb lw it mw b gy nc nd l ne nf">SELECT {{ metrics.distinct_users }} FROM {{ datasources.customers }}<br/>--or<br/>SELECT * FROM {{ metrics.metric('customer', by='day', dims=['country', 'year']) }}</span></pre><p id="795e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要一个中间层来将通用查询转换为实际的SQL查询，即查询引擎。</p><p id="e3ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你注意到这里所有商业智能工程师的利益和<strong class="lb iu">小</strong> <a class="ae ky" href="https://www.linkedin.com/feed/update/urn:li:activity:6885632330640171008/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">大</strong> </a> <strong class="lb iu">。我们有一个定义，而不是用稍微不同的语法为所有数据存储编写又长又复杂的查询</strong>。我们不需要在不同的地方定义像<code class="fe mt mu mv mw b">distinctUsers</code>这样的指标，而是将它存储一次，然后应用于所有的系统。没有必要担心你是否得到了最新版本或者是否有人改变了计算。下一章将详细介绍如何集中存储一个指标定义。</p><blockquote class="nv nw nx"><p id="b1be" class="kz la ms lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated">我们看到在变换层出现了更多的抽象。度量层(因Airbnb的Minerva 、<a class="ae ky" href="https://transform.co/" rel="noopener ugc nofollow" target="_blank">Transform.co</a>和<a class="ae ky" href="https://metriql.com/" rel="noopener ugc nofollow" target="_blank"> Metriql </a>而流行)，特征工程框架(更接近MLops)，A/B测试框架，以及各种形状和风格的本土计算框架的寒武纪大爆发。称之为“数据中间件”、“参数管道”或“计算框架”，但这个领域正在开始成形。来自<a class="ae ky" href="https://preset.io/blog/reshaping-data-engineering/" rel="noopener ugc nofollow" target="_blank">现代数据堆栈如何重塑数据工程</a></p></blockquote><p id="84c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的分析API图所示，它通过GraphQL与其他组件集成，以便从指标和数据目录存储中读取数据，或者通过编排触发更新。除了只实现某些部分的无头BI工具之外，没有集成的工具。在<a class="ae ky" href="https://www.sspaeti.com/blog/graphql-the-next-level-of-data-engineering/#the-recent-hype-around-headless-bi" rel="noopener ugc nofollow" target="_blank">最近围绕无头毕的炒作</a>一章，你可以找到更多关于他们的内容。</p><h1 id="3533" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">度量存储|无头BI</h1><p id="ba82" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">无头BI部分，或者我在本文中提到的度量存储，是存放所有<a class="ae ky" href="https://support.google.com/analytics/answer/1033861?hl=en" rel="noopener ugc nofollow" target="_blank">度量</a>的重要地方。度量标准，如计算度量、维度等。，这通常是从Tableau、Power BI、Superset、Looker等商业智能工具中了解到的。<strong class="lb iu">这些工具都有自己的度量存储，大多数情况下，它们都有描述聚合计算或维度的语言</strong>。这里最著名的是来自Looker的<a class="ae ky" href="https://docs.looker.com/data-modeling/learning-lookml/what-is-lookml" rel="noopener ugc nofollow" target="_blank"> LookML </a>。这里的不同之处在于，我们将所有BI工具的这一部分分离出来，并将它们集中起来。它允许我们以结构化和源代码控制的方式定义它们，而不是在专有工具中。</p><blockquote class="nv nw nx"><p id="8c87" class="kz la ms lb b lc ld ju le lf lg jx lh ny lj lk ll nz ln lo lp oa lr ls lt lu im bi translated"><strong class="lb iu">将其视为遵循</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">干</strong> </a> <strong class="lb iu">原则</strong>集中实现一次的某些业务逻辑、关键代码或元数据。假设您使用Apache Druid，您可能有复杂的计算度量，作为ML-Engineer或任何客户，您希望使用BI工具查询这些度量。不是在每个工具中添加格式化选项、单位、描述来重新创建它们，而是将它们存储在分析API的中心。此外，在度量存储的帮助下。</p></blockquote><p id="18c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析API中不同组件之间的通信是通过GraphQL从查询引擎返回查询，在需要时通过直接查询查询或更新元数据存储和数据API配置，并执行来自编排的请求。</p><p id="1455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，大多数工具和人员使用<strong class="lb iu">流行的模板化解决方案和</strong> <a class="ae ky" href="https://multithreaded.stitchfix.com/blog/2017/07/06/one-weird-trick/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Jinja和SQL </strong> </a>并集成到公司选择的BI工具中。但是由于Jinja SQL逻辑很难跨不同的数据库引擎重用，并且如果您开始嵌套这些查询，很快就会变得混乱，因此度量存储变得流行起来。</p><p id="07e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您现在所理解的，指标存储是分析API的一个重要组成部分，而作为分析查询和指标的关键组件几乎是同义词。此外，随着分析工程师越来越受欢迎，他们的领域知识主要是定义和创建这种指标的转换。</p><p id="9353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之上，我将看到类似于Kafka 的 <a class="ae ky" href="https://docs.confluent.io/platform/current/schema-registry/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">汇合模式注册表</strong> </a> <strong class="lb iu">的<strong class="lb iu">附加服务集成，例如比较不同版本的度量定义和数据存储模式。这将减少将数据管道和应用程序逻辑与数据存储中不断发展的表和视图模式集成的错误。并允许一致地添加新的度量和维度。</strong></strong></p><h2 id="9d67" class="nb lw it bd lx ob oc dn mb od oe dp mf li of og mh lm oh oi mj lq oj ok ml ol bi translated">最近关于无头毕的炒作</h2><p id="a90b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您关注数据领域，您会注意到围绕元数据的<strong class="lb iu">炒作，这些术语被称为度量存储或无头BI。有趣的开源和闭源公司以及围绕它起步的工具包括</strong><a class="ae ky" href="https://cube.dev/blog/introducing-cube-sql/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">cube . js</strong></a><strong class="lb iu"/><a class="ae ky" href="https://metriql.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Metriql</strong></a><strong class="lb iu"/><a class="ae ky" href="https://www.supergrain.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">super grain</strong></a><strong class="lb iu"/><a class="ae ky" href="https://transform.co/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">Transform.co</strong></a><strong class="lb iu">或者</strong> <a class="ae ky" href="https://medium.com/airbnb-engineering/how-airbnb-enables-consistent-data-consumption-at-scale-1c0b6a8b9206" rel="noopener"> <strong class="lb iu"> Minerva API </strong>您还将看到，由于上面提到的许多原因，他们正在使用或开始使用GraphQL。</a></p><p id="eaa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最新的公告发生在<a class="ae ky" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt的</a>公开会议的基调上<a class="ae ky" href="https://coalesce.getdbt.com/" rel="noopener ugc nofollow" target="_blank">联合</a>来自<a class="ae ky" href="https://twitter.com/drewbanin" rel="noopener ugc nofollow" target="_blank">德鲁巴宁</a>关于“<a class="ae ky" href="https://youtu.be/MdSMSbQxnO0" rel="noopener ugc nofollow" target="_blank">公制</a>”。他讲述了5000年前我们测量的起源，如果你还没看过，那一定要看。如果你想知道更多的细节，请关注已经开始的<a class="ae ky" href="https://github.com/dbt-labs/dbt-core/issues/4071" rel="noopener ugc nofollow" target="_blank"> Github问题</a>中的许多信息和令人兴奋的想法。</p><h1 id="9a2d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据目录</h1><p id="ccde" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">根据联合国欧洲经济委员会(une ce)2003年的数据，在过去的十年中，数据增长了40倍(今天要高得多)。随着时间的推移，很难保持这一数量。数据目录服务解决了处理快速增长的数据的问题。</p><p id="5acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案不在于数据，而在于跟踪元数据并有效地呈现它们。像<a class="ae ky" href="https://amundsen.io/" rel="noopener ugc nofollow" target="_blank"> Amundsen </a>这样的数据目录和发现工具通过向我们显示哪些数据集可用、谁在哪年创建的、多少行的元数据、最小/最大条目来实现这一点。它包含一个评级系统，用户可以对数据集提供反馈，让您感受数据质量以及使用该数据集的有效性。<strong class="lb iu">这是谷歌搜索，但元数据有一个方便的界面，你的指标存储</strong>。</p><p id="45cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您选择或构建的工具，您可以与指标存储和其他组件(如orchestrator或web应用程序)进行交互。如果组件本身有GraphQL接口，这就是最佳解决方案。用户将使用这种工具的web界面，分析API的其他部分将通过GraphQL和REST成为可编程接口。例如，编排工具将查询最新的db-schema或持续数据源的列表。</p><h1 id="8f1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">管弦乐编曲</h1><p id="cd88" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">编排部分是大部分业务逻辑和转换最终落地的地方。<strong class="lb iu">与其直接在GraphQL上将所有东西都构建到查询引擎中，不如使用合适的工具来重用代码并更好地集成它</strong>。</p><p id="054e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为<a class="ae ky" href="http://dagster.io" rel="noopener ugc nofollow" target="_blank"> Dagster </a>是现代的业务规则引擎，你可以在其中用python代码表达逻辑，这使得它与<a class="ae ky" href="https://www.linkedin.com/feed/update/urn:li:activity:6857348322504540160/" rel="noopener ugc nofollow" target="_blank">的无代码/少代码方法</a>相比是可测试和可扩展的。Dagster提供了大量的工具，如<a class="ae ky" href="https://docs.dagster.io/concepts/resources" rel="noopener ugc nofollow" target="_blank">资源</a>来捕获可重用的代码，如连接到Druid，创建一个delta表，启动一个spark作业，所有这些都在管道中使用。分析API中的另一个构件是<a class="ae ky" href="https://docs.dagster.io/concepts/ops-jobs-graphs/ops#ops" rel="noopener ugc nofollow" target="_blank"> Op </a>，它将您的业务逻辑浓缩为<a class="ae ky" href="https://docs.dagster.io/concepts/ops-jobs-graphs/jobs-graphs" rel="noopener ugc nofollow" target="_blank">数据管道</a>中的功能任务。它用类型化的输入和输出进行了很好的定义，并使用了诸如上述资源之类的上下文，使得作为op的一部分运行spark作业变得很容易。</p><p id="d9d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析API中的集成是与GraphQL的集成，因为Dagster有一个内置的。Dagster使用这个接口来查询各种元数据，启动管道/传感器(突变)，或者订阅特定的信息。旁注:这不是凭空而来的，因为Dagster <a class="ae ky" href="https://twitter.com/schrockn" rel="noopener ugc nofollow" target="_blank">的创始人尼克·施勒克</a>是GraphQL的联合创始人😉。我们没有运行和使用<a class="ae ky" href="https://docs.dagster.io/concepts/dagit/dagit" rel="noopener ugc nofollow" target="_blank"> Dagster UI </a>，而是为开发人员使用该接口，并通过分析API对其进行抽象。</p><h1 id="3316" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">SQL连接器</h1><p id="0f38" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> SQL是除了python之外的数据语言，在前面的</strong> <a class="ae ky" href="https://www.sspaeti.com/blog/business-intelligence-meets-data-engineering/#8220use-notebooks-to-open-up-the-data-silos8221" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">文章</strong> </a> <strong class="lb iu">中有详细阐述。这就是为什么我们也需要为此提供一个接口。</strong>SQL连接器集成了所有BI、SQL speaking或遗留工具。例如，连接器主要实现一个ODBC或JDBC驱动程序，Avatica构建在Apache Druid使用的<a class="ae ky" href="https://calcite.apache.org/avatica" rel="noopener ugc nofollow" target="_blank"> Apache方解石</a>上。这样，就有了一种与ANSI SQL接口的方法，包括度量存储中的所有度量和维度，如果工具使用SQL，就无需在访问端做额外的工作。</p><h1 id="1cd6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建分析API的挑战</h1><p id="763e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在写这篇文章的时候，我经常发现自己与现有的架构和工具相冲突。这一章无论如何也不意味着是完整的。它指出了构建这样一个中央界面的挑战，并让我们从它们的优缺点中学习。</p><ul class=""><li id="6e26" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated"><strong class="lb iu">具有OpenAPI规范的微服务:</strong>由于部署应用程序很容易，我们可以在不同的API和服务之间进行大量双向通信。有了<a class="ae ky" href="https://swagger.io/specification/" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范(早期称为Swagger) </a>，你可以使用工具生成文档、客户端代码和测试。</li><li id="11e6" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://github.com/roapi/roapi" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> ROAPI </strong> </a>:另一个迷人之处是，它自动为静态数据集旋转只读API，而不需要你写一行代码。它建立在<a class="ae ky" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache Arrow </a>和<a class="ae ky" href="https://github.com/apache/arrow-datafusion" rel="noopener ugc nofollow" target="_blank"> Datafusion </a>之上。</li><li id="302e" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">云数据仓库方法:</strong>如果您使用一个主要的云数据仓库，这是一种整体架构。它给你一个API，你可以用普通的SQL访问数据。它有与你的网络应用紧密结合的缺点。</li><li id="3eb1" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.linkedin.com/feed/update/urn:li:activity:6857348322504540160/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">无代码/少代码平台</strong> </a>:当你购买一个<a class="ae ky" href="https://www.sspaeti.com/blog/business-intelligence-meets-data-engineering/#8220use-closed-source-if-you-dont-have-the-developers-or-the-time8221" rel="noopener ugc nofollow" target="_blank">闭源厂商平台</a>如<a class="ae ky" href="https://www.ascend.io/" rel="noopener ugc nofollow" target="_blank"> Ascend.io </a>或类似平台时也是如此。</li><li id="5e8d" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="http://cidrdb.org/cidr2021/papers/cidr2021_paper17.pdf" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Lakehouse架构</strong></a><strong class="lb iu">by data bricks:</strong>lake house表明，一切都朝着更小的移动部分发展，将数据接口整合到最低限度或一个单一接口。首席执行官Ali Ghodsi最近表示:“尽管我们在所有数据工具和框架方面取得了很大进展，但人们仍在四处奔波，寻找正确的数字，并与曾经正确的数字进行斗争”。这表明需要指标存储和中央分析API。</li><li id="1955" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.sspaeti.com/blog/olap-whats-coming-next/#data-virtualisations" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">数据虚拟化</strong> </a>:数据虚拟化是集中和连接所有移动部分的另一种方式。<strong class="lb iu">你不用四处移动和复制数据，也不用预聚合数据</strong>，但是你有一个语义中间层来创建你的商业模型(比如立方体)。这些工具，例如<a class="ae ky" href="https://www.dremio.com/" rel="noopener ugc nofollow" target="_blank"> Dremio </a>或<a class="ae ky" href="https://www.sspaeti.com/blog/olap-whats-coming-next/#data-virtualisations" rel="noopener ugc nofollow" target="_blank"> others </a>，使用Apache Arrow技术，该技术将缓存并优化大量内存，以便您获得快速响应时间。Apache Arrow如何工作，以及他们如何集中数据移动，你可以在Julien Le Dem的Spark Summit演讲中看到。</li><li id="7b61" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><strong class="lb iu">无服务器功能:</strong>更少的架构，但是对于更小的目标，你可以使用无服务器功能(没有基础设施)来运行你的胶合代码，例如，在<a class="ae ky" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> AWS Lambda </a>中，举一个例子。您的函数可以对支持高度事件驱动用例的事件做出反应。</li><li id="32bc" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated"><a class="ae ky" href="https://www.sspaeti.com/blog/data-warehouse-automation-dwa/" rel="noopener ugc nofollow" target="_blank">数据仓库自动化</a> **:另一种解决方法是投资自动化。你可以不用购买你的数据仓库，而是用诸如TimeXTener、WhereScape、BiGenius 和<a class="ae ky" href="https://dwa.guide/dwa-tools/" rel="noopener ugc nofollow" target="_blank">等等工具来构建它。您可以敏捷地工作，将所有内容集成到您的数据仓库中，而不是将所有内容集成到一个单一的接口中。更多关于那个</a></li></ul><h1 id="5c8c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="d71f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我们所见，GraphQL是数据工程和构建分析API的强大工具。我们了解了分析API的用途，以及数据团队如何努力为当今复杂的云架构开发一个API，主要是为了服务于各种利益相关方和其他业务部门。具有查询引擎、指标存储、数据目录、编排工具和SQL连接器的分析API的组件。最后，我们看了看其他解决方案和挑战，总的来说，就是我们现在面临的问题。</p><p id="4de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的意思是不要以任何方式成为银弹解决方案。更重要的是，我希望它能帮助你开发出适合自己的最佳解决方案。我相信在接下来的几个月或几年里，这个特定的主题将会有很多进展，我期待着看到围绕Analytics API和GraphQL的生态系统。我还对这些解决方案的命名感兴趣，因为在我看来<em class="ms">分析API </em>还不是最终的名称。</p><p id="a18e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">暂时就这样了。我期待你的建议和批评。让我知道你是如何解决构建分析API的问题的，以及你对此的想法。</p></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><p id="4a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">原载于2022年1月22日</em><a class="ae ky" href="https://www.sspaeti.com/blog/analytics-api-with-graphql-the-next-level-of-data-engineering/" rel="noopener ugc nofollow" target="_blank"><em class="ms">【https://www.sspaeti.com】</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>