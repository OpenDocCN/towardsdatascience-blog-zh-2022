# 用 Python 在 10 分钟内完成从基础到高级的日志记录

> 原文：<https://towardsdatascience.com/basic-to-advanced-logging-with-python-in-10-minutes-631501339650>

## 日志速成班，解决常见日志问题

![](img/6960211af3ebd6841d9ef01991716a74.png)

[Aditya Saxena](https://unsplash.com/@adityaries?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

在 Python 项目中，很容易使用打印语句和堆栈跟踪来跟踪代码进度和调试。但是，日志记录提供了跟踪和调试时间戳、文件名、代码行号等附加功能，区分不同类型的打印语句，甚至可以选择将打印语句保存到日志文件或其他位置，而不仅仅是在控制台或命令行上查看！

本文将介绍日志记录的组件，如何在一个文件中执行日志记录，以及如何使用配置以可重用和可伸缩的方式跨多个文件执行日志记录。

***更新*** *:本文是一个系列的一部分。查看其他“10 分钟内”话题* [*此处*](https://medium.com/@kayjanwong/list/in-10-minutes-eeaa9aa67055) *！*

# 目录

*   [日志记录的组成部分:文件、级别、格式](https://medium.com/p/631501339650/#ff3f)
*   [文件内的基本记录](https://medium.com/p/631501339650/#c1dd)
*   [日志记录的高级组件:记录器、处理器、过滤器、格式化器](https://medium.com/p/631501339650/#0ce9)
*   [使用配置文件进行高级日志记录](https://medium.com/p/631501339650/#bd1f)
*   [常见问题:覆盖、继承](https://medium.com/p/631501339650/#9202)

# 日志记录的组成部分

在深入研究代码实现之前，有几个组件是有效使用日志记录不可或缺的。

## 日志文件—在哪里记录？

建议将日志保存到日志文件中，而不是在控制台或命令行中查看，因为一旦控制台或终端关闭，信息就会消失。我们可以指定我们想要存储日志的项目的相对路径。

您还可以定义保存模式。默认情况下，日志以追加模式保存，但可以更改为写入模式以覆盖以前的日志。

## 日志级别—何时记录？

根据所跟踪事件的任务和严重性，有 5 个级别的日志记录。按照严重性的递增顺序，

*   `**DEBUG**`:记录详细信息，用于诊断问题，即故障调查
*   `**INFO**`:记录详细信息，用于程序的正常运行，即状态监控
*   `**WARN**`:记录未来的意外事件或潜在问题，当代码在意外事件发生后仍能正常工作时使用
*   `**ERROR**`:记录严重的问题，当代码不能执行某些功能时使用
*   `**CRITICAL**`:记录严重错误，在代码无法继续运行时使用

当有疑问时，我总是在正常操作时使用`INFO`级别，而在分别面临次要和主要问题时使用`WARN`或`ERROR`级别。

默认情况下，日志级别为`WARN`，这意味着低于该级别的日志级别，即`DEBUG`和`INFO`，将不会被记录，除非更改默认日志级别。

## 日志格式—记录什么？

可以设置日志的格式，这种格式适用于所有日志条目——这意味着您不必为每个日志调用手动标准化相同的格式！默认情况下，日志条目遵循格式`**levelname:name:message**`，比如`DEBUG:root:This is a log entry`，但是可以对其进行定制以包含更多信息，

*   `**asctime**`:日志时间，具有默认格式`%Y-%m-%d %H:%M:%S,%f`，但是可以根据 Python 日期时间模块[格式代码](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes)进行更改
*   `**levelname**`:日志级别，即`DEBUG`、`INFO`
*   `**name**`:记录仪名称，默认为`root`
*   `**filename**`:包含日志调用的文件名，即`file.py`
*   `**module**`:文件名的名称部分，即`file`
*   `**funcName**`:包含日志调用的函数名，即`function_name`
*   `**lineno**`:发出日志调用的文件的行号
*   `**message**`:日志消息，如`This is a log entry`
*   更多格式属性可以在找到

为了指定格式，我们使用`"%(component)s"`约定，比如`"%(levelname)s"`。例如，默认格式表示为`"%(levelname)s:%(name)s:%(message)s"`。这将在下一节详细阐述。

# 文件内的基本日志记录

理解了日志组件之后，我们就可以记录一些信息了！日志记录可以这样进行，

在上面的例子中，我们使用`**basicConfig**`来指定日志配置，

*   `**filename**`:日志文件，*相对于*项目的路径
*   `**filemode**`:保存模式，`"a"`追加(默认)，`"w"`写入
*   `**level**`:日志级别，`DEBUG`表示将记录等于或高于`DEBUG`级别的每个项目
*   `**format**`:日志格式
*   `**datefmt**`:日志格式中`asctime`的日期格式
*   `**encoding**`:指定编码，仅在 Python 版本中可用

指定配置后，我们可以在代码中插入日志调用，如`logging.info()`来执行日志记录。默认情况下，只记录日志消息，但是我们可以设置`exc_info=True`来捕获堆栈跟踪，如第 19 行所示。

也就是说，使用`basicConfig`实现日志记录需要在不同的文件中定义配置，这会导致重复的代码。在下一节中，我们将利用配置文件以可重用和可伸缩的方式实现日志记录。

# 日志记录的高级组件

对于日志记录的高级用法，我们可以在一个配置文件中定义日志配置，使其可在多个 Python 文件中重复使用。如果以这种方式实现日志记录，可以完成更多的项目和定制，并且它建立在上一节中的基本组件之上。

## 记录器

> 记录器公开应用程序代码直接使用的接口

记录器对应于日志条目中的`name`属性。默认选择`root`记录器及其保存路径、保存模式、格式等设置。由*处理程序*处理(下一节)。

使用模块级日志记录器是一个很好的习惯，这样模块名而不是`root`将作为日志条目的`name`属性出现。

如果需要一个以上的设置，可以定义并使用自定义记录器来代替`root`记录器。

模块级记录器和自定义记录器可以这样实现，

```
# Within Python file
import logging
logging.basicConfig(...)

# Module-level logger
logger = logging.getLogger(__name__)

# Custom logger
logger = logging.getLogger("custom_logger")

# Log call
logger.info("Log with info-level severity")
```

注意日志调用现在用`logger.info()`代替`logging.info()`！

## 经理人

> 处理程序将日志记录发送到适当的目的地(类似于日志文件)

处理程序指定如何保存日志。在前面的部分中，我们只将日志保存到一个日志文件中，但是有更多的方法来处理日志。这可以通过使用已经为您实现的相关处理程序类来完成。常见的处理程序类包括:

*   `**StreamHandler**`:发送消息到流，即控制台
*   `**FileHandler**`:发送消息到磁盘文件
*   `**RotatingFileHandler**`:支持最大日志文件大小和日志文件循环的 FileHandler
*   更多的处理器类型可以在[这里](https://docs.python.org/3/howto/logging.html#useful-handlers)找到。

**模块化**:处理程序是以模块化的方式实现的，这样就可以定义一个处理程序名，并在不同的记录器(`root`或自定义记录器)之间重用。

**多对一**:一个日志记录器可以由多个处理程序组成，例如，如果我们希望日志使用`StreamHandler`同时出现在控制台上，并使用`FileHandler`保存到一个日志文件中。

## 过滤

> 过滤器根据严重性(类似于日志级别)确定输出哪些日志记录

过滤器设置日志严重级别，并记录指定严重级别及以上的所有内容。在字段`**level**`下，过滤器与处理程序一起定义。

如果需要更多的定制，例如只过滤一个特定的严重性级别，必须编写一个 Python 类，这个过滤器将与处理程序一起定义，但现在在字段`**filters**`下。

**模块化**:过滤器是以模块化的方式实现的，这样就可以定义一个过滤器名称，并在不同的处理程序中重用。

**多对一**:一个处理器可以由多个过滤器组成。

## 格式化程序

> 格式化程序指定日志记录的格式(类似于日志格式)

格式化程序设置日志条目的格式。在字段`**formatter**`下，格式化程序与处理程序一起定义。

模块化:格式化程序是以模块化的方式实现的，这样就可以定义一个格式化程序名，并在不同的处理程序中重用。

**一对一**:每个处理程序只能有一种日志格式。

> 每个处理程序都有一个独特的文件过滤格式设置

因为过滤器和格式化程序是与处理程序一起定义的，所以每个处理程序都有一个唯一的文件过滤器格式设置。如果需要另一个文件(`StreamHandler`或`FileHandler`)、过滤器(`DEBUG`或`WARN`级)或格式，应该定义一个单独的处理程序。

# 使用配置文件进行高级日志记录

我们现在将使用配置文件实现日志记录——这比使用`basicConfig`更具可重用性和可伸缩性。配置可以在`.py`或`.yml`文件中的`.conf`文件或字典中定义

字典配置可以这样定义，

我们可以看到字典配置被分成几个部分

*   `**version**`(第 13 行):用整数表示版本号
*   `**loggers**`(第 14–25 行):定义根和自定义记录器，由一个或多个处理程序组成
*   `**handlers**`(第 26–41 行):定义在记录器中使用的自定义处理程序，包括特定的文件过滤格式设置
*   `**filters**`(第 42–47 行):定义在处理程序中使用的自定义过滤器
*   `**formatters**`(第 48–52 行):定义在处理程序中使用的自定义格式化程序

使用`.conf`文件的等效实现可以是这样的，

要使用`logging.conf`中定义的配置初始化记录器，

```
import logging.config
logging.config.fileConfig("logging.conf")
logger = logging.getLogger(__name__)
```

比较`dictConfig`和`fileConfig`，字典实现是首选，因为它更新，能够支持更多功能，如使用自定义过滤器。

比较`logging.config`和`logging.basicConfig`，使用配置文件减少了重复代码的数量，并将配置抽象到单独的字典或配置文件中，这是跨多个文件执行日志记录的首选方式。

# 常见问题

在这一节中，我将涉及一些使用配置文件实现日志记录的常见问题和注意事项。

## 最重要的

有几种方法可以覆盖日志配置。

№1:同时使用`logging.basicConfig`和`logging.config`

如果不同的文件使用不同的方法实例化记录器，并且在这些文件之间进行了一些导入，使得日志配置中存在冲突，`logging.config`实现优先，`logging.basicConfig`被覆盖。

№2:日志级别是在日志程序级别与处理程序级别定义的

如果您注意到在字典和`logging.conf`文件中，日志级别被定义了两次，一次在记录器定义中，另一次在处理程序定义中。严重性级别越高，优先级越高，其次是记录器级别优先于处理程序级别。

为了使这项工作对您有利，我们可以将日志记录级别设置为最低严重性`DEBUG`，并使用处理程序级别来控制级别。如果一个级别应该跨多个处理程序进行标准化，那么可以在 logger 定义中随意定义这个级别。

## 遗产

在继承期间，日志将被传递给记录器及其高级(祖先)记录器，导致日志条目被复制。默认情况下，所有自定义记录器都继承自`root`记录器。

为了防止继承导致重复的日志，我们可以在配置中定义记录器时将`propagate`字段指定为`False`。

希望您已经更多地了解了日志记录的组件，以及如何使用配置文件以可重用和可伸缩的方式实现它！与普通的打印语句相比，日志记录有助于开发人员更好地控制和理解代码库，在大型项目中调试代码时尤其有用。

**感谢您的阅读！如果你喜欢这篇文章，请随意分享。**

# 相关链接

记录文档:[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)

伐木食谱:[https://docs.python.org/3/howto/logging-cookbook.html](https://docs.python.org/3/howto/logging-cookbook.html)