<html>
<head>
<title>NumPy for Data Science Interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学面试的数字</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-for-data-science-interviews-1f86e7277ddd#2022-01-07">https://towardsdatascience.com/numpy-for-data-science-interviews-1f86e7277ddd#2022-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="79f5" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">数据科学面试的数字</h1></div><div class=""><h2 id="1dd5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">数据科学NumPy简介</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/8baab02e4297a94f3b3c9226c86b2973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kg3NXfDTiP6e6bbMYje-Ag.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="2117" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">NumPy是Python数据科学生态系统中用于科学计算的基础库。NumPy的一些关键特性包括</p><ul class=""><li id="17ed" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">速度:NumPy数组比标准Python列表快50倍</li><li id="8826" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">性能:NumPy融合了Python的易用性和C的速度</li><li id="f8de" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">索引和广播:熊猫中广泛使用的特性是从NumPy继承来的。</li><li id="a8f2" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">计算工具:NumPy拥有全面的数学函数和计算工具，几乎可以满足所有需求。您可以执行诸如曲线拟合、优化、线性代数、变换等操作。，得心应手。</li><li id="5ee4" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">NumPy是许多其他科学计算库构建的基础。一些使用NumPy的知名库有<br/> - Stats和ML库:SciPy、Statsmodels、Scikit-Learn、SpaCy <br/> -可视化:Matplotlib、Seaborn、Plotly、Bokeh、Altair <br/> -数组操作:PyTorch、Dask、TensorFlow <br/> - ETL: Pandas</li></ul><p id="e652" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你是一个有抱负的数据科学家，精通NumPy是意料之中的。幸运的是，NumPy简单易学。在这个由两部分组成的系列中，我们将从NumPy的基础开始，转到NumPy的高级用法。</p><h1 id="45cb" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">对金钱的需求</h1><p id="53a2" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">让我们举一个简单的例子。假设你想从A点到B点，有多种旅行方式。你可以骑自行车试着走路，或者你可能想开车。有很多选择，你可以选择跑车或SUV，甚至在车辆中。如果你不知道你将在什么样的地形上行驶，你可能会更适合使用SUV，因为这就是它们的设计目的——一种多功能车辆。然而，如果你的目标是在尽可能短的时间内完成旅程，并且你知道道路铺设良好，没有来自另一个方向的意外交通，你会选择跑车，因为你可以快速通过距离。简而言之，这就是标准Python列表和NumPy数组之间的区别。Python列表是您的全地形车，而NumPy数组是跑车。Python列表旨在处理可以插入到列表中的所有类型的数据。然而，假设。您知道数据是同质的和数字类型的数据(整数、浮点、布尔、日期时间等。)并涉及大量计算。在这种情况下，您最好使用NumPy。</p><p id="e11f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们看一个简单的用例。假设我们有一个简单的五种元素的列表。我们想创建另一个列表，包含这些元素除以5的结果。我们将不得不遍历列表并逐元素执行操作，因为对整个列表执行除法操作将导致错误。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="957f" class="nj mi iq nf b gy nk nl l nm nn">mylist <strong class="nf ir">=</strong> [10,20,30,40,50]<br/>mylist <strong class="nf ir">/</strong> 5</span><span id="58fa" class="nj mi iq nf b gy no nl l nm nn"><strong class="nf ir">--------------------------------------------------------------------</strong><br/><strong class="nf ir">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="nf ir">~\AppData\Local\Temp/ipykernel_21064/503464290.py</strong> in &lt;module&gt;<br/>      1 mylist <strong class="nf ir">=</strong> <strong class="nf ir">[10,20,30,40,50]</strong><br/><strong class="nf ir">----&gt; 2 </strong>mylist <strong class="nf ir">/</strong> <strong class="nf ir">5</strong><br/><br/><strong class="nf ir">TypeError</strong>: unsupported operand type(s) for /: 'list' and 'int'</span></pre><p id="6161" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">即使这五个元素都是数字，Python列表也不允许您执行这种除法运算，因为Python运算设计用于所有可能的情况。由于列表不需要只包含数字数据类型，Python不允许这样做。</p><p id="55a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输入NumPy。使用NumPy数组，我们可以简单地将整个数组除以5。就像你会对熊猫系列做的一样(事实上，熊猫系列从NumPy获得这些能力)。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="6717" class="nj mi iq nf b gy nk nl l nm nn">myarray <strong class="nf ir">=</strong> np<strong class="nf ir">.</strong>array(mylist)<br/>myarray <strong class="nf ir">/</strong> 5</span><span id="02b9" class="nj mi iq nf b gy no nl l nm nn">array([ 2.,  4.,  6.,  8., 10.])</span></pre><p id="ce16" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">使用NumPy的另一个原因是速度。NumPy数组比Python标准列表快得多。这里有一个简单的例子。我们将添加两个Python列表，每个列表包含一百万个元素。比较列表操作和等价的NumPy操作，我们发现NumPy比标准列表快20倍。(<strong class="kz ir"> <em class="np">注:速度可能不同</em> </strong>)</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="7d5a" class="nj mi iq nf b gy nk nl l nm nn">size_of_vec <strong class="nf ir">=</strong> 1000000<br/><br/><strong class="nf ir">def</strong> pure_python_version():                                                <br/>    time_python <strong class="nf ir">=</strong> time<strong class="nf ir">.</strong>time()                                             <br/>    my_list1 <strong class="nf ir">=</strong> range(size_of_vec)                                         <br/>    my_list2 <strong class="nf ir">=</strong> range(size_of_vec)<br/>    sum_list <strong class="nf ir">=</strong> [my_list1[i] <strong class="nf ir">+</strong> my_list2[i] <strong class="nf ir">for</strong> i <strong class="nf ir">in</strong> range(len(my_list1))]  <br/>    <strong class="nf ir">return</strong> time<strong class="nf ir">.</strong>time() <strong class="nf ir">-</strong> time_python                                      <br/><br/><strong class="nf ir">def</strong> numpy_version():                                                      <br/>    time_numpy <strong class="nf ir">=</strong> time<strong class="nf ir">.</strong>time()                                              <br/>    my_arr1 <strong class="nf ir">=</strong> np<strong class="nf ir">.</strong>arange(size_of_vec)                                      <br/>    my_arr2 <strong class="nf ir">=</strong> np<strong class="nf ir">.</strong>arange(size_of_vec)<br/>    sum_array <strong class="nf ir">=</strong> my_arr1 <strong class="nf ir">+</strong> my_arr2                                         <br/>    <strong class="nf ir">return</strong> time<strong class="nf ir">.</strong>time() <strong class="nf ir">-</strong> time_numpy                                       <br/><br/><br/>python_time <strong class="nf ir">=</strong> pure_python_version()                                       <br/>numpy_time <strong class="nf ir">=</strong> numpy_version()                                              <br/>print("Pure Python version {:0.4f}"<strong class="nf ir">.</strong>format(python_time))<br/>print("Numpy version {:0.4f}"<strong class="nf ir">.</strong>format(numpy_time))<br/>print("Numpy is in this example {:0.4f} times faster!"<strong class="nf ir">.</strong>format(python_time<strong class="nf ir">/</strong>numpy_time))</span><span id="7dae" class="nj mi iq nf b gy no nl l nm nn">Pure Python version 0.2890<br/>Numpy version 0.0030<br/>Numpy is in this example 96.4017 times faster!</span></pre><h1 id="01b7" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">NumPy与Python和Pandas数据类型的比较</h1><p id="1ffd" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">熊猫呢？熊猫数据框提供了一种操作表格数据的简单方法。每个熊猫系列都是建立在NumPy阵列上的。熊猫提供了使用行标签和列标签来标记元素的优势。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="137d" class="nj mi iq nf b gy nk nl l nm nn"><strong class="nf ir">Pandas Series and NumPy arrays</strong><br/>myseries = pd.Series([10,20,30,40,50], index = ['A', 'B', 'C', 'D', 'E'])<br/>myseries<br/>A    10<br/>B    20<br/>C    30<br/>D    40<br/>E    50<br/>dtype: int64<br/>pd_to_np = myseries.to_numpy()<br/>pd_to_np<br/>array([10, 20, 30, 40, 50], dtype=int64)</span></pre><p id="9434" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，随着数据量的增长，数学运算变得越来越慢<a class="ae kw" href="https://stackoverflow.com/questions/21567842/is-there-a-performance-difference-between-numpy-and-pandas" rel="noopener ugc nofollow" target="_blank"/>。人们可以使用Pandas来操作数据，然后转移到NumPy来更快地执行操作。</p><h1 id="3147" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">数字基础</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/8bd583831517c270be4bda868a60bff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-bKAi9JJme2Wm5G-zQyrKA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图片</p></figure><h1 id="a650" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">初始化</h1><p id="b9b3" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">有多种初始化NumPy数组的方法。最简单的方法是向NumPy中的array方法传递一个列表(或任何其他类似数组的对象)。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="9553" class="nj mi iq nf b gy nk nl l nm nn">list_to_np = np.array([1,2,3,4,5])<br/>list_to_np<br/>array([1, 2, 3, 4, 5])<br/>tuple_to_np = np.array((1,2,3,4,5))<br/>tuple_to_np<br/>array([1, 2, 3, 4, 5])</span></pre><p id="9bbb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，下面的代码会产生一个错误。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="27a8" class="nj mi iq nf b gy nk nl l nm nn"># This will result in an error<br/>wrong_np= np.array(1,2,3,4,5)<br/>wrong_np<br/>--------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_21064/3907638067.py in &lt;module&gt;<br/>      1 # This will result in an error<br/>----&gt; 2 wrong_np= np.array(1,2,3,4,5)<br/>      3 wrong_np</span><span id="c95a" class="nj mi iq nf b gy no nl l nm nn">TypeError: array() takes from 1 to 2 positional arguments but 5 were given</span></pre><p id="5626" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是开始使用NumPy时最常见的错误之一。我们需要将数组元素作为类似数组的对象传递，如list、tuple、Pandas Series等。</p><h1 id="5b9c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">规模</h1><p id="832a" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">NumPy数组是同质项目的n维容器。NumPy可以处理多维数据，因此非常适合科学计算。我们可以像前面创建一维数组一样创建多维数组。</p><p id="7a51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">多维数组</strong></p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="5cc0" class="nj mi iq nf b gy nk nl l nm nn">array_2d = np.array([<br/>    [1,2,3,4,5], <br/>    [11,12,13,14,15]<br/>]<br/>)<br/>array_2d<br/>array([[ 1,  2,  3,  4,  5],<br/>       [11, 12, 13, 14, 15]])</span></pre><p id="f9d8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要记住的一点是，这里的子列表的长度应该是相同的，否则，NumPy将创建一个所谓的不规则数组(列表类型的数组)数据，这基本上违背了NumPy的目的。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="77c7" class="nj mi iq nf b gy nk nl l nm nn"># Ragged Array<br/>array_ragged = np.array([<br/>    [1,2,3,4,5], <br/>    [11,12,13,14,15, 16]<br/>]<br/>)<br/>array_ragged</span><span id="5a5c" class="nj mi iq nf b gy no nl l nm nn">C:\Users\Asus\AppData\Local\Temp/ipykernel_21064/3536024976.py:2: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray<br/>  array_ragged = np.array([<br/>array([list([1, 2, 3, 4, 5]), list([11, 12, 13, 14, 15, 16])],<br/>      dtype=object)</span></pre><p id="0f1c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">把它想象成驾驶一辆跑车进入沙漠。它会移动(至少一段时间)，但这不是它的设计目的！</p><p id="082e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以很容易地将一维数据转换成多维数据，反之亦然。我们将在以后研究这些。</p><h1 id="c3eb" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">描述性属性</h1><p id="c2d9" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">与熊猫一样，我们可以找出NumPy数组的各种属性。最常用的属性是。</p><p id="2575" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np"> ndim </em> </strong>:数据的维数(轴数)。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="2812" class="nj mi iq nf b gy nk nl l nm nn">myarray<br/>array([10, 20, 30, 40, 50])<br/>myarray.ndim<br/>1<br/>array_2d<br/>array([[ 1,  2,  3,  4,  5],<br/>       [11, 12, 13, 14, 15]])<br/>array_2d.ndim<br/>2</span></pre><p id="622e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np"> shape </em> : </strong>它以元组的形式返回每个维度上元素的数量</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="87b0" class="nj mi iq nf b gy nk nl l nm nn">myarray.shape<br/>(5,)<br/>array_2d.shape<br/>(2, 5)</span></pre><p id="43c8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np"> size </em> </strong>:返回数组中元素的个数。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="f92d" class="nj mi iq nf b gy nk nl l nm nn">myarray.size<br/>5<br/>array_2d.size<br/>10</span></pre><p id="1673" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np"> dtype </em> : </strong>这为我们提供了数组元素的数据类型。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="3c54" class="nj mi iq nf b gy nk nl l nm nn">dtype : datatype of the array elements</span><span id="2139" class="nj mi iq nf b gy no nl l nm nn">myarray<br/>array([10, 20, 30, 40, 50])<br/>myarray.dtype<br/>dtype('int32')<br/>myarray / 5<br/>array([ 2.,  4.,  6.,  8., 10.])<br/>(myarray / 5).dtype<br/>dtype('float64')</span></pre><p id="91e1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然最常见的数据类型是整数(int)和浮点(float)，但NumPy还允许您创建日期时间、布尔和字符类型数组。</p><h1 id="bc3c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">特殊数组</h1><p id="1614" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">NumPy允许我们非常容易地快速初始化大型数组，尤其是那些与科学计算相关的数组。</p><p id="e38e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np">个</em></strong><em class="np">—1的数组。</em></p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="d486" class="nj mi iq nf b gy nk nl l nm nn">ones_ar = np.ones([3,7])<br/>ones_ar<br/>array([[1., 1., 1., 1., 1., 1., 1.],<br/>       [1., 1., 1., 1., 1., 1., 1.],<br/>       [1., 1., 1., 1., 1., 1., 1.]])</span></pre><p id="22a6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"><em class="np">0</em></strong>—0的数组</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="e964" class="nj mi iq nf b gy nk nl l nm nn">zeros_ar = np.zeros([6,4])<br/>zeros_ar<br/>array([[0., 0., 0., 0.],<br/>       [0., 0., 0., 0.],<br/>       [0., 0., 0., 0.],<br/>       [0., 0., 0., 0.],<br/>       [0., 0., 0., 0.],<br/>       [0., 0., 0., 0.]])</span></pre><p id="96f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np">眼</em> </strong> —指定对角线上为1，其他地方为0的数组。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="d9af" class="nj mi iq nf b gy nk nl l nm nn">eye_ar = np.eye(6,4, 1)<br/>eye_ar<br/>array([[0., 1., 0., 0.],<br/>       [0., 0., 1., 0.],<br/>       [0., 0., 0., 1.],<br/>       [0., 0., 0., 0.],<br/>       [0., 0., 0., 0.],<br/>       [0., 0., 0., 0.]])<br/>eye_ar2 = np.eye(6,4, -2)<br/>eye_ar2<br/>array([[0., 0., 0., 0.],<br/>       [0., 0., 0., 0.],<br/>       [1., 0., 0., 0.],<br/>       [0., 1., 0., 0.],<br/>       [0., 0., 1., 0.],<br/>       [0., 0., 0., 1.]])</span></pre><p id="6f00" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除此之外，我们还可以创建等距数组。标准Python中有range数据类型。NumPy有两种非常常用的方法来快速创建相似间距的值。这些是:</p><p id="a706" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="np"> arange: </em> </strong>这与标准Python中的range数据类型非常相似。NumPy中的arange方法使用与range数据类型相同的元素创建一个数组。与range数据类型不同，它存储为NumPy数组。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="c942" class="nj mi iq nf b gy nk nl l nm nn">arange_ar = np.arange(1,20,3)<br/>arange_ar<br/>array([ 1,  4,  7, 10, 13, 16, 19])</span></pre><p id="7591" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"><em class="np">linspace</em></strong>:linspace方法将给定的端点划分成等间距的区间。在给定的例子中，我们想要五个等距的点，1和12是端点。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="8b17" class="nj mi iq nf b gy nk nl l nm nn">linspace_ar = np.linspace(1,12,5)<br/>linspace_ar<br/>array([ 1.  ,  3.75,  6.5 ,  9.25, 12.  ])</span></pre><h1 id="47be" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">重塑NumPy数组</h1><p id="5a1c" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">NumPy允许您轻松地将数组的形状更改为我们想要的尺寸。我们可以简单地使用reshape方法来改变数组的形状。需要注意的一点是，只有当两个数组的大小(元素的数量)相同时，才可以改变数组的形状。因此，您可以将包含60个元素的数组拆分为以下形状</p><ul class=""><li id="c999" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">60x1(或1x60、1x 60x 1……)</li><li id="6506" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">2x30</li><li id="051b" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">4x15</li><li id="ffec" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">2x3x10</li><li id="9f33" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">1x6x5等等</li></ul><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="fa59" class="nj mi iq nf b gy nk nl l nm nn">ar60 = np.arange(1,61)<br/>ar60<br/>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,<br/>       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,<br/>       35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,<br/>       52, 53, 54, 55, 56, 57, 58, 59, 60])<br/>ar_6_10 = ar60.reshape(6,10)<br/>ar_6_10<br/>array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10],<br/>       [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],<br/>       [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],<br/>       [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],<br/>       [41, 42, 43, 44, 45, 46, 47, 48, 49, 50],<br/>       [51, 52, 53, 54, 55, 56, 57, 58, 59, 60]])<br/>ar_6_10.shape<br/>(6, 10)</span></pre><p id="47e5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，不能将一个60元素的数组拆分成另一个一维上有7个元素的数组</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="2194" class="nj mi iq nf b gy nk nl l nm nn">ar60.reshape(7,10)<br/>--------------------------------------------------------------------<br/>ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_21064/1130489163.py in &lt;module&gt;<br/>----&gt; 1 ar60.reshape(7,10)</span><span id="9c37" class="nj mi iq nf b gy no nl l nm nn">ValueError: cannot reshape array of size 60 into shape (7,10)</span></pre><p id="cb9d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">NumPy中的快速破解允许它自己计算尺寸。例如，如果您不知道特定数组中元素的确切数量，但想要六行，我们可以通过指定-1作为要计算的维度来实现。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="5e57" class="nj mi iq nf b gy nk nl l nm nn">ar60.reshape(6,-1)<br/>array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10],<br/>       [11, 12, 13, 14, 15, 16, 17, 18, 19, 20],<br/>       [21, 22, 23, 24, 25, 26, 27, 28, 29, 30],<br/>       [31, 32, 33, 34, 35, 36, 37, 38, 39, 40],<br/>       [41, 42, 43, 44, 45, 46, 47, 48, 49, 50],<br/>       [51, 52, 53, 54, 55, 56, 57, 58, 59, 60]])</span></pre><p id="440f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在上面的例子中，我们有60个元素，所以当我们把它调整为(6，-1)时，NumPy自动计算出另一个维度为60 / 6 = 10。</p><p id="5cc3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">显然，如果一个轴上的元素数不是60的倍数，这就行不通了。所以这将返回一个错误。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="12e4" class="nj mi iq nf b gy nk nl l nm nn"># This will return an error<br/>ar60.reshape(7,-1)<br/>--------------------------------------------------------------------<br/>ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_21064/3388074008.py in &lt;module&gt;<br/>      1 # This will return an error<br/>----&gt; 2 ar60.reshape(7,-1)</span><span id="d5f5" class="nj mi iq nf b gy no nl l nm nn">ValueError: cannot reshape array of size 60 into shape (7,newaxis)</span></pre><p id="c0f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，NumPy一次只能计算一个未知维度。所以这也会导致错误。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="a413" class="nj mi iq nf b gy nk nl l nm nn"># So will this<br/>ar60.reshape(6,-1,-1)<br/>--------------------------------------------------------------------<br/>ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_21064/2258005957.py in &lt;module&gt;<br/>      1 # So will this<br/>----&gt; 2 ar60.reshape(6,-1,-1)</span><span id="dde4" class="nj mi iq nf b gy no nl l nm nn">ValueError: can only specify one unknown dimension</span></pre><h1 id="0e06" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">索引和切片数组</h1><p id="0718" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">索引和切片NumPy数组，就像我们处理Pandas数据帧、Pandas系列和列表一样。假设你想在一个数组中找到第n个索引项；您可以像我们处理Python列表一样简单地使用切片器。切片器的其他功能也像处理Python列表或Pandas数据帧一样工作。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="340b" class="nj mi iq nf b gy nk nl l nm nn">ar60<br/>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,<br/>       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,<br/>       35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,<br/>       52, 53, 54, 55, 56, 57, 58, 59, 60])<br/>• Accessing the item at index = 5 (Note NumPy is zero indexed)<br/>ar60[5]<br/>6<br/>• Accessing the first 10 elements<br/>ar60[:10]<br/>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</span></pre><p id="1619" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于多维数组，我们可以用与Pandas iloc方法相同的方式进行索引。这是一个从二维数组中选择的例子</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="567e" class="nj mi iq nf b gy nk nl l nm nn">ar5_12 = ar60.reshape(5,12)<br/>ar5_12<br/>array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12],<br/>       [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],<br/>       [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],<br/>       [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48],<br/>       [49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]])<br/>ar5_12[2,5]<br/>30</span></pre><p id="c6d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也可以通过使用多个切片器来进行子集划分。这是从二维数组中选择多个项目的另一个例子</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="c95e" class="nj mi iq nf b gy nk nl l nm nn">ar5_12[2][5]<br/>30</span></pre><p id="8854" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以将一系列索引传递给切片器。这非常类似于熊猫数据帧中的iloc方法。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="4992" class="nj mi iq nf b gy nk nl l nm nn">• NumPy indexing is very similar to iloc method in Pandas<br/>ar5_12[:, 3]<br/>array([ 4, 16, 28, 40, 52])<br/>ar5_12[2, :]<br/>array([25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36])</span></pre><h1 id="3fb3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">布尔掩码</h1><p id="48d1" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">NumPy中最强大的概念之一是布尔屏蔽。正如我们在前面的Pandas中看到的，我们可以基于逻辑真/假条件对NumPy数组进行子集划分，并获得满足该条件的元素输出。这在熊猫中相当普遍。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="e25f" class="nj mi iq nf b gy nk nl l nm nn">ar60<br/>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,<br/>       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,<br/>       35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,<br/>       52, 53, 54, 55, 56, 57, 58, 59, 60])</span><span id="674b" class="nj mi iq nf b gy no nl l nm nn">ar60[ar60 % 3 == 0]</span><span id="f033" class="nj mi iq nf b gy no nl l nm nn">array([ 3,  6,  9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51,<br/>       54, 57, 60])</span></pre><p id="e05d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与Pandas一样，在创建这些布尔掩码时，我们将不得不使用Python逻辑操作符，而不是像and、or这样的关键字。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="f29c" class="nj mi iq nf b gy nk nl l nm nn">ar60[(ar60 % 3 == 0) | (ar60 % 5 == 0)]<br/>array([ 3,  5,  6,  9, 10, 12, 15, 18, 20, 21, 24, 25, 27, 30, 33, 35, 36,<br/>       39, 40, 42, 45, 48, 50, 51, 54, 55, 57, 60])<br/># This will result in an error<br/>ar60[(ar60 % 3 == 0) or (ar60 % 5 == 0)]<br/>--------------------------------------------------------------------<br/>ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_21064/445061012.py in &lt;module&gt;<br/>      1 # This will result in an error<br/>----&gt; 2 ar60[(ar60 % 3 == 0) or (ar60 % 5 == 0)]</span><span id="8369" class="nj mi iq nf b gy no nl l nm nn">ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()</span></pre><p id="0f41" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">查看我们的帖子“<a class="ae kw" href="https://www.stratascratch.com/blog/microsoft-data-scientist-interview-questions/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">微软数据科学家面试问题</a>”，找到最近的一个面试问题，该问题测试“布尔掩码数组”作为Python的主要概念之一。</p><h1 id="8660" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">NumPy中的函数</h1><p id="5796" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">NumPy自带各种内置函数。这些函数可以非常快速地执行数学运算和复杂的科学计算。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="876a" class="nj mi iq nf b gy nk nl l nm nn">ar5_12<br/>array([[ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12],<br/>       [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],<br/>       [25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],<br/>       [37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48],<br/>       [49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60]])<br/>ar5_12.sum()<br/>1830</span></pre><p id="a994" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们也可以沿着特定的轴而不是整个数组来执行这些操作。所以，如果你想得到沿行或仅沿列的元素的和，那也是可能的，记住最外面的维度是轴0，下一个是轴1，依此类推。与标准Python一样，我们可以使用负索引。最里面的维度将是axis = -1，依此类推。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="0458" class="nj mi iq nf b gy nk nl l nm nn">ar5_12.shape<br/>(5, 12)</span><span id="c9b2" class="nj mi iq nf b gy no nl l nm nn">• axus 0 is the outer most axis, -1 is the innermost<br/>ar5_12.sum(axis = 0)<br/>array([125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180])<br/>ar5_12.sum(axis = 1)<br/>array([ 78, 222, 366, 510, 654])</span><span id="428a" class="nj mi iq nf b gy no nl l nm nn">• Negative axis<br/>ar5_12.sum(axis = -1)<br/>array([ 78, 222, 366, 510, 654])<br/>ar5_12.sum(axis = -2)<br/>array([125, 130, 135, 140, 145, 150, 155, 160, 165, 170, 175, 180])</span></pre><p id="99f1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除了简单的聚合函数，如sum、max、min等。，我们也有内置的标准数学函数。NumPy中函数的<a class="ae kw" href="https://numpy.org/doc/stable/reference/routines" rel="noopener ugc nofollow" target="_blank">完整列表</a>可以参考文档。</p><h1 id="797a" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">矢量化运算</h1><p id="ac2a" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">使NumPy如此强大的另一个特性是矢量化运算。这些允许我们在整个维度甚至整个数组上执行数学运算。例如，如果我们想添加两个数组，你可以简单地这样做。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="3ca3" class="nj mi iq nf b gy nk nl l nm nn">list01 = [10,11,12,13]<br/>list02 = [20,21,22,23]<br/>np.array(list01) + np.array(list02)<br/>array([30, 32, 34, 36])</span></pre><p id="a690" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这对于连接两个列表的Python列表来说是不可能的。</p><pre class="kh ki kj kk gt ne nf ng nh aw ni bi"><span id="d0d6" class="nj mi iq nf b gy nk nl l nm nn">list01 + list02<br/>[10, 11, 12, 13, 20, 21, 22, 23]</span></pre><p id="0927" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这些操作不仅限于相同维数的数组。甚至不同的数组也可以用于这些矢量化运算。这个过程称为广播，我们将在本系列的下一部分中研究NumPy的这些和更多高级特性，我们将涉及:</p><ul class=""><li id="c83c" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">NumPy随机数运算</li><li id="94d9" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">堆叠和拆分等阵列操作</li><li id="c0d8" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">处理缺失值</li><li id="1767" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">广播</li><li id="4b83" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">矩阵运算</li><li id="448a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">曲线拟合</li><li id="1996" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">将数据导入NumPy</li></ul><h2 id="79b5" class="nj mi iq bd mj nq nr dn mn ns nt dp mr lg nu nv mt lk nw nx mv lo ny nz mx oa bi translated">结论</h2><p id="4f5e" class="pw-post-body-paragraph kx ky iq kz b la mz jr lc ld na ju lf lg nb li lj lk nc lm ln lo nd lq lr ls ij bi translated">对于有抱负的数据科学家来说，NumPy可以说是仅次于Pandas的最重要的Python库。虽然对于没有数学或技术背景的人来说，NumPy可能会显得有点不舒服，但如果我们从熊猫开始，那么NumPy就变得非常容易使用。NumPy提供的可能性和能力是其他标准库中所没有的。</p><p id="dc26" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">和其他技能一样，耐心、坚持和练习是提高的关键。如果你想在实际的数据科学面试中实践这些以及更多现实生活中的问题，请立即加入StrataScratch。您将发现一个由20，000多名志同道合的数据科学爱好者组成的社区，并在解决500多个不同难度的编码和非编码问题的同时进行学习。今天就注册，让你在微软、谷歌、亚马逊等顶级科技公司或优步、Doordash等热门初创公司工作的梦想成为现实。所有的代码示例都可以在<a class="ae kw" href="https://github.com/viveknest/statascratch-solutions/blob/main/NumPy%20for%20Data%20Science%20Part%2001.ipynb" rel="noopener ugc nofollow" target="_blank"> Github这里</a>找到。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="e4f6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">【https://www.stratascratch.com】最初发表于<a class="ae kw" href="https://www.stratascratch.com/blog/numpy-for-data-science-interviews/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"><em class="np"/></a><em class="np">。</em></p></div></div>    
</body>
</html>