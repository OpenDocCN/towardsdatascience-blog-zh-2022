# 为什么 Julia 的生态系统比大多数其他编程语言更加一致

> 原文：<https://towardsdatascience.com/why-julias-ecosystem-is-more-consistent-than-most-other-programming-languages-fa1fd0273bde>

## 朱莉娅的一致性概述，以及为什么这是一件好事

![](img/c266c8a7481f180cb461b0210b57cd1d.png)

(图片由 [Pixabay](http://pixabay.com) 上的 [xresch](https://pixabay.com/images/id-3088958/) 拍摄)

# 介绍

生态系统是任何编程语言的一个非常重要的方面。这可以从语言变得流行的过程中看出来，因为通常程序员不想使用一种还没有他们需要的可用工具的语言。每一种高级编程语言都需要一种生态系统，这种生态系统足以促进特定编程语言的目标和希望。虽然 Julia 是一种相对较新的语言，而且与许多其他语言相比，它的生态系统可以说是很小的，但这个生态系统近年来随着语言本身的发展已经成长了很多。

然而，这些生态系统的另一个经常被低估的特性是一致性。这既体现在实际语法的一致性上，也体现在文档和格式上。方法调用需要以某种方式构造，以某种方式命名，就像构造函数和事物也需要以某种方式构造一样。然而，在 Julia 中，事情更进了一步，方法的实际一致性被带到了整个包的生态系统中。今天我想花一些时间来欣赏 Julia 的这一部分，解释它背后的方法论，以及演示如何制作一个也符合生态系统的包。本文中不会有太多代码，但是如果您想亲自查看或尝试本文中使用的代码，这里有一个链接，指向我在 Github 上用来演示这些内容的笔记本:

[](https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/julias%20consistent%20ecosystem%20via%20method%20extension.ipynb)  

# 朱莉娅生态系统的一致性

与许多其他编程语言相比，Julia 的包似乎更加一致。通常，一个有经验的 Julia 程序员实际上可以猜出他们想要使用的方法调用，而不管它实际上是什么类型的。之所以会这样，与 Julia 的核心范式和方法论有关，

> 多重派遣。

你真的不能谈论太多关于 Julia 语言而不谈论多重分派。因此，我写了很多关于多重分派的文章。如果您想了解更多关于多重分派的知识，以及为什么我认为 Julia 是第一种真正完美地使用泛型编程概念作为范例的语言，我有一篇关于这个概念的文章，您可以在这里阅读:

[](/how-julia-perfected-multiple-dispatch-16675db772c2)  

在整个 Julia 的生态系统中，例如当使用 DataFrames.jl 包时，您会发现在整个生态系统中都可以找到为 Base 中的核心数据结构和类型创建的相同的 Julia 基本函数。这意味着，在许多情况下，我们可以猜测我们希望对我们的值调用什么方法。需要删除数组中超过特定限制的值？使用过滤器！()方法。需要删除数据帧中超过特定限制的值？使用过滤器！()方法。当事物被设计成具有这样的一致性时，并且假定除了这些类型之外的参数通常是相同的，Julia 很快就开始感觉比当今存在的许多其他语言更加流畅。使用软件包不再需要你学习整个 API 和做大量的研究，现在这一切都很容易，可以浓缩成一点点的学习，然后将常规的 Julian 方法应用于一切。

# 这实际上是如何做到的？

既然我们了解了 Julia 的生态系统是如何更加一致的，我们需要真正了解这是为什么。这一切的基础来自于 Julia 的延展性。在 Julia 中，所有的方法定义都是可扩展的，这是因为方法定义在语义上不同于函数定义。函数只是一个定义的名称，例如下面的函数 myfunction():

```
function myfunction(x::Int64)end
```

这个函数是 myfunction，但是方法是 myfunction(x::Int64)。也就是说，我们可以使用 import 关键字直接导入一个函数。一旦我们以这种方式导入了一个函数，我们就可以通过为该定义编写新方法来扩展它的功能。不过，在我们真正开始做之前，我们可能想创建一个类型来分派我们的新方法。我们将扩展过滤器！()函数，完全是因为我之前讲过。在这方面，我们要做的第一件事是直接导入函数。

```
import Base: filter!
```

现在我们将创建我们想要过滤的类型。为了简单起见，我将创建一个包含两个不同数组的类型，这是非常基本和容易理解的。

```
mutable struct TwoArrays
    first::AbstractArray
    second::AbstractArrayend
```

我也不需要创建任何类型的内部构造函数，因为这是一个非常适合我要用过滤器演示的内容的构造函数！()函数。如您所料，这个函数已经有了一个方法定义，可以在数组上调用。记住，实际上我们的目标是过滤这个结构中的两个数组。如果我们尝试调用过滤器！()在这种类型上，我们会得到一个方法错误。我们实际上可以用一行代码实现整个目标:

```
filter!(f::Function, ta::TwoArrays) = begin filter!(f, ta.first); filter!(f, ta.second) end
```

因为我们不期望从变异函数过滤器返回！()，我们不需要预期任何回报，这使得这完全是在公园散步。为了中等可读性，这里也是同一函数的多行版本。

```
function filter!(f::Function, ta::TwoArrays)
    filter!(f, ta.first)
    filter!(f, ta.second)
end
```

现在我们要做的就是尝试我们的功能！

```
tas = TwoArrays([5, 6, 7, 8], [5, 6, 7, 8])
filter!(x -> x > 6, tas)
```

对于那些对使用匿名函数作为参数感到困惑的人，这里有一个到另一篇文章的链接，在这篇文章中，我详细介绍了匿名函数是什么:

[](/what-on-earth-is-an-anonymous-function-f8043eb845f3)  

这段代码运行良好，两个数组中的所有值都大于 6！

```
println(tas.first)
println(tas.second)[7, 8]
[7, 8]
```

# 结论

Julia 是一门非常棒的语言。更好的是，围绕这种语言使用了多种多样的调度方式。已经想到的一些东西，比如构造函数和这种轻松扩展方法的能力，绝对是其他实现无法比拟的。Julia 以一种非常酷的方式处理很多事情，这是我非常喜欢这门语言的一点。很容易理解为什么在编程语言的整个范围内使用相同的基方法是非常有价值的。它使软件包更容易使用，在某些情况下，你可以大胆猜测如何做某事，你实际上是正确的！感谢您阅读这篇文章，我希望这在扩展 Julia 的前沿既有启发性又有信息性！