<html>
<head>
<title>Intermediate SQL for Everyone</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向所有人的中级SQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intermediate-sql-for-everyone-fe35c541147a#2022-01-18">https://towardsdatascience.com/intermediate-sql-for-everyone-fe35c541147a#2022-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="9c0b" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">面向所有人的中级SQL</h1></div><div class=""><h2 id="92c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建数据库，学习有用的语法，构建信息查询</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed59a67f248117e4496107af129f798d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gOr0arWRnOGzVIIj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马修·布罗德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始学习SQL时，我发现很难超越绝对的基础。我喜欢<a class="ae ky" href="https://www.datacamp.com/courses/introduction-to-sql" rel="noopener ugc nofollow" target="_blank">数据营的课程</a>，因为我可以直接在屏幕上的控制台上输入代码。但是一旦课程结束，我怎么能实践我学到的东西呢？当我找到的所有教程都是代码片段，而没有我自己可以查询的底层数据库时，我该如何继续改进呢？</p><p id="cbf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现自己陷入了一个“先有鸡还是先有蛋”的问题——我需要访问数据库来学习足够的SQL以便被录用，但是我所知道的唯一数据库是我试图被录用的那些公司的<em class="lv">！</em></p><p id="36c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">事实证明，创建自己的数据库很简单。在本帖中，我们将创建一个简单的关系数据库，它将让我们探索基础知识之外的SQL主题。如果你理解了下面的问题，那么你就为这篇文章的其余部分做好了准备。(如果没有，请查看工程基础帖子中的<a class="ae ky" rel="noopener" target="_blank" href="/engineering-essentials-for-data-science-4a7a92a1ff3e"> SQL初级读本和</a><a class="ae ky" rel="noopener" target="_blank" href="/a-hands-on-demo-of-sql-vs-nosql-databases-in-python-eeb955bba4aa"> SQL与NoSQL </a>深度探讨。)</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="6b1b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">目录</h1><ul class=""><li id="14ad" class="mq mr it lb b lc ms lf mt li mu lm mv lq mw lu mx my mz na bi translated">安装</li><li id="8376" class="mq mr it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">有用的语法</li><li id="fe6d" class="mq mr it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">高级查询</li><li id="d8b4" class="mq mr it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">往引擎盖下看:<code class="fe ng nh ni nj b">EXPLAIN</code></li></ul><h1 id="0f47" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">安装</h1><p id="559d" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">学习一门新语言时，练习至关重要。阅读这篇文章并点头附和是一回事，能够自己探索想法是另一回事。所以让我们从在你的电脑上建立一个数据库开始，这样你就可以实验和练习了。虽然这听起来有点吓人，但实际上很简单！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/ca8ba0042b0cf1545df0517b9a60b055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tlj78gLF469eli0M3Or8Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="51d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是在您的计算机上安装SQL。我们将使用<a class="ae ky" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL (Postgres) </a>，一种常见的SQL方言。为此，我们访问<a class="ae ky" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">下载页面</a>，选择我们的操作系统(如Windows)，然后运行安装。如果您在数据库上设置了密码，请在下一步使用它！(由于我们的数据库不会公开，所以使用类似<code class="fe ng nh ni nj b">admin</code>的简单密码就可以了。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d946d4e0d62f4f91beba6715bfd40f18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*ekhpScPkmHafcMEeVzai6g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="05ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是安装<a class="ae ky" href="https://www.pgadmin.org/" rel="noopener ugc nofollow" target="_blank"> pgAdmin </a>，这是一个图形用户界面(GUI ),可以轻松地与我们的PostgreSQL数据库进行交互。我们通过进入<a class="ae ky" href="https://www.pgadmin.org/download/" rel="noopener ugc nofollow" target="_blank">安装页面</a>，点击我们操作系统的链接，然后按照步骤操作。</p><p id="1adf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(仅供参考，本教程使用Postgres 14和pgAdmin 4 v6.3。)</p><p id="19bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦两者都安装了，我们打开pgAdmin并点击“添加新服务器”这一步实际上建立了一个到现有服务器的连接，这就是为什么我们需要先安装Postgres。我将我的服务器命名为<code class="fe ng nh ni nj b">home</code>,并传递了我在Postgres安装过程中定义的密码。</p><p id="8855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在准备创建一些表格！让我们制作一组表格来描述学校可能有的数据:学生、教室和成绩。我们将对数据进行建模，假设一个教室由多个学生组成，每个学生都有多个年级。</p><p id="6497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用GUI完成所有这些工作，但是我们将编写代码来使我们的工作流可重复。要编写将创建我们的表的查询，我们将右键单击<code class="fe ng nh ni nj b">postgres</code>(在<code class="fe ng nh ni nj b">home</code> &gt; <code class="fe ng nh ni nj b">Databases (1)</code> &gt; <code class="fe ng nh ni nj b">postgres</code>下)，然后单击查询工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/433ab128edd2c9f0ca54c9f3106ffeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_FZO0gnjvRP0vN3thkxkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="2c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建<code class="fe ng nh ni nj b">classrooms</code>表开始。我们将保持这个表的简单:它将只包含一个<code class="fe ng nh ni nj b">id</code>和<code class="fe ng nh ni nj b">teacher</code>名称。在查询工具中键入以下代码，然后点击run。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6b52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一行中，<code class="fe ng nh ni nj b">DROP TABLE IF EXISTS classrooms</code>，删除已经存在的<code class="fe ng nh ni nj b">classrooms</code>表。(有道理！)如果其他表指向它，Postgres将阻止我们删除<code class="fe ng nh ni nj b">classrooms</code>，所以我们指定<code class="fe ng nh ni nj b">CASCADE</code>来覆盖这个约束。[1]这没关系——如果我们删除了<code class="fe ng nh ni nj b">classrooms</code>，我们可能会从头开始重新生成所有内容，因此所有其他表也会被删除！</p><p id="32ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ng nh ni nj b">CREATE TABLE</code>之前添加<code class="fe ng nh ni nj b">DROP TABLE IF EXISTS</code>让我们<strong class="lb iu">在脚本</strong>中编写我们的数据库模式，如果我们决定以某种方式改变我们的数据库——添加表、改变列的数据类型等等，这是很方便的。我们可以简单地将生成数据库的指令存储在一个脚本中，当我们想要进行更改时更新该脚本，然后重新运行它。[2]</p><p id="2b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在也能够<a class="ae ky" href="https://www.atlassian.com/git/tutorials/what-is-version-control" rel="noopener ugc nofollow" target="_blank">版本控制</a>我们的模式并共享它。事实上，本文中的整个数据库都可以从<a class="ae ky" href="https://github.com/mgsosna/sql_fun/blob/main/school/create_db.sql" rel="noopener ugc nofollow" target="_blank">这个脚本</a>中重新创建，所以请随意尝试！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/0a797531f74285565f5316e0ea59301b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aPOBLKBwUAAS9zAOkLfyVg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="38e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第4行可能也会引起您的注意:这里我们指定<code class="fe ng nh ni nj b">id</code>是主键，这意味着该列中的每一行都必须包含一个值，并且每个值都必须是唯一的。为了避免需要跟踪哪些<code class="fe ng nh ni nj b">id</code>值已经被使用，我们使用了<code class="fe ng nh ni nj b">GENERATED ALWAYS AS IDENTITY</code>，这是对<a class="ae ky" href="https://www.postgresql.org/docs/9.5/sql-createsequence.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">序列</strong> </a>语法的替代。因此，在将数据插入该表时，我们只需要提供<code class="fe ng nh ni nj b">teacher</code>名称。</p><p id="71c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在第5行，我们指定<code class="fe ng nh ni nj b">teacher</code>是一个最大长度为100个字符的字符串。[3]如果我们碰到一个老师的名字比这个长，我们就不得不缩写他们的名字或者修改表格。</p><p id="f137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建<code class="fe ng nh ni nj b">students</code>表。我们的表将由一个唯一的<code class="fe ng nh ni nj b">id</code>、学生的<code class="fe ng nh ni nj b">name</code>和一个指向<code class="fe ng nh ni nj b">classrooms</code>的<a class="ae ky" href="https://www.postgresqltutorial.com/postgresql-foreign-key/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">外键</strong> </a>组成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="06dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在创建表之前再次删除它，然后指定一个自动递增的<code class="fe ng nh ni nj b">id</code>和一个100字符的<code class="fe ng nh ni nj b">name</code>。我们现在包括一个<code class="fe ng nh ni nj b">classroom_id</code>列，并在第7-9行指定该列指向<code class="fe ng nh ni nj b">classrooms</code>表的<code class="fe ng nh ni nj b">id</code>列。</p><p id="f33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过指定<code class="fe ng nh ni nj b">classroom_id</code>是一个外键，我们已经设置了一个关于如何将数据写入<code class="fe ng nh ni nj b">students</code>的规则。Postgres不允许我们在<code class="fe ng nh ni nj b">students</code>中插入一个不存在于<code class="fe ng nh ni nj b">classrooms</code>中的带有<code class="fe ng nh ni nj b">classroom_id</code>的行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="eafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一些教室。因为我们指定了<code class="fe ng nh ni nj b">id</code>列将自动递增，所以我们只需插入教师姓名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4f46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在我们有了一些教室，我们可以向<code class="fe ng nh ni nj b">students</code>添加记录，并引用这些教室。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="46d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们得到一个还没有被分配教室的学生，会发生什么？是不是要等他们收到教室才能记录到数据库里？</p><p id="ffb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是否定的:<strong class="lb iu">虽然我们的外键需求会阻止写入引用</strong> <code class="fe ng nh ni nj b"><strong class="lb iu">classrooms</strong></code> <strong class="lb iu">中不存在的id，但它允许我们传入一个</strong><code class="fe ng nh ni nj b"><strong class="lb iu">NULL</strong></code><strong class="lb iu"/><code class="fe ng nh ni nj b"><strong class="lb iu">classroom_id</strong></code><strong class="lb iu">。我们可以通过为<code class="fe ng nh ni nj b">classroom_id</code>显式声明<code class="fe ng nh ni nj b">NULL</code>或者只传入<code class="fe ng nh ni nj b">name</code>来做到这一点。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们来记录一些成绩。由于分数对应于<em class="lv">作业</em>——比如家庭作业、项目、出勤和考试——我们实际上将使用两个表来更有效地存储我们的数据。<code class="fe ng nh ni nj b">assignments</code>将包含作业本身的数据，而<code class="fe ng nh ni nj b">grades</code>将记录每个学生在作业中的表现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="cd30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，现在让我们通过CSV上传数据，而不是手动插入行。你可以从<a class="ae ky" href="https://github.com/mgsosna/sql_fun/tree/main/school" rel="noopener ugc nofollow" target="_blank">这个repo </a>下载文件或者自己写。请注意，要允许pgAdmin访问数据，您可能需要<a class="ae ky" href="https://stackoverflow.com/questions/14083311/permission-denied-when-trying-to-import-a-csv-file-from-pgadmin" rel="noopener ugc nofollow" target="_blank">更新文件夹</a>(下面的<code class="fe ng nh ni nj b">db_data</code>)的权限。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们看一看，以确保一切就绪。下面的查询查找按教师分组的每个作业类别的平均分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建立数据库做得好！我们现在准备试验一些更复杂的SQL概念。我们将从您可能还没有遇到过的语法开始，这会让您更好地控制您的查询。然后，我们将介绍一些其他的连接，以及在查询增长到几十行或几百行时组织查询的方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/00cf28499875481bc00c46c0aa8cd31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cvVatG536F-OgyGMhK2F_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/1f631a5f35f1f3bb8f596d5712086f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XcxJveR6fgWLQ06y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sotti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shifaaz shamoon </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="380e" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">有用的语法</h1><h2 id="772f" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">过滤器:<code class="fe ng nh ni nj b">WHERE</code>与<code class="fe ng nh ni nj b">HAVING</code></h2><p id="6ccb" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">您可能熟悉<code class="fe ng nh ni nj b">WHERE</code>过滤器，并且您可能听说过<code class="fe ng nh ni nj b">HAVING</code>。但是它们到底有什么不同呢？让我们在<code class="fe ng nh ni nj b">grades</code>上执行一些查询来找出答案。</p><p id="81e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从<code class="fe ng nh ni nj b">grades</code>中抽取一些行来提醒我们自己数据是什么样子的。我们使用<code class="fe ng nh ni nj b">ORDER BY RANDOM()</code>来洗牌，然后用<code class="fe ng nh ni nj b">LIMIT</code>来取5。(仅仅为了获得一个样本而对表中的所有行进行排序是非常低效的，但是如果表很小的话，这也没什么。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="173a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每一行都是学生在作业中的分数。现在，假设我们想知道每个学生的平均分数。我们会执行一个<code class="fe ng nh ni nj b">GROUP BY</code>，使用<code class="fe ng nh ni nj b">AVG(score)</code>和四舍五入来保持整洁。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们想要上表，但是只包含那些<code class="fe ng nh ni nj b">avg_score</code>在50和75之间的行。换句话说，我们只想显示学生2。如果我们使用<code class="fe ng nh ni nj b">WHERE</code>滤镜会发生什么？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那看起来一点也不对。学生5正确地消失了，但是学生1、3和4仍然在那里。更糟糕的是，他们的<code class="fe ng nh ni nj b">avg_score</code>值变了！如果这些数字被写入一份重要的报告，而你不明白发生了什么，这可能会引起一些恐慌。</p><p id="6c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们实际上想要做的是使用一个<code class="fe ng nh ni nj b">HAVING</code>滤镜。看下面的区别。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个查询返回截然不同的结果，因为<code class="fe ng nh ni nj b"><strong class="lb iu">WHERE</strong></code> <strong class="lb iu">和</strong> <code class="fe ng nh ni nj b"><strong class="lb iu">HAVING</strong></code> <strong class="lb iu">在聚合的不同阶段过滤数据。</strong>上面的<code class="fe ng nh ni nj b">WHERE</code>查询在聚合之前过滤数据<em class="lv">，而<code class="fe ng nh ni nj b">HAVING</code>过滤<em class="lv">结果</em>。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/c41d1bb2f996cd046eaf3c5a8bf9ad9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKNI2LLpTIf9kyGhzdDwQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">上述</strong> <code class="fe ng nh ni nj b"><strong class="lb iu">WHERE</strong></code> <strong class="lb iu">查询中的汇总结果发生了变化，因为我们更改了<em class="lv">用于计算每个学生平均分数的原始数据</em>。学生5没有任何介于50和75之间的分数，因此被放弃。与此同时，<code class="fe ng nh ni nj b">HAVING</code>查询只是在计算之后过滤结果。</strong></p><p id="58fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你熟悉了<code class="fe ng nh ni nj b">WHERE</code>和<code class="fe ng nh ni nj b">HAVING</code>，你就可以使用它们来创建非常具体的查询，例如查找平均<em class="lv">家庭作业</em>分数在50到75之间的学生。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="d3df" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">如果——那么:<code class="fe ng nh ni nj b">CASE WHEN</code> &amp; <code class="fe ng nh ni nj b">COALESCE</code></h2><p id="b8b3" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在一个列上需要某种类型的<code class="fe ng nh ni nj b">if</code> - <code class="fe ng nh ni nj b">else</code>逻辑是很常见的。例如，您可能有一个模型预测表，您希望通过某个阈值将值二进制化为正负标签。</p><p id="3108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的数据库中，假设我们想将<code class="fe ng nh ni nj b">grades</code>表中的分数转换成字母等级。我们可以用<code class="fe ng nh ni nj b">CASE WHEN</code>轻松做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们传递给<code class="fe ng nh ni nj b">CASE WHEN</code>的逻辑可以扩展到多个列。例如，我们可以从我们的<code class="fe ng nh ni nj b">students</code>表中生成一个<code class="fe ng nh ni nj b">instructor</code>列，其中包含学生的老师(如果有的话)，否则包含他们自己的名字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="de29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们所做的只是处理空值，那么<code class="fe ng nh ni nj b">COALESCE</code>是一个更干净的选择。<code class="fe ng nh ni nj b">COALESCE</code>返回传递给它的参数中的第一个非空值。重写上面的查询，我们得到这样的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dd33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">漂亮又干净！上面的第4行与第二个<code class="fe ng nh ni nj b">CASE WHEN</code>示例中的第4–7行相同:如果<code class="fe ng nh ni nj b">teacher</code>不为空，则返回该值。否则返回<code class="fe ng nh ni nj b">name</code>。</p><p id="f1b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">COALESCE</code>将下移您提供的参数，直到找到一个非空值。如果所有值都为空，则返回null。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f97dce1b1521c6293701b98cafb30b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcTNQvLua7qwnilpE5jD-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<em class="lv">是Postgres中的一个<code class="fe ng nh ni nj b">IF</code>语句，但是它用于多个</em>查询的控制流，而不是在一个查询中。作为一名数据科学家，你不太可能经常使用<code class="fe ng nh ni nj b">IF</code>——即使作为一名数据工程师，我也认为你会在像<a class="ae ky" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank"> Airflow </a>这样的协调器中处理这样的逻辑，所以我们在这里跳过它。[4]</p><h1 id="a270" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置运算符:<code class="fe ng nh ni nj b">UNION</code>、<code class="fe ng nh ni nj b">INTERSECT</code>和<code class="fe ng nh ni nj b">EXCEPT</code></h1><p id="ba26" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当我们<code class="fe ng nh ni nj b">JOIN</code>表格时，我们横向追加数据<em class="lv"/>。例如，在下面的查询中，我们将来自<code class="fe ng nh ni nj b">students</code>、<code class="fe ng nh ni nj b">grades</code>和<code class="fe ng nh ni nj b">assignments</code>表的亚当的数据放在一起，创建一个这些列并排的表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="24ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水平附加我们的数据在大多数时候对我们很有用。但是如果我们想垂直堆叠查询结果<em class="lv"/>呢？</p><p id="ccf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想象一下，我们的学校腐败得令人难以置信，用学生的名字来决定他们是否毕业，而不是成绩。如果学生的名字1)以<code class="fe ng nh ni nj b">A</code>或<code class="fe ng nh ni nj b">B</code>开头，或者2)有五个字母长，则通过考试。我们可以通过查找符合每个标准的学生来查找所有即将毕业的学生，然后使用<code class="fe ng nh ni nj b">UNION ALL</code>将这些行堆叠起来。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在第4–11行和第18–24行看到了第一个<strong class="lb iu">子查询</strong>，它是更复杂查询的构建块。注意，这些子查询需要被命名为(<code class="fe ng nh ni nj b">x</code>和<code class="fe ng nh ni nj b">y</code>)，以便<code class="fe ng nh ni nj b">UNION ALL</code>能够工作。</p><p id="e798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能还注意到我们使用了<code class="fe ng nh ni nj b">UNION ALL</code>而不是<code class="fe ng nh ni nj b">UNION</code>。区别在于<code class="fe ng nh ni nj b">UNION ALL</code>返回<em class="lv">所有的</em>行，而<code class="fe ng nh ni nj b">UNION</code>删除重复的行(包括在<code class="fe ng nh ni nj b">x</code>和<code class="fe ng nh ni nj b">y</code>内)。这个查询的结果是相同的，因为Betty满足两个条件，但是如果我们不包括<code class="fe ng nh ni nj b">reason</code>列，我们将只看到Betty和<code class="fe ng nh ni nj b">UNION</code>一次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择<code class="fe ng nh ni nj b">UNION</code>或<code class="fe ng nh ni nj b">UNION ALL</code>取决于您想要如何处理副本。当编写复杂的查询时，我更喜欢使用<code class="fe ng nh ni nj b">UNION ALL</code>来确保结果表具有我期望的行数——如果有重复的，我很可能在前面的某个地方搞砸了<code class="fe ng nh ni nj b">JOIN</code>。如果您在源头解决问题，而不是在最后过滤，那么您的查询将会更高效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/8ded362cdccb7f8884a71701c1bb4d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXCPN-6T7FgfMbOOpx45sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bf12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">UNION</code>和<code class="fe ng nh ni nj b">UNION ALL</code>是<a class="ae ky" href="https://en.wikipedia.org/wiki/Set_operations_(SQL)" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">集合操作符</strong> </a>，从子查询A和B返回<em class="lv">所有</em>行(sans与<code class="fe ng nh ni nj b">UNION</code>重复)。另外两个操作符<code class="fe ng nh ni nj b">INTERSECT</code>和<code class="fe ng nh ni nj b">EXCEPT</code>，让我们只返回<em class="lv">符合特定标准</em>的行。<code class="fe ng nh ni nj b">INTERSECT</code>只返回出现在<em class="lv">和</em>子查询中的行，而<code class="fe ng nh ni nj b">EXCEPT</code>返回A中不属于b中<em class="lv">而不是</em>的行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/f3feb1f32394e63c7ec153778d5114e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xayt8Zrjw6r4IvGANbhMaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们演示了<code class="fe ng nh ni nj b">INTERSECT</code>，它查找子查询之间共享的行(即id为2或3的行)。与<code class="fe ng nh ni nj b">UNION</code>不同，我们不需要命名子查询。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们展示了相同的查询，但是使用了<code class="fe ng nh ni nj b">EXCEPT</code>，它在A中查找不在B中的<em class="lv">而不是</em>的行(即ID为1的行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7fe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">集合操作符共同赋予我们组合查询结果(<code class="fe ng nh ni nj b">UNION</code>)、查看重叠记录(<code class="fe ng nh ni nj b">INTERSECT</code>)以及精确查看表之间哪些行不同(<code class="fe ng nh ni nj b">EXCEPT</code>)的能力。不再需要打印表格来堆叠或手动比较它们！</p><h2 id="946c" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">数组函数</h2><p id="8839" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">关系数据库中的数据通常是<a class="ae ky" href="https://en.wikipedia.org/wiki/First_normal_form#Atomicity" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">原子</strong> </a>，其中每个单元格包含一个值(例如<code class="fe ng nh ni nj b">grades</code>表中每行一个分数)。但有时将值存储为数组会很有用。对于这种类型的数据，Postgres提供了广泛的<a class="ae ky" href="https://www.postgresql.org/docs/12/functions-array.html" rel="noopener ugc nofollow" target="_blank">数组函数</a>，让我们可以创建和操作数组。</p><p id="e3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个有用的函数是<code class="fe ng nh ni nj b">ARRAY_AGG</code>，它将行转换成数组。下面，我们将<code class="fe ng nh ni nj b">ARRAY_AGG(score)</code>和<code class="fe ng nh ni nj b">GROUP BY name</code>结合起来，为每个学生创建所有分数的数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ab0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ng nh ni nj b">CARDINALITY</code>来查找数组的长度，使用<code class="fe ng nh ni nj b">ARRAY_REPLACE</code>来替换指定的值。(或者，<code class="fe ng nh ni nj b">ARRAY_REMOVE</code>删除它们。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="10da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会发现最后一个有用的函数是<code class="fe ng nh ni nj b">UNNEST</code>，它将数组解包为行。(本质上与<code class="fe ng nh ni nj b">ARRAY_AGG</code>相反。)</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！已经介绍了<a class="ae ky" href="http://localhost:4000/Intermediate-SQL/#filters-where-vs-having" rel="noopener ugc nofollow" target="_blank">过滤器</a>、<a class="ae ky" href="http://localhost:4000/Intermediate-SQL/#if-then-case-when--coalesce" rel="noopener ugc nofollow" target="_blank"> if-then逻辑</a>、<a class="ae ky" href="http://localhost:4000/Intermediate-SQL/#set-operators-union-intersect-and-except" rel="noopener ugc nofollow" target="_blank">集合操作符</a>和<a class="ae ky" href="http://localhost:4000/Intermediate-SQL/#array-functions" rel="noopener ugc nofollow" target="_blank">数组函数</a>，现在让我们继续构建更高级的查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/e8f1eeaed3b9aba0a2612513f4cc836a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Ni0hEzTMNQqMaFNKd5TNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/fba871bc92aaaf00ff9d239536d3a39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9JLyV_7OGgwaMsYb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@saiph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">赛夫·穆罕默德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fbe6" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">高级查询</h1><h2 id="cb96" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">自连接</h2><p id="a8de" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">有时，我们可能希望将表<em class="lv">与自身</em>连接起来，以获得我们需要的数据。一个常见的例子是<a class="ae ky" href="https://www.postgresqltutorial.com/postgresql-self-join/" rel="noopener ugc nofollow" target="_blank">“经理”问题</a>，我们在这里将它重新表述为“最好的朋友”问题。其思想是，如果表中的行包含指向表中其他行的<em class="lv">的值(比如IDs)，那么我们可以将表<em class="lv">连接到其自身</em>以获得对应于这些值的附加数据。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/97f99cebd029f4ee9fcc5d43c3ecfe58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ZiAnM6WcA8CBRs2y5mz6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="57e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从添加然后填充一个<code class="fe ng nh ni nj b">best_friend_id</code>列到我们的<code class="fe ng nh ni nj b">students</code>表开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将最好的朋友的身份存储为一个数字是有效的，但是可读性不是很好。为了确定每个学生最好的朋友是谁，我们进行了一次自我加入。我们将<code class="fe ng nh ni nj b">students</code> <em class="lv">连接到自身</em>，其中一个表中的<code class="fe ng nh ni nj b">id</code>列是另一个表中的<code class="fe ng nh ni nj b">best_friend_id</code>。在我们的例子中，我们用别名<code class="fe ng nh ni nj b">x</code>和<code class="fe ng nh ni nj b">y</code>来区分这些表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="2468" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">窗口功能</h2><p id="31ab" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">窗口函数类似于聚合函数(任何带有<code class="fe ng nh ni nj b">GROUP BY</code>的函数)，因为它们将计算应用于一组值。然而，与聚合函数不同，<em class="lv">窗口函数不会减少行数。</em></p><p id="aa6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们取每个学生的平均分。在下面的第4–6行，我们添加了<code class="fe ng nh ni nj b">OVER</code>和<code class="fe ng nh ni nj b">PARTITION BY</code>来将聚合转换成窗口函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像<code class="fe ng nh ni nj b">AVG</code>、<code class="fe ng nh ni nj b">MIN</code>或<code class="fe ng nh ni nj b">MAX</code>这样的聚合器，<code class="fe ng nh ni nj b">PARTITION BY</code>分组中的每一行都将具有相同的值。这可能对某些分析有用，但它并不能真正体现窗口函数的优势。</p><p id="0492" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更有用的案例是<strong class="lb iu">排名</strong>每个学生的分数。首先，这是我们如何对所有学生的分数进行排名。我们使用<code class="fe ng nh ni nj b">RANK() OVER</code>，然后传入列进行排名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="81d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对每个学生的分数<em class="lv">进行排名</em>是一行代码的修改:我们简单地将<code class="fe ng nh ni nj b">PARTITION BY s.name</code>添加到<code class="fe ng nh ni nj b">OVER</code>子句中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dd97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.postgresql.org/docs/9.3/functions-window.html" rel="noopener ugc nofollow" target="_blank">其他窗口功能</a>包括计算领先值和滞后值(如时间序列的前一个值)、累积分布以及密集或百分比等级。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/d90134de75db0077a9ce561743233a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8X22VIGnIbFczi7TboU6vQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="43c1" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated"><code class="fe ng nh ni nj b">WITH</code></h2><p id="ce02" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">让我们通过介绍一种技术来结束这一节，这种技术将使我们能够编写尽可能复杂的查询，只需将子查询串在一起。<code class="fe ng nh ni nj b"><strong class="lb iu">WITH</strong></code> <strong class="lb iu">让我们命名一个子查询，</strong>意味着我们可以在其他地方引用该子查询的结果。</p><p id="84bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，我们想标记学生在<code class="fe ng nh ni nj b">grades</code>的分数是否高于他们的平均分。在一个查询中消除这个问题似乎很简单——我们只需要用一个<code class="fe ng nh ni nj b">GROUP BY</code>计算每个平均值，然后做一些类似于<code class="fe ng nh ni nj b">g.score &gt; avg</code>的事情，对吗？先说<code class="fe ng nh ni nj b">GROUP BY</code>聚合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="06ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很简单。但是，我们如何将个人得分与这些平均值进行比较呢？以下两种尝试都会引发错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们<em class="lv">可以</em>通过调用一个窗口函数两次让这个工作起来，但是看起来有点难看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更干净、更具可伸缩性的替代方法是使用<code class="fe ng nh ni nj b">WITH</code>。我们可以将我们的查询分成两个子查询——一个计算平均值，另一个将平均值表加入到<code class="fe ng nh ni nj b">grades</code>中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ng nh ni nj b">WITH</code>查询比只写两次窗口函数要长得多。何必呢？这个更详细的查询提供了两个重要的优势:<strong class="lb iu">可伸缩性</strong>和<strong class="lb iu">可读性。</strong></p><p id="f0f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询可能会变得非常长——在Meta(脸书)，这是我遇到的最长的查询(到目前为止！)超过1000行，调用了25个表。如果没有<code class="fe ng nh ni nj b">WITH</code>子句，这个查询将完全不可读，这些子句划分了代码中不同的、<em class="lv">命名为</em>的部分。</p><p id="7226" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理大数据时，我们没有时间依次运行这些子查询，将结果保存到CSV，然后用Python执行合并和分析。所有的数据库交互都需要一次性运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6319e3245af9c1f846dde48f0f1c5bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgwWYTCuopZbJopmMScuRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cf52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个例子。比方说，我们学校腐败的成绩及格政策被曝光，管理人员被解雇。现在，通过一门课的标准是1)你的加权平均分数至少是85%,或者2)你的传记项目分数超过70%。将这个逻辑捆绑到一个<code class="fe ng nh ni nj b">CASE WHEN</code>中会很痛苦，但是如果我们用<code class="fe ng nh ni nj b">WITH</code>分解查询，这就很简单了。</p><p id="4138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先确定哪些学生会通过考试，因为他们的加权平均分数超过了85%。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">艰苦的学校！(但是加油卡罗琳！)现在，让我们来确定哪些学生通过了考试，因为他们的传记项目获得了70%以上的分数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="230b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望找到符合任一标准的学生，因此我们需要一个类似如下的查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="70fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于<code class="fe ng nh ni nj b">WITH</code>来说很简单。我们简单地将上面的两个查询命名为<code class="fe ng nh ni nj b">weighted_pass</code>和<code class="fe ng nh ni nj b">project_pass</code>，然后像上面一样引用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/89d7a76ab5d6f63df67d13bc350640b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*65i8OhqpfiMZwejr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nixcreative?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰勒·尼克斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="66d8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">往引擎盖下看:<code class="fe ng nh ni nj b">EXPLAIN</code></h1><p id="949a" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在结束这篇文章之前，让我们讨论最后一个概念。我们对SQL了解得越多，就有越多的方法来构建复杂的查询。应该用<code class="fe ng nh ni nj b">EXCEPT</code>还是<code class="fe ng nh ni nj b">NOT IN</code>？我们应该执行几个额外的<code class="fe ng nh ni nj b">JOIN</code>还是使用<code class="fe ng nh ni nj b">WITH</code>和<code class="fe ng nh ni nj b">UNION ALL</code>？</p><p id="8b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">本质上，我们如何知道一个查询比另一个查询更高效还是更低效？</strong></p><p id="17a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Postgres其实可以告诉你这个。关键字<code class="fe ng nh ni nj b">EXPLAIN</code>提供了一个<a class="ae ky" href="https://www.postgresguide.com/performance/explain/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">执行计划</strong> </a>，详细描述了<em class="lv">Postgres如何在幕后执行您的查询</em>。从本文开头重新回顾一下查询，我们看到Postgres执行查询的顺序与我们编写查询的顺序完全不同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/5b12b5cc09c2b2b28780e5e2897e01b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1m8cic0LA6JN0dCt_dwMOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a919" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用<code class="fe ng nh ni nj b">EXPLAIN ANALYZE</code>更进一步，它将运行查询并详述性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="60b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们在上面看到，Postgres顺序扫描(<code class="fe ng nh ni nj b">Seq Scan</code>)我们的<code class="fe ng nh ni nj b">grades</code>和<code class="fe ng nh ni nj b">students</code>表，因为这些表没有索引。换句话说，Postgres不知道<code class="fe ng nh ni nj b">students</code>表中后面的行将比前面的行具有更低还是更高的ID(如果我们要对ID进行索引)。这种次优的性能对于我们的小型数据库来说并不是一个大问题，但是如果我们的数据库增长到数百万行，我们肯定需要识别并修复这样的瓶颈。[5]</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/0c96dab910f13996e58fe16cb721e093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lxvLqG6YyZcx6sTE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·劳埃德·布兰克-费尔南德斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="c624" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="5788" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这篇文章概述了一些SQL技巧，一旦你超越了基础，这些技巧就会变得有用。我们从安装Postgres和pgAdmin开始，通过在我们自己的笔记本电脑上进行SQL实验，为自己的成功做准备。</p><p id="5df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们讨论了构建更复杂查询的有用语法。我们从过滤器开始，概述了<code class="fe ng nh ni nj b">WHERE</code>和<code class="fe ng nh ni nj b">HAVING</code>之间的区别。然后我们讨论了if-then逻辑，展示了如何用<code class="fe ng nh ni nj b">CASE WHEN</code>存储值，用<code class="fe ng nh ni nj b">COALESCE</code>处理空值。我们用集合操作符从水平合并转移到垂直合并，详细说明了<code class="fe ng nh ni nj b">UNION</code>、<code class="fe ng nh ni nj b">UNION ALL</code>、<code class="fe ng nh ni nj b">INTERSECT</code>和<code class="fe ng nh ni nj b">EXCEPT</code>如何在提供的表中保留一些或所有行。然后，我们通过展示如何创建和处理数组来结束这一部分。</p><p id="bf7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们讨论了更高级查询的组件，比如使用自连接来连接自身的表、用于组内比较的窗口函数以及命名子查询的<code class="fe ng nh ni nj b">WITH</code>。最后，我们讨论了<code class="fe ng nh ni nj b">EXPLAIN</code>和<code class="fe ng nh ni nj b">EXPLAIN ANALYZE</code>如何量化我们的查询性能并指出需要改进的地方。</p><p id="bc1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想要不断拓展自己的知识面？总是有更多的函数需要学习，比如<code class="fe ng nh ni nj b">CAST</code>(用于转换数据类型，例如将浮点数转换为整数)，或者<a class="ae ky" href="https://www.postgresql.org/docs/8.0/xfunc.html" rel="noopener ugc nofollow" target="_blank">用户自定义函数</a>，用于进一步简化您的代码。这些都是有用的，但是实际上我建议考虑让<em class="lv">尽可能优化你的查询。即使在计算能力基本不受限制的FAANG公司，如果查询需要的内存超过了服务器的处理能力，查询也会失败。为复杂的查询选择正确的方法会使数据管道更容易维护，这意味着当它中断时，您不太可能在午夜被调用。(希望如此！)</em></p><p id="ec07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好，<br/>哑光</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/3fead4a98197b8280b8e3e0814f8890c.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*2MQ3xRWQN_XPbRbK8N4d7g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="d347" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">脚注</h1><h2 id="5d9a" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">1.安装</h2><p id="9cec" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当我们在删除一个表时指定<code class="fe ng nh ni nj b">CASCADE</code>时，实际上会发生什么？一点演示可能会有帮助。</p><p id="7861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们删除了<code class="fe ng nh ni nj b">classrooms</code>而没有删除任何其他表。<code class="fe ng nh ni nj b">students</code>中的<em class="lv">数据</em>不受影响——我们仍然可以看到原始的教室id。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在重新创建<code class="fe ng nh ni nj b">classrooms</code>并输入<em class="lv">不同的</em>教师，<code class="fe ng nh ni nj b">students</code>和<code class="fe ng nh ni nj b">classrooms</code>之间的关系不再准确。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="9cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这是因为</strong> <code class="fe ng nh ni nj b"><strong class="lb iu">CASCADE</strong></code> <strong class="lb iu">删除了</strong> <code class="fe ng nh ni nj b"><strong class="lb iu">students</strong></code> <strong class="lb iu">中的外键引用。</strong>我们可以通过手动将<code class="fe ng nh ni nj b">students</code>中的<code class="fe ng nh ni nj b">classroom_id</code>(现在不是外键)更新为不在<code class="fe ng nh ni nj b">classrooms</code>中的ID来看到这一点，但是无法通过<code class="fe ng nh ni nj b">grades</code>中的<code class="fe ng nh ni nj b">student_id</code>(其中<em class="lv">是</em>外键)来做到这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e6da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe ng nh ni nj b">CASCADE</code>的最后一点说明。如果我们在<code class="fe ng nh ni nj b">students</code>中创建外键时指定了<code class="fe ng nh ni nj b">ON DELETE CASCADE</code>，那么删除<code class="fe ng nh ni nj b">classrooms</code>中的行将会删除<code class="fe ng nh ni nj b">students</code>中的链接行。出于隐私原因，这可能很重要，例如，如果您希望在客户或员工离开您的公司后删除他们的所有信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="7510" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">2.安装</h2><p id="decb" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">编写我们的数据库<em class="lv">模式</em>是一个工程最佳实践，但是对于实际数据，我们将执行<a class="ae ky" href="https://www.ionos.com/digitalguide/server/security/how-does-data-backup-work-for-databases/" rel="noopener ugc nofollow" target="_blank">数据库备份</a>。有多种方法可以做到这一点，从占用大量内存的完整备份到相对较轻的更改快照。理想情况下，这些文件被发送到地理上远离存储我们数据库的服务器的某个地方，因此自然灾害不会摧毁您的整个公司。</p><h2 id="8f85" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">3.安装</h2><p id="d00f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们将<code class="fe ng nh ni nj b">teacher</code>列指定为最多100个字符的字符串，因为我们不认为我们会遇到比这更长的名称。但是，如果我们将行限制为100个字符而不是200或500个字符，我们真的节省了存储空间吗？</p><p id="f906" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Postgres中，无论我们指定10、100还是500，从技术上来说都无关紧要。因此，指定一个限制可能更像是向未来的工程师(包括您自己)传达您对本专栏中的数据的期望的最佳实践。</p><p id="dd3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在MySQL <a class="ae ky" href="https://stackoverflow.com/questions/1962310/importance-of-varchar-length-in-mysql-table" rel="noopener ugc nofollow" target="_blank">中，大小限制<em class="lv">对</em>有影响</a>:临时表和<code class="fe ng nh ni nj b">MEMORY</code>表将存储长度相等的字符串，填充到表模式中指定的最大值，这意味着如果没有值接近该限制，那么<code class="fe ng nh ni nj b">VARCHAR(1000)</code>将浪费大量空间。</p><h2 id="795a" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">4.如果——那么:<code class="fe ng nh ni nj b">CASE WHEN</code> &amp; <code class="fe ng nh ni nj b">COALESCE</code></h2><p id="3ffb" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你很好奇，下面是带有<code class="fe ng nh ni nj b">IF</code>语句的Postgres代码的样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="dce2" class="nt lz it bd ma nu nv dn me nw nx dp mi li ny nz mk lm oa ob mm lq oc od mo oe bi translated">5.引擎盖下看:<code class="fe ng nh ni nj b">EXPLAIN</code></h2><p id="49bd" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">随着数据库大小的增长，在表上设置索引对于确保性能至关重要。我们可以很容易地为<code class="fe ng nh ni nj b">grades</code>中的分数设置一个索引，例如，使用下面的查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="415e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们再次运行<code class="fe ng nh ni nj b">EXPLAIN ANALYZE</code>，我们将看到Postgres仍然运行顺序扫描。这是因为Postgres的优化已经超出了一篇“中级SQL”博客文章所能教给你的！如果表中的行数相对较少，<a class="ae ky" href="https://stackoverflow.com/questions/5203755/why-does-postgresql-perform-sequential-scan-on-indexed-column/5203827" rel="noopener ugc nofollow" target="_blank">执行顺序扫描</a>实际上比使用索引更快，因此Postgres使用更快的方法执行查询。</p></div></div>    
</body>
</html>