<html>
<head>
<title>An Easy Guide to Advanced SQL Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级SQL窗口函数简易指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-advanced-sql-window-functions-f63f2642cbf9#2022-01-05">https://towardsdatascience.com/a-guide-to-advanced-sql-window-functions-f63f2642cbf9#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="e991" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/tips-and-tricks" rel="noopener" target="_blank">小窍门</a></h2><div class=""><h1 id="80ce" class="pw-post-title jb jc it bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">高级SQL窗口函数简易指南</h1></div><div class=""><h2 id="494c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据科学家和分析师的必备知识</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f8de55ac1ff0a32bbf7865b3b6cda08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*897TSHTrMldcViTd"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">本·米歇尔在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="c584" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">本文是关于SQL中数据分析的高级窗口函数的指南。这绝对是数据科学家和分析师必须知道的。我将首先介绍什么是窗口函数，为什么你应该使用它们，以及3种类型的窗口函数。接下来，我将通过现实生活中的例子来展示如何使用这些函数。</p><h1 id="dcdc" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">什么是窗口函数？</h1><p id="27d1" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">窗口函数于2003年首次引入标准SQL。根据<a class="ae lh" href="https://www.postgresql.org/docs/9.1/tutorial-window.html" rel="noopener ugc nofollow" target="_blank">PostgreSQL文件</a>:</p><blockquote class="ni nj nk"><p id="a3e7" class="lp lq nl lr b ls lt kd lu lv lw kg lx nm lz ma mb nn md me mf no mh mi mj mk im bi translated">“一个<em class="it">窗口函数</em>对一组与当前行有某种关联的表行执行计算…在后台，窗口函数能够访问的不仅仅是查询结果的当前行。”</p></blockquote><p id="a03f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">窗口函数类似于GROUP BY子句中完成的聚合。但是，行不会组合成一行，每一行都保留它们各自的标识。也就是说，窗口函数可以为每行返回一个值。这是我的意思的一个很好的形象化的例子。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/f04fdc6ba47b739a42eb167a31c097fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWw3tHCsXRHyOKOkm81eUg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="8fef" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">请注意图片左侧的GROUP BY聚合是如何将三行组合成一行的。图片右侧的窗口函数能够输出每一行的聚合值。这可以使您不必在分组后进行连接。</p><h2 id="3ad7" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">示例:分组依据与窗口函数</h2><p id="f7c5" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">这里有一个简单的例子，让你体会一下窗口函数的作用。</p><p id="2847" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">假设我们有一些工资数据，我们想创建一个列，给出每个职位的平均工资。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/84ec4acd769498efce056635a9668066.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*WAzUYHQeF7l4cRYT6mdBAQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">示例工资数据-按作者分类的图像</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/f8c41fe6153d1b595378a8a688496f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNjN_3P3JOz1h_o2tBQnaA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">分组依据与窗口功能—按作者排序的图像</p></figure><p id="fadd" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">左边是<code class="fe od oe of og b">GROUP BY</code>聚合将返回的内容，右边是窗口函数将返回的内容。如您所见，group by将我们的数据合并为三行。通过一个窗口函数，我们保留了原来的11行，并增加了一个名为AVG薪水的新列。如果需要，我们可以选择将每个人的工资与平均工资进行比较。</p><h1 id="9c4e" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">为什么要使用窗口函数？</h1><p id="8922" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">窗口函数的一个主要优点是，它允许您同时处理聚合值和非聚合值，因为行不会折叠在一起。</p><p id="17c5" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">窗口函数也很容易使用和阅读。也就是说，它们可以降低查询的复杂性，这使得以后的维护更加容易。</p><p id="c044" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">此外，它们还可以帮助解决性能问题。例如，您可以使用窗口函数，而不必进行自连接或交叉连接。</p><p id="2dfb" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我保证，窗口函数真的很神奇，知道它真的很棒。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/2d902efdb92d402977e48dfdfd167d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jeq2T-cphOxQBY-y"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="7b7c" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">重要提示:</h1><p id="4d44" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">在我们开始之前，需要注意的是，根据SQL中的操作顺序，窗口函数在列表中排在第六位。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/b58cbe32b686868aa151c8f5a5c13f6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCyFDF35OZ3n0dyZqX6_Tw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="ea93" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这很重要，因为基于这种逻辑顺序，窗口函数在<code class="fe od oe of og b">SELECT</code>和<code class="fe od oe of og b">ORDER BY,</code>中是允许的，但在<code class="fe od oe of og b">FROM</code>、<code class="fe od oe of og b">WHERE</code>、<code class="fe od oe of og b">GROUP BY</code>或<code class="fe od oe of og b">HAVING</code>子句中是不允许的。</p><blockquote class="ni nj nk"><p id="a283" class="lp lq nl lr b ls lt kd lu lv lw kg lx nm lz ma mb nn md me mf no mh mi mj mk im bi translated"><em class="it">注意:如果您确实需要将它放在</em> <code class="fe od oe of og b"><em class="it">WHERE</em></code> <em class="it">子句或</em> <code class="fe od oe of og b"><em class="it">GROUP BY</em></code> <em class="it">子句中，您可以通过使用子查询或</em> <code class="fe od oe of og b"><em class="it">WITH</em></code> <em class="it">查询来避开这个限制。</em></p></blockquote><h1 id="4ea8" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">窗口函数语法</h1><p id="0295" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">下面是<code class="fe od oe of og b">SELECT</code>子句中窗口函数的一般语法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8946a479a02ae53dbad2459091bcae47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*NKUDO4a5fu5kVW-OlkHUJw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="8c3c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这里有很多单词，所以让我们来看看一些定义:</p><ul class=""><li id="100a" class="ok ol it lr b ls lt lv lw ly om mc on mg oo mk op oq or os bi translated"><strong class="lr jd"> window_function </strong>是我们要使用的窗口函数的名称；例如，sum、avg或row_number(我们将在后面了解更多)</li><li id="e3a0" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">表达式是我们希望窗口函数操作的列的名称。根据所使用的window_function，这可能不是必需的</li><li id="1334" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated"><strong class="lr jd">在</strong>上只是表示这是一个窗口功能</li><li id="0f89" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated"><strong class="lr jd"> PARTITION BY </strong>将行划分为多个分区，这样我们可以指定使用哪些行来计算窗口函数</li><li id="7609" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated"><strong class="lr jd"> partition_list </strong>是我们想要进行分区的列的名称</li><li id="e7b2" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated"><strong class="lr jd"> ORDER BY </strong>用于对每个分区中的行进行排序。这是可选的，不必指定</li><li id="0375" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated"><strong class="lr jd"> order_list </strong>是我们要排序的列的名称</li><li id="8f8d" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">如果我们想进一步限制分区中的行，可以使用行<strong class="lr jd">。这是可选的，通常不使用</strong></li><li id="25bf" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated"><strong class="lr jd"> frame_clause </strong>定义从当前行偏移多少</li></ul><p id="f850" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">不要担心记住定义和语法，甚至不要担心完全理解它的确切含义。一旦你看了文章中的例子，并对如何编写窗口函数有了直观的理解，一切都会变得更有意义。</p><h2 id="7d5b" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">快速示例</h2><p id="c8b4" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">为了帮助你更好地理解语法的真正工作原理，下面是一个窗口函数在实践中的例子。</p><p id="a3d5" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这是一个查询，它将生成我们前面看到的关于职位工资的输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oy"><img src="../Images/c20919d1efe2f2e9810509f811df4314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVX7Ws5Dk_f9-a6o9Wy_kQ.png"/></div></div></figure><p id="9d5a" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这里，<strong class="lr jd"> AVG() </strong>是窗口函数的名称，<strong class="lr jd">薪资</strong>是表达式，<strong class="lr jd"> JOB_TITLE </strong>是我们的分区表。我们没有使用ORDER BY，因为不需要它，我们也不想使用行，因为我们不想进一步限制我们的分区。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/705a418e5104ca5f12ee6a6b3e6f75b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*rUXfOhUaJCSMQkGh5FnEmA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0855" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">同样，现在不需要记忆语法。在这个阶段，我希望您理解的一个概念是，窗口函数为“窗口”或“分区”中的每一行计算一个值。窗口可以是多行中的一行，由子句<code class="fe od oe of og b">PARTITION BY</code>指定。在我们的例子中，我们按照职位进行了划分。正如你在上面的片段中看到的，我用不同的颜色突出显示了每个职位。每种颜色代表不同的“窗口”或不同的“分区”。窗口函数为每个分区计算一个平均薪金值。</p><h1 id="d7ef" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated"><strong class="ak">窗口功能列表</strong></h1><p id="5dd6" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">现在你知道了语法，让我们看看不同种类的窗口函数，它们可以代替下面的红色字体。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pa"><img src="../Images/ff73277ced5c89fe46047df592d5db28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NV9bCjSJTKXQ8_-X-aHjVg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="a88a" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">有三种主要类型的窗口函数可供使用:聚合函数、排名函数和值函数。在下图中，您可以看到属于每个组的一些函数的名称。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pb"><img src="../Images/aa542a538802da4664cf1fe29b6c0828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8SPxze2b1OdCdPo1maVGw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="d19f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">下面是对每种窗口函数用途的一个快速概述。</p><p id="7205" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">聚合函数:</strong>我们可以使用这些函数来计算各种聚合，例如平均值、总行数、最大值或最小值，或者每个窗口或分区内的总和。</p><p id="7d38" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">排名函数:</strong>这些函数对于在其分区内对行进行排名非常有用。</p><p id="e776" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">值函数:</strong>这些函数允许您比较分区内前一行或后一行的值，或者分区内的第一个或最后一个值。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="86d5" class="ml mm it bd mn mo pc mq mr ms pd mu mv ki pe kj mx kl pf km mz ko pg kp nb nc bi translated"><strong class="ak">窗口功能练习</strong></h1><p id="ba25" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">现在让我们开始做一些有趣的练习来帮助你真正掌握窗口函数是如何工作的。我们将对聚合函数、排名函数和价值函数进行各种练习。</p><h2 id="4dfd" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">数据</h2><p id="31d1" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">对于下面的示例问题，我使用的数据来自位于<a class="ae lh" href="https://github.com/jpwhite3/northwind-SQLite3" rel="noopener ugc nofollow" target="_blank">这个网站</a>上的Northwind数据库。参见Northwind_small.sqlite，该文件也可以在我的github repo中找到。</p><blockquote class="ni nj nk"><p id="f895" class="lp lq nl lr b ls lt kd lu lv lw kg lx nm lz ma mb nn md me mf no mh mi mj mk im bi translated"><em class="it">根据下载源，“Northwind示例数据库随Microsoft Access一起提供，作为管理小型企业客户、订单、库存、采购、供应商、运输和员工的教学模式。Northwind是一个优秀的小型企业ERP教程模式，包括客户、订单、库存、采购、供应商、运输、员工和单一条目会计。</em></p></blockquote><p id="c369" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">数据库的完整模式显示在上面链接的网站上。对于本文中的示例，我将只使用[Order]和[OrderDetail]表。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/0fe2842e040aadc203556a1a04aa7d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*vz3DggeLfupObUnYlCa11A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:<a class="ae lh" href="https://github.com/jpwhite3/northwind-SQLite3" rel="noopener ugc nofollow" target="_blank">https://github.com/jpwhite3/northwind-SQLite3</a></p></figure><h1 id="eced" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">聚合函数</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/843fc47d2733a199a0516fa7d468e0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zR68gv0uhJkq9B9PoUNDSA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h2 id="5480" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习1:创建一个新列来计算每个CustomerId的平均单价</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/5507057ddc408e662309f30421480b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*Mk6G_IyrlcgIS2cPBPhsTA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="718c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">从左边列出的聚合窗口函数列表中，我们可以看到AVG()将是我们想要使用的窗口函数。我们的表达式将是单价列，因为我们要计算单价的平均值。</p><p id="17d3" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">接下来，我们需要弄清楚我们想要如何分区。也就是说，为了创建我们的分区，应该如何将这些行组合在一起？练习语句告诉我们找到每个CustomerId的平均价格。这告诉我们，我们希望对具有相同CustomerId的行进行分组，因此这将是我们的分区列表的一部分。在本练习中，我们不使用ORDER BY。下面是我们的查询看起来像什么。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="6741" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       UnitPrice, <br/>       <strong class="og jd">AVG(UnitPrice) OVER (PARTITION BY CustomerId) AS “AvgUnitPrice”</strong><br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/739eef5bcc740cf1cf26116857ec4915.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*c9eFD04nSDvxmzg2zza8oA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="f91c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">正如您在上面的图像中看到的，计算了CustomerId的每个分区的平均单价。</p><p id="19eb" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">以下是一些你可以自己尝试的练习:</p><ol class=""><li id="0b9e" class="ok ol it lr b ls lt lv lw ly om mc on mg oo mk pt oq or os bi translated">创建计算每个CustomerId的最大折扣的新列</li><li id="a82b" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk pt oq or os bi translated">创建一个新列来计算每个产品Id的最小单价</li></ol><h2 id="bb31" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习2:创建一个新列来计算每组CustomerId和EmployeeId的平均单价。</h2><p id="3094" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">您可以选择按多列进行分区。之前，我们计算了每个CustomerId组的平均单价。这一次，我们将添加EmployeeId。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="4322" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       EmployeeId, <br/>       AVG(UnitPrice) OVER (<strong class="og jd">PARTITION BY CustomerId, EmployeeId</strong>) AS       “AvgUnitPrice”<br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId </span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/85fedf873ee8b256d48fddcf4d7215cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*NEoVEmqBzFSlX3NHNK9dUg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="f61b" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">请注意分区与之前相比有什么变化。这些计算是针对CustomerId和EmployeeId的每个唯一组进行的，在表中以不同的颜色直观地显示出来。</p><h1 id="54f7" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">排名功能</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/843fc47d2733a199a0516fa7d468e0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zR68gv0uhJkq9B9PoUNDSA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><h2 id="72e7" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习3:创建一个新列，按降序排列每个CustomerId的单价。</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/36d1f144e8be160285ad8a686d524408.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*GJU1s-fu2g8Y3DyTu6gF7g.png"/></div></figure><p id="6ecc" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们可以用三种不同的方法来完成这个练习。</p><p id="cb93" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们将使用左边列表中的前三个排名函数:ROW_NUMBER、RANK和DENSE_RANK。</p><p id="8d79" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">每一个都有稍微不同的数据排序方式。</p><h2 id="3fe0" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">行数</h2><p id="4028" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">我们可以使用这个函数来显示给定行在其分区中的行号。请注意，对于排名函数，我们不需要像之前对聚合函数那样在括号内指定表达式。</p><p id="c171" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">另外，既然是做排名，这里顺序很重要。我们必须确保单价列排序正确，以便正确应用排名。为此，我们可以在<code class="fe od oe of og b"><strong class="lr jd">PARTITION BY.</strong></code>之后添加<code class="fe od oe of og b"><strong class="lr jd">ORDER BY UnitPrice DESC</strong></code>作为窗口函数的一部分</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="a766" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       OrderDate, <br/>       UnitPrice, <br/>       <strong class="og jd">ROW_NUMBER() </strong>OVER (PARTITION BY CustomerId <strong class="og jd">ORDER BY UnitPrice DESC</strong>) AS “UnitRank”<br/>FROM [Order] <br/>INNER JOIN OrderDetail <br/>ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/2f1380298ac65497b5eec1ffb0356f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*joUTr_rzCxsdei-4NM3O9A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来源:作者</p></figure><p id="c675" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">正如您在上面的输出中看到的，我们的UnitPrice列是降序排列的，在最后一列中显示了每个客户id的单位排名。客户ALFK有12行，因此等级从1到12。</p><p id="1f4d" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">您可能想知道，如果我在SQL语句的末尾而不是在windows函数中使用ORDER BY，会发生什么情况，我会得到相同的结果吗？</p><p id="0492" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">花一分钟考虑一下，然后回来。我的顺序是在窗口函数内部还是外部有关系吗？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/59ec8b128c025310a075f54440521189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1uIAA69Tv28qCxIW"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">马库斯·温克勒在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a9f5" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们来试试吧！将ORDER BY从windows函数中移除，并将其添加到末尾。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="f5cc" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       OrderDate, <br/>       UnitPrice,    <br/>       ROW_NUMBER() OVER (PARTITION BY CustomerId) AS “UnitRank”<br/>FROM [Order]<br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId<br/><strong class="og jd">ORDER BY CustomerId, UnitPrice DESC </strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi py"><img src="../Images/88bf1170211879dc99cfdfc1c8cbed62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*ZjC9zOWHR-p5GrVHAcI_tQ.png"/></div></figure><p id="9602" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">嗯，看起来我们没有得到和之前一样的结果。单价按降序排列正确，但单位的排名看起来不对。为什么不呢？</p><p id="72ba" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">回想一下SQL的操作顺序。窗口函数第六次处理，而ORDER BY第十次处理。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/589dd86d6f270c3a9edb8c3a18acc291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4geqKDCNEEdhvaxrJqdnjw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="1d3d" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">所以行号是在单价被订购之前创建的。这就是为什么我们得不到相同的结果！有道理。</p><h2 id="5776" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">排名()</h2><p id="d6d5" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">现在，让我们用RANK()代替ROW_NUMBER()。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="cfe8" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       OrderDate, <br/>       UnitPrice, <br/>       <strong class="og jd">RANK() </strong>OVER (PARTITION BY CustomerId ORDER BY UnitPrice DESC) AS “UnitRank”<br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/dfdb9c7e2e099eecf46e53c2e4008ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*hjPb9avD8vWlbbwy35Eeqw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="9045" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">现在有什么不同？对于行号，没有重复的数字。但是使用rank()，如果有多个值具有完全相同的值，RANK函数会给它们相同的排名。</p><p id="8f72" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">请注意，在第2行和第3行中，单价是45.60，因此这两行的等级都是2。第7行和第8行也具有相同的单价，并被赋予相同的等级7。</p><p id="4bee" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">还要注意排名跳过了一个数字。例如，在行3中，等级跳到4，因为有两行等级为2。如果有三行的秩为2，那么它将跳到秩5，依此类推。'</p><p id="84af" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如果你不想让它跳过数字呢？嗯，我们可以用<strong class="lr jd"> DENSE_RANK() </strong>来代替。</p><h2 id="d493" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">密集等级()</h2><p id="7140" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">同样，替换我们的窗口函数为<strong class="lr jd"> DENSE_RANK() </strong>，其他保持不变。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="9064" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       OrderDate, <br/>       UnitPrice, <br/>       <strong class="og jd">DENSE_RANK() </strong>OVER (PARTITION BY CustomerId ORDER BY UnitPrice DESC) AS “UnitRank”<br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/cc83a6106c4708858eea8f31abf72df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*569nAYxQUvjSgeAG1SRS-A.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="a3bc" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">它遵循与RANK()相同的行为，因为如果值相同，那么这些行将被赋予相同的等级。参见第2行和第3行。请注意，在第4行中，等级现在没有跳过一个数字。它是排名3而不是4。</p><p id="9336" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">你现在的作业是学习PERCENT_RANK()和NTILE()是如何工作的，并亲自尝试这些函数。</p><h1 id="5b0f" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">价值函数</h1><p id="ce60" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">对我来说，值函数可能是窗口函数如此神奇的首要原因。这些函数对于从其他行中提取可能对报表有用的值非常有用。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/cf8987869cf7d0601dd4bd018efb0190.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*Fc1LZxxzIqoGpzQ2N3zdNA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="0b02" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们可以使用LAG或LEAD函数来帮助我们创建一个能够从其他行提取值的列。LAG可以从前面的行返回值，而LEAD可以从后面的行返回值。在处理时序数据和计算时间差异时，比较前一行或后一行非常有用。</p><h2 id="dac0" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习4:创建一个新列，为每个产品Id提供前一个订单日期的数量。</h2><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="ba5b" class="nq mm it og b gy po pp l pq pr">SELECT ProductId, <br/>       OrderDate, <br/>       Quantity, <br/>       <strong class="og jd">LAG(Quantity) OVER (PARTITION BY ProductId ORDER BY OrderDate) AS "LAG"</strong><br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId </span></pre><p id="a3f3" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们在Quantity列上使用LAG来返回前一行的值。就像以前一样，我们需要确保我们的数据在我们的窗口函数中是有序的。我们将按订单日期排序。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/c95f88bc166262ddf4430969a0c13eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*U5Pb6kyZYtMvbhHw13o3YA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="e062" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">正如您在上面的图像中看到的，我们得到了一个包含前一个订单日期数量的列。这非常有用，因为我们可以将当前订单日期与之前的订单日期进行比较，并计算两个时间段的差异。在第一行中，没有以前的订单日期，所以它是NaN或null。</p><h2 id="6bf0" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习5:创建一个新列，为每个产品Id提供以下订单日期的数量。</h2><p id="18a1" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">这看起来和我们之前的例子非常相似。但是，这一次，由于我们想要下面的行，我们将使用LEAD()。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="ff09" class="nq mm it og b gy po pp l pq pr">SELECT ProductId, <br/>       OrderDate, <br/>       Quantity, <br/>       <strong class="og jd">LEAD</strong>(Quantity) OVER (PARTITION BY ProductId ORDER BY OrderDate) AS "LEAD"<br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/6e68e15a5948a45f7c45b7ab4f396c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*iuOau5lUBTHwmPAbfngLlQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="17d4" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如您所见，新的列前导包含下一行的值。</p><h2 id="79c1" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习6:创建一个新列，提供每个ProductId的首次订购数量。</h2><p id="913a" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">为了获得第一个数量，我们可以使用<strong class="lr jd"> FIRST_VALUE </strong>函数，它将给出一个分区中的第一个值。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="c9b1" class="nq mm it og b gy po pp l pq pr">SELECT ProductId, <br/>       OrderDate, <br/>       Quantity, <br/>       <strong class="og jd">FIRST_VALUE</strong>(Quantity) OVER (PARTITION BY ProductId ORDER BY OrderDate) AS "FirstValue"<br/>FROM [Order] <br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/bd9b6abdaf862019cddcf33c9204c0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*crsYDwLQoWTRX1Ilrkwusw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="444f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如图所示，产品ID 1的第一个订单是在2012年8月20日，数量为45，因此我们得到与产品1相关的所有行的值为45。</p><p id="2810" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这里有一个练习让你自己试试。</p><ol class=""><li id="4d6e" class="ok ol it lr b ls lt lv lw ly om mc on mg oo mk pt oq or os bi translated">创建一个新列，为每个ProductId提供第二个订购数量。(提示:使用第n个值函数)</li></ol><h2 id="0d22" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">使用frame _子句</h2><p id="7063" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">让我们从练习中稍作休息，学习一个还没有讨论过的新概念。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qd"><img src="../Images/8a3212ad85efee6ac5ce0deae63bdf34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q3m6aliQHLibhxuD"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@bubo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">路博尖塔</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="83c0" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">您可能还记得开头的定义，我们可以用frame_clause指定行来进一步限制我们的窗口大小。我把这个留到最后，因为人们可能会对此有点困惑。我将快速浏览一下语法及其用法，然后让我们看一个例子来真正理解发生了什么。</p><p id="ae59" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">下面是通用语法的样子</p><p id="2bc6" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">行之间</strong> &lt;起始_行&gt; <strong class="lr jd">和</strong> &lt;结束_行&gt;</p><p id="d5b7" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在<starting_row>和<ending row="">中，我们有以下选项可供选择:</ending></starting_row></p><ul class=""><li id="933d" class="ok ol it lr b ls lt lv lw ly om mc on mg oo mk op oq or os bi translated">UNBOUNDED PRECEDING分区中当前行之前的所有行，即分区的第一行</li><li id="d878" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">[some #] PRECEDING —当前行之前的行数</li><li id="049c" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">当前行—当前行</li><li id="aa9f" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">[some #] FOLLOWING —当前行之后的行数</li><li id="d68b" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">UNBOUNDED FOLLOWING分区中当前行之后的所有行，即分区的最后一行</li></ul><p id="0c20" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这里有一些如何写的例子:</p><ul class=""><li id="4a7a" class="ok ol it lr b ls lt lv lw ly om mc on mg oo mk op oq or os bi translated">EN 3前一行和当前行之间的行-这意味着回顾前3行直到当前行。</li><li id="aeac" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">无界的前一行和后一行之间的行—这意味着从分区的第一行开始查找，直到当前行之后的第一行</li><li id="ed0a" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">EN 5之前的行和1之前的行之间-这意味着回顾前5行，直到当前行之前的1行</li><li id="c1f9" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk op oq or os bi translated">无界在前和无界在后之间的行—这意味着从分区的第一行到分区的最后一行</li></ul><p id="096f" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">值得注意的是，每当添加ORDER BY子句时，SQL都会将默认窗口设置为未绑定的前一行和当前行之间的行。</p><h2 id="70c2" class="nq mm it bd mn nr ns dn mr nt nu dp mv ly nv nw mx mc nx ny mz mg nz oa nb iz bi translated">练习7:计算每个CustomerId的累积移动平均单价。</h2><p id="e9b6" class="pw-post-body-paragraph lp lq it lr b ls nd kd lu lv ne kg lx ly nf ma mb mc ng me mf mg nh mi mj mk im bi translated">为了计算累积移动平均值，我们将利用frame_clause。</p><pre class="ks kt ku kv gt pk og pl pm aw pn bi"><span id="7ece" class="nq mm it og b gy po pp l pq pr">SELECT CustomerId, <br/>       UnitPrice, <br/>       AVG(UnitPrice) OVER (PARTITION BY CustomerId <br/>       ORDER BY CustomerId <br/>       <strong class="og jd">ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</strong>) AS “CumAvg”<br/>FROM [Order]<br/>INNER JOIN OrderDetail ON [Order].Id = OrderDetail.OrderId</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/209a315f8ac3a7c72621d17243465b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*FK8pEUSQhqKZv4FGNekZFA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="648c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在上面的输出中，您可以看到每行都重新计算了平均值。在第1行中，只有1个数字，因此平均值为45.60。在第2行，累计平均值是45.60和18的平均值。在第3行中，累计值是45.60、18和12的平均值。诸如此类…</p><p id="ad7c" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">以下是一些你可以自己尝试的练习:</p><ol class=""><li id="a587" class="ok ol it lr b ls lt lv lw ly om mc on mg oo mk pt oq or os bi translated">计算每个CustomerId的前5行到前3行的平均数量。</li><li id="44dc" class="ok ol it lr b ls ot lv ou ly ov mc ow mg ox mk pt oq or os bi translated">计算每个CustomerId的前2行到当前行的最小单价</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/535e79aa5963b745d619c15db7ad5ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o_ryS1rinojY4jmO"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@jingdachen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">陈京达</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e738" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如果你准备好参加<strong class="lr jd">挑战</strong>，试试这个奖励游戏。</p><p id="7f83" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated"><strong class="lr jd">挑战练习:</strong>创建一个新列，提供每个产品Id的最后订购数量。(提示:使用LAST_VALUE()窗口函数并考虑分区)</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="dccc" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">完成这篇文章非常棒！窗口功能非常强大，非常有趣，所以我希望你喜欢这些练习。感谢您的阅读！如果您有反馈或问题，请在下面留言。</p><p id="32e7" class="pw-post-body-paragraph lp lq it lr b ls lt kd lu lv lw kg lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">如果你正在寻找一份备忘单，点击这里的链接<a class="ae lh" href="https://learnsql.com/blog/sql-window-functions-cheat-sheet/" rel="noopener ugc nofollow" target="_blank"/>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/3ebb3ca1718c4148b7f72cebc12a7f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SiBdONi6lTIPWsFj"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">安德鲁·舒尔茨在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div></div>    
</body>
</html>