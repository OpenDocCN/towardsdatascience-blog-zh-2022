<html>
<head>
<title>How To Use A Variable Number of Arguments in Python Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python函数中使用可变数量的参数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-variable-number-of-arguments-in-python-functions-d3a49a9b7db6#2022-01-17">https://towardsdatascience.com/how-to-use-variable-number-of-arguments-in-python-functions-d3a49a9b7db6#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="5c2e" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">如何在Python函数中使用可变数量的参数</h1></div><div class=""><h2 id="d84f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个关于*args和**kwargs的小故事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54c7c189bd78497608a1c2bde8e5b30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRGFpvGFdhicOLEbtkTs4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者制作的图像</p></figure><p id="2db9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将学习*args和**kwargs，这两个特殊的Python符号，您可能以前在一些函数签名中遇到过。</p><blockquote class="lu lv lw"><p id="e1ea" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">他们做什么？它们解决什么问题？您如何使用它们来提高代码的灵活性？</em> </strong></p></blockquote><p id="347e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将回答这些问题。📚</p><h1 id="bc57" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">Python函数中可变数量的参数</h1><p id="f736" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这个标题有点像剧透:<strong class="la iu"> *args </strong>和<strong class="la iu"> **kwargs </strong>允许您向函数传递可变数量的参数。但我们会谈到这一点。</p><p id="ded7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们看看一些具有这种灵活性的流行函数，并考虑一下您如何也能从中受益。</p><p id="80ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您熟悉Python编程语言，您可能知道以下两个函数:</p><p id="adc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> 1 — </strong>出了名的内置<code class="fe my mz na nb b"><strong class="la iu">print</strong></code>功能:</p><p id="2971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顾名思义，这个函数将数据打印到标准输出中。但是你知道它也可以接受任意数量的参数(来打印)吗？</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="74fc" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">print("hello")<br/># hello</strong></span><span id="7ae0" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">print("hello", "there")<br/># hello there</strong></span><span id="c8a2" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">print("I", "have", 5, "dollars")<br/># I have 5 dollars</strong></span><span id="8909" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">print("a", 2, [1, 2, 3])<br/># a 2 [1, 2, 3]</strong></span><span id="d5fc" class="ng mc it nb b gy nl ni l nj nk">...</span></pre><p id="6370" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">2—</strong><code class="fe my mz na nb b"><strong class="la iu">os</strong></code>模块的<code class="fe my mz na nb b"><strong class="la iu">join</strong></code>功能:</p><p id="0925" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数连接文件系统上任意数量的路径。同样，它接受可变数量的路径作为参数。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="6eef" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">import os</strong></span><span id="e75f" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">path1 = os.path.join("/")<br/>path2 = os.path.join("/", "Users")<br/>path3 = os.path.join("/", "Users", "Library")</strong></span><span id="9037" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu"># ...</strong></span></pre></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="448a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用接受可变数量参数的函数可能非常有用:这提供了很大的灵活性，并减少了函数签名中的混乱。此外，它没有对所需参数的数量做任何假设，这在多种情况下可能是合适的。</p><p id="fceb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在很多情况下，你需要使用一个参数个数可变的函数。</p><p id="7e78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们举一个例子:假设您想要构建一个计算数值聚合(平均值、总和、乘法等)的函数。)超过一些数字。<br/>为简单起见，考虑<strong class="la iu">乘法</strong>(这同样适用于其他聚合)。</p><p id="b86e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想定义一个将两个数相乘的函数，你可以简单地这样做:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="51bb" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def multiply_numbers(n1, n2):<br/>    product = n1 + n2<br/>    return product</strong></span></pre><p id="35b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很好，但是把三个数相乘怎么样？还是四个？还是万一呢？</p><p id="3e47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以想到的一个自然的解决方案是将所有数字放在一个列表中，并将其传递给函数:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="d796" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def multiply_numbers(list_of_numbers):<br/>    product = 1<br/>    for number in list_of_numbers:<br/>        product *= number<br/>    return product</strong></span></pre><p id="947f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这种解决方案可行，但是如果您不预先知道列表中的所有元素，它可能会有点不方便，也不太灵活。此外，它强迫你创建一个看起来不必要的列表对象。</p><h1 id="dc1c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">用*args传递非关键字参数</h1><p id="9aed" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><strong class="la iu"> *args: </strong>你可能以前在函数中见过这个奇怪的参数，但你从来不知道它是怎么回事。</p><p id="5dad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，在函数中使用*args是Python判断这个函数将:</p><ol class=""><li id="fea9" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt ny nz oa ob bi translated">接受任意数量的参数</li><li id="1a52" class="nt nu it la b lb oc le od lh oe ll of lp og lt ny nz oa ob bi translated">将收到的参数打包到一个名为args的<strong class="la iu">元组</strong>中。注意<strong class="la iu"> args </strong>只是一个名字，你可以用任何你想要的东西来代替。(我们将在下面看到一个例子)</li></ol><p id="626b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来扔点代码把事情说清楚。</p><p id="b441" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们定义一个函数，它将参数打包在一个args变量中，并将这个变量打印到控制台。没什么特别的。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="4139" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def my_awesome_function(*args):<br/>   # do awesome job!<br/>   print(args)</strong></span></pre><p id="83c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们传递任意数量的参数:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="83fb" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">my_awesome_function(1, 2, 3)<br/>(1, 2, 3)</strong></span><span id="1844" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">my_awesome_function(1, 2, 3, 4)<br/>(1, 2, 3, 4)</strong></span></pre><p id="a991" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们会清楚地看到，它们确实都被打包在一个元组中。</p><p id="cfd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使我们没有通过任何论证，</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="2dff" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">my_awesome_function()<br/>()</strong></span></pre><p id="9e0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们仍然得到一个(空的)元组。</p><p id="4c3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这可能会让一些人有点畏缩，但是您甚至可以打包不同类型的多个参数。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="e27a" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">my_awesome_function(1, "2", [1, 2])<br/>(1, "2", [1, 2])</strong></span></pre><p id="0954" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">*运算符是做什么的？<br/> 这是一个拆包符。它出现在一个iterable(例如一个列表或一个元组)之前，它真正做的是将它的元素作为函数的参数展开。它基本上是一种符号，其中:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="71df" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">my_awesome_function(1, 2, 3)</strong></span></pre><p id="26aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相当于:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="0c4d" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">my_awesome_function(*[1, 2, 3])</strong></span></pre></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="a8e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，回到我们之前关于乘法的例子，我们可以通过打包重写函数。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="d85c" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def multiply_numbers(*numbers):<br/>    product = 1<br/>    for number in numbers:<br/>        product *= number<br/>    return product</strong></span></pre><p id="f7cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数现在可以接收任意数量的参数，即使您有一个数字列表，您仍然可以使用它:这就是解包的用处。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="815a" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">multiply_numbers(*large_list)</strong></span></pre><h1 id="9413" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">用**kwargs传递关键字参数</h1><p id="d20f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><strong class="la iu">首先，什么是关键词论点？</strong></p><p id="1912" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您定义如下所示的函数时:</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="f396" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def sum_numbers(a, b):<br/>    return a + b</strong></span></pre><p id="3fe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以用两种不同的方式调用它，或者通过</p><p id="1984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1-传递位置参数</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="6365" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">sum_numbers(1, 2)</strong></span></pre><p id="9c38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2-或传递关键字(或命名)参数</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="da21" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">sum_numbers(a=1, b=2)</strong></span></pre><p id="3d41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所料，Python也有自己传递可变长度关键字参数(或命名参数)的方式:这是通过使用<strong class="la iu"> **kwargs </strong>符号来实现的。</p><p id="24c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用**kwargs时，传递给函数的所有关键字参数都打包在一个字典中。正如您所料，这个字典变量叫做kwargs。</p><p id="fb9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个利用<strong class="la iu"> **kwargs的小例子。</strong>一个简单的例子，接受关键字参数并打印它们的键值对。</p><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="885a" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def show_user_info(**data):<br/>    # data is a dict<br/>    for key, value in data.items():<br/>        print(f"{key}: {value}")</strong></span><span id="07f2" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">&gt;&gt;&gt; show_user_info(name="Ahmed")<br/>name: Ahmed</strong></span><span id="8de6" class="ng mc it nb b gy nl ni l nj nk"><strong class="nb iu">&gt;&gt;&gt; show_user_info(name="Ahmed", job="data scientist")<br/>name: Ahmed<br/>job: data scientist</strong></span></pre><h1 id="578f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用*args和**kwargs</h1><p id="d200" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">现在您已经理解了这两种符号的基础，有一些适用于它们的特定规则:</p><ul class=""><li id="4fd2" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt oh nz oa ob bi translated">您可以在位置参数中使用*args。在这种情况下，*args必须在末尾</li></ul><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="0e3e" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def my_function(a, b, *args):<br/>    # do magic stuff</strong></span></pre><ul class=""><li id="fb15" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt oh nz oa ob bi translated">如果我们在前面的例子中添加一个带有默认值的位置参数，这个参数必须在最后</li></ul><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="c7ed" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def my_function(a, b, *args, c=2)<br/>    # do more magic stuff</strong></span></pre><ul class=""><li id="5f4d" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt oh nz oa ob bi translated">您可以将<strong class="la iu"> *args </strong>与<strong class="la iu"> **kwargs </strong>组合起来，甚至可以添加带有默认值的位置参数。在这种情况下，顺序是:<strong class="la iu"> *args </strong>、带有默认值的位置参数、<strong class="la iu"> **kwargs </strong></li></ul><pre class="kj kk kl km gt nc nb nd ne aw nf bi"><span id="3163" class="ng mc it nb b gy nh ni l nj nk"><strong class="nb iu">def my_function(a, b, *args, c=2, **kwargs):<br/>   # make Harry Potter cry</strong></span></pre><h1 id="751b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">结论</h1><p id="3afa" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">让我们结束它。</p><ul class=""><li id="6098" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt oh nz oa ob bi translated"><strong class="la iu"> *args </strong>和<strong class="la iu"> **kwargs </strong>允许你拥有可变长度的参数</li><li id="b932" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated"><strong class="la iu"> *args </strong>允许您传递可变数量的非关键字参数，这些参数被打包到一个元组中</li><li id="260c" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated"><strong class="la iu"> **kwargs </strong>允许您传递可变数量的关键字参数，这些参数被打包到一个字典中</li><li id="3fff" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated"><strong class="la iu"> *args </strong>和<strong class="la iu"> **kwargs </strong>让你的代码更加灵活</li><li id="bf69" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated">*args和**kwargs可以与位置参数组合在一起</li></ul><h1 id="ddf6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">资源</h1><p id="bf63" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如果您有兴趣更深入地研究*args和**kwargs主题，您可以查看以下资源:</p><ul class=""><li id="5f15" class="nt nu it la b lb lc le lf lh nv ll nw lp nx lt oh nz oa ob bi translated"><a class="ae oi" href="https://stackoverflow.com/questions/33542959/why-use-packed-args-kwargs-instead-of-passing-list-dict" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/33542959/why-use-packed-args-kwargs-inst-of-passing-list-dict</a></li><li id="c8f2" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated"><a class="ae oi" href="https://www.pythontutorial.net/python-basics/python-args/" rel="noopener ugc nofollow" target="_blank">https://www.pythontutorial.net/python-basics/python-args/</a></li><li id="1dcb" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated"><a class="ae oi" href="https://treyhunner.com/2018/04/keyword-arguments-in-python/#What_are_keyword_arguments" rel="noopener ugc nofollow" target="_blank">https://trey hunner . com/2018/04/keyword-arguments-in-python/# What _ are _ keyword _ arguments</a>？</li><li id="24c5" class="nt nu it la b lb oc le od lh oe ll of lp og lt oh nz oa ob bi translated"><a class="ae oi" rel="noopener" target="_blank" href="/10-examples-to-master-args-and-kwargs-in-python-6f1e8cc30749">https://towards data science . com/10-examples-to-master-args-and-kwargs-in-python-6f1e 8 cc 30749</a></li></ul><h1 id="d98a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">感谢阅读🙏</h1><p id="ad2a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">同样，如果你已经做到了这一步，我想感谢你的时间，并希望你已经学到了一些有用的东西，使你的代码更干净，更灵活。</p><p id="5944" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天就这些了。下次见！👋</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="eb3f" class="mb mc it bd md me oj mg mh mi ok mk ml jz ol ka mn kc om kd mp kf on kg mr ms bi translated">新到中？您可以每月订阅5美元，并解锁无限的文章— <a class="ae oi" href="https://ahmedbesbes.medium.com/membership" rel="noopener">单击此处。</a></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/2d2efaf99ebfaefe5f234166755171e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G7RypdYbeLCCra1Y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山德拉·诺维兹卡娅在<a class="ae oi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div></div>    
</body>
</html>