# 估计流数据中特定于事件的计数

> 原文：<https://towardsdatascience.com/estimating-event-specific-counts-in-streaming-data-c237f51ead4f>

## **简单而引人注目的 CountMin 草图**

![](img/05c11fb4a8acdf77a7e626d7e0531a73.png)

由[路易斯·阿里亚斯](https://unsplash.com/@luism_arias?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/counting?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

想象一串输入符号 *a* ， *b* ， *a* ， *c* ， *a* ，…。我们想知道某个符号到达了多少次。

这个问题有很多用途。计算向谷歌进行某项查询、在 YouTube 上观看某个视频或从 iTunes 购买某首歌曲的次数。和许多其他人。

我们可以使用散列表来解决这个问题，散列表的键是目前为止在流中看到的不同符号，值是它们的频率。然后可以从这个散列表中查找任何符号的计数。

当有数十亿个不同的符号时，这种方法会消耗大量内存。

如果我们愿意牺牲一些计数的准确性，我们可以使用一个非常紧凑的数据结构来解决这个问题。此外，数据结构将以流式方式更新。

好吧，我们开始吧。首先，目录详细地揭示了我们将涉及的内容。

```
**Single Hash Function** Randomizing the Hash Function
   Example 3
**Multiple Hash Functions** Example 
   Estimated Symbol’s Count 
   Example 
   Very High-Dimensional Universes 
   Sparse Representations 
   Why Use Multiple Hash Functions? 
   Choosing The Hash Functions 
   Running Time 
   Mergability 
   Design Choices And Tradeoffs: A Thought Experiment 
**Very High-Dimensional Use Cases** 
   Text Documents As Symbols 
   Configuring The CountMinSketch On Text Documents 
   Count Estimation Example 
   The Expected Effects Of Our Configuration Choices 
**Summary 
Further Reading** 
```

**单哈希函数**

让我们从散列表方法开始,“进化我们的方式”到 CountMinSketch。为了便于说明，我们将使用一个运行场景，其中的符号是 32 位二进制向量。

hashmap 方法使用计数器的映射 *C* 。最初，地图是空的。就好像宇宙中所有的符号都是 0 计数。当一个新的符号 *v* 到达流中时，我们将 *C* [ *v* ]加 1。我们查任意符号 *v* 在任意时刻的频率为 *C* [ *v* ]。

这种方法的内存需求是流中不同符号的数量，在最坏的情况下是 2。如果流已经有许多不同的到达，这可能是一个问题。比如几十亿。即使到目前为止这个流只接收到少量的不同符号，我们也不能保证 *C* 的大小最终不会爆炸。

现在让我们开始概括，试图防止 *C* 爆炸。

让 *h* ( *v* )表示我们应用于符号 *v* 的特定散列函数。在上一段的描述中，我们把每一次出现的 *C* [ *v* ]都换成*C*[***h***(*v*)】。hashmap 方法对应于使用哈希函数 *h* ( *v* )等于 *v* 。

这就是事情开始变得有趣的地方。现在让我们使用一个散列函数，它的范围比宇宙的大小小得多。例如， *h* ( *v* )返回 *v* 的前 16 位。 *h* ( *v* )的范围在 65K 左右。所以 *C* 永远不需要超过 65K 的计数器，远远少于 2。

我们必须付出代价。我们是。我们现在可以有碰撞。假设两个符号 *u* 和 *v* 具有相同的 hash 值，即 *h* ( *u* )等于 *h* ( *v* )。 *u* 和 *v* 的计数混合到同一个计数器*C*[*h*(*u*)】。也就是说，虽然我们无法辨别 *u* 或 *v* 的真实计数，但我们可以肯定地说*C*[*h*(*u*)]是两者的上限。例如，如果[ *h* ( *u* )]为 0，我们可以确定地知道，无论是 *u* 还是 *v* 都没有到达流中。

总结

```
To better bound the number of counters, we use a hash function whose range is **constricted**. While this potentially sacrifices accuracy, our estimated counts remain **upper bounds**.
```

**随机化散列函数**

哈希函数“提取前 16 位”偏向于前 16 位。一个简单的随机化方法使其无偏。

首先在初始化阶段，产生一个随机的 32 位二进制数，其中正好有 16 位为 1 值。(随机性在于这些 1 值的位置。)记录这个数字，并在计算任何符号的哈希值时将其用作掩码。

让我们在下面的例子中说明这一点。

**例子**

在这里，我们将宇宙限制为 8 位数字。请注意，哈希值是一个 4 位数。

```
mask  0 **1** **1** 0 0 **1** 0 **1**
value 1 **1** **1** 0 0 **0** 0 **1**
hash    **1** **1**     **0**   **1**
```

**非常高维度的宇宙**

在我们运行的例子中，二进制向量是 32 位长。有些情况下，位向量要长得多，有数百万或数十亿位。我们将在后面的章节中讨论它们。CountMinSketch 在那里特别有吸引力。

**稀疏表示**

至此，我们已经隐含地假设 *C* 是由所选散列函数的范围索引的数组。在许多用例中，我们想要使用的散列函数可能有很大的范围。也就是说， *m* 非常大，可能几十亿。

即使在低维宇宙中，选择的哈希函数也可能有非常大的范围。我们之前见过一个例子， *h* ( *v* ) = v 其中 *m* 在 32 位二进制向量的论域上是 2。显然，对于一个更高维度的宇宙，这变得更加可能。

在这种情况下， *C* 的一种自然表示就是散列表。 *C* 的键是目前为止在流中观察到的 *h* ( *v* )的值。*C*[*h*(*v*)]照例是 *h* ( *v* ) *的*数。

当在流中观察到的 *h* ( *v* )的不同值的数量远小于 *m* 时，这种表示非常紧凑。实际情况往往如此。

**多个哈希函数**

我们将使用多个散列函数 *h* 1、…、 *hn* ，都在相同的范围 1、2、…、 *m* 上。我们将把我们的计数器映射归纳为一个计数器矩阵。行索引散列函数。这些列索引散列值，都在范围 1、2、…、 *m* 内。 *C* [ *i* ， *hi* ( *v* )]将存储对符号 *v* 应用 *i* th 哈希函数的计数。

当符号 *v* 到达流中时，从 1 到 *n* ，每增加一个*I*C[*I*][*hi*(*v*)】就增加 1。如下图所示。

**示例**

为了方便起见，我们将使用一个比我们运行的宇宙基数更高的宇宙。

我们的符号将是以 4 为基数的 3 位数。即*v*=*v*1*v*2*v*3 其中每个 *vi* 为 0、1、2 或 3。我们将使用三个哈希函数 *h* 1( *v* )、 *h* 2( *v* )和 *h* 3( *v* )。一位数一个。 *hi* ( *v* )将等于 *vi，*v*v*的第 *i* 位的值。例如， *h* 2(1 **3** 2)等于 3，如粗体所示。

*C* 是一个 3×4 矩阵，因为我们有三个散列函数，每个散列函数都有四个相同的值。

假设符号 011 和 232 分别到达流中四次和七次。最后，不管它们到达的顺序如何， *C* 是

```
 **0 1 2 3**
**1** 4 0 7 0
**2** 0 4 0 7
**3** 0 4 7 0
```

*C* 的行和列，用粗体显示，分别索引数字位置和数字值。

我们来解释一下*C*【2】【1】。它至少是 4，因为 0 **1** 1 在流中出现了四次，并且它的第二个数字是 1。It 不大于 4，因为没有冲突，因为在流中出现的唯一的另一个符号 232 在第二位置具有不同的值。

**估计符号数**

回想一下，对于任何符号 *v* ，我们想要估计它到目前为止到达流中的次数。

当使用单个散列函数时，符号的估计计数只是简单的*C*[*h*(*v*)】。当我们使用多个哈希函数时， *v* 的出现影响 *n* 计数器 *C* [ *i* ，*hi*(*v*)】for*I*范围从 1 到 *n* 。我们如何从 n 次计数得到一个估计值呢？

回想一下，在上一节中我们注意到，对于任何固定的哈希函数 *h* ，*C*[*h*(*v*)]是 *v* 的真实计数的上限。在 *n* 哈希函数的设置中，这意味着对于范围从 1 到 n 的 *i* ，每个*C**I*， *hi* ( *v* )】都是 *v* 的真实计数的一个上界。因此，这些上限中最小的一个作为这个真实计数的最佳估计。也就是说，我们有

```
CountUB(v): The minimum of C[i][hi(v)] for i from 1 to n
```

**例子**

现在让我们来计算宇宙中几个数字的估计数。一个将被证明是精确的计数，另一个是明显的高估。

考虑 232。CountUB(232)是下面粗体显示的三个单元格*C*【1】【2】、*C*【2】【3】和*C*【3】【2】中的最小计数。

```
 **0 1 2 3**
**1** 4 0 **7** 0
**2** 0 4 0 **7**
**3** 0 4 **7** 0
```

首先，注意这些单元中的每一个都是无冲突的。它只记录流中 232 的出现次数。011 是该流接收到的唯一的另一个符号，它不影响任何这些单元。这是因为两个符号{2，3}和{0，1}中的值集是不相交的。因此，这三个单元格中的最小值 7 正好是 232 的真实计数。

接下来考虑 212。CountUB(212)是下面以粗体显示的三个单元格中的最小计数。

```
 **0 1 2 3**
**1** 4 0 **7** 0
**2** 0 **4** 0 **7**
**3** 0 4 **7** 0
```

CountUB(212)是 4，而 212 的真实计数是零。这是因为所有三个单元都有相对于 212 的冲突。这是因为**2**T2 1T4 2 在第一和第三位置与 **2** 3 **2** 碰撞，在第二位置与 0 *1* 1 碰撞。

**为什么要使用多个哈希函数？**

与其使用多个散列函数，为什么不适当地扩大单个散列函数的范围呢？考虑我们运行的 universe 示例中的散列函数“提取前 16 位”。它使用大约 65K 的计数器。假设我们添加了第二个哈希函数“提取接下来的 16 位”。现在这两个加起来用了~130K 计数器。我们可以使用单个散列函数“提取第一个 **17** 位”并获得相同数量的计数器。

使用多个散列函数的直觉围绕着在估计符号计数中使用最小*运算。例如，为了精确估计符号的计数，最小操作中涉及的仅仅一个单元是无冲突的就足够了。*

使用多个散列函数的好处，尤其是使用最小操作的好处，将在后面关于非常高维用例的章节中更清楚地展现出来。

**选择哈希函数**

哈希函数应该是独立的。这个想法是为了减少碰撞。也就是多元化。

作为相反类型的极端例子，考虑当所有散列函数都相同时。使用多个并没有给我们带来任何好处。在额外的内存和计算需求中，我们确实承担了使用多个的所有成本。

这是一个具体的例子，在我们的 32 位独立数的宇宙中，有 4 个合理的散列函数可供选择。 *h* 1、 *h* 2、 *h* 3、 *h* 4 将分别提取第一、第二、第三和第四个 8 位的块。

**运行时间**

假设散列函数可以在恒定时间内被评估，在计数器矩阵 *C* 中寻找和增加适当的计数器的运行时间与散列函数的数量 *n* 成比例。计算任何符号的估计计数也在与 *n* 成比例的时间内运行，因为它涉及查找 *n* 个单元并计算它们的最小值。

**可制造性**

这是一个概念，将两个流分别创建的草图合并，会产生与从两个流合并的单个流中获得的草图相同的草图。

可合并性在分布式设置中是非常有用的操作。它允许以分布式的方式从不同的流中构建草图。然后根据需要进行合并，以估计全局计数，即，好像来自所有流的合并。

只要所有草图使用相同的散列函数，CountMinSketch 就是可合并的。

这可以表示如下:

```
C(S1) + C(S2) = C(S1 + S2)
```

这里 *C* ( *S* )表示由流 *S* 构建的草图，LHS 中的“+”表示草图合并操作，RHS 中的“+”表示流合并操作。

合并两个 CountMinSketches 很简单:只需按组件将它们的矩阵相加。这在下面描述。

```
C[i,j] = C1[i,j] + C2[i,j] for all i, j
```

*C* 是 *C* 1 和 *C* 2 的合并。

**设计选择和权衡:一个思维实验**

散列函数的数量及其范围的大小如何影响各种权衡？

下面的思维实验将帮助我们思考这些问题。

我们的宇宙将是 32 位数字。我们将考察 *n* = 1，2，4，8，…，32 的各种配置。

配置 *n* 会使用 *n* 哈希函数 *h* 1( *n* )，…， *h* 2( *n* )。 *hi* ( *n* )将从一个 32 位数字中提取 32/ *n* 位的第 *i* 块。

配置 *n* =1 使用单一哈希函数*h*(*v*)=*v*。在另一个极端，配置 *n* =32 使用 32 个哈希函数*hi*(*v*)=*VI*，其中 *i* 范围从 1 到 *n* 。

*n* =1 配置提供完全精确的计数。然而，在最坏的情况下，它可能需要 2 个计数器。在另一个极端， *n* =32，我们只需要 32*2=64 个计数器。显然，估计的符号计数可能相当不准确。

很明显，随着 *n* 的增加，内存限制会成倍增加。这是因为 *C* 中的行数随着 *n* 线性增加，而列数呈指数减少。

精确度如何下降尚不清楚。

这两个极端之间的某个地方可能是用户认为可以接受的特定折衷的最佳点。内存需求与准确性的对比。到达数据流的数据的性质也明显影响这种权衡。

**非常高维的用例**

**文本文件作为符号**

假设我们的“符号”是到达流中的文本文档。例如，到达 Twitter 流的推文。比方说，对于每个文档，我们想要估计它在流中被观察到的次数。

按照惯例，让我们在向量空间模型中用一个合适的向量来表示一个文档。向量的维数是词典中术语的数量，通常以百万计。第 *i* 个成分表示词典中的第 *i* 个术语。

我们可以将文档向量的第 *i* 个分量的值设置为文档中第 I 个词典项的频率。或者该频率的二进制版本。或者更高级的变体，其利用术语的 IDF 来调整该频率。

好了，现在我们已经将文档编码为相同固定维度的向量。我们现在试图估计在水流中观察到的不同矢量的数量。

请注意，不同的向量计数不一定是不同的文档计数。这是因为多个文档可能具有相同的矢量编码。

这可能是一件好事。通过适当地选择文档的矢量编码，我们可以忽略我们可能不关心的细微差别。

**在文本文档上配置 count minsketch**

在这种设置中，什么是合理的哈希函数？这里有一个。所谓的比特采样哈希函数，hi(v) = vi，我们在本帖前面遇到过。它只是提取 v 的第 I 个分量。在我们的设置中，这对应于词典中的特定术语。

值 *vi* 取决于我们的矢量编码。我们可以将它作为术语在文档中的出现指示符(布尔型)，或者它的频率。或者更复杂的东西。我们的选择隐含地定义了我们正在计数的内容。例如，当 *v* 为布尔向量编码时，哈希函数*h*_*data*(*v*)根据 *v* 编码的文档中是否出现 *data* 一词，返回 *true* 或 *false* 。

在本节的其余部分，我们将仅限于布尔型的位采样散列函数。

下一个问题:我们应该使用多个哈希函数吗？如果我们能够负担得起使用词典中有多少术语就有多少哈希函数(可能有数百万)，是的，那就好了。如果没有，我们可能首先选择一个我们能负担得起的词典的随机子集，并使用与之对应的散列函数。

**计数估计示例**

对于特定的 *v* ，CountUB( *v* )会是什么？让我们用一个玩具的例子来说明。这个例子将引发一场有趣的讨论。

在这个例子中，为了便于阅读，我们将“估计文档的频率”简称为“估计文档的矢量编码的频率”。

假设我们的词典正好由五个词组成:*数据*、*数据*、数据*、*挖掘*数据*计算机*。比方说我们要估计文档{ *数据*， *of* }在流中出现的频率。*

首先，让我们确定在这个估计中我们需要的特定计数器。分别是*C**数据【T17，1】，*C**【T21，1】，*C**【T25，0】，*C**采矿【T29，0】，*C**计算机【T33，0】。前两个分别计算流中包含单词 *data* 和 *mining* 的文档的数量。接下来的三个分别计算流中不包含单词*、*、*的*和*计算机*的文档的数量。接下来，我们取其中的最小值，并将其作为估计值返回。*****

现在进行非正式讨论。这将有助于想象词典是维基百科中所有不同的文章。并且该流的文档是从该语料库中提取的。

我们期望 *C* [ *数据【T47，1】比*C*[【T51，1】的*小得多，因为*的*比*数据*更常见。我们预计 *C* [ *the 【T61，0】比 C[ *mining 【T63，0】或 *C* [ *computer 【T67，0】要小得多，因为大多数维基百科文章中都有单词 *the* 。对于*采矿*或*电脑*来说并非如此。*****

因此，我们预计我们的文档在流中的估计频率将是 *C* [ *数据【T77，1】和 *C* [ *the* ，0]中的最小值。换句话说，是“包含单词*数据*的维基百科文章数量”和“不包含单词*数据*的维基百科文章数量”中较小的一个。*

**我们的配置选择的预期效果**

很明显，随着我们增加哈希函数的数量，即增加我们跟踪的*存在*和*不存在*计数的词典项的数量，估计精度应该会提高。我们跟踪的词典单词数量越多，我们就越能期望它们在特定文档中的存在和不存在计数的最小值接近真实计数。

**总结**

这篇文章讨论了在一个可能无界的流中估计某个符号出现次数的问题。它专注于 CountMinSketch，这是一种带有伴随算法的数据结构，在流设置中特别有吸引力。它只对数据进行一次操作，并且可以根据我们的需要配置使用更少或更多的内存。(后者是为了提高精度或用于非常高维的用例)。

**延伸阅读**

1.  https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch
2.  【https://web.stanford.edu/class/cs168/l/l2.pdf 