# 5 个 Groovy 技巧帮助你在 Julia 中编写更好的代码

> 原文：<https://towardsdatascience.com/5-groovy-tips-help-you-write-better-code-in-julia-4c7317e60862>

## 一些提高 Julia 代码可读性的技巧使其更容易理解

![](img/30c4a28da528015ea07d20c0f335d50f.png)

(图片由 [Pixabay](https://pixabay.com/images/id-4178304/) 上的 [Darkmoon_Art](https://pixabay.com/users/darkmoon_art-1664300/) 提供)

# 介绍

在一些容量中，在某个时刻，每个程序员都写过一些糟糕的代码。事实是，在生活中，一个人经常需要犯错误，以便从这些错误中学习和成长，并使自己变得更好。这同样适用于软件工程和编程。通常代码可能是一个迷宫，这些困难使得从一个不是很结构化的东西创建一个结构变得非常困难。当软件是非结构化的时候，实现代码的更新是非常困难的。

幸运的是，编写良好且组织良好的代码可以缓解这些问题。唯一的问题是，在某些情况下，我们并不总是编写组织良好的代码。对于那些喜欢 Julia 编程语言的人来说，有一些非常简单的步骤可以让你的代码变得更好。考虑到方法定义还有一个新的方面，这些步骤对 Julia 来说是额外有价值的，那就是由于语言的多分派范例而被类型化。让我们来看看这些技术，我用它们来使我的代码在 Julia 中变得更好。另外，如果你想看 Python 的等价物，这里有我写的另一篇文章的链接:

[](/how-not-to-make-spaghetti-out-of-python-7f4d96d4000b)  

# №1:按类型和层次结构参数分开调度

我真正喜欢做的第一件事是将方法分组，并保持它们有组织。同名的方法可能应该一起定义。让这些方法具有层次结构是很有意义的，因为 Julian 子类型系统也是为了做同样的事情而设计的。考虑下面的例子，它很好地演示了不同的类型以及它们的超类型和子类型是如何被调度的。

```
showit(x::Number) = println("Number", x)
showit(x::Float64) = println("Float", x)
showit(x::Integer) = println("Integer", x)
```

在这段代码中，超类型是 Number。也就是说，如果我们要提供任何抽象数字类型的子类型，那么数字函数就会运行。然后我们有两个分派，一个是针对浮点 64 的，一个是针对 64 位整数的。如果我们在一个更大的文件中，将这些调度放在一起是很有意义的，因为从逻辑上讲，它们本质上是相同的函数定义。如果我们有另一个子类型调度，那么对这些调用进行分层排序是很有意义的，就像这样:

```
showit(x::Number) = println("Number", x)showit(x::Real) = println("Real Number", x)
showit(x::Float64) = println("Float", x)
showit(x::Integer) = println("Integer", x)
showit(x::Imaginary) = println("Imaginary Number", x)
showit(x::Complex) = println("Complex", x)
```

我认为这更有意义，因为我们可以主动查看哪个函数将在类型层次结构中捕捉每个类型。这最终使得方法定义更容易用它们的类型来估算，特别是当它与类型层次结构相关时。

# №2:遵循命名惯例

朱莉娅有一个特殊的命名惯例，当然应该遵循。遵循这些惯例是一个好主意的原因是，你甚至可以在打电话之前就知道你正在使用什么样的定义。在 Julia 中，构造函数和模块在其名称中每个单词的开头都用大写字母表示。

```
module NotMain
    mutable struct Hello
         x::Int64
    endend
```

变量名和方法名都是小写的。

```
x = 5
println(y::Hello) = println(y.x)
```

最后，如果一个函数改变了它的任何参数，那么你应该在它的名字后面加上一个解释点。这使得判断一个函数是否会改变你的数据变得容易得多，并且使得所有的数据改变变得非常明显，这绝对是你想要的，除非你喜欢数据丢失之类的。

```
change_thing!(x::5)end
```

所有这些共同创造了一种语法，在这种语法中，我们可以解开正在发生的事情的类型，甚至不知道我们正在使用的名称的任何信息。

```
using NotMain # Modulex = Hello(1) # Constructor
y = Hello(2) # Constructor
println("Hello") # Method ()
x # Defined variable name
incrementx!(h::Hello) = h.x += 1 # We can tell this is a mutating call
```

# №3:使用类型层次结构

Julia 被低估的优势之一是类型层次结构。Julia 中的子类型的伟大之处在于，结合多种调度，它可以非常强大。使用子类型的另一个很大的好处是，它将使你的软件更具可扩展性，因为现在你可以导入抽象类型，用类似的字段对某些东西进行子类型化，然后这个新类型立即继承分派给那个类型的每个方法。这可以节省很多时间，因为您不需要为每种类型编写单独的函数，相反，您可以只调度一种类型，然后根据需要相应地调度下面的类型。我有一篇文章详细介绍了这一点，并概括了 Julia 中的类型，因此，如果您还不熟悉这一点，这可能是了解 Julia 中的类型层次结构的好地方:

[](/everything-you-need-to-know-about-types-in-julia-84f64c0f86f3)  

# №4:提取

在我的故事中，提取是一种技术，在这里我们重复这个选择，因为提取绝对是使代码更好的最有价值的事情之一。当我们提取代码时，我们将它移动到自己独特的方法中，这将在一个全新的元上清理代码。所有其他的例子通常主要适用于在全局或模块范围内工作，但是提取可以用来清理你的函数，以及缩短它们。

提取过程非常简单，您只需命名代码的一部分，然后将其封装到一个方法中。我也有一整篇关于提取的文章，如果你想更深入地了解这项技术的话。

[](/more-methods-means-better-code-1d3b237f6cf2) [## 更多的方法意味着更好的代码

towardsdatascience.com](/more-methods-means-better-code-1d3b237f6cf2) 

# №5:内联迭代

创建 for 循环和迭代是每个程序员通常害怕的事情之一。这并不是说创建这种东西很困难，只是每次打开一个循环来做某件事时，它都会在循环被调用期间停止执行。即使使用并行处理，最终在一个线程上运行仍然需要时间，所以避免编写大量的 for 循环绝对是一个很好的约束。

For 循环还创建了一个全新的范围，接受参数，并创建了一个新的缩进级别。就处理和编写循环的实际语法而言，有很多东西要进入迭代循环。幸运的是，语法很容易改进，改进语法的一种技术是使用内联 for 循环。在 Julia 中，它们的速度也快得多，并且提供了返回，因此不需要初始化。考虑下面的短语:

```
x = []
for y in example
   push!(x, y)
end
```

我们可以将这句话简化成这样一行代码:

```
x = [y for y in example]
```

我认为这样更简洁。内联迭代用[]语法表示，考虑到我们期望数组类型的可迭代返回，这很有意义。

# 结论

对于编程，有很多小事情可以做，以改善他们的代码，使其运行或看起来更好。在众多改进中，有这五个，我希望它们能提供一些易于使用的技术来改进你的 Julia 代码的外观，有时甚至是性能。特别是，我发现提取和单行 for 循环非常有价值。感谢您阅读我的文章，我希望所有这些很酷的提示都能派上用场。