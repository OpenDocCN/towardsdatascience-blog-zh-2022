# 熊猫索引操作不一致的解决方案

> 原文：<https://towardsdatascience.com/a-solution-for-inconsistencies-in-indexing-operations-in-pandas-b76e10719744>

## 摆脱烦人的设置 WithCopyWarning 消息

![](img/0c97da3cd3244e84993a901f8f48b137.png)

由[凯利·西克玛](https://unsplash.com/@kellysikkema)在 [Unsplash](https://unsplash.com) 上拍摄的照片

## 介绍

pandas 中的索引操作非常灵活，因此，有许多情况可能表现得非常不同，从而产生意想不到的结果。此外，很难预测何时会出现`SettingWithCopyWarning`以及这到底意味着什么。我将展示几个不同的场景，以及每个操作如何影响您的代码。之后，我们将看看一个叫做`Copy on Write` 的新特性，它可以帮助你摆脱不一致和`SettingWithCopyWarnings`。我们还将研究这对性能和其他一般方法的影响。我是熊猫核心团队的一员。

## 索引操作

让我们看看索引操作目前在 pandas 中是如何工作的。如果您已经熟悉索引操作，可以跳到下一节。但是要注意，很多情况下都有不同的行为形式。确切的行为很难预测。

当父数据帧和新数据帧的底层数据不共享时，pandas 中的操作产生一个副本。视图是与父对象共享数据的对象。对视图的修改可能会影响父对象。

目前，一些索引操作返回副本，而另一些返回视图。确切的行为很难预测，即使对于有经验的用户也是如此。这在过去一直是我的一大烦恼。

让我们从具有两列的数据帧开始:

```
df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})
```

对数据帧或系列的 **getitem** 操作返回初始对象的子集。该子集可能由一列或一组列、一行或一组行或者两者的混合组成。数据帧或系列上的 **setitem** 操作更新初始对象的子集。子集本身由调用的参数定义。

数据帧上的常规 **getitem** 操作在大多数情况下提供了一个视图:

```
view = df["user_id"]
```

因此，新对象`view`仍然引用父对象`df`及其数据。因此，写入视图也会修改父对象。

```
view.iloc[0] = 10
```

这个 **setitem** 操作将因此不仅更新我们的`view`而且更新`df`。这是因为**底层数据**在两个对象之间共享。

只有当列`user_id`在`df`中只出现一次时才成立。一旦`user_id`被复制， **getitem** 操作返回一个数据帧。这意味着返回的对象是副本而不是视图:

```
df = pd.DataFrame(
    [[1, 10, 2], [3, 15, 4]], 
    columns=["user_id", "score", "user_id"],
)
not_a_view = df["user_id"]
not_a_view.iloc[0] = 10
```

**设置项**操作不更新`df`。我们也得到我们的第一个`SettingWithCopyWarning`，尽管这是一个完全可以接受的操作。 **getitem** 操作本身有更多的情况，比如类似列表的键，例如`df[["user_id"]]`，多索引列等等。我将在后续文章中更详细地介绍执行索引操作的不同形式及其行为。

让我们看看另一个比单个 **getitem** 操作稍微复杂一点的例子:**链式索引**。链式索引意味着用一个布尔掩码过滤，后跟一个 **getitem** 操作，或者反过来。这是一步完成的。我们没有创建新的变量来存储第一次操作的结果。

我们再次从常规数据帧开始:

```
df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})
```

我们可以通过以下方式更新所有得分高于 15 的`user_ids`:

```
df["user_id"][df["score"] > 15] = 5
```

我们取列`user_id`，然后应用过滤器。这非常好，因为列选择创建了一个视图，而 **setitem** 操作更新了该视图。我们也可以切换两种操作:

```
df[df["score"] > 15]["user_id"] = 5
```

这个执行命令产生另一个`SettingWithCopyWarning`。与我们之前的例子相反，什么都没有发生。数据帧`df`未被修改。这是无声的无操作。布尔掩码总是创建初始数据帧的副本。因此，初始的 **getitem** 操作返回一个副本。返回值不赋给任何变量，只是一个临时结果。**设置项**操作更新这个临时副本。因此，修改会丢失。掩码返回副本，而列选择返回视图，这是一个实现细节。理想情况下，这样的实现细节应该是不可见的。

另一种方法如下:

```
new_df = df[df["score"] > 15]
new_df["user_id"] = 10
```

该操作按预期更新了`new_df`，但无论如何显示了一个`SettingWithCopyWarning`，因为我们不能更新`df`。在这种情况下，我们大多数人可能都不想更新初始对象(例如`df`)，但我们还是得到了警告。根据我的经验，这会导致不必要的`copy`语句分散在代码库中。

这只是当前索引操作中不一致和恼人之处的一小部分。

由于实际的行为很难预测，这就迫使许多其他方法的防御性副本。举个例子，

*   删除列
*   设置新索引
*   重置索引
*   …

全部复制底层数据。从实现的角度来看，这些副本是不必要的。这些方法可以很容易地返回视图，但是返回视图会导致不可预知的行为。理论上，一个 **setitem** 操作可以通过整个调用链传播，一次更新许多数据帧。

## 写入时复制

让我们看看一个叫做“写时复制”(CoW)的新特性如何帮助我们消除代码库中的这些不一致。CoW 表示以任何方式从另一个数据帧或序列**派生的任何数据帧或序列**总是表现为副本**。因此，我们只能通过修改对象本身来改变对象的值。CoW 不允许更新与另一个数据帧或系列对象共享数据的数据帧或系列。有了这些信息，我们可以再次看看我们最初的例子:**

```
df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})
view = df["user_id"]
view.iloc[0] = 10
```

**getitem** 操作提供了对`df`及其数据的查看。 **setitem** 操作在`10`被写入第一行之前触发底层数据的拷贝。因此，该操作不会修改`df`。这种行为的一个优点是，我们不必担心`user_id`可能被复制或者使用`df[["user_id"]]`而不是`df["user_id"]`。所有这些情况的行为完全一样，没有恼人的警告显示。

在更新对象的值之前触发复制会影响性能。这肯定会导致一些业务的小幅放缓。另一方面，许多其他操作可以**避免**防御副本，从而极大地提高性能。以下操作都可以用 CoW 返回视图:

*   删除列
*   设置新索引
*   重置索引
*   还有很多。

让我们考虑以下数据框架:

```
na = np.array(np.random.rand(1_000_000, 100))
cols = [f"col_{i}" for i in range(100)]
df = pd.DataFrame(na, columns=cols)
```

使用`add_prefix`将给定的字符串(例如`test`)添加到每个列名的开头:

```
df.add_prefix("test")
```

如果没有 CoW，这将在内部复制数据。当只看操作时，这是不必要的。但是由于返回视图可能有副作用，所以该方法返回一个副本。因此，操作本身相当慢:

```
482 ms ± 3.43 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
```

这需要很长时间。我们实际上只修改了 100 个字符串，而没有触及任何数据。在这种情况下，返回视图可以显著提高速度:

```
46.4 µs ± 1.04 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)
```

同样的操作运行速度要快几个数量级。更重要的是，当使用 CoW 时，`add_prefix`的运行时间是一个常量，不依赖于数据帧的大小。这个手术是在熊猫的主要分支上进行的。

只有当两个不同的对象共享相同的底层数据时，才需要复制。在上面的例子中，`view`和`df`引用了相同的数据。如果数据是一个`DataFrame`对象专有的，则不需要复制，我们可以继续就地修改数据:

```
df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})
df.iloc[0] = 10
```

在这种情况下，setitem 操作将继续原地操作，而不会触发复制。

因此，我们最初看到的所有不同场景现在都有完全相同的行为。我们再也不用担心微妙的矛盾了。

另一个目前具有奇怪且难以预测的行为的例子是链式索引。CoW 下的链式索引**永远不会**工作。这是奶牛机制的直接结果。最初选择的列可能会返回一个视图，但是当我们执行后续的 **setitem** 操作时会触发一个副本。幸运的是，我们可以很容易地修改代码以避免链式索引:

```
df["user_id"][df["score"] > 15] = 10
```

我们可以使用`loc`同时完成这两个操作:

```
df.loc[df["score"] > 15, "user_id"] = 10
```

总的来说，我们创建的每个对象的行为都像父对象的副本。我们不能意外地更新当前正在处理的对象之外的对象。

## 如何尝试它

可以试试熊猫 1.5.0 以来的牛功能。开发仍在进行中，但一般机制已经工作。

您可以通过以下语句之一全局设置 CoW 标志:

```
pd.set_option("mode.copy_on_write", True)
pd.options.mode.copy_on_write = True
```

或者，您可以使用以下命令在本地启用 CoW:

```
with pd.option_context("mode.copy_on_write", True):
    ...
```

## 结论

我们已经看到，熊猫的索引操作有许多难以预测的边缘情况和行为上的微妙差异。CoW 是一个旨在解决这些差异的新特性。根据我们对数据的处理，它可能会对性能产生积极或消极的影响。关于 CoW 的完整提案可在[此处](https://docs.google.com/document/d/1ZCQ9mx3LBMy-nhwRl33_jgcvWo9IWdEfxDNQ2thyTb0/edit#heading=h.iexejdstiz8u)找到。

感谢您的阅读。请在评论中分享您对索引和写时复制的想法和反馈。我将继续关注这个话题和熊猫。如果你想了解更多关于熊猫的信息，请关注我。