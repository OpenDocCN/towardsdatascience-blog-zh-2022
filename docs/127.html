<html>
<head>
<title>ANSYS in a Python Web App, Part 1: Post Processing with PyDPF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Web应用程序中的ANSYS，第1部分:使用PyDPF进行后处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ansys-in-a-python-web-app-part-1-post-processing-with-pydpf-44d2fbaa6135#2022-01-05">https://towardsdatascience.com/ansys-in-a-python-web-app-part-1-post-processing-with-pydpf-44d2fbaa6135#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="a2e3" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Python Web应用程序中的ANSYS，第1部分:使用PyDPF进行后处理</h1></div><div class=""><h2 id="cac7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将PyAnsys与Plotly的Dash和Dash-VTK组件集成，构建Ansys结构分析后处理web应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9c05c6e49132d77bbb0eded5abc15461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*s3fBDsz4WXP7AZcm_VRrgw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最后的后期处理app。作者图片</p></figure><p id="e308" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ANSYS <a class="ae lr" href="https://www.ansys.com/blog/ansys-gets-into-open-source-with-github" rel="noopener ugc nofollow" target="_blank">最近宣布</a>支持一个开源项目:<a class="ae lr" href="https://docs.pyansys.com/index.html" rel="noopener ugc nofollow" target="_blank"> PyAnsys </a>。PyAnsys被拆分成多个包:<a class="ae lr" href="https://mapdldocs.pyansys.com/" rel="noopener ugc nofollow" target="_blank"> PyMAPDL </a>用于与Ansys multiphysics仿真和方程解算器的实例进行交互，以及<a class="ae lr" href="https://dpfdocs.pyansys.com/" rel="noopener ugc nofollow" target="_blank"> PyDPF-Core </a> ( &amp;它的简化兄弟<a class="ae lr" href="https://postdocs.pyansys.com/" rel="noopener ugc nofollow" target="_blank"> PyDPF-Post </a>)用于后处理Ansys结果文件。作为一个几乎每天都在使用ANSYS和Python的结构分析师，这真的很吸引我。我还使用了Plotly的Dash框架来构建相当简单的网络应用程序，用于后处理数据和求解各种方程或系统。</p><p id="89ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Jupyter笔记本上玩了一会儿PyANSYS之后，我决定看看是否可以将一个web应用程序混合在一起，该应用程序将PyANSYS用作非分析师可以使用并获得洞察力的专门构建的分析工具的后端(或者至少构建一些朝着那个方向发展的东西)。PyANSYS被拆分成几个包。PyMAPDL专注于与正在运行的MAPDL实例(本地或远程)通信，该实例在运行时获取许可证。PyDPF-Core和PyDPF-Post侧重于对已经解决的文件进行后处理(例如*。rst)。这些库确实需要安装Ansys。</p><p id="3f3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将介绍如何使用PyDPF、Dash &amp; Dash-VTK构建一个web应用程序，该应用程序加载并绘制一些PyDPF示例的结果。你可以在这个<a class="ae lr" href="https://github.com/shkiefer/pyAnsys_DPF_dash" rel="noopener ugc nofollow" target="_blank"> GitHub库中看到完整的文件(笔记本和Dash app)。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0f4f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">普洛特利的破折号&amp;破折号-VTK</h1><p id="be7a" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated"><a class="ae lr" href="https://dash.plotly.com/introduction" rel="noopener ugc nofollow" target="_blank"> Plotly的Dash </a>开源框架被描述为一个仅用python就能构建全功能网络应用的框架。我非常喜欢用它来构建我希望其他用户(除了我自己)会使用的应用程序。</p><p id="30c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然自首次亮相以来它已经发展了很多，但你可以阅读2017年的公告文章，以了解Dash的更多背景信息:</p><div class="mw mx gp gr my mz"><a href="https://medium.com/plotly/introducing-dash-5ecf7191b503" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">🌟引入破折号🌟</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">用纯Python创建反应式Web应用程序</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div><p id="8260" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">几年前，我开发了几个基于VTK的桌面应用程序，用于有限元分析结果的后处理。因此，当我了解到Dash-VTK时，我很兴奋地尝试将其中一些移植到网络应用程序中。我把一个例子和一篇文章放在一起，你可以在这里查看:</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/3d-mesh-models-in-the-browser-using-python-dash-vtk-e15cbf36a132"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">使用python &amp; dash_vtk在浏览器中创建三维网格模型</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">使用python和Dash、pyvista和dash_vtk库导入和查看非结构化网格的快速示例…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="no l nk nl nm ni nn kp mz"/></div></div></a></div><p id="d64a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">借助Dash，我们能够构建一个具有简单、简洁用户界面的应用程序，这要归功于Dash-VTK视图3D网格和相关结果。如果你使用Ansys来解决你的分析问题，你需要将结果从Ansys中导出为某种固定的(可能是文本)格式，这样它们就可以被web应用程序读取。您必须导出模型(网格)以及Ansys的结果，并处理所有的映射。这可能是脆弱的，并且将限于您(作为开发人员)编码阅读的任何结果。这就是PyDPF帮助消除模型和网格步骤导出并从完整的结果文件直接进入数据处理和绘图的地方。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="297f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">PyDPF</h1><p id="6ce6" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">PyDPF中的DPF代表数据处理框架，并且(根据PyAnsys文档)专用于后处理:</p><blockquote class="np nq nr"><p id="f43f" class="kv kw ns kx b ky kz jr la lb lc ju ld nt lf lg lh nu lj lk ll nv ln lo lp lq ij bi translated">DPF是一个基于工作流的框架，允许通过链接运算符进行简单和/或复杂的评估。DPF的数据是基于物理不可知的数学量定义的，这些数学量在一个称为场的自给自足的实体中描述。这使得DPF成为一个模块化和易于使用的工具，具有广泛的能力。这是一个为处理大量数据而设计的产品。</p></blockquote><p id="2318" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PyAnsys文档和示例强调了它在Jupyter笔记本中的使用(包括绘图)。我使用<a class="ae lr" href="https://code.visualstudio.com/docs/python/jupyter-support-py" rel="noopener ugc nofollow" target="_blank"> VS代码“交互窗口”&amp;“Python代码文件”</a>探索了这些库，它们实际上是一个Jupyter笔记本。让我们看看它在笔记本上是什么样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1d7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">….瞧啊。关于结果文件的大量信息，如结果集、单位和网格统计。</p><pre class="kg kh ki kj gt ny nz oa ob aw oc bi"><span id="9932" class="od ma iq nz b gy oe of l og oh">DPF Model<br/>------------------------------<br/>DPF Result Info<br/>Analysis: static<br/>Physics Type: mecanic<br/>Unit system: MKS: m, kg, N, s, V, A, degC<br/>Available results:<br/>U Displacement :nodal displacements<br/>ENF Element nodal Forces :element nodal forces<br/>ENG_VOL Volume :element volume<br/>ENG_SE Energy-stiffness matrix :element energy associated with the stiffness matrix<br/>ENG_AHO Hourglass Energy :artificial hourglass energy<br/>ENG_TH thermal dissipation energy :thermal dissipation energy<br/>ENG_KE Kinetic Energy :kinetic energy<br/>ENG_CO co-energy :co-energy (magnetics)<br/>ENG_INC incremental energy :incremental energy (magnetics)<br/>BFE Temperature :element structural nodal temperatures<br/>------------------------------<br/>DPF  Meshed Region:<br/>3751 nodes<br/>3000 elements<br/>Unit: m<br/>With solid (3D) elements<br/>------------------------------<br/>DPF  Time/Freq Support:<br/>Number of sets: 1<br/>Cumulative     Time (s)       LoadStep       Substep<br/>1              1.000000       1              1</span></pre><p id="5e6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们更进一步，画出一些结果。在下面的脚本中，我们首先设置几个变量来选择结果类型、分量和时间步长(第3–7行)。然后，使用<code class="fe oi oj ok nz b">model.metadata.result_info</code>对象的<code class="fe oi oj ok nz b">available_results</code>属性，我们可以获得结果文件中每个结果类型的结果信息对象(如位移、应力等)。结果信息对象不是实际存储结果数据的地方。它只是一个元数据对象，但是拥有使用操作符检索实际结果的所有信息。首先，我们使用元数据对象的<code class="fe oi oj ok nz b">operator_name</code>属性创建一个操作符，并将其连接到<code class="fe oi oj ok nz b">model.metadata.data_sources </code>，后者将通用操作符与我们的模型对象关联起来。然后，我们使用<code class="fe oi oj ok nz b">time_scoping</code>输入来通过索引选择结果集(在本例中，从典型的基于0转换为基于1)。如果这个结果集中只有一个组件，那么我们通过调用<code class="fe oi oj ok nz b">res_op.outputs.field_container()</code>方法获得所选数据集的fields容器。如果有一个以上的组件，那么我们创建一个新的操作符(<code class="fe oi oj ok nz b">component_selector_fc()</code>)，通过将结果操作符输出连接到gist的第21行的<code class="fe oi oj ok nz b">comp_sel</code>操作符，将它链接到结果操作符。然后我们添加另一个输入来选择组件号(第22行),并通过调用<code class="fe oi oj ok nz b">.outputs.fields_container()</code>方法请求fields容器对象。在我们的<code class="fe oi oj ok nz b">field_container </code>中应该只有1个<code class="fe oi oj ok nz b">field</code>对象，我们可以将它作为列表中的第一项来访问。最后，我们将过滤后的字段传递给<code class="fe oi oj ok nz b">mesh</code>对象上的<code class="fe oi oj ok nz b">plot</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/4cae906f1da3958acb0f4d3ad219be88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AthfRLYZYLsBS6_uF1IA5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PyAnsys DPF位移图在Jupyter笔记本。图片作者。</p></figure><p id="7194" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要更改结果类型、成分或时间步长，只需更改索引参数(<code class="fe oi oj ok nz b">res_idx</code>、<code class="fe oi oj ok nz b">comp_idx</code>或<code class="fe oi oj ok nz b">tf_idx</code>)。如果您查看PyDPF示例，您会注意到有绘制位移的快捷方式，但是我们稍后将使用这种更通用的方法。</p><p id="8f4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PyDPF在背景中使用VTK对象来绘制结果。PyDPF将网格对象转换为VTK非结构化网格，并在绘图前将数组添加到该网格对象中。当我们到达VTK的Dash _时，我们也需要网格对象，所以让我们试着明确地使用它。让我们把它放在一个函数里！</p><p id="8629" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个函数中，我们传入网格区域(<code class="fe oi oj ok nz b">model.metadata.meshed_region</code>)和我们想要绘制的过滤后的字段对象。我们检查字段的位置(网格/节点或元素/单元)，然后将字段数据顺序映射到vtk网格对象中节点/单元的顺序。这是必要的，因为原始字段数据可能有不同于节点/元素顺序的映射/顺序(所以你不能直接将<code class="fe oi oj ok nz b">field.data</code>数组分配给<code class="fe oi oj ok nz b">grid</code>对象！).一旦我们得到分配了结果数组的<code class="fe oi oj ok nz b">grid</code>，我们就可以用<code class="fe oi oj ok nz b">grid.plot(scalars=name)</code>替换<code class="fe oi oj ok nz b">mesh.plot(f0)</code>行。这里的要点是，我们直接用VTK对象(我们将需要Dash_vtk)绘图…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="dece" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">pyDPF Dash应用程序</h1><p id="39c8" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">现在是主菜…</p><p id="f4ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好的，我们有一个脚本可以将结果集过滤到特定的字段(按结果类型、时间和组件)，我们有一个函数可以提取vtk网格对象，并通过适当的范围将该字段分配给它。我们现在要设置Dash应用程序，以便我们可以选择一个内置示例，并选择结果类型(按名称)和时间步长(按时间)以及(如果合适)选择结果的组成部分。听起来像4x <code class="fe oi oj ok nz b">dcc.dropdown</code>组件。我们还将使用<a class="ae lr" href="https://dash-bootstrap-components.opensource.faculty.ai/" rel="noopener ugc nofollow" target="_blank">dash _ bootstrap _ components</a>来使它看起来更漂亮，并添加一些回调函数，这些回调函数遍历所选的<code class="fe oi oj ok nz b">ansys.dpf.core.examples</code>示例来收集下拉菜单的适当选项。为了稳定起见，我们将把实际的绘图放在“绘图”按钮后面。</p><p id="1990" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是带有下拉菜单和绘图按钮的布局的摘录。我使用一个全局变量<code class="fe oi oj ok nz b">APP_ID </code>主要是出于习惯，以便在多页面应用程序的情况下区分id名称。几个下拉菜单缺少<code class="fe oi oj ok nz b">options </code>和<code class="fe oi oj ok nz b">value</code>参数。我们将用回调来填充它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0916" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是填充结果类型、时间步长和组件下拉选项和默认值的两个回调。第一个是在选择示例时触发的。这个回调遍历<code class="fe oi oj ok nz b">metadata.result_info</code>对象中的<code class="fe oi oj ok nz b">available_results </code>,并使用结果类型的名称创建下拉选项。我们还创建了时间步长选项，使用浮点值作为<code class="fe oi oj ok nz b">label</code>，使用整数索引作为<code class="fe oi oj ok nz b">value </code>参数(还记得在笔记本示例中使用的索引吗？我们还发回默认值(最后一个时间步长和第一个结果类型)。</p><p id="a1dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当选择一个结果类型时，触发第二个回调。我们使用结果名称来查找合适的<code class="fe oi oj ok nz b">result_info </code>项(使用<code class="fe oi oj ok nz b">next</code>)。一旦我们有了这些，我们就确定组件的数量，并创建<code class="fe oi oj ok nz b">options</code>、<code class="fe oi oj ok nz b">values</code>，以及下拉列表是否应该是<code class="fe oi oj ok nz b">disabled </code>(对于1个组件的情况)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0d27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是为Dash_VTK返回3D对象的回调函数。当“绘图”按钮被按下时，这个回调被触发。我们使用<code class="fe oi oj ok nz b">example_dropdown </code>和一个全局变量(<code class="fe oi oj ok nz b">dict</code>)获得模型对象，该变量将示例名称(<code class="fe oi oj ok nz b">simple_bar</code>、<code class="fe oi oj ok nz b">msup_transient</code>和<code class="fe oi oj ok nz b">static</code>)映射到它们相应的<code class="fe oi oj ok nz b">ansys.dpf.core.examples</code>对象。我们获得了前面回调中的<code class="fe oi oj ok nz b">result_info </code>对象，但是现在我们获得了<code class="fe oi oj ok nz b">meshed_region </code> ( <code class="fe oi oj ok nz b">mesh</code>)对象。下一部分在笔记本示例中应该看起来很熟悉，除了在我们获得分配了字段的网格对象之后，我们将它转换成Dash_VTK <code class="fe oi oj ok nz b">GeometryRepresentation</code>组件所期望的<code class="fe oi oj ok nz b">mesh_state </code>对象。我们还将色阶范围设置为现场结果的最小值/最大值。这里没有显示一个函数，它只使用一个颜色条创建一个plotly图形。虽然你可以对dash_vtk源代码进行一些编辑，并重新构建javascript(使用node.js和npm)以获得一个scalrabar来与Dash_VTK一起工作(见<a class="ae lr" href="https://github.com/plotly/dash-vtk/issues/52" rel="noopener ugc nofollow" target="_blank">此处</a>)，但我发现创建一个与Dash_VTK具有相同背景的plotly colorbar相当简单。详情见完整项目。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="9345" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这个<a class="ae lr" href="https://github.com/shkiefer/pyAnsys_DPF_dash" rel="noopener ugc nofollow" target="_blank"> GitHub库中看到完整的文件(笔记本和Dash应用程序)。</a>我还包含了一个yml文件，用于通过conda安装所有需要的库。</p><p id="4df1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我确实注意到在切换具有不同数量组件的结果类型时，javascript有些不稳定，例如从<code class="fe oi oj ok nz b">displacement</code> (3个组件)到<code class="fe oi oj ok nz b">stress</code> (6个组件)。我尝试了一些东西，但是钻研javascript (react_VTK)超出了我的专业范围。如果您看到一个错误，您可以刷新页面并重新开始。第一个情节总是有效的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e74a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">酷，但是…..为什么？</h1><p id="2689" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">好问题…我相信当目标用户不是模拟专家时，将pyAnsys打包成web应用程序是最强大的。否则，您可以只使用笔记本界面、工作台或MAPDL。我能想到几个后处理在web应用程序中有用的例子:</p><ol class=""><li id="4dc9" class="om on iq kx b ky kz lb lc le oo li op lm oq lq or os ot ou bi translated">一个结果文件数据库，其中的结果文件将与一些额外的元数据存档，并可以提出来审查非常具体的结果(如压力)</li><li id="b8ac" class="om on iq kx b ky ov lb ow le ox li oy lm oz lq or os ot ou bi translated">存储基本“单位”分析，可使用叠加进行缩放/组合，叠加由web应用程序中提供的参数控制</li></ol><p id="fd5b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢你能走到这一步。我希望你能在这里找到有用的东西。在以后的文章中，我将介绍如何将PyAnsys pyMAPDL库集成到Dash应用程序中，这可能会更有用，因为Dash应用程序可以作为一个非常受限的预处理器。它将包括解决和提取一些结果。</p></div></div>    
</body>
</html>