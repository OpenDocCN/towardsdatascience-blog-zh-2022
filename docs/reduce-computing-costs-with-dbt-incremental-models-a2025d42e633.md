# 使用 dbt 增量模型降低计算成本

> 原文：<https://towardsdatascience.com/reduce-computing-costs-with-dbt-incremental-models-a2025d42e633>

## 它们是什么以及如何实现它们

![](img/b1c7e907a1dee13761bb722a38993ec9.png)

林赛·亨伍德在 [Unsplash](https://unsplash.com/s/photos/stairs?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

dbt 现在在数据转换方面非常流行。而且，这是有原因的！dbt 使编写模块化代码变得容易，彻底改变了编写数据模型的传统过程。您不再需要一遍又一遍地重复相同的代码行，使您的代码难以阅读并且运行缓慢。

[dbt](/what-is-dbt-a0d91109f7d0) 有许多令人敬畏的特性，使它成为最好的数据转换工具。宏和包是我在数据模型中使用的两个工具。虽然，我最喜欢的一个特性是创建增量模型的能力，但这一点没有被充分提及。

围绕增量模型有很多混乱。我应该在什么时候使用它们？我该怎么写呢？

在本文中，我将讨论它们是什么，为什么您想要使用它们，以及如何使用 dbt 成功地编写一个。还有一个为我所有的雪花用户发布的新特性，将使编写增量模型更加容易。

# 什么是增量模型？

传统的数据模型将在每次运行时针对整个可用数据集执行代码，替换之前存在的整个数据集。**增量模型将只对整个可用数据集*执行一次*，即第一次运行**时。然后，在接下来的运行中，它将只对自上次运行以来的新数据执行。

这通过允许 dbt*插入*和*更新*可用的新记录来实现。与传统的数据模型不同，增量模型只转换尚未转换的数据。但是，如果记录已经更新，它将转换该数据记录以匹配更新。

# 增量模型的优势

增量模型减少了数据模型的运行时间。当您的运行时间减少时，数据仓库的性能会提高，您可以节省计算成本。这是一个全面的胜利！

当您将增量模型实现到您的 dbt 项目中时，您将会注意到您的模型运行所需的时间要少得多。在实现增量具体化之前，我的一些 dbt 数据模型每天早上需要运行 3 个多小时。这并不理想，原因有二:

*   你是在为仓库在雪花网上的时间付费
*   您的业务团队希望在开始工作时就能获得这些数据

在重写 dbt 数据模型以使用增量具体化之后，许多数据模型只需要 40 分钟左右就可以运行。这不仅降低了成本，而且增加了信心，当团队需要时，您的数据模型将是最新的。

# 使用 dbt 的增量物化

物化[引用](https://docs.getdbt.com/docs/building-a-dbt-project/building-models/configuring-incremental-models)数据定义语言(DDL)在你选择的数据仓库中创建等价的模型。使用增量具体化，dbt 将在您的特定仓库解决方案中创建一个增量模型的等价物。

增量模型目前被创建为数据仓库中的视图。因此，**您只能对 select 语句使用增量具体化，而不能使用复杂的聚合或连接**。总是建议在数据模型的最简单层使用增量具体化。

为了将 dbt 模型指定为增量模型，只需将它包含在 SQL 文件的顶部:

```
{{
    config(
        materialized='incremental'
    )
}}
```

为了让 dbt 构建一个增量模型，您还需要在这个文件中提供另外两个配置:

*   如何过滤数据
*   唯一性约束(可选)

## 过滤 dbt 模型

dbt 需要一种方法来知道数据集中哪些行是新的。如果它没有一条数据可以过滤，那么它就不知道如何区分旧数据行和新数据行。记住，**增量模型只转换以前没有转换过的数据**，除非它被更新。

`**is_incremental()**`宏用于过滤您的 dbt 模型。如果你不熟悉 dbt 宏是如何工作的，你可以在这里阅读更多的。在宏中，您可以指定一个只希望在增量运行时运行的筛选器。这意味着这个过滤器**不是在您的数据模型第一次运行时在您的 SQL 代码中编译的**。它只在**不是**第一次运行时编译。

您的`is_incremental()`宏中的过滤器应该是一个`WHERE`语句，它基于您的数据集中的时间戳列进行过滤。

```
{% if is_incremental() %}where event_created_at > (select max(event_created_at) from {{ this }})

{% endif %}
```

`{{this}}`简单来说就是指回数据表本身。因此，您实际上是在说，“*对这个数据模型最后一次运行*之后创建的新数据运行这个转换”。

## dbt 模型中的唯一性约束

如果您没有使用行可以更新的数据表，那么这个步骤是不必要的。只有当数据表允许行随着它们的变化而不断更新时，才需要使用这种方法。

例如，如果有一个表显示在给定时间用户的购物车中有什么，您将希望指定一个惟一性约束，以便 dbt 知道何时更新该行。购物车中的商品会不断变化，您希望在您的增量模型中捕捉这些变化。

指定唯一性约束可以防止主键重复。为了添加它，您只需在前面定义的配置中指定它。

```
{{
    config(
        materialized='incremental',
        unique_key='order_line_id'
    )
}}
```

在这里，`order_line_id`充当我们的数据表的主键。如果昨天的数据模型和今天的数据模型中存在唯一的`order_line_id`，新的数据行将替换旧的数据行。如果我们没有指定唯一性约束，那么就会有两行数据，昨天的和今天的，具有相同的主键。

# 配置您的增量模型

现在，我们来讨论最难的部分。如何将我的 dbt 模型重新配置为增量模型？这就是事情变得令人困惑的地方。数据模型越复杂，在 dbt 中利用增量具体化就越复杂。你真的需要把你的模型分解成几个部分。

记住，增量模型目前只能使用`SELECT`语句运行。我的第一个建议是过滤您想要在模型中使用的数据。因此，如果您在较大的增量模型中使用几个不同的表，那么您会希望将它们分割成不同的增量模型，用于所使用的每个数据表。然后，您将在每个模型中指定具体化配置、过滤器和惟一性约束。

虽然这看起来是多余的，但这是目前运行增量具体化的唯一方法。幸运的是，雪花最近宣布他们将推出物化表。这将允许更复杂的操作，如物化模型中的连接和聚合。[敬请期待](https://madisonmae.substack.com/)发布的一篇关于如何使用 dbt 和雪花配置物化表的文章！

# 调试物化模型

最后，让我们讨论一下如何调试物化模型。由于需要验证，当您第一次编写它们时可能会有压力。我的数据模型看起来像预期的那样吗？这些值是否与模型未具体化时的值相比较？

为了进行调试和验证，您可能需要刷新整个表，就好像它不是增量表一样。您可以使用`dbt full-refresh`命令来完成此操作。这将刷新您的整个表，并像第一次运行模型一样运行它。

在最初的几天里，并行运行您的模型和增量模型的完全刷新可能会有所帮助，以确保它们相匹配。通过允许您相互验证模型，这将有助于最小化未来的数据灾难。如果您有一个已经投入生产一段时间的数据模型，并且您知道它是可靠的，这将是特别强大的。比较它们会让你对自己的改变充满信心。

# 结论

令人惊讶的是，一旦构建了初始模型，您就可以利用 dbt 中的所有特性。我不断地寻找新的方法来提高模型的运行时间、可读性和质量！将增量具体化到其中只是不断改进数据转换的众多方法之一。

如果您想了解如何使用免费的 dbt 软件包来防止数据丢失，请点击[此处](/prevent-data-loss-with-this-free-dbt-package-a676c2e59c97)。如果你想掌握 dbt 中的数据透视表，点击[这里](/mastering-pivot-tables-in-dbt-832560a1a1c5)。

欲了解更多关于分析工程、现代数据堆栈和 dbt 的信息，[订阅我的免费每周简讯](https://madisonmae.substack.com/)。