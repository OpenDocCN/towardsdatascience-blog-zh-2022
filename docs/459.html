<html>
<head>
<title>Predicting future values with RNN, LSTM, and GRU using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch预测RNN、LSTM和GRU的未来值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predicting-future-values-with-rnn-lstm-and-gru-using-pytorch-d9ef50991ec7#2022-01-16">https://towardsdatascience.com/predicting-future-values-with-rnn-lstm-and-gru-using-pytorch-d9ef50991ec7#2022-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b0c0590bec81038a7d1cafb9905b3229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Gw4BSgx6SbY43ckq"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">恩库鲁列科·乔纳斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""><h1 id="170c" class="pw-post-title jh ji jj bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf bi translated">使用PyTorch预测RNN、LSTM和GRU的未来值</h1></div><div class=""><h2 id="f4de" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">将算法用于预测未来价值</h2></div><p id="de8d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我之前的博文中，我帮助你开始使用PyTorch构建一些递归神经网络(RNN)，比如香草RNN、LSTM和GRU。如果您还没有看过，我强烈建议您先看一下，因为我将基于我在那里提供的一些概念和代码进行构建。同样，在这篇文章中，我也将坚持使用相同的数据集，<a class="ae jg" href="https://www.kaggle.com/robikscube/hourly-energy-consumption" rel="noopener ugc nofollow" target="_blank"> PJM的每小时能耗</a>。上次我们停止了对测试集进行预测，并根据实际值评估模型性能。尽管有一个好的开始，我们还是错过了拼图的一部分。</p><p id="66ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们被要求对没有实际值的时间步长进行预测，该怎么办？这通常是时间序列预测的情况；我们从历史时间序列数据开始，预测接下来会发生什么。这篇文章将向你展示如何使用我们之前创建的RNN、LSTM和GRU模型来预测未来的价值。所以，不像那一个，这将是一个相对较短的一个——我希望。</p><h1 id="dea0" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">使用日期时间功能进行预测</h1><p id="2e14" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">为了生成对未来的预测，我向类<em class="mr">优化</em>添加了一个新函数，该函数与方法<em class="mr">评估</em>一样，采用<em class="mr">预测_加载器</em>、<em class="mr">批量_大小</em>和<em class="mr">n _特征</em>，并生成对未来的<em class="mr">n _步数</em>的预测。与<em class="mr">评估</em>不同，生成的预测不受数据帧中实际值的约束，而是受作为输入给出的步数的约束。当然，这只是一种方法，但是你也可以通过限制你的预测日期来尝试一下。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="784f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据我们正在处理的数据集的频率，我们可以选择每小时、每天或每月进行预测。一种方法是将这些参数手动传递给我们的预测函数。嗯，我想这还不够有趣。我们还可以编写一个简单的函数来获取数据集的开始日期和时间频率。它只是获取最后一个<em class="mr"> DateTimeIndex </em>值，并加上前一个索引之间的时间间隔。至于频率，类似地，我们将返回这两点之间的时间间隔。使用这两个值，<em class="mr"> start_date </em>和<em class="mr"> freq </em>，我们可以生成跨越预测期的<em class="mr"> DateTimeIndex </em>。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1688" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像我们之前对历史数据进行预测一样，我们现在将使用<em class="mr">日期时间</em>要素、一键编码、循环要素和节假日来生成要素。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi my"><img src="../Images/0ccaa272ecfd72bb3f482ee0f51d8d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ra4XbSGS3Dc9dcPtpcZQA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><p id="d398" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，是时候为预测值创建一个数据加载器实例了。你可能已经在想了，<em class="mr">“没有实际值，我们到底要怎么填写目标值(y)。”</em>我找到了一个快速解决问题的方法，只需将所有预测指数的<em class="mr">值</em>列设置为0，并忽略后面阶段的指数。</p><p id="9d00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您检查类<em class="mr">优化</em>中的函数，名为<em class="mr"> forecast_with_predictors，</em>您可能会注意到我忽略了DataLoader实例的目标值部分。而且，公平地说，我不确定这是否接近最佳实践，所以如果您能想到更优雅的方法来解决它，请随时联系我。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0a61" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们调用<em class="mr">优化</em>的<em class="mr">forecast _ with _ predictors</em>函数来生成预测。如您所料，该函数返回根据您在上一步中选择的变换缩放的值。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="19d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们需要将缩放后的预测值逆变换为原始目标值，就像我们之前使用<em class="mr"> inverse_transform </em>所做的那样</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e010ac64f7d63608334664311bc40818.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*mXSSs6gzgaGnX_CavJvAxw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><p id="e69f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将使用Plotly包来绘制预测值，如下所示。正如你在下面看到的，这可能不是最好的预测。从这里开始，您可以通过许多方式来探索如何改善结果，无论是功能工程、超参数调整还是选择完全不同的模型。看你的了！</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi na"><img src="../Images/d54f815eb335782fcac948b817f18fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TKsjFC3BR8gY1fE2DgZ1lA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/5c02b356ddf28c9cb5bb46f7ffda083c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oimzFvgPUkPKV6BPp_-8yg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><h1 id="773d" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">具有滞后特征的预测</h1><p id="8ba9" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">用滞后观测值预测时间序列，或简称滚动时间序列，需要一种稍微不同的方法。与具有日期时间特征的时间序列不同，我们不能简单地填充未来的滞后时间观测值。相反，我们需要用每个新的预测更新下一步，并滚动时间窗口。所以，如果这部分看起来或多或少像是一个入门级的CS编程练习，相信你的直觉。</p><p id="5b34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，我们将另一个方法<em class="mr"> forecast_with_lag </em>添加到<em class="mr">优化</em>类中，以使用滚动逻辑生成预测。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7703" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mr"> DataLoader </em>类表示数据集上的Python iterable。因此，下面一行通过迭代整个数据集来帮助获得一个<em class="mr">数据加载器</em>实例中的最后一个时间步长。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="ea4a" class="nh lv jj nd b gy ni nj l nk nl">*_, (X, y) = test_loader_iter</span></pre><p id="d65f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面一行将张量的第二维值移动一位，这样张量<code class="fe nm nn no nd b">[[[x1, x2, x3, ... , xn ]]]</code>就变成了<code class="fe nm nn no nd b">[[[xn, x1, x2, ... , x(n-1)]]]</code>。</p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="0747" class="nh lv jj nd b gy ni nj l nk nl">X = torch.roll(X, shifts=1, dims=2)</span></pre><p id="647f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的行从3D张量的最后一个维度中选择第一个元素，并将该项设置为存储在<em class="mr">NumPy</em>T4】ndarray(<em class="mr">yhat</em>)，<code class="fe nm nn no nd b">[[xn+1]]</code>中的预测值。然后，新的输入张量变成<code class="fe nm nn no nd b">[[[x(n+1), x1, x2, ... , x(n-1)]]]</code></p><pre class="ms mt mu mv gt nc nd ne nf aw ng bi"><span id="11e7" class="nh lv jj nd b gy ni nj l nk nl">X[..., -1, 0] = yhat.item(0)</span></pre><p id="c8f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像我们之前做的那样，我们可以为带有滞后观测值的时间序列生成预测，并绘制预测的未来值。为了避免重复，我将只分享几个时代的训练后的一些样本结果。但是你可以看看我在这篇文章中分享的Google Colab笔记本是如何做到的。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/1a0f6834cea0a6c63457c9d562fe064c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8PvjOGY6t8ZN2ibujqN8Kg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/882b4e3eff4573e519a3a76989bd7c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*qm56H3Z8-ni35KKHFaE71A.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片作者。</p></figure><p id="4780" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据模型预测的值进行多次单步预测可能会在短期内产生合理的结果。随着预测周期的增加，预测变得越来越不准确，因此也越来越不适合预测。</p><p id="a358" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，为了进行多次单步预测并在每次预测后更新输入，我们必须一个接一个地遍历数据集，就像我们在测试集上遍历for循环一样。毫不奇怪，这使我们失去了矩阵运算和小批量训练为我们提供的所有计算优势。</p><p id="fe48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，我非常怀疑基于滚动的预测方法是一个好的实践。此外，<em class="mr"> LSTM </em>和<em class="mr"> GRU </em>可以很好地将过去的观测结果带到下一次观测，而不会遇到<em class="mr">递减/爆炸梯度</em>的问题。</p><h1 id="4965" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">最后的话</h1><p id="b980" class="pw-post-body-paragraph ky kz jj la b lb mm kk ld le mn kn lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我没想到我会花这么长时间来跟进我的上一篇文章，但我很高兴我最终做到了。我希望这篇文章能帮助你更好地理解如何使用两种不同的方法来预测未来值。如果有任何你同意或不同意的地方，请不要犹豫评论或联系我。</p><p id="3398" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，这里有一个<a class="ae jg" href="https://colab.research.google.com/drive/1sOQjtErD70IeV2eJCBysQwi0DQKIzvU1?usp=sharing" rel="noopener ugc nofollow" target="_blank">链接</a>到Google Colab笔记本，如果你想看完整的带有新预测方法的笔记本。在下一篇文章中，我计划回顾一些正则化技术及其在时间序列预测中的应用。但是我们会看到它如何发展。</p></div></div>    
</body>
</html>