<html>
<head>
<title>8 Essential Python Techniques for Data Engineers and Analysts (with code samples)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据工程师和分析师的8种基本Python技术(带代码示例)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-essential-python-techniques-for-data-engineers-and-analysts-with-code-samples-5915b31ce724#2022-01-17">https://towardsdatascience.com/8-essential-python-techniques-for-data-engineers-and-analysts-with-code-samples-5915b31ce724#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="b309" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">面向数据工程师和分析师的8种基本Python技术(带代码示例)</h1></div><div class=""><h2 id="a1c6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些是我重复使用最多的Python代码片段</h2></div><p id="8f7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使是最有经验的程序员也要用谷歌搜索。</p><p id="28bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我重新搜索我一直使用的简单代码行，只是为了快速提醒语法。从这个意义上说，我真的是在为自己写这篇文章。这些是我作为数据通才反复使用的最常见的Python代码。</p><p id="a781" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(以下所有示例都是使用Python 3.6或更高版本完成的)</p><h2 id="2027" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">将数据库中的数据查询成Pandas数据帧或CSV文件</h2><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/camw81/1cca77c0878ded60b2c1c0d839649a7a" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/camw 81/1 CCA 77 c 0878d 60 B2 C1 c 0d 839649 a 7a</a></p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="1bb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当SQL不足以进行分析或复杂的数据转换时，Python可能是答案。但是在你争论任何数据之前，你必须把数据放到内存中，这样你就可以用它做一些事情。如果您的数据库在MS SQL Server上，使用PYODBC如果您在Postgres上，使用PSYCOPG2，您可以使用Python轻松地编写查询和提取数据。从那以后，只需要将数据转换成易于使用的格式。为此，我喜欢熊猫。将查询数据放入Pandas非常简单，只需将列表转换成CSV，然后使用pandas <em class="mq"> read_csv </em>函数。或者，如果需要的话，您可以将read_csv构建到您的<em class="mq"> run_sql </em>函数<em class="mq"> </em>中。</p><h2 id="8e7e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">发送带有完整错误代码输出的电子邮件警报</h2><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/camw81/c791a3dc992462059accce0562225ffc" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/camw 81/c 791 a 3直流992462059接入0562225ffc </a></p></figure><p id="e896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">监控自动化作业(cron或其他)中的错误对于运行数据管道或其他代码至关重要。我广泛使用电子邮件提醒，当我在自动节奏上运行的任何脚本中断时提醒我。</p><p id="015e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了快速找到问题的根源，我也非常喜欢在我的电子邮件中收到Python的完整回溯错误消息，这样我就能确切地知道在我修复脚本时要寻找什么。traceback包允许您使用<em class="mq"> traceback.format_exc() </em>来获取这些信息，然后将其作为一个字符串放入您的电子邮件中。</p><p id="6fd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用代码片段的最佳方式实际上是将函数调用到另一个脚本中，在该脚本中有您想要监控的代码。将您的代码包装在一个<em class="mq"> try/except </em>语句中，然后在出现异常时执行<em class="mq"> send_alert </em>函数，将完整的错误报告发送到您的电子邮件中。</p><p id="a705" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用此代码之前，您需要有一个虚拟的电子邮件帐户设置。Gmail是最简单的。对于本例，请确保您打开了“不太安全的应用程序访问”(见下面的截图)。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="ms mt di mu bf mv"><div class="gh gi mr"><img src="../Images/b443e94b3de85454ab217d7846e495f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRtG_vuDrfRD2qP0UhT6fA.png"/></div></div></figure><h2 id="fc0d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">将CSV文件写入数据库(Postgres或SQL Server)</h2><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/camw81/ff53586ad228f2f624522ba10c9e5930" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/camw 81/ff 53586 ad 228 F2 f 624522 ba 10 C9 e 5930</a></p></figure><p id="a6e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是很多代码——但它是我每天使用的最重要的技术之一，用于从任何来源获取数据并将其推入数据库。上面的例子最适合使用MS SQL Server——特别是Azure SQL数据库和Azure Blob存储。我将<a class="ae mi" href="https://gist.github.com/camw81/6be60842c67d9ae3e4610781d82c91ac" rel="noopener ugc nofollow" target="_blank">把链接放在这里</a>到另一个你可以用于POSTGRES数据库的例子——这个例子稍微简单一点。</p><p id="71f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里的基本思想是通过几个步骤将数据从CSV文件导入数据库:</p><ol class=""><li id="b650" class="my mz it kk b kl km ko kp kr na kv nb kz nc ld nd ne nf ng bi translated">将CSV文件推入blob存储。</li><li id="320c" class="my mz it kk b kl nh ko ni kr nj kv nk kz nl ld nd ne nf ng bi translated">通过在SQL数据库上创建外部数据源，将目标数据库表绑定到blob存储。</li><li id="fe45" class="my mz it kk b kl nh ko ni kr nj kv nk kz nl ld nd ne nf ng bi translated">创建一个临时表，您将在其中插入CSV文件。</li><li id="08b9" class="my mz it kk b kl nh ko ni kr nj kv nk kz nl ld nd ne nf ng bi translated">将CSV文件批量插入到临时表中</li><li id="ef57" class="my mz it kk b kl nh ko ni kr nj kv nk kz nl ld nd ne nf ng bi translated">最后，使用合并标准将临时表合并到最终表中。</li></ol><p id="2987" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有无数种方法可以让数据到达你想要的地方。这是我几乎每天都依赖的方法。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/bc52a79d2d6f3a5f713bfb64ca183bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vpenph-BHUhoQmWw5WUImA.jpeg"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated">图片由<a class="ae mi" href="https://www.pexels.com/@thisisengineering?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">this isensegining</a>来自<a class="ae mi" href="https://www.pexels.com/photo/extreme-close-up-photo-of-codes-on-screen-3861976/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a></p></figure><h2 id="8fa6" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">从REST API取回多页数据</h2><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/camw81/b5c7234204c977bb5296b23933321301" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/camw 81/b5 c 723204 c 977 bb 5296 b 2393331301</a></p></figure><p id="025f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我需要创建一个与API集成的ETL管道时，我会使用上面两段代码的一些迭代。许多API使用异步请求(您发出一个代码请求，然后在后台等待它完成)，我也将它包含在示例中。为了让代码工作，您需要为您正在使用的API交换端点URL和特定的分页键。如果API要求使用client_id/client_secret进行认证，那么您还需要遵循一个认证过程来获取访问令牌(我在<a class="ae mi" href="https://medium.com/me/stats/post/edcc8d6441b1" rel="noopener">的另一篇文章</a>中有一个这样的例子)。一旦完成了这些，上面的代码示例将成为构建集成的良好起点。</p><h2 id="ab8e" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">为数据库插入清理和格式化REST API JSON结果</h2><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div><p class="me mf gj gh gi mg mh bd b be z dk translated"><a class="ae mi" href="https://gist.github.com/camw81/eb92fc23b690967237059adff254f4df" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/camw 81/b5 c 723204 c 977 bb 5296 b 2393331301</a></p></figure><p id="aa25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我编写的几乎所有API集成，我都使用上述代码片段的变体。这种方法假设数据将以JSON格式返回——这意味着它应该可以处理大约75%的API数据请求。格式化后，这个脚本将把JSON数据结构组织成表格格式(列表的列表),然后可以很容易地插入到CSV中——准备好推送到DB。可能有一个更简单的方法来做到这一点，但这是我多年来一直使用的方法，它还没有让我失望。</p><h2 id="1091" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">清理CSV文件以插入数据库</h2><pre class="lx ly lz ma gt nn no np nq aw nr bi"><span id="02b3" class="le lf it no b gy ns nt l nu nv">import pandas as pd</span><span id="68c7" class="le lf it no b gy nw nt l nu nv">write_file = '~/directory/filename.csv'</span><span id="6949" class="le lf it no b gy nw nt l nu nv">df = pd.read_csv(write_file)</span><span id="bd2f" class="le lf it no b gy nw nt l nu nv">df = df.replace({‘\$’:’’}, regex = True)<br/>df = df.replace({‘%’:’’}, regex = True)<br/>df = df.replace({‘\,’:’’}, regex = True)<br/>df = df.replace({“‘“:’’}, regex = True)<br/>df = df.replace({“nan”:’’}, regex = True)</span></pre><p id="ac36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个简单的方法，但是它为我节省了无数时间来清理混乱的数据源——比如手动创建的CSV文件。你们中的许多人可能遇到过这样的情况，有人希望将OneDrive或GDrive文件夹中的CSV文件推送到数据库中。问题是，这些文件的格式通常会使数据库插入变得很麻烦。幸运的是，Pandas内置了<em class="mq"> replace </em>函数，只需一行代码就能清除特定字符。</p><p id="75a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的文件包含带有$或%或其他符号的数字，并且您希望将它们作为数字类型推入数据库，那么这个代码片段非常有用。用replace函数和chosen符号清理数据将会清除所有这些数据，使您使用的任何数据库都可以轻松地将数据作为数字类型读取。</p><h2 id="1931" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">创建结束日期和开始日期</h2><pre class="lx ly lz ma gt nn no np nq aw nr bi"><span id="2d83" class="le lf it no b gy ns nt l nu nv">import datetime </span><span id="5c23" class="le lf it no b gy nw nt l nu nv">#### Set todays date ####<br/>today = datetime.datetime.now().date()</span><span id="8345" class="le lf it no b gy nw nt l nu nv">#### Create to_date by adding or subtracting dates from today's date<br/>to_date = today-datetime.timedelta(1) </span><span id="9446" class="le lf it no b gy nw nt l nu nv">#### Create your from date by subtracting the number of days back #### you want to start<br/>from_date = today-datetime.timedelta(7)</span><span id="7ae9" class="le lf it no b gy nw nt l nu nv">#### Create timestamp of today's date using desired format<br/>todaysdate = datetime.datetime.strftime(datetime.datetime.now(),'%Y-%m-%d')</span></pre><p id="9cd8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数API在请求数据时都需要日期参数。该示例使用Python的datetime包，通过。timedelta()函数。我一直使用它来根据脚本运行的日期/时间，在我的脚本中构建自动的到/从日期计算。</p><h2 id="727f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">分块处理大的Python列表</h2><pre class="lx ly lz ma gt nn no np nq aw nr bi"><span id="f1c1" class="le lf it no b gy ns nt l nu nv">def chunker(seq, size):<br/> return (seq[pos:pos + size] for pos in range(0, len(seq), size))</span><span id="e8c4" class="le lf it no b gy nw nt l nu nv">for group in chunker(order_items,100):<br/>      for item in group:<br/># Do something to each group</span></pre><p id="6029" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个我经常使用的小函数，用来把非常大的列表分块。这对于清理和格式化JSON数据(如上所示)非常有用，因为有时您会从API中提取大量数据，并希望对其进行处理，然后以可管理的块的形式将其推送到DB中。<em class="mq"> chunker </em>函数允许你选择一次要处理多大的块，然后在每个块上运行你的代码。这个例子使用了一个100个条目的块，但是您可以根据需要调整这个数字。</p><p id="e8f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我在日常数据工程和分析工作中一直使用的8种Python技术。希望其中一些能让您的数据生活更轻松。</p><p id="11e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢这篇文章，你可以在这里找到我的其他作品<a class="ae mi" href="https://medium.com/@camwarrenm" rel="noopener"/>。你也可以在推特上关注我<a class="ae mi" href="https://twitter.com/camwarrenm" rel="noopener ugc nofollow" target="_blank"> @camwarrenm </a></p></div></div>    
</body>
</html>