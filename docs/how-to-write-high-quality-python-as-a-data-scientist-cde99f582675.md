# 作为数据科学家如何编写高质量的 Python

> 原文：<https://towardsdatascience.com/how-to-write-high-quality-python-as-a-data-scientist-cde99f582675>

## 学习需求技能！

## 你应该学习的一套具体技能！

![](img/145f19a7d536d75eca6f5b758d415138.png)

照片由[西格蒙德](https://unsplash.com/@sigmund?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

# 您的旅程概述

1.  [为什么高质量的代码很重要](#bada)
2.  没有风格，你什么都不是
3.  [变量名——比听起来更难！](#7e18)
4.  [模块化你的代码](#b99c)
5.  [设计原则？没听说过！](#3626)
6.  [代码质量的进一步资源](#f712)
7.  [包装](#d56d)

# 1 —为什么高质量的代码很重要

当作为一名数据科学家起步时，人们会听到关于代码质量的相互矛盾的故事。有人说代码质量真的很重要。其他人说，数据科学家不是软件工程师，并采用以下口头禅:

> 谁在乎呢。如果成功了就成功了，对吧？

当面对关心或不关心代码质量的选择时，很容易选择阻力最小的途径。学习编写高质量的代码需要时间和精力。为什么不干脆忽略代码质量，少一件担心的事情呢😌

嗯，正如你可能从这篇博文的标题中怀疑的那样，我在这里告诉你数据科学家的**代码质量实际上很重要**。实际上相当多！这里有三种情况，高质量的代码可以节省你无数的时间:

*   如果代码质量不好，错误和可疑的边缘情况很容易被忽视。这导致后来耗时的错误修复，最糟糕的是，生产失败。高质量的代码可以让你尽早失败，快速失败。
*   当新人开始一个项目时，他们必须了解代码库是如何工作的。数据科学和软件工程都是如此。当代码随意编写时，入职流程会变慢。代码的某些部分将是神秘的，除了编写代码的人之外，其他任何人都无法真正理解。甚至对于编写代码的人来说，几个月后这可能会变得毫无意义。高质量的代码是**未来可以理解的**。
*   假设你有一个非常成功的数据科学项目。要求您扩展项目以满足不断增长的需求。通过数据管道的数据量和数据速度将会更高。如果你的代码很糟糕，那么事情可能不像看起来那么简单。当代码具有高质量时，应该可以更顺利地扩展到新的环境。高质量的代码**可以扩展到新的情况**。

希望您现在已经确信高质量的代码是有用的。然而，学习编写高质量的代码是一个渐进的过程。你的代码质量在今天和明天之间不会有很大的变化。没关系。如果你努力改进，那么从长远来看，你的劳动成果将会被所有人看到。

我建议你采取这样的心态:高质量的代码是你引以为豪的东西。几乎每个杰出的作家都为自己的作品感到自豪。同样，作为一名数据科学家，你应该为你的代码感到自豪。它是你创造的东西。它是传递价值的东西。因此，代码应该是高质量的。就这么简单。

在这篇博文中，我将向您展示一些用 Python 编写高质量代码的要点。把博客文章看作一个开始，而不是一幅完整的图画。最后，我会给你一些很酷的资源，它们可以帮助你在编写代码的道路上走得更远🔥

# 2 —没有风格你什么都不是

## 问题是

在大多数编程语言中，有许多方法可以解决同一个问题。这鼓励了创造力和解决问题的新方法。但是，也有看似无限的方法来完成以下任务:

*   选择函数定义中的参数之间是否有空格。你应该写一个函数作为`def my_function(a, b)`或者`def my_function(a,b)`或者`def my_function( a, b )`。
*   函数名应该怎么写？也许就一个字`def myfunction(a, b)`？也许在**`def my_function(a, b)`蛇案中？或者也许在**骆驼案**T5？或者也许**帕斯卡-凯斯**T6？**

**对于每一行代码，都有这样的考虑。如果您对所做的选择采取随机行动，您的代码会变得像这样混乱:**

```
def MyFUNCTION( a,b) :
  return a+b
```

**呸！那又怎样？你的公司是否应该召开内部会议，让你了解每个案例应该如何处理？听起来非常无聊。**

## **解决方案**

**不要害怕！在 Python 中有 PEP8。这是官方建议的代码风格约定。关于 PEP8 的精彩摘要，你可以看看肯尼斯·雷茨的时尚版。**

**每个 Python 开发者都应该(除非你的公司有自己的风格指南)遵守 PEP8。这一开始看起来可能有点麻烦。相反，一旦你接受了 PEP8 作为大多数风格决策的权威，你就可以把精力集中在代码的其他方面。您现在不需要考虑上面代码片段的正确风格版本。正确的格式是:**

```
def my_function(a, b):
    return a + b
```

**仍然有大量的决定留给代码的作者。你应该使用[类型提示](/modernize-your-sinful-python-code-with-beautiful-type-hints-4e72e98f6bf1)来指示参数的数据类型吗？您可能应该编写一个 docstring 来解释该函数的作用。逻辑怎么实现还是 100%看你。你根本不需要花精力去考虑风格的选择。**

**我建议你花 10-15 分钟浏览一下 [PEP8 风格指南](https://pep8.org/)以获得一些改进。当你不确定具体的选择时，你可以查阅 PEP8。**

## **自动代码格式化程序**

**还有像 [Black](/tired-of-pointless-discussions-on-code-formatting-a-simple-solution-exists-af11ea442bdc) 这样的自动代码格式化器，它会自动为你格式化代码。这些太棒了！但是，你要知道，它们是有局限性的。**

**举个例子，PEP8 建议用单词`Error`结束 Python 中的一个自定义异常类。因此，表示数据处理错误的类的开头应该写成例如**

```
class DataProcessingError(Exception):
---
```

**这是像 Black 这样的自动格式化程序无法解决的问题。无论如何，使用像 Black 这样的自动格式化程序。但是一定要记住 PEP8 的大部分内容。**

## **但是我不想！**

**![](img/f63006beb2bcb174bd80c04d0ed6e6d1.png)**

**[马太·亨利](https://unsplash.com/@matthewhenry?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片**

**有些读者会认为代码格式和代码风格不重要。如果你真的看不到 PEP8 的重要性，那么这是完全正确的。要知道，如果你不坚持你的代码，很多人会认为你的代码质量很差。格式糟糕的代码会让人产生期望，就像充满拼写错误的邮件一样。**

# **3 —变量名—比听起来更难！**

**用 Python 命名变量、函数、类、模块和包是一项艰苦的工作。事实上，菲尔·卡尔顿有以下名言:**

> **计算机科学只有两个硬东西:缓存失效和事物命名。—菲尔·卡尔顿**

**幸运的是，大多数数据科学家不必处理[缓存失效](https://en.wikipedia.org/wiki/Cache_invalidation)。然而，你被事物的命名所困扰。Python 包和模块应该有简洁的全小写名称。我们来讨论一下如何给我们的宝贝起个好名字；*变量*、*函数*和*类*。**

## **简单的惯例**

**有几个简单的惯例，一个人应该永远遵守。**

**首先，**永远不要**覆盖内置。例如，创建以下变量可能很有吸引力:**

```
a = 5
b = 2
min = 0
if a < b:
    min = a
else:
    min = b
```

**上面的代码用变量`min`覆盖了内置函数`min()`。现在，如果你试图使用内置的`min()`函数，你的程序就会崩溃。引用教父的话，“看看他们是如何屠杀我的孩子的！”😧**

**其次，对于变量、函数和类，有一些 PEP8 约定你应该遵守。变量名和函数名都应该小写，不同的单词用下划线隔开:**

```
my_variable = 5def my_function(a, b):
   return a + b
```

**如果希望一个变量在整个程序中保持不变，那么可以用大写字母来表示:**

```
MY_NONCHANGING_VARIABLE = 5
```

**对于类，它们的名称应该用大写的单词连接起来，如下所示:**

```
class MyAwesomeClass():
---
```

**上面对变量名的具体选择并没有提供很多信息。这是我们现在要讨论的命名事物的困难部分。**

## **硬性主观性**

**命名事物的困难之处在于不遵循上面描述的惯例。困难的部分是选择以简洁的方式表明实体是什么(对于变量和类)或者它是做什么的(对于函数)。以下是我想强调的一些准则(适用于变量):**

*   ****仔细挑长度:**变量名不能太短也不能太长。如果变量名太短，你最终会使用不是每个人都能理解的缩写。你能说出变量`c = 7`或`vprice = 5`代表什么吗？断章取义，很明显这些变量名有多烂。但是通过编写:`count_of_how_many_steps_our_pipeline_has = 7`和`variance_of_the_column_price_in_our_dataset = 5`，它们也可以扩展得太长。现在可以理解，但是读起来就是噩梦。尝试找到一个合适的中间地带:`pipeline_steps = 7`和`variance_price = 7`怎么样？**
*   ****不要提到数据类型:**将变量的数据类型隐藏在名称中往往很有诱惑力。我们很多人都有把熊猫称为数据帧的罪过。这个想法是，通过将`df`作为**数据帧的缩写，**可以向读者表明这是一个数据帧。这种方法被称为[匈牙利符号](https://en.wikipedia.org/wiki/Hungarian_notation)，并且在很大程度上不被提倡。在 Python 中，你可以用`type()`函数轻松检查某个东西的类型。如果你也使用类型提示，匈牙利符号就变得毫无用处。我建议把你可用的“变量名 milage”花在更有用的东西上。**
*   ****使用直观的领域语言:**您已经存储了变量`broccoli`、`celery`和`beets`，这些变量计算每种蔬菜的销售数量。您现在需要一个容器类型(比如字典)来存储所有这些变量。你把这本字典叫做什么？别担心，这不是一道难题。我不知道你怎么想，但我会称之为`vegatables`。尽可能使用直观的领域语言。唯一的例外是，如果您希望您的代码扩展到领域知识不再有意义的情况。**

**对于函数，上面的指导原则同样适用(请不要在函数名中嵌入“函数”一词)。唯一值得注意的是，函数通常做一些事情，而不是包含一些东西。因此，功能通常被赋予动作词(动词)来强调它们做什么。`prune_tree()`、`recommend_item()`等名字都很棒。**

**希望我已经让你相信花些时间给你的变量命名是值得的。在某些情况下，打破上述准则将是你最好的行动。例如，缩写 API(应用程序编程接口)是众所周知的。由此(私！)名为`api_password`的变量完全没问题。使用你自己的判断！**

# **4 —模块化您的代码**

**并非所有代码都是平等的。有些代码很难扩展。有些代码不容易被重用。有些代码很难检查错误。在所有这些方面做出改进的一个方法是**模块化你的代码**。**

**这在实践中意味着什么？你的代码应该分成函数和类。这些函数和类应该再次分组到 Python 模块中。为什么这样做？**

**考虑没有以任何方式分组的代码(您可能认为代码是“自由浮动的”)。这当然方便写在开头。然而，随着代码的增长，它变得越来越麻烦。**

**你必须复制和粘贴代码来做一些小的调整。如果你想扩展它，现在你必须在所有重复的地方修改代码。天知道如果一个同事要求你代码的一个特性你会怎么做——一切都是完全交织在一起的。不要让我开始讨论如何检查代码中的错误。**

**开始时的便利变成了一场噩梦😧**

**解决方法是什么？您应该定期将代码重构为函数和类。让我们以函数为例。函数是一段可重用的代码。当您的代码按逻辑分组到函数中时，您可以:**

*   ****轻松重用一些代码:**因为一个函数是一个独立的部分，你可以将那个特定的函数导出到其他设置中。也许你已经开发了一个很棒的函数`clean_missing_values()`来清除数据集中的缺失值。现在，您也可以在其他项目中使用该功能(只需进行最小的调整)。**
*   ****轻松检查代码中的错误:**可以通过单元测试来测试函数中的错误。在编写 Python 时，最常见的编写单元测试的库是 **Unittest** 和(我的最爱) **Pytest** 。**
*   ****轻松添加文档，更加清晰:**对于函数，您可以添加[文档字符串](https://www.programiz.com/python-programming/docstrings)来解释它们的功能。您还可以将[类型提示](https://docs.python.org/3/library/typing.html)添加到向其他开发人员和数据科学家解释输入和输出的数据类型的函数中。你会发现，一旦项目的复杂性增加，模块化的代码就更容易理解了。**

**特别是对于数据科学家来说，代码经常被留在 Jupyter 笔记本单元中，完全没有模块化。如果不从长远来看加以解决，上述所有问题都会变得更加突出。**

**不要误解我。Jupyter 笔记本是数据探索和测试机器学习模型的伟大工具。但是，请确保您留出时间将代码重构为可维护的部分(函数和类)。这样做，从长远来看，你会省去很多痛苦。此外，你将成为团队中测试人员/开发人员最喜欢的人，这总是一个优势😅**

# **5—设计原则？没听说过！**

## **你不用设计原则？**

**通常， [**设计原则**](https://www.geeksforgeeks.org/an-introduction-to-software-development-design-principles/) 是软件开发人员全神贯注的事情。许多数据科学家的印象是，设计原则并不真正与他们有太多的关系。对于这种说法，我想指出亚当·贾奇关于一般设计的名言:**

> **“好设计的替代品总是坏设计。没有所谓的没有设计。”亚当·贾奇**

**Adam Judge 说的绝对是视觉角度的设计。然而，我认为结论仍然代表着编写代码时的设计原则。通过编写代码，你在使用设计原则。你可能只是没有好好利用它们。**

**让我们从一些设计原则开始，以提高您的一般代码质量！**

## **可爱的缩写😍**

**![](img/1d459fa7ee8a3e473000f92c4af7376f.png)**

**加里·本迪格在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片**

**首先，有一些可爱的首字母缩略词正在被到处乱扔。在编写代码时，您应该将这些原则视为指导原则:**

**接吻:保持简单，傻傻的。尽可能降低复杂性。我们举个例子。比如你想算出 1 到 1000 之间有多少个非平方数。回想一下，非平方数`n`只是一个不能用其他数`m`的`n = m**2`来表示的数。下面的代码解决了我们的问题:**

```
non_square_numbers = len(set(range(1, 1001)).difference(set(map(lambda x: x ** 2, range(1, 1001)))))
```

**要诚实。虽然上面的代码解决了这个问题(甚至使用了很酷的功能，如 set 和 map 函数)，但它看起来很可怕。你可能花了一些时间去读它。这太复杂了。考虑以下简化:**

```
from math import sqrtnon_square_numbers = list(range(1, 1001))for n in range(1, int(sqrt(1001))):
    non_square_numbers.remove(n ** 2)
```

**新代码不仅更清晰，而且更快。我只需要运行这些数字直到 1001 的平方根，因为我是平方数字。从 KISS 中得到的教训是，如果让你的代码更容易理解，有时候让它长一点是值得的。**

****干:不要重复自己**——这个原则鼓励将你的代码模块化成函数。这样做可以避免代码重复。事实上，每当您发现自己重复代码时，您可能应该模块化您的代码。**

**YAGNI:你不会需要它的——这个原则鼓励你不要过度设计解决方案。我们来做一个具体的例子。**

**假设您正在编写一个数据管道，其中第一步是一个从 SQL 数据库读取数据的函数。也许在未来，你还需要阅读 CSV 文件。所以你也要实现它。也许在将来，你也需要阅读 XML。或者 JSON。或者拼花文件。**

**在这种情况下，YAGNI 原理很简单。不要。您可能不需要所有的扩展，并且您正在编写永远不会被使用的代码。相反，请确保您的代码可以扩展。但是请将实际的扩展留到您真正需要这样做的时候。**

**遵循 YAGNI 原则，你的代码库会更小，你需要担心的松散线程也会更少。**

## **坚实的设计原则**

**一组完善的设计原则(尤其是在 OOP 中)是[坚实的原则](http://d-the-first-five-principles-of-object-oriented-design)。它们形成了一组久经考验的设计原则，在过去的几十年中被大量使用。SOLID 中的五个设计原则是:**

*   ****S**——[单一责任原则](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#single-responsibility-principle)**
*   ****O** — [开闭原理](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#open-closed-principle)**
*   ****L** — [利斯科夫替代原理](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#liskov-substitution-principle)**
*   ****I** — [界面偏析原理](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#interface-segregation-principle)**
*   ****D** — [依存倒置原则](https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design#dependency-inversion-principle)**

**并非所有坚实的原则在数据科学中都同样有用。事实上，我在数据学科中很少使用利斯科夫的替代原理。不要误解我，这是一个伟大的设计原则，我非常尊重芭芭拉·利斯科夫。但是，在大量使用 OOP 的软件工程中，它肯定更有用。我认为数据科学家最重要的坚实原则是单一责任原则。**

**单一责任原则声明函数(以及类)应该有单一的责任。让我们用一个例子来探讨这意味着什么。**

**假设您有一个函数`process_data()`，它加载一个 CSV 文件作为 Pandas 数据帧，删除丢失的值，选择一些特征，然后最终绘制这些特征。您的函数`process_data()`现在有四个职责:导入数据、清理数据、特征提取和绘图。为什么这样不好？**

**首先，现在很难将代码导出到其他设置。您可能已经在函数`process_data()`中编写了顶级缺失值清除代码。你如何在其他地方使用这些代码，比如说，不能进行特征提取的地方？没那么简单。**

**测试你的代码是否有缺陷也更加困难。通过做多种不同的事情，有更多的地方让臭虫藏身。**

**单一责任原则建议将功能`process_data()`分解为四个功能。这些功能可以称为`import_csv_data()`、`clean_missing_values()`、`extract_features()`和`plot_features()`。这样，每个功能都有一个单独的职责😃**

# **6 —代码质量的更多资源**

**我已经给了你一些提高代码质量的起点。关于这个主题的更多信息，您应该从哪里获得？**

*   ****代码风格:**除了熟记 PEP8 并使用有效的代码格式化程序(如 [Black](https://pypi.org/project/black/) 或 [autopep8](https://pypi.org/project/autopep8/) )之外，真的没什么别的了。如果您想确保您执行了这一点，那么就请做代码评审的人提供关于代码风格的反馈。您可能还想研究一下在 [PEP257](https://peps.python.org/pep-0257/) 中编写适当的文档字符串的 Python 约定。**
*   ****变量名:**我在这里最好的建议是注意你选择的变量名。除此之外，我在 Al Sweigart 的书[中发现了许多有趣的点，超出了 Python](https://www.goodreads.com/book/show/41392896-beyond-the-basic-stuff-with-python) 的基本内容。**
*   ****模块化代码:**编写模块化代码需要付出努力。如果您不确定何时(以及如何)使用类，请考虑学习更多关于 OOP(面向对象编程)的知识。我可以推荐免费的 YouTube 系列 [Python OOP 教程](https://www.youtube.com/playlist?list=PL-osiE80TeTsqhIuOqKhwlXsIBIdSeYtc)作为一个很好的起点。除此之外，我建议您熟悉 Python 函数的各个方面，以便能够有效地使用它们。例如，如果您不知道 Python 函数默认返回值`None`，那么您的代码可能会反映出这种知识的缺乏。**
*   ****设计原则:**我只是给了你一点设计原则的味道。有关于这个主题的经典书籍，也有专门针对数据科学的书籍。然而，我怎么推荐都不为过。它们具有极高的质量，并对许多设计原则进行了 Python 特有的介绍。**

# **7 —总结**

**![](img/1bc2433f4186ac84ae54e1d8a5168ab0.png)**

**照片由[斯潘塞·伯根](https://unsplash.com/@spencerbergen?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄**

**希望你正在成为一名高质量的代码制作者。如果你的代码不是一夜之间完美的，也不用担心。获得高质量的代码是一个漫长的旅程，我每天都在努力。**

****喜欢我写的？**查看我的其他帖子，了解更多 Python 内容:**

*   **[用漂亮的类型提示使你罪恶的 Python 代码现代化](/modernize-your-sinful-python-code-with-beautiful-type-hints-4e72e98f6bf1)**
*   **[用 Python 可视化缺失值非常简单](/visualizing-missing-values-in-python-is-shockingly-easy-56ed5bc2e7ea)**
*   **[使用 PyOD 在 Python 中引入异常/异常值检测🔥](/introducing-anomaly-outlier-detection-in-python-with-pyod-40afcccee9ff)**
*   **[5 个能在紧要关头救你的牛逼数字功能](/5-awesome-numpy-functions-that-can-save-you-in-a-pinch-ba349af5ac47)**
*   **5 个专家提示，帮助你提高 Python 的词典技能🚀**

**如果你对数据科学、编程或任何介于两者之间的东西感兴趣，那么请随意在 LinkedIn 上加我，并向✋问好**