<html>
<head>
<title>Forecasting with Synthetic Data at Scale (Nixtla &amp; YData)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用大规模合成数据进行预测(Nixtla &amp; YData)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-with-synthetic-data-at-scale-nixtla-ydata-404b65600876#2022-01-05">https://towardsdatascience.com/forecasting-with-synthetic-data-at-scale-nixtla-ydata-404b65600876#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="59a3" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">利用大规模合成数据进行预测(Nixtla &amp; YData)</h1></div><div class=""><h2 id="aa51" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">制作合成时间序列数据，然后用深度学习模型进行预测</h2></div><p id="73d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">由</em><a class="ae lc" href="http://github.com/nixtla" rel="noopener ugc nofollow" target="_blank"><em class="lb"/></a><em class="lb">和</em> <a class="ae lc" href="http://YData.ai" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> YData </em> </a> <em class="lb">组成。</em> <a class="ld le ep" href="https://medium.com/u/2855bd3e0293?source=post_page-----404b65600876--------------------------------" rel="noopener" target="_blank"> <em class="lb">费德里科·加尔萨·拉米雷斯</em> </a> <em class="lb">和</em> <a class="ld le ep" href="https://medium.com/u/76b639655285?source=post_page-----404b65600876--------------------------------" rel="noopener" target="_blank"> <em class="lb">马克斯·梅根塔尔</em> </a> <em class="lb">。</em></p><h2 id="f13b" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">介绍</h2><p id="7073" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在这篇文章中，我们解释了如何使用<a class="ae lc" href="https://github.com/Nixtla/nixtlats" rel="noopener ugc nofollow" target="_blank"> nixtlats </a>和<a class="ae lc" href="https://github.com/ydataai/ydata-synthetic" rel="noopener ugc nofollow" target="_blank"> ydata-synthetic </a>，开源和免费的python库允许您生成合成数据来训练最先进的深度学习模型，而不会明显损失数据质量。我们开发了一个不直接访问原始数据的深度学习预测管道，并表明合成数据对模型的性能影响最小。</p><h2 id="73bb" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">动机</h2><p id="7418" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在过去的十年中，基于神经网络的预测方法在大规模预测应用中变得无处不在，超越了行业界限，进入了学术界，因为它在许多实际任务中重新定义了最先进的技术，如需求规划、电力负荷预测、逆向物流、天气预测，以及M4和M5等预测比赛。</p><p id="e1c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，对于那些对创建预测感兴趣的人来说，一个问题是不使用原始数据的模型开发或软件测试；这可能是因为实际数据需要时间来收集，对其使用有限制，或者数据根本不存在。在许多应用程序中，用户不希望模型能够访问实际数据，特别是如果模型训练是在云中或基础设施之外进行的。上述情况极大地限制了实践，阻止了使用可用云对大型数据集的模型进行缩放。</p><p id="6585" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章展示了如何使用<code class="fe md me mf mg b">nixtlats</code>和<code class="fe md me mf mg b">ydata-synthetic</code>来解决这个问题。首先，用户可以使用<code class="fe md me mf mg b">ydata-synthetic</code>创建合成数据；合成数据是人工创建的，并保留原始数据属性，在合规的同时确保其商业价值。随后，用户可以使用<code class="fe md me mf mg b">nixtlats</code>训练最先进的神经预测算法，而无需访问原始数据。一旦模型经过训练，就可以将模型发送给原始数据的所有者，并对其基础设施的安全性进行推断。下图描述了该过程。</p><figure class="mi mj mk ml gt mm gh gi paragraph-image"><div role="button" tabindex="0" class="mn mo di mp bf mq"><div class="gh gi mh"><img src="../Images/f97bdc0de65a94cc8b7b743e7c607415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJtRNHZTvg86Sz0tCexOUg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">作者图片</p></figure><p id="ddd2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们评估并显示，与原始模型的预测相比，合成模型的预测性能保持不变。</p><h1 id="c5d7" class="mx lg iq bd lh my mz na lk nb nc nd ln jw ne jx lq jz nf ka lt kc ng kd lw nh bi translated">图书馆</h1><p id="a328" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">库<code class="fe md me mf mg b">nixtlats</code>和<code class="fe md me mf mg b">ydata-synthetic</code>在<a class="ae lc" href="https://pypi.org/project/nixtlats/" rel="noopener ugc nofollow" target="_blank"> PyPI </a>中可用，所以你可以使用<code class="fe md me mf mg b">pip install nixtlats</code>和<code class="fe md me mf mg b">pip install ydata-synthetic</code>来安装它们。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="c2ef" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">数据</h2><p id="3e96" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">为了评估管道，我们考虑每年的<a class="ae lc" href="https://www.kaggle.com/yogesh94/m4-forecasting-competition-dataset" rel="noopener ugc nofollow" target="_blank"> M4竞赛</a>数据集。数据集最初是<a class="ae lc" href="https://github.com/Mcompetitions/M4-methods" rel="noopener ugc nofollow" target="_blank">公开发布的</a>，它是带着<a class="ae lc" href="https://github.com/Mcompetitions/M4-methods/issues/16" rel="noopener ugc nofollow" target="_blank">完全开放访问许可</a>发布的。M4主要预测竞赛引入了一种新的多变量时间序列模型，称为指数平滑递归神经网络(ESRNN)，它在基线和复杂时间序列集合上以较大优势获胜。</p><p id="7e9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<code class="fe md me mf mg b">nixtlats</code>库来方便地访问数据。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4e60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本例中，我们使用1000个年度时间序列。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7229" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe md me mf mg b">M4.load</code>方法返回训练集和测试集，所以我们需要将它们分开。该库还提供了各种各样的数据集，<a class="ae lc" href="https://nixtla.github.io/nixtlats" rel="noopener ugc nofollow" target="_blank">参见文档</a>。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c9b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe md me mf mg b">nixtlats</code>需要虚拟测试集来进行预测，因此我们将训练数据与零值测试数据相结合。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="0d7e" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">管道</h2><h2 id="0d9c" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">使用ydata-synthetic创建合成数据</h2><p id="727e" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在本节中，我们使用来自<code class="fe md me mf mg b">ydata-synthetic</code>的<code class="fe md me mf mg b">TimeGAN</code>模型合成由<code class="fe md me mf mg b">Y_df_train</code>定义的训练数据。查看<a class="ae lc" rel="noopener" target="_blank" href="/synthetic-time-series-data-a-gan-approach-869a984f2239">后的合成时间序列数据:GAN方法</a>，您可以了解更多关于<code class="fe md me mf mg b">TimeGAN</code>模型的信息。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="82ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下线路训练<code class="fe md me mf mg b">TimeGAN</code>模式，</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0cde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对象<code class="fe md me mf mg b">synth_data</code>包含合成训练数据。为了使用<code class="fe md me mf mg b">nixtlats</code>,我们需要将<code class="fe md me mf mg b">synth_data</code>转换成熊猫数据帧。使用下面几行代码可以很容易做到这一点。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="1bd4" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">使用nixtlats训练深度学习模型</h2><p id="92ee" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在本节中，我们使用以前的合成数据来训练M4竞赛的获胜者ESRNN模型。这种模式是混合的；一方面，它通过指数平滑模型局部拟合每个时间序列，然后使用递归神经网络训练水平。您可以通过使用ESRNN模型查看Python中的<a class="ae lc" href="https://medium.com/analytics-vidhya/forecasting-in-python-with-esrnn-model-75f7fae1d242" rel="noopener">预测来了解关于此模型的更多信息。</a></p><p id="d554" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型培训的流程遵循PyTorch的通用实践。首先必须实例化一个<code class="fe md me mf mg b">Dataset</code>。<code class="fe md me mf mg b">TimeSeriesDataset</code>类允许在每次迭代中返回完整的序列，这对于ESRNN之类的递归模型很有用。为了进行实例化，该类接收目标系列<code class="fe md me mf mg b">Y_df</code>作为包含列<code class="fe md me mf mg b">unique_id</code>、<code class="fe md me mf mg b">ds</code>和<code class="fe md me mf mg b">y</code>的pandas dataframe。此外，还可以包括临时外生变量<code class="fe md me mf mg b">X_df</code>和静态变量<code class="fe md me mf mg b">S_df</code>。在这种情况下，我们只使用原始模型中的静态变量。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们需要做的是定义<code class="fe md me mf mg b">nixtlats</code>中包含的ESRNN模型如下:</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="a13e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以这样训练它，</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="d33e" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">用真实数据训练的模型</h2><p id="5096" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">为了比较提供相似结果的两种解决方案，在本节中，我们使用原始数据训练模型。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8015" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以这样训练它，</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="f1e4" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">比较预测</h2><p id="4bfb" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">最后，我们使用原始数据对两个模型进行预测，<code class="fe md me mf mg b">model_synth</code>用合成数据训练，<code class="fe md me mf mg b">model</code>用原始数据训练。首先，我们定义测试数据集和加载器。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="54bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下几行用综合模型获得预测，</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="996d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，下面几行通过用真实数据训练的模型获得预测，</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="05e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们使用平均百分比误差(MAPE)及其对称版本(SMAPE)将两个模型的性能与真实值进行比较。<code class="fe md me mf mg b">nixtlats</code>提供的功能可以轻松做到这一点。</p><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="mi mj mk ml gt mm"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7170" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，考虑到MAPE损失，即使是用<code class="fe md me mf mg b">ydata-synthetic</code>生成的合成数据训练的模型也能产生更好的预测。</p><h2 id="8f33" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated">结论</h2><p id="c299" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">合成数据有广泛的应用。在这篇文章中，我们展示了创建合成数据的完整管道，并使用它来训练最先进的深度学习模型。正如我们所看到的，性能没有受到损害，甚至对于某些指标来说，性能甚至更好。</p></div></div>    
</body>
</html>