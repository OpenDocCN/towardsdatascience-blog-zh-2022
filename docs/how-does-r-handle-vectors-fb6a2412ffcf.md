# R 如何处理向量？

> 原文：<https://towardsdatascience.com/how-does-r-handle-vectors-fb6a2412ffcf>

## R |幕后|向量

# R 如何处理向量？

## 当然是简单而神奇的爱！

![](img/b56cd317383728244ee3aee1fa5dfa9f.png)

戴安娜·波莱希娜在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

r 是一种非常容易掌握的语言。这是它成为数据科学领跑者的一个原因:人们可以快速启动并运行。向量是 R 帮助事情变得简单快捷的方式之一。但是幕后到底发生了什么呢？

# 什么是向量？

向量是 r 中许多数据科学操作的支柱。与的*或*的*循环相比，它们的速度快得令人难以置信。速度的提高是因为向量只能存储单一类型的数据。这意味着如果你想创建一个向量，你不能把字符和数字变量都放进去。*

向量对于数据的存储和交互非常重要。如果我们有一组数字，我们可以把它们放在一个向量中，以便于计算。表格数据通常存储在数据框中，其中每一行是一个观察值，每一列是一个包含观察值特定属性的向量。

[](/storing-data-r-data-structures-717245c6bab8)  

# 矢量化运算

编程中操作多个对象的一种常用技术是对它们进行循环。我相信你对循环中的*很熟悉。你告诉它从哪里开始和停止，它将从开始到停止一遍又一遍地运行一些代码。*

让我们看一个使用`cars`数据集的例子。它包括汽车的速度(英里/小时)和停车距离(英尺)。如果我们想计算数据集中的平均速度，我们可以使用*作为*循环。我们创建`speed_sum`作为一个数字来跟踪我们的速度变量的总和，然后我们在`cars`数据帧的`speed`列中循环每个观察值。最后，我们将`speed`的总和除以我们的答案的数据集中的行数:15.4。

```
speed_sum <- 0
for (i in 1:nrow(cars)) {
    speed_sum <- speed_sum + cars$speed[i]
}
speed_sum / nrow(cars)[1] 15.4
```

这里有一个关于向量的很酷的事情:许多函数被优化来对它们执行操作。这意味着矢量化函数有可能比循环的*快得多。*

就拿`mean`函数来说吧。它计算我们给它的任何数字向量的平均值。对于`cars`的`speed`列，这又是 15.4。

```
mean(cars$speed)[1] 15.4
```

与使用矢量化的`mean`函数相比，使用 for 循环获得平均值要快多少？写一个循环需要的时间可能很多，这取决于任务。甚至我们快速的 *for* 循环求平均值也占用了 5 行。我们添加的代码越多，我们的任务就越复杂，我们就有越多的机会出错并花时间调试。有了矢量化的函数，我们可以节省很多时间，因为我们知道函数需要向量并进行计算。

与矢量化函数相比，计算循环的时间呢？嗯，在我的电脑上(Ubuntu 20.04，R 3.6.3，锐龙 5 5600G，16GB 内存，256GB 固态硬盘，RTX 3090)，向量化这个相当简单的操作可以导致执行速度的巨大提高。我们可以看到用`rbenchmark`包可以快 185 倍！

```
library(rbenchmark)benchmark(
    "Loop" = {
        speed_sum <- 0
        for (i in 1:nrow(cars)) {
            speed_sum <- speed_sum + cars$speed[i]
        }
        speed_sum / nrow(cars)
    },
    "Vectorized" = {
        mean(cars$speed)
    }
) test     reps elapsed relative user.self sys.self user.child
1    Loop     100   0.185    185     0.185        0        0
2 Vectorized  100   0.001     1      0.001        0        0
```

[](/r-is-slow-and-its-your-fault-2fcedacc7abb)  

# 标量运算

我们还可以用向量做其他很酷的事情。如果你熟悉矩阵代数，你可能还记得标量运算。这是当你把一个向量加、减、乘或除以一个数的时候。因此，不用创建一个循环来对向量中的每个数字进行操作，我们可以在计算中使用我们的向量，R 会将我们的标量操作应用于向量的每个元素。

还是关于`cars`的数据集，也许你来自一个使用公制的合理国家。`speed`变量以英里每小时记录。不用创建一个循环来将向量中的每个数字乘以 1.609 以转换为千米每小时，您只需将向量乘以该数字，R 会处理剩下的事情。

```
cars$speed * 1.609# Note: only the first 5 numbers from the output are shown here[1] 6.436  6.436 11.263 11.263 12.872 ...
```

想要组合更多的标量操作吗？去吧！作为一个来自我们用华氏温度来测量温度的疯狂国家的人，摄氏数据对我来说没有多大意义。`beaver1`数据集(内置于 R 中)有以摄氏度为单位的海狸体温记录。通过一些标量运算，我可以把这些转换成我更好理解的单位。

```
(beaver1$temp  * (9/5)) + 32# Note: only the first 5 numbers from the output are shown here[1] 97.394 97.412 97.430 97.556 97.790 ...
```

哇，那是一只热海狸！🦫

# 2 个向量

如果两个向量长度相同，计算起来就很简单。想象一下我在找一辆 1974 年的车。`mtcars`数据集有当年 32 辆汽车的一些统计数据。我想要力量大的东西，但不要太重。我可以计算出马力(`hp`)和重量(`wt`)的比值，通过将这两个向量相除。

```
mtcars$hp / mtcars$wt# Note: only the first 5 numbers from the output are shown here[1] 41.98473 38.26087 40.08621 34.21462 50.87209 ...
```

很简单，对吧？我们才刚刚开始，两个长度相同的向量。由于这些向量来自数据帧的列，我们可以使用相同的概念来过滤我们的数据帧。我们来筛选一下 6 缸以上的车。这一次，我们的结果将包括所选行的所有数据。

```
mtcars[mtcars$cyl >= 6 ,]
```

过滤器利用向量的力量来得到我们想要的东西。首先，它创建一个`TRUE`和`FALSE`的向量。我们前面说的标量运算也可以是逻辑语句！所以这条语句实际上是将向量`mtcars$cyl`的每个元素与标量 6 进行比较，并给出一个向量的结果。

```
mtcars$cyl >= 6# Note: only the first 5 numbers from the output are shown here[1] TRUE TRUE FALSE TRUE TRUE ...
```

为了过滤数据集，我们可以使用括号和相同大小的向量`TRUE`和`FALSE`值来选择我们想要的。在我们的例子中，我们需要 true/false 向量表明柱面数量大于或等于 6 的行。

让我们用这些数据来看看另一个向量技巧。我想知道这些汽车中有多少是 6 缸或 6 缸以上的。为了做到这一点，我可以利用这样一个事实，即在引擎下，R 将`TRUE`表示为 1，将`FALSE`表示为 0。

如果我对我们的真/假向量使用 sum 函数，它将对真值求和，并告诉我有多少辆车符合标准。结果，32 辆车中有 21 辆有 6 个或更多的汽缸。所有这一切都需要一些向量知识来帮助解决这个问题！

```
sum(mtcars$cyl >= 6)[1] 21
```

# 两个不同长度的向量

这是事情开始变得棘手的地方，也是 R 真正开始展示它在处理向量时所做的神奇和简化的地方。标量运算是两种不同长度的向量的特例。本质上，你是在告诉 R 用你的向量和一个长度为 1 的向量做一个运算。正如我们已经讨论过的，R 将重用单个值，并对向量的每个元素执行操作。但是如果我们让第二个向量长一点呢？

这个例子会更抽象一些。它可以帮助你理解 R 在向量运算中使用的魔法。让我们回到我们的`cars`数据集中的`speed`列。这次我们来除以一个长度为 2 的向量:`c(2, 4)`。我将包括来自`speed`列的前 5 个数字，这样您就可以知道发生了什么。

```
cars$speed[1:5][1] 4 4 7 7 8cars$speed / c(2, 4)# Note: Only the first 5 numbers of the output are shown here[1] 2.00 1.00 3.50 1.75 4.00 ...
```

…那么到底发生了什么？基本上，当你使用长度为 1 的标量或向量时，会发生同样的事情。r 将重用向量的每个元素，直到它计算出整个`speed`列的操作。让我们看一下这些操作:

1.  `speed`的第 1 个元素 4 被`c(2, 4)`的第 1 个元素 2 除。这给了我们 2。
2.  `speed`的第 2 个元素 4 被`c(2, 4)`的第 2 个元素 4 除。这给了我们 4。
3.  `speed`的第 3 个元素 7 被`c(2, 4)`的第 1 个元素 2 除。这给了我们 3.5。
4.  依此类推，直到`speed`列的其余部分。

这在现实世界中可能不是最实用的，但是只要较小向量的长度是较大向量长度的倍数，这就可行。但是如果长度不是彼此的倍数呢？

继续尝试这段代码。`speed`列的长度为 50。这个新向量的长度为 3。因为 50 不是 3 的倍数，所以 R 做两件事:

1.  它试图完成操作。它遵循与上一个示例相同的模式。
2.  它会生成一条警告消息，告诉我们较长的向量不是较短向量的倍数。

```
cars$speed / c(3, 6, 9)# Note: only the first 5 numbers from the output are shown here[1] 1.3333333 0.6666667 0.7777778 2.3333333 1.3333333 ...
Warning message:
In cars$speed/c(3, 6, 9) :
  longer object length is not a multiple of shorter object length
```

啊，神奇的向量处理 R 做到了。它会进行计算，但会给出一点警告信息，这样我们就知道有些东西看起来不太对劲。

# 结论

那么我们学到了什么？向量很快。它们通常允许我们比类似的循环更快地编写性能更好的代码。我们可以用向量和一个数字来计算。有一些函数对整个向量进行运算以得到结果，我们可以对多个向量进行运算，即使向量大小不同。r 对向量的处理也让我们知道什么时候事情看起来不太对，比如我们的向量长度不是彼此的倍数。

[](https://realdrewdata.medium.com/membership) 