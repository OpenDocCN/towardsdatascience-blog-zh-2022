<html>
<head>
<title>Understanding OPTICS and Implementation with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解光学和Python实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-optics-and-implementation-with-python-143572abdfb6#2022-01-27">https://towardsdatascience.com/understanding-optics-and-implementation-with-python-143572abdfb6#2022-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6832" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">无监督学习</h2><div class=""><h1 id="7d29" class="pw-post-title jb jc it bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">理解光学和Python实现</h1></div><div class=""><h2 id="4ef0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在这篇文章中，我简单地谈谈如何理解一种无监督学习方法，OPTICS，以及它在Python中的实现。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/13081b1b98d5595f598a33f3bbe4c40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WwhVdqHnTPQKrpOI"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="de12" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> OPTICS </strong>代表<strong class="lk jd">排序点识别聚类结构</strong>。它是一种基于<em class="me">密度的</em>无监督学习算法，由开发<strong class="lk jd"> DBSCAN </strong>的同一个研究小组开发。正如我在<a class="ae lh" rel="noopener" target="_blank" href="/understanding-dbscan-and-implementation-with-python-5de75a786f9f">上一篇文章</a>中所讨论的，DBSCAN有一个很大的缺点，那就是它很难在<strong class="lk jd">变化密度</strong>的数据中识别聚类。但是，光学不要求密度在整个数据集内保持一致。</p><p id="cdc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是一个简单的例子来说明光学系统优于DBSCAN的优势。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mf"><img src="../Images/8552c5535d588e3e58afc54c125085b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrlHMK-WusyUEu2yYb9DLg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不同密度的示例数据。光学性能优于DBSCAN。(图片由作者提供)</p></figure><p id="8fff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，DBSCAN中的恒定距离参数<em class="me"> eps </em>只能将<em class="me"> eps </em>内的点彼此视为邻居，显然错过了图右下方的集群(<a class="ae lh" rel="noopener" target="_blank" href="/understanding-dbscan-and-implementation-with-python-5de75a786f9f">阅读此贴了解更多关于DBSCAN </a>中参数的详细信息)。如果我们使用一个更大的<em class="me"> eps </em>参数，该集群可以被识别，但它也可能将其他两个顶部集群合并在一起。所以，很难在DBSCAN中预定义一个完美的<em class="me">EPS</em>；然而，在光学中，我们不需要担心这一点。</p><p id="6ac4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本帖中，我将谈谈如何理解这个算法，以及如何用Python实现它。希望文章有帮助。</p><h2 id="34d1" class="mg mh it bd mi mj mk dn ml mm mn dp mo lr mp mq mr lv ms mt mu lz mv mw mx iz bi translated">理解光学</h2><p id="1cfc" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">正如您所记得的，在DBSCAN中应用了单一的距离截断来确定两个数据点是否彼此靠近(相邻)。但是如上例所示，这可能不是理想的解决方案，因为一个集群中的“长”距离可能是另一个集群中的“短”距离。</p><p id="dacd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像全国的房价一样，30万的房子在我住的镇上相当贵，但在曼哈顿却很便宜。这就是为什么当我们看不同组(群)的房子(数据点)时，记住不同的价格标准是很重要的。</p><p id="e96c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，在光学中，我们如何将不同群体对距离的不同“标准”考虑在内呢？最直接的方法之一就是与<em class="me">本地环境</em>(上下文)进行比较。具体来说，如果我们有兴趣确定从A点到B点的距离是大还是小，我们可以将距离(A到B)与局部环境中所有成对的距离进行比较。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/e00a07aaf1ce1b3cd88b8a590558113c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1nkjVjzMLOHKH1cQlC5pTA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">比较从A到B到当地环境的距离(图片由作者提供)</p></figure><p id="8b90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我们从上面的图解中看到的，与本地环境中的所有成对距离相比，从A到B的距离并不算大，对吗？所以，我们应该把A和B看作邻居(A和B在距离上很近)。</p><p id="b2b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在前面判断A到B的距离大不大的步骤中，你可能已经注意到了几个不是很清楚的东西。举个例子，</p><blockquote class="ne nf ng"><p id="8b7a" class="li lj me lk b ll lm kd ln lo lp kg lq nh ls lt lu ni lw lx ly nj ma mb mc md im bi translated">1.如何定义一个“局部区域”？尤其是当没有像示例中所示的这样清晰的数据分离时？</p><p id="e618" class="li lj me lk b ll lm kd ln lo lp kg lq nh ls lt lu ni lw lx ly nj ma mb mc md im bi translated">2.如何确定一个局部环境是否值得调查？如果没有足够的配对距离让我比较呢？</p><p id="b739" class="li lj me lk b ll lm kd ln lo lp kg lq nh ls lt lu ni lw lx ly nj ma mb mc md im bi translated">3.真的有必要考虑区域中所有成对的距离吗？例如，比较从A到B的距离和从B到D的距离是否公平(特别是当我们已经知道B和D似乎是局部区域的对立边界时)？</p></blockquote><p id="795b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有上面列出的问题，恭喜你！因为你思考的方向是正确的！</p><p id="898e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，要定义一个“局部区域”，我们需要一个中心和一个半径(与DBSCAN中的概念相同)。例如，A点是我们想参观的第一个点，我们想参观A的本地。我们设置A为圆心，预定义值<em class="me"> r </em>为半径，局部区域定义为圆内的面积(如下图)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f227e5c6708bae78cd4cbc4490f1833b.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*vWARpF-yvJB3tBr5hizJKA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">定义我们想要调查的“局部区域”(图片由作者提供)</p></figure><p id="4627" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的示例图中，显然，r是围绕点A的半径的良好选择，因为它完美地覆盖了数据点的“局部聚类”。然而，在现实中，我们看不到数据的全貌，或者我们没有那些“局部聚类”的清晰分离。因此，通常将r设置为一个相对较大的值是一个很好的做法，这样可以避免当你站在a点时出现在一个非常小的区域。</p><p id="4c4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其次，为了确定一个区域是否值得研究，我们设置了一个最小数量的数据点作为标准。例如，只有在至少有N个数据点(包括中心本身)的情况下，上一步定义的“局部区域”才值得研究。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/60361f39e636375764d5f85936a015cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*-GnKdnDK0XSAU7wpeVOhTg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">P点不值得调查N=3(图片由作者提供)</p></figure><p id="e1da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的图中，我们设置N= 3，这意味着一个区域只有在超过3个数据点时才值得研究。因此，点P周围的区域不会作为“局部区域”进行调查，因为它没有任何邻居，并且我们无法比较任何成对的距离。</p><p id="07e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第三，你可能已经注意到，当我们想要确定从A到B的距离是否很大时，没有必要计算“局部区域”内的所有成对距离。让我们再来看看局部区域中的成对距离，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/574a8f88b9f59cf2660b528fab1ceb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*wgITkkSJziRsmq4D8e6aWw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">将局部区域中的所有成对距离简化为成对距离。(图片由作者提供)</p></figure><p id="95ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图左图所示，A点和B点在图中“相邻”，但B点和D点不相邻。毫无疑问AB比BD短，所以比较A到B的距离和B到d的距离既不公平也没有必要，有没有办法让我们只考虑那些“相邻”点之间的距离(如上面右图所示)？</p><p id="3e90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，在上面的图中，减少从左到右的比较是非常理想的，因为我们有更多的数据点，位置更加复杂，我们很难手动选择这些边缘与A到b的距离进行比较。</p><p id="a0e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者，我们可以用迭代的方式来解决这个问题吗？比如我们逐个访问局部区域内的点，每次只记录当前点到其相邻点的距离然后移动到下一个点。在访问了该区域的所有点之后，我们记录了所有相邻的距离。通过这种方式，我们不必提前看到距离的全貌，也不必在访问完所有成对的距离后手动选择这些距离。</p><p id="e735" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个很好的方法，但是我们能进一步降低复杂度吗？</p><p id="72e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧，我不想让你感到困惑，所以让我再次陈述这个问题。我们希望将A和B之间的距离与所有其他成对的“相邻”距离进行比较，以确定A和B是否彼此接近。</p><p id="578d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你还记得为什么我们想知道A和B之间的距离与其他成对距离相比是大还是小吗？我们想知道B是否属于当前访问的数据点聚类(以点A为中心的聚类)。换句话说，我们希望使用距离度量来确定一个点对于一个数据点集群是否是<strong class="lk jd">可达的</strong>。</p><p id="f7b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可达或不可达。嗯……我们能给每个点分配一个可达性分数吗？那会简单很多吗？可达性分数大的地方是集群不能到达的地方，可达性分数小的地方是集群内部可以到达的地方。</p><p id="2287" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你在这里感到有点失落，不要担心。请跟我走一遍整个过程，我相信你会明白我在说什么。</p><p id="fdc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是步骤:</p><p id="d59b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们访问a点周围的局部区域。我们计算从中心点到该区域中所有其他点的距离，AB、AC、AD、AE和AF，并记录它们。我们<strong class="lk jd">对记录的距离进行</strong>排序，并将这些距离视为当前可达性得分。我们还需要将A推送到最终的分数列表，以便不再访问它。作为初始点，A是没有赋值的，所以让它保持空白(或者我们可以给它赋一个超大的值)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nn"><img src="../Images/d667417c87994fbf6c590592d8973ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WPDwD_M-3oX1ZmJ3E2WbQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第一步。(图片由作者提供)</p></figure><p id="450c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们访问可达性分数最小的点(点D)，该点也是离当前中心点最近的点。我们使用这个新点作为中心点，并计算从当前中心点到其邻域内没有被访问过的其他点的距离。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/eb5219529ca055f40a3b307277c9f645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hA1ak06RSLF7XF3niuydtA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第二步。(图片由作者提供)</p></figure><p id="a946" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图所示，我们只计算D到C的距离和D到E的距离，因为A已经被访问过了(不需要再计算)。然后，如果可用，我们用较小的分数更新当前可达性分数列表。这里，E的新分数为1，小于上一步中的分数(步骤1中E=1.4)。所以，我们<strong class="lk jd">更新</strong> E的分数。但是C点的分数比第一步大，这意味着C从A比从d更容易到达。所以，我们在这一步保持C的分数<strong class="lk jd">不变</strong>。在没有调查的情况下，B和F在该步骤中不被更新。</p><p id="9473" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，我们希望记录每个点的最小可达性分数，以便声明它是否属于当前集群，因此当有更小的分数可用时，我们<strong class="lk jd">不能</strong>对C使用大的分数。如果我们仅仅因为没有使用C点的最佳得分而将其排除在集群之外，这对于C点是不公平的。</p><p id="47b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第三，我们移动到E，因为E在当前列表中具有最小的可达性分数。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi no"><img src="../Images/f2fb796a1dbe3183b98f5313152dd30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f672ASWkDcM5LzW4Oi4Ang.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第三步。(图片由作者提供)</p></figure><p id="4685" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图所示，我们只需要计算从E到F的距离，因为在前面的步骤中已经执行了A和D。我们为F (F = 1.9)得到一个稍小的可达性分数，所以我们在当前分数列表中更新它。</p><p id="442a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，B点具有最小的可达性分数，因此我们在该步骤中将其用作当前中心点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/2a71c837f2045beac592a8c8176ce7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NRZkWUyk6wLg2C3ad1K7g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第四步。(图片由作者提供)</p></figure><p id="8d7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">步骤4中没有更新可达性分数，因为我们找不到更小的值。然后我们以C为中心点进行第五步。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/fecd87d7b52e03e8db796ec981fe46bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F7eYFzr_Fqb4Xd-NhP8Tsg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第五步。(图片由作者提供)</p></figure><p id="95a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们以点F为中心点，将F的可达性得分输出到列表中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/662f3d3fe12e0819952e116e215f6d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4yld3HHeGZ-VFPjUesNyQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第六步。(图片由作者提供)</p></figure><p id="524b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，我们已经访问了当前本地的所有六个点，并获得了最终的可达性得分列表。这样，我们就不会错过“相邻”点之间的任何成对距离。此外，我们得到了一个有序的分数列表，它度量了调查聚类中的点的可达程度。</p><p id="3e8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面描述的过程是否比计算区域中所有成对的距离简单得多？</p><p id="3b13" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，我们可以将这个过程应用于整个数据集。比如以F为中心点参观后，我们在当地就没有其他未参观的点了。然后，下一个中心点可以是数据集中的任何其他数据点。</p><p id="62d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们按照参观的顺序画出一条连接中心点的可能的完整路径，它可能类似于下图。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/9c6ca21226e30a7270bd35a62b717926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*t3Fjw2RQ8JSUFkXCkHIxEw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">整个数据集中的中心点路径(图片由作者提供)</p></figure><p id="851c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以将路径想象为一条贪婪的蛇，它想通过总是咬下一个最近的球(在分数列表中)来吃掉图中的所有球(数据点)。</p><p id="e987" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">右上角的单个点与中间聚类的预定义邻域(半径为r)有一个“邻居”，因此在橙色部分的最后一步中对其进行了访问。但是，左下方的点根本没有“邻居”，所以从来没有调查过，因为它不符合我们的标准，即一个区域只有至少有N = 3个邻居(包括它自己)才值得调查。</p><p id="6e4f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完成所有这些后，我们得到了一个可达性分数列表，我们可以用它做什么呢？别忘了我们的目标是定义一个点是否属于局部聚类。例如，这是我们得到的分数列表，</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/236da19c01ccabbe5a2ba692ec1bf46e.png" data-original-src="https://miro.medium.com/v2/resize:fit:204/format:webp/1*zGZlgn_1A1YL2PQDRp__dQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">分数列表(图片由作者提供)</p></figure><p id="30ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们将分数绘制成条形图，我们可以将它们可视化如下。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/dcddb938cac4181b06cf90e297f814ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuoTs-0TRTzFZyipllQXug.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">可达性得分图(作者图片)</p></figure><p id="4cc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能已经注意到，右边柱状图中的三个谷与左边的三个集群相对应。因此，使用最终的可达性分数列表，我们能够检测到聚类，即使它们具有不同的密度。</p><p id="e356" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，您可以发现更密集的集群(左侧面板左上角的棕色集群)对应于条形图上更深的山谷(右侧面板上用棕色圈出的山谷)。一个更稀疏的集群(左侧面板右下方的蓝色集群)对应于一个相对较浅的山谷(柱状图最左侧的圆圈)。</p><p id="703f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，我们将一个值得参观的街区定义为至少有3个邻居的区域。我们可以把这三个邻居视为邻里关系的核心。实际上，我们并不太关心这些点是否位于核心，因为它们显然属于这个集群。因此，通常对于核心中的所有点，我们将核心大小设置为它们的可达性分数。</p><p id="683d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，在下图中，在以A为中心、半径为r的区域中有六个点。该区域的核心由A、D和E组成，因为D和E是距离A最近的两个点(N = 3)。我们知道D在核心之内，所以不用记录A到D的确切距离(一个很小的值)。我们可以简单地将核心大小(核心的半径)指定为点d的得分。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nu"><img src="../Images/981d9f7b14864d8659f7410d7b4cbbcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:390/format:webp/1*pk_AGqk-nN15kuBdJyOtig.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">核心尺寸以橙色突出显示。用蓝色突出显示的邻近区域。(图片由作者提供)</p></figure><p id="60c8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在通过核心大小近似核心内的点的分数之后，我们可以从最终可达性分数列表中得到的最小值就是核心大小。我们为什么要这么做？第一，避免记录那么多无用的微小微小值；第二，使柱状图中的波谷看起来更平滑(如下所示)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b3cf0a23047d5a33e36d1bfea1cf54d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*Rn1pJFSo5ues5bBG1RiLfA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">将微小分数设置为分数大小。(图片由作者提供)。</p></figure><p id="fb61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我没有使用任何来自光学的概念，但上面描述的程序正是光学。如果你一直往下看，你已经理解了光学。</p><p id="5d73" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我从教科书中抽出一些描述，并简要说明它们是如何嵌入我上面的解释中的。</p><h2 id="fd76" class="mg mh it bd mi mj mk dn ml mm mn dp mo lr mp mq mr lv ms mt mu lz mv mw mx iz bi translated">光学算法</h2><p id="c227" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">大部分教材都是这样开头的，“光学的基本思想类似于DBSCAN但是比DBSCAN多了两个概念”。让我用一些官方词汇来描述光学中的这两个概念，并告诉你这些复杂的术语实际上指的是我上面的简单语言描述。</p><blockquote class="ne nf ng"><p id="26b8" class="li lj me lk b ll lm kd ln lo lp kg lq nh ls lt lu ni lw lx ly nj ma mb mc md im bi translated">在光学中，每个点被分配一个<em class="it">核心距离</em>，它描述了到第<em class="it"> MinPts </em>最近点的距离，以及从点<em class="it"> p </em>到另一个点<em class="it"> o </em>的可到达距离，该距离或者是<em class="it"> o </em>和<em class="it"> p、</em>之间的距离，或者是<em class="it"> p </em>的核心距离，以较大者为准。</p></blockquote><p id="92b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">核心距离就是我所描述的核心大小，它只是作为近似核心内部点的距离的阈值。可达性距离就是我们记录的每个点的可达性分数。</p><p id="8f99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是教科书上的算法伪代码。</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="788d" class="mg mh it nx b gy ob oc l od oe"><strong class="nx jd">function</strong> OPTICS(DB, eps, MinPts) <strong class="nx jd">is</strong><br/>    <strong class="nx jd">for each</strong> point p of DB <strong class="nx jd">do</strong><br/>        p.reachability-distance = UNDEFINED<br/>    <strong class="nx jd">for each</strong> unprocessed point p of DB <strong class="nx jd">do</strong><br/>        N = getNeighbors(p, eps)<br/>        mark p as processed<br/>        output p to the ordered list<br/>        <strong class="nx jd">if</strong> core-distance(p, eps, MinPts) != UNDEFINED <strong class="nx jd">then</strong><br/>            Seeds = empty priority queue<br/>            update(N, p, Seeds, eps, MinPts)<br/>            <strong class="nx jd">for each</strong> next q in Seeds <strong class="nx jd">do</strong><br/>                N' = getNeighbors(q, eps)<br/>                mark q as processed<br/>                output q to the ordered list<br/>                <strong class="nx jd">if</strong> core-distance(q, eps, MinPts) != UNDEFINED <strong class="nx jd">do</strong><br/>                    update(N', q, Seeds, eps, MinPts)</span></pre><p id="972b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我知道这很难理解。所以，忽略它，和我前面几段用的步骤一模一样。这里光学最终输出的是可达性距离列表，也就是我们之前看到的可达性得分列表。</p><p id="490a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，当可达性距离柱状图生成时，光学器件停止工作。最终的聚类步骤需要手动执行，这就是为什么严格来说，OPTICS是<strong class="lk jd">而不是</strong>一种聚类方法，而是一种显示数据集结构的方法。</p><h2 id="9f1f" class="mg mh it bd mi mj mk dn ml mm mn dp mo lr mp mq mr lv ms mt mu lz mv mw mx iz bi translated">Python中的实现</h2><p id="0ff4" class="pw-post-body-paragraph li lj it lk b ll my kd ln lo mz kg lq lr na lt lu lv nb lx ly lz nc mb mc md im bi translated">用Python实现光学非常容易，</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="d4d1" class="mg mh it nx b gy ob oc l od oe"><strong class="nx jd">from</strong> <strong class="nx jd">sklearn.cluster</strong> <strong class="nx jd">import</strong> OPTICS<br/><br/>optics_clustering = OPTICS(min_samples=3).fit(X)<br/></span></pre><p id="630e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想知道数据点的最终标签，请使用</p><pre class="ks kt ku kv gt nw nx ny nz aw oa bi"><span id="4ddd" class="mg mh it nx b gy ob oc l od oe">optics_clustering.labels_</span></pre><p id="9e91" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很简单，对吧？</p><p id="1ccb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能已经注意到，在光学实现代码中没有名为eps的参数。那是因为这个参数只要不是超级小，其实并不会影响结果。想象一下，当你第一步站在A点时的最大视野。为什么？如果你再看一遍帖子，就很容易得到答案。</p><p id="9a72" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样！如果你喜欢看我的帖子。请<a class="ae lh" href="https://jianan-lin.medium.com/subscribe" rel="noopener">订阅我的媒介账号</a>！</p><p id="e04c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">干杯！</p><h2 id="46c5" class="mg mh it bd mi mj mk dn ml mm mn dp mo lr mp mq mr lv ms mt mu lz mv mw mx iz bi translated">参考资料:</h2><div class="of og gp gr oh oi"><a href="https://scikit-learn.org/stable/modules/generated/sklearn.cluster.OPTICS.html" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jd gy z fp on fr fs oo fu fw jc bi translated">sklearn.cluster.OPTICS</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">从向量数组估计聚类结构。光学(排序点以识别聚类结构)，密切…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">scikit-learn.org</p></div></div><div class="or l"><div class="os l ot ou ov or ow lb oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://en.wikipedia.org/wiki/OPTICS_algorithm" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jd gy z fp on fr fs oo fu fw jc bi translated">光学算法-维基百科</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">对点进行排序以识别聚类结构(光学)是一种算法，用于在</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">en.wikipedia.org</p></div></div><div class="or l"><div class="ox l ot ou ov or ow lb oi"/></div></div></a></div></div></div>    
</body>
</html>