<html>
<head>
<title>XGBoost for time series: lightGBM is a bigger boat!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost for time series: lightGBM是更大的船！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xgboost-for-timeseries-lightgbm-is-a-bigger-boat-197864013e88#2022-01-23">https://towardsdatascience.com/xgboost-for-timeseries-lightgbm-is-a-bigger-boat-197864013e88#2022-01-23</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""><h1 id="816a" class="pw-post-title it iu iv bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">XGBoost for time series: lightGBM是更大的船！</h1></div><figure class="gl gn jt ju jv jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi js"><img src="../Images/1b65139cf5c2114e086c3945431c6679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F8vzP7kxSRVeEprD"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">威廉·戴尼奥在<a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="ki kj kk"><p id="90b1" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj io bi translated"><strong class="ko iw">更新</strong>:发现我关于渐变提升的新书，<a class="ae kh" href="https://amzn.to/3gaBn4R" rel="noopener ugc nofollow" target="_blank">实用渐变提升</a>。这是用python中的许多例子对渐变增强的深入探究。</p></blockquote><div class="lk ll gp gr lm ln"><a href="https://amzn.to/3gaBn4R" rel="noopener  ugc nofollow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iw gy z fp ls fr fs lt fu fw iu bi translated">实用的渐变增强:深入探究Python中的渐变增强</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">这本书的梯度推进方法是为学生，学者，工程师和数据科学家谁希望…</h3></div></div><div class="lv l"><div class="lw l lx ly lz lv ma kb ln"/></div></div></a></div><p id="e195" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">在处理时间序列时，能够处理外推是至关重要的。没有外推法，处理趋势是不可能的。</p><p id="164e" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">从数学上讲，这意味着基础模型必须在其公式中至少集成一个线性部分。</p><p id="4a44" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">在上一篇文章中，我展示了XGBoost的一个最重要的限制是它不能根据构造进行推断。</p><div class="lk ll gp gr lm ln"><a rel="noopener follow" target="_blank" href="/xgboost-for-time-series-youre-gonna-need-a-bigger-boat-9d329efa6814"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd iw gy z fp ls fr fs lt fu fw iu bi translated">XGBoost for Time Series:你需要一艘更大的船</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">XGBoost是一个非常强大和通用的模型。它的应用范围很广，并已得到应用</h3></div><div class="me l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">towardsdatascience.com</p></div></div><div class="lv l"><div class="mf l lx ly lz lv ma kb ln"/></div></div></a></div><p id="db26" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">这是相当严格的，因为在许多ML情况下，你需要能够推断。在处理时间序列时尤其如此，因为你通常想要预测未来，而没有外推，你就被困在了过去。XGBoost所做的所有预测都是历史值的集合。</p><p id="203a" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">在某种程度上，XGBoost无法预测历史上没有的东西。</p><h1 id="f4a6" class="mg mh iv bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">问题</h1><p id="4a19" class="pw-post-body-paragraph kl km iv ko b kp ne kr ks kt nf kv kw mb ng kz la mc nh ld le md ni lh li lj io bi translated">为了具体说明这个问题，让我们以我在上一篇文章中使用的代码为例:</p><figure class="nj nk nl nm gt jw"><div class="bz fp l di"><div class="nn no l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">试着用XGBoost建模一个简单的线性函数。作者代码。</p></figure><p id="601e" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">我们面对的是一个简单的线性时间序列，它与时间严格成比例，可以用一个基本的线性方程来建模。</p><p id="124b" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">正如我们在前面的脚本生成的图中看到的，XGBoost没有抓住趋势:</p><figure class="nj nk nl nm gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi np"><img src="../Images/e83547c4f4b6768c2310a1328367e144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7LK1fj5jpo6O87bPneST-g.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">XGBoost预测与实际值。作者的情节。</p></figure><h1 id="1a28" class="mg mh iv bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">解决方案</h1><p id="c586" class="pw-post-body-paragraph kl km iv ko b kp ne kr ks kt nf kv kw mb ng kz la mc nh ld le md ni lh li lj io bi translated">然而，XGBoost和更一般的使用梯度推进方法训练的决策树的集成仍然是非常强大的工具，尽管有这种限制，但在时间序列上表现相对较好。</p><p id="d5ff" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">如果我们能保持这种树状的方法，并在模型中集成一些关于特征的比例关系，那将是完美的。</p><p id="ee33" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">我最近看到了这篇不错的论文，<a class="ae kh" href="https://arxiv.org/pdf/1802.05640.pdf" rel="noopener ugc nofollow" target="_blank">用分段线性回归树进行梯度提升</a>，它准确地提出了一种使用更复杂的基础学习器的方法:分段线性函数而不是分段常数函数。</p><p id="465f" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">在本文中，他们表明，使用这种更复杂的学习器不仅提高了精度，而且加快了收敛速度。</p><p id="2f93" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">从数学上讲，这意味着标准梯度的恒定权重提升了决策树，用以下公式计算:</p><figure class="nj nk nl nm gt jw gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/27a252f0be789c7f9f3686ad36ef3bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*Q7Nbq-3Giw53XfEZEUiQbA.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">最佳叶重。作者的公式</p></figure><p id="08f6" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">其中，G_j是应用于叶中剩余数据的目标函数的梯度，H_j是目标函数的hessian，将被更复杂的估计器代替:</p><figure class="nj nk nl nm gt jw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a1df29b685e601608e1d0fb8684a10db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*k5uuoucY223wlHLF-OYbcw.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">使用所选要素计算的线性权重。作者的公式。</p></figure><p id="356c" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">对于树的每个叶子，标准梯度增强方法必须适合于识别a参数的最佳值，而且选择要使用的相关特征</p><p id="0586" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">在他们的论文中，作者解释了如何做这件事。</p><p id="ba11" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">非常好的消息是，它已经在XGBoost最重要和最著名的竞争对手之一:LightGBM中实现了！</p><h1 id="656e" class="mg mh iv bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">LigthGBM</h1><p id="6c1a" class="pw-post-body-paragraph kl km iv ko b kp ne kr ks kt nf kv kw mb ng kz la mc nh ld le md ni lh li lj io bi translated">在深入讨论这个主题之前，先简单介绍一下LightGBM。这是一个实现梯度推进方法来训练决策树集合的库。</p><p id="a69b" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">根据GitHub stars的评价，它不如XGBoost有名，但它仍然是XGBoost的一个非常受欢迎和重要的替代产品。</p><p id="96a2" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">它主要由微软开发。允许使用线性函数作为基础预测值的选项是<code class="fe ns nt nu nv b">linear_tree.</code></p><h1 id="f1e2" class="mg mh iv bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">在数学上，我们相信</h1><p id="1e99" class="pw-post-body-paragraph kl km iv ko b kp ne kr ks kt nf kv kw mb ng kz la mc nh ld le md ni lh li lj io bi translated">让我们检查一下之前的例子，当使用这种基础学习者的LightGBM时，我们得到了预期的结果。</p><p id="7644" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">首先，为了让我们相信选项<code class="fe ns nt nu nv b">linear_tree</code>确实能够解决我们的问题，我们将运行没有该选项的第一个脚本:</p><figure class="nj nk nl nm gt jw"><div class="bz fp l di"><div class="nn no l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">尝试在没有linear_tree选项的情况下捕捉数据的线性行为。作者代码。</p></figure><p id="82a0" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">正如这个脚本生成的图所显示的，在没有选项<code class="fe ns nt nu nv b">linear_tree</code>的情况下，LighGBM的性能并不比XGBoost好:</p><figure class="nj nk nl nm gt jw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e28e5c4f4f3a4a4ff4e3ee6e6ce3ca71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*S2l5-LnDfW7V3PW-t9bM-w.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">没有线性树，LightGBM无法推断。图片由作者提供。</p></figure><p id="fd49" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">现在让我们运行完全相同的代码，除了选项<code class="fe ns nt nu nv b">linear_tree:</code>之外，使用LighGBM默认参数</p><figure class="nj nk nl nm gt jw"><div class="bz fp l di"><div class="nn no l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">用LighGBM和线性树捕捉数据的线性本质。作者代码。</p></figure><p id="af7c" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">答对了。正如理论预测的那样(这是个好消息，否则我会白写这篇文章:)，LightGBM抓住了数据的线性本质:</p><figure class="nj nk nl nm gt jw gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/ab69c64406f3f778f9b318b44b655214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*s2PhGNk-lJ0Htp_SJksc-A.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">LightGBM外推完美！作者的情节。</p></figure><h2 id="9c6b" class="nx mh iv bd mi ny nz dn mm oa ob dp mq mb oc od mu mc oe of my md og oh nc oi bi translated">更深刻的理解</h2><p id="1c8b" class="pw-post-body-paragraph kl km iv ko b kp ne kr ks kt nf kv kw mb ng kz la mc nh ld le md ni lh li lj io bi translated">看看lightGBM选择的参数会非常有趣。</p><p id="20e8" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">我们知道，我们非常基本的时间序列只是与时间成比例，其系数值为6.66。</p><p id="683e" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">理想情况下，lightGBM应该将这个值确定为其线性模型的最佳值。</p><p id="67ce" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">这很容易检查。我们将生成最简单的模型，以便于阅读模型定义。</p><p id="6aab" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">我们将使用<code class="fe ns nt nu nv b">save_model</code>函数来导出模型。下面是代码:</p><figure class="nj nk nl nm gt jw"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="5260" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">代码基本上和以前一样，除了我们调整参数得到最简单的一个:深度减少到1，估计器的数量是2。</p><p id="271e" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">查看模型定义，我们得到:</p><figure class="nj nk nl nm gt jw"><div class="bz fp l di"><div class="nn no l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">LightGBM导出的模型定义。内容由作者提供。</p></figure><p id="ee79" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">两条重要的线是:</p><blockquote class="ki kj kk"><p id="53f9" class="kl km kn ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj io bi translated">leaf _ features = 0 0<br/>leaf _ coeff = 0 . 7019912661967</p></blockquote><p id="c06f" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">这意味着所使用的特征是第一个特征，即时间。因为深度等于1，所以有两片叶子。一个重量为0.701，另一个重量为6.659。这不完全是6.66，但已经很接近了。</p></div><div class="ab cl oj ok hz ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="io ip iq ir is"><h1 id="1778" class="mg mh iv bd mi mj oq ml mm mn or mp mq mr os mt mu mv ot mx my mz ou nb nc nd bi translated">结论</h1><p id="f7c1" class="pw-post-body-paragraph kl km iv ko b kp ne kr ks kt nf kv kw mb ng kz la mc nh ld le md ni lh li lj io bi translated">在处理数据科学问题时，理解要素之间以及要素与时间之间的关联方式至关重要。基于这种理解，有必要将这种关系转化为数学公式。</p><p id="8269" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">了解这些公式，掌握可用机器学习算法的底层数学基础的数据科学家将能够选择正确的算法并建立相关的模型。</p><p id="0077" class="pw-post-body-paragraph kl km iv ko b kp kq kr ks kt ku kv kw mb ky kz la mc lc ld le md lg lh li lj io bi translated">我们在本文中已经看到，为了进行外推，我们至少需要在我们的模型中集成一些线性。知道LightGBM支持这种基础学习者有助于我们高效优雅地解决我们的问题。</p></div></div>    
</body>
</html>