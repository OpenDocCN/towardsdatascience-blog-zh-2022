<html>
<head>
<title>Reduce your worries: using ‘reduce’ with PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">减少您的担忧:使用PySpark的“Reduce”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/reduce-your-worries-using-reduce-with-pyspark-642106d6ae50#2022-01-14">https://towardsdatascience.com/reduce-your-worries-using-reduce-with-pyspark-642106d6ae50#2022-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="16d6" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">减少您的担忧:使用PySpark的“Reduce”</h1></div><div class=""><h2 id="6311" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用python轻松重复PySpark操作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8ae4854cb338483f7c8fbdce0d34f81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y8nPWVjD5OB-yi5i"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@simonmigaj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> S Migaj </a>拍摄的照片</p></figure><p id="3a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用PySpark，您可能已经熟悉了它编写类似SQL的查询的能力。您可以轻松地对常见的SQL子句进行方法链，如。select()，。filter/where()/，。join()，。withColumn()，。groupBy()和。agg()来转换Spark数据帧。它本身就很强大，但是当您将它与python风格的脚本结合使用时，它的功能就变得无限了。我将展示两个例子，在这两个例子中，我使用python的functools库中的“reduce”来重复地对Spark数据帧应用操作。</p><h2 id="d7c5" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">堆叠桌子</h2><p id="e03c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">第一个技巧是使用类似SQL的union all堆叠任意数量的数据帧。假设您有一系列结构相同的表，并且您想将它们堆叠在一起。出于共享的目的，可以将这些表划分成许多较小的表，或者每个表可以代表一个月，或者其他任何原因。在这个例子中，我们假设有一个parquet文件路径列表，其中包含一系列需要组合的表。我们可以编写一个不必要的for循环来一个接一个地堆叠它们，但是更好的方法是利用functools库中的“reduce”。</p><p id="6d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">reduce函数需要两个参数。第一个参数是我们想要重复的函数，第二个参数是我们想要重复的iterable。通常当你使用reduce时，你使用一个需要两个参数的函数。一个常见的例子是</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="dfdd" class="ls lt iq mr b gy mv mw l mx my">reduce(lambda x, y : x + y, [1,2,3,4,5])</span></pre><p id="e9b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它会这样计算:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8708" class="ls lt iq mr b gy mv mw l mx my">((((1+2)+3)+4)+5)</span></pre><p id="e935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将使用DataFrame <em class="mz">方法</em>来代替，并在iterable上重复链接它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="eae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个方法链按照我们的期望组合了我们所有的数据框架。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1e3f" class="ls lt iq mr b gy mv mw l mx my">(dfs[0].unionAll(dfs[1])).unionAll(dfs[2])...</span></pre><h2 id="ea06" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">嵌套OR/AND</h2><p id="ec75" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在下一个例子中，我们将需要应用一个包含一系列条件的过滤器，这些条件可能全部由or或and连接。一个常见的SQL示例是，您可能希望查询与特定市场相关的所有行，您只需要知道“市场”字段的前三个字符。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d7b2" class="ls lt iq mr b gy mv mw l mx my">SELECT * FROM TABLE<br/>WHERE (MARKET LIKE 'AQ1%' OR MARKET LIKE 'AW3%' OR MARKET LIKE 'M89%' OR ...)</span></pre><p id="4a13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我的表，每个人都有一行，一系列列表示他们在那个月是否被覆盖。如果他们在那个月被覆盖，他们在列中有1，否则他们有0。我想查询至少在某个时间范围的某个点上有覆盖率的所有成员，所以我想编写的类似SQL的查询如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7be6" class="ls lt iq mr b gy mv mw l mx my">SELECT * FROM TABLE<br/>WHERE (COV_2007 = 1 OR COV_2008 = 1 OR COV_2009 = 1 OR ... OR COV_2106 = 1)</span></pre><p id="7efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SQL中单独编写这个是一件痛苦的事情，但是使用python我们可以很容易地编写这个重复OR条件的脚本。</p><p id="0bc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我首先创建一个我感兴趣的列的字符串列表。在示例中，我想要2020年7月到2021年6月(它们被命名为“cov _ 2007”—“cov _ 2106”)。</p><p id="c066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我创建一个列级过滤器的列表，在本例中，我希望该列等于值1。使用reduce之前的最后一步是创建我想要重复的函数。在这种情况下，我创建了一个lambda函数，它只接受两列的逻辑或(如果需要，您可以使用' &amp; '来代替AND)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b74c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就够了！使用' reduce '节省了我大量的时间来写出不必要的条件，或者写一个不好的for循环。我希望你喜欢阅读！</p></div></div>    
</body>
</html>