<html>
<head>
<title>Every Single Awesome Built-In Function In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中每一个令人敬畏的内置函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/every-single-awesome-built-in-function-in-python-f36a23842954#2022-01-06">https://towardsdatascience.com/every-single-awesome-built-in-function-in-python-f36a23842954#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="c051" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Python中每一个令人敬畏的内置函数</h1></div><div class=""><h2 id="df92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看这种语言已经提供的一些最好的Python方法，以及如何使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49d0a9574ecf002f06a411caf996a6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qq6sfgjojNHqSn7cJKE_-A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-5811382/" rel="noopener ugc nofollow" target="_blank"> Viki_B </a>提供)</p></figure><h1 id="0a40" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="fef3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">ython以其C解释的和类似英语的语法荣耀，已经在机器学习领域运行了几年。令人惊讶的是，一种可以用世界上最有影响力和最强大的编程语言之一轻松编写的高级解释脚本语言在机器学习方面表现出色。就语言和科学计算而言，Python的成功是当之无愧的，也是不言自明的。</p><p id="9a84" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">虽然Python是一种相对容易掌握的语言，读起来像英语，语法简单，但它可能很难掌握。Python编程语言在某些领域有很大的深度，不断接触新的模块和工具以了解更多他们碰巧正在学习的东西是很棒的——这就是计算的乐趣。外面有这么多东西，没有一个人不能探索新的东西。总是有更多的东西要学，所以热爱学习的人应该考虑数据科学或某种软件工程的职业生涯，这很有趣，而且很多人没有意识到这是非常有创造性的。</p><p id="76d9" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">有了这种艺术，总有办法提高你的技术。为了说明这一点，我想介绍一个场景。:在我们所有的开发者故事和数据科学旅程中，有一段时间我们遇到了另一个比我们优秀得多的程序员。最棒的是我们有一个极好的机会去学习，不好的是当我们觉得我们不知道我们在做什么，因为</p><blockquote class="nb nc nd"><p id="87b7" class="lr ls ne lt b lu mw ju lw lx mx jx lz nf my mc md ng mz mg mh nh na mk ml mm im bi translated">他/她/他们只是把我的20行互相嵌套的循环变成了一行方法调用。</p></blockquote><p id="eb48" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">好吧，不管怎样，也许这只是我早期和我的一个老师经历过的一个场景——但是情况表明，在你的武器库中拥有一堆方法和这些方法的小技巧是很重要的。对于Python来说尤其如此，我将这种语言描述为在对象旁边有一个非常有条理的生态系统。我最近写了一篇关于我最喜欢的Python装饰者的文章。这让我开始思考，我最喜欢的东西是什么…只是Python..？我认为它的包装让它变得很棒。我首先想到的是标准库中令人惊奇的选择方法，这些方法总是很有用。如果你想阅读我关于装饰者的文章，这里有一个链接:</p><div class="ni nj gp gr nk nl"><a rel="noopener follow" target="_blank" href="/10-of-my-favorite-python-decorators-9f05c72d9e33"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">我最喜欢的10个Python装饰者</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">Python编程语言中更多优秀装饰者的概述。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div><p id="b8ad" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">不断接触新的做事方法是很棒的，今天我们将回顾一些我一直以来最喜欢的方法，</p><blockquote class="oa"><p id="5c21" class="ob oc it bd od oe of og oh oi oj mm dk translated">你可能没有注意到他们。</p></blockquote><p id="2f45" class="pw-post-body-paragraph lr ls it lt b lu ok ju lw lx ol jx lz ma om mc md me on mg mh mi oo mk ml mm im bi translated">我们将讨论Python编程语言中的所有内置函数。这不包括用Python打包的标准库中的那些。这些功能的伟大之处在于它们总是在那里帮助你。另外，对于那些想自己尝试这段代码的人来说，这里是这篇文章的笔记本:</p><div class="ni nj gp gr nk nl"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/essential%20and%20builtin%20python%20funcs.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd iu gy z fp nq fr fs nr fu fw is bi translated">Emmetts-DS-NoteBooks/essential和内置python funcs.ipynb at master …</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="op l nw nx ny nu nz ks nl"/></div></div></a></div></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="9936" class="kz la it bd lb lc ox le lf lg oy li lj jz oz ka ll kc pa kd ln kf pb kg lp lq bi translated">№1: abs()</h1><p id="10f6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">abs()方法是一种内置于Python核心的方法。我记得在我早期的编程经历中，当我还是一个小孩子的时候，看到各种语言中一直在使用abs()，但不知道它是什么意思。因此，假设我们中的许多人都使用过这种方法，或者至少以前在某人的代码中见过它，这可能是明智的。这个方法到底是做什么的，这个方法的一些常规用法是什么？</p><p id="1e67" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">abs()中的abs()是absolute的简称。该函数返回两个数值之间的绝对距离。这些术语中的距离是数字上远离零的索引，例如，你离零有多少个数字，你们之间有什么。假设列表中有两个项目:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="5221" class="ph la it pd b gy pi pj l pk pl">list = [5, -32]</span></pre><p id="1645" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果我们想计算5是否在-32的3以内，您首先需要将-32转换为它的正等效值，然后将这两个值相减。要做到这一点，我们需要找出这个数字是否是负数，如果是，那么我们将不得不看看我们的数字是小于它还是大于它，等等。最后变成了一堆条件句。然而，有了abs，</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="71c6" class="ph la it pd b gy pi pj l pk pl">abs(5 - 32)</span><span id="91a6" class="ph la it pd b gy pm pj l pk pl">27</span></pre><blockquote class="nb nc nd"><p id="fc16" class="lr ls ne lt b lu mw ju lw lx mx jx lz nf my mc md ng mz mg mh nh na mk ml mm im bi translated">那就简单多了。</p></blockquote><h1 id="95e9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:任何()</h1><p id="42e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们今天要看的第二个方法是any()方法。any()方法可以用于许多不同的事情，通常用于列表，尽管它意味着接受任何iterable。any方法只是简单地检查列表的所有索引是真还是假。如果任何元素为真，它将返回true。如果所有的元素都是假的，它将返回假。如果没有元素，它将返回false。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="af57" class="ph la it pd b gy pi pj l pk pl">any([True, False, True])</span><span id="ef9b" class="ph la it pd b gy pm pj l pk pl"><br/>any([False, False])</span><span id="bb3c" class="ph la it pd b gy pm pj l pk pl">False</span><span id="b221" class="ph la it pd b gy pm pj l pk pl"><br/>any([])</span><span id="42bf" class="ph la it pd b gy pm pj l pk pl">False</span></pre><p id="c2eb" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">让我们把这纳入一个使用概念，我们将首先考虑以下功能:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="6108" class="ph la it pd b gy pi pj l pk pl">def check_list(lst : list):<br/>    if any(lst):<br/>        print("there is now a value")</span></pre><p id="5de0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这个函数检查一个列表，看看里面是否有任何东西。这是一个更干净的选择，如果有的话，只调用(list)而不是</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="5203" class="ph la it pd b gy pi pj l pk pl">if len(lst) &gt; 0:<br/>    print("There is now a value")</span></pre><p id="a493" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">但是，在这种情况下，any()方法有一些重要的问题需要考虑，</p><blockquote class="oa"><p id="2e76" class="ob oc it bd od oe of og oh oi oj mm dk translated">性能。</p></blockquote><p id="9ed4" class="pw-post-body-paragraph lr ls it lt b lu ok ju lw lx ol jx lz ma om mc md me on mg mh mi oo mk ml mm im bi translated">第二个例子可能没有那么漂亮，但是由于any方法的迭代性质，它可能会更快。也就是说，这个模块有很多很酷的应用程序，所以我肯定会在库中保留一个标签，以防这种用例在您的工作中发生。</p><h1 id="e024" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">ascii()</h1><p id="4122" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">ascii方法提供了Python字符的可打印版本。也就是说，扩展的ascii是一种全球计算标准，例如，要让打印机正确地读取整数，而不是作为字符读取，它们需要加上48才能正确地驻留在ascii表上。基本上，这个函数可以用来将标准的Python字符转换成ascii标准。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="c1c4" class="ph la it pd b gy pi pj l pk pl">ascii("hello")<br/>"'hello'"</span></pre><h1 id="f706" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">bin()</h1><p id="d5e0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">bin方法只是将一个值(由于某种原因不能是char)返回到一个字节的数据中。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="e455" class="ph la it pd b gy pi pj l pk pl">bin(50)<br/>'0b110010'</span></pre><p id="b7fc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果您正在从Python中控制汇编代码，这可能是有用的，但是该事件的可能性在统计上可能并不显著。很有可能这在Python中完全没用。</p><h1 id="157b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">可调用()</h1><p id="fd1a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果对象是可调用的，callable()方法返回true，否则返回false。我认为这个函数的真正用途最初来自于产生“_不可调用！”错误。然而，它可能对一些在你自己的软件中相似的应用程序有用，所以这是一个值得注意的功能。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="186e" class="ph la it pd b gy pi pj l pk pl">callable(5)<br/>False</span></pre><h1 id="6664" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">编译()</h1><p id="3e11" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">compile()方法只是编译一个添加的参数python文件。我们可以编译一串Python。然后将这个编译后的Python放入一个可以执行的对象中。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="4ead" class="ph la it pd b gy pi pj l pk pl">code = 'sum([5, 10, 15])'<br/>codeObeject = compile(code, 'sumstring', 'exec')</span><span id="bbf5" class="ph la it pd b gy pm pj l pk pl">exec(codeObeject)</span></pre><p id="43c5" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">对象的类型是我们的变量名:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="7666" class="ph la it pd b gy pi pj l pk pl">type(codeObject)<br/>code</span></pre><h1 id="08cd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">枚举()</h1><p id="a80d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">enumerate方法将接受一个iterable，并返回对应于每个索引的索引位置的键。每当我们需要循环计数，或者需要我们处理的每个值的索引时，这通常在for循环中使用。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="5f28" class="ph la it pd b gy pi pj l pk pl">for index, val in enumerate([5, 10, 15]):<br/>    print(index, "\n", val)</span><span id="295c" class="ph la it pd b gy pm pj l pk pl">0 <br/> 5<br/>1 <br/> 10<br/>2 <br/> 15</span></pre><p id="d8c8" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在这里，我只是打印了每个值，每个值之间有一个\n，它开始一个新行。非常简单，但是很容易看出这种方法的应用领域。也就是说，enumerate有很多不同的用例，它肯定是Python的一个功能。也就是说，我强烈建议选择这个来提高自己的Python技能。这可能是这个列表中为数不多的方法之一，实际上我可以自信地说我每天都在使用它，所以有了这种用处，就很容易明白为什么我推荐使用它了。</p><h1 id="40db" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">静态方法()</h1><p id="b103" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">staticmethod函数实际上是一个非常酷的函数，可以用来从Python中移除一些范例。我们可以调用面向对象类的函数来创建一个公共的全局版本。实际上，这意味着我们可以有条不紊地上课。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="50d4" class="ph la it pd b gy pi pj l pk pl">class Adder:</span><span id="84d6" class="ph la it pd b gy pm pj l pk pl">def add_numbers(num1, num2):<br/>    return num1 + num2</span><span id="1d0e" class="ph la it pd b gy pm pj l pk pl">Adder.add_numbers = staticmethod(Adder.add_numbers)</span><span id="b47a" class="ph la it pd b gy pm pj l pk pl">tot = Adder.add_numbers(5, 7)<br/>print(tot)</span></pre><p id="62fc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最棒的是，我们不再需要用我们的类创建一个新的类型，我们可以直接调用这个方法。当你有一个私有方法时，这是很方便的，但是你更希望它是全局的，特别是当你不是写这样一个类的人的时候。</p><h1 id="800d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">过滤器()</h1><p id="3cf8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">filter()方法与几乎所有其他编程语言中的filter()方法非常相似。该方法可用于根据“掩码”过滤iterable掩码只是位数组的高级名称。位数组只是一个位的数组，意味着一个带索引的位的集合。一个位只是一个真/假值，通常是1或0。换句话说，一个位数组只是一个布尔数组，或者一个二进制数组，例如…</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="680e" class="ph la it pd b gy pi pj l pk pl">[0, 1, 0, 1, 1, 0, 1, 0]</span></pre><p id="c4dc" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">为了使用filter()方法进行过滤，我们只需创建一个过滤函数——或表达式。我们也可以像上面一样用一个位数组来实现，但是我将使用一个函数，因为这在Python约定中似乎更典型:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="2fc2" class="ph la it pd b gy pi pj l pk pl">def filter_func(x):<br/>    if x &lt; 5:<br/>        return(False)<br/>    else:<br/>        return(True)</span></pre><p id="7a21" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在让我们制作一个数组来使用:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="499b" class="ph la it pd b gy pi pj l pk pl">d = [1, 3, 5, 7, 9, 11]</span></pre><p id="773d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">最后，我们可以通过filter()方法传递它。然而，这个函数的输出可能不是您所期望的:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="a188" class="ph la it pd b gy pi pj l pk pl">z = filter(filter_func, d)</span><span id="99a0" class="ph la it pd b gy pm pj l pk pl">&lt;filter at 0x7fb7851834f0&gt;</span></pre><p id="7c93" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们得到的不是过滤后的数组的返回，而是一个过滤器对象。filter对象是预过滤元素的迭代器。为了演示如何使用一个简单的for循环，我将把它们拿出来:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="a2cb" class="ph la it pd b gy pi pj l pk pl">vals = [w for w in z]<br/>print(vals)</span><span id="c78a" class="ph la it pd b gy pm pj l pk pl">[5, 7, 9, 11]</span></pre><h1 id="340f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">格式()</h1><p id="4d10" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python中的一个对数据科学应用程序非常有用的函数是format()方法。这个方法可以用一个简单的char将任何值转换成给定的格式。例如，我们可以使用以下语法将值. 5转换成百分比:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="2623" class="ph la it pd b gy pi pj l pk pl">x = .5<br/>fifty_percent = format(x, '%')</span></pre><p id="89d7" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我对这个函数的唯一看法，更具体地说，它在数据科学中的应用，是这个新格式化值的数据类型是<strong class="lt iu">而不是</strong>。我觉得这多少破坏了这个功能的价值。例如，如果有一个百分比类型，我们的值随后被转换为百分比类型，这也很好，但是看看我们得到的类型:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="ed48" class="ph la it pd b gy pi pj l pk pl">print(type(fifty_percent))<br/>print(fifty_percent)</span><span id="ebd0" class="ph la it pd b gy pm pj l pk pl">&lt;class 'str'&gt;<br/>50.000000%</span></pre><p id="f71d" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">虽然有点不足，但是，在很多情况下，这个函数都可以派上用场——而且在基本Python中，它肯定是值得了解的。</p><h1 id="f8f8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">getattr()</h1><p id="9e54" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">getattr()是一个相当简单的方法，但是它可以用于许多不同的事情。一般来说，它并不完全用于标准的Python操作，但是，在某些情况下，它肯定会派上用场。考虑我们以前的加法器类，但是现在有了更多的数据:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="1d9e" class="ph la it pd b gy pi pj l pk pl">class Adder:<br/>    numbers_added = 0<br/>    def add_numbers(num1, num2):<br/>        self.numbers_added += 1<br/>        return num1 + num2</span></pre><p id="981e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们现在可以使用getattr()方法获得numbers_added属性:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="3baf" class="ph la it pd b gy pi pj l pk pl">ouradder = Adder()</span><span id="ae16" class="ph la it pd b gy pm pj l pk pl">added = getattr(ouradder, "numbers_added")</span><span id="4747" class="ph la it pd b gy pm pj l pk pl">print(added)</span><span id="9b2f" class="ph la it pd b gy pm pj l pk pl">0</span></pre><p id="12f0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我认为这可以派上用场的地方是第三个位置参数，默认。该参数允许设置默认值。举一个更奇怪的例子，假设我们已经编写了一个完整的游戏，这两个类是我们的元素:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="8584" class="ph la it pd b gy pi pj l pk pl">class Player:<br/>    hp = 1</span><span id="cc2a" class="ph la it pd b gy pm pj l pk pl">class Bush:<br/>    def __init__(self, size):<br/>        self.size = size</span></pre><p id="dab0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">玩家职业有属性hp，但是灌木没有生命值，所以它没有。现在让我们假设我们有一个方法来检查游戏中所有对象的健康状况，就像这样:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="0cfe" class="ph la it pd b gy pi pj l pk pl">def check_hp(x):<br/>    print(x.hp)</span></pre><p id="8deb" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">如果我们让一个玩家通过这个新方法，一切都很好:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="e20e" class="ph la it pd b gy pi pj l pk pl">check_hp(Player())</span><span id="27e1" class="ph la it pd b gy pm pj l pk pl">1</span></pre><p id="bddd" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然而，由于Bush类型没有属性hp，一旦我们在Bush上尝试，我们将得到一个恰当命名的<strong class="lt iu">属性错误</strong>:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="4f54" class="ph la it pd b gy pi pj l pk pl">check_hp(Bush(5))</span><span id="7ba9" class="ph la it pd b gy pm pj l pk pl">AttributeError: 'Bush' object has no attribute 'hp'</span></pre><p id="af2c" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们可以通过使用getattr()方法减轻这种情况，并提供一个默认值零。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="7bcb" class="ph la it pd b gy pi pj l pk pl">def check_hp(x):<br/>    hp = getattr(x, "hp", 0)<br/>    print(hp)</span><span id="017b" class="ph la it pd b gy pm pj l pk pl">check_hp(Bush(5))</span><span id="4535" class="ph la it pd b gy pm pj l pk pl">0</span></pre><p id="8fb0" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">现在，一个完整的玩家和灌木丛列表可以毫无问题地调用这个方法，而且它会忽略那些没有这个属性的类。</p><h1 id="2abd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">全局()</h1><p id="acd4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">globals()方法只是返回当前全局范围内所有全局定义的别名的字典。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="009a" class="ph la it pd b gy pi pj l pk pl">x = globals()<br/>print(x)</span><span id="aeef" class="ph la it pd b gy pm pj l pk pl">{'__name__': '__main__', '__doc__': 'Automatically created module for IPython interactive environment', '__package__': None, '__loader__': None, '__spec__': None, '__builtin__': &lt;module 'builtins' (built-in)&gt;, '__builtins__': &lt;module 'buil...............</span></pre><p id="f92a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这在某些情况下非常有用，尤其是在跟踪给定全局范围的状态非常重要的情况下。</p><h1 id="d113" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">哈希()</h1><p id="1b8f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如所料，hash()方法返回给定Python对象的散列值。这有许多应用，并被广泛用于根据本质上并不完全唯一的UUID来跟踪代码中的对象。除了唯一性之外，唯一的区别是UUID的hash()版本也是…</p><blockquote class="oa"><p id="58a8" class="ob oc it bd od oe of og oh oi oj mm dk translated">数据。精彩，漂亮，数据。</p></blockquote><p id="2ee4" class="pw-post-body-paragraph lr ls it lt b lu ok ju lw lx ol jx lz ma om mc md me on mg mh mi oo mk ml mm im bi translated">也就是说，UUID的值通常是任意的并且完全唯一，而散列的值遵循特定的散列算法(散列函数)。)这通常应用于密码术中，因为散列经常被用作存储或传输信息的私有方式。把它想象成一把锁，哈希是数据上的锁，哈希函数是打开锁的钥匙。</p><h1 id="3654" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">iter()</h1><p id="cba7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">iter()方法非常有用。它可以用来从任何类型的iterable中快速创建一个迭代器，如果一个特定的类型在其定义中没有绑定__iter__ default函数，这将非常方便。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="054e" class="ph la it pd b gy pi pj l pk pl">mylist = iter(["spaghetti", "onions", "celery"])</span></pre><p id="af60" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">此外，它还可以和其他方法一起使用，比如下面的例子:</p><h1 id="1fbd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">下一个()</h1><p id="4ba9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">next()方法可用于返回迭代器的下一个值。这可以用在任何类型的迭代器上。它可以用来构建你自己的全局类型的循环，这非常棒。在迭代时，您可以有效地定义全局值，而不必受限于for循环的边界。</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="d0e4" class="ph la it pd b gy pi pj l pk pl">mylist = iter(["spaghetti", "onions", "celery"])<br/>x = next(mylist)<br/>print(x)<br/>x = next(mylist)<br/>print(x)<br/>x = next(mylist)<br/>print(x)</span><span id="ae0b" class="ph la it pd b gy pm pj l pk pl">spaghetti<br/>onions<br/>celery</span></pre><h1 id="a879" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">反转()</h1><p id="0751" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个方法真的很简单，但是很有用。这个函数的结果在Python语言中随处可见。如果你熟悉reverse或rev是你正在使用的方法中的一个关键词参数，那就太惊讶了！一直以来，您都在使用依赖于Python基础上的这个方法的函数调用！</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="9392" class="ph la it pd b gy pi pj l pk pl">mylist = reversed(["spaghetti", "onions", "celery"])<br/>x = next(mylist)<br/>print(x)<br/>x = next(mylist)<br/>print(x)<br/>x = next(mylist)<br/>print(x)</span><span id="77a6" class="ph la it pd b gy pm pj l pk pl">celery<br/>onions<br/>spaghetti</span></pre><h1 id="e2f5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">切片()</h1><p id="28b1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">slice()方法也是处理集合的一个非常棒和有用的方法。该方法可用于选择给定iterable的特定索引。我们可以使用start参数选择单个，或者使用start和stop参数选择一个范围:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="bf4a" class="ph la it pd b gy pi pj l pk pl">a = [5, 10, 15]<br/>x = slice(1, 2)<br/>print(a[x])<br/>[5, 10]</span></pre><p id="9081" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们还可以使用step参数更进一步。这个参数将从开始到结束取那个间隔，并且只返回那些值。在这里，我使用精确的方法得到字母表中的每三个字母:</p><pre class="kj kk kl km gt pc pd pe pf aw pg bi"><span id="d6b7" class="ph la it pd b gy pi pj l pk pl"># Every third letter<br/>a = ("a", "b", "c", "d", "e", "f", "g", "h")<br/>x = slice(1, len(a), 3)<br/>print(a[x])</span></pre></div><div class="ab cl oq or hx os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="im in io ip iq"><h1 id="a890" class="kz la it bd lb lc ox le lf lg oy li lj jz oz ka ll kc pa kd ln kf pb kg lp lq bi translated">结论</h1><p id="19f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python编程语言是一种因其高级本质而广受尊崇的语言，这肯定是有道理的。这些方法中有很多展示了高级Python如何获得一些开箱即用的相当激进的能力。所有这些都很容易使用，这是一个优势。在这种情况下，知道就已经成功了一半！感谢您阅读我的文章，我很高兴能够为您的Python技能做出贡献！</p></div></div>    
</body>
</html>