<html>
<head>
<title>Serverless Deployment of Machine Learning Models on AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS Lambda上机器学习模型的无服务器部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serverless-deployment-of-machine-learning-models-on-aws-lambda-5bd1ca9b5c42#2022-01-13">https://towardsdatascience.com/serverless-deployment-of-machine-learning-models-on-aws-lambda-5bd1ca9b5c42#2022-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="cc7f" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">AWS Lambda上机器学习模型的无服务器部署</h1></div><div class=""><h2 id="4cc4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在AWS Lambda上部署dockerised ML模型的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5d114f66abe8e957e1ec97fd62305c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L1h_amj7O3SPQ3dh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@benchaccounting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">钳工</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="0b9d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="ccae" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我之前的<a class="ae kv" rel="noopener" target="_blank" href="/deploying-docker-containerised-ml-models-on-aws-elastic-beanstalk-67cbfbb2def4">指南</a>中，我们探讨了在AWS Elastic Beanstalk上部署机器学习模型的概念和方法。尽管在很大程度上是自动化的，但像AWS Elastic Beanstalk这样的服务仍然需要部署EC2实例和弹性负载平衡器这样的关键服务。AWS Elastic Beanstalk上提供的资源总是活动的，即使不需要。</p><p id="720a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过消除基础设施管理任务，无服务器代码编排的概念脱离了云计算资源的传统实现。无服务器云计算是在Elastic Beanstalk上提供的免手动基础设施管理方法的演变，但没有服务器的供应或管理。</p><p id="9c1b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">无服务器计算是一种事件驱动的计算服务，可以为几乎任何应用程序运行代码。由于开发人员不需要管理基础设施，代码的无服务器实现具有提高生产率的好处，因为开发人员可以花更多的时间编写代码。最终，无服务器功能是无状态的，只在你需要的时候执行。这使得它们成为许多应用的高性价比解决方案。</p><p id="675c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本指南中，我们将学习如何将机器学习模型部署为lambda函数，即AWS提供的无服务器产品。我们将首先通过在我们的机器上集成AWS CLI来设置工作环境。接下来，我们将训练一个K近邻分类器，我们将把它部署为docker容器。本指南将带您浏览您需要的工具，使您能够在将应用程序部署为AWS上的lambda函数之前，在本地测试您的应用程序。</p><p id="5df1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们开始吧。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="878a" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">内容</h1><ul class=""><li id="9272" class="nb nc iq lq b lr ls lu lv lx nd mb ne mf nf mj ng nh ni nj bi translated">先决条件</li><li id="5319" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">MNIST数据集简介</li><li id="f8ed" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">训练K-最近邻(KNN)分类器</li><li id="c580" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">初始化AWS S3存储桶</li><li id="4cf4" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">使用SAM部署和测试AWS lambda函数</li><li id="397b" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">AWS资源终止</li><li id="7515" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">摘要</li></ul></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="0b5d" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">先决条件</h1><p id="c511" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在继续之前，您需要满足几个先决条件。本指南将要求您与许多工具进行交互，因此请花一些时间来满足这些先决条件。</p><ol class=""><li id="a2d0" class="nb nc iq lq b lr mk lu ml lx np mb nq mf nr mj ns nh ni nj bi translated">你需要一个<a class="ae kv" href="https://aws.amazon.com/free" rel="noopener ugc nofollow" target="_blank"> AWS </a>账户。您可以注册免费层，该层将在注册时自动应用。</li><li id="7dc8" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">导航命令行的一些技术知识。</li><li id="6861" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">安装<a class="ae kv" href="https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a></li><li id="3eaf" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated"><a class="ae kv" href="https://medium.com/@lloyd.hamilton/setting-up-aws-cli-credentials-65d0a5fc0c4e" rel="noopener">设置AWS CLI </a></li><li id="d045" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">安装<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" rel="noopener ugc nofollow" target="_blank"> AWS无服务器应用模型CLI </a></li><li id="b3cd" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">安装<a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="0b44" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated"><a class="ae kv" href="https://www.python.org/downloads/release/python-397/" rel="noopener ugc nofollow" target="_blank"> Python 3.9.7 </a></li><li id="ccf4" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated"><a class="ae kv" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"> VS代码</a>与<a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=ms-toolsai.jupyter" rel="noopener ugc nofollow" target="_blank"> Jupyter扩展</a>或任何你喜欢的IDE。</li><li id="63c8" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">诗歌——Python包管理工具(阅读我的<a class="ae kv" href="https://python.plainenglish.io/poetic-simplification-of-python-virtual-environments-dc2ebf12b1a4" rel="noopener ugc nofollow" target="_blank">上一篇关于如何使用诗歌的文章</a></li><li id="1cc4" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">Python库:scikit-learn、numpy、requests、pandas、joblib、boto3、matplotlib、py toolter、jupyter、ipykernel。您可以使用poem安装我当前的python版本，或者将<code class="fe nt nu nv nw b">requirements.txt</code>文件包含在Git存储库中。</li><li id="5b84" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">这个项目的项目存储库在这里被链接<a class="ae kv" href="https://github.com/lloydhamilton/aws_lambda_no_authoriser" rel="noopener ugc nofollow" target="_blank">。代码的主体可以在Jupyter笔记本中找到，链接</a><a class="ae kv" href="https://github.com/lloydhamilton/aws_lambda_no_authoriser/blob/master/deploying_lambda.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</li></ol></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="7dfd" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">概观</h1><p id="88fb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本指南的目的是向您介绍在AWS上将机器学习模型部署为lambda函数所需的步骤。本指南记录了部署lambda函数所需的关键工具。这是我们将在这个项目中涵盖的内容的概述。</p><ul class=""><li id="a987" class="nb nc iq lq b lr mk lu ml lx np mb nq mf nr mj ng nh ni nj bi translated">在用于部署的MNIST数据集上训练K-最近邻分类器。</li><li id="eed5" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">将S3存储桶初始化为数据存储。</li><li id="3da4" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">使用AWS无服务器应用程序模型(SAM)对dockerised lambda函数进行本地测试。</li><li id="662d" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ng nh ni nj bi translated">使用AWS SAM部署云形成堆栈。</li></ul></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="05f2" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">1.MNIST数据简介</h1><p id="9f5f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于这个分类项目，我们将使用包含70，000张手写数字图像的<a class="ae kv" href="https://en.wikipedia.org/wiki/MNIST_database" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据集。在该数据集中，每行代表一幅图像，每列代表28×28像素图像中的一个像素。MNIST数据集被广泛用于训练分类器，并且可以使用辅助函数<code class="fe nt nu nv nw b"><a class="ae kv" href="http://scikit-learn.org/stable/modules/generated/sklearn.datasets.fetch_openml.html" rel="noopener ugc nofollow" target="_blank">sklearn.datasets.fetch_openml</a></code>来获取。来自OpenML的所有数据都是免费使用的，包括所有的经验数据和元数据，在<a class="ae kv" href="http://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">CC-BY license</a>下许可使用。</p><p id="0e62" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个项目的所有代码都可以在Jupyter笔记本中找到，<code class="fe nt nu nv nw b">deploying_models.ipynb</code>，从github repo链接<a class="ae kv" href="https://github.com/lloydhamilton/aws_lambda_no_authoriser" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="3c88" class="ob kx iq nw b gy oc od l oe of">aws_lambda_no_authoriser<br/>├── app<br/>│   ├── lambda_predict.py<br/>│   └── knnclf.joblib<br/>├── .gitignore<br/>├── Dockerfile<br/>├── LICENSE<br/>├── deploying_lambda.html<br/>├── deploying_lambda.ipynb<br/>├── overview.png<br/>├── poetry.lock<br/>├── pyproject.toml<br/>├── requirements.txt<br/>└── template_no_auth.yaml</span></pre><p id="914a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面的代码将下载MNIST数据，并对20，000行进行采样。该数据集已经过缩减，以减少该项目的模型大小和构建时间。下面的代码还将绘制数据集中的第一幅图像，我们可以看到它是数字8。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9057cf238e6caa23fdb195c549740dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*ckoGWeQizuUiF7Esc5u5Dw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">绘图输出显示第一个图像是手写的数字8。(图片由作者提供)</p></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="2182" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">2.训练K-最近邻分类器</h1><p id="062b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">首先，我们将把数据分成训练集和测试集，然后使用<code class="fe nt nu nv nw b">scikit-learn</code>库训练一个K近邻分类器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="5046" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过交叉验证，该模型达到了相当不错的96%的平均准确率。让我们在<code class="fe nt nu nv nw b">test_features</code>数据集上评估模型的性能，并使用<code class="fe nt nu nv nw b">show_cm</code>函数绘制一个混淆矩阵，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/799b4a0fb5ca9f45fdc091949d86ff09.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*TQExZpmvo-xTUzBQQnvAsA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">准确度:0.95725(图片由作者提供)</p></figure><p id="f8a2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">基于测试数据集的准确性，我们可以看到我们的模型符合数据。当比较训练集和测试集之间的准确性时，我们得到了非常相似的预测准确性。</p><p id="3d22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，如上图所示的混淆矩阵非常有助于可视化模型性能的差距。这将有助于我们理解分类器所犯的错误。</p><p id="1063" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该矩阵表明，在16个例子中，数字4被误认为数字9，在12个例子中，数字8被误认为数字5。</p><p id="1907" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看下面的图片，可能会明白为什么会出现这些错误，因为数字4和9确实有一些相似的特征。数字8和5也是如此。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/1fc8131e48828362b88060dec22fd54f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wjf5-j41OCytuQx4mIhZgg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="97ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这一见解不会影响AWS上的模型部署，但将有助于指导进一步改进模型的策略。</p><p id="1861" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们将使用Docker将模型保存在本地，作为lambda函数的一部分进行封装。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="30f2" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">3.初始化AWS S3存储桶</h1><p id="9cce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下图展示了支持lambda函数所需部署的整体资源基础设施。我们的应用程序有三个关键的资源要求:</p><ol class=""><li id="72d2" class="nb nc iq lq b lr mk lu ml lx np mb nq mf nr mj ns nh ni nj bi translated"><strong class="lq ir"> S3桶</strong>用来存储数据。</li><li id="583f" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated"><strong class="lq ir"> API网关</strong>管理HTTP请求。</li><li id="118b" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated"><strong class="lq ir">λ函数</strong>包含预测逻辑。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/e0dac11bbba0ba3cc031aa7860ac757c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3lPjvBv7aWZRUnfIRb56Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ML模型的无服务器部署——1)测试数据上传到S3桶。2)为了启动lambda函数，通过Amazon API网关发送一个POST HTTP请求。lambda函数的初始化执行从S3桶下载数据并执行预测的代码。4)HTTP响应返回给客户端，预测作为数据有效载荷。(图片由作者提供)</p></figure><p id="bcd1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Lambda函数将包含基于存储在S3存储桶中的<code class="fe nt nu nv nw b">test_features</code>数据集执行预测的Python代码。因此，我们将首先需要初始化一个S3桶，在那里我们可以托管我们的数据。</p><p id="e00e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为此，我们将使用AWS Python SDK <code class="fe nt nu nv nw b">boto3</code>与AWS进行交互。这个包包含了我们集成Python项目和AWS所需的所有依赖项。</p><p id="a130" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们用下面的代码初始化一个S3桶。</p><p id="8089" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> <em class="om">注意:</em></strong><em class="om"/><code class="fe nt nu nv nw b"><em class="om">bucket_name</em></code><em class="om">必须是唯一的，因此您必须用一个未被采用的名称替换</em> <code class="fe nt nu nv nw b"><em class="om">bucket_name</em></code> <em class="om">。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8791" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">S3存储桶将托管我们的<code class="fe nt nu nv nw b">test_features</code>数据集，我们可以在lambda函数中调用该数据集来执行预测。</p><p id="dbb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了保存当前在我们工作区中的对象，我们将使用来自<code class="fe nt nu nv nw b">io</code>库的<code class="fe nt nu nv nw b">BytesIO</code>函数。这将使我们能够在文件对象中临时存储<code class="fe nt nu nv nw b">test_features</code>数据集。这个文件对象可以通过调用<code class="fe nt nu nv nw b">.upload_fileobj</code>函数上传到S3桶。</p><p id="791e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b">bucket</code>变量定义目标S3桶，而<code class="fe nt nu nv nw b">key</code>变量将定义桶中的文件路径。<code class="fe nt nu nv nw b">bucket</code>和<code class="fe nt nu nv nw b">key</code>变量将构成对lambda函数的POST HTTP请求中的数据有效载荷的一部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7111" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以用下面的帮助函数检查对象是否已经上传。<code class="fe nt nu nv nw b">list_s3_objects</code>将列出定义的桶中的所有对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ace1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出:<code class="fe nt nu nv nw b">[‘validation/test_features.joblib’]</code></p><p id="78ef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在已经成功初始化了一个S3存储桶来存储<code class="fe nt nu nv nw b">test_feature</code>数据。接下来的两个关键资源，API网关和lambda函数，将使用AWS无服务器应用模型(SAM)进行部署。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="5ad7" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">4.使用SAM部署和测试AWS Lambda函数</h1><p id="f430" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://aws.amazon.com/serverless/sam/" rel="noopener ugc nofollow" target="_blank"> AWS SAM </a>是一个用于构建无服务器应用的开源框架。它是一个工具，通过提供简单的语法在AWS上部署功能、API或数据库，简化了无服务器架构的构建过程。SAM是一个平台，它将快速部署无服务器应用程序所需的所有工具统一在一个YAML配置文件中。</p><p id="4b5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有其他选项，例如<a class="ae kv" href="https://www.serverless.com" rel="noopener ugc nofollow" target="_blank">无服务器</a>，这是一个很好的选项。无服务器具有作为通用云接口(AWS、Azure、Google Cloud)的额外优势，以增加多功能性。然而，我个人发现在AWS SAM上本地集成和测试docker容器比在无服务器上更好。我很好奇是否有人有不同的意见！一定要留个便条。</p><p id="648b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是当前项目的整体文件夹结构，可以在github <a class="ae kv" href="https://github.com/lloydhamilton/aws_lambda_no_authoriser" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="6867" class="ob kx iq nw b gy oc od l oe of">aws_lambda_no_authoriser<br/>├── app<br/>│   ├── lambda_predict.py<br/>│   └── knnclf.joblib<br/>├── .gitignore<br/>├── Dockerfile<br/>├── LICENSE<br/>├── deploying_lambda.html<br/>├── deploying_lambda.ipynb<br/>├── overview.png<br/>├── poetry.lock<br/>├── pyproject.toml<br/>├── requirements.txt<br/>└── template_no_auth.yaml</span></pre><p id="07b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在下面的部分中，我将专门讨论三个重要的文件。</p><ol class=""><li id="3a2e" class="nb nc iq lq b lr mk lu ml lx np mb nq mf nr mj ns nh ni nj bi translated">详细说明SAM配置的<code class="fe nt nu nv nw b">.yaml</code>文件。(<code class="fe nt nu nv nw b">template_no_auth.yaml</code>)</li><li id="8329" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">一个包含lambda函数代码的<code class="fe nt nu nv nw b">.py</code>文件。(<code class="fe nt nu nv nw b">lambda_predict.py</code>)</li><li id="26e6" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">一个<code class="fe nt nu nv nw b">Dockerfile</code>详细描述了封装我们的lambda函数的代码。(<code class="fe nt nu nv nw b">Dockerfile</code>)</li></ol><h2 id="6448" class="ob kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated"><code class="fe nt nu nv nw b">4.1. template_no_auth.yaml</code></h2><p id="bdbc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nt nu nv nw b">template_no_auth.yaml</code>定义了构建无服务器应用程序所需的所有代码。你可以在这里找到模板规范<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification.html" rel="noopener ugc nofollow" target="_blank">的官方文档。</a></p><p id="0167" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> <em class="om">注:</em> </strong> <em class="om">该当前模板不包括执行API请求的服务器端认证的资源。因此，在当前状态下部署我们的lambda函数将允许任何人使用URL向您的函数发出请求。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="f2a5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们仔细看看模板文件，以便更好地理解正在定义的配置。我将它分成三个部分，并在标题中链接了每个声明的相应文档。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="e3ee" class="ob kx iq nw b gy oc od l oe of">AWSTemplateFormatVersion: "2010-09-09"<br/>Transform: AWS::Serverless-2016-10-31<br/>Globals:<br/>   Function:<br/>      Timeout: 50<br/>      MemorySize: 5000<br/>   Api:<br/>      OpenApiVersion: 3.0.1<br/>Parameters:<br/>   Stage:<br/>      Type: String<br/>      Default: dev</span></pre><p id="1c3c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b">AWSTemplateFormatVersion</code></p><p id="625a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最新的模板格式版本是<code class="fe nt nu nv nw b">2010-09-09</code>，是目前唯一的有效值。</p><p id="bedc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html" rel="noopener ugc nofollow" target="_blank">Transform</a></code></p><p id="b9c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b">AWS::Serverless-2016–10–31</code>声明将AWS CloudFormation模板文件标识为AWS SAM模板文件，并且是SAM模板文件的要求。</p><p id="aac4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification-template-anatomy-globals.html" rel="noopener ugc nofollow" target="_blank">Globals</a></code></p><p id="821d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">特定资源使用的全局变量可以在这里定义。功能超时，内存大小分别设置为50和5000 MB。当达到指定的超时时间时，函数将停止执行。您应该将超时值设置为预期的执行时间，以防止函数运行时间超出预期。最后，在我们的模板中，我们已经将open API版本设置为3.0.1。</p><p id="ff7c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html" rel="noopener ugc nofollow" target="_blank">Parameters</a></code></p><p id="bb8e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将默认分段值设置为<code class="fe nt nu nv nw b">dev</code>。您可以定义可在yaml文件中引用的参数值。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="6192" class="ob kx iq nw b gy oc od l oe of">Resources:<br/>   LambdaAPI:<br/>      Type: AWS::Serverless::Api<br/>      Properties:<br/>         StageName: !Ref Stage<br/>   PredictFunction:<br/>      Type: AWS::Serverless::Function<br/>      Properties:<br/>         PackageType: Image<br/>         Architectures:<br/>             - x86_64<br/>         Events:<br/>            Predict:<br/>               Type: Api<br/>               Properties:<br/>                  RestApiId: !Ref LambdaAPI<br/>                  Path: /predict<br/>                  Method: POST<br/>         Policies:<br/>            - AmazonS3FullAccess<br/>      Metadata:<br/>         Dockerfile: Dockerfile<br/>         DockerContext: ./<br/>         DockerTag: python3.9-v1</span></pre><p id="101b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html" rel="noopener ugc nofollow" target="_blank">Resources</a></code></p><p id="9a2d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在参考资料部分，我们将声明应用程序所需的特定AWS资源。这个<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification-resources-and-properties.html" rel="noopener ugc nofollow" target="_blank">列表</a>详细列出了您可以在SAM中声明的可用资源的数量。</p><p id="588a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们的项目，我们将声明<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-api.html" rel="noopener ugc nofollow" target="_blank"> API网关</a>和<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-function.html" rel="noopener ugc nofollow" target="_blank"> lambda函数</a>为资源。我们不需要声明S3存储桶，因为我们已经为我们的项目创建了一个存储桶。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/e0dac11bbba0ba3cc031aa7860ac757c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3lPjvBv7aWZRUnfIRb56Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ML模型的无服务器部署——1)测试数据上传到S3桶。2)为了启动Lambda函数，通过Amazon API网关发送一个POST HTTP请求。Lambda函数的初始化执行从S3桶下载数据并执行预测的代码。4)HTTP响应返回给客户端，预测作为数据有效载荷。(图片由作者提供)</p></figure><p id="66d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在参考资料部分，声明了一个名为<code class="fe nt nu nv nw b">LambdaAPI</code>的API。<code class="fe nt nu nv nw b">LambdaAPI</code>具有属性<code class="fe nt nu nv nw b">StageName</code>，该属性具有参数stage。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="e07f" class="ob kx iq nw b gy oc od l oe of">LambdaAPI:<br/>      Type: AWS::Serverless::Api<br/>      Properties:<br/>         StageName: !Ref Stage</span></pre><p id="5fd2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">参考资料部分还声明了一个名为<code class="fe nt nu nv nw b">PredictFunction</code>的lambda函数。要将lambda函数声明为docker映像，需要将<code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-function.html#sam-function-packagetype" rel="noopener ugc nofollow" target="_blank">PackageType</a></code>变量定义为<code class="fe nt nu nv nw b">Image</code>，并且必须在yaml文件的<code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-using-build.html" rel="noopener ugc nofollow" target="_blank">Metadata</a></code>部分声明指向docker文件的链接。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="16f8" class="ob kx iq nw b gy oc od l oe of">PredictFunction:<br/>      Type: AWS::Serverless::Function<br/>      Properties:<br/>         PackageType: Image<br/>         Architectures:<br/>             - x86_64<br/>         Events:<br/>            Predict:<br/>               Type: Api<br/>               Properties:<br/>                  RestApiId: !Ref LambdaAPI<br/>                  Path: /predict<br/>                  Method: POST<br/>         Policies:<br/>            - AmazonS3FullAccess<br/>      Metadata:<br/>         Dockerfile: Dockerfile<br/>         DockerContext: ./<br/>         DockerTag: python3.9-v1</span></pre><p id="5c89" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们还指定了一个<code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-function-eventsource.html" rel="noopener ugc nofollow" target="_blank">event</a></code>，它将触发lambda函数。在这种情况下，<code class="fe nt nu nv nw b">LambdaAPI</code>对<code class="fe nt nu nv nw b">/predict</code>端点的POST HTTP请求将触发lambda函数。最后，为了让lambda函数能够访问S3存储桶，我们附加了AWS manage <a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-function.html#sam-function-policies" rel="noopener ugc nofollow" target="_blank">策略</a> <code class="fe nt nu nv nw b">AmazonS3FullAccess</code>。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="2203" class="ob kx iq nw b gy oc od l oe of">Outputs:<br/>   LambdaApi:<br/>      Description: "API Gateway endpoint URL for Dev stage for  Predict Lambda function"<br/>      Value: !Sub "https://${MyApi}.execute-api.${AWS::Region}.amazonaws.com/${Stage}/predict"</span></pre><p id="cc47" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nt nu nv nw b"><a class="ae kv" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/outputs-section-structure.html" rel="noopener ugc nofollow" target="_blank">outputs</a></code>部分，我们声明了一组在使用SAM部署应用程序后返回的输出。我已经定义了输出来返回API端点的URL以调用lambda函数。</p><h2 id="251c" class="ob kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">4.2.λ_ predict . py</h2><p id="9c7d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nt nu nv nw b">lambda_predict.py</code>文件包含与我们应用的预测逻辑相关的代码。一般而言，该功能将:</p><ol class=""><li id="7769" class="nb nc iq lq b lr mk lu ml lx np mb nq mf nr mj ns nh ni nj bi translated">加载模型。</li><li id="1691" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">下载由<code class="fe nt nu nv nw b">bucket</code>和<code class="fe nt nu nv nw b">key</code>变量引用的<code class="fe nt nu nv nw b">test_features</code>数据集。</li><li id="03ab" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">对下载的数据集执行预测。</li><li id="3e50" class="nb nc iq lq b lr nk lu nl lx nm mb nn mf no mj ns nh ni nj bi translated">以numpy数组的形式返回预测的JSON对象。</li></ol><p id="6f94" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">python文件还包含一个记录脚本进度的<code class="fe nt nu nv nw b">logger</code>类，这对调试非常有帮助。</p><p id="86f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，在优化lambda函数时，这是一个很好的时机来说明冷启动的概念以及它如何影响延迟。我已经<a class="ae kv" href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/" rel="noopener ugc nofollow" target="_blank">链接了</a>一篇文章，很好地解释了这个概念。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="7d89" class="ob kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">4.3.Dockerfile文件</h2><p id="5ffe" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nt nu nv nw b">Dockerfile</code>详述了将我们的lambda函数封装成docker映像所需的指令。我将使用Python 3.9并使用诗歌安装Python依赖项。</p><p id="98a0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">需要注意的关键点是，docker映像的入口点被设置为在<code class="fe nt nu nv nw b">lambda_predict.py</code>文件中声明的<code class="fe nt nu nv nw b">lamba_handler</code>函数。这个入口点定义了在一个<code class="fe nt nu nv nw b">event</code>触发器(比如HTTP POST请求)期间要执行的函数。初始化容器映像时，将执行同一脚本中的<code class="fe nt nu nv nw b">lambda_handler</code>函数之外的任何代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="05ec" class="ob kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">4.4.在本地构建和测试应用程序。</h2><p id="ac29" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">AWS SAM提供了在部署之前构建和本地测试应用程序的功能。</p><ol class=""><li id="d2ca" class="nb nc iq lq b lr mk lu ml lx np mb nq mf nr mj ns nh ni nj bi translated">确保docker正在运行。在终端窗口中，导航到项目目录并在SAM中构建应用程序。</li></ol><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="b6fe" class="ob kx iq nw b gy oc od l oe of">sam build -t template_no_auth.yaml</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/c9303ca0ac1066645a0795bc25222665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8kOjcZdeZjH0b3OnG4YjQg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="7290" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">2.在本地部署dockerised lambda函数。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="a29f" class="ob kx iq nw b gy oc od l oe of">sam local start-api</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/7534afc46d52a1dcaad85009cadb18cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zm7Atrxh77fs4yBmbRKh7g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="09d2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">3.在<code class="fe nt nu nv nw b"><a class="ae kv" href="http://127.0.0.1:3000." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:3000</a>/predict</code>本地调用该功能。您的URL可能有所不同。</p><p id="cf77" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> <em class="om">注意:</em> </strong> <em class="om">引用S3上</em> <code class="fe nt nu nv nw b"><em class="om">test_feature</em></code> <em class="om">数据集的</em> <code class="fe nt nu nv nw b"><em class="om">bucket</em></code> <em class="om">和</em> <code class="fe nt nu nv nw b"><em class="om">key</em></code> <em class="om">变量需要作为POST HTTP请求中数据有效载荷的一部分进行传递。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/799b4a0fb5ca9f45fdc091949d86ff09.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*TQExZpmvo-xTUzBQQnvAsA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">准确度:0.95725(图片由作者提供)</p></figure><p id="2442" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">与之前的<code class="fe nt nu nv nw b">test_feature</code>预测相比，本地调用的lambda函数如我们预期的那样执行，因为我们获得了相同的结果。</p><h2 id="81cd" class="ob kx iq bd ky on oo dn lc op oq dp lg lx or os li mb ot ou lk mf ov ow lm ox bi translated">4.5.在AWS Lambda上部署</h2><p id="1c5c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">就像在本地部署一样容易，SAM也将处理在AWS Lambda上部署的所有繁重工作。</p><p id="e144" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">a)在SAM中构建应用程序。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="18ca" class="ob kx iq nw b gy oc od l oe of">sam build -t template_no_auth.yaml</span></pre><p id="2844" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">b)部署应用程序。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="d296" class="ob kx iq nw b gy oc od l oe of">sam deploy --guided</span></pre><p id="35f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">遵循指导您完成部署配置的提示。除了少数例外，我使用的大多数设置都是默认值。</p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="09ea" class="ob kx iq nw b gy oc od l oe of">Stack Name [sam-app]: predict-no-auth<br/>AWS Region [eu-west-2]:<br/>Parameter Stage [dev]: <br/>Confirm changes before deploy [y/N]: <br/>Allow SAM CLI IAM role creation [Y/n]: <br/>Disable rollback [y/N]: y<br/>PredictFunction may not have authorization defined, Is this okay? [y/N]: y<br/>Save arguments to configuration file [Y/n]: <br/>SAM configuration file [samconfig.toml]: <br/>SAM configuration environment [default]:<br/>Create managed ECR repositories for all functions? [Y/n]:</span></pre><p id="7414" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在部署阶段，SAM将把应用程序的最新版本上传到一个托管的Amazon弹性容器注册中心(Amazon ECR)上。</p><p id="ec0f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">SAM还将输出CloudFormation事件的列表，详细说明为您的应用程序部署所请求的AWS资源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/0310cf812512844e4b79a424cb3ebdc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFloKgvooyUosKDNEZ6OSg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自堆栈操作的云形成事件(图片由作者提供)</p></figure><p id="aa4a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最终输出将详细说明调用lambda函数的API网关URL。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/bc50d8f987ae8ba07ab58beeac30afbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VHHygF4AAq7ixCa5MfWl6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8b9c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">c)通过用上面输出的URL替换下面代码中的URL来调用您的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/799b4a0fb5ca9f45fdc091949d86ff09.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*TQExZpmvo-xTUzBQQnvAsA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">准确度:0.95725(图片由作者提供)</p></figure><p id="9043" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">恭喜你！🎉🎉如果您已经达到了这个里程碑，那么我们已经成功地在AWS上部署了一个KNN分类器作为lambda函数。</p><p id="ba1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，如前所述，公开的API目前并不安全，任何拥有该URL的人都可以执行您的函数。有许多<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-controlling-access-to-apis.html" rel="noopener ugc nofollow" target="_blank">方法</a>来保护API gateway的lambda函数，但是这不在本指南的范围之内。</p><p id="ad64" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">d)使用以下命令终止和删除AWS lambda函数。用应用程序的名称替换<code class="fe nt nu nv nw b">[NAME_OF_STACK]</code>。文档可以在这里找到<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-cli-command-reference-sam-delete.html" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kg kh ki kj gt nx nw ny nz aw oa bi"><span id="54df" class="ob kx iq nw b gy oc od l oe of">sam delete --stack-name [NAME_OF_STACK]</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="e171" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">摘要</h1><p id="9590" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">lambda函数在生产中的多功能性不容低估。API驱动的lambda函数的执行，正如在这个项目中演示的，是众多<a class="ae kv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-property-function-eventsource.html" rel="noopener ugc nofollow" target="_blank">事件</a>驱动的lambda函数被激活的方式之一。除了作为一个经济高效的解决方案，lambda functions需要更少的维护，因为AWS处理大量的资源和基础设施管理。因此，这让开发者有更多的时间将注意力集中到其他地方。</p><p id="29dd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本指南中，我们在AWS lambda上训练、测试和部署了一个机器学习模型。首先，在MNIST数据集上训练一个K-最近邻分类器。这个经过训练的模型使用Docker与包含预测逻辑的lambda函数打包在一起。借助SAM，dockerised容器在AWS上部署为cloudformation堆栈之前在本地进行了测试，其中模型用作API端点。</p><p id="f4d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你已经读完了这篇指南，我希望你已经学到了一些新的东西。如果有任何问题，请留下您的评论，我将非常乐意帮助您。</p><p id="0264" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">更多数据科学相关内容请务必在<a class="ae kv" href="https://www.linkedin.com/in/illoydhamilton/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、Medium或Twitter(<a class="ae kv" href="https://twitter.com/iLloydHamilton" rel="noopener ugc nofollow" target="_blank">@ illoyd Hamilton</a>)关注我。</p><p id="b113" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">来<a class="ae kv" href="https://codeclan.com" rel="noopener ugc nofollow" target="_blank"> CodeClan </a>跟我学吧。</p><p id="c920" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意这个空间。</p></div></div>    
</body>
</html>