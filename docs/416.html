<html>
<head>
<title>Visualizing Backpropagation in Neural Network Training at Any Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在任意尺度的神经网络训练中可视化反向传播</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/visualizing-backpropagation-in-neural-network-training-2647f5977fdb#2022-01-14">https://towardsdatascience.com/visualizing-backpropagation-in-neural-network-training-2647f5977fdb#2022-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="cdba" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">在任意尺度的神经网络训练中可视化反向传播</h1></div><div class=""><h2 id="6b4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用HiPlot生成平行坐标图来可视化深度学习模型训练。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8b744e4f36364951c001845ac7cb1025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tveesbVZ-nCY_vZjlSCWOA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个平行坐标图来可视化ML训练(图片由作者提供)</p></figure><p id="712e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理解和调试神经网络在数据集上的性能是机器学习(ML)模型的端到端生命周期中的关键一章。有能力理解一个模型是如何被训练的，可以提供有价值的洞察力，去发现哪里可以被改进。在本文中，我们将创建一个简单而有效的方法，在神经网络训练期间可视化一个称为<a class="ae lr" rel="noopener" target="_blank" href="/understanding-backpropagation-algorithm-7bb3aa2f95fd">反向传播</a>的过程。我们将使用的可视化技术被称为<a class="ae lr" href="https://www.data-to-viz.com/graph/parallel.html" rel="noopener ugc nofollow" target="_blank">平行坐标图</a>。这通常是一种用于从多个数据点以不同的单位或类型可视化许多不同特征的技术。下面是本文其余部分的概要:</p><ol class=""><li id="ddb0" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">理解评估深度学习模型的重要性</li><li id="0795" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">建立基础</li><li id="bc68" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">生成可视化</li></ol></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9bd8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">1.理解评估深度学习模型的重要性</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/f6fb02e3ea4faf4fe9ede7be325bfd55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LJeisZ7hbzoTYb9Z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">汉斯·雷尼尔斯在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="ab9b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">深度学习模型在现实世界中有着广泛的应用，从欺诈检测到自动驾驶汽车。这些应用通常会影响我们的日常生活。当一个模型被扩展以供数百万用户每天使用数百万次时，模型指标的微小改进可能会导致整体模型性能的显著改进。</p><p id="d693" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过使用可视化，我们可以更深入地理解我们的模型在每个<a class="ae lr" href="https://deepai.org/machine-learning-glossary-and-terms/epoch" rel="noopener ugc nofollow" target="_blank">时期</a>的训练和表现。我们对模型了解得越多，我们在选择模型时就能做出更清晰的决策。我们还可以使用此信息来了解我们的模型是否基于所使用的评估度量过拟合或欠拟合，这有助于调整超参数。</p><h1 id="f5d8" class="mn mo iq bd mp mq ng ms mt mu nh mw mx jw ni jx mz jz nj ka nb kc nk kd nd ne bi translated">2.建立基础</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/8e5cf1ac1d1a1b7f1a3117d7ecea5717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fu5PfapomhT5YbNl"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@etiennegirardet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾蒂安·吉拉尔代</a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4b2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们理解了可视化模型训练可以提供的好处，让我们开始构建吧！这个例子将使用Python版。</p><p id="2c41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将从导入Python依赖项开始:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="6ee3" class="nr mo iq nn b gy ns nt l nu nv">import tensorflow as tf</span><span id="130e" class="nr mo iq nn b gy nw nt l nu nv">from keras import layers<br/>from keras import models</span></pre><p id="2bba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这个示例模型，我们将使用[1] <a class="ae lr" href="https://keras.io/api/datasets/boston_housing/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> Keras Boston Housing数据集</strong> </a>。该数据集包含波士顿周围房屋的13个要素，目标值是房屋的价值。要下载和加载数据，请添加以下几行:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="f968" class="nr mo iq nn b gy ns nt l nu nv"># Download dataset<br/>dataset = tf.keras.datasets.boston_housing</span><span id="7489" class="nr mo iq nn b gy nw nt l nu nv"># Test train split<br/>(x_train, y_train), (x_test, y_test) = dataset.load_data()</span><span id="89e0" class="nr mo iq nn b gy nw nt l nu nv"># Normalize data using training data<br/>mean = train_data.mean(axis=0)<br/>train_data -= mean<br/>std = train_data.std(axis=0)<br/>train_data /= std<br/><br/>test_data -= mean<br/>test_data /= std</span></pre><p id="af30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然数据已经准备好进行训练，我们将创建一个函数来构建我们的准系统神经网络。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="bede" class="nr mo iq nn b gy ns nt l nu nv">def build_model():</span><span id="458e" class="nr mo iq nn b gy nw nt l nu nv">    model = models.Sequential()</span><span id="fcf2" class="nr mo iq nn b gy nw nt l nu nv">    model.add(layers.Dense(64, activation='relu',<br/>              input_shape=(x_train.shape[1],)))</span><span id="72e7" class="nr mo iq nn b gy nw nt l nu nv">    model.add(layers.Dense(64, activation='relu'))</span><span id="1763" class="nr mo iq nn b gy nw nt l nu nv">    model.add(layers.Dense(1))</span><span id="03db" class="nr mo iq nn b gy nw nt l nu nv">    model.compile(optimizer='rmsprop', loss='mse', metrics=['mae'])</span><span id="cbd6" class="nr mo iq nn b gy nw nt l nu nv"><br/>return model</span></pre><p id="e1e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，让我们训练模型！</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="a7c3" class="nr mo iq nn b gy ns nt l nu nv">num_epochs = 18</span><span id="3432" class="nr mo iq nn b gy nw nt l nu nv">model = build_model()</span><span id="a038" class="nr mo iq nn b gy nw nt l nu nv">model_history = model.fit(x_train, y_train, epochs=num_epochs, batch_size=16, verbose=0)</span><span id="b7aa" class="nr mo iq nn b gy nw nt l nu nv">test_mse_score, test_mae_score = model.evaluate(x_test, y_test)</span><span id="5e5b" class="nr mo iq nn b gy nw nt l nu nv">print(test_mae_score)</span></pre><p id="75bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的模型使用平均绝对误差作为评估标准。MAE可以用来评估我们的模型有多精确，并且可以给出性能的感觉。MAE分数将总是正数，分数越接近0，模型的性能越好。MAE可以通过取误差的平均值来计算。取预测值减去实际值的绝对值，取所有这些数值的和，最后除以数据点的总数，🎉你得到了你的梅分数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/69e06f85f65d7fe65580a30b66b586e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aPHtBO39z9V7mcUo2YBQA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算MAE(作者图片)的公式</p></figure><h1 id="f6e7" class="mn mo iq bd mp mq ng ms mt mu nh mw mx jw ni jx mz jz nj ka nb kc nk kd nd ne bi translated">3.生成可视化</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/21a9d49484d93d0107eca27b3f426e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*phAkJ1Y43Ecdl0Y0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae lr" href="https://unsplash.com/@isaacmsmith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Isaac Smith </a>在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3dc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是最精彩的部分！让我们通过生成一个平行图来直观地观察我们的基线神经网络在每个时期的模型训练情况！</p><p id="85b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们将利用脸书的开源HiPlot库。<strong class="kx ir"> HiPlot </strong>是一个轻量级工具，能够根据提供的数据轻松快速地生成平行坐标图。这是并排显示多个要素以直观分析数据外观的一种非常方便的方式。在我们的例子中，我们可以使用提取的关于模型训练的元数据来非常快速地创建令人惊叹的交互式可视化。关于HiPlot的更多信息可以在<a class="ae lr" href="https://github.com/facebookresearch/hiplot" rel="noopener ugc nofollow" target="_blank"> HiPlot Github库</a>上找到。</p><p id="1692" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要生成可视化，首先需要为HiPlot安装一个Python依赖项:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="1bfc" class="nr mo iq nn b gy ns nt l nu nv">pip install -U hiplot</span></pre><p id="cfac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，您需要导入HiPlot并使用函数来生成绘图。</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="cfd2" class="nr mo iq nn b gy ns nt l nu nv">import hiplot as hip</span><span id="15f2" class="nr mo iq nn b gy nw nt l nu nv">data = [{'epoch': idx,<br/>         'loss': model_history.history['loss'][idx], <br/>         'mae': model_history.history['mae'][idx]}<br/>       for idx in range(num_epochs)]<br/>hip.Experiment.from_iterable(data).display()</span></pre><p id="e24a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的代码将使用Keras model.fit()方法的返回值将模型历史加载到HiPlot中，以便进行可视化和交互。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/654b72d1fdb7f149c86080b2a242a424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hm7axgABJpTTAD-BCqwtGQ.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与HiPlot生成的平行图交互(图片由作者提供)</p></figure><p id="4aa8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">🎉恭喜你建立了神经网络模型，并用HiPlot生成的并行图可视化了反向传播过程！您会注意到，对于每个时期，MAE得分逐渐变得更好，现在我们能够分析并与这些数据进行交互，同时查看拟合在确切时期逐渐减弱的位置。</p><p id="077f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过这个过程，我们可以看到创建这些交互式可视化的可行性和无缝性，同时还可以通过利用训练历史数据来深入了解模型在训练期间的运行情况。使用HiPlot的最大优势之一<strong class="kx ir">是您可以添加许多其他属性来扩展到可视化中，以绘制更好的图片，而无需显著增加计算能力需求。</strong></p><h1 id="d630" class="mn mo iq bd mp mq ng ms mt mu nh mw mx jw ni jx mz jz nj ka nb kc nk kd nd ne bi translated">参考</h1><p id="c08d" class="pw-post-body-paragraph kv kw iq kx b ky nz jr la lb oa ju ld le ob lg lh li oc lk ll lm od lo lp lq ij bi translated">[1]波士顿住房数据集:<a class="ae lr" href="https://keras.io/api/datasets/boston_housing/" rel="noopener ugc nofollow" target="_blank">https://keras.io/api/datasets/boston_housing/</a></p><p id="9c57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Harrison d .和Rubin feld d . l .‘<a class="ae lr" href="https://www.law.berkeley.edu/files/Hedonic.PDF" rel="noopener ugc nofollow" target="_blank">享乐价格和对清洁空气的需求</a>’(1978)，J. Environ。经济学&amp;管理学，第5卷，81–102页</p></div></div>    
</body>
</html>