<html>
<head>
<title>My Most Useful Data Science Tips And Tricks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我最有用的数据科学技巧和诀窍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/my-most-useful-data-science-tips-and-tricks-da3c0c7930c7#2022-01-14">https://towardsdatascience.com/my-most-useful-data-science-tips-and-tricks-da3c0c7930c7#2022-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="be76" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">我最有用的数据科学技巧和诀窍</h1></div><div class=""><h2 id="e393" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分享一些关于数据科学建模和数据处理的有用提示</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/aeb35f813e2db745d71c7fd23bc67902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*KwURR1lDGM53EhdBmqakAw.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">(图片由<a class="ae ku" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ku" href="https://pixabay.com/images/id-20424/" rel="noopener ugc nofollow" target="_blank"> PublicDomainPictures </a>提供)</p></figure><h1 id="d6b4" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">介绍</h1><p id="c316" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">对于局外人来说，数据科学可能是一个令人困惑的隧道，夹在一个全是计算和假设检验的领域和一个全是计算机编程的领域之间。我们明白这一点，不要担心——我们也害怕。说到这里，对于那些可能对数据科学或计算机编程完全陌生的人，我在这里有一点阅读，可能会在2021年开始使用数据科学时提供一些更准确的信息(去年没有太大变化。)</p><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/how-to-break-into-data-science-in-2021-8-steps-87cb02a4a1f4"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">2021年如何闯入数据科学(8步)</h2><div class="mt l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ko mm"/></div></div></a></div><p id="7412" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">无论如何，在这些年的巫术实践中，我遇到了一些小趣闻，我想与大家分享。这些是我现在第一次做的典型的事情，因为当你去做的时候，注意这些方面比回头去修复它们容易得多。当它们对模型的设计至关重要时，情况尤其如此，因此这些提示中的许多对于防止对模型或其训练数据进行戏剧性的重新设计可能是至关重要的。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="3131" class="kv kw it bd kx ky nm la lb lc nn le lf jz no ka lh kc np kd lj kf nq kg ll lm bi translated">№1:注意类型</h1><p id="d6a4" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">当探索来自对给定特性的下一次观察的整个数据和知识世界时，很容易忘记自己完全是在编程。作为数据科学家，总有一些人可能更喜欢数据科学技能集的某些部分。例如，一些数据科学家可能喜欢建模和构建神经网络，但讨厌数据处理。</p><p id="07ed" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">有一件事会使事情变得容易得多，特别是当涉及到使用具有类型系统变化的语言时，那就是不断地监控你的类型，或者使用一个允许你这样做的数据管理框架。例如，我们可以使用astype()将一个系列转换为一种数据类型(将系列中的值转换为一种数据类型)，并且我们可以通过以下方式获得当前数据类型:</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9f13" class="nw kw it ns b gy nx ny l nz oa">df.dtypes<br/>df.astype(Int64)</span></pre><p id="00c4" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">在OddFrames.jl for Julia中，我们也使用了dtype()函数，但是语法略有不同。我们还使用可变版本dtype！()以便将此类型转换为我们的数组。我们也可以通过为一个类型设置一个索引来做到这一点。：</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="07ea" class="nw kw it ns b gy nx ny l nz oa">od.dtype(:column)<br/>od.dtype!(:column, Int64)</span></pre><p id="db06" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">在DataFrames.jl中，对于我们的最后一个例子，我们可以通过</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="6207" class="nw kw it ns b gy nx ny l nz oa">eltype.(eachcol(df))</span></pre><p id="eb7a" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">如果你使用的是动态类型的语言，如果你从事数据科学，你很可能就是这样，那么你可能需要关注那些类型特别弱的语言中的数据。当类型是弱类型而不是强类型时，如果您想了解更多关于弱类型或隐式类型的信息，我这里有一整篇文章:</p><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/all-about-typing-explicit-vs-implicit-and-static-vs-dynamic-980da4387c2f"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">关于类型:显式与隐式，静态与动态</h2><div class="ob l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">快速浏览类型以及它们如何与语言交互。</h3></div><div class="mt l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mu l"><div class="oc l mw mx my mu mz ko mm"/></div></div></a></div><p id="5973" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">所有这些弱/强或隐式/显式意味着编译器将基于其编译或解释算法显式或隐式地控制类型。换句话说，有些数据可能会在您不知道的情况下改变类型。</p><h1 id="c0d9" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">№2:花更多时间测试</h1><p id="9e20" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我能提供的另一个很好的建议，尤其是在建模的时候，是做更多的测试。测试是确定两个值之间有多大关联的唯一可靠方法。</p><p id="d11a" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">测试你将在模型中使用的特性，观察排列，考虑每个特性的重要性。所有这些都可以形成一个更好的模型，并且可以减少花在绞尽脑汁想为什么这个模型不起作用上的时间。现在一头扎进笔记本，让你面前的数据符合你的模型，这可能令人兴奋，但耐心是一种美德。当涉及到数据科学时尤其如此，因为在测试和处理数据时，您的发现过程通常会指导您的整个项目。</p><h1 id="366c" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">№3:花更多时间处理</h1><p id="47ae" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">可能我最不喜欢的数据科学技能是数据处理。尽管探索数据很有趣，处理数据也很轻松，但也可能令人沮丧——尤其是在管理框架不够完善，或者数据没有正确保存或查询的情况下。是的，这是真的，我们都有这样一个文件，它将我们的整个文件读入一个数据帧的一个观察值中。那是糟糕的时代，但是不管处理数据和数据工程对某些人来说有多无聊，它都是数据科学过程中至关重要的一部分。</p><p id="d0c9" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">拥有完全干净的数据可以消除数据中的一些差异。很多时候，一组特定的连续样本的范围实际上根本不能反映整个特征的性质…用不太通俗的话来说，我们称之为异常值，但我的观点是，将列命名为正确的名称、特征工程、特征压缩、分解，所有这些对于在给定模型上获得最佳精度都至关重要。也就是说，大量的时间，甚至可能是永恒的时间，可以用于处理一个数据集，所以明智的做法是先了解一下什么时候有一些好的特性，什么时候没有。</p><h1 id="d6d0" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">№4:去掉无关紧要的功能！</h1><p id="6bf5" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我对数据科学的第四个有用的建议是去掉无关紧要的特性。在我们的训练数据集中，有一些因素会对每一次观察产生显著的影响。也就是说，无论n是二十还是两亿，每个观察值对最终成为回报的结果都很重要。</p><p id="bf24" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">无关紧要的特征是不重要的特征。有些人可能认为将所有的特性放入模型中是有意义的，因为模型可能会辨别出哪些特性的权重更大或更小，事实就是如此。然而，当试图获得更高的验证准确性时，以错误的方式将模型放在数据之上会导致很多麻烦。</p><p id="5e4e" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">总的来说，拥有太多的要素而没有足够的数据来正确连接权重会导致过度拟合现象。许多建模都归结于平衡偏差，这样模型才适合于适量的数据，而不会使模型过拟合或欠拟合。为了更好地完成这项工作，通常会使用分解，但是在大多数情况下，抛弃无关紧要的特性可能比进一步处理它更好。如果您想阅读更多关于分解的内容，我有一篇关于奇异值分解的文章，这可能是对分解及其用途的很好的介绍:</p><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/deep-in-singular-value-decomposition-98cfd9532241"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">深入奇异值分解</h2><div class="mt l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mu l"><div class="od l mw mx my mu mz ko mm"/></div></div></a></div><h1 id="d8dd" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">№5:从基线开始工作</h1><p id="2dfb" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">数据科学家的一个良好实践是始终从基线精度预测开始。这有几个主要原因，第一个原因是，它为我们提供了一个良好的起点，让我们知道如何实现准确性。同样，它会给我们一个很好的想法，关于我们可能要处理的特性的深度。例如，如果我在二进制预测中使用多数类基线，并看到准确率约为50 %,我可能会指出我的数据框中只有两个类别。不用说，这可能表明一种布尔特征类型，以及一种理想的一次性编码方法。所有这些信息都可以从简单的基线中提取出来。</p><p id="e1d8" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">使用基线的另一个原因是看你是否真的需要一个模型来预测这个特征。在某些情况下，运行一个模型可能根本没有意义，比如你预测一个反应，是或不是。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="87df" class="nw kw it ns b gy nx ny l nz oa">y = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1]</span></pre><p id="31e6" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">该双数组表示响应，0表示否，1表示是。我们的n，观察总数，这里是11。在这10个值中，只有一个是零。在本例中，这代表了10%的数据。因此，如果我们在这里不使用模型，只是每次都猜这个值是1，我们在90%的情况下都是正确的。在某些情况下，这个数字可能会高得多。为不需要模型进行预测的特征拟合模型是没有用的。</p><h1 id="89a1" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">№6:使用验证集</h1><p id="5b5c" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">一些真正有助于改进模型的建议是使用验证集以及测试和训练集对两个不同的数据样本进行预测，这对于数据科学来说无疑是一种很好的实践。验证集给出了一个基本目标，以及我们模型的一个相当精确的演示，虽然它可能不会过拟合。</p><p id="1713" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">在建模时，验证集有助于完成许多不同的事情。首先，它缩小了样本大小，这将意味着特性的重要性，<strong class="lp iu">以及</strong>特性的数量都将在建模时更能代表特性本身。除了常规的训练和测试集之外，使用验证集的唯一缺点是，由于没有足够的数据来填充神经元的权重，您的模型可能会不足。</p><h1 id="4ece" class="kv kw it bd kx ky kz la lb lc ld le lf jz lg ka lh kc li kd lj kf lk kg ll lm bi translated">№7:争论时，选择好的功能</h1><p id="eaff" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">我想分享的最后一个关于数据科学的惊人技巧来自于数据科学过程的早期，那就是数据争论。在我看来，数据争论可能是现代数据科学过程中最困难的步骤之一。有了许多不同的东西，例如预测建模和矩阵数学，我们能够使用依赖关系来加载Python中的快速C脚本，并且大多数对Python来说太慢或者编程工作量大的东西都被导入并用作依赖关系。</p><p id="9c70" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">然而，数据争论就不是这样了，因为数据争论通常需要某种定制的脚本，或者保存数据然后加载的方法。也就是说，争论数据可能非常困难。当争论数据时，我的建议是以尽可能干净的格式争论数据。如果可能，在构建保存数据的结构时，扫描缺失或荒谬的值。先发制人地完成所有这些是一个好主意，因为这将保持数据本身的干净，并使您未来处理数据的工作变得容易得多。就像在常规处理阶段一样，这里的一点点数据工程可以节省后期大量的时间！</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="49bf" class="kv kw it bd kx ky nm la lb lc nn le lf jz no ka lh kc np kd lj kf nq kg ll lm bi translated">结论</h1><p id="2e76" class="pw-post-body-paragraph ln lo it lp b lq lr ju ls lt lu jx lv lw lx ly lz ma mb mc md me mf mg mh mi im bi translated">数据科学有如此多的来龙去脉，很容易理解为什么它对一些可能有兴趣加入该领域的人来说是势不可挡的。然而，按部就班地看待事物，并着眼于每个单独的方面，对于建立足够强大的知识基础以促进伟大的数据科学技能会有极大的帮助。</p><p id="2964" class="pw-post-body-paragraph ln lo it lp b lq na ju ls lt nb jx lv lw nc ly lz ma nd mc md me ne mg mh mi im bi translated">这篇文章包含了我多年来作为一名数据科学家所学到的七件事。我来自一个更传统的计算机科学/软件工程背景，这其中的一些部分花了很多时间去学习，只是因为从来没有人告诉过我。正是因为这个原因，我现在将这些话传达给你，所以我希望这些小技巧在你的数据科学之旅中派上用场。感谢您阅读我的文章，祝您有愉快的一天！</p></div></div>    
</body>
</html>