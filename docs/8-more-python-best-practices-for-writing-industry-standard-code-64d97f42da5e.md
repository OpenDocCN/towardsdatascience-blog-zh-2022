# 编写行业标准代码的 8 个 Python 最佳实践

> 原文：<https://towardsdatascience.com/8-more-python-best-practices-for-writing-industry-standard-code-64d97f42da5e>

## 我进入软件行业后学到的一些 Python 最佳实践

![](img/9a7f98503b8e2ed0b67a7447dbda78b2.png)

照片由来自[佩克斯](https://www.pexels.com/photo/woman-programming-on-a-notebook-1181359/)的[克里斯蒂娜·莫里洛](https://www.pexels.com/@divinetechygirl/)拍摄

我最近读了 Anmol Tomar 的一篇关于 Python 最佳实践的好文章[。它涉及简单而有效的最佳实践，可以提高您的代码质量。然后我觉得“嗯，我可以在 Anmol 的这个列表中再添加几个。”因此，我在这里，写这篇博客。在进入这个行业之前，我没有遵循这些最佳实践。但是在成为团队的一员后，我从我的同事那里学到了这些最佳实践，并希望我知道并尽早遵循这些小步骤。](/python-best-practices-for-writing-industry-standard-code-66b848783e0b)

“行业标准代码”听起来可能有些花哨。但它只不过是可读的、可重用的、可修改的代码。在工业界，我们在团队中工作。如果我在为一家公司工作时写了一些代码，我写的代码就归这家公司所有。一段时间后，一个完全不同的人，为同一家公司工作，应该能够阅读我的代码，理解它，对它进行改进，或者修复它的一个错误，或者将它与另一个软件集成。如果这是不可能的，软件业将不会超越个人。因此，只要你写的代码简单易懂，别人可以改进，你就是在写“行业标准代码”。

我在这里列出的 8 个最佳实践是 Anmol 在他的文章[中提到的内容的补充。也一定要读一读。永远不会有“最佳实践”的详尽列表这些是我在这个行业学到的一些简单的方法，帮助我提高了我的编码水平，并在一个协作的环境中工作。所以永远不要把它当作一组有限的最佳实践。](/python-best-practices-for-writing-industry-standard-code-66b848783e0b)

## 1.不要在你的代码中使用随机值。将它们定义为常量。

比方说，您正在编写的这段代码有一行将质量(kg)转换为重量(N)。这是一个简单的一行程序，你必须将质量变量乘以 9.8 ms⁻。所以我们倾向于写一行像下面这样的代码。

> 不良做法

技术上是正确的。但是当有人在没有上下文的情况下阅读你的代码时，他们会想为什么是 9.8，它从哪里来。因此，将它定义为一个命名的常量并随后使用它总是好的。

> 良好实践

Python 不像大多数其他语言那样有常量定义。因此我们把它定义为另一个变量。但是我们使用`ALL_CAPS`作为命名约定来表示它是一个常量。定义常量时，最好在源文件的顶部定义(在导入之后)。如果项目很大，并且许多源文件共享项目级常量，您可以在一个`constants.py`文件中定义所有常量，并根据需要将它们导入到所需的源文件中。

## 2.使用动词作为函数和方法名

这听起来可能不太重要，但请听我说完。假设你正在编写一个函数来计算一个给定数字的质因数。很可能我们倾向于这样定义函数:

> 不良做法

然后当调用函数并将其输出赋给一个变量时，我们会想知道该给这个变量取什么名字，因为`prime_factors`已经被占用了。如果我们想在函数中定义一个局部变量，情况也是如此。但是如果我们稍微思考一下，我们几乎总是写一个函数或方法来“做某事”。函数和方法对数据执行操作。因此，将您的函数和方法命名为`<do>_<something>`是一个好主意。在这个特殊的例子中，我更喜欢下面的函数名。

> 良好实践

之后，我将使用`prime_factors`作为变量名来捕获函数调用的结果。

## 3.根据访问范围要求将成员定义为私有或受保护

将类的属性和方法定义为私有或受保护不是 Python 的语言特性。但这可以通过一个普遍公约来实现。公开仅必要的属性和方法始终是最佳实践。其他的都应该保护类的私有成员。受保护的成员是可以从类及其子类中访问的属性和方法，而私有成员只能从类本身中访问。

在 Python 中，以下约定用于定义受保护成员和私有成员。以单下划线`_`为前缀的成员受到保护，以双下划线`__`为前缀的成员是私有成员。

> 良好实践

正如我上面提到的，在 Python 中这只是一个约定。我们仍然有办法接近这些成员。但好的程序员不会。这向可能扩展您的程序的后续程序员表明，这些属性和方法并不意味着可以从外部访问。

即使您没有以面向对象的方式使用 Python(因为大多数人都没有)，您仍然可以对不打算在其他地方导入的函数采用相同的约定。只需在这样的函数名前面加上下划线。这将表明该函数是文件的本地函数，不应该被导入到其他地方。

## 4.不要导入*

过去我已经做过很多次了。当我想导入一些我在别处定义的组件时，我只需这样做:

> 不良做法

当我们在代码中执行`import *`时，模块中的所有实体都将被导入到当前的名称空间中。这严重影响了代码的可读性。当您有两行这样的代码时，读者将会忘记您所使用的实体是从哪里导入的。更糟糕的是，这种导入可能会隐藏早期导入或本地定义中的名称。

如果您正在访问许多实体，最好的办法是导入整个包或模块。然后，您可以稍后以`<module>.<class>`的身份访问这些类或函数。如果只导入一两个组件，使用`from <package> import <class>`格式。但很少使用它。

> 良好实践

## 5.使用代码格式化程序

如果我说许多样式(格式)最佳实践可以被强制或自动应用到您的代码中，那会怎么样？是的，开始使用代码格式化程序或 linter。在工业环境中，大多数组织都将 linter 作为 CI(持续集成)管道的一部分。当您尝试将一些代码推送到组织的 repo 时，它将被自动标记，如果没有遵循任何规定的最佳实践，它将引发一个错误，阻止代码的合并。

所以还是开始用比较好。[布莱克](https://github.com/psf/black)是一个很好的代码格式化程序。它可以帮助你按照 PEP8 标准的规定格式化你的代码。一些 ide 有内置的代码格式化程序，你可以通过一个简单的快捷方式来使用它。Linters 不仅仅是代码格式化程序。它们是静态代码分析器。它们可以用来检查是否使用了正确的变量命名约定，检查错误等。Pylint 可以作为介绍棉绒的起点。

## 6.编写单元测试

这可能会非常耗时。但是，当在团队中工作或从事长期项目时，这是必不可少的。编写适当的单元测试使你的代码“标准化”。单元测试是一种机制，通过它可以测试源代码中各个逻辑单元的功能。您可以简单地隔离逻辑错误并防止它们向上传播。当在一个团队中工作时，这是必不可少的，因为如果一个功能上有缺陷的代码被合并，它会在与其他组件交互时导致错误。相信我，从长远来看，编写适当的单元测试实际上是节省时间的。Python 内置的 [unittest](https://docs.python.org/3/library/unittest.html) 库非常适合对你的 python 代码进行单元测试。

## 7.记录错误

你的代码不是没有错误的。即使在林挺、单元测试、手工测试之后，偶尔在生产中失败的可能性也很高。相信我，没事的。这在业内是常有的事。重要的是你是否已经先发制人地采用了机制来捕捉哪里出了问题。只有当你有一个指向哪里出了问题的指针时，你才能修复错误。所以在代码中启用强制错误记录。这很简单——使用 python [日志](https://docs.python.org/3/library/logging.html)。

> 良好实践

还可以根据项目的需要使用警告、信息和调试级别的日志记录。请记住，日志文件是您的“黑匣子”，如果您的代码在生产中失败，您将不得不使用它进行“事后分析”。

## 8.生成包含版本的 requirements.txt 文件

如果您在机器学习、数据科学或任何其他领域工作，并且这些领域的包在不断发展并获得重大更新，那么这就更容易理解了。您将创建一个虚拟环境，安装一些包并处理一个项目，然后交付。那你一段时间都不会碰这个项目。之后，你应该做一些改进。现在您尝试重新创建环境，您的代码很有可能会中断。嗯，原因是软件包经历更新，有时可能包含重大变更。

您可以通过遵循下面提到的最佳实践来简单地解决这个问题。

1.  每个项目都有单独的虚拟环境
2.  为每个项目使用一个`requirements.txt`文件来跟踪已安装的包
3.  当跟踪软件包时，使用确切的软件包版本来跟踪它们。

第三点很重要。如果您在 repo 中总是有工作包版本，那么每次您尝试重新创建环境时，都会安装该包的确切版本。因此，不会有任何突破性的变化。

您可以手动跟踪您安装的软件包，或者如果您正在维护一个适当的最小环境，您可以使用下面的 shell 命令来自动生成文件。

```
pip freeze > requirements.txt
```

> **编辑**:正如[塞萨尔·弗洛里斯](https://medium.com/u/37afeaaf9b9a?source=post_page-----64d97f42da5e--------------------------------)在评论中提到的，使用`pip freeze`可能会导致问题，因为它也会跟踪二级依赖关系。因此，手动跟踪包裹将是最好的选择。

如果你需要更多关于 requirements.txt 的信息，这里有一篇[好文章](https://learnpython.com/blog/python-requirements-file/)。

这就是我进入软件行业后学到的 8 个基本 Python 最佳实践。我希望这篇文章对你有用。此外，如果您认为应该包括任何评论/更多最佳实践，请在评论部分提出。

## 参考

[](/python-best-practices-for-writing-industry-standard-code-66b848783e0b) [## 编写行业标准代码的 Python 最佳实践

towardsdatascience.com](/python-best-practices-for-writing-industry-standard-code-66b848783e0b) [](https://www.tutorialsteacher.com/python/public-private-protected-modifiers)  [](https://stackoverflow.com/questions/9916878/importing-modules-in-python-best-practice)  [](https://github.com/psf/black)  [](https://pypi.org/project/pylint/)      [](https://learnpython.com/blog/python-requirements-file/) 