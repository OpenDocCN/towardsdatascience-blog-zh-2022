<html>
<head>
<title>Scheduling Notebook and Script Runs with GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GitHub动作安排笔记本和脚本运行</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/scheduling-notebook-and-script-runs-with-github-actions-cc60f3ac17f2#2022-01-22">https://towardsdatascience.com/scheduling-notebook-and-script-runs-with-github-actions-cc60f3ac17f2#2022-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="3c4e" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用GitHub动作安排笔记本和脚本运行</h1></div><div class=""><h2 id="ce23" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GitHub操作来自动化工作流程，并从脚本和笔记本中运行和更新结果</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/544a50d569703896ca15feff1aa92408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7BYnMgtiFeVBMBvA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@insungyoon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尹新荣</a>拍摄的照片</p></figure><p id="70a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们已经对定期更新的数据流进行了一些很酷的数据分析，例如体育统计数据或当前天气状况。现在，我们将代码添加到GitHub上的版本控制中，但是如果我们可以用更新的数据更新它而不必再次运行它，那将会非常酷。一个解决方案是使用Flask这样的框架创建一个web应用程序(我以前写过一篇文章，这里有一个基本的例子<a class="ae ky" rel="noopener" target="_blank" href="/create-and-deploy-a-simple-web-application-with-flask-and-heroku-103d867298eb"/>)，但是如果我们想要一个更简单的、只需要很少额外编码的东西呢？我们可以使用GitHub动作来定期运行我们的脚本，并更新输出和绘图来完成这项工作。</p><p id="becb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将通过编写一个简单的Jupyter笔记本来演示我们如何做到这一点，这个笔记本使用由<a class="ae ky" href="https://www.metaweather.com/api/" rel="noopener ugc nofollow" target="_blank">meta weather</a>【1】提供的免费API来获取城市列表中的当前天气。我们将把它设置为每3小时运行一次，并给我们的图添加点，这样，随着时间的推移，我们将开始构建天气趋势。所以，让我们开始吧！</p><h1 id="d1b7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">设置虚拟环境</strong></h1><p id="428c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们的笔记本按计划运行时，它将在虚拟机上完成，因此我们需要确保我们在本地计算机和云机器上都有一致的开发环境。我们首先为这个项目创建一个新的虚拟环境(我把我的虚拟环境放在一个文件夹<code class="fe ms mt mu mv b">~/venvs</code>中，但是你可以选择任何你想要的文件夹，包括项目文件夹本身)。打开您的终端并运行以下命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7b18" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">&gt;</strong> python3 -m venv ~/venvs/gh-actions<br/><strong class="mv iu">&gt;</strong> source ~/venvs/gh-actions/bin/activate</span></pre><p id="46e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在应该看到<code class="fe ms mt mu mv b">(gh-actions)</code>出现在您终端的提示符之前，表明您在虚拟环境中。要脱离这个环境，只需输入命令<code class="fe ms mt mu mv b">deactivate</code>。</p><p id="e4a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个干净的Python环境，没有安装依赖项，您可以通过运行<code class="fe ms mt mu mv b">pip freeze</code>来确认。您应该看不到输出，因为您没有安装软件包。</p><p id="d7bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的笔记本，我们将使用一个名为<code class="fe ms mt mu mv b">requests</code>的库来获取数据。在收到我们的API响应后，我们将使用<code class="fe ms mt mu mv b">pandas</code>来管理我们的数据，并用<code class="fe ms mt mu mv b">matplotlib</code>来绘制它。此外，我们显然需要<code class="fe ms mt mu mv b">jupyter</code>。因此，让我们按如下方式安装我们的依赖项:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="927b" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">(gh-actions) &gt;</strong> pip install --upgrade pip<br/><strong class="mv iu">(gh-actions) &gt;</strong> pip install requests pandas matplotlib jupyter jupyterlab</span></pre><p id="1f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了捕获最终运行我们笔记本的虚拟机所需的所有依赖关系，我们需要创建一个<code class="fe ms mt mu mv b">requirements.txt</code>文件，用于复制我们的本地环境。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="99b7" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu">(gh-actions) &gt;</strong> pip freeze &gt; requirements.txt</span></pre><p id="de5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在应该有一个名为<code class="fe ms mt mu mv b">requirements.txt</code>的文件，它列出了安装在您的虚拟环境中的所有包及其版本，GitHub Actions稍后可以使用它们。</p><p id="2ab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，既然这已经不碍事了，让我们继续写一些代码吧！</p><h1 id="79a6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">获取天气数据</h1><p id="9079" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.metaweather.com/api/" rel="noopener ugc nofollow" target="_blank"> MetaWeather API </a> [1]来查询城市列表的当前天气——在本例中，我们将选择旧金山、首尔、钦奈和开普敦。为此，我们必须首先导入相关的库:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="6d24" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Import Packages</strong><br/>import requests</span></pre><p id="ee69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个WOE(究竟在哪里)ID来查询我们各个城市的天气。让我们首先用所有WOE IDs的<code class="fe ms mt mu mv b">None</code>值初始化一个字典，我们接下来将查询它:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="441f" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Initialize dictionary of cities</strong><br/>cities = {<br/>    "San Francisco": None,<br/>    "Seoul": None,<br/>    "Chennai": None,<br/>    "Cape Town": None<br/>}</span></pre><p id="50d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以向API发出查询来获取城市id。我们有了基本端点URL，并用<code class="fe ms mt mu mv b">requests</code>包发出请求，并用<code class="fe ms mt mu mv b">.json()</code>将响应转换成字典。为了让我们的查询工作，我们必须将城市全部改为小写，并用<code class="fe ms mt mu mv b">+</code>替换空格，我们在下面也这样做了。响应是一个字典列表——我们将从列表中的第一个元素开始索引<code class="fe ms mt mu mv b">woeid</code>键-值对，以获得每个城市的WOE ID。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="7d0e" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Endpoint to query for IDs<br/></strong>BASE_URL_LOCATION = "<a class="ae ky" href="https://www.metaweather.com/api/location/search/?query=" rel="noopener ugc nofollow" target="_blank">https://www.metaweather.com/api/location/search/?query=</a>"</span><span id="f96f" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Query for WOE ID values<br/></strong>for city in cities.keys():<br/>    payload = requests.get(<br/>        BASE_URL_LOCATION + city.lower().replace(" ", "+")<br/>    ).json()<br/>    <br/>    cities[city] = payload[0]["woeid"]</span><span id="1ba0" class="na lw it mv b gy nf nc l nd ne">&gt;&gt; cities</span><span id="853f" class="na lw it mv b gy nf nc l nd ne">{'San Francisco': 2487956,<br/> 'Seoul': 1132599,<br/> 'Chennai': 2295424,<br/> 'Cape Town': 1591691}</span></pre><p id="aa26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经有了所有城市的WOE IDs，我们可以继续向API请求使用这些ID值来获取天气。返回的有效载荷是未来几天的天气预报，第一个是今天的天气预报，全部包含在键值对<code class="fe ms mt mu mv b">consolidated_weather</code>中。从这里，我们想要提取三个值<code class="fe ms mt mu mv b">created</code>(天气预报的时间)<code class="fe ms mt mu mv b">the_temp</code>(当前温度)和<code class="fe ms mt mu mv b">weather_state_name</code>(当前天气状态——例如，多云、晴朗等。).然后，我们将数据存储为一个字典列表，接下来我们可以很容易地将其转换为一个<code class="fe ms mt mu mv b">pandas</code>数据帧。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c268" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Endpoint to query for weather<br/></strong>BASE_URL_WEATHER = "<a class="ae ky" href="https://www.metaweather.com/api/location/" rel="noopener ugc nofollow" target="_blank">https://www.metaweather.com/api/location/</a>"</span><span id="aa27" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Query weather data</strong></span><span id="523d" class="na lw it mv b gy nf nc l nd ne">curr_weather = []</span><span id="060e" class="na lw it mv b gy nf nc l nd ne">for city, woe_id in cities.items():<br/>    payload = requests.get(BASE_URL_WEATHER + str(woe_id)).json()<br/>    curr_weather.append(<br/>        {<br/>            "time_utc": payload["consolidated_weather"][0]["created"],<br/>            "location": city,<br/>            "temperature_c": payload["consolidated_weather"][0]["the_temp"],<br/>            "weather_state": payload["consolidated_weather"][0]["weather_state_name"]<br/>        }<br/>    )</span></pre><p id="2480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看我们刚刚查询的数据:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b33b" class="na lw it mv b gy nb nc l nd ne">pd.DataFrame(curr_weather)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/692233ff5802d39cdeefc6f82cdf1e4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej6XVXIbbho01pXPmIhgBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="0fba" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">向文件追加数据</strong></h1><p id="caa0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将把我们的每个天气点存储在同一个目录下的一个<code class="fe ms mt mu mv b">.csv</code>文件中，我们将使用<code class="fe ms mt mu mv b">pandas</code>来操作它。我们将添加一些代码来打开当前的<code class="fe ms mt mu mv b">.csv</code>文件，添加新记录并保存新的<code class="fe ms mt mu mv b">.csv</code>。为了确保我们的代码在第一次运行时工作，我们将添加一个<code class="fe ms mt mu mv b">try/except</code>，这样它就不会抛出异常。此外，我们将在保存文件之前删除重复的行。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5a4a" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Import pandas<br/></strong>import pandas as pd</span><span id="2b7f" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Add entry to CSV file</strong><br/>try:<br/>    df = pd.read_csv("weather_locations.csv")<br/>    df = df.append(pd.DataFrame(curr_weather))<br/>except Exception:<br/>    # Create DataFrame on first run<br/>    df = pd.DataFrame(curr_weather)<br/>    <br/><strong class="mv iu"># Drop duplicate rows</strong><br/>df = df.drop_duplicates()<br/>    <br/><strong class="mv iu"># Save new CSV<br/></strong>df.to_csv("weather_locations.csv", index=False)</span></pre><h1 id="336f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">动态加载字体</strong></h1><p id="9a2a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于我们将在虚拟机上渲染我们的绘图，我们也不知道默认缓存中将会有什么字体。幸运的是，我们实际上可以从TTF文件中动态加载字体。在这种情况下，我从<a class="ae ky" href="https://fonts.google.com/specimen/Lato" rel="noopener ugc nofollow" target="_blank"> Google Fonts </a>下载了字体Lato，并将文件<code class="fe ms mt mu mv b">Lato-Regular.ttf</code>放在同一个工作目录下一个名为<code class="fe ms mt mu mv b">fonts/</code>的文件夹中。现在，要将字体直接从TTF文件添加到目录中，我们需要以下代码:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5427" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Import matplotlib font manager<br/></strong>import matplotlib.font_manager as fm</span><span id="116b" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Dynamically load font<br/></strong>font_path = "./fonts/Lato-Regular.ttf"</span><span id="ea64" class="na lw it mv b gy nf nc l nd ne">fm.fontManager.addfont(font_path)<br/>fm.FontProperties(fname=font_path)</span></pre><h1 id="6055" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">标绘结果</strong></h1><p id="a7ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们已经加载了数据源和字体，我们可以继续绘制结果了。我之前已经写了一篇文章详细描述了一些基础知识，所以我将跳过一些解释，直接进入我们将用来产生我们的图的代码。我们利用<code class="fe ms mt mu mv b">transforms</code>在绘图的最后一个点之后添加城市名称，首先转换为像素，添加40像素的横向填充，然后转换回数据坐标。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d5d9" class="na lw it mv b gy nb nc l nd ne"><strong class="mv iu"># Plot Parameters</strong><br/>plt.rcParams["font.family"] = "Lato"<br/>plt.rcParams["font.size"] = 16<br/>plt.rcParams["axes.linewidth"] = 2<br/>plt.rcParams["xtick.major.size"] = 0<br/>plt.rcParams["xtick.major.pad"] = 10<br/>plt.rcParams["ytick.major.size"] = 0<br/>plt.rcParams["ytick.major.pad"] = 10</span><span id="c2b4" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Colors</strong><br/>colors = {<br/>    "San Francisco": "#363b6e",<br/>    "Seoul": "#cd2e3a",<br/>    "Chennai": "#ff9933",<br/>    "Cape Town": "#007749"<br/>}</span><span id="7de1" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Create figure and axis</strong><br/>fig = plt.figure(figsize=(15, 10), dpi=300, facecolor="white")<br/>ax = fig.add_subplot(111)<br/>ax.grid(color="#d3d3d3")<br/>ax.spines["top"].set_visible(False)<br/>ax.spines["left"].set_visible(False)<br/>ax.spines["right"].set_visible(False)</span><span id="0e2b" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Load DataFrame<br/></strong>df = pd.read_csv("weather_locations.csv")</span><span id="6037" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Convert date column to datetime<br/></strong>df.time_utc = df.time_utc.apply(lambda t: pd.to_datetime(str(t)))</span><span id="82a2" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Sort values by time<br/></strong>df = df.sort_values("time_utc")</span><span id="f919" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Convert data to pixels<br/></strong>DC_to_FC = ax.transData.transform<br/>FC_to_DC = ax.transData.inverted().transform</span><span id="bf3a" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Plot Data<br/></strong>for city in cities.keys():<br/>    df_temp = (<br/>        df[df["location"] == city].reset_index(drop=True).copy()<br/>    )</span><span id="ca79" class="na lw it mv b gy nf nc l nd ne">    ax.plot(<br/>        mdates.date2num(df_temp["time_utc"]),  <br/>        df_temp["temperature_c"], <br/>        color=colors[city],<br/>        lw=2, <br/>        markevery=[-1], <br/>        marker="o", <br/>        ms=10, <br/>        mew=2, <br/>        mfc="white"<br/>    )</span><span id="27e5" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Add labels</strong><br/>for city in cities.keys():<br/>    df_temp = (<br/>        df[df["location"] == city].reset_index(drop=True).copy()<br/>    )<br/>    coords_original = [<br/>        mdates.date2num(df_temp.iloc[-1].time_utc),  <br/>        df_temp.iloc[-1].temperature_c<br/>    ]<br/>    coords_transformed = DC_to_FC(coords_original)<br/>    <br/>    <strong class="mv iu"># Pad 40 pixels between last point and label</strong><br/>    coords_transformed[0] += 40<br/>    coords_new = FC_to_DC(coords_transformed)<br/>    ax.text(<br/>        coords_new[0], coords_new[1], <br/>        city, ha="left", va="center", <br/>        color=colors[city]<br/>    )</span><span id="74a9" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Tick Label Format</strong><br/>ax.xaxis.set_major_formatter(mdates.DateFormatter("%m/%d"))</span><span id="ec6e" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Axis Labels</strong><br/>ax.set_xlabel("Date", labelpad=10, size=20)<br/>ax.set_ylabel("Temperature (˚C)", labelpad=10, size=20)</span><span id="d555" class="na lw it mv b gy nf nc l nd ne"><strong class="mv iu"># Axis Limits</strong><br/>ax.set_ylim(<br/>    min(df.temperature_c.round(0)) - 5, <br/>    max(df.temperature_c.round(0) + 5)<br/>)</span><span id="ab87" class="na lw it mv b gy nf nc l nd ne">plt.savefig("weather_locations.png", dpi=300, bbox_inches="tight")<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/92185ff9296b27ddc727d63dc1695ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fW7lcdtYocHzCIelKVM13w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d68b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经运行了几次，以生成一些初始数据，但还没有很多点。然而，久而久之，随着收集的数据越来越多，这个图表会慢慢变得完整。</p><p id="f26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，最重要的部分——自动运行这个笔记本和上传新的情节！</p><h1 id="680e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">设置GitHub动作</strong></h1><p id="e81f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要设置笔记本的自动运行，我们必须使用YAML文件定义一个工作流，这是一种可读性很强的标记语言。我们首先从我们的<em class="ni">库</em>的基础层创建文件<code class="fe ms mt mu mv b">/.github/workflows/update-plot.yml</code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1380" class="na lw it mv b gy nb nc l nd ne">GitHub Repo<br/>|<br/>+-- .github<br/>|   |<br/>|   +-- workflows<br/>|       |<br/>|       +-- update-plot.yml<br/>|<br/>+-- Project Files/Folders</span></pre><p id="dd9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的第一件事是为我们的工作流命名，在我们将它添加到repo后，它将出现在GitHub的UI中，并添加我们希望它运行的时间表，我们将每3小时这样做一次，从午夜开始。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1a7b" class="na lw it mv b gy nb nc l nd ne">name: Update Weather Locations Plot</span><span id="0c57" class="na lw it mv b gy nf nc l nd ne">on:<br/>  schedule:<br/>    - cron: '0 0-21/3 * * *'<br/>  workflow_dispatch:</span></pre><p id="a3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间表是用一个<code class="fe ms mt mu mv b">cron</code>表达式表示的，你可以通过这个<a class="ae ky" href="https://crontab.guru/every-12-hours" rel="noopener ugc nofollow" target="_blank">链接</a>了解更多，但它基本上是说每12小时在第0分钟运行。运行的时间将是UTC，所以在创建您的<code class="fe ms mt mu mv b">cron</code>表达式时请记住这一点。此外，添加<code class="fe ms mt mu mv b">workflow_dispatch</code>可以让你随时从GitHub UI手动运行工作流。</p><p id="f048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要列出需要在我们的工作流中运行的具体任务。我们首先将所有这些步骤放入一个名为<code class="fe ms mt mu mv b">update_plot</code>的整体作业中，该作业将在最新版本的Ubuntu上运行:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ab12" class="na lw it mv b gy nb nc l nd ne">jobs:<br/>  update_plot:<br/>    name: Update plot with location weather data<br/>    runs-on: ubuntu-latest</span></pre><p id="67d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在将定义我们工作中的不同步骤。我们必须做的第一件事是检查我们的存储库，这可以通过一个名为<code class="fe ms mt mu mv b">actions/checkout@v2</code>的内置动作来完成。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="8fa1" class="na lw it mv b gy nb nc l nd ne">steps:<br/>  - name: Checkout<br/>    uses: actions/checkout@v2</span></pre><p id="a42f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须在Ubuntu虚拟机上设置Python，这可以使用一个名为<code class="fe ms mt mu mv b">actions/setup-python@v2</code>的内置动作来完成。我们将使用Python 3.7，并将<code class="fe ms mt mu mv b">pip</code>设置为缓存依赖关系的缓存，以便更快地进行后续设置。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5fed" class="na lw it mv b gy nb nc l nd ne">- name: Setup Python<br/>  uses: actions/setup-python@v2<br/>  with:<br/>    python-version: '3.7'<br/>    cache: 'pip'</span></pre><p id="2d9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们安装来自<code class="fe ms mt mu mv b">requirements.txt</code>的依赖项</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4a5c" class="na lw it mv b gy nb nc l nd ne">- name: Install Dependencies<br/>  run: pip install -r requirements.txt</span></pre><p id="0693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了运行我们的笔记本，我们将首先使用<code class="fe ms mt mu mv b">jupyter nbconvert</code>将其转换成一个脚本，然后使用Python直接运行该脚本。这些命令的结果应该是更新的<code class="fe ms mt mu mv b">weather_extremes.csv</code>和<code class="fe ms mt mu mv b">weather_extremes.png</code>。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="912d" class="na lw it mv b gy nb nc l nd ne">- name: Run Script and Update Plot<br/>  run: |<br/>    jupyter nbconvert --to script weather_locations.ipynb<br/>    python weather_locations.py</span></pre><p id="ae0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要提交并把对上面两个文件的更改推送到存储库，这非常像我们在本地计算机上做的那样。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b468" class="na lw it mv b gy nb nc l nd ne">- name: Commit and Push Changes<br/>  run: |<br/>    git config --local user.email "actions@github.com"<br/>    git config --local user.name "GitHub Actions"<br/>    git add weather_locations.csv weather_locations.png<br/>    git commit -m "Updated plot on `date` with GitHub Actions"<br/>    git push origin master</span></pre><p id="ee01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有这些放在一起，我们完成的YAML文件将如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e731" class="na lw it mv b gy nb nc l nd ne">name: Update Weather Locations Plot</span><span id="14d7" class="na lw it mv b gy nf nc l nd ne">on:<br/>  schedule:<br/>    - cron: '0 0-21/3 * * *'<br/>  workflow_dispatch:</span><span id="ef70" class="na lw it mv b gy nf nc l nd ne">jobs:<br/>  update_plot:<br/>    name: Update plot with new extreme weather data<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v2</span><span id="bccc" class="na lw it mv b gy nf nc l nd ne">      - name: Setup Python<br/>        uses: actions/setup-python@v2<br/>        with:<br/>          python-version: '3.7'<br/>          cache: 'pip'</span><span id="5e59" class="na lw it mv b gy nf nc l nd ne">      - name: Install Dependencies<br/>        run: pip install -r requirements.txt</span><span id="b127" class="na lw it mv b gy nf nc l nd ne">      - name: Run Script and Update Plot<br/>        run: |<br/>          jupyter nbconvert --to script weather_locations.ipynb<br/>          python weather_locations.py</span><span id="e69c" class="na lw it mv b gy nf nc l nd ne">      - name: Commit and Push Changes<br/>        run: |<br/>          git config --local user.email "actions@github.com"<br/>          git config --local user.name "GitHub Actions"<br/>          git add weather_locations.csv weather_locations.png<br/>          git commit -m "Updated plot on `date` with GitHub Actions"<br/>          git push origin master</span></pre><p id="7b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您将YAML文件提交并推送到GitHub，您现在应该能够转到GitHub Repo上的<code class="fe ms mt mu mv b">Actions</code>选项卡，并且能够看到您刚刚创建的工作流！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/71cf96a727c010cdee6701f654fda41e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWQhdkDQ8uhgGlH0JijZdw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们将<code class="fe ms mt mu mv b">workflow_dispatch</code>添加到了我们的工作流中，如果您愿意，您应该可以选择现在手动运行更新。否则，请高枕无忧，让您的文件每天自动更新两次！通过将情节放入您的<code class="fe ms mt mu mv b">README</code>中，您还可以在每次访问存储库时看到变化。</p><h1 id="92ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">结论</strong></h1><p id="a8ec" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">感谢您阅读本教程，学习如何使用GitHub操作来自动运行您的笔记本和脚本！本文中的所有代码都可以在这个<a class="ae ky" href="https://github.com/venkatesannaveen/medium-articles" rel="noopener ugc nofollow" target="_blank"> Github资源库</a>中获得。</p><p id="024a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！我感谢任何反馈，你可以在<a class="ae ky" href="https://twitter.com/naveenv_92" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上找到我，并在<a class="ae ky" href="https://www.linkedin.com/in/naveenvenkatesan/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系以获取更多更新和文章。</p><h1 id="f606" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">参考文献</strong></h1><p id="630c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">[1]<a class="ae ky" href="https://www.metaweather.com/api/" rel="noopener ugc nofollow" target="_blank">https://www.metaweather.com/api/</a></p></div></div>    
</body>
</html>