<html>
<head>
<title>Let’s Do: Feature Engineering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们做:特征工程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lets-do-feature-engineering-5731efc3d7fe#2022-01-07">https://towardsdatascience.com/lets-do-feature-engineering-5731efc3d7fe#2022-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="fcee" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">让我们做:特征工程</h1></div><div class=""><h2 id="a207" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用房屋销售价格数据和一个<code class="fe kf kg kh ki b">LightGBM</code>模型简要展示简单特征工程的威力。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f5cfad83860693c7160feba2d1f94665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ewCvp758-qjLHSGS"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@danist07?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Danist Soh </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="c896" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">简要背景</h1><p id="c31d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">特征工程对不同的人有不同的含义，但该术语主要包括识别、操作和转换信息以提高模型预测能力的过程。</p><p id="da99" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">该过程可以细分为更具体的阶段(既不是穷尽的也不是连续的):</p><ol class=""><li id="3b75" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><strong class="lu ir">清理数据</strong>——例如缺失数据的替换或插补。</li><li id="fbbe" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ir">编码数据</strong> —分类数据类型到数字数据类型的转换。</li><li id="7e7b" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ir">(重新)缩放数据</strong> —适当地转换数字数据，使其符合期望的分布或位于期望的范围内，这可能是利用正则化惩罚或提高神经网络性能所必需的。</li><li id="58d4" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ir">分解数据</strong> —“复合”数据项可以分解成它们的组成部分。例如，包含性别x年龄组合(例如“年轻男性”)的某个指示的数据项可以分成两个单独的项，一个描述性别，另一个描述年龄。</li><li id="7a4d" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated"><strong class="lu ir">重组数据</strong> —单个数据项可以合并成一个数据项。例如，单独的<em class="nh">性别</em>和<em class="nh">年龄</em>数据项可以组合成单个<em class="nh">性别x年龄</em>复合特征。</li></ol><p id="d3ce" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">还有一类特征工程:<strong class="lu ir">模型堆叠</strong>。这包括构建单独的模型，并将其预测用作输入特征。这是一个稍微不同的方法，我们将在以后的文章中保留它。</p><h1 id="dcac" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">为什么要设计功能？</h1><p id="5acf" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">虽然我们大多数人选择追逐<strong class="lu ir">预测能力</strong>——特征工程可以在这方面有所帮助——但进行特征工程还有其他原因。</p><p id="ec9d" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">一个驱动程序是我们正在使用的型号的<strong class="lu ir">类型。如果我们在一个(广义的)线性建模空间中玩，我们会意识到在模型中使用交互项的好处。在模型构建中包含这些术语允许模型捕捉不同的特征如何相互作用<em class="nh">在一起</em>以产生效果。</strong></p><p id="85dc" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这方面的一个例子是在汽车保险损失的预测中包含了一个<em class="nh">性别x年龄</em>的交互作用:我们通常认为保险“风险”可以随着年龄(通常在年轻和年老时更高)和性别(通常男性高于女性)而变化。但是年轻的男性呢？还是老年女性？在模型中仅包括一个<em class="nh">葛</em>和<em class="nh">性别</em>作为主要效果可能会捕获大部分效果，但是包括交互项也可以提高模型的功效。</p><p id="dca6" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">许多模型界面允许用户指定要使用的交互术语，但除此之外不允许更多的定制。回到<em class="nh">性别x年龄</em>的例子，指定我们只想区分25岁以下的男性和女性司机可能很难使用模型规范接口——我们可能需要通过一个新特性来捕捉这一点。此外，显式地指定复杂的交互可以使理解模型变得更容易。</p><p id="47b6" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">有效的特征工程也有助于降低模型的复杂性。整合新信息或以简洁的方式总结信息可以减少充分捕捉预期效果所需的建模量——我们正在帮助模型更快地找到答案。</p><p id="578c" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">例如:</p><ul class=""><li id="e9b8" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn ni mz na nb bi translated">在GLM环境中，我们可以通过使用旨在捕捉复杂交互效应的新功能来简化模型，而不是将那些复杂的交互项合并到模型构建过程中。</li><li id="4cb0" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">在GBM设置中，模型更能够识别复杂的交互，使用工程特征可以减少模型收敛所需的迭代次数。</li></ul><p id="cf41" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果我们在一个受限的环境中工作，这可能是一个额外的祝福。例如，在实际生产中使用模型可能会有一些最大延迟需求，因此可能会限制部署模型的形式或深度。在这种情况下，使用强大的功能以最简洁的方式获取尽可能多的信息是至关重要的。</p><p id="3d2f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">最后——但肯定不是最不重要的——是特征工程可能揭示对问题的新见解。</p><p id="5007" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们可以用几种方法来解决这个问题:</p><ol class=""><li id="7948" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">在新设计特性的水平或值范围内检查目标特性的趋势。</li><li id="867a" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">在新设计的特征水平上评估基线预测和目标特征之间的差距。<em class="nh">如果我们有一个希望改进的初始模型预测，这很有用。</em></li><li id="871e" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">在我们的模型中拟合新特征，并评估它们对模型拟合和模型预测的影响；在这种情况下，要素重要性和SHAP值会很有用。<em class="nh">在这种情况下，评估现有功能和新功能的相互作用也很方便。</em></li></ol></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="899d" class="la lb iq bd lc ld nq lf lg lh nr lj lk jw ns jx lm jz nt ka lo kc nu kd lq lr bi translated">一项实验</h1><p id="efa3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">既然我们已经介绍了特性工程背后的一些理论和动机，让我们来看看它在工作中的一个实际例子。</p><p id="2cea" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">首先，我们来获取一些数据。在本例中，我们将使用来自Kaggle的<strong class="lu ir">房价—高级回归技术</strong>竞赛的数据(可公开获得，于2021年17月12日从<a class="ae kz" href="https://www.kaggle.com/c/house-prices-advanced-regression-techniques/" rel="noopener ugc nofollow" target="_blank">房价—高级回归技术| Kaggle </a>下载，该数据基于Dean De Cock编制的用于数据科学教育的Ames Housing数据集- <a class="ae kz" href="http://jse.amstat.org/v19n3/decock.pdf" rel="noopener ugc nofollow" target="_blank">示例:(amstat.org)</a>)。</p><p id="b55b" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">简而言之:</p><ul class=""><li id="9216" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn ni mz na nb bi translated">目的是利用房子的属性(例如，房子的大小、卧室数量、厨房质量等)预测房子的销售价格。).</li><li id="94dc" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">输入数据是数字和分类特征的混合，需要进行适当的处理。</li><li id="9885" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">有一些丢失的数据。这在很大程度上是由获取数据的方式造成的，但需要引起注意。</li><li id="ea4f" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">数据可能足够大，我们可以使用基于树的模型(小心)。这不是目前的主要问题，因为我们正在尝试测试一个想法。</li></ul><h2 id="dde5" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">假设:简单的特征工程可以提高预测销售价格的LightGBM模型的预测能力。</h2><h2 id="306c" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">基本规则</h2><p id="7547" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">为了让我们在测试我们的假设时保持诚实，我们将设置以下防护栏:</p><ol class=""><li id="c5a6" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">目标值不会以任何方式转换。</li><li id="b3eb" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">将使用5重交叉验证策略对非折叠数据进行模型性能评估。</li><li id="c164" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">编码、缩放和变换将由特征的类型决定；这意味着新设计的特征将以与原始特征相同的方式处理。在我们的例子中，我们不做数值转换，我们将使用LightGBM对分类特征的默认处理。</li><li id="d223" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">模型超参数将在模型运行中保持不变，并且不会有超参数调整。</li></ol><p id="02b5" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们的练习将分为以下几个步骤:原始数据的处理、基础数据的准备、包含新设计特征的扩充数据的准备、基础数据集和扩充数据集的模型构建和预测，以及模型性能的最终评估。</p><p id="3565" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我已经为这个例子编写了管道代码，并将展示它的大部分(可能需要一些想象力来填补空白)。</p><p id="a9a6" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们走吧！</p><h2 id="0fd5" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">处理原始数据</h2><p id="d2da" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">如前所述，我们需要处理丢失的数据。我们将通过以下方式做到这一点:</p><ol class=""><li id="190d" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">如果缺失是由数据捕获方法引起的，我们将用适当的值(例如“无”或0)填充缺失值。</li><li id="0cdb" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">如果出现意外缺失，我们将根据附近其他房屋的特征估算缺失值。如果我们考虑分类特征，缺失的值将被邻域中最常见的值替换。如果我们考虑一个数字特征，缺失值将使用邻域中的中值来替换。</li></ol><p id="1cd4" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们还将创建一个包含文件夹标识符列。我们现在将使用<code class="fe kf kg kh ki b">Id </code>列，因为它是一个惟一的整数(我不知道在它的创建中有什么模式会引入奇怪的效果)，尽管我更喜欢在更正式的设置中使用散列。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="98f8" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">准备基础数据</h2><p id="52b5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">一个简单的小脚本来分离输入数据、交叉验证标识符和目标变量:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="5cb2" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">准备扩充数据</h2><p id="8e42" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">现在是更有趣的事情——创建新功能。</p><p id="cdc0" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这通常需要一点创造力，可能是一个非常有趣的头脑风暴练习(我知道这很无聊)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9d05" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">正如你所看到的，我所创造的特征一点也不复杂或精致；或许可以公平地说，他们可以做一些工作！</p><p id="0ea1" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">然而，这些是<code class="fe kf kg kh ki b">LightGBM</code>型号不需要自己解决的特性和效果。</p><p id="9941" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">说到这里，让我们来看看我们是如何处理建模和折叠外预测的…</p><h2 id="34f9" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">模型建立和预测</h2><p id="311b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们将使用<code class="fe kf kg kh ki b">LightGBM</code>交叉验证方法。这允许我们通过一次调用(并且不需要使用循环)在适当的折叠上训练<em class="nh"> k </em>模型。</p><p id="84d2" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们必须使用一个生成器来创建<code class="fe kf kg kh ki b">LightGBM</code>的折叠索引(记得关闭默认的随机播放)，并且在聚合之前将折叠预测手动设置为零。</p><p id="172c" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">虽然以上是需要记住的技术要点，但我想提请注意我们处理分类特征的方式。我通常会使用类别编码器之类的包来手动编码类别特征，这一次我们尝试了LightGBM的原生方法，它几乎不需要手动干预(显然)。我们需要做到以下几点:</p><ol class=""><li id="07fc" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">创建列表(不是索引！)的功能名称。</li><li id="698b" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">创建分类的要素(要素名称)列表。</li><li id="25a7" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">将每个分类特征转换为<code class="fe kf kg kh ki b">category </code>数据类型。</li><li id="90ca" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">将列表和数据作为参数输入<code class="fe kf kg kh ki b">LightGBM</code>。</li></ol><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oi oj l"/></div></figure><h2 id="cf74" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">评估模型性能</h2><p id="64c9" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">评估基于基本数据的模型和基于增强数据的模型的非折叠模型预测的性能的一些代码。相当手动，并且有改进的潜力:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a752" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">相当多的指标需要评估——如果我们的假设是正确的，那么我们可以预期大多数指标都会有所改善。</p><h2 id="4c04" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq og bi translated">而结果呢！</h2><p id="a5c3" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们的实验结果如下:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ok"><img src="../Images/3d55b183fc927daf694ec368f4596634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Qn7iMHpxszDkuiCVtIyfQ.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="6bab" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我们似乎大获全胜，也就是说，在5个不同的指标中，基于扩充数据集构建的模型优于基于基础数据集构建的模型。这是一个相当强的结果！</p><h1 id="0628" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">包装它</h1><p id="3f4d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">…带着一些散漫。</p><ul class=""><li id="352c" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn ni mz na nb bi translated">在本文中，我们介绍了一些特性工程<strong class="lu ir">理论</strong>，即我们在野外可能遇到的各种特性工程。我们简单地提到了作为特征工程方法的<strong class="lu ir">模型堆叠</strong>，但是没有深入细节。</li><li id="6ab6" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">我们也谈到了<strong class="lu ir">为什么我们会考虑特性工程</strong>的一些动机。和我的文章一样，我的列表并不详尽，我们很可能只是触及了特性工程冰山的表面。</li><li id="5360" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">我们使用一个样本数据集试验了一些特征工程。实验参数保持不变，只有输入数据集允许变化。在基于非折叠模型预测计算的5个不同模型性能指标中，我们看到使用扩充数据集构建的<strong class="lu ir">模型优于使用基础数据构建的模型。</strong></li><li id="e013" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">现在，<strong class="lu ir">并不是说<em class="nh">将永远是</em>这种情况，或者性能改进将永远是这种明显的</strong>。改变管道中的一些元素，例如引入更复杂的数据处理，或引入超参数调整步骤，可能会改变结果。</li><li id="7975" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">我们在这里进行了非常基本的特征工程。将来，我想尝试一些更先进的技术，如<strong class="lu ir">非负矩阵分解、主成分分析和t分布随机邻域嵌入</strong>。这些技术比我们进行的简单的求和与求差要复杂得多！</li><li id="56dc" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn ni mz na nb bi translated">为了评估新功能的影响，<strong class="lu ir">我们选择重建完整的模型。由于这在现实世界中可能是不可能的，我们可能不得不采取不同的方法来评估新特性的价值，也许是通过从现有模型中“提升”。使用这种方法进行类似的实验会很有趣——也许以后会有！</strong></li></ul><p id="87ca" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">一如既往，我希望你喜欢读这篇文章，就像我喜欢写它一样！</p><p id="da3f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">新年快乐，2022年5月带来伟大的事情。</p></div></div>    
</body>
</html>