<html>
<head>
<title>A Step-by-Step Guide to Calculating Autocorrelation and Partial Autocorrelation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算自相关和偏自相关的分步指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-step-by-step-guide-to-calculating-autocorrelation-and-partial-autocorrelation-8c4342b784e8#2022-01-30">https://towardsdatascience.com/a-step-by-step-guide-to-calculating-autocorrelation-and-partial-autocorrelation-8c4342b784e8#2022-01-30</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/ded02b6ba6263f92661198b601001ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKD6i9oBCS4ZfMfksSBbTg.jpeg"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">照片由<a class="ae ji" href="https://unsplash.com/@_staticvoid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Lucas Santos </a>在<a class="ae ji" href="https://unsplash.com/s/photos/clock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""><h1 id="6b4e" class="pw-post-title jj jk jl bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">计算自相关和偏自相关的分步指南</h1></div><div class=""><h2 id="60ac" class="pw-subtitle-paragraph ki jk jl bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dk translated">如何在Python中从头开始计算ACF和PACF值</h2></div><p id="de3c" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">如果您从事过任何时间序列任务，我相信您曾经研究过识别时间序列中关系本质的方法——自相关测量。例如，您可能已经使用ACF和PACF图来确定ARMA模型的阶数。</p><p id="9dd9" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">然而，你真的想知道这些相关系数是如何计算出来的吗？如果没有，这篇文章是适合你的地方。我们将简要描述这两个度量是什么，然后逐步展示如何在Python中计算它们。</p><p id="716d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">为了管理预期，我们将重点关注系数背后的计算，而不是它们的解释以及如何使用它们进行时间序列建模的细节。这将是另一篇文章的主题。</p><h1 id="1fba" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">设置</h1><p id="43b7" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">像往常一样，我们快速导入所需的库。我们将使用<code class="fe mt mu mv mw b">statsmodels</code>中的函数作为基准来确保我们的计算是正确的。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="0934" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">数据</h1><p id="e858" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">在本文中，我们将使用一个简单的经典时间序列数据集——航空乘客数据集。你可以在<code class="fe mt mu mv mw b">seaborn</code>库(<code class="fe mt mu mv mw b">sns.load_dataset("<a class="ae ji" href="https://github.com/mwaskom/seaborn-data/blob/master/flights.csv" rel="noopener ugc nofollow" target="_blank">flights.csv</a>")</code>)中找到数据集，或者从我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/data/air_passengers.csv" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中下载稍微预处理的版本。对于我们的计算，我们将使用一个名为<code class="fe mt mu mv mw b">y</code>的<code class="fe mt mu mv mw b">pandas</code>系列，它包含每月的航空乘客人数。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi nd"><img src="../Images/fbbd24dfd872d5e0c56337feb0646bcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hfcRxcc_bXYV5_Lz__oxIQ.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="9418" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我敢肯定你已经非常熟悉上面的图:)然后，我们生成两个包含ACF/PACF值的图。虽然我们不会显式地复制这些图(虽然我们可以)，但我们关注的是由图上的点(和垂直线)表示的值。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="mx my mz na gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi ne"><img src="../Images/be184bb4675a261bf70cf73352006b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njUMtVZyD91loYOspm3Zmw.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="b1c4" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated"><strong class="lc jm">注意:</strong>虽然我们不会在本文中明确涉及，但蓝色阴影区域是置信区间。区间内的ACF/PACF值在5%水平(默认设置，我们可以更改)不被视为具有统计学意义。</p><h1 id="1e77" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">自相关</h1><p id="b576" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">让我们从两者中较简单的开始。简而言之，自相关是时间序列与其滞后时间序列的相关性。最简单的例子——滞后1——将告诉我们本月的航空乘客数量与上个月的相关程度。自然，我们可以用任意数量的滞后来重新表述这个句子。</p><p id="723a" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">简单回顾之后，让我们使用<code class="fe mt mu mv mw b">statsmodels</code>来计算基准。我们之前生成的图使用了24个滞后，但是为了方便起见，我们将考虑10个滞后。计算ACF的值就像下面的代码片段一样简单。</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="4ba6" class="nj lx jl mw b gy nk nl l nm nn">acf(df, nlags=10)</span></pre><p id="5b02" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这将生成以下数组:</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="8699" class="nj lx jl mw b gy nk nl l nm nn">array([1.        , 0.94804734, 0.87557484, 0.80668116, 0.75262542,        0.71376997, 0.6817336 , 0.66290439, 0.65561048, 0.67094833,        0.70271992])</span></pre><p id="e419" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们知道自相关是时间序列与其滞后值的相关性。因此，对于我们的计算，我们可以很容易地创建一个数据框架，在不同的列中包含原始和滞后序列，然后使用<code class="fe mt mu mv mw b">corr</code>方法来计算皮尔逊相关系数。让我们试一试。</p><p id="cb8c" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们从生成数据帧开始:</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d1b8" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这将生成下表:</p><figure class="mx my mz na gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi no"><img src="../Images/9d3990e318fd3d2f9793705c6e1cf020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uD4KXCl2fgtuJOYc1duSfQ.png"/></div></div><p class="je jf gj gh gi jg jh bd b be z dk translated">作者图片</p></figure><p id="7bb0" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated"><code class="fe mt mu mv mw b">lag_0</code>栏是原来的系列，其他的都做了适当的移动。然后，我们计算相关矩阵并打印原始系列的列—它显示原始系列如何与数据帧的所有列相关。</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="00bc" class="nj lx jl mw b gy nk nl l nm nn">acf_df.corr()["y_lag_0"].values</span></pre><p id="ddd4" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">它返回以下数组:</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="e09a" class="nj lx jl mw b gy nk nl l nm nn">array([1.        , 0.96019465, 0.89567531, 0.83739477, 0.7977347 ,        0.78594315, 0.7839188 , 0.78459213, 0.79221505, 0.8278519 ,        0.8827128 ])</span></pre><p id="01df" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">有些不对劲，值与我们的基准不符。原因是什么呢？通常情况下，细节决定成败。让我们来看看自相关公式:</p><figure class="mx my mz na gt ix gh gi paragraph-image"><div class="gh gi np"><img src="../Images/20ccf0a435f705de932697fdbdf2a558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*PtwBYIykIRy0FpIQtnMIBw.png"/></div><p class="je jf gj gh gi jg jh bd b be z dk translated">来源:<a class="ae ji" href="https://otexts.com/fpp3/acf.html" rel="noopener ugc nofollow" target="_blank">预测:原理与实践第三版</a></p></figure><p id="7ba2" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这里有几件事需要我们注意:</p><ul class=""><li id="b65e" class="nq nr jl lc b ld le lg lh lj ns ln nt lr nu lv nv nw nx ny bi translated">公式中的所有数列都被贬低了，也就是说，平均值已经从它们中减去了。我们没有明确地这样做，但是在<code class="fe mt mu mv mw b">corr</code>方法中，这是在幕后发生的。</li><li id="f4d0" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">和一般的相关公式有什么不同——我们总是在减去原始序列的均值！因为我们创建了滞后，所以原始序列和滞后序列的平均值不会相同。</li><li id="e37d" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">在分母中，我们除以原始序列的方差。在皮尔逊相关系数中，我们将除以两个考虑变量的标准偏差的乘积。</li></ul><p id="0de4" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">现在让我们用上面的公式计算ACF值。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="d6da" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">它返回以下数组:</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="60f2" class="nj lx jl mw b gy nk nl l nm nn">array([1.        , 0.94804734, 0.87557484, 0.80668116, 0.75262542,        0.71376997, 0.6817336 , 0.66290439, 0.65561048, 0.67094833,        0.70271992])</span></pre><p id="3008" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这与我们使用<code class="fe mt mu mv mw b">statsmodels</code>中的<code class="fe mt mu mv mw b">acf</code>函数计算的结果完全吻合。</p><p id="ca25" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">另外，这个公式可能来自关于时间序列预测的最好的书——《预测:原则与实践》。我强烈推荐给任何对这个话题感兴趣的人。你可以在这里阅读我的观点/评论:</p><div class="iu iv gp gr iw of"><a rel="noopener follow" target="_blank" href="/the-best-book-to-start-learning-about-time-series-forecasting-69fcc618b6bb"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jm gy z fp ok fr fs ol fu fw jk bi translated">开始学习时间序列预测的最佳书籍</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">更妙的是，它是免费的！</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot jc of"/></div></div></a></div><h1 id="2a01" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">偏自相关</h1><p id="8fff" class="pw-post-body-paragraph la lb jl lc b ld mo km lf lg mp kp li lj mq ll lm ln mr lp lq lr ms lt lu lv io bi translated">偏相关有点难理解。再一次，它描述了时间序列和它的滞后对应物之间的关系，然而，这一次去除了所有的中间效应。例如，我们可以使用偏相关来确定本月的乘客人数<em class="oe">与6个月前的人数</em>有什么直接关系。在本例中，当计算PACF时，我们将删除有关6个月前的值如何影响5个月前的值的信息，然后是第5个滞后和第4个滞后之间的影响，依此类推，直到最近一个月。</p><p id="c8f5" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这也意味着第一部分自相关与第一自相关相同，因为没有中间效应要消除。</p><p id="25f1" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">更有趣的是，有很多计算偏相关的方法。<code class="fe mt mu mv mw b">statsmodels</code>中的函数提供了3种方法:尤尔-沃克方法、OLS(普通最小二乘法)方法和列文森-德宾递归方法。此外，每个选项都有一些可选的变体(总共有7+种不同的组合)。</p><p id="7b68" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在本文中，我们将重点放在OLS方法，这是基于自回归(AR)模型。该算法的细节描述如下。</p><p id="1057" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">首先，我们创建一个滞后值的矩阵(或DaraFrame ),直到第N个<em class="oe"/>。在这一点上，我们不删除任何观察，即使它们在技术上是不可用的(由于产生滞后的方式)。然后，对于2和<em class="oe"> N </em>之间的每次迭代(表示为<em class="oe"> k </em>):</p><ul class=""><li id="9200" class="nq nr jl lc b ld le lg lh lj ns ln nt lr nu lv nv nw nx ny bi translated">我们拟合一个线性回归模型(带截距),使用原始序列作为目标，使用滞后序列直到第<em class="oe"> k </em>个滞后作为特征。在此步骤中，我们使用从第<em class="oe"> k </em>个开始的观测值，因为并非所有的观测值都适用于滞后特性。</li><li id="26de" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">第<em class="oe"> k </em>个变量的系数就是第<em class="oe"> k </em>个偏自相关系数。</li></ul><p id="cc65" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这种方法背后的想法是，中间时间点解释的方差可以从滞后系数中排除。下面我们描述<code class="fe mt mu mv mw b">statsmodels</code>中可用的两种OLS方法之间的差异。如果描述过于专业，或者您只想直接动手，请随意跳过。</p><blockquote class="ou ov ow"><p id="c062" class="la lb oe lc b ld le km lf lg lh kp li ox lk ll lm oy lo lp lq oz ls lt lu lv io bi translated">准确地说，我们描述的是<code class="fe mt mu mv mw b">statsmodels</code>所说的“有效的”OLS方法，也是默认的OLS方法。“低效”方法非常相似，只是做了一些小的调整。首先，在创建滞后值矩阵之前，我们贬低原始系列。然后，在创建滞后矩阵之后，我们移除第一个<em class="jl"> N </em>观察值(在有效的方法中，我们迭代地减少观察值的数量，而不是在最开始移除多余的观察值)。这有明显的实际含义。让我们假设您使用了两次低效的方法，第一次是获得2号之前的滞后系数，然后重复这个过程直到4号。在这种情况下，在第一次计算中获得的第二部分自相关系数将不等于来自后一次计算的相应第二系数。这是因为基础回归使用了不同数量的观察值。您可以在附带的笔记本中看到该示例(文章末尾的链接)。</p></blockquote><p id="011f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">好了，这些技术细节已经足够了，让我们来计算一下航空乘客时间序列的部分自相关。和以前一样，我们从使用来自<code class="fe mt mu mv mw b">statsmodels</code>的<code class="fe mt mu mv mw b">pacf</code>函数创建基准开始。</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="d279" class="nj lx jl mw b gy nk nl l nm nn">pacf(df, nlags=10, method="ols")</span></pre><p id="7391" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这将生成以下数组:</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="806c" class="nj lx jl mw b gy nk nl l nm nn">array([ 1.        ,  0.95893198, -0.32983096,  0.2018249 ,  0.14500798,         0.25848232, -0.02690283,  0.20433019,  0.15607896,  0.56860841,         0.29256358])</span></pre><p id="adb9" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">然后，我们使用上述步骤计算偏自相关系数。</p><figure class="mx my mz na gt ix"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="ff60" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">代码应该是不言自明的，因为它几乎是将编写的步骤逐字翻译成Python代码。唯一可能是新的是来自<code class="fe mt mu mv mw b">statsmodels</code>的<code class="fe mt mu mv mw b">lagmat</code>功能。我们可以使用这个方便的函数，而不是手动创建滞后序列——就像我们之前在ACF示例中所做的那样。它有很多方便的特性，例如，它允许我们自动删除包含无效值的前几个观察值。有关更多信息，请查看<a class="ae ji" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.tsatools.lagmat.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="6428" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们的代码生成以下偏自相关系数，这些系数等于我们之前使用<code class="fe mt mu mv mw b">pacf</code>函数生成的系数。</p><pre class="mx my mz na gt nf mw ng nh aw ni bi"><span id="8a1f" class="nj lx jl mw b gy nk nl l nm nn">array([ 1.        ,  0.95893198, -0.32983096,  0.2018249 ,  0.14500798,         0.25848232, -0.02690283,  0.20433019,  0.15607896,  0.56860841,         0.29256358])</span></pre><p id="7cde" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">注意:在这篇<a class="ae ji" href="https://timeseriesreasoning.com/contents/partial-auto-correlation/" rel="noopener ugc nofollow" target="_blank">文章</a>中，您可以找到计算偏自相关系数的另一种方法的逐步介绍，这次是基于残差的相关性。</p><h1 id="d413" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">外卖食品</h1><ul class=""><li id="476a" class="nq nr jl lc b ld mo lg mp lj pa ln pb lr pc lv nv nw nx ny bi translated">自相关函数描述了时间序列与其滞后对应序列之间的关系，</li><li id="b100" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">偏相关描述了一种直接关系，也就是说，它消除了中间滞后值的影响，</li><li id="1064" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">有多种计算偏自相关系数的方法，也许最简单的一种是基于使用OLS估计自回归(AR)模型的方法。</li></ul><p id="29ea" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">您可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Time Series/acf_and_pacf_explained.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。此外，欢迎任何建设性的反馈。你可以在<a class="ae ji" href="https://twitter.com/erykml1?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">推特</a>或评论中联系我。</p><p id="6153" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">喜欢这篇文章吗？成为一个媒介成员，通过无限制的阅读继续学习。如果你使用<a class="ae ji" href="https://eryk-lewinson.medium.com/membership" rel="noopener">这个链接</a>成为会员，你将支持我，而不需要额外的费用。提前感谢，再见！</p><p id="e45c" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">您可能还会对以下内容感兴趣:</p><div class="iu iv gp gr iw of"><a rel="noopener follow" target="_blank" href="/one-thing-you-might-not-have-known-about-linear-regression-634446de7559"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jm gy z fp ok fr fs ol fu fw jk bi translated">关于线性回归，有一点你可能不知道</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">如何训练具有多个输出的单个模型</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="pd l oq or os oo ot jc of"/></div></div></a></div><div class="iu iv gp gr iw of"><a rel="noopener follow" target="_blank" href="/the-easiest-way-to-identify-holidays-in-python-58333176af4f"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jm gy z fp ok fr fs ol fu fw jk bi translated">用Python识别假日的最简单方法</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">如何快速将假期要素添加到数据集中</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="pe l oq or os oo ot jc of"/></div></div></a></div><div class="iu iv gp gr iw of"><a rel="noopener follow" target="_blank" href="/8-more-useful-pandas-functionalities-for-your-analyses-ef87dcfe5d74"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd jm gy z fp ok fr fs ol fu fw jk bi translated">用于分析的8个更有用的熊猫功能</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">它们可以让你的日常工作更轻松、更快捷</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">towardsdatascience.com</p></div></div><div class="oo l"><div class="pf l oq or os oo ot jc of"/></div></div></a></div><h1 id="fbba" class="lw lx jl bd ly lz ma mb mc md me mf mg kr mh ks mi ku mj kv mk kx ml ky mm mn bi translated">参考</h1><ul class=""><li id="7f6a" class="nq nr jl lc b ld mo lg mp lj pa ln pb lr pc lv nv nw nx ny bi translated"><a class="ae ji" href="https://www.statsmodels.org/stable/index.html" rel="noopener ugc nofollow" target="_blank">https://www.statsmodels.org/stable/index.html</a></li><li id="a0c3" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated">Hyndman，R.J .，&amp; Athanasopoulos，G. (2021) <em class="oe">预测:原则与实践</em>，第三版，原文:澳大利亚墨尔本。OTexts.com/fpp3.于2022年1月28日登陆。</li><li id="cb9c" class="nq nr jl lc b ld nz lg oa lj ob ln oc lr od lv nv nw nx ny bi translated"><a class="ae ji" href="https://www.statsmodels.org/stable/" rel="noopener ugc nofollow" target="_blank">https://www.statsmodels.org/stable/</a></li></ul></div></div>    
</body>
</html>