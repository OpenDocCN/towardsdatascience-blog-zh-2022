<html>
<head>
<title>SettingWithCopyWarning in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在熊猫中设置版权警告</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/settingwithcopywarning-in-pandas-782e4aa54ff7#2022-01-05">https://towardsdatascience.com/settingwithcopywarning-in-pandas-782e4aa54ff7#2022-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="3c8b" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">在熊猫中设置版权警告</h1></div><div class=""><h2 id="e6a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它是什么，为什么突然出现，以及如何摆脱它</h2></div><p id="8552" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(TL；dr:如果你是来寻求答案的，直接跳到<a class="ae lb" href="#0e7a" rel="noopener ugc nofollow">消除带有复制警告的设置</a></p><p id="263e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是一个熊猫用户，当你给一个<code class="fe lc ld le lf b">pd.DataFrame</code>或<code class="fe lc ld le lf b">pd.Series</code>赋值的时候，你可能已经看到SettingWithCopyWarning弹出来了。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="3f5e" class="lo lp iq lf b gy lq lr l ls lt">In [1]: import pandas as pd<br/>     …:<br/>     …: df = pd.DataFrame({<br/>     …:     “A”: [1, 2, 3, 4, 5],<br/>     …:     “B”: [6, 7, 8, 9, 10],<br/>     …:     }, index=range(5)<br/>     …: )<br/>     …: dfa = df.loc[3:5]<br/>     …: dfa[“C”] = dfa[“B”] * 50</span><span id="32fa" class="lo lp iq lf b gy lu lr l ls lt">&lt;ipython-input-2–63497d1da3d9&gt;:9: SettingWithCopyWarning:<br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="ee74" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfa[“C”] = dfa[“B”] * 50</span></pre><p id="35c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">pandas在这里给出了一个警告，因为赋值可能会也可能不会像预期的那样工作。</p><p id="86a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要说明的是，赋值确实发生了；这里强调的是“预期”。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="ddb2" class="lo lp iq lf b gy lq lr l ls lt">In [2]: dfa<br/>Out[2]:<br/>  A B C<br/>3 4 9 450<br/>4 5 10 500</span><span id="5403" class="lo lp iq lf b gy lu lr l ls lt">In [3]: df<br/>Out[3]:<br/>  A B<br/>0 1 6<br/>1 2 7<br/>2 3 8<br/>3 4 9<br/>4 5 10</span></pre><p id="8c8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你认为<code class="fe lc ld le lf b">df</code>的内容会受到<code class="fe lc ld le lf b">dfa</code>中赋值的影响吗？对于这种情况是否会发生，熊猫有着内在一致的(尽管有些迟钝)规则。只是在这种情况下，用户期望的模糊性需要一个警告，这样当我们的代码出现问题时，像你我这样的最终用户就知道去哪里找了。</p><h1 id="5424" class="lv lp iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">带有视图和副本的链式分配</h1><figure class="lg lh li lj gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mm"><img src="../Images/ce4bd701796f3f486277deb6e5542541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ha5XUucUzmJZPKSZ"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@kar111?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭佳欣·阿维蒂西安</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1076" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从数据帧或系列中选择要访问的行或列的行为称为<em class="my">索引</em>。pandas的灵活性允许链式索引，您可以重复索引前一次索引操作的结果。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="e77a" class="lo lp iq lf b gy lq lr l ls lt"># Select the 2nd to 4th row of data where col A &gt; 3 and col B != 7<br/>df[df[“A”] &gt; 3 &amp; df[“B”] != 7].iloc[3:5]</span></pre><p id="9b63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后pandas将返回数据帧的视图或副本。视图(浅层拷贝)引用原始数据帧中的数据，而拷贝(深层拷贝)是同一数据的单独实例。</p><p id="a7bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很难预测索引操作将返回哪个，因为它取决于底层数组的内存布局。索引的链接方式会导致不同的<code class="fe lc ld le lf b">__getitem__</code>和<code class="fe lc ld le lf b">__setitem__</code>调用被隐藏起来。再现下面的例子:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="159c" class="lo lp iq lf b gy lq lr l ls lt"># Example borrowed from [1]<br/>dfmi.loc[:, (‘one’, ‘second’)] = value<br/># becomes<br/>dfmi.loc.__setitem__((slice(None), (‘one’, ‘second’)), value)</span><span id="18b8" class="lo lp iq lf b gy lu lr l ls lt">dfmi[‘one’][‘second’] = value<br/># becomes<br/>dfmi.__getitem__(‘one’).__setitem__(‘second’, value)</span></pre><p id="4a80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链式索引本身没有问题，但使用链式索引赋值，即<code class="fe lc ld le lf b">chained assignment</code>，可能会有问题。根据具体情况，链式赋值要么直接修改原始数据帧，要么返回原始数据帧的修改副本。当链式索引不明显时，这可能会导致潜在的错误。</p><p id="9d24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链式索引可以跨几行代码进行:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="6db5" class="lo lp iq lf b gy lq lr l ls lt"># The following doesn’t look like chain indexing, does it?<br/>dfa = df.loc[row1:row2, col1:col2]<br/>…<br/>…<br/>dfa[row2] = dfa[row1].apply(fn)</span></pre><p id="d1bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果pandas在这个场景中没有发出警告，那么<code class="fe lc ld le lf b">df</code>没有被第二个赋值修改就不明显了。这就是SettingWithCopyWarning存在的原因。</p><p id="5d21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">熊猫医生[ ]对此进行了更详细的研究。警告信息链接到它很有帮助，这很好，因为如果你在Google上搜索<code class="fe lc ld le lf b">pandas settingwithcopywarning</code>，文档页面很容易被遗漏！在撰写本文时，它是Google首页的第7个结果，被blogposts和StackOverflow问题挤掉了。</p><h1 id="872e" class="lv lp iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">使用内部API在幕后窥视</h1><p id="1625" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">链式索引是选择正确数据的天赐便利，但是链式赋值是赋值正确值的雷区。[ ]中的TowardsDataScience文章提供了一个很好的例子，其中仅颠倒链式索引的顺序就可以决定是否对原始数据帧进行赋值:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="a299" class="lo lp iq lf b gy lq lr l ls lt"># Example borrowed from [2]</span><span id="f564" class="lo lp iq lf b gy lu lr l ls lt"># This updates `df`<br/>df[“product_group”][df[“product_group”]==”PG4"] = “PG14”</span><span id="5f30" class="lo lp iq lf b gy lu lr l ls lt"># This doesn’t!<br/>df[df[“product_group”]==”PG4"][“product_group”] = “PG14”</span><span id="4a5a" class="lo lp iq lf b gy lu lr l ls lt"># pandas raises warnings for both<br/># the user needs to confirm the intended outcome</span></pre><p id="8966" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<a class="ae lb" href="https://stackoverflow.com/questions/26879073/checking-whether-data-frame-is-copy-or-view-in-pandas" rel="noopener ugc nofollow" target="_blank">这个StackOverflow post </a>、<code class="fe lc ld le lf b">pd.DataFrame</code>和<code class="fe lc ld le lf b">pd.Series</code>对象拥有<code class="fe lc ld le lf b">_is_view</code>和<code class="fe lc ld le lf b">_is_copy</code>属性作为它们内部API的一部分。<code class="fe lc ld le lf b">_is_view</code>如果对象是视图，返回True如果对象不是视图，返回False。<code class="fe lc ld le lf b">_is_copy </code>存储一个<a class="ae lb" href="https://docs.python.org/3/library/weakref.html" rel="noopener ugc nofollow" target="_blank">弱引用</a>到它被复制的数据帧，或者<code class="fe lc ld le lf b">None</code>如果它不关联到一个现有的数据帧。</p><p id="74eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打印这些内部属性，同时使用链式赋值确实揭示了一些有趣的信息。一方面，pandas使用<code class="fe lc ld le lf b">_is_copy</code>来决定是否需要提高SettingWithCopyWarning。另一方面，用<code class="fe lc ld le lf b">_is_view = True</code>修改数据帧意味着它将影响原始的底层数据帧。</p><p id="54bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，一个免责声明:内部API不是最终用户可以访问的，可能会发生变化，使用它们需要您自担风险。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="7f16" class="lo lp iq lf b gy lq lr l ls lt">In [4]: pd.__version__<br/>Out[4]: ‘1.3.3’</span><span id="e59f" class="lo lp iq lf b gy lu lr l ls lt"># Setting up convenience functions<br/>In [5]: def make_clean_df():<br/>     …:     df = pd.DataFrame({<br/>     …:         “A”: [1, 2, 3, 4, 5],<br/>     …:         “B”: [6, 7, 8, 9, 10],<br/>     …:         “C”: [11, 12, 13, 14, 15],<br/>     …:         }, index=range(5)<br/>     …:     )<br/>     …:     return df</span><span id="6375" class="lo lp iq lf b gy lu lr l ls lt">In [6]: def show_attrs(obj):<br/>     …:     print(f”view: {obj._is_view}, copy: {obj._is_copy}”)</span></pre><p id="3992" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将首先展示几种常见索引方法的<code class="fe lc ld le lf b">_is_view</code>和<code class="fe lc ld le lf b">_is_copy</code>属性。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="1bd8" class="lo lp iq lf b gy lq lr l ls lt">In [7]: df = make_clean_df()</span><span id="11f6" class="lo lp iq lf b gy lu lr l ls lt">In [8]: show_attrs(df.loc[3:5])<br/>     …: show_attrs(df.iloc[3:5])<br/>     …: show_attrs(df.loc[3:5, [“A”, “B”]])<br/>     …: show_attrs(df.iloc[3:5, [0, 1]])<br/>     …: show_attrs(df[“A”])<br/>     …: show_attrs(df.loc[:, “A”])</span><span id="568e" class="lo lp iq lf b gy lu lr l ls lt">view: True, copy: &lt;weakref at 0x7f4d648b2590; to ‘DataFrame’ at 0x7f4d648b54c0&gt;<br/>view: True, copy: &lt;weakref at 0x7f4d648b2590; to ‘DataFrame’ at 0x7f4d648b54c0&gt;<br/>view: False, copy: None<br/>view: False, copy: &lt;weakref at 0x7f4d648be770; dead&gt;<br/>view: True, copy: None<br/>view: True, copy: None</span></pre><p id="11a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来分解一下:</p><ul class=""><li id="2d75" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated"><code class="fe lc ld le lf b">df.loc[3:5]</code>和<code class="fe lc ld le lf b">df.iloc[3:5]</code>都返回了视图并引用了原始数据帧。</li><li id="4706" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">对于<code class="fe lc ld le lf b">df.loc[3:5, [“A”, “B”]]</code>和<code class="fe lc ld le lf b">df.iloc[3:5, [0, 1]]</code>，当在行的顶部额外指定列时，返回<code class="fe lc ld le lf b">df</code>的副本。使用<code class="fe lc ld le lf b">.loc</code>索引没有对OG数据帧的引用，而使用<code class="fe lc ld le lf b">iloc</code>索引会导致对已被垃圾收集的临时数据帧的引用，这与<code class="fe lc ld le lf b">None</code>本身一样好。我们看看这是否有什么意义。</li><li id="3587" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">直接使用<code class="fe lc ld le lf b">df[“A”]</code>或<code class="fe lc ld le lf b">df.loc[:, “A”]</code>引用一个列会返回一个视图，而不引用原始数据帧。这可能与每个dataframe列实际上被存储为一个<code class="fe lc ld le lf b">pd.Series</code>有关。</li></ul><p id="101f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们手动创建这些索引数据帧/系列的副本，会发生什么情况？</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="bca3" class="lo lp iq lf b gy lq lr l ls lt">In [9]: show_attrs(df.loc[3:5].copy())<br/>     …: show_attrs(df.iloc[3:5].copy())<br/>     …: show_attrs(df.loc[3:5, [“A”, “B”]].copy())<br/>     …: show_attrs(df.iloc[3:5, [0, 1]].copy())<br/>     …: show_attrs(df[“A”].copy())<br/>     …: show_attrs(df.loc[:, “A”].copy())</span><span id="f417" class="lo lp iq lf b gy lu lr l ls lt">view: False, copy: None<br/>view: False, copy: None<br/>view: False, copy: None<br/>view: False, copy: None<br/>view: False, copy: None<br/>view: False, copy: None</span></pre><p id="0ffb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显式调用<code class="fe lc ld le lf b">.copy</code>会返回不引用原始数据帧/序列的数据副本。在这些副本上分配数据不会影响原始数据帧，因此不会触发SettingwithCopyWarnings。假设上面的<code class="fe lc ld le lf b">df.loc[3:5, [“A”, “B”]]</code>和<code class="fe lc ld le lf b">df.iloc[3:5, [0, 1]]</code>具有相似的属性，我们可以预期它们在链式分配下的行为应该类似于显式创建的副本。</p><p id="ba4f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将尝试几个链式分配场景。</p><h2 id="1844" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">场景1:使用loc索引的特定行</h2><p id="8afd" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">以下三个链接的赋值引发SettingWithCopyWarnings:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="7bc9" class="lo lp iq lf b gy lq lr l ls lt">In [10]: df = make_clean_df()<br/>      …: dfa = df.loc[3:5]<br/>      …: show_attrs(dfa)</span><span id="7c94" class="lo lp iq lf b gy lu lr l ls lt">view: True, copy: &lt;weakref at 0x7fba308565e0; to ‘DataFrame’ at 0x7fba3084eac0&gt;</span><span id="40b1" class="lo lp iq lf b gy lu lr l ls lt"># (1a)<br/>In [11]: dfa[dfa % 2 == 0] = 100</span><span id="dc14" class="lo lp iq lf b gy lu lr l ls lt">/tmp/ipykernel_34555/3321004726.py:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="826b" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfa[dfa % 2 == 0] = 100<br/>/home/tnwei/miniconda3/envs/ml/lib/python3.9/site-packages/pandas/core/<br/>frame.py:3718: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame</span><span id="1f1b" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> self._where(-key, value, inplace=True)</span><span id="173f" class="lo lp iq lf b gy lu lr l ls lt"># (1b)<br/>In [12]: dfa[“D”] = dfa[“B”] * 10</span><span id="3a93" class="lo lp iq lf b gy lu lr l ls lt">/tmp/ipykernel_34555/447367411.py:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="8c18" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfa[“D”] = dfa[“B”] * 10 # 1b</span><span id="176c" class="lo lp iq lf b gy lu lr l ls lt"># (1c)<br/>In [13]: dfa[“A”][3] = 10</span><span id="7475" class="lo lp iq lf b gy lu lr l ls lt">/tmp/ipykernel_34555/1338713145.py:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame</span><span id="4740" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfa[“A”][3] = 10</span></pre><p id="3a8e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有赋值对<code class="fe lc ld le lf b">dfa</code>本身生效，但只有(1a)和(1c)影响原始数据帧。(1b)没有。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="deb9" class="lo lp iq lf b gy lq lr l ls lt">In [14]: print(dfa)<br/> <br/>  A  B  C   D<br/>3 10 9  100 90<br/>4 5  100 15 1000</span><span id="3790" class="lo lp iq lf b gy lu lr l ls lt">In [15]: print(df)</span><span id="825b" class="lo lp iq lf b gy lu lr l ls lt">  A  B  C<br/>0 1  6  11<br/>1 2  7  12<br/>2 3  8  13<br/>3 10 9  100<br/>4 5  100 15</span></pre><p id="7056" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe lc ld le lf b">dfa</code>不再是视图，而是dataframe的副本！</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="3995" class="lo lp iq lf b gy lq lr l ls lt">In [16]: show_attrs(dfa) # view changed to False</span><span id="0188" class="lo lp iq lf b gy lu lr l ls lt">view: False, copy: &lt;weakref at 0x7fba308565e0; to ‘DataFrame’ at 0x7fba3084eac0&gt;</span></pre><p id="a652" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这告诉我们，熊猫会在必要时将视图转换为副本。这进一步说明了为什么找出链式分配本质上是棘手的，并且很难在库级别自动满足。</p><h2 id="46db" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">场景2:使用iloc索引的特定行</h2><p id="7846" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这与场景1相同，但是使用<code class="fe lc ld le lf b">iloc</code>代替。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="de4c" class="lo lp iq lf b gy lq lr l ls lt">In [17]: df = make_clean_df()<br/>      …: dfb = df.iloc[3:5]<br/>      …: show_attrs(dfb)</span><span id="21b7" class="lo lp iq lf b gy lu lr l ls lt">view: True, copy: &lt;weakref at 0x7fba30862040; to ‘DataFrame’ at 0x7fba30868c10&gt;</span><span id="6e85" class="lo lp iq lf b gy lu lr l ls lt"># (1a)<br/>In [18]: dfb[dfb % 2 == 0] = 100</span><span id="c621" class="lo lp iq lf b gy lu lr l ls lt">/tmp/ipykernel_34555/734837801.py:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="39fe" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfb[dfb % 2 == 0] = 100<br/>/home/tnwei/miniconda3/envs/ml/lib/python3.9/site-packages/pandas/core/<br/>frame.py:3718: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame</span><span id="d10c" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> self._where(-key, value, inplace=True)</span><span id="3f81" class="lo lp iq lf b gy lu lr l ls lt"><br/># (1b)<br/>In [19]: dfb[“D”] = dfb[“B”] * 10</span><span id="fcfa" class="lo lp iq lf b gy lu lr l ls lt">/tmp/ipykernel_34555/4288697762.py:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame.<br/>Try using .loc[row_indexer,col_indexer] = value instead</span><span id="09e3" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfb[“D”] = dfb[“B”] * 10</span><span id="4b72" class="lo lp iq lf b gy lu lr l ls lt"># (1c)<br/>In [20]: dfb[“A”][3] = 10</span><span id="7a1e" class="lo lp iq lf b gy lu lr l ls lt">/tmp/ipykernel_34555/2062795903.py:1: SettingWithCopyWarning: <br/>A value is trying to be set on a copy of a slice from a DataFrame</span><span id="1148" class="lo lp iq lf b gy lu lr l ls lt">See the caveats in the documentation: <a class="ae lb" href="https://pandas.pydata.org/pandas-docs/" rel="noopener ugc nofollow" target="_blank">https://pandas.pydata.org/pandas-docs/</a><br/>stable/user_guide/indexing.html#returning-a-view-versus-a-copy<br/> dfb[“A”][3] = 10</span></pre><p id="c7d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观察到的结果与场景1相同。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="d584" class="lo lp iq lf b gy lq lr l ls lt">In [21]: print(dfb)<br/>  A  B  C   D<br/>3 10 9  100 90<br/>4 5  100 15 1000</span><span id="30a1" class="lo lp iq lf b gy lu lr l ls lt">In [22]: print(df)</span><span id="695d" class="lo lp iq lf b gy lu lr l ls lt">  A  B   C<br/>0 1  6   11<br/>1 2  7   12<br/>2 3  8   13<br/>3 10 9   100<br/>4 5  100 15</span><span id="6c69" class="lo lp iq lf b gy lu lr l ls lt">In [23]: show_attrs(dfb)</span><span id="8c1c" class="lo lp iq lf b gy lu lr l ls lt">view: False, copy: &lt;weakref at 0x7fba30862040; to ‘DataFrame’ at 0x7fba30868c10&gt;</span></pre><h2 id="efa2" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">场景3:使用loc索引特定的行和列</h2><p id="ab22" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">与场景1相同，但是也指定了列。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="1063" class="lo lp iq lf b gy lq lr l ls lt">In [24]: df = make_clean_df()<br/>      …: dfc = df.loc[3:5, [“A”, “B”]]<br/>      …: show_attrs(dfc)</span><span id="5280" class="lo lp iq lf b gy lu lr l ls lt">view: False, copy: None</span><span id="d421" class="lo lp iq lf b gy lu lr l ls lt">In [25]: dfc[dfc % 2 == 0] = 100 # No warnings raised<br/>      …: dfc[“D”] = dfc[“B”] * 10<br/>      …: dfc[“A”][3] = 10</span></pre><p id="f47b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有发出警告。所有更改在“dfc”上生效，但不影响“df”。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="6e17" class="lo lp iq lf b gy lq lr l ls lt">In [26]: print(dfc)<br/> <br/>  A  B  D<br/>3 10 9  90<br/>4 5  100 1000</span><span id="a801" class="lo lp iq lf b gy lu lr l ls lt">In [27]: print(df)</span><span id="d4f1" class="lo lp iq lf b gy lu lr l ls lt">  A  B   C<br/>0 1  6   11<br/>1 2  7   12<br/>2 3  8   13<br/>3 10 9   100<br/>4 5  100 15</span></pre><p id="30f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链式分配结果是不同的，而索引的数据与场景1中的相同。我的猜测是，对索引操作更完整的描述促使pandas直接提前返回一个副本，而不是链接到原始数据帧的视图。</p><h2 id="c036" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">场景4:使用iloc索引特定的行和列</h2><p id="f1c3" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">这类似于场景3，但使用的是iloc。鉴于过去的几个场景，这个场景与场景3的结果相同也就不足为奇了。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="a6d8" class="lo lp iq lf b gy lq lr l ls lt">In [28]: df = make_clean_df()<br/>      …: dfd = df.iloc[3:5, [0, 1]]<br/>      …: show_attrs(dfd)</span><span id="efe0" class="lo lp iq lf b gy lu lr l ls lt">view: False, copy: &lt;weakref at 0x7fba306f29f0; dead&gt;</span><span id="9fab" class="lo lp iq lf b gy lu lr l ls lt">In [29]: dfd[dfd % 2 == 0] = 100 # No warnings raised<br/>      …: dfd[“D”] = dfd[“B”] * 10<br/>      …: dfd[“A”][3] = 10</span><span id="7306" class="lo lp iq lf b gy lu lr l ls lt">In [30]: print(dfd)</span><span id="226e" class="lo lp iq lf b gy lu lr l ls lt">  A  B   D<br/>3 10 9   90<br/>4 5  100 1000</span><span id="9e9d" class="lo lp iq lf b gy lu lr l ls lt">In [31]: print(df)</span><span id="fa81" class="lo lp iq lf b gy lu lr l ls lt">  A B  C<br/>0 1 6  11<br/>1 2 7  12<br/>2 3 8  13<br/>3 4 9  14<br/>4 5 10 15</span></pre><p id="0ef1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，` dfd '在这段代码的末尾放弃了对垃圾收集数据帧的引用。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="2891" class="lo lp iq lf b gy lq lr l ls lt">In [32]: show_attrs(dfd)</span><span id="c312" class="lo lp iq lf b gy lu lr l ls lt">view: False, copy: None</span></pre><h2 id="df76" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">场景5:直接引用数据帧的一列</h2><p id="f787" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">此方案测试系列的链式分配。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="8a7d" class="lo lp iq lf b gy lq lr l ls lt">In [33]: df = make_clean_df()<br/>      …: dfe = df[“A”]<br/>      …: show_attrs(dfe)</span><span id="ae71" class="lo lp iq lf b gy lu lr l ls lt">view: True, copy: None</span><span id="f7b1" class="lo lp iq lf b gy lu lr l ls lt">In [34]: dfe[1] = 99999 # No warnings raised<br/>      …: dfe.loc[2:4] = 88888</span></pre><p id="4e0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">dfe</code>保留了<code class="fe lc ld le lf b">df[“A”]. </code>的视图所有影响<code class="fe lc ld le lf b">dfe</code>的变化都反映在<code class="fe lc ld le lf b">df[“A”]</code>中，它仍然是<code class="fe lc ld le lf b">df</code>的一部分。对于单个系列的链式作业，似乎没有什么可担心的。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="6654" class="lo lp iq lf b gy lq lr l ls lt">In [35]: print(dfe)</span><span id="06ab" class="lo lp iq lf b gy lu lr l ls lt">0 1<br/>1 99999<br/>2 88888<br/>3 88888<br/>4 88888<br/>Name: A, dtype: int64</span><span id="cee8" class="lo lp iq lf b gy lu lr l ls lt">In [36]: print(df)</span><span id="eca5" class="lo lp iq lf b gy lu lr l ls lt">  A     B C<br/>0 1     6 11<br/>1 99999 7 12<br/>2 88888 8 13<br/>3 88888 9 14<br/>4 88888 10 15</span><span id="6f75" class="lo lp iq lf b gy lu lr l ls lt">In [37]: show_attrs(dfe)</span><span id="5584" class="lo lp iq lf b gy lu lr l ls lt">view: True, copy: None</span></pre><h1 id="0e7a" class="lv lp iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">正在删除SettingWithCopyWarnings</h1><p id="c0bf" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">当pandas不确定是否希望值赋值影响原始数据帧时，会弹出SettingWithCopyWarnings。因此，消除这些警告需要避免赋值的模糊性。从上面的代码示例可以看出，让pandas返回不引用原始数据帧的副本是一种干净的方法，可以确保值不会被意外地写入原始数据帧。</p><p id="baf6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现这是我在研究这个主题时遇到的解决方案中的一个统一线索。总结如下:</p><h2 id="4f3d" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">禁用警告</h2><p id="2363" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">如果您知道自己在做什么，并且代码的行为符合预期，您可以选择通过禁用警告来取消警告[ ]:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="6c94" class="lo lp iq lf b gy lq lr l ls lt"># Example borrowed from [³]</span><span id="8370" class="lo lp iq lf b gy lu lr l ls lt"># Disables SettingWithCopyWarning globally<br/>pd.set_option(‘mode.chained_assignment’, None)</span><span id="5548" class="lo lp iq lf b gy lu lr l ls lt"># Resets the warning option to default<br/>pd.reset_option(‘mode.chained_assignment’)</span><span id="ceaa" class="lo lp iq lf b gy lu lr l ls lt"># Disables SettingWithCopyWarning locally within a context manager<br/>with pd.option_context(‘mode.chained_assignment’, None):<br/>    # YOUR CODE HERE</span></pre><p id="3344" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，您可以通过将dataframe <code class="fe lc ld le lf b">_is_copy</code>属性设置为<code class="fe lc ld le lf b">None</code> [ ]，取消警告。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="ac29" class="lo lp iq lf b gy lq lr l ls lt"># Example modified from [3]<br/>In [38]: df = pd.DataFrame({<br/>      …:     “A”: [1, 2, 3, 4, 5],<br/>      …:     “B”: [6, 7, 8, 9, 10],<br/>      …:     “C”: [11, 12, 13, 14, 15],<br/>      …: }, index=range(5))<br/>      …: <br/>      …: dfa = df.loc[3:5]<br/>      …: print(dfa._is_copy)</span><span id="79bf" class="lo lp iq lf b gy lu lr l ls lt">&lt;weakref at 0x7f4d64792810; to ‘DataFrame’ at 0x7f4d64784460&gt;</span><span id="723a" class="lo lp iq lf b gy lu lr l ls lt">In [39]: dfa._is_copy = None<br/>      …: dfa[“D”] = dfa[“B”] * 10 # No warning raised</span></pre><p id="9bdc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，让警告消失并不能解决不可靠的链式分配问题。链式作业是一个雷区，你可能会也可能不会踩到地雷。禁用警告就像移除雷区警告标志。精神食粮。</p><h2 id="0d1e" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">让警告不在第一时间出现</h2><p id="9b5c" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">当遇到SettingWithCopy警告时，请花点时间跟踪链式赋值，并决定是要直接修改原始数据帧，还是将值赋给数据帧的副本。</p><h2 id="82e5" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">处理原始数据帧</h2><p id="b80c" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">使用<code class="fe lc ld le lf b">.loc</code>索引直接给数据帧赋值。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="d58b" class="lo lp iq lf b gy lq lr l ls lt"># Modified from examples in [2]<br/>In [40]: df = pd.DataFrame({<br/> …: “A”: [1, 2, 3, 4, 5],<br/> …: “B”: [6, 7, 8, 9, 10],<br/> …: “C”: [11, 12, 13, 14, 15],<br/> …: }, index=range(5))<br/> …:<br/> …: df.loc[df[“A”] % 2 != 0, “B”] = df.loc[df[“A”] % 2 != 0, “B”] + 0.5<br/> …: print(df)</span><span id="8411" class="lo lp iq lf b gy lu lr l ls lt">A B C<br/>0 1 6.5 11<br/>1 2 7.0 12<br/>2 3 8.5 13<br/>3 4 9.0 14<br/>4 5 10.5 15</span></pre><p id="656b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">熊猫医生推荐这种方法有两个原因:</p><ul class=""><li id="e154" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">使用<code class="fe lc ld le lf b">.loc</code>肯定会引用它所调用的底层数据帧。<code class="fe lc ld le lf b">.iloc</code>不具备这个属性。</li><li id="3e1d" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated"><code class="fe lc ld le lf b">.loc</code>步进取代了链式步进，成为单一步进步骤。如果您参考上面带有视图和副本的<a class="ae lb" href="#5424" rel="noopener ugc nofollow">链式分配下的示例，<code class="fe lc ld le lf b">.loc</code>索引将链式索引解析为单个<code class="fe lc ld le lf b">__setitem__</code>调用。</a></li></ul><p id="c2ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果使用条件选择数据，可以考虑返回一个掩码，而不是原始数据帧的副本。屏蔽是一个布尔序列或数据帧，可方便地用于<code class="fe lc ld le lf b">.loc</code>索引，如下例所示:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="fc91" class="lo lp iq lf b gy lq lr l ls lt"># Modified from examples in [5]<br/>In [41]: df = pd.DataFrame({<br/>      …:     “A”: [1, 2, 3, 4, 5],<br/>      …:     “B”: [6, 7, 8, 9, 10],<br/>      …:     “C”: [11, 12, 13, 14, 15],<br/>      …: }, index=range(5))</span><span id="11c0" class="lo lp iq lf b gy lu lr l ls lt">In [42]: dfa = (df[“A”] &lt;= 3) &amp; (df[“C”] == 12)</span><span id="ecba" class="lo lp iq lf b gy lu lr l ls lt">In [43]: df.loc[dfa, “B”] = 99 # dfa can be fed into the loc index!</span><span id="7eeb" class="lo lp iq lf b gy lu lr l ls lt">In [44]: print(df) # changes took place in the original dataframe</span><span id="b28f" class="lo lp iq lf b gy lu lr l ls lt">  A B  C<br/>0 1 6  11<br/>1 2 99 12<br/>2 3 8  13<br/>3 4 9  14<br/>4 5 10 15</span></pre><p id="2c10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果现有的索引逻辑很复杂，直接在原始数据帧上工作可能会很棘手。在这种情况下，您可以使用下一节中的方法之一返回一个副本，然后将它赋回原始数据帧[⁴].</p><h2 id="e496" class="lo lp iq bd lw ns nt dn ma nu nv dp me ko nw nx mg ks ny nz mi kw oa ob mk oc bi translated">为数据帧的显式副本赋值</h2><p id="beb7" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">使用<code class="fe lc ld le lf b">assign</code>、<code class="fe lc ld le lf b">where</code>和<code class="fe lc ld le lf b">replace</code>:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="3c7c" class="lo lp iq lf b gy lq lr l ls lt">In [45]: df = pd.DataFrame({<br/>      …:     “A”: [1, 2, 3, 4, 5],<br/>      …:     “B”: [6, 7, 8, 9, 10],<br/>      …:     “C”: [11, 12, 13, 14, 15],<br/>      …: }, index=range(5))</span><span id="e9e4" class="lo lp iq lf b gy lu lr l ls lt"># 1. Use the `assign` method to add columns<br/>In [46]: df = df.assign(D=df[“C”] * 10)<br/>      …: df = df.assign(**{“D”: df[“C”] * 10}) # allows passing variables as names</span><span id="11c5" class="lo lp iq lf b gy lu lr l ls lt"># 2. Use the `where` method to select values using conditionals and replace them<br/># Modified from examples in [2]<br/>In [47]: df[“B”] = df[“B”].where(<br/>      …:     df[“A”] &lt; 2, df[“B”] * 10<br/>      …: )</span><span id="4a23" class="lo lp iq lf b gy lu lr l ls lt"># 3. Use the `replace` method to select and replace values in the dataframe<br/># Modified from examples in [2]<br/>In [48]: df = df.replace({“A” : 1}, 100)</span><span id="db33" class="lo lp iq lf b gy lu lr l ls lt">In [49]: print(df)<br/>  A   B  C  D<br/>0 100 6  11 110<br/>1 2  70  12 120<br/>2 3  80  13 130<br/>3 4  90  14 140<br/>4 5  100 15 150</span></pre><p id="cc22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将连锁作业步骤分解成单个作业[⁵]:]</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="c5f5" class="lo lp iq lf b gy lq lr l ls lt"># Examples borrowed from [4]<br/># Not these<br/>df[“z”][mask] = 0<br/>df.loc[mask][“z”] = 0</span><span id="7bb2" class="lo lp iq lf b gy lu lr l ls lt"># But this<br/>df.loc[mask, “z”] = 0</span></pre><p id="7558" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种不太优雅但十分简单的方法是手动创建原始数据帧的副本，并对其进行处理[ ]。只要不引入额外的链式索引，就不会看到SettingWithCopyWarning。</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="6c6e" class="lo lp iq lf b gy lq lr l ls lt">In [50]: df = pd.DataFrame({<br/>      …:     “A”: [1, 2, 3, 4, 5],<br/>      …:     “B”: [6, 7, 8, 9, 10],<br/>      …:     “C”: [11, 12, 13, 14, 15],<br/>      …: }, index=range(5))</span><span id="252b" class="lo lp iq lf b gy lu lr l ls lt">In [51]: dfa = df.loc[3:5].copy() # Added .copy() here<br/>      …: dfa.loc[3, “A”] = 10 # causes this line to raise no warning</span></pre><h1 id="ade2" class="lv lp iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">重复上面的一些示例，而不触发带有副本的设置警告</h1><p id="8130" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">用<code class="fe lc ld le lf b">where</code>替换链接的赋值:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="4489" class="lo lp iq lf b gy lq lr l ls lt"># (i)<br/>df = make_clean_df()<br/>dfa = df.loc[3:5]</span><span id="b021" class="lo lp iq lf b gy lu lr l ls lt"># Original that raises warning<br/># dfa[dfa % 2 == 0] = 100</span><span id="c400" class="lo lp iq lf b gy lu lr l ls lt">dfa = dfa.where(dfa % 2 != 0, 100) # df is not affected</span></pre><p id="2fbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将在索引数据帧上创建新列替换为<code class="fe lc ld le lf b">assign</code>:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="be58" class="lo lp iq lf b gy lq lr l ls lt"># (ii) <br/>df = make_clean_df()</span><span id="3dbf" class="lo lp iq lf b gy lu lr l ls lt"># Original that raises warning<br/># dfa[“D”] = dfa[“B”] * 10</span><span id="bc0c" class="lo lp iq lf b gy lu lr l ls lt">dfa = dfa.assign(D=dfa[“B”]*10) # df is not affected</span></pre><p id="aa7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用<code class="fe lc ld le lf b">.loc</code>索引赋值之前，创建数据帧的副本:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="c5d9" class="lo lp iq lf b gy lq lr l ls lt"># (iii)<br/>df = make_clean_df()</span><span id="0816" class="lo lp iq lf b gy lu lr l ls lt"># Original that raises warnings<br/># dfa = df.loc[3:5]<br/># dfa[“A”][3] = 10</span><span id="54a2" class="lo lp iq lf b gy lu lr l ls lt"># Create a copy then do loc indexing<br/>dfa = df.loc[3:5].copy()<br/>dfa.loc[3, “A”] = 10</span></pre><p id="b9e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，使用<code class="fe lc ld le lf b">.loc</code>索引直接给<code class="fe lc ld le lf b">dfa</code>赋值仍然会引发警告，因为对<code class="fe lc ld le lf b">dfa</code>的赋值是否也会影响<code class="fe lc ld le lf b">df</code>还不清楚。</p><h1 id="99af" class="lv lp iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">真正根除带有复制警告的设置</h1><p id="b567" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">就我个人而言，我喜欢将重要脚本的SettingWithCopyWarnings提升为SettingWithCopyExceptions，使用以下代码:</p><pre class="lg lh li lj gt lk lf ll lm aw ln bi"><span id="1af8" class="lo lp iq lf b gy lq lr l ls lt">pd.set_option(‘mode.chained_assignment’, “raise”)</span></pre><p id="5eb8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做可以强制处理链式赋值，而不是允许警告累积。</p><p id="3cb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我的经验，清理被SettingWithCopyWarnings阻塞的带有stderr的笔记本是一种特殊的禅。我真心推荐。</p><p id="2327" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原创博文:<a class="ae lb" href="https://tnwei.github.io/posts/setting-with-copy-warning-pandas/" rel="noopener ugc nofollow" target="_blank">在熊猫身上设置版权警告</a></p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="4157" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[ ]:链式任务的官方“熊猫”文件。<br/>[<a class="ae lb" href="https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy](https://pandas.pydata.org/docs/user_guide/indexing.html#returning-a-view-versus-a-copy)" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/docs/user _ guide/indexing . html # returning-a-view-vs-a-copy](https://pandas . pydata . org/docs/user _ guide/indexing . html # returning-a-view-vs-a-copy)</a></p><p id="b5a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[ ]:这是一篇关于数据科学的文章，简要介绍了几种处理带有拷贝警告的设置的方法。<br/>[<a class="ae lb" href="https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08](https://scribe.rip/@towardsdatascience.com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe15d62de08)" rel="noopener ugc nofollow" target="_blank">https://scribe . rip/@ towards data science . com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe 15d 62 de 08】(https://scribe . rip/@ towards data science . com/3-solutions-for-the-setting-with-copy-warning-of-python-pandas-dfe 15d 62 de 08)</a></p><p id="47d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[]:data quest关于此主题的深入文章。值得注意的是，在《熊猫》中有一节专门讲述了处理链式分配的历史。<br/>[<a class="ae lb" href="https://www.dataquest.io/blog/settingwithcopywarning/](https://www.dataquest.io/blog/settingwithcopywarning/)" rel="noopener ugc nofollow" target="_blank">https://www . data quest . io/blog/settingwithcopywarning/](https://www . data quest . io/blog/settingwithcopywarning/)</a></p><p id="3449" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[⁴]: StackOverflow后，包含更多的连锁转让的例子。[<a class="ae lb" href="https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe](https://stackoverflow.com/questions/48173980/pandas-knowing-when-an-operation-affects-the-original-dataframe)" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/48173980/pandas-known-when-a-operation-affects-the-original-data frame](https://stack overflow . com/questions/48173980/pandas-known-when-a-operation-affects-the-original-data frame)</a></p><p id="ecc7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[⁵]: RealPython的文章覆盖了这个主题。对我来说，RealPython是仅次于官方图书馆文档的值得信赖的goto参考资料。本文进一步深入研究了pandas和numpy中的底层视图和复制机制，pandas依赖于numpy。<br/>[<a class="ae lb" href="https://realpython.com/pandas-settingwithcopywarning/](https://realpython.com/pandas-settingwithcopywarning/)" rel="noopener ugc nofollow" target="_blank">https://real python . com/pandas-settingwithcopywarning/](https://real python . com/pandas-settingwithcopywarning/)</a></p></div></div>    
</body>
</html>