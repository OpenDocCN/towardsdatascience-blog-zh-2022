<html>
<head>
<title>Lazy Arrays and Their Potential Applications in Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">惰性数组及其在数据科学中的潜在应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/lazy-arrays-and-their-potential-applications-in-data-science-d1f34e8657f6#2022-01-20">https://towardsdatascience.com/lazy-arrays-and-their-potential-applications-in-data-science-d1f34e8657f6#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="89bb" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">惰性数组及其在数据科学中的潜在应用</h1></div><div class=""><h2 id="813d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是惰性数组，如何在数据科学环境中使用它们？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae2b67cdcca555909ede140f11844abd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2Y3XrFJMRNfVx4laD4IcA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-1547018/" rel="noopener ugc nofollow" target="_blank"> Pixapopz </a>提供)</p></figure><h1 id="6a44" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="fc53" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据科学就是寻找适合完美模型的完美数据。有时，某些模型可能比其他模型需要更多的数据，这是由于偏差的原因。如果你想知道更多关于一个给定的模型是如何不足或过度的，以及偏见意味着什么，我有一整篇文章，你可以在这里阅读:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/everything-you-need-to-know-about-bias-over-fitting-and-under-fitting-8e2c1963107b"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">关于偏差、过度拟合和欠拟合，你需要知道的一切</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">偏见的详细描述以及它是如何融入机器学习模型的</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="11bb" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">也就是说，如果你有一个巨大的模型，有很多非常好的、统计上显著的特征，但仍然不合适，会发生什么？换句话说，如果您的模型急需数据，但由于硬件的限制，您似乎没有办法输入更多的数据，该怎么办呢？不管你有什么样的系统，它的内存容量总是有限的。也许你碰巧在一台内存很小的电脑上工作，比如Chromebook或类似的东西。对于这些情况，我有几个选项，您必须补救您的数据问题。</p><p id="280c" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">第一种选择是利用分解。分解可以采用许多不同的维度和特性，并将它们压缩成本质上一个可读的特性。这将节省大量内存，也有利于机器学习模型的性能和分析，但是像分解这样的事情是有限制的，它不会完全解决这些问题。我确实有一篇关于奇异值分解的文章，这可能是最恰当和最流行的分解形式，如果你想了解更多关于这个主题的知识，你可以在这里阅读:</p><div class="mn mo gp gr mp mq"><a rel="noopener follow" target="_blank" href="/deep-in-singular-value-decomposition-98cfd9532241"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">深入奇异值分解</h2><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">towardsdatascience.com</p></div></div><div class="mz l"><div class="nk l nb nc nd mz ne ks mq"/></div></div></a></div><p id="9b77" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">下一个方法是把数组变成表达式。这很像随机投影，但是当你真正开始考虑它的时候，它确实变得有点困难。你怎么能做出一个通用的表达式来表示整个数组的数据呢？今天我想考虑的就是这个，以及这些表达式数组的应用，它们可以帮助机器学习领域的人。此外，我决定在本文中编写我们自己的惰性数组，我在一个笔记本中快速完成了这项工作，下面是该笔记本文件的链接:</p><div class="mn mo gp gr mp mq"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/lazyarrays.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Emmetts-DS-NoteBooks/lazy arrays . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">github.com</p></div></div><div class="mz l"><div class="nl l nb nc nd mz ne ks mq"/></div></div></a></div><blockquote class="nm nn no"><p id="0092" class="lr ls np lt b lu nf ju lw lx ng jx lz nq nh mc md nr ni mg mh ns nj mk ml mm im bi translated">顺便说一句，两年多的笔记本提交到那个仓库。2022年将是我在Medium上写博客的第三年。非常感谢大家这两三年的美好时光！</p></blockquote></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="f8c0" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">什么是懒数组？</h1><p id="7fea" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">惰性数组是作为表达式或函数存储在内存中的数组(相同的区别，只是类型不同)。举个例子来形象地说明这到底是什么意思可能会有帮助。考虑以下阵列:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="d44a" class="ok la it og b gy ol om l on oo">x = [5, 10, 15, 20]</span></pre><p id="f10a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这个数组中的每个元素都可以被5整除，数据是线性的。因此，我们可以用经典的斜率式公式来计算，当然，这不需要任何y截距。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="a1ee" class="ok la it og b gy ol om l on oo">xbar(n) = n * 5</span></pre><p id="8815" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">正如索引该数组将提供存储在该位置的值的返回一样，</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="fd71" class="ok la it og b gy ol om l on oo">x[1]</span><span id="9639" class="ok la it og b gy os om l on oo">5</span></pre><p id="66db" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果我们像调用这个索引一样调用这个新函数，我们将得到相同的确切回报:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="55da" class="ok la it og b gy ol om l on oo">xbar(1)</span><span id="cd29" class="ok la it og b gy os om l on oo">5</span></pre><p id="f230" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在我们可以将数组的维数限制在4，所以虽然数组不能调用超出这些界限的索引，但是函数可以。我们可以通过简单地存储一些值来解决这个问题，就像我们要做一个LazyArray构造函数…像这样举个例子:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="9876" class="ok la it og b gy ol om l on oo">mutable struct LazyArray<br/>    n::Int64<br/>    function LazyArray(is::Any ...)<br/>        new{typeof(is[1])}(length(is))</span><span id="f1ff" class="ok la it og b gy os om l on oo">    end<br/>end</span></pre><p id="3412" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">对于那些不写Julia的人来说，这可能有点令人困惑，但是现在我们有了一个新类型LazyArray，它的属性是n，即值的长度。我们需要完成的最后一件事是一个表达式。通常，LazyArray构造函数会被提供一个表达式和一些需要创建的东西。这是因为对数组的某些函数规范形式进行逆向工程可能很困难。也就是说，如果没有无限多的可能性，这将是困难的。</p><p id="0c70" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">无论如何，考虑到这实际上是不可能的，我想考虑我们正在从一个数字数组，1–100，000，000，创建一个惰性数组，这应该给出一个好主意，为什么我们应该首先使用惰性数组。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="f86b" class="ok la it og b gy ol om l on oo">mutable struct LazyArray<br/>    n::Int64</span><span id="c464" class="ok la it og b gy os om l on oo">    f::Function<br/>    function LazyArray(is::Any ...)</span><span id="df75" class="ok la it og b gy os om l on oo">        f(x) = x * 1<br/>        new{typeof(is[1])}(length(is),f)</span><span id="c905" class="ok la it og b gy os om l on oo">end<br/>end</span></pre><p id="5461" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">考虑到我们的实现，我们可能还希望允许从一个常规数组构造一个惰性数组。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="9184" class="ok la it og b gy ol om l on oo">mutable struct LazyArray<br/>    n::Int64</span><span id="d3a6" class="ok la it og b gy os om l on oo">f::Function<br/>    function LazyArray(is::Any ...)</span><span id="18e5" class="ok la it og b gy os om l on oo">f(x) = x * 1<br/>        new(length(is),f)</span><span id="5ffe" class="ok la it og b gy os om l on oo">end</span><span id="2937" class="ok la it og b gy os om l on oo">    function LazyArray(is::AbstractArray)<br/>        f(x) = x * 1</span><span id="6ebd" class="ok la it og b gy os om l on oo">        new(length(is), f)<br/>    end<br/>end</span></pre><p id="99b6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这是重复的代码，因为我们要调用数组类型，而不是只调用any的一个…它被求值为一个元组。我们可以通过反转这些调用来避免代码重复，让LazyArray(::AbstractArray)在我调用的LazyArray(::Any …)中的值之后被调用，并且所提供的值被转换成一个数组。请允许我演示:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c0e2" class="ok la it og b gy ol om l on oo">mutable struct LazyArray<br/>    n::Int64</span><span id="5c17" class="ok la it og b gy os om l on oo">f::Function</span><span id="1679" class="ok la it og b gy os om l on oo">function LazyArray(is::AbstractArray)<br/>        f(x) = x * 1</span><span id="bdd8" class="ok la it og b gy os om l on oo">new(length(is), f)<br/>    end<br/>    function LazyArray(is::Any ...)<br/>    return(LazyArray([i for i in is]))</span><span id="bc17" class="ok la it og b gy os om l on oo">end</span><span id="288f" class="ok la it og b gy os om l on oo"><br/>end</span></pre><p id="7a52" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们甚至可以进一步将这个最小化到</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="1c58" class="ok la it og b gy ol om l on oo">mutable struct LazyArray<br/>    n::Int64</span><span id="83b8" class="ok la it og b gy os om l on oo">f::Function</span><span id="b1ed" class="ok la it og b gy os om l on oo">function LazyArray(is::AbstractArray)<br/>        f(x) = x * 1</span><span id="eaae" class="ok la it og b gy os om l on oo">new(length(is), f)<br/>    end<br/>    LazyArray(is::Any ...) = LazyArray([i for i in is])</span><span id="347b" class="ok la it og b gy os om l on oo">end</span></pre><p id="e23c" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在我们有了函数，f，我们可以继续讨论这些函数如何在前端工作。每当调用索引时，我们将在被调用的点上计算给定的索引。在Julia中，这都是通过扩展Base.getindex()方法来完成的。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="fbf5" class="ok la it og b gy ol om l on oo">import Base: getindex</span></pre><p id="1f04" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">基本上，提供给这个方法的任何索引都将通过我们的f函数运行。假设我们希望新的惰性数组与之前的数组长度相同，如果索引大于我们想要的值，我们也可能希望抛出</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="5c1f" class="ok la it og b gy ol om l on oo">function getindex(a::LazyArray, i::Int64)<br/>    if i &gt; a.n<br/>        throw(IndexError("Index outta bounds, yo"))<br/>    end<br/>    a.f(i)</span><span id="b36c" class="ok la it og b gy os om l on oo">end</span></pre><p id="ecc1" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">同样，我将对UnitRange做同样的事情。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="75e0" class="ok la it og b gy ol om l on oo">function getindex(a::LazyArray, i::UnitRange)<br/>    if i[2] &gt; a.n<br/>        throw(IndexError("Index outta bounds, yo"))<br/>    end<br/>    [a.f[val] for val in i]</span><span id="9a8d" class="ok la it og b gy os om l on oo">end</span></pre><p id="97f0" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在让我们创建一个新的范围，这将是我们的x数组，我们将通过它本身的惰性版本。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="c14c" class="ok la it og b gy ol om l on oo">x = Array(1:1000000)</span><span id="5dce" class="ok la it og b gy os om l on oo">lazyx = LazyArray(x)</span></pre><p id="982b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在让我们评估和比较这两个数组的内存使用情况，然后尝试一些索引。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="b280" class="ok la it og b gy ol om l on oo">varinfo()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/4e26ce5ddfa4b5497e3601fa2d89d9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*_BhFMku-L-_OTTmyqR460g.png"/></div></figure><p id="421d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们看到，典型的x 1，000，000元素向量方法占用了7.629兆字节的内存。另一方面，我们的懒惰版本只占用16字节的内存。惰性版本的优点还在于，不管x有多长，我们仍然会有相同的内存使用量。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="882b" class="ok la it og b gy ol om l on oo">x = Array(1:100000000)</span><span id="406f" class="ok la it og b gy os om l on oo">lazyx = LazyArray(x)<br/>varinfo()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/35b831333e436cb63831778b812a595b.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*ZNw4gKWPMazrB-l3a888aw.png"/></div></figure><p id="66c9" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">虽然我们的lazyx只需要16个字节来存储，而我们最初的x几乎需要整整10亿字节来存储，但它们在数学上是等价的。Lazyx只是x的一种规范形式，一种数学压缩的代数表示。这是通过索引揭示的，它保持完全相同:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="382f" class="ok la it og b gy ol om l on oo">x[500]</span><span id="6d53" class="ok la it og b gy os om l on oo">500</span><span id="d475" class="ok la it og b gy os om l on oo">lazyx[500]</span><span id="86c9" class="ok la it og b gy os om l on oo">lazyx[1:1000]</span><span id="e0c6" class="ok la it og b gy os om l on oo">MethodError: no method matching getindex(::var"#f#1", ::Int64)</span></pre><blockquote class="ov"><p id="21d4" class="ow ox it bd oy oz pa pb pc pd pe mm dk translated">哎哟</p></blockquote><p id="9e72" class="pw-post-body-paragraph lr ls it lt b lu pf ju lw lx pg jx lz ma ph mc md me pi mg mh mi pj mk ml mm im bi translated">不知道为什么我试图索引函数而不是调用它。</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="f858" class="ok la it og b gy ol om l on oo">function getindex(a::LazyArray, i::UnitRange)<br/>    if i[2] &gt; a.n<br/>        throw(IndexError("Index outta bounds, yo"))<br/>    end<br/>    [a.f(val) for val in i]<br/>end</span><span id="e0a8" class="ok la it og b gy os om l on oo">lazyx[1:1000] == x[1:1000]</span><span id="0921" class="ok la it og b gy os om l on oo">true</span></pre><p id="39dd" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">对于我们的实现，下一步将是实现一些基本函数，比如length，分派一些函数，比如。+，等等。添加到一个表达式列表中，最后构建一个迭代器或者进行某种迭代绑定。</p><h1 id="aa64" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">惰性数组的实现</h1><p id="7fa7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们已经编写了自己的惰性数组，并因此完全理解了它们的作用和工作原理，我们需要考虑它们实际上是如何实现的，它们是如何派上用场的，以及它们的优秀之处。惰性数组的一个重要问题是，它们需要给定数组的某种代数形式。对于一般的数据源来说，这未必是一件难以置信的事情。在线性模型上可能很容易，但在非线性模型上肯定不容易。这限制了数据科学中的潜在应用，因为数据通常是非线性的，每当事情是这样时，表达式可能很难评估。</p><p id="9982" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">也就是说，仍然有一些惰性数组的实现，以及这些实现的一些问题。我想谈的第一个是Python的Dask框架的实现。这个实现可以在dask.array中找到，根据我的经验，它非常健壮。dask系统主要针对集群，而不是单一系统。也就是说，对于像典型的数据科学过程这样更加个人化和声明性的东西，我们真的不需要将这些东西分布在一个计算机集群中——此外，与一组硬件的密切关系也不是一件坏事。</p><p id="d74d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">惰性数组的dask实现实际上非常棒，非常健壮。总的来说，dask软件包相当不错。我真正喜欢的是，我们可以向计算中添加额外的表达式，然后一次性执行所有的操作。</p><p id="1c49" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">在Julia中还有另一个类似的实现，名为LazyArrays.jl。当然，这个实现更接近于我们上面编写的示例，以演示这些数组的功能和内存使用，但这一点仍然有效。这个实现与dask非常相似，但是我要说的是dask模块内部的一些语法变得更简单了。我认为这可以归结为dask是一个拥有大量赞助商的庞大团队，而LazyArrays团队只是普通的朱利安一起创造东西。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="84b8" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">结论</h1><p id="9f69" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">问题是，现在我们知道了什么是惰性数组，以及它们如何有益于数据科学，那么这些数组对DS/ML有什么价值呢？像这样的惰性数组的概念在一个特定的环境中非常好:</p><blockquote class="nm nn no"><p id="a094" class="lr ls np lt b lu nf ju lw lx ng jx lz nq nh mc md nr ni mg mh ns nj mk ml mm im bi translated">我们更关心记忆，而不是计算。</p></blockquote><p id="4608" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">特别是在像Julia这样的语言中，它提供了更具命令性的静态类型的低级语言的速度和高级声明性语法的便利，这是我们可能要做的一个权衡。之前的10，000，000个值的数组几乎使用了千兆字节的数据。我的电脑总共只有8g的内存。也就是说，在执行期间，一个维度占用了整整10亿字节，也就是我总内存的1/8，这是一个很大的问题。在这种情况下，只要我们可以用表达式计算数组，这将非常适用于我正在进行的任何项目。</p><p id="f19b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我想到的一个真正伟大的应用是在工程特征中。也许我们甚至可以以表达式的形式读入值，但肯定主要形式是通过函数或表达式进行工程设计。这样我们可以说有一个惰性数组，它的起始表达式是</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="14b8" class="ok la it og b gy ol om l on oo">df["feature"] + df["feature"]</span></pre><p id="cfdf" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我认为惰性阵列真的很酷，可能会对数据科学产生相当大的影响。坦率地说，我喜欢用数组的代数表示法做大量的实验。这似乎是一个伟大的方式，许多东西都有可能被压缩。我一直在思考一些潜在的方法，也许我可以将这些方法应用到我的数据管理框架中，但是我们将会看到结果，因为我现在在每个地方都有很多工作要做。如果我要实现它，我希望它更有用，基本上允许任何值被转换成表达式。那么它可能是完全不费力的，你甚至不需要考虑它。感谢您阅读我的文章，我希望这个关于惰性数组的小项目既有趣又有趣。</p></div></div>    
</body>
</html>