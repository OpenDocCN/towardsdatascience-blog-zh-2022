<html>
<head>
<title>How to Write Pythonic Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写Pythonic代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-write-pythonic-code-208ec1513c49#2022-01-31">https://towardsdatascience.com/how-to-write-pythonic-code-208ec1513c49#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="c0f9" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">如何编写Pythonic代码</h1></div><div class=""><h2 id="f46b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">充分利用这美丽的语言</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03e4f7a185ace6a43bffc27f6285edc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0PNaiYW4Lkq7CDLY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@hiteshchoudhary" rel="noopener ugc nofollow" target="_blank"> Hitesh Choudhary </a>拍摄的照片</p></figure><p id="4bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> E </span>每种编程语言都有自己的习惯用法，由用户定义。在Python社区中，<em class="me">Python</em>是一个描述代码的词，它不仅语法正确，而且以预期的方式使用语言。从可维护性、可读性和效率的角度来看，它提高了整体代码质量。广义地说，它还为整个开发团队创建了一个代码模式，以关注问题的真正本质。要使库成为Python库，就要让Python开发人员很自然地在他们的代码库中使用它。记住，读<strong class="lb iu">代码比写</strong>代码更频繁。</p><p id="6ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它实际上是什么意思呢？这听起来像是一个模糊的概念。我该如何通过向他们展示‘T9’可信的‘T10’Python代码来破解Python采访呢？在本文中，我想告诉你8个广泛推广的Pythonic特性，它们将把你的代码带到下一个层次。它们主要是为希望快速提高技能的Python初学者设计的，但也有一些针对中间用户和专家的技巧。最后，我会给你一些关于编写一个Pythonic库或框架的技巧，以及一些有助于你自学的免费资源。</p><p id="1c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这是一篇长文章。为了给你一些期望，这里是内容。请随意跳过您已经知道的内容。</p><ul class=""><li id="12ea" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">蟒蛇的禅</li><li id="d5d1" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">PEP8</li><li id="d6a5" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">价值交换&amp;多重分配</li><li id="e6a7" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">传递多个参数(*args和**kwargs)</li><li id="b00c" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">理解</li><li id="97b6" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">强调</li><li id="99d0" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">上下文管理器</li><li id="9b3c" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">发电机</li><li id="a413" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">命名空间和范围</li><li id="39a7" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">可变默认参数</li><li id="91ab" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">编写一个Pythonic库</li><li id="3612" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">其他免费资源</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="5899" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">蟒蛇的禅</h2><p id="9dcf" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果我不从<em class="me">蟒蛇的禅</em>开始，这篇文章就不完整了。您可以通过键入<code class="fe ny nz oa ob b">import this</code>在任何给定的时间找到它。这是编写Python代码的19个“指导原则”的总结。我更愿意将其视为一种思维方式，而不是实际的语法指南。然而，这首诗中的哲学已经影响了全球成千上万的Python开发人员。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/9c477d4fb833bc98ca97541f4f547d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ki1tnMzXUjc5fSPmk1raHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蟒蛇之禅(摄影:高)</p></figure><p id="78e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我稍后将向你们展示的例子肯定是遵循这一理念的。请通读一遍。我将向您传达一些核心概念，以便您为示例做好准备。</p><p id="5d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">简单明了&amp;可读性</strong></p><p id="9dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把这三个特征放在同一个桶里，因为总的来说，这意味着编写每个人都能理解的简单和干净的代码。你可以用许多不同的方式来解释它。这首诗中的一个例子是<code class="fe ny nz oa ob b">flat is better than nested</code>，意思是在你的项目中不要有太多的子类别(模块/包)。<code class="fe ny nz oa ob b">sparse is better than dense</code>意味着不要在一行代码中塞进太多的函数<em class="me"> (79个字符的规则无论如何都会换行)</em>。</p><p id="7846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">没事<em class="me">打破</em>规则</strong></p><p id="3202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就结构而言，Python不如Java等其他编程语言严格。您可以编写纯过程(如脚本)或面向对象范例(如Java ),或者两者兼而有之。关键是你不必把你的代码放进不适合你的鞋子里。过分遵循规则会导致高度抽象和样板代码。</p><p id="fd1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意错误处理</strong></p><p id="3b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误不应该被忽略。快速失败并捕获它们比隐藏错误并继续程序更好。当bug远离原来的位置时，它们变得更难调试，因此现在而不是以后引发异常。</p><p id="54c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">应该有一种——最好只有一种——显而易见的方法来做这件事</strong></p><p id="778f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然是作为指南写的，但是我感觉用Python真的很难做到这一点。Python被认为是一种灵活的编程语言，受到大型社区的支持，这意味着人们每天都可以对现有的解决方案提出新的想法。然而，它试图传达的主要信息是，不值得花力气去学习每一种可能的方法。社区已经做了一些努力来标准化这些格式，我马上会谈到。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="c193" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">PEP8</h2><p id="cd08" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">正如我前面提到的，Python是一种灵活的语言，在格式上没有太多限制。这就是PEP8 出现的原因。欢迎您以任何方式编写Python代码，只要它是有效的。然而，使用一致的风格使你的代码更容易阅读和维护。PEP8提供了丰富的项目列表。绝对值得一查。</p><p id="f2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些著名的linters，如<a class="ae ky" href="https://flake8.pycqa.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Flake8 </a>和<a class="ae ky" href="https://pylint.org/" rel="noopener ugc nofollow" target="_blank"> Pylint </a>可以在你提交代码之前发现问题，从而为你的同事节省审查时间。像<a class="ae ky" href="https://black.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Black </a>这样的库甚至可以自动修复格式问题。常见的做法是将这些工具集成到您的IDE(例如vscode)和CI/CD管道中。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="6352" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">价值交换和多重分配</h2><p id="87a9" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">你可能以前见过这个问题:如何交换两瓶水？答案是得到第三个空瓶子。大多数语言都是这样处理的，需要一个额外的变量来交换值。</p><p id="d454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而在Python中，生活变得更容易了。您可以像这样交换两个值:</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="a989" class="na nb it ob b gy oj ok l ol om">a = 1<br/>b = 2<br/>a, b = b, a</span></pre><p id="278f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来太神奇了。第<code class="fe ny nz oa ob b">a,b=b,a</code>行被称为赋值，其中右边是一个表达式，左边是几个变量。右边的表达式<code class="fe ny nz oa ob b">b,a</code>其实就是<strong class="lb iu">一个元组</strong>。不信？在终端中尝试一下:</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="aa0b" class="na nb it ob b gy oj ok l ol om">&gt;&gt;&gt; 1,2<br/>(1, 2)</span></pre><p id="24c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">括号在元组中并不是真正必要的。</strong></p><p id="46c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，Python支持多重赋值，这意味着左侧可能有多个变量，每个变量都被赋值给元组中的一个值。这也称为<em class="me">拆包</em>分配。另一个解包赋值的例子是list:</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="9279" class="na nb it ob b gy oj ok l ol om">fruits = ["apple", "banana"]<br/>f1,f2 = fruits</span></pre><p id="b666" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果会是<code class="fe ny nz oa ob b">f1="apple"</code>，<code class="fe ny nz oa ob b">f2="banana"</code>。</p><p id="815d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，您可以轻松、优雅、自然地分配变量，而无需样板代码。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="b387" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">传递多个参数(*args和**kwargs)</h2><p id="057c" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">与前一点相关，Python允许向函数传递多个参数，而无需在函数中定义它们。一个例子可以是一个将一些数字相加的函数，但是数字的大小是未知的。</p><p id="e60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种简单的方法是创建一个列表变量作为函数的输入。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="4c16" class="na nb it ob b gy oj ok l ol om">def calculate(values):<br/>    for val in values:<br/>        ....<br/>calculate([1,2,3,4])</span></pre><p id="7b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在Python中，你可以有一个接口而不提供列表。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="43ec" class="na nb it ob b gy oj ok l ol om">def calculate(*values):<br/>    for val in values:<br/>        ....<br/>calculate(1,2,3,4)<br/>calculate(*[1,2,3,4]) # this works too</span></pre><p id="dc1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ny nz oa ob b">*values</code>等于<code class="fe ny nz oa ob b">(1,2,3,4)</code>是一个<strong class="lb iu">元组</strong>(一个可迭代的)，函数内部的逻辑可以保持不变。</p><p id="adcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe ny nz oa ob b">*args</code>类似，<code class="fe ny nz oa ob b">**kwargs</code>接受命名参数，并将它们解包成键、值对。当你有一堆有不同含义的可选参数时，这很有用。在这个例子中，房子可以由不同类型的房间组成。如果你不喜欢有太多的争论，你可以提供一本字典来代替。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="b1f4" class="na nb it ob b gy oj ok l ol om">def build_house(**kwargs):<br/>    for room,num in **kwargs:<br/>        ...<br/>build_house(bedroom=2,kitchen=1,bathroom=1,garden=1)<br/>build_house(bedroom=2,kitchen=1,bathroom=2,storage_room=1)</span></pre><p id="0814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解包的另一个有趣的事情是你可以很容易地合并两个列表或字典。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="3d2e" class="na nb it ob b gy oj ok l ol om">first = [1,2,3]<br/>second = [4,5,6]<br/>result = [*first, *second] <br/># [1,2,3,4,5,6]</span><span id="04f9" class="na nb it ob b gy on ok l ol om">first = {"k1":"v1"}<br/>second = {"k2":"v2"}<br/>result = {**first, **second}<br/># {"k1":"v1", "k2":"v2"}</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="a46a" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">理解</h2><p id="d9ba" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">理解很酷。这是我对它的第一印象。理解用于在单个指令而不是多个操作中创建数据结构。一个经典的例子是将一个for循环转换成一行代码。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="e9bf" class="na nb it ob b gy oj ok l ol om">result = []<br/>for i in range(10):<br/>    result.append(i**2)</span><span id="8bf9" class="na nb it ob b gy on ok l ol om"># use list comprehension<br/>result = [i**2 for i in range(10)]</span></pre><p id="0dcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，理解的表现更好，因为它的操作更少，因此不需要对每一项都执行<code class="fe ny nz oa ob b">.append()</code>。在复杂的函数中，理解可以明显减少代码的行数，使读者容易理解。另一个可比较的方法是使用<a class="ae ky" rel="noopener" target="_blank" href="/learn-python-lambda-from-scratch-f4a9c07e4b34">λ表达式</a>。同样的表达式可以写成这样:</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="7ce0" class="na nb it ob b gy oj ok l ol om">result = list(map(lambda x:x**2, [i for i in range(3)]))</span></pre><p id="577d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果代码创建了复杂的表达式，不要强迫它成为一行代码。我读过《Python中的干净代码》一书，其中有一个很好的例子。<code class="fe ny nz oa ob b">collect_account_ids_from_arns</code>函数接收一个值列表，然后解析、匹配并最终将它们添加到<code class="fe ny nz oa ob b">collected_account_ids</code>中。</p><p id="462b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是for循环的简单解决方案。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="3030" class="na nb it ob b gy oj ok l ol om">def collect_account_ids_from_arns(arns):<br/>    collected_account_ids = set()<br/>    for arn in arns:<br/>        matched = re.match(ARN_REGEX, arn)<br/>        if matched is not None:<br/>            account_id = matched.groupdict()["account_id"]<br/>            collected_account_ids.add(account_id)<br/>    return collected_account_ids</span></pre><p id="bbf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是有领悟的版本。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="03db" class="na nb it ob b gy oj ok l ol om">def collect_account_ids_from_arns(arns):<br/>    matched_arns = filter(None, (re.match(ARN_REGEX, arn) for arn in arns))<br/>    return {m.groupdict()["account_id"] for m in matched_arns}</span></pre><p id="48e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个更紧凑的版本是使用walrus operator。该示例将代码推送到实际的一行程序中。但这并不一定比第二种方法更好。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="c0da" class="na nb it ob b gy oj ok l ol om">def collect_account_ids_from_arns(arns):<br/>    return { matched.groupdict()["account_id"] for arn in arns if (matched := re.match(ARN_REGEX, arn)) is not None }</span></pre><p id="15a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解可以简化代码并提高性能，但是考虑可读性也是必须的。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="0705" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">强调</h2><p id="fd44" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">Python中使用下划线的方式不止一种。每种类型代表属性的不同特征。</p><p id="9497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，对象的所有属性都是公共的。没有<em class="me"> private </em>关键字阻止你访问一个属性。Python在函数名前使用下划线(如<code class="fe ny nz oa ob b">def _build()</code>)来划定对象的接口。以下划线开头的属性应该被认为是私有的，不能从外部调用。类的私有方法/属性只能在内部调用。如果这个类获得了太多的内部方法，这可能是这个类违反了单一责任原则的标志，也许你想把一些责任提取给其他类。</p><p id="6a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下划线的另一个Pythonic特性是所谓的<a class="ae ky" href="https://rszalski.github.io/magicmethods/" rel="noopener ugc nofollow" target="_blank"> <em class="me">魔法</em>方法</a>。神奇的方法被双下划线包围，如<code class="fe ny nz oa ob b">__init__</code>。好玩的事实，根据<a class="ae ky" href="https://www.dourish.com/goodies/jargon.html" rel="noopener ugc nofollow" target="_blank"> <em class="me">原黑客的字典</em> </a>，神奇的意思是</p><blockquote class="oo op oq"><p id="4f33" class="kz la me lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated"><em class="it">一个没有公开的功能，它允许一些本来不可能的事情。</em></p></blockquote><p id="2b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python社区在Ruby社区之后采用了这个术语。它们允许用户访问语言的核心特性，从而创建丰富而强大的对象。成为魔术方法的专家可以让你的客户拥有干净的代码。听起来很抽象？让我们看一个例子:</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="aa95" class="na nb it ob b gy oj ok l ol om">class House:<br/>    def __init__(self, area):<br/>        self.area = area<br/>    def __gt__(self, other):<br/>        return self.area &gt; other.area</span><span id="074a" class="na nb it ob b gy on ok l ol om">house1 = House(120)<br/>house2 = House(100)</span></pre><p id="f3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过覆盖魔法方法<code class="fe ny nz oa ob b">__gt__</code>，使用<code class="fe ny nz oa ob b">House</code>的客户端可以用<code class="fe ny nz oa ob b">house1 &gt; house2</code>比2个房子，而不是类似<code class="fe ny nz oa ob b">house1.size() &gt; house2.size()</code>的东西。</p><p id="0486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个例子是改变类的表示。如果你打印<code class="fe ny nz oa ob b">house1</code>，你会得到一个带有id的Python对象。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="0281" class="na nb it ob b gy oj ok l ol om">print(house1)<br/># &lt;__main__.House object at 0x10181f430&gt;</span></pre><p id="ae39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了魔法方法<code class="fe ny nz oa ob b">__repr__</code>，打印语句变得更加不言自明。神奇的方法对客户隐藏了实现细节，同时给了开发人员改变其原始行为的能力。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="0f51" class="na nb it ob b gy oj ok l ol om">def __repr__(self) -&gt; str:<br/>    return f"This house has {self.area} square meters."</span><span id="5e0b" class="na nb it ob b gy on ok l ol om">print(house1)<br/># This house has 120 square meters.</span></pre><p id="1883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管使用下划线很常见，但是不要使用双下划线来定义属性，也不要定义自己的神奇方法。它不是Pythonic式的，只会让你的同行感到困惑。我写了一篇关于这个话题的文章。你可以在这里查看<a class="ae ky" rel="noopener" target="_blank" href="/5-different-meanings-of-underscore-in-python-3fafa6cd0379"/>。</p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/5-different-meanings-of-underscore-in-python-3fafa6cd0379"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">Python中下划线的5种不同含义</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">确保使用正确的语法</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="16fd" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">上下文管理器</h2><p id="9031" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">上下文管理器值得单独写一篇文章。这是一个非常有用的特性，可以帮助你在某些动作之前和之后运行一些东西。资源管理是它的一个很好的用例。您希望确保文件或连接在处理后关闭。</p><p id="3ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，可以使用两种方法来分配和释放资源:</p><ul class=""><li id="9303" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">使用<code class="fe ny nz oa ob b">try .. finally</code>挡块</li><li id="78fc" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">使用<code class="fe ny nz oa ob b">with</code>构造</li></ul><p id="7571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我想打开一个文件，阅读内容，然后关闭它。这就是使用<code class="fe ny nz oa ob b">try .. finally</code>的样子。<code class="fe ny nz oa ob b">finally</code>语句保证无论发生什么情况，资源都被正确关闭。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="045f" class="na nb it ob b gy oj ok l ol om">f = open("data.txt","r") <br/>try:<br/>  text = f.read()<br/>finally:<br/>  f.close()</span></pre><p id="0d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，您可以使用<code class="fe ny nz oa ob b">with</code>语句使它更加Pythonic化。如您所见，许多样板代码被删除了。当您使用<code class="fe ny nz oa ob b">with</code>语句时，您进入了一个上下文管理器，这意味着当程序块完成时，文件将被关闭，即使发生了异常。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="3b50" class="na nb it ob b gy oj ok l ol om">with open("data.txt", "r") as f:<br/>  text = f.read()</span></pre><p id="73a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么发生的？任何上下文管理器都由两个神奇的方法组成:<code class="fe ny nz oa ob b">__enter__</code>和<code class="fe ny nz oa ob b">__exit__</code>。<code class="fe ny nz oa ob b">with</code>语句将调用方法<code class="fe ny nz oa ob b">__enter__</code>，它返回的任何内容都将被赋给<code class="fe ny nz oa ob b">as</code>之后的变量。在该块中的最后一行代码完成后，Python将调用<code class="fe ny nz oa ob b">__exit__</code>，其中资源被关闭。</p><p id="0ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我们可以自由地用自己的逻辑实现上下文管理器。我想向您展示实现上下文管理器的3种不同方法(是的..我们正在打破<em class="me">Python的禅</em>的规则。假设我想为备份创建一个数据库处理程序。数据库应该在备份前脱机，并在备份后重新启动。</p><ul class=""><li id="4bcc" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><strong class="lb iu">创建上下文管理器类。</strong>在这个例子中，在<code class="fe ny nz oa ob b">__enter__</code>扇区不需要返回任何东西，这是可以的。<code class="fe ny nz oa ob b">__exit__</code>扇区接收从块中产生的异常。您可以决定如何处理异常。如果您什么都不做，那么在资源被正确关闭后，异常将被引发给调用方。或者您可以根据异常类型处理<code class="fe ny nz oa ob b">__exit__</code>块中的异常。但是总的原则是不要默默地接受错误。另一个通用提示是不要在<code class="fe ny nz oa ob b">__exit__</code>块中返回<code class="fe ny nz oa ob b">True</code>，除非你知道你在做什么。返回<code class="fe ny nz oa ob b">True</code>将忽略所有的异常，它们不会被提交给调用者。</li></ul><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="236a" class="na nb it ob b gy oj ok l ol om">def stop_db():<br/>  # stop database</span><span id="54a3" class="na nb it ob b gy on ok l ol om">def start_db():<br/>  # start database</span><span id="08a1" class="na nb it ob b gy on ok l ol om">def backup_db():<br/>  # backup database</span><span id="956d" class="na nb it ob b gy on ok l ol om">class DatabaseHandler:<br/>  def __enter__(self):<br/>    stop_db()</span><span id="497a" class="na nb it ob b gy on ok l ol om">def __exit__(self, exc_type, ex_value, ex_traceback):<br/>    start_db()</span><span id="46e9" class="na nb it ob b gy on ok l ol om">with DatabaseHandler():<br/>  backup_db()</span></pre><ul class=""><li id="2e31" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><strong class="lb iu">使用</strong> <code class="fe ny nz oa ob b"><strong class="lb iu">contextmanager</strong></code> <strong class="lb iu">装饰器。你不必每次都创建一个类。想象一下，您希望将现有的功能转变为上下文管理器，而不需要过多地重构代码。在这种情况下，您可以使用装饰器。装饰者本身是另一个话题。但它本质上做的是把原来的函数变成一个生成器。<code class="fe ny nz oa ob b">yield</code>之前的所有内容都是<code class="fe ny nz oa ob b">__enter__</code>的一部分，产生的值成为<code class="fe ny nz oa ob b">as</code>之后的变量。在这个例子中，不需要放弃任何东西。一般来说，如果您只需要一个上下文管理器函数而不需要保留太多状态，这是一个更好的方法。</strong></li></ul><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="96af" class="na nb it ob b gy oj ok l ol om">import contextlib</span><span id="952b" class="na nb it ob b gy on ok l ol om">@contextlib.contextmanager<br/>def db_handler():     <br/>  try:         <br/>    stop_db()         <br/>    yield     <br/>  finally:        <br/>    start_db()</span><span id="72bc" class="na nb it ob b gy on ok l ol om">with db_handler():     <br/>  db_backup()</span></pre><ul class=""><li id="66ff" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><strong class="lb iu">基于</strong> <code class="fe ny nz oa ob b"><strong class="lb iu">contextlib.ContextDecorator</strong></code>创建一个装饰类:第三个选项是创建一个装饰类，它是前两个选项的混合。您不用使用仍然可以使用的<code class="fe ny nz oa ob b">with</code>语句，而是将它用作函数顶部的装饰器。这样做的好处是，通过简单地将装饰器应用于其他函数，您可以任意多次地重用它。</li></ul><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="b999" class="na nb it ob b gy oj ok l ol om">class db_handler_decorator(contextlib.ContextDecorator):<br/>  def __enter__(self):<br/>    stop_db()</span><span id="68fb" class="na nb it ob b gy on ok l ol om">  def __exit__(self, ext_type, ex_value, ex_traceback):<br/>    start_db()</span><span id="c9ed" class="na nb it ob b gy on ok l ol om">@db_handler_decorator()<br/>def db_backup():<br/>  # backup process</span></pre><p id="9ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，对于一个项目来说，这是一个相当长的部分。我不会在上下文管理器上深入讨论太多。但是总的建议是，即使你是一个初学者，你也应该至少理解它的工作原理。作为一名中级或专家，您可以尝试从头开始创建一些上下文管理器，以发现它更多的本质。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="a590" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">发电机</h2><p id="4fd1" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在上一篇文章中，我提到了一个叫做生成器的概念，这也是区别于Python的一个独特的特性。生成器是一个iterable，它定义了一个<code class="fe ny nz oa ob b">next()</code>方法。但特别的是你只能迭代一次，因为它们不会把所有的值都存储在内存中。</p><p id="9782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器被实现为一个函数，但是它没有像常规函数一样使用<code class="fe ny nz oa ob b">return</code>，而是使用了<code class="fe ny nz oa ob b">yield</code>。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="abfe" class="na nb it ob b gy oj ok l ol om">def generator():<br/>  for i in range(10):<br/>    yield i**2</span><span id="cfa4" class="na nb it ob b gy on ok l ol om">print(generator)<br/># &lt;function generator at 0x109663d90&gt;</span></pre><p id="68fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会看到这在<code class="fe ny nz oa ob b">asyncio</code>中被大量使用，因为协程本质上是一个生成器。然而，它的优势之一是减少内存使用，这可能会对大数据集产生巨大影响。假设我想对1M的记录进行一些计算。</p><p id="ae59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在了解<code class="fe ny nz oa ob b">yield</code>之前，你会这样做。问题在于，你必须将所有100万条记录的结果存储在内存中。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="65ba" class="na nb it ob b gy oj ok l ol om">def calculate(size):<br/>  result = []<br/>  for i in range(size):<br/>    result.append(i**2)<br/>  return result</span><span id="ae8a" class="na nb it ob b gy on ok l ol om">for val in calculate(1_000_000):<br/>  print(val)</span></pre><p id="056e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个使用<code class="fe ny nz oa ob b">yield</code>的替代方案。只在轮到它的时候才计算结果，从而节省了大量的内存使用。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="f0ba" class="na nb it ob b gy oj ok l ol om">def calculate(size):<br/>  for i in range(size):<br/>    yield i**2</span><span id="0b46" class="na nb it ob b gy on ok l ol om">for val in calculate(1_000_000):<br/>  print(val)</span></pre><p id="f734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器也是懒惰求值背后的秘密，对此我写了另一篇文章。请随意检查。</p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/what-is-lazy-evaluation-in-python-9efb1d3bfed0"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">Python中的懒求值是什么？</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">你不知道Python为你优化了多少代码</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="a4fa" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">命名空间和范围</h2><p id="c158" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">作为<em class="me">Python的禅</em>的最后一行，我们来谈谈Python中的命名空间和作用域。名称空间是Python中的一个系统，用于确保所有名称(属性、函数、类、模块)在程序中是唯一的。在Python中，名称空间作为一个字典来管理，其中键是对象名，值是对象本身。</p><p id="89f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，Python中有4种类型的名称空间:Python内置的、全局的、封闭的和按层次排序的局部的。这个图也被称为<strong class="lb iu"> LEGB </strong>规则。解释器首先在本地搜索名称，然后是封闭的，然后是全局的，最后是内置的，这意味着低级别的名称(例如本地的)将覆盖高级别的相同名称(例如封闭的)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/09030dd4fea2ed8e1abcd60d3ae8afcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*Eli1TLfTKteacoADWpayjw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由创作<a class="od oe ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----208ec1513c49--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="cf60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它如何影响我们的编码？大多数时候，如果你只是遵循LEGB规则，你不必做任何特别的事情。这里举个例子。在继续前进之前想一想。产量是多少？</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="c3c4" class="na nb it ob b gy oj ok l ol om">val = 1</span><span id="ae19" class="na nb it ob b gy on ok l ol om">def outer():<br/>  val = 2<br/>  <br/>  def inner():<br/>    val = 3<br/>    print(val)<br/>  <br/>  inner()</span><span id="9e47" class="na nb it ob b gy on ok l ol om">print(outer())<br/>print(val)</span></pre><p id="5f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据LEBG规则，较低的级别应该覆盖较高的级别。在函数<code class="fe ny nz oa ob b">inner()</code>中，<code class="fe ny nz oa ob b">val</code>的值为3，所以调用函数<code class="fe ny nz oa ob b">outer()</code>将返回3。然而，如果你只是像<code class="fe ny nz oa ob b">print(val)</code>一样打印出<code class="fe ny nz oa ob b">val</code>，你将得到1，因为你目前在函数之外，并试图访问全局值<code class="fe ny nz oa ob b">val = 1</code>。</p><p id="12be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你想从较低的级别修改一个全局值，这可以用<code class="fe ny nz oa ob b">global</code>关键字来实现。你需要的是在你想要改变全局值的地方加上<code class="fe ny nz oa ob b">global val</code>。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="1881" class="na nb it ob b gy oj ok l ol om">val = 1</span><span id="e022" class="na nb it ob b gy on ok l ol om">def outer():<br/>  val = 2<br/>  <br/>  def inner():<br/><strong class="ob iu">    global val<br/></strong>    val = 3<br/>    print(val)<br/>  <br/>  inner()</span><span id="55c4" class="na nb it ob b gy on ok l ol om">print(outer()) # 3<br/>print(val) # 3</span></pre><p id="ae50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个声明，像<code class="fe ny nz oa ob b">global val = 3</code>这样的语法是不正确的。另一个选择是<code class="fe ny nz oa ob b">globals()[“val”] = 3</code>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="7fc0" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">可变默认参数</h2><p id="4cfb" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">最后但同样重要的是，我想向您展示一个Pythonic警告，您可能认为这是一个<em class="me"> bug </em>，但实际上是一个特性。尽管它令人困惑，但它仍然是每个人都必须与之相处的Pythonic特性。</p><p id="ab90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑下面的例子。功能<code class="fe ny nz oa ob b">add_to_shopping_cart</code>将<code class="fe ny nz oa ob b">food</code>加到<code class="fe ny nz oa ob b">shopping_cart</code>上。如果没有提供，<code class="fe ny nz oa ob b">shopping_cart</code>默认为空列表。在这个例子中，在没有提供<code class="fe ny nz oa ob b">shopping_cart</code>的情况下调用这个函数两次应该会得到两个列表，每个列表有一个元素。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="28b4" class="na nb it ob b gy oj ok l ol om">def add_to_shopping_cart(food, shopping_cart = []):<br/>  shopping_cart.append(food)<br/>  return shopping_cart</span><span id="7909" class="na nb it ob b gy on ok l ol om">print(add_to_shopping_cart("egg"))<br/># ["egg"]<br/>print(add_to_shopping_cart("milk"))<br/># ["egg","milk"]</span></pre><p id="5108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这是实际发生的事情。解释是——变量<code class="fe ny nz oa ob b">shopping_cart</code>是<strong class="lb iu">在函数</strong>的定义上只创建一次，也就是这个函数第一次被调用的时刻。从那时起，Python解释器将在每次调用函数时使用相同的变量，这意味着每当值改变时，Python将把它传递给下一次调用，而不是用默认值重新创建它。</p><p id="3d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复很简单——使用<code class="fe ny nz oa ob b">None</code>作为缺省的sentinel值，并在函数体中分配实际的缺省值<code class="fe ny nz oa ob b">[]</code>。由于名称空间和本地范围的原因，<code class="fe ny nz oa ob b">shopping_cart</code>将在每次<code class="fe ny nz oa ob b">None</code>时被重新创建。</p><pre class="kj kk kl km gt of ob og oh aw oi bi"><span id="dd03" class="na nb it ob b gy oj ok l ol om">def add_to_shopping_cart(food, shopping_cart=None):<br/>  shopping_cart = shopping_cart or []<br/>  shopping_cart.append(food)<br/>  return shopping_cart</span><span id="af60" class="na nb it ob b gy on ok l ol om">print(add_to_shopping_cart("egg"))<br/># ['egg']<br/>print(add_to_shopping_cart("milk"))<br/># ["milk"]</span></pre><p id="02c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的经验是不要改变可变的默认参数，除非你知道你在做什么。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="b38a" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">写一个Pythonic库</h2><p id="1372" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">到目前为止，我们讨论的都是每一个Python特性。当谈到编写Python库或框架时，我们还应该考虑如何设计Python API。除了遵循常见的Python习惯用法，旨在被其他人使用的接口通常比其他语言更小、更轻量级。如果这个库过多地重复发明轮子，就会被认为不是Pythonic。考虑到<em class="me">“只有一种方法”，最好将另一个第三方软件包安装到您的库中。</em></p><p id="12bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个通用的提示是，不要仅仅为了遵循像Java这样的设计模式而编写样板代码。一个例子是<a class="ae ky" href="https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python" rel="noopener ugc nofollow" target="_blank">如何用Python </a>写一个singleton。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="5279" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">其他免费资源</h2><p id="c174" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">我没有提到的是一些基本的Pythonic表达，比如用<code class="fe ny nz oa ob b">for i, color in enumerate(colors)</code>代替<code class="fe ny nz oa ob b">for i in range(len(colors))</code>。这里有一些很棒的Youtube视频，让你重温一下知识。</p><p id="3be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=OSGv2VnC0go" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=OSGv2VnC0go</a>(将代码转换成漂亮的、惯用的Python)</p><p id="18d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=x-kB2o8sd5c" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=x-kB2o8sd5c</a>(一条蟒蛇？美学:美丽和我为什么是蟒蛇)</p><p id="1b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以看看2003年的这个<a class="ae ky" href="https://mail.python.org/pipermail/tutor/2003-October/025930.html" rel="noopener ugc nofollow" target="_blank">帖子，当时人们在讨论什么是Pythonic。很有趣的一个！我喜欢这一段:</a></p><blockquote class="oo op oq"><p id="1f46" class="kz la me lb b lc ld ju le lf lg jx lh or lj lk ll os ln lo lp ot lr ls lt lu im bi translated">Unpythonic正在进行大量的类型检查，或者非常努力地使<br/>成为私有/受保护的东西。或者使用索引来循环遍历列表<br/>，而不仅仅是“在我的列表中查找项目”。基本上，人们做的任何事情都是因为他们在其他语言中是这样做的，认为它已经尽善尽美了。</p></blockquote></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="821b" class="na nb it bd nc nd ne dn nf ng nh dp ni li nj nk nl lm nm nn no lq np nq nr ns bi translated">结论</h2><p id="1e6a" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">谢谢你能来这里。感谢您的宝贵时间！这篇15分钟的文章只是关于<em class="me">python</em>特性的冰山一角。除了每一项和文章中没有包括的许多其他项目之外，还有很多要说的。无论如何，我希望这能启发你重新审视你的Python代码，并能给你的同行更多有价值的评审意见。任何想法都欢迎在评论区发表！</p></div></div>    
</body>
</html>