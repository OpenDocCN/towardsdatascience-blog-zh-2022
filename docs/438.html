<html>
<head>
<title>6 Lesser-Known SQL Techniques to Save You 100 Hours a Month</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6种鲜为人知的SQL技术每月为您节省100个小时</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-lesser-known-sql-techniques-to-save-you-100-hours-a-month-10ceed47d3fe#2022-01-15">https://towardsdatascience.com/6-lesser-known-sql-techniques-to-save-you-100-hours-a-month-10ceed47d3fe#2022-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="ecc2" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">6种鲜为人知的SQL技术每月为您节省100个小时</h1></div><div class=""><h2 id="3dba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些简单的技术使您的分析和数据提取更容易</h2></div><p id="6f0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在八年的数据职业生涯中，我依靠一些简单但鲜为人知的SQL技术为自己节省了无数的时间来执行分析和构建ETL管道。</p><p id="eee1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将分享六个反复出现的问题:</p><h2 id="1753" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">从表中查找和删除重复记录</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9cf5" class="le lf it mc b gy mg mh l mi mj">with x as (select *, row_number() over(partition by [key],[key],[key] order by [key]) as rowRank from {schema}.{table})<br/>select * from x where rowRank &gt; 1;</span></pre><p id="8eed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有比复制品更糟糕的了。可怕的重复记录给我的数据生命周期带来了巨大的痛苦。重复会弄乱任何分析或仪表板——尤其是那些不会因为简单的DISTINCT子句而消失的分析或仪表板。有多种方法可以识别重复项，但我发现上面的例子是最简单的。</p><p id="443d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只需将主查询包装在一个CTE中，在您希望检查的所有变量之后，添加一个在所有表键上分区的<em class="mk"> row_number </em>函数。该分区必须包含所有表键才能正常工作，否则您可能会将非重复项错误分类。<em class="mk"> row_number </em>函数在这里做的是对您提供的所有键实例进行排序。在CTE之后，运行一个简单的选择和过滤，其中新的<em class="mk">row _ number</em>function<em class="mk"/>字段大于1。输出将返回所有重复的记录——因为任何具有<em class="mk"> rowRank &gt; 1 </em>的记录在表中都有重复的键。此外，您可以通过运行以下命令来查看有多少重复记录:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="28d0" class="le lf it mc b gy mg mh l mi mj">with x as (select *, row_number() over(partition by [key],[key],[key] order by [key]) as rowRank from {schema}.{table})<br/>select [keys], max(rowRank) - 1 num_duplicates from x group by [keys];</span></pre><p id="9b20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，如果您想删除所有的重复项，您实际上可以在CTE中使用delete语句！</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9e4f" class="le lf it mc b gy mg mh l mi mj">with x as (select *, row_number() over(partition by [key],[key],[key] order by [key]) as rowRank from {schema}.{table})<br/>delete * from x where rowRank &gt; 1;</span></pre><p id="172a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:delete将<strong class="kk iu">永久地</strong>从表中删除记录——所以应该非常小心地使用它。测试这种方法的一种方法是创建一个有问题的表的临时副本，并在第一个副本上运行删除操作。然后在主表上执行删除之前做一些质量保证。</p><figure class="lx ly lz ma gt mm gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/d8e5ddfb3033f3f571da99e7c601ff6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*XROvqMpxG0DrZScyWpetsQ.jpeg"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">凯文·Ku从<a class="ae mt" href="https://www.pexels.com/photo/data-codes-through-eyeglasses-577585/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄的照片</p></figure><h2 id="101f" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">从表中查询最近的一组记录</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6cc1" class="le lf it mc b gy mg mh l mi mj">select a.*, a.[date] from {schema}.{table} a <br/>join (select max(date) maxDate from schema.table) b <br/>on a.date = b.maxDate</span></pre><p id="7bee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数数据专业人员都处理大量时间序列数据。然而，时间序列不仅仅是带有日期戳的值，它还可以是数据集的带有日期戳的版本。例如，在我目前的工作中，我们会定期“快照”数据集当天版本的副本，以便我们可以跟踪它如何随着时间的推移而变化。从表中获取最新的记录集(即最新的“版本”)变得很重要。上面的查询通过在最大日期字段上将有问题的表连接到自身来实现这一点。内部联接筛选出日期不等于最大日期的所有记录。或者，您可以使用左连接，然后使用where子句进行筛选:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="b097" class="le lf it mc b gy mg mh l mi mj">select a.*, a.[date], b.maxDate from {schema}.{table} a <br/>left join (select max(date) maxDate from schema.table) b <br/>on a.date = b.maxDate<br/>where date = maxDate</span></pre><h2 id="a522" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">每月或每周开始/周末汇总每日数据</h2><p id="1b2f" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated"><strong class="kk iu">每月</strong></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d11c" class="le lf it mc b gy mg mh l mi mj">select [key], sum([field]),  DATEADD(month, DATEDIFF(month, 0, [date field]), 0) as month from {schema}.{table} group by [key]</span></pre><p id="e43d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">周初</strong></p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fadf" class="le lf it mc b gy mg mh l mi mj">select [key], sum([field]),  DATEADD(wk, DATEDIFF(wk, 6, [date]), 6) as weekBeginning from {schema}.{table} group by [key]</span></pre><p id="4ebf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上两种技术将允许您快速、轻松地在月初或周初对每日级别的时间序列数据进行分组。SQL中还有其他日期函数可以做到这一点，但我发现这些是最简单的。这种技术还有助于在仪表板工具或excel中更容易地显示时间序列。例如，我经常喜欢使用以“YYYY-MM”的形式显示时间序列中连续几个月的视觉效果，以这种方式设置查询将使这一工作变得更加容易。</p><h2 id="d14d" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">聚集自定义(案例时)类别的数据</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a119" class="le lf it mc b gy mg mh l mi mj">select [key], sum([field]), <br/>CASE WHEN date between '2022-09-01' and '2022-12-31' then 'Fall'<br/>WHEN date between '2022-01-01' and '2022-03-31' then 'Winter'<br/>WHEN date between '2022-04-01' and '2022-06-30' then 'Spring'<br/>WHEN date between '2022-07-01' and '2022-08-31' then 'Summer' end as Seasons from {schema}.{table} group by <br/>CASE WHEN date between '2022-09-01' and '2022-12-31' then 'Fall'<br/>WHEN date between '2022-01-01' and '2022-03-31' then 'Winter'<br/>WHEN date between '2022-04-01' and '2022-06-30' then 'Spring'<br/>WHEN date between '2022-07-01' and '2022-08-31' then 'Summer' end</span></pre><p id="cc40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用这种技术，您可以使用CASE语句和GROUP BY子句聚合自定义类别的数据。这可以在上面的一个语句中完成，或者如果你想避免使用长组，你可以使用CTE。(注意:在GROUP BY case语句中，以“end”结尾，而不是像SELECT语句中那样以“end as”结尾)。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1085" class="le lf it mc b gy mg mh l mi mj">WITH X as (select [key], [field]), <br/>CASE WHEN date between '2022-09-01' and '2022-12-31' then 'Fall'<br/>WHEN date between '2022-01-01' and '2022-03-31' then 'Winter'<br/>WHEN date between '2022-04-01' and '2022-06-30' then 'Spring'<br/>WHEN date between '2022-07-01' and '2022-08-31' then 'Summer' end as Seasons from {schema}.{table})<br/>select [key], sum([field]), Seasons from X group by Seasons </span></pre><p id="3378" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我使用日期参数创建了一个“季节”字段，但是您可以做任何事情。</p><h2 id="08b3" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">在同一个表中找出今天和昨天(或任意两个日期)的区别</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="610e" class="le lf it mc b gy mg mh l mi mj">-- MS SQL SERVER 2016 or later</span><span id="b65b" class="le lf it mc b gy mz mh l mi mj">with x as (<br/>select *, row_number() over(partition by [keys] order by [date_field] desc) as dateOrder<br/>from {schema}.{table}<br/>where [date_field] &gt;= dateadd(day,-2,getdate()))<br/>,<br/>x1 as (<br/>select * from x where dateOrder = 1),<br/>x2 as (select * from x where dateOrder = 2)<br/>select [fields] from x1 <br/>left join x2 on x1.key = x2.key (and x1.key = x2.key and x1.key = x2.key)<br/>where x2.[key] is null </span><span id="8336" class="le lf it mc b gy mz mh l mi mj">-- POSTGRES SQL </span><span id="c17c" class="le lf it mc b gy mz mh l mi mj">with x as (<br/>select *, row_number() over(partition by [keys] order by [date_field] desc) as dateOrder<br/>from {schema}.{table}<br/>where [date_field] &gt;= CURRENT_TIMESTAMP - interval '2 day'<br/>,<br/>x1 as (<br/>select * from x where dateOrder = 1),<br/>x2 as (select * from x where dateOrder = 2)<br/>select [fields] from x1 <br/>left join x2 on x1.key = x2.key (and x1.key = x2.key and x1.key = x2.key)<br/>where x2.[key] is null</span></pre><p id="2019" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一个看起来非常合适，但是它是一个经常出现的用例。它的一些用途:</p><ul class=""><li id="8362" class="na nb it kk b kl km ko kp kr nc kv nd kz ne ld nf ng nh ni bi translated">监视每天有多少新记录被添加到表中。</li><li id="7992" class="na nb it kk b kl nj ko nk kr nl kv nm kz nn ld nf ng nh ni bi translated">识别在“快照”表中的两个日期之间添加的新记录(即，正如我上面描述的，这些表具有相同数据集/数据源的时间戳副本)。</li></ul><h2 id="b4d6" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">将一个表中的数据合并到另一个表中(最简单的方法)</h2><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="72f9" class="le lf it mc b gy mg mh l mi mj">delete from {schema}.{target_table} where exists (select 1 from {schema}.{source_table} where {schema}.{source_table}.[key] = {schema}.{target_table}.[key])</span></pre><p id="fbcf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多方法可以将数据从一个表合并到另一个表。MS SQL实际上有一个MERGE语句来做这样的事情。然而，我发现以上是在脚本化ETL管道中设置数据合并的最简单的方法。</p><p id="d59c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我编写了大量代码来自动从API获取数据，然后例行公事地将新数据转储到数据库表中。通常，我的做法是让Python脚本拉回特定时间范围内的新数据(2天-1周或更长时间，具体取决于数据源)，然后将所有数据推送到临时表中。一旦新数据出现在临时表中，我就运行上面的delete语句，该语句将扫描生产表，查找新表中已经存在的记录。最后，一旦删除了目标表中所有已经存在的记录，我就运行一个简单的从临时表到目标表的插入操作。</p><p id="9de8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这些技术中至少有一种对您来说是新的，并且有助于简化您的查询和分析。如果你喜欢这篇文章，你可以在这里查看我的其他作品。如果您对从REST APIs获取数据感兴趣，那么<a class="ae mt" rel="noopener" target="_blank" href="/how-to-pull-data-from-an-api-using-python-requests-edcc8d6441b1">这篇文章</a>也会很有帮助。</p></div></div>    
</body>
</html>