<html>
<head>
<title>Fuzzy String Search: Pruning The Search Space</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">模糊字符串搜索:修剪搜索空间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fuzzy-string-search-pruning-the-search-space-4012811f592a#2022-01-21">https://towardsdatascience.com/fuzzy-string-search-pruning-the-search-space-4012811f592a#2022-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="aada" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated"><strong class="ak">模糊字符串搜索:修剪搜索空间</strong></h1></div><div class=""><h2 id="8aa2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">拼音键，区分位置的哈希</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68a0b46e648d7ebfd2f563a1210f18f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fh0b6jtAI1X1HDIV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@octadan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">屋大维丹</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="5f12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在给定的字符串字典中寻找一个字符串的近似匹配的问题。</p><p id="9848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。我们想在一个干净的人名字典中搜索<em class="lv"> Jonahtan </em>。我们真正的意思是，在考虑到拼写错误或其他变化后，我们希望找到近似的匹配。我们所说的“其他变体”是什么意思？在我们的示例中，我们真正想要找到的是字典中的名字，这些名字是隐含在输入字符串中的名字的似乎合理的替代表达式。这不仅包括拼写错误，还包括昵称。也可以包括<em class="lv">先生</em>、<em class="lv">小姐</em>、…</p><p id="1876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索可能会在字典中产生与<em class="lv"> Jonahtan </em>匹配的<em class="lv"> Jonathan </em>。我们知道后者是一个拼写错误，并在这个过程中找到它的正确拼写。</p><p id="9039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">一般方法</strong></p><p id="61a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的常见方法是调用模糊匹配器作为黑盒方法。模糊匹配器输入两个字符串，并计算它们成为同一实体的表达式的可能性。模糊匹配器在[1]中有详细介绍。</p><p id="4f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种简单的方法是获取输入字符串，将其与字典中的每个字符串进行模糊匹配，将得分最高的匹配排列在列表的顶部，然后以某种方式决定哪些排名最高的匹配(如果有)是输入字符串的足够好的匹配。</p><p id="8bb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当字典很大时，这种方法会很慢。即使它不是很慢，我们也可能有严格的运行时间要求，比如实时查找匹配。</p><p id="443d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">修剪搜索空间</strong></p><p id="bf69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们关注的是修剪搜索空间以减少模糊匹配的问题。当然，修剪取决于输入字符串。</p><p id="4e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们讨论一些剪枝方法，特别是那些基于语音键和基于位置敏感散列的方法。我们用一个运行中的例子来说明它们:在名字的(大)字典中查找字符串的模糊匹配。</p><p id="c3f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">有哪些取舍？</strong></p><p id="fbb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目的是在不丢失任何真实匹配的情况下，尽可能地减少空间。因为这个理想可能无法保证，在实践中，所寻求的是性能(在运行时间的意义上使用)和召回率(修剪后找到的真实匹配的百分比)的适当折衷。虽然精度不会显式地出现在权衡中，但它可以间接出现。这是因为较低的精度潜在地转化为更多的结果需要处理，即修剪不充分。有鉴于此，用一个合适的量化修剪的指标来代替“性能”是有吸引力的。最终影响性能的是结果列表的大小。</p><p id="c60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">音标键</strong></p><p id="fb31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从字符串派生的音标试图保留字符串的发音。想想<em class="lv">约瑟夫</em>和<em class="lv">约瑟夫</em>。它们听起来一样。所以它们应该有相同的音标。</p><p id="8638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们寻找发音相似的字符串时，拼音键有助于缩减搜索空间。我们不是寻找发音相似的字符串，而是查找所有其语音关键字与查询字符串相同的字符串。</p><p id="59a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成语音键的两种流行方法是Soundex和Metaphone。变音被广泛认为更好。所以我们这里就重点说一下。</p><p id="9109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是几对具有相同变音键的名字。这摘自[1]。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="232a" class="mb mc it lx b gy md me l mf mg">Steven, Stephen → STFN, John, Jon → JN, Cathy, Kathy → K0</span></pre><p id="c974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明，在我们的用例中，通过变音键进行修剪将会工作得很好。寻找发音相似的名字。</p><p id="0351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，会有假阳性。例如，<em class="lv"> Jack </em>和<em class="lv"> Jake </em>有相同的变音键，<em class="lv"> JK </em>。这在修剪过程中不必担心，因为过滤掉误报是模糊匹配器的责任。如果假阳性率如此之高以至于修剪无效，这将是一个问题。幸运的是，变音键不是这样的。</p><p id="7ee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，使用合适的语音键可以有效地在字典中找到听起来像输入字符串的名字。但通常这不是我们想要找到的全部。例如，我们还会发现名字中有拼写错误。考虑<em class="lv">Ri</em><strong class="lb iu"><em class="lv">ch</em></strong><em class="lv">ard</em>vs<em class="lv">Ri</em><strong class="lb iu"><em class="lv">HC</em></strong><em class="lv">ard</em>。显然，这些应该是匹配的，因为这种差异可以用一种常见的错误来解释:相邻字母的错位。然而，他们不健全的名字。事实上，我们看到它们的变音键是不同的，分别是RXRT和RKRT。这两个关键字的不同之处在于两个名称中粗体区域的发音方式不同。</p><p id="c716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，即使在我们的例子中，使用语音键进行修剪也是不够的。</p><p id="38c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">哈希键</strong></p><p id="536b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从讨论到这一点，我们可以抽象出剪枝问题如下。在给定的论域(在我们的例子中，是人名)上定义一个散列函数，它具有以下属性:</p><ol class=""><li id="b197" class="mh mi it lb b lc ld lf lg li mj lm mk lq ml lu mm mn mo mp bi translated"><em class="lv">应该充分修剪搜索空间</em>。虽然这是一个非正式的描述，但很容易根据经验对其进行评估或将其形式化。</li><li id="ea60" class="mh mi it lb b lc mq lf mr li ms lm mt lq mu lu mm mn mo mp bi translated"><em class="lv">它应该有接近100%的召回率</em>。也就是说，被视为匹配的两个名字字符串几乎肯定应该具有相同的哈希值。</li></ol><p id="89b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语音键是特殊类型的散列函数。更一般地扩展到散列函数，打开了大门。</p><p id="a098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，这一切都很好，但我们仍然必须弄清楚，作为一个特殊的情况，如何在名字字符串中出现换位错误的情况下进行修剪。</p><p id="625f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们接下来讨论的技术在这方面提供了诱人的可能性。</p><p id="e8fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">区分位置哈希</strong></p><p id="db0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑我们的特殊要求。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5079" class="mb mc it lx b gy md me l mf mg">Two first-name strings deemed a match should almost certainly have the same hash value.</span></pre><p id="5255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在考虑以下内容，位置敏感散列的定义性断言</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="a0b2" class="mb mc it lx b gy md me l mf mg">Map items to hashes so that similar items have the same hash value with high probability.</span></pre><p id="3931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有匹配的吗？(双关。)是的。如下所述。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8e5c" class="mb mc it lx b gy md me l mf mg">Two first-name strings deemed a match ⇐⇒ similar items<br/>almost certainly ⇐⇒ high probability</span></pre><p id="cd12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了。我们仍然没有解决我们问题的具体方案。再坚持一会儿。</p><p id="18c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">位采样</strong></p><p id="a4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑长度为<em class="lv"> n </em>的二元向量。选择特定尺寸<em class="lv"> i </em>。对于一个<em class="lv"> n </em>位向量<strong class="lb iu"> x </strong>，定义h _<em class="lv">I</em>(<strong class="lb iu">x</strong>)=<em class="lv">x</em>_ I，这个hash函数只是简单的选出<strong class="lb iu"> x </strong>的<em class="lv"> i </em>位。</p><p id="9303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一族哈希函数<em class="lv"> h </em> _1、…、<em class="lv"> h </em> _ <em class="lv"> n </em>有一个有趣的(也是吸引人的)性质，对于任意两个二元向量<strong class="lb iu"> x </strong>和<strong class="lb iu"> y </strong>，如果我们选择一个随机哈希函数<em class="lv"> h </em> _i，越相似的<strong class="lb iu"> x </strong>和<strong class="lb iu"> y </strong>越有可能是<em class="lv"> h 【T43</em></p><p id="7008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，那不透明。我们来分解一下。首先，我们在这里如何定义相似性？我们将它定义为两个向量具有相同值的<em class="lv"> n </em>位的分数。因此<strong class="lb iu"> 110 </strong> 1和<strong class="lb iu"> 110 </strong> 0具有相似性，因为两个向量中的4位中的3位具有相同的值。(这些位用粗体标识。)</p><p id="91b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们用极端的例子来建立直觉。考虑<strong class="lb iu"> x </strong> = <strong class="lb iu"> y </strong> =1001。显然对于1到4中的每一个<em class="lv"> i </em>来说<em class="lv"> h </em> _ <em class="lv"> i </em> ( <strong class="lb iu"> x </strong>)等于<em class="lv">h</em>_<em class="lv">I</em>(<strong class="lb iu">y</strong>)。这只是说，在两个向量相同的极端情况下，该属性将保持“极端”，这意味着无论选择哪个哈希函数，它在两个向量中的值都必然相同。</p><p id="427b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们可以看到，当<strong class="lb iu"> x </strong>和<strong class="lb iu"> y </strong>相距最大时，例如1001对0110，每个散列函数必然具有不同的值。</p><p id="d9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在考虑“中间某处”的情况。为了便于说明，以这样的方式排列尺寸，即<strong class="lb iu"> x </strong>和<strong class="lb iu"> y </strong>的第一个<em class="lv"> d </em>位是相同的，其余的是不同的。下面是一个例子</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="9206" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">1011111</strong><em class="lv">01001<br/></em><strong class="lx iu">1011111</strong><em class="lv">10110</em></span></pre><p id="b4cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里<em class="lv"> n </em> = 12，<em class="lv"> d </em> = 7，相同的位用粗体表示，不同的用斜体表示。</p><p id="12f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从1到12中随机选择尺寸<em class="lv"> i </em>。<em class="lv"> x </em> _ <em class="lv"> i </em>和<em class="lv"> y </em> _ <em class="lv"> i </em>具有相同值的概率为<em class="lv"> d </em> / <em class="lv"> n </em>，这正好是<strong class="lb iu"> x </strong>和<strong class="lb iu"> y </strong>的相似度值(我们已经定义过了)。</p><p id="b9d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">使用比特采样来修剪搜索空间</strong></p><p id="c028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了目前为止我们对比特采样的了解，让我们用它来修剪搜索空间。</p><p id="52b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们想要更精确地定义我们的修剪问题。设<em class="lv"> D </em>表示一组长度为<em class="lv"> n </em>的二元向量，<strong class="lb iu"> x </strong>表示一个同类的单一向量。我们希望使用上一节定义的相似性函数，在<em class="lv"> D </em>中高效地找到与<strong class="lb iu"> x </strong>最相似的向量。</p><p id="eba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上一节的内容建议使用以下方式使用位采样来定义散列键。这里<strong class="lb iu"> y </strong>是一个长度为n的二元向量。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5e93" class="mb mc it lx b gy md me l mf mg">key(<strong class="lx iu">y</strong>)<br/>  Sample i uniformly at random from {1, 2, …, n}<br/>  return (i,y_i)</span></pre><p id="8269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe mv mw mx lx b">key(.)</code>是一个随机程序。在每个调用<code class="fe mv mw mx lx b">key(.)</code>中，随机选取其位要被采样的维度。</p><p id="80a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种键控机制，我们将D中的每个向量<strong class="lb iu"> d </strong>散列到它的键<code class="fe mv mw mx lx b">key(<strong class="lb iu">d</strong>)</code>。</p><p id="87af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们准备在任何新的输入向量<strong class="lb iu"> x </strong>的<em class="lv"> D </em>中寻找邻居。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="bc7e" class="mb mc it lx b gy md me l mf mg">neighbors(<strong class="lx iu">x</strong>)<br/>  key_of_x = key(x)<br/>  Return all vectors in D whose key is key_of_x</span></pre><p id="533e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这种方法效果如何？让我们来做一个例子。说<em class="lv"> n </em> = 2而<em class="lv"> D </em>包含11。考虑调用<code class="fe mv mw mx lx b">neighbors(11)</code>。它会找到11吗？不一定。为什么不呢？因为D中的11是索引在键(<em class="lv"> i </em>，1)下的。随后，在调用<code class="fe mv mw mx lx b">neighbors(11)</code>中，在键(<em class="lv"> j </em>，1)下查找。鉴于<em class="lv"> i </em>和j都在{1，2}中，由于密钥(.)功能。</strong></p><p id="54ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，那可不好。我们能做什么？</p><p id="329a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查找期间的多个键</strong></p><p id="8224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在查找过程中，我们可以生成多个键，并聚合所有与它们相关的向量。这潜在地增加了期望的向量在返回的结果集中的可能性。我们付出的一个代价是在查找过程中花费更多的时间。我们付出的一个潜在的更大代价是，结果的数量可能会大幅增加。在这种情况下，我们可能需要花更多的时间对它们进行后处理。这两点以后再详细讲。</p><p id="4c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个明智的方法。定义一个函数<em class="lv"> multi_key </em> ( <strong class="lb iu"> y </strong>，<em class="lv"> m </em>)，该函数调用<em class="lv">key</em>(<strong class="lb iu">y</strong>)<em class="lv">m</em>次，收集查找每个key得到的向量，并将其作为一个集合返回。</p><p id="ec0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<em class="lv">键</em> ( <strong class="lb iu"> y </strong>)索引矢量。使用<em class="lv"> multi_key </em> ( <strong class="lb iu"> y </strong>，<em class="lv"> m </em>)查找其邻居。</p><p id="c356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能期望这种方法有多有效？m<em class="lv">m</em>应该是什么？让我们从<em class="lv">回忆</em>的角度来看这个问题，我们将它定义为一个索引向量在后续查找自身的结果集中的概率。凭直觉，回忆应该随着<em class="lv"> m </em>的增加而增加。(查找时间也是如此。)</p><p id="3a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何固定的<em class="lv"> n </em>，我们可以很容易地将召回量化为m的函数。让<em class="lv"> i </em>表示索引向量<strong class="lb iu"> y </strong>时使用的维度。设<em class="lv"> j </em>表示在任意一个后续调用<em class="lv">键</em> ( <strong class="lb iu"> y </strong>)期间采样的尺寸。<em class="lv"> i </em>和<em class="lv"> j </em>不同的概率是(<em class="lv"> n </em> -1)/ <em class="lv"> n </em>，因为<em class="lv"> j </em>有<em class="lv"> n </em>个可能的值，除了其中一个之外，其余的都与<em class="lv"> i </em>不同。尝试查找<strong class="lb iu"> y </strong>时，调用<em class="lv">键</em> ( <strong class="lb iu"> y </strong>)的<em class="lv"> m </em>中的每个<em class="lv"> j </em>不同的概率为(<em class="lv">n</em>-1)/<em class="lv">n</em>)^<em class="lv">m</em>)。至少有一个<em class="lv"> j </em>等于<em class="lv"> i </em>的概率，即回忆，是这样的</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="2bfb" class="mb mc it lx b gy md me l mf mg">1 — ((<em class="lv">n</em>-1)/<em class="lv">n</em>)^<em class="lv">m</em>                                                 (R1)</span></pre><p id="3fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<em class="lv"> n </em> = 20，让我们计算各种<em class="lv"> m </em>使用(R1)的召回。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f13c" class="mb mc it lx b gy md me l mf mg">m       1      2      10   20    50     100<br/>recall 0.05  0.0975  0.4  0.64  0.92   0.994</span></pre><p id="4e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明，为了实现接近100%的召回率，m 需要比n <em class="lv">大得多。这是可信的。带有替换的随机采样本质上有点低效，因为同一个密钥可能被采样多次。好吧，与其用<em class="lv"> multi_key </em> ( <strong class="lb iu"> y </strong>，<em class="lv"> m </em>)，不如干脆把20个键都一一列举出来。</em></p><p id="91ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查找<em class="lv"> n个</em>键</strong></p><p id="3c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们知道了查找n个<em class="lv">键就足以获得100%的回忆。</em></p><p id="8587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样够好了吗？没那么快。我们还需要考虑结果集的大小，因为当查找这么多键时，结果集可能会很大。</p><p id="1ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分析下面的场景。假设<em class="lv"> D </em>包含1^ <em class="lv"> n </em>，我们随后对其进行查找。考虑一个向量<strong class="lb iu"> y </strong>在<em class="lv"> D </em>中，其中有<em class="lv"> d </em>个。现在考虑neighbors(1^ <em class="lv"> n </em>的结果集。在枚举1^ <em class="lv"> n </em>的邻居时，我们将查找，对于1中的每个<em class="lv"> i </em>到<em class="lv"> n </em>，索引在值1下的<em class="lv"> D </em>中的向量。然后把它们都结合起来。</p><p id="53e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<strong class="lb iu"> y </strong>被索引到<em class="lv"> i </em>上，使得<em class="lv"> y </em> _ <em class="lv"> i </em>为1，则它将位于neighbors(1^ <em class="lv"> n </em>。这种情况发生的概率是<em class="lv"> d </em> / <em class="lv"> n </em>。这是因为在<em class="lv"> n </em>中有<em class="lv"> d </em>个值为1的位，索引从<em class="lv"> n </em>个位中随机选择一个位进行索引。</p><p id="8730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说<em class="lv"> D </em>包含<em class="lv"> m </em> _ <em class="lv"> d </em>这样的向量。我们可以期待他们中的<em class="lv">m</em>_<em class="lv">d</em>*<em class="lv">d</em>/<em class="lv">n</em>进入<em class="lv">邻居</em> (1^ <em class="lv"> n </em>)的结果集。</p><p id="4365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在假设<em class="lv"> d </em>很小，比如说4，而<em class="lv"> n </em>大得多，比如说20。此外，假设<em class="lv"> D </em>包含许多包含<em class="lv"> d </em>个向量的向量，即<em class="lv"> m </em> _ <em class="lv"> d </em>很大。这似乎是合理的，因为宇宙中有“20选4”这样的向量。由于<em class="lv"> d </em>很小，相对于1^ <em class="lv"> n </em>来说，可以合理地预期大部分(如果不是全部)都是假阳性。因为m<em class="lv">m</em>_<em class="lv">d</em>很大，所以很多这样的误报会出现在结果集中。</p><p id="8586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们上面的分析适用于1^ <em class="lv"> n </em>。可以概括一下吗？让我们用任何一个<em class="lv"> n </em>位向量<strong class="lb iu"> x </strong>来代替1^ <em class="lv"> n </em>。设D中的<strong class="lb iu"> y </strong>与<strong class="lb iu"> x </strong>有共同的<em class="lv"> d </em>位，即相似度<em class="lv"> S </em> ( <strong class="lb iu"> x </strong>，<strong class="lb iu"> y </strong>)等于<em class="lv"> d </em> / <em class="lv"> n </em>。和以前一样，<strong class="lb iu"> y </strong>到达<em class="lv"> neigbors </em> ( <strong class="lb iu"> x </strong>)结果集的概率是<em class="lv"> d </em> / <em class="lv"> n </em>。所以如果有<em class="lv"> m </em> _ <em class="lv"> d </em>这样的向量<strong class="lb iu"> y </strong>，我们可以像之前一样，期待<em class="lv">m</em>_<em class="lv">d</em>*<em class="lv">d</em>/<em class="lv">n</em>能够到达结果集。由于<em class="lv"> d </em>小，这些相对于<strong class="lb iu"> x </strong>很可能是误报。如果<em class="lv"> m </em> _ <em class="lv"> d </em>很大，那么结果集中就有很多。</p><p id="dd59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，当<em class="lv"> D </em>包含许多与<strong class="lb iu"> x </strong>有轻微相似性的向量时，在任意向量<strong class="lb iu"> x </strong>上查找所有<em class="lv"> n </em>维确实可以返回许多结果。这是一个问题，当这些结果大部分是假阳性时，这似乎是合理的。</p><p id="6bdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们还能尝试什么呢？</p><p id="08df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">无替换样品</strong></p><p id="657c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样，让我们对一个维度进行m次采样。与之前不同，让我们在不更换的情况下对<em class="lv">进行采样。这相当于从<em class="lv"> n </em>个维度中随机选择一个<em class="lv"> m </em>维度的子集。</em></p><p id="70f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这能给我们带来什么？更加灵活。将<em class="lv"> m </em>设置为<em class="lv"> n </em>给出了“在所有尺寸上查找”的情况。选择小于n的m让我们在返回结果集的大小上权衡召回。</p><p id="26fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">回忆作为<em class="lv">m</em>T3】的函数</strong></p><p id="3097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一个<em class="lv"> D </em>中的<strong class="lb iu"> y </strong>，我们在它被索引后的某个时间查找它。查找到的结果集包含<strong class="lb iu"> y </strong>的概率是多少？这是<em class="lv"> m </em> / <em class="lv"> n </em>，在查找过程中随机选择的<em class="lv"> m </em>维度包括<strong class="lb iu"> y </strong>被索引的维度的概率。</p><p id="5304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉我们什么？召回率随着<em class="lv"> m </em>线性下降。当然，你只会想要降低<em class="lv"> m </em>，也就是说，付出减少召回的代价，除非你有所收获，特别是搜索结果的数量也大幅下降。接下来我们来分析一下这个。</p><p id="b06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果集的预期大小</strong></p><p id="a1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个场景，我们将重复上一节所做的分析。为了保持独立，我们将从头开始拼写所有内容。与先前分析不同的部分用粗体表示。</p><p id="5de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<em class="lv"> D </em>包含1^ <em class="lv"> n </em>，我们随后对其进行查找。考虑一个向量<strong class="lb iu"> y </strong>在<em class="lv"> D </em>中，其中有<em class="lv"> d </em>个1。现在考虑neighbors(1^ <em class="lv"> n </em>的结果集。在枚举1^ <em class="lv"> n </em>的邻居时，我们将查找从<em class="lv"> n </em>位中随机采样(替换)的<em class="lv"> m </em>位中的每一位的<em class="lv"> </em> <strong class="lb iu">，在采样位的值1下索引<em class="lv"> D </em>中的向量。然后把它们都结合起来。</strong></p><p id="387d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<strong class="lb iu"> y </strong>被索引到位<em class="lv"> i </em>上，使得<em class="lv"> y </em> _ <em class="lv"> i </em>是1 <strong class="lb iu">并且<em class="lv"> i </em>是在neighbors(1^ <em class="lv"> n </em> ) </strong>中查找期间采样的<em class="lv"> m </em>位之一，<strong class="lb iu"> y </strong>将在<em class="lv">邻居</em>(t67)中<em class="lv"> y </em> _ <em class="lv"> i </em>为1的概率为<em class="lv"> d </em> / <em class="lv"> n </em>。<strong class="lb iu"> <em class="lv"> i </em>是在neighbors(1^ <em class="lv"> n </em>中查找期间采样的<em class="lv"> m </em>位之一的概率是<em class="lv"> m </em> / <em class="lv"> n </em>。所以组合概率是(<em class="lv">d</em>/<em class="lv">n</em>)*(<em class="lv">m</em>/<em class="lv">n</em>)</strong><em class="lv">。</em></p><p id="3351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">综上所述，通过在计算<em class="lv">邻居</em> (1^ <em class="lv"> n </em>)所涉及的查找过程中对<em class="lv"> m </em>位进行替换采样，召回1^ <em class="lv"> n </em>的概率为<em class="lv"> m </em> / <em class="lv"> n </em>，结果集的预期大小为<em class="lv">m</em>_<em class="lv">d</em>*(<em class="lv">d</em>/<em class="lv">n</em>)*(<em class="lv"/></p><p id="c83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多键下的索引</strong></p><p id="6e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们只在查找过程中使用多个键。如果我们在索引期间也使用这种机制会怎么样？更具体地，对于在1和<em class="lv"> n </em>之间的整数值参数<em class="lv"> m </em> I，当索引一个<strong class="lb iu"> x </strong>时，我们采样<em class="lv"> m </em> I比特，替换从1到<em class="lv"> n </em>并且在每个比特下索引<strong class="lb iu"> x </strong>。</p><p id="137f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用与之前相同的查找机制，召回概率将随着<em class="lv"> m </em> I的增加而增加。结果集的预期大小也是如此。</p><p id="78f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">收紧查找</strong></p><p id="325b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了试图抵消随着<em class="lv"> m </em> I的增加而增加的结果集的预期大小，我们可以引入一个参数，称之为<em class="lv"> k </em> L，以使查找条件更加严格。</p><p id="2ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，如果任何特定于位的查找找到一个向量，它就包含在结果集中。有了参数<em class="lv"> k </em> L，只有在特定于位的查找中至少有<em class="lv"> k </em> L找到它时，我们才能将它包含在结果集中。</p><p id="3ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，这确实使我们的聚合逻辑变得复杂了，现在需要包括一些过滤。我们不能只是累加我们找到的所有向量，一路去重复它们。我们还必须确保找到的向量至少在特定于位的结果集中。</p><p id="0215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">撇开聚合和过滤逻辑的复杂性不谈，直觉上，这种机制似乎有可能让我们对权衡进行更多的控制。</p><p id="3811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们就说到这里。现在用<em class="lv"> n </em>、<em class="lv"> d </em>、<em class="lv"> m </em>、<em class="lv"> m </em> I、<em class="lv"> k </em> L来参数化的这种情况，量化分析起来令人望而生畏。</p><p id="2e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">从比特采样到多项式采样</strong></p><p id="0060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">位采样机制扩展到定义为<em class="lv">D</em>1 X<em class="lv">D</em>2 X…X<em class="lv">Dn</em>的论域。这里，每个“尺寸”i 都有一组有限的相关值。不同的维度可以有不同的值集。统计学家和数据科学家可能会将此视为定义在n个分类变量集合上的空间，每个变量都有自己的一组值。</p><p id="c4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们把这一段放在这篇文章中是因为它的启发价值。它为多项式空间上基于LSH的索引和查找提供了第二种机制，一种直接的机制。也可以使用比特采样机制；它首先需要将这个宇宙转变成一个二元宇宙。虽然有一种自然的方法可以使用所谓的一键编码将多项式空间转换为二进制空间，但尚不清楚基于两种不同编码(一种直接编码，一种二进制编码)的LSH的精度和召回率如何比较。</p><p id="60a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">延伸阅读</strong></p><ol class=""><li id="a6be" class="mh mi it lb b lc ld lf lg li mj lm mk lq ml lu mm mn mo mp bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/fuzzy-string-matching-algorithms-e0d483c2a9ea">模糊字符串匹配算法。Levenshtein，语音学|作者Arun ja gota | 2021年12月|走向数据科学</a></li><li id="58e3" class="mh mi it lb b lc mq lf mr li ms lm mt lq mu lu mm mn mo mp bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Metaphone" rel="noopener ugc nofollow" target="_blank">变音——维基百科</a></li><li id="0541" class="mh mi it lb b lc mq lf mr li ms lm mt lq mu lu mm mn mo mp bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein distance —维基百科</a></li></ol></div></div>    
</body>
</html>