# 1:长度(A)被认为是有害的——或者如何使 Julia 代码“通用安全”

> 原文：<https://towardsdatascience.com/1-length-a-considered-harmful-or-how-to-make-julia-code-generic-safe-ac7b39cfc2f0>

![](img/dbb2e4be904320e5cb939e44d373bf47.png)

照片由[埃里克·维特索](https://unsplash.com/@ewitsoe?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

## Julia 允许在相当抽象和通用的层次上编写代码，因此提供了强大的表达能力。然而，这种优势也给程序员带来了特殊的挑战。这篇文章展示了如何克服它们。

Julia 的几个语言概念，如用户可扩展的类型系统、参数类型、可选的类型声明和多重分派，使得编写非常通用的代码成为可能，并且可以应用于许多情况——甚至代码的作者也经常无法预料的情况。这些可能性也是 Julia 高度可组合性的支柱。

这是一个明显的优势，也是很多人喜欢 Julia 胜过其他编程语言的原因之一。但是这是有代价的，因为它扩大了可能出错的范围。所以在编写这样的代码时必须特别小心。

如果您编写的 Julia 代码只是供自己使用，因此能够控制传递的参数以及代码如何与其他包组合，那么您就不需要太担心这些问题。但是如果你写的代码被其他人使用(特别是公开可用的包，比如 Julia 注册表中的包)，那么你需要记住这些方面。

我将给出三个常见的例子来展示这些挑战是怎样的，以及如何克服它们。这些信息中的大部分都可以在 Julia 文档中找到，但是我怀疑该语言的许多新手是否读过它们，因为在许多其他编程语言中，这些情况并不存在。那么，如果你不知道有一个问题，你为什么要去寻找答案呢？此外，最近关于话语的讨论表明，即使是经验丰富的 Julia 程序员有时也会落入这些陷阱。

# 数组

让我们从 Julia 中最常见的数据结构之一开始:`Array` s .(一维)数组乍一看与其他编程语言中的数组非常相似(可能除了索引是基于 1 的)。

你可以在`Array`上使用一堆预定义的函数，例如`length(A)`给你数组`A`中包含的元素个数。这提供了迭代数组并以如下方式打印每个元素的可能性:

```
for i in 1:length(A)
    println(A[i])
end
```

您可以找到另一种方法，使用函数`eachindex(A)`返回`A`的迭代器:

```
for i in eachindex(A)
    println(A[i])
end
```

第二个版本看起来更优雅，但除此之外，两个版本似乎可以互换。…这就是问题开始的地方。

事实上，如果你使用(具体的)类型`Array`的数组，这两种变体只有可以互换。`Array`是`AbstractArray`的一个亚型。如果你允许`A`是`AbstractArray`的任何其他子类型，你可能会遇到麻烦。`AbstractArray`不保证第一个元素在索引 1 处，也不保证最后一个元素在索引`length(A)`处。

> 因此`1:length(A)`必须被视为有害。

如果您使用`OffsetArrays`(另一个`AbstractArray`的子类型)，您可以自由定义索引边界。以下语句创建一个包含 11 个(随机)元素的数组，索引从-5 到 5:

```
B = OffsetArray(rand(11), -5:5)*--> 11-element OffsetArray(::Vector{Float64}, -5:5) 
    with eltype Float64 with indices -5:5*
```

如果您应用`1:length(B)`-变量进行索引，将会出现错误，因为在这种情况下将使用索引值> 5。除此之外，索引不会从第一个元素开始，而是从第七个元素开始。

另一方面，`eachindex(B)` -variant 是安全的，因为它保证你得到一个迭代器，覆盖从第一个到最后一个的所有元素，不管数据结构使用哪种索引方式。

如果您不需要索引值(如示例中的情况)，下面的变体也是安全的(因为它更简洁，所以是首选的):

```
for a in A
    println(a)
end
```

# 用线串

另一种常见的数据结构是`String` s，在 Julia 中被定义为一系列`Char` s。乍一看,`String` s 可以像字符数组一样使用(类似于 Java 或 C)。所以要访问字符串`s = "Hello"`中的第二个字符，你可以写`c = s[2]`。该操作后，变量`c`包含字母“e”。

您可以使用`s[3]`来访问`s`中“e”后面的字符(本例中为“l”)。

只要*只使用* ASCII 字符，这就可以工作。但是在 Julia 中，`Char`可能是任何 Unicode 字符(UTF 8 编码)。这些字符可能需要多于一个字节的存储空间(与纯 ASCII 字符相反)。

对于 Unicode 字符，上面的例子不再适用:

```
u = “α = alpha”    # string with a Unicode-characteru[1]     --> 'α': Unicode U+03B1 (category Ll: Letter, lowercase)u[2]     --> **ERROR:** StringIndexError: invalid index [2], 
             valid nearby indices [1]=>'α', [3]=>' '
```

`u`(‘α’)中的第一个字母是一个(2 字节)Unicode 字符。因此`u[2]`不是可打印字符(而是第一个字符的一部分)。

要安全地索引任意 Unicode 字符串，您需要以下函数:

*   `firstindex(u)`—`u`的最小指数
*   `lastindex(u)`—`u`的最大指数
*   `nextind(u, i)` —索引`i`之后的下一个有效索引
*   `prevind(u, i)` —索引`i`之前的前一个有效索引

因此，要获得`u`(‘α’)中的第一个字符，然后是‘α’后面的下一个字符，您应该使用:

```
i = firstindex(u)   --> 1
u[i]                --> 'α': Unicode U+03B1 
                        (category Ll: Letter, lowercase)i = nextind(u,i)    --> 3
u[i]                --> ' ': ASCII/Unicode U+0020 
                        (category Zs: Separator, space)
```

为了安全地迭代一个字符串的所有元素，下面的表达式完成了这项工作(只有当您想要在一个字符串内来回移动时，才需要上述函数):

```
for c in u
    println(c)
end
```

# 类型声明

到目前为止，我们看到的两个例子处理的是您应该在适当的抽象级别上访问数据结构的情况。也就是说，对数据结构的访问不应该依赖于对其实现的知识或(更糟的)假设。

下一个例子提出了另一个主题:关于类型声明的使用。

在 Julia 中，类型声明是可选的，但它们有助于编译器生成最佳代码。编译器至少需要知道输入参数的具体类型，以便为算法生成高效的代码。基于这个起点，它可以推断出大多数情况下所有其他变量的类型。

另一方面，您希望您的代码尽可能通用，以使其适用于广泛的情况。这两个要求相互冲突。

让我们看一个例子来更清楚地说明这种情况。二维空间中的点的类型定义可能如下所示:

```
struct Point
    x
    y
end
```

这是这种定义的最一般的方式。但是通常我们希望在我们的`Point`上定义依赖于一些算术函数的函数，如下例所示:

```
function distance(a::Point, b::Point)
    sqrt((b.x - a.x)^2 + (b.y - a.y)^2)
end
```

为了保证这些算术函数可用于`x`和`y`，我们必须将这些字段声明为`Number`类型。这是最通用(即最不具体)的声明:

```
struct Point
    x :: Number
    y :: Number
end
```

所以保持代码尽可能通用的需求通过`Point`的定义得到了满足。但是对于编译器来说并不是真正有用的。

当创建`Point` s 的实例时，我们可以使用`Number`的任何子类型，如`Int8`、`Int64`、`Int128`、`Float16`、`Float32`、`Complex{Float32}`、`Rational{Int64}`等。例如，如果我们想要用我们的`Point`类型在屏幕上表示像素，那么`x`和`y`的`Int32`值可能适合这个任务。为了对一些数学应用的点进行建模，我们可以使用`Float64`来表示真实值。对于这两个用例，多边形(表示为点的向量)的定义是:

```
pixel_poly = Vector{Point}()real_poly  = Vector{Point}()
```

两个表达式是相同的。这意味着编译器不知道在每种情况下需要什么样的内存表示，因此无法为该特定类型生成优化的代码。相反，它必须提供一个非常通用的结构，能够存储上述每个子类型。这样效率不高。

解决这一冲突的方法是使用(受约束的)参数类型，如下所示:

```
struct Point{T <: Number}
    x :: T
    y :: T
end
```

当创建一个`Point`的实例时，使用参数类型`T`仍然给了我们使用任何具体类型`T`的自由。声明`<: Number`将可能的类型限制为`Number`的子类型(同上)。

但是，如果我们需要一个特定的实例，我们现在也可以指定它的类型，并将多边形的两个定义写成:

```
pixel_poly = Vector{Point{Int32}}()real_poly  = Vector{Point{Float64}}()
```

使用(受约束的)参数类型代替抽象类型满足了我们的两个要求:类型的广泛适用性和能够通知编译器在特定用例中需要的具体类型。

# 结论

我们已经看到了编写泛型 Julia 代码的一些最常见的挑战，以及如何使其安全。

前两个例子表明，您必须理解数据类型提供的抽象，并使用与该抽象级别匹配的函数来访问它:

*   `AbstractArray`表示(在一维情况下)可以使用索引访问的元素序列。但是它没有断言最小和最大索引。
    只有具体子类型`Array`保证第一个索引为 1，最后一个索引为`length(A)`。
*   `String`表示一系列的`Char`,但是它没有断言它们的大小相等。
    只有当您将应用程序限制为 ASCII 字符时，您才可以假定大小相等(一个字节)。

在所有这些情况下，Julia 都提供了一组丰富的函数来以一种适当(并且安全)的方式处理数据结构。

最后一个示例演示了如何将类型声明与参数类型结合使用，以尽可能保持代码的通用性，同时为编译器提供足够的信息来生成最佳代码。

当然，这些并不是你必须小心这些问题的唯一情况。但我认为这些例子很有代表性，希望我能提高对这些挑战的认识。