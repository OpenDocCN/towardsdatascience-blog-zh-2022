<html>
<head>
<title>Replace Python Lists and Make Your Code Orders of Magnitude Faster!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">替换Python列表，让你的代码快几个数量级！</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/replace-python-lists-and-make-your-code-orders-of-magnitude-faster-702c08fb397b#2022-01-05">https://towardsdatascience.com/replace-python-lists-and-make-your-code-orders-of-magnitude-faster-702c08fb397b#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="44b3" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">替换Python列表，让你的代码快几个数量级！</h1></div><div class=""><h2 id="802f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">没有花哨的库，没有复杂的工程，只有一种数据结构——哈希表。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/13a7450414097a4c829c7f0ec8daad2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S94vUfEXjimBZQRI.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fe65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个初学编程的人都喜欢for-loops，因为它们很实用，也很容易理解。同样，大家都爱数组。然而，更多的时候，我们开始在任何事情上使用数组，而不去考虑它。我们上了数据结构的课，但在实践所学内容时，我们做得不够。直到最近我才发现自己掉进了这个陷阱。我正在处理一个编程任务，试图挑战自己写出高效快速的代码。</p><p id="c779" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以做得更好！</p><p id="da8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将简要介绍Python中的字典和集合。我们将(重新)发现这些数据结构在我们的代码中使数据操作超快的能力。我们将了解哈希表如何导致巨大的算法性能改进。</p><p id="1126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但首先我们需要回顾一些概念。<br/>是时候回归基础了！</p><h1 id="f0ea" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">回到基础:散列表</h1><p id="d5d2" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">编程语言中的数据结构是计算机科学中抽象数据结构的实现。Python字典和集合基本上是一个<em class="mr">哈希表</em>。哈希表是一种抽象数据结构的实现，称为<em class="mr">关联数组</em>，字典<em class="mr">或映射<em class="mr"/>。简单地说，哈希表是从键到值的映射。给定一个键，可以查询数据结构以获得相应的值。</em></p><p id="7824" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现这一点的简单方法是使用一个<em class="mr">直接地址表</em>或一个数组。<br/>所以对于一个键<em class="mr"> 1 </em>，我们将把值存储在数组的索引位置<em class="mr"> 1 </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/2492fd91337f9efdd944f84d19afc70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0A2BRCoO9eQ43jTK.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。<em class="mt"> </em>用数组直接寻址。<br/>每个键简单地映射到数组中的下一个槽。</p></figure><p id="2e4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这种方法有一个问题。如果有很多键，数组的大小会很大。这使得按内存方式存储变得不可行。</p><p id="d1a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对此的解决方案是使用一个<em class="mr">散列函数。</em>哈希函数负责将键映射到哈希表中存储的值。你给它传递一个键，它就抛出一个叫做<em class="mr">哈希值</em>的值。哈希值确定哈希表中存储对应于该键的值的位置。换句话说，它是一个指数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/909b3ce2f3c1fa538147c8cc56b280d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LXMVpezor2Pl3nHE.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。使用哈希函数和哈希表。</p></figure><p id="e017" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，哈希表的大小将小于直接地址表的大小。这意味着哈希表在内存方面是可行的。然而，这也意味着两个键可以映射到相同的值。<br/>这被称为<em class="mr">哈希冲突</em>，当哈希函数在给定两个不同键的情况下输出相同的值时就会发生。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08abe7d7b6451f051bf1a656433f2480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CUrcldoPl58A2HxE.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。通过用链表链接来解决散列冲突。</p></figure><p id="5763" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，如果两个键散列为相同的值，我们可以将值存储在一个链表中(见上图)。任何随后的冲突只会导致该值被追加到链表中。这被称为通过<em class="mr">链接</em>的冲突解决。</p><p id="d569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在你可以想象一下，如果所有的键都被散列为相同的值，那么它们都将被添加到链表中，这意味着性能不会比使用链表更好！</p><p id="aec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果哈希表太满，就会调整其大小。该阈值被称为<em class="mr">负载系数</em>，并确定已占用插槽与可用插槽的比率。通常，当值超过<code class="fe mv mw mx my b">3/4</code>时，哈希表的大小就会改变。这确保了链表不会太满，并保证了承诺的平均性能。最后，散列函数通常以这样一种方式被选择，即它们跨槽均匀地分布密钥。这意味着碰撞的几率很小。</p><p id="dee9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！现在让我们看看一些大O符号。</p><h1 id="7ecd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">回到基础:O(1)与O(n)</h1><p id="a256" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在数组中搜索元素的平均时间复杂度为<code class="fe mv mw mx my b">O(n)</code>,因为我们需要线性遍历列表来找到元素。<br/>列表越大，搜索元素所需的时间越长。你可以想象这是一排人站在那里，从最左边的人开始，问他是否是你要找的人。<br/>如果不是，你问旁边的人，以此类推。你可以想象，如果有1000个人对10个人，找到那个人需要更长的时间。</p><p id="f08c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是对于哈希表，搜索的平均时间复杂度是<code class="fe mv mw mx my b">O(1)</code>——它是常数。不管你存储的元素数量是多少，是100万还是10个，找到一个元素总是需要一个固定的时间单位。换句话说，对于所有大小的输入，它都是快速的。<br/>你可以想象一群人站着，多一个人是你的帮手。要找到那个人，你只需要问帮助者，而不是在整个团队中寻找。助手会立即告诉你你感兴趣的人在哪里。</p><p id="c77b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">元素的插入和删除也是<code class="fe mv mw mx my b">O(1)</code>。</p><p id="4777" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mr">点击</em> <a class="ae mz" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mr">此处</em> </a> <em class="mr">获取一份非常好的数据结构和大o的备忘单。</em></p><p id="39de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，现在是编码的时候了，看看哈希表是如何工作的！</p><h1 id="0628" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">代码和基准</h1><p id="a536" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们将模拟以下任务:</p><ul class=""><li id="6581" class="na nb it la b lb lc le lf lh nc ll nd lp ne lt nf ng nh ni bi translated">一个列表<code class="fe mv mw mx my b"><strong class="la iu">L</strong></code>，包含从0到100，000的排序元素。倒数第三个索引有一个随机生成的负值，范围从0到100，000。</li><li id="2222" class="na nb it la b lb nj le nk lh nl ll nm lp nn lt nf ng nh ni bi translated">列表<code class="fe mv mw mx my b"><strong class="la iu">R</strong></code>包含从0到100，000的元素，按排序顺序排列。</li></ul><p id="4474" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务很简单。我们需要找到<code class="fe mv mw mx my b"><strong class="la iu">L</strong></code>中没有出现在<code class="fe mv mw mx my b"><strong class="la iu">R</strong></code>中的值。</p><p id="81ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我知道有更简单的方法来解决这个问题，但出于学习的目的，我们将尝试一种更复杂的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9002" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mv mw mx my b">solution</code>函数是一个解决方案的简单实现。我们对<code class="fe mv mw mx my b"><strong class="la iu">L</strong></code>进行迭代，并检查每个元素是否存在于列表<code class="fe mv mw mx my b"><strong class="la iu">R</strong></code>中。<code class="fe mv mw mx my b">in</code>操作符检查成员资格，类似于执行搜索操作。如果它存在，我们简单地返回负整数。</p><p id="1ac5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该解决方案的耗时约为<strong class="la iu"><em class="mr">60秒</em> </strong>。</p><p id="9750" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们分析<code class="fe mv mw mx my b">solution</code>函数的代码，我们看到时间复杂度是<strong class="la iu"><em class="mr">【o(n^2】</em></strong>。<br/>这是因为对于<strong class="la iu"> <em class="mr"> L </em> </strong>中的每个元素，我们都在遍历<strong class="la iu"> <em class="mr"> R </em> </strong>并检查成员资格。for循环在运行<strong class="la iu"> <em class="mr"> n </em> </strong>步时采用<strong class="la iu"> <em class="mr"> O(n) </em> </strong>。对于每一步，我们都要做O(n)  操作，因为我们需要检查列表<strong class="la iu"> <em class="mr"> R </em> </strong>中的每一个元素，看它是否是我们要找的元素。<br/>这就给出了<strong class="la iu"><em class="mr">【o(n)*o(n)=o(n^2】</em></strong></p><p id="9dae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该操作以二次时间运行。所花费的时间将等于输入大小的平方。你可以想象得到越来越大的数字的平方会产生越来越大的值。</p><p id="5681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们能做些什么来改善这种情况？</p><p id="39e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代替遍历<strong class="la iu"> <em class="mr"> R </em> </strong>来检查成员资格，我们可以将<strong class="la iu"> <em class="mr"> R </em> </strong>实现为散列表而不是数组。因此，检查成员资格的时间复杂度将是<em class="mr"/><strong class="la iu"><em class="mr">(1)</em></strong>。<br/>因此，运算会取<strong class="la iu"><em class="mr">【O(n)* O(1)= O(n)</em></strong>。</p><p id="d59e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是线性的输入大小！因此，所花费的时间将与输入大小成正比(与二次方相反)。</p><p id="214a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">等着看性能提升吧！</p><p id="17b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计时<code class="fe mv mw mx my b">solution2</code>给出0.011秒<strong class="la iu"><em class="mr"/></strong>的经过时间。这是超过5000倍的进步！</p><h1 id="b3d6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论和结束语</h1><p id="bb59" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">总之，你已经了解了使用散列函数和散列表背后的动机。我们简要地看了一下散列表的大O符号，并将其与数组的大O符号进行了比较。更重要的是，我们看到了一个实现，它利用哈希表在创纪录的时间内解决了一个算法问题。</p><p id="57ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为软件工程师，我们必须知道在正确的情况下使用正确的工具，而不是试图在我们遇到的每个场景中使用暴力技术。</p><p id="bf3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住这一点，有几点需要记住。</p><p id="7c76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像所有的事情一样，哈希表并不是万能的。它们并不适合所有的用例。例如，重复元素不能存储在哈希表中。因此，如果您的用例需要，您最好使用数组。同样，哈希表也是不排序的。如果您的用例需要一个排序的数据结构，哈希表不是答案。最后，没有内置函数来查找哈希表中的最大或最小元素。最后，上面提到的时间复杂度是<em class="mr">平均情况</em>。可能会出现“T2”最差情况，这意味着散列表的性能与数组相同。</p><p id="57b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章的内容。下次见。</p><h1 id="8685" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">资源</h1><p id="98d0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">科尔曼·托马斯·H等人，<em class="mr">算法简介</em>(麻省理工学院出版社，2009)。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="3aba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mr">原载于</em><a class="ae mz" href="https://haseebkamal.com/replace-python-lists-and-make-your-code-orders-of-magnitude-faster/" rel="noopener ugc nofollow" target="_blank"><em class="mr">https://haseebkamal.com</em></a><em class="mr">。</em></p></div></div>    
</body>
</html>