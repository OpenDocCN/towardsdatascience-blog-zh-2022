<html>
<head>
<title>Create a user interface for your data-analysis project with Jupyter and autocalc</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jupyter和autocalc为您的数据分析项目创建一个用户界面</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-a-ui-with-ipywidgets-and-autocalc-2ef8ea4cc6c2#2022-01-19">https://towardsdatascience.com/creating-a-ui-with-ipywidgets-and-autocalc-2ef8ea4cc6c2#2022-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="6e80" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用Jupyter和autocalc为您的数据分析项目创建一个用户界面</h1></div><div class=""><h2 id="d13d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">autocalc软件包如何让您自动重新计算变量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ecc9b7c115c7708066a20db0b7c515f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIHn9EWDoiU6hJMxoWYX-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">App预览。作者图片</p></figure><p id="b4ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章的目标读者是使用Python的数据科学家，他们希望用最少的努力为他们的项目创建简单的用户界面，如上图所示。</p><p id="96ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我之前的文章中，我介绍了autocalc包，它可以让你组织内部变量之间的依赖关系。在这篇文章中，我们将更进一步，实现一个更复杂的例子，涉及机器学习，模型拟合和预测。</p><div class="ls lt gp gr lu lv"><a rel="noopener follow" target="_blank" href="/create-a-simple-app-quickly-using-jupyter-notebook-312bdbb9d224"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用Jupyter笔记本快速创建一个简单的应用程序</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">数据科学家和其他希望将Python函数转化为交互式应用程序的人的指南。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">towardsdatascience.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="bff0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">特别是，我们将:</p><ul class=""><li id="d658" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">加载分类数据集，并将其分为训练样本和测试样本</li><li id="0a9b" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">为用户提供微调机器学习模型的超参数(来自scikit-learn的支持向量分类器)</li><li id="1ea9" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">报告测试数据集的混淆矩阵</li><li id="9e52" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">提供一个界面，根据手动输入的参数运行模型。</li></ul><p id="2b5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，这篇文章的目的是展示如何使用Jupyter笔记本和<a class="ae lr" href="https://pypi.org/project/autocalc/" rel="noopener ugc nofollow" target="_blank">自动计算</a>包来实现这一点。我们在这里的目的不是深入机器学习算法的细节，也不是提供任何意义上的“最佳”模型。有兴趣的读者可以参考分类器的<a class="ae lr" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="b4ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在文章的最后你会找到整个笔记本的源代码的链接，它包含了下面所有的代码单元。</p><p id="927e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:如果没有安装autocalc，可以用<code class="fe my mz na nb b">pip install autocalc</code>安装。</p><p id="2331" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以让我们开始吧！</p><h1 id="a179" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">进口</h1><p id="d440" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">像往常一样，我们从导入相关的包开始</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="3405" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">创建主布局</h1><p id="0bcf" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">让我们从设计我们的小应用程序的外观开始。这个想法是在超参数的左边有一列，在右边有两个选项卡:一个用于混淆矩阵，另一个用于预测。注意，我们使用标准的IPywidgets作为我们的接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/945ba503fc895b1fdd50f55db4a26338.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GtPAnL4M2xiZPOfW8gkB3A.png"/></div></div></figure><h1 id="4dbb" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">创建和显示超参数的输入</h1><h2 id="37da" class="oc nd iq bd ne od oe dn ni of og dp nm le oh oi no li oj ok nq lm ol om ns on bi translated">读取defaulf超参数值</h2><p id="4066" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">幸运的是，scikit-learn提供了一种以编程方式读取估计器默认参数设置的方法。这是通过用默认参数(即空参数列表)然后使用<code class="fe my mz na nb b">get_params</code>方法。<a class="ae lr" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html" rel="noopener ugc nofollow" target="_blank"> SVC </a>类有几个超参数，如<code class="fe my mz na nb b">C</code>、<code class="fe my mz na nb b">kernel</code>、<code class="fe my mz na nb b">degree</code>等。它们中的一些(例如<code class="fe my mz na nb b">C</code>和<code class="fe my mz na nb b">kernel</code>)总是相关的，而其他的，只有当其他参数取某个值时才相关。例如<code class="fe my mz na nb b">degree</code>仅在<code class="fe my mz na nb b">kernel=='poly'</code>时相关。</p><h2 id="cb7c" class="oc nd iq bd ne od oe dn ni of og dp nm le oh oi no li oj ok nq lm ol om ns on bi translated">指定输入</h2><p id="83fd" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">让我们从简单的开始，它们总是相关的。注意，<code class="fe my mz na nb b">autocalc.autocalc.Var</code>的第一个位置参数是一个字符串，在显示<code class="fe my mz na nb b">Var</code>时使用，或者作为一个小部件集，或者在使用例如<code class="fe my mz na nb b">str(Var('xyz')</code>时使用。本例中使用的其他参数或者不言自明，或者将在相关阶段详细说明。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5aa7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所述，<code class="fe my mz na nb b">degree</code>参数仅在<code class="fe my mz na nb b">kernel=='poly'</code>时使用。所以我们决定显示，但是当情况不是这样时，禁用相应的小部件。这里的想法是像往常一样创建degree-Var，并给<code class="fe my mz na nb b">kernel</code>变量分配一个回调，这将在需要时禁用/启用degree小部件。</p><p id="54e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，我们如何使用<code class="fe my mz na nb b">Var</code>来创建回调。这里需要注意的是<code class="fe my mz na nb b">autocalc</code>的方法与<code class="fe my mz na nb b">ipywidget</code>的<code class="fe my mz na nb b">.observe</code>方法的不同之处:</p><ul class=""><li id="dedd" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">当使用<code class="fe my mz na nb b">autocalc</code>时，动作被附加到被作用的实体，而不是触发动作的实体。</li><li id="bd5c" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">在<code class="fe my mz na nb b">ipywidgets</code>中，动作由微件触发。在<code class="fe my mz na nb b">autocalc</code>的情况下，动作由<code class="fe my mz na nb b">Var</code>触发，其可能具有关联的窗口小部件，但这不是必需的。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d8c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">前一个单元格中的代码功能齐全，并给出了如何处理这种情况的想法。然而，对于其他变量，我们将多次使用上述模式。所以让我们避免代码重复，为此创建一个<code class="fe my mz na nb b">Var</code>的子类。我们将使用与上面相同的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="6646" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义了类<code class="fe my mz na nb b">CVar</code>之后，我们可以从#+-+-+-+-+开始退出代码片段，使用更直接的定义。(你可以安全地删除那部分代码，不会影响功能。它只是为了更容易理解<code class="fe my mz na nb b">CVar</code>的定义。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0340" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据<a class="ae lr" href="https://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html" rel="noopener ugc nofollow" target="_blank">文档</a>,<code class="fe my mz na nb b">gamma</code>的值可以是<code class="fe my mz na nb b">'auto'</code>、<code class="fe my mz na nb b">'scale'</code>或浮点数。我们将使用下面的两个小部件来实现它。注意，自定义<code class="fe my mz na nb b">gamma</code>值的输入仅在选择<code class="fe my mz na nb b">'custom'</code>时有效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="5d13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们已经创建了小部件，是时候将它们显示在模型参数框中了。请注意，显示带有关联小部件的<code class="fe my mz na nb b">Var</code>会导致显示其名称，后跟其小部件。如果你想把这个部件集放在一个<code class="fe my mz na nb b">HBox</code>中，你必须使用<code class="fe my mz na nb b">Var</code>对象的<code class="fe my mz na nb b">.widget_set</code>字段。如果您只想显示小部件，您可以使用<code class="fe my mz na nb b">.widget</code>字段访问它。当在下面最后一行显示<code class="fe my mz na nb b">gamma</code>参数的输入时，这两者都会显示出来:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="6b97" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">加载数据</h1><p id="53e9" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">在本例中，我们将使用<a class="ae lr" href="https://archive.ics.uci.edu/ml/datasets/Iris" rel="noopener ugc nofollow" target="_blank">鸢尾数据集</a>，该数据集将用于根据鸢尾植物的某些特征来识别其类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="983f" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">创建输出</h1><p id="1ea8" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">我们已经指定了我们的输入部件，我们已经加载了数据。是时候处理了。记住，我们希望有两种不同类型的输出:混淆矩阵和预测器。它们都将使用fitted <code class="fe my mz na nb b">SVC</code>对象，因此将其定义为一个单独的变量是有意义的，这样就可以在它们之间共享。</p><h2 id="8593" class="oc nd iq bd ne od oe dn ni of og dp nm le oh oi no li oj ok nq lm ol om ns on bi translated">混淆矩阵</h2><p id="9f22" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">下面的<code class="fe my mz na nb b">model_fun</code>函数用于从超参数创建拟合的<code class="fe my mz na nb b">SVC</code>对象，而<code class="fe my mz na nb b">confusion_matrix_fun</code>函数使用<code class="fe my mz na nb b">SVC</code>对象创建混淆矩阵的可绘图表示，也称为“模型”。</p><p id="e0c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这两个函数中，我们都使用虹膜数据集。这不会出现在输入参数中，对于我们的目的来说，它被认为是一个常数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ce8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">模型和混淆矩阵图都将被包装在<code class="fe my mz na nb b">Var</code>中，这样我们就可以自动化它们的计算。注意，<code class="fe my mz na nb b">model</code>变量是用<code class="fe my mz na nb b">lazy=True</code>参数定义的。这个参数是用来做什么的？到目前为止，我们声明的<code class="fe my mz na nb b">Var</code>要么是输入，要么是根据其他<code class="fe my mz na nb b">Var</code>(例如<code class="fe my mz na nb b">gamma</code>)计算出来的，计算速度非常快。所以当他们的一个输入改变时，我们可以立即重新计算。</p><p id="b449" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">机器学习模型(如<code class="fe my mz na nb b">SVC</code>)有许多输入参数，一般来说，计算起来很慢。因此，我们不希望在更改其中一个参数后重新计算模型，而是希望更改我们需要的所有参数，然后让重新计算发生。(注意:当前数据集非常小，因此重新计算只需几秒钟，但通常输入数据集要大几个数量级。)</p><p id="f0e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是通过<code class="fe my mz na nb b">lazy</code>标志实现的。如果任何输入改变，<code class="fe my mz na nb b">Var</code>将进入“未定义”状态(<code class="fe my mz na nb b">Var.is_undefined</code>评估为<code class="fe my mz na nb b">True</code>)，而不是重新计算。它进入这种状态的原因是为了避免我们的变量不一致:一个<code class="fe my mz na nb b">Var</code>有一个不同的状态，要么是由它的输入产生的，要么是被显式覆盖的。</p><p id="7c95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了强制重新计算一个懒惰的<code class="fe my mz na nb b">Var</code>，需要显式调用它的<code class="fe my mz na nb b">.get</code>或<code class="fe my mz na nb b">.recalc</code>方法。</p><p id="b46b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与<code class="fe my mz na nb b">model</code>变量相反，<code class="fe my mz na nb b">cm</code>并不懒惰，但是它依赖于一个懒惰变量(<code class="fe my mz na nb b">model</code>)。因此，当<code class="fe my mz na nb b">model</code>的其中一个输入发生变化时，<code class="fe my mz na nb b">cm</code>也将处于未定义状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="71d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以现在<code class="fe my mz na nb b">model</code>很懒，也就是说我们需要一些手动触发来让它评估。我们将使用一个按钮小部件来实现，它将显示在超参数小部件的下面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="ba97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe my mz na nb b">model</code>变量是内部变量，不会向用户透露。因此，如果没有定义，用户就看不到它。但是对于公共变量(即。用户看到的那些)需要对未定义的状态做些什么。如果一个公共变量有一个小部件，它可以有一个未定义的状态(例如一个可以是空的文本框)，那么它由<code class="fe my mz na nb b">autocalc</code>处理。但是当一个更复杂的变量，比如混乱矩阵图，变得不确定时，我们必须指定该做什么。</p><p id="0701" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的<code class="fe my mz na nb b">cm_display</code>函数将作用于<code class="fe my mz na nb b">cm</code> <code class="fe my mz na nb b">Var</code>的值。如果定义正确，它将绘制在输出框中。否则，该框中的内容将被清除，并替换为一条消息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3538" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于<code class="fe my mz na nb b">cm_display</code>功能，我们需要注意几点:</p><ol class=""><li id="6151" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq oo mq mr ms bi translated">我们明确地检查了它的输入是否未定义。在前面的函数中，我们不必做这样的事情。这是因为，默认情况下，这些函数不必处理未定义输入。如果他们的任何一个输入未定义，该函数甚至不会被评估，并且有问题的<code class="fe my mz na nb b">Var</code>也将被设置为未定义状态。要覆盖这种行为，需要将<code class="fe my mz na nb b">undefined_input_handling</code>参数设置为<code class="fe my mz na nb b">'function'</code>，如下所示。</li><li id="2aed" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq oo mq mr ms bi translated">注意，我们如何检查<code class="fe my mz na nb b">cm</code>是否被定义:<code class="fe my mz na nb b">cm is undefined</code>，尽管如上所述，检查<code class="fe my mz na nb b">Var</code>是否被定义需要使用<code class="fe my mz na nb b">.is_undefined</code>方法。值得注意的是，这些在<code class="fe my mz na nb b">Var</code>的<code class="fe my mz na nb b">fun</code>参数中给出的函数总是作用于<code class="fe my mz na nb b">Var</code>内部的值，而不是<code class="fe my mz na nb b">Var</code>对象本身。所以<code class="fe my mz na nb b">cm_display</code>函数范围内的<code class="fe my mz na nb b">cm</code>变量与外部范围内的<code class="fe my mz na nb b">cm</code>变量不同，而是它的“内部”值:<code class="fe my mz na nb b">cm._get_raw()</code>。虽然这可能会造成一些混乱，但基本原理是在<code class="fe my mz na nb b">autocalc</code>框架中，我们希望尽可能重用原始函数，这些函数作用于“普通”变量，而不是<code class="fe my mz na nb b">Var</code>变量。只有在这些特殊情况下，我们才需要为变量<code class="fe my mz na nb b">undefined</code>做准备。</li><li id="df33" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq oo mq mr ms bi translated">我们重用了之前创建的<code class="fe my mz na nb b">calibrate_button</code>小部件。这个按钮现在可能出现在两个不同的地方。但是对朱庇特来说是可以的。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h2 id="07b8" class="oc nd iq bd ne od oe dn ni of og dp nm le oh oi no li oj ok nq lm ol om ns on bi translated">预言者</h2><p id="7f47" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">预测器的想法是，当用户遇到一株鸢尾时，她可以要求模型根据<code class="fe my mz na nb b">variable_list</code>中列出的属性来识别它，如“萼片长度”、“萼片宽度”、“花瓣长度”和“花瓣宽度”。</p><p id="cf74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们为这些参数创建输入部件。我们使用Python list-comprehension从<code class="fe my mz na nb b">variable_list</code>创建<code class="fe my mz na nb b">Var</code>，并用来自训练集第一条记录的相应值初始化这些值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="09c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要一个函数来将校准的模型和测量的属性转换为预测，我们需要显示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="2fe3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们最终的应用程序将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ecc9b7c115c7708066a20db0b7c515f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIHn9EWDoiU6hJMxoWYX-w.png"/></div></div></figure><h1 id="59c7" class="nc nd iq bd ne nf ng nh ni nj nk nl nm jw nn jx no jz np ka nq kc nr kd ns nt bi translated">结束语</h1><p id="e233" class="pw-post-body-paragraph kv kw iq kx b ky nu jr la lb nv ju ld le nw lg lh li nx lk ll lm ny lo lp lq ij bi translated">在本文中，我们围绕机器学习任务创建了一个简单的应用程序。我们使用Jupyter笔记本作为平台，Ipywidgets用于大多数输入和输出，autocalc包用于连接我们的组件。</p><p id="d889" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这篇文章能帮助你在Jupyter notebook中轻松创建类似的应用程序。如果你喜欢我的帖子，请鼓掌，关注，分享，评论。这鼓励我生产更多。</p><ul class=""><li id="2074" class="mk ml iq kx b ky kz lb lc le mm li mn lm mo lq mp mq mr ms bi translated">赠送的<a class="ae lr" href="https://pypi.org/project/autocalc/" rel="noopener ugc nofollow" target="_blank">自动计算</a>包是我写的。我欢迎对<a class="ae lr" href="https://github.com/kefirbandi/autocalc" rel="noopener ugc nofollow" target="_blank"> github </a>的评论/建议/请求。</li><li id="a6e6" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">这个帖子最初是作为Jupyter笔记本创建的。作为单个笔记本的<a class="ae lr" href="https://gist.github.com/kefirbandi/6204da76c2a8f8e26af78331afe6223a" rel="noopener ugc nofollow" target="_blank">代码</a>可以作为github gist获得。</li><li id="95cf" class="mk ml iq kx b ky mt lb mu le mv li mw lm mx lq mp mq mr ms bi translated">使用<a class="ae lr" href="https://www.dexplo.org/jupyter_to_medium" rel="noopener ugc nofollow" target="_blank"> jupyter_to_medium工具</a>将其转换为介质。非常感谢<a class="op oq ep" href="https://medium.com/u/cf7f60f2eeb3?source=post_page-----2ef8ea4cc6c2--------------------------------" rel="noopener" target="_blank"> Ted Petrou </a>的这个包。</li></ul><div class="ls lt gp gr lu lv"><a href="https://medium.com/dunder-data/jupyter-to-medium-initial-post-ecd140d339f0" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">Jupyter到中等初始职位</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">我非常兴奋地宣布jupyter_to_medium的正式发布，这是一个扩展jupyter的Python包…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="or l mg mh mi me mj kp lv"/></div></div></a></div></div></div>    
</body>
</html>