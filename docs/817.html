<html>
<head>
<title>An Algorithmic Implementation of an Autonomous Driving LiDAR Perception Stack with PCL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于PCL的自动驾驶激光雷达感知栈的算法实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-algorithmic-implementation-of-an-autonomous-driving-lidar-perception-stack-with-pcl-4d5928bcebc7#2022-01-30">https://towardsdatascience.com/an-algorithmic-implementation-of-an-autonomous-driving-lidar-perception-stack-with-pcl-4d5928bcebc7#2022-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="3184" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">基于PCL的自动驾驶激光雷达感知栈的算法实现</h1></div><div class=""><h2 id="31c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于激光雷达感知的C++管道示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9810b5025e85403fae8a8049e18fb362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RHcKF5R5tx4wo6aV"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍摄</p></figure><h1 id="962c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="ce95" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">自动驾驶是一个相对较新且非常迷人的现代技术领域。自2004年DARPA Grand Challenge期间公开展示并在2007年的城市挑战赛期间转向更具挑战性的城市环境以来，自动驾驶一直受到业界和学术界的追捧。这些应用一直在个人自动驾驶汽车、自动出租车车队、卡车运输、送货等等之间徘徊，但技术仍未出现。自动驾驶陷入幻灭低谷的原因之一是软件驱动栈的感知组件是一个非常复杂的问题。虽然大多数团队采用基于激光雷达的感知，但特斯拉和Wayve仍试图建立摄像头优先的感知。依赖激光雷达的解决方案也可以分为两类:处理点云的传统计算机视觉算法和基于深度学习的方法。神经网络承诺以高平均精度解决感知问题，然而，如果我们想在最坏的情况下证明合理的精度，这是不够的。在汽车行业，当软件必须满足ASIL D级可靠性时，最好有一个独立的传统非ML感知堆栈在车辆上运行，并提供与汽车标准的高度一致性。在本文中，我们将看看在PCL(一个开源的点云库)的帮助下实现的广告栈。</p><p id="226b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们将坚持系统级的测试驱动开发(TDD ),以确保我们的整个代码在第一次现场部署发生之前得到彻底的测试。为此，我们需要一个数据集来运行我们的代码。卡尔斯鲁厄理工学院和芝加哥丰田理工学院的经典2012数据集Kitti非常适合这个目的。这是第一批大规模高质量数据集之一，旨在作为自动驾驶领域计算机视觉算法的基准。Kitti具有包括检测在内的几个子数据集，但我们对跟踪子数据集更感兴趣，因为我们将利用数据的时间属性以及GNSS定位数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/de0b2a6b92dc15ee6665cdcef5630401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1mcRdyjTq0EKG-M_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">谷歌地图定位的凯蒂跟踪序列0000</p></figure><p id="827c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Kitti跟踪由21个同步的PNG图像序列、威力登激光雷达扫描和来自RT3003 GPS-IMU模块的NMEA记录组成。数据集的一个重要特征是传感器之间的彻底相互校准，包括矩阵“Tr_imu_velo ”,它是从GPS-IMU坐标到威力登激光雷达坐标的转换。</p><p id="eeba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感知管道的架构如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/213bbb147840ad7c03140d98937bf1af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RDg_FXVRwSWBEMZr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点云感觉形态的感知管道。图片由作者提供。</p></figure><p id="d711" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们分别讨论每个组件，并深入研究它们的C++实现。</p><h1 id="b3c6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">点云抽取</h1><p id="24bb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为什么我们可能需要抽取来自深度传感器(可能是一个或几个激光雷达)的点云？自动驾驶软件最重要的要求是满足实时操作约束。第一个要求是处理流水线跟上激光雷达扫描采样的速率。在实际情况下，扫描速率可能从每秒10次扫描到每秒25次扫描不等，这导致任何处理阶段的最大延迟从100毫秒到40毫秒不等。如果对于任何可能的输入点云，任何阶段(例如集群化)滞后超过100毫秒(对于每秒10次扫描的速率)，将会发生丢帧，或者流水线的总延迟将开始任意增长。这里的一个解决方案是丢弃激光雷达点，而不是丢弃整个帧。这将逐渐降低准确性指标(召回率和精确度)，并保持管道实时运行。第二个要求是系统的整体延迟或反应时间。同样，总延迟应限制在至少100或200毫秒，500毫秒甚至1秒左右的反应时间对于自动驾驶来说是不可接受的。因此，通过首先应用抽取来处理少量的激光雷达点来开始算法设计是有意义的。</p><p id="0c77" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">抽取的标准选项有:</p><ol class=""><li id="4c3b" class="mr ms iq lq b lr mk lu ml lx mt mb mu mf mv mj mw mx my mz bi translated">规则的</li><li id="80d2" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">(伪)随机</li><li id="044a" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">体素网格</li></ol><p id="cd6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">常规缩减采样速度很快，但可能会导致点云上出现锯齿图案。随机或伪随机下采样也很快，但可能会导致小对象不可预测地完全消失。像PCL的pcl::VoxelGrid &lt;&gt;类这样的体素网格过滤是智能和自适应的，但需要额外的计算和内存。一如既往，选择一种方法而不是另一种方法是一种设计选择。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/e944ec317f2a650bb8eaa005298e01e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3sFjI2lgwQRc0iuy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">原始点云。请注意，此处显示的RGB图像仅用于清除。RGB数据不用于激光雷达管线。图片由作者提供。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/519a43b5830bbbd0f72271a970563fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fCHGcV9VJ9cjPFDi"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">抽取的点云。图片由作者提供。</p></figure><h1 id="975c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">多扫描聚合</h1><p id="5832" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">多扫描聚合是在自我车辆相对于地面移动时将若干历史激光雷达扫描配准到公共坐标系的过程。公共坐标系可以是本地导航框架(也称为ego-master坐标)或当前激光雷达传感器坐标。我们将以后者为例。这个阶段理论上是可选的，但在实践中非常重要。问题是下一阶段的聚类取决于激光雷达点的密度，如果密度不足，过度聚类的影响可能会发挥作用。过度集群化意味着任何对象(汽车、公共汽车、建筑墙壁等)都可能被分割成几个部分。就其本身而言，对于检测障碍物来说，这可能不是问题，但是，对于感知-跟踪-过度集群化的下游模块来说，这是一个巨大的挑战。跟踪器可能不准确地关联物体的碎片，并产生将由预测模块在与自我车辆路径交叉的方向上外推的轨迹，这又使得自我车辆突然刹车。我们绝对不希望集群化中的小错误在下游组件中造成大量错误。</p><p id="45ff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">几次连续扫描(5到10次)的聚合成比例地增加了落在每个物体上的激光雷达点的密度，并有助于精确的聚类。自我车辆运动的一个很好的特点是，汽车能够从不同的角度观察同一物体，并且激光雷达扫描模式覆盖物体的不同部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/c3f4deb8e5474cc6d0c087e4aee7bb80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eJL4vkekBVFAzdJ6"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自我载体(灰色方框)从不同的角度观察同一个物体。图片由作者提供。</p></figure><p id="c22c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看执行聚合的代码。第一阶段是用历史点云以及随后的扫描仪姿态之间的姿态变换来保持约束长度的队列。请注意，我们如何使用从RT3003 GPS-IMU模块获得的平移速度[Vx，Vy]和旋转速度Wz来构建姿态变换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4061" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第二阶段，我们从时间上向后的最近扫描开始遍历队列，将扫描到扫描的转换累积到集合转换中，并将集合转换应用于每个历史帧。通过这种方法，我们使计算成本为O(N*D ),其中N是点数，D是历史的深度(扫描次数)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3f9c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在聚集之后，如果移动的物体看起来有点模糊，那么点云会变得模糊。这是一个挫折，可以在集群化阶段进一步处理。在这个阶段，我们需要的是一个更密集的点云，从多个帧中积累信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/8e2cd27d22486fdcbf3ce6065297c1ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x6ffenWDYRMQMVQT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">5帧聚合点云。为了便于观察，地面被移开了。图片由作者提供。</p></figure><h1 id="d038" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">地面移除</h1><p id="71aa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">感知堆栈的目的是提供有关动态对象和静态障碍物的信息。汽车应该在道路上行驶，通常路面不被认为是障碍。因此，我们可以移除从路面反射的所有激光雷达点。为了做到这一点，我们首先将地面检测为平面或曲面，并移除表面周围约10厘米或以下的所有点。有几种方法可以检测点云上的地面:</p><ol class=""><li id="18ea" class="mr ms iq lq b lr mk lu ml lx mt mb mu mf mv mj mw mx my mz bi translated">用Ransac探测一架飞机</li><li id="3771" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">用霍夫变换检测平面</li><li id="1059" class="mr ms iq lq b lr na lu nb lx nc mb nd mf ne mj mw mx my mz bi translated">具有填色的非平面表面检测</li></ol><p id="5073" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们借助Eigen和PCL库更深入地了解Ransac的C++实现。</p><p id="fad4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，我们来定义一下我们的候选平面。我们将使用基点加法向量的形式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e215" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们定义一个辅助函数，它允许我们在点云转换到平面坐标后，在Z坐标上找到满足条件的所有点的索引。条件是由lambda函数给出的，因为我们希望这个帮助器尽可能通用。请按照代码中的注释来了解实现的细节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5a4b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，主要的Ransac实现如下所示。第一步是根据Z坐标对点进行粗略过滤。此外，我们需要再次抽取点，因为我们不需要聚合云中的所有点来验证候选平面。这些操作可以一次完成。</p><p id="56e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，我们开始迭代。借助C++标准库的std::mt19937伪随机生成器，每次迭代采样3个随机点。对于每个三元组，我们计算平面并确保其法线向上。然后我们使用同一个帮助函数find _ inlier _ indices来计算内联器的数量。迭代结束后，我们剩下的是最佳平面候选，我们最终使用它来复制点云中索引不在列表中的所有点。请注意std::unordered_set &lt;&gt;的使用。它允许执行索引的常数时间O(1)搜索，而不是我们对std::vector &lt;&gt;的线性O(N)搜索。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="cc3d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看地面消除的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/45d06c0b23f29605e59a6da982d42209.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AEZ_rNsxAjeVtxN0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在移除地面之前。图片由作者提供。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/dc970be0b8abe8547e61bb7878a3d29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KcRG-LOD6569slnL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">移除地面后。图片由作者提供。</p></figure><p id="522e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">去除了背景之后，我们准备对剩余的点进行聚类，并通过凸包提取来压缩对象元数据。这两个阶段值得他们自己的文章。我将在即将到来的第二部分中介绍它们的实现。同时下面是聚类的最终结果——凸包提取。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/c4594522ac48c094f5d189a5f7c5db63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*obD-RPYx7Cgamd-b"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用凸包可视化的最终聚类对象。图片由作者提供。</p></figure><p id="ace5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">凸包绝对是任何追踪器都渴望接受的元数据类型。它们在RAM使用方面更紧凑，并且比定向边界框更精确地表示对象的边界。这是另一个可视化，取自Kitti序列0003。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/8b573aa5e6766903ef56315029cf2db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IkHWygsVlVwCKJtunICCDw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自KITTI追踪序列0003的集群化点云。图片由作者提供。</p></figure><h1 id="da90" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="d863" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我相信，自动驾驶将是人类在生活质量和整体生产力方面的一次飞跃。它将最终使“自动”-“移动”真正成为一个最终自动化的移动设备。自动驾驶需要最高水平的软件工程，我希望许多刚开始职业生涯的工程师在阅读这篇文章后会受到鼓励，以完善他们的技能。</p><p id="449f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">参考资料:</p><p id="dce4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[1] <a class="ae kv" href="https://github.com/Obs01ete/lidar_course/tree/master/src" rel="noopener ugc nofollow" target="_blank">作者在Github上的项目源代码</a>(星星不胜感激)</p><p id="e6c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[2] <a class="ae kv" href="http://www.cvlibs.net/datasets/kitti/eval_tracking.php" rel="noopener ugc nofollow" target="_blank">基蒂跟踪页面</a></p><p id="9cc5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[3] <a class="ae kv" href="https://pointclouds.org/" rel="noopener ugc nofollow" target="_blank"> PCL点云处理库</a></p></div></div>    
</body>
</html>