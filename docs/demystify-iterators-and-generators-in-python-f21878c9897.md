# 揭开 Python 中迭代器和生成器的神秘面纱

> 原文：<https://towardsdatascience.com/demystify-iterators-and-generators-in-python-f21878c9897>

## 了解处理大型数据集的有效方法

![](img/1cd3f689abc22407266ffff0161174e3.png)

图片由 Pixabay 中的[设计](https://pixabay.com/photos/magic-cube-patience-tricky-hobby-1976725/)完成

当您有一个大型数据集时，比如一个大的 CSV 文件或一个大的 SQL 表，将所有数据加载到内存中是低效的，甚至是不可能的。你的电脑会卡住，你的程序会崩溃。调试起来既费时又令人沮丧。幸运的是，迭代器和生成器是解决这类问题的好工具。此外，理解生成器有助于学习更高级的特性，比如目前越来越流行的 asyncio。

## Python 中的范围

在开始之前，让我们看一下特殊的`range`函数，该函数返回一个产生整数序列的**可迭代的**。Iterable，顾名思义，就是可以迭代的东西。或者你可以把它理解为可以在一个`for`循环中使用的东西。让我们用一些简单的代码来验证一下:

从这个简单的代码片段中，我们可以知道:

*   从技术上讲，`range`是一个类，尽管它以非 Pythonic 化的小写字母开头。`range`返回的对象属于`range`类型。
*   一个`range`对象是**可迭代的**并且可以被迭代。
*   然而，`range`对象不是迭代器。我们需要使用`iter`函数将一个**可迭代**转换成一个**迭代器**。

## 迭代器

迭代器是一个实现神奇的`__next__`方法的对象，因此可以在`next`函数中用来产生数据流的下一个元素，如上所示。为了理解迭代器是如何工作的，让我们创建一个模仿`range`函数行为的类。

我们需要一些代码来模拟`range`的位置参数的行为。重要的是，我们需要一个状态变量`counter`来记录自定义迭代器处于哪个状态以及下次生成哪个值。

让我们用`next`函数试试定制迭代器:

是的，它像预期的那样工作。现在，让我们试着在一个`for`循环中使用它，看看会发生什么。

嗯，有点奇怪，不是吗？`MyRangeIter`是迭代器，但不是可迭代的。如果迭代器只能在`next`函数中使用，而不能在`for`循环中使用，那么它就没有用。实际上，要使一个迭代器可迭代，我们需要实现`__iter__`魔法方法，这使得它可迭代，并且可以与上面演示的`iter`函数一起使用。如果你现在在`r_iter`上使用`iter`，你也会看到一个错误，说它是不可迭代的。现在让我们添加`__iter__`方法:

我们已经知道，`iter`函数调用底层类的`__iter__`方法并返回一个迭代器。在这个例子中，返回的迭代器是它自己。是的，很奇怪，但事情就是这样。实际上，如果您意识到要使类能够使用`next`和`iter`函数，必须分别实现神奇的`__next__`和`__iter__`方法，那么理解起来就不会那么困难了。

现在该变量可以在`for`循环中使用。你可以自己尝试一下。

## 发电机

如上所述，创建迭代器需要相当多的样板代码。我们需要创建一个类并实现神奇的`__next__`和`__iter__`方法。在 Python 中有一种更好的方法，这就是生成器的亮点。

要创建一个生成器，我们不需要创建一个类并实现神奇的`__next__`和`__iter__`方法。生成器简单地由生成器函数定义:

生成器函数的所有魔力都在于关键字`**yield**`，它将数据和控制返回给调用者，但保留函数的状态。当它再次迭代时，函数被恢复，并基于最新状态产生一个新值。在这个例子中，状态是用简单的计数器实现的。如果你把`yield`改成`return`，那么它就是一个常规函数，只会返回一个值。实际上，如果没有`yield`关键字，它根本不是一个生成器，不能被迭代。

让我们试试我们的发电机:

类似于迭代器，当生成器耗尽时会引发`StopIteration`异常。该异常由`for`循环自动处理。

此外，应该注意的是，生成器函数中的`return`关键字会引发`StopIteration`异常，返回值将被用作异常的消息。这对于理解生成器的类型注释是很重要的，我们将很快介绍这一点。

## 生成器理解

在我们学习更高级的生成器的`send`方法之前，让我们先学习一些简单而方便的东西。与列表理解类似，我们可以使用生成器理解用一行代码创建一个生成器。唯一的区别是我们需要将括号改为圆括号:

正如我们所见，生成器理解与列表理解非常相似。你只需要把括号换成圆括号。但是，使用 list comprehension，所有数据都被加载到内存中，这可以通过创建的变量的大小反映出来。另一方面，它不是生成器理解的情况，这使得它更加节省内存。

## 了解发电机的`send`方法

大多数情况下，不需要使用生成器的`send`方法。在用 Python 编码的这些年里，我从来没有机会使用它。然而，理解它是如何工作的有助于为生成器添加类型注释。此外，如果你想了解 Python 中的 [asyncio](https://docs.python.org/3/library/asyncio.html) 库是如何工作的，这也很重要，因为[协程](https://peps.python.org/pep-0342/)是由幕后的生成器实现的。

让我们更新生成器，让它接受用户发送的值。该值将用于更改生成器函数中的`stop`变量，这样我们可以生成更多的值:

注意，发送给生成器函数的值是由`yield`语句接收的。您可以将`yield`语句的返回值赋给一个变量，并相应地使用它。要向生成器发送一个值，只需调用生成器上的`send()`方法:

请注意，您只能在生成器已经产生某些东西之后向它发送数据，否则，您将看到一个`TypeError`:

## 生成器的类型注释

最后，让我们向上面创建的生成器函数添加类型注释。[在函数中添加类型注释](https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d)可以让你的代码更健壮，更容易理解。不用读函数体就能知道返回类型。

如果一个生成器函数既包含了`yield`和`return`关键字，也可以接受外部发送的值，那么我们需要使用泛型`Generator[YieldType, SendType, ReturnType]`:

注意对于`*args`，我们只需要为一个参数添加类型注释。更多细节请参考[本讨论](https://stackoverflow.com/questions/37031928/type-annotations-for-args-and-kwargs)。

在大多数情况下，我们的生成器只会产生值。在这种情况下，我们可以将`SendType`和`ReturnType`设置为`None`:

[或者](https://docs.python.org/3.6/library/typing.html#typing.Generator)，当一个生成器只产生值时，我们可以将返回类型标注为`Iterable[YieldType]`或`Iterator[YieldType]`，这对于那些不理解生成器的`send`方法的人来说更简洁，更容易混淆:

在这篇文章中，我们介绍了 iterables、iterators 和 generators 的技术细节，它们可以让您高效地处理需要大量资源(尤其是内存)的大型数据集。提供了一些简单的代码片段，可以帮助您理解迭代器和生成器的神奇方法，您通常将它们用作黑盒。发电机更受关注，因为它更简单，应用更广泛。我们已经揭开了`send`方法及其类型注释的神秘面纱。有了这些知识，您也可以理解更高级的特性，比如 Python 中的 asyncio。

相关文章:

*   [使用 mypy 和 pydantic 进行 Python 类型化和验证](https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d)