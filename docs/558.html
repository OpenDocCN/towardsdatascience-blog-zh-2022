<html>
<head>
<title>Develop a Conversational AI Bot in 4 simple steps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用4个简单的步骤开发一个对话式人工智能机器人</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/develop-a-conversational-ai-bot-in-4-simple-steps-1b57e98372e2#2022-01-19">https://towardsdatascience.com/develop-a-conversational-ai-bot-in-4-simple-steps-1b57e98372e2#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="d0c2" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用4个简单的步骤开发一个对话式人工智能机器人</h1></div><div class=""><h2 id="c395" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用PyTorch transformers、FastAPI和Docker创建聊天机器人</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/0804db4ee48ed679b74f2cad81cef5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*zIxyGH-bIZP4cA7Ho8oilQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由作者提供。</p></figure><h1 id="a3d5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">目录</h1><ol class=""><li id="e25f" class="lm ln it lo b lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">介绍</li><li id="db84" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">步骤1:利用预先训练的模型</li><li id="e8c4" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">步骤2:构建后端</li><li id="6f41" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">步骤3:构建前端</li><li id="dd27" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">第四步:用Docker打包app</li><li id="12d3" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">结论</li><li id="786c" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">参考</li></ol><h1 id="d679" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="aa1f" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">对话式AI聊天机器人无疑是目前最先进的聊天机器人。这种聊天机器人混合使用自然语言处理(NLP)和人工智能(AI)来理解用户的意图，并提供个性化的响应。</p><p id="a41d" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">使用专有数据训练(或微调)这种模型，使公司能够直接通过聊天窗口向客户提供提交保险索赔、升级数据计划、更改航班等多种方式。</p><p id="601a" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">在本帖中，我们将讨论:</p><ol class=""><li id="fc8a" class="lm ln it lo b lp mw lr mx lt nb lv nc lx nd lz ma mb mc md bi translated">如何使用预先训练好的PyTorch模型构建聊天机器人；</li><li id="ba51" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">如何使用FastAPI和Jinja与模型对话；</li><li id="5338" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz ma mb mc md bi translated">如何使用Docker部署我们的定制模型？</li></ol><h1 id="56e2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">步骤1:利用预先训练的模型</h1><p id="0e66" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">让我们首先安装必要的Python包来构建和测试我们的新聊天机器人。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3456" class="nj kv it nf b gy nk nl l nm nn">pip install --no-cache-dir transformers[torch] uvicorn fastapi jinja2 python-multipart</span></pre><p id="d366" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">对于我们的聊天机器人，我们将使用来自微软的预先训练好的<code class="fe no np nq nf b">DialoGPT-large</code>模型。为了加载这个模型，我们可以简单地对<code class="fe no np nq nf b">transformers</code>中的<code class="fe no np nq nf b">AutoTokenizer</code>和<code class="fe no np nq nf b">AutoModelForCausalLM</code>类使用<code class="fe no np nq nf b">from_pretrained</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="2b80" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">要调用模型，我们需要:<br/> 1。<code class="fe no np nq nf b">encode</code>用户消息使用<code class="fe no np nq nf b">tokenizer</code>；<br/> 2。<code class="fe no np nq nf b">generate</code>使用<code class="fe no np nq nf b">model</code>对象的机器人响应；<br/> 3。<code class="fe no np nq nf b">decode</code>使用<code class="fe no np nq nf b">tokenizer</code>的响应。</p><p id="fee9" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">将下面的片段复制并粘贴到终端或笔记本电池上进行测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="18d7" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">如果上面所有的库都安装正确，那么这段代码应该运行时不会出现错误或警告。如果是这样，应该会返回以下消息:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="05aa" class="nj kv it nf b gy nk nl l nm nn">I'm good, you?</span></pre><p id="ce3b" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">现在我们知道模型工作得很好，让我们将这两个片段包装在一个可重用的类中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="161b" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">上面的代码片段有两个方法，一个用于加载模型(<code class="fe no np nq nf b">load_model</code>)，另一个用于在用户给定消息的情况下从机器人那里获得回复(<code class="fe no np nq nf b">get_reply</code>)。注意，我们扩展了<code class="fe no np nq nf b">get_reply</code>方法来考虑过去的聊天历史。此外，为了提高对话的一致性，我们调整了模型的<code class="fe no np nq nf b">top_k</code>、<code class="fe no np nq nf b">top_p</code>和<code class="fe no np nq nf b">temperature</code>。</p><p id="7dda" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">你可以在这里找到完整的文件:<a class="ae nt" href="https://github.com/andreRibeiro1989/medium/blob/main/chatbot/app/model.py" rel="noopener ugc nofollow" target="_blank"> chatbot/app/model.py </a></p><h1 id="7de9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">步骤2:构建后端</h1><p id="cb54" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">既然我们已经理清了chatbot模型，下一步就是通过标准的HTTP方法使这个模型可用。为此，我们将在FastAPI应用程序中包装模型。</p><p id="75df" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">因为我们只对给定用户消息的模型的响应感兴趣，所以我们只需要实现一个端点(<code class="fe no np nq nf b">/</code>)来获得来自聊天机器人的回复。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7853" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">注意，我们在上面的FastAPI端点中使用了<code class="fe no np nq nf b">Form</code>语法。当我们实现前端时，使用<code class="fe no np nq nf b">Form</code>类型的理由将变得更加明显。要测试上面的代码片段，请运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="620e" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">如果一切顺利，您应该会得到下面的JSON。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="297a" class="nj kv it nf b gy nk nl l nm nn">{'message': "I'm good, you?"}</span></pre><p id="170b" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">你可以在这里找到完整的文件:<a class="ae nt" href="https://github.com/andreRibeiro1989/medium/blob/main/chatbot/app/main.py" rel="noopener ugc nofollow" target="_blank"> chatbot/app/main.py </a></p><h1 id="8359" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">步骤3:构建前端</h1><p id="0ed8" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">我们的前端将由用户和机器人之间的简单对话组成，类似于WhatsApp或Messenger。</p><p id="e496" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">我们将根据麻省理工学院的许可改编bootsnipp.com大学提供的pablocorezzola的原创作品，而不是从头开始构建对话。这里使用的用户和机器人头像图标是从flaticon.com免费获得的(在代码中的图标旁边和这个post)⁴⁵.的末尾提供了对作者的鸣谢</p><p id="f325" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">对于这个应用程序，请确保您下载了<code class="fe no np nq nf b">CSS</code>文件。你将不需要<code class="fe no np nq nf b">HTML</code>或<code class="fe no np nq nf b">JS</code>文件。在下面的结构中添加<code class="fe no np nq nf b">CSS</code>文件，一个空的<code class="fe no np nq nf b">index.html</code>和头像图标。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6aa1" class="nj kv it nf b gy nk nl l nm nn">static/<br/>  styles.css<br/>  avatar_user.png<br/>  avatar_bot.png</span><span id="b0b2" class="nj kv it nf b gy nu nl l nm nn">templates/<br/>  index.html</span></pre><p id="100c" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">在编辑模式下打开<code class="fe no np nq nf b">index.html</code>文件，粘贴以下内容。这里有两条重要的线:</p><ul class=""><li id="66b2" class="lm ln it lo b lp mw lr mx lt nb lv nc lx nd lz nv mb mc md bi translated">第8行:将<code class="fe no np nq nf b">styles.css</code>文件添加到FastAPI应用程序中；</li><li id="4621" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz nv mb mc md bi translated">第15行:允许我们使用<code class="fe no np nq nf b">jinja</code> <code class="fe no np nq nf b">TemplateResponse</code>注入用户和机器人生成的必要对话框。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9f58" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">为此，我们还需要将下面的代码片段添加到我们的FastAPI应用程序中。</p><ul class=""><li id="6c7b" class="lm ln it lo b lp mw lr mx lt nb lv nc lx nd lz nv mb mc md bi translated">第5行:允许FastAPI应用程序显示<code class="fe no np nq nf b">/static</code>文件夹中的任何文件；</li><li id="58d5" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz nv mb mc md bi translated">第9行:告诉Jinja模板<code class="fe no np nq nf b">index.html</code>文件在哪里。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="12c3" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">最后，我们需要修改FastAPI端点来呈现对话框HTML，而不是之前的JSON消息。该对话框将用于使用Jinja替换<code class="fe no np nq nf b">templates/index.html</code>中的<code class="fe no np nq nf b">{{ chat|safe }}</code>占位符。</p><p id="8fbd" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">为此，用下面的代码片段替换前面的端点(<code class="fe no np nq nf b">/</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="75b8" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">注意<code class="fe no np nq nf b">build_html_chat()</code>函数还没有定义。该函数接受3个参数:</p><ul class=""><li id="804d" class="lm ln it lo b lp mw lr mx lt nb lv nc lx nd lz nv mb mc md bi translated"><code class="fe no np nq nf b">is_me</code>:布尔定义给定消息是来自用户还是机器人；</li><li id="7d7b" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz nv mb mc md bi translated"><code class="fe no np nq nf b">text</code>:用户/机器人消息；</li><li id="c272" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz nv mb mc md bi translated"><code class="fe no np nq nf b">time</code>:处理消息的时间。</li></ul><p id="27f7" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">因为这个函数只是一个标准的HTML代码块，所以我不会在本文中涉及它。而是可以从以下链接(以及完整的前端脚本)获取:<a class="ae nt" href="https://github.com/andreRibeiro1989/medium/blob/main/chatbot/app/html_utils.py" rel="noopener ugc nofollow" target="_blank">chatbot/app/html _ utils . py</a>；<a class="ae nt" href="https://github.com/andreRibeiro1989/medium/blob/main/chatbot/app/templates/index.html" rel="noopener ugc nofollow" target="_blank">聊天机器人/app/templates/index.html </a></p><h1 id="3203" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">第四步:用Docker打包app</h1><p id="af04" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">最后一步是用Docker打包我们的新应用。这一步将允许我们在本地、专用服务器或云上部署我们的应用程序，而不需要任何额外的工作。</p><p id="0c93" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">让我们从定义最终的应用程序结构开始，如下所示。因为我们还没有定义<code class="fe no np nq nf b">Dockerfile</code>，所以简单地创建一个空白文件。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6752" class="nj kv it nf b gy nk nl l nm nn">app/<br/>  static/<br/>    styles.css<br/>    avatar_user.png<br/>    avatar_bot.png<br/>  templates/<br/>    index.html<br/>  main.py<br/>  model.py<br/>  html_utils.py<br/>Dockerfile</span></pre><p id="4e94" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated"><code class="fe no np nq nf b">Dockerfile</code>必须包括:</p><ul class=""><li id="b425" class="lm ln it lo b lp mw lr mx lt nb lv nc lx nd lz nv mb mc md bi translated">我们在步骤1 <em class="nw">中安装的Python库；</em></li><li id="93fb" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz nv mb mc md bi translated">上面列出的后端和前端<code class="fe no np nq nf b">app/</code>文件；</li><li id="12e7" class="lm ln it lo b lp me lr mf lt mg lv mh lx mi lz nv mb mc md bi translated">启动容器时将调用的入口点文件(<code class="fe no np nq nf b">main.py</code>)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1a2b" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">要构建和运行容器，只需在终端上键入以下内容:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a8c8" class="nj kv it nf b gy nk nl l nm nn">docker build . -t chatbot &amp;&amp; \<br/>  docker run -p 8000:8000 chatbot</span></pre><p id="0890" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">如果Docker <code class="fe no np nq nf b">build</code>和<code class="fe no np nq nf b">run</code>命令按预期执行，以下输出应该是清楚的:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3cc5" class="nj kv it nf b gy nk nl l nm nn">INFO:     Waiting for application startup.<br/>INFO:     Application startup complete.<br/>INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)</span></pre><p id="3dc8" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">要测试Docker容器，请在您最喜欢的浏览器中打开一个新标签，并键入<a class="ae nt" href="http://0.0.0.0:8000/" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:8000/ </a>。然后，键入“嗨”。“你好吗，”在文本框中。</p><p id="7f6e" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">交叉手指，希望几秒钟后，您会看到两条消息。第一个是你刚刚输入的，第二个是机器人的回复。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ny nz di oa bf ob"><div class="gh gi nx"><img src="../Images/99f75bb387e6a2599851111e67f434bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*0vgGTRpYEP4XqtI5z6y_SA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">用户输入“嗨”后，聊天机器人应用程序完成的例子。“你好吗，”</p></figure><p id="7363" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">构建和运行这个应用程序所需的所有文件都可以在这里找到<a class="ae nt" href="https://github.com/andreRibeiro1989/medium/tree/main/chatbot/app" rel="noopener ugc nofollow" target="_blank"> main/chatbot/app </a></p><h1 id="441e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="82cd" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">智能聊天机器人的革命已经到来。这种高度复杂和强大的模型允许多个公司以方便和可扩展的方式提供不同的服务。</p><p id="1056" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">在这篇文章中，我介绍了构建你自己的聊天机器人的基本思想，从模型创建到后端和前端。请注意，这只是一个简单的例子，说明了如何实现一个简单的对话机器人，而不应该被用于任何超过说明。</p><p id="9404" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">如果你想知道更多关于如何以无服务器的方式部署这样的应用，看看我过去的文章"<a class="ae nt" rel="noopener" target="_blank" href="/build-a-serverless-api-with-amazon-lambda-and-api-gateway-dfd688510436">用Amazon Lambda和API Gateway构建无服务器API</a>"⁶"和"<a class="ae nt" href="https://betterprogramming.pub/deploy-a-reddit-bot-using-aws-lambda-and-eventbridge-7df793b979b2" rel="noopener ugc nofollow" target="_blank">使用AWS Lambda和EventBridge部署" remindme " Reddit bot</a>" ⁷.</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="615c" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated"><a class="ae nt" href="https://andrefsr.medium.com/subscribe" rel="noopener"> <strong class="lo iu">加入我的邮件列表，我一发布新内容，你就能收到新内容！</strong> </a></p><p id="0370" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑报名成为一名媒体成员。每月5美元，让你可以无限制地访问Python、机器学习和数据科学文章。如果你使用<a class="ae nt" href="https://andrefsr.medium.com/membership" rel="noopener">我的链接</a>注册，我会赚一小笔佣金，不需要你额外付费。</p><div class="oj ok gp gr ol om"><a href="https://andrefsr.medium.com/membership" rel="noopener follow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">通过我的推荐链接加入Medium-andréRibeiro</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">andrefsr.medium.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ko om"/></div></div></a></div><h1 id="0490" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><p id="b4f7" class="pw-post-body-paragraph mj mk it lo b lp lq ju ml lr ls jx mm lt mn mo mp lv mq mr ms lx mt mu mv lz im bi translated">[1]张等著《<em class="nw">对话:会话回应生成的大规模生成性预训练</em>》(2020)，arXiv <br/> <a class="ae nt" href="https://arxiv.org/abs/1911.00536" rel="noopener ugc nofollow" target="_blank">，</a></p><p id="8d7b" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">[2]拥抱脸团队，“一个最先进的大规模预训练反应生成模型(dialog pt)”<br/><a class="ae nt" href="https://huggingface.co/microsoft/DialoGPT-large" rel="noopener ugc nofollow" target="_blank">https://huggingface.co/microsoft/DialoGPT-large</a></p><p id="7502" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">[3]pablocrezzola，“简单聊天”:Bootstrap 3.0片段——在麻省理工学院许可下发布<a class="ae nt" href="https://bootsnipp.com/snippets/y8e4W" rel="noopener ugc nofollow" target="_blank">https://bootsnipp.com/snippets/y8e4W</a></p><p id="e423" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">[4] Freepick，<em class="nw"> Bot免费图标【https://www.flaticon.com/free-icon/bot_1786548?】<br/><a class="ae nt" href="https://www.flaticon.com/free-icon/bot_1786548?term=bot%20avatar&amp;page=1&amp;position=1&amp;page=1&amp;position=1&amp;related_id=1786548&amp;origin=search" rel="noopener ugc nofollow" target="_blank">term = bot % 20 avatar&amp;page = 1&amp;position = 1&amp;page = 1&amp;position = 1&amp;related _ id = 1786548&amp;origin = search</a></em></p><p id="3450" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">【5】自由选择，<em class="nw">男人自由图标</em>【https://www.flaticon.com/premium-icon/man_2202112?】<br/><a class="ae nt" href="https://www.flaticon.com/premium-icon/man_2202112?term=avatar&amp;page=1&amp;position=2&amp;page=1&amp;position=2&amp;related_id=2202112&amp;origin=search" rel="noopener ugc nofollow" target="_blank">term =头像&amp;page = 1&amp;position = 2&amp;page = 1&amp;position = 2&amp;related _ id = 2202112&amp;origin = search</a></p><p id="156b" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">6 a .里贝罗。"<em class="nw">用亚马逊Lambda和API网关构建无服务器API</em>"<br/><a class="ae nt" rel="noopener" target="_blank" href="/build-a-serverless-api-with-amazon-lambda-and-api-gateway-dfd688510436">https://towardsdatascience . com/Build-a-server less-API-with-Amazon-Lambda-and-API-Gateway-DFD 688510436</a></p><p id="a8f0" class="pw-post-body-paragraph mj mk it lo b lp mw ju ml lr mx jx mm lt my mo mp lv mz mr ms lx na mu mv lz im bi translated">7 a .里贝罗。"<em class="nw">使用AWS Lambda和EventBridge部署一个“RemindMe”Reddit Bot</em>"<br/><a class="ae nt" rel="noopener" target="_blank" href="/build-a-q-a-app-with-pytorch-cb599480e29">https://towardsdatascience . com/build-a-q-a-app-with-py torch-CB 599480 e29</a></p></div></div>    
</body>
</html>