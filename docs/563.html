<html>
<head>
<title>Where does python get its random numbers from?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">python的随机数是从哪里来的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/where-does-python-get-its-random-numbers-from-81dece23b712#2022-01-19">https://towardsdatascience.com/where-does-python-get-its-random-numbers-from-81dece23b712#2022-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/db8cd9e8b193492675ead5dd6cf1554e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApApJllf65Em_KUtIEhEEw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">迪伦·诺尔特在<a class="ae jd" href="https://unsplash.com/s/photos/lottery?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""><h1 id="67fe" class="pw-post-title je jf jg bd jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc bi translated">python的随机数是从哪里来的？</h1></div><div class=""><h2 id="6b8e" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">现代伪随机数发生器及其新的NumPy实现的简单说明</h2></div><p id="9524" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在生成正态分布的数字样本时，我很好奇它们“从哪里来”——特别是计算机如何能够创建遵循选择分布的数字，无论是正态分布、指数分布还是更古怪的分布。无论创建这些正态分布值的方法是什么(<a class="ae jd" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" rel="noopener ugc nofollow" target="_blank">反转采样</a>、<a class="ae jd" href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform" rel="noopener ugc nofollow" target="_blank">博克斯-米勒</a>或快速的<a class="ae jd" href="https://en.wikipedia.org/wiki/Ziggurat_algorithm" rel="noopener ugc nofollow" target="_blank">金字形神算法</a>)，它们都始于一个基本构件:一系列<em class="lr">均匀分布的</em>值。</p><p id="fe69" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就引出了一个问题:这些是从哪里来的？在大多数情况下:从一个“伪随机数发生器”——或PRNG。注意到<a class="ae jd" href="https://numpy.org/devdocs/release/1.17.0-notes.html" rel="noopener ugc nofollow" target="_blank"> NumPy在2019年7月</a>改变了他们默认的PRNG以回应<a class="ae jd" href="https://numpy.org/neps/nep-0019-rng-policy.html" rel="noopener ugc nofollow" target="_blank">这个NEP </a>(尽管互联网上仍然充斥着旧的做法)我很想知道:</p><ul class=""><li id="4dc7" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">他们为什么要改变它</li><li id="8201" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">PRNGs最初是如何工作的</li></ul><p id="4436" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后用简单的英语写下我的想法，同时附上一些有用的图表和代码示例。这是这些笔记，主要由Melissa O'Neill的<a class="ae jd" href="https://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf" rel="noopener ugc nofollow" target="_blank">这篇</a>(非常容易理解)论文和<a class="ae jd" href="https://www.youtube.com/watch?v=45Oet5qjlms&amp;list=WL&amp;index=171&amp;t=364s" rel="noopener ugc nofollow" target="_blank">这篇</a>相关讲座指导，Melissa O ' Neill是2014年PRNG的PCG家族的作者，现在形成了NumPy的默认PRNG。</p><h2 id="2716" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">为什么是“伪”？</h2><p id="32b0" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">因为产生真正的随机性是很难的——对人类(试试你的运气<a class="ae jd" href="https://www.expunctis.com/2019/03/07/Not-so-random.html" rel="noopener ugc nofollow" target="_blank">这里</a>看看你怎么样)和机器都是如此。如果我们认为机器只是接受输入并根据我们给它们的指令产生输出，那么根据定义，输出将和输入一样随机。</p><p id="bf7d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有一些方法可以确保这种输入是“真正”随机的，这些方法主要涉及硬件来测量自然界中真正随机的东西(如大气噪声)，但通常我们用选定的(非随机)初始值来“播种”算法。即使我们使用发电机启动时的机器时间(作为整数)作为种子，这也不是100%随机的。然而，我们也许应该首先质疑是否值得追求真正的随机性。</p><h2 id="b053" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">我们想要“真正的随机性”吗？</h2><p id="6605" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">这要看上下文。如果我们认为随机性是可预测性的反义词，而可预测性是安全性的敌人，那么回答这个问题就容易多了。当我们使用随机数来生成用于安全(即加密)的密钥时，我们希望这些数字看起来尽可能随机，以最小化威胁的可能性。因此，在这种情况下，真正的随机数发生器是有用的。</p><p id="ca89" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在其他情况下，当涉及到生成模拟时，我们可能会有其他优先事项，抵消绝对零可预测性的愿望。我们可能对一个函数感到满意，当你知道初始值(或足够的序列)时，它是完全确定的和可预测的，当你:</p><ul class=""><li id="abfc" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">不知道起始值</li><li id="571c" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">实际上，知道“足够多”的序列是不可能的</li></ul><p id="9a91" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就引出了下一个问题:</p><h2 id="786f" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">PRNGs的哪些特性是理想的？</h2><p id="01d3" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated"><strong class="kx jh">速度、尺寸和再现性</strong></p><p id="4bab" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里没有什么特别的——我们想要的是能够快速生成大量可再现的随机数，并且不占用太多内存，特别是如果我们计划让它们在不同的线程中运行的话。</p><p id="95d5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">均匀性</strong></p><p id="8bd1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们知道生成的随机数将落在区间<code class="fe ne nf ng nh b">[0, n]</code>内，那么我们希望该区间内的每个数字都有均等的机会被选中——否则，即使理论上<em class="lr">和</em>我们有很多数字可以选择，但实际上这个数字会小得多。举个例子，如果我们在区间<code class="fe ne nf ng nh b">[0, 255]</code>中有可能的数字，但实际上我们的PRNG只选择了<code class="fe ne nf ng nh b">3</code>或<code class="fe ne nf ng nh b">250</code>，那么这根本不是随机的。另一方面，我们不一定想要一个保证一致性的算法。如果是这种情况，那么如果我们有一系列的<code class="fe ne nf ng nh b">n</code>号码可供选择，并且我们已经选择了<code class="fe ne nf ng nh b">n-1</code>号码，那么最终的号码根本不是随机的——它将仅仅是还没有被选择的号码。通过反向工作，我们可以看到，当我们到达范围的末端时，任何保证一致性的算法都将减少随机性，也称为“周期”。</p><p id="98cc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">一个长‘期’</strong></p><p id="68e2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们承认，为了让计算机生成一个序列，我们必须给它一个函数，将前一个数字转换成下一个数字，那么如果我们最终得到一个我们以前见过的数字，我们将开始重复这个序列。只要我们从一个有界区间中选择数字，这种情况就一定会发生，因为如果我们在<code class="fe ne nf ng nh b">[0, n]</code>中选择数字，那么根据定义，第<code class="fe ne nf ng nh b">n+1</code>个数字一定是之前一个数字的重复。换句话说，在适当大小的序列<strong class="kx jh">上，所有PRNGs都将复制，因此变得确定</strong>。为了防止这种情况，我们可以在这种情况发生之前使数字的数量(句点)比我们希望采样的数字序列的长度大得多。</p><p id="a578" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">图案缺失</strong></p><p id="65de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这似乎是显而易见的，但值得一提。例如，满足上述所有属性的一个好算法就是简单地“加1”:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/cb73407c8698c24ec631682cec92b187.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FjK1rrD-CjXmu53rVnIDEg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="f383" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将是:</p><ul class=""><li id="c413" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">惊人的快，小，可重复(我们只需要知道<code class="fe ne nf ng nh b">X_0</code>我们开始的价值)</li><li id="c213" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">统一:给定区间中的每个数字将被选择一次</li><li id="4ba7" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">长周期:只要我们不在某个值上“绕回”以确保数字大小不会变大，它就不会重复，即映射一个大数字，<code class="fe ne nf ng nh b">y</code>，回到零并重新开始</li></ul><p id="f83a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，前面的条件提供了伪随机算法表现为随机的能力，但并不能保证这一点——我们仍然需要一个好的算法，当你不知道初始条件时，它缺乏可预测性。</p><p id="11e8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一位很关键，如果您知道算法的“状态”(比如上一个随机数和将其转换为下一个随机数的函数)，所有PRNGs都是确定的。关键是，如果没有这些信息，数字就会显得随机——就像一只火鸡认为圣诞节是一只“黑天鹅”,而农民却不是(随机性是相对于你的信息集而言的)。</p><h2 id="56f9" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">lcg</h2><p id="0d55" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">线性同余生成器(lcg)是最古老的PRNGs之一，幸运的是非常容易理解。</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/93b47a7a8f14214af30aee17d6c8fe41.png" data-original-src="https://miro.medium.com/v2/format:webp/1*pta9JgL6rUIAyQUMsG1Phw.png"/></div></figure><p id="cb7d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，为了得到序列中的下一个数字，我们取前一个数字，然后:</p><ul class=""><li id="4533" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">乘以某个常数<code class="fe ne nf ng nh b">a</code></li><li id="e91d" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">添加一些其他常数<code class="fe ne nf ng nh b">c</code></li><li id="35b6" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">当我们除以其他常数时取余数<code class="fe ne nf ng nh b">m</code></li></ul><p id="05c5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，没有什么太“计算机科学y”的可怕的单词或短语，如“矩阵线性递归”或“梅森素数”。让我们为<code class="fe ne nf ng nh b">{a, c, m}</code>选择一些值，看看输出是什么样子。</p><p id="6b57" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">具体来说，让我们以非常简单的<a class="ae jd" href="https://en.wikipedia.org/wiki/Lehmer_random_number_generator" rel="noopener ugc nofollow" target="_blank"> Lehmer 1951发生器</a>的形式构成一个发生器- <code class="fe ne nf ng nh b">a=3</code>、<code class="fe ne nf ng nh b">c=0</code>，为了确保我们生成8位数字，让我们设置<code class="fe ne nf ng nh b">m=2^8=256</code>。这最后一位只是意味着数字将保持在<code class="fe ne nf ng nh b">[0, 255]</code>之间，因此适合8位。</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><pre class="ni nj nk nl gt np nh nq nr aw ns bi"><span id="8b3f" class="mg mh jg nh b gy nt nu l nv nw"><strong class="nh jh">3, 9, 27, 81, 243</strong>, 217, 139, 161, 227, 169, 251, 241, 211, 121, 107, 65, 195, 73, 219, 145, 179, 25, 75, 225, 163, 233, 187, 49, 147, 185, 43, 129, 131, 137, 155, 209, 115, 89, 11, 33, 99, 41, 123, 113, 83, 249, 235, 193, 67, 201, 91, 17, 51, 153, 203, 97, 35, 105, 59, 177, 19, 57, 171, 1, <strong class="nh jh">3, 9, 27, 81, 243</strong>, 217, 139, 161, 227, 169, 251, 241, 211, 121, 107, 65, 195, 73, 219, 145, 179, 25, 75, 225, 163, 233, 187, 49, 147, 185, 43, 129, 131, 137, 155, 209</span></pre><p id="f8a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么我们已经看到了什么问题呢？</p><ul class=""><li id="2ea6" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">所有的数字都是奇数，所以我们根本没有一致地接触到所有的数字(任何可观察到的模式都是随机性的对立面)</li><li id="b17c" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">这段时间很短——你可以看到我们在中途回到起点，然后开始重复自己</li></ul><h2 id="7852" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">如果lcg如此糟糕，那么这与今天的PRNGs有关系吗？</h2><p id="c429" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">因为lcg<em class="lr">不</em>可怕。上面的LCG <em class="lr">很糟糕，但这与作为一个数字生成器家族的LCG本身关系不大，而与我们参数化它的方式关系更大。事实上，下面的LCG被称为<code class="fe ne nf ng nh b">drand48</code>，并且是<code class="fe ne nf ng nh b">java.util.Random</code>的基础:</em></p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="333a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是与上面的LCG规范有一个关键的不同。</p><h2 id="ef05" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">不只是输出‘状态’，而是它的一个函数</h2><p id="5d21" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">在第一个例子中，我们只是生成了序列中的下一个数字并输出它。如果是<code class="fe ne nf ng nh b">255</code>，那么我们序列中的下一个数字是<code class="fe ne nf ng nh b">255</code>。别开玩笑了。在上面的LCG实现中，情况并非如此——我们有下面的<code class="fe ne nf ng nh b">yield seed &gt;&gt; 16</code>。在python中，这是一个按位运算符，将所有位向右移动16位，结果最右边的16位被丢弃。</p><p id="e887" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以举一个例子——如果我们有数字<code class="fe ne nf ng nh b">1017</code>，我们可以用二进制表示为<code class="fe ne nf ng nh b">11 1111 1001</code>(间距只是为了便于阅读)——如果我们做<code class="fe ne nf ng nh b">1017 &gt;&gt; 3</code>，那么我们最后得到<code class="fe ne nf ng nh b">111 1111</code>(也就是<code class="fe ne nf ng nh b">127</code>)，也就是说，我们将所有内容向右移动3位，并删除右边的前3位。这只是一个这样的函数，它展示了一种提高产量的方法。现在，我们的LCG算法有了以下设置:</p><ul class=""><li id="e071" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">生成序列中的下一个数字——这是LCG的“状态”(只是术语)</li><li id="1b99" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用“状态”生成“输出”——这是随后用于形成序列一部分的数字</li></ul><p id="c260" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是为什么我们可以有一个具有“8位输出”的“16位发生器”，因为发生器的“状态”是一个16位数字，但输出是一个8位数字，其中8位数字是通过对16位状态应用一些函数来创建的。正如我们将会看到的，创建具有不同输出状态的PRNGs可以极大地改善它们的统计特性。</p><h2 id="3c41" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">随机图表:可视化随机性</h2><p id="61a6" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">为了获得关于各种算法有多随机的一些直觉，我们需要一种方法来可视化这种随机性。为此，我们将再次借用梅丽莎·奥尼尔论文中的一个观点。实际上，随机数发生器比我们将要做的要大得多(64位状态，32位输出)，但以下是想法:</p><ul class=""><li id="3b0b" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">创建一个具有16位状态的生成器，即种子/状态在范围<code class="fe ne nf ng nh b">[0, 65535]</code>(其中上限为<code class="fe ne nf ng nh b">2**16-1</code>)内</li><li id="567a" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">输出一个从16位状态导出的8位数字——即输出序列中的每个数字都在<code class="fe ne nf ng nh b">[0, 255]</code>中</li><li id="681e" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">取序列并将相邻的点成对分组，即<code class="fe ne nf ng nh b">[x_0, x_1], [x_2, x_3], etc</code></li><li id="e753" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">这些对在一个256 x 256的图形中形成了<code class="fe ne nf ng nh b">{x, y}</code>坐标</li><li id="381c" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">使用PRNG生成<code class="fe ne nf ng nh b">2^16</code>坐标并绘制，如果没有配对坐标，则该坐标为白色，给定坐标上的配对越多，该坐标将越黑</li></ul><p id="d438" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在某种程度上，这将给我们一个很好的随机图像。如果我们有一个好的算法，我们会有一个有很多点的图，总体上看起来是随机的。通过一个例子就可以很容易地看出这一点。让我们用一个参数化好的“16位状态，8位输出LCG”画出几个“随机图”。</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/17df64a375235afd091c3e60a7db2473.png" data-original-src="https://miro.medium.com/v2/format:webp/1*VYerLo1lEbxZmq4ex4oQtA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="d187" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">左上角的图表显示了当我们取16位状态数中最右边的8位时得到的结果。例如，如果我们迭代的“状态”是用二进制表示为<code class="fe ne nf ng nh b">1111 1111 1000 0101</code>的数字<code class="fe ne nf ng nh b">65413</code>，那么我们将输出最右边的8位- <code class="fe ne nf ng nh b">1000 0101</code>(或<code class="fe ne nf ng nh b">133</code>)。我们对所有的数字都这样做，将它们成对分组并绘制出来。</p><p id="8957" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">我们可以看到，这些数字看起来一点也不随机——它们形成了整齐的直线。</strong>这是<a class="ae jd" href="https://en.wikipedia.org/wiki/Marsaglia's_theorem" rel="noopener ugc nofollow" target="_blank">马萨格里亚定理</a>，显示了当我们的周期太小时lcg的问题(因此得到像这样的重复值)。然而，随着我们向更高的16位状态发展，情况开始有所好转。在右下方的图表中仍然有一个清晰的结构，但我们在覆盖空间方面做得更好。</p><p id="3ac0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，当看到这一点时，我们可以做出如下观察:<strong class="kx jh">由LCG产生的16位状态数中的8位组越高，它们看起来越随机。</strong></p><h2 id="215e" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">输入PCG</h2><p id="2f5c" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">尽管lcg仍有广泛的实际用途，但它们不是2019年前NumPy的默认PRNG。相反，在NumPy 1.17之前，使用了一种叫做<a class="ae jd" href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="noopener ugc nofollow" target="_blank">梅森扭扭器</a>的算法——具体来说是mt 19937——因为其周期长度(绝对巨大)是一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Mersenne_prime" rel="noopener ugc nofollow" target="_blank">梅森素数</a>(<code class="fe ne nf ng nh b">2**19937 - 1</code>-2的负1次方)而得名。然而，随着1.17 NumPy版本的发布，它切换到默认PRNG是一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Permuted_congruential_generator" rel="noopener ugc nofollow" target="_blank"> PCG - <em class="lr">置换</em>(线性)同余发生器</a>。</p><p id="6da2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PCG是Melissa O'Neill创建的一个生成器家族，它巧妙地利用了上面的观察结果——尤其是图表。想法是这样的:</p><ul class=""><li id="9048" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">输出状态的函数，而不是直接输出状态，似乎增加了随机性</li><li id="5b4f" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">lcg在低位(左上图)明显缺乏随机性，但高位往往“更随机”(右下图)</li><li id="4feb" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">例如，如果我们有一个输出8位数的16位状态，那么我们只需要选择8位来输出</li><li id="721b" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">为什么我们不使用16位状态中最随机的前几位来选择将哪个函数应用于16位状态的其余部分，以生成8位输出</li><li id="7f85" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">换句话说，让我们使用我们状态中最随机的部分来随机选择一个变换函数应用于状态的其余部分——一种随机的排序算法</li></ul><p id="55c4" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个简单的例子。</p><h2 id="3849" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">PCG的</h2><p id="8ae9" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">上述9个图表执行以下操作:从16位状态计算8位输出，其中8位输出是通过预定的位移(从左上0到右下8)生成的。但是，如果不是固定的换档，而是随机的换档呢？</p><p id="7e0d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们从哪里得到这种随机性？从我们16位状态的最高几位开始。换句话说，如果我们有一个状态<code class="fe ne nf ng nh b">57277</code> ( <code class="fe ne nf ng nh b">1101 1111 1011 1101</code>)，我们可以:</p><ul class=""><li id="bf89" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">使用最高的2位<code class="fe ne nf ng nh b">11</code>来确定移位，在本例中为3</li><li id="0c8d" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">将此移位应用于其他位，<code class="fe ne nf ng nh b">01 1111 1011 1101</code> s.t .我们不是选择<em class="lr">最左边的</em> 8位，<code class="fe ne nf ng nh b">0111 1110</code>，而是将3向右移位并选择位<code class="fe ne nf ng nh b">1111 0111</code></li></ul><p id="9ef9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在某种程度上，我们在查看上述9个图表时所做的是使用8–15，9–16图的随机性来随机选择我们是否从<code class="fe ne nf ng nh b">{4-11}</code> - <code class="fe ne nf ng nh b">{7-14}</code>图中选择一个数字。让我们看看这个是什么样子的:</p><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/4e4cb0853aefebb713b6be2fc785ef32.png" data-original-src="https://miro.medium.com/v2/format:webp/1*HsK8ydJKV2_5zhOVng39Vw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="f60f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很明显，仍然有一些结构，但通过简单地取16位状态的最高2位，并使用它来选择状态其余部分的置换，改进是巨大的——因此命名为置换(线性)同余生成器。但这仅仅是一种这样的转换——位移。</p><p id="24f8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其他变形呢？有大量的变换(异或、旋转等)可用于创建PCG族，其中高位随机选择哪种排列应用于线性生成的状态。让我们来看另外两种可以使用的排列。</p><h2 id="04c6" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">旋转</h2><p id="1cf0" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">我们可以(随机)选择的一种变换是比特的“旋转”。就像前面的<code class="fe ne nf ng nh b">&gt;&gt;</code>操作符一样，我们将位向右移动并丢弃溢出，通过旋转，我们移动一个方向，但不是丢弃溢出，而是将溢出带到另一侧。</p><p id="e590" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们有数字<code class="fe ne nf ng nh b">113</code>，用二进制表示为<code class="fe ne nf ng nh b">111 0001</code>，我们可以执行<code class="fe ne nf ng nh b">2</code>的“右旋转”来创建<code class="fe ne nf ng nh b">011 1100</code>或<code class="fe ne nf ng nh b">60</code>。这里，我们将最右边的2位(<code class="fe ne nf ng nh b">01</code>)旋转到最开始的位置，并将所有内容下移。</p><h2 id="0618" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">xorshift</h2><p id="5b74" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">我们可以应用的另一种变换是“xorshift”。还是那句话，我们用同一个例子来说明。再次采取<code class="fe ne nf ng nh b">113</code> ( <code class="fe ne nf ng nh b">111 0001</code>)我们可以:</p><ul class=""><li id="87b8" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">将其下移一个量，例如2，得到<code class="fe ne nf ng nh b">001 1100</code></li><li id="e11f" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">将<a class="ae jd" href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR" rel="noopener ugc nofollow" target="_blank">按位异或</a>函数应用于原始数字和移位后的数字</li></ul><p id="2273" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，我们将对<code class="fe ne nf ng nh b">111 0001</code>和<code class="fe ne nf ng nh b">001 1100</code>计算<code class="fe ne nf ng nh b">xor</code>(或者python中的<code class="fe ne nf ng nh b">^</code>)以获得<code class="fe ne nf ng nh b">110 1101</code>(当只有1位为1时为1，如果两者都为1或0，则为0)。</p><h2 id="0158" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">PCG XSH-RS和PCG XSH-RR</h2><p id="d8e7" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">现在让我们看看两种常见PCG的随机曲线图，看看它们与上面的相比如何。它们是:</p><ul class=""><li id="3fc8" class="ls lt jg kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">PCG XSH-RS:首先计算一个xorshift操作，然后随机地<em class="lr">移位</em>结果位</li><li id="bed3" class="ls lt jg kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">PCG XSH-RR:首先计算一个xorshift操作，然后随机地<em class="lr">旋转</em>结果位</li></ul><figure class="ni nj nk nl gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="ab gu cl nm"><img src="../Images/aea7a0b09cb52c0bb100ba5bfe1b7a42.png" data-original-src="https://miro.medium.com/v2/format:webp/1*jbzArJ5hCkX6cTO8MrLJiA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="2007" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，仍然有结构，但他们是一个显著的进步。这种结构的存在是因为我们使用的是“小型”发电机。正如16位状态的高8位比低8位更随机一样，32位状态的高16位比低8位更随机。当我们使用越来越大的状态时，我们自然会增加周期。<strong class="kx jh">将这两者结合在一起就是为什么即使是非常大的(96位状态，32位输出)lcg也能通过</strong> <a class="ae jd" href="https://en.wikipedia.org/wiki/TestU01" rel="noopener ugc nofollow" target="_blank"> <strong class="kx jh">大碾压</strong></a><strong class="kx jh"/>——Pierre L ' e cuyer和Richard Simard打包的一组广泛的统计测试，用于测试PRNGs是否具有前面提到的理想特性。</p><p id="9088" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给定随机选择的排列的附加随机性，PCG的性能比lcg好得多，因此不需要如此大的状态来通过测试套件。正是因为这个原因，它们被作为NumPy中的默认PRNG——确切的算法是PCG XSL RR 128/64。</p></div></div>    
</body>
</html>