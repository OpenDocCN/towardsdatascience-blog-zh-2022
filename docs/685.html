<html>
<head>
<title>Runtime Introspection: Julia’s Most Powerful, Best-Kept Secret</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运行时自省:Julia最强大、保守得最好的秘密</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/runtime-introspection-julias-most-powerful-best-kept-secret-bf845e282367#2022-01-24">https://towardsdatascience.com/runtime-introspection-julias-most-powerful-best-kept-secret-bf845e282367#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="2616" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">运行时自省:Julia最强大、保守得最好的秘密</h1></div><div class=""><h2 id="cc45" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Julia中使用内省处理类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e5a95d4122d0ff53cadb6ae78cf14d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUs9gtIZEJlivTdo3MDWjA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-3118729/" rel="noopener ugc nofollow" target="_blank"> Skitterphoto </a>拍摄)</p></figure><h1 id="33dc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="f89f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当谈到最终执行您的代码时，我们经常使用的许多高级编程语言都没有提供很多工具来允许人们在执行时查看语言。当然，我们可以打印值，我们可以有一些输出来告诉我们代码是否工作，但是在执行时使用已定义的类型和名称要困难得多。我的意思是这是有意义的，这不是一个人通常想在执行过程中做的事情，到处剖析类型和定义的字段——在大多数情况下，这根本不值得。</p><p id="4b63" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，虽然在大多数情况下，自省对你来说可能是不必要的，但对你的语言的编译器来说，为了更好地理解正在发生的事情以及你的环境，自省是必要的。也就是说，在某些情况下，人们可能与编译器一起工作，或者像编译器一样控制作用域。此外，在Julia中进行元编程时，自省可以产生非常有效的效果。尽管在Julia文档中可以获得这方面的信息，但它是在Julia的<strong class="lt iu">开发者文档</strong>中，而不是常规文档中。也就是说，我的假设是，大多数使用Julia的人不会开发这种语言本身，但肯定会在他们使用这种语言的某个时候利用自省，因为我认为这是这种语言在许多不同的应用程序中可以做的一件有价值的事情。也就是说，如果你更愿意阅读文档而不是我对这些特性的解释，这里有一个Julia文档的链接:</p><div class="ms mt gp gr mu mv"><a href="https://docs.julialang.org/en/v1/devdocs/reflection/" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">反思和自省</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Julia提供了多种运行时反射功能。模块的导出名称可使用…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">docs.julialang.org</p></div></div></div></a></div><p id="5a72" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，对于那些想要自己运行这些示例的人来说，我在这个小概述中使用的代码是笔记本格式的:</p><div class="ms mt gp gr mu mv"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/runtime%20introspection.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">Emmetts-DS-NoteBooks/runtime introspection . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">github.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="3bf3" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">数据类型</h1><p id="48b6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于数据类型，我们需要了解的第一件事是，在Julia中，它们有称为“字段”的属性。我们可以检查任何给定类型或数据类型的字段。当然，字段有几种不同的属性，但是最重要的两种是字段名和它们的类型。我们可以通过使用同名的方法来获取字段名，</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="7b99" class="ob la it nx b gy oc od l oe of">mutable struct Noodle<br/>    class::Symbol<br/>    length::Integer<br/>end</span><span id="bbb6" class="ob la it nx b gy og od l oe of">fieldnames(Noodle)</span><span id="245f" class="ob la it nx b gy og od l oe of">(:class, :length)</span></pre><p id="e0d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将返回一个表示该类型中每个字段名的符号元组。在Julia中，你定义的所有东西都有一个对应的符号。也就是说，也有一些符号对应于在你的全球环境中创造的每一个价值。我们还可以使用getfield()和setfield来获取和设置字段！()然而，有许多情况下setfield！()是行不通的。每当我们使用。，例如</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="6ab8" class="ob la it nx b gy oc od l oe of">Noodle.class</span></pre><p id="628a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们实际上是在调用getfield方法。如果我们使用</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="7823" class="ob la it nx b gy oc od l oe of">Noodle.class = :spaghet</span></pre><p id="779b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后我们调用setfield方法。我们可以从模块和类型中获取字段。例如，我们可以从main获得一个:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="3717" class="ob la it nx b gy oc od l oe of">getfield(Main, :Noodle)</span><span id="618a" class="ob la it nx b gy og od l oe of">Noodle</span></pre><blockquote class="oh oi oj"><p id="4ff1" class="lr ls ok lt b lu mn ju lw lx mo jx lz ol mp mc md om mq mg mh on mr mk ml mm im bi translated">Main只是Julia中顶层全局模块的名字。</p></blockquote><p id="1455" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，Julia中任何类型的参数或数据的一个重要组成部分是它的类型。我们可以使用fieldtypes()方法或者只使用。添加到Julia中每个类型的类型字段。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="46c1" class="ob la it nx b gy oc od l oe of">fieldtypes(Noodle)<br/>(Symbol, Integer)</span><span id="7f11" class="ob la it nx b gy og od l oe of">Noodle.types<br/><br/>svec(Symbol, Integer)</span></pre><h1 id="6612" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">子类型</h1><p id="3e03" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">尽管它们不太适合运行时，但在自省给定模块的类型层次结构的组件时，它们仍然很有价值。我们可以通过使用子类型操作符<code class="fe oo op oq nx b">&lt;:</code>来识别一个类型是否是某物的子类型。此运算符既用于表示类型在其定义中使用时是抽象类型的子类型，也用于返回一个布尔值，表明所提供的类型是否是抽象类型的子类型。首先，让我们看看如何设置子类型:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="52c8" class="ob la it nx b gy oc od l oe of">abstract type Pasta end</span><span id="c0b9" class="ob la it nx b gy og od l oe of">struct Spaghet &lt;: Pasta<br/>    length::Integer<br/>end</span></pre><p id="3ffd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个新的Spaghet类型将继承应用于Pasta类型的任何方法。我们现在还可以使用相同的语法来了解Spaghet实际上是否是Pasta的子类型，这将是正确的:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="f60e" class="ob la it nx b gy oc od l oe of">Spaghet &lt;: Pasta</span><span id="8c17" class="ob la it nx b gy og od l oe of">true</span></pre><p id="0071" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还可以通过使用subtypes()方法获得给定抽象类型的所有子类型:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="82a6" class="ob la it nx b gy oc od l oe of">subtypes(Pasta)<br/>1-element Vector{Any}:<br/> Spaghet</span></pre><p id="ea1f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你没有接触过朱利安式的等级制度，我有一整篇文章可以更详细地介绍:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/overview-abstract-super-type-heirarchies-in-julia-26b7e64c9d10"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">概述Julia中的抽象超类型层次结构</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Julia的酷类型抽象介绍！</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="or l ng nh ni ne nj ks mv"/></div></div></a></div><p id="ef01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，这里有一个子类型树函数，它对于更好地可视化子类型也很有价值。我只是在这里的某个问题上发现了这一点，但我认为对于那些可能想更好地掌握某个类型的人来说，这绝对是非常好的:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="5b6a" class="ob la it nx b gy oc od l oe of">function subtypetree(t, level=1, indent=4)<br/>           level == 1 &amp;&amp; println(t)<br/>           for s in subtypes(t)<br/>             println(join(fill(" ", level * indent)) * string(s))<br/>             subtypetree(s, level+1, indent)<br/>           end<br/>       end</span><span id="594a" class="ob la it nx b gy og od l oe of">subtypetree(Number)</span><span id="a8b3" class="ob la it nx b gy og od l oe of">Number<br/>    Complex<br/>    Real<br/>        AbstractFloat<br/>            BigFloat<br/>            Float16<br/>            Float32<br/>            Float64<br/>        AbstractIrrational<br/>            Irrational<br/>        Integer<br/>            Bool<br/>            Signed<br/>                BigInt<br/>                Int128<br/>                Int16<br/>                Int32<br/>                Int64<br/>                Int8<br/>            Unsigned<br/>                UInt128<br/>                UInt16<br/>                UInt32<br/>                UInt64<br/>                UInt8<br/>        Rational</span></pre><h1 id="ff48" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在后台</h1><p id="9ec4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我想展示的最后几样东西是为了一些更深入的内省。对于我们的第一个例子，我们将查看@code_llvm宏，它只给出给定表达式的llvm代码:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="ee69" class="ob la it nx b gy oc od l oe of"><a class="ae ky" href="http://twitter.com/code_llvm" rel="noopener ugc nofollow" target="_blank">@code_llvm</a> subtypetree(Number)</span><span id="4412" class="ob la it nx b gy og od l oe of">;  @ In[16]:1 within `subtypetree`<br/>define nonnull {}* @japi1_subtypetree_2021({}* %0, {}** %1, i32 %2) #0 {<br/>top:<br/>  %3 = <strong class="nx iu">alloca</strong> {}**, align 8<br/>  <strong class="nx iu">store</strong> volatile {}** %1, {}*** %3, align 8<br/>  %4 = <strong class="nx iu">load</strong> {}*, {}** %1, align 8<br/>;  @ In[16]:2 within `subtypetree`<br/>  <strong class="nx iu">call</strong> void @j_subtypetree_2022({}* nonnull %4, i64 signext 1, i64 signext 4) #1<br/>  <strong class="nx iu">ret</strong> {}* inttoptr (i64 139868392615944 to {}*)<br/>}</span></pre><p id="6635" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一个很酷的类似的小宏是@code_typed。这与Meta有相似的用法。@lower，在大多数情况下，我认为这可能是一个更好的选择，除非我们想要获取的信息是一个单独的方法调用，例如，这是行不通的:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="18a8" class="ob la it nx b gy oc od l oe of"><a class="ae ky" href="http://twitter.com/code_typed" rel="noopener ugc nofollow" target="_blank">@code_typed</a> debuginfo = :source begin<br/>    +(1, 1, 5)<br/>    -(7, 3)<br/>end</span><span id="ac35" class="ob la it nx b gy og od l oe of">expression is not a function call, or is too complex for @code_typed to analyze; break it down to simpler parts if possible. In some cases, you may want to use Meta.@lower.</span></pre><p id="6223" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相比Meta。@较低:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="c875" class="ob la it nx b gy oc od l oe of">Meta.<a class="ae ky" href="http://twitter.com/lower" rel="noopener ugc nofollow" target="_blank">@lower</a> begin<br/>    +(1, 1, 5)<br/>    -(7, 3)<br/>end</span><span id="1d40" class="ob la it nx b gy og od l oe of">:($(Expr(:thunk, CodeInfo(<br/>    @ In[24]:2 within `top-level scope`<br/>1 ─      1 + 1 + 5<br/>│   @ In[24]:3 within `top-level scope`<br/>│   %2 = 7 - 3<br/>└──      return %2<br/>))))</span></pre><p id="be3b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于自省，我想分享的最后一件事是varinfo()方法。这种方法很棒，因为它可以说明不同类型的记忆的用法，也可以很好地描述我们的环境中有什么。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="acc7" class="ob la it nx b gy oc od l oe of">varinfo()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/94bb004b4005493b4aa674866834ed11.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*KYZPu8IlG5WfVLDsR122Ug.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="a1bb" class="kz la it bd lb lc nr le lf lg ns li lj jz nt ka ll kc nu kd ln kf nv kg lp lq bi translated">结论</h1><p id="f626" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">自省是编程语言的一个重要方面。当我们处理那些我们可能并不真正了解字段的类型时，这真的很方便。我认为，当我们使用动态类型语言时，情况更是如此。此外，对于不允许我们监视或控制内存和其他硬件组件的高级语言来说，在许多情况下尽可能多地使用内省确实很有意义。我认为朱利安的内省方法在大多数情况下是非常恰当的，我可能在内省方面使用最多的是varinfo()方法。了解事情占用了多少内存真是太好了，尤其是在开发自己的包的时候。感谢您阅读我的文章，我真的很感激，我希望这篇概述有助于阐明一些更好的控制Julia语言的方法！</p></div></div>    
</body>
</html>