<html>
<head>
<title>The Newest Package for Instantly Validating ML Models — Deepchecks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于即时验证ML模型的最新包— Deepchecks</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-newest-package-for-instantly-evaluating-ml-models-deepchecks-d478e1c20d04#2022-01-13">https://towardsdatascience.com/the-newest-package-for-instantly-evaluating-ml-models-deepchecks-d478e1c20d04#2022-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="49dc" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">用于即时验证ML模型的最新包— Deepchecks</h1></div><div class=""><h2 id="7fd6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Deepchecks是一个ML套件，用于验证Scikitlearn模型的性能。它与内置的Scikitlearn解决方案相比如何？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/24c860c148d02db15fed06893988b012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3sslPNZ3Q2NPJ6N5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·利维拉尼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ca03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ML模型的模型验证，尤其是在生产环境中的模型验证，一直是并且很可能将继续是机器学习研究中最困难的子课题之一。毫不奇怪，有许多初创公司、研究人员和大型科技公司投入资源来完善这个持续存在的问题。</p><p id="30c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一家公司Deepchecks刚刚开源了他们的<a class="ae ky" href="https://docs.deepchecks.com/en/stable/examples/guides/quickstart_in_5_minutes.html" rel="noopener ugc nofollow" target="_blank">机器学习验证工具</a>。该工具使用简单，可以在任何Scikitlearn模型上工作。</p><p id="7db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很棒，但是Scikitlearn提供了大量用于模型验证的内置工具。值得转行吗？</p><p id="ba05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这个套件，我设置了一个相当简单的玩具问题。给定下面的数据帧模式和550个样本，我想预测列<em class="lv">被浪费了</em></p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ea37" class="mb mc it lx b gy md me l mf mg">Index: CustomerID<br/>LoanPayoffPeriodInMonths           object<br/>LoanReason                         object<br/>RequestedAmount                     int64<br/>InterestRate                       object<br/>Co-Applicant                       object<br/>YearsAtCurrentEmployer             object<br/>YearsInCurrentResidence             int64<br/>Age                                 int64<br/>RentOrOwnHome                      object<br/>TypeOfCurrentEmployment            object<br/>NumberOfDependantsIncludingSelf     int64<br/>CheckingAccountBalance             object<br/>DebtsPaid                          object<br/>SavingsAccountBalance              object<br/>CurrentOpenLoanApplications         int64<br/>WasTheLoanApproved                 object</span></pre><p id="7397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我设置了一个故意不完美的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">随机森林分类器</a>来解决这个问题，使用一些简单的参数调整，比如最小成本复杂性修剪，以及80/20的训练/测试分割。这个模型是故意不优化的，以评估发现常见问题的容易程度。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="1af1" class="mb mc it lx b gy md me l mf mg">X = df[df.columns.values[:-1]]<br/>Y = df["WasTheLoanApproved"]<br/>X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)<br/>clf=RandomForestClassifier(n_estimators=100, ccp_alpha=0.008)<br/>clf.fit(X_train,y_train)<br/>y_pred=clf.predict(X_test)<br/>y_pred_train=clf.predict(X_train)</span></pre><h2 id="f2b7" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">scikit学习简单验证</h2><p id="321c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我已经训练好了我的简单模型，我可以使用Scikitlearn提供的一些简单的验证技术来识别我的模型的性能。我将查看我的训练与测试准确性、我的精确度、回忆和F1分数，以及我的特征重要性。下面是这样做所需的代码行:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="c682" class="mb mc it lx b gy md me l mf mg">#Let us look at train and test accuracy<br/>print("Accuracy Train:",metrics.accuracy_score(y_train, y_pred_train))<br/>print("Accuracy Test:",metrics.accuracy_score(y_test, y_pred))<br/>print(classification_report(y_test, y_pred))<br/>#and feature importance<br/>feature_imp = pd.Series(clf.feature_importances_,index=df_num.columns.values[:-1]).sort_values(ascending=False)<br/>#A chart<br/>sns.barplot(x=feature_imp, y=feature_imp.index)<br/>plt.xlabel('Feature Importance Score')<br/>plt.ylabel('Features')<br/>plt.title("Visualizing Feature Importance")<br/>plt.legend()<br/>plt.show()</span></pre><p id="87b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不错，在10行代码中，我能够得到以下结果:(如果你需要复习下面的分数，我推荐<a class="ae ky" href="https://medium.com/@kohlishivam5522/understanding-a-classification-report-for-your-machine-learning-model-88815e2ce397" rel="noopener">这篇中等文章</a>，或者如果你想要完整的课程，我推荐<a class="ae ky" href="https://datasciencedojo.com/python-for-data-science/?ref=jdibattista3" rel="noopener ugc nofollow" target="_blank">数据科学道场</a>)</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d05f" class="mb mc it lx b gy md me l mf mg">Accuracy Train: 0.7985436893203883<br/>Accuracy Test: 0.7184466019417476<br/>              precision    recall  f1-score   support<br/><br/>           0       0.50      0.31      0.38        29<br/>           1       0.76      0.88      0.82        74<br/><br/>    accuracy                           0.72       103<br/>   macro avg       0.63      0.59      0.60       103<br/>weighted avg       0.69      0.72      0.70       103</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/09f0520c7938d82319c58ca1c89d24d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*PhGgVm3okyPmimYc65dTLA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为解释这些结果非常容易——由于召回率低，0的F1分数非常低，这意味着在这个数据集中，它将许多0错误地标记为1。支持还表明数据集中1的实例比0的多得多，但这可能是也可能不是问题。特征重要性图看起来不错，表明似乎没有一个支配性特征控制分类器。一个有经验的ML工程师可以利用这些信息，推断出我们有一个不平衡的分类，并且可能需要尝试对0和1的比率进行更均匀的子采样，以获得更好的模型，但是这个结果可能不是每个人都清楚的。</p><h2 id="3568" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">深度检查现成的验证</h2><p id="971d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Deepchecks的优势在于它允许任何人用很少的代码运行一套验证指标。您所要做的就是创建dataset对象，指定标签列、索引(如果有意义的话)和分类特征(推荐，不是必需的)。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ff9f" class="mb mc it lx b gy md me l mf mg">from deepchecks import Dataset<br/>from deepchecks.suites import full_suite<br/>ds_train = X_train.merge(y_train, left_index=True, right_index=True)<br/>ds_test = X_test.merge(y_test, left_index=True, right_index=True)<br/>ds_train = Dataset(ds_train, label="WasTheLoanApproved", cat_features=["TypeOfCurrentEmployment", "LoanReason", "DebtsPaid"])<br/>ds_test =  Dataset(ds_test,  label="WasTheLoanApproved", cat_features=["TypeOfCurrentEmployment", "LoanReason", "DebtsPaid"])<br/>suite = full_suite()<br/>suite.run(train_dataset=ds_train, test_dataset=ds_test, model=clf)</span></pre><p id="b414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在8行代码中，该套件对我的数据集运行了30多次检查。这些检查分为4个主要类别:<a class="ae ky" href="https://docs.deepchecks.com/en/stable/examples/checks/distribution/index.html" rel="noopener ugc nofollow" target="_blank">数据分布</a>(我的测试数据是否与我的训练数据相似)<a class="ae ky" href="https://docs.deepchecks.com/en/stable/examples/checks/integrity/index.html" rel="noopener ugc nofollow" target="_blank">数据完整性</a>(我的数据中是否有可能导致问题的错误值)<a class="ae ky" href="https://docs.deepchecks.com/en/stable/examples/checks/methodology/index.html" rel="noopener ugc nofollow" target="_blank">方法</a>(我的训练/测试集大小是否正确且没有泄漏)<a class="ae ky" href="https://docs.deepchecks.com/en/stable/examples/checks/performance/index.html" rel="noopener ugc nofollow" target="_blank">性能</a>(相当明显——我的模型是否表现良好)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/3eefb46a49781ac184722400272ab640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CK5RXhKFyedJbdKaAeyO4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="468d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是条件总结，可以看出，这是一个非常强大的验证工具。这不仅提供了与我运行的几个Scikitlearn测试相似的结果，而且像数据完整性和数据漂移这样的问题也很容易被忽视，并需要大量的代码来测试。拥有一个可以单独检查这些内容的平台使它值得使用。</p><p id="3180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们回到我的模型。所有这些测试都已运行，当前型号只有两项检查未通过，两项检查都与性能相关。带有超链接的测试有相关的图表。让我们来看看失败的例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/fb3f5edf8f15ccd58058e59a7631c6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kkRkwAUY69iL_GRVeTWDwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="327b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">性能报告</em>故障告诉我，模型稍微过拟合。特别是当查看0类(贷款未批准)时，测试集精度下降非常显著。</p><p id="64a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">简单的模型比较</em>告诉我，当前模型的预测方式并不比每次只猜测一个常数“1”好多少。这是一个很大的问题，也是一个明显的信号，表明1在数据集中被过多地表示了。我可以通过查看我们的测试集ROC报告来确认这一点，由于我们错误地分类了我们代表不足的类，所以测试集的ROC报告只能勉强接受。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/4d8bbfa2150af1d7f418438a013069e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tzbm_N-8z4u7YoBesiwyGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者认为auc &lt; 0.7为失败|图片</p></figure><p id="c985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，这使我得出了与内置的Scikitlearn方法大致相同的结论，但是Deepchecks以一种更容易产生和理解的方式提供了这些信息。</p><h1 id="7dfa" class="nh mc it bd mh ni nj nk mk nl nm nn mn jz no ka mq kc np kd mt kf nq kg mw nr bi translated">改进/缺点</h1><p id="2eec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">既然我已经展示了这个测试套件的强大功能，我想深入了解一些我想看到的特性。其中一些更挑剔，但它们是我在整个平台中发现的弱点。</p><h2 id="d6c2" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">推断分类特征是不一致的</h2><p id="0867" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">文档指出，强烈建议显式声明任何分类特性，但是如果没有指定，平台可以尝试推断哪些是分类特性。目前的推断过程使用简单的启发式，在我的测试中，我发现这是不可靠的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/cce628069404c4e975a5677292cb144d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8sEZUfJ5ivXLXICk4XNJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试推断的分类特征|作者图片</p></figure><p id="4c62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，第一个问题是它不一定能检测到相同的分类特征。第二个问题是缺乏准确性。训练集确定了4个分类特征，其中只有1个实际上是分类的。我希望看到一种统计方法来代替这种启发式方法，以获得可能更好的结果。同时，在使用这个包时，请定义你的分类变量。</p><h2 id="bdb1" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">声明数据集类会变得更容易</h2><p id="2dc0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这属于吹毛求疵的范畴。第一个问题是声明一个索引。要声明一个索引(可以进行更多的数据完整性检查)，必须将索引设为一列(使用reset_index ),然后显式声明。如果有一个use_dataframe_index=True/False参数，可以轻松地绕过显式声明并使用数据帧本身的索引，这将是一个很好的改进。</p><p id="2e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个小的改进是能够分别传入X(输入)和Y(输出/预测)数据帧，而不是只接受带有显式声明标签的完整数据帧。这仅仅是因为这可以更好地匹配许多个人天生使用Scikitlearn的训练测试分割的方式。你可以在上面看到，我必须重新连接我的X和Y数据帧才能进入套件。</p><h2 id="0024" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">不一致的解释和解释资源</h2><p id="8086" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">很大一部分图表很好地解释了测试是什么，为什么它很重要，然后是一些外部文档来做进一步的解释。这在校准度量测试中很容易看出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f5fbe5d4cc4e2788d95dec9cf7261835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PK36br_SGpAcSrFb7LOZXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">校准度量测试|作者图片</p></figure><p id="f11c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这个原因，当图表/测试很少或没有解释时，我很失望，例如，ROC报告</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/18e3a26833f0bcd4a375e9698d1360a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ye1ePd6fQMp4fL8AGCdM5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="beff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为，对于最近才接触ML的人来说，这可能会导致信息过载的感觉，并且在出现问题时，对如何调试他们的模型缺乏指导。</p><h2 id="f61c" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">宽松的通过-失败开箱即用</h2><p id="8f5a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">开箱即用的套件预先调整了一些关于什么是“好”模型的宽松定义。就拿我算法的测试ROC来说吧。当然，测试通过了，但它几乎是失败的。如果没有进一步的调查，这可能会导致用户忽略可能需要解决的问题。如果有预定义的性能层(例如，“严格”模式)，它可能会抛出更多警告，让用户知道这不是一个确定的问题，但可能是值得考虑优化的问题。</p><p id="776c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个吹毛求疵的问题，因为Deepchecks已经通过实现<a class="ae ky" href="https://docs.deepchecks.com/en/stable/examples/guides/create_a_custom_suite.html" rel="noopener ugc nofollow" target="_blank">定制套件</a>部分解决了这个问题。对于众多测试中的任何一个，都可以调整性能边界和度量标准，从而允许对合格模型的构成进行微调。这个建议纯粹是作为单一开箱即用套件和完全定制模型之间的“中间地带”。</p><h2 id="77ea" class="mb mc it bd mh mi mj dn mk ml mm dp mn li mo mp mq lm mr ms mt lq mu mv mw mx bi translated">仅限于Scikitlearn</h2><p id="a9a6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果包可以处理不同的ML包就好了。比如NLP的Gensim，或者深度学习的TensorFlow。至少检测这些其他包中的数据漂移的能力是值得探索的。</p><h1 id="e878" class="nh mc it bd mh ni nj nk mk nl nm nn mn jz no ka mq kc np kd mt kf nq kg mw nr bi translated">结论</h1><p id="eb53" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个包虽然新，但非常棒，只会让机器学习模型评估变得更容易。手工运行所有这些测试需要数百行代码。将它简化为一个简单的函数调用将很容易地将这个包转移到一个我计划紧密集成到我的开发过程中的包中。我迫不及待地想用这个包来扩展过去的Scikitlearn并开发更复杂的见解。</p><p id="0530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢你所读的，请随意<a class="ae ky" href="https://jerdibattista.medium.com/" rel="noopener">跟随我</a>，阅读更多我写的东西。我倾向于每个月深入一个主题一次，这通常涉及新的包、技巧和窍门，或者ML空间中我认为需要更好解释的任何东西！</p><div class="nv nw gp gr nx ny"><a rel="noopener follow" target="_blank" href="/the-best-python-sentiment-analysis-package-1-huge-common-mistake-d6da9ad6cdeb"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">最好的Python情绪分析包(+1个巨大的常见错误)</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">如何在不训练自己模型的情况下获得近乎完美的性能</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">towardsdatascience.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div></div></div>    
</body>
</html>