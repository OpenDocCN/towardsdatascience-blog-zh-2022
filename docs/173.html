<html>
<head>
<title>SQL, Pandas, or Both: Analyzing the UK Electoral System with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL，Pandas，或两者兼而有之:用Python分析英国选举系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-pandas-or-both-analysing-the-uk-electoral-system-24fa01d33d05#2022-01-06">https://towardsdatascience.com/sql-pandas-or-both-analysing-the-uk-electoral-system-24fa01d33d05#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="0a79" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">SQL，Pandas，或两者兼而有之:用Python分析英国选举系统</h1></div><div class=""><h2 id="6e15" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python Pandas非常适合分析和绘制数据，但是您应该用Pandas还是SQL编写代码呢？让我们来看看使用两者的一些常见操作，并看看它们是如何比较的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6303504c8209b934e10a8924c808cb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZQY7byDdODfCReoi.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f7d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不是SQL专家。事实上，老实说，这是我在职业生涯的大部分时间里试图避免的两件事之一(另一件是Visual Basic)。但是有些人对使用R、Python或Pandas进行数据分析的想法嗤之以鼻，因为…嗯，这就是SQL的设计目的。</p><p id="4dd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SQL已经存在了很长时间——大约50年——并且仍然是关系数据库世界中事实上的查询语言。SQLite、MySQL、MariaDB和Postgresql等流行产品都是基于SQL的，高端企业系统Oracle和Microsoft SQL Server也是如此。</p><p id="650c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，如果你是一个做数据分析的Python程序员，你应该用Pandas还是SQL编写代码呢？</p><p id="70d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想使用Python对一些英国选举数据做一些分析，这需要我做一些相当普通和简单的分析任务。最初，我想弄清楚为什么英国政府在议会中拥有绝大多数席位，却只获得了相对较小比例的普选。</p><p id="2383" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我决定同时使用Pandas和SQL来看看我更喜欢哪个。我将描述我做了什么以及如何做的，你可以自己决定你认为哪种方法更好(或者，实际上，如何改进它们)。</p><p id="acf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进行分析，我们将使用来自英国2019年大选(最后一次)的数据，当我们比较SQL和Pandas时，我们也可以了解一点民主在英国是如何运作的。</p><p id="3e79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两个文件，一个CSV文件(供Pandas使用)和一个SQLite数据库——两者包含完全相同的数据。这些数据是公共记录，来自下议院图书馆保存的选举结果。这些数据可以在Open Parliament Licence 3.0下免费使用，我的节略版可以从我的Github repo免费下载。</p><p id="12d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里的兴趣是看看英国议会到底有多有代表性。鉴于目前的保守党政府获得了不到50%的选票，他们怎么会在下议院获得大约80%的多数席位呢？</p><h1 id="3cdd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">因第一个到达终点线而获胜</h1><p id="71d2" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">事实上，任何熟悉英国<em class="ms">得票最多者当选</em>投票制度的人可能都已经知道答案了。为便于投票，英国被划分为650个选区，每个选区为他们选择的候选人投票(这些候选人通常代表一个政党)，得票最多的候选人获胜。如果只有两个候选人，那么获胜者肯定获得了50%以上的选票。但通常情况并非如此。</p><p id="682a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数选区都有两个以上的候选人，所以如果投票结果很接近，获胜的候选人只比她的对手有一点点优势，那么这个候选人很可能只有不到50%的选票。我们可以用一个简单的例子来说明这一点:假设一个选区有5万张选票，其中5000张投给了绿党，1万张投给了自由民主党，1.5万张投给了工党，剩下的2万张投给了保守党。保守党以5000英镑的多数票获胜，并获得该选区的议会席位。但是他们只获得了40%的选票！</p><p id="2ba5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当这种情况在650个选区重复时，你可以看到在下议院拥有最多席位的政党可能不会得到大多数选民的支持。</p><p id="ea31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一制度的批评者认为这是一个根本性的弱点，他们更喜欢其他欧洲国家的比例制度。支持者称<em class="ms">第一个超过</em>第二个可以避免不可避免的联合政府的衰弱。</p><p id="9dc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，让我们不要担心政治，让我们弄清楚发生了什么，无论如何都要进行分析。</p><h1 id="5aa6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">原始数据</h1><p id="7108" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">正如我所说的，有两个相同的数据集，一个是SQLite数据库，另一个是CSV文件。SQLite是Python不可或缺的一部分，因此它非常适合这个练习，CSV文件可以很容易地导入到Pandas数据帧中。</p><p id="b062" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在一定程度上对数据进行了匿名处理，因为我删除了当选议员的姓名以及他们所代表的选区的名称——这与个人或该国的地区无关，而只是关于数字是如何累加的。</p><p id="1724" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些表包含以下列:</p><ul class=""><li id="7fdd" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">ons_id:选区的标识符</li><li id="c138" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">结果:获胜的一方，以及它是新的胜利还是“保留”</li><li id="0410" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">第一方:获胜的一方</li><li id="54fa" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">第二党:第二大党</li><li id="8944" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">选民:选民的数量</li><li id="71a1" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">valid_votes:有效票数</li><li id="ee0b" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">invalid_votes:无效票数</li><li id="ed76" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">多数票:获胜者和亚军之间的票数差异</li><li id="e84e" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">保守党、工党、工党、英国退出欧盟党、绿党、苏格兰国民党、社会党、民主统一党、社会党、统一党、联盟党、其他:各党派及其投票份额</li></ul><p id="987e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了加载数据，我们使用下面的代码。</p><p id="f8a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于CSV文件:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="3325" class="nm lw it ni b gy nn no l np nq">import pandas as pd<br/>election_df = pd.read_csv('elections.csv')</span></pre><p id="96d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于数据库:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9102" class="nm lw it ni b gy nn no l np nq">import sqlite3 as sql<br/>conn = sql.connect('elections.db')</span></pre><p id="9588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这给了我们两种形式的数据集。</p><p id="456f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们这样做</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="d178" class="nm lw it ni b gy nn no l np nq">election_df.head(4)</span></pre><p id="c9a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到它的样子。这是局部视图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/6b9823c774aade64ce2b61811b322b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_K2UjtCmZIdo0QGm.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9d36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进行分析，我们想知道每个政党的投票数。所以第一件要做的事情就是找出所有赢得下议院席位的政党的名字。我们首先从专栏<em class="ms"> first_party </em>中获取所有获胜者的列表。</p><p id="dfb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用熊猫，我们只需这样做:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="f4ef" class="nm lw it ni b gy nn no l np nq">election_df['first_party']</span></pre><p id="d5b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以把这个表达式赋给一个变量，这样我们就有了所有赢家的列表。</p><p id="a489" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何用SQL做到这一点？</p><p id="f167" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一件事是构造一个SQL查询，然后执行它。您可以看到下面的查询是一个字符串。我们首先使用<code class="fe ns nt nu ni b">SELECT</code>关键字声明我们感兴趣的字段(<code class="fe ns nt nu ni b">first_party</code>)，然后在<code class="fe ns nt nu ni b">FROM</code>子句中声明包含该字段(<code class="fe ns nt nu ni b">elections</code>)的表。我们使用前面从数据库文件创建的连接来执行它。这将返回一个游标，我们可以用它来检索包含我们的数据的行。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1b5e" class="nm lw it ni b gy nn no l np nq">query = """<br/>    SELECT first_party <br/>    FROM elections<br/>"""<br/>cur = conn.execute(query)<br/>rows = cur.fetchall()</span></pre><p id="9230" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">名单现在在<code class="fe ns nt nu ni b">rows</code>。不太像熊猫那么简洁。</p><p id="1d05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们的名单中有很多重复的地方，因为同一个政党可能赢得了很多席位。因此，我们想要的是这份获奖名单中的独特价值，对于熊猫来说，这很简单:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0126" class="nm lw it ni b gy nn no l np nq">partiesdf = election_df['first_party'].unique()</span></pre><p id="c5f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只是使用<code class="fe ns nt nu ni b">unique()</code>方法过滤结果，这就是我们分配给变量<code class="fe ns nt nu ni b">partiesdf</code>的内容。</p><p id="8928" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在SQL中，我们在查询中使用<code class="fe ns nt nu ni b">DISTINCT</code>关键字来产生相同的结果。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="88d8" class="nm lw it ni b gy nn no l np nq">query = """<br/>    SELECT DISTINCT first_party <br/>    FROM elections<br/>"""<br/>cur = conn.execute(query)<br/>rows = cur.fetchall()<br/>partiesdb = rows</span></pre><p id="cd18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这段代码中，我们将结果赋给了变量<code class="fe ns nt nu ni b">partiesdb</code>。</p><p id="0643" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，我们用这两种技术得到的结果并不完全相同。对于Pandas版本，结果是一系列单值，而对于SQL查询，结果是一个元组列表。这样做的原因是，虽然我们将只从Pandas获得单个值的列表，但我们可以在SQL <code class="fe ns nt nu ni b">SELECT</code>语句中指定多个值，因此结果必须是一个潜在的多个值的列表。只要我们意识到差异，这并不是什么大不了的事情，也就是说，我们将使用Pandas系列的每个单独的元素，而在SQL版本中，我们感兴趣的是每个列表元素中元组的第一个值。我们的Python代码也会相应调整。</p><p id="e296" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是熊猫的版本:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2b96" class="nm lw it ni b gy nn no l np nq">['Lab', 'Con', 'SNP', 'PC', 'LD', 'DUP', 'SF', 'SDLP', 'Green','Spk', 'Alliance']</span></pre><p id="798c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从SQL中我们得到:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="1c04" class="nm lw it ni b gy nn no l np nq">[('Lab',), ('Con',), ('SNP',), ('PC',), ('LD',), ('DUP',), ('SF',), ('SDLP',), ('Green',), ('Spk',), ('Alliance',)]</span></pre><p id="604f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">名单中的所有名字都是那些在英国议会中至少拥有一套席位的政党，只有代表下议院议长的<code class="fe ns nt nu ni b">Spk</code>除外。这位特殊的议员管理着众议院，被认为是中立的，通常不需要投票。因此，他或她不算党员。</p><p id="a8ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后我们将从我们的计算中移除扬声器。</p><p id="0d71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来我们要做的是找出每一方的获胜次数。每一个胜利都代表了下议院的一个席位，它们被记录在<code class="fe ns nt nu ni b">'first_party'</code>栏中。所以，对于熊猫，我们可以写:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="cdd4" class="nm lw it ni b gy nn no l np nq">election_df['first_party'] == 'lab'</span></pre><p id="b932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来获取工党的选举结果。就是这个:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="5396" class="nm lw it ni b gy nn no l np nq">0       True<br/>1      False<br/>2      False<br/>3      False<br/>4      False<br/>    ...  <br/>645     True<br/>646    False<br/>647    False<br/>648     True<br/>649    False<br/>Name: first_party, Length: 650, dtype: bool</span></pre><p id="6e62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以如果我们运行这段代码:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="0821" class="nm lw it ni b gy nn no l np nq">election_df[election_df['first_party']=='lab']</span></pre><p id="c799" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将获得工党所有胜利的列表，该列表的长度将代表他们获得的席位数。对我们之前创建的列表中的每个政党执行此操作，我们就可以获得每个政党赢得的席位总数。</p><p id="d1f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以这样做，将计数追加到一个空列表中，如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="92d1" class="nm lw it ni b gy nn no l np nq">partywinsdf = []</span><span id="b6da" class="nm lw it ni b gy nv no l np nq">for i in partiesdf:<br/>    partywinsdf.append(len(election_df[election_df['first_party']==i]))<br/>print(partiesdf)</span></pre><p id="84df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是一种更Pythonic化的方法是像这样使用列表理解:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4687" class="nm lw it ni b gy nn no l np nq">partywinsdf = [len(election_df[election_df['first_party']==i]) <br/>        for i in partiesdf]</span></pre><p id="f2ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果是每个政党的席位数列表。下面是派对列表，后面是我们创建的获胜名单(即席位)，如上所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="795d" class="nm lw it ni b gy nn no l np nq">['Lab' 'Con' 'SNP' 'PC' 'LD' 'DUP' 'SF' 'SDLP' 'Green' 'Spk' 'Alliance']<br/>[202, 365, 48, 4, 11, 8, 7, 2, 1, 1, 1]</span></pre><p id="9b1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从中可以看到，工党获得了202个席位，保守党获得了365个席位，苏格兰民族党(SNP)获得了48个席位，以此类推。</p><p id="36d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种使用Pandas的方法运行良好，但是它与SQL相比如何呢？下面是等效的SQL版本，再次使用Python的列表理解。大多数处理都在函数<code class="fe ns nt nu ni b">getWins(i)</code>中进行，该函数获取由<code class="fe ns nt nu ni b">i</code>表示的一方的获胜次数。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9561" class="nm lw it ni b gy nn no l np nq">def getWins(i):<br/>    query = f"""<br/>        SELECT * <br/>        FROM elections<br/>        WHERE first_party = '{i[0]}'<br/>    """<br/>    cur = conn.execute(query)<br/>    rows = cur.fetchall()<br/>    return(len(rows))</span><span id="2dac" class="nm lw it ni b gy nv no l np nq">partyWinsdb = [ getWins(i) for i in partiesdb]</span></pre><p id="14b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">真正的工作是由<code class="fe ns nt nu ni b">SELECT</code>语句完成的，该语句使用一个<code class="fe ns nt nu ni b">WHERE</code>子句来过滤选择，使得<code class="fe ns nt nu ni b">first_party</code>的值等于传递给该函数的参与方名称。请记住，在SQL版本中，参与方名称在元组中，因此参与方名称是<code class="fe ns nt nu ni b">i[0]</code>，元组的第一个(也是唯一的)元素。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="9218" class="nm lw it ni b gy nn no l np nq">SELECT * <br/>FROM elections<br/>WHERE first_party = '{i[0]}'</span></pre><p id="b45b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与Pandas版本相比，SQL语句的语法(至少从我的角度来看)在意图上比Pandas更清晰。话虽如此，它仍然相当冗长。</p><p id="635c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看图表形式的数据。为此，我们将使用Pandas绘图功能，因为这是最简单的制图方法之一。</p><p id="d490" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的熊猫专用版本是:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="db71" class="nm lw it ni b gy nn no l np nq">dfdf = pd.DataFrame(partywinsdf,partiesdf)<br/>dfdf.plot.bar(legend=False,title='Seat allocation per party')</span></pre><p id="d872" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SQL版本几乎完全相同:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="6a85" class="nm lw it ni b gy nn no l np nq">import pandas as pd<br/>dfdb = pd.DataFrame(partyWinsdb,partiesdb)<br/>dfdb.plot.bar(legend=False, title='Seat allocation per party')</span></pre><p id="6b72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从这两者中得到的图表是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/9f189add3215d40bff3edcea7763d2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/0*RCldHfSpfbL2agMh.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e6b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以从中看出，拥有最多议会席位的政党是保守党，比第二名工党多150个席位。苏格兰民族党(SNP)排在第二位，接下来是自由民主党、各种其他地区政党和绿党。</p><p id="69dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们很快就会看到这个结果与每个政党的投票百分比的对比。但首先我要做一个决定。</p><h1 id="129a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我选择熊猫</h1><p id="d415" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在这一点上，我想我知道我更喜欢什么了。我承认我喜欢SQL语句的清晰性，但这并没有说服我放弃熊猫而选择SQL。</p><p id="8b69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想做的下一件事是创建一个包含分析结果的新表，以便绘制一些图表。我可以使用SQL来完成这项工作，不会有太大的困难，但是我必须将它转换成熊猫的数据帧，以便绘制它。</p><p id="5fda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了结束剩下的分析，我将使用熊猫——反正它主要是关于绘制图表的，所以我认为它更合适(你可能不同意，在这种情况下，我将非常高兴在下面的评论中听到你的观点)。</p><h1 id="f36d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">比例代表制</h1><p id="55f7" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我接下来想做的是展示如果议会席位按投票数比例分配，2019年选举的结果会是什么。</p><p id="f04d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先要做的是从数据中删除发言者，因为他不代表真实的一方。扬声器是元素9，因此最简单的方法是:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="4b57" class="nm lw it ni b gy nn no l np nq">partiesdf = list(partiesdf)<br/>partiesdf.pop(9)<br/>seats = list(partywinsdf)<br/>seats.pop(9)</span></pre><p id="a6e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是从<code class="fe ns nt nu ni b">partiesdf</code>列表和<code class="fe ns nt nu ni b">seats</code>列表中删除了第9个元素。</p><p id="f1c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们算出总投票数和每个政党的投票数。</p><p id="96e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">投票总数是<code class="fe ns nt nu ni b">valid_votes</code>栏的总和。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="e24e" class="nm lw it ni b gy nn no l np nq">total_votes=election_df['valid_votes'].sum()</span></pre><p id="4009" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得每个政党的总投票数列表，我们将对应于该政党的列中的值相加。</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="45e7" class="nm lw it ni b gy nn no l np nq">total_votes_party = [election_df[i].sum() for i in partiesdf]</span></pre><p id="7c06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用这些数据创建一个新的数据框架:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="2ba9" class="nm lw it ni b gy nn no l np nq">share_df = pd.DataFrame()<br/>share_df['partiesdf'] = partiesdf<br/>share_df['votes'] = total_votes_party<br/>share_df['percentage_votes']=share_df['votes']/total_votes*100<br/>share_df['seats'] = seats<br/>share_df['percentage_seats']=share_df['seats']/650*100<br/>share_df['deficit']=share_df['percentage_seats']-share_df['percentage_votes']<br/>share_df['proportional_seats']=share_df['percentage_votes']/100*650</span></pre><p id="6a4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的数据帧如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/6955858d04947698ff06751e7a60164c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J-82oZvpj3pQdxAQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1fa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这有多有代表性。下面是一个条形图，比较了某个政党获得的席位百分比和投票百分比。我们这样创建它:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a809" class="nm lw it ni b gy nn no l np nq">share_df.plot.barh(x='partiesdf',<br/>    y = ['percentage_seats','percentage_votes'],figsize=(15,5))</span></pre><p id="1aed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/c04b4d883ff0b019c10ba65de3e5699a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wJpefu2uO88Yzfxd.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8c04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以看到，保守党、DUP和苏格兰国民党的席位比例高于选票比例，而其他政党的席位比例低于选票比例。我们可以通过绘制如下的<code class="fe ns nt nu ni b">deficit</code>列来了解谁是系统中的赢家和输家:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="103f" class="nm lw it ni b gy nn no l np nq">share_df.plot.barh(x='partiesdf',y=['percentage_seats','percentage_votes'],figsize=(15,5))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/627ed9b59743783187d24ac25bfd9386.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*F-PZk1ppOYnmLrRC.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4b51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从这张图表中你可以看出为什么自由民主党(图中的<code class="fe ns nt nu ni b">ld</code>)更喜欢英国的比例代表制选举。他们拥有的议会席位远少于他们的投票份额。绿党也同样处于不利地位。</p><p id="4c80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果每个政党的投票数按比例代表，英国议会会是什么样子？如果我们将实际获得的席位数与真正比例制下分配的席位数进行对比，如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a75b" class="nm lw it ni b gy nn no l np nq">share_df.plot.bar(x='partiesdf',y=['seats','proportional_seats'],figsize=(15,5))</span></pre><p id="cbe5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到下议院的组成会有很大的不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/d7317b59b8f504525fa05a9a9acaefdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SYPvytuNcr2iwxpF.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4e73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">按比例分配的席位以橙色显示，你可以看到保守党的代表将大幅减少，他们将失去多数席位。工党将获得更多席位，但真正的赢家将是自由民主党，其席位将从11席飙升至75席，而绿党将从1席升至17席。</p><p id="467a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">转而采用比例制是否是一种改进(事实上，是一种什么样的制度)不由我来说。然而，鉴于英国目前的政治状况，人们可以很容易地看到，在上述情况下，工党、自由民主党和绿党的联盟将比保守党拥有更多席位(约300个)，并且在其他地方政党的支持下组建政府是非常可行的。这样的结果意味着英国将会有一个完全不同的政府，不是通过改变选民的想法，而是通过不同的计票方法。</p><h1 id="c2ee" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">那么，现在怎么办？</h1><p id="10dc" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我在这里的主要目的是弄清楚，在Python中，是否应该更多地依赖SQL，而不是更少地依赖Pandas来进行数据分析，而不是在英国倡导新的选举制度。为此，我已经下定决心，虽然我不会像过去那样主动避开SQL，但现在我会坚持使用Pandas(尽管我仍然不会放弃Visual Basic)。</p><p id="5a31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读，我希望我对变幻莫测的英国选举制度的探索对熊猫和Python中的SQL(以及选举改革，如果你碰巧是英国人)有所帮助。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="48dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文的所有源代码都可以在我的<a class="ae lu" href="https://alanjones2.github.io/Alan-Jones-article-code/" rel="noopener ugc nofollow" target="_blank"> Github库</a>中找到。这里有到<a class="ae lu" href="https://raw.githubusercontent.com/alanjones2/Alan-Jones-article-code/master/sqlpandas/elections.csv" rel="noopener ugc nofollow" target="_blank">选举. csv </a>和<a class="ae lu" href="https://github.com/alanjones2/Alan-Jones-article-code/raw/master/sqlpandas/elections.db" rel="noopener ugc nofollow" target="_blank">选举. db </a>的直接链接。</p><p id="28a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你愿意，你可以订阅我偶尔发布的免费时事通讯，Substack上的<a class="ae lu" href="https://technofile.substack.com/" rel="noopener ugc nofollow" target="_blank">Technofile</a>——我会在那里发布新的文章。<a class="ae lu" href="https://technofile.substack.com/p/streamlit-special" rel="noopener ugc nofollow" target="_blank">这里</a>举例来说就是我写的一堆<a class="ae lu" href="https://technofile.substack.com/p/streamlit-special" rel="noopener ugc nofollow" target="_blank"> Streamlit文章</a>的帖子。</p><div class="oi oj gp gr ok ol"><a href="https://alanjones2.github.io/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">AlanJones:编码、科学和技术</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">关于数据可视化和类似主题的文章、教程和应用程序——大部分是Python语言，参见一些示例…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">alanjones2.github.io</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>