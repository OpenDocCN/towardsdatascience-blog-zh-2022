# 创建 Python 列表的 3 大 Python 思维技巧

> 原文：<https://towardsdatascience.com/top-3-pythonic-thinking-tips-for-python-list-creation-161fe893e81a>

## 用于数据科学的 Python 列表派生

![](img/7a8afac9f507355552b7fb7c0f682f92.png)

图片由[谢恩·奥尔登多夫](https://www.pexels.com/@pluyar/)在[像素](https://www.pexels.com/photo/shallow-focus-photography-of-magnifying-glass-with-black-frame-924676/)上拍摄

[Effective Python](https://www.amazon.com/Effective-Python-Specific-Software-Development/dp/0134853989) 是 Brett Slatkin 写的一本书，涵盖了 59 种编写更好的 Python 的具体方法。这本书以随机访问的方式编写，每个主题都有独立的源代码。对于中级 python 程序员来说，无论是工程师还是数据科学家，它都是一个很好的资源，因为它涵盖了可以按任何顺序学习的广泛主题。

涵盖的许多主题非常适用于数据科学工作流。例如，它用 PEP8 介绍了 python 思维，pep 8 是一种风格指南，确保您的 python 代码是可读的。它涵盖了函数、类和元类的最佳实践，所有这些在数据科学工作流中都有重要的用例。它还涵盖了为列表、元组和字典编写可读理解的最佳方法。这可以应用于诸如特征工程、数据预处理和数据后处理的任务。

理解是以可读的方式从一个列表导出另一个列表的有用方法。有效的 python 涵盖了理解的最佳实践(也适用于元组和字典)。它不鼓励使用 map 和 filter，它们可以完成与理解相同的任务，但代码更嘈杂、更难阅读。它也建议不要在理解中使用多种表达方式。最后，它建议对需要理解大量数据的任务使用生成器。

在数据科学工作流中编写有效的 python 可以确保用于要素工程、数据预处理和数据后处理等任务的代码高效易读。效率和可读性使得数据科学和机器学习代码库更容易维护。代码越容易阅读，就越容易在不产生错误的情况下进行修改。此外，了解执行任务的更有效的方法，如列表派生，最终有助于开发人员编写更有效的代码。

在这里，我们将看到如何将三种有效的 python 实践整合到一个简单的数据科学工作流中。我们将看看如何使用列表理解，而不是映射和过滤，可以提高可读性。我们还将看到，将理解限制在最多两个表达式可以确保代码清晰。最后，我们将在处理大量数据时比较理解和生成器。

对于这项工作，我将在 [Deepnote](https://deepnote.com/) 中编写代码，这是一个协作数据科学笔记本，使运行可重复的实验变得非常容易。我们将使用[医疗成本数据集](https://www.kaggle.com/datasets/mirichoi0218/insurance)。这些数据在[数据库内容许可](https://opendatacommons.org/licenses/dbcl/1-0/) (DbCL: Public Domain)下公开免费使用、修改和共享。

## **使用列表理解代替映射&过滤器**

Map 和 filter 内置于 python 函数中，这些函数为可以通过列表理解实现的任务提供了方便快捷的方式。为了展示这些技术之间的区别，我们将考虑两个常见的数据任务。具体来说，我们将展示如何使用 map 来生成列的 log 转换，然后展示如何使用 list comprehension 来完成相同的任务。

首先，让我们导航到 Deepnote 并创建一个新项目(如果您还没有帐户，可以免费注册)。

让我们创建一个名为“effective_python”的项目，并在这个项目中创建一个名为“list_comp_generators”的笔记本。另外，让我们将 insurance.csv 文件拖放到页面左侧的“文件”面板中:

![](img/006b4f945acf9f52ab7ec289eb3686c9.png)

作者截图

接下来，让我们导入 pandas 库并将我们的数据读入 pandas 数据框架:

作者创建的嵌入

接下来，让我们显示前五行数据:

作者创建的嵌入

*使用地图进行对数变换*

我们首先要考虑的列转换是对数转换。这是一种常用的技术，用于将倾斜数据转换为近似正常的数据。我们可以使用 map()函数来转换数据中的数值列表。让我们使用地图进行身体质量指数值的对数变换。我们将导入 Numpy 库，并定义一个函数，该函数将一个列表作为输入，并返回一个经过对数转换的元素列表:

作者创建的嵌入

接下来，我们可以使用 map 将我们的函数应用到我们的身体质量指数列表。map 函数接受我们将要应用的函数的名称和一个 iterable(在我们的例子中是一个列表):

```
output_list = map(function, list)
```

我们首先定义一个名为 bmi_list 的变量，并将 bmi 值的列表存储在变量中。然后，我们可以将我们的函数和列表传递给内置的 map 函数，并将结果存储在一个新列表中，我们称之为 bmi_lt_map。然后，我们需要定义一个新列来存储转换后的列:

作者创建的嵌入

请注意，这需要 5 行代码来完成:

```
import numpy as np 
def log_transform(input_list):
    return np.log(input_list)
bmi_list = list(df['bmi'])
bmi_lt_map = map(log_transform, bmi_list)
df['bmi_lt_map'] = bmi_lt_map
```

*使用列表理解进行日志转换*

让我们看看如何使用列表理解来帮助我们用更容易理解的代码达到同样的目的:

作者创建的嵌入

我们发现只用两行代码就可以做同样的事情。它也更容易阅读。值得注意的是，将 log 转换直接应用到 dataframe 列也是紧凑且易于阅读的，尽管这对于更复杂的转换是不可能的。

作者创建的嵌入

## **在列表理解中避免两个以上的表达**

假设我们有一个由分类机器学习模型生成的预测概率列表:

作者创建的嵌入

我们可以使用列表理解将这个列表转换成单个列表(我们可以“展平”列表):

作者创建的嵌入

这是一个包含两个 for 循环的列表理解。这是使用两个传统 for 循环的一个易于阅读的替代方法:

作者创建的嵌入

列表理解方法占用了两行代码，而传统的 for 循环占用了 5 行代码！尽管列表理解起来很方便，但可读性和紧凑性会随着两个以上的表达式而迅速减弱。假设我们想为概率大于 0.8 的列表生成一个标签为“是”的列表。、“可能”表示概率在 0.5 到 0.8 之间，而“否”表示概率小于 0.5。我们可以使用列表理解来做到这一点:

作者创建的嵌入

虽然这是紧凑的，但阅读和理解起来相当困难。如果我们使用传统的 for 循环，虽然它需要更多的代码行，但却更容易理解:

作者创建的嵌入

thump 的一个好的规则是避免使用两个或更多的列表理解表达式，包括 for 循环和条件。

## **大输入的发电机表达式**

虽然列表理解非常有用、简洁且易于理解，但是对于大量输入，它们需要大量的内存。对于大量输入，列表理解的替代方法是生成器表达式。生成器表达式结合了理解和生成器。它们是大量输入的理想选择，因为它们从表达式中一次产生一个项目。要编写生成器表达式，我们只需使用括号()。假设我们有一个分类预测概率的大列表。我们将使用 Numpy 的 random.normal 方法生成 2 亿个预测概率的综合列表，其平均值为 0.5，标准偏差为 0.1:

作者创建的嵌入

现在假设我们想使用列表理解生成一个标签列表。我们将为大于 0.5 的概率指定“是”，为小于 0.5 的概率指定“否”。

如果我们尝试在与我们的列表理解相同的单元格中打印前十个元素，我们将耗尽内存:

作者创建的嵌入

所以我们需要在一个单独的单元格中这样做:

作者创建的嵌入

生成器表达式可以用来计算一个迭代器，它一次产生一项，而不是整个表达式。这有助于避免内存分配问题:

作者创建的嵌入

我们看到，我们能够创建生成器对象并打印前十个元素，而不会遇到内存问题。

这篇文章中的代码可以在 [GitHub](https://github.com/spierre91/deepnote/blob/main/list_comp_generators.ipynb) 上找到。

## 结论

在这篇文章中，我们讨论了一些通过 pythonic 思维来改进列表创建的有用方法。首先，我们讨论了列表理解应该如何用于 map 和 filter，因为它更容易理解，尤其是在与 python 初学者合作时。然后，我们讨论了如何避免在列表理解中使用两个以上的表达式，以最大限度地提高清晰度和可读性。最后，我们展示了如何使用生成器表达式来替代对大量输入的列表理解。我鼓励你将这些技术应用到你自己的软件工程和机器学习项目中。