<html>
<head>
<title>Connecting Data Points to a Road Graph with Python Efficiently</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python高效地将数据点连接到道路图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/connecting-datapoints-to-a-road-graph-with-python-efficiently-cb8c6795ad5f#2022-01-25">https://towardsdatascience.com/connecting-datapoints-to-a-road-graph-with-python-efficiently-cb8c6795ad5f#2022-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="46d1" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">用Python高效地将数据点连接到道路图</h1></div><div class=""><h2 id="1523" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何从头开始构建一个函数，然后用numba将它加速80倍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f8f8355a58a490ad1339a64f391fee7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYAd1aal5Et1A-Qzs6VAtQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">美国宇航局在<a class="ae kv" href="https://unsplash.com/s/photos/internet?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="3d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，找到一个给定点的最近的道路是很容易的，但是当我们谈论数百万个点和数千条道路时，事情可能会变得有点复杂。我想告诉你如何从头构建一个这样的函数，然后用Numba把它加速80倍。</p><p id="932c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在本文中，我将解决以下任务:</p><blockquote class="ls lt lu"><p id="d731" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">考虑到</p><p id="8769" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">-700万个点，每个点由其经纬度决定<br/> -图中1万条道路。道路以OSMnx图形的形式存储</p><p id="95bd" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">去做</p><p id="5664" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">对于图中的每条道路，找出这条特定道路距离最近的点的数量。</p></blockquote><p id="181b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本质上需要的是将第一张地图转换成第二张地图，但是要有更多的点和街道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/4c2b76178ed66cd073ec145aa0904cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7PPjprtcWT6jRlkd1h5pw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">颜色表示与给定街道相关的点数。(图片由作者提供)</p></figure><p id="11de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，给定的任务对于标准的Shapely函数来说太重了，所以我们需要定制解决方案。</p><h2 id="fafd" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">1.几何学</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/faa56fa98ae9ce324951c70ebbbb7b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*EaoyNT6T7Xr54ZMUGMkD4w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="684f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从最简单的方法开始。从坐标原点到两点定义的直线的距离可以用以下公式计算:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9c0884c7351d0a53f11b6e72d1fdc37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/0*51kqnW1T-DAmyFMH"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e51b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用这个公式来计算从任何给定点的距离。要做到这一点，所需要做的就是转换坐标，使给定点在原点结束。</p><p id="82e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们编写一个简单的函数，遍历所有的街道并找到最近的一条。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="516f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一的问题是，在现实生活中，街道不是无限的，通常由它们的端点来定义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/2ac4264a8757cf9b4f1fcd8be4b3e2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*IOnGPdNOdw9dLlyyPLvhLg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑图中的情况。虽然点A更靠近第一个线段，但上面的公式告诉我们，点A更靠近第二个线段，因为它的延伸线就在点附近。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/832dccf928967c2364512b69cb46fda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*yNo6U0pzZkOExY1OU8uHzw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ab0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了消除这些街道，让我们引入一个规则，即从数据点到街道的垂直线必须在其端点之间相交。否则，街道被认为是不相关的。我想指出的是，这条规则相当于要求从数据点到街道端点的线与街道成锐角。第二个要求更容易检查。我们需要做的就是计算代表三角形边的向量的标量积。如果两个向量之间的角度是钝角，则标量积为负，反之亦然。</p><p id="3134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是检查三角形是否是锐角的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我不会从头开始重写整个函数，只显示发生变化的部分。整个功能会在文末呈现。</p></figure><p id="09ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我猜你已经知道我们将面临的下一个问题。现实生活中不是所有的街道都是直的。考虑下图中的情况</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/2f0fb129196177075e86eda22e837d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*DEAiYRej5cugB4zLwJRYBA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="55ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们刚刚开发的算法将第一条线作为最近的一条线返回，而答案显然是第二条线。这是因为当前的方法只考虑了端点，而没有考虑曲率。幸运的是，OSMnx图还包含街道的几何形状，可以用街道子段的端点坐标序列的形式来表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/44e72de5a6cceec55e23a3a7db6bdde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*XOBW-NKI_DSUwDAnMealHQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3c3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，要解决这个问题，我们需要做的就是对每条街道的所有子分段进行迭代。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e16c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这又产生了一个意想不到的问题。如果某条远处街道的某一段的延续正好位于数据点附近，会发生什么情况？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/855445f8fc9b2265d33ff6c19b8f6911.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*h3plDI7v4WZERVTVBd6nWA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="e639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该点将与街道№2相关联，而它显然属于第一条街道。然而，这个问题可以通过检查每个子线段的三角形是否尖锐来解决，就像我们已经对街道的端点所做的那样。</p><p id="0626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这涵盖了所有可能导致问题的情况，因此我们可以进入下一部分，效率优化。</p><h2 id="dc41" class="ma mb iq bd mc md me dn mf mg mh dp mi lf mj mk ml lj mm mn mo ln mp mq mr ms bi translated">2.效率优化</h2><p id="1c16" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">至此，整体算法完成。我们可以添加到函数逻辑中来加速它的唯一方法是检查街道是否太远，如果太远就删除街道。添加一条线后，检查所有端点是否都在一定距离之内，函数如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，经过所有的调整后，计算700万个点中每个点的最近街道需要大约一周的时间。我们需要更深入。</p><p id="901d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用Numba库来进一步加速这个函数。它所做的是在运行时使用LLVM编译器库将某些Python函数翻译成优化的机器代码。唯一的缺点是它不支持动态类型以及一些特定于Python的数据类型，如Pandas数据框。我故意没有使用不支持的数据类型，所以不会有问题。所以我们所要做的就是指定在加速函数中使用的变量的数据类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e8ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于要用Numba强制的函数，必须在它之前放置@jit decorator。仅此而已。</p><p id="e727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，为了测试效率增益，让我们加载伦敦市中心的街道图，并生成一千个点。我试着用Numba加速和不用Numba加速找到所有点最近的街道。结果如下:</p><ul class=""><li id="471f" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">不含数字——4分27秒</li><li id="e7de" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">数字为0分3.4秒</li></ul><p id="e261" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码运行速度提高了80倍，令人印象深刻。将700万个点与街道相关联的初始任务仅用了几个小时就完成了，而不是一周。</p><p id="960c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我把所有的代码和更多的图片做了一个笔记本。你可以在这个库中找到它。</p><p id="fab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读文章，希望您觉得有用！</p><div class="nv nw gp gr nx ny"><a href="https://vityazevdanil.medium.com/" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">丹尼尔·维蒂亚泽夫培养基</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">阅读Danil Vityazev在媒体上的文章。数据和商业分析师。我制作商业的数学模型…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">vityazevdanil.medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div></div></div>    
</body>
</html>