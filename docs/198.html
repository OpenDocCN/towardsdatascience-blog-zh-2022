<html>
<head>
<title>Everything you need to know about Indexing in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Julia中的索引，您需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-indexing-in-julia-b0a695de45b7#2022-01-07">https://towardsdatascience.com/everything-you-need-to-know-about-indexing-in-julia-b0a695de45b7#2022-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="4269" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">关于Julia中的索引，您需要知道的一切</h1></div><div class=""><h2 id="665f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于Julia中索引的所有细节的概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c9bac7fdb7ab74815f999ba44f61f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cSqdZJ6rI5JdImZKhSMj6A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由Pixabay上的DavidZydd提供)</p></figure><h1 id="0955" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="fe65" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi mm translated">在编程领域，尤其是数据科学领域，使用由更小元素组成的数据结构是很常见的。正如人们所料，这些集合需要以某种方式从集合外部进行交互——为此，程序员使用索引。索引是一个至关重要的编程主题，它在特定语言中的深度总是很大的学问。很多时候，当谈到对编程语言的熟悉和了解时，归结为使用一段时间后对调用的了解。</p><p id="518d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">幸运的是，在本文中，我将介绍一些非常抽象的方法。也就是说，包含类型的类型定义对于什么类型可以通过该函数传递是非常模糊的。在朱莉娅，最大的错误是</p><blockquote class="na"><p id="98bb" class="nb nc it bd nd ne nf ng nh ni nj ml dk translated">方法错误</p></blockquote><p id="02a6" class="pw-post-body-paragraph lq lr it ls b lt nk ju lv lw nl jx ly lz nm mb mc md nn mf mg mh no mj mk ml im bi translated">我们也可以用索引来解决这些问题。有一种使用索引的核心方法是Julia独有的，而且以我个人的经验来看非常简单。与其他生态系统相比，这种方法似乎非常适合。此外，如果您想查看包含本文代码的笔记本，您可以从Github仓库获得它:</p><div class="np nq gp gr nr ns"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/Julia%20Indexing.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">Emmetts-DS-NoteBooks/Julia indexing . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og ks ns"/></div></div></a></div></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="512e" class="ky kz it bd la lb oo ld le lf op lh li jz oq ka lk kc or kd lm kf os kg lo lp bi translated">索引</h1><p id="3191" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Julia内部的每种类型都可以被索引，信不信由你。即使对于不是集合的类型也是如此，我们将演示这一点。然而，让我们先来看看更简单的东西，比如基本的数组索引。我们可以使用一个整数作为数组中的一维参考点进行索引。如果数组是有序的，这尤其有用。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="9995" class="oy kz it ou b gy oz pa l pb pc">array = [1, 2, 3, 4, 5]<br/>array[1]</span><span id="d9bb" class="oy kz it ou b gy pd pa l pb pc">1</span></pre><p id="a7a1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在要澄清的是，我们没有得到一个值，因为在这个例子中，我们通过索引传递了一个值，我们得到一个值，因为这是数组中的第一个值。例如，如果我们把1改成5:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="6f68" class="oy kz it ou b gy oz pa l pb pc">array = [5, 2, 3, 4, 5]<br/>array[1]</span><span id="4b75" class="oy kz it ou b gy pd pa l pb pc">5</span></pre><p id="3b43" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们还可以通过范围进行索引:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="284e" class="oy kz it ou b gy oz pa l pb pc">array[1:5]</span><span id="3aa8" class="oy kz it ou b gy pd pa l pb pc">5-element Vector{Int64}:<br/> 1<br/> 2<br/> 3<br/> 4<br/> 5</span></pre><p id="e728" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">如果这个集合是一个字典，我们也可以通过键(不管是什么类型)进行索引。)如果你想更多地了解Julia的各种数据结构，你可以在这里阅读或观看:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/in-depth-look-at-data-structures-in-julia-d22171a8f5ed"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">深入了解Julia中的数据结构</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">Julia编程语言中数据结构的快速介绍。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="pe l od oe of ob og ks ns"/></div></div></a></div><p id="142d" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">对于要提供的类型的完整列表，我们实际上可以对一个方法打上问号。索引调用的方法是来自base的getindex()方法。让我们在上面调用文档浏览器:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="ffcb" class="oy kz it ou b gy oz pa l pb pc">?(getindex)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/5100993c5a0c32d73c9a17aa3ec4115a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzUitSFkvTruW6tibBBNug.png"/></div></div></figure><p id="1fde" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们也可以设置索引。这将调用setindex！()方法，它有一个解释点，因为它会改变我们发送给它的类型。让我们继续导入getindex()和setindex！()直接从基础开始，以便我们可以扩展它们:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="c81d" class="oy kz it ou b gy oz pa l pb pc">import Base: getindex, setindex!</span></pre><p id="6b74" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在，只需使用典型的Julia分派方法，我们就可以设置任何结构来拥有我们想要的任何类型的索引。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="b1bd" class="oy kz it ou b gy oz pa l pb pc">mutable struct NotACollection<br/>    x::Int64<br/>end</span></pre><p id="d0f6" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们构造的类型根本不是这样一个集合，相反，它只是在里面有一个整数。它实际上是一个非常无用的构造函数。不管怎样，我们现在要把它分派到索引任何东西都会返回x的地方，只有一个索引，我不知道你想让我说什么。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="8998" class="oy kz it ou b gy oz pa l pb pc">getindex(notcol::NotACollection, y::Int64) = notcol.x</span><span id="7324" class="oy kz it ou b gy pd pa l pb pc">notacol = NotACollection(5)</span></pre><p id="4a0a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">现在，如果我们调用我们的类型的索引，它肯定不是一个集合，我们得到的数字，并没有大惊小怪:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="08c6" class="oy kz it ou b gy oz pa l pb pc">notacol[1]<br/>5</span></pre><p id="b05e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">如果您在没有首先扩展getindex()的情况下这样做，这段代码将返回一个MethodError。现在，为了好玩，我们将对setindex做同样的事情！():</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="2496" class="oy kz it ou b gy oz pa l pb pc">setindex!(notcol::NotACollection, y::Int64, val::Int64) = notcol.x = y</span><span id="c66b" class="oy kz it ou b gy pd pa l pb pc">notacol[1] = 10</span><span id="32a4" class="oy kz it ou b gy pd pa l pb pc">println(notacol[x])</span></pre><h1 id="4263" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">索引方法</h1><p id="f7a5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在让我们看看一些有用的方法，它们可以用来处理基本的数据结构和改变它们的索引。我认为这些是Julia的基本知识，所以我真的很高兴与你分享这些令人敬畏的基本方法。这些是我所知道的随时会派上用场的一些工具。</p><h2 id="4780" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">大小()</h2><p id="d9f6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">第一种方法是size()。这个方法相当于Python中的shape()。这将给出给定数组或矩阵的维数。虽然我们还没有深入多维数组，但是size()对于处理多维数组来说将会非常方便。也就是说，保持这种方法及其使用方便，当然可以适用于一维或多维应用程序。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="f75c" class="oy kz it ou b gy oz pa l pb pc">nums = [54, 33, 22, 13]<br/>size(nums)</span><span id="2218" class="oy kz it ou b gy pd pa l pb pc">(4,)</span></pre><p id="121e" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">返回类型是一个二元元组，我们可以对其进行索引:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="47c1" class="oy kz it ou b gy oz pa l pb pc">println(typeof(size(nums)))</span><span id="1b7e" class="oy kz it ou b gy pd pa l pb pc">Tuple{Int64}</span><span id="40aa" class="oy kz it ou b gy pd pa l pb pc">println(size(nums)[1])</span><span id="39a1" class="oy kz it ou b gy pd pa l pb pc">4</span></pre><h2 id="3796" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">用力！()</h2><p id="17a5" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">用力！()方法是Julia语言中最有用的方法之一。这个方法的伟大之处在于它被定义在类型层次结构的顶端。这意味着可以将哪些类型传递给push！()通常非常抽象。这种抽象意味着可以提供许多不同的类型。然而，这确实带来了一些可能需要注意的细微差别。朱莉娅的伟大之处还在于我们可以改变语言。</p><p id="eede" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">用力！()方法用于将新元素移动到结构中。它可以处理字典、数组和各种其他数据类型——几乎是你能想到的任何数据类型。推动的伟大之处在于！()除非你尝试，否则你永远不知道它是否会起作用，如果它不起作用，你可以随时写你自己的推！()来照顾它。让我们在我们的阵列上尝试一下:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="43fa" class="oy kz it ou b gy oz pa l pb pc">push!(nums, 5)</span><span id="a33a" class="oy kz it ou b gy pd pa l pb pc">5-element Vector{Int64}:<br/> 54<br/> 33<br/> 22<br/> 13<br/>  5</span></pre><p id="5d89" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">实际上，我写了一整篇文章来深入讨论这个问题！()方法，所以如果您碰巧对阅读这种方法及其各种细微差别感兴趣，您可以在这里阅读:</p><h2 id="471c" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">追加！()</h2><p id="e16a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">追加！()方法很类似于推送！()方法。喜欢推！()方法，追加！()方法将元素添加到给定的数组中。然而，一个关键的区别是附加！()会尽可能避免变异命令，推！()不会。追加！()方法对于它应该使用的类型来说也更加明确和具体。通常，它用于简单数据类型的数组。让我们看一下我们阵列的一个示例:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="c88f" class="oy kz it ou b gy oz pa l pb pc">append!(nums, 5)<br/>6-element Vector{Int64}:<br/> 54<br/> 33<br/> 22<br/> 13<br/>  5<br/>  5</span></pre><p id="54db" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">注意，因为我们的数组是Vector{Int64}类型的，所以我们只能通过这个函数推送整数。我们也可以推送可以转换成整数的数字，但是在大多数情况下，我们需要在提供它们之前进行类型转换。</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="1e9a" class="oy kz it ou b gy oz pa l pb pc">append!(nums, 5.5)</span><span id="5aa6" class="oy kz it ou b gy pd pa l pb pc">InexactError: Int64(5.5)</span></pre><p id="dda5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">铸造那种类型产生它确实工作:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="e911" class="oy kz it ou b gy oz pa l pb pc">append!(nums, 5.5)</span></pre><p id="3267" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">但是，如果该结构将包含多种类型，更好的方法可能是将整个结构强制转换为包含{Any}:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="e7ee" class="oy kz it ou b gy oz pa l pb pc">nums = Array{Any}(nums)<br/>append!(nums, 5.5)</span></pre><h2 id="f74d" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">滤镜！()</h2><p id="72ae" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Julia中的filter方法是另一个非常常用的方法。这一点在使用统计数据时尤其有用。想想熊猫数据框面具，它实际上成了我最喜欢的熊猫特写的一部分:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/20-great-pandas-tricks-for-data-science-3a6daed71da0"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">数据科学的20个大熊猫技巧</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">你应该每天使用的20个大熊猫技巧。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="pr l od oe of ob og ks ns"/></div></div></a></div><blockquote class="ps pt pu"><p id="55b9" class="lq lr pv ls b lt mv ju lv lw mw jx ly pw mx mb mc px my mf mg py mz mj mk ml im bi translated">但是，过滤！()在Julia中是等价的。也哇，一年多前。</p></blockquote><p id="c6ea" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我和过滤器有些小问题！()，这并不是说我不喜欢这种方法——我只是觉得使用起来比其他界面更烦人。Julia倾向于在它所做的许多事情上出类拔萃，并使事情对程序员来说变得超级容易——但这是一个例子，我认为学会这一点比学会另一种语言更难，那就是Python。幸运的是，我希望进行的修改的语法非常容易完成，布尔索引现在可以在我目前正在开发的包OddFrames.jl中找到，您也可以在这里查看Github页面:</p><div class="np nq gp gr nr ns"><a href="https://github.com/ChifiSource/OddFrames.jl" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">GitHub-chifi source/odd frames . JL:面向对象的、基于dict的DataFrames包！</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">jl是Julia的一种新的数据管理和操作包。然而，许多类似的软件包…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="pz l od oe of ob og ks ns"/></div></div></a></div><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="96a5" class="oy kz it ou b gy oz pa l pb pc">filter((x) -&gt; x == 5, nums)</span></pre><p id="1ce1" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">对于这个方法，我们使用一个叫做匿名函数的东西作为它的第一个参数，为了更全面地了解这个概念，您可以在这里阅读一篇深入研究它们的文章:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/what-on-earth-is-an-anonymous-function-f8043eb845f3"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd iu gy z fp nx fr fs ny fu fw is bi translated">匿名函数到底是什么？</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">揭开Julia中匿名函数和类型的来龙去脉</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="qa l od oe of ob og ks ns"/></div></div></a></div><p id="9939" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">在本文的稍后部分，我们还将更多地涉及它们，但是现在我们将简单地观察我们的过滤值:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="d59f" class="oy kz it ou b gy oz pa l pb pc">filter((x) -&gt; x == 5, nums)</span><span id="7f62" class="oy kz it ou b gy pd pa l pb pc">2-element Vector{Any}:<br/> 5<br/> 5</span></pre><h2 id="e44d" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">收集()</h2><p id="cc12" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">像collect这样的方法通常很难解释，但是collect可以用来快速地从某种生成器或进程中获取值。本质上任何能够返回iterable的东西。如果我们有范围</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="7be5" class="oy kz it ou b gy oz pa l pb pc">r = 5:10</span></pre><p id="1b62" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们想得到一个从5到10的数组，我们可以简单地调用collect来得到结果</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="cca1" class="oy kz it ou b gy oz pa l pb pc">collect(r)</span><span id="da4a" class="oy kz it ou b gy pd pa l pb pc">6-element Vector{Int64}:<br/>  5<br/>  6<br/>  7<br/>  8<br/>  9<br/> 10</span></pre><h2 id="2547" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">findall()</h2><p id="c123" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">芬多。()方法是一种我可以非常肯定地说非常有用的方法。有很多这样的呼吁，所以用ole问号’是一个很好的例子:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="8728" class="oy kz it ou b gy oz pa l pb pc">?(findall)</span></pre><p id="04f8" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">实际上，我在OddFrames.jl中多次使用这种方法。对于我将要演示的示例代码，我们将查看OddFrames.jl的<a class="ae qb" href="https://github.com/ChifiSource/OddFrames.jl/blob/main/src/interface/index_iter.jl" rel="noopener ugc nofollow" target="_blank"> index_iter.jl文件，您可以通过单击该文本来查看。</a></p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="0581" class="oy kz it ou b gy oz pa l pb pc">function getindex(od::AbstractOddFrame, col::Symbol)<br/>        pos = findall(x-&gt;x==col, od.labels)[1]<br/>        return(od.columns[pos])<br/>end<br/>getindex(od::AbstractOddFrame, col::String) = od[Symbol(col)]<br/>getindex(od::AbstractOddFrame, axis::Int64) = od.columns[axis]<br/>function getindex(od::AbstractOddFrame, mask::BitArray)<br/>        pos = findall(x-&gt;x==0, mask)<br/>        od.drop(pos)<br/>end<br/>getindex(z::UnitRange) = [od.labels[i] for i in z]</span></pre><p id="920b" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这段代码是几个getindex()调度绑定。您可能还记得前面的getindex()。OddFrames.jl处理数组中的一维数组，这些数组可以相互堆叠，但不能。findall()方法在这里使用了两次。第一种情况是用符号调用索引时:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="69a3" class="oy kz it ou b gy oz pa l pb pc">od[:column]</span></pre><p id="7805" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">在这个例子中，findall()方法向我们返回等同于这样一个东西的任何实例的索引。出于某种原因，我见过的许多Julia代码在操作符周围没有使用空格，因此我采用了它——尽管我认为这不合适，所以让我把它写得更容易阅读一些:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="3b26" class="oy kz it ou b gy oz pa l pb pc">pos = findall(x -&gt; x == col, od.labels)[1]</span></pre><p id="2e25" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">我们所做的就是试图找到一个与该值相等的标签，我们首先使用:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="1137" class="oy kz it ou b gy oz pa l pb pc">x -&gt; x</span></pre><p id="21e5" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">这告诉Julia我们想要创建一个匿名函数。现在这个x是一个变量，我们已经定义了一个函数，它将返回一个BitArray。BitArray只是一种保存布尔真/假值的数组，通常为1和0。1和0都只占用一位，因此这被称为双数组。也许我可以简单的解释一下，说它是一个二进制数组。无论如何，我们的数组是直接从这里返回的:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="c385" class="oy kz it ou b gy oz pa l pb pc">x == col</span></pre><p id="ce6a" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">然后，我们遍历od.labels，看看是否有匹配的值。由于OddFrame中的标签不能相同，我们总是知道如果在OddFrame中没有找到它，那么它要么是一个值，要么没有值。给定这些信息，我在最后调用第一个索引，这将把我们的值的类型从数组{Int64，1}变成Int64。然后我们简单地在返回中调用该列的索引:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="38a0" class="oy kz it ou b gy oz pa l pb pc">function getindex(od::AbstractOddFrame, col::Symbol)<br/>        pos = findall(x-&gt;x==col, od.labels)[1] <br/>       return(od.columns[pos])<br/>end</span></pre><p id="5805" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">向前跳一点，我们看到条件掩码也使用了同样的方法:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="9663" class="oy kz it ou b gy oz pa l pb pc">function getindex(od::AbstractOddFrame, mask::BitArray)<br/>        pos = findall(x-&gt;x==0, mask)<br/>        od.drop(pos)<br/>end</span></pre><p id="84a0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">唯一的区别是，这次findall()用于收集需要删除的位置，然后在od.drop()方法中使用这个列表中的下一个方法来删除那个值。</p><p id="3add" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">对于我们的笔记本示例，我们将获得等于5的每个值:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="0c0d" class="oy kz it ou b gy oz pa l pb pc">z = findall(x -&gt; x == 5, nums)<br/>array = [nums[x] for x in z]</span></pre><h2 id="c6b0" class="oy kz it bd la pg ph dn le pi pj dp li lz pk pl lk md pm pn lm mh po pp lo pq bi translated">删除at！()</h2><p id="b263" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我想看的最后一个方法是deleteat！()方法。如前所述，我们将在OddFrames.jl中查看这个示例。我们还将在笔记本中做另一个示例。OddFrames示例位于OddFrames存储库中的<a class="ae qb" href="https://github.com/ChifiSource/OddFrames.jl/blob/main/src/type/member_func.jl" rel="noopener ugc nofollow" target="_blank"> member_func.jl文件中，再次单击此文本。</a>删除at！()方法就是用来做这件事的，在特定的索引处删除。</p><blockquote class="ps pt pu"><p id="23d2" class="lq lr pv ls b lt mv ju lv lw mw jx ly pw mx mb mc px my mf mg py mz mj mk ml im bi translated">我知道有人在某处不断读到，当你吃东西的时候，要知道你并不孤单。也许我们只是饿了。</p></blockquote><p id="13af" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">该方法简单易用，只需提供一个集合和一个索引:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="a135" class="oy kz it ou b gy oz pa l pb pc">function _drop(row::Int64, columns::Array)<br/>        [deleteat!(col, row) for col in columns]<br/>end</span></pre><p id="07ff" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">在这种情况下，这是通过迭代循环完成的，并对提供的向量进行变异。虽然这样做有回报，但并不意味着要使用它——也许我应该在此之后返回，以确保这一点得到理解。对于我们的笔记本电脑示例，我们将删除整个阵列:</p><pre class="kj kk kl km gt ot ou ov ow aw ox bi"><span id="7877" class="oy kz it ou b gy oz pa l pb pc">while length(nums) &gt; 1<br/>    deleteat!(nums, 1)<br/>end</span><span id="f951" class="oy kz it ou b gy pd pa l pb pc">println(nums)</span><span id="8894" class="oy kz it ou b gy pd pa l pb pc">Any[5.5]</span></pre><blockquote class="na"><p id="1444" class="nb nc it bd nd ne qc qd qe qf qg ml dk translated">安息吧。</p></blockquote><h2 id="c729" class="oy kz it bd la pg qh dn le pi qi dp li lz qj pl lk md qk pn lm mh ql pp lo pq bi translated">这么多方法</h2><p id="d584" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当然，处理这类类型的方法有很多，所以我不可能一一描述，但是除了像length()和sum()等常规方法之外，我还发现了一些非常有价值的方法。除了size()，这些都是特定于Julia的，所以我认为新的Julia用户可能会发现这些有参考价值。甚至还有横向和纵向的串联，各种矩阵运算等等。</p><h1 id="0ad7" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="a7a2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">Julia语言有一种非常好的处理迭代的方式。每种语言都有我欣赏的方法，但与使用Python类的默认方法或在r中完成相同的任务相比，我真的很喜欢这种方法。每当我使用其他语言时，我发现自己经常错过这些功能，这告诉我它们可能是很棒的功能。</p><p id="3fa0" class="pw-post-body-paragraph lq lr it ls b lt mv ju lv lw mw jx ly lz mx mb mc md my mf mg mh mz mj mk ml im bi translated">感谢您的阅读，我很高兴能与您分享这些知识。这些是Julia用户第一次开始时可能不知道的一些事情，所以把这些方法带到你面前并提供更多关于在Julia中使用iterable items的信息真是太棒了。</p></div></div>    
</body>
</html>