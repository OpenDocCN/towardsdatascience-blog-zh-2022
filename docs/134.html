<html>
<head>
<title>Why You Should Save NumPy Arrays with Zarr</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么应该用Zarr保存NumPy数组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-save-numpy-arrays-with-zarr-dabff4ae6c0c#2022-01-05">https://towardsdatascience.com/why-you-should-save-numpy-arrays-with-zarr-dabff4ae6c0c#2022-01-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="9fc0" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">为什么应该用Zarr保存NumPy数组</h1></div><div class=""><h2 id="c82b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用Dask更快地读写阵列</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e1619876fb12e73f8e095436e531c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ikaD6ot28DacO_O-AnA5vw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由Sebastian Kanczok通过<a class="ae ky" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="5c03" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">TL；博士；医生</h1><p id="5c16" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这篇文章告诉你为什么以及如何使用Zarr格式来保存你的NumPy数组。它指导您使用Zarr和Dask并行地读取和写入大型NumPy数组。</p><p id="de51" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想直接进入，这是代码。如果您对代码有任何疑问，请在Twitter 上联系我<a class="ae ky" href="https://twitter.com/richardpelgrim" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="8aa9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">保存NumPy数组的常用方法</h1><p id="17a9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">存储NumPy数组的三种常见方式是<a class="ae ky" href="https://crunchcrunchhuman.com/2021/12/25/numpy-save-csv-write/" rel="noopener ugc nofollow" target="_blank">存储为</a> <code class="fe ms mt mu mv b"><a class="ae ky" href="https://crunchcrunchhuman.com/2021/12/25/numpy-save-csv-write/" rel="noopener ugc nofollow" target="_blank">.csv</a></code> <a class="ae ky" href="https://crunchcrunchhuman.com/2021/12/25/numpy-save-csv-write/" rel="noopener ugc nofollow" target="_blank">文件</a>，<a class="ae ky" href="https://mungingdata.com/numpy/save-numpy-text-txt/" rel="noopener ugc nofollow" target="_blank">存储为</a> <code class="fe ms mt mu mv b"><a class="ae ky" href="https://mungingdata.com/numpy/save-numpy-text-txt/" rel="noopener ugc nofollow" target="_blank">.txt</a></code> <a class="ae ky" href="https://mungingdata.com/numpy/save-numpy-text-txt/" rel="noopener ugc nofollow" target="_blank">文件</a>或<code class="fe ms mt mu mv b">.npy</code>文件。</p><p id="048e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些方法都有重要的局限性:</p><ul class=""><li id="fe8b" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">CSV和TXT文件是人类可读的格式，不能包含大于二维的NumPy数组。</li><li id="01cc" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">原生NPY二进制文件格式<strong class="lt iu">不支持并行读/写</strong>操作。</li></ul><p id="09c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们在下面看看这一点。</p><p id="fabd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将从创建一个伪NumPy数组开始。我们将使用<code class="fe ms mt mu mv b">np.random.rand</code>生成两个填充了随机数的数组，一个是二维数组，一个是三维数组:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="0a36" class="no la it mv b gy np nq l nr ns">import numpy as np </span><span id="4fd0" class="no la it mv b gy nt nq l nr ns">array_XS = np.random.rand(3,2) <br/>array_L = np.random.rand(1000, 1000, 100)</span></pre><p id="e22a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将三维<code class="fe ms mt mu mv b">array_L</code>存储为<code class="fe ms mt mu mv b">.txt</code>或<code class="fe ms mt mu mv b">.csv</code>会抛出一个值错误:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="4aeb" class="no la it mv b gy np nq l nr ns">np.savetxt('array_L.txt', array_L, delimiter=" ") np.savetxt('array_L.csv', array_L, delimiter=",") </span><span id="4618" class="no la it mv b gy nt nq l nr ns">ValueError: Expected 1D or 2D array, got 3D array instead</span></pre><p id="474a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以将三维数组存储为. npy文件。这是可行的，但不能扩展到大于内存的数据集或其他需要并行读取和/或写入的情况。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="1069" class="no la it mv b gy np nq l nr ns">np.save('array_L.npy', array_L)</span></pre><h1 id="329c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用Zarr保存NumPy数组</h1><p id="3cfc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了上面的三个选项，考虑将NumPy数组保存到<a class="ae ky" href="https://zarr.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Zarr </a>中，这是一种用于存储分块、压缩的N维数组的格式。</p><p id="e516" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Zarr的三个最重要的优势是:</p><p id="5ed1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">1.内置<strong class="lt iu">多种压缩选项</strong>和级别</p><p id="0e71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2.支持<strong class="lt iu">多个后端数据存储</strong> (zip，S3等。)</p><p id="9c6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">3.<strong class="lt iu">可以并行读写数据</strong> *在n维压缩块中吗</p><p id="8301" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Zarr还被Dask、TensorStore和x-array等PyData库广泛采用，这意味着将这种文件格式与支持的库一起使用时，性能会有显著提高。</p><p id="cbf7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nu"> * Zarr支持分别并发读取和并发写入，但不支持同时并发读取和写入。</em></p><h1 id="0e7b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用Zarr压缩NumPy数组</h1><p id="d9c4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看看Zarr的压缩选项。下面，我们将小数组和大数组保存到<code class="fe ms mt mu mv b">.zarr</code>并检查结果文件大小。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="c832" class="no la it mv b gy np nq l nr ns">import zarr <br/># save small NumPy array to zarr <br/>zarr.save('array_XS.zarr', array_XS) </span><span id="016b" class="no la it mv b gy nt nq l nr ns"># get the size (in bytes) of the stored .zarr file <br/>! stat -f '%z' array_XS.zarr <br/>&gt;&gt; 128 </span><span id="81f5" class="no la it mv b gy nt nq l nr ns"># save large NumPy array to zarr <br/>zarr.save('array_L.zarr', array_L) </span><span id="ebf9" class="no la it mv b gy nt nq l nr ns"># get the size of the stored .zarr directory <br/>! du -h array_L.zarr &gt;&gt; 693M	array_L.zarr</span></pre><p id="31c6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将<code class="fe ms mt mu mv b">array_L</code>存储为Zarr会导致文件大小显著减少(<code class="fe ms mt mu mv b">array_L</code>减少约15%)，即使只有默认的开箱即用压缩设置。查看随附的笔记本以获得更多压缩选项，您可以调整这些选项来提高性能。</p><h1 id="7822" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用Zarr加载NumPy数组</h1><p id="1f05" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可以使用<code class="fe ms mt mu mv b">zarr.load()</code>将存储为<code class="fe ms mt mu mv b">.zarr</code>的数组加载回Python会话中。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="101c" class="no la it mv b gy np nq l nr ns"># load in array from zarr <br/>array_zarr = zarr.load('array_L.zarr')</span></pre><p id="11c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它将作为一个常规的NumPy数组加载。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="3c22" class="no la it mv b gy np nq l nr ns">type(array_zarr) </span><span id="4200" class="no la it mv b gy nt nq l nr ns">&gt;&gt;&gt; numpy.ndarray</span></pre><p id="ad9b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Zarr支持多个后端数据存储。这意味着你也可以轻松地从基于云的数据商店加载<code class="fe ms mt mu mv b">.zarr</code>文件，比如亚马逊S3:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="977b" class="no la it mv b gy np nq l nr ns"># load small zarr array from S3 <br/>array_S = zarr.load(<br/>"s3://coiled-datasets/synthetic-data/array-random-390KB.zarr"<br/>)</span></pre><h1 id="7fea" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">利用Zarr和Dask并行读写NumPy数组</h1><p id="7a31" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您正在处理存储在云中的数据，那么您的数据很可能比本地机器内存大。在这种情况下，您可以使用Dask并行读写大型Zarr数组。</p><p id="3f66" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面我们试着加载一个370GB。zarr文件直接插入到我们的Python会话中:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="b5a4" class="no la it mv b gy np nq l nr ns">array_XL = zarr.load(<br/>"s3://coiled-datasets/synthetic-data/array-random-370GB.zarr"<br/>)</span></pre><p id="7da9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将失败，并出现以下错误:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="4a45" class="no la it mv b gy np nq l nr ns">MemoryError: Unable to allocate 373. GiB for an array with shape (10000, 10000, 500) and data type float64</span></pre><p id="728f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">加载同样的370GB。zarr文件放入Dask数组工作正常:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="4416" class="no la it mv b gy np nq l nr ns">dask_array = da.from_zarr(<br/>"s3://coiled-datasets/synthetic-data/array-random-370GB.zarr"<br/>) </span></pre><p id="7288" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为Dask <em class="nu">评估懒惰</em>。在您明确指示Dask对数据集执行计算之前，不会将数组读入内存。在这里阅读更多关于Dask <a class="ae ky" href="https://coiled.io/blog/what-is-dask/" rel="noopener ugc nofollow" target="_blank">的基础知识。</a></p><p id="1ecf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着您可以在本地对该数据集执行一些计算。但是将整个数组加载到本地内存仍然会失败，因为您的机器没有足够的内存。</p><p id="f9c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nu">注意:即使你的机器在技术上有足够的存储资源将这个数据集溢出到磁盘，这也会大大降低性能。</em></p><div class="nv nw gp gr nx ny"><a href="https://coiled.io/blog/common-dask-mistakes/" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">使用Dask时要避免的常见错误</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">第一次使用Dask可能是一个陡峭的学习曲线。经过多年的建设Dask和引导人们通过…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">coiled.io</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div><h1 id="caa5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用线圈扩展到Dask集群</h1><p id="8b97" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要在云中的Dask集群上运行它，以访问额外的硬件资源。</p><p id="2b6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此:</p><ol class=""><li id="eb58" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm on nc nd ne bi translated">旋转盘绕的簇</li></ol><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="30fa" class="no la it mv b gy np nq l nr ns">cluster = coiled.Cluster(<br/>    name="create-synth-array", <br/>    software="coiled-examples/numpy-zarr", <br/>    n_workers=50, worker_cpu=4, <br/>    worker_memory="24Gib", <br/>    backend_options={'spot':'True'}, <br/>)</span></pre><p id="0cd5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">2.将Dask连接到该群集</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="f8a6" class="no la it mv b gy np nq l nr ns">from distributed import Client <br/>client = Client(cluster)</span></pre><p id="3260" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">3.然后轻松地在整个集群上运行计算。</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="3e57" class="no la it mv b gy np nq l nr ns"># load data into array<br/>da_1 = da.from_zarr(<br/>"s3://coiled-datasets/synthetic-data/array-random-370GB.zarr"<br/>) </span><span id="8ecd" class="no la it mv b gy nt nq l nr ns"># run computation over entire array (transpose)<br/>da_2 = da_1.T da_2</span><span id="b541" class="no la it mv b gy nt nq l nr ns">%%time <br/>da_2.to_zarr(<br/>"s3://coiled-datasets/synthetic-data/array-random-370GB-T.zarr"<br/>) </span><span id="326a" class="no la it mv b gy nt nq l nr ns">CPU times: user 2.26 s, sys: 233 ms, total: 2.49 s <br/>Wall time: 1min 32s</span></pre><p id="3690" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们的Coiled集群有50个Dask workers，每个都有24GB RAM，都运行一个包含必要依赖项的预编译软件环境。这意味着我们有足够的资源轻松地转置数组，并将其写回S3。</p><p id="48c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Dask能够并行地为我们完成所有这些工作，而无需将数组加载到本地内存中。它在不到两分钟的时间内将一个372GB的阵列加载、转换并保存回S3。</p><h1 id="6ed2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">保存NumPy数组摘要</h1><p id="0655" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们回顾一下:</p><ul class=""><li id="209d" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">许多存储NumPy数组的常用方法都有很大的局限性。</li><li id="db6a" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">Zarr文件格式提供了强大的压缩选项，支持多个数据存储后端，并且可以并行读/写NumPy数组。</li><li id="42ef" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">Dask允许您充分利用这些并行读/写能力。</li><li id="3f21" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">将Dask连接到按需盘绕的集群允许在大于内存的数据集上进行高效计算。</li></ul><p id="d1ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在LinkedIn 上关注我<a class="ae ky" href="https://www.linkedin.com/in/richard-pelgrim/" rel="noopener ugc nofollow" target="_blank">,了解定期的数据科学和机器学习更新和黑客攻击。</a></p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="8882" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nu">原载于2022年1月5日</em><a class="ae ky" href="https://coiled.io/blog/save-numpy-dask-array-to-zarr/" rel="noopener ugc nofollow" target="_blank"><em class="nu">https://coiled . io</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>