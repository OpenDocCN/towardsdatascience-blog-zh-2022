<html>
<head>
<title>Learning Generics in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在围棋中学习泛型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-generics-in-go-318f53752ccd#2022-01-31">https://towardsdatascience.com/learning-generics-in-go-318f53752ccd#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="74d5" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">在围棋中学习泛型</h1></div><div class=""><h2 id="6d2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">泛型在Go 1.18中发布，是时候学习如何利用这个新特性了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37f1e5728d93628f250cdc21507fb485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsJcRAcgdHOEzEPGk_8DzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泛型的可视化解释，用函数表示的一行，泛型接受多个输入。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="bf42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">泛型在更新1.18(将于2022年2月发布)中推出，带有一系列其他闪亮的新功能。你可以在我的1.18补丁说明摘要中了解所有的变化。</p><div class="lu lv gp gr lw lx"><a href="https://medium.com/@percybolmer/go-1-18-comes-with-many-amazing-changes-d33ac0afd6ee" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">Go 1.18带来了许多惊人的变化</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">期待已久的Go 1.18即将到来，它可能是很长一段时间以来讨论最多的Go更新…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml ks lx"/></div></div></a></div><p id="f17c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始使用1.18，您可以运行或下载它<a class="ae mm" href="https://go.dev/dl/#go1.18beta1" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2eaa" class="ms mt it mo b gy mu mv l mw mx">go install golang.org/dl/go1.18beta1@latest</span></pre><p id="3164" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然还添加了其他一些好东西，但毫无疑问，泛型的实现已经盖过了其他一切。这是一个已经讨论了很长时间的话题，有许多开发者支持它，也有许多反对它。</p><p id="623f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多人觉得泛型棘手而复杂，但是让我们揭开其中的奥秘。一旦你熟悉了它们，就不难使用了。</p><p id="519c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看看什么是泛型，并学习如何使用它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的视频涵盖了泛型，如果你喜欢它胜过文本的话</p></figure><h2 id="b14b" class="ms mt it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">什么是泛型，为什么Go需要泛型</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/85f9d14b2cd31c4050fa335ab32b5055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KHoCrnBbh5s2y9owcwkVlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用函数，允许多种类型的输入和输出。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="c3a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">泛型是一种让函数接受多种数据类型作为相同输入参数的方式。假设您有一个函数，它应该接受一个输入参数，并减去第二个输入参数的值。</p><p id="3c8c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您需要决定使用哪种数据类型，int、int64还是floats。这将迫使任何使用subtract函数的开发人员在使用它之前将其值转换为正确的数据类型。</p><p id="bbc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个解决方案是为int提供一个subtract函数，为floats提供另一个函数，等等，这样就有多个函数做同样的工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">减法使用相同的减法函数，将浮点数转换为整数</p></figure><p id="b63b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果可以跳过类型转换或重复的函数会怎么样？在上面的例子中，我们从float结果中得到错误的结果，因为我们在把它转换成int时去掉了0.5。</p><p id="a85a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，唯一合适的解决方案是拥有重复的函数，一个<code class="fe ns nt nu mo b">Subtract(a,b int) int</code>和一个副本<code class="fe ns nt nu mo b">Subtractfloat(a,b float32) float32</code>。</p><p id="f0d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我说复制功能是唯一的解决方案，我知道你可以使用<code class="fe ns nt nu mo b">interface{}</code>输入和输出解决方案。我不喜欢那个软件，它容易出错，而且很笨重。您还会丢失编译时错误检查，因为编译器不知道您在用那个接口做什么。这很快变得不可维护，并增加了许多额外的代码。</p><p id="9d56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是泛型旨在解决的问题，也是为什么如此多的开发人员非常渴望看到它的发布。</p><p id="1314" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，Go 1.18发布了泛型的第一个草案，解决上述问题的方法很简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通用减法——一个简单的解决方案</p></figure><h2 id="02b9" class="ms mt it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">泛型及其工作原理——泛型函数的基础</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/579676395b6aaf17cc9d418af6590057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvHtIQ_n-L3ErY0bj-ub4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过向第一个函数提供类型参数开始学习泛型。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="d96c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们深入学习泛型的基本用法。</p><p id="0d17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将从常规的<code class="fe ns nt nu mo b">Subtract</code>函数开始，并向它添加通用特性，同时了解我们添加的是什么，以及为什么添加。</p><p id="70be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数的语法是，我们通过声明<code class="fe ns nt nu mo b">func FunctionName</code>来定义函数，声明之后是函数参数。</p><p id="4991" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">功能参数</strong>在<code class="fe ns nt nu mo b">()</code>里面定义，可以任意多。函数参数是通过声明名称，后跟数据类型来定义的。例如<code class="fe ns nt nu mo b">(a int)</code>定义了函数的局部作用域将有一个名为a的整数。</p><p id="d816" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu mo b">Subtract</code>方法有数据类型为int的函数参数<code class="fe ns nt nu mo b">a</code>和<code class="fe ns nt nu mo b">b</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们用它作为学习泛型的基础。</p></figure><p id="19d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，函数参数可能看起来微不足道，但是在进入泛型之前理解它是至关重要的。</p><p id="22c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了函数参数，还有<strong class="la iu">类型参数</strong>。类型参数在<code class="fe ns nt nu mo b">[]</code>内部定义，应该在函数参数<code class="fe ns nt nu mo b">[](a,b int)</code>之前定义。您可以像定义函数参数一样定义类型参数，名称后跟数据类型。</p><blockquote class="nv nw nx"><p id="0f3c" class="ky kz ny la b lb lc ju ld le lf jx lg nz li lj lk oa lm ln lo ob lq lr ls lt im bi translated">类型参数通常是大写的，以便于识别。</p></blockquote><p id="3378" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个例子，我们声明参数V是一个整数，<code class="fe ns nt nu mo b">[V int]</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型参数V已被添加，此代码尚未运行。</p></figure><p id="dc43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数参数和类型参数的区别在于，函数参数在函数的局部范围内可用。如果你像上面那样定义<code class="fe ns nt nu mo b">V</code>，你将不能在函数中使用<code class="fe ns nt nu mo b">V</code>作为变量。类型参数只说明V代表什么数据类型。</p><p id="7914" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用类型参数定义的是，有一个叫做V 的<strong class="la iu">数据类型，它是一个int。这允许我们使用<code class="fe ns nt nu mo b">V</code>作为函数参数中<code class="fe ns nt nu mo b">int</code>的替换，并且在函数范围内。</strong></p><p id="77eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在可以用<code class="fe ns nt nu mo b">V</code>替换<code class="fe ns nt nu mo b">a</code>和<code class="fe ns nt nu mo b">b</code>的数据类型，以及输出到<code class="fe ns nt nu mo b">V</code>的函数</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Subtract现在使用类型参数v。</p></figure><p id="d185" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，你可能认为我们什么也没完成，我们只是用一个更复杂的解决方案替换了<code class="fe ns nt nu mo b">int</code>。而且你是对的，我们还没做完，上面的代码不会编译。不允许像我们一样替换类型参数中的单个数据类型，除非把它放在接口中。</p><p id="c3c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您尝试编译当前的减法函数，您应该会看到一个错误，指出<code class="fe ns nt nu mo b">int is not an interface</code>。</p><p id="9cb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原因是a <code class="fe ns nt nu mo b">type parameter</code>期望一个<code class="fe ns nt nu mo b">type constraint</code>作为值，而不是一个数据类型。约束是函数参数必须满足的<code class="fe ns nt nu mo b">interface</code>。</p><p id="8bb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将通过使用一个<code class="fe ns nt nu mo b">|</code>字符向<code class="fe ns nt nu mo b">type parameter</code>添加第二个数据类型。管道字符用于表示<code class="fe ns nt nu mo b">or</code>，这意味着我们可以向<code class="fe ns nt nu mo b">V</code>参数添加许多不同的数据类型选项。使用<code class="fe ns nt nu mo b">|</code>也是创建新内联<code class="fe ns nt nu mo b">interface</code>的一种简便方式。</p><p id="7ff0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将把int32和float32作为可能的数据类型添加到<code class="fe ns nt nu mo b">V</code>中。这样做将自动创建一个被编译器用作<code class="fe ns nt nu mo b">type constraint</code>的<code class="fe ns nt nu mo b">interface</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用|键入参数，这为我们创建了一个类型约束(接口)</p></figure><p id="842c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以尝试使用带有简单main函数的新<code class="fe ns nt nu mo b">Subtract</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用您的第一个泛型函数</p></figure><p id="a148" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使事情更清楚，我们可以打破类型约束。只是为了让它更容易理解，并且允许约束是可重用的。</p><p id="db4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了创建约束，我们只需声明一个接口<code class="fe ns nt nu mo b">Subtractable</code>，其中包含数据类型。它的语法和我们在类型参数中使用的简写定义是一样的，所以我们可以把它复制出来，我还添加了更多的数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向通用函数添加可减法类型约束</p></figure><p id="e9af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在你成为泛型大师之前的最后一件事。当你调用泛型函数来设置要使用的数据类型时，你可以应用一个类型参数，当我们到达更高级的用法时，这将更有意义。</p><p id="98c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">添加的方法是再次使用类型参数，但这次是在函数调用之前。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="dc5f" class="ms mt it mo b gy mu mv l mw mx">result := Subtract[int](a, b)</span></pre><h2 id="a915" class="ms mt it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">类型参数和波浪号(~)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0dc5e56de686a9f79ab3ff1a1e243a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmUKsfbdHD0uSq8hx0d8kg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型参数被提供给函数调用以指定数据类型。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="ddfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们现在可以使用通用函数了，但是还有一些细节。想象一下，如果你想控制在一个通用函数中使用的数据类型？</p><p id="df64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设您想要使用我们创建的<code class="fe ns nt nu mo b">Subtract</code>函数，它将推断数据类型，除非被明确告知。您可以通过<strong class="la iu">类型参数</strong>来实现这一点，语法与定义通用函数时相同。您可以在参数前的括号中提供数据类型。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e488" class="ms mt it mo b gy mu mv l mw mx">Subtract[int](10,20) // Will be using int datatype <br/>Subtract[int64](10,20) // Will be using int64 datatype</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go —在调用函数时使用类型参数来决定要使用的数据类型</p></figure><p id="c255" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">霍雷。我们现在甚至可以告诉函数使用什么数据类型，太棒了！</p><p id="7ab8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这里仍然有一个问题。如果您的数据类型是Subtractable中任何类型的别名/派生类型，该怎么办？</p><p id="6c50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您将无法以我们当前声明的可减法的方式使用您的数据类型。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="e39c" class="ms mt it mo b gy mu mv l mw mx">// create a custom int derived from int<br/>type MyOwnInteger int</span><span id="b1c1" class="ms mt it mo b gy oc mv l mw mx">var myInt MyOwnInteger<br/>myInt = 10<br/>Subtract(myInt, 20) // This will Crash, Since myInt is not Subtractable</span></pre><p id="3788" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，Go团队还添加了<code class="fe ns nt nu mo b">~</code>，它告诉约束，从给定类型派生的任何类型都是允许的。在下面的例子中，我们允许<code class="fe ns nt nu mo b">MyOwnInteger</code>成为<code class="fe ns nt nu mo b">Subtractable</code>的一部分，方法是在它前面加上<code class="fe ns nt nu mo b">~</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用~允许别名类型成为类型约束的一部分</p></figure><h2 id="22a4" class="ms mt it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">通用类型，任何&amp;可比较的</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33989101309816e88534a72a6d5d6db5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-_GO9_PJC8huD4XRtpqGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go中引入的新别名将用作类型约束，any和comparable。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="2b7c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经讲述了<code class="fe ns nt nu mo b">generic functions</code>，现在是时候讲述<code class="fe ns nt nu mo b">generic types</code>了。</p><p id="97d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要创建一个泛型类型，你必须定义一个新的类型，并给它一个类型参数。为了了解这一点，我们将创建一个<code class="fe ns nt nu mo b">Results</code>类型，它是在先前创建的<code class="fe ns nt nu mo b">Subtractable</code>约束中找到的任何数据类型的一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泛型类型结果是可减法数据类型的一部分。</p></figure><p id="bc9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">语法不应该是新的，我希望您现在能够理解泛型类型定义中发生了什么。它与前面的示例相同。在本例中，我们创建了一个数据条目属于数据类型<code class="fe ns nt nu mo b">Subtractable</code>的切片，从而告诉编译器当结果切片被初始化时，必须定义包含在可减法接口中的类型。</p><p id="4680" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使用结果，我们将更新main函数，并注意当创建变量时，我们如何定义<code class="fe ns nt nu mo b">Results</code>片将要使用的数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用结果通用类型(通用数据类型的一部分)</p></figure><p id="58bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我已经知道你在想什么，我们能说<code class="fe ns nt nu mo b">Results</code>应该使用<code class="fe ns nt nu mo b">Subtractable</code>类型约束吗？</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="878d" class="ms mt it mo b gy mu mv l mw mx">var resultStorage Results[Subtractable]</span></pre><p id="a753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遗憾的是，Subtractable是一个类型约束，我们不能在<code class="fe ns nt nu mo b">Results</code>的初始化中使用它。这样做会触发编译错误<code class="fe ns nt nu mo b">interface contains type constraints</code>。</p><p id="95dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以做的是使用新引入的any来允许<code class="fe ns nt nu mo b">Results</code>保存任何数据类型。<code class="fe ns nt nu mo b">any</code>是<code class="fe ns nt nu mo b">interface{}</code>的别名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ResultStorage现在可以保存减法运算的所有值。</p></figure><p id="84a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还不完善，是初稿。我希望我们能在未来看到添加<code class="fe ns nt nu mo b">Subtractable</code>的方法，避免使用<code class="fe ns nt nu mo b">any</code>，因为它允许我们添加各种数据类型。</p><p id="1b08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有另一个名为<code class="fe ns nt nu mo b">comparable</code>的新类型，它是一个类型约束，可以通过使用<code class="fe ns nt nu mo b">==</code>或<code class="fe ns nt nu mo b">!=</code>进行比较的任何数据类型都可以满足这个约束。</p><p id="6f75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">熟悉这些词很重要，因为随着社区对泛型越来越熟悉，你可能会看到它们到处出现。</p><h2 id="38e1" class="ms mt it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">接口约束和通用结构</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/41dfe7c9d50a899f46c915a657b09776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*feWuYQyAhQ3Frotw_qn4-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">接口可以用作类型约束。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="4fea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，我们只使用了单个约束和输出。我们只使用了<code class="fe ns nt nu mo b">type constraints</code>，但是也可以使用接口作为约束。</p><p id="92a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们尝试创建一个接受名为<code class="fe ns nt nu mo b">Moveable</code>的接口的通用函数。该函数将简单地触发输入类型的<code class="fe ns nt nu mo b">Move</code>，任何实现该接口的结构都应该能够<code class="fe ns nt nu mo b">Move</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Move —具有输入v必须可移动的约束的通用函数</p></figure><p id="681b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你应该熟悉这个语法，我们创建了一个约束，说类型V必须是<code class="fe ns nt nu mo b">Moveable</code>，输入参数V是类型V</p><p id="2c39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还将创建一个<code class="fe ns nt nu mo b">Person</code>和一个<code class="fe ns nt nu mo b">Car</code>来试用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">移动多个结构的一般方式。</p></figure><p id="514c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，为了保持简单，我们只使用了一个通用参数。但是请记住，您可以添加多个，并输出多个。</p><p id="2fe2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们将<code class="fe ns nt nu mo b">Moveable</code>和<code class="fe ns nt nu mo b">Subtractable</code>约束组合到<code class="fe ns nt nu mo b">Move</code>函数中，允许用户添加一个<code class="fe ns nt nu mo b">Distance</code>值，我们用它来计算离目标还有多远。</p><p id="bcfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要添加更多类型约束，只需在<code class="fe ns nt nu mo b">[]</code>中添加参数，就像常规参数一样。我们将添加定义为<code class="fe ns nt nu mo b">S</code>的<code class="fe ns nt nu mo b">Subtractable</code>类型，而不是接受<code class="fe ns nt nu mo b">meters</code>为<code class="fe ns nt nu mo b">Int</code>，我们将允许它为<code class="fe ns nt nu mo b">S</code></p><p id="7d01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们的<code class="fe ns nt nu mo b">Move</code>函数在两个<code class="fe ns nt nu mo b">Type Constraints</code>中的样子</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="cd02" class="ms mt it mo b gy mu mv l mw mx">func Move[V Moveable, S Subtractable](v V, distance S, meters S) S</span></pre><p id="b4ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，仅仅这个改变就会导致编译器崩溃，因为<code class="fe ns nt nu mo b">Move</code>函数接受了一个<code class="fe ns nt nu mo b">Int</code>并且<code class="fe ns nt nu mo b">Moveable</code>定义了这是Move应该工作的方式。所以我们需要让<code class="fe ns nt nu mo b">Move</code>接受<code class="fe ns nt nu mo b">Subtractable</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向Move函数添加Subtractable并将Int改为Subtractable</p></figure><p id="ef6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这看起来很棒，对吧？！可悲的是，上面的要点不是一个工作示例，这只是我们想要完成的伪代码。上面的代码不会编译，编译器会生气地对你大喊大叫，因为我们在一个<code class="fe ns nt nu mo b">Interface</code>里面使用了一个<code class="fe ns nt nu mo b">Type Constraint</code>，这是不允许的，记得吗？</p><p id="a4fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是有一种方法可以得到我们想要的东西。泛型结构是在初始化期间定义其数据类型的结构。</p><blockquote class="od"><p id="a9b1" class="oe of it bd og oh oi oj ok ol om lt dk translated">特别感谢<a class="ae mm" href="https://www.reddit.com/user/ar1819/" rel="noopener ugc nofollow" target="_blank"> u/ar1819 </a>帮助我找到这个解决方案</p></blockquote><p id="77da" class="pw-post-body-paragraph ky kz it la b lb on ju ld le oo jx lg lh op lj lk ll oq ln lo lp or lr ls lt im bi translated">我们需要为<code class="fe ns nt nu mo b">interface</code>定义<code class="fe ns nt nu mo b">S</code>类型，就像我们为通用函数所做的一样。通过简单地将<code class="fe ns nt nu mo b">[S Subtractable]</code>添加到<code class="fe ns nt nu mo b">interface</code>声明中，我们可以说该结构不仅需要相同的方法集作为接口的一部分，还需要成为一个<code class="fe ns nt nu mo b">Generic Struct</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向接口添加类型约束</p></figure><p id="97d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果这是合同的规则，让我们将它添加到<code class="fe ns nt nu mo b">Car</code>和<code class="fe ns nt nu mo b">Person</code>中。这些结构现在将被命名为<code class="fe ns nt nu mo b">Generic</code>。这意味着当创建一个对象时，您还必须定义用于该对象的数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这就是如何在Go中声明泛型结构</p></figure><p id="1f90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了创建我们的汽车和人，我们需要指定他们使用什么数据类型。这是作为所有通用特征使用<code class="fe ns nt nu mo b">[]</code>完成的。记住，它们被称为<strong class="la iu">类型参数。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始化两个泛型结构，使用[]分配数据类型</p></figure><p id="ac74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们现在使用的是<code class="fe ns nt nu mo b">Person[S Subtractable]</code>，而不仅仅是<code class="fe ns nt nu mo b">Person</code>，所以所有的方法都需要使用这个初始化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使泛型结构成为可移动接口的一部分需要设置[S]</p></figure><p id="7803" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还应该通过升级成使<code class="fe ns nt nu mo b">Move</code>函数现在接受一个<code class="fe ns nt nu mo b">Generic Movable</code>，并且还接受<code class="fe ns nt nu mo b">Subtractable</code>约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可移动必须定义其类型</p></figure><p id="ee25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们准备创建<code class="fe ns nt nu mo b">main</code>函数，它使用了我们已经完成的所有事情。使用<code class="fe ns nt nu mo b">Car</code>的第一个<code class="fe ns nt nu mo b">Move</code>调用很容易理解，这是因为我们使用了<code class="fe ns nt nu mo b">int</code>，编译器会默认使用。</p><p id="5ec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，第二个调用更加复杂，因为我们现在想要使用<code class="fe ns nt nu mo b">float64</code>数据类型。要做到这一点，我们需要在定义<strong class="la iu">类型参数</strong>的地方，为<code class="fe ns nt nu mo b">Move()</code>调用添加常规的<code class="fe ns nt nu mo b">[]</code>。在这种情况下，<code class="fe ns nt nu mo b">Moveable</code>将是一个初始化为float64的<code class="fe ns nt nu mo b">Person</code>。<code class="fe ns nt nu mo b">Subtractable</code>的数据类型也将是float64。所以类型定义会是<code class="fe ns nt nu mo b">[Person[float64], float64]Move()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为汽车和人调用移动功能</p></figure><p id="b3e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个技巧是考虑放置类型参数的顺序。我们可以通过重新排序<code class="fe ns nt nu mo b">Move</code>中的类型参数来避免<code class="fe ns nt nu mo b">Move[Person[float64], float64]</code>。这要归功于编译器和运行时推断数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr mz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型参数的排序在语法上更好</p></figure><h2 id="998b" class="ms mt it bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">结论</h2><p id="6da8" class="pw-post-body-paragraph ky kz it la b lb os ju ld le ot jx lg lh ou lj lk ll ov ln lo lp ow lr ls lt im bi translated">祝贺你，如果你在这里成功了，你现在是仿制药领域的专家了！</p><p id="a02a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你会发现它们是有用的，我知道许多人一直在等待这个版本。许多人创建了自己的库，用于对切片、使用队列的地图等进行排序。很快可能会有很多新的包和新的API用于旧的库。</p><p id="66b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多用例对于泛型来说都很棒，但是有时候反而容易让事情变得有点复杂。尝试只在有实际用例时使用它们。</p><p id="f026" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢我写的东西，不要错过我的指南，它提供了围棋中的模糊功能！</p><div class="lu lv gp gr lw lx"><a href="https://medium.com/@percybolmer/fuzzy-testing-in-go-96eb08b7694d" rel="noopener follow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iu gy z fp mc fr fs md fu fw is bi translated">围棋模糊测试</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Fuzzing是作为Go 1.18中标准库的一部分发布的。这是一个很酷的方法来定位你的…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">medium.com</p></div></div><div class="mg l"><div class="ox l mi mj mk mg ml ks lx"/></div></div></a></div><p id="8c66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">走出去，成为普通人！</p></div></div>    
</body>
</html>