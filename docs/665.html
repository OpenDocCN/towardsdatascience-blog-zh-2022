<html>
<head>
<title>5 Advanced Tips on Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Decorators的5个高级技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-advanced-tips-on-python-decorators-113307d5a92c#2022-01-24">https://towardsdatascience.com/5-advanced-tips-on-python-decorators-113307d5a92c#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="f8e9" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Python Decorators的5个高级技巧</h1></div><div class=""><h2 id="bea6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你想写出简洁、易读、高效的代码吗？嗯，python decorators可能会在您的旅程中帮助您。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0eb9b0eb19d4eb7c1cd7d08eff538fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jRrWcGQepqSmMyL0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">毛里西奥·穆尼奥斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Fluent Python的第7章中，卢西亚诺·拉马尔霍讨论了装饰器和闭包。它们在基本的DS工作中并不常见，但是当您开始编写异步代码来构建生产模型时，它们就成为了一个无价的工具。</p><p id="6efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事不宜迟，我们开始吧。</p><h1 id="f52a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1 —什么是室内设计师？</h1><p id="8772" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们进入技巧之前，让我们先了解一下装饰者是如何工作的。</p><p id="d25e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">装饰器是简单的接受一个函数作为输入的函数。从语法上来说，它们通常被描述为“修饰”函数上方的一行中的<code class="fe mp mq mr ms b">@my_decorator</code>,例如…</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5f43" class="mx lt iq ms b gy my mz l na nb">temp = 0</span><span id="d1cc" class="mx lt iq ms b gy nc mz l na nb">def decorator_1(func):<br/>  print('Running our function')<br/>  return func</span><span id="52f3" class="mx lt iq ms b gy nc mz l na nb">@decorator_1<br/>def temperature():<br/>  return temp</span><span id="5a18" class="mx lt iq ms b gy nc mz l na nb">print(temperature())</span></pre><p id="a639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，真正发生的是当我们调用<code class="fe mp mq mr ms b">temperature()</code>时，我们只是运行<code class="fe mp mq mr ms b">decorator_1(temperature())</code>，如下所示…</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="487e" class="mx lt iq ms b gy my mz l na nb">temp = 0</span><span id="b350" class="mx lt iq ms b gy nc mz l na nb">def decorator_1(func):<br/>  print('Running our function')<br/>  return func</span><span id="ff05" class="mx lt iq ms b gy nc mz l na nb">def temperature():<br/>  return temp</span><span id="0b8b" class="mx lt iq ms b gy nc mz l na nb">decorator_1(temperature())</span></pre><p id="eb2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，<strong class="ky ir">所以decorators是以另一个函数作为参数的函数。但是我们为什么要这么做呢？</strong></p><p id="3e0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，装修工真的是多才多艺，厉害。它们通常用于异步回调和函数式编程。还可以利用它们在函数中构建类似类的功能，从而减少开发时间和内存消耗。</p><p id="37ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们进入一些提示…</p><h1 id="ef0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2 —属性装饰者</h1><p id="281c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:使用内置的</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">@property</strong></code> <strong class="ky ir">来增强setter/getter功能。</strong></p><p id="cc2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最常见的内置装饰器之一是<code class="fe mp mq mr ms b">@property</code>。许多OOP语言，比如Java和C++，建议使用getter/setter范例。这些函数用于确保我们的变量不会返回/被赋予不正确的值。一个例子是要求我们的<code class="fe mp mq mr ms b">temp</code>变量大于绝对零度…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4d1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe mp mq mr ms b">@property</code>方法增加很多这种功能，使我们的代码更具可读性和动态性…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="51ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，为了简洁起见，我们删除了<code class="fe mp mq mr ms b">my_setter()</code>中的所有条件逻辑，但是概念是相同的。<code class="fe mp mq mr ms b">c.temperature</code>不是比<code class="fe mp mq mr ms b">c.my_getter()</code>可读性强很多吗？我当然这么认为。</p><p id="3493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但在我们继续之前，有一个重要的挑剔之处。<strong class="ky ir">在python中，没有私有变量这种东西。</strong>前缀<code class="fe mp mq mr ms b">_</code>表示变量是受保护的，不应该在类外引用。但是，您仍然可以…</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="298f" class="mx lt iq ms b gy my mz l na nb">c = my_vars(500)<br/>print(c._temp)      # 500</span><span id="a6f7" class="mx lt iq ms b gy nc mz l na nb">c._temp = -10000<br/>print(c._temp)      # -1000</span></pre><p id="ee7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">python中不存在真正的私有变量，这是一个有趣的设计选择。论点是OOP中的私有变量实际上并不是私有的——如果有人想访问它们，他们可以改变源类的代码，使变量成为公共的。</p><p id="47e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python鼓励“负责任的开发”，并允许你从外部访问类中的任何东西。</p><h1 id="95a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3 —类方法和静态方法</h1><p id="3a4a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:使用内置的</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">@classmethod</strong></code> <strong class="ky ir">和</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">@staticmethod</strong></code> <strong class="ky ir">来扩充类功能。</strong></p><p id="69c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个装饰者经常被混淆，但是他们的区别非常明显。</p><ul class=""><li id="321d" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated"><code class="fe mp mq mr ms b">@classmethod</code>将类作为参数。它绑定到<strong class="ky ir">类本身，</strong>而不是类实例。因此，它<strong class="ky ir">可以</strong>跨所有实例访问或修改该类。</li><li id="c9cb" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated"><code class="fe mp mq mr ms b">@staticmethod</code>不把类作为参数。它绑定到<strong class="ky ir">类实例，</strong>而不是类本身。因此，它<strong class="ky ir">根本不能</strong>访问或修改这个类。</li></ul><p id="36ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个例子…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">classmethods最大的用例是它们作为我们类的可选构造函数的能力，这对于<a class="ae kv" href="https://stackoverflow.com/questions/5738470/whats-an-example-use-case-for-a-python-classmethod" rel="noopener ugc nofollow" target="_blank">多态性</a>非常有用。即使你没有在继承上做什么疯狂的事情，不用if/else语句就能实例化类的不同版本也是不错的。</p><p id="1f36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，静态方法通常用作完全独立于类状态的实用函数。注意，我们的<code class="fe mp mq mr ms b">isAdult(age)</code>函数不需要通常的<code class="fe mp mq mr ms b">self</code>参数，所以即使它想引用，也不能引用这个类。</p><h1 id="15f3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4 —快速提示</h1><p id="ff78" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">提示:使用</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">@functools.wraps</strong></code> <strong class="ky ir">保存函数信息。</strong></p><p id="8a35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，装饰器只是接受另一个函数作为参数的函数。所以，当我们调用装饰函数时，我们实际上首先调用了装饰器。这个流程覆盖了关于修饰函数的信息，比如<code class="fe mp mq mr ms b">__name__</code>和__doc__字段。</p><p id="f97d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了克服这个问题，我们可以利用另一个装饰者…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ba28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有<code class="fe mp mq mr ms b">@wraps</code>装饰器，我们的打印语句的输出如下。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="ea17" class="mx lt iq ms b gy my mz l na nb">print(f(5))        # 30<br/>print(f.__name__)  # 'call_func'<br/>print(f.__doc__)   # ''</span></pre><p id="8f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为了避免覆盖重要的函数信息，一定要使用</strong> <code class="fe mp mq mr ms b"><strong class="ky ir">@functools.wraps</strong></code> <strong class="ky ir">装饰器。</strong></p><h1 id="8990" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5-创建自定义装饰器</h1><p id="335b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">提示:构建你自己的装饰器来扩充你的工作流程，但是要小心。</p><p id="67b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">decorators中的变量作用域有点奇怪。我们没有时间深入细节，但如果你真的如此专注，这里有一篇29分钟的文章。请注意，如果出现以下错误，请仔细阅读decorator scope:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/e9c907e34cd8fe2414591afab1b2c5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zk_U_ikYLPw3UxZ2G_33cw.png"/></div></div></figure><p id="0dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个免责声明，让我们继续看一些有用的自定义装饰器…</p><h2 id="38e5" class="mx lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">5.1 —基于装饰器的商店功能</h2><p id="f27b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的代码在函数被调用时将它们附加到一个列表中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f9c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个潜在的用例是单元测试，就像<a class="ae kv" href="https://docs.pytest.org/en/6.2.x/" rel="noopener ugc nofollow" target="_blank"> pytest </a>一样。假设我们有快速测试和慢速测试。我们可以给每个函数添加一个<code class="fe mp mq mr ms b">@slow</code>或<code class="fe mp mq mr ms b">@fast</code>装饰器，然后调用相应列表中的每个值，而不是手动将每个函数分配给一个单独的列表。</p><h2 id="6489" class="mx lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">5.2 —时间数据查询或模型训练</h2><p id="8097" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的代码打印了你的函数的运行时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c5d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在运行任何类型的数据查询或使用错误日志训练模型，那么估计运行时间真的很有用。仅仅通过一个<code class="fe mp mq mr ms b">@time_it</code>装饰器，您就可以获得任何函数的运行时估计。</p><h2 id="6a87" class="mx lt iq bd lu nu nv dn ly nw nx dp mc lf ny nz me lj oa ob mg ln oc od mi oe bi translated">5.3-对功能输入执行流量控制</h2><p id="485a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">以下代码在执行函数之前对函数参数执行条件检查。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个装饰器对我们所有函数的参数<code class="fe mp mq mr ms b">x</code>应用条件逻辑。如果没有装饰器，我们必须将<code class="fe mp mq mr ms b">if is not None</code>流控制写入每个函数。</p><p id="8c82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些只是几个例子。装修工真的很有用！</p></div><div class="ab cl of og hu oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="ij ik il im in"><p id="aa5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="om">感谢阅读！我会再写18篇文章，把学术研究带到DS行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>