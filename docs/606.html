<html>
<head>
<title>Querying Hierarchical API’s with Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用递归查询分层API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/going-down-the-rabbit-hole-querying-hierarchical-apis-with-recursion-6d48fe40f591#2022-01-20">https://towardsdatascience.com/going-down-the-rabbit-hole-querying-hierarchical-apis-with-recursion-6d48fe40f591#2022-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="6618" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用递归查询分层API</h1></div><div class=""><h2 id="0f82" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写从ICD API中提取关系的递归函数的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3a81ecdadf4786bc3b8f7cc2d679735a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QDEj-rQPUKTWj52N"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Brannon Naito 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="171a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归是强大的，但我总是被它吓倒。最近，我需要从API中提取层次数据，我意识到递归很有意义，所以我不得不面对自己的恐惧。如果你也不喜欢递归，并且希望看到一个实际的例子，那么这篇指南可能会有所帮助。</p><h2 id="e6cb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">ICD——国际疾病分类</h2><p id="ad5b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我将解释ICD-10诊断代码以及它们是如何存储在ICD API(<a class="ae kv" href="http://icd.who.int/icdapi" rel="noopener ugc nofollow" target="_blank">icd.who.int/icdapi</a>)中的。当患者寻求医疗保健服务时，医疗保健提供者会提供ICD诊断代码，以便付款人可以了解就诊原因和他们接受治疗的目的。ICD诊断代码有三个或三个以上的字符，以字母开头，后跟数字。例如，如果提供者诊断患者患有额叶脑癌，他们可以使用代码C711，即“额叶恶性肿瘤”(尽管他们可以选择使用未指明的代码，如C719，即“脑恶性肿瘤，未指明”，例如，如果它存在于多个位置)。如果我们想分析脑癌患者，我们可能不关心肿瘤的确切位置，所以我们需要一种方法来分组所有脑癌代码。</p><p id="0e57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在ICD-10分级体系中，以C71开头的编码都是“脑恶性肿瘤”的编码，C71编码属于C69-C72的更广泛类别，即“眼、脑和中枢神经系统其他部分的恶性肿瘤”。我们可以到C00-D49的另一个层次，它代表所有肿瘤的编码。这就是我们想要提取的层次结构。</p><p id="2592" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种结构很有帮助——因为它允许我们在不同的粒度级别上分析数据。我们可能希望通过广泛的疾病类别进行分析，如癌症、呼吸系统疾病、消化道疾病、感染等。或者，我们可能希望通过分析更具体的疾病，如皮肤癌或志贺氏菌感染，进行更深入的研究。如果我们可以简单地采用ICD代码的第一个<em class="mq"> n </em>字符来获得不同的粒度级别，那就太好了，但是正如我们在脑癌例子中看到的，我们有一些以C6开头的代码与以C7开头的代码分组，并且不是所有的C6代码都在同一个组中。事实上，一些疾病组以C6开始(C60-C63代表“男性生殖器官的恶性肿瘤”，C64-C68代表“泌尿道的恶性肿瘤”，C69-C72代表“眼、脑和中枢神经系统其他部分的恶性肿瘤”)。</p><p id="463a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">icd10data.com网站有助于将这种层级形象化。点击<a class="ae kv" href="https://www.icd10data.com/ICD10CM/Codes" rel="noopener ugc nofollow" target="_blank">页面</a>上的链接，您可以看到不同疾病类别是如何分组的，以及代码是如何随着深入而变得更加具体的。</p><h2 id="78a9" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> ICD API </strong></h2><p id="9976" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">icd.who.int/icdapi的ICD API(<a class="ae kv" href="http://icd.who.int/icdapi" rel="noopener ugc nofollow" target="_blank"/>)包含了这种有价值的层次结构信息。通过一些简单的python请求，我们可以提取层次结构中每一层包含的信息，并确定下一层是什么代码。首先，让我们做好准备。您需要创建一个帐户，并获得自己的客户ID和客户机密。我将凭据存储在我的凭据管理器(Windows)中，并使用密匙环包来访问它们。一旦有了凭证，就可以生成一个访问令牌。令牌的使用时间是有限的，稍后会详细介绍。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c974" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经设置好了，我们可以编写一些函数来从API中提取数据，并将其作为JSON返回。每个请求都会返回一个名为“child”的元素，这就是递归的由来。我们将从层次结构的顶层开始，获取顶层URI的所有子节点，找到这些子节点的所有子节点，依此类推，直到我们遇到没有子节点的URI。</p><p id="7d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子。我们从https://id.who.int/icd/release/10的URI <a class="ae kv" href="https://id.who.int/icd/release/10" rel="noopener ugc nofollow" target="_blank">开始，找到http://id.who.int/icd/release/10/2019</a><a class="ae kv" href="http://id.who.int/icd/release/10/2019" rel="noopener ugc nofollow" target="_blank">的最新版本URI。我们将其保存为变量<em class="mq"> uri_latest </em>。从那里，我们可以使用函数<em class="mq"> get_contents </em>来查找最新版本的所有子链接。之后，我们可以对每个孩子重复相同的过程，以捕获ICD诊断代码的层次结构。</a></p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="be59" class="ls lt iq mu b gy my mz l na nb">#Children links (corresponds to links on <a class="ae kv" href="https://www.icd10data.com/ICD10CM/Codes" rel="noopener ugc nofollow" target="_blank">https://www.icd10data.com/ICD10CM/Codes</a>)</span><span id="27e0" class="ls lt iq mu b gy nc mz l na nb">In: get(uri_latest)<br/>Out:</span><span id="0e2f" class="ls lt iq mu b gy nc mz l na nb">{'@context': 'http://id.who.int/icd/contexts/contextForTopLevel.json',<br/> '@id': 'http://id.who.int/icd/release/10/2019',<br/> 'title': {'@language': 'en',<br/>  '@value': 'International Statistical Classification of Diseases and Related Health Problems 10th Revision (ICD-10) Version for 2019'},<br/> 'releaseDate': '2020-02-01',<br/> 'child': ['http://id.who.int/icd/release/10/2019/I',<br/>  'http://id.who.int/icd/release/10/2019/II',<br/>  'http://id.who.int/icd/release/10/2019/III',<br/>  'http://id.who.int/icd/release/10/2019/IV',<br/>  'http://id.who.int/icd/release/10/2019/V',<br/>  'http://id.who.int/icd/release/10/2019/VI',<br/>  'http://id.who.int/icd/release/10/2019/VII',<br/>  'http://id.who.int/icd/release/10/2019/VIII',<br/>  'http://id.who.int/icd/release/10/2019/IX',<br/>  'http://id.who.int/icd/release/10/2019/X',<br/>  'http://id.who.int/icd/release/10/2019/XI',<br/>  'http://id.who.int/icd/release/10/2019/XII',<br/>  'http://id.who.int/icd/release/10/2019/XIII',<br/>  'http://id.who.int/icd/release/10/2019/XIV',<br/>  'http://id.who.int/icd/release/10/2019/XV',<br/>  'http://id.who.int/icd/release/10/2019/XVI',<br/>  'http://id.who.int/icd/release/10/2019/XVII',<br/>  'http://id.who.int/icd/release/10/2019/XVIII',<br/>  'http://id.who.int/icd/release/10/2019/XIX',<br/>  'http://id.who.int/icd/release/10/2019/XX',<br/>  'http://id.who.int/icd/release/10/2019/XXI',<br/>  'http://id.who.int/icd/release/10/2019/XXII'],<br/> 'browserUrl': 'http://apps.who.int/classifications/icd10/browse/2019/en'}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="4247" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">API时间限制</h2><p id="ae16" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当我开始这个过程的时候，事情看起来很好，运行良好。然而，大约一个小时后，递归过程失败了，我意识到这是因为我的访问令牌已经过期了。这意味着我需要一种方法来跟踪我使用令牌的时间，并在它过期之前更新它。要在递归函数中做到这一点，需要跟踪全局范围内的变量。由于函数一遍又一遍地调用自己，在局部范围内使用变量将是一件痛苦的事情。</p><p id="64b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是更新“get”函数中使用的令牌和头的两个函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h2 id="3ff3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">递归</h2><p id="2ddf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后，我们需要一个地方来存储我们查询过的所有信息。同样，我们使用一个全局变量'<em class="mq"> dfs </em>'，它是我们已经提取并将在最后组合的所有关系的列表。列表中的每个项目将包含父代码和父标题，以及子代码和子标题，从而创建一个树形结构。</p><p id="c683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的递归函数将需要使用<em class="mq"> get_contents </em>函数找到一个URI的所有相关信息，将我们想要的存储在我们的全局变量<em class="mq"> dfs </em>中，然后在URI的每个子节点上调用自己来继续这个过程。此时，它会在发出下一个请求之前检查令牌和报头是否需要更新。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fe1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显示数据框，我们从根节点(没有父节点)开始，找到它下面的所有关系，从“某些感染和寄生虫病”开始。然后，递归从“肠道传染病”开始，遍历“某些感染和寄生虫病”的所有子分类。接下来，从“霍乱”开始，它进入子类。在它收集了所有特定的霍乱诊断代码后，它会继续处理“伤寒和副伤寒”等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/421973e87c40082ed258a4aa09e6283a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JT1lwytxYFFCSUZpQWwWig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者创造的形象</p></figure><p id="7387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在让这个函数在我的机器上运行了大约4个小时之后，我能够捕捉到ICD码和它们的层次结构之间的所有关系。需要进行一些清理，以便从树结构中将它组织成一个有用的表，但是一旦有了树结构，我就可以通过用层次结构中更高级别的代码替换原始诊断代码来改变分析的粒度。这让我可以更容易地比较类似情况的患者。</p><p id="edfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇指南能启发你在有意义的地方使用递归。你可以在我的GitHub<a class="ae kv" href="https://github.com/patricknormile/examples/blob/main/icdAPI_recursion_example.py" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/patricknormile/examples/blob/main/ICD API _ recursion _ example . py</a>上找到完整的代码</p><p id="051b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>