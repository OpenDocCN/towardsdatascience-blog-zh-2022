<html>
<head>
<title>How to Plot a Confusion Matrix from a K-Fold Cross-Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从K倍交叉验证中绘制混淆矩阵</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-plot-a-confusion-matrix-from-a-k-fold-cross-validation-b607317e9874#2022-01-15">https://towardsdatascience.com/how-to-plot-a-confusion-matrix-from-a-k-fold-cross-validation-b607317e9874#2022-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="7d99" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a></h2><div class=""><h1 id="ce37" class="pw-post-title jb jc it bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">如何从K倍交叉验证中绘制混淆矩阵</h1></div><div class=""><h2 id="d75a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">绘制k倍交叉验证评估中涉及的所有折叠的组合混淆矩阵</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/42ae50688a8ebd93224c00c18414ca30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d2wXnJhoueLEfpuv9mFujw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae lh" href="https://unsplash.com/s/photos/fold?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h1 id="3e93" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">背景</h1><p id="b6c2" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当评估机器学习模型的性能时，通常将数据分成训练集和测试集，例如通过采样80%的数据用于训练，20%用于测试。</p><p id="4b09" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">该模型适合训练数据，然后可以使用一系列指标进行评估和调整，包括准确度、精确度、召回率、f1分数等。</p><p id="2f7f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最终，机器学习模型将根据测试数据进行性能评估，这些测试数据被放在一边并从训练中排除，因为根据模型建立过程中未使用的新数据进行评估可以更好地表明这些模型在现实世界中的表现。</p><p id="7340" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，这种方法有时会有问题。在我参加的Kaggle比赛中，我经常欣喜地发现，我的最新算法在我保留的测试数据中表现如此之好，结果却在Kaggle验证数据中进行了测试，结果发现性能很差。</p><p id="68ce" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这到底是怎么回事？好吧，在那些Kaggle比赛中，我绞尽脑汁也没能爬上领先的位置，我得出结论，我只是幸运地选择了测试数据的样本，并在性能上得了高分。</p><p id="b042" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这就是k倍交叉验证的用武之地。</p><p id="9c26" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">交叉验证不是抽取20%的数据用于测试，剩下的80%用于训练，而是多次抽取数据，每次抽取不同的一组数据用于测试和训练。它可以被形象化如下:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/2fc591fb516167b5a0ab9022514af915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BbGueObj0svWFF8vs4sVtA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="44fc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意:实际上褶皱并不像这样整洁干净。上图给人的印象是，训练数据和测试数据都是连续的(即，这些行彼此紧邻)，但实际情况并非如此。</p><p id="9052" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在<code class="fe nc nd ne nf b">scikit-learn</code>库中，我在第一个“测试数据”块中可视化的行集实际上是从整个数据集中采样的，但为了学习交叉验证是如何工作的，简化的可视化更容易理解。</p><p id="e904" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这些数据被分成5个“折叠”,这可以在Python中使用<code class="fe nc nd ne nf b">scikit-learn</code>库实现，如下所示</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ni"><img src="../Images/ddeb45ca0799c4410753e94d4f604214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7BXoSEcUC8LcK2qa8QFvwg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="8668" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">请注意:我从ka ggle(<a class="ae lh" href="https://www.kaggle.com/nicapotato/womens-ecommerce-clothing-reviews" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/nica potato/womens-ecommerce-clothing-reviews</a>)选择了一个数据集，该数据集获得了“CC0: Public Domain”许可，这意味着“你可以复制、修改、分发和执行该作品，即使是出于商业目的，都无需请求许可”(详见<a class="ae lh" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/publicdomain/zero/1.0/</a>)。</p><p id="eab6" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对<code class="fe nc nd ne nf b">KFold</code>的调用创建了分为训练集和测试集的5个“折叠”数据，对<code class="fe nc nd ne nf b">cross_val_score</code>的调用执行以下操作</p><ol class=""><li id="2617" class="nj nk it mc b md mw mg mx mj nl mn nm mr nn mv no np nq nr bi translated">迭代5次折叠中的每一次</li><li id="a2a1" class="nj nk it mc b md ns mg nt mj nu mn nv mr nw mv no np nq nr bi translated">对于每个折叠，使模型适合为训练保留的4/5的数据</li><li id="ca18" class="nj nk it mc b md ns mg nt mj nu mn nv mr nw mv no np nq nr bi translated">针对为测试保留的1/5数据评估模型的性能</li></ol><p id="7361" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对<code class="fe nc nd ne nf b">cv_results.mean()</code>的调用计算所有5次折叠的性能平均值，作为一个单一的数字，比单一的训练/测试分割方法更有可能给出生产性能的更好指示。</p><h1 id="cab3" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">问题是</h1><p id="bd31" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我发现交叉验证的一个问题是，我喜欢为我的分类机器学习算法绘制一个混淆矩阵，以帮助我可视化性能，但没有直接和即时的方法来做到这一点。</p><p id="5e33" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果我执行了单个训练/测试分割，我将使模型适合训练数据，然后我可以使用模型来预测测试数据的类别，并将这些类别与实际类别一起传递到混淆矩阵中。</p><p id="357e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，当使用交叉验证时，模型拟合发生在<code class="fe nc nd ne nf b">cross_val_score</code>内部。我们的<code class="fe nc nd ne nf b">RandomForestClassifier</code>的<code class="fe nc nd ne nf b">model</code>实例还没有安装，即使安装了，到底应该用什么数据来评估它呢？</p><p id="32df" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">事实证明，有一种相对简单的方法来产生一组预测的和实际的类，然后可以在混淆矩阵中使用这些类来可视化算法的性能和有效性。</p><h2 id="574c" class="nx lj it bd lk ny nz dn lo oa ob dp ls mj oc od lu mn oe of lw mr og oh ly iz bi translated">1.导入库</h2><p id="3b02" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">完成这项任务还需要几个库…</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="c2fa" class="nx lj it bd lk ny nz dn lo oa ob dp ls mj oc od lu mn oe of lw mr og oh ly iz bi translated">2.计算预测类别和实际类别</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="36b7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">该解决方案的核心部分是通过定义一个名为<code class="fe nc nd ne nf b">cross_val_predict</code>的帮助函数来计算折叠数据的实际和预测类别(即分类),该函数执行以下操作</p><ol class=""><li id="f08a" class="nj nk it mc b md mw mg mx mj nl mn nm mr nn mv no np nq nr bi translated">获取机器学习算法的本地副本(<code class="fe nc nd ne nf b">model</code>)以避免更改传入的副本</li><li id="a7f4" class="nj nk it mc b md ns mg nt mj nu mn nv mr nw mv no np nq nr bi translated">围绕5个交叉验证数据折叠进行迭代(假设<code class="fe nc nd ne nf b">n_splits=5</code>)。</li><li id="dad1" class="nj nk it mc b md ns mg nt mj nu mn nv mr nw mv no np nq nr bi translated">对于5次分裂中的每一次—</li></ol><p id="1463" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">a.从培训功能、培训目标、测试功能和测试目标的数据中提取行</p><p id="cc2a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">b.将实际目标分类附加到<code class="fe nc nd ne nf b">actual_classes</code></p><p id="6803" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">c.使用从当前文件夹中提取的训练数据来拟合机器学习模型</p><p id="6bfd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">d.使用拟合模型预测当前文件夹中测试数据的目标分类</p><p id="901b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">e.将当前文件夹测试数据的预测类别追加到<code class="fe nc nd ne nf b">predicted_classes</code></p><p id="ecba" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，helper函数返回可用于绘制混淆矩阵的完整的实际和预测类(分类)集。</p><h2 id="4793" class="nx lj it bd lk ny nz dn lo oa ob dp ls mj oc od lu mn oe of lw mr og oh ly iz bi translated">3.想象混乱矩阵</h2><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="e0c2" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe nc nd ne nf b">plot_confusion_matrix</code>助手函数使用<code class="fe nc nd ne nf b">sklearn.metrix.confusion_matrix</code>来计算矩阵，然后由一个叫<code class="fe nc nd ne nf b">heatmap</code>的人用一种很好的格式来显示矩阵，这有助于通过可视化来全面理解算法的性能。</p><h2 id="ef4f" class="nx lj it bd lk ny nz dn lo oa ob dp ls mj oc od lu mn oe of lw mr og oh ly iz bi translated">4.调用助手函数</h2><p id="1de4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">定义了两个辅助函数后，只需依次调用它们来计算实际类和预计类，然后显示混淆矩阵。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/bf52a9877938ba3030449f4400c563d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*51aTZbIzNFQ1X3CQ9W1cJw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="c72c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">91%的总体交叉验证准确度看起来性能良好，但是复合混淆矩阵的可视化显示，虽然该算法在预测<code class="fe nc nd ne nf b">Review Sentiment</code>何时为<code class="fe nc nd ne nf b">Positive</code>时表现良好，但在预测<code class="fe nc nd ne nf b">Neutral</code>和<code class="fe nc nd ne nf b">Negative</code>分类时表现差得多。</p><h1 id="72a7" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">结论</h1><p id="dc93" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Abhisek Thakur是一位数据科学家，也是世界上第一位Kaggle四重大师，他将交叉验证定义为…</p><p id="3d7b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="oj">“构建机器学习模型过程中的一个步骤，帮助我们确保我们的模型准确地拟合数据，并确保我们不会过度拟合”</em></p><p id="efaa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">他继续说道…</p><p id="5727" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><em class="oj">“交叉验证是建立机器学习模型的第一步，也是最重要的一步。如果你有一个好的交叉验证方案，其中验证数据代表训练和现实世界的数据，你将能够建立一个良好的高度可推广的机器学习模型。”</em></p><p id="2bac" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">来自世界领先的数据科学家的这一强烈建议导致了这样的结论:k倍交叉验证是一种比简单的训练/测试分割更好的方法，因此本文通过可视化和示例来解释交叉验证。</p><p id="b520" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">人们注意到，使用<code class="fe nc nd ne nf b">scikit-learn</code>库中的<code class="fe nc nd ne nf b">cross_val_score</code>进行交叉验证的一个缺点是，没有直接的方法来可视化混淆矩阵中的结果，并且示例中使用的数据显示了混淆矩阵是多么有用，尤其是在数据不平衡的情况下。</p><p id="907e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，文章提供了一个名为<code class="fe nc nd ne nf b">cross_val_predict</code>的帮助函数的代码和解释，该函数通过访问折叠的索引并构建实际和预测的类来解决这个问题，然后使用<code class="fe nc nd ne nf b">plot_confusion_matrix</code>函数在混淆矩阵中有效地可视化结果。</p><p id="8780" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">K-fold交叉验证是构建准确的机器学习算法的核心步骤，提取和可视化实际和预测的分类对于理解结果和优化性能非常有用。</p><h1 id="6838" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">感谢您的阅读！</h1><p id="9002" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果你喜欢读这篇文章，为什么不看看我在https://grahamharrison-86487.medium.com/<a class="ae lh" href="https://grahamharrison-86487.medium.com/" rel="noopener">的其他文章呢？此外，我很乐意听到您对这篇文章、我的任何其他文章或任何与数据科学和数据分析相关的内容的看法。</a></p><p id="a64e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你想联系我讨论这些话题，请在LinkedIn上找我—<a class="ae lh" href="https://www.linkedin.com/in/grahamharrison1" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/grahamharrison1</a>或者发邮件给我<a class="ae lh" href="mailto:GHarrison@lincolncollege.ac.uk" rel="noopener ugc nofollow" target="_blank">ghar rison @ Lincoln college . AC . uk</a>。</p><p id="68e7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你想通过订阅来支持作者和全世界1000个为文章写作做出贡献的人，请使用这个链接——<a class="ae lh" href="https://grahamharrison-86487.medium.com/membership" rel="noopener">https://grahamharrison-86487.medium.com/membership</a>(注意:如果你使用这个链接注册，作者将收到一定比例的费用)。</p></div></div>    
</body>
</html>