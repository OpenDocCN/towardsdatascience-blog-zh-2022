<html>
<head>
<title>NumPy for Data Science Interviews: Part 02</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学访谈节目:第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-for-data-science-interviews-part-02-28c9ee37d2c8#2022-01-13">https://towardsdatascience.com/numpy-for-data-science-interviews-part-02-28c9ee37d2c8#2022-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="5a67" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">数据科学访谈节目:第2部分</h1></div><div class=""><h2 id="4dfd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">数据科学数字系列的第2部分</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/ce7ce641bc04754321068caa1d75f63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KaiNAsLOvPGQW5-a"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="7012" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<a class="ae kw" rel="noopener" target="_blank" href="/numpy-for-data-science-interviews-1f86e7277ddd">的上一篇文章</a>中，我们看了使用NumPy的基础知识。我们讨论了</p><ul class=""><li id="5fa9" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">对NumPy的需求以及NumPy数组与Python列表和Pandas系列的比较。</li><li id="1b21" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">尺寸、形状等数组属性。</li><li id="b60f" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">NumPy中的特殊数组</li><li id="730a" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">重塑NumPy数组</li><li id="983c" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">索引和切片NumPy数组</li><li id="9e0d" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">NumPy数组中的布尔掩码</li><li id="742b" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">NumPy中的基本函数</li><li id="29a2" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">矢量化运算</li></ul><p id="90e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本系列的第二部分，我们将讨论NumPy中的高级主题及其在数据科学中的应用。我们将会看到</p><ul class=""><li id="3f43" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">随机数生成</li><li id="6c8b" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">高级阵列操作</li><li id="7122" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">处理缺失值</li><li id="a02e" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">NumPy中的排序和搜索功能</li><li id="1e1f" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">广播</li><li id="8087" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">矩阵运算和线性代数</li><li id="9262" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">多项式</li><li id="f496" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">曲线拟合</li><li id="0d6c" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">将数据导入NumPy和从NumPy导出数据</li></ul><p id="c7ff" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您以前没有使用过NumPy，我们建议您阅读NumPy系列的<a class="ae kw" rel="noopener" target="_blank" href="/numpy-for-data-science-interviews-1f86e7277ddd">第一部分，开始了解NumPy概念。</a></p><h1 id="09ca" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">NumPy的高级用法</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/113673084c26d0f5623ea04fdb730b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvTBkfN9aA3Qj7EV5h2U6Q.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图片</p></figure><h2 id="46f7" class="mz mi iq bd mj na nb dn mn nc nd dp mr lg ne nf mt lk ng nh mv lo ni nj mx nk bi translated">NumPy随机数运算</h2><p id="ff2d" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">随机数生成是科学图书馆的重要基础。NumPy支持使用random()模块生成随机数。最简单的随机数生成方法之一是rand()。rand方法返回0和1之间均匀随机分布的结果。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="0b87" class="mz mi iq nr b gy nv nw l nx ny">np.random.rand()<br/>0.008305751553221774</span></pre><p id="4bbe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以指定需要生成的随机数的数量。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="fda7" class="mz mi iq nr b gy nv nw l nx ny">np.random.rand(10)<br/>array([0.03246139, 0.41410126, 0.96956026, 0.43218461, 0.3212331 ,<br/>       0.98749094, 0.83184371, 0.33608471, 0.98037176, 0.03072824])</span></pre><p id="0d46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">或者指定生成的数组的形状。例如，在这种情况下，我们得到15个形状为3 x 5的均匀分布的随机数</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="a119" class="mz mi iq nr b gy nv nw l nx ny">np.random.rand(3,5)<br/>array([[0.65233864, 0.00659963, 0.60412613, 0.85469298, 0.95456249],<br/>       [0.25876255, 0.12360838, 0.20899371, 0.9162027 , 0.74732087],<br/>       [0.97992517, 0.1444538 , 0.47195618, 0.38424683, 0.93320447]])</span></pre><p id="b5ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们也可以生成指定范围内的整数。为此，我们使用randint()方法。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="2bd6" class="mz mi iq nr b gy nv nw l nx ny">np.random.randint(4)<br/>0</span></pre><p id="431e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以指定需要多少个整数。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="2ad4" class="mz mi iq nr b gy nv nw l nx ny">np.random.randint(1,6)<br/>4</span></pre><p id="072f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与rand方法一样，在randint函数中，我们也可以指定最终数组的形状</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="b106" class="mz mi iq nr b gy nv nw l nx ny">np.random.randint(1,6, (5,3))<br/>array([[1, 1, 2],<br/>       [4, 4, 3],<br/>       [3, 4, 5],<br/>       [5, 3, 4],<br/>       [4, 1, 5]])</span></pre><h1 id="ed8c" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">抽样</h1><p id="7e72" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">我们也可以使用随机数发生器对给定的群体进行抽样。例如，如果我们想从10种不同的颜色中选择三种颜色，我们可以使用choice选项。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="9ab7" class="mz mi iq nr b gy nv nw l nx ny">color_list = ['Red', 'Blue', 'Green', 'Orange', 'Violet', 'Pink', 'Indigo', 'White', 'Cyan', 'Black' ]<br/>np.random.choice(color_list, 5)<br/>array(['Black', 'Black', 'Cyan', 'Black', 'Cyan'], dtype='&lt;U6')</span></pre><p id="9506" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以指定是否希望重复选择</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="4c29" class="mz mi iq nr b gy nv nw l nx ny"># Using replace = False to avoid repetitions<br/>np.random.choice(color_list, 5, replace = False)<br/>array(['Black', 'Pink', 'Red', 'Indigo', 'Blue'], dtype='&lt;U6')</span></pre><p id="70b4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如您所料，如果选择的数量大于可用选项的数量，该函数将返回一个错误。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="d2ae" class="mz mi iq nr b gy nv nw l nx ny"># Error when sample is more than the population<br/>np.random.choice(color_list, 15, replace = False)<br/>--------------------------------------------------------------------<br/>ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_9040/2963984956.py in &lt;module&gt;<br/>      1 # Error when sample is more than the population<br/>----&gt; 2 np.random.choice(color_list, 15, replace = False)</span><span id="a778" class="mz mi iq nr b gy nz nw l nx ny">mtrand.pyx in numpy.random.mtrand.RandomState.choice()</span><span id="45eb" class="mz mi iq nr b gy nz nw l nx ny">ValueError: Cannot take a larger sample than population when 'replace=False'</span></pre><h1 id="d914" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">“冻结”随机状态</h1><p id="89bf" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">数据科学领域的一个关键要求是结果的可重复性。当我们选择随机数来计算结果时，为了能够重现相同的结果，我们需要相同的随机数序列。为此，我们需要了解随机数是如何产生的。</p><p id="78f3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由计算机算法产生的随机数大多称为<a class="ae kw" href="https://en.wikipedia.org/wiki/Random_number_generation" rel="noopener ugc nofollow" target="_blank">伪随机数</a>。简而言之，这是一个数字序列，它具有与随机数相同的属性，但由于内存、磁盘空间等限制，最终会重复一种模式。该算法使用一个名为<a class="ae kw" href="https://en.wikipedia.org/wiki/Random_seed" rel="noopener ugc nofollow" target="_blank">种子</a>的初始值来生成随机数。算法的特定种子将输出相同的随机数序列。把它想象成一辆车的注册号码或者社会安全号码。这个数字可以用来识别序列。</p><p id="f6ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了重现相同的随机数集合，我们需要指定序列的种子。在NumPy中，这可以通过设置生成器的RandomState来实现。让我们用下面的例子来说明这一点。我们之前从十种颜色中选了五种。每次执行代码，我们可能会得到不同的结果。但是，如果我们在调用choice方法之前修复RandomState，那么无论我们执行多少次单元格，都会得到相同的结果。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="f83c" class="mz mi iq nr b gy nv nw l nx ny"><strong class="nr ir">Freezing the Random State</strong></span><span id="2b7c" class="mz mi iq nr b gy nz nw l nx ny"># without freezing : each time you execute this cell, you might get a different result<br/>np.random.choice(color_list, 5, replace = False)</span><span id="f030" class="mz mi iq nr b gy nz nw l nx ny">array(['White', 'Blue', 'Black', 'Cyan', 'Indigo'], dtype='&lt;U6')</span><span id="d864" class="mz mi iq nr b gy nz nw l nx ny">np.random.choice(color_list, 5, replace = False)<br/>array(['Orange', 'Cyan', 'Pink', 'Violet', 'Black'], dtype='&lt;U6')</span><span id="fbd6" class="mz mi iq nr b gy nz nw l nx ny">np.random.choice(color_list, 5, replace = False)<br/>array(['Green', 'Blue', 'Orange', 'Pink', 'White'], dtype='&lt;U6')</span><span id="996e" class="mz mi iq nr b gy nz nw l nx ny"># If we fix the random state, we will get the same sequence over and over again<br/>np.random.RandomState(42).choice(color_list, 5, replace = False)<br/>array(['Cyan', 'Blue', 'Pink', 'Red', 'White'], dtype='&lt;U6')</span><span id="1526" class="mz mi iq nr b gy nz nw l nx ny">np.random.RandomState(42).choice(color_list, 5, replace = False)<br/>array(['Cyan', 'Blue', 'Pink', 'Red', 'White'], dtype='&lt;U6')</span><span id="abb0" class="mz mi iq nr b gy nz nw l nx ny">np.random.RandomState(42).choice(color_list, 5, replace = False)<br/>array(['Cyan', 'Blue', 'Pink', 'Red', 'White'], dtype='&lt;U6')</span></pre><p id="fa9f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这在数据科学操作中非常有用，例如将数据集拆分为训练和测试数据集。您将在几乎所有采样方法中找到这些播种选项——sample、Pandas中的shuffle方法、scikit_learn等中的train_test_split方法。</p><p id="887c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">另一个有用的随机数操作是洗牌。顾名思义，shuffle方法可以很好地对数组的元素进行重新排序。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="1f1f" class="mz mi iq nr b gy nv nw l nx ny">my_ar = np.arange(1,11)<br/>my_ar<br/>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</span><span id="6131" class="mz mi iq nr b gy nz nw l nx ny">np.random.shuffle(my_ar)<br/>my_ar<br/>array([ 6,  3,  8, 10,  4,  2,  1,  9,  5,  7])</span><span id="2eb4" class="mz mi iq nr b gy nz nw l nx ny">my_ar = np.arange(1,11)<br/>np.random.shuffle(my_ar)<br/>my_ar<br/>array([ 6,  7, 10,  8,  1,  9,  3,  4,  2,  5])</span><span id="8442" class="mz mi iq nr b gy nz nw l nx ny">my_ar = np.arange(1,11)<br/>np.random.shuffle(my_ar)<br/>my_ar<br/>array([ 7,  6,  2,  4,  5,  8, 10,  9,  1,  3])</span></pre><p id="367c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也可以通过指定RandomState()来“固定”洗牌的结果。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="1bff" class="mz mi iq nr b gy nv nw l nx ny"># Using random state to fix the shuffling<br/>my_ar = np.arange(1,11)<br/>my_ar<br/>array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</span><span id="8806" class="mz mi iq nr b gy nz nw l nx ny">np.random.RandomState(123).shuffle(my_ar)<br/>my_ar<br/>array([ 5,  1,  8,  6,  9,  4,  2,  7, 10,  3])</span><span id="0a56" class="mz mi iq nr b gy nz nw l nx ny">my_ar = np.arange(1,11)<br/>np.random.RandomState(123).shuffle(my_ar)<br/>my_ar<br/>array([ 5,  1,  8,  6,  9,  4,  2,  7, 10,  3])</span><span id="499b" class="mz mi iq nr b gy nz nw l nx ny">my_ar = np.arange(1,11)<br/>np.random.RandomState(123).shuffle(my_ar)<br/>my_ar<br/>array([ 5,  1,  8,  6,  9,  4,  2,  7, 10,  3])</span></pre><h1 id="1e57" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">数组运算</h1><p id="a329" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">NumPy支持一系列数组操作。我们已经在NumPy系列的<a class="ae kw" href="https://www.stratascratch.com/blog/numpy-for-data-science-interviews/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">第一部中看到了一些基本的。让我们来看看一些高级操作。</a></p><p id="12d4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="oa">拆分一个数组。</em> <br/>我们有很多种选择，可以把数组分解成更小的数组。</p><p id="317b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="oa">split()</em><br/>split方法提供了两种主要的拆分数组的方法。<br/>如果我们传递一个整数，这个数组就被分割成大小相等的数组。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="74d6" class="mz mi iq nr b gy nv nw l nx ny">my_ar = np.arange(31,61)<br/>my_ar<br/>array([31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,<br/>       48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60])<br/>np.split(my_ar, 5)<br/>[array([31, 32, 33, 34, 35, 36]),<br/> array([37, 38, 39, 40, 41, 42]),<br/> array([43, 44, 45, 46, 47, 48]),<br/> array([49, 50, 51, 52, 53, 54]),<br/> array([55, 56, 57, 58, 59, 60])]</span></pre><p id="bc81" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果数组不能分成大小相等的子数组，它将返回一个错误。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="f5a5" class="mz mi iq nr b gy nv nw l nx ny"># This will result in an error since the array cannot be split into equal parts<br/>np.split(my_ar, 8)<br/>--------------------------------------------------------------------<br/>TypeError                                 Traceback (most recent call last)<br/>c:\users\asus\appdata\local\programs\python\python39\lib\site-packages\numpy\lib\shape_base.py in split(ary, indices_or_sections, axis)<br/>    866     try:<br/>--&gt; 867         len(indices_or_sections)<br/>    868     except TypeError:</span><span id="4a3d" class="mz mi iq nr b gy nz nw l nx ny">TypeError: object of type 'int' has no len()</span><span id="aafc" class="mz mi iq nr b gy nz nw l nx ny">During handling of the above exception, another exception occurred:</span><span id="b526" class="mz mi iq nr b gy nz nw l nx ny">ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_9040/3446337543.py in &lt;module&gt;<br/>      1 # This will result in an error since the array cannot be split into equal parts<br/>----&gt; 2 np.split(my_ar, 8)</span><span id="48c4" class="mz mi iq nr b gy nz nw l nx ny">&lt;__array_function__ internals&gt; in split(*args, **kwargs)</span><span id="b465" class="mz mi iq nr b gy nz nw l nx ny">c:\users\asus\appdata\local\programs\python\python39\lib\site-packages\numpy\lib\shape_base.py in split(ary, indices_or_sections, axis)<br/>    870         N = ary.shape[axis]<br/>    871         if N % sections:<br/>--&gt; 872             raise ValueError(<br/>    873                 'array split does not result in an equal division')<br/>    874     return array_split(ary, indices_or_sections, axis)</span><span id="498a" class="mz mi iq nr b gy nz nw l nx ny">ValueError: array split does not result in an equal division<br/>To avoid equal division error, use array_split() method</span></pre><p id="a747" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了克服这个问题，我们可以使用array_split()方法。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="8eb0" class="mz mi iq nr b gy nv nw l nx ny">np.array_split(my_ar, 8)<br/>[array([31, 32, 33, 34]),<br/> array([35, 36, 37, 38]),<br/> array([39, 40, 41, 42]),<br/> array([43, 44, 45, 46]),<br/> array([47, 48, 49, 50]),<br/> array([51, 52, 53, 54]),<br/> array([55, 56, 57]),<br/> array([58, 59, 60])]</span></pre><p id="2156" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以传递拆分数组的索引，而不是指定子数组的数量。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="fa25" class="mz mi iq nr b gy nv nw l nx ny">np.split(my_ar, [5,12,15])<br/>[array([31, 32, 33, 34, 35]),<br/> array([36, 37, 38, 39, 40, 41, 42]),<br/> array([43, 44, 45]),<br/> array([46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60])]</span></pre><p id="4b07" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以使用另外两个方法<br/>hs split——来水平划分数组</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="f420" class="mz mi iq nr b gy nv nw l nx ny"><strong class="nr ir">hsplit</strong></span><span id="ef07" class="mz mi iq nr b gy nz nw l nx ny">ar2d = my_ar.reshape(5,6)<br/>ar2d<br/>array([[31, 32, 33, 34, 35, 36],<br/>       [37, 38, 39, 40, 41, 42],<br/>       [43, 44, 45, 46, 47, 48],<br/>       [49, 50, 51, 52, 53, 54],<br/>       [55, 56, 57, 58, 59, 60]])<br/>np.hsplit(ar2d, [2,4])<br/>[array([[31, 32],<br/>        [37, 38],<br/>        [43, 44],<br/>        [49, 50],<br/>        [55, 56]]),<br/> array([[33, 34],<br/>        [39, 40],<br/>        [45, 46],<br/>        [51, 52],<br/>        [57, 58]]),<br/> array([[35, 36],<br/>        [41, 42],<br/>        [47, 48],<br/>        [53, 54],<br/>        [59, 60]])]</span></pre><p id="d1b2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在指定索引处垂直拆分。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="4e6b" class="mz mi iq nr b gy nv nw l nx ny">np.vsplit(ar2d, [1,4])<br/>[array([[31, 32, 33, 34, 35, 36]]),<br/> array([[37, 38, 39, 40, 41, 42],<br/>        [43, 44, 45, 46, 47, 48],<br/>        [49, 50, 51, 52, 53, 54]]),<br/> array([[55, 56, 57, 58, 59, 60]])]</span></pre><p id="bf2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="oa">堆叠阵列。</em> <br/>和split方法一样，我们可以堆叠(或组合)数组。三种常用的方法是:</p><p id="cbf0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Stack:顾名思义，这个方法堆叠数组。对于多维数组，我们可以指定不同的轴来堆叠。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="6b79" class="mz mi iq nr b gy nv nw l nx ny">ar01 = np.ones((2,4)) * 5<br/>ar01<br/>array([[5., 5., 5., 5.],<br/>       [5., 5., 5., 5.]])<br/>ar02 = np.ones((2,4))<br/>ar02               <br/>array([[1., 1., 1., 1.],<br/>       [1., 1., 1., 1.]])<br/>ar03 = np.ones((2,4))*3<br/>ar03<br/>array([[3., 3., 3., 3.],<br/>       [3., 3., 3., 3.]])</span><span id="5dc4" class="mz mi iq nr b gy nz nw l nx ny"><br/>np.stack([ar01,ar02,ar03], axis = 0)<br/>array([[[5., 5., 5., 5.],<br/>        [5., 5., 5., 5.]],</span><span id="f352" class="mz mi iq nr b gy nz nw l nx ny">[[1., 1., 1., 1.],<br/>        [1., 1., 1., 1.]],</span><span id="dff7" class="mz mi iq nr b gy nz nw l nx ny">[[3., 3., 3., 3.],<br/>        [3., 3., 3., 3.]]])<br/>np.stack([ar01,ar02,ar03], axis = 1)<br/>array([[[5., 5., 5., 5.],<br/>        [1., 1., 1., 1.],<br/>        [3., 3., 3., 3.]],</span><span id="bf4f" class="mz mi iq nr b gy nz nw l nx ny">[[5., 5., 5., 5.],<br/>        [1., 1., 1., 1.],<br/>        [3., 3., 3., 3.]]])<br/>np.stack([ar01,ar02,ar03], axis = 2)<br/>array([[[5., 1., 3.],<br/>        [5., 1., 3.],<br/>        [5., 1., 3.],<br/>        [5., 1., 3.]],</span><span id="0374" class="mz mi iq nr b gy nz nw l nx ny">[[5., 1., 3.],<br/>        [5., 1., 3.],<br/>        [5., 1., 3.],<br/>        [5., 1., 3.]]])</span></pre><p id="014d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">hstack:这将水平堆叠数组，类似于用于拆分的hsplit()方法。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="b4ea" class="mz mi iq nr b gy nv nw l nx ny">ar01 = np.arange(1,6)<br/>ar01<br/>array([1, 2, 3, 4, 5])<br/>ar02 = np.arange(11,16)<br/>ar02<br/>array([11, 12, 13, 14, 15])<br/>np.hstack([ar01,ar02])<br/>array([ 1,  2,  3,  4,  5, 11, 12, 13, 14, 15])<br/>np.hstack([ar01.reshape(-1,1), ar02.reshape(-1,1)])<br/>array([[ 1, 11],<br/>       [ 2, 12],<br/>       [ 3, 13],<br/>       [ 4, 14],<br/>       [ 5, 15]])</span></pre><p id="c7ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">vstack:这是垂直堆叠数组，类似于用于拆分的vsplit方法。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="4053" class="mz mi iq nr b gy nv nw l nx ny">np.vstack([ar01,ar02])<br/>array([[ 1,  2,  3,  4,  5],<br/>       [11, 12, 13, 14, 15]])<br/>np.vstack([ar01.reshape(-1,1), ar02.reshape(-1,1)])<br/>array([[ 1],<br/>       [ 2],<br/>       [ 3],<br/>       [ 4],<br/>       [ 5],<br/>       [11],<br/>       [12],<br/>       [13],<br/>       [14],<br/>       [15]])</span></pre><h1 id="e655" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">处理缺失值</h1><p id="f05c" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">处理缺失值是数据科学中的一项重要任务。虽然我们希望数据没有任何缺失值，但不幸的是现实生活中的数据可能包含缺失值。与在聚合时自动忽略缺失值的Pandas函数不同，NumPy聚合函数不以类似的方式处理缺失值。如果在聚合过程中遇到一个或多个缺失值，则结果值也将缺失。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="fc51" class="mz mi iq nr b gy nv nw l nx ny">my_ar = np.array([1, np.nan, 3])<br/>my_ar<br/>array([ 1., nan,  3.])<br/>my_ar.sum()<br/>nan<br/>my2dar = np.array([[1, np.nan, 3],[4,5,6]])<br/>my2dar<br/>array([[ 1., nan,  3.],<br/>       [ 4.,  5.,  6.]])<br/>my2dar.sum(axis = 0)<br/>array([ 5., nan,  9.])<br/>my2dar.sum(axis = 1)<br/>array([nan, 15.])</span></pre><p id="dcda" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了计算这些忽略缺失值的聚合值，我们需要使用“NaN-Safe”函数。例如，NaN-Safe版本的sum-nansum()将计算忽略缺失值的数组的和，nanmax()将计算忽略缺失值的数组的最大值，依此类推。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="698b" class="mz mi iq nr b gy nv nw l nx ny">np.nansum(my_ar)<br/>4.0<br/>np.nansum(my2dar, axis = 0)<br/>array([5., 5., 9.])<br/>np.nansum(my2dar, axis = 1)<br/>array([ 4., 15.])</span></pre><h1 id="4bb8" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">整理</h1><p id="72c3" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">数据科学中遇到的另一个常见操作是排序。NumPy有许多排序方法。</p><p id="5101" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">基本排序方法允许按升序排序。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="3bf0" class="mz mi iq nr b gy nv nw l nx ny">my_ar = np.random.randint(1,51, 10)<br/>my_ar<br/>array([48, 37, 45, 48, 31, 22,  5, 43,  2, 21])<br/>np.sort(my_ar)<br/>array([ 2,  5, 21, 22, 31, 37, 43, 45, 48, 48])</span></pre><p id="a854" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于多维数组，可以指定轴来执行排序操作。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="b7a3" class="mz mi iq nr b gy nv nw l nx ny">my2dar = my_ar.reshape(2,-1)<br/>my2dar<br/>array([[48, 37, 45, 48, 31],<br/>       [22,  5, 43,  2, 21]])<br/>np.sort(my2dar, axis = 0)<br/>array([[22,  5, 43,  2, 21],<br/>       [48, 37, 45, 48, 31]])<br/>np.sort(my2dar, axis = 1)<br/>array([[31, 37, 45, 48, 48],<br/>       [ 2,  5, 21, 22, 43]])</span></pre><p id="998c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">注意</em> </strong>:没有降序排序选项。可以对排序后的数组使用翻转方法来反转排序过程。或者用切片机。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="7629" class="mz mi iq nr b gy nv nw l nx ny">np.sort(my_ar)[::-1]<br/>array([48, 48, 45, 43, 37, 31, 22, 21,  5,  2])<br/>np.flip(np.sort(my_ar))<br/>array([48, 48, 45, 43, 37, 31, 22, 21,  5,  2])<br/>np.sort(my2dar, axis = 0)[::-1, :]<br/>array([[48, 37, 45, 48, 31],<br/>       [22,  5, 43,  2, 21]])<br/>np.sort(my2dar, axis = 1)[:, ::-1]<br/>array([[48, 48, 45, 37, 31],<br/>       [43, 22, 21,  5,  2]])</span></pre><p id="5869" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">NumPy也有间接排序方法。这些方法不是返回排序后的数组，而是返回排序后的数组的索引。将这些索引传递给切片器，我们就可以得到排序后的数组。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="b50a" class="mz mi iq nr b gy nv nw l nx ny">my_ar<br/>array([48, 37, 45, 48, 31, 22,  5, 43,  2, 21])<br/>np.argsort(my_ar)<br/>array([8, 6, 9, 5, 4, 1, 7, 2, 0, 3], dtype=int64)<br/>my_ar[np.argsort(my_ar)]<br/>array([ 2,  5, 21, 22, 31, 37, 43, 45, 48, 48])<br/>np.argsort(my2dar, axis = 0)<br/>array([[1, 1, 1, 1, 1],<br/>       [0, 0, 0, 0, 0]], dtype=int64)<br/>np.argsort(my2dar, axis = 1)<br/>array([[4, 1, 2, 0, 3],<br/>       [3, 1, 4, 0, 2]], dtype=int64)</span></pre><p id="4620" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">另一个可用的间接排序选项是lexsort。lexsort方法允许以指定的顺序对不同的数组进行排序。假设有两个数组—第一个包含五个人的年龄，第二个包含身高。如果我们想先按年龄再按身高排序，我们可以使用lexsort方法。结果将是考虑两种排序顺序的索引。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="648a" class="mz mi iq nr b gy nv nw l nx ny">age_ar = np.random.randint(20,45,5)<br/>age_ar<br/>array([26, 31, 39, 33, 25])<br/>height_ar = np.random.randint(160,185,5)<br/>height_ar<br/>array([180, 176, 174, 172, 177])<br/>np.lexsort((age_ar, height_ar))<br/>array([3, 2, 1, 4, 0], dtype=int64)</span></pre><h1 id="1c24" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">搜索</h1><p id="7bff" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">像排序方法一样，NumPy也提供了多种搜索方法。最常用的是-</p><p id="b08d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">argmax(和argmin):这些函数返回最大值(或最小值)的索引。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="859e" class="mz mi iq nr b gy nv nw l nx ny">my_ar<br/>array([48, 37, 45, 48, 31, 22,  5, 43,  2, 21])<br/>np.argmax(my_ar)<br/>0<br/>np.argmin(my_ar)<br/>8<br/>my2dar<br/>array([[48, 37, 45, 48, 31],<br/>       [22,  5, 43,  2, 21]])<br/>np.argmax(my2dar, axis = 0)<br/>array([0, 0, 0, 0, 0], dtype=int64)<br/>np.argmax(my2dar, axis = 1)<br/>array([0, 2], dtype=int64)</span></pre><p id="e457" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">NaN-Safe方法也可以忽略nanargmax和nanargmin中缺少的值</p><p id="8214" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">其中:这将返回满足指定条件的数组的索引。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="150c" class="mz mi iq nr b gy nv nw l nx ny">np.where(my_ar &gt; 30)<br/>(array([0, 1, 2, 3, 4, 7], dtype=int64),)</span></pre><p id="8492" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，它还可以根据元素是否满足条件来操作输出。例如，如果我们想将所有大于30的元素作为正数返回，其余的作为负数返回，我们可以用下面的方式来实现。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="1c3f" class="mz mi iq nr b gy nv nw l nx ny">np.where(my_ar &gt; 30, my_ar, -my_ar)<br/>array([ 48,  37,  45,  48,  31, -22,  -5,  43,  -2, -21])</span></pre><p id="1537" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也可以在多维数组上执行这些操作。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="4127" class="mz mi iq nr b gy nv nw l nx ny">np.where(my2dar &gt; 30, my2dar, -my2dar)<br/>array([[ 48,  37,  45,  48,  31],<br/>       [-22,  -5,  43,  -2, -21]])</span></pre><p id="1005" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">argwhere:返回满足where条件的数组的索引。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="7d80" class="mz mi iq nr b gy nv nw l nx ny">np.argwhere(my_ar &gt; 30)<br/>array([[0],<br/>       [1],<br/>       [2],<br/>       [3],<br/>       [4],<br/>       [7]], dtype=int64)<br/>np.argwhere(my2dar &gt; 30)<br/>array([[0, 0],<br/>       [0, 1],<br/>       [0, 2],<br/>       [0, 3],<br/>       [0, 4],<br/>       [1, 2]], dtype=int64)</span></pre><h1 id="42d4" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">广播</h1><p id="67c2" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">NumPy中最强大的概念之一是广播。NumPy中的广播特性允许我们在某些情况下对不同形状的数组执行算术运算。在本系列的前一部分<a class="ae kw" href="https://www.stratascratch.com/blog/numpy-for-data-science-interviews/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">中，我们已经看到了如何对两个形状相同的数组执行算术运算。或带有数组的标量。广播将这个概念扩展到两个形状不同的阵列。</a></p><p id="f620" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，并不是所有的阵列都与广播兼容。为了检查两个数组是否适合广播，NumPy匹配数组元素的形状，从最外面的轴开始，一直到最里面的轴。如果相应的尺寸为</p><ul class=""><li id="3082" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">同一的</li><li id="5787" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">或者至少其中一个等于1。</li></ul><p id="2661" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了说明这一过程，让我们举几个例子。</p><p id="748d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">播音示例01 </em> </strong></p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="f94f" class="mz mi iq nr b gy nv nw l nx ny">ar01 = np.arange(10,50,10)<br/>ar01<br/>array([10, 20, 30, 40])<br/>ar02 = 5<br/>ar01 + ar02<br/>array([15, 25, 35, 45])</span></pre><p id="1535" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，我们试图广播一个带有标量的shape (4，)数组。标量值通过第一个数组的形状传播。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ob"><img src="../Images/cd6e24f55dcf59b3f51c6eb26d6a2fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*byV4DTBC1fufaNXjW5XYAw.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><p id="7c4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">播音示例02 </em> </strong></p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="7c85" class="mz mi iq nr b gy nv nw l nx ny">ar01 = np.arange(10,50,5).reshape(2,-1)<br/>ar01<br/>array([[10, 15, 20, 25],<br/>       [30, 35, 40, 45]])<br/>ar01.shape<br/>(2, 4)<br/>ar02 = np.array([[100],[200]])<br/>ar02<br/>array([[100],<br/>       [200]])<br/>ar02.shape<br/>(2, 1)<br/>ar01 + ar02<br/>array([[110, 115, 120, 125],<br/>       [230, 235, 240, 245]])</span></pre><p id="b7b8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此示例分别有两个形状为(2，4)和(2，1)的数组。广播规则从最右边的维度应用。</p><ul class=""><li id="16b7" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">首先，为了使维度4与维度1匹配，第二个数组被扩展。</li><li id="1655" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">然后程序检查下一个尺寸。因为这两个维度是相同的，所以不需要传播。</li><li id="3140" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">第一个数组和传播的第二个数组现在具有相同的维度，并且它们可以按元素添加。</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oc"><img src="../Images/7c682f0568c7d843ba87e78c994481a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6wI7tw-bfmyIh9FwmY_6Kg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><p id="9180" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">广播示例03 </em> </strong></p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="d698" class="mz mi iq nr b gy nv nw l nx ny">ar01 = np.arange(10,80,10)<br/>ar01<br/>array([10, 20, 30, 40, 50, 60, 70])<br/>ar01.shape<br/>(7,)<br/>ar02 = np.arange(100,500,100).reshape(-1,1)<br/>ar02<br/>array([[100],<br/>       [200],<br/>       [300],<br/>       [400]])<br/>ar02.shape<br/>(4, 1)<br/>ar01 + ar02<br/>array([[110, 120, 130, 140, 150, 160, 170],<br/>       [210, 220, 230, 240, 250, 260, 270],<br/>       [310, 320, 330, 340, 350, 360, 370],<br/>       [410, 420, 430, 440, 450, 460, 470]])</span></pre><p id="7478" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本例中，我们试图将形状(7)的数组与形状(4，1)的数组相加。广播以下面的方式进行。</p><ul class=""><li id="2c2b" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">我们首先检查最右边的维度(7)和(1)。因为第二个数组的维数是1，所以它被扩展以适合第一个数组的大小(7)。</li><li id="0e40" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">此外，使用(4)检查接下来的维度()。为了匹配第二个数组的尺寸，第一个数组被扩展以适合第二个数组的大小(4)。</li><li id="5638" class="lt lu iq kz b la mc ld md lg me lk mf lo mg ls ly lz ma mb bi translated">现在扩展数组的维数是(7，4)并且是按元素添加的。</li></ul><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi od"><img src="../Images/0249cf5674f87a31597940c723adc9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zo9cTCZt7cl-MnEyAY-VjA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><p id="b7af" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，我们看一下不适合一起广播的两个阵列。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="aebd" class="mz mi iq nr b gy nv nw l nx ny">ar01 = np.arange(10,80,10).reshape(-1,1)<br/>ar01<br/>array([[10],<br/>       [20],<br/>       [30],<br/>       [40],<br/>       [50],<br/>       [60],<br/>       [70]])<br/>ar01.shape<br/>(7, 1)<br/>ar02<br/>array([[100],<br/>       [200],<br/>       [300],<br/>       [400]])<br/>ar02.shape<br/>(4, 1)</span></pre><p id="0f78" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这里，我们尝试将shape (7，1)的数组与shape (4，1)的数组相加。我们从最右边的维度开始—两个数组在这个维度上都有1个元素。然而，当我们检查下一个维度(7)和(4)时，这些维度对于广播是不兼容的。因此，程序抛出一个ValueError。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="9e59" class="mz mi iq nr b gy nv nw l nx ny">ar01 + ar02<br/>--------------------------------------------------------------------<br/>ValueError                                Traceback (most recent call last)<br/>~\AppData\Local\Temp/ipykernel_9040/1595926737.py in &lt;module&gt;<br/>----&gt; 1 ar01 + ar02</span><span id="eff0" class="mz mi iq nr b gy nz nw l nx ny">ValueError: operands could not be broadcast together with shapes (7,1) (4,1)</span></pre><h1 id="0fa7" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">矩阵运算和线性代数</h1><p id="4481" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">NumPy提供了许多执行矩阵和线性代数运算的方法。我们看看其中的一些。</p><p id="3fd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">转置矩阵:</em> </strong></p><p id="ac8b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于二维数组，转置是指将行交换为列，将列交换为行。人们可以简单地调用。t属性来获取转置矩阵。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="32e5" class="mz mi iq nr b gy nv nw l nx ny">my2dar<br/>array([[48, 37, 45, 48, 31],<br/>       [22,  5, 43,  2, 21]])<br/>my2dar.T<br/>array([[48, 22],<br/>       [37,  5],<br/>       [45, 43],<br/>       [48,  2],<br/>       [31, 21]])</span></pre><p id="b008" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于多维数组，我们可以使用transpose()方法，指定要转置的轴。</p><p id="751d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">矩阵的行列式:</em> </strong></p><p id="6075" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于方阵，我们可以计算出<a class="ae kw" href="https://en.wikipedia.org/wiki/Determinant" rel="noopener ugc nofollow" target="_blank">行列式</a>。行列式在高等数学和数据科学中有许多应用。这些用于使用<a class="ae kw" href="https://en.wikipedia.org/wiki/Cramer%27s_rule" rel="noopener ugc nofollow" target="_blank">克莱姆法则</a>求解线性方程组，计算<a class="ae kw" href="https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors" rel="noopener ugc nofollow" target="_blank">特征值</a>，这些特征值用于<a class="ae kw" href="https://en.wikipedia.org/wiki/Principal_component_analysis" rel="noopener ugc nofollow" target="_blank">主成分分析</a>等。要找到一个方阵的行列式，我们可以调用NumPy的linalg子模块中的det()方法。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="545d" class="mz mi iq nr b gy nv nw l nx ny">sq_ar = np.random.randint(10,50,9).reshape(3,3)<br/>sq_ar<br/>array([[34, 42, 34],<br/>       [12, 16, 33],<br/>       [22, 33, 12]])<br/>np.linalg.det(sq_ar)<br/>-4558.000000000001<br/>sq_ar2 = np.array([[12,15], [18,10]])<br/>sq_ar2<br/>array([[12, 15],<br/>       [18, 10]])<br/>np.linalg.det(sq_ar2)<br/>-149.99999999999997</span></pre><p id="e41f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">矩阵乘法:</em> </strong></p><p id="e23d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">两个矩阵相乘构成了高等数学和数据科学中众多应用的基础。matmul()函数实现了NumPy中的矩阵乘法功能。为了说明矩阵乘法，我们用eye()方法创建的单位矩阵乘以一个矩阵。我们应该得到原始矩阵作为结果积。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="8327" class="mz mi iq nr b gy nv nw l nx ny">sq_ar<br/>array([[34, 42, 34],<br/>       [12, 16, 33],<br/>       [22, 33, 12]])<br/>np.matmul(sq_ar, np.eye(3,3))<br/>array([[34., 42., 34.],<br/>       [12., 16., 33.],<br/>       [22., 33., 12.]])<br/>sq_ar2<br/>array([[12, 15],<br/>       [18, 10]])<br/>np.matmul(sq_ar2, np.eye(2,2))<br/>array([[12., 15.],<br/>       [18., 10.]])</span></pre><p id="87f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">矩阵的逆:</em> </strong></p><p id="9857" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于方阵M，矩阵M-1的逆矩阵被定义为使得M M-1 = In的矩阵，其中In表示n乘n单位矩阵。我们可以通过使用NumPy中linalg子模块的inv()方法找到NumPy中矩阵的逆。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="3b58" class="mz mi iq nr b gy nv nw l nx ny">inv2 = np.linalg.inv(sq_ar2)<br/>inv2<br/>array([[-0.06666667,  0.1       ],<br/>       [ 0.12      , -0.08      ]])</span></pre><p id="4614" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以证明矩阵与其逆矩阵的乘积等于单位矩阵。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="fda3" class="mz mi iq nr b gy nv nw l nx ny">np.matmul(sq_ar2, inv2)<br/>array([[ 1.00000000e+00, -8.32667268e-17],<br/>       [ 0.00000000e+00,  1.00000000e+00]])</span></pre><p id="6986" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"><em class="oa">NumPy数组相等。</em>T29】</strong></p><p id="5d68" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">给定浮点精度的差异，我们可以比较两个NumPy数组在给定的容差内是否元素相等。这可以使用allclose方法来完成。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="c903" class="mz mi iq nr b gy nv nw l nx ny">np.allclose(np.eye(2,2), np.matmul(sq_ar2, inv2))<br/>True</span></pre><p id="e024" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir"> <em class="oa">求解器。</em> </strong></p><p id="6531" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">NumPy的linalg模块有solve方法，可以计算线性方程组的精确解。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="621d" class="mz mi iq nr b gy nv nw l nx ny"><strong class="nr ir">Solving Linear Equations</strong></span><span id="374b" class="mz mi iq nr b gy nz nw l nx ny">x1 + x2 = 10<br/>2x1 + 5x2 = 41<br/>This should give x1 = 3 and x2 = 7</span><span id="0714" class="mz mi iq nr b gy nz nw l nx ny">coeff_ar = np.array([[1,1],[2,5]])<br/>ord_ar = np.array([[10],[41]])<br/>np.linalg.solve(coeff_ar, ord_ar)<br/>array([[3.],<br/>       [7.]])</span></pre><h1 id="9fe7" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">多项式</h1><p id="671c" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">像线性代数子模块一样，NumPy也支持多项式代数。该模块有几个方法以及包含常见算术运算的多项式类。让我们看看多项式子模块的一些功能。为了说明这一点，我们用x f(x)中的多项式来表示</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="3ca1" class="mz mi iq nr b gy nv nw l nx ny">f(x) = x² - x - 6</span></pre><p id="e822" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以从系数中创建多项式。注意，系数必须按度数的升序排列。所以先列出常数项的系数(-6)，然后是x的系数(-1)，最后是x (1)的系数</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="e9d1" class="mz mi iq nr b gy nv nw l nx ny">from numpy.polynomial.polynomial import Polynomial<br/>poly01 = Polynomial([-6,-1,1])<br/>poly01<br/>x → -6.0-1.0x+1.0x²</span></pre><p id="a443" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该表达式也可以被因式分解为</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="6090" class="mz mi iq nr b gy nv nw l nx ny">f(x) = (x-3)(x+2)</span></pre><p id="77e5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里3和-2是方程f(x) = 0的<a class="ae kw" href="https://en.wikipedia.org/wiki/Equation_solving" rel="noopener ugc nofollow" target="_blank">根</a>。我们可以通过调用roots()方法找到多项式的根。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="941e" class="mz mi iq nr b gy nv nw l nx ny">poly01.roots()<br/>array([-2.,  3.])</span></pre><p id="c987" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以使用fromroots()方法从根开始形成方程。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="599e" class="mz mi iq nr b gy nv nw l nx ny">poly02 = Polynomial.fromroots([-2,3])<br/>poly02<br/>x → -6.0-1.0x+1.0x²</span></pre><p id="d2e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">多项式模块还包含linspace()方法，该方法可用于创建跨域的等距x和f(x)对。这可以用来方便地绘制图形。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="26ef" class="mz mi iq nr b gy nv nw l nx ny">polyx, polyy = poly01.linspace(n = 21, domain = [-5,5])</span><span id="4a2a" class="mz mi iq nr b gy nz nw l nx ny">plt.plot(polyx, polyy)<br/>[&lt;matplotlib.lines.Line2D at 0x26006fd2e80&gt;]</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5d5399bad9c2a967e703326251ca3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*P1TPigEsvqn3btqr9l2L9A.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><h1 id="12cc" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">曲线拟合</h1><p id="4f6a" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">NumPy多项式子模块还提供多项式对数据的最小平方拟合。为了说明这一点，让我们创建一组数据点，并为多项式表达式添加一些随机性。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="beae" class="mz mi iq nr b gy nv nw l nx ny">numpoints = 11<br/>x_vals = np.linspace(-5,5,numpoints)<br/>y_vals = x_vals**2 + x_vals - 12 + np.random.rand(numpoints)*4</span><span id="dec0" class="mz mi iq nr b gy nz nw l nx ny">plt.scatter(x_vals, y_vals)<br/>&lt;matplotlib.collections.PathCollection at 0x26008086940&gt;</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi of"><img src="../Images/069eec539de97eaa324b6310000686a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*h0DdIOvhyVY0cgFWN74Lkg.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><p id="c4d3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们在这些点上调用polyfit()方法，并找到拟合多项式的系数。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="7be0" class="mz mi iq nr b gy nv nw l nx ny">from numpy.polynomial import polynomial<br/>fit_pol = polynomial.polyfit(x_vals, y_vals, 2)<br/>fit_pol<br/>array([-9.35761397,  0.96843091,  0.93303665])</span></pre><p id="726c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以通过绘制数值来直观地验证拟合度。为此，我们使用多值方法来计算这些点处的多项式函数。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="f127" class="mz mi iq nr b gy nv nw l nx ny">fit_y = polynomial.polyval(x_vals, fit_pol)<br/>plt.scatter(x_vals, y_vals)<br/>plt.plot(x_vals, fit_y, c = 'Red', alpha = 0.5 )<br/>[&lt;matplotlib.lines.Line2D at 0x26008102c10&gt;]</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi og"><img src="../Images/d3d1e29ce2527919df0fa1de8a2f05e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*9D5rXf1rIxednLeEQwNMeQ.png"/></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者图片</p></figure><h1 id="b086" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">在NumPy中导入和导出数据</h1><p id="fda5" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">到目前为止，我们已经动态创建了数组。在现实生活的数据科学场景中，我们通常有可用的数据。NumPy支持从文件导入数据和将NumPy数组导出到外部文件。我们可以使用save和load方法在native NumPy native(.npy和。npz格式)。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="55a8" class="mz mi iq nr b gy nv nw l nx ny"><strong class="nr ir">save</strong></span><span id="3916" class="mz mi iq nr b gy nz nw l nx ny">with open("numpyfile.npy", "wb") as f:<br/>    np.save(f, np.arange(1,11).reshape(2,-1))</span><span id="d673" class="mz mi iq nr b gy nz nw l nx ny"><strong class="nr ir">load</strong></span><span id="2e15" class="mz mi iq nr b gy nz nw l nx ny">with open("numpyfile.npy", "rb") as f:<br/>    out_ar = np.load(f)<br/>out_ar<br/>array([[ 1,  2,  3,  4,  5],<br/>       [ 6,  7,  8,  9, 10]])</span></pre><p id="aa21" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以使用loadtxt和savetxt方法从文本文件中读取数据和向文本文件中写入数据。</p><pre class="kh ki kj kk gt nq nr ns nt aw nu bi"><span id="0a63" class="mz mi iq nr b gy nv nw l nx ny"><strong class="nr ir">savetxt</strong></span><span id="027a" class="mz mi iq nr b gy nz nw l nx ny">np.savetxt("nptxt.csv", np.arange(101,121).reshape(4,-1))</span><span id="6081" class="mz mi iq nr b gy nz nw l nx ny"><strong class="nr ir">loadtxt</strong></span><span id="87af" class="mz mi iq nr b gy nz nw l nx ny">np.loadtxt("nptxt.csv")<br/>array([[101., 102., 103., 104., 105.],<br/>       [106., 107., 108., 109., 110.],<br/>       [111., 112., 113., 114., 115.],<br/>       [116., 117., 118., 119., 120.]])</span></pre><h2 id="bec2" class="mz mi iq bd mj na nb dn mn nc nd dp mr lg ne nf mt lk ng nh mv lo ni nj mx nk bi translated">结论</h2><p id="181d" class="pw-post-body-paragraph kx ky iq kz b la nl jr lc ld nm ju lf lg nn li lj lk no lm ln lo np lq lr ls ij bi translated">在本系列中，我们研究了NumPy，它是Python数据科学生态系统中用于科学计算的基础库。如果你熟悉熊猫，那么搬到NumPy是非常容易的。有抱负的数据科学家或声称精通Python的数据分析师会对NumPy感到满意。</p><p id="9dcc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">和任何技能一样，掌握数字所需要的只是耐心、坚持和练习。你可以从StrataScratch上的实际数据科学面试中尝试这些和许多其他的<a class="ae kw" href="https://www.stratascratch.com/blog/data-science-interview-guide-questions-from-80-different-companies/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">数据科学面试问题</a>。加入由40，000多名志同道合的数据科学爱好者组成的社区。你可以练习1000多个不同难度的编码和非编码问题。今天就加入StaraScratch，让你在苹果、网飞、微软等顶级科技公司工作的梦想成为现实，或者在Noom、Doordash等热门初创公司工作的梦想成为现实。所有的代码示例都可以在<a class="ae kw" href="https://github.com/viveknest/statascratch-solutions/blob/main/NumPy%20for%20Data%20Science%20Part%2002.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>这里找到。</p></div><div class="ab cl oh oi hu oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="ij ik il im in"><p id="4d25" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">【https://www.stratascratch.com】最初发表于<a class="ae kw" href="https://www.stratascratch.com/blog/numpy-for-data-science-interviews-part-02/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"><em class="oa"/></a><em class="oa">。</em></p></div></div>    
</body>
</html>