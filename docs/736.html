<html>
<head>
<title>Make Your Machine Learning Model Work Better with DateTime Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用日期时间功能使您的机器学习模型更好地工作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-your-machine-learning-model-work-better-with-datetime-features-eb21de397fe8#2022-01-26">https://towardsdatascience.com/make-your-machine-learning-model-work-better-with-datetime-features-eb21de397fe8#2022-01-26</a></blockquote><div><div class="fc ik il im in io"/><div class="ip iq ir is it"><h2 id="948e" class="iu iv iw bd b dl ix iy iz ja jb jc dk jd translated" aria-label="kicker paragraph">特征工程，机器学习</h2><div class=""><h1 id="478e" class="pw-post-title je jf iw bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用日期时间功能使您的机器学习模型更好地工作</h1></div><div class=""><h2 id="f1b7" class="pw-subtitle-paragraph kc jf iw bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">解释如何从日期和时间中提取新要素的现成教程</h2></div><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj ku"><img src="../Images/bb02102cd0faa2149792eaa077e44bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NSC6Xt6-m6er06vz"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae lk" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="f858" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">毫无疑问，特征工程是构建机器学习模型的最重要的方面之一。研究表明，一个好的模特和一个优秀的模特之间的差别可以通过你设计你的特征的方式来实现。</p><p id="3c40" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">为了提高模型的准确性，您需要解决数据(不完整或不一致)和模型构建过程中的问题。当精度与您期望的不相似时，您可以使用不同的参数重新训练，或者设计与问题更相关的新功能。</p><p id="5f93" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在这篇文章中，我将通过一个实际的例子来讨论如何<strong class="ln jg">从日期时间变量</strong>中提取新的特征来增加机器学习模型的准确性。</p><p id="a860" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">文章组织如下:</p><ul class=""><li id="0357" class="mh mi iw ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">从日期提取特征</li><li id="9a4b" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">时间特征提取</li><li id="d7aa" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">实际例子</li></ul><h1 id="bd15" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">1从日期提取特征</h1><p id="759d" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">有些数据集提供了日期或日期时间字段，在为机器学习模型构建输入要素时通常会将其删除(显然，除非您正在处理时间序列😃).</p><p id="159f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">相反，DateTime可用于提取新要素，这些新要素可添加到数据集的其他可用要素中。</p><p id="e346" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">日期由一天、一个月和一年组成。从这三个部分中，至少可以提取四个不同的特征:</p><ul class=""><li id="ce77" class="mh mi iw ln b lo lp lr ls lu mj ly mk mc ml mg mm mn mo mp bi translated">一年中的某一天、一月中的某一天或一周中的某一天</li><li id="a505" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">一年中的月份</li><li id="c0ab" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">季节</li><li id="d39e" class="mh mi iw ln b lo mq lr mr lu ms ly mt mc mu mg mm mn mo mp bi translated">年</li></ul><p id="eb25" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在所有情况下，除了年份，所考虑的特征应分为两部分:正弦和余弦，以保证周期性，例如1月1日接近12月31日。</p><h2 id="8f9a" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">1.1一年中的某一天、一月中的某一天或一周中的某一天</h2><p id="ee72" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">一年中的某一天是指1到365(或366)之间的数字。当您有一个细粒度的精细数据集，并且在几天内有一个平衡的分布时，可以使用这个特性，否则，使用这个特性可能是危险的，因为它可能会产生过度拟合。</p><p id="1e5f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在Python中，一年中的某一天可以按如下方式计算:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="d095" class="ns mw iw oe b gz oi oj l ok ol">import <strong class="oe jg">numpy</strong> as np</span><span id="e6fe" class="ns mw iw oe b gz om oj l ok ol">current_date = "2022-01-25 17:21:22"<br/>cdate = datetime.strptime(current_date, '%Y-%m-%d %H:%M:%S')</span><span id="4b1a" class="ns mw iw oe b gz om oj l ok ol"><strong class="oe jg">day_sin</strong> = np.sin(2 * np.pi * cdate.timetuple().tm_yday/365.0)<br/><strong class="oe jg">day_cos</strong> = np.cos(2 * np.pi * cdate.timetuple().tm_yday/365.0)</span></pre><p id="a022" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">对于数据集中更稀疏的日期值，我建议您利用一天作为一个月中的某一天或一周中的某一天。</p><h2 id="d228" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">一年的1.2个月</h2><p id="23fb" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">一年中的月份是指1到12之间的数字。如果您的Pandas数据帧中有一个DateTime列，则一年中的月份可以提取如下:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="2cce" class="ns mw iw oe b gz oi oj l ok ol">df['month_sin'] = np.sin(2 * np.pi * df['date_time'].dt.month/12.0)<br/>df['month_cos'] = np.cos(2 * np.pi * df['date_time'].dt.month/12.0)</span></pre><h2 id="1deb" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">1.3季节</h2><p id="b2a3" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">季节是一个分类变量，它包括以下值:<em class="on">春天</em>、<em class="on">夏天</em>、<em class="on">秋天、</em>和<em class="on">冬天</em>。关于前面的特征，不计算季节的周期性。</p><p id="2762" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在Python中，可以提取季节，如Stackoverflow 上这个<a class="ae lk" href="https://stackoverflow.com/questions/16139306/determine-season-given-timestamp-in-python-using-datetime" rel="noopener ugc nofollow" target="_blank">有趣的帖子中所解释的。</a></p><p id="45f4" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">或者，季节可以被视为一个数字特征。在这种情况下，你应该注意周期性，所以你应该计算正弦和余弦。</p><h2 id="7256" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">1.4年</h2><p id="0d05" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated"><strong class="ln jg">通常，当您必须预测未来的值时，年份作为输入特征不是很有用。</strong>然而，为了完整起见，我描述了如何利用它作为输入特性。</p><p id="6a3c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果数据集包含多个年份，则可以使用年份。根据您的需要，它可以是分类变量，也可以是数值变量。</p><p id="8934" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果您的Pandas数据帧中有一个DateTime列，则年份可以提取如下:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="0c2e" class="ns mw iw oe b gz oi oj l ok ol">df['year'] = df['date_time'].dt.year</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oo"><img src="../Images/1227164753344991dde3de4ae2cb31b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nSS906hW-iRM2fJh"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated"><a class="ae lk" href="https://unsplash.com/@crrrrraig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克雷格·迈莱赫兰</a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="f404" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">2时间特征提取</h1><p id="fb5a" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">可以从DateTime列中提取时间特征。</p><p id="2496" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">根据数据集的粒度，可以提取不同级别的时间要素(小时、分钟、秒……)。然而，最常见的时间特性是以小时为基础的。请始终记住，时间特征应分为正弦和余弦，以反映数据的周期性(例如，23:59接近0:01)。</p><p id="c24c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">在Python中，给定一个日期时间变量，可以按如下方式提取一个小时:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="32d8" class="ns mw iw oe b gz oi oj l ok ol">import <strong class="oe jg">numpy</strong> as np</span><span id="c933" class="ns mw iw oe b gz om oj l ok ol"><strong class="oe jg">hour_sin</strong> = np.sin(2 * np.pi * cdate.hour/24.0)<br/><strong class="oe jg">hour_cos</strong> = np.cos(2 * np.pi * cdate.hour/24.0)</span></pre><h1 id="6b6f" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">3一个实例</h1><p id="7ace" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">这个例子利用了Kaggle上的<a class="ae lk" href="https://www.kaggle.com/muthuj7/weather-dataset" rel="noopener ugc nofollow" target="_blank">天气数据集</a>，该数据集有<a class="ae lk" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0: Public Domain </a>许可。</p><p id="e41a" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">本例的目标是构建一个多类分类器，该分类器根据输入要素预测天气状况(由数据集的列摘要给出)。我计算了两种情况下的准确性:有和没有DateTime特性。</p><h2 id="258d" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">3.1加载数据集</h2><p id="67e7" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">该数据集可在Kaggle上获得。我把它作为一个熊猫的数据框打开:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="0945" class="ns mw iw oe b gz oi oj l ok ol">import <strong class="oe jg">pandas</strong> as pd</span><span id="69bd" class="ns mw iw oe b gz om oj l ok ol">df = <strong class="oe jg">pd.read_csv</strong>('../input/weather-dataset/weatherHistory.csv')</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj op"><img src="../Images/2b48a41137ea759d8408506cd59aab0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fky0YiWLLK8wWVCmHb4Jiw.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="fee1" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">该数据集包含96，453条记录和12列。</p><h2 id="4802" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">3.2探索性数据分析</h2><p id="b2a8" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">现在，我去掉对预测没有太大影响的变量。我注意到<em class="on">隔音罩</em>对于所有行都是一样的，所以我可以将其移除。</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="a06d" class="ns mw iw oe b gz oi oj l ok ol">df['Loud Cover'].<strong class="oe jg">value_counts</strong>()</span></pre><p id="0584" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="335c" class="ns mw iw oe b gz oi oj l ok ol">0.0    96453<br/>Name: Loud Cover, dtype: int64</span></pre><p id="1394" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我还可以删除<em class="on">每日摘要</em>列，因为它只包含文本。</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="8816" class="ns mw iw oe b gz oi oj l ok ol">df.<strong class="oe jg">drop</strong>(['Daily Summary','Loud Cover'],axis=1,inplace=True)</span></pre><p id="8fef" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">最后，我处理缺失值:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="841d" class="ns mw iw oe b gz oi oj l ok ol">df.<strong class="oe jg">isnull()</strong>.<strong class="oe jg">sum()</strong></span></pre><p id="153a" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="59ac" class="ns mw iw oe b gz oi oj l ok ol">Formatted Date                0<br/>Summary                       0<br/>Precip Type                 517<br/>Temperature (C)               0<br/>Apparent Temperature (C)      0<br/>Humidity                      0<br/>Wind Speed (km/h)             0<br/>Wind Bearing (degrees)        0<br/>Visibility (km)               0<br/>Pressure (millibars)          0</span></pre><p id="b543" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated"><em class="on">预测类型</em>列包含一些缺失值。我放下了。</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="020e" class="ns mw iw oe b gz oi oj l ok ol">df.<strong class="oe jg">dropna</strong>(inplace=True)</span></pre><h2 id="66f5" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">3.3数据清理</h2><p id="7bf8" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">首先，我将分类数据转换成数字数据:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="24b9" class="ns mw iw oe b gz oi oj l ok ol">from sklearn.preprocessing import <strong class="oe jg">LabelEncoder</strong></span><span id="98bf" class="ns mw iw oe b gz om oj l ok ol">le = LabelEncoder()<br/>df['Precip Type']=le.fit_transform(df['Precip Type'])<br/>df['Summary']=le.fit_transform(df['Summary'])</span></pre><p id="607d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">然后，我标准化输入特征:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="9e94" class="ns mw iw oe b gz oi oj l ok ol">from sklearn.preprocessing import <strong class="oe jg">StandardScaler</strong></span><span id="6847" class="ns mw iw oe b gz om oj l ok ol">scaler = StandardScaler()<br/>df[df.columns[2:]] = scaler.fit_transform(df[df.columns[2:]])</span></pre><p id="6dde" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我从第二个第三列开始，因为我没有标准化前两列(DateTime和Summary)。</p><h2 id="1c48" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">3.4特征工程</h2><p id="232f" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">现在，我准备提取一年中的某一天和某一小时。我定义了一个函数，在给定日期的情况下，提取天数和小时数的正弦和余弦值:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="2ed7" class="ns mw iw oe b gz oi oj l ok ol">import <strong class="oe jg">numpy </strong>as np<br/>from <strong class="oe jg">datetime</strong> import datetime</span><span id="cab1" class="ns mw iw oe b gz om oj l ok ol">def <strong class="oe jg">discretize_date</strong>(current_date, t):<br/>    current_date = current_date[:-10]<br/>    cdate = datetime.strptime(current_date, '%Y-%m-%d %H:%M:%S')</span><span id="2651" class="ns mw iw oe b gz om oj l ok ol">if t == 'hour_sin':<br/>        return np.sin(2 * np.pi * cdate.hour/24.0)<br/>    if t == 'hour_cos':<br/>        return np.cos(2 * np.pi * cdate.hour/24.0)<br/>    if t == 'day_sin':<br/>        return np.sin(2 * np.pi * cdate.timetuple().tm_yday/365.0)<br/>    if t == 'day_cos':<br/>        return np.cos(2 * np.pi * cdate.timetuple().tm_yday/365.0)</span></pre><p id="e55f" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在，我提取新的特征:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="d421" class="ns mw iw oe b gz oi oj l ok ol">date_types = ['hour_sin', 'hour_cos', 'day_sin', 'day_cos']<br/>for dt in date_types:<br/>    df[dt] = df['Formatted Date'].apply(lambda x : discretize_date(x, dt))</span><span id="02e1" class="ns mw iw oe b gz om oj l ok ol">df.drop(['Formatted Date'],axis=1,inplace=True)</span></pre><p id="5c9c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我计算特征之间的相关性，以检查是否有一些特征高度相关。在这种情况下，两个功能中的一个可能会被删除。</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="0e57" class="ns mw iw oe b gz oi oj l ok ol">df.corr()</span></pre><figure class="kv kw kx ky gu kz gi gj paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gi gj oq"><img src="../Images/5a3ab5ee671c37b577b461d4126e219d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52C2hP6bjvEKGC2JROPW5g.png"/></div></div><p class="lg lh gk gi gj li lj bd b be z dk translated">作者图片</p></figure><p id="d8af" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">表观温度和温度高度相关，因此我可以降低表观温度:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="243d" class="ns mw iw oe b gz oi oj l ok ol">df.<strong class="oe jg">drop</strong>(['Apparent Temperature (C)'],axis=1,inplace=True)</span></pre><h2 id="35e1" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">3.5列车测试拆分</h2><p id="b903" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">我将数据分成X和y两部分，然后分成训练集和测试集:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="9b43" class="ns mw iw oe b gz oi oj l ok ol">from sklearn.model_selection import train_test_split</span><span id="00f7" class="ns mw iw oe b gz om oj l ok ol">X = df.iloc[:,1:]<br/>y=df.iloc[:,0] <br/><br/>X_train,X_test,y_train,y_test = <strong class="oe jg">train_test_split</strong>(X,y,test_size=0.3,random_state=1)</span></pre><h2 id="8839" class="ns mw iw bd mx nt nu dn nb nv nw dp nf lu nx ny nh ly nz oa nj mc ob oc nl jc bi translated">3.6模型培训和评估</h2><p id="58e0" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">我测试了两个模型，一个有DateTime特性，另一个没有。首先，我用日期时间特征训练模型:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="d207" class="ns mw iw oe b gz oi oj l ok ol">from sklearn.ensemble import RandomForestClassifier</span><span id="3781" class="ns mw iw oe b gz om oj l ok ol">model = <strong class="oe jg">RandomForestClassifier</strong>(max_depth=32,n_estimators=120,random_state=1)<br/>model.<strong class="oe jg">fit</strong>(X_train,y_train)<br/>y_pred = <strong class="oe jg">model.predict</strong>(X_test)</span></pre><p id="3c4c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我计算的准确度是:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="1f72" class="ns mw iw oe b gz oi oj l ok ol">from sklearn.metrics import <strong class="oe jg">accuracy_score</strong></span><span id="44bd" class="ns mw iw oe b gz om oj l ok ol"><strong class="oe jg">accuracy_score</strong>(y_test, y_pred)</span></pre><p id="923d" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="0aaf" class="ns mw iw oe b gz oi oj l ok ol">0.6695389319342622</span></pre><p id="0b09" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">现在，我在没有日期时间功能的情况下训练模型:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="958e" class="ns mw iw oe b gz oi oj l ok ol">model = <strong class="oe jg">RandomForestClassifier</strong>(max_depth=32,n_estimators=120,random_state=1)<br/>model.<strong class="oe jg">fit</strong>(X_train[X_train.columns[:-4]],y_train)</span><span id="4824" class="ns mw iw oe b gz om oj l ok ol">y_pred = model.<strong class="oe jg">predict</strong>(X_test[X_test.columns[:-4]])</span></pre><p id="0b0b" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我计算精确度:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="8d18" class="ns mw iw oe b gz oi oj l ok ol">accuracy_score(y_test, y_pred)</span></pre><p id="7ab1" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">它给出了以下输出:</p><pre class="kv kw kx ky gu od oe of og aw oh bi"><span id="ca2d" class="ns mw iw oe b gz oi oj l ok ol">0.5827108161634411</span></pre><p id="1e71" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">请注意具有日期时间功能的模型如何优于另一个模型。</p><p id="b457" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">你可以在我的<a class="ae lk" href="https://www.kaggle.com/alod83/using-datetime-for-weather-prediction" rel="noopener ugc nofollow" target="_blank"> Kaggle简介</a>中获得本教程的完整代码。</p><h1 id="5fd4" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">摘要</h1><p id="5520" class="pw-post-body-paragraph ll lm iw ln b lo nn kg lq lr no kj lt lu np lw lx ly nq ma mb mc nr me mf mg ip bi translated">恭喜你！您刚刚学习了如何从机器学习模型中提取日期时间特征！本文中描述的实际例子证明了日期时间特性的存在可以提高机器学习模型的性能。</p><p id="5fb0" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">我留给你一个挑战性的问题:</p><blockquote class="or"><p id="48f2" class="os ot iw bd ou ov ow ox oy oz pa mg dk translated">日期时间特性会引入过度拟合吗？</p></blockquote><p id="2d76" class="pw-post-body-paragraph ll lm iw ln b lo pb kg lq lr pc kj lt lu pd lw lx ly pe ma mb mc pf me mf mg ip bi translated">敬请关注…</p><p id="584c" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">你可以通过阅读<a class="pg ph ep" href="https://medium.com/u/8bd9949e2d6?source=post_page-----eb21de397fe8--------------------------------" rel="noopener" target="_blank">哈希尔·帕特尔</a>的这篇有趣的文章来了解更多关于特征工程的概念，这篇文章题为什么是<a class="ae lk" rel="noopener" target="_blank" href="/what-is-feature-engineering-importance-tools-and-techniques-for-machine-learning-2080b0269f10">特征工程——机器学习的重要性、工具和技术</a>。</p><p id="7fbf" class="pw-post-body-paragraph ll lm iw ln b lo lp kg lq lr ls kj lt lu lv lw lx ly lz ma mb mc md me mf mg ip bi translated">如果你已经走了这么远来阅读，对我来说今天已经很多了。谢谢！你可以在<a class="ae lk" href="https://alod83.medium.com/which-topics-would-you-like-to-read-c68314dc6813" rel="noopener">这篇文章</a>中读到更多关于我的内容。</p><h1 id="338a" class="mv mw iw bd mx my mz na nb nc nd ne nf kl ng km nh ko ni kp nj kr nk ks nl nm bi translated">相关文章</h1><div class="pi pj gq gs pk pl"><a rel="noopener follow" target="_blank" href="/a-machine-learning-model-is-no-longer-a-black-box-thanks-to-shap-9f6ae3adaedc"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd jg gz z fq pq fs ft pr fv fx jf bi translated">多亏了SHAP，机器学习模型不再是黑匣子</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">Python中的一步一步教程，揭示了机器学习模型的内部工作原理</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz le pl"/></div></div></a></div><div class="pi pj gq gs pk pl"><a href="https://medium.com/geekculture/why-overfitting-makes-machine-learning-algorithms-perform-worse-7414ce71031a" rel="noopener follow" target="_blank"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd jg gz z fq pq fs ft pr fv fx jf bi translated">为什么过度拟合会使机器学习算法的性能变差</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">关于机器学习过拟合的一些基本概念和减轻过拟合的一些技巧。</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">medium.com</p></div></div><div class="pu l"><div class="qa l pw px py pu pz le pl"/></div></div></a></div><div class="pi pj gq gs pk pl"><a rel="noopener follow" target="_blank" href="/getting-started-with-comet-ml-549d44aff0c9"><div class="pm ab fp"><div class="pn ab po cl cj pp"><h2 class="bd jg gz z fq pq fs ft pr fv fx jf bi translated">Comet ML入门</h2><div class="ps l"><h3 class="bd b gz z fq pq fs ft pr fv fx dk translated">机器学习流行实验平台概述，并附有实例。</h3></div><div class="pt l"><p class="bd b dl z fq pq fs ft pr fv fx dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="qb l pw px py pu pz le pl"/></div></div></a></div></div></div>    
</body>
</html>