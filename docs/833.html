<html>
<head>
<title>Go 1.18 Comes With Many Amazing Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 1.18带来了许多惊人的变化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/go-1-18-comes-with-many-amazing-changes-d33ac0afd6ee#2022-01-31">https://towardsdatascience.com/go-1-18-comes-with-many-amazing-changes-d33ac0afd6ee#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="f98e" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">Go 1.18带来了许多惊人的变化</h1></div><div class=""><h2 id="b138" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go 1.18将于二月发布，它包含了多项改进语言的变化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81e0cd5f4233f967e86d69757f264cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UMtIno29vozaAB5DKz9Kw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="9484" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">期待已久的围棋<a class="ae lu" href="https://tip.golang.org/doc/go1.18" rel="noopener ugc nofollow" target="_blank"> 1.18 </a>即将到来，这可能是很长一段时间以来讨论最多的围棋更新。语言中加入了一些重要的新东西，其中最突出的是泛型。</p><p id="6de8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多新加入的东西被忽略了，因为每个人都专注于泛型，所以让我们快速回顾一下即将到来的所有变化。在即将到来的更新中，有一些我觉得很重要的改变，你看不到提到那么多。</p><p id="2e04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一些主要特性，我有一篇深入的文章，如果您想更深入地了解该特性，欢迎阅读。</p><p id="cede" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想看视频，你可以在我的Youtube上找到这篇文章。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我在视频中讲述了Go 1.18的所有变化</p></figure><h2 id="0a61" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">无商标消费品</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37f1e5728d93628f250cdc21507fb485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qsJcRAcgdHOEzEPGk_8DzA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泛型的可视化解释，用函数表示的一行，泛型接受多个输入。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="ac69" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，Go最终得到了泛型。这似乎是一个让开发人员感到不安的话题，一些开发人员似乎喜欢这个想法，一些似乎讨厌它。</p><p id="08cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">泛型是一种允许函数接受多种不同数据类型的方式。当您必须对许多不同的类型执行相同的操作时，这很有用。</p><p id="f8f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go中缺少泛型的问题以前已经解决了，每个数据类型使用重复的函数，或者使用一个空的<code class="fe mq mr ms mt b">interface{}</code>来处理所需的数据类型，这个空的<code class="fe mq mr ms mt b">interface{}</code>是用一个大的<code class="fe mq mr ms mt b">switch</code>进行类型转换的。这两种变通方法是解决泛型缺乏的常见方法。在1.18版本中，这些解决方案，或者说黑客攻击可以被移除。</p><blockquote class="mu"><p id="55c1" class="mv mw it bd mx my mz na nb nc nd lt dk translated"><code class="fe mq mr ms mt b">[]interface{} hack — Generic Developer</code>的日子一去不复返了</p></blockquote><p id="161b" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">想象一下，你需要对一部分整数和一部分浮点数的值求和。这将需要您有两个重复的函数，函数将是相同的，一个<code class="fe mq mr ms mt b">for range</code>通过并添加值并返回结果。唯一的区别是定义的输入参数数据类型。</p><p id="57b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在泛型出现之前，这需要一个特定于每种数据类型的汇总函数，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用重复函数求解不同数据类型的总计数</p></figure><p id="8953" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用泛型，所有这三个汇总函数都可以用同一个函数来代替。</p><p id="fc41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看用泛型来解决这个问题时是什么样子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汇总总值的通用解决方案</p></figure><p id="ac8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我看来，这是一个巨大的进步。不仅减少了代码量，而且更易于维护、阅读，是一个不太复杂的解决方案。</p><p id="e3ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何使用泛型的知识，你可以阅读我写的关于泛型的文章。在这篇文章中，我们介绍了如何使用泛型，以及还可以用它做些什么。</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/@percybolmer/learning-generics-in-go-318f53752ccd" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">在围棋中学习泛型</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">泛型在更新1.18(将于2022年2月发布)中推出，带有一系列其他闪亮的新功能。你可以…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><h2 id="96cd" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">模糊测试</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f27e429af90e923b68509eeafc20e6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skeuHKluH_S4e3kyBHw6aQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go中的Fuzzing允许我们测试随机生成的函数输入。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="9166" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模糊是我最喜欢的更新之一。我很惊讶人们不再谈论它。它将使我们能够在测试过程中生成输入参数。</p><p id="7378" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这听起来可能不多，但是它允许我们容易地扩展单元测试来定位和跟踪更多的bug。表驱动测试允许我们给出许多不同的输入，但是你可能不会写几百个不同的测试输入，但是fuzzing可以允许这样产生。</p><p id="fdb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Fuzzing允许你测试数以千计的不同输入，这有助于发现隐藏的错误，你可能不会想到自己检查的错误。</p><p id="670a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于模糊化的想法是，通过为你的函数生成一堆不同的输入，有更高的机会找到突破性的边缘情况。fuzzing包将接受一个示例输入作为基础，称为<code class="fe mq mr ms mt b">seed corpus</code>。fuzzer将使用这些示例作为起点，并对其进行修改，以找到导致函数中断的值。</p><p id="35c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Fuzzing将被添加到<code class="fe mq mr ms mt b">testing</code>包中，它将是一个新的结构，使用方式与<code class="fe mq mr ms mt b">testing.T</code>相同，但不是<code class="fe mq mr ms mt b">testing.F</code>。</p><p id="a684" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">来自<a class="ae lu" href="https://go.dev/blog/fuzz-beta" rel="noopener ugc nofollow" target="_blank"> go.dev </a>的一个关于fuzzing的例子看起来是这样的，注意他们如何添加GET查询参数作为种子语料库，这将允许fuzzer生成数千个类似的输入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">go.dev —模糊示例</p></figure><p id="8436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解如何使用fuzzer和编写fuzzing函数，for，etc HTTP处理程序或更多，那么你可以阅读我的文章。</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/@percybolmer/fuzzing-tests-in-go-96eb08b7694d" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">围棋模糊测试</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">Fuzzing是作为Go 1.18中标准库的一部分发布的。这是一个很酷的方法来定位你的…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob ks nn"/></div></div></a></div><h2 id="fba0" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">工作区</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a28cab1e78f95a79d2366925cdbc0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQHLWpmUFAq4AErUO8zb9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作区模式允许我们以更好的方式替换版本和模块。图片由珀西·博尔梅尔提供。Gopher由拓也·上田提供，原始Go Gopher由勒内·弗伦奇提供(CC BY 3.0)</p></figure><p id="8f2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">发布工作区是为了让开发人员能够轻松地切换项目中使用的模块版本。这样做的原因是为了在同时处理多个模块时简化开发。</p><p id="41a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你一直在公司环境中使用go模块，你很可能被迫添加一个<code class="fe mq mr ms mt b">replace</code>指令来改变或强制使用一个包的本地版本。</p><p id="68f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mq mr ms mt b">replace</code>指令很容易忘记从您的<code class="fe mq mr ms mt b">go.mod</code>文件中删除，如果将其推送到存储库，将会破坏其他开发人员的模块。因为工具现在将使用在<code class="fe mq mr ms mt b">go.mod</code>文件中给定的路径，这很可能不存在于另一个开发人员的计算机上。</p><p id="de02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对<code class="fe mq mr ms mt b">replace</code>不熟悉，你可以通过告诉它用本地路径或特定版本替换某个模块来替换要在<code class="fe mq mr ms mt b">go.mod</code>文件中使用的模块，让它获取一个本地分支，而不是用<code class="fe mq mr ms mt b">go get</code>获取库</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">go . mod-最小替换指令。</p></figure><p id="096d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在要点中看到我是如何告诉go工具，任何时候它看到<code class="fe mq mr ms mt b">github.com/programmingpercy/mymodule</code>它都应该从我在<code class="fe mq mr ms mt b">/home/users/percy/experimental/mymodule</code>的计算机上的本地路径获取，而不是使用<code class="fe mq mr ms mt b">go get</code></p><p id="90bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们有一个针对<code class="fe mq mr ms mt b">go.mod</code>文件中的<code class="fe mq mr ms mt b">replace</code>指令的补救措施。这对我来说很重要，我经常发现自己同时在多个模块上工作，同时对它们进行修改。</p><p id="cd08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始使用他们所说的<code class="fe mq mr ms mt b">workspace</code>模式，您可以使用常规的go工具初始化工作区。类似于创建一个模块，您运行<code class="fe mq mr ms mt b">go work init</code>。这将创建您的工作空间文件，我们可以开始使用。</p><p id="7ec1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，工作空间模式将使许多go工具开始使用<code class="fe mq mr ms mt b">go.work</code>文件，并为您修改它。go团队声明您不应该将<code class="fe mq mr ms mt b">go.work</code>文件推送到存储库，因为这将在<code class="fe mq mr ms mt b">go.mod</code>文件中再次引入<code class="fe mq mr ms mt b">replace</code>的问题。</p><p id="c729" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">工作区模式将强制使用<code class="fe mq mr ms mt b">go.work</code>中提到的所有模块，类似于<code class="fe mq mr ms mt b">go.mod</code>文件。我们仍然可以使用<code class="fe mq mr ms mt b">replace</code>指令来指定要使用的模块。这允许您继续使用replace指令，同时保持您的<code class="fe mq mr ms mt b">go.mod</code>文件干净，并且只有。git忽略<code class="fe mq mr ms mt b">go.work</code>。</p><p id="c0d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae lu" href="https://go.googlesource.com/proposal/+/master/design/45713-workspace.md" rel="noopener ugc nofollow" target="_blank">的提议中，</a>提到了更多的特性，在不同工作区之间切换以轻松测试多个依赖版本的能力，等等。迫不及待地想尝试这个功能。</p><h2 id="efae" class="lx ly it bd lz ma mb dn mc md me dp mf lh mg mh mi ll mj mk ml lp mm mn mo mp bi translated">荣誉奖</h2><p id="a296" class="pw-post-body-paragraph ky kz it la b lb od ju ld le oe jx lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">有一些变化值得一提，但没有大到足以有他们的一章。</p><p id="723f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">任何</strong> —如果你开始看到<code class="fe mq mr ms mt b">any</code>出现在go代码库中，不要惊慌。这是<code class="fe mq mr ms mt b">interface{}</code>的一个新的预声明别名</p><p id="b006" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">可比较的</strong> —一个接口的预声明别名，包含所有可以使用<code class="fe mq mr ms mt b">==</code>和<code class="fe mq mr ms mt b">!=</code>进行比较的类型。这与泛型相关联，并被用作约束。</p><p id="5bbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">net/netip — 看起来我们将会得到一个新的处理ip地址的包。我在Go里做过很多人脉，处理IP地址一直很痛苦。看起来我不是唯一一个经历这种情况的人，让我们希望这个解决方案会更好。</p><p id="2360" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">琴弦。削减</strong>——我从来不知道我们需要的改进。strings包附带了一个新的函数，<code class="fe mq mr ms mt b">Cut</code>，它将找到一个分隔符并返回在分隔符前后找到的任何内容。它还将返回一个布尔值，表明是否找到了分隔符。</p><blockquote class="mu"><p id="0839" class="mv mw it bd mx my mz na nb nc nd lt dk translated">IP:端口—我正看着你</p></blockquote><h2 id="3e6d" class="lx ly it bd lz ma oi dn mc md oj dp mf lh ok mh mi ll ol mk ml lp om mn mo mp bi translated">结论</h2><p id="c3e1" class="pw-post-body-paragraph ky kz it la b lb od ju ld le oe jx lg lh of lj lk ll og ln lo lp oh lr ls lt im bi translated">此次更新将带来许多受欢迎的变化。go团队一直在努力工作，我们可以从许多重大变化中看出这一点。</p><p id="afe6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我特别喜欢工作区和fuzzing的介绍。</p><p id="4f73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">go语言正在成熟，作为一个地鼠，我很自豪地看着它成长。</p><p id="a3ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢我写的文章，如果你想了解如何使用新特性，请确保查看关于主要主题的深入文章。你应该了解一下<a class="ae lu" href="https://medium.com/@percybolmer/learning-generics-in-go-318f53752ccd" rel="noopener">泛型</a>和<a class="ae lu" href="https://medium.com/@percybolmer/fuzzy-testing-in-go-96eb08b7694d" rel="noopener">模糊化</a>。</p><p id="815e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你还在等什么，<a class="ae lu" href="https://go.dev/dl/#go1.18beta1" rel="noopener ugc nofollow" target="_blank">下载</a>1.18更新，并开始使用所有新的闪亮奖品！</p></div></div>    
</body>
</html>