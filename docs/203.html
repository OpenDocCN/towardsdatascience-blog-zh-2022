<html>
<head>
<title>From Kernel Density Estimation to Spatial Analysis In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从核密度估计到Python中的空间分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-kernel-density-estimation-to-spatial-analysis-in-python-64ddcdb6bc9b#2022-01-07">https://towardsdatascience.com/from-kernel-density-estimation-to-spatial-analysis-in-python-64ddcdb6bc9b#2022-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="4ebe" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">从核密度估计到Python中的空间分析</h1></div><div class=""><h2 id="8c82" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将您的KDE转化为地理空间数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e959c60bc24cac7fbbebfd9e108c860c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bilUjpkWTGvk-81xWozP_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。核密度估计的例子</p></figure><p id="ead9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">核密度估计(KDE)是一个有用的分析和可视化工具，通常是可视化或分析工作流的最终产品。核密度估计是很好的可视化，但是它们的使用还可以更进一步。</p><p id="03d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我将展示一种使用Python获取内核密度估计图并将它们转换成地理空间数据以便进一步分析的方法。</p><h1 id="4217" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">核密度估计</h1><p id="c37d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在<a class="ae mo" href="https://seaborn.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Seaborn </a>的帮助下，使用Python创建内核密度估计图相当简单。我们从读入GeoPandas中的点数据集开始。我正在使用芬兰赫尔辛基的自行车共享站的数据集，从OpenStreetMap检索，但只要你的数据包含坐标或形状点，你应该没问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">读入数据</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/32068d1e1d2f1bd3139a9f63b47f0c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*d57WheG8WYDI3f1FyzvVjQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自行车共享站数据框架</p></figure><p id="d1b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了读入的数据，我们可以开始创建我们的核密度估计。我不会深入讨论KDE本身的细节，因为还有很多其他来源，比如<a class="ae mo" href="https://scikit-learn.org/stable/modules/density.html#kernel-density-estimation" rel="noopener ugc nofollow" target="_blank"> scikit-learn文档</a>，但是下一个代码块展示了Seaborn实现是如何工作的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建核密度估计。</p></figure><p id="9b1d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这产生了KDE图，我们将把它转换成可用于空间操作的有形状的对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e959c60bc24cac7fbbebfd9e108c860c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bilUjpkWTGvk-81xWozP_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。KDE情节。</p></figure><h2 id="ef05" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">为每个强度级别创建多重多边形</h2><p id="26e2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">KDE图的不同轮廓可以通过我们的KDE的<code class="fe ne nf ng nh b">collections</code>对象来访问。通过对该对象进行迭代，我们可以访问我们之前定义的每个亮度级别的每个轮廓的每个路径。</p><p id="37bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可能会出现轮廓不连续的情况，因此我们为相同强度级别的每条路径创建一个多边形，然后将它们组合成一个多多边形，为每个强度级别提供一个多多边形。</p><p id="a88a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里的方法受到了<a class="ae mo" href="https://gis.stackexchange.com/questions/99917/converting-matplotlib-contour-objects-to-shapely-objects" rel="noopener ugc nofollow" target="_blank"> StackExchange </a>上的这个线程的启发。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将我们的轮廓转换成多重多边形</p></figure><h2 id="4b18" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">转换为地理数据</h2><p id="e50e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">现在我们已经有了一个包含我们的多多边形和相应强度级别的元组列表，我们可以创建一个Pandas数据框架，然后我们可以将其转换为GeoDataFrame。</p><p id="e81e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过地理数据框架，我们可以访问轮廓的Shapely对象，并利用Shapely的所有内置操作，例如轻松计算每个轮廓的面积估计值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">转换到地理数据框架并导出数据。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/77f6d03aa1b0ec0cbafc04e45031d5b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*JfS6MR3exQLvOFZPZACmLw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成的地理数据框架</p></figure><p id="d2bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的地理数据框架显示了我们生成的多重多边形以及每个估计等高线的面积计算。由于我们现在有了Shapely对象，我们可以使用Shapely的任何内置方法来扩展空间分析，或者由于我们已经将地理数据框架导出到地理包，我们可以在QGIS等中打开它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/fa4283c71903520b90c00541d8556f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f-_HgZhHgCUr-3gbQQh0YQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。在QGIS中打开Geopackage。</p></figure><h1 id="a6c7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="9a2f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这篇文章中，我简单介绍了如何将你的KDE图转换成形状优美的物体和地理空间文件，以便你进一步分析。</p></div></div>    
</body>
</html>