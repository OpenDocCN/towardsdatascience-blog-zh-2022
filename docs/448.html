<html>
<head>
<title>Everything You Need To Know About Types In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Julia中的类型，你需要知道的一切</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/everything-you-need-to-know-about-types-in-julia-84f64c0f86f3#2022-01-15">https://towardsdatascience.com/everything-you-need-to-know-about-types-in-julia-84f64c0f86f3#2022-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="3c59" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">关于Julia中的类型，你需要知道的一切</h1></div><div class=""><h2 id="8104" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对Julia中类型系统的全面概述，以及一些你需要了解的关键内容。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/294d948361bccd3e2f06bf14b3516375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IF12jx50onduD7NfwVrnbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank">像素窗口</a>上的<a class="ae ky" href="https://pixabay.com/images/id-144980/" rel="noopener ugc nofollow" target="_blank">剪贴画向量</a>生成)</p></figure><h1 id="d092" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ea4e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我看来，作为一种动态类型语言，在Julia中仍然需要考虑很多类型。这实际上是我比其他语言更喜欢的东西，其他语言有时会试图隐藏类型并隐式地为你改变类型。JavaScript中的这类东西把我逼到了疯狂的边缘，所以像Julia的(令人惊奇的)类型系统是非常令人耳目一新的。来自许多其他语言，我觉得Julia的类型系统非常健壮，可能是我用过的最好的一个。</p><p id="7483" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，对于任何动态类型化的类型系统，类型如何被持有以及如何被改变和操作的特定设计必然会有一些奇怪和细微的差别。这是在Julia被JIT编译的基础上，而且…哦，是的…</p><blockquote class="ms"><p id="6d51" class="mt mu it bd mv mw mx my mz na nb mm dk translated">使用多重分派作为编程范例。</p></blockquote><p id="cc6e" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">今天，我将与你们分享我所知道的关于类型的一切，从数据结构、构造函数和方法与类型的接口，到学习更多关于类型的知识，甚至构建复杂的构造函数。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="ef0b" class="kz la it bd lb lc no le lf lg np li lj jz nq ka ll kc nr kd ln kf ns kg lp lq bi translated">№1:一切都是一种类型。</h1><p id="a04e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于Julia，我们应该了解的第一件事是，一切都是一种类型。这是Julia语法方法论的中心，一切都需要是一个类型。也就是说，既然一切都是类型，我们可以通过其他调用来分派类型，等等。就像那样，我们的类型可以通过它们的方法组连接起来。这是茱莉亚背后的核心思想，而且很奇妙。例如，函数的类型如下:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="727c" class="ny la it nu b gy nz oa l ob oc">Function</span></pre><p id="efcd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一切事物都有一部分是这样被持有的，因为语言大部分是自己写的。此外，这些类型的大部分功能都可以通过导入基方法然后将它们绑定到值来扩展。这使得你在Julia中写的任何东西都更加可扩展。</p><h1 id="4333" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:类型of()</h1><p id="b2ba" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们不知道某个东西的类型，我们可以使用type of()方法来解决这个问题。对于您可能希望偶尔运行的条件来说，这也很方便。这个函数也方便地提供了许多探索特性，因为用typeof调用第一个索引非常容易。然而如今，我觉得我更喜欢od.dtype()的OddFrames.jl方法。</p><h1 id="15a5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3: varinfo()</h1><p id="1e63" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">varinfo()方法是一个非常酷和简单的方法，每当你启动它时，Julia就会导出它。换句话说，你可以在任何地方使用它！它显示了我们的全球环境中的值及其各自的内存使用情况的减价表:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="1f1c" class="ny la it nu b gy nz oa l ob oc">varinfo()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/22b011cffcd7827e81c2076f4a6ee192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5YGqfweqiod6JoURmC69RQ.png"/></div></div></figure><h1 id="33fd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">第四名:派遣</h1><p id="b452" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你对Julia感兴趣，但是没有听说过multiple dispatch，或者它在Julia中是什么样的——准备在下一集享受这个奇妙的范例吧。我们基本上可以将方法名定义为它们的别名和参数类型！这是一个自ML语言以来就存在的概念，但至少对于大型编程语言设计来说，有点不为人知。我有一整篇文章详细介绍了为什么多重调度在Julia中如此之好，实际上有趣的是，它使用了与今天相同的项目中的一些旧代码！</p><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/how-julia-perfected-multiple-dispatch-16675db772c2"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">朱莉娅如何完善多重派遣</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">让我们看看Julia语言是如何让多重调度变得完美的</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><p id="9695" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Julia以一种巨大的方式出现在dispatch中，由于多重调度，这个列表中的许多元素都是可能的。这是一个关键特性，有太多的理由认为它很棒。但是，首先让我向您展示一个使用多重分派来扩展length()函数的基本用法，例如，它相当于Python中的len()。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="6fbc" class="ny la it nu b gy nz oa l ob oc">function _drop!(column::Symbol, labels::Array{Symbol}, columns::Array,<br/>        types::Array)<br/>        pos = findall(x-&gt;x==column, labels)[1]<br/>        deleteat!(labels, pos)<br/>        deleteat!(types, pos)<br/>        deleteat!(columns, pos)<br/>end<br/>function  _drop!(mask::BitArray, labels::Vector{Symbol},<br/>         columns::AbstractArray, types::AbstractArray)<br/>        pos = findall(x-&gt;x==0, mask)<br/>        _drop(pos, column, labels, types)<br/>end<br/>function _drop!(row::Int64, columns::Array, labels::Vector{Symbol},<br/>        types::Array{Type})<br/>        [deleteat!(col, row) for col in columns]<br/>end</span></pre><p id="9769" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个例子函数，_drop！()来自我最近开发的一个叫做OddFrames.jl的包。顺便说一下，它已经非常成熟了，并且即将有一个稳定的版本，所以如果你想看看，这里有链接！：</p><div class="oe of gp gr og oh"><a href="https://github.com/ChifiSource/OddFrames.jl/tree/main" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GitHub-chifi source/odd frames . JL:Julia的独特数据管理平台</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">OddFrames.jl是一个用于在Julia中管理数据的新包。轻到足以成为任何项目的依赖，但丰富…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><p id="ca7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">反正你也看到了，我有_滴！()使用值绑定掩码</p><h1 id="895e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№5:子打字</h1><p id="5b1d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于在Julia中输入，你应该知道的下一件事是子类型。什么是子类型，它们与调度有什么关系？通过使用抽象层，子类型被用来在广泛的功能范围内扩展类型的方法。我们本质上是在定义一个新的方法范围，这些方法是私有的，用于将我们的类型传递给其他类型。在这个抽象层中，我们有很多孩子，用“:子类型”操作符表示。看看这个:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="b2d4" class="ny la it nu b gy nz oa l ob oc">abstract type AbstractOddFrame end<br/>abstract type AbstractMutableOddFrame &lt;: AbstractOddFrame end</span></pre><p id="10a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们定义了这两个抽象层，Julia将始终使用它拥有的最低层。如果调度是直接针对那个类型的，它将跳到下一个可用的抽象类型，直到它用完抽象；然后你得到一个MethodError。这意味着有了这两个子类型:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="07b0" class="ny la it nu b gy nz oa l ob oc">OddFrame &lt;: AbstractMutableOddFrame</span></pre><p id="9a7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">和</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="b658" class="ny la it nu b gy nz oa l ob oc">AbstractOddFrame &lt;: ImmutableOddFrame</span></pre><p id="8b35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从技术上讲，我可以在复制函数中调用::AbstractOddFrame来调度ImmutableOddFrame:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="4fa0" class="ny la it nu b gy nz oa l ob oc">function copy(od::OddFrame)<br/>    values = copy(Array{Pair}(od))<br/>    return(OddFrame(values))<br/>end</span><span id="5bea" class="ny la it nu b gy ox oa l ob oc">function copy(od::ImmutableOddFrame)<br/>        values = copy(Array{Pair}(od))<br/>        return(ImmutableOddFrame(values))<br/>end</span></pre><p id="d47d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重要的是，我们要知道一个不可变的或可变的OddFrame是否存在。我们可以让这里的急件更抽象一些</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="f0a1" class="ny la it nu b gy nz oa l ob oc">copy(od::ImmutableOddFrame)<br/>copy(od::OddFrame)</span></pre><p id="76f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">到…里面</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="2660" class="ny la it nu b gy nz oa l ob oc">copy(od::AbstractOddFrame)<br/>copy(od::AbstractMutableOddFrame)</span></pre><p id="e84c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是因为AbstractMutableOddFrame是抽象OddFrames的子类型。但是请记住，方法是在最接近的抽象类型中被读取的。这是需要记住的关键。</p><h1 id="58d7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№6:匿名打字</h1><p id="a683" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可以做的另一件有趣的事情是对一组随机数据类型有效地调用new()。这些数据类型可以是任何东西，函数、整数、数组、矩阵、构造类型，我指的是任何东西。同样，我们可以把它构造成一个回报，就像这样:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="c9b1" class="ny la it nu b gy nz oa l ob oc">x(w) = 5 + w</span><span id="168d" class="ny la it nu b gy ox oa l ob oc">y = 5<br/>z = () -&gt; (x;y)</span><span id="ba4c" class="ny la it nu b gy ox oa l ob oc">z.x(5)</span><span id="d65e" class="ny la it nu b gy ox oa l ob oc">10</span><span id="035c" class="ny la it nu b gy ox oa l ob oc">z.y</span><span id="a0b0" class="ny la it nu b gy ox oa l ob oc">5</span></pre><h1 id="942d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7:动态构造函数类型</h1><p id="3774" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有时，我们可能希望将一个类型提供给构造函数，以便在某种别名下进行分派。在我们不知道将得到什么类型的回报的用例中，我们可能希望这样。我们可以使用以下语法将提供给内部构造函数的类型更改为在外部构造函数中提供。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="a45a" class="ny la it nu b gy nz oa l ob oc">mutable struct example{unknownT}</span></pre><p id="93e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这种语法基本上意味着“这里的类型”，因为同样的原因，我们可以有一个数组{Pair},同时仍然为数组使用相同的内部构造函数返回，例如。这完全进入了我的下一个类型特性，所以让我们通过关注函数和结构中的uknownT()调用来更详细地了解动态构造函数类型。</p><h1 id="dabb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№8:内部构造函数</h1><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="279b" class="ny la it nu b gy nz oa l ob oc"># Outer Constructor<br/>mutable struct example{unknownT}<br/>    data::Dict<br/>    idontknow::unknownT</span><span id="0882" class="ny la it nu b gy ox oa l ob oc"># Inner Constructor<br/>    function example(data::Dict)<br/>        idontknow = 5<br/>        unknownT = typeof(idontknow)<br/>        new{unknownT}(data, idontknow)</span><span id="0015" class="ny la it nu b gy ox oa l ob oc">end</span><span id="598d" class="ny la it nu b gy ox oa l ob oc">end</span></pre><p id="2dd4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用内部构造函数也是dispatch的一个特性。内部构造函数很棒，因为在某种程度上它们充当了类型的初始化函数，但它们也可以像数据类对象一样使用，或者可以是一个成熟的类，我们将在下一个例子中看到。</p><h1 id="f0c1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№9:面向对象编程</h1><p id="205f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">只需将构造函数属性设置为Function类型，我们就可以轻松地改变Julia的范式，开始面向对象编程。您甚至可以使用成员变量，根本不需要使用self。看看我的OddFrames.jl项目中的这三个OddFrame构造函数，看看你是否能注意到它们是如何组合在一起的。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="2b6d" class="ny la it nu b gy nz oa l ob oc">mutable struct OddFrame &lt;: AbstractMutableOddFrame<br/>        labels::Array{Symbol}<br/>        columns::Array{Any}<br/>        types::Array<br/>        head::Function<br/>        dtype::Function<br/>        not::Function<br/>        only::Function<br/>        drop!::Function<br/>        dropna!::Function<br/>        dtype!::Function<br/>        merge!::Function<br/>        only!::Function<br/>        #==<br/>        Constructors<br/>        ==#<br/>        function OddFrame(labels::Vector{Symbol}, columns::Any,<br/>                types::Vector{DataType})<br/>                head, dtype, not, only = member_immutables(labels, columns,<br/>                                                                types)<br/>                drop!, dropna!, dtype!, merge!, only! = member_mutables(labels,<br/>                columns, types)<br/>                return(new(labels, columns, types, head, dtype, not, only, drop!,<br/>                dropna!, dtype!, merge!, only!))<br/>        end<br/>        function OddFrame(p::Pair ...)<br/>                labels, columns = ikeys(p), ivalues(p)<br/>                length_check(columns)<br/>                name_check(labels)<br/>                types = [typeof(x[1]) for x in columns]<br/>                return(OddFrame(labels, columns, types))<br/>        end</span></pre><p id="3a21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里实际上有几个调度电话在一起工作。因为唯一真正根据输入改变的是，我为所有的调用创建了一个分派存根，以创建我的方法并返回类型，这样代码就不会重复。同样，这也是OddFrame的另一个构造函数。实际的OddFrame类型包含几个函数，其行为很像一个类。</p><h1 id="65e7" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№10:获取字段()</h1><p id="b4cb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一个很酷的东西是getfield()模块，您可以利用它来更强制性地处理Julia中的类型。我们可以使用它通过符号(提供给外部构造函数的字段)获得数据值。这是一个非常有趣的电话，是一个很好的记住，以防事情变得有点疯狂。在朱莉娅的作品中，你可以看到一些非常疯狂的东西。记住这是一个好主意，把这样的事情记在心里，这样你就可以通过探索回报来实验和学习。</p><h1 id="f93d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№11:将方法扩展到类型</h1><p id="fe1d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我想谈的最后一件事是展示多重调度作为一种范例是多么有效..是的，因为这可能暗示；这一个也确实因为多重派遣才存在。在下面的示例中，我们从base扩展了getindex()方法，以便在OddFrame上设置索引:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="8ca3" class="ny la it nu b gy nz oa l ob oc">import Base: getindex<br/>function getindex(od::AbstractOddFrame, col::Symbol)<br/>        pos = findall(x-&gt;x==col, od.labels)[1]<br/>        return(od.columns[pos])<br/>end</span></pre><h1 id="1fa6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="7f66" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Julia的范式方法可能有点奇怪</p><blockquote class="ms"><p id="edad" class="mt mu it bd mv mw mx my mz na nb mm dk translated">“如果多重派遣能做到，我们就让你去做”</p></blockquote><p id="189a" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">背后的方法论。也就是说，对我来说，这当然不是一件坏事。多重分派是如此不可思议的方便，以至于可以出于许多不同的原因来制作伟大的软件。我们对Julia的能力没有任何限制，因为它有如此多的通用应用程序——作为一个范例，多重调度是非常通用的。它使事情更容易扩展，允许我们构建复杂的构造函数，并允许我们基于层次结构对不同类型使用相同的方法调用——这非常棒！非常感谢你阅读我的文章，它对我来说意味着整个世界。我希望这澄清了一些关于用Julia语言打字的误解或秘密。一如既往，祝你度过愉快的一天！</p></div></div>    
</body>
</html>