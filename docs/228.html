<html>
<head>
<title>Understanding Python decorators: Six levels of decorators from beginner to expert</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python装饰者:从初学者到专家的六个层次的装饰者</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/six-levels-of-python-decorators-1f12c9067b23#2022-01-08">https://towardsdatascience.com/six-levels-of-python-decorators-1f12c9067b23#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="b439" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">理解Python装饰者:从初学者到专家的六个层次的装饰者</h1></div><div class=""><h2 id="0910" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">装饰者如何工作，何时使用它们，以及6个越来越复杂的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/61215e1ae77448241a28316697d7e3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k2meBKNh3X6HhEFU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这段代码已经装饰得很漂亮了(图片由<a class="ae ky" href="https://unsplash.com/@intricateexplorer" rel="noopener ugc nofollow" target="_blank">复杂的探险家</a>在<a class="ae ky" href="https://unsplash.com/photos/H0-3xfbU8wk" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><p id="8584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装饰器是一个非常方便的工具，可以用来改变函数的行为，而不用修改函数本身。它们允许您在不更改现有代码的情况下轻松添加功能。有许多用例(其中一些我们将在今天讨论),如日志记录、性能检查、验证权限等。</p><p id="4888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读完这篇文章后，你会对装饰者如何工作、如何应用以及何时应用有一个清晰的了解。我们将从最简单、最基本的例子开始，然后慢慢地向更复杂的例子发展。最后我们会有一个函数，用不同类型的多个装饰器来装饰。我们来编码吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="58df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">装修工如何工作</h1><p id="ef24" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们将指定一个我们想要装饰的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="c06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，这个函数叫做‘say hello ’,我们可以通过运行<code class="fe nb nc nd ne b">sayhello()</code>来执行它(注意函数名后面的()。这和<code class="fe nb nc nd ne b">print(sayhello)</code>不一样；这将返回函数名和存储函数的内存地址:<br/> <code class="fe nb nc nd ne b">&lt;function sayhello at 0x000001F64CA25A60&gt;</code></p><p id="7b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建一个装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们创建了一个期望另一个函数的函数。然后，我们定义一个名为wrapper的内部函数，在其中执行接收到的函数。然后我们返回内部函数。定义内部函数的原因是为了处理参数，我们将在下一章看到这一点。</p><p id="fac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像这样使用这个装饰器<code class="fe nb nc nd ne b">our_decorator(sayhello())</code>或者添加一点语法糖，然后像这样传递它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="e3fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法是等价的:我们将<code class="fe nb nc nd ne b">sayhello</code>包装在<code class="fe nb nc nd ne b">our_decorator</code>中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2f1c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">复杂6步中的装饰者</h1><p id="f391" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经了解了decorator及其语法的工作方式，我们将通过decorator的6个步骤向您展示它们提供的所有可能性和灵活性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5dd338edd2d84ab4ff08738ea54e54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kIyz8swdwhMSYEC3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让我们开始装饰吧(图片由<a class="ae ky" href="https://unsplash.com/@danielkcheung" rel="noopener ugc nofollow" target="_blank">张家瑜</a>于<a class="ae ky" href="https://unsplash.com/photos/ZqqlOZyGG7g" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="51d7" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">1.最简单的装饰</h2><p id="4950" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们创建一个装饰器的最基本的例子。我们创建了一个名为<code class="fe nb nc nd ne b">logging_decorator</code>的函数，它将用于修饰其他函数。首先，我们检查代码，然后浏览:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们正在重新使用旧的<code class="fe nb nc nd ne b">sayhello</code>功能。我们用一个叫做<code class="fe nb nc nd ne b">logging_decorator</code>的函数来修饰它。正如您在第3–5行中看到的，我们可以在实际执行<code class="fe nb nc nd ne b">sayhello</code>之前和之后做一些事情，所以让我们打印出我们调用这个函数用于调试的事实。</p><p id="4b55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，我们可以将函数作为对象来访问。这样我们可以在第3行和第5行调用函数的名字。执行下面的代码会打印出以下内容:</p><pre class="kj kk kl km gt nr ne ns nt aw nu bi"><span id="4b34" class="nf md it ne b gy nv nw l nx ny">[LOG]   calling sayhello<br/> === Hello from the function function<br/>[LOG] called sayhello</span></pre><p id="54a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们的函数非常简单；它甚至不返回任何东西。在下一部分，我们将增加一点复杂性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0f5e" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">2.传递参数和返回值</h2><p id="6b3d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在前一部分中，我们的装饰器只是执行包装的函数。我们将升级代码，以便函数接收参数并实际返回一些内容。这就是名为<code class="fe nb nc nd ne b">wrapper</code>的内部函数的用武之地。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="882d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们修饰了<code class="fe nb nc nd ne b">multiply</code>函数。这个函数需要两个参数。我们在第2行用*args和**kwargs修改了decorator函数内部的包装器。然后我们将它们传递给第4行的修饰函数。在同一行中，我们还接收修饰函数的结果，然后在第6行返回。这些微小的变化使得我们可以从我们的目标函数中得到一个结果:</p><pre class="kj kk kl km gt nr ne ns nt aw nu bi"><span id="b4eb" class="nf md it ne b gy nv nw l nx ny">[LOG]   calling multiply<br/>  === Inside the multiply function<br/> [LOG] called multiply<br/>[result]   20</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="eb9e" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">3.多个装饰者</h2><p id="9e34" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也可以用多个装饰器来装饰一个函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="33d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码首先将<code class="fe nb nc nd ne b">multiply</code>包装在<code class="fe nb nc nd ne b">logging_decorator_2</code>中，然后将整个串包装在<code class="fe nb nc nd ne b">logging_decorator_1</code>中。它从目标函数开始，通过所有装饰器向上移动。您可以在下面的输出中看到装饰器被调用的顺序:</p><pre class="kj kk kl km gt nr ne ns nt aw nu bi"><span id="23d4" class="nf md it ne b gy nv nw l nx ny">[LOG1]   calling decorator 1<br/>[LOG2]   calling decorator 2<br/> multiply function<br/>[LOG2] called decorator 2<br/>[LOG1] called decorator 1<br/>[result]   42</span></pre><p id="c83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用我们的两个装饰器调用目标函数非常类似于下面的代码行。两者是等价的，但是在下面一行中，类似包装器的属性非常清楚:<br/> <code class="fe nb nc nd ne b">logging_decorator_1(logging_decorator_2(multiply(14,3)))</code></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2035" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">4.将参数传递给装饰者</h2><p id="6b62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一部分中，我们将稍微修改一下日志装饰器，以便它可以接收参数。我们希望收到一个指示调试模式是打开还是关闭的参数。如果它打开，我们就打印出测井曲线，否则就不打印。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="0e76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变化在第1行；这里我们允许装饰者接受一个变量。然后在包装器中，我们可以访问这个变量，并决定是否打印出这一行。我们可以在第13行确定调试模式是开还是关。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6205" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">5个有状态的装饰类</h2><p id="2051" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这一部分中，我们将创建一个装饰器来计算目标函数被调用的次数。为了做到这一点，装饰器需要保存一些状态:它必须记住函数被调用的次数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="fbb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你看到的，我们用目标函数初始化了这个类。然后，当目标函数被调用时，我们增加call_count。这是如何使用这个装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="2e1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行此操作将产生以下结果:</p><pre class="kj kk kl km gt nr ne ns nt aw nu bi"><span id="4c31" class="nf md it ne b gy nv nw l nx ny">Called multiply for the 1th time<br/>Called multiply for the 2th time<br/>Called multiply for the 3th time<br/>Called multiply for the 4th time<br/>res: (42, 70, 54, 8)</span></pre><p id="a54f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跟踪一个函数被调用的频率对于限制API调用非常方便</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b3f2" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">6.装饰参数和函数参数之间的交互</h2><p id="27af" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在最后一步中，我们将创建一个装饰器，它可以用密码保护一个函数。在装饰参数中，我们将定义密码。我们将使用通过目标函数提供的密码对此进行检查。类似的装饰器通常用于为API路由提供安全性，例如</p><p id="3720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，下面的例子只是一个例子；这不是一个安全代码的好例子。查看<a class="ae ky" href="https://mikehuls.medium.com/keep-your-code-secure-by-using-environment-variables-and-env-files-4688a70ea286" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>了解更多关于如何在代码中安全存储机密信息的信息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="6aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们在第14行的装饰器中提供了我们的有效密码。然后，在装饰器中，我们从第5行的args或kwargs中获取通过目标函数提供的密码。然后，在第6行，我们检查提供的密码是否正确。执行上面的代码会产生下面的输出:</p><pre class="kj kk kl km gt nr ne ns nt aw nu bi"><span id="28df" class="nf md it ne b gy nv nw l nx ny">You can only see this if you provided the right answer<br/>Incorrect password</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37eb0614d9d269425bfaebf6572a07bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uyOrlSVXCIHPU9gS"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰者允许你创造真正的杰作(图片由<a class="ae ky" href="https://unsplash.com/@igormiske" rel="noopener ugc nofollow" target="_blank">伊戈尔·米斯克</a>在<a class="ae ky" href="https://unsplash.com/photos/oLhTLD-RBsc" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><h1 id="2c73" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">结论</h1><p id="187b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在这篇文章中，我试图解释为什么以及何时需要使用装饰器。然后我们看了6个越来越复杂的例子，我希望用它们来展示装饰者可以带来的灵活性。</p><p id="02a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有建议/澄清，请评论，以便我可以改进这篇文章。同时，看看我的<a class="ae ky" href="https://mikehuls.medium.com/" rel="noopener">关于各种编程相关话题的其他文章</a>，比如:</p><ul class=""><li id="d816" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/why-is-python-so-slow-and-how-to-speed-it-up-485b5a84154e" rel="noopener">Python为什么慢，如何加速</a></li><li id="ddb0" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener">Python中的高级多任务处理:应用线程池和进程池并进行基准测试</a></li><li id="5579" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/write-your-own-c-extension-to-speed-up-python-x100-626bb9d166e7" rel="noopener">编写自己的C扩展来加速Python x100 </a></li><li id="ae28" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">【Cython入门:如何在Python中执行&gt;每秒17亿次计算</li><li id="dc80" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">用FastAPI用5行代码创建一个快速自动归档、可维护且易于使用的Python API</a></li><li id="755c" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc" rel="noopener">创建并发布你自己的Python包</a></li><li id="23ae" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893" rel="noopener">创建您的定制私有Python包，您可以从您的Git库PIP安装该包</a></li><li id="5487" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/virtual-environments-for-absolute-beginners-what-is-it-and-how-to-create-one-examples-a48da8982d4b" rel="noopener">完全初学者的虚拟环境——什么是虚拟环境，如何创建虚拟环境(+示例)</a></li><li id="f910" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><a class="ae ky" href="https://mikehuls.medium.com/dramatically-improve-your-database-inserts-with-a-simple-upgrade-6dfa672f1424" rel="noopener">通过简单的升级大大提高您的数据库插入速度</a></li></ul><p id="5399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="2280" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="6009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？跟我来！</p><div class="os ot gp gr ou ov"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">通过我的推荐链接加入Medium—Mike Huls</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">mikehuls.medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>