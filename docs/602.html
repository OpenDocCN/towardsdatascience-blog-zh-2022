<html>
<head>
<title>Getting Introduced to SML: A Weird Polymorphic Language Originated in 1983</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SML入门:一种起源于1983年的怪异多态语言</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-introduced-to-sml-a-weird-polymorphic-language-originated-in-1983-797ff9d6622e#2022-01-20">https://towardsdatascience.com/getting-introduced-to-sml-a-weird-polymorphic-language-originated-in-1983-797ff9d6622e#2022-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="38f8" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">SML入门:一种起源于1983年的怪异多态语言</h1></div><div class=""><h2 id="5676" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尝试用SML语言编写和编译一些基本代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3819a74b37630bf9512b72936187297e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzaOJVBd-gZCZ94PLyYnVw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="https://pixabay.com/images/id-3914806/" rel="noopener ugc nofollow" target="_blank"> geralt </a>在<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上提供)</p></figure><h1 id="d69a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">前言</h1><p id="816f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我作为一名计算机程序员的经历中，我爱上了计算机编程中的许多概念，这些概念现在已经成为通用编程概念。在我的生命中，有一段时间我爱上了面向对象编程，以及类的子类化，比如C++中的子类化。在河的另一边，我也喜欢许多函数式编程语言，有些语言有独特的类型系统，比如标准的ML，或者我今天第一次尝试的SML编程语言。需要说明的是，我一生中从未写过这种语言，我也不打算继续写下去——尽管，如果它激发了我的兴趣，你永远不会知道像我这样的大脑会发生什么。</p><p id="2005" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无论如何，我有过许多不同编程概念的美好经历，但仍然有一个是我最喜欢的:</p><blockquote class="ms"><p id="7ebf" class="mt mu it bd mv mw mx my mz na nb mm dk translated">多态性。</p></blockquote><p id="8af1" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">多态只是一个书呆子气的词，意思是我们正在基于类型改变事物。在大多数例子中，这是函数调用。更简单地说，我们的方法附加在我们的类型上。我遇到的第一种利用这种编程概念的语言是Julia编程语言。如果你今天看一下我的博客，你可能会发现上面有很多关于朱莉娅的内容，而且很多时候我都在写朱莉娅。虽然Julia不仅仅有多态和多重分派，但这是Julia的一个重要部分，而且该语言的范例围绕着多重分派的使用。如果您想了解更多，我将在下面的文章中详细介绍Julia中多重分派的伟大之处:</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/how-julia-perfected-multiple-dispatch-16675db772c2"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">朱莉娅如何完善多重派遣</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">让我们看看Julia语言是如何让多重调度变得完美的</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div><p id="1a3a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也就是说，我爱上了朱莉娅，因为她身上所有的优点。在许多方面，朱莉娅在精神上有点像曼梯·里的继承者。ML最初是通过多分派概念实现参数多态性的，在认识到它对计算世界的贡献后，我想拜访一下这种我最喜欢的语言的精神继承者。这正是我今天要做的，同时将结果与Julia进行比较，也许是我所经历过的其他种类的语言。最后一件事，我为向自己介绍这种令人敬畏的语言而写的所有代码都可以在我在Github上的Random_Code库中找到，这里有一个链接:</p><div class="nh ni gp gr nj nk"><a href="https://github.com/emmettgb/Random_Code/blob/main/tryingsml/src/trying.sml" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">Random _ Code/trying . SML at main emmett GB/Random _ Code</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny ks nk"/></div></div></a></div></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="188e" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">第一部分:建立SML</h1><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1f95" class="or la it on b gy os ot l ou ov">[emmac@fedora ~]$ sudo dnf install sml<br/>[sudo] password for emmac: <br/>Fedora 34 - x86_64 - Updates                     29 kB/s | 7.9 kB     00:00    <br/>Fedora 34 - x86_64 - Updates                    444 kB/s | 444 kB     00:00    <br/>Fedora Modular 34 - x86_64 - Updates             58 kB/s |  12 kB     00:00    <br/>No match for argument: sml<br/>Error: Unable to find a match: sml</span></pre><blockquote class="ow ox oy"><p id="dfcf" class="lr ls oz lt b lu mn ju lw lx mo jx lz pa mp mc md pb mq mg mh pc mr mk ml mm im bi translated">好吧，看起来不会那么容易。</p></blockquote><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="22b0" class="or la it on b gy os ot l ou ov">[emmac@fedora ~]$ sudo dnf search sml<br/>Last metadata expiration check: 0:01:20 ago on Tue 18 Jan 2022 06:48:04 AM EST.<br/>================================================ Name &amp; Summary Matched: sml =================================================<br/>perl-Net-LDAP-DSML.noarch : DSML Writer for Net::LDAP</span></pre><p id="b224" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">原来这个包实际上叫做smlnj，但是它只在一些不知名的个人包存档中可用，而且鉴于我使用Fedora——这对我来说是不可行的。相反，我找到了<a class="ae ky" href="https://www.smlnj.org/dist/working/110.98.1/install.html" rel="noopener ugc nofollow" target="_blank">这些指令</a>，它们详细描述了如何使用Bash脚本运行某种安装程序</p><blockquote class="ms"><p id="6f96" class="mt mu it bd mv mw mx my mz na nb mm dk translated">手指交叉。</p></blockquote><p id="ed68" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">好了，原来Bash脚本是对一堆make文件的调用，所以显然在Fedora上安装SML的唯一方法是从源代码构建并安装它。我能够做到这一切，现在我面临的唯一问题是，现在它已经安装了，我的路径中没有它，也不知道这个安装中的任何文件到哪里去了。真的，没有任何关于这方面的文档，除了我刚刚提到的那些细节，http://smlnj.org<a class="ae ky" href="http://smlnj.org" rel="noopener ugc nofollow" target="_blank">网站在资源方面完全没有用。</a></p><p id="8927" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，过了一会儿，我回到了我的~/下载目录，在我的下载文件夹里看到了像“bin”这样的目录和类似的东西，我感到非常困惑。我通常不会注意到这一点，但是我按照last modified进行了排序，并且正在寻找上面我最初使用wget下载的tarball。请记住，由于这些文件是在之后修改的，它们一定是在之后被放在那里的。足够充分的是，这并不构成一个“安装”，至少不是在Unix类系统上，这是我们在Unix中使用语言的更典型的方式。考虑到这一点，我将这些目录移到了~/。sml，然后我像这样导出我的SML bin的路径:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="cc40" class="or la it on b gy os ot l ou ov">nano ~/.bashrc</span><span id="8d8a" class="or la it on b gy pd ot l ou ov">export PATH="$PATH:~/.sml/bin"</span></pre><p id="e31e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">获取新信息。bashrc文件，</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="3a82" class="or la it on b gy os ot l ou ov">source ~/.bashrc</span></pre><p id="1d34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我们可以从我们的终端调用sml:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="3ef4" class="or la it on b gy os ot l ou ov">[emmac@fedora config]$ sml<br/>Standard ML of New Jersey (64-bit) v110.98.1 [built: Tue Jan 18 06:53:10 2022]<br/>-</span></pre><blockquote class="ms"><p id="3c67" class="mt mu it bd mv mw pe pf pg ph pi mm dk translated">耶！</p></blockquote><p id="098c" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">此外，对于那些对该软件的许可感到好奇的人:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="d980" class="or la it on b gy os ot l ou ov">================================================================================<br/>The new code is covered under the following license:<br/>====================<br/>STANDARD ML OF NEW JERSEY COPYRIGHT NOTICE, LICENSE AND DISCLAIMER.</span><span id="186c" class="or la it on b gy pd ot l ou ov">Copyright (c) 2016 by The Fellowship of SML/NJ</span><span id="67bb" class="or la it on b gy pd ot l ou ov">Permission is hereby granted, free of charge, to any person<br/>obtaining a copy of this software and associated documentation<br/>files (the "Software"), to deal in the Software without restriction,<br/>including without limitation the rights to use, copy, modify, merge,<br/>publish, distribute, sublicense, and/or sell copies of the Software,<br/>and to permit persons to whom the Software is furnished to do so,<br/>subject to the following conditions:</span></pre></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="a9c7" class="kz la it bd lb lc oh le lf lg oi li lj jz oj ka ll kc ok kd ln kf ol kg lp lq bi translated">第二部分:尝试SML</h1><p id="e968" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然SML语言的安装可能不完全正常，但代码看起来相对容易理解。在实际编写和尝试设计一个包之前，我想在REPL中尝试一些基本操作，</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="eb25" class="or la it on b gy os ot l ou ov">[emmac@fedora src]$ sml<br/>Standard ML of New Jersey (64-bit) v110.98.1 [built: Tue Jan 18 06:53:10 2022]<br/>-</span></pre><p id="83d2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不确定这是否只在类Unix系统上，因为我相信这种语言很可能是为Windows系统设计的，所以也许这就是这个REPL如此糟糕的原因…相反，REPL并不可怕，除非你想说，以任何方式移动光标。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1eab" class="or la it on b gy os ot l ou ov">Standard ML of New Jersey (64-bit) v110.98.1 [built: Tue Jan 18 06:53:10 2022]<br/>- hello^[[D^[[D^[[D^[[D</span></pre><blockquote class="ow ox oy"><p id="8863" class="lr ls oz lt b lu mn ju lw lx mo jx lz pa mp mc md pb mq mg mh pc mr mk ml mm im bi translated">同样是的，我确实在早上6:53构建了这个编译器。</p></blockquote><p id="85da" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也许这是有益的怀疑，但我认为这很可能是REPL的设计与Windows铭记，和一些关于移动光标的系统调用方式是不同的，并没有组装适合我的系统。当然，这只是推测——我也使用过其他有这个问题的REPLs最著名的是我的编程语言的REPL。</p><blockquote class="ms"><p id="ad9a" class="mt mu it bd mv mw mx my mz na nb mm dk translated">罪名成立。</p></blockquote><figure class="pk pl pm pn po kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/4b8a51e9f0f0e42dfe1110caac4bf8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*wD70hTFgIrgfVrhTIYVEYw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="8688" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们试着添加一些数字！</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="7f5b" class="or la it on b gy os ot l ou ov">- val x = 5 + 5;<br/>val x = 10 : int</span></pre><p id="64ad" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好了，现在我有了一个值，只需要弄清楚如何打印它，以及函数调用是如何构造的…耐心等待…</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="7f89" class="or la it on b gy os ot l ou ov">- print(x);<br/>stdIn:2.1-2.9 Error: operator and operand do not agree [tycon mismatch]<br/>  operator domain: string<br/>  operand:         int<br/>  in expression:<br/>    print x</span></pre><blockquote class="ms"><p id="52cb" class="mt mu it bd mv mw pe pf pg ph pi mm dk translated">我的天啊。</p></blockquote><p id="01f7" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我相信这里发生的事情是我向操作员提供了错误的类型。我相信“域”代表了这个方法应该应用于哪种类型。记住这一点，因为现在我只是想做hello world，让我们切换到一个字符串——然后我们可以弄清楚我们到底如何打印一个整数。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="b4cf" class="or la it on b gy os ot l ou ov">- y = "hello"<br/>= ;<br/>Yes, I forgot the semi-colon</span><span id="5ec8" class="or la it on b gy pd ot l ou ov">- print y;<br/>helloval it = () : unit</span></pre><p id="f1c9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里一个有趣的方面是我们使用的语言类型。ML是一种静态类型语言。我也必须承认，我从来没有像这样使用过REPL的静态类型语言，我不这么认为。整个事情感觉非常奇怪，但同时真的很酷，我很高兴能了解更多。顺便说一句，对于那些像我一样有兴趣实际学习这种语言，或窥视其范式思想以获得一些赞赏的人，我会推荐<a class="ae ky" href="https://en.wikipedia.org/wiki/Standard_ML#Type_inference" rel="noopener ugc nofollow" target="_blank">维基百科页面</a>，因为它确实是唯一好的信息来源，因为sml网站似乎是一堆403、404和HTML，没有任何CSS。在看了这些例子之后，我想向你们展示这种语言实际上有多酷。</p><p id="bee6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我真正喜欢这门语言的是，它有一种处理函数和类型的方式，我们可以在Julia的更高层次上看到这种方式。编写这种语言实际上围绕着两个领域。人们可以主要在函数式编程范式中工作，使用声明性方法调用，或者可以使用命令式等效方法工作，后者更多地基于使用结构和事物，而不是纯粹的高级操作符调用。下面是维基百科页面上列出的两者的例子:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="41b1" class="or la it on b gy os ot l ou ov"><strong class="on iu">fun</strong> factorial 0 = 1<br/>  | factorial n = n * factorial (n - 1)</span></pre><p id="7eac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以上是该函数的声明版本。我必须承认，我不确定0在这个上下文中是什么意思，这有点粗略。另一个重要的注意事项，正如我所检查的，在SML语中,|绝对是一个基本操作符，因为它被用来表示这些额外的调用——但是我想在我看这个的同时，我发现了什么</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="cc8e" class="or la it on b gy os ot l ou ov">factorial 0 = 1</span></pre><p id="b884" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">是。</p><p id="7047" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">阶乘0 = 1仅仅意味着如果提供的值是0，那么我们得到1——我想..也许我们应该尝试使用运算符来查看:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="50b5" class="or la it on b gy os ot l ou ov">- val x = factorial 0<br/>= ;<br/>val x = 1 : int</span></pre><p id="28e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我写这个函数的另一个版本，如果它是-1，就返回3，只是为了确保这绝对是这个意思:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="2722" class="or la it on b gy os ot l ou ov">- fun factorial 0 = 1<br/>= | factorial -1 = 3<br/>= | factorial n = n * factorial (n - 1)<br/>= ;<br/>stdIn:23.5-25.38 Error: clauses do not all have same function name</span><span id="a9ea" class="or la it on b gy pd ot l ou ov">stdIn:23.5-25.38 Error: parameter or result constraints of clauses do not agree [overload - bad instantiation]<br/>  this clause:      'Z * 'Y[INT] -&gt; 'X<br/>  previous clauses:      'W[INT] -&gt; 'X<br/>  in declaration:<br/>    factorial =<br/>      (fn 0 =&gt; 1  | (factorial,1) =&gt; 3  | n =&gt; n * factorial (n - 1))</span></pre><p id="3f08" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我将来可能会理解，但现在不会，因为负值-1，我们不再使用与其他类型相同的类型…记住，我将尝试用1来代替…</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="399e" class="or la it on b gy os ot l ou ov">fun factorial 0 = 1<br/>| factorial 1 = 3<br/>| factorial n = n * factorial (n - 1);</span><span id="1363" class="or la it on b gy pd ot l ou ov">val factorial = fn : int -&gt; int<br/></span><span id="283a" class="or la it on b gy pd ot l ou ov">- factorial 1;<br/>val it = 3 : int</span></pre><p id="2c1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这与更迫切的召唤相反，鉴于我迄今为止的新知识，我认为现在对我来说更容易理解。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="732f" class="or la it on b gy os ot l ou ov"><strong class="on iu">fun</strong> factorial n = <strong class="on iu">let</strong> <strong class="on iu">val</strong> i = ref n <strong class="on iu">and</strong> acc = ref 1 <strong class="on iu">in</strong><br/>    <strong class="on iu">while</strong> !i &gt; 0 <strong class="on iu">do</strong> (acc := !acc * !i; i := !i - 1); !acc<br/><strong class="on iu">end</strong></span></pre><p id="8e6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里有一个很酷的小函数，这绝对是一个更好的实现，因为它不使用递归。我们在结尾语法上也达到了一个高峰，这确实让这门语言更接近Julia。看一下这两种语言之间的比较:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="24fe" class="or la it on b gy os ot l ou ov"><strong class="on iu">function</strong> factorial(n) <br/><strong class="on iu">let</strong> <strong class="on iu">val</strong> i = ref n &amp;&amp; acc = ref 1 <strong class="on iu">in</strong><br/>    <strong class="on iu">while</strong> !i &gt; 0 <br/>        (acc := !acc * !i; i := !i - 1) !acc</span><span id="5537" class="or la it on b gy pd ot l ou ov"><strong class="on iu">    end</strong></span><span id="cb91" class="or la it on b gy pd ot l ou ov">!acc<br/><strong class="on iu">end</strong></span></pre><p id="7f42" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">非常相似，Julia甚至看起来更像ML，带有更多的声明性内联函数声明:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="ae49" class="or la it on b gy os ot l ou ov">factorial(n) = let...</span></pre><p id="2a0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我开始用ML做一个小项目之前，我还想了解三件事情:</p><ul class=""><li id="4655" class="pp pq it lt b lu mn lx mo ma pr me ps mi pt mm pu pv pw px bi translated">类型</li><li id="f1b3" class="pp pq it lt b lu py lx pz ma qa me qb mi qc mm pu pv pw px bi translated">索引</li><li id="0f11" class="pp pq it lt b lu py lx pz ma qa me qb mi qc mm pu pv pw px bi translated">环</li></ul><p id="8109" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些都将是我决定创建的包的基本要素，这是一个有趣的包，但同时在一种新的语言中执行将是具有挑战性的。此外，在寻找关于这个概念的信息时，我偶然发现了一个很酷的可以用ML完成的小东西，我想分享一下。这是一个I<a class="ae ky" href="https://www.cs.cornell.edu/courses/cs2112/2021fa/lectures/lecture.html?id=loopinv#:~:text=Loop%20invariants%20and%20tail%2Drecursive%20functions" rel="noopener ugc nofollow" target="_blank">n保持不变的尾递归紧循环</a>的封装，在一个不变的外部函数中有一个或多个累加器参数。这是什么意思？我们把这个被递归调用的函数变成了一个常规的循环。不变量只是“在程序状态下返回真值的东西”的一个花哨的说法这就是为什么我们需要在定义这个函数之前限制它的范围。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="e7b5" class="or la it on b gy os ot l ou ov"><strong class="on iu">local</strong><br/>    <strong class="on iu">fun</strong> loop (0, acc) = acc<br/>      | loop (m, acc) = loop (m - 1, m * acc)<br/><strong class="on iu">in</strong><br/>    <strong class="on iu">fun</strong> factorial n = loop (n, 1)<br/><strong class="on iu">end</strong></span></pre><p id="50ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">显然，虽然尾部递归不是我想在这里学习的，但是我们在这里有一个关于如何使用累加器循环的突出例子。这里最重要的事情是，我们实际上需要从传统的循环语法中构造迭代循环。换句话说，在这种语言中，我们需要编写自己的break。我最初想为我的第一个SML项目做一些疯狂的事情，但是考虑到现在我将不得不编写比最初预期的更多的函数，我可能会做一些更简单的事情。</p><h1 id="4c6f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">第3部分:构建我的第一个ML包</h1><p id="3b0c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我的第一个SML套餐，我决定做一些简单的事情。最大的原因是，使用列表的每个依赖项都需要被编程。我不希望整天坐在这里编写基本列表操作的循环，所以我决定只列出几个要加载的文件，然后我们将在REPL中使用它们。第一个是总结，我们肯定需要。我要用求和来计算一个数组的平均值。这听起来可能很简单，但实际上并不简单，因为我同时通过尝试、错误和研究来学习这种语言的语法——老实说，对我来说，语法的某些部分可能需要花很多时间来适应。也就是说，我用过的最接近的语言是Lisp。然而，这种断言主要是在类型中，这种语言也有多态性扳手扔在，所以它真的仍然是不一样的。考虑到这一点，在花了大约20分钟的时间试图写出一些有用的东西之后，</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="c5ed" class="or la it on b gy os ot l ou ov">fun sum (x::y::xs) = x :: sum (x+y::xs)<br/>  | sum xs = xs</span></pre><blockquote class="ow ox oy"><p id="5e82" class="lr ls oz lt b lu mn ju lw lx mo jx lz pa mp mc md pb mq mg mh pc mr mk ml mm im bi translated">奇怪的旁注:用这种语言和REPL人一起工作会非常令人恼火。在不能移动光标和这些奇怪的事情之间，无效语法只是等待更多的分号，这是一个相当大的斗争。</p></blockquote><p id="aa92" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也没有我需要的标准长度函数。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="48be" class="or la it on b gy os ot l ou ov">fun len(xs) =<br/> case xs of<br/>  [] =&gt; 0<br/>  | (_::xs') =&gt; 1 + len(xs')</span></pre><p id="c005" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这里，我还学习了case语法，这是一种非常命令式的语法，我很高兴在这种语言中看到它。length函数没有问题，但是sum函数最终给我带来了一些问题。主要问题是，每当我对列表求和时，它都是分布在每个值上的累积和。换句话说，累加器将每个循环值加在一起，但只有最后一个索引才是我们想要的实际整数。我尝试编写一个新的函数来返回一个整数——但是使用空列表构造函数，无论何时我们返回一个整数，这个函数都会变得非常混乱。我必须承认，我不知道这到底是为什么，但不管怎样，我写了一个快速的最大值函数，试图减轻这一点，所以我可以解决它，并得到我的平均值。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="9c28" class="or la it on b gy os ot l ou ov">fun maximum(xs)=<br/>   case xs of<br/>   [] =&gt; NONE<br/>   | (head::[]) =&gt; SOME head<br/>   | (head::neck::rest) =&gt; if head &gt; neck<br/>      then maximum (head::rest)<br/>      else maximum (neck::rest)</span></pre><p id="3e46" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在我有了这三个函数，我将继续定义两个新值:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="da74" class="or la it on b gy os ot l ou ov">(*An interesting way to leave comments*)<br/>val x = [4, 7, 12, 18, 22];</span></pre><blockquote class="ow ox oy"><p id="9a9f" class="lr ls oz lt b lu mn ju lw lx mo jx lz pa mp mc md pb mq mg mh pc mr mk ml mm im bi translated">另外，看看SML的评论。</p></blockquote><p id="125a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们试着运行这个应用程序。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="7738" class="or la it on b gy os ot l ou ov">[emmac@fedora src]$ sml trying.sml<br/>Standard ML of New Jersey (64-bit) v110.98.1 [built: Tue Jan 18 06:53:10 2022]<br/>[opening trying.sml]<br/>val len = fn : 'a list -&gt; int<br/>val maximum = fn : int list -&gt; int option<br/>val sum = fn : int list -&gt; int list<br/>val x = [4,7,12,18,22] : int list</span><span id="fd3b" class="or la it on b gy pd ot l ou ov">-</span></pre><p id="00f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">嘿，成功了！我们需要做的最后一件事是将所有这些函数的使用结合到x上。我将在REPL中完成剩余的工作。我已经找到了关于这种语言的更多资源，我想今后我可能会在某个时候再尝试这种语言，也许会在其中开发一些东西，因为迭代的水平在这里实际上是非常棒的。我们实际上可以使用堆栈，从堆栈中弹出和推送数据——尽管我们也不一定要这样做。我认为能够选择你的方法真的很棒；每个特定场景的声明性或命令性。然而，我确实觉得语法有点限制，函数以一种奇怪的方式工作，并以一种奇怪的方式成为参数属性。实际上，这归结为多重分派的实现与Julia的完全不同。例如，abs函数是实类型下的一个调用:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="46c0" class="or la it on b gy os ot l ou ov">Real.abs(-1)<br/>= ;<br/>[autoloading]</span><span id="213e" class="or la it on b gy pd ot l ou ov">unexpected exception (bug?) in SML/NJ: Io [Io: openIn failed on "/home/emmac/Downloads/sml.boot.amd64-unix/smlnj/basis/.cm/amd64-unix/basis.cm", No such file or directory]<br/>  raised at: Basis/Implementation/IO/bin-io-fn.sml:626.25-626.71<br/>             ../cm/util/safeio.sml:30.11<br/>             ../compiler/TopLevel/interact/evalloop.sml:45.54</span></pre><p id="f501" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好吧，也许我在这里的另一个问题是，我没有任何SML基地..？但是我不确定…不管怎样，我真的不在乎，我可以写我自己的绝对函数…</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="b8b3" class="or la it on b gy os ot l ou ov"><strong class="on iu">fun</strong> abs(r: real):real =<br/>  <strong class="on iu">if</strong> r &lt; 0.0 <strong class="on iu">then</strong> ~r <strong class="on iu">else</strong> r</span></pre><p id="807d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们最终用我的小包裹开始这个REPL，并尝试得到平均…</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="594c" class="or la it on b gy os ot l ou ov">[emmac@fedora src]$ sml trying.sml<br/>Standard ML of New Jersey (64-bit) v110.98.1 [built: Tue Jan 18 06:53:10 2022]<br/>[opening trying.sml]<br/>val len = fn : 'a list -&gt; int<br/>val maximum = fn : int list -&gt; int option<br/>val sum = fn : int list -&gt; int list<br/>val x = [4,7,12,18,22] : int list</span></pre><p id="9746" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我要做的第一件事是得到数组的和，</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="fb82" class="or la it on b gy os ot l ou ov">- val cumsum = sum x;<br/>val cumsum = [4,11,23,41,63] : int list</span></pre><p id="ed20" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在要得到实际的总和，我要得到新的累计列表的最大值。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="ae02" class="or la it on b gy os ot l ou ov">- val summation = maximum cumsum;<br/>val summation = SOME 63 : int option</span></pre><p id="ec91" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我会得到x的长度:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="bd73" class="or la it on b gy os ot l ou ov">- val n = len x;<br/>val n = 5 : int</span></pre><p id="3695" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还有…分…</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="297e" class="or la it on b gy os ot l ou ov">- val mu = summation / n<br/>= ;<br/>stdIn:4.5-4.23 Error: operator and operand do not agree [tycon mismatch]<br/>  operator domain: real * real<br/>  operand:         int option * int<br/>  in expression:<br/>    summation / n</span></pre><blockquote class="ms"><p id="26ed" class="mt mu it bd mv mw pe pf pg ph pi mm dk translated">美味的肉汁。</p></blockquote><p id="4bb2" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我相信real可能只是一个整数的抽象，所以我认为我们在这里面临的问题是在我们的最大函数中，因为它返回“int option”，不管那是什么意思。我找到了关于此选项类型的以下信息，以便找出它被退回的原因:</p><div class="nh ni gp gr nj nk"><a href="https://smlfamily.github.io/Basis/option.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">期权结构</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">编辑描述</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">smlfamily.github.io</p></div></div></div></a></div><p id="21ca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在里面，我发现了这个函数:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1ad1" class="or la it on b gy os ot l ou ov"><strong class="on iu">val</strong> <a class="ae ky" href="https://smlfamily.github.io/Basis/option.html#SIG:OPTION.getOpt:VAL" rel="noopener ugc nofollow" target="_blank">getOpt</a> <strong class="on iu">:</strong> <em class="oz">'a</em> option <strong class="on iu">*</strong> <em class="oz">'a</em> <strong class="on iu">-&gt;</strong> <em class="oz">'a</em></span></pre><p id="6a70" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想那可能会有用。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="99a2" class="or la it on b gy os ot l ou ov">- val realsum = getOpt summation;<br/>stdIn:1.6-7.19 Error: operator and operand do not agree [tycon mismatch]<br/>  operator domain: 'Z option * 'Z<br/>  operand:         int option<br/>  in expression:<br/>    getOpt summation</span></pre><blockquote class="ms"><p id="6a5e" class="mt mu it bd mv mw pe pf pg ph pi mm dk translated">号码</p></blockquote><p id="033b" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">你知道，我甚至没有真正读过那个函数的描述符…读完之后，我意识到我们真正需要的是valOf函数:</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="2399" class="or la it on b gy os ot l ou ov">- val realsum = valOf summation;<br/>val realsum = 63 : int</span></pre><blockquote class="ms"><p id="76d2" class="mt mu it bd mv mw pe pf pg ph pi mm dk translated">耶！</p></blockquote><pre class="pk pl pm pn po om on oo op aw oq bi"><span id="815e" class="or la it on b gy os ot l ou ov">- val mu = realsum / n;<br/>stdIn:8.5-8.21 Error: operator and operand do not agree [tycon mismatch]<br/>  operator domain: real * real<br/>  operand:         int * int<br/>  in expression:<br/>    realsum / n</span></pre><blockquote class="ms"><p id="7956" class="mt mu it bd mv mw pe pf pg ph pi mm dk translated">什么？！</p></blockquote><p id="fee0" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">好吧，那就更奇怪了。我期望能够分割整数(多么罪恶！)但很明显，这不是SML的做事方式…</p><p id="a9fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">事实证明，所有这些都很简单，但也很复杂。运算符/不是SML的除法运算符。除法运算符是div。还有，我还是不知道/本身是干什么用的。这里有一个我找到的数学运算符表的链接，它不在上面。</p><div class="nh ni gp gr nj nk"><a href="http://rigaux.org/language-study/syntax-across-languages/Mthmt.html" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">每个类别跨语言的语法</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Awk，B，BourneShell，C，C#，C++，CoffeeScript，E，Eiffel，F#，Forth，Go，Haskell，Io，Java，JavaScript，Logo，Maple…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">rigaux.org</p></div></div></div></a></div><p id="97b6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">虽然/肯定做了一些事情，有两个实际值，我现在的任务只是这个意思——当我不写文章时，有一个完整的兔子洞可以钻进去。考虑到这一点，我们只需要稍微修改一下代码。</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="1f0c" class="or la it on b gy os ot l ou ov">- val mu = realsum div n;<br/>val mu = 12 : int</span></pre><h1 id="a48f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结束语</h1><p id="f9f9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">所以这些第一步可能有些基础，但与我使用过的其他语言相比，这种语言肯定有很大的不同。这是20世纪60年代和80年代之间开发的语言的伟大之处——我们通常在计算领域期望的许多标准完全空缺。我个人持保留意见，认为这是一件很棒的事情，因为我们可以学到更多关于语言、语言结构和范式的知识。</p><p id="ec46" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这个特定的应用程序中，我在一些函数式编程语言(比如Lisp)方面的经验很有帮助。尽管这种语言和Lisp一点也不像。不管怎样，不管出于什么原因，它真的让我回到了那种语言。这种语言真的是独一无二的，我认为任何人开始接触这种语言都会有一些困难。如果你是一名SML程序员，我很抱歉还不知道如何写这种语言。也就是说，我绝对认为这种对概念和编程语言的探索是一个好主意。此外，C++编程语言的创始人Bjourne Stroustup也是如此，他引用了下面这段话:</p><blockquote class="ow ox oy"><p id="11fe" class="lr ls oz lt b lu mn ju lw lx mo jx lz pa mp mc md pb mq mg mh pc mr mk ml mm im bi translated">自然，每个专业程序员都应该知道几种语言，并且应该意识到不同语言之间的编程和设计技术有很大的不同。stroustrup.com，比约恩·斯特劳斯特鲁普</p></blockquote><div class="nh ni gp gr nj nk"><a href="https://www.stroustrup.com/devXinterview.html#:~:text=Naturally%2C%20every%20professional%20programmer%20should%20know%20several%20languages%2C%20and%20should%20be%20aware%20that%20programming%20and%20design%20techniques%20differ%20significantly%20between%20languages" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">比雅尼·斯特劳斯特鲁普访谈录</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">比雅尼·斯特劳斯特鲁普是C++的设计者和最初的实现者，也是C++编程语言和</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">www.stroustrup.com</p></div></div></div></a></div><p id="b6bc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">走出你的舒适区，体验代码中不同的语法和范例，这当然是一个好主意——因为我认为这可以让你成为一名更好的程序员，无论是在一般情况下，还是回家后使用你通常使用的语言。非常感谢你阅读我的SML之旅。虽然有一些小问题，和一些奇怪的/学习的经历，但是看着这种建立了现代形式的多重调度的语言是很有趣的。我会说，我肯定认为朱莉娅做得更好，当然，但这总是主观的——当然，朱莉娅只是在某些方面做得更好，而不是其他方面。所有这些设计都有优点和缺点，我认为是应用程序真正让两种语言之间的选择有效。话虽如此，我真的不知道SML技能可能有多大用处，或者它们可能有多受欢迎，但我的猜测是，它可能不是最好的学习语言之一，除非你和我出于同样的目的学习它；教育。我确信这种语言是古老的、经过测试的，并且肯定可以在许多环境中使用，我只是不太确定是否有更好的选择。祝你有美好的一天，保持好奇，快乐编程！</p></div></div>    
</body>
</html>