<html>
<head>
<title>Snorkel — A Human-In-The-Loop Platform to Build Training Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通气管——构建训练数据的人在回路平台</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/snorkel-programmatically-build-training-data-in-python-712fc39649fe#2022-01-29">https://towardsdatascience.com/snorkel-programmatically-build-training-data-in-python-712fc39649fe#2022-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="7c51" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">通气管——构建训练数据的人在回路平台</h1></div><div class=""><h2 id="b0a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">停止手工标记您的数据。而是以编程方式对其进行标记</h2></div><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div></figure><h1 id="dd6f" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">动机</h1><p id="99e9" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">想象一下，你试图判断一份招聘启事是不是假的。你想出了一些关于虚假招聘的假设，比如:</p><ul class=""><li id="050f" class="md me it lj b lk mf ln mg lq mh lu mi ly mj mc mk ml mm mn bi translated">几乎没有描述要求的招聘信息很可能是假的。</li><li id="418f" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated">没有公司简介或标识的招聘信息很可能是假的。</li><li id="8fa4" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated">一份需要一些教育或经验的工作很可能是真实的。</li></ul><p id="c4f0" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">如何测试这些特征在预测欺诈方面的准确性？如何将不同要素的冲突预测合并到一个标注中？</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/1431a9441ad4b4007fe4322310be07c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h97dB_BDRVGzp7r91uLVmw.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><p id="eb35" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">这时候浮潜就派上用场了。</p><h1 id="6d2a" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">什么是浮潜？</h1><p id="d67c" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><a class="ae nh" href="https://www.snorkel.org/" rel="noopener ugc nofollow" target="_blank">snuck</a>是一个开源的Python库，用于以编程方式构建训练数据集，无需手动标记。有了通气管，用户可以在几小时或几天内创建一个训练数据集，而不是在几周或几个月内手动标记它们。</p><p id="769d" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">通气管支持不同的操作，但本文将只回顾标记操作。</p><p id="ba2e" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">要安装通气管，请键入:</p><pre class="ki kj kk kl gt ni nj nk nl aw nm bi"><span id="0452" class="nn kq it nj b gy no np l nq nr">pip install snorkel</span></pre><h1 id="d4be" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">加载数据</h1><p id="5d04" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们将在Kaggle的数据集<a class="ae nh" href="https://www.kaggle.com/shivamb/real-or-fake-fake-jobposting-prediction" rel="noopener ugc nofollow" target="_blank">真实/虚假职位发布预测</a>上使用浮潜来预测职位发布是虚假还是真实。I <a class="ae nh" href="https://github.com/khuyentran1401/Data-science/blob/master/feature_engineering/snorkel_example/processing.ipynb" rel="noopener ugc nofollow" target="_blank">对数据</a>进行预处理，并将其分成训练集和测试集。</p><p id="8d14" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">让我们看看训练数据集是什么样的:</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="af37" class="nv kq it nj b be nw nx l ny nr">import pandas as pd<br/><br/>train_df = pd.read_pickle("https://github.com/khuyentran1401/Data-science/blob/master/feature_engineering/snorkel_example/train_fake_jobs.pkl?raw=true")<br/>test_df = pd.read_pickle("https://github.com/khuyentran1401/Data-science/blob/master/feature_engineering/snorkel_example/test_fake_jobs.pkl?raw=true")<br/><br/>train_df</span></pre><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nz ko l"/></div></figure><p id="f519" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated"><code class="fe oa ob oc nj b">fraudulent</code>栏表示招聘信息是否是假的。</p><p id="12b8" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">现在我们有了数据，我们如何给每个招聘信息贴标签呢？</p><h1 id="1401" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">创建标签功能</h1><p id="9e1e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们根据对假公司的假设创建标签函数:</p><ul class=""><li id="9527" class="md me it lj b lk mf ln mg lq mh lu mi ly mj mc mk ml mm mn bi translated">假公司没有公司简介或标识</li><li id="1716" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated">真正的公司需要背景调查</li><li id="cc1b" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated">真正的公司需要一定的经验或教育水平</li></ul><p id="c591" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">让我们使用scupco的<code class="fe oa ob oc nj b">labeling_function</code>装饰器来测试这些假设。<code class="fe oa ob oc nj b">labeling_function</code>装饰器允许我们使用函数快速标记数据集中的实例。</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="1884" class="nv kq it nj b be nw nx l ny nr">from snorkel.labeling import labeling_function<br/><br/># Give a meaningful name to each value<br/>FAKE = 1<br/>REAL = 0<br/>ABSTAIN = -1<br/><br/># Create labeling functions<br/><br/>@labeling_function()<br/>def no_company_profile(x: pd.Series):<br/>    return FAKE if x.company_profile == "" else ABSTAIN<br/><br/><br/>@labeling_function()<br/>def no_company_logo(x: pd.Series):<br/>    return FAKE if x.has_company_logo == 0 else ABSTAIN<br/><br/><br/>@labeling_function()<br/>def has_background_check(x: pd.Series):<br/>    return REAL if "background check" in x.requirements else ABSTAIN<br/><br/><br/>@labeling_function()<br/>def required_experience(x: pd.Series):<br/>    return REAL if x.required_experience else ABSTAIN<br/><br/><br/>@labeling_function()<br/>def required_education(x: pd.Series):<br/>    return REAL if x.required_education else ABSTAIN</span></pre><p id="139f" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">关于上述标签功能的详细信息:</p><ul class=""><li id="0ac0" class="md me it lj b lk mf ln mg lq mh lu mi ly mj mc mk ml mm mn bi translated">每个函数都试图根据一些条件来确定样本是否是假的。</li><li id="2c1d" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><code class="fe oa ob oc nj b">ABSTAIN</code>或<code class="fe oa ob oc nj b">-1</code>表示预测是不确定的。</li></ul><h1 id="6097" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">对数据应用标注函数</h1><p id="fdcc" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们使用这些标注函数来标注我们的训练数据集:</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="a7aa" class="nv kq it nj b be nw nx l ny nr">lfs = [<br/>    no_company_profile,<br/>    no_company_logo,<br/>    has_background_check,<br/>    required_experience,<br/>    required_education,<br/>]<br/><br/>applier = PandasLFApplier(lfs=lfs)<br/>L_train = applier.apply(df=train_df)</span></pre><p id="ba3f" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">查看训练数据集:</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="939d" class="nv kq it nj b be nw nx l ny nr"># Get the shape<br/>&gt;&gt;&gt; L_train.shape <br/>(13410, 5)<br/><br/># View the first two samples<br/>&gt;&gt;&gt; L_train[0:2]<br/>array([[-1, -1, -1,  0,  0],<br/>       [-1, -1, -1, -1, -1]]) </span></pre><p id="91af" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated"><code class="fe oa ob oc nj b">L_train</code>的第一维是样本数。<code class="fe oa ob oc nj b">L_train</code>的第二维度是来自五个标记函数的预测。</p><h1 id="c30c" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">使用真实标签评估标签功能</h1><p id="a81b" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">既然我们已经使用每个标注函数创建了标签，那么我们如何确定这些标签的准确性呢？有了<code class="fe oa ob oc nj b">LFAnalysis</code>，这可以很快完成。</p><p id="8f69" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">让我们将预测与实际标签进行比较，以评估每个标签功能:</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="8673" class="nv kq it nj b be nw nx l ny nr">from snorkel.labeling import LFAnalysis<br/><br/>LFAnalysis(L=L_train, lfs=lfs).lf_summary(Y=train_df.fraudulent.values)</span></pre><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi od"><img src="../Images/2697a2497fc6282a1d222109498d8241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AJ--82hUHeI67QeqzS1u4A.png"/></div></div></figure><p id="6366" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">上表中的详细统计数据:</p><ul class=""><li id="bb0d" class="md me it lj b lk mf ln mg lq mh lu mi ly mj mc mk ml mm mn bi translated"><strong class="lj iu">极性</strong>:该LF输出的唯一标签集合(不包括弃权)</li><li id="534b" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><strong class="lj iu">覆盖率</strong>:数据集被标记的部分</li><li id="bc24" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><strong class="lj iu">重叠</strong>:这个LF和至少一个其他LF一致的数据集部分</li><li id="3f6e" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><strong class="lj iu">冲突</strong>:该LF与至少一个其他LF不一致的数据集部分</li><li id="2683" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><strong class="lj iu">修正</strong>:该LF标注的数据点数正确</li><li id="d3a8" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><strong class="lj iu">不正确</strong>:该LF标注的数据点数不正确</li><li id="e9c2" class="md me it lj b lk mo ln mp lq mq lu mr ly ms mc mk ml mm mn bi translated"><strong class="lj iu">经验精度</strong>:该LF的经验精度，通过以下公式计算:</li></ul><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi oe"><img src="../Images/d262125948c99ed34559bf39cd06c5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*GGZU6S5wcFfx2vFln-hUxg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><p id="38bf" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">从表中可以看出<code class="fe oa ob oc nj b">has_background_check</code>、<code class="fe oa ob oc nj b">required_experience</code>、<code class="fe oa ob oc nj b">required_education</code>标注函数的精度都在0.95以上。</p><p id="9075" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">如果不进行测试，我们就无法猜测这些特征是虚假招聘的有力证据。</p><h1 id="d008" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">评估没有真实标签的标签功能</h1><p id="c6cf" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在评估没有真正标签的标签功能时，通气管也是理想的选择。</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="d4f5" class="nv kq it nj b be nw nx l ny nr">LFAnalysis(L=L_train, lfs=lfs).lf_summary()</span></pre><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi of"><img src="../Images/4526c0d359341aca1069b975ac818a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhtImRmxarRJN_NhUR-eSQ.png"/></div></div></figure><h2 id="d075" class="nn kq it bd kr og oh dn kv oi oj dp kz lq ok ol lb lu om on ld ly oo op lf oq bi translated">评估冲突</h2><p id="0601" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们可以看到标签功能之间存在一些冲突。这可能意味着一个标注函数预测一个职位发布是假的，而另一个标注函数预测一个职位发布是真的。</p><p id="ffaf" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">可能会有一些招聘广告要求特定的经验，但没有公司的标志。让我们用<code class="fe oa ob oc nj b">get_label_buckets</code>找到这些招聘信息。</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="31c3" class="nv kq it nj b be nw nx l ny nr">from snorkel.analysis import get_label_buckets<br/><br/>buckets = get_label_buckets(L_train[:, 1], L_train[:, 3])<br/><br/>train_df.iloc[buckets[(FAKE, REAL)]].sample(10, random_state=1)[<br/>    ["has_company_logo", "required_experience", "fraudulent"]<br/>]</span></pre><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="nz ko l"/></div></figure><p id="0e3b" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">上表可以看出，很多公司要求具体经验，但是没有公司logo。这导致了两个标记函数之间的预测差异。</p><h1 id="c807" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">组合预测</h1><p id="3703" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本节中，您将学习两种在不同标注函数的预测不一致时组合它们的方法。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi or"><img src="../Images/88edd0e68edb7706d9b0e69a6ea5f354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4WgnT76D5LxXMfqtneya9A.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><h2 id="6306" class="nn kq it bd kr og oh dn kv oi oj dp kz lq ok ol lb lu om on ld ly oo op lf oq bi translated">多数标签投票人</h2><p id="8c6f" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">一个简单的方法是使用多数票。如果有两个<code class="fe oa ob oc nj b">1s</code>和一个<code class="fe oa ob oc nj b">0</code>，那么预测将是<code class="fe oa ob oc nj b">1</code>。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi os"><img src="../Images/b0edda47f2126a11c80b9e189a628ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSYzFmny51LV5Ylk19o-Zg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><p id="f8ae" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">如果没有连接，忽略<code class="fe oa ob oc nj b">-1</code>(无标签)。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ot"><img src="../Images/24c87c8a0da32b283cef7a2ca65227ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbF1XB05rEDKc09zWu-zJg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><p id="a97d" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">如果有平局，则返回<code class="fe oa ob oc nj b">-1</code>。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ou"><img src="../Images/a861fd6896e79d99234f922fb8816eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asLqrjNefDdnr-7-jOpatg.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><p id="3ad4" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">让我们尝试一下这个标签模型，看看它在测试集上的表现如何:</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="f788" class="nv kq it nj b be nw nx l ny nr">from snorkel.labeling.model import MajorityLabelVoter<br/><br/># Create the model<br/>majority_model = MajorityLabelVoter()<br/>preds_train = majority_model.predict(L=L_train)<br/><br/># Get test predictions<br/>L_test = applier.apply(df=test_df)<br/><br/># Get train and test labels<br/>Y_train = train_df["fraudulent"]<br/>Y_test = test_df["fraudulent"]<br/><br/># Evaluate<br/>majority_acc = majority_model.score(L=L_test, Y=Y_test)[<br/>    "accuracy"<br/>]<br/>print(f"{'Majority Vote Accuracy:':&lt;25} {majority_acc * 100:.1f}%")</span></pre><pre class="ov ni nj nk nl aw nm bi"><span id="da05" class="nn kq it nj b gy no np l nq nr">Majority Vote Accuracy:   80.7%</span></pre><p id="3cdc" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">成绩还算不错！</p><h2 id="866e" class="nn kq it bd kr og oh dn kv oi oj dp kz lq ok ol lb lu om on ld ly oo op lf oq bi translated">标签模型</h2><p id="97a7" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">注意，<code class="fe oa ob oc nj b">MajorityLabelVoter</code>没有考虑不同标记函数的变化统计以及这些函数之间的相关性。如果两个特征高度相关，特定信号将在基于多数投票的模型中被过度表示。</p><p id="97f0" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated"><code class="fe oa ob oc nj b">LabelModel</code>通过产生噪声感知训练标签来更恰当地处理这些问题。你可以在本文中了解更多关于<code class="fe oa ob oc nj b">LabelModel</code>的信息。</p><pre class="ki kj kk kl gt ni nj ns bn nt nu bi"><span id="8412" class="nv kq it nj b be nw nx l ny nr">from snorkel.labeling.model import LabelModel<br/><br/>label_model = LabelModel(cardinality=2, verbose=True)<br/>label_model.fit(L_train=L_train, n_epochs=500, log_freq=100, seed=1)<br/><br/># Evaluate the model<br/>label_model_acc = label_model.score(L=L_test, Y=Y_test)["accuracy"]<br/>print(f"{'Label Model Accuracy:':&lt;25} {label_model_acc * 100:.1f}%")</span></pre><pre class="ov ni nj nk nl aw nm bi"><span id="7e6f" class="nn kq it nj b gy no np l nq nr">Label Model Accuracy:     72%</span></pre><p id="d8e6" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated"><code class="fe oa ob oc nj b">LabelModel</code>的精确度不如<code class="fe oa ob oc nj b">MajorityLabelVoter</code>的精确度。然而，在不同的数据集或不同的标记函数集中，<code class="fe oa ob oc nj b">LabelModel</code>可能比<code class="fe oa ob oc nj b">MajorityLabelVoter</code>执行得更好。</p><h1 id="36a0" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">结论</h1><p id="c23e" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">恭喜你！您刚刚学会了使用不同的标注函数进行快速测试，并使用通气管为您的训练数据集创建标注。我希望这篇文章能激励你自动化你的标注过程，而不是花费数周或数月来手工标注你的数据。</p><p id="1291" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">随意发挥，并在这里叉这篇文章的源代码:</p><div class="ow ox gp gr oy oz"><a href="https://github.com/khuyentran1401/Data-science/tree/master/feature_engineering/snorkel_example" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">数据科学/特征_工程/通气管_硕士实例khuyentran 1401/数据科学</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">有用的数据科学主题以及代码和文章的集合…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn nb oz"/></div></div></a></div></div><div class="ab cl po pp hx pq" role="separator"><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt pu"/><span class="pr bw bk ps pt"/></div><div class="im in io ip iq"><p id="f225" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">我喜欢写一些基本的数据科学概念，并尝试不同的算法和数据科学工具。你可以在LinkedIn和Twitter上与我联系。</p><p id="fee8" class="pw-post-body-paragraph lh li it lj b lk mf ju lm ln mg jx lp lq mt ls lt lu mu lw lx ly mv ma mb mc im bi translated">如果你想查看我写的所有文章的代码，请点击这里。在Medium上关注我，了解我的最新数据科学文章，例如:</p><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/similarity-encoding-for-dirty-categories-using-dirty-cat-d9f0b581a552"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">使用dirty_cat对脏类别进行相似性编码</h2><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="pv l pk pl pm pi pn nb oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/kats-a-generalizable-framework-to-analyze-time-series-data-in-python-3c8d21efe057"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">kats:Python中分析时间序列数据的通用框架</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">预测、检测变化点、异常，并获得时间序列中的关键统计数据</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="pw l pk pl pm pi pn nb oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/supercharge-your-python-string-with-textblob-2d9c08a8da05"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">使用TextBlob增强您的Python字符串</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">在一行代码中获得更多关于文本的见解！</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="px l pk pl pm pi pn nb oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a rel="noopener follow" target="_blank" href="/sentiment-analysis-of-linkedin-messages-3bb152307f84"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">使用Python和情感分析探索和可视化您的LinkedIn网络</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">希望优化您的LinkedIn个人资料？为什么不让数据为你服务呢？</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="pi l"><div class="py l pk pl pm pi pn nb oz"/></div></div></a></div><h1 id="4d52" class="kp kq it bd kr ks kt ku kv kw kx ky kz jz la ka lb kc lc kd ld kf le kg lf lg bi translated">参考</h1><p id="e512" class="pw-post-body-paragraph lh li it lj b lk ll ju lm ln lo jx lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Shivam Bansal 。2020–02–29.真/假职位发布预测。<br/> CC0:公共领域。从<a class="ae nh" href="https://www.kaggle.com/shivamb/real-or-fake-fake-jobposting-prediction" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/shivamb/true-or-fake-fake-job posting-prediction</a>检索2022–01–25。</p></div></div>    
</body>
</html>