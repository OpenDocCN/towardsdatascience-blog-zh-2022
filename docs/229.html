<html>
<head>
<title>Introduction to Data Version Control</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据版本控制简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-data-version-control-5c4a83276b9#2022-01-08">https://towardsdatascience.com/introduction-to-data-version-control-5c4a83276b9#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="cc8b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON |数据|编程</h2><div class=""><h1 id="da4a" class="pw-post-title jb jc it bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">数据版本控制简介</h1></div><div class=""><h2 id="206e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Hangar在Python中实现自己的DVC的分步指南</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ba48ffac120391301c3b1f87585922ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J0mzuX7I_hyLH9kh"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">雅罗斯拉夫·穆齐琴科在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="9bd1" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">什么是数据版本控制(DVC)？</h1><p id="233d" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">任何生产级系统都需要某种版本控制。当前真相的唯一来源。任何持续更新的资源，尤其是由多个用户同时更新的资源，都需要某种审计线索来跟踪所有的更改。</p><p id="0451" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在软件工程中，对此的解决方案是<a class="ae lh" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>。如果你在生活中写过代码，那么你可能对Git的美妙之处很熟悉。Git允许我们提交变更，从一个源创建不同的分支，并将我们的分支合并回原始分支，等等。</p><p id="23e1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">除了数据集，DVC完全是同样的范例。看，当不同的用户在相同的数据集上进行不同的实验时，实时数据系统不断地接收更新的数据点。这就导致了同一个数据集的多个版本，绝对不是单一的真实来源。</p><p id="3b1e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">此外，在机器学习环境中，我们还会在同一数据集的不同版本上训练同一“模型”的多个版本(例如，模型重新训练以包括较新的数据点)。如果没有适当的审核和版本控制，这将会创建一个数据集和实验的复杂网络。我们绝对不希望这样！</p><p id="6bcc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，DVC是一个通过记录特定数据集的变化来跟踪数据集的系统。有多种免费和付费的DVC解决方案。我最近发现了<a class="ae lh" href="https://github.com/tensorwerk/hangar-py" rel="noopener ugc nofollow" target="_blank">机库</a>，一个完全开源的Python DVC包。让我们看看它能做什么，好吗？</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="161e" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">使用机库</h1><p id="0de1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">hangar包是一个纯Python实现，可以通过pip获得。它的核心功能也与git紧密相关，这对学习曲线有很大帮助。我们也可以选择通过命令行或使用其专用的Python客户端与hangar交互。</p><p id="87f3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">一些可用的功能包括:</p><ul class=""><li id="61d6" class="nn no it mc b md mw mg mx mj np mn nq mr nr mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">检出</em> </strong> <em class="nw"> —切换到新的分支或参考点</em></li><li id="1f83" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">提交</em> </strong> <em class="nw"> —将当前变更添加到当前分支</em></li><li id="a77d" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">分支</em> </strong> <em class="nw"> —创建一个指向特定提交的引用点</em></li><li id="dac8" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">合并</em></strong><em class="nw">——合并一个分支到另一个分支的变更</em></li><li id="23d5" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw"> diff </em> </strong> <em class="nw"> —比较两个分支之间的变化</em></li><li id="7ad6" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">推送</em> </strong> <em class="nw"> —上传本地版本到远程仓库</em></li><li id="cd60" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">拉/取</em> </strong> <em class="nw"> —从远程存储库更新数据集的本地版本</em></li><li id="1c51" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated"><strong class="mc jd"> <em class="nw">日志</em> </strong> <em class="nw"> —显示提交历史</em></li></ul><blockquote class="oc od oe"><p id="ae7f" class="ma mb nw mc b md mw kd mf mg mx kg mi of my ml mm og mz mp mq oh na mt mu mv im bi translated">注意:远程存储库是当前事实的唯一来源。</p></blockquote><p id="31c3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里要注意的积极的一点是，Hangar不是构建在git之上的，而是模拟了git的功能。这使得它更快。</p><p id="4984" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们可以使用以下方式通过pip安装hangar:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="3b94" class="on lj it oj b gy oo op l oq or">pip install hangar</span></pre><p id="44a7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">安装好Hangar之后，我们就可以直接把包导入Python了。</p><p id="8269" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们需要做的第一件事就是创建一个数据仓库。我们可以从Hangar包中导入Repository类，并用它来定义我们的存储库。</p><p id="3019" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果这是我们第一次使用一个特定的存储库，我们还必须使用<code class="fe os ot ou oj b">init()</code>函数初始化它。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="065f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在我们继续我们的数据版本化例子之前，让我们首先讨论Hangar背后的方法论。</p><h1 id="9ff4" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">接近机库</h1><p id="3458" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Hangar背后的主要学习曲线是理解与软件包交互的最佳方式。机库包括四个主要部分:</p><h2 id="ffbe" class="on lj it bd lk ox oy dn lo oz pa dp ls mj pb pc lu mn pd pe lw mr pf pg ly iz bi translated">仓库</h2><p id="8f52" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们可以将存储库视为我们的项目仓库。存储库本质上是所执行的提交的集合和历史。</p><p id="e4c8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">理想情况下，每个项目都有自己的存储库。例如，如果我们有两个主要任务—预测手写数字和预测欺诈—我们也分别创建两个存储库。</p><h2 id="37fb" class="on lj it bd lk ox oy dn lo oz pa dp ls mj pb pc lu mn pd pe lw mr pf pg ly iz bi translated">数据集</h2><p id="27cf" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这个很简单。数据集就是，你猜对了，我们的数据集。但是数据集到底是什么呢？我们拿泰坦尼克号数据集来类比一下。数据集由什么组成？</p><p id="8308" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">是个别样品吗？是被监控的变量吗？这就是我们可以发挥创造力的地方。Hangar将数据集描述为列的集合。我们接下来会讨论这个问题。</p><h2 id="c8fb" class="on lj it bd lk ox oy dn lo oz pa dp ls mj pb pc lu mn pd pe lw mr pf pg ly iz bi translated">专栏</h2><p id="4b3d" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">该列可以是我们喜欢的任何数据属性或特性。它可以是要素数组、标签数组、要素名称数组，甚至是唯一标识符数组。但是，列数组中的每一项都应该对应于数据集中的一个样本。目前，支持的列类型有:</p><ul class=""><li id="56c6" class="nn no it mc b md mw mg mx mj np mn nq mr nr mv ns nt nu nv bi translated">添加字节列—字节</li><li id="6cbd" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated">add_ndarray_column —数组</li><li id="6d4b" class="nn no it mc b md nx mg ny mj nz mn oa mr ob mv ns nt nu nv bi translated">add_str_column —字符串</li></ul><p id="3a6a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">例如，如果我们有一个28x28图像的数据集，我们将选择一个数组列(每个样本的形状都是28x28)来表示实际的数字数据。我们可以用字节或字符串列来存储它的标签，用字符串列来存储图像文件名。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/f6c1ef68525251d176bee8c4665ea039.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*DUJ1-a0BXeM0zgPK-HIKog.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="4a14" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当然，以上只是如何构建数据集的指南。你正在处理的数据类型，以及要做的实验类型，都会影响到机库的构建策略。例如，也可以选择一个专用的列用于训练数据，另一个用于验证数据。</p><p id="97a7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">列应该是数据样本的集合。我们从一个空集合开始，随着样本的增加，集合索引增加。</p><h2 id="cbd5" class="on lj it bd lk ox oy dn lo oz pa dp ls mj pb pc lu mn pd pe lw mr pf pg ly iz bi translated">数据</h2><p id="7e55" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">最后是数据。一旦我们确定了哪些列，相应地处理数据就变成了一个相对简单的任务。数据本身只是数字。它没有任何直接意义，也没有任何结构。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="adaa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这样一来，让我们继续我们例子的其余部分。</p><p id="b841" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">假设我们有一个表格分类数据集— <code class="fe os ot ou oj b">df</code> —我们将简单地将整个数据集以字节的形式存储在一列中。</p><p id="d104" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们首先创建一个WriterCheckout。WriterCheckout对象允许我们启用一个特定的分支(在我们的例子中，我们只有一个分支:主分支)的写访问权限(也就是说，能够向活动分支写入和提交更改)。我们使用<code class="fe os ot ou oj b">master = repo.checkout(write=True)</code>来实现这一点。</p><p id="8565" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然后，我们可以通过调用<code class="fe os ot ou oj b">add_bytes_column</code>命令Hangar创建一个名为“<em class="nw">数据</em>的字节列。因为这是我们第一次提交，所以我们的列仍然是空的。对于第一次提交，我们可以在索引0处提交数据。因为我们将列指定为bytes对象，所以我们必须首先将数据转换为bytes对象。我们最终可以调用<code class="fe os ot ou oj b">commit</code>函数来提交并保存我们的更改。下面，我们展示一个我们刚刚讨论过的代码示例。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ov ow l"/></div></figure><blockquote class="oc od oe"><p id="0613" class="ma mb nw mc b md mw kd mf mg mx kg mi of my ml mm og mz mp mq oh na mt mu mv im bi translated">注意:为了避免冲突，Hangar不允许一个以上的WriterCheckouts循环使用。因此，当不使用WriterCheckout时，一定要关闭它。如果一个写锁已经在循环中，我们只能以只读模式签出。</p></blockquote><p id="f828" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果我们想在同一个列中添加另一个提交，我们遵循相同的过程，但是改为提交到<code class="fe os ot ou oj b">master['data'][1]</code>，对于将来的提交以此类推。每个提交还将绑定一个散列键。</p><h2 id="7559" class="on lj it bd lk ox oy dn lo oz pa dp ls mj pb pc lu mn pd pe lw mr pf pg ly iz bi translated">机库中的分支</h2><p id="a48c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">当我们想要在特定点获得数据的副本以在其上运行定制实验而不实际改变它时，分支变得特别有用。我们可以分支，在我们确认我们的处理是正确的之后，我们也有能力合并回主流。典型的分支流程如下所示:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="1085" class="on lj it oj b gy oo op l oq or">Create Branch -&gt; Checkout Branch -&gt; Make Changes -&gt; Commit -&gt; Merge</span></pre><p id="5f3e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们可以使用<code class="fe os ot ou oj b">repo.create_branch(name='test')</code>创建分支，合并如下:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="e679" class="on lj it oj b gy oo op l oq or">master.merge(message='message for merge', dev_branch='test')</span></pre><p id="96cc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Hangar中的每个提交都有一个哈希键。我们可以使用该散列来精确定位分支点:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="b520" class="on lj it oj b gy oo op l oq or">test_branch2 = repo.create_branch(name='test2', base_commit=&lt;SOME_HASH_KEY&gt;)</span></pre><p id="ab29" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">通过调用<code class="fe os ot ou oj b">repo.log()</code>，我们可以获得当前分支及其最新提交的日志摘要。日志示例如下所示:</p><pre class="ks kt ku kv gt oi oj ok ol aw om bi"><span id="5394" class="on lj it oj b gy oo op l oq or">* a=cf94cf8b4c5758c885c6b84d58c4fbe22f379510 (test2): added new test branch<br/>* a=a8fe61916764b873f13c80a14ce4fda610b74df9 (test) (master): Base Dataset</span></pre><p id="d972" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们可以得到分支之间的差异和冲突如下:</p><p id="12ac" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe os ot ou oj b">repo.diff('master', 'test2')</code></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="3afc" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">结束语</h1><p id="ecd8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在这篇文章中，我们介绍了作为Python中DVC开源解决方案的机库包。这就是机库提供的所有东西吗？肯定不是！我们介绍了基础知识，并发现了如何开始使用Hangar。和往常一样，我强烈建议你仔细阅读他们的<a class="ae lh" href="https://hangar-py.readthedocs.io/en/stable/readme.html" rel="noopener ugc nofollow" target="_blank">文档</a>，并使用你自己的用例进行实践。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="c816" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你喜欢这篇文章吗？如果是的话，也许你可以考虑成为会员来支持我和你其他喜欢的作家。</p><div class="pi pj gp gr pk pl"><a href="https://david-farrugia.medium.com/membership" rel="noopener follow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jd gy z fp pq fr fs pr fu fw jc bi translated">加入我的介绍链接媒体-大卫法鲁吉亚</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">david-farrugia.medium.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz lb pl"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="9160" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">想给我买杯咖啡吗？</strong></p><div class="pi pj gp gr pk pl"><a href="https://paypal.me/itsdavidfarrugia?country.x=MT&amp;locale.x=en_US" rel="noopener  ugc nofollow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jd gy z fp pq fr fs pr fu fw jc bi translated">使用贝宝支付大卫法鲁吉亚。我</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">如果您接受cookies，我们将使用它们来改善和定制您的体验，并使我们的合作伙伴能够向您展示…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">paypal.me</p></div></div><div class="pu l"><div class="qa l pw px py pu pz lb pl"/></div></div></a></div></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="a41a" class="li lj it bd lk ll ni ln lo lp nj lr ls ki nk kj lu kl nl km lw ko nm kp ly lz bi translated">想联系吗？</h1><p id="b9a5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我很想听听你对这个话题的想法，或者其他什么。如果你想联系我，请给我发电子邮件至davidfarrugia53@gmail.com<em class="nw"/>。</p><p id="386d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Linkedin  — <a class="ae lh" href="https://twitter.com/davidfarrugia53" rel="noopener ugc nofollow" target="_blank"> Twitter </a></p></div></div>    
</body>
</html>