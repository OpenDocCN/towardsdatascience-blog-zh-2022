<html>
<head>
<title>PyTorch Multi-Weight Support API Makes Transfer Learning Trivial Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch多权重支持API让迁移学习再次变得琐碎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytorch-multi-weight-support-api-makes-transfer-learning-trivial-again-899071fa2844#2022-01-13">https://towardsdatascience.com/pytorch-multi-weight-support-api-makes-transfer-learning-trivial-again-899071fa2844#2022-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="bb75" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">PyTorch多权重支持API让迁移学习再次变得琐碎</h1></div><div class=""><h2 id="2dcc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个新的Pytorch API使微调流行的神经网络架构变得容易，并使它们为您工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6cf6da8655d7b226929d87a7db5bcf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6IDNWIoPS1qcO6Zv0dxNg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">艾莉娜·格鲁布尼亚克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e5e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微调深度学习(DL)模型从未如此简单。像<a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>和<a class="ae ky" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>这样的现代DL框架使得这个任务变得微不足道。你可以在几分钟内拥有一个经过战斗考验的适合你需求的人工神经网络。</p><p id="21f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，微调您的模型只是您实验中的一步。因此，像这样的实验通常遵循以下算法:</p><ol class=""><li id="42cf" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">实例化您想要微调的神经网络架构。例如，如果您的领域是计算机视觉，您可能希望加载ResNet架构。</li><li id="0eee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">为此架构加载一组权重。坚持我们的计算机视觉示例，通过在ImageNet数据集上训练模型获得的一组权重通常是首选。</li><li id="a830" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建预处理函数或操作组合，将数据塑造成所需的形状。</li><li id="bc71" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将你在第一步中实例化的神经网络与你的数据相匹配。您可以根据需要调整模型的输出层，或者冻结一些层以保持权重子集不变。这些决定取决于您的用例。</li><li id="6df7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在保留的测试数据集上评估您训练的神经网络。您必须以处理定型数据集的相同方式处理测试数据集。任何微小的差异都会导致模型性能的恶化，这是非常难以调试的。</li><li id="5944" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">存储实验的元数据，例如数据集的类名，以便在以后的应用程序中使用它们，甚至执行健全性检查。</li></ol><div class="mj mk gp gr ml mm"><a rel="noopener follow" target="_blank" href="/xresnet-from-scratch-in-pytorch-e64e309af722"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd iu gy z fp mr fr fs ms fu fw is bi translated">Pytorch中从头开始的xResNet</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">从你的ResNet架构中挤出一点额外的东西。</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">towardsdatascience.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na ks mm"/></div></div></a></div><p id="2cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是你说的重点，"<em class="nb">等一下，这不是那么直截了当的！</em>“你说得对，细节决定成败；如果你什么都自己做，有很多陷阱要避免。</p><p id="b496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们看看一个新的PyTorch API如何使这一切变得更加机械化，从而节省您的时间和精力。</p><blockquote class="nc nd ne"><p id="051e" class="kz la nb lb b lc ld ju le lf lg jx lh nf lj lk ll ng ln lo lp nh lr ls lt lu im bi translated"><a class="ae ky" href="https://www.dimpo.me/newsletter?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=pytorch-pretrained-api" rel="noopener ugc nofollow" target="_blank"> Learning Rate </a>是为那些对AI和MLOps的世界感到好奇的人准备的时事通讯。你会在每周五收到我关于最新人工智能新闻和文章的更新和想法。订阅<a class="ae ky" href="https://www.dimpo.me/newsletter?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=pytorch-pretrained-api" rel="noopener ugc nofollow" target="_blank">这里</a>！</p></blockquote></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="cc05" class="np nq it bd nr ns nt nu nv nw nx ny nz jz oa ka ob kc oc kd od kf oe kg of og bi translated">古老的方式:徒步旅行</h1><p id="dd90" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">为了对正在发生的事情有一个坚实的理解，我们将首先检查旧的方式。我们不会训练一个模特，但我们会做几乎所有其他的事情:</p><ul class=""><li id="0f19" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu om mb mc md bi translated">加载神经网络架构的预训练版本</li><li id="5510" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu om mb mc md bi translated">预处理数据集</li><li id="0e8a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu om mb mc md bi translated">使用神经网络在测试集上获得预测</li><li id="0590" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu om mb mc md bi translated">使用数据集的元数据获得人类可读的结果</li></ul><p id="9f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段总结了您需要做什么来勾选上面列表中的所有框:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="91ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此示例中，首先加载ResNet神经网络体系结构。您将<code class="fe op oq or os b">pretrained</code>标志设置为<code class="fe op oq or os b">True</code>,告诉PyTorch您不希望它随机初始化模型的权重。相反，它应该使用通过在ImageNet数据集上训练模型而获得的权重。</p><p id="a1b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，定义并初始化数据转换的组合。因此，在将图像输入模型之前，PyTorch将:</p><ul class=""><li id="2778" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu om mb mc md bi translated">将图像调整为<code class="fe op oq or os b">224x224</code></li><li id="ec1a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu om mb mc md bi translated">把它转换成张量</li><li id="a485" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu om mb mc md bi translated">将张量的每个值转换为类型<code class="fe op oq or os b">float</code></li><li id="f175" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu om mb mc md bi translated">使用一组给定的平均值和标准偏差将其标准化</li></ul><p id="4999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，您准备处理图像，并通过神经网络层获得输出。这一步是最简单的一步。</p><p id="adf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您希望以人类可读的方式打印结果。这意味着你不想打印出你的模型预测的图像是<code class="fe op oq or os b">4</code>类。这对您或您的应用程序的用户来说没有任何意义。您希望打印出您的模型预测图像显示一只狗有95%的可信度。</p><p id="2b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，您首先需要加载包含类名的元数据文件，并为您的预测确定正确的类名。</p><p id="51fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我承认这个剧本不算太大的工作量；然而，它有两个缺点:</p><ol class=""><li id="70fd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您处理测试数据集的方式的微小变化可能会导致难以调试的错误。请记住，您应该像处理训练数据集一样转换测试数据集。如果你不知道你是怎么做到的，或者别人运行了训练程序，你就完了。</li><li id="7534" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您必须随身携带元数据文件。同样，对该文件的任何篡改都可能导致意想不到的结果。这些错误会让你的头在键盘上撞上几天。</li></ol><p id="a701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看一个新的PyTorch API如何让这一切变得更好。</p><h1 id="e558" class="np nq it bd nr ns ot nu nv nw ou ny nz jz ov ka ob kc ow kd od kf ox kg of og bi translated">走向</h1><p id="57d7" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">正如我们之前看到的，您有两个痛点需要解决:(I)总是以相同的方式处理您的训练和测试子集，(ii)消除携带单独的元数据文件的需要。</p><p id="15be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一个示例来看看新的PyTorch API如何应对这些挑战:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会立即看到脚本明显变小了。但这不是重点；该脚本更小，因为您不必从头定义一个<code class="fe op oq or os b">preprocess</code>函数，也不必加载任何元数据文件。</p><p id="1099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第9行，您会看到一些新的东西。不是告诉PyTorch你需要一个预训练版本的ResNet，首先，你实例化一个新的<code class="fe op oq or os b">weights</code>对象，然后用它实例化模型。在这个<code class="fe op oq or os b">weights</code>对象中，您可以找到在训练期间应用于数据的转换和数据集的元数据。这太棒了。</p><p id="6fe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个观察结果是，您现在可以轻松地选择要预加载的重量。例如，您可以选择加载一组不同的权重，只需对代码进行微小的更改:</p><pre class="kj kk kl km gt oy os oz pa aw pb bi"><span id="41be" class="pc nq it os b gy pd pe l pf pg"><em class="nb"># New weights with accuracy 80.674%<br/></em>model <strong class="os iu">=</strong> resnet50(weights<strong class="os iu">=</strong>ResNet50_Weights.ImageNet1K_V2)</span></pre><p id="a93b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者询问在ImageNet上产生最佳结果的答案:</p><pre class="kj kk kl km gt oy os oz pa aw pb bi"><span id="4e43" class="pc nq it os b gy pd pe l pf pg"><em class="nb"># Best available weights (currently alias for ImageNet1K_V2)<br/></em>model <strong class="os iu">=</strong> resnet50(weights<strong class="os iu">=</strong>ResNet50_Weights.default)</span></pre><h1 id="5a51" class="np nq it bd nr ns ot nu nv nw ou ny nz jz ov ka ob kc ow kd od kf ox kg of og bi translated">结论</h1><p id="3ea6" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">微调深度学习(DL)模型从未如此简单。像TensorFlow和PyTorch这样的现代DL框架使得这个任务变得微不足道。</p><p id="6925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，仍然有一些陷阱要避免。最值得注意的是，您应该总是以相同的方式处理您的训练和测试子集，并且消除携带单独的元数据文件的需要。</p><p id="a604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您需要使用一组不同的权重作为起点，或者您已经有了一组权重，并且希望在某个中央存储库中共享它们，会发生什么情况呢？有没有一种简单的方法来实现这一点？</p><p id="90cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，新的PyTorch多权重支持API涵盖了所有这些挑战。你可以通过安装PyTorch的夜间版本进行试验，并对这个<a class="ae ky" href="https://github.com/pytorch/vision/issues/5088" rel="noopener ugc nofollow" target="_blank"> GitHub问题</a>提供反馈。</p><h1 id="e92e" class="np nq it bd nr ns ot nu nv nw ou ny nz jz ov ka ob kc ow kd od kf ox kg of og bi translated">关于作者</h1><p id="19c1" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">我的名字是<a class="ae ky" href="https://www.dimpo.me/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=pytorch-pretrained-api" rel="noopener ugc nofollow" target="_blank">迪米特里斯·波罗普洛斯</a>，我是一名为<a class="ae ky" href="https://www.arrikto.com/" rel="noopener ugc nofollow" target="_blank">阿里克托</a>工作的机器学习工程师。我曾为欧洲委员会、欧盟统计局、国际货币基金组织、欧洲央行、经合组织和宜家等主要客户设计和实施过人工智能和软件解决方案。</p><p id="62b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣阅读更多关于机器学习、深度学习、数据科学和数据操作的帖子，请关注我的<a class="ae ky" href="https://towardsdatascience.com/medium.com/@dpoulopoulos/follow" rel="noopener" target="_blank"> Medium </a>、<a class="ae ky" href="https://www.linkedin.com/in/dpoulopoulos/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或Twitter上的<a class="ae ky" href="https://twitter.com/james2pl" rel="noopener ugc nofollow" target="_blank"> @james2pl </a>。</p><p id="dcde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所表达的观点仅代表我个人，并不代表我的雇主的观点或意见。</p></div></div>    
</body>
</html>