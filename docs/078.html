<html>
<head>
<title>Create a Simple App Quickly Using Jupyter Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jupyter笔记本快速创建一个简单的应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-a-simple-app-quickly-using-jupyter-notebook-312bdbb9d224#2022-01-04">https://towardsdatascience.com/create-a-simple-app-quickly-using-jupyter-notebook-312bdbb9d224#2022-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="2cea" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用Jupyter笔记本快速创建一个简单的应用程序</h1></div><div class=""><h2 id="5dc9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据科学家和其他希望将Python函数转化为交互式应用程序的人的指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f639772f33ffbdf9e35fab505eedbbec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGt0KSHgz8PrR3jJ5yCr5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从代码到应用——作者图片</p></figure><p id="3483" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将演示一个健壮但易于使用的解决方案，除了Python、Jupyter notebook和Ipywidgets等众所周知的工具之外，它只需要很少的知识。</p><p id="20bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将构建一个交互式应用程序来解决一个二次方程。这是一个非常简单的例子，但足以演示该方法。我们不会直接跳到最终的解决方案，而是通过几个简单的步骤逐步实现。我将从最简单的基于笔记本的实现开始，以完全交互式的解决方案结束。</p><p id="7099" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">问题表述:</p><p id="c39b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给定三个数字a、b和c，找出满足以下条件的x:</p><p id="e827" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">a x +b x +c = 0</p><p id="aaf7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">众所周知，该方程的解由下式给出:</p><p id="3936" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">(-b + D)/2a和(-b-D)/2a，其中D = sqrt(b -4ac)</p><h2 id="489f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">1.直接法</h2><p id="7a1c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们第一次尝试为这个问题创建一个笔记本，看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="745d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经实现了功能。是时候重构我们的笔记本来使用功能了，而不是到处扔代码。</p><h2 id="80e1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">2.使用函数</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d9dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过创建这些功能，第一个直接的好处是可重用性。我们不需要每次想要使用该功能时都复制并粘贴代码。</p><p id="fa86" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但最重要的是它给出的结构:函数清楚地显示了它们的输入和输出。这也有助于在我们的大脑中构建问题，并分离解决方案的主要构件。</p><h2 id="d541" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">3.小工具</h2><p id="c779" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在我们已经实现了主要函数，我们可以进行计算了。<br/>然而，对于必须在代码单元格中输入值的用户来说，这不是很方便。通过为系数引入输入部件，我们可以做得更好。注意，最后几个没有变化的单元格被省略了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bb0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在它开始看起来像一个应用程序，用户不再需要修改代码，但仍然需要在每个单元格后按Ctrl-Enter。此外，每次用户更改值时，都需要重新执行单元格#5。(注意，我们必须使用“.”来引用小部件的值。值”。)</p><h2 id="0bc1" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">4.瞧</h2><p id="8b45" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果你使用Jupyter笔记本，你很可能听说过“瞧”。它的作用是获取一个普通的Jupyter笔记本，保留输出单元格，隐藏代码单元格。这使得外观更加整洁。<br/>瞧，安装起来超级容易。如果您的环境中尚未安装，您可以通过以下方式进行安装:</p><p id="ff8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mr ms mt mu b">pip install voila</code></p><p id="92fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你现在重启jupyter-notebook，你会在按钮栏看到一个“瞧”按钮。</p><p id="1a6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，当你对你的笔记本进行可视化时，你将不得不得出结论，它不能工作，至少不能按照预期的方式工作:改变输入框中的值没有任何效果。<br/>为什么？因为在用户有机会输入/修改值之前，voila执行了所有的代码单元。所以不管初始值是什么，都将被使用。</p><p id="da67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了让voila工作，您必须设置某种交互性:代码执行需要通过与小部件的交互来触发。您不再有手动执行代码单元的选项。</p><h2 id="6c94" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">5.让我们增加互动性</h2><p id="ecde" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有几种方法可以让你在部件状态改变时触发一些动作。您可以使用<code class="fe mr ms mt mu b">interact</code>函数或<code class="fe mr ms mt mu b">observe</code>方法。但是请注意，这些仅在单个小部件级别上运行。您可以设置一个在小部件改变时执行的动作，但是您无法控制它将触发的事件链:您可以很容易地触发<code class="fe mr ms mt mu b">D</code>的重新计算，但是您真正需要的是<code class="fe mr ms mt mu b">x1</code>和<code class="fe mr ms mt mu b">x2</code>的重新计算。您可以手动跟踪整个依赖图，并在<code class="fe mr ms mt mu b">c</code>改变时记得更新<code class="fe mr ms mt mu b">x1</code>和<code class="fe mr ms mt mu b">x2</code>。但是这不方便而且容易出错。假设您有一个稍微大一点的项目，有20或30个内部变量，它们以某种非平凡的方式相互依赖。手动跟踪要更新的变量将很快导致错误。</p><p id="c14c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，我提出的解决方案是使用<a class="ae mv" href="https://autocalc.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">自动计算</a>包。这个包允许你在内部变量和用户公开变量之间建立依赖图。一旦建立了这个图(DAG ),您就不需要手动重新计算变量了。就像Excel的自动更新功能。</p><p id="5ab8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有其他针对同一问题的包，autocalc的优势在于它的简单性:你只需要学习一个名为<code class="fe mr ms mt mu b">Var</code>的类来设置DAG。所以让我们深入研究一下:</p><p id="5a94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，您需要安装软件包</p><p id="ccd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mr ms mt mu b">pip install autocalc</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fe9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你现在打开你的笔记本，它会像预期的那样工作</p><p id="b05e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意事项:</p><ul class=""><li id="6cc5" class="mw mx iq kx b ky kz lb lc le my li mz lm na lq nb nc nd ne bi translated">查看<a class="ae mv" href="https://autocalc.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank">自动计算</a>的文档，了解高级特性，如“惰性”计算。</li><li id="95e1" class="mw mx iq kx b ky nf lb ng le nh li ni lm nj lq nb nc nd ne bi translated">一些输出值(如数据帧)无法通过微件显示。在这种情况下，仍然可以自动更新输出。诀窍是设置一个虚拟变量，它取决于输出。分配给该变量的函数需要在值改变时执行必要的操作。这种技术在<code class="fe mr ms mt mu b">autocalc.tools.PreviewAcc</code> helper类中使用，这是一种现成的解决方案。</li></ul><p id="aed4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这个小描述对你有用。如果你喜欢我的帖子，请鼓掌，关注，分享，评论。这鼓励我生产更多。</p><h2 id="4a2a" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">放弃</h2><p id="aff0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我是<a class="ae mv" href="https://github.com/kefirbandi/autocalc" rel="noopener ugc nofollow" target="_blank">自动计算</a>包的作者。</p></div></div>    
</body>
</html>