<html>
<head>
<title>Spark Graphx Pregel API: It’s Not as Complex as It Sounds</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spark Graphx Pregel API:它没有听起来那么复杂</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/spark-graphx-pregel-its-not-so-complex-as-it-sounds-d196da246c73#2022-01-24">https://towardsdatascience.com/spark-graphx-pregel-its-not-so-complex-as-it-sounds-d196da246c73#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="7c9d" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">Spark Graphx Pregel API:它没有听起来那么复杂</h1></div><div class=""><h2 id="6193" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解Pregel的基础知识，以及它如何解决现实世界中的问题，即使这些问题与图形没有严格的关系。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f5be65066f0b1f1c39db7afec18ebbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eORJsHOpBMHL9IG7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://www.pexels.com/photo/person-wearing-beige-sweater-holding-map-inside-vehicle-1252500/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/person-weaking-米色-毛衣-手持-地图-车内-1252500/ </a></p></figure><h1 id="3ed3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">普雷格尔什么？</h1><p id="db5e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Spark附带了一个图形处理库，其中有几个有用的API，用户可以开箱即用，例如查找连接的组件、计算三角形和排列图形中的节点。这些API只是将用户从重新发明轮子中解放出来。这不仅是关于图的问题或算法，也是关于可伸缩性的问题，这样问题就可以在大量数据的情况下得到解决。</p><p id="78d3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我以前有机会使用这些API，但是有一个API看起来有点复杂。它实际上是一个框架，需要开发人员插入一些逻辑来解决定制问题。该API被称为“<strong class="lq ir"> Pregel </strong>”。</p><p id="e934" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">来自<a class="ae kv" href="https://stanford.edu/~rezab/classes/cme323/S15/notes/lec8.pdf" rel="noopener ugc nofollow" target="_blank">斯坦福的课堂素材</a>:</p><blockquote class="mp mq mr"><p id="3078" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">pregel(Parallel、Graph和Google三个词的组合)是一个数据流范式和系统，用于Google创建的大规模图形处理，以解决仅使用MapReduce框架难以解决或成本高昂的问题。虽然该系统仍然是Google的专利，但计算范式已被许多图形处理系统采用，许多流行的图形算法已被转换为Pregel框架。Pregel本质上是一个限制在图的边上的消息传递接口。</p></blockquote><p id="d228" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当图很大时，像Dijkstra的最短路径这样的算法可能不是很有效。这并不是因为算法本身就很糟糕，而是因为图像无法容纳在一台机器的内存中。</p><p id="239d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Spark对Pregel的实现是在<a class="ae kv" href="https://15799.courses.cs.cmu.edu/fall2013/static/papers/p135-malewicz.pdf" rel="noopener ugc nofollow" target="_blank">的原始论文</a>中提出的一个轻微的变体，以允许某些内部优化。为了继续这篇文章的其余部分，建议对Spark Graphx有一些基本的了解。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="9b7c" class="kw kx iq bd ky kz nd lb lc ld ne lf lg jw nf jx li jz ng ka lk kc nh kd lm ln bi translated">简而言之Pregel API</h1><p id="a652" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Pregel作为一个API有以下冗长的签名，长时间的currying和高阶函数。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="a253" class="nn kx iq nj b gy no np l nq nr"><strong class="nj ir">def</strong> pregel[A]<br/>      (initialMsg<strong class="nj ir">:</strong> A,<br/>       maxIter<strong class="nj ir">:</strong> Int = Int.MaxValue,<br/>       activeDir<strong class="nj ir">:</strong> EdgeDirection = EdgeDirection.Out)<br/>      (vprog<strong class="nj ir">:</strong> (VertexId, VD, A) <strong class="nj ir">=&gt;</strong> <strong class="nj ir">VD</strong>,<br/>       sendMsg<strong class="nj ir">:</strong> EdgeTriplet[VD, ED] <strong class="nj ir">=&gt;</strong> <strong class="nj ir">Iterator</strong>[(VertexId, A)],<br/>       mergeMsg<strong class="nj ir">:</strong> (A, A) <strong class="nj ir">=&gt;</strong> A)<br/>    <strong class="nj ir">:</strong> Graph[VD, ED]</span></pre><p id="1774" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从上到下:</p><ol class=""><li id="7f07" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj nx ny nz oa bi translated">该函数在类型A上是通用的，类型A是从一个节点发送到另一个节点的消息的类型。Pregel基本上是一个消息发送和聚合算法。该类型是从下一个参数中推断出来的。</li><li id="9165" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated"><strong class="lq ir"> initialMsg </strong>参数保存调用API时发送给图中所有节点的消息。</li><li id="5e98" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated"><strong class="lq ir"> maxIter </strong>是一个数字，用于设定运行迭代次数的上限，默认为Int类型的最大值。</li><li id="a5ec" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated"><strong class="lq ir"> activeDirection </strong>控制消息是通过边缘的出站方向还是入站方向发送，默认为出站。这里讨论的所有例子都假定默认值为出站方向。</li><li id="f194" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated"><strong class="lq ir"> vprog </strong>是一个函数，它获取顶点Id、顶点数据和发送的消息，并基于某种逻辑更新顶点数据。这个函数通常被称为顶点程序。</li><li id="389b" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated"><strong class="lq ir"> sendMsg </strong>是另一个函数，它接受边三元组并返回由顶点Id和消息组成的元组数组。这是用于生成消息的函数，这些消息将在迭代的下一步中使用。</li><li id="4f29" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated"><strong class="lq ir"> mergeMsg </strong>是从发送到同一节点(顶点)的一组消息中挑选出一条消息的功能。</li><li id="4455" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated">调用这个Pregel API的返回类型是另一个具有相同类型的顶点和边数据的图形，但是它的顶点数据可能是输入图形的变异版本。</li></ol><p id="85f8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在接下来的几节中，上述内容的含义和用法将会更加清楚。</p><p id="ed57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们使用Spark文档单源最短路径示例来实现和解释Pregel，然后我将跳转到一个可以使用Pregel解决的实际业务问题。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="6639" class="kw kx iq bd ky kz nd lb lc ld ne lf lg jw nf jx li jz ng ka lk kc nh kd lm ln bi translated">你好Pregel</h1><p id="786d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">要解决的问题是单源最短路径；简称SSSP。如果你使用谷歌地图或苹果地图，它们解决了几乎相同的问题，只是有些不同，但概念仍然是一样的。Graphx的Spark文档提供了一个片段来解决这个问题，但是是针对随机生成的图形。</p><p id="f862" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们从头开始，从下图开始。节点1是起始节点，我们希望找到图中起始节点1到其他节点的最短距离。目测问题，节点2和3的距离很明显，分别为5和7。节点4到1的最短距离应该是(5+12)和(7+8)的最小值，即15。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/b878befdc3ec8e539e508c6361b3cb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*7nCUmC1Y1VCCwV47AxXyBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="5fb2" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">在Spark中创建图形</h2><p id="c1b2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Spark Graphx中的图必须有一个顶点RDD和一个边RDD。顶点RDD是一个元组数组，其中第一个元素是必须很长的节点Id(这就是为什么我没有将节点命名为A、B、C、D)。元组的第二部分是顶点数据，在这种情况下，它被初始化为距节点1的最短距离。节点1的值为0，每隔一个节点的距离为无穷大，这将在该过程完成后改变。</p><blockquote class="mp mq mr"><p id="b8e5" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">附言:顶点RDD是这样创建的，以便于直接运行Pregel。在这篇文章的第二部分，我们将看到一种不同的初始化技术，以防初始化图形所需的逻辑有点复杂。</p></blockquote><p id="0286" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">边缘RDD是一个容易的；它有源节点Id、目标节点Id和边数据，在我们的例子中是两个节点之间的距离。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="bdbb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了验证图形是否构建成功，可以将顶点和边部分打印为数据框。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/3e42d614e42c79041e808e3ab0ca0770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6d24nz2gW28Go0ImtakhA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="7d93" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">运行预凝胶</h2><p id="0be4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在是时候使用Pregel获得最短路径了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="3944" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">函数签名在前面已经总结过了，所以现在是时候看看实际的实现了:</p><ol class=""><li id="840e" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj nx ny nz oa bi translated">第1行上的正无穷大比特是要发送给所有节点的初始消息。</li><li id="f6c4" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated">第2行具有顶点程序，该程序简单地检查接收的消息(newDist)是否小于当前分配的最短距离(Dist)。如果计算结果为真，则用消息值更新顶点数据。请记住，除了节点1之外的所有节点都以+Inf的顶点数据开始。</li><li id="e2fb" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated">第3行到第9行具有沿边缘发送消息的逻辑。该算法在一个循环中迭代，其中每次迭代被称为超级步骤。在每个超级步骤中，生成一组消息并发送给一些节点。节点处理消息以改变顶点数据，并且循环继续。当由于所有节点都暂停而没有生成新消息时，循环结束。所有节点都以主动方式启动算法，因为所有节点都接收到了初始消息。<strong class="lq ir">如果生成的消息中没有一条边接触到一个节点，则该节点可以被暂停。</strong>这并不意味着节点将永远停止，因为如果有消息触及它的一条边，它可以在后面的步骤中被重新激活。在我们的例子中，消息发送函数只是检查当前节点距离(triplet.srcAttr)和边距离(triplet.attr)之和是否小于目标节点上设置的距离(triplet.dstAtrr)。如果评估为真，则在边缘上生成新消息。该消息是要向其发送消息的目标节点的元组加上新的距离值，该新的距离值应该小于目标节点上的当前距离。这个新的距离可以作为顶点程序的节点数据。如果条件评估为false，则不会从当前节点生成新消息。</li><li id="74a6" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated">第10行只是控制一个节点在收到多个消息时处理哪个消息。在我们的例子中，如果一个节点有多条输入边，它将从这些边上发送的消息中选择最短的距离。无论节点收到一条还是多条消息，都将只选取一条消息，其值将用于变异目标节点顶点数据。</li></ol><p id="90c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请参见Spark Docs上的<a class="ae kv" href="https://spark.apache.org/docs/latest/graphx-programming-guide.html#pregel-api" rel="noopener ugc nofollow" target="_blank">伪代码</a>来形象化上述描述。第二次调用<code class="fe ov ow ox nj b">mapReduceTriplets</code>有一个最终参数(称为<code class="fe ov ow ox nj b">activeSetOpt</code>)来控制哪些节点将生成消息。</p><p id="a5fc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面可能看起来过于复杂或不可读(也许这是我的写作风格)，但一旦我们描述了手头问题的迭代，这可能会改变。我将把它推迟几秒钟，现在显示输出。该算法的结果是几乎相同的图，其中每个顶点数据被更新以反映从节点1的最短路径距离。这是因为我们将图初始化为节点1的值为零，所有其他节点的值为正无穷大<strong class="lq ir">。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/72b0572c8f68601a1c2daf7b0b50ff3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ONRu5pSohS07FbqWzbczQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ed5c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如您所见，距离计算正确，节点4在从节点1到节点3再到节点4的最短路径上有一个距离。</p><h2 id="280b" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">可视化超级步骤行为</h2><p id="17db" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果算法的文本描述很复杂，那么展示某种基于调试的运行会使画面更清晰。这是再次作为复习的图表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/b878befdc3ec8e539e508c6361b3cb2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*7nCUmC1Y1VCCwV47AxXyBg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4e10" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">超0步</strong></p><p id="2b06" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该算法从所有活动节点开始，并且所有节点都接收到+Inf的初始消息。</p><p id="ccc1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每个节点运行顶点程序，该程序不会对任何节点的顶点数据造成任何改变，因为+Inf的初始消息不小于任何节点的顶点数据。</p><p id="52a3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一个<strong class="lq ir"> sendMsg </strong>功能在所有(<strong class="lq ir">活动</strong>)节点的所有出站边缘被触发，这意味着:</p><ul class=""><li id="bf53" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">节点1向节点2和3发送两个消息，每个消息的值分别为零加上1 &amp; 2和1 &amp; 3之间的边距离，因为该值(5或7)小于目标节点上的顶点数据值。</li><li id="cecd" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">节点2和3不向节点4生成任何消息，因为它们的顶点数据仍然是+Inf。刷新一下你的记忆，是<strong class="lq ir"> Iterator.empty </strong>行。</li><li id="cd0c" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">节点4也不生成任何消息，因为它没有出站边。</li></ul><p id="47a1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">超级第一步</strong></p><p id="be96" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">顶点程序根据上一步的消息运行。</p><ul class=""><li id="cdb8" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">节点2从节点1接收值为5的消息。节点2的顶点数据被更新为5，因为它小于+Inf的当前值。</li><li id="ec89" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">节点3从节点1接收值为7的消息。节点3的顶点数据被更新为7，因为它小于+Inf的当前值。</li></ul><p id="8dfc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在节点1、2 &amp; 3的出站边缘上调用<strong class="lq ir"> sendMsg </strong>(因为它们是仅有的具有当前消息边缘的节点),这产生了以下结果:</p><ul class=""><li id="952b" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">节点1不向节点2和3发送任何消息，因为上面代码片段中第4行的条件不满足。</li><li id="2bca" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">节点2向节点4发送值为17的消息，因为5+ 12小于+Inf。5是节点2上的值，12是从节点2到节点4的边距离。</li><li id="65a6" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">节点3向节点4发送值为15的消息，因为7+ 8小于+Inf。7是节点3上的值，8是从节点3到节点4的边距离。</li></ul><p id="6755" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">超级第二步</strong></p><p id="7826" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">顶点程序根据上一步的消息运行。</p><ul class=""><li id="2318" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">因为节点4接收到不止一条消息，所以调用函数<strong class="lq ir"> mergeMsg </strong>从17和15中挑选出一条消息。根据<strong class="lq ir"> mergeMsg </strong>功能的逻辑选取值为15的消息。</li><li id="5e46" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">在节点4上调用顶点程序，节点4将其顶点数据从+Inf更改为15。</li></ul><p id="6ce6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">在节点2、3、4的出站边缘上调用sendMsg </strong>(因为它们是仅有的具有带有当前消息的边缘的节点),这产生了以下结果:</p><ul class=""><li id="14e8" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">节点2和3不发送任何新消息，因为上面代码片段中第4行的条件不满足。</li><li id="5af4" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">节点4没有出站边缘，因此它不产生任何消息。</li></ul><p id="36d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当没有新的消息生成时，算法结束，并返回最终的图，其中每个顶点与节点1具有正确的最短距离。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa ot l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://tenor.com/view/movies-matilda-piece-of-cake-cake-piece-gif-16988524" rel="noopener ugc nofollow" target="_blank">https://tenor . com/view/movies-Matilda-piece-cake-piece-gif-16988524</a></p></figure><p id="19f3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">希望这解释了Spark Pregel API是如何工作的，以及它如何用于解决大型图形上的几种类型的问题。</p><p id="ab2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">等等！这里不是包装。再来讨论一下我最近遇到的另一个实际用例。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="bfcb" class="kw kx iq bd ky kz nd lb lc ld ne lf lg jw nf jx li jz ng ka lk kc nh kd lm ln bi translated">有待解决的新的重大问题</h1><p id="8eab" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你可能会想到使用一些社交媒体或维基百科或引用数据集的复杂大数据规模问题。这实际上是一个经典问题，可以使用递归公共表表达式来解决(Spark OOTB目前不支持这一功能)。数据大小可大可小，但这并不十分相关，因为Pregel旨在处理大数据。</p><p id="4856" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设有一个传统的雇员表，包含Id、经理Id和所有其他常见属性，如姓名、部门、加入日期等。要求是检查这个employee表，找出层次结构中向某个雇员报告的所有雇员(直接/间接)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/499d0a8acfcc2dc372a61967fbbee422.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipEVjg-bbc-AN9fbxzW_6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="bbd0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这可以用于应用一些安全措施，使得一个雇员可以查看她自己以及直接或间接向她报告的任何其他雇员所拥有的数据或人工制品。这听起来像动作/间谍电影中的<em class="ms">通关等级</em>概念。</p><p id="5975" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们可以将每个雇员的层次结构路径编码为雇员记录的一部分，那么就可以应用一个简单的表过滤器来查找一个雇员记录以及向他报告的所有雇员。</p><p id="c061" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，上面屏幕截图中的雇员层次结构路径可以如下保存:</p><ul class=""><li id="f9cf" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">苔莎</li><li id="abdb" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">苔莎|爱德华|</li><li id="d7ac" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">苔莎|埃文|</li><li id="9e39" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">|泰莎|埃文|约翰|</li></ul><p id="b1e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了获得Evan的根层次结构，我们可以过滤表中任何路径包含<strong class="lq ir"> |evan|的人。</strong></p><p id="9319" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> <em class="ms">附注:路径将由员工的唯一ID组成，这些id可能看起来像GUID之类的，并且id中不允许使用分隔符。</em>T13】</strong></p><p id="d034" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是为什么要把Pregel牵扯进来呢？这可以在SQL Server或Oracle上使用递归cte来实现。使用Pregel预计算层次路径可能有两个原因:</p><ol class=""><li id="e336" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj nx ny nz oa bi translated">员工数据是作为ETL管道的一部分准备的，并存储在一些可能不支持递归cte的数据存储中。管道使用Spark来准备接收和转换数据。Spark还没有递归cte，所以Pregel恰好是一个很好的选择。</li><li id="d539" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj nx ny nz oa bi translated">预先计算路径有利于提高性能，这样消费者就不必总是运行这个逻辑(即使他们支持针对该数据存储的递归cte)。许多APIs中间件系统都有积极的性能SLA，让这样的数据提前持久化是一个明显的优势。</li></ol><h2 id="414d" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">在Graphx中准备人力资源图表</h2><p id="be3a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我就不再赘述了，因为现在事情应该相当简单了，下面是上一节中显示的HR图如何在Graphx中表示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="a9e9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因为边属性值在我们的例子中是不相关的，所以它被设置为默认值0L。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/caa6253c75116ad604bb102decc84a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFhrIxeUWi9vLTgMPKuLLQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="dfe0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">为预凝胶计算准备图形</strong></p><p id="9a29" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在SSSP的例子中，已经创建了图，使得开始节点的值为零，并且每个其他节点的值为+Inf。这足以让我们使用Pregel开始计算。在其他情况下，可能有必要根据问题类型，用一些初始状态来改变输入图形数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="760f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们的HR案例中，如果节点有父节点，我们可以将每个节点数据更改为空字符串，否则节点的数据将由两个|字符组成的节点Id包装。</p><p id="3da9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">稍后您将看到如何将所有这些图连接在一起，以得到一个包含Id、雇员姓名和路径的图或表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pd"><img src="../Images/a667ec001a55ba870583717b75958599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wEcHuMTW2fFMjLM-RCisoQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3101" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该图具有相同的节点和边结构，但是每个节点值都从雇员姓名更改为一些不同的初始值。但是只要原始的数字id还在，就不会丢失任何东西。顺便说一下，这里一个明显的假设是，除了高层员工，每个员工都有一个经理。这也意味着每个节点只能接收一条或零条消息。</p><h2 id="bdc4" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">编码层次路径的预凝胶逻辑</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="b9de" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以上真的很简单:</p><ul class=""><li id="d0e2" class="ns nt iq lq b lr mk lu ml lx nu mb nv mf nw mj oz ny nz oa bi translated">初始消息被设置为空字符串，表示没有路径信息。</li><li id="3c8e" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">如果发送的消息具有非空路径，顶点程序改变当前节点上的路径。</li><li id="fba2" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">Send message函数检查源节点是否有路径，而目标节点是否有，如果有，则向目标节点发送一条消息，连接源节点路径和目标节点Id。</li><li id="2c43" class="ns nt iq lq b lr ob lu oc lx od mb oe mf of mj oz ny nz oa bi translated">甚至不需要合并消息函数，因为它永远不会被调用，所以任何虚拟逻辑都足够了。</li></ul><p id="291f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是预期的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pe"><img src="../Images/8d95b378dc326847429114f651c706c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kc_E94d7siO6dFHIGFagTg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="f670" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要重复查找Evan(节点3)层次的逻辑，应该是这样的:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="53bf" class="nn kx iq nj b gy no np l nq nr">SELECT * FROM EMPLOYEE WHERE PATH LIKE '%|3|%'</span></pre><h2 id="b486" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">连接输出图和输入图</h2><p id="d181" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最后一个逻辑是将上面的图与原始图连接起来，这样我们就可以得到一个包含层次结构路径的雇员数据的单一视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/c78266633c1b16cd44f1d5c07c755d91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*OrYXGWKk1liOwwqWpcx_7g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="4b3a" class="nn kx iq bd ky oh oi dn lc oj ok dp lg lx ol om li mb on oo lk mf op oq lm or bi translated">2022年5月更新—多母公司人力资源层次结构</h2><p id="bfee" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Hareesh Alamala留下了一条<a class="ae kv" href="https://gist.github.com/ylashin/6e3b0beca02847fad2e4ee84d0ba1424#gistcomment-4129830" rel="noopener ugc nofollow" target="_blank">评论</a>,询问如果一个节点有多个父节点，如何调整算法。让我们在DAG上尝试相同的HR层次路径，其中一些节点有多个父节点。预期的结果将是相似的，除了每个节点有一个路径数组而不是一个路径，因为在这种情况下可能有许多父节点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/38b5f09a671435b748e334eb049ba3a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*CmFwfkCEJ0vcRi8R.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Tred-G.svg/1920px-Tred-G.svg.png" rel="noopener ugc nofollow" target="_blank">https://upload . wikimedia . org/Wikipedia/commons/thumb/f/Fe/Tred-g . SVG/1920 px-Tred-g . SVG . png</a></p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="8843" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">上面的输出显示了一些节点(1，2，3)有一条路径，其余的有多条路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/6f4ba8ba5536914e100b7b773cda28b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWlJine2omT2PmgunbELXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6af1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ms">我还更新了算法解释，以反映节点暂停的原因，不是因为它们没有生成/接收消息，而是因为没有消息的边接触到这些节点。文件通过下面的评论清楚地解释了这一点。</em></p><blockquote class="mp mq mr"><p id="00b4" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">发送新消息，跳过两边都没有收到消息的边。</p></blockquote><h1 id="e569" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">包裹</h1><p id="3501" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这需要一点努力，但希望你理解Pregel是如何工作的，以及如何用它来解决现实世界的问题，即使它们看起来不像典型的图形问题。</p><p id="12b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">代码是用Scala编写的，只需稍加修改就可以移植到PySpark。</p><p id="316d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这篇文章中使用的图表的性质也有一些隐含的假设。如果图中有负值的圈或边(在SSSP的情况下)，这可能会导致无限循环。所以先试着理解你的图，验证你的Pregel逻辑会收敛到比Int.MaxValue少的步数。😂</p></div></div>    
</body>
</html>