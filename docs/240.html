<html>
<head>
<title>Writing A Merge Function For My Data-Frames Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为我的数据框包编写合并函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/writing-a-merge-function-for-my-data-frames-package-f492e313d02b#2022-01-08">https://towardsdatascience.com/writing-a-merge-function-for-my-data-frames-package-f492e313d02b#2022-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="253a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">OddFrames.jl</h2><div class=""><h1 id="fdbd" class="pw-post-title jb jc it bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy bi translated">为我的数据框包编写合并函数</h1></div><div class=""><h2 id="6f48" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为我的包OddFrames.jl创建两种不同类型的合并。</h2></div><h1 id="811f" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">介绍</h1><p id="a207" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">数据管理框架通常因其方法和功能而备受推崇。这可能是因为这些方法可能很难构建，但也非常方便。关于移动和操作数据有很多东西要学，做这样一个项目的好处是我可以尝试创建自己的算法。</p><p id="4820" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">对于那些不熟悉我的项目OddFrames.jl的人来说，这是一个用于Julia中数据管理的选择性面向对象包。当然，这个软件包的应用主要是基于科学计算。也就是说，这肯定是一个有趣又酷的项目。如果你想查看这个项目的Github，你可以在这里:</p><div class="mk ml gp gr mm mn"><a href="https://github.com/ChifiSource/OddFrames.jl" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd jd gy z fp ms fr fs mt fu fw jc bi translated">GitHub-chifi source/odd frames . JL:面向对象的DataFrames包！</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">jl是Julia的一种新的数据管理和操作包。然而，许多类似的软件包…</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">github.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb nc mn"/></div></div></a></div><p id="eaf0" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">今天，我们将加入一些新的功能，使我们能够轻松地将奇数帧组合在一起。我有几个有趣的计划来解决这个问题，我计划用函数做一些很酷的调度，我知道一个合并函数将会非常困难，所以不再多说，让我们开始写这些函数吧！最后一件事，如果你想更深入地了解OddFrames.jl，这里是我写的关于这个包的前一篇文章，我在其中写了一个CSV解析器:</p><div class="mk ml gp gr mm mn"><a rel="noopener follow" target="_blank" href="/the-wretched-pain-i-experienced-creating-a-csv-reader-in-julia-e67520857b9c"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd jd gy z fp ms fr fs mt fu fw jc bi translated">我在Julia中创建CSV阅读器时经历的痛苦</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">想知道CSV文件是如何解析的吗？这是字符串处理的好方法！</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="nd l my mz na mw nb nc mn"/></div></div></a></div></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="dce1" class="kr ks it bd kt ku nl kw kx ky nm la lb ki nn kj ld kl no km lf ko np kp lh li bi translated">修改构造函数</h1><p id="d433" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">由于有如此多的构造函数，我将把本文示例的重点放在pairs的分派上:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="5866" class="nz ks it nv b gy oa ob l oc od">function OddFrame(p::Pair ...)</span></pre><p id="65fd" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">不过，在我们深入研究这个函数之前，让我们快速看一下外部构造函数，了解一下上下文。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="e85c" class="nz ks it nv b gy oa ob l oc od">mutable struct OddFrame &lt;: AbstractMutableOddFrame<br/>        labels::Array{Symbol}<br/>        columns::Array{Any}<br/>        types::Array<br/>        head::Function<br/>        drop::Function<br/>        dropna::Function<br/>        dtype::Function<br/>        merge!::Function</span><span id="a30c" class="nz ks it nv b gy oe ob l oc od">            function OddFrame(p::Pair ...)</span></pre><p id="54ff" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">任何时候我们看到这样的外部构造函数，在内部构造函数中有不同的调用，这意味着我们很可能期望从函数中返回外部构造函数内部的数据。换句话说，OddFrame(::Pair)只是一组命令，在获取数据的算法完成后，这些命令将调用OddFrame(::Array，::Array，…)。这个函数的第一部分获取我们的三个数组、标签、列和类型。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="9c14" class="nz ks it nv b gy oa ob l oc od">function OddFrame(p::Pair ...)<br/>                # TODO Would be nice to combine these loops:<br/>                labels  = [x[1] for x in p]<br/>                columns = [x[2] for x in p]<br/>                length_check(columns)<br/>                name_check(labels)<br/>                types = [typeof(x[1]) for x in columns]<br/>                # Head<br/>                #== TODO, maybe the best approach to solving<br/>                the TODO outlined in member_func : 35 is to check<br/>                REPL or otherwise here?==#</span></pre><p id="23a7" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">之后，定义了这个新构造类型OddFrame的子类型的函数调用。这些调用来自member_funcs.jl文件的函数，我们很快也会用到这个文件。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="6f57" class="nz ks it nv b gy oa ob l oc od">head(x::Int64) = _head(labels, columns, types, x, )<br/>                head() = _head(labels, columns, types, 5)<br/>                # Drop<br/>                drop(x) = _drop(x, columns)<br/>                drop(x::Symbol) = _drop(x, labels, columns, coldata)<br/>                drop(x::String) = _drop(Symbol(x), labels, columns, coldata)<br/>                # Dropna<br/>                dropna() = _dropna(columns)<br/>                # Dtype<br/>                dtype(x::Symbol) = typeof(coldata[findall(x-&gt;x == x,<br/>                                                labels)[1]][1])<br/>                dtype(x::Symbol, y::Type) = _dtype(columns[findall(x-&gt;x == x,<br/>                 labels)[1]], y)</span></pre><p id="861b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">这是构造函数中我要添加代码的部分。我将简单地为一个名为merge的新功能添加一些调度功能！().你可能会注意到这里合并！()有一个解释点，表明这个方法将改变它所调用的类型。在这个例子中，我们需要一个OddFrame来合并OddFrame。我们的方法也需要来自当前OddFrame的数据。这是我想到的:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="c585" class="nz ks it nv b gy oa ob l oc od"># Merge<br/> merge_def = labels[length(labels)]<br/>merge!(od::OddFrame; at::Symbol = merge_def) = _merge!(labels,<br/>                columns, od, at)<br/>merge!(x::Array; at::Symbol = merge_def) = _merge!(labels,<br/>                columns, od, at)<br/>                </span><span id="9adf" class="nz ks it nv b gy oe ob l oc od">merge_defi = length(labels)</span><span id="af6b" class="nz ks it nv b gy oe ob l oc od"><br/>merge!(od::OddFrame; at::Int64 = merge_defi) = _merge!(labels,<br/>                columns, od, at)<br/>                merge!(x::Array, at::Int64 = merge_defi) = _merge!(lables,<br/>                columns, od, at)</span></pre><p id="591a" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">前两个合并是针对作为符号的at关键字参数，后两个合并是针对作为整数的at关键字参数。我们实际上可以通过将默认的关键字参数赋予别名来改变它，例如merge_def，这种方法的唯一问题是函数永远不会被重新定义。换句话说，在这里使用默认值可能更好，并使用条件，因为OddFrame的长度是可变的，所以如果我们删除了一些列，现在我们的长度只有2，我们不希望设置索引为5。让我们改变这一点:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="e197" class="nz ks it nv b gy oa ob l oc od"># Merge<br/>merge!(od::OddFrame; at::Symbol = :end) = _merge!(labels,<br/>                columns, od, at)<br/>merge!(x::Array; at::Symbol = :end) = _merge!(labels,<br/>                columns, od, at)<br/>                merge_defi = length(labels)<br/>merge!(od::OddFrame; at::Int64 = 0) = _merge!(labels,<br/>                columns, od, at)<br/>merge!(x::Array, at::Int64 = 0) = _merge!(lables,<br/>                columns, od, at)</span></pre><p id="0de8" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我们要做的就是使用new()函数包装这个类型:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="3c20" class="nz ks it nv b gy oa ob l oc od"># type<br/>                new(labels, columns, types, head, drop, dropna, dtype);</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="93ff" class="kr ks it bd kt ku nl kw kx ky nm la lb ki nn kj ld kl no km lf ko np kp lh li bi translated">合并方法</h1><p id="68e2" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我们开始写合并之前！()方法，我们先写merge()。与我们刚刚写的两个函数相反，这两个函数将调用_merge！()在member_funcs.jl中，我们现在在methods.jl中工作，我准备写一个方法，用非变异的方式合并两个OddFrame，返回一个新的odd frame。存储在methods.jl和member_funcs.jl中的函数之间的最大区别是成员函数是该类型的子类型，这通常意味着它们将使用我们的数组，而方法通常将使用这些member_funcs与索引和所有其他frame属性一前一后地为API做出贡献。也就是说，我们在这里的论点可能只是两个奇怪的框架。我还将继续下去，把标签也拿出来:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="5557" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractMutableOddFrame,<br/>        od2::AbstractOddFrame; at::Int64 = width(od))<br/>        # f = od, s = od2<br/>        flabels = od.labels<br/>        slabels = od2.labels</span><span id="b472" class="nz ks it nv b gy oe ob l oc od">end</span></pre><p id="e9f0" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在，我们将使用width(od)来填充at调用，这将被限制为表示轴的索引。一旦进入函数，我们就可以继续进行一些初始化。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="3688" class="nz ks it nv b gy oa ob l oc od">pairs = []</span></pre><p id="cc1e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们将简单地创建一组新的对，然后将它们直接发送回OddFrame构造函数，并返回一个新的OddFrame。如果我们的OddFrame的维度有效，我还将添加一个throw，例如，我们有一个3列的OddFrame，但有人试图在5列进行合并。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="6c2f" class="nz ks it nv b gy oa ob l oc od">if at &gt; width(od) || at &lt; 1<br/>throw(BoundsError("Merge position is not an index on this OddFrame!"))<br/>        end</span></pre><p id="4c88" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们将需要在随后的for循环中使用enumerate()方法来枚举我们的索引，</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="1f2b" class="nz ks it nv b gy oa ob l oc od">for (n, col) in enumerate(od.labels)</span><span id="d3a8" class="nz ks it nv b gy oe ob l oc od">end</span></pre><p id="07ee" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我想到了，我们甚至真的不需要od.labels，我们可以只使用我们的od的宽度()。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="ed59" class="nz ks it nv b gy oa ob l oc od">for n in 1:width(od)</span></pre><p id="926f" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我将有一个嵌套的for循环，如果值等于at，它将填充第二个Oddframe的对。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="8a50" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractMutableOddFrame,<br/>        od2::AbstractOddFrame; at::Int64 = width(od))<br/>        if at &gt; width(od) || at &lt; 1<br/>                throw(BoundsError("Merge position is not an index on this OddFrame!"))<br/>        end<br/>        pairs = []<br/>        for n in 1:width(od)<br/>                if n == at<br/>                        for col in width(od2)<br/>                                push!(pairs, )<br/>                        end<br/>                end<br/>                push!(pairs, od.labels[n], od.columns[n])<br/>        end<br/>end</span></pre><p id="887e" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在让我快速总结一下这个函数:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="fa36" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractOddFrame,<br/>        od2::AbstractOddFrame; at::Int64 = width(od))<br/>        if at &gt; width(od) || at &lt; 1<br/>                throw(BoundsError("Merge position is not an index on this OddFrame!"))<br/>        end<br/>        pairs = []<br/>        for n in 1:width(od)<br/>                if n == at<br/>                        for n in 1:width(od2)<br/>                                push!(pairs, od2.labels[n] =&gt; od2.columns[n])<br/>                        end<br/>                end<br/>                push!(pairs, od.labels[n] =&gt; od.columns[n])<br/>        end<br/>        return(OddFrame(pairs))<br/>end</span></pre><p id="1b8c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我还意识到不可变和可变类型都可以通过这一点，所以我改变了一点。现在，让我们打开一个笔记本，尝试这段代码。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="8403" class="nz ks it nv b gy oa ob l oc od">include("../src/OddFrames.jl")<br/>using Main.OddFrames</span><span id="ba6f" class="nz ks it nv b gy oe ob l oc od">arr = [5, 10, 15, 20, 25]<br/>od = OddFrame(:A =&gt; arr, :B =&gt; arr)<br/>od2 = OddFrame(:Z =&gt; arr, :B =&gt; arr)<br/></span><span id="797c" class="nz ks it nv b gy oe ob l oc od">od3 = Main.OddFrames.merge(od, od2)</span><span id="b766" class="nz ks it nv b gy oe ob l oc od">Column names may not be duplicated!<br/><br/>Stacktrace:<br/> [1] (::Main.OddFrames.var"#name_check#75")(labels::Vector{Symbol})<br/>   @ Main.OddFrames ~/dev/OddFrames.jl/src/type/frame.jl:125</span></pre><p id="c936" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">在未来，我认为这可能是有意义的改变，只是用一个数字或什么来修改标签，然而这只是一个简单的用法错误，我在我的OddFrames上使用了相同的符号两列。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="b128" class="nz ks it nv b gy oa ob l oc od">od2 = OddFrame(:Z =&gt; arr, :W =&gt; arr)</span><span id="b2af" class="nz ks it nv b gy oe ob l oc od">od3 = Main.OddFrames.merge(od, od2)</span><span id="dd5c" class="nz ks it nv b gy oe ob l oc od">UndefVarError: coldata not defined</span></pre><blockquote class="of"><p id="f1aa" class="og oh it bd oi oj ok ol om on oo me dk translated">我的天啊。</p></blockquote><p id="2201" class="pw-post-body-paragraph lj lk it ll b lm op kd lo lp oq kg lr ls or lu lv lw os ly lz ma ot mc md me im bi translated">被调用的构造函数似乎过时了，因为现在coldata只在打印头时被引用，数组类型用于保存数组。很可能我们在这里调用OddFrame(::Array{Pair})而不是调用OddFrame(::Pair…)，这并不是一件坏事，只是对于我正在开发的这个版本，我主要关注的是保持一个构造函数最新，直到API相对健壮。让我们继续看一看产生这个错误的构造函数:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="9912" class="nz ks it nv b gy oa ob l oc od">function OddFrame(p::AbstractVector)<br/>                # Labels/Columns<br/>                labels, columns = map(x-&gt;x[1], p), map(x-&gt;x[2], p)<br/>                length_check(columns)<br/>                name_check(labels)<br/>                types = [typeof(x[1]) for x in columns]<br/>                # Head<br/>                head(x::Int64) = _head(labels, columns, types, x)<br/>                head() = _head(labels, columns, types, 5)<br/>                # Drop<br/>                drop(x) = _drop(x, columns)<br/>                drop(x::Symbol) = _drop(x, labels, columns, coldata)<br/>                drop(x::String) = _drop(Symbol(x), labels, columns, coldata)<br/>                dropna() = _dropna(columns)<br/>                dtype(x::Symbol) = typeof(coldata[findall(x-&gt;x == x,<br/>                                                labels)[1]][1])<br/>                dtype(x::Symbol, y::Type) = _dtype(columns[findall(x-&gt;x == x,<br/>                 labels)[1]], y)<br/>                # type<br/>                new(labels, columns, coldata, head, drop, dropna, dtype);<br/>        end</span></pre><blockquote class="of"><p id="350f" class="og oh it bd oi oj ok ol om on oo me dk translated">坚持住。</p></blockquote><p id="9571" class="pw-post-body-paragraph lj lk it ll b lm op kd lo lp oq kg lr ls or lu lv lw os ly lz ma ot mc md me im bi translated">我真的这么生气吗？所以这很奇怪。您可能已经注意到，在我展示的第一个构造函数中有一个TODO，</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="0d3f" class="nz ks it nv b gy oa ob l oc od"># TODO Would be nice to combine these loops:<br/>                labels  = [x[1] for x in p]<br/>                columns = [x[2] for x in p]</span></pre><p id="b4eb" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">虽然在这个构造函数中可能没有做到这一点，但我认为这个map()语法更好:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="a145" class="nz ks it nv b gy oa ob l oc od">labels, columns = map(x-&gt;x[1], p), map(x-&gt;x[2], p)</span></pre><p id="5b53" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">然而，这种语法有一个问题——它将返回一个元组，因为map()将保留这些类型，所以我们需要将其更改为其他构造函数所具有的类型。最后，我将更改真正导致我们错误的东西，即new()调用:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="5848" class="nz ks it nv b gy oa ob l oc od">new(labels, columns, coldata, head, drop, dropna, dtype);</span><span id="bf48" class="nz ks it nv b gy oe ob l oc od">new(labels, columns, types, head, drop, dropna, dtype);</span></pre><p id="ee81" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我可能想做的另一件事是提取更多的这些构造函数，在这一点上重复这么多行是没有意义的，函数定义当然可以从这些构造函数中提取——但是现在，让我们回来测试一下！</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="95f1" class="nz ks it nv b gy oa ob l oc od">od3 = Main.OddFrames.merge(od, od2)</span><span id="ae00" class="nz ks it nv b gy oe ob l oc od">OddFrame([:A, :Z, :W, :B], Any[[5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25]], DataType[Int64, Int64, Int64, Int64], Main.OddFrames.var"#head#66"{Vector{DataType}, Vector{Vector{Int64}}, Vector{Symbol}}(DataType[Int64, Int64, Int64, Int64], [[5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25]], [:A, :Z, :W, :B]), Main.OddFrames.var"#drop#67"{Vector{Vector{Int64}}, Vector{Symbol}}([[5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25]], [:A, :Z, :W, :B]), Main.OddFrames.var"#dropna#68"{Vector{Vector{Int64}}}([[5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25]]), Main.OddFrames.var"#dtype#69"{Vector{Vector{Int64}}, Vector{Symbol}}([[5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25]], [:A, :Z, :W, :B]), #undef)</span></pre><p id="d72b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">列表底部的未定义是因为合并！()函数尚未在此构造函数中定义。现在让我们来看看这个奇怪的框架:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="8a1c" class="nz ks it nv b gy oa ob l oc od">od3.head()</span></pre><figure class="nq nr ns nt gt ov gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi ou"><img src="../Images/467edd8a145b8bfc6e65f87b1e36ece5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*994KOWONyCrlYOhDSom2KQ.png"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="of"><p id="fe2c" class="og oh it bd oi oj ok ol om on oo me dk translated">嘿，成功了！</p></blockquote><p id="df09" class="pw-post-body-paragraph lj lk it ll b lm op kd lo lp oq kg lr ls or lu lv lw os ly lz ma ot mc md me im bi translated">现在让我们通过在索引1处合并来检查at关键字参数:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="b413" class="nz ks it nv b gy oa ob l oc od">od3 = Main.OddFrames.merge(od, od2, at = 1)<br/>od3.head()</span></pre><figure class="nq nr ns nt gt ov gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi pf"><img src="../Images/dd717bc3a3c42eff5a657ec816511365.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fxp3mcipUyVCK2mfTgopwA.png"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">(图片由作者提供)</p></figure><p id="257a" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">然而，我们需要做一点小小的调整，这真的很简单。在merge()方法中，我们需要给at参数加1，使它的宽度为OddFrame + 1，因为在第一个示例中，现在它将它们全部放在索引2处:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="ece2" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractOddFrame,<br/>        od2::AbstractOddFrame; at::Int64 = width(od) + 1)</span></pre><p id="f474" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">让我们快速复制这个函数并稍微修改一下，以便为at关键字参数提供调度:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="da52" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractOddFrame,<br/>        od2::AbstractOddFrame; at::Symbol = od.labels[width(od)])<br/>        pairs = []<br/>        for n in 1:width(od)<br/>                if n == at<br/>                        for n in 1:width(od2)<br/>                                push!(pairs, od2.labels[n] =&gt; od2.columns[n])<br/>                        end<br/>                end<br/>                push!(pairs, od.labels[n] =&gt; od.columns[n])<br/>        end<br/>        return(OddFrame(pairs))<br/>end</span></pre><p id="1422" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们只需要将条件改为询问labels[n]是否等于at:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="1372" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractOddFrame,<br/>        od2::AbstractOddFrame; at::Symbol = od.labels[width(od)])<br/>        pairs = []<br/>        for n in 1:width(od)<br/>                if od.labels[n] == at<br/>                        for n in 1:width(od2)<br/>                                push!(pairs, od2.labels[n] =&gt; od2.columns[n])<br/>                        end<br/>                end<br/>                push!(pairs, od.labels[n] =&gt; od.columns[n])<br/>        end<br/>        return(OddFrame(pairs))<br/>end</span></pre><h1 id="b44a" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">变异函数</h1><p id="88e7" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">现在是艰难的时候了。我们需要用多个调度调用来创建一个类似的成员函数来合并我们的OddFrames。这是备忘单:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="f467" class="nz ks it nv b gy oa ob l oc od">merge!(od::OddFrame; at::Symbol = :end) = _merge!(labels,<br/>                columns, od, at)<br/>merge!(x::Array; at::Symbol = :end) = _merge!(labels,<br/>                columns, od, at)<br/>merge_defi = length(labels)<br/>merge!(od::OddFrame; at::Int64 = 0) = _merge!(labels,<br/>                columns, od, at)<br/>merge!(x::Array; at::Int64 = 0) = _merge!(labels,<br/>                columns, od, at)</span></pre><p id="901a" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我们基本上需要为每次做函数_merge！()上面叫。因为关键字参数是由我们的成员函数OddFrame.merge处理的！()，我们可能应该对at使用位置参数，这样更快更容易。我在这里也改变了我的想法，虽然我们对符号使用了dispatch，上次也是这样，但这次我们只是将值设置为等于labels数组中给定符号的索引。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="7770" class="nz ks it nv b gy oa ob l oc od">merge!(od::OddFrame; at::Any = 0) = _merge!(labels,<br/>                columns, od, at)<br/>merge!(x::Array; at::Any = 0) = _merge!(labels,<br/>                columns, x, at)</span></pre><p id="243c" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我在最初的调用中也犯了一些愚蠢的错误，我用这些替换了它们。因此，以下是匹配方法:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="ee60" class="nz ks it nv b gy oa ob l oc od">function _merge!(labels::Array{Symbol}, columns::Array{Any},<br/>        od::AbstractOddFrame, at::Any)</span><span id="6cb3" class="nz ks it nv b gy oe ob l oc od">end<br/>function _merge!(labels::Array{Symbol}, columns::Array{Any},<br/>        x::Array, at::Any)</span><span id="588f" class="nz ks it nv b gy oe ob l oc od">end</span></pre><p id="a349" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">第一个更难，因为它需要我们遍历整个OddFrame，所以让我们先来看看数组版本。我要做的第一件事是确保我们的at参数是一个整数。我们将使用findall()获取该元素的位置，如果它是:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="8ae1" class="nz ks it nv b gy oa ob l oc od">if typeof(at) == Symbol<br/>    at = findall(x-&gt;x==at, labels)[1]<br/>end</span></pre><p id="33ec" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我还将抛出length_check()，如果数组的维数不同，这个函数将抛出:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="1582" class="nz ks it nv b gy oa ob l oc od">length_check([x, columns[1])</span></pre><p id="0ec3" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我们将使用大量的推力！().如果你想阅读关于推的完整指南，推在朱莉娅中是相当重要的！()，以及这种非常通用的方法的所有细微差别，我实际上已经写了一整篇文章，您可以在这里阅读:</p><div class="mk ml gp gr mm mn"><a rel="noopener follow" target="_blank" href="/everything-you-need-to-know-about-push-in-julia-1f01891f1c0a"><div class="mo ab fo"><div class="mp ab mq cl cj mr"><h2 class="bd jd gy z fp ms fr fs mt fu fw jc bi translated">关于Push你需要知道的一切！在朱莉娅</h2><div class="mu l"><h3 class="bd b gy z fp ms fr fs mt fu fw dk translated">用力！()方法是你需要了解的Julia基础的重要部分。让我们来看看它能做什么。</h3></div><div class="mv l"><p class="bd b dl z fp ms fr fs mt fu fw dk translated">towardsdatascience.com</p></div></div><div class="mw l"><div class="pg l my mz na mw nb nc mn"/></div></div></a></div><p id="809b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">如果我没有一个想法的话，接下来的部分会非常困难。我将扩展一些Julia的基本方法来处理一些我需要的语法。另一种方法是在将来我需要的时候再做，这可能会很多，所以我认为这肯定是一个好主意。我要创造一个新的推动！()变异方法。</p><p id="39e4" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">这里的问题是，由于我们处于突变模式，我们必须改变这些类型。否则，该函数将需要一个适当的返回——这是我们不想要的，因为它只是为了改变类型本身。这就是我在讨论允许程序员更容易地管理不变性和可变性时所讨论的，这是该包的一个关键焦点——因此，重要的是，无论何时某个东西应该变异，它都应该变异，无论何时它不应该变异，它都不应该变异。将来，很可能大多数可变版本的方法，比如我们前面写的那个，将会使用一个又一个副本。目前，我的重点是获得一个足够好的内核来考虑这个工作接口，实际上我们已经非常接近了！</p><p id="d748" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我实际上为此创建了一个新文件，该文件中所有代码的重点是扩展基本Julia类型的功能，这是该包的另一个关键特性OddFrame中没有意外和专有的构造数据类型，只有Julian数据结构。因为我们可以扩展它们中的任何一个来使用我们的方法，所以真的没有必要创建新的类型。我做的文件叫<code class="fe ph pi pj nv b">interface/basetools.jl</code>。我添加的第一个方法将是一个新的推送！()绑定，它将接受一个iterable、一个值和一个at关键字参数。这样，如果我想添加at = _，它总是在那里，但不会干扰定期推送！()，因此我可以导出它。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="bf4c" class="nz ks it nv b gy oa ob l oc od">function push!(iter::AbstractVector, val::Any; at::Int64 = length(iter))</span></pre><p id="0200" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我将按范围索引iter向量，并获取索引前后的所有值。我将对索引后面的值做同样的处理:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="13a0" class="nz ks it nv b gy oa ob l oc od">begin_vec = iter[1:at - 1]<br/>n_vec = iter[at:length(iter)]</span></pre><p id="ceb4" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我们将使用deleteat清除数组！()，这样我们就可以推了！()这些值随后返回。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="5bed" class="nz ks it nv b gy oa ob l oc od"># Clears Array<br/>    deleteat!(iter, 1:length(iter))</span></pre><p id="e231" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">然后，最后:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="a7c2" class="nz ks it nv b gy oa ob l oc od">[push!(iter, v) for v in begin_vec]<br/>push!(iter, val)<br/>[push!(iter, v) for v in n_vec]</span></pre><p id="508b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">总的来说，</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="1d1f" class="nz ks it nv b gy oa ob l oc od">import Base: push!</span><span id="445a" class="nz ks it nv b gy oe ob l oc od">function push!(iter::AbstractVector, val::Any; at::Int64 = length(iter))<br/>    begin_vec = iter[1:at - 1]<br/>    n_vec = iter[at:length(iter)]<br/>    # Clears Array<br/>    deleteat!(iter, 1:length(iter))<br/>    [push!(iter, v) for v in begin_vec]<br/>    push!(iter, val)<br/>    [push!(iter, v) for v in n_vec]<br/>    iter<br/>end</span></pre><p id="c8f9" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在让我们回到我们的合并！()函数这其实是为了和简单地使用push！()将数组的值放入各自的索引中。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="dec7" class="nz ks it nv b gy oa ob l oc od">function _merge!(labels::Array{Symbol}, columns::Array{Any},<br/>        x::Array, at::Any)<br/>        if typeof(at) == Symbol<br/>                at = findall(x-&gt;x==at, labels)[1]<br/>        end<br/>        length_check([x, columns[1]])<br/>        push!(labels, Symbol(at), at = at)<br/>        push!(columns, x, at = at)<br/>end</span></pre><blockquote class="of"><p id="4f70" class="og oh it bd oi oj ok ol om on oo me dk translated">简单。</p></blockquote><p id="ffe3" class="pw-post-body-paragraph lj lk it ll b lm op kd lo lp oq kg lr ls or lu lv lw os ly lz ma ot mc md me im bi translated">最后，我们只需要为OddFrame编写相同的代码。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="4df6" class="nz ks it nv b gy oa ob l oc od">function _merge!(labels::Array{Symbol}, columns::Array{Any},<br/>        od::AbstractOddFrame, at::Any)<br/>        if typeof(at) == Symbol<br/>                at = findall(x-&gt;x==at, labels)[1]<br/>        end<br/>        for (n, val) in enumerate(names(od::AbstractOddFrame))<br/>                push!(labels, val, at = at)<br/>                push!(columns, od[val], at = at)<br/>                at += 1<br/>        end<br/>end</span></pre><p id="6f3f" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">这里很容易理解，我们只是迭代地推进，并在每个循环中添加at。我们使用names(od)，这只是一个绑定到od.labels的方法，然后我们使用名称进行索引，我们通过循环来获取列的数据。然而，现在我意识到我搞砸了一件事，我忘记了类型数组！然而，一旦我们完成这两个功能，这将是一个快速而简单的修复。我想我有点搞混了，因为非变异函数不需要类型数组，因为它通过调用构造函数返回。</p><blockquote class="of"><p id="4317" class="og oh it bd oi oj pk pl pm pn po me dk translated">我想现在是时候验证一下了。</p></blockquote><pre class="pp pq pr ps pt nu nv nw nx aw ny bi"><span id="13e7" class="nz ks it nv b gy oa ob l oc od">include("../src/OddFrames.jl")</span><span id="b8ed" class="nz ks it nv b gy oe ob l oc od">LoadError: syntax: invalid iteration specification<br/>in expression starting at /home/emmac/dev/OddFrames.jl/src/type/member_func.jl:79<br/>in expression starting at /home/emmac/dev/OddFrames.jl/src/type/frame.jl:3<br/>in expression starting at /home/emmac/dev/OddFrames.jl/src/OddFrames.jl:1</span></pre><p id="0efb" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我的天啊。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="eb0f" class="nz ks it nv b gy oa ob l oc od">for (n, val) in enumerate(names(od::AbstractOddFrame))</span></pre><p id="a01f" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">为什么我把铅字放在那里？</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="0a33" class="nz ks it nv b gy oa ob l oc od">include("../src/OddFrames.jl")<br/>od.merge!(arr)</span><span id="6533" class="nz ks it nv b gy oe ob l oc od">MethodError: no method matching _merge!(::Vector{Symbol}, ::Vector{Vector{Int64}}, ::Vector{Int64}, ::Int64)<br/>Closest candidates are:<br/>  _merge!(::Array{Symbol}, ::Array{Any}, ::Array, ::Any) at ~/dev/OddFrames.jl/src/type/member_func.jl:85</span></pre><p id="d0d2" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">噢，向量。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="2f31" class="nz ks it nv b gy oa ob l oc od">LoadError: UndefVarError: Vectoor not defined<br/>in expression starting at /home/emmac/dev/OddFrames.jl/src/type/member_func.jl:74</span></pre><blockquote class="pu pv pw"><p id="a939" class="lj lk px ll b lm mf kd lo lp mg kg lr py mh lu lv pz mi ly lz qa mj mc md me im bi translated">我讨厌这里。</p></blockquote><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="8e84" class="nz ks it nv b gy oa ob l oc od">od.merge!(arr)<br/>BoundsError: attempt to access 2-element Vector{Symbol} at index [0:2]</span></pre><p id="3442" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我想我可能不小心把默认值设置为零了…</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="c2e6" class="nz ks it nv b gy oa ob l oc od"># Merge<br/>merge!(od::OddFrame; at::Any = 0) = _merge!(labels,<br/>    columns, od, at)<br/> merge!(x::Array; at::Any = 0) = _merge!(labels,<br/>                columns, x, at)</span></pre><p id="f187" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我做到了。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="a698" class="nz ks it nv b gy oa ob l oc od">od.merge!(arr, at = 1)<br/>3-element Vector{Vector{Int64}}:<br/> [5, 10, 15, 20, 25]<br/> [5, 10, 15, 20, 25]<br/> [5, 10, 15, 20, 25]</span></pre><blockquote class="of"><p id="c566" class="og oh it bd oi oj ok ol om on oo me dk translated">嘿！</p></blockquote><pre class="pp pq pr ps pt nu nv nw nx aw ny bi"><span id="08dc" class="nz ks it nv b gy oa ob l oc od">od.head()<br/>[[5, 10, 15, 20, 25], [5, 10, 15, 20, 25], [5, 10, 15, 20, 25]]DataType[Int64, Int64]</span><span id="3eb8" class="nz ks it nv b gy oe ob l oc od">BoundsError: attempt to access 2-element Vector{Any} at index [3]</span></pre><p id="1e0d" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">为什么会这样？类型数组没有新元素，因此每当我们试图访问对应于新标签的元素时，它都会得到一个错误。您可以看到head函数当前打印数据，有三列，但只有两种类型。</p><h1 id="0bbe" class="kr ks it bd kt ku kv kw kx ky kz la lb ki lc kj ld kl le km lf ko lg kp lh li bi translated">添加类型</h1><p id="fe2e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这里我不打算讲太多的细节，但是我们将把类型作为参数添加到方法中！()函数，并以与之前相同的方式推送，并在method()函数中添加简单的调用。让我们从方法函数开始，我也将继续，从另一个函数中复制代码，将at转换为数字。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="822f" class="nz ks it nv b gy oa ob l oc od">function merge(od::AbstractOddFrame,<br/>        od2::AbstractOddFrame; at::Any = width(od) + 1)<br/>        if typeof(at) == Symbol<br/>                at = findall(x-&gt;x==at, labels)[1]<br/>        end<br/>        if at &gt; width(od) || at &lt; 1<br/>                throw(BoundsError("Merge position is not an index on this OddFrame!"))<br/>        end<br/>        pairs = []<br/>        for n in 1:width(od)<br/>                if n == at<br/>                        for n in 1:width(od2)<br/>                                push!(pairs, od2.labels[n] =&gt; od2.columns[n])<br/>                        end<br/>                end<br/>                push!(pairs, od.labels[n] =&gt; od.columns[n])<br/>        end<br/>        return(OddFrame(pairs))<br/>end</span></pre><p id="ec29" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">我也刚刚意识到，在这里我们的类型被照顾，我完全忘记了。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="3188" class="nz ks it nv b gy oa ob l oc od">function _merge!(labels::Vector{Symbol}, types::AbstractVector,<br/>         columns::AbstractVector, od::AbstractOddFrame, at::Any)<br/>        if typeof(at) == Symbol<br/>                at = findall(x-&gt;x==at, labels)[1]<br/>        end<br/>        for val in names(od)<br/>                push!(labels, val, at = at)<br/>                push!(columns, od[val], at = at)<br/>                push!(types, od.dtype(val))<br/>                at += 1<br/>        end<br/>end</span></pre><p id="1751" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">哦，我意识到我是在毫无理由地列举…方便地调用你自己的函数使工作花费更少的时间感觉真好。</p><blockquote class="of"><p id="148d" class="og oh it bd oi oj pk pl pm pn po me dk translated">每次都令人满意。</p></blockquote><p id="70e2" class="pw-post-body-paragraph lj lk it ll b lm op kd lo lp oq kg lr ls or lu lv lw os ly lz ma ot mc md me im bi translated">现在，我们最后修改内部构造函数中的调用:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="b717" class="nz ks it nv b gy oa ob l oc od"># Merge<br/>merge!(od::OddFrame; at::Any = 0) = _merge!(labels, types,<br/>                columns, od, at)<br/>merge!(x::Array; at::Any = 0) = _merge!(labels, types,<br/>                columns, x, at)</span></pre><p id="ab9b" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在让我们最终尝试一下吧！</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="6208" class="nz ks it nv b gy oa ob l oc od">od.merge!(arr, at = 1)<br/>3-element Vector{DataType}:<br/> Int64<br/> Int64<br/> Int64</span><span id="4ab0" class="nz ks it nv b gy oe ob l oc od">od.head()</span></pre><figure class="nq nr ns nt gt ov gh gi paragraph-image"><div role="button" tabindex="0" class="ow ox di oy bf oz"><div class="gh gi qb"><img src="../Images/13577379e51544f437d96072a6bc018e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxndg86LIsYm44CkHLS3Gg.png"/></div></div><p class="pb pc gj gh gi pd pe bd b be z dk translated">(图片由作者提供)</p></figure><blockquote class="of"><p id="ee9a" class="og oh it bd oi oj ok ol om on oo me dk translated">太美了。</p></blockquote><h1 id="d488" class="kr ks it bd kt ku kv kw kx ky kz la lb ki qc kj ld kl qd km lf ko qe kp lh li bi translated">很酷的急件</h1><p id="46f4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在完成这些整合之前，我还想做一些很酷的事情。第一个是添加一个新的dispatch，它只是+操作符下的merge函数的别名。这段代码将进入methods.jl。</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="dc03" class="nz ks it nv b gy oa ob l oc od">+(od::AbstractOddFrame, od2::AbstractOddFrame) = merge(od, do2)</span></pre><p id="4060" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">当然，必须将这些添加到输入中:</p><pre class="nq nr ns nt gt nu nv nw nx aw ny bi"><span id="b9eb" class="nz ks it nv b gy oa ob l oc od">import Base: show, size, length, +, +=, -, -=</span></pre><p id="0506" class="pw-post-body-paragraph lj lk it ll b lm mf kd lo lp mg kg lr ls mh lu lv lw mi ly lz ma mj mc md me im bi translated">现在我们可以在奇数帧上使用<code class="fe ph pi pj nv b">+</code>和<code class="fe ph pi pj nv b">-</code>。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="2db3" class="kr ks it bd kt ku nl kw kx ky nm la lb ki nn kj ld kl no km lf ko np kp lh li bi translated">结论</h1><p id="d3bc" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">OddFrames项目进展非常顺利，我认为它也有一些非常酷的特性。我发现特别酷的是范式性质与奇怪框架的可变性相一致。虽然今天编程的某些部分有点疯狂，但可能大部分是在我们写那个推送的时候！()方法，我认为该基地变得非常有前途，我真的很高兴能把它的其余部分建设好！谢谢你看我的文章，它对我来说意味着整个世界！</p></div></div>    
</body>
</html>