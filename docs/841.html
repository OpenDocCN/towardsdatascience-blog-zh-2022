<html>
<head>
<title>A Poetic Apology</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">诗意的道歉</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-poetic-apology-71a41db4ecce#2022-01-31">https://towardsdatascience.com/a-poetic-apology-71a41db4ecce#2022-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="901a" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">诗意的道歉</h1></div><div class=""><h2 id="1025" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">或者为什么要用诗歌来管理Python的依赖性</h2></div><p id="3b54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你曾经花时间尝试编写一个Python应用程序，你可能在某个时候体验过Python臭名昭著的依赖地狱。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d3a0d553eda348da69287aa270b2fa06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QpdBM516FvHCha1B67-Yw.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">图片由<a class="ae lr" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lr" href="https://unsplash.com/@alinnnaaaa" rel="noopener ugc nofollow" target="_blank"> Alina Grubnya </a> k拍摄</p></figure><p id="56d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，在你(和我们所有人)写作的时候，有一些很好的解决痛苦纠结的方法，上面的图片生动地描述了这些方法。事实上，您很可能已经知道，如果您想要针对多个Python版本进行开发，您可以很容易地使用<a class="ae lr" href="https://github.com/pyenv/pyenv" rel="noopener ugc nofollow" target="_blank"> pyenv </a>来解开您扭曲的环境。您可能还知道，如果您碰巧同时处理多个具有冲突依赖关系的项目，那么您可以使用<em class="ls">虚拟环境</em>来隔离冲突的库。在本文中，我们将介绍另一个工具，<a class="ae lr" href="https://github.com/python-poetry/poetry" rel="noopener ugc nofollow" target="_blank">poems</a>，并讨论为什么您应该将它添加到您自己的工具包中。</p><h1 id="ec48" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">问题是</h1><p id="aa6e" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">想象一下，在一个孤独的夜晚，您决定启动一个简单的虚拟Python项目，准确地说是名为<code class="fe mq mr ms mt b">foo</code>，其结构如下</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="b90f" class="my lu iq mt b gy mz na l nb nc">├── foo<br/>│   ├── foo<br/>│   │   ├── bar<br/>│   │   │   └── data.py<br/>│   │   └── constants.py<br/>│   └── README.md</span></pre><p id="53a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这不是您的第一个Python项目，并且您希望避免花费更多的时间来修复您的系统和项目模块之间的不兼容性，您努力地从您的shell中用</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="e565" class="my lu iq mt b gy mz na l nb nc">$&gt; python -m venv ~/Desktop/venv/foo-venv</span></pre><p id="1d75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并在新创建的项目中激活它</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="29ad" class="my lu iq mt b gy mz na l nb nc">$&gt; source ~/Desktop/venv/foo-venv/bin/activate</span></pre><p id="bbab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">配备了一个隔离的环境，您成功地开始安装无处不在的熊猫数据库。为了实现这一点，你使用Python事实上的包管理器<code class="fe mq mr ms mt b">pip</code>,并小心地固定库版本以确保可复制性</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="221a" class="my lu iq mt b gy mz na l nb nc">$&gt; pip install pandas<strong class="mt ir">==</strong>0.25.3</span></pre><p id="9b07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于您在进行探索性数据分析方面有点懒惰，您还安装了漂亮的<code class="fe mq mr ms mt b">pandas-profiling</code>模块来帮助您完成这项繁琐的工作</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9abc" class="my lu iq mt b gy mz na l nb nc">$&gt; pip install pandas-profiling<strong class="mt ir">==</strong>2.5.0</span></pre><p id="fcd6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在所有这些调情之后，您最终开始编码(假设将下面几行添加到<code class="fe mq mr ms mt b">data.py</code>文件中，事实上，可以这样称呼它)</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="df40" class="my lu iq mt b gy mz na l nb nc"><strong class="mt ir">import</strong> pandas <strong class="mt ir">as</strong> pd<br/><strong class="mt ir">from</strong> pandas_profiling <strong class="mt ir">import</strong> ProfileReport<br/>df<strong class="mt ir">=</strong>pd.DataFrame([['a',1],['b',None]],columns<strong class="mt ir">=</strong>['category', 'value'])<br/>df['category']<strong class="mt ir">=</strong>df['category'].astype('category')<br/><strong class="mt ir">if</strong> __name__<strong class="mt ir">==</strong>'__main__':ProfileReport(df).to_file('foo.html')</span></pre><p id="a578" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于您滥用<code class="fe mq mr ms mt b">print</code>语句进行调试的日子已经一去不复返了，您安装了漂亮而方便的<a class="ae lr" href="https://github.com/pdbpp/pdbpp" rel="noopener ugc nofollow" target="_blank"> pdbpp </a>库来检查这些代码行是否如预期的那样工作</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="6343" class="my lu iq mt b gy mz na l nb nc">$&gt; pip install pdbpp<strong class="mt ir">==</strong>0.10.2</span></pre><p id="ac6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并使用<code class="fe mq mr ms mt b">python -m pdb -cc data.py</code>在<em class="ls">事后调试模式</em>下运行您的代码。</p><p id="d4b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">满意于干净的运行，您现在意识到为了发布您的华丽的应用程序而不落入“在我的机器上工作”的陷阱，您需要一种方法来收集所有的依赖项。快速的Google搜索会显示pip的<code class="fe mq mr ms mt b">freeze</code>子命令允许通过下面的咒语将当前的环境包记录到一个<code class="fe mq mr ms mt b">requirements.txt</code>文件中</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="b3f9" class="my lu iq mt b gy mz na l nb nc">$&gt; pip freeze <strong class="mt ir">&gt;</strong> requirements.txt</span></pre><p id="95e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它允许任何人通过简单地安装所需的依赖项来使用您的项目</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="d0e5" class="my lu iq mt b gy mz na l nb nc">$&gt; pip install -r requirements.txt</span></pre><p id="3f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就在你即将向世界展示你的杰作项目时，你意识到改进的调试模块实际上只供你在开发时使用。有了将冻结的需求分割成单独的生产和开发文件的想法，您可以查看生成的文件，却发现您的应用程序的依赖项的每一个子依赖项都在其中列出，并锁定到一个特定的版本。预见到维护这个庞大列表的噩梦，你卸载了<code class="fe mq mr ms mt b">pdbpp</code>库以确保一个干净的需求文件</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="b604" class="my lu iq mt b gy mz na l nb nc">$&gt; pip uninstall -y pdbpp <strong class="mt ir">&amp;&amp;</strong> pip freeze <strong class="mt ir">&gt;</strong> requirements.txt</span></pre><p id="f750" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，快速浏览一下修改后的需求文件，会发现事情并不像预期的那样:<code class="fe mq mr ms mt b">pdbpp</code>确实被删除了，但是它的依赖项，比如<code class="fe mq mr ms mt b">fancycompleter</code>，仍然被安装。因为这似乎是一个死胡同，所以您选择从零开始，手动创建一个只有生产依赖关系的<code class="fe mq mr ms mt b">requirements.txt</code>文件</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9994" class="my lu iq mt b gy mz na l nb nc">pandas==0.25.3<br/>pandas-profiling==2.5.0</span></pre><p id="3f33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以及等效的开发文件<code class="fe mq mr ms mt b">requirements_dev.txt</code>，仅包含</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="9000" class="my lu iq mt b gy mz na l nb nc">pdbpp==0.10.2</span></pre><p id="cfb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过记录孤立的顶级包，似乎帮助您避开了可怕的Python依赖地狱，这种聪明给您留下了深刻的印象，您决定今天就到此为止，第二天再对您的应用程序进行最后一次测试。</p><p id="2b13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">早上醒来，新闻铺天盖地:熊猫v1终于出来了(才过了十二年！).用令人难以置信的长changelog拖延了几个小时，使你得出结论，你的复杂foo-project肯定会通过更新到全新的版本而获得显著的改进。现在，既然你已经锁定了熊猫的确切版本，你不能简单地运行</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="5f3a" class="my lu iq mt b gy mz na l nb nc">$&gt; pip install -U -r requirements.txt</span></pre><p id="6911" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，你必须执行</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="cd32" class="my lu iq mt b gy mz na l nb nc">$&gt; pip install pandas<strong class="mt ir">==</strong>1.0.0</span></pre><p id="fc57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这导致了一个特别奇怪和混乱的情况:您的终端弹出一个错误</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="31ab" class="my lu iq mt b gy mz na l nb nc">ERROR: pandas-profiling 2.5.0 has requirement pandas==0.25.3, but you'll have pandas 1.0.0 which is incompatible.</span></pre><p id="d28e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe mq mr ms mt b">pandas 1.0.0</code>的安装还是发生了。假设这是一个<code class="fe mq mr ms mt b">pip</code>出错的警告，你相应地更新你的<code class="fe mq mr ms mt b">requirements.txt</code>文件，然后愉快地最后一次运行你的<code class="fe mq mr ms mt b">data.py</code>模块，却发现它抛出了一个神秘的<code class="fe mq mr ms mt b">TypeError</code>。感觉现在被pip明显无法解决依赖性所出卖，您回滚您的更改并坚持使用Pandas(现在)过时的版本。</p><p id="26eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您似乎有一个工作项目，但是I)您不确定恢复Pandas版本是否会破坏您的应用程序的可复制性，ii)代码肯定会看起来更好，iii)睡了一夜好觉之后，您承认您的应用程序的整体功能没有您前一天晚上想象的那么复杂和丰富。为了解决前两个问题，您首先将<code class="fe mq mr ms mt b">black</code>格式化程序添加到您的<code class="fe mq mr ms mt b">requirements_dev.txt</code>中</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="4a9b" class="my lu iq mt b gy mz na l nb nc">black==19.10b0</span></pre><p id="b6fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在您的项目目录中，您用</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8542" class="my lu iq mt b gy mz na l nb nc">$&gt; rm -rf ~/Desktop/venv/foo-venv<br/>$&gt; python -m venv ~/Desktop/venv/foo-venv<br/>$&gt; source ~/Desktop/venv/foo-venv/bin/activate<br/>$&gt; pip install -r requirements_dev.txt<br/>$&gt; pip install -r requirements.txt</span></pre><p id="6115" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你在你的项目根中运行<code class="fe mq mr ms mt b">black</code>(用<code class="fe mq mr ms mt b">black .</code>)，并且对它所做的美化工作非常满意，但是为了遵守Mutt Data的格式风格(这恰好符合你不喜欢把每个单引号都变成双引号的习惯)，你添加了一个<code class="fe mq mr ms mt b">pyproject.toml</code>，告诉<code class="fe mq mr ms mt b">black</code>跳过这种可怕的字符串规范化默认设置</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="a3ea" class="my lu iq mt b gy mz na l nb nc">[tool.black]<br/>skip-string-normalization = <strong class="mt ir">true</strong></span></pre><p id="a8b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码现在看起来很棒，新的事后调试运行表明，在新的(可复制的)环境中，一切似乎都工作得很好。在将代码部署到服务器上或与外界共享之前，唯一要做的事情是避免在代码周围硬编码常量，如报告名称。因此，您决定将下面几行添加到您的<code class="fe mq mr ms mt b">constants.py</code>空模块中</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="7acd" class="my lu iq mt b gy mz na l nb nc">REPORT_FILE <strong class="mt ir">=</strong> 'foo.html'</span></pre><p id="ff1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并修改<code class="fe mq mr ms mt b">data.py</code>从相关父文件中导入该常量</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="094c" class="my lu iq mt b gy mz na l nb nc"><strong class="mt ir">from</strong> ..constants <strong class="mt ir">import</strong> REPORT_FILE</span></pre><p id="5160" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而不幸的是，现在新的<code class="fe mq mr ms mt b">data.py</code>运行显示下一个错误</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="c73e" class="my lu iq mt b gy mz na l nb nc">ImportError: attempted relative import with no known parent package</span></pre><p id="8f71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据无所不知的说法，这是有道理的，因为Python相对导入只在一个包中工作，因此如果你想从一个父目录导入，你应该创建这样的包或者破解<code class="fe mq mr ms mt b">sys.path</code>。作为一个真正的纯粹主义者，你选择了前一条道路，并用以下内容创建了一个<code class="fe mq mr ms mt b">setup.py</code></p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="fe42" class="my lu iq mt b gy mz na l nb nc"><strong class="mt ir">from</strong> setuptools <strong class="mt ir">import</strong> setup</span><span id="f883" class="my lu iq mt b gy nd na l nb nc"><strong class="mt ir">with</strong> open('requirements.txt') <strong class="mt ir">as</strong> f:<br/>    install_requires <strong class="mt ir">=</strong> f.read().splitlines()<br/><strong class="mt ir">with</strong> open('requirements_dev.txt') <strong class="mt ir">as</strong> f:<br/>    extras_dev_requires <strong class="mt ir">=</strong> f.read().splitlines()</span><span id="0dfb" class="my lu iq mt b gy nd na l nb nc">setup(<br/>    name<strong class="mt ir">=</strong>'foo',<br/>    version<strong class="mt ir">=</strong>'0.0.1',<br/>    author<strong class="mt ir">=</strong>'Mutt',<br/>    author_email<strong class="mt ir">=</strong>'info@muttdata.ai',<br/>    install_requires<strong class="mt ir">=</strong>install_requires,<br/>    extras_require<strong class="mt ir">=</strong>{'dev': extras_dev_requires},<br/>    packages<strong class="mt ir">=</strong>['foo'],<br/>)</span></pre><p id="fd1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在一个全新的虚拟环境中，你用<code class="fe mq mr ms mt b">pip install -e .[dev]</code>在可编辑模式下安装你的包，改变<code class="fe mq mr ms mt b">data.py</code>中的导入行来解释包的结构</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="8223" class="my lu iq mt b gy mz na l nb nc"><strong class="mt ir">from</strong> foo.constants <strong class="mt ir">import</strong> REPORT_FILE</span></pre><p id="dfd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祈祷一切最终都顺利…</p><p id="2198" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切都确实(很容易)工作，但不知何故，所有让它工作的跳跃让你感到不安。简短的反思揭示了恐惧浪潮的几个原因:</p><ol class=""><li id="444a" class="ne nf iq kh b ki kj kl km ko ng ks nh kw ni la nj nk nl nm bi translated">因为您计划同时处理多个Python项目，所以隔离是工作流的一个基本部分。虚拟环境确实解决了这个问题，但是激活/停用过程很麻烦并且容易忘记。</li><li id="0bcd" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">隔离项目之间的依赖关系并不能解决项目内部的依赖冲突。适当的依赖解析是任何值得尊敬的包管理器的首要要求，然而<code class="fe mq mr ms mt b">pip</code>直到2020年10月才实现了这个特性。人工保证复杂项目中的依赖一致性是一个死锁。</li><li id="25cb" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">如果你想把你的应用程序/项目作为一个包来安装，你必须在已经有多个需求文件的基础上增加一个<code class="fe mq mr ms mt b">setup.py</code>的开销。但是，您已经阅读了PEPs 517-518，并且想要尝试其中提到的更简单、更安全的构建机制。</li><li id="4964" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">您考虑在不同的机器上尝试您的应用程序，但是意识到它运行Python 3.7，而您的本地机器运行3.8。要将<code class="fe mq mr ms mt b">pyenv</code>用于您的隔离虚拟env，您需要一个额外的插件<a class="ae lr" href="https://github.com/pyenv/pyenv-virtualenv" rel="noopener ugc nofollow" target="_blank"> pyenv-virtualenv </a>，这使得管理venvs更加麻烦。</li><li id="1f20" class="ne nf iq kh b ki nn kl no ko np ks nq kw nr la nj nk nl nm bi translated">您曾短暂地使用过<a class="ae lr" href="https://github.com/pypa/pipenv" rel="noopener ugc nofollow" target="_blank"> Pipenv </a>，它承诺给Python带来其他语言的更成熟的包管理器(如Javascript的<code class="fe mq mr ms mt b">yarn/npm</code>或Rust的<code class="fe mq mr ms mt b">Cargo</code>)令人羡慕的特性，但很快就失望了。Pipenv不仅误导性地宣称自己是Python官方推荐的打包工具(实际上它是为编写应用程序而不是包而设计的)，而且它也没有发布超过一年，并且在创建确保可重复/确定性构建的锁文件时仍然无休止地挂起。</li></ol><p id="a5ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在绝望无助的状态下，你开始疯狂地在网上搜索，看看是否已经有了解决所有这些问题的方法。在众多部分/不完整的候选人中，你终于遇到了一个令人难以置信地让他们全都崩溃的候选人:这就是诗歌。</p><h1 id="cb6c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">解决方案</h1><h1 id="adc4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">安装(带Pipx)</h1><p id="6578" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">诗歌是一个用Python编写的CLI应用程序，所以你可以简单地用<code class="fe mq mr ms mt b">pip install --user poetry</code>安装它。然而，你可能已经安装了或者将要安装其他Python CLI应用程序(例如奇特的PostgreSQL客户端<code class="fe mq mr ms mt b">pgcli</code>或者下载YouTube视频的<code class="fe mq mr ms mt b">youtube-dl</code>)。如果你用你系统的软件包管理器(比如说<code class="fe mq mr ms mt b">apt</code>、<code class="fe mq mr ms mt b">yay</code>或<code class="fe mq mr ms mt b">brew</code>)来安装它们，它们将被安装在一个全局级别，它们的依赖关系可能会发生冲突。你可以为每一个创建单独的venv，但是为了使用它们，你必须首先经历激活环境的麻烦…</p><p id="405e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种恼人的场景，你可以使用<a class="ae lr" href="https://github.com/pipxproject/pipx" rel="noopener ugc nofollow" target="_blank"> pipx </a>，它将在一个隔离的虚拟环境中精确地安装软件包，同时让它们在你的shell中随时可用(也就是将可执行文件添加到你的二进制文件中<code class="fe mq mr ms mt b">$PATH</code>)。除了为全球访问提供CLI应用程序之外，它还可以轻松列出、升级和卸载这些应用程序。要用<code class="fe mq mr ms mt b">pipx</code>安装诗歌，首先要用</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="652d" class="my lu iq mt b gy mz na l nb nc">$&gt; python -m pip install --user pipx<br/>$&gt; python -m pipx ensurepath</span></pre><p id="a6a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后直接做</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="bf48" class="my lu iq mt b gy mz na l nb nc">$&gt; pipx install poetry</span></pre><p id="c7dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢生活在边缘(像我一样)，你可以选择安装一个带<code class="fe mq mr ms mt b">pipx install --pip-args='--pre' poetry</code>的<code class="fe mq mr ms mt b">pre-release</code>版本。</p><h1 id="907e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用</h1><p id="ad93" class="pw-post-body-paragraph kf kg iq kh b ki ml jr kk kl mm ju kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">现在，你已经准备好去尝试诗歌承诺的奇迹了。为此，您用上面的<code class="fe mq mr ms mt b">.py</code>文件创建一个名为<code class="fe mq mr ms mt b">foo-poetry</code>的新文件夹/项目，然后运行<code class="fe mq mr ms mt b">poetry init</code>。一个交互式提示将开始要求您提供关于您的包的基本信息(名称、作者等)，这些信息将用于创建一个<code class="fe mq mr ms mt b">pyproject.toml</code>文件。这基本上是您之前添加到<code class="fe mq mr ms mt b">setup.py</code>中的相同元数据，只有一些微小的变化</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="dc41" class="my lu iq mt b gy mz na l nb nc">This command will guide you through creating your pyproject.toml config.</span><span id="525b" class="my lu iq mt b gy nd na l nb nc">Package name <strong class="mt ir">[</strong>foo-poetry]:  foo<br/>Version <strong class="mt ir">[</strong>0.1.0]:  0.0.1<br/>Description <strong class="mt ir">[]</strong>:<br/>Author <strong class="mt ir">[</strong>petobens &lt;petobens@yahoo.com&gt;, n to skip]:  Mutt &lt;info@muttdata.ai&gt;<br/>License <strong class="mt ir">[]</strong>:<br/>Compatible Python versions <strong class="mt ir">[</strong>^3.8]:  ~3.7</span><span id="a46d" class="my lu iq mt b gy nd na l nb nc">Would you like to define your main dependencies interactively? <strong class="mt ir">(</strong>yes/no<strong class="mt ir">)</strong> <strong class="mt ir">[</strong>yes<strong class="mt ir">]</strong> no<br/>Would you like to define your development dependencies interactively? <strong class="mt ir">(</strong>yes/no<strong class="mt ir">)</strong> <strong class="mt ir">[</strong>yes<strong class="mt ir">]</strong> no<br/>Generated file</span><span id="bc04" class="my lu iq mt b gy nd na l nb nc"><strong class="mt ir">[</strong>tool.poetry]<br/>name <strong class="mt ir">=</strong> "foo"<br/>version <strong class="mt ir">=</strong> "0.0.1"<br/>description <strong class="mt ir">=</strong> ""<br/>authors <strong class="mt ir">=</strong> <strong class="mt ir">[</strong>"Mutt &lt;info@muttdata.ai&gt;"<strong class="mt ir">]</strong></span><span id="18ae" class="my lu iq mt b gy nd na l nb nc"><strong class="mt ir">[</strong>tool.poetry.dependencies]<br/>python <strong class="mt ir">=</strong> "^3.7"</span><span id="9491" class="my lu iq mt b gy nd na l nb nc"><strong class="mt ir">[</strong>tool.poetry.dev-dependencies]</span><span id="e13d" class="my lu iq mt b gy nd na l nb nc"><strong class="mt ir">[</strong>build-system]<br/>requires <strong class="mt ir">=</strong> <strong class="mt ir">[</strong>"poetry-core&gt;=1.0.0a5"<strong class="mt ir">]</strong><br/>build-backend <strong class="mt ir">=</strong> "poetry.core.masonry.api"<br/></span><span id="438d" class="my lu iq mt b gy nd na l nb nc">Do you confirm generation? <strong class="mt ir">(</strong>yes/no<strong class="mt ir">)</strong> <strong class="mt ir">[</strong>yes<strong class="mt ir">]</strong> yes</span></pre><p id="eefd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要强调的两个相关设置是构建系统和Python版本规范。关于第一种方法，你现在唯一需要知道的是，它使用PEPs 517–518中的标准来定义一种替代方法，在没有<code class="fe mq mr ms mt b">setuptools</code>的情况下从源代码构建一个项目(因此消除了对<code class="fe mq mr ms mt b">setup.py</code>文件的需要)。关于第二个设置，为了理解指定Python版本约束的语法，您应该阅读<a class="ae lr" href="https://python-poetry.org/docs/versions/" rel="noopener ugc nofollow" target="_blank">诗歌版本文档</a>，在那里您会发现脱字符号(^)要求意味着只允许较小的和补丁更新(即我们的应用程序将与Python 3.7和3.8一起工作，但不能与4.0一起工作)。</p><p id="c465" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，您只有一个<code class="fe mq mr ms mt b">TOML</code>文件(您也可以用它来集中您的<code class="fe mq mr ms mt b">black</code>配置)。如何指定依赖关系？简单地跑</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="2b5e" class="my lu iq mt b gy mz na l nb nc">$&gt; poetry add pandas<strong class="mt ir">==</strong>0.25.3</span></pre><p id="a9d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这导致了</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="bc85" class="my lu iq mt b gy mz na l nb nc">Creating virtualenv foo-KLaC03aC-py3.8 <strong class="mt ir">in</strong> /home/pedro/.cache/pypoetry/virtualenvs</span><span id="7d3d" class="my lu iq mt b gy nd na l nb nc">Updating dependencies<br/>Resolving dependencies... <strong class="mt ir">(</strong>0.6s<strong class="mt ir">)</strong></span><span id="3af7" class="my lu iq mt b gy nd na l nb nc">Writing lock file<br/></span><span id="7457" class="my lu iq mt b gy nd na l nb nc">Package operations: 5 installs, 0 updates, 0 removals</span><span id="ccc8" class="my lu iq mt b gy nd na l nb nc">  - Installing six <strong class="mt ir">(</strong>1.15.0<strong class="mt ir">)</strong><br/>  - Installing numpy <strong class="mt ir">(</strong>1.19.1<strong class="mt ir">)</strong><br/>  - Installing python-dateutil <strong class="mt ir">(</strong>2.8.1<strong class="mt ir">)</strong><br/>  - Installing pytz <strong class="mt ir">(</strong>2020.1<strong class="mt ir">)</strong><br/>  - Installing pandas <strong class="mt ir">(</strong>0.25.3<strong class="mt ir">)</strong></span></pre><p id="bd38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，一个初始的<code class="fe mq mr ms mt b">add</code>命令将会I)创建一个虚拟环境，ii)安装所请求的包及其子依赖项，iii)将每个下载的依赖项的确切版本写入到<code class="fe mq mr ms mt b">poetry.lock</code>文件中(您应该将它提交到您的VCS中以加强可复制性),以及iv)将新添加的包添加到<code class="fe mq mr ms mt b">pyproject.toml</code>文件的<code class="fe mq mr ms mt b">tool.poetry.dependencies</code>部分。最后一项还表明，如果您想安装一个新的依赖项，您可以重用<code class="fe mq mr ms mt b">add</code>命令，或者直接在您的<code class="fe mq mr ms mt b">pyproject.toml</code>文件中添加这样一行。例如，如果您现在想要添加<code class="fe mq mr ms mt b">pandas-profiling</code>库，那么您可以修改pyproject，使其具有</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="1728" class="my lu iq mt b gy mz na l nb nc">pandas-profiling = "2.5.0"</span></pre><p id="2b04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于在这个阶段已经存在一个<code class="fe mq mr ms mt b">poetry.lock</code>文件，如果您现在运行<code class="fe mq mr ms mt b">poetry install</code>，那么poems将使用这个锁文件中指定的版本来解析和安装依赖关系(以确保版本的一致性)。然而，由于您手动向<code class="fe mq mr ms mt b">pyproject.toml</code>文件添加了一个新的依赖关系，<code class="fe mq mr ms mt b">install</code>命令将会失败。所以，在这种情况下，你需要运行<code class="fe mq mr ms mt b">poetry update</code>，本质上相当于删除锁文件，再次运行<code class="fe mq mr ms mt b">poetry install</code>。</p><p id="c7df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加一个<code class="fe mq mr ms mt b">development</code>依赖项以类似的方式工作，唯一的警告是在执行<code class="fe mq mr ms mt b">add</code>命令时需要使用<code class="fe mq mr ms mt b">--dev</code>标志</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="5216" class="my lu iq mt b gy mz na l nb nc">$&gt; poetry add pdbpp<strong class="mt ir">==</strong>0.10.2 --dev<br/>$&gt; poetry add black<strong class="mt ir">==</strong>19.10b0 --dev</span></pre><p id="5bd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产生的包将被附加到<code class="fe mq mr ms mt b">tool.poetry.dev-dependencies</code>部分。</p><p id="ab97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然依赖关系已经设置好了，你就可以运行你的代码<code class="fe mq mr ms mt b">data.py</code>文件了</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="36ad" class="my lu iq mt b gy mz na l nb nc">$&gt; poetry run python data.py</span></pre><p id="716d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将在项目的virtualenv中执行命令。或者，您可以简单地通过运行以下命令在活动的venv中生成一个shell</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="0758" class="my lu iq mt b gy mz na l nb nc">$&gt; poetry shell</span></pre><p id="b446" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在假设您想要更新Pandas版本，就像您之前在检查pip无法执行依赖关系解析时所做的那样。为此，您可以像下面这样更新约束</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="533a" class="my lu iq mt b gy mz na l nb nc">$&gt; poetry add pandas<strong class="mt ir">==</strong>1.0.0</span></pre><p id="0ccd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一次正确地失败了，并出现以下错误</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="2cb0" class="my lu iq mt b gy mz na l nb nc">Updating dependencies<br/>Resolving dependencies... <strong class="mt ir">(</strong>0.0s<strong class="mt ir">)</strong></span><span id="7910" class="my lu iq mt b gy nd na l nb nc"><strong class="mt ir">[</strong>SolverProblemError]<br/>Because pandas-profiling <strong class="mt ir">(</strong>2.5.0<strong class="mt ir">)</strong> depends on pandas <strong class="mt ir">(</strong>0.25.3<strong class="mt ir">)</strong><br/> and foo depends on pandas <strong class="mt ir">(</strong>1.0.0<strong class="mt ir">)</strong>, pandas-profiling is forbidden.<br/>So, because foo depends on pandas-profiling <strong class="mt ir">(</strong>2.5.0<strong class="mt ir">)</strong>, version solving failed.</span></pre><p id="32cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，您注意到诗歌似乎解决了您在上一节中列出的最初两个要求(即简单的项目隔离和适当的自动依赖解析)。在你满怀希望之前，你要验证它是否能直接打包你的代码(特别是没有<code class="fe mq mr ms mt b">setup.py</code>)。值得注意的是，这个简单的代码归结为包含了下面一行:<code class="fe mq mr ms mt b">pyproject.toml</code>文件的<code class="fe mq mr ms mt b">tool.poetry</code>部分</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="0942" class="my lu iq mt b gy mz na l nb nc">packages = [{include = "foo"}]</span></pre><p id="2d9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随后执行一个新的<code class="fe mq mr ms mt b">poetry install</code>，默认情况下，它将在可编辑模式下安装项目。</p><p id="c624" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被诗歌的简单易用所激动，你开始怀疑诗歌是否是你一直在寻找的终极工具。它能检查所有的盒子吗？为了最终回答这个问题，您想看看在不同Python版本之间切换是否容易。假设您的本地机器默认使用Python 3.8，那么您随后安装了带有<code class="fe mq mr ms mt b">pyenv install 3.7.7</code>的<code class="fe mq mr ms mt b">3.7.7</code>(由于您将3.7设置为您的应用程序<code class="fe mq mr ms mt b">pyproject.toml</code>的下限，因此安装先前的版本将不会起作用)。为了使这个版本在本地可用，您将一个<code class="fe mq mr ms mt b">.python-version</code>文件添加到您的项目的根目录中，该文件包含一个带有<code class="fe mq mr ms mt b">3.7.7</code>的单行，然后告诉poem创建一个带有该版本的virtualenv并使用它</p><pre class="lc ld le lf gt mu mt mv mw aw mx bi"><span id="6da6" class="my lu iq mt b gy mz na l nb nc">$&gt; poetry env use 3.7</span></pre><p id="be89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你用<code class="fe mq mr ms mt b">poetry env list</code>检查它是否被正确激活，你就用<code class="fe mq mr ms mt b">poetry install</code>安装所有的依赖项，并最终运行你的代码,(不出所料)没有问题地完成。</p><p id="15a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">惊叹于其直观的质朴，你得出结论，诗歌正是你所需要的。事实上，您还不知道这一点，但是您得到的比您期望的要多得多，因为您只触及了特性的表面。你仍然需要发现它可以并行安装软件包，当一切失控时抛出漂亮的彩色异常，与你选择的IDE/编辑器集成(如果那是vim，你可以试试你卑微的仆人的<a class="ae lr" href="https://github.com/petobens/poet-v" rel="noopener ugc nofollow" target="_blank">无耻地处理这件事</a>)，有一个命令可以直接发布一个软件包，除了其他无数的乐趣之外，还计划有一个插件系统来进一步扩展。</p><p id="c494" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">有一点非常清楚:诗歌是明天的Python包管理器。你不妨今天就开始使用它。</strong></p><p id="9067" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有兴趣阅读更多机器学习相关内容，请访问我们公司的<a class="ae lr" href="https://muttdata.ai/blog/" rel="noopener ugc nofollow" target="_blank">博客</a>。我希望你觉得这篇文章有用，至少有点娱乐性。如果你需要帮助找出用数据推动业务的最佳方式，你可以在这里找到我们的公司<a class="ae lr" href="http://muttdata.ai" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a987" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章也被<a class="ae lr" href="https://muttdata.ai/blog/2020/08/21/a-poetic-apology.html" rel="noopener ugc nofollow" target="_blank">发表在</a>Mutt Data的公司博客上。</p></div></div>    
</body>
</html>