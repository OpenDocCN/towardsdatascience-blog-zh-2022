<html>
<head>
<title>Be Gone Boilerplate Code! Master Dataclasses in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">去样板代码！Python中的主数据类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/be-gone-boilerplate-code-master-dataclasses-in-python-d3f302f9a7c4#2022-01-19">https://towardsdatascience.com/be-gone-boilerplate-code-master-dataclasses-in-python-d3f302f9a7c4#2022-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="aa61" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">去样板代码！Python中的主数据类</h1></div><div class=""><h2 id="1ca6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">熟悉一个非常有用的数据容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a309895b5913cda14a8965c8795df8ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80KGHQv3pyS4ICmtlFjHYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><h1 id="8dba" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">您的旅程概述</h1><ol class=""><li id="c08b" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><a class="ae mi" href="#40d7" rel="noopener ugc nofollow">设置舞台</a></li><li id="6ce6" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#63dc" rel="noopener ugc nofollow">什么是数据类？</a></li><li id="bcf4" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#820f" rel="noopener ugc nofollow">创建数据类的实例</a></li><li id="cc53" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#dad6" rel="noopener ugc nofollow">简单验证</a></li><li id="5c0c" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#d594" rel="noopener ugc nofollow">数据类之间相等</a></li><li id="7029" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#c9f4" rel="noopener ugc nofollow">数据类的排序</a></li><li id="89c0" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#766f" rel="noopener ugc nofollow">不可变数据类</a></li><li id="1834" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md me mf mg mh bi translated"><a class="ae mi" href="#2718" rel="noopener ugc nofollow">包装</a></li></ol></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="40d7" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">1 —搭建舞台</h1><p id="d8ba" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">Python有许多数据类型，可以作为其他数据类型的容器。最简单的例子是内置数据类型<code class="fe nn no np nq b">List</code>、<code class="fe nn no np nq b">Tuple</code>、<code class="fe nn no np nq b">Dictionary</code>和<code class="fe nn no np nq b">Set</code>。虽然这些数据类型在某些设置中工作得很好，但在许多设置中却不尽如人意。这对于数据科学家和数据工程师来说并不陌生:</p><ul class=""><li id="bc78" class="lq lr it ls b lt nr lv ns lx nt lz nu mb nv md nw mf mg mh bi translated">使用NumPy数组是因为列表很慢，而且不是为向量运算和线性代数而构建的。</li><li id="9836" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated">你使用熊猫数据框架是因为字典对于数据分析来说不够方便。</li></ul><p id="fd78" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">然而，在数据科学/工程领域之外，还有一些非常有用的数据容器。例子有<em class="oa">命名元组</em>、<em class="oa">数据类</em>和<em class="oa"> Pydantic模型</em>。这些数据容器在数据领域经常被忽略，因为它们不是绝对必要的。人们低估了他们对减少样板代码、获得数据验证和处理数据的帮助。用下面的木工比喻来思考这个问题🔨</p><blockquote class="ob"><p id="99e4" class="oc od it bd oe of og oh oi oj ok md dk translated">可以用螺丝刀的背面敲入钉子。但是，如果有一把锤子躺在周围，等着被使用，你为什么要这样做呢？</p></blockquote><p id="ccc9" class="pw-post-body-paragraph na nb it ls b lt ol ju nc lv om jx nd lx on nf ng lz oo ni nj mb op nl nm md im bi translated">可能在数据科学/数据工程中经常被忽略的更有用的数据结构之一是<strong class="ls iu">数据类</strong>。这是Python生态系统(Python 3.7版及更高版本)的新成员。在这篇博文中，我将告诉你开始在你的项目中使用数据类所需要知道的一切。</p><p id="4e60" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated"><strong class="ls iu">你是视频人吗？我在dataclasses上制作了四个YouTube视频，内容与博客相同。如果你想检查一下，请便！</strong></p><ul class=""><li id="82a4" class="lq lr it ls b lt nr lv ns lx nt lz nu mb nv md nw mf mg mh bi translated"><a class="ae mi" href="https://youtu.be/Yi55fpwcFhA" rel="noopener ugc nofollow" target="_blank">Python中的主数据类第1部分——基本结构和验证</a></li><li id="4d1c" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated"><a class="ae mi" href="https://youtu.be/y9uRbrxDWQE" rel="noopener ugc nofollow" target="_blank">Python第2部分中的主数据类——数据类之间的相等性</a></li><li id="eec5" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated"><a class="ae mi" href="https://youtu.be/myENiF_Zw7Q" rel="noopener ugc nofollow" target="_blank">Python中的主数据类第3部分——数据类的排序</a></li><li id="8cba" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated"><a class="ae mi" href="https://youtu.be/Yi55fpwcFhA" rel="noopener ugc nofollow" target="_blank">Python第4部分中的主数据类—不可变数据类</a></li></ul><p id="f879" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated"><strong class="ls iu">先决条件:</strong>因为数据类本质上是增强的Python类，所以你需要知道Python类的基础。如果您对诸如<em class="oa">抽象</em>、<em class="oa">封装</em>和<em class="oa">多态之类的高级术语感到生疏，也不必感到难过。你不需要任何高级的东西👍</em></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="63dc" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">2-什么是数据类？</h1><p id="43d3" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">一个数据类是一个数据容器，它包含了电池。更确切地说，它是一个已经实现了一些很酷的特性的Python类。通过使用数据类，您将避免编写大量样板代码。Dataclasses为您提供了一种灵活且可预测的方式来存储数据、比较数据和排序数据。</p><p id="056c" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">要开始使用dataclasses，<strong class="ls iu">确保您安装了Python 3.7或更高版本</strong>。您不需要下载第三方库，因为数据类在标准库中。以下是模拟汽车的数据类的最小示例:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="5dc9" class="ou kz it nq b gy ov ow l ox oy">from dataclasses import dataclass</span><span id="a1e1" class="ou kz it nq b gy oz ow l ox oy">@dataclass<br/>class Car:<br/>  """A dataclass that models a car."""<br/>  brand: str<br/>  year: int<br/>  price: float<br/>  used: bool</span></pre><p id="27d2" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">让我们慢慢浏览上面的代码片段:</p><ul class=""><li id="fd8d" class="lq lr it ls b lt nr lv ns lx nt lz nu mb nv md nw mf mg mh bi translated">1 —从<code class="fe nn no np nq b">dataclasses</code>模块导入<code class="fe nn no np nq b">dataclass</code>装饰器。</li><li id="9988" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated">2 —将dataclass装饰器应用于一个名为<code class="fe nn no np nq b">Car</code>的类。</li><li id="fb05" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated">3 —为数据类应该包含的各种数据编写类似<code class="fe nn no np nq b">brand: str</code>的属性。属性名将是<code class="fe nn no np nq b">brand</code>，而<code class="fe nn no np nq b">str</code>表示它应该是一个字符串。这是Python中<em class="oa">类型提示</em>的一个例子。如果你不熟悉，那就看看<a class="ae mi" rel="noopener" target="_blank" href="/modernize-your-sinful-python-code-with-beautiful-type-hints-4e72e98f6bf1">这篇博文</a>。</li></ul><p id="3e06" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">使用上面的代码，您已经表示了一辆具有四个属性<code class="fe nn no np nq b">brand</code>、<code class="fe nn no np nq b">year</code>、<code class="fe nn no np nq b">price</code>和<code class="fe nn no np nq b">used</code>的汽车😃</p><p id="dbd4" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">您创建的只是一个普通的Python类，除了<code class="fe nn no np nq b">dataclass</code>装饰器增加了额外的功能。您是否注意到在类中不需要<code class="fe nn no np nq b">__init__</code>方法？这是<code class="fe nn no np nq b">dataclass</code>装饰器为您修复的事情之一。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="e735" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">3-创建数据类的实例</h1><p id="5b63" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">现在，您将继续使用上一节中的代码，并创建一些汽车实例。要制造两辆汽车，您只需提供必要的属性:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="5704" class="ou kz it nq b gy ov ow l ox oy"># Initiate a BMW car<br/>bmw_car = Car(brand="bmw", year=2016, price=20000, used=False)</span><span id="347f" class="ou kz it nq b gy oz ow l ox oy">#Initiate an Audi car<br/>audi_car = Car(brand="audi", year=2018, price=18000, used=True)</span></pre><p id="1a9b" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">让我们把这些车打印出来:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="1121" class="ou kz it nq b gy ov ow l ox oy">print(bmw_car)<br/>print(audi_car)</span><span id="b839" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>Car(brand="bmw", year=2016, price=20000, used=False)<br/>Car(brand="audi", year=2018, price=18000, used=True)</span></pre><p id="4999" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">打印数据类时的输出是信息性的，无需在类中编写<code class="fe nn no np nq b">__repr__</code>方法。这是由<code class="fe nn no np nq b">dataclass</code>装饰器自动处理的🔥</p><p id="eafc" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">要查看还自动实现了什么，您可以使用<code class="fe nn no np nq b">inspect</code>模块:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="44ff" class="ou kz it nq b gy ov ow l ox oy">import inspect</span><span id="46e1" class="ou kz it nq b gy oz ow l ox oy"># Inspect the Car class<br/>print(inspect.getmembers(Car, inspect.isfunction))</span><span id="76d0" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:</strong><br/>[('__eq__', &lt;function __create_fn__.&lt;locals&gt;.__eq__ at 0x0000021CB9A23790&gt;), ('__init__', &lt;function __create_fn__.&lt;locals&gt;.__init__ at 0x0000021CB9A23670&gt;), ('__repr__', &lt;function __create_fn__.&lt;locals&gt;.__repr__ at 0x0000021CB9A135E0&gt;)]</span></pre><p id="929e" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">我知道这不是最美丽的景象😅</p><p id="2ac6" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">如果你仔细阅读，那么你可以看到一个<code class="fe nn no np nq b">__eq__</code>、<code class="fe nn no np nq b">__init__</code>和<code class="fe nn no np nq b">__repr__</code>是在dataclass中自动实现的。稍后我将回到<code class="fe nn no np nq b">__eq__</code>是如何实现的。</p><p id="90a4" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">默认情况下，数据类是可变的。这意味着您可以进行以下更改:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="3095" class="ou kz it nq b gy ov ow l ox oy"># The Audi car becomes used<br/>audi_car.used = True<br/>print(audi_car.used)</span><span id="ad08" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:</strong><br/>True</span></pre><p id="4ede" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">最后，你可以让一个数据类的一些属性拥有<em class="oa">默认值。</em>假设您希望<code class="fe nn no np nq b">used</code>属性有一个默认值<code class="fe nn no np nq b">False</code>。为此，您只需更改一行代码:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="d980" class="ou kz it nq b gy ov ow l ox oy">used: bool = False # Last line in the Car class</span></pre><p id="ead5" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">现在，如果你写</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="db64" class="ou kz it nq b gy ov ow l ox oy">bmw_car = Car(brand="bmw", year=2016, price=20000)</span></pre><p id="81fd" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">您会自动获得以下内容:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="5e38" class="ou kz it nq b gy ov ow l ox oy">print(bmw_car)</span><span id="f4e2" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>Car(brand="bmw", year=2016, price=20000, used=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/c835849a786becb865fee7b1abc69504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y1M-BRlOt9pRDM6i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">穆罕默德·诺哈西在<a class="ae mi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="53bd" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">4-简单验证</h1><p id="e0a7" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">人们很容易将数据类视为过于复杂的字典。为什么不用下面的方法简单地存储变量<code class="fe nn no np nq b">bmw_car</code>呢？</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="530a" class="ou kz it nq b gy ov ow l ox oy">bmw_car = {<br/>  "brand": "bmw", <br/>  "year": 2016, <br/>  "price": 20000, <br/>  "used": False<br/>}</span></pre><p id="f7f6" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">虽然这也是可行的，但是数据类提供了值得考虑的额外特性。其中之一是初始化新实例时的基本验证。</p><p id="7b5f" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">为了演示这一点，我在我的工作目录中创建了一个名为<code class="fe nn no np nq b">cars</code>的文件夹(不要担心这是哪里，我将只使用相对路径)。文件夹<code class="fe nn no np nq b">cars</code>包含四个文件<code class="fe nn no np nq b">car1.json</code>、<code class="fe nn no np nq b">car2.json</code>、<code class="fe nn no np nq b">car3.json</code>和<code class="fe nn no np nq b">car4.json</code>。每个JSON文件都包含一行数据:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="159b" class="ou kz it nq b gy ov ow l ox oy"><strong class="nq iu">car1.json<br/></strong>{<br/>  "brand": "bmw", <br/>  "year": 2016, <br/>  "price": 20000<br/>}</span><span id="89d4" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">car2.json<br/></strong>{<br/>  "brand": "audi", <br/>  "year": 2018, <br/>  "price": 25000, <br/>  "used": true<br/>}</span><span id="f3ce" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">car3.json<br/></strong>{<br/>  "brand": "toyota", <br/>  "year": 2020, <br/>  "price": 22000, <br/>  "used": false<br/>}</span><span id="28e0" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">car4.json<br/></strong>{<br/>  "brand": "toyota",  <br/>  "price": 22000, <br/>  "used": false<br/>}</span></pre><p id="7979" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">我想将这里给出的四辆汽车初始化为dataclass对象。仔细看上面的四个例子。有没有应该拒绝的？</p><p id="2be5" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">导入JSON文件和启动<code class="fe nn no np nq b">Car</code>实例可以通过下面的标准Python代码片段来完成:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="c551" class="ou kz it nq b gy ov ow l ox oy">import json</span><span id="926d" class="ou kz it nq b gy oz ow l ox oy"># Loading and initiating the cars<br/>cars = []<br/>for i in range(1, 5):<br/>  with open(f"cars/car{i}.json", 'r') as file:<br/>    car_info = json.load(file)<br/>    cars.append(Car(**car_info))<br/>print(cars)</span><span id="bb74" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>TypeError: __init__() missing 1 required positional argument: 'year'</span></pre><p id="52de" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">你会立即得到反馈，有什么地方出错了😮</p><p id="9d7d" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">当然，当你查看<code class="fe nn no np nq b">car4.json</code>时，就会发现<code class="fe nn no np nq b">year</code>属性不见了。如果您使用基本的字典来建模汽车，那么您将需要大量枯燥的代码来确保提供没有默认值的属性。</p><p id="85cd" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">通过使用第三方库<strong class="ls iu"> MyPy </strong>，您还可以使用dataclasses中的类型提示来获得更好的数据验证。虽然这超出了这篇博文的范围，但是如果你感兴趣的话，可以看看<a class="ae mi" href="http://mypy-lang.org/" rel="noopener ugc nofollow" target="_blank"> MyPy </a>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="d594" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">5-数据类之间相等</h1><p id="ec0c" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">dataclasses的一个很酷的特性是它们已经实现了一个用于比较实例的<code class="fe nn no np nq b">__eq__</code>方法。为了了解这是如何工作的，让我们考虑另一个数据类示例，其中您对图书进行建模:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="5cc1" class="ou kz it nq b gy ov ow l ox oy">from dataclasses import dataclass</span><span id="910b" class="ou kz it nq b gy oz ow l ox oy">@dataclass<br/>class Book:<br/>  """A dataclass for representing books."""<br/>  title: str<br/>  author: str<br/>  isbn: str<br/>  pages: int = 0</span></pre><p id="4185" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">到目前为止，一切顺利。现在举以下四个例子:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="16c3" class="ou kz it nq b gy ov ow l ox oy">fluent_python = Book(<br/>  title="Fluent Python", <br/>  author="Luciano Ramalho", <br/>  isbn="978-1-491-94600-8",<br/>  pages=751<br/>)</span><span id="2433" class="ou kz it nq b gy oz ow l ox oy">fluent_python_identical = Book(<br/>  title="Fluent Python", <br/>  author="Luciano Ramalho", <br/>  isbn="978-1-491-94600-8",<br/>  pages=751<br/>)</span><span id="29bc" class="ou kz it nq b gy oz ow l ox oy">fluent_python_missing_pages = Book(<br/>  title="Fluent Python",<br/>  author="Luciano Ramalho",<br/>  isbn="978-1-491-94600-8"<br/>)</span><span id="a97a" class="ou kz it nq b gy oz ow l ox oy">python_crash_course = Book(<br/>  title="Python Crash Course", <br/>  author="Eric Matthes", <br/>  isbn="978-1-593-27928-8"<br/>)</span></pre><p id="d688" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">书籍<code class="fe nn no np nq b">fluent_python</code>和<code class="fe nn no np nq b">fluent_python_identical</code>包含完全相同的数据。另一方面，书<code class="fe nn no np nq b">fluent_python_missing_pages</code>是缺页的，所以页数被设置为默认值<code class="fe nn no np nq b">0</code>。最后，这本书<code class="fe nn no np nq b">python_crash_course</code>从根本上不同于其他所有的书。</p><p id="9e65" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">下面显示了如果您尝试比较不同的实例会发生什么:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="609b" class="ou kz it nq b gy ov ow l ox oy">print(fluent_python == python_crash_course)</span><span id="68c3" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>False</span><span id="3773" class="ou kz it nq b gy oz ow l ox oy">print(fluent_python == fluent_python_identical)</span><span id="4404" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>True</span><span id="1871" class="ou kz it nq b gy oz ow l ox oy">print(fluent_python == fluent_python_missing_pages)</span><span id="5448" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>False</span></pre><p id="066b" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">最有趣的是，书<code class="fe nn no np nq b">fluent_python</code>和<code class="fe nn no np nq b">fluent_python_missing_pages</code>并不被认为是平等的。</p><blockquote class="ob"><p id="9185" class="oc od it bd oe of og oh oi oj ok md dk translated">当且仅当两个dataclasses实例的所有属性都相等时，它们才被视为相等。</p></blockquote><p id="5cec" class="pw-post-body-paragraph na nb it ls b lt ol ju nc lv om jx nd lx on nf ng lz oo ni nj mb op nl nm md im bi translated">这与平时上课的方式形成了鲜明的对比。对于通常的类，除非你实现了你自己的<code class="fe nn no np nq b">__eq__</code>方法，否则只有当两个实例引用同一个内存地址时，它们才被认为是相等的。这是一个非常严格的标准，在数据科学和数据工程中不是很有用。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="c9f4" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">6-数据类中的排序</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/f059dba8fe8be15ffb4685ef8bc12bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G80NDpzEQ1Mzzx1S"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae mi" href="https://unsplash.com/@andretaissin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德烈·泰森</a>在<a class="ae mi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5410" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">既然您已经看到了数据类的基础知识，那么是时候讨论数据类的排序了。默认情况下，数据类没有顺序。但是，您可以指定希望数据类按如下方式排序:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="12bc" class="ou kz it nq b gy ov ow l ox oy">@dataclass(order=True)<br/>class RGBColor:<br/>  """A class for keeping track of a color."""<br/>  red: int<br/>  green: int<br/>  blue: int</span></pre><p id="7f03" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">注意，我在dataclass装饰器中指定了<code class="fe nn no np nq b">order=True</code>。您现在得到以下排序:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="2cbb" class="ou kz it nq b gy ov ow l ox oy">almost_white_color = RGBColor(red=254, green=255, blue=255)<br/>red_color = RGBColor(red=255, green=0, blue=0)</span><span id="34ee" class="ou kz it nq b gy oz ow l ox oy">print(almost_white_color &gt; red_color)</span><span id="60e6" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>False</span></pre><p id="f4fa" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">这是怎么回事？😟</p><p id="df82" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">如果除了<code class="fe nn no np nq b">order=True</code>之外没有指定任何东西，那么默认的排序将按照<em class="oa">字典的方式</em>来比较属性。这意味着首先将<code class="fe nn no np nq b">almost_white</code> (254)的<code class="fe nn no np nq b">red</code>值与<code class="fe nn no np nq b">red_color</code> (255)的<code class="fe nn no np nq b">red</code>值进行比较。因为254小于255，所以得到输出<code class="fe nn no np nq b">False</code>。如果出现平局，则比较下一个属性(绿色),依此类推。</p><p id="2dc0" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">默认顺序通常不是您想要的。这一次，它很大程度上依赖于属性的排序(红色现在比蓝色更适合确定大小)。对于红、绿、蓝三色同等重要的RGB颜色来说，这似乎不是一个好主意。</p><p id="e14c" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">这就引出了一个问题:<em class="oa">如何指定自己的排序？</em></p><p id="95c0" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">以下示例为您的<code class="fe nn no np nq b">RGBColor</code>数据类实现了自定义顺序:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="2d8d" class="ou kz it nq b gy ov ow l ox oy">from dataclasses import dataclass, field</span><span id="28f3" class="ou kz it nq b gy oz ow l ox oy">@dataclass(order=True)<br/>class RGBColor:<br/>  """A class for keeping track of a color."""<br/>  sort_index: int = field(init=False, repr=False)<br/>  red: int<br/>  green: int<br/>  blue: int</span><span id="0617" class="ou kz it nq b gy oz ow l ox oy">  def __post_init__(self):<br/>    self.sort_index = self.red + self.green + self.blue</span></pre><p id="9a5f" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">这里发生了一些事情。让我们把它们一个一个分解开来:</p><ul class=""><li id="60cd" class="lq lr it ls b lt nr lv ns lx nt lz nu mb nv md nw mf mg mh bi translated">除了<code class="fe nn no np nq b">dataclass</code>之外，你还可以从<code class="fe nn no np nq b">dataclasses</code>模块中导入<code class="fe nn no np nq b">field</code>。</li><li id="3866" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated">您创建了一个属性<code class="fe nn no np nq b">sort_index</code>,该属性将用于对数据类的实例进行排序。我稍后会回到论点<code class="fe nn no np nq b">init=False</code>和<code class="fe nn no np nq b">repr=False</code>的意思。</li><li id="b75c" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated">您创建了一个名为<code class="fe nn no np nq b">__post_init__</code>的特殊方法。该方法在<code class="fe nn no np nq b">__init__</code>方法在引擎盖下执行后执行。然后指定<code class="fe nn no np nq b">sort_index</code>属性应该是什么。之所以需要在<code class="fe nn no np nq b">__init__</code>方法之后指定，是因为您需要能够访问三个属性<code class="fe nn no np nq b">red</code>、<code class="fe nn no np nq b">green</code>和<code class="fe nn no np nq b">blue</code>。默认情况下，<code class="fe nn no np nq b">__post_init__</code>方法中指定的变量将决定数据类的排序方式。</li></ul><p id="deed" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">现在你有了以下比较:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="98c0" class="ou kz it nq b gy ov ow l ox oy">almost_white_color = RGBColor(red=254, green=255, blue=255)<br/>red_color = RGBColor(red=255, green=0, blue=0)</span><span id="e126" class="ou kz it nq b gy oz ow l ox oy">print(almost_white_color &gt; red_color)</span><span id="5a55" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/>True</strong></span></pre><p id="dfc4" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">之所以认为<code class="fe nn no np nq b">almost_white_color</code>比<code class="fe nn no np nq b">red_color</code>要“高”,是因为您现在要比较这些值</p><p id="fd28" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi">254 + 255 + 255 &gt; 255 + 0 + 0,</p><p id="bab9" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">这明明是<code class="fe nn no np nq b">True</code>。请注意，当您创建两种颜色<code class="fe nn no np nq b">almost_white_color</code>和<code class="fe nn no np nq b">red_color</code>时，您没有为<code class="fe nn no np nq b">sort_index</code>传入一个值。这是因为你在创建<code class="fe nn no np nq b">sort_index</code>时指定了<code class="fe nn no np nq b">init=False</code>。第二个参数<code class="fe nn no np nq b">repr=False</code>确保如果你打印出实例，那么你看不到属性<code class="fe nn no np nq b">sort_index</code>:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="684d" class="ou kz it nq b gy ov ow l ox oy">print(almost_white_color)<br/>print(red_color)</span><span id="5203" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:</strong><br/>RGBColor(red=254, green=255, blue=255)<br/>RGBColor(red=255, green=0, blue=0)</span></pre><p id="04bd" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">因为你想为<code class="fe nn no np nq b">sort_index</code>设置自定义属性，比如<code class="fe nn no np nq b">init=False</code>和<code class="fe nn no np nq b">repr=False</code>，你需要使用<code class="fe nn no np nq b">dataclasses</code>模块中的<code class="fe nn no np nq b">field</code>函数。有关字段的更多信息，请查看关于数据类的<a class="ae mi" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank"> Python文档。</a></p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="766f" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">7-不可变数据类</h1><p id="3100" class="pw-post-body-paragraph na nb it ls b lt lu ju nc lv lw jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">我想告诉你的最后一件事是如何使数据类<strong class="ls iu">不可变</strong>。我之前告诉过你数据类是可变的。但是，你可以改变这一点！以下示例说明了如何使dataclass不可变:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="1cf1" class="ou kz it nq b gy ov ow l ox oy">from dataclasses import dataclass</span><span id="e44b" class="ou kz it nq b gy oz ow l ox oy">@dataclass(frozen=True)<br/>class Rectangle:<br/>  """A dataclass representing a geometrical rectangle."""<br/>  height: float<br/>  width: float</span></pre><p id="c866" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">如您所见，真正需要做的唯一事情是在dataclass装饰器中指定<code class="fe nn no np nq b">frozen=True</code>。一旦这样做了，那么您的数据类实例将不会是可变的:</p><pre class="kj kk kl km gt oq nq or os aw ot bi"><span id="5df4" class="ou kz it nq b gy ov ow l ox oy">my_rect = Rectangle(height=1, width=2)<br/>my_rect.height = 47</span><span id="8c7e" class="ou kz it nq b gy oz ow l ox oy"><strong class="nq iu">Output:<br/></strong>dataclasses.FrozenInstanceError: cannot assign to field 'height'</span></pre><p id="2c30" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">让数据类不可变有助于确保代码不会被意外修改😎</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="2718" class="ky kz it bd la lb mv ld le lf mw lh li jz mx ka lk kc my kd lm kf mz kg lo lp bi translated">8—总结</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/27326344f84c7c0faae812f5de3e8e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XW_CzG1V4aju-fej"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae mi" href="https://unsplash.com/@shutterspence?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯潘塞·伯根</a>在<a class="ae mi" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bbae" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">我已经向您展示了数据类在Python中是如何工作的。我希望你学到了一些新东西，并且能够在未来的项目中使用这些东西。</p><p id="cfae" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated"><strong class="ls iu">喜欢我写的？</strong>查看我的其他帖子，了解更多Python内容:</p><ul class=""><li id="08d6" class="lq lr it ls b lt nr lv ns lx nt lz nu mb nv md nw mf mg mh bi translated"><a class="ae mi" rel="noopener" target="_blank" href="/modernize-your-sinful-python-code-with-beautiful-type-hints-4e72e98f6bf1">用漂亮的类型提示使你罪恶的Python代码现代化</a></li><li id="2b77" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated"><a class="ae mi" rel="noopener" target="_blank" href="/visualizing-missing-values-in-python-is-shockingly-easy-56ed5bc2e7ea">用Python可视化缺失值非常简单</a></li><li id="acbd" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated"><a class="ae mi" rel="noopener" target="_blank" href="/painlessly-speed-up-your-data-analysis-in-python-with-mito-2b79de4f2f46">使用米托轻松加速Python中的数据分析</a></li><li id="dad2" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated"><a class="ae mi" rel="noopener" target="_blank" href="/5-awesome-numpy-functions-that-can-save-you-in-a-pinch-ba349af5ac47"> 5个超赞的数字功能，能在紧要关头救你一命</a></li><li id="d635" class="lq lr it ls b lt mj lv mk lx ml lz mm mb mn md nw mf mg mh bi translated">5个专家建议让你的Python字典技能突飞猛进🚀</li></ul><p id="5ec4" class="pw-post-body-paragraph na nb it ls b lt nr ju nc lv ns jx nd lx nx nf ng lz ny ni nj mb nz nl nm md im bi translated">如果你对数据科学、编程或任何介于两者之间的东西感兴趣，那么请随意在LinkedIn上加我，并向✋问好</p></div></div>    
</body>
</html>