<html>
<head>
<title>Question-Answering on Textbooks by Searching and Ranking</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于搜索和排序的教科书问答</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/question-answering-on-textbooks-by-searching-and-ranking-609f8b007aa6#2022-01-03">https://towardsdatascience.com/question-answering-on-textbooks-by-searching-and-ranking-609f8b007aa6#2022-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="aa0a" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">基于搜索和排序的教科书问答</h1></div><div class=""><h2 id="f9f5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用数据做很酷的事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a680cc4a15abd6fd0c9db47cba92137e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*58HntY5poeAohoK78mIoew.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">照片由nadi borodina在Unsplash上拍摄</p></figure><h1 id="81a7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="653c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">问答是自然语言处理的一个流行应用。在大数据集上训练的Transformer模型极大地改善了问答的最新结果。</p><p id="24f3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">问题回答任务可以用许多方式来表述。最常见的应用是在小范围内回答提取的问题。班数据集是一个流行的数据集，其中给定一段话和一个问题，模型选择代表答案的单词。这在下面的图1中示出。</p><p id="34ed" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然而，大多数问题回答的实际应用涉及非常长的文本，如完整的网站或数据库中的许多文档。使用Google Home/Alexa之类的语音助手回答问题需要在网络上搜索大量文档以获得正确答案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/7e62cac8af128081bf7c723f64e7a3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*9OfV9iklKJ1y0oyhbkdrnQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">小队数据集。图片来自<a class="ae mo" href="https://arxiv.org/pdf/1606.05250.pdf" rel="noopener ugc nofollow" target="_blank">小队论文</a>。</p></figure><p id="6fa9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这篇博客中，我们使用<a class="ae mo" href="https://github.com/deepset-ai/haystack" rel="noopener ugc nofollow" target="_blank"> Haystack </a>构建了一个搜索和问答应用程序。这个应用程序搜索了几本与编程相关的O'Reilly开源书籍。代码在Github <a class="ae mo" href="https://github.com/priya-dwivedi/Deep-Learning/blob/master/Question_Answering_on_TextBooks_using_Search/Question_Answering_TextBooks.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>公开。你也可以在这里使用<a class="ae mo" href="https://colab.research.google.com/drive/1lxBoth4JPvsZewr1zpqeOhW0W9Hxms8q#scrollTo=CRFyiVsNSZYS" rel="noopener ugc nofollow" target="_blank">的Colab笔记本</a>来测试这个模型。</p><p id="2839" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里的完整帖子也可以在我们的网站<a class="ae mo" href="https://deeplearninganalytics.org/question-answering-on-textbooks-by-searching-and-ranking/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="9fa2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">搜索和排名</h1><p id="f2de" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">那么，我们如何从庞大的数据库中检索答案呢？</p><p id="bb4d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们将回答问题的过程分为两步:</p><ol class=""><li id="b0ff" class="mp mq it lo b lp mi ls mj lv mr lz ms md mt mh mu mv mw mx bi translated">搜索和排序:从我们的数据库中检索可能有答案的段落</li><li id="32b5" class="mp mq it lo b lp my ls mz lv na lz nb md nc mh mu mv mw mx bi translated">阅读理解:在检索到的文章中寻找答案</li></ol><p id="fb2f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">搜索和排名过程通常包括将数据编入数据库，如弹性搜索数据库或T2 FAISS数据库。这些数据库已经实现了在数百万条记录中进行快速搜索的算法。可以使用TFIDF或BM25使用查询中的单词来完成搜索，或者可以通过嵌入文本来考虑文本的语义来完成搜索，或者也可以使用这些的组合。在我们的代码中，我们使用了来自<a class="ae mo" href="https://github.com/deepset-ai/haystack" rel="noopener ugc nofollow" target="_blank">干草堆</a>的基于TFIDF的检索器。整个数据库被上传到ElasticSearch数据库，搜索是使用TFIDF检索器完成的，该检索器根据分数对结果进行排序。要了解不同类型的搜索，请查看Haystack的博客。</p><p id="55cc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">来自检索器的前k个段落然后被发送到问题回答模型以获得可能的答案。在这篇博客中，我们尝试了两种模式——1。在班数据集和2上训练的BERT模型。在班数据集上训练的罗伯塔模型。《干草堆中的读者》帮助加载这些模型，并通过对从搜索中检索到的段落运行这些模型来获得前K个答案。</p><h1 id="35b9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">构建我们的问答应用程序</h1><p id="d166" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">用于开发该问答模型的训练数据集是编程开源O ' Reilly book-<a class="ae mo" href="https://www.oreilly.com/openbook/beosprog/book/" rel="noopener ugc nofollow" target="_blank">Be操作系统编程</a>。书中的个别章节以pdf文件的形式从<a class="ae mo" href="https://www.oreilly.com/openbook/" rel="noopener ugc nofollow" target="_blank"> O'Reilly网站</a>下载。这本书是在知识共享许可下提供的。我们通过合并章节创建了一个合并的PDF，这些章节可以在google drive <a class="ae mo" href="https://drive.google.com/drive/u/2/folders/1-IAona91wwNKA0_Wm0ux5yCtH15m8Yv2" rel="noopener ugc nofollow" target="_blank">这里</a>找到。如果使用Colab，将此PDF上传到您的环境中。</p><p id="885a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们使用HayStack PDF转换器将PDF读入一个文本文件</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="e129" class="ni kv it ne b gy nj nk l nl nm">converter = PDFToTextConverter(remove_numeric_tables=True, valid_languages=["en"])</span><span id="12f4" class="ni kv it ne b gy nn nk l nl nm">doc_pdf = converter.convert(file_path="/content/converter_merged.pdf", meta=None)[0]</span></pre><p id="1dc2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，我们使用Haystack中的预处理器类将文档分割成许多更小的文档。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="840e" class="ni kv it ne b gy nj nk l nl nm">preprocessor = PreProcessor(</span><span id="20a0" class="ni kv it ne b gy nn nk l nl nm">clean_empty_lines=True,</span><span id="35c3" class="ni kv it ne b gy nn nk l nl nm">clean_whitespace=True,</span><span id="9258" class="ni kv it ne b gy nn nk l nl nm">clean_header_footer=False,</span><span id="94f5" class="ni kv it ne b gy nn nk l nl nm">split_by="word",</span><span id="08d5" class="ni kv it ne b gy nn nk l nl nm">split_length=100,</span><span id="d16e" class="ni kv it ne b gy nn nk l nl nm">split_respect_sentence_boundary=True)</span><span id="a59a" class="ni kv it ne b gy nn nk l nl nm">dict1 = preprocessor.process([doc_pdf])</span></pre><p id="1503" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">每份文件约100字。预处理程序创建1200个文档。</p><p id="daa6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们将这些文档索引到一个ElasticSearch数据库，并初始化一个TFIDF检索器。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f7cf" class="ni kv it ne b gy nj nk l nl nm">retriever = TfidfRetriever(document_store=document_store)</span><span id="e43a" class="ni kv it ne b gy nn nk l nl nm">document_store.write_documents(dict1)</span></pre><p id="8680" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">检索器将对ElasticSearch数据库中的文档进行搜索，并对结果进行排序。</p><p id="ed9f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们初始化问答管道。我们可以使用FARM或Transformer阅读器在HuggingFace hub上加载任何问答模型。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="aaf6" class="ni kv it ne b gy nj nk l nl nm">reader = TransformersReader(model_name_or_path="deepset/bert-large-uncased-whole-word-masking-squad2", tokenizer="bert-base-uncased", use_gpu=-1)</span></pre><p id="7bfc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，我们将检索器和排序器合并到一个管道中，一起运行它们。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="b86d" class="ni kv it ne b gy nj nk l nl nm">from haystack.pipelines import ExtractiveQAPipeline</span><span id="08d3" class="ni kv it ne b gy nn nk l nl nm">pipe = ExtractiveQAPipeline(reader, retriever)</span></pre><p id="4e56" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">仅此而已！我们现在准备测试我们的管道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Giphy免版税。链接:【https://giphy.com/gifs/cheer-cheering-11sBLVxNs7v6WA T2】</p></figure><h1 id="a896" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">测试管道</h1><p id="e68e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">为了测试管道，我们通过它运行我们的问题，为来自检索器和阅读器的top_k结果设置我们的首选项。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5f09" class="ni kv it ne b gy nj nk l nl nm">prediction = pipe.run(query="What is Virtual Memory?", params={"Retriever": {"top_k": 10}, "Reader": {"top_k": 3}}</span></pre><p id="7d9d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当我们要求管道解释虚拟内存时，最重要的结果是非常相关的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/8380e5b627c947a8f1b1bd79f92f9095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bDDCA11qDJoDyxaWbDHekA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">问题1管道测试</p></figure><p id="c54d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，我们询问OpenGL工具包，得到的答案正确地解释了这个库允许程序员向模型添加3D功能。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="eb32" class="ni kv it ne b gy nj nk l nl nm">prediction = pipe.run(query="What is OpenGL kit?", params={"Retriever": {"top_k": 10}, "Reader": {"top_k": 3}}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nv"><img src="../Images/2a43a8906d7e1b8ae984d2a762c52498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*olOoueh59G0vw0C7Lfm8lQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">问题2管道测试</p></figure><p id="eca2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们已经在许多问题上测试了管道，它表现得相当好。阅读源pdf中的新主题并提出相关问题很有趣。通常，我发现我阅读的段落在前3个结果中。</p><p id="cc27" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我的实验表明，伯特和罗伯塔的结果基本相似，罗伯塔略胜一筹。</p><p id="43d3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请使用<a class="ae mo" href="https://colab.research.google.com/drive/1lxBoth4JPvsZewr1zpqeOhW0W9Hxms8q?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Colab </a>或<a class="ae mo" href="https://github.com/priya-dwivedi/Deep-Learning/blob/master/Question_Answering_on_TextBooks_using_Search/Question_Answering_TextBooks.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上的代码通过模型运行您自己的科学问题。</p><h1 id="7a6f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="7e75" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这个博客展示了问答如何应用于许多实际应用，包括长文本，如pdf格式的数据库，或者包含许多文章的网站。我们在这里使用Haystack构建一个相对简单的应用程序。Haystack有许多杠杆可以调整和微调，以进一步提高性能。我希望你下载代码，运行你自己的实验。请在下面的评论中分享你的经历。</p><p id="cec6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在<a class="ae mo" href="https://deeplearninganalytics.org/" rel="noopener ugc nofollow" target="_blank">深度学习分析</a>，我们非常热衷于使用机器学习来解决现实世界的问题。我们已经帮助许多企业部署了创新的基于人工智能的解决方案。如果您看到合作的机会，请通过我们的网站<a class="ae mo" href="https://deeplearninganalytics.org/contact-us/" rel="noopener ugc nofollow" target="_blank">这里</a>联系我们。</p><h1 id="2b01" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">参考</h1><ul class=""><li id="b71b" class="mp mq it lo b lp lq ls lt lv nw lz nx md ny mh nz mv mw mx bi translated"><a class="ae mo" href="https://ai.facebook.com/blog/roberta-an-optimized-method-for-pretraining-self-supervised-nlp-systems/" rel="noopener ugc nofollow" target="_blank">罗伯塔模型</a></li><li id="f8c5" class="mp mq it lo b lp my ls mz lv na lz nb md nc mh nz mv mw mx bi translated"><a class="ae mo" href="https://haystack.deepset.ai/overview/intro" rel="noopener ugc nofollow" target="_blank">草堆文档</a></li></ul></div></div>    
</body>
</html>