<html>
<head>
<title>3 SQL Swaps to Write Better Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3次SQL交换以编写更好的代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-sql-swaps-to-write-better-code-f8d304699cde#2022-01-06">https://towardsdatascience.com/3-sql-swaps-to-write-better-code-f8d304699cde#2022-01-06</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""><h1 id="9716" class="pw-post-title it iu iv bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">3次SQL交换以编写更好的代码</h1></div><div class=""><h2 id="81b3" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">如何确保您的代码是准确的、可读的和高效的</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/a62bc11a82cd4cabddab926c4756d6d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4KW_YEdYgZdUwZHP_fOaA.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@denisseleon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼斯·莱昂</a>在<a class="ae la" href="https://unsplash.com/s/photos/light-switch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e652" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">无论你是数据分析师、数据工程师、数据科学家还是分析工程师，你都必须编写干净的代码。你不应该是唯一一个能理解你写的东西的人。它需要让团队中的其他人能够阅读，以便在未来几年中使用和改进。</p><p id="bf51" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我最大的烦恼之一是当我发现草率的代码，然后写它的人已经不在公司了！没有办法知道他们在想什么，为什么他们以某种方式写逻辑。在我目前的角色中，这是一个持续的斗争，我正在重写我们所有的核心数据模型。</p><p id="3e0b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">信不信由你，写SQL代码有好有坏。仅仅因为它运行并得到您想要的结果，并不意味着它是编写良好的代码。要被认为是好的代码，它必须是准确的、可读的和高效的。</p><p id="2555" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里有一些你可以在代码中进行的SQL交换，以确保它更具可读性和效率，这是编写良好代码的两个核心要素。</p><h1 id="712e" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">TOP →行号()</h1><p id="1433" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在重写旧的数据模型时，我经常遇到使用函数<code class="fe mu mv mw mx b">TOP</code>的子查询。虽然这可能会让你得到你正在寻找的解决方案，但它很难阅读，并且可能需要很长时间来运行。</p><p id="8aba" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">以下是我发现的一个例子:</p><pre class="kl km kn ko gt my mx mz na aw nb bi"><span id="6599" class="nc ly iv mx b gy nd ne l nf ng">SELECT<br/>   customer_id,<br/>   (SELECT<br/>       TOP order_id <br/>    FROM orders<br/>    WHERE orders.customer_id = customers.customer_id<br/>    ORDER BY date DESC)<br/>FROM customers </span></pre><p id="59fa" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">作为工程师和分析师，我们希望确保我们正在编写尽可能干净和高效的代码。所以，如果你使用的是<code class="fe mu mv mw mx b">TOP</code>，这里有一个函数可以代替。</p><p id="7740" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><code class="fe mu mv mw mx b">ROW_NUMBER()</code>是一个窗口功能，允许您为满足特定条件的每一行分配一个序号。使用<code class="fe mu mv mw mx b">ORDER BY</code>和<code class="fe mu mv mw mx b">PARTITION BY</code>指定这些条件。</p><p id="d8e4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><code class="fe mu mv mw mx b">ORDER BY</code>指定您希望如何对表格中的值进行排序。日期通常用于此。</p><p id="7f45" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><code class="fe mu mv mw mx b">PARTITION BY</code>指定作为值分组依据的列。这取决于您查询的目的。</p><p id="7ddc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这个例子中，我们需要<code class="fe mu mv mw mx b">ORDER BY</code> date和<code class="fe mu mv mw mx b">PARTITION BY</code> customer_id。因为我们试图为每个客户找到最近的订单，所以按客户id进行分区将为每个唯一的id计算一个新的序列。</p><pre class="kl km kn ko gt my mx mz na aw nb bi"><span id="bc75" class="nc ly iv mx b gy nd ne l nf ng">SELECT <br/>   customer_id, <br/>   order_id,<br/>   ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY date) AS order_sequence_number <br/>FROM orders</span></pre><p id="e98e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，这将产生一个与原始表具有相同行数的表，但是，这一次有一个新的列<code class="fe mu mv mw mx b">order_sequence_number</code>来指示每个客户的订单顺序。为了获得客户的第一个订单，我们需要编写另一个查询，只选择等于1的序列号。</p><pre class="kl km kn ko gt my mx mz na aw nb bi"><span id="33a7" class="nc ly iv mx b gy nd ne l nf ng">WITH</span><span id="3d5e" class="nc ly iv mx b gy nh ne l nf ng">order_row_number_calculated AS (<br/>   SELECT <br/>      customer_id, <br/>      order_id,<br/>      ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY date) AS order_sequence_number <br/>   FROM orders<br/>)</span><span id="8dd2" class="nc ly iv mx b gy nh ne l nf ng">SELECT <br/>   customer_id,<br/>   order_id <br/>FROM order_row_number_calculated<br/>WHERE order_sequence_number = 1</span></pre><p id="2fe2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们有了一个CTE，它在第一个查询中查找每一行的行号，然后通过只查找分组中第一个行号来过滤查询。这对任何人来说都更容易阅读，并且通常运行速度更快。</p><h1 id="c08f" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">子查询→cte</h1><p id="b35f" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">上面显示的最后一个例子也可以用于这种交换！如果你看上面，我们从查询中的子查询开始，然后使用cte结束。</p><p id="a5b2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">CTE到底是什么？CTE代表普通餐桌用语。它创建了一组临时结果，您可以在后续查询中使用。它要求您以<code class="fe mu mv mw mx b">WITH</code>开始，并在每个CTE前使用<code class="fe mu mv mw mx b"> table_name AS</code>。序列中的最后一个CTE应该是一个简单的SELECT语句，既没有table_name也没有<code class="fe mu mv mw mx b">AS</code>。</p><p id="ef4f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">它应该是这样的:</p><pre class="kl km kn ko gt my mx mz na aw nb bi"><span id="4fb5" class="nc ly iv mx b gy nd ne l nf ng">WITH <br/>money_summed AS (<br/>   SELECT <br/>      customer_id,<br/>      date,<br/>      SUM(balance) AS balance,<br/>      SUM(debt) AS debt<br/>   FROM bank_balance <br/>   GROUP BY customer_id, date<br/>),</span><span id="3488" class="nc ly iv mx b gy nh ne l nf ng">money_available_calculated AS (<br/>   SELECT <br/>      customer_id,<br/>      date,<br/>      (balance - debt) AS money_available <br/>   FROM money_summed <br/>   GROUP BY customer_id, date<br/>)</span><span id="5e7d" class="nc ly iv mx b gy nh ne l nf ng">SELECT<br/>   customer_id,<br/>   money_available <br/>FROM money_available_calculated <br/>WHERE date = '2022-01-01' </span></pre><p id="7517" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">注意，在最后一个<code class="fe mu mv mw mx b">SELECT</code>语句之前，我们没有使用表名或括号。前一组括号后面也没有逗号。一系列cte中的最后一个查询总是作为普通查询写入。请务必记住这一点，因为在使用cte时，由于格式化导致的错误是常见的！</p><h1 id="a2ae" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">≤和≥ →之间</h1><p id="bee1" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">使用日期列将两个表连接在一起是很常见的。大多数时候，当我看到这个的时候，他们是通过使用<code class="fe mu mv mw mx b">≥</code>和<code class="fe mu mv mw mx b">≤</code>来连接的。虽然这种方法有效，但看起来很混乱。幸运的是，有一个更好的方法来做到这一点！</p><p id="6406" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><code class="fe mu mv mw mx b">BETWEEN</code>是一个SQL函数，允许您选择两个给定值之间的范围。它返回在你给它的值之间的值<em class="ni">。它可以与数字、日期甚至字符串一起使用。</em></p><p id="3c27" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">但是，最需要注意的是，这个功能是<em class="ni">包含</em>的。这意味着指定的值也将包含在您的结果中。所以，它只能真正取代<code class="fe mu mv mw mx b">≤</code>或<code class="fe mu mv mw mx b">≥</code>而不是<code class="fe mu mv mw mx b">&lt;</code>或<code class="fe mu mv mw mx b">&gt;</code>。</p><p id="e490" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">首先，让我们看一个查询，它使用<code class="fe mu mv mw mx b">≤</code>和<code class="fe mu mv mw mx b">≥</code>符号连接两个使用日期的表。</p><pre class="kl km kn ko gt my mx mz na aw nb bi"><span id="fca8" class="nc ly iv mx b gy nd ne l nf ng">SELECT<br/>   customers.customer_id,<br/>   customers.activated_at, <br/>   campaigns.campaign_id<br/>FROM customers<br/>LEFT JOIN campaigns <br/>ON customers.campaign_id = campaigns.campaign_id <br/>WHERE customers.activated_at &gt;= campaigns.started_at AND customers.activated_at &lt;= campaigns.ended_at</span></pre><p id="a6cd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在<code class="fe mu mv mw mx b">WHERE</code>子句中，我们需要使用<code class="fe mu mv mw mx b">activated_at</code>指定两个不同的语句。一个是该列在<code class="fe mu mv mw mx b">≥ started_at</code>处，另一个是<code class="fe mu mv mw mx b">≤ ended_at</code>处。</p><p id="95f9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，让我们使用<code class="fe mu mv mw mx b">BETWEEN</code>。</p><pre class="kl km kn ko gt my mx mz na aw nb bi"><span id="dfe1" class="nc ly iv mx b gy nd ne l nf ng">SELECT<br/>   customers.customer_id,<br/>   customers.activated_at, <br/>   campaigns.campaign_id<br/>FROM customers<br/>LEFT JOIN campaigns <br/>ON customers.campaign_id = campaigns.campaign_id <br/>WHERE customers.activated_at BETWEEN campaigns.started_at AND campaigns.ended_at</span></pre><p id="3195" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里，我们只需要指定<code class="fe mu mv mw mx b">activated_at</code>一次，而不是两次。</p><p id="e7eb" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">哪个查询更容易阅读和理解？虽然第一个可能不太复杂，但是代码中的小差异会产生巨大的差异。这就是好的和伟大的<em class="ni">的区别。</em></p><h1 id="fdcf" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">结论</h1><p id="8408" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">刚开始学习SQL的时候，你希望专注于能够解决给你的问题，并得到正确的答案。随着你发展自己的技能，变得更加自信，你需要努力改进<em class="ni">如何</em>找到解决方案。</p><p id="f473" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">每个工程师和分析师都希望他们的队友能够阅读他们的代码，并且容易理解。你不仅会讨厌回答无数的问题，而且他们也会讨厌问你这些问题。努力使您的SQL代码高效易读。如果有一个功能可以作为快捷方式，那就使用它！</p><p id="8723" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">另外，不要忘记文档的重要性。给你的代码加注释可以让其他人的工作变得容易很多，也省去了提问的必要。如果你认为你写的东西可能很难理解，解释它的意思！我坚信代码永远不会有太多的注释。</p><p id="bc5f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">有关提高SQL技能的更多提示，请查看您需要了解的<a class="ae la" rel="noopener" target="_blank" href="/8-sql-date-functions-you-need-to-know-c6c887a8394f"> 8个SQL日期函数</a>、<a class="ae la" rel="noopener" target="_blank" href="/how-to-use-sql-cross-joins-5653fe7d353">如何使用SQL交叉连接</a>，以及<a class="ae la" rel="noopener" target="_blank" href="/how-to-use-sql-window-functions-5d297d29f810?source=your_stories_page----------------------------------------">如何使用SQL窗口函数</a>。</p></div></div>    
</body>
</html>