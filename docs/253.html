<html>
<head>
<title>Airflow, Prefect, and Dagster: An Inside Look</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">气流，级长，和Dagster:一个内部看看</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/airflow-prefect-and-dagster-an-inside-look-6074781c9b77#2022-01-10">https://towardsdatascience.com/airflow-prefect-and-dagster-an-inside-look-6074781c9b77#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""><h1 id="32c3" class="pw-post-title io ip iq bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">气流，级长，和Dagster:一个内部看看</h1></div><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0be027cf5208f41017783fc50362ec06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JUnRi0Yl2YQqZCiV"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">约书亚·索蒂诺在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现代数据堆栈的一大优点是与组成堆栈的所有不同组件的互操作性，但不幸的是，编排仍然是一个棘手的问题。数据管道仍然涉及定制脚本和逻辑，它们并不完全适合ETL工作流。无论是定制的内部服务，还是像下载文件、解压文件和读取内容这样简单的事情，仍然需要编排工具。</p><p id="4109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然现代数据堆栈确实提供了很大的灵活性，各种组件可以很好地相互配合，但能够协调整个堆栈的工作流仍然不是一个已解决的问题。</p><p id="b975" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入流程编排工具，如Apache Airflow、Prefect和Dagster。这些工具是数据工程团队的面包和黄油。阿帕奇气流(Apache Airflow)是三者中最古老的一个，是一个经过战斗考验的可靠解决方案，它脱胎于Airbnb，由Maxime Beauchemin创建。当时，数据工程是一个不同的世界，主要关注定期调度的批处理作业，这些作业通常涉及带有Hive和Druid等词的丑陋系统。今天你仍然可以在气流中看到很多这种传统。</p><p id="4756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Prefect和Dagster是较新的产品，都受其云产品Prefect Cloud和Dagster Cloud的支持。Prefect Cloud可以自由启动并托管一个调度程序，而混合架构允许您在本地或基础架构上运行任务。Dagster Cloud刚刚发布，正在提前访问中！</p><h1 id="7e8d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是气流，它的顶级替代品是什么？</h1><p id="f977" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Airflow是一个工作流编排工具，用于编排分布式应用程序。它通过使用DAGs(有向无环图)在不同的服务器或节点上调度作业来工作。Apache Airflow提供了一个丰富的用户界面，可以轻松地可视化管道中的数据流。您还可以监控每个任务的进度并查看日志。</p><p id="833f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你曾经对日期如何在气流中工作感到困惑，你会看到一些遗产。很少有人不被什么是执行日期以及为什么他们的DAG没有在他们期望的时候运行所迷惑。所有这些都是从午夜后一段时间运行日常工作的日子里滋生出来的。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/935fc60fa0dae92a646fe166417c452c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*shXSY68nEp6eiDNv.gif"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">来看看多年前的气流1.4，来源:<a class="ae kc" href="https://github.com/apache/airflow/tree/efd9e4c4f5dc413308fa958a8038240a38840f67" rel="noopener ugc nofollow" target="_blank">Github上的气流</a></p></figure><p id="eef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Airflow现在是Apache的一个项目，Apache基金会对它的采用巩固了该项目作为现状开源编排和调度工具的地位。今天，成千上万的公司使用气流来管理他们的数据管道，你很难找到一家大公司在他们的堆栈中没有一点气流。像天文学家和AWS这样的公司甚至提供托管气流作为服务，这样围绕部署和维护实例的基础设施就不再是工程团队关心的问题。</p><p id="17b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，随着数据环境的变化，在测试、非预定工作流、参数化、数据传输和存储抽象方面，Airflow经常会遇到一些障碍。</p><h1 id="b135" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">气流的好处</h1><p id="2b11" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在我们深入其中一些陷阱之前，有必要提一下气流的一些好处:毫无疑问，一个已经存在了十多年、得到Apache基金会支持、完全开源并被数千家公司使用的项目是一个值得考虑的项目。从很多方面来说，选择气流是最安全的选择，社区支持和被证明的有用性使它成为一个如此安全的选择，你甚至可能会说没有人因为选择气流而被解雇(可能)。</p><p id="d99d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，与任何其他竞争对手相比，气流的堆栈溢出问题要多2个数量级。如果你有问题，你不是一个人，其他人有希望找到解决方案。几乎所有你能想到的工具都有气流提供器，使得用你现有的数据工具创建管道变得容易。</p><h1 id="4949" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">气流的问题</h1><p id="821c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">随着数据环境的不断发展，数据团队使用工具做的事情越来越多。他们正在构建复杂的管道来支持数据科学和机器学习用例，从各种系统和终端接收数据以将其收集到仓库和数据湖中，并为跨多个数据系统的终端用户工具编排工作流。有一段时间，气流是唯一真正可用的编排工具，因此许多团队试图将他们日益复杂的需求挤进气流，经常碰壁。</p><p id="d3f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到的气流部署的主要问题分为以下几类:</p><ul class=""><li id="dc18" class="mj mk iq kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">本地开发、测试和存储抽象</li><li id="8de2" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">一次性和不定期计划的任务</li><li id="4914" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">任务之间的数据移动</li><li id="9475" class="mj mk iq kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">动态和参数化的工作流</li></ul><p id="b08b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过探索两个替代工具Dagster和Prefect如何解决这些问题来深入研究每一个问题。</p><h1 id="fe2c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">看看达格斯特和长官</h1><p id="95ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Dagster是一个相对年轻的项目，由尼克·施勒克于2018年4月启动，他之前是脸书GraphQL的联合创始人。同样，2018年，耶利米·劳因(Jeremiah Lowin)成立了Prefect，他在设计Prefect时吸取了作为阿帕奇气流(Apache air flow)PMC成员的经验。</p><p id="b369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个项目都在解决一个共同的问题，但却有着不同的驱动理念。Dagster采用第一性原理方法进行数据工程。它构建时考虑了整个开发生命周期，从开发到部署，再到监控和可观察性。另一方面，Prefect坚持负面工程的哲学，建立在用户知道如何编码的假设上，并且尽可能简单地获取代码，并将其构建到分布式管道中，由其调度和编排引擎支持。</p><p id="2fdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个项目都获得了很大的牵引力，并迅速改善。让我们来看看这两个项目是如何应对气流所面临的一些挑战的。</p><h1 id="3d25" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">本地开发和测试</h1><p id="3e46" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了气流，本地开发和测试可能是一场噩梦。如果您的production Airflow实例使用Kubernetes作为执行引擎，那么您的本地开发也需要Kubernetes，因为使用S3Operator编写的任务需要连接到AWS S3才能运行:这对于本地开发来说并不理想。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="7924" class="nc lc iq my b gy nd ne l nf ng"># In Airflow, the task writes to S3, using the S3 hook, and the function doesn't take any arguments.<br/>def to_s3():<br/>    path_file = 'test.csv'<br/>    df = pd.read_csv(path_file)<br/>    csv_buffer = StringIO()<br/>    df.to_csv(csv_buffer)<br/>    s3 = S3Hook(aws_conn_id='my_s3')<br/>    s3.get_conn()<br/>    s3.put_object(Body=csv_buffer.getvalue(),<br/>                  Bucket=BUCKET_NAME,<br/>                  Key='test.csv')</span><span id="99d4" class="nc lc iq my b gy nh ne l nf ng">task_to_s3_op = PythonOperator(<br/>    task_id='UploadToS3',<br/>    provide_context=True,<br/>    python_callable=to_s3,<br/>    dag=dag<br/>)</span></pre><p id="ca18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Dagster，计算和存储是两个不同的问题，可以抽象出来。您的函数接受输入和输出，而不是显式地向DAG提供特定的Kubernetes实例，这取决于在运行时配置的持久化数据的资源，无论是用于开发的本地临时文件，还是生产云中的加密对象存储。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="2530" class="nc lc iq my b gy nd ne l nf ng"># In Dagster, a function is explicit about  data frames as inputs and outputs. How these are persisted is defined at run-time, not in the code itself. <br/>@solid<br/>def filter_over_50(people: DataFrame) -&gt; DataFrame:<br/>  return people.filter(people['age'] &gt; 50)</span><span id="617e" class="nc lc iq my b gy nh ne l nf ng"># Resource definitions can be swapped out depending on the environment through code<br/>calories_test_job = calories.to_job(<br/>    resource_defs={"warehouse": local_sqlite_warehouse_resource}<br/>)<br/>calories_dev_job = calories.to_job(<br/>    resource_defs={"warehouse": sqlalchemy_postgres_warehouse_resource}<br/>)</span></pre><p id="bb8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管通过RunConfigs，Prefect也支持存储上的抽象级别。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="7413" class="nc lc iq my b gy nd ne l nf ng">from prefect import Flow<br/>from prefect.run_configs import KubernetesRun</span><span id="bb7e" class="nc lc iq my b gy nh ne l nf ng"># Set run_config as part of the constructor<br/>with Flow("example", run_config=KubernetesRun()) as flow:<br/>    ...</span></pre><p id="38cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这并没有提供与Dagster相同的抽象级别，这使得本地开发更加棘手。对于Prefect来说，参数化是局部开发的重点。通过能够参数化您的流，您可以为本地开发提供较小的数据集，为生产使用提供较大的数据集。</p><h1 id="2d10" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">计划任务</h1><p id="3816" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在Airflow中，计划外任务会导致许多意外问题，所有DAG都需要某种类型的计划，并且不可能在相同的执行时间内多次运行DAG。</p><p id="e3aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Prefect，流程可以随时运行，因为工作流是独立的对象。由于其调度程序的工作方式，我们通常需要等待5-10秒才能让Airflow DAG从预定时间运行，而Prefect通过利用Dask等工具，实现了DAG和任务的快速调度。</p><p id="6ecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，Dagster为手动运行和计划Dag提供了很大的灵活性。您甚至可以根据时间表本身修改特定作业的行为，这是非常强大的。例如，如果您希望在周末和工作日提供不同的运行时配置。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="139d" class="nc lc iq my b gy nd ne l nf ng">@schedule(job=configurable_job, cron_schedule="0 0 * * *")<br/>def configurable_job_schedule(context: ScheduleEvaluationContext):<br/>    scheduled_date = context.scheduled_execution_time.strftime("%Y-%m-%d")<br/>    return RunRequest(<br/>        run_key=None,<br/>        run_config={"ops": {"configurable_op": {"config": {"scheduled_date": scheduled_date}}}},<br/>        tags={"date": scheduled_date},<br/>    )</span></pre><p id="46cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Dagster中运行作业非常简单:</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="e817" class="nc lc iq my b gy nd ne l nf ng">dagster job execute -f hello_world.py</span></pre><h1 id="11d8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">气流中的数据流，提督和达格斯特</h1><p id="0804" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">气流最大的难点之一是相关任务之间的数据移动。传统上，每个任务都必须将数据存储在某个外部存储设备中，使用XComs传递关于数据存储位置的信息(先不说XComs出现之前的情况)，接下来的任务必须解析这些信息以检索数据并处理数据。</p><p id="603f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Dagster中，作业的输入和输出可以更加明确。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="d73d" class="nc lc iq my b gy nd ne l nf ng">import csv</span><span id="8c5c" class="nc lc iq my b gy nh ne l nf ng">import requests<br/>from dagster import get_dagster_logger, job, op</span><span id="4832" class="nc lc iq my b gy nh ne l nf ng">@op<br/>def download_cereals():<br/>    response = requests.get("&lt;https://docs.dagster.io/assets/cereal.csv&gt;")<br/>    lines = response.text.split("\\n")<br/>    return [row for row in csv.DictReader(lines)]</span><span id="4287" class="nc lc iq my b gy nh ne l nf ng">@op<br/>def find_sugariest(cereals):<br/>    sorted_by_sugar = sorted(cereals, key=lambda cereal: cereal["sugars"])<br/>    get_dagster_logger().info(<br/>        f'{sorted_by_sugar[-1]["name"]} is the sugariest cereal'<br/>    )</span><span id="3182" class="nc lc iq my b gy nh ne l nf ng">@job<br/>def serial():<br/>    find_sugariest(download_cereals())</span></pre><p id="1480" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中可以清楚地看到，download _谷类操作返回一个输出，find_sugariest操作接受一个输入。Dagster还提供了一个可选的类型提示系统，以提供良好的测试体验，这在气流任务和Dag中是不可能的。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="52e0" class="nc lc iq my b gy nd ne l nf ng">@op(out=Out(SimpleDataFrame))<br/>def download_csv():<br/>    response = requests.get("&lt;https://docs.dagster.io/assets/cereal.csv&gt;")<br/>    lines = response.text.split("\\n")<br/>    get_dagster_logger().info(f"Read {len(lines)} lines")<br/>    return [row for row in csv.DictReader(lines)]</span><span id="0897" class="nc lc iq my b gy nh ne l nf ng">@op(ins={"cereals": In(SimpleDataFrame)})<br/>def sort_by_calories(cereals):<br/>    sorted_cereals = sorted(cereals, key=lambda cereal: cereal["calories"])<br/>    get_dagster_logger().info(<br/>        f'Most caloric cereal: {sorted_cereals[-1]["name"]}'<br/>    )</span></pre><p id="f38e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Prefect中，输入和输出也很清楚，很容易连接在一起。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="1147" class="nc lc iq my b gy nd ne l nf ng">with Flow("Aircraft-ETL") as flow:<br/>    reference_data = extract_reference_data()<br/>    live_data = extract_live_data()</span><span id="1498" class="nc lc iq my b gy nh ne l nf ng">    transformed_live_data = transform(live_data, reference_data)</span><span id="377a" class="nc lc iq my b gy nh ne l nf ng">    load_reference_data(reference_data)<br/>    load_live_data(transformed_live_data)</span></pre><p id="7f77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转换函数接受来自reference_data和live_data的输出。对于大文件和昂贵的操作，Prefect甚至提供了缓存和持久化输入和输出的能力，从而在调试时缩短开发时间。</p><h1 id="d516" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">动态工作流</h1><p id="3639" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Dagster和Prefect的另一个很棒的功能是创建动态工作流的简单界面，这是Airflow所缺少的。</p><p id="a416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Prefect中，参数可以在云接口中指定，或者显式地提供给Flow runner。这使得扩展到大型复杂计算变得容易，同时允许在管道上工作时进行合理的初始开发。</p><p id="a6c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Dagster中，您可以定义一个图，然后对该图进行参数化，以允许动态配置，这是完全定制资源、配置、挂钩和执行器的能力。</p><pre class="mf mg mh mi gt mx my mz na aw nb bi"><span id="3cc3" class="nc lc iq my b gy nd ne l nf ng">from dagster import graph, op<br/>from dagster import ResourceDefinition</span><span id="4864" class="nc lc iq my b gy nh ne l nf ng">@op(required_resource_keys={"server"})<br/>def interact_with_server(context):<br/>    context.resources.server.ping_server()</span><span id="16a6" class="nc lc iq my b gy nh ne l nf ng">@graph<br/>def do_stuff():<br/>    interact_with_server()</span><span id="e0db" class="nc lc iq my b gy nh ne l nf ng">prod_server = ResourceDefinition.mock_resource()<br/>local_server = ResourceDefinition.mock_resource()</span><span id="a8f3" class="nc lc iq my b gy nh ne l nf ng">prod_job = do_stuff.to_job(resource_defs={"server": prod_server})<br/>local_job = do_stuff.to_job(resource_defs={"local": local_server})</span></pre><h1 id="298b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包扎</h1><p id="1ab1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我希望这是对一些新的编排工具的有益探索，这些工具已经开始在数据领域获得牵引力。尽管Airflow有缺点，但它仍然是一个可靠的、架构良好的平台，可以很好地为许多人服务。然而，这一领域的竞争只会有助于改进所有的工具，因为它们可以相互学习和改进。我很期待看到这个领域的发展，也很想知道你的想法。</p><p id="52ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您使用的是哪个调度程序？您是否有迁移气流的计划？请在下面评论或者在<a class="ae kc" href="https://twitter.com/@pedram_navid" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或者通过<a class="ae kc" href="mailto:pedram@hightouch.io" rel="noopener ugc nofollow" target="_blank">电子邮件告诉我！</a></p><p id="77aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">喜欢这个关于ETL编排的内容吗？阅读更多关于下一代ETL: </strong> <a class="ae kc" href="https://hightouch.io/blog/reverse-etl/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">反向ETL </strong> </a> <strong class="kf ir">，或联系Hightouch的</strong><a class="ae kc" href="https://linkedin.com/in/pedramnavid" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">Pedram</strong></a><strong class="kf ir">或</strong> <a class="ae kc" href="https://hightouch.io/demo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">团队。</strong> </a></p></div></div>    
</body>
</html>