<html>
<head>
<title>Build a Song Recommendation System using Streamlit and Deploy on Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Streamlit构建歌曲推荐系统并在Heroku上部署</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-song-recommendation-system-using-streamlit-and-deploy-on-heroku-375a57ce5e85#2022-01-11">https://towardsdatascience.com/build-a-song-recommendation-system-using-streamlit-and-deploy-on-heroku-375a57ce5e85#2022-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="8316" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">使用Streamlit构建歌曲推荐系统并在Heroku上部署</h1></div><div class=""><h2 id="7ac4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Spotify音乐数据集的K近邻构建一个简单的歌曲推荐引擎</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77f48f55884a6a2755c151d571efb70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OFOu_b9iRFdVMexJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">韦斯·希克斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="0448" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2b26" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">像你我这样的音乐爱好者可能会不断渴望迎合我们个人音乐品味的新歌。无论是最近令人兴奋的hip-pop，充满活力和活力的k-pop，还是轻松柔和的渐进式爵士乐，我们都可以从歌曲推荐系统中受益，该系统可以推荐我们喜欢的新歌。</p><p id="3c2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于音乐数据的可用性和深度学习的进步，我们能够建立一个简单的歌曲推荐系统，可以推荐与我们个人偏好密切匹配的歌曲。这些偏好或对我们推荐系统的输入包括音乐流派、发行年份范围和几种不同的音频特征，如能量、乐器性、音质等。<strong class="lt iu">在本文中，我们将用</strong><a class="ae ky" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Streamlit</strong></a><strong class="lt iu">构建这个推荐引擎，用</strong><a class="ae ky" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Scikit-learn</strong></a><strong class="lt iu">构建k-近邻机器学习模型，并用</strong><a class="ae ky" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Heroku</strong></a><strong class="lt iu">部署我们的网站。</strong></p><p id="bebf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了了解我们正在建设的东西，你可以在这里查看最终的应用程序:<a class="ae ky" href="https://song-recommendation-streamlit.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">song-recommendation-streamlit.herokuapp.com</a>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="cf25" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">资料组</h1><p id="3e4f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在开始构建我们的应用程序之前，我们需要一个音乐数据集。对于我们的数据集，我们将使用来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/saurabhshahane/spotgen-music-dataset" rel="noopener ugc nofollow" target="_blank"> Spotify和Genius Track数据集</a>。该数据集包含使用其API从Spotify平台收集的数千张专辑、艺术家和歌曲的信息。此外，数据集还包含歌曲的低级音频特征，以及它们的歌词。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/5d3f7f129eea60f772715f616b7fdfbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cdtJmsy7fbaVsfG0EkuHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据集统计</p></figure><h2 id="e3cb" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">数据集预处理</h2><p id="e9c0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的数据预处理的目标是我们想要一个联合数据集，该数据集由每首歌曲及其各自的流派信息、发行年份和音频特征组成，因为这些将是我们对系统的输入。目前，数据集主要分为三个<code class="fe nr ns nt nu b">csv</code> <em class="nv"> </em>文件:<code class="fe nr ns nt nu b">spotify_artists.csv</code>、<code class="fe nr ns nt nu b">spotify_albums.csv</code>和<code class="fe nr ns nt nu b">spotify_tracks.csv</code>。<code class="fe nr ns nt nu b">spotify_artists.csv</code>包含每个艺术家的流派信息，<code class="fe nr ns nt nu b">spotify_albums.csv</code>包含每个专辑的发行日期，而<code class="fe nr ns nt nu b">spotify_tracks.csv</code>包含每首歌曲的音频特征。</p><p id="6d74" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了组合这三个数据集，我们可以从使用<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>加载这三个数据集开始。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/c6ff5a24d52d257fef3ec517381762c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vV7FrCz6jvqI8GHwV4sanQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">读出数据</p></figure><p id="53f8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是三个数据集的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/1b33e0585e577ccc09da08d13ad686e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-YxCQxoDtV0924ZZDHe-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Spotify专辑数据(75511行)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/2d026fe5414d73c9ebd8535fa9f2f5ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M5Pt1Mf5HLx3kz9w82OWPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Spotify艺术家数据(56129行)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/77661ac63a9e52141c7a2ee70463b446.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRv8J85X_kRwZw9Rna637g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Spotify跟踪数据(101939行)</p></figure><p id="37c3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们可以用<code class="fe nr ns nt nu b">tracks</code>数据连接<code class="fe nr ns nt nu b">albums</code>和<code class="fe nr ns nt nu b">artists</code>。我们需要将专辑发行年份和艺术家流派信息与曲目数据结合起来。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="e464" class="nf la it nu b gy od oe l of og">## join artist genre information and album release date with track dataset<br/># drop irrelevant columns<br/># get only tracks after 1990<br/>def join_genre_and_date(artist_df, album_df, track_df):<br/>    album = album_df.rename(columns={'id':"album_id"}).set_index('album_id')<br/>    artist = artist_df.rename(columns={'id':"artists_id",'name':"artists_name"}).set_index('artists_id')<br/>    track = track_df.set_index('album_id').join(album['release_date'], on='album_id' )<br/>    track.artists_id = track.artists_id.apply(lambda x: x[2:-2])<br/>    track = track.set_index('artists_id').join(artist[['artists_name','genres']], on='artists_id' )<br/>    track.reset_index(drop=False, inplace=True)<br/>    track['release_year'] = pd.to_datetime(track.release_date).dt.year<br/>    track.drop(columns = ['Unnamed: 0','country','track_name_prev','track_number','type'], inplace = True)<br/>    <br/>    return track[track.release_year &gt;= 1990]</span></pre><p id="3a15" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，我们还从我们的曲目数据帧中删除了不相关的列，只保留了最近的歌曲(1990年以后出版的歌曲)，以保持我们的数据集较小，这将允许我们在构建应用程序时加快加载和处理时间。</p><p id="45ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过只包含属于我们选择的特定流派的歌曲来进一步缩小数据集的大小。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="20b9" class="nf la it nu b gy od oe l of og">def get_filtered_track_df(df, genres_to_include):<br/>    df['genres'] = df.genres.apply(lambda x: [i[1:-1] for i in str(x)[1:-1].split(", ")])<br/>    df_exploded = df.explode("genres")[df.explode("genres")["genres"].isin(genres_to_include)]<br/>    df_exploded.loc[df_exploded["genres"]=="korean pop", "genres"] = "k-pop"<br/>    df_exploded_indices = list(df_exploded.index.unique())<br/>    df = df[df.index.isin(df_exploded_indices)]<br/>    df = df.reset_index(drop=True)<br/>    return df</span></pre><p id="b632" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nr ns nt nu b">get_filtered_track_df</code>返回的dataframe将删除<code class="fe nr ns nt nu b">genres_to_include</code>中不属于任何流派的歌曲。然后，我们运行以下程序:</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="5d0d" class="nf la it nu b gy od oe l of og">genres_to_include = genres = ['dance pop', 'electronic', 'electropop', 'hip hop', 'jazz', 'k-pop', 'latin', 'pop', 'pop rap', 'r&amp;b', 'rock']<br/>track_with_year_and_genre = join_genre_and_date(artists_data, albums_data, tracks_data)<br/>filtered_track_df = get_filtered_track_df(track_with_year_and_genre, genres_to_include)</span></pre><p id="2b79" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之后，我们对稍后将使用的<code class="fe nr ns nt nu b">uri</code>列做一些预处理，并进一步删除不相关的列:</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="48be" class="nf la it nu b gy od oe l of og">filtered_track_df["uri"] = filtered_track_df["uri"].str.replace("spotify:track:", "")<br/>filtered_track_df = filtered_track_df.drop(columns=['analysis_url', 'available_markets'])</span></pre><p id="3346" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">预处理后的数据如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/942c03a50e54bae912e872ee74c305f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3fpuLLDOOOxsK_z2FcI4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预处理数据集</p></figure><p id="7e96" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们将其保存到一个<code class="fe nr ns nt nu b">csv</code>文件中:</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="29a4" class="nf la it nu b gy od oe l of og">filtered_track_df.to_csv("filtered_track_df.csv", index=False)</span></pre><h1 id="8186" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">主应用程序</h1><p id="1660" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了预处理过的数据集，我们可以开始构建我们的主应用程序了。我们将使用Streamlit，这是一个Python web框架，用于构建机器学习和数据科学的web应用程序。如果这是你第一次听说它，请随意查看它的文档！</p><h2 id="67a8" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">安装库</h2><p id="4440" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">开始构建我们的应用程序的第一步是安装库，如果你还没有这样做的话。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="b230" class="nf la it nu b gy od oe l of og">pip install streamlit<br/>pip install pandas<br/>pip install plotly<br/>pip install scikit-learn</span></pre><p id="655e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除了Streamlit，我们还将使用Pandas来加载我们的数据，plotly用于可视化，scikit-learn用于实现我们的机器学习模型。</p><p id="5842" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的环境中安装了库之后，我们可以创建一个名为<code class="fe nr ns nt nu b">app.py</code>的文件，并开始编写Streamlit代码。</p><p id="d466" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们首先导入我们需要的库。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="a355" class="nf la it nu b gy od oe l of og">import streamlit as st<br/>st.set_page_config(page_title="Song Recommendation", layout="wide")</span><span id="4460" class="nf la it nu b gy oh oe l of og">import pandas as pd<br/>from sklearn.neighbors import NearestNeighbors<br/>import plotly.express as px<br/>import streamlit.components.v1 as components</span></pre><p id="9005" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，我们在导入Streamlit后设置页面配置，以便利用整个布局空间。</p><h2 id="eaf6" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">加载数据</h2><p id="7224" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">导入所需的库后，我们编写一个函数来加载之前保存的预处理过的<code class="fe nr ns nt nu b">.csv</code>数据。我们还使用Streamlit内置函数<code class="fe nr ns nt nu b">@st.cache</code>保存缓存以加快加载速度。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="182a" class="nf la it nu b gy od oe l of og"><a class="ae ky" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank">@st</a>.cache(allow_output_mutation=True)<br/>def load_data():<br/>    df = pd.read_csv("data/filtered_track_df.csv")<br/>    df['genres'] = df.genres.apply(lambda x: [i[1:-1] for i in str(x)[1:-1].split(", ")])<br/>    exploded_track_df = df.explode("genres")<br/>    return exploded_track_df</span></pre><p id="f189" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们定义用户可以从中选择的风格列表，以及用户可以定制的音频特性列表。请注意，这里使用的流派列表与我们预处理数据时使用的相同。我们也称上面定义的<code class="fe nr ns nt nu b">load_data</code>。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="8e34" class="nf la it nu b gy od oe l of og">genre_names = ['Dance Pop', 'Electronic', 'Electropop', 'Hip Hop', 'Jazz', 'K-pop', 'Latin', 'Pop', 'Pop Rap', 'R&amp;B', 'Rock']<br/>audio_feats = ["acousticness", "danceability", "energy", "instrumentalness", "valence", "tempo"]</span><span id="0ca5" class="nf la it nu b gy oh oe l of og">exploded_track_df = load_data()</span></pre><h2 id="dd19" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">k-NN机器学习模型</h2><p id="2e4d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">加载数据后，我们可以开始构建我们的机器学习模型来推荐歌曲。有许多方法可以解决这个问题。一种简单的方法是使用k最近邻模型来获得在距离上与用户选择的特征输入集最接近的热门歌曲。这些“特征输入”包括感兴趣的流派、发行年份范围(开始年份和结束年份)和一组音频特征(声音、可跳舞性、能量、乐器性、效价、速度)。</p><p id="113b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用Sklearn来构建k-NN模型，并返回给定测试点的top-k结果。为了执行上述功能，我们编写了函数<code class="fe nr ns nt nu b">n_neighbors_uri_audio</code>，它将按照排名的升序返回顶部邻居的Spotify URIs和音频特征值(最接近输入特征的点排在第一位)。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="3a7b" class="nf la it nu b gy od oe l of og">def n_neighbors_uri_audio(genre, start_year, end_year, test_feat):<br/>    genre = genre.lower()<br/>    genre_data = exploded_track_df[(exploded_track_df["genres"]==genre) &amp; (exploded_track_df["release_year"]&gt;=start_year) &amp; (exploded_track_df["release_year"]&lt;=end_year)]<br/>    genre_data = genre_data.sort_values(by='popularity', ascending=False)[:500]</span><span id="d9cb" class="nf la it nu b gy oh oe l of og">    neigh = NearestNeighbors()<br/>    neigh.fit(genre_data[audio_feats].to_numpy())</span><span id="461b" class="nf la it nu b gy oh oe l of og">    n_neighbors = neigh.kneighbors([test_feat],       n_neighbors=len(genre_data), return_distance=False)[0]</span><span id="b899" class="nf la it nu b gy oh oe l of og">    uris = genre_data.iloc[n_neighbors]["uri"].tolist()<br/>    audios = genre_data.iloc[n_neighbors][audio_feats].to_numpy()<br/>    return uris, audios</span></pre><p id="b4f1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，我们只使用属于某个流派的前500首最受欢迎的歌曲，以便我们的系统推荐的歌曲会更受欢迎。如果你不介意被推荐不太受欢迎的歌曲，请随意使用这个数字或删除它。</p><h2 id="c49a" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">应用布局和集成</h2><p id="e378" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，终于到了构建应用程序最激动人心的部分:前端布局的时候了！在我们的主页中，我们可以有一个巨大的标题，上面写着“歌曲推荐引擎”和一个仪表板，允许用户定制他们想听的歌曲。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="ca39" class="nf la it nu b gy od oe l of og">title = "Song Recommendation Engine"<br/>st.title(title)</span><span id="788a" class="nf la it nu b gy oh oe l of og">st.write("First of all, welcome! This is the place where you can customize what you want to listen to based on genre and several key audio features. Try playing around with different settings and listen to the songs recommended by our system!")<br/>st.markdown("##")</span><span id="5967" class="nf la it nu b gy oh oe l of og">with st.container():<br/>    col1, col2,col3,col4 = st.columns((2,0.5,0.5,0.5))<br/>    with col3:<br/>        st.markdown("***Choose your genre:***")<br/>        genre = st.radio(<br/>            "",<br/>            genre_names, index=genre_names.index("Pop"))<br/>    with col1:<br/>        st.markdown("***Choose features to customize:***")<br/>        start_year, end_year = st.slider(<br/>            'Select the year range',<br/>            1990, 2019, (2015, 2019)<br/>        )<br/>        acousticness = st.slider(<br/>            'Acousticness',<br/>            0.0, 1.0, 0.5)<br/>        danceability = st.slider(<br/>            'Danceability',<br/>            0.0, 1.0, 0.5)<br/>        energy = st.slider(<br/>            'Energy',<br/>            0.0, 1.0, 0.5)<br/>        instrumentalness = st.slider(<br/>            'Instrumentalness',<br/>            0.0, 1.0, 0.0)<br/>        valence = st.slider(<br/>            'Valence',<br/>            0.0, 1.0, 0.45)<br/>        tempo = st.slider(<br/>            'Tempo',<br/>            0.0, 244.0, 118.0)</span></pre><p id="a0c2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要在localhost上运行streamlit应用程序，可以运行:</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="adf4" class="nf la it nu b gy od oe l of og">streamlit run app.py</span></pre><p id="c4f3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将呈现网页:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/867cc13131ef9d511aaa68831e4b3874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QO2A2HPtSlj6RbFgjWOsqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仪表板布局</p></figure><p id="9dae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">看起来不错！你可以定制你想要的仪表盘，改变你喜欢的输入风格。</p><p id="760d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在构建仪表板之后，我们可以使用用户选择的功能来显示要推荐的歌曲。为此，我们可以调用前面定义的<code class="fe nr ns nt nu b">n_neighbors_uri_audio</code>函数。为了显示推荐的歌曲，我们可以使用<a class="ae ky" href="https://developer.spotify.com/documentation/widgets/generate/embed/" rel="noopener ugc nofollow" target="_blank"> Spotify开发者小部件</a>来显示一个使用经典HTML的iframe。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="ea03" class="nf la it nu b gy od oe l of og">tracks_per_page = 6<br/>test_feat = [acousticness, danceability, energy, instrumentalness, valence, tempo]<br/>uris, audios = n_neighbors_uri_audio(genre, start_year, end_year, test_feat)</span><span id="a198" class="nf la it nu b gy oh oe l of og">tracks = []<br/>for uri in uris:<br/>    track = """&lt;iframe src="<a class="ae ky" href="https://open.spotify.com/embed/track/{" rel="noopener ugc nofollow" target="_blank">https://open.spotify.com/embed/track/{</a>}" width="260" height="380" frameborder="0" allowtransparency="true" allow="encrypted-media"&gt;&lt;/iframe&gt;""".format(uri)<br/>    tracks.append(track)</span></pre><p id="8c0b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">给定一组输入，我们希望能够推荐更多的歌曲，这样用户就有更多的选择，而不是只显示前6首歌曲。因此，我们可以添加一个“推荐更多歌曲”按钮。为了支持这一点，我们需要使用<a class="ae ky" href="https://docs.streamlit.io/library/api-reference/session-state" rel="noopener ugc nofollow" target="_blank"> Streamlit的会话状态</a>来在每个用户会话的重新运行之间共享变量。我们可以使用会话状态来检查用户是否更改了任何输入。如果用户改变任何输入，系统需要从(顶部邻居的)开始推荐。如果用户继续按“推荐更多歌曲”按钮而不改变任何输入，则将遍历顶部邻居，直到顶部邻居列表的末尾。请记住，推荐的歌曲按其排名的升序排列。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="f5d0" class="nf la it nu b gy od oe l of og">if 'previous_inputs' not in st.session_state:<br/>    st.session_state['previous_inputs'] = [genre, start_year, end_year] + test_feat</span><span id="66e8" class="nf la it nu b gy oh oe l of og">current_inputs = [genre, start_year, end_year] + test_feat<br/>if current_inputs != st.session_state['previous_inputs']:<br/>    if 'start_track_i' in st.session_state:<br/>        st.session_state['start_track_i'] = 0<br/>    st.session_state['previous_inputs'] = current_inputs</span><span id="badf" class="nf la it nu b gy oh oe l of og">if 'start_track_i' not in st.session_state:<br/>    st.session_state['start_track_i'] = 0</span></pre><p id="40ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">设置会话状态后，我们可以在布局中显示推荐的歌曲，并实现“推荐更多歌曲”按钮。我们还可以显示每首歌曲的雷达图，显示其音频特征的值。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="ba94" class="nf la it nu b gy od oe l of og">with st.container():<br/>    col1, col2, col3 = st.columns([2,1,2])<br/>    if st.button("Recommend More Songs"):<br/>        if st.session_state['start_track_i'] &lt; len(tracks):<br/>            st.session_state['start_track_i'] += tracks_per_page</span><span id="4cf9" class="nf la it nu b gy oh oe l of og">current_tracks = tracks[st.session_state['start_track_i']: st.session_state['start_track_i'] + tracks_per_page]<br/>    current_audios = audios[st.session_state['start_track_i']: st.session_state['start_track_i'] + tracks_per_page]<br/>    if st.session_state['start_track_i'] &lt; len(tracks):<br/>        for i, (track, audio) in enumerate(zip(current_tracks, current_audios)):<br/>            if i%2==0:<br/>                with col1:<br/>                    components.html(<br/>                        track,<br/>                        height=400,<br/>                    )<br/>                    with st.expander("See more details"):<br/>                        df = pd.DataFrame(dict(<br/>                        r=audio[:5],<br/>                        theta=audio_feats[:5]))<br/>                        fig = px.line_polar(df, r='r', theta='theta', line_close=True)<br/>                        fig.update_layout(height=400, width=340)<br/>                        st.plotly_chart(fig)<br/>        <br/>            else:<br/>                with col3:<br/>                    components.html(<br/>                        track,<br/>                        height=400,<br/>                    )<br/>                    with st.expander("See more details"):<br/>                        df = pd.DataFrame(dict(<br/>                            r=audio[:5],<br/>                            theta=audio_feats[:5]))<br/>                        fig = px.line_polar(df, r='r', theta='theta', line_close=True)<br/>                        fig.update_layout(height=400, width=340)<br/>                        st.plotly_chart(fig)</span><span id="a5d2" class="nf la it nu b gy oh oe l of og">else:<br/>        st.write("No songs left to recommend")</span></pre><p id="74f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您再次运行整个时，您将得到以下应用程序！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/c03a77673e308c121c5818351c67c085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kv2gKvTaYKAZjw1K81M2_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">歌曲显示布局</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2344f1ab1dceb1948d5e7a01de9e6129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4MPU4W83dyT54uvPmKrlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">歌曲显示布局</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/b90b3d6342309b70b93e89a256a754b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Upoai3A97r8WLiHMWrNB8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新航<em class="om">吊灯</em>雷达图</p></figure><p id="d601" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以验证歌曲是否与用户选择的输入匹配，以及“推荐更多歌曲”按钮是否有效！这个应用程序最棒的地方在于，你不仅可以探索新歌，还可以直接播放歌曲预览(如果你有Spotify，甚至可以播放整首歌)。现在你可以坐下来享受你最喜欢的音乐了！</p><p id="0e7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了方便起见，下面是<code class="fe nr ns nt nu b">app.py</code>的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h1 id="d8dd" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">部署</h1><p id="710e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我让你进入自己的音乐世界之前，这里有一个额外的部分来教你如何部署这个应用程序，让世界看到。</p><p id="026d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">说到web部署，有大量选项可供选择。<a class="ae ky" href="https://docs.streamlit.io/streamlit-cloud/get-started/deploy-an-app" rel="noopener ugc nofollow" target="_blank"> Streamlit Cloud </a>支持自己的部署服务，但是我个人觉得<a class="ae ky" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>过去非常好用，所以我就用这个。</p><h2 id="b168" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">创建必要的文件</h2><p id="9cd3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">以下是您需要在Heroku上部署的文件:</p><ul class=""><li id="9aa6" class="op oq it lt b lu mn lx mo ma or me os mi ot mm ou ov ow ox bi translated">requirements.txt :一个文本文件，包含应用程序所需的所有依赖项及其版本的列表</li><li id="1c5c" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><strong class="lt iu"> setup.sh </strong>:在Heroku上设置app的Shell文件</li><li id="ba81" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><strong class="lt iu">proc file</strong>:Heroku用来运行和启动app的入口点</li></ul><p id="76b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在应用程序的根目录中创建这三个文件，并将以下内容复制粘贴到您自己的目录中。</p><p id="1c64" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> requirements.txt </strong></p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="7f40" class="nf la it nu b gy od oe l of og">streamlit==1.0.0<br/>pandas==1.3.3<br/>plotly==5.3.1<br/>scikit-learn==0.23.2</span></pre><p id="8e50" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> setup.sh </strong></p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="f5e5" class="nf la it nu b gy od oe l of og">mkdir -p ~/.streamlit/<br/>echo "\<br/>[server]\n\<br/>headless = true\n\<br/>port = $PORT\n\<br/>enableCORS = false\n\<br/>" &gt; ~/.streamlit/config.toml</span></pre><p id="af5d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">过程文件</strong></p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="c4b4" class="nf la it nu b gy od oe l of og">web: sh setup.sh &amp;&amp; streamlit run app.py</span></pre><h2 id="0d0c" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">创建一个Github存储库(如果还没有的话)</h2><p id="e15a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，您应该创建一个github repo。然后，您可以使用以下代码将您的代码推送到repo。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="3baf" class="nf la it nu b gy od oe l of og">echo "# song_recommendation" &gt;&gt; README.md<br/>git init<br/>git add .<br/>git commit -m "first commit"<br/>git branch -M main<br/>git remote add origin <a class="ae ky" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:[username]/[repo_name].git<br/>git push -u origin main</span></pre><p id="85de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">运行上述命令后，您应该看到您的代码被推送到repo。</p><h2 id="405d" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">创建Heroku帐户并安装Heroku CLI</h2><p id="ae19" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在收集了必要的文件和Github repo之后，我们现在可以创建一个Heroku帐户了。导航到Heroku的主要网站创建帐户。</p><div class="pd pe gp gr pf pg"><a href="https://www.heroku.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">云应用平台| Heroku</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">无论您是在构建简单的原型还是关键业务产品，Heroku的全托管平台都能为您提供…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">www.heroku.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div><p id="78e1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">创建帐户后，安装Heroku CLI:</p><div class="pd pe gp gr pf pg"><a href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">Heroku CLI</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">Heroku命令行界面(CLI)使得直接从终端创建和管理您的Heroku应用程序变得非常容易…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">devcenter.heroku.com</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu ks pg"/></div></div></a></div><h2 id="eb72" class="nf la it bd lb ng nh dn lf ni nj dp lj ma nk nl ll me nm nn ln mi no np lp nq bi translated">部署到Heroku</h2><p id="9a26" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们有了部署到Heroku的所有工具！最后一步是运行以下命令登录到您的帐户，构建您的应用程序，并进行部署。</p><pre class="kj kk kl km gt nz nu oa ob aw oc bi"><span id="24ea" class="nf la it nu b gy od oe l of og">heroku login<br/>heroku create [app_name]<br/>git push heroku main</span></pre><p id="d595" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="nv">注意:无论何时修改代码，都要记得在推送到heroku main之前进行git add和commit。</em></p><p id="e1c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">恭喜你！您现在应该可以在<code class="fe nr ns nt nu b">[app_name].herokuapp.com</code>上看到您的应用正在运行。</p><p id="4d07" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我已经在Heroku上部署了这个应用程序的一个版本，你可以在这里访问:<a class="ae ky" href="https://song-recommendation-streamlit.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">song-recommendation-streamlit.herokuapp.com</a>。本文中显示的代码可以在<a class="ae ky" href="https://github.com/itsuncheng/song_recommendation" rel="noopener ugc nofollow" target="_blank">这个github库</a>中找到。</p><h1 id="5042" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="9952" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我希望你们都从这篇教程中学到了一些东西！简而言之，我们建立了一个歌曲推荐引擎，它可以接受用户的音乐偏好，并找到与他们最匹配的歌曲。我们通过使用k-NN模型来实现这一点。为了演示推荐系统，我们使用Streamlit构建了web应用程序，并将其部署在Heroku上。</p><p id="a8ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我希望你们都喜欢这篇文章。请随意使用推荐系统，并让我知道您的想法！以后有更多精彩的帖子可以随时关注我。下期再见，注意安全！</p><p id="2570" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另外，请随意查看我的其他一些有趣的帖子:</p><div class="pd pe gp gr pf pg"><a href="https://medium.datadriveninvestor.com/beginners-guide-to-web-scraping-using-beautifulsoup-and-python-999a927f20e6" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">使用BeautifulSoup和Python的Web抓取初学者指南</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">简单的教程涵盖了美丽的基础知识，并举例说明了如何抓取维基百科的文章</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="pp l"><div class="pw l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/beginners-guide-to-regular-expressions-in-python-d16d2fa31587"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">Python正则表达式初学者指南</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">关于正则表达式的简单教程，涵盖了你需要知道的所有基础知识</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="px l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/top-nlp-books-to-read-2020-12012ef41dc1"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">2020年最佳NLP读物</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">这是我个人为自然语言处理推荐的书籍列表，供实践者和理论家参考</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="py l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/top-nlp-libraries-to-use-2020-4f700cdb841f"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">2020年将使用的顶级NLP库</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">AllenNLP，Fast.ai，Spacy，NLTK，TorchText，Huggingface，Gensim，OpenNMT，ParlAI，DeepPavlov</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pz l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a rel="noopener follow" target="_blank" href="/deepstyle-f8557ab9e7b"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">DeepStyle(第1部分):使用最先进的深度学习生成高级时尚服装和…</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">附带论文和Github代码提供！</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="qa l pr ps pt pp pu ks pg"/></div></div></a></div><h1 id="cce6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><ul class=""><li id="5704" class="op oq it lt b lu lv lx ly ma qb me qc mi qd mm ou ov ow ox bi translated"><a class="ae ky" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"> Streamlit网站</a></li><li id="c477" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><a class="ae ky" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank"> Sklearn网站</a></li><li id="53df" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><a class="ae ky" href="http://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku网站</a></li><li id="25e9" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫网站</a></li><li id="4c76" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><a class="ae ky" href="https://www.spotify.com/" rel="noopener ugc nofollow" target="_blank"> Spotify网站</a></li><li id="69ee" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><a class="ae ky" href="https://www.kaggle.com/saurabhshahane/spotgen-music-dataset" rel="noopener ugc nofollow" target="_blank"> Spotify和Genius曲目数据集</a>，Kaggle</li><li id="8a40" class="op oq it lt b lu oy lx oz ma pa me pb mi pc mm ou ov ow ox bi translated"><a class="ae ky" href="https://developer.spotify.com/documentation/widgets/generate/embed/" rel="noopener ugc nofollow" target="_blank"> Spotify嵌入式API </a>，面向开发者的Spotify</li></ul></div></div>    
</body>
</html>