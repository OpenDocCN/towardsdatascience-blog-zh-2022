# Python 和真相

> 原文：<https://towardsdatascience.com/python-and-the-truth-90cf08380246>

## 以及类型对它的反应

![](img/db5944ad6bcac3ba3134dc2678e191f0.png)

马库斯·温克勒的照片，Unspash。

一段代码的逻辑流程可以想象成一棵树的树枝。条件帮助开发人员处理特定的情况，一般来说，它们以特性和验证的形式增加了新的分支。

**布尔值**给数据结构带来意义。任何数字或字符串本身都不是正确或错误的，直到我们将其与我们的**规则**和期望进行比较。

如果我的杯子空了，我会倒更多的咖啡；但是如果我没有足够的咖啡，我需要去商店。如果是星期天，商店关门，零咖啡，我会难过。

人们已经将他们的大部分日常事务和互动建立在一套隐含应用的规则之上，这些规则基于**值**和**状态**。例如，如果我的咖啡少于 7 粒，我就不能准备更多的咖啡，如果杯子的状态是`Empty`，我会把它装满。

然而，Python 为对象赋予了真值，即使没有构建条件表达式。在本帖中，我们将探索真值背后的定义，如何操作它们并避免讨厌的错误，以及如何调整自定义类的真值。

# 真实与虚假

Python 对象根据它们的值或状态持有一个`True`或`False`表示。默认情况下，所有值都是`True`减去一个特定的集合。

请注意我们是如何将任何类型直接转换成`bool`的。如果结果是`True`，否则我们就说这个值是*真、*或*假。访问值的真实性允许我们在条件或布尔运算中直接使用它们，而无需添加任何比较。*

现在，这个逻辑是如何用 Python 编程的呢？如果你从来没有这样做过，我建议你读一些标准类型的`help`，比如`str`或者`int`。如果我们分析这两个，我们会发现一些有趣的定义:

请注意，如果`int`值不等于 0，则它们是`True`，如果所有`str`的长度不等于 0，则它们都是`True`，即使没有实现`__bool__`。如果我们看一下`object`的 Python [文档](https://docs.python.org/3/reference/datamodel.html#object.__bool__)，我们会看到对这种行为的解释:

> `object.**__bool__**` ( *自我*)
> 
> 被调用来实现真值测试和内置操作`bool()`；应返回`False`或`True`。当这个方法没有被定义时，调用`[__len__()](https://docs.python.org/3/reference/datamodel.html#object.__len__)`，如果它被定义，并且如果它的结果是非零的，对象被认为是真的。如果一个类既没有定义`[__len__()](https://docs.python.org/3/reference/datamodel.html#object.__len__)`也没有定义`[__bool__()](https://docs.python.org/3/reference/datamodel.html#object.__bool__)`，那么它的所有实例都被认为是真的。

有了这个定义，我们可以快速扩展任何序列或迭代器对象的答案，甚至将其应用于我们的自定义类。

# 如果你是认真的，请不要勾选

我们在上面的例子中忽略的一个独特的对象是`None`。通过添加类型提示，在阅读代码和对缺失值进行干净的异常管理时，使用`Optional` s 是一个巨大的帮助。

然而，如果我们在检查这种特定情况时没有注意，我们可能会隐藏一些难以调试的问题。拥有一个缺失值`None`和拥有一个真值为`False`的值是不同的。

由于`None`的`bool`值为`False`，第一个场景将捕捉到缺失的`count`和`count == 0`。而第二个将只为`None`显式执行。

这里没有好坏之分，但是你必须考虑什么对你的商业逻辑有意义。

# 玩弄真相

了解 Python 如何将`True`或`False`赋给它的类型允许我们在我们的类中复制行为，这可以方便地使代码更简单和更有表现力。

有了一个相对简单的定义，我们可以重用一个整数的真值，我们可以顺利地识别空咖啡杯。

# 布尔运算符

此外，理解值的真实度 使用布尔运算符打开了一扇令人兴奋的门。它们不仅可以应用于`if`和`while`条件，还可以基于现有对象的真实性定义新的变量。我们将根据这份[文档](https://docs.python.org/3/library/stdtypes.html#truth-value-testing)来完成:

注意我们如何应用`or`和`and`操作符来获得有趣的结果，特别是在表达式求值方面。根据第一个论点的真实性，第二个论点可能会也可能不会被评估。这被称为**短路**，它允许我们仅在需要或需要满足特定条件时延迟特定的执行。

假设我们正在开发一个银行应用程序。查询账户资金，需要告知密码；否则，可能会发生异常。

通过短路条件，只有在正确告知密码的情况下，`get_funds()`才会被(安全地)执行。否则，函数不会被求值，因为结果布尔表达式已经是`False`。

# 结论

Python 的灵活性有时是有代价的。例如，不知道特定行为的开发人员可能会用小的实现细节来掩盖实际的程序逻辑。解药？好奇心和测试。

在这篇文章中，我们看到了 Python 如何将对象转换成`bool`，这在条件和布尔运算中是一个强大的工具。我们还将这些定义应用于一个定制类，同时学习关注逻辑的细节。

简而言之，这是 Python 的[禅仍然正确的又一个例子:“显式比隐式好”。认真检查`None`！](https://peps.python.org/pep-0020/)