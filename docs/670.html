<html>
<head>
<title>How To Use PyCall.jl: Python Libraries In Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Julia中使用PyCall.jl: Python库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-pycall-jl-python-libraries-in-julia-7f0e7a47ba70#2022-01-24">https://towardsdatascience.com/how-to-use-pycall-jl-python-libraries-in-julia-7f0e7a47ba70#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="2eda" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">如何在Julia中使用PyCall.jl: Python库</h1></div><div class=""><h2 id="dce9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Julia的PyCall包的概述，以及更多关于它的有用性和可用性的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/50c314644529239dbfecec7c844c3c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H4zCeuFMabhJfegvAw6UGg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这么多书，简直就像两个图书馆的总和！(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://pixabay.com/images/id-1281581/" rel="noopener ugc nofollow" target="_blank">像素</a>提供)</p></figure><h1 id="4d48" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="6412" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在我们今天生活的计算世界中，引入一种新的编程语言的最大问题之一将是它的生态系统。它类似于操作系统和计算机现在普遍面临的一些问题。许多技术是建立在工具之上的，这些工具要么已经过时，要么我们知道用我们新发现的知识可以写得更好。尽管这可能会有问题，但在某些情况下，当涉及到软件时，抱着“如果它没有坏，就不要修复它”的心态是有意义的，除非我们想用余生来重写为90年代的系统编写的代码。</p><p id="dfcc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我的观点是，从零开始创建一个全新的生态系统是非常困难的，特别是对于一种从无到有并试图在没有生态系统的情况下建立自己的语言。在大多数情况下，除非这种好处真的值得，否则我怀疑大多数人甚至会采用一种新语言。有很多新的东西需要学习，从语法到错误输出和调试，到如何处理包，甚至安装一种编程语言都可能令人困惑，正如我在Fedora系统上安装标准元语言时很好地展示的那样。这还没有触及学习如何对抗一个全新的工具生态系统的挑战。</p><p id="9558" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">幸运的是，对于那些用渴望的眼光看着Julia的人来说，你真的不需要学习Julia生态系统来尝试从Python开始。这可以通过PyCall.jl包来完成，正如人们所预料的那样，这个包用于调用Python包。Julia处理这个问题的另一种方式是多重调度通常如何使整个生态系统更加一致，这一点我不会在本文中讨论，但肯定值得注意。我最近写了另一篇文章，详细介绍了如何在自己的代码中使用这种技术，以及它对Julian软件包的影响。事不宜迟，让我们来看看PyCall.jl。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="0272" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">设置</h1><p id="a263" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我必须承认，我已经很久没有使用PyCall.jl包了。坦白地说，自从我上次接触这个软件包以来，Julia的生态系统已经有了显著的增长，这种语言的用户群也是如此。为了证明这一点，我想让你们注意一下这张由<a class="ne nf ep" href="https://medium.com/u/2c8aac9051d3?source=post_page-----7f0e7a47ba70--------------------------------" rel="noopener" target="_blank">洛根·基尔帕特里克</a>提供的图片，他是一位Julia语言的开发者和社区倡导者(Julia info的优秀用户)。):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5512" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我想说的是，随着Julia的广泛应用，PyCall.jl包就变得不那么需要了，因为很多时候已经用Julia编写了某种功能的模块实现。虽然有时文档和这些东西可能有点参差不齐，但一般来说，大多数Julia包都相当一致且易于使用。也就是说，PyCall.jl仍然是Python开发人员进入Julia的一个途径，而不需要学习一个全新的工具生态系统，这就是我希望这篇文章针对的目标。考虑到这种语言在过去几年中的发展，数据科学领域的人可能至少应该以某种方式熟悉这种语言。也就是说，用PyCall来尝试它是体验Julia的一种真正安全的方式，不会产生信息过载。此外，对于使用像Tensorflow over Flux.jl这样的软件也有一些争论，例如，在工业中仅仅是为了成熟——此外还有Google——出错的能力。</p><p id="fbd4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">今天我们将看看如何使用Pandas来管理Julian数据，尽管DataFrames.jl、Julia的内置线性代数以及Julia中的其他解决方案非常强大，但是叫Pandas有点傻，很难学习一个全新的软件包和一门全新的语言，所以让我们开始吧！</p><p id="a1e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用PyCall.jl其实真的很简单，第一步就是安装。我们可以通过Julia中的包Pkg的方法或者我倾向于使用的Pkg命令REPL来使用Pkg。在朱莉娅·REPL中按下]就可以进入REPL，这非常方便。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="801a" class="nn la it nj b gy no np l nq nr">using Pkg; Pkg.add("PyCall")</span><span id="e633" class="nn la it nj b gy ns np l nq nr">julia&gt; ]</span><span id="614a" class="nn la it nj b gy ns np l nq nr">pkg&gt; add PyCall</span></pre><p id="cc42" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你不像我一样使用Linux，你也需要在你的机器上安装Python的标准版本。当然，您将在Linux上需要它，但是您可能已经有了它。如果一切正常，您现在应该能够使用PyCall了。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0016" class="nn la it nj b gy no np l nq nr">using PyCall</span></pre><p id="840b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您想指定使用特定版本的PYTHON，您需要定义一个环境变量Python，然后使用Pkg构建PyCall.jl。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="f277" class="nn la it nj b gy no np l nq nr"># ENV["PYTHON"] = "/usr/bin/python3.7"<br/>bash&gt; julia</span><span id="6725" class="nn la it nj b gy ns np l nq nr">julia&gt; ]<br/>pkg&gt; build PyCall</span></pre><h1 id="d422" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用PyCall.jl</h1><p id="1eb3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经在机器上安装了PyCall，让我们实际开始使用这个包。对于接下来的部分，我将在一个小示例笔记本上工作。这里有一个Github上的笔记本链接，如果你想自己尝试这段代码的话:</p><div class="nt nu gp gr nv nw"><a href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Julia/pycall%20basic%20examples.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">Emmetts-DS-NoteBooks/py call basic examples . ipynb at master emmett GB/Emmetts-DS-NoteBooks</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">各种项目的随机笔记本。通过创建帐户，为emmettgb/Emmetts-DS笔记本电脑的开发做出贡献…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><h2 id="5a94" class="nn la it bd lb ol om dn lf on oo dp lj ma op oq ll me or os ln mi ot ou lp ov bi translated">执行Python</h2><p id="95a1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们实际上可以使用字符串在当前的Julia环境下执行整个Python环境。为了使一个字符串成为Python代码，我们只需在多行字符串前添加py，如下例所示，我创建了一个add20函数:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="87ab" class="nn la it nj b gy no np l nq nr">py"""<br/>def add20(x):<br/>    return x + 20<br/>"""</span></pre><p id="0223" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用相同的语法，在某种程度上，通过提供Julia中的参数来插入它，以获得Julia中的返回:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="2899" class="nn la it nj b gy no np l nq nr">py"add20"(20)</span><span id="cade" class="nn la it nj b gy ns np l nq nr">40</span></pre><p id="ad5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这被视为常规返回，此外，类型保存得非常好，这令人印象深刻。</p><h2 id="2318" class="nn la it bd lb ol om dn lf on oo dp lj ma op oq ll me or os ln mi ot ou lp ov bi translated">导入Python</h2><p id="0c67" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然像我们刚才做的那样交替使用Python和Julia非常令人兴奋，但这可能也不是人们试图从Julia中使用Python的原因。这个包最流行的用法可能是从Python生态系统中导入包。正如我之前所说的，我们将在Julia中制作一个熊猫数据框，这实际上非常简单。第一步是使用pyimport()方法导入我们的包:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="d187" class="nn la it nj b gy no np l nq nr">pd = pyimport("pandas")</span><span id="3d87" class="nn la it nj b gy ns np l nq nr">PyObject &lt;module 'pandas' from '/usr/lib64/python3.9/site-packages/pandas/__init__.py'&gt;</span></pre><p id="f55f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这给了我们一个PyObject类型的返回——这很好。该模块能够拥有Python生态系统中的许多相同的行为和语法，这一切都是通过这一行代码完成的——这简直是荒谬的声明性。我们还可以按照您的预期创建数据框:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c114" class="nn la it nj b gy no np l nq nr">df = pd.DataFrame(Dict(:A =&gt; [5, 10, 15], :B =&gt; [5, 10, 15]))</span></pre><p id="96d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，作为新构造对象的子对象的函数可以按照您预期的方式调用:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="640b" class="nn la it nj b gy no np l nq nr">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/fa5f17f959c85b7383b5344a5924db71.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*Z3hcm3kBW-994oEEfAhuTw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c80a" class="nn la it nj b gy no np l nq nr">df.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/f106a89f35b99ccbe0a9e523eaea804d.png" data-original-src="https://miro.medium.com/v2/resize:fit:350/format:webp/1*E-B1ptO5Bq4C6-PErRBPpg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><h1 id="f6ef" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">表演</h1><p id="6b63" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">人们转向Julia的一个重要原因是因为性能，正如这篇著名的博客文章所详述的，Julia最初是被创造出来的。也就是说，在从Python切换到Julia的过程中，也许没有一个Julia包可以做你需要做的事情，一个很好的问题是，我们是否会获得任何额外的性能优势或障碍，因为我们从Julia调用Python，而不仅仅是编写Python。我想说的第一件事是内存使用。</p><h2 id="63d8" class="nn la it bd lb ol om dn lf on oo dp lj ma op oq ll me or os ln mi ot ou lp ov bi translated">记忆</h2><p id="74f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我在使用PyCall时遇到的一个大问题是，当涉及到内存使用时，PyCall真的会给你留下很多想象空间，尤其是在某种专业设置或开发环境中。也就是说，当Julia使用Python时，确实没有很好的方法来检查内存使用情况。了解这一点会很好，因为现在我们所得到的基本上是一个指向Julia中定义的PyObject的指针。这是有问题的，因为它们总是占用相同数量的内存。我觉得奇怪的是，varinfo()甚至不包含PyCall模块，还定义了一个不占用内存定义为nothing的p。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="8f62" class="nn la it nj b gy no np l nq nr">varinfo()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/619008f2e45adf499f8a6b1d13d6ade7.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*Gs0c7uw3FLzUEnGUHZdGlg.png"/></div></figure><p id="b9c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">(解释或更正刚说过的话)我是说..很难表达将Python这样的大模块加载到8 * 8位中是多么的不可能。对于那些不了解位和字节的人来说，给定文本文件中的每个字符就是一个字节的数据。此外，我们的DataFrame肯定不能是八个字节，因为它包含六个整数和两个标签，每个都是一个字节，再加上对象内部的方法，这些方法远不止一个字节。所以数据本身可能是八个字节，但对象作为一个整体肯定不是。确实有一些可以导入和使用的分析模块，但是所有这些都不会给我们任何关于PyCall使用了多少内存的信息，这正是我真正想要的。所以不幸的是，没有很好的方法来分析内存使用情况——这可能也是切换到Julia包的一个很好的原因，但是计算时间呢，这可能是Python的最大障碍。</p><h2 id="8194" class="nn la it bd lb ol om dn lf on oo dp lj ma op oq ll me or os ln mi ot ou lp ov bi translated">口译时报</h2><p id="7f75" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如你所料，我们将使用不同的笔记本来比较Python和Julia。记住，这些将是每个计算的内核化版本，这肯定会影响时间——然而，根据我的经验，IJulia通常能够以与REPL相同的速度运行，有时会落后几毫秒，所以我不确定这是一个大问题。我将使用标准的库模块timeit来为Python计算计时，并且我将为Julia使用@time宏。进口也将包括在测试中。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="32df" class="nn la it nj b gy no np l nq nr"><a class="ae ky" href="http://twitter.com/time" rel="noopener ugc nofollow" target="_blank">@time</a> begin <br/>    df = pd.DataFrame(Dict("A" =&gt; r.randn(1000000), "B" =&gt; r.randn(1000000)))<br/>end</span><span id="15a5" class="nn la it nj b gy ns np l nq nr">r = pyimport("numpy.random")</span></pre><p id="0668" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">重要的一点是，我重启了内核。Julia有很多JIT缓存和预编译的魔法，所以当涉及到这类事情时，这绝对是我会做的事情，以获得准确的基准。这是我们的Julia结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/c8cdc779dd551a4835e3c301bb262726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOUStKM9Uub5OXN5rzsB8w.png"/></div></div></figure><blockquote class="pa pb pc"><p id="7cf2" class="lr ls pd lt b lu mn ju lw lx mo jx lz pe mp mc md pf mq mg mh pg mr mk ml mm im bi translated">左边是Julia，右边是Python，只是澄清一下。</p></blockquote><p id="f2a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这种情况下，Julia确实稍微落后于Python。然而，在我看来，这其实是非常令人印象深刻的！Julia在使用另一种语言的包时仍能这么快，这一事实令人印象深刻。我还剩下大约1g的内存(我讨厌这里)，所以让我们滥用我的计算机，把那台改成3，这样我们就可以看到Julia是否开始用更多的值出错。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/7faff713db88a44ca38a530e0db205f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXXWdNHGivyLCUJLKtaIDw.png"/></div></div></figure><p id="9318" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">随着我们增加值的数量，我们看到Julia慢慢开始赶上Python。PyCall显然有一些开销，而且我们使用的是Python。老实说，这是意料之中的，老实说，我真的认为Python的Julia接口会导致比现在更多的开销。这确实说明了这个模块是多么令人印象深刻。</p><blockquote class="pi"><p id="d57f" class="pj pk it bd pl pm pn po pp pq pr mm dk translated">有人给我的电脑带来了一个除颤器。</p></blockquote></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8440" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结束语</h1><p id="96e5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">PyCall.jl已经存在一段时间了，我们可以看到Julia代码可以变得多么健壮和快速。尽管我们在这个实例中使用了Python，但Julia代码运行解释后的代码的速度仍然比纯Python代码快几毫秒。令人印象深刻！当然，这里真正重要的可能是FORTRAN或C代码，但无论哪种方式，我们通过两层语言调用代码并从中获得如此大的收益仍然是非常激进的。</p><p id="10dc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有这些都证明了Julia是一门很棒的语言，而且PyCall.jl是入门Julia的好方法。在学习Julia生态系统时，基本上不需要做任何工作，人们可以使用他们一直使用的相同的软件包，并在Julia中获得一定程度的经验。我认为使用PyCall.jl慢慢接近Julia是一个非常好的主意，PyCall的性能不会对任何试图这样做的人造成很大的阻碍。对于我的Pythonista读者，我希望这篇文章能让你想到在Julia中入门是多么容易。正如我前面提到的，这种语言正在迅速发展。老实说，我也不认为现在是学习它的最好时机，因为社区和生态系统现在都在爆炸。</p><p id="7138" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一点，我是一名数据科学家，因此我对数据科学感兴趣，我真的不介意关于数据科学或一般技术相关主题的直接消息、回复和类似的东西(不是垃圾邮件或奇怪的提议)。如果您对让Julia使用您的机器感兴趣，并且不知道从哪里开始，或者只是对共享一些信息感兴趣，请随时联系我！谢谢你读这篇文章，它对我来说意味着整个世界，我真的很感激！</p></div></div>    
</body>
</html>