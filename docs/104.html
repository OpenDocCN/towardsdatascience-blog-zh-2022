<html>
<head>
<title>A Generalized Quantum Linear Function</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个广义量子线性函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-generalized-quantum-linear-function-e73b6b7c3c80#2022-01-04">https://towardsdatascience.com/a-generalized-quantum-linear-function-e73b6b7c3c80#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""><h1 id="5e0c" class="pw-post-title ir is it bd iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp bi translated">一个广义量子线性函数</h1></div><div class=""><h2 id="babc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解量子数据科学的基本构建模块</h2></div><p id="9256" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_genlin&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><p id="3f6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上周，<a class="ae le" rel="noopener" target="_blank" href="/towards-a-generalized-quantum-linear-function-f682d572ee19">我们开发了我们的算法来创建一个量子线性函数</a>。它获取斜率和截距，并相应地准备量子位测量概率。但是，目前的版本只适用于两个量子位。</p><p id="b1c2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">在今天的帖子中，我们将该函数推广到任何数量的量子位。</strong></p><p id="b773" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但首先，让我们简单地看看算法如何对两个量子位产生以下结果。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/51e2a8fd87843cb3d47473f1fc4ae7f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aEAAlS7AL7mSr5b1XVMQDw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="4bdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们把所有的值分成相等的块。在最简单的情况下，块的大小代表斜率和截距(当斜率=截距时)。</p><p id="eca5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，第一个状态(00)有一个块(因为我们把这个状态解释为值0)，两个后续状态相差一个块。我们每走一步就增加一个模块。下图描述了这种方法。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/271e988d05b6c15c490551c42e5053de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iyUI0bDeCzX4mAy5QL0lHg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="dd5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，我们不能假设斜率和截距相等。因此，我们可能需要使用更小的块。那么，斜率(即a)和截距(即b)可能由多个块组成。但是总的方法保持不变。在下图中，我们使用单个块作为截距(b)，多个块作为斜率(a)。状态00只有拦截块。然后，我们根据坡度添加相应数量的块。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/b0d2937d8ae161cff504e0e03c57381d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9IcK8UuqtjvlXh1mz4MTJA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="62fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们的任务由两个要点组成:</p><ul class=""><li id="1b14" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">计算一个州应该拥有的街区数量</li><li id="0daa" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">准备量子位元，让状态的测量机率代表对应的数字</li></ul><p id="fa15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一项任务相当容易。如果我们知道状态的位置，那么块的数量对应于这个位置乘以代表斜率的块加上代表截距的块。在Python代码中，该函数是一行程序。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="08d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个任务稍微复杂一点。但也没那么难。</p><p id="df23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们看状态数时，我们看到它们是位串。每个位置表示相应量子位的值。例如，右边的数字代表最低量子位的值(在电路的位置0)。相应地，左边的数字代表最高量子位的值。在两个量子位的电路中，这些都是我们拥有的量子位。但是，同样的逻辑适用于具有任意数量量子位的电路。</p><p id="e2e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们从最高量子位开始，根据总块数划分状态，如下图所示。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/3940f408067ec3f7795549798ea19dd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tY-tAcBaGUqKIuAV34xp_w.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="0cee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过使用RY门来实现这一点——围绕量子位的Y轴旋转。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="93c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这个门需要一个角度，我们需要将概率(上半部分的块数与下半部分和上半部分之和的总块数之比)转换成相应的角度。这就是<code class="fe ml mm mn mo b">prob_to_angle</code>函数的作用。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="677e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们只看这些上量子位为1的状态。然后，我们拆分这些状态，并计算块数。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e9580745aabc55b060d3254765bfabb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SuW423m59NnEHSy9-ibArA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="0e42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过一个受控的RY门来实现这一点。这只适用于控制量子位为1的情况——因此只适用于上半部分。请注意，upper和lower的值现在必须只代表子集。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="11da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们对上量子位为0的这些状态做同样的事情，把它封装到X个门中。对于给定的量子位，X门翻转0和1。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="05b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于两个量子位的电路，我们现在完成了。如果我们有更多的量子位，我们将需要进一步前进，直到我们遍历所有的量子位。下图描述了此过程。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/1d422bdc0cdc88ff1e19a6f436e58497.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1yCcfmah2TSpj0c6gE-rA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="5c24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最顶层，我们将量子位分成两块。在下一级，我们将这两个块中的每一个分成另外两个块。为了只考虑各自的部分，我们增加了上面的量子位作为控制量子位。随着每一层的深入，我们需要添加上层量子位作为控制。这意味着我们基本上使用多重控制的RY门。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="043e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们需要的是一个遍历所有层次的函数。当然，有无数种方法可以实现这一点。因为我喜欢递归(调用自己的函数)，这里是我的方法。</p><p id="442e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们程序的顶层，我们定义基本常数，创建一个<code class="fe ml mm mn mo b">QuantumCircuit</code>和一个<code class="fe ml mm mn mo b">QuantumRegister</code>，调用<code class="fe ml mm mn mo b">split</code>函数，并执行电路。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="ecb2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有神奇的事情都发生在split函数中，该函数有三个参数:</p><ul class=""><li id="9dfa" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated"><code class="fe ml mm mn mo b">current</code>量子位是量子位在电路中的位置，</li><li id="ba6c" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><code class="fe ml mm mn mo b">offsets</code>是所有为1的父量子位的列表，</li><li id="e18a" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated"><code class="fe ml mm mn mo b">controls</code>是所有父量子位的列表。</li></ul><p id="0c74" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过<code class="fe ml mm mn mo b">split(QUBITS-1, [], [])</code>调用函数让我们从最高量子位开始，没有父量子位。</p><p id="7e37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，让我们来看看函数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="be5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们计算一些我们需要的值。<code class="fe ml mm mn mo b">middle</code>表示当前量子位所跨越的区间的中心位置。例如，我们从第三个量子位(位置2)开始。因此，<code class="fe ml mm mn mo b">middle</code>就是2^{2+1}/2=8/2=4.这有助于我们决定在哪里分裂国家。</p><p id="f223" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ml mm mn mo b">offset</code>是<code class="fe ml mm mn mo b">offsets</code>列表中所有位置的平方和。由于当前为空，因此<code class="fe ml mm mn mo b">offset</code>为0。</p><p id="3752" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们计算放入下半部分的所有状态的块，我们计算放入上半部分的那些。如上所述，<code class="fe ml mm mn mo b">middle</code>作为<code class="fe ml mm mn mo b">lower</code>的结束和<code class="fe ml mm mn mo b">upper</code>部分的开始。我们现在忽略偏移量，因为它是0。因此，<code class="fe ml mm mn mo b">lower</code>包含状态0到3的块，而<code class="fe ml mm mn mo b">upper</code>包括状态4到7。</p><p id="4bf3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步，我们添加量子门。在第一次迭代中，<code class="fe ml mm mn mo b">controls</code>列表为空。因此，我们直接跳到RY门。然后，我们将<code class="fe ml mm mn mo b">current</code>量子位旋转一个角度，该角度代表上部块除以总块的比率给出的概率。</p><p id="31d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，由于<code class="fe ml mm mn mo b">current</code>大于0，我们调用split函数两次。我们将<code class="fe ml mm mn mo b">current</code>减1，因为我们想处理下一个更低的量子位。在这两个调用中，我们将<code class="fe ml mm mn mo b">current</code>添加到<code class="fe ml mm mn mo b">controls</code>的列表中。这两个调用之间唯一的区别是，我们在第二个调用中将<code class="fe ml mm mn mo b">current</code>添加到了<code class="fe ml mm mn mo b">offsets</code>列表中。</p><p id="7674" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们看看第二次调用<code class="fe ml mm mn mo b">split</code>时会发生什么。我们叫它像<code class="fe ml mm mn mo b">split(1, [2], [2])</code>。</p><p id="03e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ml mm mn mo b">middle</code>现在设定为2^{1+1}/2=2.现在的偏移量是2^2=4.这是我们的起点，因为在这个迭代中，我们只处理状态的上半部分(4-7)。当我们计算<code class="fe ml mm mn mo b">lower</code>时，我们从位置4开始计算块数，并在位置4+2=6之前结束。鞋帮从位置6开始，刚好在位置8之前结束。</p><p id="902b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这一次，我们在<code class="fe ml mm mn mo b">controls</code>中有了一个量子位。我们循环遍历这个列表。但是由于这个元素也在<code class="fe ml mm mn mo b">offsets</code>列表中，我们不应用X-gate。</p><p id="63bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，这一次，我们应用多控制RY ( <code class="fe ml mm mn mo b">mcry</code>)门，而不是RY门。<code class="fe ml mm mn mo b">controls</code>列表中的所有位置都用作控制。因此，只有当这些位置的量子位是1时，我们才应用旋转。在我们的例子中，如果位置1的顶部量子位是1，我们只应用旋转。这仅意味着第四至第七个州。</p><p id="4af0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次调用分裂函数，这次是针对位置0的量子位。这里第一个叫<code class="fe ml mm mn mo b">split(0,[2], [2,1])</code>。我们将当前的量子位(位置1)添加到控制中，但没有添加到偏移中。</p><p id="5fdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们研究这个迭代时，<code class="fe ml mm mn mo b">offset</code>与之前的(=4)相同。但是由于<code class="fe ml mm mn mo b">current</code>位置现在是0，<code class="fe ml mm mn mo b">middle</code>就不同了。现在，我们把状态4和状态5分开。</p><p id="65bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在主要的区别是我们在<code class="fe ml mm mn mo b">controls</code>列表中有一个条目不在<code class="fe ml mm mn mo b">offsets</code>列表中。这是位置1。因此，在应用多控制RY门之前和之后，我们在这个量子位上应用X门。这意味着我们只想对位置1的量子位为0的情况应用旋转。</p><p id="ead4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们来看看运行这条电路的结果。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/5a92a4327b1855304833e692cf20abb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YZe_xL_T2ttV3lJHZejKIA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><h1 id="9015" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="7cfc" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">线性函数可能是孩子们在高中遇到的第一个函数。然而，在量子电路中对付它们需要这样或那样的技巧。在你掌握量子机器学习的过程中，你会发现很大一部分工作实际上是经典的问题解决。</p><p id="ae49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_genlin&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_genlin&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>