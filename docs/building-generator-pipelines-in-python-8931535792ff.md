# 用 Python 构建生成器管道

> 原文：<https://towardsdatascience.com/building-generator-pipelines-in-python-8931535792ff>

## 本文提出了一种构建生成器管道的优雅方法

![](img/4e8a24124735751ac9a77ddaf1b4e4fd.png)

发电机管道:解决问题的捷径。马修·布罗德尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在软件中，[管道](https://en.wikipedia.org/wiki/Pipeline_(software))意味着对可迭代的每个元素按顺序执行多个操作(例如，调用一个又一个函数),每个元素的输出都是下一个元素的输入。

在 Python 中，可以用各种方式构建管道，有些方式比其他方式简单。在本文中，我们将讨论一种优雅的方式:生成器管道。

让我举一个简单的例子。对于我们来说，使用由简单操作组成的管道会更容易，这样我们就不必关注每个操作在做什么。例如，对于整数范围内的每个数字，您希望应用以下计算:

*   求平方根
*   数字翻倍，加 12
*   求数字的平方
*   加上圆周率的平方根
*   添加 75
*   返回舍入到两位小数后的结果

当然，没有人会这样做，但是想象一下，每一步都在 iterable 的特定元素上执行操作。例如，iterable 可以包含许多文件，您希望读取它们，对它们进行预处理，对每个文本应用 NLP 模型，分析结果，然后返回它们。或者，您有许多包含定量数据的文件，您希望读取每个文件，检查并预处理数据，使用 ML 模型，然后以某种有组织的方式返回结果。这两个示例可以像上面的示例一样组织在一个管道中，因为每个示例都有一个 iterable，其中包含一系列操作要依次应用到的项目，一个项目的输出是下一个项目的输入。

# 常见的方法

可能最自然的方法是获取 iterable 的每个元素，并逐步应用这些计算。所以，当你有两个函数要应用于`x`时，比如说，`f1()`然后是`f2()`，你可以通过`f2(f1(x))`来完成。就这么简单——但是当应用更多的函数并且它们接受更多的参数时，产生的代表`f2(f1(x))`的代码就变成了一个难以理解的怪物。你会在下面看到。

首先，让我们创建一个对数字执行操作的管道。

***注*** *:下面这段是描述代码中类型提示的题外话。不感兴趣可以跳过。*

正如你在上面的代码中看到的，我决定使用类型别名。在许多情况下，我认为这种方法比使用原始类型提示更具可读性([科萨克 2022](https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7) )。因此，我创建了类型别名`XType`来表示`x`的类型。另一个类型别名，`PipeItems`，代表一个 iterable，其中包含了我们将要创建的管道中将要处理的项目；这样就带了`XType`的对象。在我们的例子中，这些是数字，但一般来说，这可以是任何对象。函数`power()`和`add()`也将`XType`的值作为输入，但是这不是必须的；这取决于创建管道的操作。代表特定操作的函数应该接受前一个操作返回的类型的对象。

我们的第一种方法是简单地一个接一个地应用所有的函数(因此函数名为`get_pipeline_all_calc`)，可能是这样的:

什么？！

你怎么能读懂这样的代码，更不用说理解它了？我尝试了十几个版本，只是为了找出哪一个是最好的，但是……没有一个是最好的。因此，因为我需要使行更短，我选择了这一个，尽管它肯定是*不*可读的。但是，他们都不是。

在下面，您会发现在使用标志`-l 79`之后`[black](https://github.com/psf/black)`对这段代码做了什么，标志`-l 79`将最大行长度保持在 79:

我不认为这有多大帮助…你自己决定这段代码对你来说是否是可理解的。

这样的代码不仅难以阅读和理解，而且难以编写和重写。你自己试试。例如，回到管道的描述并自己实现它。或者在上面的函数中增加一个新的步骤；比如说，在加圆周率的平方根之前，把这个数提高到 3 的次方。这样做只是为了看看使用这种方法有多难。

上面的版本工作正常，无论它看起来多么疯狂和不可理解。Python 的[禅说“简单比复杂好”，所以应该有更好的方法。](https://peps.python.org/pep-0020/)

还有就是:*发电机管线*。

# 发电机管道

`get_pipeline_all_calc()`函数返回一个生成器，所以我们可以称之为生成器管道。因为它返回了一个`generator`对象，我们必须评估它的项目。这是生成器管道的一个伟大之处:在被创建之后，管道(正式地说，它是一个`generator`对象)可以被延迟评估，也就是按需评估。可以一次完成，可以分步完成，也可以在想要或者需要的时候对后续项目进行评估。

然而，许多人不同意这是一个发电机管道；更确切地说，它是压入生成器的计算。*真正的生成器管道在管道的每一步都使用一个生成器*。

因此，要构建一个生成器管道，您需要使每一步都成为基于前一步的生成器的生成器。第一步将 iterable 与原始项一起使用。

这实际上比听起来简单。下面的函数显示了实现这一点的一种方法:

您当然可以使用不同的命名，这可以稍微提高可读性。例如，不使用`step_i`的名称，其中`i`代表步骤的 ID，实际上您可以使用一个有意义的名称。例如，`step_1`可以是`root_squared`，`step_2`可以变成`doubled`，`step_3`可以是`added_12`。虽然在这里这样的命名并不真正有用，但在许多情况下会有用。您也可以在每个步骤中使用`map()`(稍后我们将返回到`map()`)。

对我来说，生成器管道版本`get_pipeline_original()`可读性更好，也更容易更新(例如，添加一个新操作)。我看到了链中的每一步，所以很容易添加新的一步，不像在`get_pipeline_all_calc()`中。

然而，代码并不完美。我们能进一步改进它吗？

# 我们能把发电机管道做得更好吗？

`get_pipeline_original()`函数展示了创建生成器管道的典型方法。我不认为它经常被使用，尽管它有可读性。虽然可读，但它不是完全可读的。例如，我不喜欢视觉混乱，这主要是由在每一步中创建生成器表达式的`for`循环造成的。也许最重要的是，为了理解这样的管道，您需要同时考虑两件事:操作和生成器表达式。在它们之间，前者构成了本质，后者构成了方法论的具体内容。

正如我上面写的，我们可以使用`map()`函数来代替。但不幸的是，这没有多大帮助:我们必须理解所有的地图。

事实上，正是管道作业构成了其本质。我们应该关注它们，因为如果我们想要了解管道，我们需要了解其每个步骤的以下方面:

*   对操作的输入
*   手术的作用
*   操作的输出

回到上面的代码。我们看到了这些方面，但是当试图理解代码时，我们的大部分注意力都放在了理解生成器表达式上。

为了使代码更具可读性，我们可以尝试减少没有描述其本质的代码量。问自己以下问题:*每个操作都需要专用的生成器表达式吗？*

答案是，*当然不是*。既然没有，我们可以试着简化代码，例如，去掉所有的生成器表达式，只留下一个。考虑以下代码:

这里，`calculate()`包含单个元素的操作管道，而`get_pipeline_proposed()`为`items` iterable 的每个元素创建一个管道生成器——也就是一个生成器管道。之前在`get_pipeline_all_calc()`中，所有的操作都在一行中调用，这里没有；它们以流水线的形式出现，每一行代表一个操作。我们很容易看到，除了第一个操作之外，每个操作都将前一个操作的输出作为输入。

让我们回到这句话:*真正的生成器管道在管道的每一步都使用一个生成器*。对于这种方法，我们不能这么说，因为`calculate()`函数由一个管道组成，然后这个管道在生成器中循环。抛开命名的理论考虑，我认为我们仍然可以称这种方法为生成器管道:这是一种使用生成器评估的管道。

在我看来，`get_pipeline_proposed()`和`calculate()`函数比我们上面考虑过的任何其他版本都更具可读性，包括`get_pipeline_original()`。前者比后者需要更少的字符和更短的行——因此，它不会受到视觉混乱的影响。

不过，我们可以在`calculate()`中使用不同的命名。你觉得下面的版本怎么样？

我觉得是喜好问题。在这个例子中，我会选择带有`x`的版本，因为它表明我们从每一步得到的仍然是同一个变量，只是经过了处理。但是当每个步骤执行不同的操作时，例如，读取文件、处理文本、运行 NLP 模型，那么这样的命名可以增加可读性。

在这种情况下，使用管道操作符将函数链接起来会产生更可读的代码。我将在另一篇文章中讨论这个问题，因为它值得单独关注。

# 带地图的发电机管道()

不能用`[map()](/does-python-still-need-the-map-function-96787ea1fb05)`创建一个生成器管道吗？难道`map()`不是被创造出来的吗？

的确，我们可以。为此，我们将使用上面定义的`calculate()`函数，管道创建函数如下:

就是这样！这是生成器管道的另一个版本，用`map()`函数构建。

# 标杆管理

代码可读性是一回事；性能是另一个。传统的生成器管道创建的生成器数量与管道中的步骤数量一样多。虽然创建一个生成器在性能方面很便宜，但这仍然意味着要创建和使用几个生成器，而不是一个。当然，提议的版本(使用生成器表达式或`map()`)尽管没有使用那么多的生成器，但使用了相同数量的对象，所以它们的评估与生成器的评估一样昂贵吗？

对于基准测试，我将使用`[timeit](https://docs.python.org/3/library/timeit.html)`模块。如果你想了解更多关于这个模块的内容，你可以阅读我的文章[，从*走向数据科学*](/benchmarking-python-code-with-timeit-80827e131e48) ，在这篇文章中，我解释了这个包的一些有趣的复杂性。

我们将运行基准测试，以比较以下四种方法的性能:

*   `get_pipeline_all_calc()`:第一个版本，一个接一个地进行所有的计算；
*   `get_pipeline_original()`:传统的生成器管道，其中每个计算都是使用专用的生成器来完成的；
*   `get_pipeline_proposed()`:提出的发电机管道，是对第一个版本的修改；；和
*   `get_pipeline_proposed_map()`:提议的生成器管道，使用`map()`创建。

基准测试代码太长且重复，无法在此展示，因此您可以在本 GitHub gist 中找到它[。你会在这里找到结果。](https://gist.github.com/nyggus/6312fda2702f137899a5f23a7d746963)

以下是从基准测试中得出的结论:

*   四个中最快的是`get_pipeline_all_calc()`，即创建一个能同时调用所有函数的生成器。这并不奇怪，因为这个版本创建生成器、调用函数和创建对象的开销最低。
*   最慢的是传统的生成器流水线`get_pipeline_original()`，它使用的生成器和操作一样多。这也不足为奇，因为这个版本的开销很大，需要创建与管道中的操作一样多的生成器。
*   使用生成器表达式`get_pipeline_proposed()`的建议解决方案位于中间。
*   使用`map()`、`get_pipeline_proposed_map()`的建议解决方案比`get_pipeline_all_calc()`慢，但比`get_pipeline_proposed()`快。
*   上述结果适用于 iterable 的所有长度，即`[100, 1_000, 10_000, 100_000, 1_000_000]`。正如本例所示，可以预料 iterable 元素的执行时间实际上是相同的。

然而，请注意，我们分析的是由非常快速的操作组成的流水线。如果其中一个或多个需要很长时间来执行，基准测试将显示这两个方法之间几乎没有区别，因为在`calculate()`中创建生成器或创建几个对象的开销可以忽略不计。

如果您想检查这一点，将上面定义的`double()`功能更改如下:

并使用`number=1`。你将看不出这四种方法之间有什么有意义的区别。这是因为这一次，与操作的执行时间相比，在`calculate()`中创建生成器和附加对象的开销可以忽略不计。

因此，请记住，只有当管道本身非常快时，考虑性能才有意义。但是这个实验的主要目的是表明所提出的发电机管道结构并不比其他方法慢很多。事实证明这是真的。因此，使用这种方法时，您不必担心性能。此外，如果性能很重要，所提出的解决方案甚至会比传统的发电机管道更快——虽然只是一点点，但仍然如此。

# 结论

传统的生成器管道由与管道中的操作一样多的生成器组成。生成器管道代码比一次调用所有函数的生成器更容易理解。这就是为什么在两种选择中，生成器管道是首选。

然而，在快速操作的情况下，这种方法比在一个生成器中一次一个地调用所有操作要慢。有趣的是，`map()`版本比这更快。然而，对于更长的操作，这种差异变得可以忽略不计，对于所有版本，您将得到几乎相同的结果。

在本文中，我已经展示了使用一个生成器的生成器管道确实比其他版本更易读。特别是，这一呼吁:

比下面的生成器管道可读性差:

这两种方法都导致了完全相同的`generator`、`results`。但是它们是不同的，在这种情况下，简洁不会带来可读性。

生成器管道的确可读性更好，但这并不意味着它的可读性不能再提高了。每个操作(步骤)本身就是一个生成器，这有助于我们理解每个步骤中发生了什么。

我不喜欢这段代码的重复和不必要的视觉混乱。这背后的主要原因是生成器表达式中的`for`循环。乍一看，它们可能很重要，尽管事实是它们并不重要。

还有一点:那些创建过几个生成器管道的人知道，创建它们有时会很棘手；不一定很难编码，但有时很棘手。第一种方法——在一个长链中一个接一个地调用函数——可能是一个更大的挑战，尤其是当您需要在中间添加一个新的操作时。

这也是我写这篇文章的原因。我建议采用一种介于两者之间的方法，将前一种方法的简洁性与后一种方法的可读性结合起来。通过这样做，这种方法避免了不必要的代码片段，这些片段在每一步中都重复出现，尽管它们不做任何必要的事情。在这样的渠道中，我们有几个基本项目:

*   生成器:事实是我们只有一个 iterable，所以我们应该只有一个生成器；在提议的生成器管道结构中，`step1`创建了这个生成器；
*   *操作*:在上面的例子中，它们由函数表示，每个函数执行一个操作；在我们这里是`function1`、`function2`、`function3` 、`function4`；
*   *结果生成器对象*:这是你需要得到结果时所求值的对象，但是注意它是在第一步开始的，最后一步仍然使用它。

使用本文中提出的生成器管道结构，我们将得到一个新类型的生成器管道，如下所示:

我在上面提到过编写`get_pipeline_all_calc()`和`get_p[ipeline_original)`可能会很棘手。这种结构*并不棘手*。很*直白*。很清楚。虽然仍然比第一种方法长，但它不会像原始管道那样添加不必要的代码。与其他两个版本相比，我肯定更喜欢这个版本，尽管我确实理解并接受这也是一个偏好问题。

在性能方面，新的生成器管道介于两者之间，其中`map()`版本比生成器表达式版本性能更好。但是我们必须记住，通常情况下，这并不重要，如果一个管道需要一些计算时间，那么创建多个生成器(就像在原始生成器管道中所做的那样)的开销是可以忽略的。

当然，这篇文章没有提供任何新奇的东西。我们很多人都用过类似的管道，只是不叫它们“发电机管道”；或者不打电话给他们。

由于传统的生成器管道通常被认为是创建内存高效管道的好方法(例如，[兰登 2012](https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e) 、[乌赞 2020](https://brett.is/writing/about/generator-pipelines-in-python/) 和[卡尔曼 2021](https://betterprogramming.pub/3-data-processing-pipelines-you-can-build-with-python-generators-dc0d2019b177) )，本文建议以一种新的方式创建生成器管道，将所有操作包装在一个函数中，并使用该函数创建一个生成器。

这种方法更简单、更高效、可读性更强。总之是比较好。

# 资源

*   [维基百科。管道(软件)。](https://en.wikipedia.org/wiki/Pipeline_(software))
*   科萨克米(2022)。Python 的类型暗示:朋友，敌人，还是只是头痛？*更好的编程*。
*   `[black](https://github.com/psf/black)` [:不妥协的代码格式化程序。GitHub 仓库。](https://github.com/psf/black)
*   Python 之禅:[https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/)
*   科萨克米(2022)。用 `[timeit](/benchmarking-python-code-with-timeit-80827e131e48)` [对标 Python 代码。*走向数据科学*。](/benchmarking-python-code-with-timeit-80827e131e48)
*   `[timeit](https://docs.python.org/3/library/timeit.html)` [—测量小代码片段的执行时间。文档。](https://docs.python.org/3/library/timeit.html)
*   科萨克米(2022)。Python 还需要 map()函数吗？*走向数据科学*。
*   [Git 要点与基准代码。](https://gist.github.com/nyggus/6312fda2702f137899a5f23a7d746963)
*   [基准测试结果。](https://gist.github.com/nyggus/d3e225bf4cab72f1ae66fe2e4881bae0)
*   [乌赞一世(2020)。用 Python 生成器构建数据管道。](https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e)
*   [兰登 b。Python 中的生成器管道。](https://brett.is/writing/about/generator-pipelines-in-python/)
*   Kalkman P. (2021)。您可以使用 Python 生成器构建 3 个数据处理管道。