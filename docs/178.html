<html>
<head>
<title>Using Higher-Order Containers to Efficiently Process 7,163 (or More) DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用高阶容器高效处理7，163(或更多)个数据帧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-higher-order-containers-to-efficiently-process-7-163-or-more-dataframes-964da8b0c679#2022-01-06">https://towardsdatascience.com/using-higher-order-containers-to-efficiently-process-7-163-or-more-dataframes-964da8b0c679#2022-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9783" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/making-sense-of-big-data" rel="noopener" target="_blank">理解大数据</a></h2><div class=""><h1 id="18a2" class="pw-post-title iy iz iq bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">使用高阶容器高效处理7，163(或更多)个数据帧</h1></div><div class=""><h2 id="f0e4" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">介绍StaticFrame总线、批次、被子和纱线</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/d3ffc3db1d41683246163e552b1ee4ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8IrYGW-c1WBFmpkulBEyrA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者图片</p></figure><p id="ef33" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">数据帧处理例程通常与表集合一起工作。这种集合的示例包括每年有一个表的多年数据集、每个股票行情表的历史股票数据，或者XLSX文件中多个工作表的数据。本文介绍了用于处理这种数据帧集合的新颖的“高阶”容器，这些容器在Python StaticFrame包中实现(一个提供不可变数据帧的Pandas替代品)。三个核心容器是<code class="fe ma mb mc md b">Bus</code>、<code class="fe ma mb mc md b">Batch</code>和<code class="fe ma mb mc md b">Quilt</code>。将简要介绍第四种容器<code class="fe ma mb mc md b">Yarn</code>。</p><p id="e592" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些高阶容器的替代方法是使用一个带有层次索引的大表。例如，多只股票的时间序列数据可能被编码在一个具有两层索引的表中，外层是股票代码，内层是日期。这种方法通常效率很低，因为即使只处理少量股票，也必须将整个表加载到内存中。</p><p id="7943" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">本文介绍了用于处理大型表集合的容器，从几千到几十万个表。通过延迟加载和可选的快速卸载提供了高效的内存使用。<code class="fe ma mb mc md b">Bus</code>(以电路中使用的总线命名)，为延迟加载存储在磁盘上的表集合提供了一个类似字典的接口；收藏可以存储在SQLite、HDF5、XLSX或压缩的拼花、NPZ、pickle或分隔文本文件中。<code class="fe ma mb mc md b">Batch</code>(以批处理命名)是一个表的延迟处理器，提供了一个简洁的接口来延迟定义应用于所有表的操作。<code class="fe ma mb mc md b">Quilt</code>(以拼凑而成的纺织品命名)是所有表的一种惰性虚拟连接，允许对分区数据进行操作，就像它是一个统一的单个表一样。</p><p id="703a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">所有这三个容器都提供了相同的接口，用于读取和写入上面提到的多表存储格式(SQLite、HDF5、XLSX或拼花、NPZ、pickle或分隔文本文件的压缩存档)。这种一致性允许在不同的上下文中重用相同的数据存储。</p><p id="53cf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些工具是从我的工作环境演变而来的:处理金融数据和建立投资系统模型。在那里，数据集自然地按日期或特征划分。对于历史模拟，所需的数据可能很大。<code class="fe ma mb mc md b">Bus</code>、<code class="fe ma mb mc md b">Batch</code>、<code class="fe ma mb mc md b">Quilt</code>、<code class="fe ma mb mc md b">Yarn</code>在这个领域提供了便捷高效的工具。像Vaex和Dask这样的核心外解决方案提供了处理大量数据的相关方法，尽管有不同的权衡。</p><p id="8ae5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然这些容器是在StaticFrame中实现的，但是这些抽象对于任何数据帧或表处理库中的应用程序都是有用的。StaticFrame将数据帧简单地称为“帧”，这里将使用该约定。StaticFrame按照以下约定导入:</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="52d1" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; import static_frame as sf</span></pre></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="8883" class="mv mj iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">容器概述</h1><p id="5d0b" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">在演示使用这些容器处理成千上万个数据帧之前，我们将从处理两个数据帧开始。在创建了一个带有两个<code class="fe ma mb mc md b">Frame</code>的<code class="fe ma mb mc md b">Bus</code>之后，我们将使用同一个<code class="fe ma mb mc md b">Bus</code>来初始化一个<code class="fe ma mb mc md b">Batch</code>、<code class="fe ma mb mc md b">Quilt</code>和<code class="fe ma mb mc md b">Yarn</code>。通过这种介绍，可以观察到共同的和不同的特征。</p><h2 id="9514" class="mi mj iq bd mw nr ns dn na nt nu dp ne ln nv nw ng lr nx ny ni lv nz oa nk iw bi translated">公共汽车</h2><p id="060b" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">两个简单的<code class="fe ma mb mc md b">Frame</code>可以用来演示初始化一个<code class="fe ma mb mc md b">Bus</code>。<code class="fe ma mb mc md b">Bus.from_items()</code>方法接受成对的标签和<code class="fe ma mb mc md b">Frame</code>；条目可以在元组中提供(如下所示),或者通过Python字典或相关容器上的<code class="fe ma mb mc md b">items()</code>方法提供。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="7730" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; f1 = sf.Frame.from_element(0.5, index=('w', 'x'), <br/>    columns=('a', 'b'))<br/>&gt;&gt;&gt; f2 = sf.Frame.from_element(2, index=('y', 'z'), <br/>    columns=('a', 'b'))</span><span id="b7db" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; bus = sf.Bus.from_items((('f1', f1), ('f2', f2)))</span><span id="3f31" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; bus<br/>&lt;Bus&gt;<br/>&lt;Index&gt;<br/>f1      Frame<br/>f2      Frame<br/>&lt;&lt;U2&gt;   &lt;object&gt;</span></pre><p id="cb42" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ma mb mc md b">Bus</code>可以被认为是<code class="fe ma mb mc md b">Frame</code>的<code class="fe ma mb mc md b">Series</code>(或有序字典)，允许访问给定标签的<code class="fe ma mb mc md b">Frame</code>。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="7bed" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; bus.loc['f2']<br/>&lt;Frame: f2&gt;<br/>&lt;Index&gt;     a       b       &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>y           2       2<br/>z           2       2<br/>&lt;&lt;U1&gt;       &lt;int64&gt; &lt;int64&gt;</span></pre><p id="7b43" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ma mb mc md b">Bus</code>的一个关键特性是，当从磁盘读取时，<code class="fe ma mb mc md b">Frame</code>被延迟加载:一个<code class="fe ma mb mc md b">Frame</code>仅在被访问时被加载到内存中，并且(通过<code class="fe ma mb mc md b">max_persist</code>参数)<code class="fe ma mb mc md b">Bus</code>可以被配置为仅保存对有限数量的<code class="fe ma mb mc md b">Frame</code>的强引用，急切地卸载超出该限制的最近最少使用的。这允许检查所有的<code class="fe ma mb mc md b">Frame</code>，同时限制<code class="fe ma mb mc md b">Bus</code>加载的总内存。</p><p id="c2b5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于<code class="fe ma mb mc md b">Bus</code>支持读取和写入XLSX和HDF5(以及许多其他格式)，它提供了熊猫<code class="fe ma mb mc md b">ExcelWriter</code>和<code class="fe ma mb mc md b">HDFStore</code>接口的功能，但具有更通用和一致的接口。同样的<code class="fe ma mb mc md b">Bus</code>可以用于编写XLSX工作簿(其中每一帧都是一张表)或HDF5数据存储，只需分别使用<code class="fe ma mb mc md b">Bus.to_xlsx()</code>或<code class="fe ma mb mc md b">Bus.to_hdf5()</code>。</p><p id="1b29" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此外，<code class="fe ma mb mc md b">Bus</code>也是创建<code class="fe ma mb mc md b">Batch</code>、<code class="fe ma mb mc md b">Quilt</code>或<code class="fe ma mb mc md b">Yarn</code>的便利资源。</p><h2 id="f5fe" class="mi mj iq bd mw nr ns dn na nt nu dp ne ln nv nw ng lr nx ny ni lv nz oa nk iw bi translated">一批</h2><p id="1e13" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated"><code class="fe ma mb mc md b">Batch</code>可以被认为是一个label和<code class="fe ma mb mc md b">Frame</code>对的迭代器。除了迭代器之外，<code class="fe ma mb mc md b">Batch</code>还是一个在每个包含的<code class="fe ma mb mc md b">Frame</code>上组合延迟操作的工具。<code class="fe ma mb mc md b">Batch</code>几乎暴露了整个<code class="fe ma mb mc md b">Frame</code>接口；当被调用时，方法调用和操作符应用程序在新返回的<code class="fe ma mb mc md b">Batch</code>中被延迟，在存储的迭代器上组成延迟执行。只有在使用<code class="fe ma mb mc md b">Batch.to_frame()</code>方法创建复合<code class="fe ma mb mc md b">Frame</code>或使用类似字典的迭代器(如<code class="fe ma mb mc md b">Batch.keys()</code>、<code class="fe ma mb mc md b">Batch.items()</code>或<code class="fe ma mb mc md b">Batch.values</code>)时，才会执行操作和迭代对。</p><p id="3dd8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一个<code class="fe ma mb mc md b">Batch</code>可以用来自一个<code class="fe ma mb mc md b">Bus</code>或者任何一对标签的迭代器<code class="fe ma mb mc md b">Frame</code>的条目来初始化。从一个<code class="fe ma mb mc md b">Batch</code>中调用的方法或操作符只是返回一个新的<code class="fe ma mb mc md b">Batch</code>。调用<code class="fe ma mb mc md b">Batch.to_frame()</code>，如下图所示，是急切执行组合<code class="fe ma mb mc md b">sum()</code>操作所必需的。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="1019" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; sf.Batch(bus.items()).sum()<br/>&lt;Batch at 0x7fabd09779a0&gt;</span><span id="0ed1" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; sf.Batch(bus.items()).sum().to_frame()<br/>&lt;Frame&gt;<br/>&lt;Index&gt; a         b         &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>f1      1.0       1.0<br/>f2      4.0       4.0<br/>&lt;&lt;U2&gt;   &lt;float64&gt; &lt;float64&gt;</span></pre><p id="701e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">除了<code class="fe ma mb mc md b">Frame</code>方法外，<code class="fe ma mb mc md b">Batch</code>还支持使用<code class="fe ma mb mc md b">Frame</code>选择接口和操作符。下面，每个<code class="fe ma mb mc md b">Frame</code>取二次幂，选择“b”列，并返回新的<code class="fe ma mb mc md b">Frame</code>(组合两个选择):</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="66be" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; (sf.Batch(bus.items()) ** 2)['b'].to_frame()<br/>&lt;Frame&gt;<br/>&lt;Index&gt; w         x         y         z         &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>f1      0.25      0.25      nan       nan<br/>f2      nan       nan       4.0       4.0<br/>&lt;&lt;U2&gt;   &lt;float64&gt; &lt;float64&gt; &lt;float64&gt; &lt;float64&gt;</span></pre><p id="16ed" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ma mb mc md b">Batch</code>与熊猫<code class="fe ma mb mc md b">DataFrameGroupBy</code>和<code class="fe ma mb mc md b">Rolling</code>对象相关，在配置分组或滚动窗口可迭代后，这些接口暴露这些组或窗口上的函数应用。<code class="fe ma mb mc md b">Batch</code>概括了这一功能，支持这些上下文，并提供标签和框架的任何迭代器的通用处理。</p><h2 id="0efd" class="mi mj iq bd mw nr ns dn na nt nu dp ne ln nv nw ng lr nx ny ni lv nz oa nk iw bi translated">被子</h2><p id="4d03" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">一个<code class="fe ma mb mc md b">Quilt</code>用一个<code class="fe ma mb mc md b">Bus</code>(或<code class="fe ma mb mc md b">Yarn</code>)初始化，并要求指定虚拟连接哪个轴，垂直(轴0)或水平(轴1)。此外，<code class="fe ma mb mc md b">Quilt</code>必须为<code class="fe ma mb mc md b">retain_labels</code>定义一个布尔值:如果为真，<code class="fe ma mb mc md b">Frame</code>标签将作为外部标签保留在沿着连接轴的分层索引中。如果<code class="fe ma mb mc md b">retain_labels</code>为假，所有包含的<code class="fe ma mb mc md b">Frame</code>的串联轴上的所有标签必须是唯一的。以下示例使用先前创建的<code class="fe ma mb mc md b">Bus</code>来演示<code class="fe ma mb mc md b">retain_labels</code>参数。由于一个<code class="fe ma mb mc md b">Quilt</code>可能由数千个表组成，所以默认的表示形式会简化数据；<code class="fe ma mb mc md b">Quilt.to_frame()</code>可用于提供完全实现的表示。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="9a58" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt = sf.Quilt(bus, axis=0, retain_labels=False)</span><span id="9ac3" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; quilt<br/>&lt;Quilt&gt;<br/>&lt;Index: Aligned&gt;      a b &lt;&lt;U1&gt;<br/>&lt;Index: Concatenated&gt;<br/>w                     . .<br/>x                     . .<br/>y                     . .<br/>z                     . .<br/>&lt;&lt;U1&gt;</span><span id="b67c" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; quilt.to_frame()<br/>&lt;Frame&gt;<br/>&lt;Index&gt; a         b         &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>w       0.5       0.5<br/>x       0.5       0.5<br/>y       2.0       2.0<br/>z       2.0       2.0<br/>&lt;&lt;U1&gt;   &lt;float64&gt; &lt;float64&gt;</span><span id="c6b0" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; quilt = sf.Quilt(bus, axis=0, retain_labels=True)</span><span id="f911" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; quilt.to_frame()<br/>&lt;Frame&gt;<br/>&lt;Index&gt;                a         b         &lt;&lt;U1&gt;<br/>&lt;IndexHierarchy&gt;<br/>f1               w     0.5       0.5<br/>f1               x     0.5       0.5<br/>f2               y     2.0       2.0<br/>f2               z     2.0       2.0<br/>&lt;&lt;U2&gt;            &lt;&lt;U1&gt; &lt;float64&gt; &lt;float64&gt;</span></pre><p id="b305" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ma mb mc md b">Quilt</code>可以被认为是由许多较小的<code class="fe ma mb mc md b">Frame</code>组成的<code class="fe ma mb mc md b">Frame</code>，垂直或水平排列。重要的是，这个更大的<code class="fe ma mb mc md b">Frame</code>并没有急切地串联起来；更确切地说，根据需要从包含的<code class="fe ma mb mc md b">Bus</code>中访问<code class="fe ma mb mc md b">Frame</code>,提供了沿轴的表的惰性连接。</p><p id="9318" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">可以用<code class="fe ma mb mc md b">max_persist</code>参数配置<code class="fe ma mb mc md b">Quilt</code>中的<code class="fe ma mb mc md b">Bus</code>来限制保存在内存中的<code class="fe ma mb mc md b">Frame</code>的总数。这种显式内存管理允许在可能太大而无法加载到内存中的虚拟<code class="fe ma mb mc md b">Frame</code>上进行操作。</p><p id="5bbf" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ma mb mc md b">Quilt</code>允许使用公共<code class="fe ma mb mc md b">Frame</code>接口的子集对这个虚拟连接的<code class="fe ma mb mc md b">Frame</code>进行选择、迭代和操作。例如，<code class="fe ma mb mc md b">Quilt</code>可用于迭代行和应用函数:</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="daea" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt.iter_array(axis=1).apply(lambda a: a.sum())<br/>&lt;Series&gt;<br/>&lt;Index&gt;<br/>w        1.0<br/>x        1.0<br/>y        4.0<br/>z        4.0<br/>&lt;&lt;U1&gt;    &lt;float64&gt;</span></pre><h2 id="4ec1" class="mi mj iq bd mw nr ns dn na nt nu dp ne ln nv nw ng lr nx ny ni lv nz oa nk iw bi translated">故事</h2><p id="d44e" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">这里仅简要描述的<code class="fe ma mb mc md b">Yarn</code>提供了一个或多个<code class="fe ma mb mc md b">Bus</code>的“虚级联”。与<code class="fe ma mb mc md b">Quilt</code>号一样，较大的容器不会被急切地连接起来。与<code class="fe ma mb mc md b">Quilt</code>的二维、单个<code class="fe ma mb mc md b">Frame</code>呈现不同，<code class="fe ma mb mc md b">Yarn</code>呈现了一个包含许多帧的一维容器，具有类似<code class="fe ma mb mc md b">Bus</code>的界面。与<code class="fe ma mb mc md b">Bus</code>或<code class="fe ma mb mc md b">Quilt</code>不同，<code class="fe ma mb mc md b">Yarn</code>的索引可以任意重新标记。这些功能允许异构的<code class="fe ma mb mc md b">Bus</code>在新标签下(如果需要)在单个容器中可用。</p><p id="a305" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">作为更高阶的容器，<code class="fe ma mb mc md b">Yarn</code>只能用一个或多个<code class="fe ma mb mc md b">Bus</code>或<code class="fe ma mb mc md b">Yarn</code>初始化。一个<code class="fe ma mb mc md b">Yarn</code>甚至可以从同一个<code class="fe ma mb mc md b">Bus</code>的多个实例中创建，如果每个实例都有一个唯一的<code class="fe ma mb mc md b">name</code>:</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="5162" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; sf.Yarn.from_buses((bus.rename('a'), bus.rename('b')),<br/>    retain_labels=True)<br/>&lt;Yarn&gt;<br/>&lt;IndexHierarchy&gt;<br/>a                f1    Frame<br/>a                f2    Frame<br/>b                f1    Frame<br/>b                f2    Frame<br/>&lt;&lt;U1&gt;            &lt;&lt;U2&gt; &lt;object&gt;</span></pre><h2 id="3498" class="mi mj iq bd mw nr ns dn na nt nu dp ne ln nv nw ng lr nx ny ni lv nz oa nk iw bi translated">共同特征和区别特征</h2><p id="ae07" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated"><code class="fe ma mb mc md b">Bus</code>、<code class="fe ma mb mc md b">Batch</code>和<code class="fe ma mb mc md b">Quilt</code>的一个共同特征是，它们都支持来自标签对和<code class="fe ma mb mc md b">Frame</code>的迭代器的实例化。当迭代器来自<code class="fe ma mb mc md b">Bus</code>时，<code class="fe ma mb mc md b">Bus</code>的延迟加载可以用来最小化内存开销。</p><p id="767c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些容器都共享相同的基于文件的构造函数，如<code class="fe ma mb mc md b">from_zip_csv()</code>或<code class="fe ma mb mc md b">from_xlsx()</code>；每个构造器都有一个对应的导出器，例如分别是<code class="fe ma mb mc md b">to_zip_csv()</code>或<code class="fe ma mb mc md b">to_xlsx()</code>，允许往返读写，或者从一种格式转换成另一种格式。下面的列表总结了所有三个容器中可用的基于文件的构造函数和导出函数。(<code class="fe ma mb mc md b">Yarn</code>作为<code class="fe ma mb mc md b">Bus</code>的聚合，只支持出口商。)</p><ul class=""><li id="8fe6" class="oc od iq lg b lh li lk ll ln oe lr of lv og lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_hdf5</code>，<code class="fe ma mb mc md b">to_hdf5</code></li><li id="5d21" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_sqlite</code>，<code class="fe ma mb mc md b">to_sqlite</code></li><li id="b497" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_zip_csv</code>，<code class="fe ma mb mc md b">to_zip_csv</code></li><li id="394e" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_zip_npz</code>，<code class="fe ma mb mc md b">to_zip_npz</code></li><li id="c08c" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_zip_pickle</code>，<code class="fe ma mb mc md b">to_zip_pickle</code></li><li id="9a57" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_zip_parquet</code>，<code class="fe ma mb mc md b">to_zip_parquet</code></li><li id="a5dc" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_zip_tsv</code>，<code class="fe ma mb mc md b">to_zip_tsv</code></li><li id="1391" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">from_xlsx</code>，<code class="fe ma mb mc md b">to_xlsx</code></li></ul><p id="45d9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这些容器可以通过维度、形状和界面来区分。<code class="fe ma mb mc md b">Bus</code>和<code class="fe ma mb mc md b">Yarn</code>是<code class="fe ma mb mc md b">Frame</code>的一维集合；<code class="fe ma mb mc md b">Batch</code>和<code class="fe ma mb mc md b">Quilt</code>呈现类似于<code class="fe ma mb mc md b">Frame</code>的二维界面。虽然<code class="fe ma mb mc md b">Bus</code>的形状等于<code class="fe ma mb mc md b">Frame</code>的数量(或者对于<code class="fe ma mb mc md b">Yarn</code>而言，等于所有包含的<code class="fe ma mb mc md b">Bus</code>中的<code class="fe ma mb mc md b">Frame</code>的数量)，但是<code class="fe ma mb mc md b">Quilt</code>的形状取决于其包含的<code class="fe ma mb mc md b">Frame</code>及其定向轴。像发电机一样，<code class="fe ma mb mc md b">Batch</code>的长度(或形状)在迭代之前是未知的。最后，当<code class="fe ma mb mc md b">Bus</code>和<code class="fe ma mb mc md b">Yarn</code>暴露一个类似于<code class="fe ma mb mc md b">Series</code>的接口时，<code class="fe ma mb mc md b">Batch</code>和<code class="fe ma mb mc md b">Quilt</code>暴露一个类似于<code class="fe ma mb mc md b">Frame</code>的接口，分别在单独的<code class="fe ma mb mc md b">Frame</code>或虚拟连接的<code class="fe ma mb mc md b">Frame</code>上操作。</p><p id="94a4" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如下表所示，对于形状(<em class="oq"> x </em>，<em class="oq"> y </em>)的<em class="oq">m</em>T30】nT31】，这些容器填充了一系列维度和接口。</p><ul class=""><li id="6769" class="oc od iq lg b lh li lk ll ln oe lr of lv og lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">Bus</code> <br/>呈现尺寸:1 <br/>近似界面:<code class="fe ma mb mc md b">Series</code> <br/>组成:<em class="oq"> n </em> <code class="fe ma mb mc md b">Frame</code> <br/>呈现形状:(<em class="oq"> n </em>，)</li><li id="b59f" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">Batch </code> <br/>呈现维度:2 <br/>近似接口:<code class="fe ma mb mc md b">Frame</code> <br/>组成:标签对的迭代器，<code class="fe ma mb mc md b">Frame</code></li><li id="4f5c" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">Quilt </code> <br/>呈现尺寸:2 <br/>近似界面:<code class="fe ma mb mc md b">Frame</code> <br/>组成:1<em class="oq">n</em><code class="fe ma mb mc md b">Frame</code>的<code class="fe ma mb mc md b">Bus</code>或<code class="fe ma mb mc md b">Yarn</code>呈现形状:(<em class="oq"> xn </em>，<em class="oq"> y </em>或(<em class="oq"> x </em>，<em class="oq"> yn </em>)</li><li id="01b1" class="oc od iq lg b lh ol lk om ln on lr oo lv op lz oh oi oj ok bi translated"><code class="fe ma mb mc md b">Yarn </code> <br/>呈现尺寸:1 <br/>近似界面:<code class="fe ma mb mc md b">Series</code> <br/>组成:<em class="oq">m</em><code class="fe ma mb mc md b">Bus</code>of<em class="oq">n</em><code class="fe ma mb mc md b">Frame</code><br/>呈现形状:(<em class="oq"> mn </em>，)</li></ul></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="74f0" class="mv mj iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">处理7163个数据帧</h1><p id="3703" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">“庞大的股票市场数据集”包含7163个CSV表的集合，每个表代表一只美国股票的时间序列特征。“archive.zip”文件可从<a class="ae or" href="https://www.kaggle.com/borismarjanovic/price-volume-data-for-all-us-stocks-etfs" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/Boris marjanovic/price-volume-data-for-all-us-stocks-ETFs</a>获得</p><p id="7d1e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">打开归档文件后，我们可以从包含的“股票”目录中读取，并使用<code class="fe ma mb mc md b">Batch</code>创建股票数据的zip pickle，用ticker标记，以便在后面的示例中快速阅读。由于有些文件是空的，我们还必须过滤掉没有大小的文件。根据硬件的不同，这种初始转换可能需要一些时间。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="a5ac" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; d = 'archive/Stocks'<br/>&gt;&gt;&gt; fps = ((fn, os.path.join(d, fn)) for fn in os.listdir(d))<br/>&gt;&gt;&gt; items = ((fn.replace('.us.txt', ''), sf.Frame.from_csv(fp, index_depth=1)) for fn, fp in fps if os.path.getsize(fp))<br/>&gt;&gt;&gt; sf.Batch(items).to_zip_pickle('stocks.zip')</span></pre><p id="b037" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于<code class="fe ma mb mc md b">Bus</code>是懒惰的，从这个新的zip存档初始化加载零个<code class="fe ma mb mc md b">Frame</code>到内存中。仅当明确请求时，才提供对数据的快速访问。因此，当<code class="fe ma mb mc md b">Bus.shape</code>属性显示7163个包含的<code class="fe ma mb mc md b">Frame</code>时，<code class="fe ma mb mc md b">status</code>属性显示零个加载的<code class="fe ma mb mc md b">Frame</code> s。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="1232" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; bus = sf.Bus.from_zip_pickle('stocks.zip')<br/>&gt;&gt;&gt; bus.shape<br/>(7163,)<br/>&gt;&gt;&gt; bus.status['loaded'].sum()<br/>0</span></pre><p id="5b8f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">访问单个<code class="fe ma mb mc md b">Frame</code>只会加载那个<code class="fe ma mb mc md b">Frame</code>。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="1c63" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; bus['ibm'].shape                                                                                                                <br/>(14059, 6)</span><span id="53b4" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; bus['ibm'].columns                                                                                                              <br/>&lt;Index&gt;<br/>Open<br/>High<br/>Low<br/>Close<br/>Volume<br/>OpenInt<br/>&lt;&lt;U7&gt;</span></pre><p id="19aa" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">提取多个<code class="fe ma mb mc md b">Frame</code>会产生一个新的<code class="fe ma mb mc md b">Bus</code>从同一个存储中读取。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="dc60" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; bus[['aapl', 'msft', 'goog']]<br/>&lt;Bus&gt;<br/>&lt;Index&gt;<br/>aapl    Frame<br/>msft    Frame<br/>goog    Frame<br/>&lt;&lt;U9&gt;   &lt;object&gt;<br/>&gt;&gt;&gt; bus.status['loaded'].sum()<br/>4</span></pre><p id="704d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">用一个<code class="fe ma mb mc md b">Batch</code>我们可以对包含在<code class="fe ma mb mc md b">Bus</code>中的<code class="fe ma mb mc md b">Frame</code>执行操作，返回标记的结果。<code class="fe ma mb mc md b">Batch.apply()</code>方法可与<code class="fe ma mb mc md b">lambda</code>一起使用，将每个<code class="fe ma mb mc md b">Frame</code>的两列(“音量”和“关闭”)相乘；然后，我们用<code class="fe ma mb mc md b">iloc</code>提取最近的两个值，并产生一个复合的<code class="fe ma mb mc md b">Frame</code>，该索引来自原始的<code class="fe ma mb mc md b">Bus</code>标签:</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="9bfd" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; sf.Batch(bus[['aapl', 'msft', 'goog']].items()<br/>    ).apply(lambda f: f['Close'] * f['Volume']).iloc[-2:].to_frame()<br/>&lt;Frame&gt;<br/>&lt;Index&gt; 2017-11-09         2017-11-10         &lt;&lt;U10&gt;<br/>&lt;Index&gt;<br/>aapl    5175673321.5       4389543386.98<br/>msft    1780638040.5600002 1626767764.8700001<br/>goog    1283539710.3       740903319.18<br/>&lt;&lt;U4&gt;   &lt;float64&gt;          &lt;float64&gt;</span></pre><p id="d088" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了对整个数据集进行观察，我们可以将<code class="fe ma mb mc md b">Bus</code>传递给<code class="fe ma mb mc md b">Quilt</code>。下面，一个空片用于强制一次加载所有的<code class="fe ma mb mc md b">Frame</code>以优化<code class="fe ma mb mc md b">Quilt</code>的性能。该形状显示了大约1500万行的<code class="fe ma mb mc md b">Quilt</code>。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="574e" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt = sf.Quilt(bus[:], retain_labels=True)<br/>&gt;&gt;&gt; quilt.shape<br/>(14887665, 6)</span></pre><p id="da88" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用<code class="fe ma mb mc md b">Quilt</code>我们可以计算单日7000只证券的总交易量，而无需显式连接所有的<code class="fe ma mb mc md b">Frame</code>。下面使用的StaticFrame <code class="fe ma mb mc md b">HLoc</code>选择器允许在分层索引中进行每深度级别的选择。在这里，我们选择了2017年11月10日的所有证券记录，涵盖所有证券交易所，并对交易量求和。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="84d7" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt.loc[sf.HLoc[:, '2017-11-10'], 'Volume'].sum()<br/>5520175355</span></pre><p id="7a98" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">类似地，<code class="fe ma mb mc md b">iloc_max()</code>方法可用于查找所有证券中交易量最大的证券的代码和日期。股票代码和日期成为由<code class="fe ma mb mc md b">iloc_max()</code>选择的<code class="fe ma mb mc md b">Series</code>的<code class="fe ma mb mc md b">name</code>属性。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="e0d5" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt.iloc[quilt['Volume'].iloc_max()]<br/>&lt;Series: ('bac', '2012-03-07')&gt;<br/>&lt;Index&gt;<br/>Open                            7.4073<br/>High                            7.6065<br/>Low                             7.3694<br/>Close                           7.6065<br/>Volume                          2423735131.0<br/>OpenInt                         0.0<br/>&lt;&lt;U7&gt;                           &lt;float64&gt;</span></pre><h1 id="57a0" class="mv mj iq bd mw mx os mz na nb ot nd ne kf ou kg ng ki ov kj ni kl ow km nk nl bi translated">跨容器比较:相同的方法，不同的选择</h1><p id="a86d" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">前面的例子演示了用<code class="fe ma mb mc md b">Bus</code>、<code class="fe ma mb mc md b">Batch</code>和<code class="fe ma mb mc md b">Quilt</code>加载、处理和检查“巨大的股票市场数据集”。跨容器比较可用于进一步说明这些容器的特征。首先，我们可以通过对每个容器应用相同的方法来观察三个不同的选择是如何返回的。其次，我们可以观察如何对每个容器使用三种方法来返回相同的选择。</p><p id="944c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ma mb mc md b">head(2)</code>方法从任何容器中返回前两行(或元素)。理解方法的输出在<code class="fe ma mb mc md b">Bus</code>、<code class="fe ma mb mc md b">Batch</code>和<code class="fe ma mb mc md b">Quilt</code>之间的不同有助于说明它们的本质。</p><p id="0b02" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">对<code class="fe ma mb mc md b">Bus</code>的<code class="fe ma mb mc md b">head(2)</code>方法调用返回一个新的由前两个元素组成的<code class="fe ma mb mc md b">Bus</code>，即“庞大的股市数据集”中的前两帧。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="1747" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; bus.head(2)<br/>&lt;Bus&gt;<br/>&lt;Index&gt;<br/>fljh    Frame<br/>bgt     Frame<br/>&lt;&lt;U9&gt;   &lt;object&gt;</span></pre><p id="d9e7" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当<code class="fe ma mb mc md b">Batch</code>对<code class="fe ma mb mc md b">Bus</code>中的每个<code class="fe ma mb mc md b">Frame</code>进行操作时，调用<code class="fe ma mb mc md b">head(2)</code>会从“庞大的股票市场数据集中的每个<code class="fe ma mb mc md b">Frame</code>中提取前两行调用<code class="fe ma mb mc md b">to_frame()</code>将这些提取连接到一个新的<code class="fe ma mb mc md b">Frame</code>中，然后只从其中选择两列:</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="0f76" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; sf.Batch(bus.items()).head(2).to_frame().shape<br/>(14316, 6)<br/>&gt;&gt;&gt; sf.Batch(bus.items()).head(2).to_frame()[['Close', 'Volume']]<br/>&lt;Frame&gt;<br/>&lt;Index&gt;                     Close     Volume  &lt;&lt;U7&gt;<br/>&lt;IndexHierarchy&gt;<br/>fljh             2017-11-07 26.189    1300<br/>fljh             2017-11-08 26.3875   3600<br/>bgt              2005-02-25 11.618    97637<br/>bgt              2005-02-28 11.683    90037<br/>angi             2011-11-21 15.4      469578<br/>angi             2011-11-22 16.12     202970<br/>ccj              2005-02-25 20.235    3830399<br/>ccj              2005-02-28 19.501    3911079<br/>uhs              2005-02-25 22.822    4700749<br/>uhs              2005-02-28 23.056    1739084<br/>eqfn             2015-07-09 8.68      489900<br/>eqfn             2015-07-10 8.58      44100<br/>ivfgc            2016-12-02 99.97     5005<br/>ivfgc            2016-12-05 99.97     6002<br/>achn             2006-10-25 11.5      0<br/>achn             2006-10-26 12.39     361420<br/>eurz             2015-08-19 24.75     200<br/>...              ...        ...       ...<br/>cai              2007-05-16 15.0      3960000<br/>desc             2016-07-26 27.062    1015<br/>desc             2016-07-27 27.15     193<br/>swks             2005-02-25 7.0997    1838285<br/>swks             2005-02-28 6.9653    2737207<br/>hair             2017-10-12 9.92      2818561<br/>hair             2017-10-13 9.6       294724<br/>jnj              1970-01-02 0.5941    1468563<br/>jnj              1970-01-05 0.5776    1185461<br/>rosg             2011-08-05 181.8     183<br/>rosg             2011-08-08 169.2     79<br/>wbbw             2013-04-12 13.8      162747<br/>wbbw             2013-04-15 13.67     126845<br/>twow             2017-10-23 16.7      10045<br/>twow             2017-10-24 16.682    850<br/>gsjy             2016-03-07 25.238    14501<br/>gsjy             2016-03-08 25.158    12457<br/>&lt;&lt;U9&gt;            &lt;&lt;U10&gt;     &lt;float64&gt; &lt;int64&gt;</span></pre><p id="d19f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，<code class="fe ma mb mc md b">Quilt</code>表示所包含的<code class="fe ma mb mc md b">Frame</code>就好像它们是一个单独的、连续的<code class="fe ma mb mc md b">Frame</code>。调用<code class="fe ma mb mc md b">head(2)</code>返回虚拟<code class="fe ma mb mc md b">Frame</code>的前两行，用层次索引标记，其外部标签是<code class="fe ma mb mc md b">Frame</code>的标签(即ticker)。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="5e15" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt.head(2)[['Close', 'Volume']]<br/>&lt;Frame&gt;<br/>&lt;Index&gt;                     Close     Volume  &lt;&lt;U7&gt;<br/>&lt;IndexHierarchy&gt;<br/>fljh             2017-11-07 26.189    1300<br/>fljh             2017-11-08 26.3875   3600<br/>&lt;&lt;U4&gt;            &lt;&lt;U10&gt;     &lt;float64&gt; &lt;int64&gt;</span></pre><h1 id="4253" class="mv mj iq bd mw mx os mz na nb ot nd ne kf ou kg ng ki ov kj ni kl ow km nk nl bi translated">跨容器比较:相同的选择，不同的方法</h1><p id="0340" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">接下来，我们将展示如何对每个容器使用三种方法来返回相同的选择。虽然上面使用的<code class="fe ma mb mc md b">head()</code>方法是一种预配置的选择器，但是所有容器都支持全系列的<code class="fe ma mb mc md b">loc</code>和<code class="fe ma mb mc md b">iloc</code>选择接口。以下示例提取了1962年1月2日以来的所有“打开”和“关闭”记录。</p><p id="4b9c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了用<code class="fe ma mb mc md b">Bus</code>执行这个选择，我们可以遍历每个<code class="fe ma mb mc md b">Frame</code>并选择目标记录。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="66e8" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; for label, f in bus.items():<br/>...     if '1962-01-02' in f.index:<br/>...         print(f.loc['1962-01-02', ['Open', 'Close']].rename(label))<br/>...<br/>&lt;Series: ge&gt;<br/>&lt;Index&gt;<br/>Open         0.6277<br/>Close        0.6201<br/>&lt;&lt;U7&gt;        &lt;float64&gt;<br/>&lt;Series: ibm&gt;<br/>&lt;Index&gt;<br/>Open          6.413<br/>Close         6.3378<br/>&lt;&lt;U7&gt;         &lt;float64&gt;</span></pre><p id="e925" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">与使用<code class="fe ma mb mc md b">Bus</code>相比，<code class="fe ma mb mc md b">Batch</code>提供了更紧凑的界面来实现这种选择。在不编写循环的情况下，<code class="fe ma mb mc md b">Batch.apply_except()</code>方法可以从每个包含的<code class="fe ma mb mc md b">Frame</code>中选择行和列值，同时忽略从没有选定日期的<code class="fe ma mb mc md b">Frame</code>中产生的任何<code class="fe ma mb mc md b">KeyError</code>。调用<code class="fe ma mb mc md b">to_frame()</code>将结果和它们的<code class="fe ma mb mc md b">Frame</code>标签连接在一起。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="52fc" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; sf.Batch(bus.items()).apply_except(<br/>    lambda f: f.loc[‘1962–01–02’, [‘Open’, ‘Close’]], <br/>    KeyError).to_frame()<br/>&lt;Frame&gt;<br/>&lt;Index&gt; Open      Close     &lt;&lt;U7&gt;<br/>&lt;Index&gt;<br/>ge      0.6277    0.6201<br/>ibm     6.413     6.3378<br/>&lt;&lt;U3&gt;   &lt;float64&gt; &lt;float64&gt;</span></pre><p id="9770" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">最后，作为<code class="fe ma mb mc md b">Frame</code>的虚拟连接，<code class="fe ma mb mc md b">Quilt</code>允许选择，就像从单个<code class="fe ma mb mc md b">Frame</code>中选择一样。如下图所示，内层标签“1962–01–02”上的分层选择将所有报价机中该日期的所有记录汇集在一起。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="9add" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; quilt.loc[sf.HLoc[:, '1962-01-02'], ['Open', 'Close']]<br/>&lt;Frame&gt;<br/>&lt;Index&gt;                     Open      Close     &lt;&lt;U7&gt;<br/>&lt;IndexHierarchy&gt;<br/>ge               1962-01-02 0.6277    0.6201<br/>ibm              1962-01-02 6.413     6.3378<br/>&lt;&lt;U3&gt;            &lt;&lt;U10&gt;     &lt;float64&gt; &lt;float64&gt;</span></pre></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="4271" class="mv mj iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">最小化内存使用</h1><p id="ee55" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">在前面的例子中，<code class="fe ma mb mc md b">Bus</code>被显示为在被访问时延迟加载数据。虽然这只允许加载需要的东西，但是对已加载的<code class="fe ma mb mc md b">Frame</code>的强引用保留在<code class="fe ma mb mc md b">Bus</code>中，将它们保存在内存中。对于大型数据集合，这可能会导致不希望的数据保留。</p><p id="1786" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过在<code class="fe ma mb mc md b">Bus</code>初始化中使用<code class="fe ma mb mc md b">max_persist</code>参数，我们可以确定<code class="fe ma mb mc md b">Bus</code>中保留的<code class="fe ma mb mc md b">Frame</code>的最大数量。如下图所示，通过将<code class="fe ma mb mc md b">max_persist</code>设置为1，在加载每个<code class="fe ma mb mc md b">Frame</code>后，加载的<code class="fe ma mb mc md b">Frame</code>的数量保持为1:</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="45dd" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; bus = sf.Bus.from_zip_pickle(‘stocks.zip’, max_persist=1)<br/>&gt;&gt;&gt; bus[‘aapl’].shape<br/>(8364, 6)<br/>&gt;&gt;&gt; bus.status[‘loaded’].sum()<br/>1</span><span id="0c21" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; bus[‘ibm’].shape<br/>(14059, 6)<br/>&gt;&gt;&gt; bus.status[‘loaded’].sum()<br/>1</span><span id="beeb" class="mi mj iq md b gy ob ml l mm mn">&gt;&gt;&gt; bus[‘goog’].shape<br/>(916, 6)<br/>&gt;&gt;&gt; bus.status[‘loaded’].sum()<br/>1</span></pre><p id="c0e3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">使用这种配置，一个进程可以遍历所有7，163个<code class="fe ma mb mc md b">Frame</code>，在每个<code class="fe ma mb mc md b">Frame</code>上工作，但只会导致单个<code class="fe ma mb mc md b">Frame</code>的内存开销。虽然同样的例程可以在单个<code class="fe ma mb mc md b">Frame</code>上使用group-by来执行，但是这种方法明显倾向于在计算时间上最小化内存使用。下面的例子演示了这样一种方法，找出所有股票的收盘价之间的最大跨度。</p><pre class="kp kq kr ks gt me md mf mg aw mh bi"><span id="6315" class="mi mj iq md b gy mk ml l mm mn">&gt;&gt;&gt; max_span = 0<br/>&gt;&gt;&gt; for label in bus.index:<br/>...     max_span = max(bus[label]['Close'].max() <br/>            - bus[label]['Close'].min(), <br/>            max_span)<br/>...<br/>&gt;&gt;&gt; max_span<br/>1437986239.4042<br/>&gt;&gt;&gt; bus.status['loaded'].sum()<br/>1</span></pre><p id="c850" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">由于可以将<code class="fe ma mb mc md b">Bus</code>作为输入提供给<code class="fe ma mb mc md b">Batch</code>、<code class="fe ma mb mc md b">Quilt</code>和<code class="fe ma mb mc md b">Yarn</code>，所以整个系列的容器都可以从这种减少内存开销的方法中受益。</p><h1 id="5b77" class="mv mj iq bd mw mx os mz na nb ot nd ne kf ou kg ng ki ov kj ni kl ow km nk nl bi translated">并行处理</h1><p id="5ada" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">独立处理大量的<code class="fe ma mb mc md b">Frame</code>是一个令人尴尬的并行问题。因此，这些高阶容器为并行处理提供了机会。</p><p id="d137" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">所有压缩文档的构造器和导出器，比如<code class="fe ma mb mc md b">from_zip_parquet()</code>或<code class="fe ma mb mc md b">to_zip_npz()</code>，都支持一个<code class="fe ma mb mc md b">config</code>参数，该参数允许在一个<code class="fe ma mb mc md b">StoreConfig</code>实例中指定多处理<code class="fe ma mb mc md b">Frame</code>反序列化或序列化的工作线程数量和块大小。<code class="fe ma mb mc md b">StoreConfig</code>的相关参数有<code class="fe ma mb mc md b">read_max_workers</code>、<code class="fe ma mb mc md b">read_chunksize</code>、<code class="fe ma mb mc md b">write_max_workers</code>和<code class="fe ma mb mc md b">write_chunksize</code>。</p><p id="99dd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">类似地，所有的<code class="fe ma mb mc md b">Batch</code>构造函数都公开了<code class="fe ma mb mc md b">max_workers</code>、<code class="fe ma mb mc md b">chunk_size</code>和<code class="fe ma mb mc md b">use_threads</code>参数，以允许并行处理<code class="fe ma mb mc md b">Frames</code>。只需启用这些参数，对大量<code class="fe ma mb mc md b">Frame</code>的操作就可以是多进程或多线程的，有可能带来显著的性能提升。虽然在Python中使用线程进行CPU受限的处理通常是低效的，但是使用线程池执行的一些基于NumPy的操作(在全局解释器锁之外)可以优于进程池。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="bcb7" class="mv mj iq bd mw mx my mz na nb nc nd ne kf nf kg ng ki nh kj ni kl nj km nk nl bi translated">结论</h1><p id="a57e" class="pw-post-body-paragraph le lf iq lg b lh nm ka lj lk nn kd lm ln no lp lq lr np lt lu lv nq lx ly lz ij bi translated">虽然存在处理数据帧集合的相关工具，但是<code class="fe ma mb mc md b">Bus</code>、<code class="fe ma mb mc md b">Batch</code>、<code class="fe ma mb mc md b">Quilt</code>和<code class="fe ma mb mc md b">Yarn</code>提供了定义良好的抽象，涵盖了处理潜在的大量表集合的常见需求。结合延迟加载、急切卸载和延迟执行，以及对多种多表存储格式的支持，这些工具为数据帧处理提供了宝贵的资源。</p></div></div>    
</body>
</html>