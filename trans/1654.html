<html>
<head>
<title>Towards Solving IBM's Quantum Open Science Prize</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决IBM的量子开放科学奖</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/towards-solving-ibms-quantum-open-science-prize-cb6688878779#2022-04-19">https://towardsdatascience.com/towards-solving-ibms-quantum-open-science-prize-cb6688878779#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62d8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">今天，我们满足了参赛条件</h2></div><p id="0da4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_towpart&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><p id="55ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何发现是否从事量子计算的职业？大约三个月前，我声称最好的方法是研究IBM的量子开放科学奖。</p><p id="db87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这正是我们所做的。在我之前的文章中，我们讨论了这个挑战的本质细节。IBM希望我们使用Trotterization在IBM Quantum的7量子位雅加达系统上模拟一个三粒子系统的海森堡模型哈密顿量。首先，我们了解到<a class="ae le" rel="noopener" target="_blank" href="/a-first-glimpse-at-ibms-quantum-open-science-price-challenge-de4a2f41987e">真正的挑战不是模拟一个三粒子系统的海森堡模型哈密顿量。相反，它是关于如何在一个嘈杂的设备上做它</a>。因此，我们建立了<a class="ae le" href="https://pyqml.medium.com/how-to-set-up-jupyterlab-to-participate-in-ibms-quantum-open-science-prize-1a9d44b95bf6" rel="noopener">我们的开发环境</a>，查看了<a class="ae le" rel="noopener" target="_blank" href="/how-to-run-code-on-a-real-quantum-computer-c1fc61ff5b4">如何使用真正的量子计算机</a>，并且<a class="ae le" href="https://pyqml.medium.com/how-to-tackle-ibms-quantum-open-science-prize-e6c7fc594154" rel="noopener">向我们介绍了量子错误缓解方法</a>。</p><p id="7d2f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们选择了<a class="ae le" href="https://pyqml.medium.com/mitigating-quantum-errors-using-clifford-data-regression-98ab663bf4c6" rel="noopener"> Clifford数据回归(CDR)方法</a>。在CDR中，我们使用可以经典模拟的量子电路来训练噪声模型。这个噪声模型让我们从有噪声的值中预测无噪声的值。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/0ee80ec90f3b7602543af4f1a2f4edcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THqMWoQywY4SYAupPqm_Fw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">作者图片</p></figure><p id="7a96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用Qiskit和Mitiq实现了这种方法，在<a class="ae le" rel="noopener" target="_blank" href="/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c">本地模拟</a>和<a class="ae le" rel="noopener" target="_blank" href="/practical-error-mitigation-on-a-real-quantum-computer-41a99dddf740">真实量子计算机</a>上，结果都很有希望。不幸的是，我们认识到<a class="ae le" rel="noopener" target="_blank" href="/just-another-ordinary-day-in-the-life-of-a-quantum-software-engineer-24689cd962ff">我们不能使用CDR方法，除非我们重写IBM评估我们解决方案性能的方式</a>。我们没有这样做，因为这可能会取消我们提交的资格。相反，我们决定改变我们的方法。</p><p id="a26f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们研究了<a class="ae le" rel="noopener" target="_blank" href="/towards-quantum-measurement-error-mitigation-e6f134883f34">如何减轻噪声以满足IBM的期望</a>和【在测量级别减轻噪声】。</p><p id="4a6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们现在准备把它放在一起。</p><p id="dcd9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从概念上讲，我们遵循CDR方法的方法。</p><ol class=""><li id="9935" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ma mb mc md bi translated">生成培训数据</li><li id="a953" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">训练一个噪声模型</li><li id="9a83" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ma mb mc md bi translated">从有噪声的测量值预测无噪声的测量值</li></ol><h1 id="3ab8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">生成培训数据</h1><p id="6641" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr nd kt ku kv ne kx ky kz nf lb lc ld im bi translated">我们的训练数据由成对的测量值组成。每对由同一量子电路的有噪和无噪测量组成。为了创建这些训练数据，我们需要各自的运行时环境。</p><ul class=""><li id="b169" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ng mb mc md bi translated">无噪声(经典)模拟器</li><li id="4203" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ng mb mc md bi translated">一个嘈杂的量子设备或一个嘈杂的模拟器</li></ul><p id="29f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们使用Qiskit的<code class="fe nh ni nj nk b">QasmSimulator</code>作为两种环境。首先，我们初始化没有任何参数的<code class="fe nh ni nj nk b">QasmSimulator</code> Python类，以获得无噪声模拟器。第二，我们使用我们的IBM Quantum帐户创建一个基于Jakarta设备噪声特征的模拟后端。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="95cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步，我们需要准备量子训练电路。这里的挑战是使用代表问题的电路，但经典的模拟。最初的CDR方法通过建立电路的有噪声和无噪声期望值之间的线性关系来实现可表示性。此外，它使用由Clifford门组成的电路。这些是经典的可模拟的门。</p><p id="d331" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，我们不能使用期望值，但我们需要减轻测量级别的噪声。我们不能在有噪声和无噪声值之间建立线性关系。此外，海森堡哈密顿模拟的问题是它的潜在规模。因此，即使它完全由Clifford gates组成，对于任何给定特定大小的经典计算机来说，整个电路都变得难以处理。因此，虽然一个三粒子的海森堡哈密顿量是小菜一碟，但一个五十粒子的海森堡哈密顿量是不可能经典模拟的。</p><p id="18f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们需要重新思考我们的训练数据。我们从IBM提供的trotter化算法开始。该算法包含至少四个三态门。在之前的帖子中，我们了解到，trotterization门越多，无噪声性能越好。然而，我们使用越多的trotterization门，算法对噪声就变得越敏感。如果不采取缓解措施，噪声的负面影响将超过性能提升。但是对于缓解，使用多于最小数量的四个三态门可能是有意义的。</p><p id="262e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，对于训练来说，即使是四个trotterization门也太大了。我们需要更短的线路。幸运的是，每个trotter gate由三个子电路组成，<code class="fe nh ni nj nk b">XX</code>、<code class="fe nh ni nj nk b">YY</code>和<code class="fe nh ni nj nk b">ZZ</code>门。因此，我们的计划是构建一个训练电路，在一个tterization门中只包含三个子电路中的两个子电路。</p><p id="7037" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的函数为我们提供了这些电路。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0bc2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，这是IBM不变的trotter化电路。<code class="fe nh ni nj nk b">get_circuit</code>函数提供了一个可参数化的接口，以从中创建训练电路。这个想法是，我们可以通过参数<code class="fe nh ni nj nk b">X</code>、<code class="fe nh ni nj nk b">Y</code>和<code class="fe nh ni nj nk b">Z</code>定制我们想要包含的子电路。除非我们包括所有三个子电路，否则我们只增加一个tterization门。例如，如果我们有<code class="fe nh ni nj nk b">XX</code>和<code class="fe nh ni nj nk b">YY</code>门，该函数用这些门为单个trotter步骤创建一个电路。有必要提一下，我们需要使用预定的量子化步骤数，因为我们使用这个数作为量子位旋转的参数化。所以，具有不同快步数的电路是完全不同的。</p><p id="d760" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在准备创建训练回路。让我们用12个快步。如果你喜欢，你可以玩不同数量的步骤。</p><p id="733d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了三组电路。这些电路具有</p><ul class=""><li id="159d" class="lv lw it kk b kl km ko kp kr lx kv ly kz lz ld ng mb mc md bi translated"><code class="fe nh ni nj nk b">XX</code>和<code class="fe nh ni nj nk b">YY</code>闸门</li><li id="1884" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ng mb mc md bi translated"><code class="fe nh ni nj nk b">YY</code>和<code class="fe nh ni nj nk b">ZZ</code>闸门</li><li id="f858" class="lv lw it kk b kl me ko mf kr mg kv mh kz mi ld ng mb mc md bi translated"><code class="fe nh ni nj nk b">ZZ</code>和<code class="fe nh ni nj nk b">XX</code>门</li></ul><p id="2920" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，你也可以玩门的组合。</p><p id="57b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不是每个都创建一个单独的电路，而是27个！原因是IBM用来评估我们的模拟性能的量子态断层扫描。量子态层析成像通过从所有专有角度观察量子系统来重建量子态。对于三量子位系统，这些是3^3=27角。每个角度都会导致稍微不同的量子电路。但是这些微小的差异会显著影响测量结果。本质上，我们分别对待这些电路。</p><p id="481a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在下面的步骤中，我们为每个指定的组合创建了27个回路。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9bc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在执行所有这些电路之前，我们创建了两个辅助函数。简而言之，<code class="fe nh ni nj nk b">sorted_counts</code>函数对来自已执行电路的测量计数进行排序，并确保所有可能的状态都存在，即使它们的计数为零。</p><p id="afad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nh ni nj nk b">get_modifiers</code>函数获取一个电路，在我们的无噪声和有噪声模拟器上执行，并计算一个修改量列表。我们的电路可以产生八分之一的状态。这些范围从<code class="fe nh ni nj nk b">000</code>到<code class="fe nh ni nj nk b">111</code>。每个值都有一个修饰符。因此，每个电路有八个修改器。修改量是一个数字，当我们乘以它时，它将噪声计数变为正确的无噪声计数。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1506" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过应用<code class="fe nh ni nj nk b">get_modifiers</code>功能，我们将所有电路转换成各自的修改器。变量<code class="fe nh ni nj nk b">modifiers_xy</code>、<code class="fe nh ni nj nk b">modifiers_yz</code>和<code class="fe nh ni nj nk b">modifiers_zx</code>分别是27个电路的列表。每个元素是八个修饰符的列表。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="30db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们<code class="fe nh ni nj nk b">zip</code>将这些放入一个单独的列表(<code class="fe nh ni nj nk b">modifiers_zipped</code>)。结果是包含8个修饰符的三项元组的27个回路的列表。</p><p id="3e93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下一步中，我们计算每个回路的最终修改量。我们在<code class="fe nh ni nj nk b">mult</code>函数中这样做。该函数采用上述回路修饰符的元组。通过压缩这些元组，我们得到一个包含八个条目的列表，每个条目对应三个修饰符。实际上，我们对修饰符进行了排序，使它们都在一个对应于特定计数的列表中。</p><p id="c02b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将最终修饰符计算为这样一个列表中所有修饰符到trotter步骤一半的乘积。</p><p id="f8e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">综上所述，我们创建了三个小型经典可仿真电路，代表我们想要降低其测量值的整体电路。对于这三个电路中的每一个，我们都计算出一个修正因子列表，告诉我们有噪计数与无噪计数的偏差。最后，我们将对应于一个计数的所有修饰符相乘，从而将它们组合起来。</p><p id="c0c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，每个小回路都有三分之二的快步步。所以，这三个小电路结合起来表示两个快步走。为了计算与整个电路相对应的修改量，我们需要多次进行乘法运算。这是快步数除以二。</p><p id="e158" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们没有单个整体电路，而是27个电路，因为我们的目标是使用状态层析成像。</p><p id="308f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看我们的最终修改器有多好。我们重用了前几篇文章中创建的两个助手。这些是<code class="fe nh ni nj nk b">OwnResult</code> Python类和基于该类计算最终状态层析的<code class="fe nh ni nj nk b">state_tomo</code>函数(参见本文)。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lg lh li lj gt nn nk no np aw nq bi"><span id="6ca4" class="nr mk it nk b gy ns nt l nu nv">noisy state tomography fidelity = 0.2861 ± 0.0000<br/>noise-free state tomography fidelity = 0.9699 ± 0.0000<br/>mitigated state tomography fidelity = 0.7518 ± 0.0000</span></pre><p id="78fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总体结果显示出显著的改善。有了12个快步，最好的状态层析成像保真度大约是<code class="fe nh ni nj nk b">0.97</code>。这就是无噪声量子计算机所能达到的目标。</p><p id="8006" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，由于未减轻的(模拟的)噪声，状态层析成像下降到<code class="fe nh ni nj nk b">0.29</code>。但是一旦我们用我们的修改器减轻噪声，我们就得到一个<code class="fe nh ni nj nk b">0.75</code>的状态层析成像保真度。参加IBM量子开放科学奖的参赛标准是<code class="fe nh ni nj nk b">0.3</code>的保真度。所以，我想说我们很好。</p><p id="da98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看统计数据可以发现我们方法的有效性。我们减少了大约68%的噪音。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="lg lh li lj gt nn nk no np aw nq bi"><span id="a320" class="nr mk it nk b gy ns nt l nu nv">Error (unmitigated): 0.6838963295732885<br/>Error (mitigated): 0.21813650699579556<br/>Relative error (unmitigated): 0.7050850779029165<br/>Relative error (mitigatedR): 0.22489489909174665<br/>Error reduction: 68.1%.</span></pre><p id="6af4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_towpart&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手用Python </strong> </a> <strong class="kk iu">学习量子机器。</strong></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_towpart&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>