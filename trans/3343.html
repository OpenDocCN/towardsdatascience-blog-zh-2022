<html>
<head>
<title>31 Uniques Python Packages To Improve Your Data Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">31个独特的Python包来改进您的数据工作流</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/31-uniques-python-packages-to-improve-your-data-workflow-4f9762fc8f8b#2022-07-26">https://towardsdatascience.com/31-uniques-python-packages-to-improve-your-data-workflow-4f9762fc8f8b#2022-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="535a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">面向数据人员的各种Python包</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00a233fcc0190b96a4a3c62f2b256e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*btaN1TBjboff7O1o"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·席默克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="84f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据是一个广阔的领域，有大量的社区支持技术发展。此外，Python拥有热心的支持者，帮助数据世界变得更容易访问，并为数据工作流带来价值。</p><p id="9a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经开发了各种Python包来帮助数据人员的工作。根据我的经验，许多有用的数据Python包缺乏认知度，或者仍在流行。</p><p id="9c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么在本文中，我想向您介绍几个独特的Python包，它们将在许多方面帮助您的数据工作流。让我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="df52" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.敲门</h2><p id="39af" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/huggingface/knockknock/blob/master/README.md/" rel="noopener ugc nofollow" target="_blank"> Knockknock </a>是一个简单的Python包，用于在机器学习模型训练完成或崩溃时通知你。我们可以通过电子邮件、Slack、微软团队等多种渠道获得通知。</p><p id="7969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了安装这个包，我们使用下面的代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b5d1" class="mc md it nb b gy nf ng l nh ni">pip install knockknock</span></pre><p id="047a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以使用以下代码向您的Gmail电子邮件地址通知您的机器学习建模培训状态。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d49d" class="mc md it nb b gy nf ng l nh ni">from knockknock import email_sender<br/>from sklearn.linear_model import LinearRegression<br/>import numpy as np</span><span id="06a6" class="mc md it nb b gy nj ng l nh ni">@email_sender(recipient_emails=["&lt;your_email@address.com&gt;", "&lt;your_second_email@address.com&gt;"], sender_email="&lt;sender_email@gmail.com&gt;")</span><span id="1047" class="mc md it nb b gy nj ng l nh ni">def train_linear_model(your_nicest_parameters):</span><span id="caa4" class="mc md it nb b gy nj ng l nh ni">    x = np.array([[1, 1], [1, 2], [2, 2], [2, 3]])<br/>    y = np.dot(x, np.array([1, 2])) + 3 <br/>    regression = LinearRegression().fit(x, y) <br/><br/>    return regression.score(x, y)</span></pre><p id="2f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论你返回哪个函数，你都会得到通知。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="eee1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.tqdm</h2><p id="0c8e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当你做一个迭代或者循环过程时，你需要一个进度条吗？那么<a class="ae ky" href="https://github.com/tqdm/tqdm" rel="noopener ugc nofollow" target="_blank"> tqdm </a>就是你的答案。这个包会在你的笔记本或命令提示符中提供一个简单的进度条。</p><p id="9f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3319" class="mc md it nb b gy nf ng l nh ni">pip install tqdm</span></pre><p id="21d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以尝试使用下面的代码来显示循环过程中的进度条。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="47f2" class="mc md it nb b gy nf ng l nh ni">from tqdm import tqdm<br/>q = 0<br/>for i in tqdm(range(10000000)):<br/>    q = i +1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/a16c7877c480bd45bc9af1e586402ca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xQfcYOFbWMfJNxbZodu0QA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者GIF</p></figure><p id="11b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的GIF中看到的，你的笔记本中显示了一个漂亮的进度条。当您有一个复杂的迭代并且想要跟踪进度时，它会有用得多。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="572c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.熊猫-日志</h2><p id="e503" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/eyaltrabelsi/pandas-log" rel="noopener ugc nofollow" target="_blank"> Pandas-log </a>是一个Python包，提供对熊猫基本操作的反馈，比如<code class="fe nl nm nn nb b">.query</code>、<code class="fe nl nm nn nb b">.drop</code>、<code class="fe nl nm nn nb b">.merge</code>等等。它基于R Tidyverse，在这里你可以理解所有的数据分析步骤。</p><p id="124d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试安装软件包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3523" class="mc md it nb b gy nf ng l nh ni">pip install pandas-log</span></pre><p id="6006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装软件包后，让我们使用以下代码创建一个示例数据框。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="69e6" class="mc md it nb b gy nf ng l nh ni">import pandas as pd<br/>import numpy as np<br/>import pandas_log</span><span id="d926" class="mc md it nb b gy nj ng l nh ni">df = pd.DataFrame({"name": ['Alfred', 'Batman', 'Catwoman'],<br/>                   "toy": [np.nan, 'Batmobile', 'Bullwhip'],<br/>                   "born": [pd.NaT, pd.Timestamp("1940-04-25"),   pd.NaT]})</span></pre><p id="9d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们用下面的代码尝试做一个简单的熊猫执行。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="953b" class="mc md it nb b gy nf ng l nh ni">with pandas_log.enable():<br/>    res = (df.drop("born", axis = 1)<br/>             .groupby('name')<br/>          )</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/40c28fb7179814966d1c49ee290aa7cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TMkDgB6T1Zvrw3yRUZUVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f4d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了Pandas-log，我们可以获得所有的执行信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2bb2" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.表情符号</h2><p id="1a96" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">顾名思义，<a class="ae ky" href="https://github.com/carpedm20/emoji/" rel="noopener ugc nofollow" target="_blank">表情符号</a>是一个支持表情符号文本数据分析的Python包。通常，我们在阅读Python的表情符号时会有困难，但是表情符号包可以帮助我们。</p><p id="e825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下代码安装表情包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e540" class="mc md it nb b gy nf ng l nh ni">pip install emoji</span></pre><p id="bdbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试一个简单的包装表情符号。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="964a" class="mc md it nb b gy nf ng l nh ni">import emoji<br/>print(emoji.emojize('Python is :thumbs_up:'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/936316691c1fca44aa4ed923925809e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/format:webp/1*_f5AY2wDAIBE_lSFZAYD0Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="712a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个包，我们可以输出表情符号，因为表情符号已经被解码成Python中可接受的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6ecd" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">5.TheFuzz</h2><p id="f251" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/seatgeek/thefuzz" rel="noopener ugc nofollow" target="_blank"> TheFuzz </a>是一个Python包，它使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein距离</a>计算相似度来匹配文本。</p><p id="4d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用这个包，我们需要先安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5948" class="mc md it nb b gy nf ng l nh ni">pip install thefuzz</span></pre><p id="8988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试这个包，看看我们如何使用TheFuzz包来进行相似性文本匹配。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="03d1" class="mc md it nb b gy nf ng l nh ni">from thefuzz import fuzz, process</span><span id="08bf" class="mc md it nb b gy nj ng l nh ni">#Testing the score between two sentences<br/>fuzz.ratio("Test the word", "test the Word!")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/6efe8667c0dc96e87dba3cb0f55b858a.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*LDF4tRah2bMCcCbqhHgOhw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cc8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Fuzz还可以同时从许多单词中提取相似性分数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aacf" class="mc md it nb b gy nf ng l nh ni">choices = ["Atlanta Falcons", "New York Jets", "New York Giants", "Dallas Cowboys"]<br/>process.extract("new york jets", choices, limit=2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/24e854a6681332837938e945771547f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V0ZPje-G4xN5k0Xmd9Pe7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Fuzz适用于任何文本数据相似性活动。它应该是你的武器库中的一个包。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8341" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">6.数字计算器</h2><p id="2794" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/jaidevd/numerizer" rel="noopener ugc nofollow" target="_blank"> Numerizer </a>是一个Python包，它将书写的数字文本转换成整数或浮点数。让我们试试这个包来了解更多。</p><p id="bb51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用下面的代码安装这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="27fb" class="mc md it nb b gy nf ng l nh ni">pip install numerizer</span></pre><p id="8592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以测试这个包。我们来试试几个词来转化。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0bad" class="mc md it nb b gy nf ng l nh ni">from numerizer import numerize<br/>numerize('forty two')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7d3badf2c2a505195a7a6435b9ef3b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*i5b5pCoCvXOIuxu6eskYTA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="db1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，单词被转换成了它们的整数对应物。如果你使用另一种书写风格，比如下面的，它也是有效的。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d751" class="mc md it nb b gy nf ng l nh ni">numerize('forty-two')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/250c3a28b9c36e3c99b0cf14a9c71680.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*h4n9GWRu12Da7kwRPopYYQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也适用于表示浮点数字文本的单词。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5db8" class="mc md it nb b gy nf ng l nh ni">numerize('nine and three quarters')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/cb1ad0810469df762a8c4abc0c21b51d.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*k7aKaCUJ1TTZY0Vjone8vw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c7a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果单词不是一个数字表达式，它们会保持原样。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7117" class="mc md it nb b gy nf ng l nh ni">numerize('maybe around nine and three quarters')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/cb152e3c654c0d0e31f7e24d654b9424.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*xwk20_1sgXARYSltnxRJ2A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b2f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个包很简单，但是在很多场合都很有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="55f1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">7.PyAutoGUI</h2><p id="3ae4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">PyAutoGUI是一个简单的Python包，可以自动控制鼠标和键盘。它的工作原理是在你的IDE中传递代码并让它们为你工作。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9f05" class="mc md it nb b gy nf ng l nh ni">pip install pyautogui</span></pre><p id="7d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用下面的代码来测试这个动作。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2b20" class="mc md it nb b gy nf ng l nh ni">import pyautogui<br/>pyautogui.moveTo(10, 15)<br/>pyautogui.click()<br/>pyautogui.doubleClick()<br/>pyautogui.press('enter')</span></pre><p id="73f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码会将鼠标移动到某个位置并点击你的鼠标。通过按下功能，你也可以按下某个键盘按钮。</p><p id="e01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你需要像下载文件或收集数据这样的重复性动作时，这个包非常有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="fb0c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">8.加权计算</h2><p id="9dd6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/jsvine/weightedcalcs" rel="noopener ugc nofollow" target="_blank"> Weightedcalcs </a>是一个Python包，用于简化基于我们的数据框架的加权统计计算。从简单的统计，如加权平均值、中值和标准偏差，到加权计数和分布，用法各不相同。</p><p id="0522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用这个包，我们需要使用下面的代码来安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="eabb" class="mc md it nb b gy nf ng l nh ni">pip install weightedcalcs</span></pre><p id="5655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着用现有的数据来计算一个加权分布。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d199" class="mc md it nb b gy nf ng l nh ni">import seaborn as sns<br/>df = sns.load_dataset('mpg')</span></pre><p id="4396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我会使用seaborn包中的MPG数据集。为了计算加权统计量，我们需要首先用加权变量声明类。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b109" class="mc md it nb b gy nf ng l nh ni">import weightedcalcs as wc<br/>calc = wc.Calculator("mpg")</span></pre><p id="bfbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将使用该类通过传递数据集和计算预期变量来进行加权计算。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aba4" class="mc md it nb b gy nf ng l nh ni">calc.distribution(df, "origin")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/e73ca4bbc4d0a7d0374478f8ef08cbc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*pZjcOG5HJZ97S7Y0YNRiqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="4280" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">9.scikit-posthocs</h2><p id="5842" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/maximtrp/scikit-posthocs" rel="noopener ugc nofollow" target="_blank"> scikit-posthocs </a>是一个用于事后测试分析的python包，通常用于统计分析中的成对比较。这个包提供了简单的scikit-learn API来进行分析。让我们从安装软件包到试用它开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0b4f" class="mc md it nb b gy nf ng l nh ni">pip install scikit-posthocs</span></pre><p id="f593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么让我们从简单的数据集开始，在试用这个包之前做一个ANOVA测试。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9fc6" class="mc md it nb b gy nf ng l nh ni">import statsmodels.api as sa<br/>import statsmodels.formula.api as sfa<br/>import scikit_posthocs as sp<br/>df = sa.datasets.get_rdataset('iris').data<br/>df.columns = df.columns.str.replace('.', '')</span><span id="010a" class="mc md it nb b gy nj ng l nh ni">lm = sfa.ols('SepalWidth ~ C(Species)', data=df).fit()<br/>anova = sa.stats.anova_lm(lm)<br/>print(anova)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d53ef7f60c3b80eff2628999ee2158bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*bXtXYrAElfoK3rIvB_k2WA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="232e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得了ANOVA测试结果，但不确定哪个变量类别对结果的影响最大。这就是为什么我们要使用下面的代码进行事后测试。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="baa7" class="mc md it nb b gy nf ng l nh ni">sp.posthoc_ttest(df, val_col='SepalWidth', group_col='Species', p_adjust='holm')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1c0534bbabcfd115cc51d4257fd7de3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*ZWl3Zpc7mM6VljZ2mKSMfg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用scikit-posthoc，我们简化了事后检验的成对分析过程，并获得了P值。如果你想了解更多的事后测试，你可以在我下面的另一篇文章中读到更多。</p><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/multiple-hypothesis-testing-correction-for-data-scientist-46d3a3d1611d"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">数据科学家的多重假设检验修正</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">知道当你有很多特性要测试时该做什么(用编码来帮助你)</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="16b0" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">10.youtube_dl</h2><p id="6bdc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/ytdl-org/youtube-dl" rel="noopener ugc nofollow" target="_blank"> youtube_dl </a>是一个简单的python包，通过提供代码链接来下载youtube视频。让我们先安装包来试试这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="640a" class="mc md it nb b gy nf ng l nh ni">pip install youtube_dl</span></pre><p id="4151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用以下代码将视频下载到您的环境中。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a77b" class="mc md it nb b gy nf ng l nh ni"># Youtube Dl Example<br/>import youtube_dl<br/>ydl_opt = {}</span><span id="5e19" class="mc md it nb b gy nj ng l nh ni">with youtube_dl.YoutubeDL(ydl_opt) as ydl:<br/>    ydl.download(['<a class="ae ky" href="https://www.youtube.com/watch?v=ukzFI9rgwfU'" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=ukzFI9rgwfU'</a>])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/10e5c4ae647f5b08ddc0cf1267d042d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BYm6liNXcCKjT_QPpF1vQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="24e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载过程将开始，mp4格式的视频将可用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="fb21" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">11.地狱犬座</h2><p id="d835" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Cerberus是一个轻量级python包，用于数据验证活动。它旨在验证我们发起的任何模式数据以及基于它的数据。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0381" class="mc md it nb b gy nf ng l nh ni">pip install cerberus</span></pre><p id="1daf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Cerberus的基本用法是启动验证器类来拥有数据模式。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4f91" class="mc md it nb b gy nf ng l nh ni">from cerberus import Validator<br/>schema = {'name': {'type': 'string'}, 'gender':{'type': 'string'}, 'age':{'type':'integer'}}<br/>v = Validator(schema)</span></pre><p id="8fa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，使用我们传递给验证器类的模式，我们可以验证传递给代码的数据。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aeb8" class="mc md it nb b gy nf ng l nh ni">document = {'name': 'john doe', 'gender':'male', 'age': 15}<br/>v.validate(document)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/a3f50c19d382e83fc47393c0e678f9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*Zg0LFCKHRy84h9tza8TcRw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c89b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果传递的数据与模式相似，那么验证器类将得到真实的输出。这样，我们可以确保数据输入对于模式总是可靠的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0b89" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">12.ppscore</h2><p id="e1e6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/8080labs/ppscore" rel="noopener ugc nofollow" target="_blank"> ppscore </a>是一个python包，用来计算关于目标变量的变量预测能力。该软件包计算可以检测两个变量之间的线性或非线性关系的分数。得分范围从0(无预测能力)到1(完美预测能力)。</p><p id="d301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将安装软件包进行测试。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="27c8" class="mc md it nb b gy nf ng l nh ni">pip install ppscore</span></pre><p id="3648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后使用可用的数据，我们将使用ppscore包来计算基于目标的分数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3e67" class="mc md it nb b gy nf ng l nh ni">import seaborn as sns<br/>import ppscore as pps</span><span id="f571" class="mc md it nb b gy nj ng l nh ni">df = sns.load_dataset('mpg')<br/>pps.predictors(df, 'mpg')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/20572f2eb0c3672a1009cc62c7e5bf66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLXOIm-nLThf1EDl6TJvQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="da6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是根据目标及其ppscore对变量进行排序。排名越低，变量对目标的预测能力越低。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a787" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">13.玛雅人</h2><p id="4ae2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Maya是一个python包，用于尽可能轻松地解析日期时间数据。它使用一种简单的人类可读的交互来获取我们想要的日期时间数据。让我们通过首先安装它来开始使用这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b766" class="mc md it nb b gy nf ng l nh ni"> pip install maya</span></pre><p id="822a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用下面的代码轻松访问当前日期。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9ddf" class="mc md it nb b gy nf ng l nh ni">import maya<br/>now = maya.now()<br/>print(now)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/2a19c17c95a72b889b866c132856a377.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*wplrdqsp3RWeWBznmtA4zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="eba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以为明天的日期初始化一个对象类。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7588" class="mc md it nb b gy nf ng l nh ni">tomorrow = maya.when('tomorrow')<br/>tomorrow.datetime()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ff266961a638e0d9b3d1f1fa556e2efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*IOkBvi05Vg0T_jkJgJ9IDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cd59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个包对于任何与时间序列相关的活动都很有用，所以试试吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b526" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">14.钟摆</h2><p id="9f57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://pendulum.eustace.io/" rel="noopener ugc nofollow" target="_blank"> Pendulum </a>是另一个关注日期时间数据的python包。它用于简化任何日期时间分析过程。让我们从导入包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1d51" class="mc md it nb b gy nf ng l nh ni">pip install pendulum </span></pre><p id="3727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个简单的例子，我们可以很容易地访问时间，并用下面的代码更改它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="383f" class="mc md it nb b gy nf ng l nh ni">import pendulum</span><span id="3b1a" class="mc md it nb b gy nj ng l nh ni">now = pendulum.now("Europe/Berlin")</span><span id="ff47" class="mc md it nb b gy nj ng l nh ni"># Changing timezone<br/>now.in_timezone("Asia/Tokyo")</span><span id="461c" class="mc md it nb b gy nj ng l nh ni"># Default support for common datetime formats<br/>now.to_iso8601_string()</span><span id="b553" class="mc md it nb b gy nj ng l nh ni"># Day Shifting<br/>now.add(days=2)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/0d938b2da83a80b51bec8fbe0f1099a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P5woANCmIosAQhYBbOBhcA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b985" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">15.类别_编码器</h2><p id="ebd6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/scikit-learn-contrib/category_encoders" rel="noopener ugc nofollow" target="_blank"> category_encoders </a>是一个python包，用于类别数据编码(转换成数值数据)。这个包是各种编码方法的集合，我们可以根据需要将这些方法应用于各种分类数据。</p><p id="5c9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了试用这个包，我们需要安装这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aef1" class="mc md it nb b gy nf ng l nh ni">pip install category_encoders</span></pre><p id="ca5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用下面的例子来应用转换。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e37b" class="mc md it nb b gy nf ng l nh ni">from category_encoders import BinaryEncoder<br/>import pandas as pd</span><span id="23d5" class="mc md it nb b gy nj ng l nh ni"># use binary encoding to encode two categorical features<br/>enc = BinaryEncoder(cols=['origin']).fit(df)</span><span id="e615" class="mc md it nb b gy nj ng l nh ni"># transform the dataset<br/>numeric_dataset = enc.transform(df)<br/>numeric_dataset.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/9ce7c1ccf76b8becda44a868698fc627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9vxL7XeGUTsQQ4uw8HA5rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0327" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">16.sci kit-多重学习</h2><p id="75e5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="http://scikit.ml/index.html" rel="noopener ugc nofollow" target="_blank"> scikit-multilearn </a>是专门针对多类分类模型的机器学习模型的python包。该软件包提供了用于训练机器学习模型的API，以预测具有两个以上类目标的数据集。</p><p id="3dcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过首先安装它来开始使用这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="eb1d" class="mc md it nb b gy nf ng l nh ni">pip install scikit-multilearn</span></pre><p id="de0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用样本数据集，我们可以使用多标签KNN来训练分类器并测量性能指标。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="384a" class="mc md it nb b gy nf ng l nh ni">from skmultilearn.dataset import load_dataset<br/>from skmultilearn.adapt import MLkNN<br/>import sklearn.metrics as metrics</span><span id="9d68" class="mc md it nb b gy nj ng l nh ni">X_train, y_train, feature_names, label_names = load_dataset('emotions', 'train')<br/>X_test, y_test, _, _ = load_dataset('emotions', 'test')</span><span id="9096" class="mc md it nb b gy nj ng l nh ni">classifier = MLkNN(k=3)<br/>prediction = classifier.fit(X_train, y_train).predict(X_test)</span><span id="6bf9" class="mc md it nb b gy nj ng l nh ni">metrics.hamming_loss(y_test, prediction)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/572aa19720c26d2c583dec873596b919.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*0tnA8O5Dj5DyMnrRFmf78A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="fd2b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">17.多重集</h2><p id="107c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Multiset 是一个简单的Python包，类似于内置的set函数，但是这个包允许多次出现。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e338" class="mc md it nb b gy nf ng l nh ni">pip install multiset</span></pre><p id="c0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面的代码来使用Multiset函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1fb0" class="mc md it nb b gy nf ng l nh ni">from multiset import Multiset<br/>set1 = Multiset('aab')<br/>set1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/e8d1dd799b8203a21329d612d9fe4a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*MGjBGOGFm-IEBAQ-45vxBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fa30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以测试用于比较和数据可变性的各种函数。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="a13d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">18.爵士音乐</h2><p id="ab96" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/sangarshanan/jazzit" rel="noopener ugc nofollow" target="_blank"> Jazzit </a>是一个可爱而有趣的python包，可以在代码出错或等待代码运行时播放音乐。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="199d" class="mc md it nb b gy nf ng l nh ni">pip install jazzit</span></pre><p id="4c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用下面的代码在出错的情况下尝试样本音乐。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1a0f" class="mc md it nb b gy nf ng l nh ni">from jazzit import error_track</span><span id="ba0c" class="mc md it nb b gy nj ng l nh ni"><a class="ae ky" href="http://twitter.com/error_track" rel="noopener ugc nofollow" target="_blank">@error_track</a>("curb_your_enthusiasm.mp3", wait=5)<br/>def run():<br/>    for num in reversed(range(10)):<br/>        print(10/num)</span></pre><p id="837e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出错时会播放音乐，所以不要惊讶。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6f86" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">19.手摇计算器</h2><p id="916c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/connorferster/handcalcs" rel="noopener ugc nofollow" target="_blank"> handcalcs </a>是一个python包，用来简化笔记本渲染的数学latex过程。它将任何数学函数转化为方程形式。</p><p id="f300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装这个包，我们可以使用下面的代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="32e2" class="mc md it nb b gy nf ng l nh ni">pip install handcalcs</span></pre><p id="e8b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要导入必要的包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7cf7" class="mc md it nb b gy nf ng l nh ni">import handcalcs.render<br/>from math import sqrt</span></pre><p id="1ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将尝试使用下面的代码来测试handcalcs包。使用<code class="fe nl nm nn nb b">%%render</code> magic命令渲染Latex计算。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4f13" class="mc md it nb b gy nf ng l nh ni">%%render</span><span id="1179" class="mc md it nb b gy nj ng l nh ni">a = 4<br/>b = 6<br/>c = sqrt(3*a + b/7)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/a96df7c2d08fdb2259ebd124db740a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*xrG2fyPRNdbi8h7a580ZnA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="eca2" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">20.整洁文本</h2><p id="35fc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">NeatText是一个简单的python包，它简化了文本清理和文本数据的预处理。它对任何NLP项目和文本机器学习项目数据都很有用。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3fa6" class="mc md it nb b gy nf ng l nh ni">pip install neattext</span></pre><p id="499c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用下面的代码，我们可以试用这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="44ba" class="mc md it nb b gy nf ng l nh ni">import neattext as nt <br/>mytext = "This is the word sample but ,our WEBSITE is <a class="ae ky" href="https://exaempleeele.com" rel="noopener ugc nofollow" target="_blank">https://exaempleeele.com</a> 😊✨."<br/>docx = nt.TextFrame(text=mytext)</span></pre><p id="6a20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn nb b">TextFrame</code>用于启动NeatText类，我们可以使用各种函数来描述数据和清理数据。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f09d" class="mc md it nb b gy nf ng l nh ni">docx.describe()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3e1a8b36c0ef5cdadaf02ad29e4d7405.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*2QbKFiPg_HDv_blklKIA3w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用describe函数，我们可以理解我们需要知道的每个文本统计。</p><p id="5eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步清理数据，我们可以使用下面的代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2291" class="mc md it nb b gy nf ng l nh ni">docx.normalize()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/dc384ccb88ea36fa469b32223974e2c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OQ-XwuzdUQmwvjQvMBzWPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清理数据还是比较简单的，但是有很多功能改进了预处理。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6689" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">21.小型爵士乐队</h2><p id="5adb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/yzhao062/combo" rel="noopener ugc nofollow" target="_blank"> Combo </a>是一个用于机器学习模型和分数组合的python包。该软件包提供了一个工具箱，允许将各种机器学习模型训练到一个模型中。它被视为集成学习模型中的一个子任务。</p><p id="1678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要试用这个包，让我们先安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f817" class="mc md it nb b gy nf ng l nh ni">pip install combo</span></pre><p id="0113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以尝试使用从scikit-learn获得的乳腺癌数据集和从scikit-learn获得的各种分类模型来创建机器学习组合。</p><p id="80cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们导入所有重要的包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="65a8" class="mc md it nb b gy nf ng l nh ni">from sklearn.tree import DecisionTreeClassifier<br/>from sklearn.linear_model import LogisticRegression<br/>from sklearn.ensemble import GradientBoostingClassifier<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.neighbors import KNeighborsClassifier</span><span id="3eb6" class="mc md it nb b gy nj ng l nh ni">from sklearn.model_selection import train_test_split<br/>from sklearn.datasets import load_breast_cancer</span><span id="a853" class="mc md it nb b gy nj ng l nh ni">from combo.models.classifier_stacking import Stacking<br/>from combo.utils.data import evaluate_print</span></pre><p id="9ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看用于预测目标的单个分类器。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c7ce" class="mc md it nb b gy nf ng l nh ni"># Define data file and read X and y<br/>random_state = 42<br/>X, y = load_breast_cancer(return_X_y=True)</span><span id="cc00" class="mc md it nb b gy nj ng l nh ni">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4,<br/>                                                        random_state=random_state)</span><span id="5822" class="mc md it nb b gy nj ng l nh ni"># initialize a group of clfs<br/>classifiers = [DecisionTreeClassifier(random_state=random_state),<br/>                   LogisticRegression(random_state=random_state),<br/>                   KNeighborsClassifier(),<br/>                   RandomForestClassifier(random_state=random_state),<br/>                   GradientBoostingClassifier(random_state=random_state)]<br/>clf_names = ['DT', 'LR', 'KNN', 'RF', 'GBDT']</span><span id="5da9" class="mc md it nb b gy nj ng l nh ni"># evaluate individual classifiers<br/>for i, clf in enumerate(classifiers):<br/>    clf.fit(X_train, y_train)<br/>    y_test_predict = clf.predict(X_test)<br/>    evaluate_print(clf_names[i] + '   |   ', y_test, y_test_predict)<br/>    print()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/806e36ccd313ca72f2e73f4cde1da04f.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*qOICLZ5Da2PHdlhi0BSMBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1c95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们看看使用组合包的堆叠模型。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="af15" class="mc md it nb b gy nf ng l nh ni"># build a Stacking model and evaluate<br/>clf = Stacking(classifiers, n_folds=4, shuffle_data=False,<br/>                   keep_original=True, use_proba=False,<br/>                   random_state=random_state)</span><span id="e7a5" class="mc md it nb b gy nj ng l nh ni">clf.fit(X_train, y_train)<br/>y_test_predict = clf.predict(X_test)</span><span id="222c" class="mc md it nb b gy nj ng l nh ni">evaluate_print('Stacking | ', y_test, y_test_predict)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/814ad180d21cd2dcf0057098db0d881c.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*lcKMAya_SXEp1-DA350dFA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="17ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有所改善，但肯定还有进行另一项实验的空间。您可以使用该软件包尝试任何您认为必要的组合。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6557" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">22.皮阿兹特罗</h2><p id="88f8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你需要星座数据还是只是好奇你今天的运气？然后你可以用<a class="ae ky" href="https://github.com/sameerkumar18/pyaztro" rel="noopener ugc nofollow" target="_blank"> PyAztro </a>来实现！该软件包涵盖了独特的信息，如幸运数字，幸运标志，心情，等等。让我们试着通过安装来使用这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1420" class="mc md it nb b gy nf ng l nh ni">pip install pyaztro</span></pre><p id="67d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以用下面的代码尝试访问今天的星座。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0e36" class="mc md it nb b gy nf ng l nh ni">import pyaztro<br/>pyaztro.Aztro(sign='gemini').description</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/9da80caad6cc8b874cebd9d54a8934da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiUo1cItdUPgXqyZZkuIkw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9991" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">23.骗子</h2><p id="df2c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/joke2k/faker" rel="noopener ugc nofollow" target="_blank"> Faker </a>是一个Python包，用来简化生成合成数据。许多开发人员使用这个包来创建另一个合成数据生成器包。要使用这个包，让我们安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="0fe8" class="mc md it nb b gy nf ng l nh ni">pip install Faker</span></pre><p id="bf1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用Faker包生成合成数据，我们需要初始化<code class="fe nl nm nn nb b">Faker</code>类。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fcf7" class="mc md it nb b gy nf ng l nh ni">from faker import Faker<br/>fake = Faker()</span></pre><p id="077e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们将使用初始化的类创建一个合成数据名。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3eb1" class="mc md it nb b gy nf ng l nh ni">fake.name()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/e272f0fa1f49e7a445a6b7b307d9114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*cDqg1BPKD3D2kiU8g3lSBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="29dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们运行Faker类中的属性<code class="fe nl nm nn nb b">.name</code>时，Faker会随机生成合成数据。您仍然可以尝试使用许多属性来生成数据。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="57ed" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">24.费尔勒恩</h2><p id="2413" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://fairlearn.org/" rel="noopener ugc nofollow" target="_blank"> Fairlearn </a>是一个python包，用于评估和减轻机器学习模型中的不公平性。这个包提供了许多必要的API来查看偏差，这样我们就可以避免它。要试用这个包，让我们先开始安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="22b1" class="mc md it nb b gy nf ng l nh ni">pip install fairlearn</span></pre><p id="3bbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用Fairlearn的数据集来查看模型中有多少偏差。出于教学目的，我们将简化模型预测。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ea3b" class="mc md it nb b gy nf ng l nh ni">from fairlearn.metrics import MetricFrame, selection_rate<br/>from fairlearn.datasets import fetch_adult</span><span id="933a" class="mc md it nb b gy nj ng l nh ni">data = fetch_adult(as_frame=True)<br/>X = data.data<br/>y_true = (data.target == '&gt;50K') * 1<br/>sex = X['sex']</span><span id="d255" class="mc md it nb b gy nj ng l nh ni">selection_rates = MetricFrame(metrics=selection_rate,<br/>                              y_true=y_true,<br/>                              y_pred=y_true,<br/>                              sensitive_features=sex)</span><span id="4019" class="mc md it nb b gy nj ng l nh ni">fig = selection_rates.by_group.plot.bar(<br/>    legend=False, rot=0,<br/>    title='Fraction earning over $50,000')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/cb687b044c5d4e02df5453530965c5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*hHaQyZ1k2DbtUo5E2tM4DQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="607e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Fairlearn API有一个<code class="fe nl nm nn nb b">selection_rate</code>函数，我们可以用它来检测群体模型预测之间的分数差异，这样我们就可以看到结果的偏差。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f1cd" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">25.tiobeindexpy</h2><p id="f678" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">tiobeindexpy是一个简单的python包，用于获取TIOBE索引数据。TIOBE index是一个编程排名数据，遵循它可能很重要，因为我们不想错过编程世界中的下一件事。</p><p id="e8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用tiobeindexpy，我们需要先安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="96dd" class="mc md it nb b gy nf ng l nh ni">pip install tiobeindexpy</span></pre><p id="f849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以通过下面的代码获得当月排名前20的编程语言。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cba0" class="mc md it nb b gy nf ng l nh ni">from tiobeindexpy import tiobeindexpy as tb<br/>df = tb.top_20()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/3dd5a4e3fd7aa0f4ccf6f70eda754b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAg5-VYDQXgIHcFgQbMFiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9d91" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">26.pytrends</h2><p id="2c5a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">pytrends 是一个python包，使用他们的API获取Google上的趋势关键词。当我们想要跟上当前的网络趋势或与我们的关键词相关的趋势时，这个包是有用的。要使用这个包，我们需要先安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b24b" class="mc md it nb b gy nf ng l nh ni">pip install pytrends</span></pre><p id="3440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我想知道与关键字“礼物”相关的当前趋势，那么我将使用下面的代码来了解当前趋势。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="26c4" class="mc md it nb b gy nf ng l nh ni">from pytrends.request import TrendReq<br/>import pandas as pd<br/>pytrend = TrendReq()</span><span id="eaa6" class="mc md it nb b gy nj ng l nh ni">keywords = pytrend.suggestions(keyword='Present Gift')<br/>df = pd.DataFrame(keywords)<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/f6827a46f2febfb3ecb8876a523a2742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*xpa1L1R5_21fQoNQbw_8QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ecae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该包将返回与关键字相关的前5个趋势。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="24f4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">27.视力</h2><p id="53b0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/dylan-profiler/visions" rel="noopener ugc nofollow" target="_blank"> visions </a>是一个用于语义数据分析的python包。该包可以检测数据帧类型，并推断该列的数据应该是什么。它旨在自动化数据推断并降低工作复杂性。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5546" class="mc md it nb b gy nf ng l nh ni">pip install visions</span></pre><p id="7531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用下面的代码通过visions来检测dataframe中的列数据类型。我会使用来自seaborn的泰坦尼克号数据集。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3488" class="mc md it nb b gy nf ng l nh ni">import seaborn as sns<br/>from visions.functional import detect_type, infer_type<br/>from visions.typesets import CompleteSet<br/>df = sns.load_dataset('titanic')<br/>typeset = CompleteSet()</span><span id="dfb2" class="mc md it nb b gy nj ng l nh ni"># Inference works well even if we monkey with the data, say by converting everything to strings<br/>print(detect_type(df, typeset))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/12c7186511bfdb1b09649c9c5412a199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPujc6am7vW1Qq2xzjC2QA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="cad1" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">28.日程安排</h2><p id="19c0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/dbader/schedule" rel="noopener ugc nofollow" target="_blank"> Schedule </a>是一个python包，为任何代码创建作业调度功能。它的设计是为了方便用户在你可以设置的重复时间里安排他们想要的任何事情。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aa29" class="mc md it nb b gy nf ng l nh ni">pip install schedule</span></pre><p id="04a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我想打印出我每10秒钟工作一次。然后我会用下面的代码来做这件事。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cc81" class="mc md it nb b gy nf ng l nh ni">import schedule<br/>import time</span><span id="158e" class="mc md it nb b gy nj ng l nh ni">def job():<br/>    print("I'm working...")</span><span id="9d18" class="mc md it nb b gy nj ng l nh ni">schedule.every(10).seconds.do(job)</span><span id="6b15" class="mc md it nb b gy nj ng l nh ni">while True:<br/>    schedule.run_pending()<br/>    time.sleep(1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/98b5d670f3f74732946b82e049318475.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*ekZ3Zu25yvhVLu0aTSv_Tw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="14dd" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">29.自动更正</h2><p id="3bc1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/filyp/autocorrect" rel="noopener ugc nofollow" target="_blank">自动更正</a>是一个python包，用于许多语言中的文本拼写更正。这种用法很简单，但对数据清理过程非常有用。让我们从安装包开始。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c054" class="mc md it nb b gy nf ng l nh ni">pip install autocorrect</span></pre><p id="61ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用类似于下面代码的自动更正包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ed8d" class="mc md it nb b gy nf ng l nh ni">from autocorrect import Speller<br/>spell = Speller()<br/>spell("I'm not sleaspy and tehre is no place I'm giong to.")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/32fba3e0f7ddfc0e8caf882f6555287f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*mKnhGAmkgEWa6s3vM97qeg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="bfce" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">30.funcy</h2><p id="6a3a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">funcy 是一个python包，其中充满了日常数据分析使用的奇特实用函数。软件包中的函数太多了，我无法一一展示，还有一个备忘单<a class="ae ky" href="https://funcy.readthedocs.io/en/stable/cheatsheet.html" rel="noopener ugc nofollow" target="_blank">可以让它变得更简单。让我们从安装包开始。</a></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="5636" class="mc md it nb b gy nf ng l nh ni">pip install funcy</span></pre><p id="2d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将只展示一个从iterable变量中选择偶数的示例函数，如下面的代码所示。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ff57" class="mc md it nb b gy nf ng l nh ni">from funcy import select, even<br/>select(even, {i for i in range (20)})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/cae34793348164bd7b3167c07cfa36db.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*oDG_pJjUtZUKHpmhpuacBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e384" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">31.冰淇淋</h2><p id="da04" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/gruns/icecream" rel="noopener ugc nofollow" target="_blank"> IceCream </a>是一个python包，用于打印目的，但使调试过程更容易。基本上，这个包在打印/记录过程中提供了稍微详细一点的输出。</p><p id="5e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用这个包，我们需要使用下面的代码来安装它。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8f32" class="mc md it nb b gy nf ng l nh ni">pip install icecream</span></pre><p id="a1e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以用下面的代码来使用这个包。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="cbef" class="mc md it nb b gy nf ng l nh ni">from icecream import ic</span><span id="e1f9" class="mc md it nb b gy nj ng l nh ni">def some_function(i):<br/>    i = 4 + (1 * 2)/ 10 <br/>    return i + 35</span><span id="3aef" class="mc md it nb b gy nj ng l nh ni">ic(some_function(121))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/1becedd18a779b2e18682b88d0bc735b.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*McQXF-F-qX-6VFgsl-MXkA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="83fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数也可以用作函数检查器。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2615" class="mc md it nb b gy nf ng l nh ni">def foo():<br/>    ic()<br/>    <br/>    if some_function(12):<br/>        ic()<br/>    else:<br/>        ic()</span><span id="a433" class="mc md it nb b gy nj ng l nh ni">foo()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b90d6cbdf153d5a733a358d67a077e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*E8QnF760ykjjFa5uGq6HBg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="97c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们所做的任何数据分析来说，详细程度都是非常好的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0854" class="po md it bd me pp pq pr mh ps pt pu mk jz pv ka mn kc pw kd mq kf px kg mt py bi translated">结论</h1><p id="bb66" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，我们研究了31个独特的python包，它们在数据工作流中很有用。大多数软件包易于使用且简单明了，但有些可能需要进一步阅读。</p><p id="81fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望有帮助！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="pz qa qb"><p id="ed44" class="kz la qc lb b lc ld ju le lf lg jx lh qd lj lk ll qe ln lo lp qf lr ls lt lu im bi translated"><em class="it">访问我的</em> <a class="ae ky" href="https://bio.link/cornelli" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="it">社交媒体</em></strong></a><strong class="lb iu"><em class="it"/></strong><em class="it">进行更深入的交谈或有任何问题。</em></p></blockquote><blockquote class="qg"><p id="d169" class="qh qi it bd qj qk ql qm qn qo qp lu dk translated"><em class="qq">如果您不是作为中等会员订阅，请考虑通过</em> <a class="ae ky" href="https://cornelliusyudhawijaya.medium.com/membership" rel="noopener"> <em class="qq">我的推荐</em> </a> <em class="qq">订阅。</em></p></blockquote></div></div>    
</body>
</html>