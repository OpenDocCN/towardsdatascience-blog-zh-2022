<html>
<head>
<title>Temporal Fusion Transformer: Time Series Forecasting with Deep Learning — Complete Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间融合转换器:深度学习时间序列预测—完整教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/temporal-fusion-transformer-time-series-forecasting-with-deep-learning-complete-tutorial-d32c1e51cd91#2022-11-05">https://towardsdatascience.com/temporal-fusion-transformer-time-series-forecasting-with-deep-learning-complete-tutorial-d32c1e51cd91#2022-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="30d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建准确且可解释的预测</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d218c360900f4ac6ab37c6b0dcd6854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcPsaorW0Pn5CWuZs0WHdw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用DALLE [1]创建</p></figure><p id="4c46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据[2]，<strong class="la iu"> </strong> <a class="ae lu" rel="noopener" target="_blank" href="/temporal-fusion-transformer-googles-model-for-interpretable-time-series-forecasting-5aa17beb621"> <strong class="la iu"> <em class="lv">时态融合变换器</em> </strong> </a> <strong class="la iu">在时间序列预测方面胜过所有著名的深度学习模型。</strong></p><p id="82ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">包括用于表格时序数据的特色<em class="lv">梯度提升树</em>模型。</p><p id="ff51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是<strong class="la iu">时间融合变压器(TFT)【3】</strong>是什么，为什么这么有意思？</p><p id="6f4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们简要解释了<em class="lv">时间融合变压器</em>的新颖之处，并构建了一个基于<strong class="la iu">能源需求预测</strong>的端到端项目。具体来说，我们将涵盖:</p><ul class=""><li id="05a8" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">如何准备TFT格式的数据？</li><li id="ba2c" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">如何建立、训练和评估TFT模型？</li><li id="6959" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">如何得到关于验证数据的预测和样本外预测？</li><li id="5884" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">如何使用内置模型的<em class="lv">可解释注意力</em>机制计算<strong class="la iu">特征重要性</strong>、<strong class="la iu">季节性模式、</strong>和<strong class="la iu">极端事件鲁棒性</strong>。</li></ul><p id="7cd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧！</p><blockquote class="mk ml mm"><p id="c629" class="ky kz lv la b lb lc ju ld le lf jx lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">要深入分析时态融合转换器架构，请查看我以前的文章。</p></blockquote><h1 id="91c2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是时间融合转换器</h1><blockquote class="ni"><p id="5010" class="nj nk it bd nl nm nn no np nq nr lt dk translated"><strong class="ak"> T </strong>临时<strong class="ak"> F </strong>融合<strong class="ak">T</strong>Transformer(<strong class="ak">TFT</strong>)是一个基于Transformer的模型，它利用自我注意力来捕捉多个时间序列的复杂时间动态。</p></blockquote><p id="4388" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">TFT支持:</p><ul class=""><li id="c8d3" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated"><strong class="la iu">多个时间序列:</strong>我们可以在成千上万个单变量或多变量时间序列上训练一个TFT模型。</li><li id="dd76" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">多时段预测:</strong>模型输出一个或多个目标变量的多步预测，包括预测区间。</li><li id="f624" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">异构特性:</strong> TFT支持多种类型的特性，包括时变和静态外生变量。</li><li id="87a1" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">可解释的预测:</strong>预测可以用变量重要性和季节性来解释。</li></ul><p id="5706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中一个特征是<em class="lv">时间融合转换器</em>所独有的。我们将在下一节讨论这个问题。</p><h1 id="f54f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">扩展的时间序列数据格式</h1><p id="3c7d" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在值得注意的DL时序模型中(例如<em class="lv">DeepAR</em>【4】)，TFT脱颖而出，因为它支持各种类型的功能。这些是:</p><ul class=""><li id="ea46" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated"><strong class="la iu">时变</strong>已知<em class="lv">已知</em></li><li id="1883" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">时变</strong> <em class="lv">未知</em></li><li id="154d" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">时不变</strong>实数<em class="lv">实数</em></li><li id="33d8" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">时不变的</strong> <em class="lv">分类的</em></li></ul><p id="42a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，假设我们有一个<strong class="la iu">销售预测案例</strong>:</p><p id="3891" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们要预测三种产品的销售。<code class="fe oc od oe of b">num sales</code>是目标变量。<code class="fe oc od oe of b">CPI index</code>或<code class="fe oc od oe of b">number of visitors</code>是<em class="lv">时变未知</em>特征，因为它们仅在预测时间之前是已知的。然而，<code class="fe oc od oe of b">holidays</code>和<code class="fe oc od oe of b">special days</code>是<em class="lv">时变的已知</em>事件。</p><p id="5d97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oc od oe of b">product id</code>是<em class="lv">一个时不变(静态)分类</em>特征。其他数值的和不依赖于时间的特征如<code class="fe oc od oe of b">yearly_revenue</code>可以归类为<em class="lv">时不变实数</em>。</p><p id="0eaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在进入我们的项目之前，我们将首先展示一个关于如何将您的数据转换成<strong class="la iu">扩展时间序列格式</strong>的迷你教程。</p><blockquote class="mk ml mm"><p id="a5e2" class="ky kz lv la b lb lc ju ld le lf jx lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated"><strong class="la iu">注:</strong>本文所有图像及人物均由作者创作。</p></blockquote><h1 id="285d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">时间序列数据集函数</h1><p id="8af3" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">对于本教程，我们使用来自<a class="ae lu" href="https://github.com/jdb78/pytorch-forecasting" rel="noopener ugc nofollow" target="_blank"> PyTorch预测</a>库和PyTorch Lightning的<code class="fe oc od oe of b"><a class="ae lu" href="https://arxiv.org/pdf/1912.09363.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">TemporalFusionTransformer</strong></a></code> <strong class="la iu"> </strong>模型:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="a225" class="ok mr it of b gy ol om l on oo">pip install torch pytorch-lightning pytorch_forecasting</span></pre><p id="0ac3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个过程包括三件事:</p><ol class=""><li id="2607" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt op mc md me bi translated">用我们的时间序列数据创建一个熊猫数据框架。</li><li id="909a" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt op mc md me bi translated">将我们的数据帧包装到一个<em class="lv"> TimeSeriesDataset </em>实例中。</li><li id="6072" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt op mc md me bi translated">将我们的<em class="lv"> TimeSeriesDataset </em>实例传递给<code class="fe oc od oe of b"><a class="ae lu" href="https://arxiv.org/pdf/1912.09363.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">TemporalFusionTransformer</strong></a><strong class="la iu">.</strong></code></li></ol><p id="ed40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">时间序列数据集</em>非常有用，因为它帮助我们指定特征是随时间变化的还是静态的。另外，这是<code class="fe oc od oe of b"><a class="ae lu" href="https://arxiv.org/pdf/1912.09363.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="la iu">TemporalFusionTransformer</strong></a></code> <strong class="la iu"> </strong>唯一接受的格式。</p><p id="8b5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个最小的训练数据集来展示<em class="lv">时间序列数据集</em>是如何工作的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="d978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该以下面的方式格式化我们的数据:每个彩色的盒子代表一个不同的时间序列，用它的<code class="fe oc od oe of b">group</code>值来表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/f94f78d3d424b327414066ef355c972e.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*1p8dWHWOAz3iFJdkLA395g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图1: </strong>样本_数据熊猫数据框</p></figure><p id="8089" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的数据框架中最重要的一列是<code class="fe oc od oe of b">time_idx</code>——它决定了样本的顺序。如果没有遗漏观测值，每个时间序列的值应增加<em class="lv"> +1 </em> <strong class="la iu">。</strong></p><p id="bc84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将数据帧封装到一个<em class="lv"> TimeSeriesDataset </em>实例中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="cb94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有的参数都是不言自明的:<code class="fe oc od oe of b">max_encoder_length</code>定义了回望期，<code class="fe oc od oe of b">max_prediction_length</code>指定了将预测多少数据点。在我们的例子中，我们回顾过去的3个时间步来输出2个预测。</p><p id="eed8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TimeSeriesDataset 实例现在充当数据加载器。让我们打印一批，并检查我们的数据将如何传递到TFT:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b1e4f46fa3ca689e08439ddbc765bd36.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*pEsv_taJtPd9vwNWYB21jA.png"/></div></figure><p id="0416" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该批次包含来自第一时间序列(<code class="fe oc od oe of b">group 0</code>)的训练值<code class="fe oc od oe of b">[0,1]</code>和测试值<code class="fe oc od oe of b">[2,3,4]</code>。如果您重新运行这段代码，您将得到不同的值，因为默认情况下数据是被打乱的。</p><h1 id="034d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">需求能源预测教程</h1><p id="5418" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我们的项目将使用来自UCI的<strong class="la iu">electricityloaddiagrams 2011 2014</strong>【5】<strong class="la iu"/>数据集。这个例子的笔记本可以从<a class="ae lu" href="https://drive.google.com/file/d/1sVXcUQi0FXVZxgmiHX0oc5YZfrjwZzmA/view?usp=share_link" rel="noopener ugc nofollow" target="_blank">这里</a>下载:</p><p id="c1d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该数据集包含370个客户端/消费者15分钟一次的用电量(KWs)。数据跨度为4年(2011年至2014年)。</p><p id="d511" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些消费者是在2011年之后产生的，因此他们最初的用电量为零。</p><p id="4a7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们根据<a class="ae lu" href="https://github.com/google-research/google-research/tree/master/tft" rel="noopener ugc nofollow" target="_blank">【3】</a>进行数据预处理:</p><ul class=""><li id="8404" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">按小时汇总我们的目标变量<code class="fe oc od oe of b">power_usage</code>。</li><li id="953d" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">找出幂非零的每个时间序列的最早日期。</li><li id="c3eb" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">创建新特征:<code class="fe oc od oe of b">month</code>、<code class="fe oc od oe of b">day</code>、<code class="fe oc od oe of b">hour</code>和<code class="fe oc od oe of b">day_of_week</code>。</li><li id="739b" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">选择在<code class="fe oc od oe of b">2014–01–01</code>和<code class="fe oc od oe of b">2014–09–07</code>之间的所有日期。</li></ul><p id="f326" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始:</p><h2 id="65ee" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">下载数据</h2><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="c959" class="ok mr it of b gy ol om l on oo">wget <a class="ae lu" href="https://archive.ics.uci.edu/ml/machine-learning-databases/00321/LD2011_2014.txt.zip!unzip" rel="noopener ugc nofollow" target="_blank">https://archive.ics.uci.edu/ml/machine-learning-databases/00321/LD2011_2014.txt.zip<br/>!unzip</a> LD2011_2014.txt.zip</span></pre><h2 id="ff1f" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">数据预处理</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/4e2461e143bc614adbec2968159761bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7nYjf_c0FNYoanBTbGWlg.png"/></div></div></figure><p id="316f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每一列代表一个消费者。大多数初始<code class="fe oc od oe of b">power_usage</code>值为0。</p><p id="588e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们汇总每小时的数据。由于模型的大小和复杂性，我们只在5个消费者上训练我们的模型(对于那些非零值的消费者)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="47a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们为<em class="lv">时间序列数据集</em>格式准备数据集。请注意，每一列代表不同的时间序列。因此，我们“融化”我们的数据框架，这样所有的时间序列都是垂直堆叠而不是水平堆叠。在这个过程中，我们创造了我们的新功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="aadf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终预处理的数据帧被称为<code class="fe oc od oe of b">time_df</code>。让我们打印它的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/420111d52a7174b30aaac5bccd0c64c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63E9tji-f1J_a8rMBgvmYQ.png"/></div></div></figure><p id="a863" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oc od oe of b">time_df</code>现在处于<em class="lv">时间序列数据集</em>的正确格式。正如您现在已经猜到的，因为粒度是每小时一次，所以<code class="fe oc od oe of b">hours_from_start</code>变量将是<strong class="la iu">时间索引。</strong></p><h2 id="ea7e" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">探索性数据分析</h2><p id="5386" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">消费者/时间序列的选择不是随机的。每个时间序列的<code class="fe oc od oe of b">power usage</code>具有不同的性质，例如平均值:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="b4ca" class="ok mr it of b gy ol om l on oo">time_df[[‘consumer_id’,’power_usage’]].groupby(‘consumer_id’).mean()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/e5db53dd4c5b781dcdbf7529d04cf4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/format:webp/1*TWGyV3M8hrXlSbKPF_RCgA.png"/></div></figure><p id="e7a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们画出每个时间序列的第一个月:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/36218af39d5c6e8d9c11895bfb283277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iCiMLyWSlgESvycCtKpwvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图2: </strong>所有5个时序/消费者的第一个月。</p></figure><p id="be8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">没有明显的趋势，但每个时间序列的季节性和幅度略有不同。我们可以进一步试验和检查平稳性、信号分解等等，但是在我们的例子中，我们只关注模型构建方面。</p><p id="9f5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，请注意其他时间序列预测方法，如<strong class="la iu"> ARIMA </strong>必须满足一些要求(例如，时间序列必须首先变得平稳。)有了TFT，我们可以让我们的数据保持原样。</p><h2 id="96b5" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">创建数据加载器</h2><p id="8dca" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在这一步，我们将我们的<code class="fe oc od oe of b">time_df</code>传递给<em class="lv"> TimeSeriesDataSet </em>格式，这非常有用，因为:</p><ul class=""><li id="0326" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">它让我们不用编写自己的数据加载器。</li><li id="4640" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们可以指定TFT如何处理数据集的特征。</li><li id="c12e" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们可以轻松地标准化我们的数据集。在我们的例子中，标准化是强制性的，因为所有时间序列的大小都不同。因此，我们使用<strong class="la iu"> GroupNormalizer </strong>来分别归一化每个时间序列。</li></ul><p id="91c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的模型使用一周(7*24)的回顾窗口来预测未来24小时的用电量。</p><p id="3c04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意<code class="fe oc od oe of b">hours_from_start</code>既是时间索引，也是时变特征。<code class="fe oc od oe of b">power_usage</code>是我们的目标变量。为了便于演示，我们的验证集是最后一天:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="bda5" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">基线模型</h2><p id="a960" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">接下来，几乎所有人都忘记的一步:基线模型。特别是在时间序列预测中，你会惊讶地发现一个简单的预测器往往比一个更好的模型更好！</p><p id="5436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个简单的基线，我们预测前一天的用电量曲线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="93ad" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">训练时间融合变换器模型</h2><p id="47be" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我们可以使用PyTorch Lightning的熟悉的<em class="lv">训练器</em>界面来训练我们的TFT模型。</p><p id="154e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意以下事项:</p><ul class=""><li id="3c41" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">我们使用<strong class="la iu">提前停止</strong>回调来监控验证损失。</li><li id="2e81" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们使用<strong class="la iu"> Tensorboard </strong>来记录我们的培训和验证指标。</li><li id="317f" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们的模型使用<em class="lv">分位数损失</em>——一种特殊类型的损失，帮助我们输出预测区间。关于分位数损失函数的更多信息，请看这篇文章。</li><li id="31a2" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们使用4个<em class="lv">注意力头</em>，就像原稿一样。</li></ul><p id="c07e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在准备构建和训练我们的模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="8b30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！6个周期后，提前停止开始并停止训练。</p><h2 id="3d36" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">加载并保存最佳模型</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="5203" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要忘记保存您的模型。虽然我们可以对其进行酸洗，但最安全的选择是直接保存最佳纪元:</p><pre class="kj kk kl km gt og of oh oi aw oj bi"><span id="128b" class="ok mr it of b gy ol om l on oo">!zip  -r model.zip lightning_logs/lightning_logs/version_1/*</span></pre><p id="5397" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要再次加载模型，解压<em class="lv"> model.zip </em>并执行以下命令——记住最佳模型路径:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="0f7e" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated"><strong class="ak">检查张量板</strong></h2><p id="e346" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">仔细看看Tensorboard的训练和验证曲线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><h2 id="0ede" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">模型评估</h2><p id="1915" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">获得验证集的预测，并计算平均<strong class="la iu"> P50 </strong>(分位数中位数)<strong class="la iu">损失</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="9a8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">后两个时间序列的损失稍高，因为它们的相对量级也很高。</p><h2 id="d357" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">根据验证数据绘制预测图</h2><p id="8732" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">如果我们在<em class="lv"> predict() </em>方法上传递<code class="fe oc od oe of b">mode=raw</code>，我们将获得更多信息，包括对所有七个分位数的预测。我们还可以访问注意力值(稍后会详细介绍)。</p><p id="d93b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仔细看看<code class="fe oc od oe of b">raw_predictions</code>变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="c7fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用<em class="lv"> plot_prediction() </em>来创建我们的情节。当然，您可以制作自己的定制图——<em class="lv">plot _ prediction()</em>具有添加关注值的额外好处。</p><blockquote class="mk ml mm"><p id="cc5d" class="ky kz lv la b lb lc ju ld le lf jx lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated"><strong class="la iu">注:</strong>我们的模型一次性预测接下来的24个数据点<strong class="la iu"/>。这不是滚动预测场景，在滚动预测场景中，模型每次预测一个<strong class="la iu">单个</strong>值，并将所有预测“缝合”在一起。</p></blockquote><p id="2706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们为每个消费者创建一个图(总共5个)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/19bf4af8e18d311724928562e4935940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7Us1RXzGbglVDBscTLnMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图3:</strong>MT _ 002验证数据预测</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/0045dd27525fa66ae343390f0c69e11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QC7LCr4p4ZddM5ccg-rU-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图4:</strong>MT _ 004验证数据预测</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/76b80e28e9c7ea5bf954dfd8ab1dfdd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LyovTN-CWpa5s69801UOHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图5:</strong>MT _ 005验证数据预测</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/71fcecd3f0426cbb1dd3ee57e3235bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdlYEJH2cDl0pFfcEshIVQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图6:</strong>MT _ 006验证数据预测</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/43b3470dfc4c1a10147889b60af78fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXoJIx4ZFuqq52j7paqFsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图7:</strong>MT _ 008验证数据预测</p></figure><p id="aef1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果相当可观。</p><p id="6cb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的<em class="lv">时间融合转换器</em>模型能够捕捉所有5个时间序列在季节性和幅度方面的行为！</p><p id="a3b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，请注意:</p><ul class=""><li id="a7b6" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">我们没有执行任何超参数调整。</li><li id="bb50" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们没有实现任何花哨的功能工程技术。</li></ul><p id="8cc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在接下来的部分中，我们将展示如何通过超参数优化来改进我们的模型。</p><h2 id="5aac" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">绘制特定时间序列的预测</h2><p id="fba6" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">之前，我们使用<code class="fe oc od oe of b">idx</code>参数在验证数据上绘制预测，该参数在数据集中的所有时间序列上迭代。我们可以更具体地输出对特定时间序列的预测:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/de3e4599fb4619b754b53db387e2c773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4cG7fXkBFXvZ4-duqQ1ug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图7: </strong>训练集上MT_004 <strong class="bd ot"> </strong>的提前一天预测</p></figure><p id="e93f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<strong class="la iu">图7中，</strong>我们绘制了<strong class="la iu"> MT_004 </strong>消费者的前一天时间指数=26512。</p><p id="a6e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住，我们的时间索引列<code class="fe oc od oe of b">hours_from_start</code>从26304开始，我们可以从26388开始得到预测(因为我们设置了更早的<code class="fe oc od oe of b">min_encoder_length=max_encoder_length // 2</code>等于<code class="fe oc od oe of b">26304 + 168//2=26388</code></p><h2 id="393f" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">样本外预测</h2><p id="6696" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">让我们创建样本外预测，超越验证数据的最终数据点——也就是<code class="fe oc od oe of b">2014–09–07 23:00:00</code></p><p id="3d32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们所要做的就是创建一个新的数据帧，它包含:</p><ul class=""><li id="6c48" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated"><code class="fe oc od oe of b">N</code> = <code class="fe oc od oe of b">max_encoder_length</code>过去日期的个数，作为回看窗口TFT术语中的<strong class="la iu">编码器数据</strong>。</li><li id="e0c0" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">我们想要计算预测的大小为<code class="fe oc od oe of b">max_prediction_length</code>的未来日期，即<strong class="la iu">解码器数据。</strong></li></ul><p id="6cf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以对所有5个时间序列进行预测，或者只对一个时间序列进行预测。<strong class="la iu">图7 </strong>显示了消费者的样本外预测<strong class="la iu"> MT_002 </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/d8bd9db2a26c10aa8535a4d1ae3f18f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J2X_TZCJEEhmRBGbUI01QQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图7:</strong>MT _ 002提前一天预测</p></figure><h1 id="e0ad" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">可解释的预测</h1><p id="f7f3" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">准确的预测是一回事，但如今可解释性也很重要。</p><p id="72ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而对于深度学习模型来说就更糟糕了，深度学习模型被认为是黑盒。像<strong class="la iu"> LIME </strong>和<strong class="la iu"> SHAP </strong>这样的方法可以(在一定程度上)提供可解释性，但是对于时间序列来说并不适用。此外，它们是外部的事后方法，不依赖于特定的模型。</p><p id="a4cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lv">时间融合转换器</em>提供三种类型的可解释性:</p><ul class=""><li id="796c" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated"><strong class="la iu">季节性方面:</strong> TFT利用其新颖的<strong class="la iu">可解释的多头注意力</strong>机制来计算过去时间步骤的重要性。</li><li id="9ef8" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><strong class="la iu">特征方面:</strong> TFT利用其<strong class="la iu">变量选择网络</strong>模块来计算每个特征的重要性。</li><li id="acfa" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">极端事件稳健性:我们可以研究时间序列在罕见事件中的表现</li></ul><p id="dd7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果想深入了解<strong class="la iu">可解释性多头关注</strong>和<strong class="la iu">变量选择网络、</strong> <a class="ae lu" rel="noopener" target="_blank" href="/temporal-fusion-transformer-googles-model-for-interpretable-time-series-forecasting-5aa17beb621">的内部工作原理，可以查看我之前的文章</a>。</p><h2 id="4245" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">季节性解释能力</h2><p id="3dd8" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">TFT探索注意力权重，以了解过去时间步长的时间模式。</p><p id="1257" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前所有图中的灰线代表注意力得分。再看看那些图，你注意到什么了吗？<strong class="la iu">图8 </strong>显示了<strong class="la iu">图7 </strong>的结果，也说明了注意力得分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/934d2f6c49f397ed106ef758f02abe81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*ftiBM9pqpsSdfIX8lg9vEw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图8: </strong>显示季节性的MT_002的前一天预测</p></figure><p id="982b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意力分数揭示了当模型输出其预测时那些时间步骤的影响程度。小峰反映了每日的季节性，而接近尾声的高峰可能暗示了每周的季节性。</p><p id="cff2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们对所有时间步长和时间序列(不仅仅是我们在本教程中使用的5个时间步长和时间序列)的注意力曲线进行平均，我们将从TFT纸<strong class="la iu"> : </strong>中得到<strong class="la iu">图9 </strong>中看起来对称的形状</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/c569ca37517e6d66ae0c1005b0427134.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*UfbnJmiR7O8wW7iZnHTQHQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图9: </strong>电力数据集的时间模式(<a class="ae lu" href="https://arxiv.org/pdf/1912.09363.pdf" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure><blockquote class="mk ml mm"><p id="97d5" class="ky kz lv la b lb lc ju ld le lf jx lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated"><strong class="la iu">问题:</strong>这有什么好处？难道我们不能简单地用ACF图、时间信号分解等方法来估计季节性模式吗？？</p></blockquote><p id="e5d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">答案:</strong>真。然而，研究TFT的注意力权重有额外的好处:</p><ol class=""><li id="090d" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt op mc md me bi translated">我们可以确认我们的模型捕捉到了我们序列的明显的季节动态。</li><li id="438c" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt op mc md me bi translated">我们的模型还可以揭示隐藏的模式，因为当前输入窗口的注意力权重考虑了所有过去的输入。</li><li id="29d5" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt op mc md me bi translated">注意力权重图与自相关图不同:自相关图指的是特定的序列，而这里的注意力权重通过查看所有协变量和时间序列来关注每个时间步长的影响。</li></ol><h2 id="247c" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">功能方面的可解释性</h2><p id="6342" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">TFT的<strong class="la iu">变量选择网络</strong>组件可以很容易地估计<strong class="la iu">特征重要性:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/199b50b95a7e401a96060f1c434778b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*MDJ5X0dWP9IURUWX3T5j2A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图10: </strong>特性对验证数据的重要性</p></figure><p id="0f97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<strong class="la iu">图10 </strong>中，我们注意到以下内容:</p><ul class=""><li id="b305" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">作为过去的观察值和未来的协变量，<code class="fe oc od oe of b">hour</code>和<code class="fe oc od oe of b">day_of_week</code>都有很强的得分。原始论文中的基准也有相同的结论。</li><li id="f7d0" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated"><code class="fe oc od oe of b">power_usage</code>显然是最有影响力的观测协变量。</li><li id="492d" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">这里的<code class="fe oc od oe of b">consumer_id</code>并不重要，因为我们只使用了5个消费者。在TFT论文中，作者使用了所有370个消费者，这个变量更重要。</li></ul><blockquote class="mk ml mm"><p id="e0db" class="ky kz lv la b lb lc ju ld le lf jx lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong>如果你的分组静态变量不重要，很有可能你的数据集也可以用一个单一的分布模型来建模(像ARIMA)。</p></blockquote><h2 id="f5b7" class="ok mr it bd ms ov ow dn mw ox oy dp na lh oz pa nc ll pb pc ne lp pd pe ng pf bi translated">极端事件检测</h2><p id="c9a2" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">众所周知，时间序列在罕见事件(也称为<strong class="la iu">冲击</strong>)期间易受属性突然变化的影响。</p><p id="b798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更糟糕的是，这些事件非常难以捉摸。想象一下，如果你的目标变量因为协变量无声无息地改变了行为而在短时间内变得不稳定:</p><blockquote class="ni"><p id="8f63" class="nj nk it bd nl nm nn no np nq nr lt dk translated">这是某种随机噪声还是逃脱了我们模型的隐藏的持续模式？</p></blockquote><p id="21b5" class="pw-post-body-paragraph ky kz it la b lb ns ju ld le nt jx lg lh nu lj lk ll nv ln lo lp nw lr ls lt im bi translated">利用TFT，我们可以分析每个特性在其值范围内的鲁棒性。不幸的是，当前的数据集没有表现出波动性或罕见事件——这些更有可能在金融、销售数据等中发现。不过，我们将展示如何计算它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="2894" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些特征的值并没有全部出现在验证数据集中，所以我们只显示了<code class="fe oc od oe of b">hour</code>和<code class="fe oc od oe of b">consumer_id</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/509b1d6f6b6078bb44e911c18a1a55e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fITJzQ8BfBC01Okzn8I1wg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图11: </strong>每小时的预测值与实际值(标准化平均值)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/7dd492f8d7e3a9f743cd891ddf7becaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*TKd0RwJJqknBVXuT4KNsHA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd ot">图12:</strong>consumer _ id的预测值与实际值(归一化平均值)</p></figure><p id="5443" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这两个数字中，结果都令人鼓舞。在<strong class="la iu">图12 </strong>中，我们注意到消费者<strong class="la iu"> MT_004 </strong>与其他消费者相比表现稍差。如果我们将每个消费者的P50损失与我们之前计算的他们的平均用电量归一化，我们可以验证这一点。</p><p id="5bea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">灰色条表示每个变量的分布。我经常做的一件事是找出哪些值出现频率低。然后，我检查模型在这些方面的表现。因此，您可以很容易地检测出您的模型是否捕捉到了罕见事件的行为。</p><p id="51eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，您可以使用这种TFT功能来探测您的模型的弱点，并进行进一步的调查。</p><h1 id="1b11" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">超参数调谐</h1><p id="7d4a" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我们可以无缝地使用<em class="lv">时间融合转换器</em> <strong class="la iu"> </strong>和<strong class="la iu"> Optuna </strong>来执行超参数调谐:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oq or l"/></div></figure><p id="25ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">问题是，由于TFT是基于变压器的模型，您将需要大量的硬件资源！</p><h1 id="2d1f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结束语</h1><p id="4f8b" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated"><em class="lv">时间融合转换器</em>无疑是时间序列社区的一个里程碑。</p><p id="4308" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该模型不仅实现了SOTA结果，而且为预测的可解释性提供了一个框架。该模型在基于PyTorch预测库的<a class="ae lu" href="https://unit8co.github.io/darts/" rel="noopener ugc nofollow" target="_blank"> Darts </a> python库中也可用。</p><p id="2d1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果你对详细了解<em class="lv">时间融合转换器</em>的架构感到好奇，可以查看原始论文上的<a class="ae lu" rel="noopener" target="_blank" href="/temporal-fusion-transformer-googles-model-for-interpretable-time-series-forecasting-5aa17beb621">配套文章</a>。</p></div><div class="ab cl pr ps hx pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="im in io ip iq"><h1 id="2e06" class="mq mr it bd ms mt py mv mw mx pz mz na jz qa ka nc kc qb kd ne kf qc kg ng nh bi translated">感谢您的阅读！</h1><p id="7bcf" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我每个月写一篇有影响力的AI论文的深度分析。<br/> <strong class="la iu">保持连接！</strong></p><ul class=""><li id="1254" class="lw lx it la b lb lc le lf lh ly ll lz lp ma lt mb mc md me bi translated">订阅我的<a class="ae lu" href="https://medium.com/subscribe/@nikoskafritsas" rel="noopener">简讯</a>！</li><li id="2b34" class="lw lx it la b lb mf le mg lh mh ll mi lp mj lt mb mc md me bi translated">在Linkedin上关注我！</li></ul><h1 id="8b1d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><p id="664a" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">[1]由DALLE创建，带有文本提示“通过空间传输的蓝色霓虹正弦信号，闪亮，数字绘画，概念艺术”</p><p id="38d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2] Shereen Elsayed等人<a class="ae lu" href="https://arxiv.org/pdf/2101.02118.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="lv">我们真的需要深度学习模型进行时间序列预测吗？</em> </a></p><p id="9645" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3] Bryan Lim等人<a class="ae lu" href="https://arxiv.org/pdf/1912.09363.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="lv">用于可解释的多时间范围时间序列预测的时间融合变换器</em> </a> <em class="lv">，</em>2020年9月</p><p id="b988" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[4] D. Salinas等人，<a class="ae lu" href="https://arxiv.org/pdf/1704.04110.pdf" rel="noopener ugc nofollow" target="_blank"> DeepAR:用自回归递归网络进行概率预测</a>，国际预测杂志(2019)。</p><p id="5eda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[5]<a class="ae lu" href="https://archive.ics.uci.edu/ml/datasets/ElectricityLoadDiagrams20112014" rel="noopener ugc nofollow" target="_blank">electricityloaddiagrams 2011 2014</a>数据集由UCI，CC通过4.0。</p></div></div>    
</body>
</html>