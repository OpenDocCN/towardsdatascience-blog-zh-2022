<html>
<head>
<title>Decorator Tricks for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的装饰技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/decorator-tricks-for-data-scientists-87911eea41ca#2022-06-28">https://towardsdatascience.com/decorator-tricks-for-data-scientists-87911eea41ca#2022-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cfe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果您还没有使用Python decorators，那么您应该使用。纯句法糖。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ab4fea9429399679a98389c62574b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aCzBRB_Xe2ge0pzJYWkukw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="3a3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我记得我第一次在Python代码中看到函数顶部有一个“@”符号。我觉得有必要研究一下这个奇怪的语法。它前后都标了a，这是肯定的。函数顶部的“@”符号称为装饰器，它装饰的函数的一个函数。</p><p id="169d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以花几年时间做数据科学家，而不用装饰者。或者也许你已经使用过它们，但是还没有学会如何编写自己的代码。这个故事旨在构建在许多数据科学任务中有用的具体decorator示例，并且在这个过程中，学习如何一步一步地编写decorator。</p><p id="011d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰者的主要目的是:</p><ul class=""><li id="27e1" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">向现有函数和类添加功能</li><li id="a257" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">当做一些可能不会通过代码审查的事情时，作为代码中的一个注释</li></ul><p id="ab81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事将关注前者，向现有的函数和类添加功能。</p><p id="edc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明这一点，假设您有许多查询数据库的函数。在编写了从数据库中查询所需的所有内容的函数之后，您意识到每十次尝试中就有一次会由于一些随机的连接错误而失败。我们都知道如何使用数据库。</p><p id="e302" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您需要为所有函数添加一些重试逻辑。所述逻辑将形成为多次尝试的循环，其间可能有一些等待时间——样板代码。然而，基本的逻辑已经编码在函数中。</p><p id="d749" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以你有两个选择:</p><ul class=""><li id="831d" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">向所有函数添加样板文件；这将需要工业规模的复制粘贴，并改变每个功能的逻辑以适应重试。又乱又臭的代码。</li><li id="7f0e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">编写一个重试装饰器，并将其添加到数据库函数之上(一行代码)；否则，保持函数的逻辑不变。干净优雅的代码。</li></ul><p id="13d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我当然知道我会选择哪个选项。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="a3a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">故事结构如下:</p><ul class=""><li id="2f3b" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">装饰基础</li><li id="e4c4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">重试装饰器</li><li id="9f3b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">类注册表装饰器</li><li id="2ccd" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">周期性执行装饰器</li><li id="5c10" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最后的话</li></ul><h2 id="d8bb" class="mp mq it bd mr ms mt dn mu mv mw dp mx lh my mz na ll nb nc nd lp ne nf ng nh bi translated">装饰基础</h2><p id="0a15" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">最简单的装饰器是一个函数，它将它所装饰的函数作为参数，并返回另一个函数，该函数反过来返回被装饰的函数应该返回的任何内容。绕口令。</p><p id="7daf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过例子更容易学习:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d434" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np"> decorator_no_info </em>实际返回的是<em class="np"> _wrapper </em>函数。那是装饰者的本质；一个功能换一个功能。<em class="np"> _wrapper </em>函数接受修饰函数(<em class="np"> func </em>)接受的任何参数和关键字参数，并返回<em class="np"> func </em>返回的任何参数。在<em class="np"> _wrapper </em>中的一个附加打印显示代码块已经运行。</p><p id="5fde" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于类型提示，RT(返回类型)的目的是表明无论装饰函数返回什么，装饰器都会返回。</p><p id="d1e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个装饰者的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d688" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np">打印:</em></p><blockquote class="nq nr ns"><p id="ce55" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">这是装饰包装纸</p><p id="8f19" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi">2.0</p><p id="1257" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">_包装</p></blockquote><p id="9b55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我们看到<em class="np"> _wrapper </em>运行并返回了<em class="np"> test_deco </em>应该返回的内容。到目前为止，一切顺利。然而，修饰函数的名字已经改变了！是<em class="np"> _wrapper </em>而不是<em class="np"> test_deco </em>！</p><p id="e1f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，我们使用了来自<em class="np"> functools </em>模块的<em class="np">包装</em>装饰器。它将复制原始函数的信息，并将其传递给<em class="np"> _wrapper </em>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="cc14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如果我们运行示例，我们会看到名称是正确的，修饰函数的参数被传递给了<em class="np"> _wrapper </em>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="643d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np">打印:</em></p><blockquote class="nq nr ns"><p id="be3f" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">这是装饰包装纸</p><p id="c092" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi">2.0</p><p id="4d7e" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">测试_装饰</p><p id="ebf0" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">这是装饰包装纸</p><p id="058c" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi">5.0</p><p id="ccf3" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">测试_装饰_添加</p></blockquote><p id="38f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来是一个可以接受参数的装饰器。在这种情况下，我们创建一个外部函数，它接受装饰器参数，并返回与没有参数的情况相同的装饰器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="272d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="51d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np">版画:</em></p><blockquote class="nq nr ns"><p id="1ab0" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">这是decorator _wrapper，deco_arg_str='foo '</p><p id="2494" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi">5.0</p><p id="66be" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">测试_装饰_添加</p></blockquote><p id="4efc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">按照预期工作，装饰器参数被传递给<em class="np"> _wrapper </em>函数。</p><h2 id="05b7" class="mp mq it bd mr ms mt dn mu mv mw dp mx lh my mz na ll nb nc nd lp ne nf ng nh bi translated">重试装饰器</h2><p id="2820" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">最后，第一个例子。这里我们实现了引言中讨论的重试修饰器。装饰器逻辑与上一节中更简单的例子相同。然而，这里我们将重试逻辑引入装饰器。</p><p id="0bab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个装饰器执行被装饰的函数，并返回它应该返回的任何东西，但是捕捉到一个定制的异常并重试<em class="np"> n_retry </em>次。每次重试，睡眠时间都会增加。</p><p id="9e05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用日志记录器来了解是否有重试尝试。记录器可以作为参数提供，如果没有提供，将创建一个新的记录器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c27a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，我们想要捕捉<em class="np">值错误</em>。它尝试了两次并记录了异常，但是没有崩溃；第二次之后，程序崩溃，因为异常被引发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="842a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，该函数第一次引发了<em class="np"> ValueError </em>(崩溃)，因为我们想要捕获<em class="np"> RunTimeError </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9c58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要捕捉所有异常(不包括系统退出的异常)，使用<em class="np">异常</em>作为<em class="np">异常重试</em>，因为所有非系统退出的异常都是子类。</p><h2 id="8789" class="mp mq it bd mr ms mt dn mu mv mw dp mx lh my mz na ll nb nc nd lp ne nf ng nh bi translated">类注册表装饰器</h2><p id="ae5c" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">第二个例子是类装饰器。是的，类也可以被修饰，不仅仅是函数。为了装饰一个类，装饰器返回一个函数，但是这个函数(在我们的例子中是<em class="np"> _wrapper </em>)返回一个未实例化的类。</p><p id="4a92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特殊的例子实现了一个类注册表。对于插件或者<a class="ae nw" rel="noopener" target="_blank" href="/python-interfaces-why-should-a-data-scientist-care-2ed7ff80f225">接口</a>实现很有帮助。有时，我们直到运行时才知道对象的存在。</p><p id="bc0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想想一个插件对象；该对象遵循一个<a class="ae nw" rel="noopener" target="_blank" href="/python-interfaces-why-should-a-data-scientist-care-2ed7ff80f225">接口</a>，但是主程序不知道这些插件，也不需要它们运行。主程序加载任何可用的插件。因此，我们可以在不改变主代码的情况下添加任意数量的插件。</p><p id="d087" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事不宜迟，下面是类注册装饰器的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d30f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰器只接受注册表的名称作为参数。为了避免重复，注册表由注册表名和类名的元组索引。</p><p id="f868" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，还有一个查询注册表的功能(这是主程序了解插件的方式)。</p><p id="a7b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们将这些类添加到注册表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e1e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们查询注册表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="88d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np">版画:</em></p><blockquote class="nq nr ns"><p id="f9e0" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">富（中国姓氏）</p><p id="90d2" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">{'Foo': <class>，'巴兹':<class> }</class></class></p></blockquote><p id="2d21" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">班级在那里。我们是黄金。</p><h2 id="9c66" class="mp mq it bd mr ms mt dn mu mv mw dp mx lh my mz na ll nb nc nd lp ne nf ng nh bi translated">周期性执行装饰器</h2><p id="f326" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">最后一个例子是周期函数装饰器。有时我们想在应用程序中的函数中添加一些调度逻辑。例如，HTTP请求每隔<em class="np"> n </em>分钟获取一些数据。</p><p id="8d7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这是重试修饰器的动机，我们不想通过添加调度逻辑来扰乱实际函数的逻辑。因此，我们创建了一个装饰器来为我们做这件事。更干净。</p><p id="c0c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要求的唯一要求是装饰函数是void，也就是说，它不返回任何值。我们将执行其中的代码，不关心函数的返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="f990" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，我们使用线程模块在一个单独的线程中运行预定的功能，而不会阻塞主线程。这样，您可以运行该函数，并且调度循环不会阻塞:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="66b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="np">打印:</em></p><blockquote class="nq nr ns"><p id="8b4a" class="ky kz np la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">在周期性的<br/>foo 1656078663 . 629107<br/>foo 1656078664 . 6331909<br/>foo 165607865 . 6351948<br/>foo 165607866 . 635</p></blockquote><p id="3932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您所看到的，“after periodic”在其余的函数定期执行(即非阻塞执行)之前打印。</p><h2 id="7787" class="mp mq it bd mr ms mt dn mu mv mw dp mx lh my mz na ll nb nc nd lp ne nf ng nh bi translated">最后的话</h2><p id="3e21" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">这个故事是对装饰者和数据科学项目中的一些应用的快速浏览。希望您能编写更多自己的装饰器，并在代码中使用它们。我强烈建议您开始使用它们，直到您有信心在产品代码中使用它们。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="e3bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="4c4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。如果你想知道更多类似的故事，请订阅。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/subscribe/@diego-barba" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>