<html>
<head>
<title>Regular Expressions (Regex) with Examples in Python and Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和Pandas中的正则表达式(Regex)示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/regular-expressions-regex-with-examples-in-python-and-pandas-461228335670#2022-11-09">https://towardsdatascience.com/regular-expressions-regex-with-examples-in-python-and-pandas-461228335670#2022-11-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3ebc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中正则表达式的实用实践教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3669f57026b0b0e55f73c4ef1da9bc0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_P7udUEju5dNGc_meMp3-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自Pixabay的Josefine提供</p></figure><p id="97b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在很长一段时间里，我在复制粘贴的<a class="ae lu" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>代码中使用正则表达式，并且从不费心去理解它，只要它能工作。</p><p id="807c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我很快意识到，要处理软件和数据相关的任务，如网页抓取、情感分析和字符串操作，regex是一个必备的工具。</p><p id="4930" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文旨在通过一次一个地解决正则表达式字符和处理它们的python函数，同时提供清晰简单的例子，来揭开它们的神秘面纱。</p><p id="c98d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">什么是正则表达式？</strong>简单地说，它是一个组成模式的字符序列，用于查找、替换和提取文本数据。Regex包含自己的语法和字符，在不同的编程语言中略有不同。</p><p id="fb52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">模式</strong> —这是一个正则表达式字符串，包含我们在长字符串中寻找的信息。它可以是一个单词，一系列正则表达式特殊符号，或者两者的组合。</p><p id="a89b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Match </strong> —如果在字符串中找到了模式，我们称这个子串为匹配，并说模式已经匹配。一个操作中可以有多个匹配项。</p><p id="110a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">正则表达式的优势:</strong></p><ul class=""><li id="ec4c" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">正则表达式操作比手动字符串操作执行起来更快。</li><li id="e49a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">每种现代编程语言都包含一个用于处理正则表达式的regex引擎，同样的逻辑也适用于各种语言。</li><li id="c095" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Regex提供了一种快速编写处理复杂字符串操作的模式的方法，为您节省了时间。</li></ul><h2 id="b809" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">Python中的正则表达式</h2><p id="7618" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Python处理正则表达式的引擎在名为<code class="fe nh ni nj nk b"><a class="ae lu" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">re</a>.</code>的内置库中。一旦将该库导入到代码中，就可以使用下面提到的任何一个强大的函数。</p><p id="f2fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些函数接受以下参数:</p><ul class=""><li id="fbaf" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">要搜索的<em class="nl">图案</em>，</li><li id="9599" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">要搜索的<em class="nl">文本</em>的字符串</li><li id="5ad2" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">一个可选的<em class="nl">标记了</em>参数，该参数改变了正则表达式引擎的行为。例如<em class="nl"> flags=re。这使得模式不区分大小写。此处涉及的其他旗帜有<em class="nl"> re。M </em>，<em class="nl"> re。S </em>和<em class="nl"> re。L </em>。</em></li></ul><p id="ab3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用re库，您可以:</p><ul class=""><li id="5ab0" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">检查字符串中是否存在模式。</li><li id="5638" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">返回模式出现的次数。</li><li id="99ce" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">获取模式的位置。</li></ul><p id="326d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意:</strong> Regex从左到右搜索文本。一旦匹配，字符串的这一部分就用完了，不能在同一操作中再次匹配。</p><p id="bc5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> re.findall(pattern，text) </strong> —该函数返回列表中所有匹配的字符串。<em class="nl"> </em>下面的代码在文本中搜索‘The’并返回所有匹配字符串的列表。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="7cce" class="mj mk it nk b gy nq nr l ns nt">text = 'There was fur<strong class="nk iu">the</strong>r decline of <strong class="nk iu">the</strong> UHC'</span><span id="c17a" class="mj mk it nk b gy nu nr l ns nt">re.findall("the", text)<br/>###Output<br/>[’the’, 'the’]</span></pre><p id="2f26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">regex模式区分大小写，所以使用参数<code class="fe nh ni nj nk b">flags=re.I</code>或<code class="fe nh ni nj nk b">flags=re.IGNORECASE</code>来区分大小写。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="33d6" class="mj mk it nk b gy nq nr l ns nt">re.findall("the", text, flags=re.I)<br/>###Output<br/>[’The’, 'the’, 'the’]</span></pre><p id="7c7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意'<strong class="la iu"> The </strong> re '和' fur <strong class="la iu"> the </strong> r '的部分也是如何匹配的，因为不管前面或后面是什么，它都会查找这个精确的字符序列。</p><p id="481e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> re.search(pattern，text) </strong> —返回第一个<em class="nl">匹配项作为匹配对象。</em></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="8dfd" class="mj mk it nk b gy nq nr l ns nt">re.search("the", text)<br/>###Output<br/>&lt;re.Match object; span=(13, 16), match='the'&gt;</span></pre><p id="f1e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">match对象包含关于匹配字符串的信息，比如它的跨度(文本中的开始和结束位置)，以及匹配字符串本身。您可以通过调用它的<em class="nl">来进一步提取这些细节。group()，。span()，。start()，</em>和<em class="nl">。【T21结束()】方法如下所示。</em></p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="649a" class="mj mk it nk b gy nq nr l ns nt">match_obj = re.search("the", text)</span><span id="20cd" class="mj mk it nk b gy nu nr l ns nt"><em class="nl">#index span of matched string</em><br/>print(<strong class="nk iu">match_obj.span()</strong>)<br/>### (13, 16)</span><span id="1182" class="mj mk it nk b gy nu nr l ns nt"><em class="nl">#the matched string</em><br/>print(<strong class="nk iu">match_obj.group()</strong>)<br/>### the</span><span id="aebc" class="mj mk it nk b gy nu nr l ns nt"><em class="nl">#start position of match</em><br/>print(<strong class="nk iu">match_obj.start()</strong>)<br/>### 13</span><span id="d05f" class="mj mk it nk b gy nu nr l ns nt"><em class="nl">#end position of match</em><br/>print(<strong class="nk iu">match_obj.end()</strong>)<br/>### 16</span></pre><p id="e6e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> re.match(pattern，text) </strong> —检查模式文本的开头。如果在<em class="nl">开始</em>时出现，则返回匹配对象，否则不返回。在下面的代码中，“the”(区分大小写)没有出现在开头，因此没有输出。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1a33" class="mj mk it nk b gy nq nr l ns nt">re.match('the', text)<br/>### No output</span></pre><p id="c7fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以使用if-else语句，不管模式是否存在，它都会打印一条定制消息。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="919a" class="mj mk it nk b gy nq nr l ns nt">text = 'The focus is on 2022'<br/>is_match = re.match('the', <br/>                    text, <br/>                    re.I)<br/>if is_match:<br/>    print(f"'{is_match.group()}' <br/>          appears at {is_match.span()}")<br/>    <br/>else:<br/>    print(is_match) #None</span><span id="64ae" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>'The' appears at (0, 3)</span></pre><p id="c6d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> re.finditer(pattern，text) </strong> —这将返回一个匹配对象的迭代器，然后我们用一个列表包装这些对象以显示它们。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="d561" class="mj mk it nk b gy nq nr l ns nt">text = 'There was further decline of the UHC'</span><span id="123a" class="mj mk it nk b gy nu nr l ns nt">match = re.finditer('the', text, <br/>                    flags=re.I)<br/>list(match)</span><span id="1dbb" class="mj mk it nk b gy nu nr l ns nt">###<br/>[&lt;re.Match object; span=(0, 3), match='The'&gt;,<br/> &lt;re.Match object; span=(13, 16), match='the'&gt;,<br/> &lt;re.Match object; span=(29, 32), match='the'&gt;]</span></pre><p id="27a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">re sub(pattern，repl，text) </strong> —用<code class="fe nh ni nj nk b">‘repl’</code>字符串替换匹配的子字符串。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="4fbb" class="mj mk it nk b gy nq nr l ns nt">text = 'my pin is 4444'<br/>re.sub('4', '*', text)</span><span id="af7d" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>'my pin is ****'</span></pre><p id="b642" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> re.split(pattern，text)——</strong>将匹配位置的文本分割成列表中的元素。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="5e86" class="mj mk it nk b gy nq nr l ns nt">text = "wow! nice! love it! bye! "<br/>re.split("!", text)</span><span id="9f71" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['wow', ' nice', ' love it', ' bye', ' ']</span></pre><h2 id="aa5e" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">正则表达式元字符</h2><p id="a002" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">元字符是在正则表达式语言中具有特殊含义的符号，这就是正则表达式的威力所在。</p><p id="3283" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一节中，我们将探索不同的元字符，并使用<code class="fe nh ni nj nk b">re.findall()</code>来检查字符串中模式的存在，并返回所有匹配的子字符串。</p><p id="6550" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">使用r (python原始字符串):</strong>在一个模式前面加一个r会将该模式的所有字符转换成正常的文字，去掉任何特殊的含义，比如作为转义字符的反斜杠。regex引擎现在可以搜索它的特殊字符，正如您将看到的，反斜杠非常突出。</p><p id="702b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">用反斜杠对正则表达式字符进行转义:</strong>当你想在一个文本中精确地搜索下面的任何正则表达式符号时，你必须用反斜杠对它们进行转义(同时也使用r raw字符串)，这样它们也就失去了特殊的正则表达式含义。</p><ol class=""><li id="d1c2" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt nv mb mc md bi translated"><strong class="la iu">。</strong>(点字符或通配符)—匹配并返回字符串中的任何字符，除了新行。这可以是数字、空格、字母或标点符号。</li></ol><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="d475" class="mj mk it nk b gy nq nr l ns nt">pattern = r'.'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="bff9" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['W', 'o', 'w', '!', ' ', 'W', 'e', "'", 'r', 'e', ' ', 'n', 'o', 'w', '_', '2', '5']</span></pre><p id="9356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.<strong class="la iu"> \w </strong>(小写w) —任何字母数字字符(字母、数字或下划线)。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="c8bd" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\w'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="1129" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['W', 'o', 'w', 'W', 'e', 'r', 'e', 'n', 'o', 'w', '_', '2', '5']</span></pre><p id="803e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.<strong class="la iu"> \W </strong>(大写w) —任何非W的内容，如空格和特殊字符。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="dd9c" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\W'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="9ade" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['!', ' ', "'", ' ']</span></pre><p id="ed81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">4.<strong class="la iu">\ d</strong>—0到9之间的任意数字。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="3358" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\d'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="8e00" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['2', '5']</span></pre><p id="1a1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">5.<strong class="la iu"> \D </strong> —任何非数字。否定\d。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="612c" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\D'<br/>re.findall(pattern,<br/>        "Wow! now_25")</span><span id="0146" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['W', 'o', 'w', '!', ' ', 'n', 'o', 'w', '_']</span></pre><p id="4b0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.<strong class="la iu"> \s </strong>(小写s) —一个空格。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f43f" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\s'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="04f3" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>[' ', ' ']</span></pre><p id="698d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">7.<strong class="la iu"> \S </strong>(大写s) —求反\S。返回非空格的任何内容。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="7f0d" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\S'<br/>re.findall(pattern,<br/>        "Wow! Now_25")</span><span id="8d04" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['W', 'o', 'w', '!', 'N', 'o', 'w', '_', '2', '5']</span></pre><p id="47c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">字符集</strong></p><p id="bea3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">8.<strong class="la iu"> [] </strong>匹配方括号内的任意字符。例如，模式“[abc]”在文本中查找a或b或c，也可以写成“a|b|c”。您也可以使用破折号在括号内定义一个范围，而不是写下每个字符。例如，[a-fA-F]匹配从a到F的任何小写或大写字母，下面的代码返回任何元音字母。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="de83" class="mj mk it nk b gy nq nr l ns nt">pattern = r'[aeiou]'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="bac0" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['o', 'e', 'e', 'o']</span></pre><p id="9c2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">9.<strong class="la iu">【^】</strong>在左方括号后有一个帽子^字符否定了字符集。它返回方括号内的相反字符或范围。下面的代码返回除字母m到z之外的所有内容。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="53b1" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#Any char except letters m to z</em><br/>pattern = r'[^m-zM-Z]'<br/>re.findall(pattern,<br/>        "Wow! We're now_25")</span><span id="8e3f" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['!', ' ', 'e', "'", 'e', ' ', '_', '2', '5']</span></pre><p id="bd76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">重复正则表达式模式</strong></p><p id="e36f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也称为量词，这些特殊字符写在模式或字符之后，告诉regex引擎匹配它的次数。</p><p id="d58d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">10.<code class="fe nh ni nj nk b"><strong class="la iu">+</strong></code>(一次或多次)—如果前一模式出现一次或多次，则匹配。下面的代码匹配前面有<code class="fe nh ni nj nk b">‘hell’</code>的字符<code class="fe nh ni nj nk b">‘o’</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="bf78" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#match o in hello once or many times</em><br/>text = 'hell hello ago helloo hellooo'<br/>pattern = r'hello+'<br/>re.findall(pattern, text)</span><span id="6dcd" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['hello', 'helloo', 'hellooo']</span></pre><p id="82ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">11.<code class="fe nh ni nj nk b"><strong class="la iu">*</strong></code>(零个或更多)—如果前一模式出现零次或多次，则匹配。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="ce8c" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#match o in hello zero or many times</em><br/>text = '<strong class="nk iu">hell hello</strong> ago <strong class="nk iu">helloo hellooo</strong>'<br/>pattern = r'hello*'<br/>re.findall(pattern, text)</span><span id="864c" class="mj mk it nk b gy nu nr l ns nt">['hell', 'hello', 'helloo', 'hellooo']</span></pre><p id="d1da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">12.<code class="fe nh ni nj nk b"><strong class="la iu">?</strong></code>(零次或一次)—如果前一模式出现零次或一次，则匹配。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="71e7" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#match o in hello zero times or once</em><br/>text = '<strong class="nk iu">hell hell</strong>o ago <strong class="nk iu">hello</strong>o <strong class="nk iu">hello</strong>oo'<br/>pattern = r'hello*'<br/>re.findall(pattern, text)</span><span id="9770" class="mj mk it nk b gy nu nr l ns nt">['hell', 'hello', 'hello', 'hello']</span></pre><p id="5e2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">13.<strong class="la iu">{ n }</strong>—定义匹配前一个字符或模式的确切次数。例如<code class="fe nh ni nj nk b">‘d{3}’</code>匹配<code class="fe nh ni nj nk b">‘ddd’</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="b59e" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#Extract years</em><br/>text = '7.6% in 2020 now 2022/23 budget'<br/>pattern = r'\d{4}'<br/>re.findall(pattern, text)</span><span id="7fbc" class="mj mk it nk b gy nu nr l ns nt">['2020', '2022']</span></pre><p id="0e57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">14.<strong class="la iu">{最小，最大} </strong> —定义匹配先前模式的最小(min)和最大(max)时间。例如<code class="fe nh ni nj nk b">'d{2,4}’</code>匹配<code class="fe nh ni nj nk b">‘dd’</code>、<code class="fe nh ni nj nk b">‘ddd’</code>和<code class="fe nh ni nj nk b">‘dddd’</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f43e" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#Dot followed by 2 to 5 word chars</em><br/>text = 'may@gmail.com cal@web.me ian@me.biz'<br/>pattern = r'\.\w{2,5}'<br/>re.findall(pattern, text)</span><span id="4790" class="mj mk it nk b gy nu nr l ns nt">['.com', '.me', '.biz']</span></pre><p id="e3fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">15.<strong class="la iu"> {min，} </strong> —匹配前一个元素至少<code class="fe nh ni nj nk b">‘min’</code>次。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="02a2" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#Long words</em><br/>text = 'universal healthcare is low'<br/>pattern = r'\w{5,}'<br/>re.findall(pattern, text)</span><span id="d30c" class="mj mk it nk b gy nu nr l ns nt">['universal', 'healthcare']</span></pre><p id="3b31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">贪婪量词— </strong>上述所有量词都被认为是贪婪的，因为它们试图在每个匹配中占据尽可能多的字符，只要满足模式，就会产生最长的匹配。例如，<code class="fe nh ni nj nk b">re.findall(‘b+’, ‘bbbb’)</code>返回一个匹配<code class="fe nh ni nj nk b">[‘bbbb’]</code>，这是最长的可能匹配，即使<code class="fe nh ni nj nk b">[‘b’, ‘b’, ‘b’, ‘b’]</code>仍然是有效的匹配，但匹配较短。</p><p id="c799" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">不贪(懒)——</strong>可以通过加一个问号(？)在量词后面。这意味着regex引擎将在每次匹配时返回最少的<em class="nl">个字符。下图显示了量词在贪婪和非贪婪模式下的行为比较。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/d4f9dd5005c984a12eee1cbd4ae651a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjWP72JSJI0fo40obz5HnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4439" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">边界/锚点</strong></p><p id="3363" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">16.<strong class="la iu"> ^ </strong> —只匹配文本的开头，因此^被写成模式中的第一个字符。请注意，这不同于[^..]它否定了方括号中的模式。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="109e" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#Starts with two digits</em><br/>text = '500,000 units'<br/>pattern = r'^\d\d'<br/>re.findall(pattern, text)</span><span id="3079" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['50']</span></pre><p id="3059" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">17.<strong class="la iu"> $ </strong> —匹配字符串的结尾，因此写在模式的结尾。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="11bf" class="mj mk it nk b gy nq nr l ns nt"><em class="nl">#Ends with two digits</em><br/>text = '500,000 units'<br/>pattern = r'\d\d$'<br/>re.findall(pattern, text)</span><span id="0f80" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>[]</span></pre><p id="23e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">18.<strong class="la iu"> \b </strong>(单词边界)—匹配单词前后的边界，或a \w和a \W之间的空字符串。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="01c0" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\b'<br/>re.findall(pattern,<br/>           "Wow! We're now_25")</span><span id="7607" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['', '', '', '', '', '', '', '']</span></pre><p id="d228" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要查看边界，使用<code class="fe nh ni nj nk b">re.sub()</code>功能将<code class="fe nh ni nj nk b">\b</code>替换为~符号。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="3305" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\b'<br/>re.sub(pattern, <br/>       '~',<br/>       "Wow! We're now_25")</span><span id="a56d" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>"~Wow~! ~We~'~re~ ~now_25~"</span></pre><p id="4414" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">组</strong></p><p id="c287" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">19.<strong class="la iu"> () </strong> —当你写一个正则表达式模式时，你可以用括号定义组。这对于从字符串中提取和返回细节很有用。请注意，圆括号不会改变模式的结果，而是将它分组为可以单独检索的部分。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f5cf" class="mj mk it nk b gy nq nr l ns nt">text = 'Yvonne worked for von'<br/>pattern = r'(.o.)'<br/>re.findall(pattern, text)</span><span id="e5f2" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['von', 'wor', 'for', 'von']</span></pre><p id="d0ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">使用</strong> <code class="fe nh ni nj nk b"><strong class="la iu">m.group()</strong></code> <strong class="la iu">访问匹配的组— </strong>在下面的代码中，我们将电子邮件的不同部分分成3组。<code class="fe nh ni nj nk b">m.group()</code>和<code class="fe nh ni nj nk b">m.group(0)</code>都返回整个匹配的字符串。<code class="fe nh ni nj nk b">m.group(1)</code>、<code class="fe nh ni nj nk b">m.group(2)</code>、<code class="fe nh ni nj nk b">m.group(3)</code>分别返回不同的组。括号是访问匹配组的一种便捷方式。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="b0e1" class="mj mk it nk b gy nq nr l ns nt">text = 'this is @sue email sue@gmail.com'<br/>pattern = r'(\w+)@(\w+)\.(\w+)\b'<br/>m = re.search(pattern, text)</span><span id="e96f" class="mj mk it nk b gy nu nr l ns nt">#match object<br/>print(m)<br/>### &lt;re.Match object; span=(19, 32), <br/>                match='sue@gmail.com'&gt;</span><span id="5bf7" class="mj mk it nk b gy nu nr l ns nt">#full match<br/>m.group(0)<br/>### 'sue@gmail.com'</span><span id="ee8a" class="mj mk it nk b gy nu nr l ns nt">m.group(1)<br/>### 'sue'</span><span id="4c99" class="mj mk it nk b gy nu nr l ns nt">m.group(2)<br/>### 'gmail'</span><span id="f6cd" class="mj mk it nk b gy nu nr l ns nt">m.group(3)<br/>### 'com'</span></pre><p id="0f04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">使用</strong> <code class="fe nh ni nj nk b"><strong class="la iu">\group_num</strong></code>引用组—一个正则表达式模式可以包含几个组，如前面包含3个组的电子邮件示例所示。您可以在regex模式中使用\1、\2…从1开始按位置引用和匹配一个组。下面的代码查找字符重复出现的子字符串。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="1b2b" class="mj mk it nk b gy nq nr l ns nt">text = 'hello, we need 22 books'<br/>pattern = r'(\w)\1'<br/>list(re.finditer(pattern, text))</span><span id="4fb4" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>[&lt;re.Match obj; span=(2,4), match='ll'&gt;,<br/> &lt;re.Match obj; span=(11,13), match='ee'&gt;,<br/> &lt;re.Match obj; span=(15,17), match='22'&gt;,<br/> &lt;re.Match obj; span=(19,21), match='oo'&gt;]</span></pre><p id="3e86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">分别使用</strong> <code class="fe nh ni nj nk b"><strong class="la iu">?P&lt;name&gt;</strong></code> <strong class="la iu">和</strong> <code class="fe nh ni nj nk b"><strong class="la iu">?P=name</strong></code> <strong class="la iu">命名和访问捕获的组</strong> —您可以为组指定一个名称，以便以后访问。当您有许多组时，这比<code class="fe nh ni nj nk b">\grp_number</code>符号要好，并且它增加了您的正则表达式的可读性。要访问匹配的组，请使用<code class="fe nh ni nj nk b">m.group(‘name’)</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="f988" class="mj mk it nk b gy nq nr l ns nt">text = '08 Dec'<br/>pattern = '(?P&lt;day&gt;\d{2})\s(?P&lt;month&gt;\w{3})'<br/>m = re.search(pattern, text)<br/>m.group('day')</span><span id="2671" class="mj mk it nk b gy nu nr l ns nt">###<br/>'08'</span></pre><p id="8634" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">非捕获组</strong></p><p id="9738" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">20.<strong class="la iu">？:</strong> —匹配但不捕获组。将<code class="fe nh ni nj nk b">?:</code>包含在您希望忽略的组中。下面的代码匹配带有百分号的数字，并且只返回数字。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="5596" class="mj mk it nk b gy nq nr l ns nt">text = 'date 23 total 42% date 17 total 35%'<br/>pattern = r'(\d+)(?:%)'<br/>re.findall(pattern, text)</span><span id="4bb5" class="mj mk it nk b gy nu nr l ns nt">###<br/>['42', '35']</span></pre><p id="8312" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">21.<strong class="la iu"> | </strong> (or) —这将返回一种或另一种模式的所有匹配。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="5302" class="mj mk it nk b gy nq nr l ns nt">text = 'the <strong class="nk iu">sun</strong>ny <strong class="nk iu">sun</strong> <strong class="nk iu">shine</strong>s'<br/>re.findall(r'sun|shine', text)</span><span id="3687" class="mj mk it nk b gy nu nr l ns nt">###Output<br/>['sun', 'sun', 'shine']</span></pre><h2 id="7141" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">熊猫和正则表达式</h2><p id="66f0" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Pandas是一个强大的Python库，用于分析和操作数据集。在Pandas中搜索和清理基于文本的列时，正则表达式非常方便。</p><p id="8e31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pandas包含几个支持正则表达式模式匹配的函数，就像我们看到的<code class="fe nh ni nj nk b">re</code>库一样。下面是我们将在本教程中使用的三个主要函数。点击阅读其他熊猫正则表达式函数<a class="ae lu" href="https://kanoki.org/2019/11/12/how-to-use-regex-in-pandas/" rel="noopener ugc nofollow" target="_blank">。</a></p><ul class=""><li id="36ed" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu">Series . str . contains(pattern)</strong>—此函数检查列(Series)中的模式，在模式匹配的地方返回True和False值(掩码)。然后可以将掩码应用于整个数据帧，以便只返回真行。</li><li id="7624" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> Series.str.extract(pattern，expand，flags) </strong> —要使用此函数，我们必须在模式中使用括号定义组。该函数提取匹配项，并将组作为数据帧中的列返回。当模式中只有一个组时，使用<code class="fe nh ni nj nk b">expand=False</code>返回一个系列，而不是dataframe对象。</li><li id="84ad" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu"> Series.str.replace(pattern，repl，flag) </strong> —与<code class="fe nh ni nj nk b">re.sub()</code>类似，该函数用repl字符串替换匹配项。</li></ul><p id="9ec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本节中，我们将处理七个正则表达式任务来执行以下操作；</p><ul class=""><li id="b2d8" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">筛选数据以返回符合特定条件的行。</li><li id="31b3" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">从列中提取子字符串和其他详细信息。</li><li id="1b1d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">替换列中的值。</li></ul><p id="2c48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明这一点，我使用了Kaggle提供的titanic数据集，这里是GNU自由文档许可证下的。在新的Jupyter笔记本上，导入熊猫并加载数据。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="45d4" class="mj mk it nk b gy nq nr l ns nt">import pandas as pd<br/>df = pd.read_csv('titanic.csv')</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/69750e42141dd92f12515d4f45aeaed3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oZC73HDyQvNso81E3T8o2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者分类的数据集</p></figure><p id="2f83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">过滤数据帧— </strong> <code class="fe nh ni nj nk b"><strong class="la iu">s.str.contains(pattern)</strong></code></p><p id="1e77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">任务1: </strong>过滤数据帧，返回票号为C和a的行</p><p id="7ed9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是所有必须匹配的“C A”票变体的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c28673b4f6bd37a80b55fa2bcf1c2731.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*pL6tZslkKD0gxUvDGCtsOg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7d0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">regex模式以大写字母C开头，后面跟一个可选的点，然后是大写字母A，后面跟一个可选的点。我们对点符号进行了转义，以精确匹配句点，而不是通配符正则表达式字符。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2f7d" class="mj mk it nk b gy nq nr l ns nt">pattern = r'C\.?A\.?'<br/>mask = df['Ticket'].str.contains(pattern)<br/>df[mask].head(10)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/adb2c53eb1e86d96b3c2e93a549fc0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPjYWBhCB-sEqPffsaCXsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6f9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要获得CA的总行数，使用<code class="fe nh ni nj nk b">mask.sum()</code>，它将所有显示为1的<code class="fe nh ni nj nk b">True</code>值和显示为0的<code class="fe nh ni nj nk b">False</code>值相加。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="44fd" class="mj mk it nk b gy nq nr l ns nt">mask.sum()<br/>### 42</span></pre><p id="55f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">提取数据— </strong> <code class="fe nh ni nj nk b"><strong class="la iu">s.str.extract(patt)</strong></code></p><p id="378b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务2: 从乘客姓名中提取所有唯一的头衔，如先生、小姐和夫人。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/08017b625570ef07163f993900c1e773.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*1tXhbC9hEBmTyY0sa7jOcg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="938c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Regex模式:这将搜索一个空格，后跟一系列字母(括在括号中)，然后是一个点字符。我们使用括号将想要捕获和返回的子串分组。<code class="fe nh ni nj nk b">expand=False</code>返回一个系列对象，使我们能够在其上调用<code class="fe nh ni nj nk b">value_counts()</code>。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="e94e" class="mj mk it nk b gy nq nr l ns nt">pattern = '\s(\w+)\.'<br/>all_ts = df['Name'].str.extract(<br/>                    pattern, <br/>                    expand=False)<br/>unique_ts = all_ts.value_counts()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b067ee5a3e5aff29bbccd86d4400babf.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*aSYGE0VEPKi5LU96gZp2tw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4972" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> Task 3a: </strong>从“Name”列中提取职位、名字和姓氏，并在新的dataframe中将它们作为列返回。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a7891dfef614c1a2457e6968d5c21908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*EDagl6ryKySxNphyWDIz_g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="67c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正则表达式模式；每个名字包含“一个或多个单词字符序列”(姓氏)，然后是逗号、空格、另一个字符序列(头衔)、句号、空格、另一个字符序列(名字)，然后是零到许多其他字符。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="fe59" class="mj mk it nk b gy nq nr l ns nt">pattern = r'(\w+), (\w+\.) (\w+).*'<br/>df_names = df['Name'].str.extract(<br/>                            pattern, <br/>                            flags=re.I)<br/>df_names</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/ff866ecef6e2301fb9909eb9ea619c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*NeNJd3N4phuAQPpvKocZLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1610" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">任务3b: </strong>用名为的<em class="nl">和<em class="nl">的有序</em>列清理上面的数据帧。</em></p><p id="04c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，<strong class="la iu">命名组</strong>对于捕获和访问组非常有用。对于Pandas，这尤其方便，因为这些名称现在将成为我们新数据框架中的列名。</p><p id="73f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的正则表达式与上面的相同，除了使用<code class="fe nh ni nj nk b">(?P&lt;name&gt;).</code>命名组。代码提取三个命名的列，然后我们使用<code class="fe nh ni nj nk b">df.reindex()</code>对它们重新排序。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="fb22" class="mj mk it nk b gy nq nr l ns nt">pattern = r'(?P&lt;lastname&gt;\w+),\s<br/>                (?P&lt;title&gt;\w+\.)\s<br/>                (?P&lt;firstname&gt;\w+).*'<br/>df_named = df['Name'].str.extract(<br/>                            pattern,  <br/>                            flags=re.I)<br/>df_clean = df_named.reindex(<br/>                        columns = <br/>                            ['title', <br/>                             'firstname',<br/>                             'lastname'])<br/>df_clean.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fd244c391a17b7b9158544f49fe30d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*p-bWDp6cq6QEL5zM5Nyr4Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6353" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">替换列中的值— </strong> <code class="fe nh ni nj nk b"><strong class="la iu">s.str.replace(pattern, repl)</strong></code></p><p id="3442" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">任务4a: </strong>用大写字母替换所有标题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b4c21fce5bf238e6e01facb9166529be.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*qPpkJRgJK_rYoDbqcE4iyA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a993" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">regex模式搜索空格，然后是一个或多个单词字符(用括号括起来)，最后是一个句点。然后，我们将捕获的组替换为大写的组。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="2a1f" class="mj mk it nk b gy nq nr l ns nt">pattern = r’\s(\w+)\. '<br/>df[’Name’].str.replace(pattern, <br/>            lambda m:m.group().upper())</span></pre><p id="b039" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的<a class="ae lu" rel="noopener" target="_blank" href="/lambda-functions-with-practical-examples-in-python-45934f3653a8"> lambda函数</a>的意思是，对于每一行，取抓取的组，转换成大写。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/9e7f81d081b8f6d1bae3bd05520522ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*cAS8ynjB39yXsmFOJTn1dg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b530" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任务4b: 仅大写<code class="fe nh ni nj nk b">Mr.</code>和<code class="fe nh ni nj nk b">Mrs.</code>标题。在这种情况下，我们在括号内使用|。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="0c39" class="mj mk it nk b gy nq nr l ns nt">pattern = r'\s(Mr|Mrs)\.\s'<br/>df['Name'].str.replace(pattern, <br/>            lambda m:m.group().upper(),<br/>                      flags=re.I)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/587eccd2b3aae187c76490167e76c759.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*Ur8BgrLWgB_Thi_VYY0Yew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="12a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">任务5: </strong>通过插入破折号来显示日、月和年，从而清除下面一列中的日期。我们要保存列中的其他字，因此不能直接调用<code class="fe nh ni nj nk b"><a class="ae lu" href="https://www.w3resource.com/pandas/to_datetime.php" rel="noopener ugc nofollow" target="_blank">pd.to_datetime()</a></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6805bd65fa174282829bbdada60f81e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*n4TG7U8zIusDkCG1TBhmVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b859" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模式:搜索两位数，然后再次搜索两位数，然后搜索四位数，并用括号将它们分成三组。<a class="ae lu" rel="noopener" target="_blank" href="/lambda-functions-with-practical-examples-in-python-45934f3653a8"> lambda </a>功能意味着对于每场比赛，在第一组和第二组之后用破折号连接各组。</p><pre class="kj kk kl km gt nm nk nn no aw np bi"><span id="0a76" class="mj mk it nk b gy nq nr l ns nt">pattern = r'(\d{2})(\d{2})(\d{4})'<br/>d['A'].str.replace(pattern,<br/>        lambda m: m.group(1)+'-'+<br/>                   m.group(2)+'-'+<br/>                   m.group(3))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/ff6621b8115cee1afedf2f41a6b5b895.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*sE82DPbibCXBfdTLuEcr9g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><h2 id="66fa" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">结论</h2><p id="3067" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在本文中，我们学习了正则表达式，并使用Python re库和Pandas字符串函数来探索不同的特殊正则表达式元字符。</p><p id="cc34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还了解到，在每个模式前面加上一个r raw字符串以消除任何特殊的字符串含义，以及在字符串中精确匹配特殊的正则表达式字符时用反斜杠对它们进行转义是很重要的。你可以在GitHub 上找到所有的代码<a class="ae lu" href="https://github.com/suemnjeri/medium-articles/blob/main/Regex/Regex%20in%20python.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cd94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，大多数正则表达式都是特定情况下特有的，所以只需尝试每种可能的情况，以避免错误匹配和遗漏。大多数时候，有许多方法可以编写正则表达式，所以选择最简单和最明智的。你可以使用regex101.com<a class="ae lu" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">等网站进行测试，直到满意为止。</a></p><p id="7d04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章。每当我发表文章时，想收到更多这样的消息，请在这里订阅<a class="ae lu" href="https://suemnjeri.medium.com/subscribe/@suemnjeri" rel="noopener"/>。如果你还不是一个媒体成员，并且愿意支持我成为一名作家，请点击<a class="ae lu" href="https://medium.com/@suemnjeri/membership" rel="noopener">这个链接</a>，我将获得一小笔佣金。感谢您的阅读！</p><h2 id="abf9" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">进一步阅读</h2><ul class=""><li id="1051" class="lv lw it la b lb nc le nd lh or ll os lp ot lt ma mb mc md bi translated"><a class="ae lu" href="https://regexone.com/" rel="noopener ugc nofollow" target="_blank">正则表达式—学习正则表达式</a></li><li id="8598" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://blog.finxter.com/python-regex/" rel="noopener ugc nofollow" target="_blank"> Finxter的Python正则表达式超级能力【完整教程】</a></li><li id="ebf5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" rel="noopener" target="_blank" href="/8-ways-to-filter-a-pandas-dataframe-by-a-partial-string-or-pattern-49f43279c50f">通过部分字符串或模式过滤熊猫数据帧</a></li></ul></div></div>    
</body>
</html>