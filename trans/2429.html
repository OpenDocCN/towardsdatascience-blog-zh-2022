<html>
<head>
<title>Broadcasting in Numpy: A Powerful Technique You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数字广播:你应该知道的强大技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/broadcasting-in-numpy-a-powerful-technique-you-should-know-7dc1dde619fa#2022-05-26">https://towardsdatascience.com/broadcasting-in-numpy-a-powerful-technique-you-should-know-7dc1dde619fa#2022-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7b9d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">广播在幕后如何运作的细节</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89c9ec64f04af66c761ce510161c98c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3eI7TCeDvq9rarAb"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">唐纳德·詹纳蒂在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="ab55" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">简介</strong></h1><p id="f5e5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">什么是广播？<a class="ae ky" href="https://numpy.org/doc/stable/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">广播</strong> </a> <strong class="lt iu">是一种允许</strong><a class="ae ky" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">Numpy</strong></a><strong class="lt iu">在算术运算时处理不同形状数组的机制。</strong>在广播中，我们可以把它想象成一个较小的数组，在做某些操作之前，被“广播”成与较大的数组相同的形状。通常，较小的数组将被复制多次，直到它达到与较大的数组相同的形状。注意，我们这里说的数组指的是Numpy<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html" rel="noopener ugc nofollow" target="_blank"><em class="mn">ndarrays</em></a>，是固定大小项目的多维数组。</p><p id="7ff4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">使用广播允许</strong> <a class="ae ky" href="https://en.wikipedia.org/wiki/Vectorization" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">向量化</strong> </a> <strong class="lt iu">，这是一种处理整个数组而不是单个元素的编程风格。如果你不熟悉矢量化的概念，我写了一篇关于矢量化的文章，你可以从中了解更多。广播通常很快，因为它对数组操作进行了矢量化，所以循环发生在优化的C代码中，而不是较慢的Python中。此外，它并不真的需要存储较小数组的所有副本；相反，有更快更有效的算法来存储。</strong></p><h1 id="4b3f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">广播示例</strong></h1><p id="c423" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">举个例子，假设你想给一个数组添加一个常量。最天真的方法应该是这样的:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="3df3" class="my la it mu b gy mz na l nb nc">import numpy as np</span><span id="d6bd" class="my la it mu b gy nd na l nb nc">data = np.array([[1,2], [3,4]])<br/>constant_arr = np.array([[5,5], [5,5]])<br/>data + constant_arr<br/># result: array([[6, 7],<br/>                 [8, 9]])</span></pre><p id="d0f5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们定义一个和数据形状一样的数组来保存常数，然后把它们加起来。这是因为两个数组具有完全相同的形状。</p><p id="72a0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">但是如果这次的数据更大，比如说，是三维的。为了迎合这一点，我们将定义另一个数组来保存常数，但这一次，用了一个更大的维度:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="eb87" class="my la it mu b gy mz na l nb nc">data = np.array([[[1,2], [3,4]], [[5,6], [7,8]]])<br/>constant_arr = np.array([[[5,5], [5,5]], [[5,5], [5,5]]])<br/>data + constant_arr<br/># result: array([[[ 6,  7],<br/>                  [ 8,  9]],<br/><br/>                 [[10, 11],<br/>                  [12, 13]]])</span></pre><p id="677e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这个管用。然而，正如您所看到的，代码似乎变得有点混乱和多余。为了提高可读性，您可能会注意到我们可以使用<code class="fe ne nf ng mu b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.full.html" rel="noopener ugc nofollow" target="_blank">np.full</a></code>函数，这将允许我们定义一个给定大小的数组，其中填充了一个特定的标量值。因此，我们可以做到:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5026" class="my la it mu b gy mz na l nb nc">constant_arr = np.full((data.shape), 5)<br/>data + constant_arr<br/># result: array([[[ 6,  7],<br/>                  [ 8,  9]],<br/><br/>                 [[10, 11],<br/>                  [12, 13]]])</span></pre><p id="9fa1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，这个稍微好一点。一切都很好，但是有没有办法让它更简单、更简洁？</p><p id="46f0" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">正如你所猜测的，答案是肯定的，而实现这一点的方法就是通过广播。Numpy允许我们处理不同形状的数组，从而使我们更容易执行操作。我们可以<em class="mn">直接</em>将常量添加到任何数组中，如下所示:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="d755" class="my la it mu b gy mz na l nb nc">data + 5<br/># result: array([[[ 6,  7],<br/>                  [ 8,  9]],<br/><br/>                 [[10, 11],<br/>                  [12, 13]]])</span></pre><p id="bb82" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这不是简单多了吗？</p><h1 id="2566" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">广播失败的地方</strong></h1><p id="7efa" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">广播让一切变得更简洁，但它能与任意两个数组一起工作吗？</p><p id="d6d1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">作为一个例子，让我们试着用形状为<code class="fe ne nf ng mu b">(3,)</code>的填充了1的数组来添加前面的数据数组:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ff97" class="my la it mu b gy mz na l nb nc">new_arr = np.ones(3, dtype=int)<br/>data + new_arr</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/a7026063c18a811a4dec5e354c036016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbWU9Fzl8EetkjNx21vgDA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行此示例时显示错误</p></figure><p id="d59b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这似乎给出了一个<a class="ae ky" href="https://docs.python.org/3/library/exceptions.html#ValueError" rel="noopener ugc nofollow" target="_blank">值错误</a>。很奇怪吧。</p><p id="0978" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">产生错误的原因是Numpy无法将较小的数组(在本例中为<code class="fe ne nf ng mu b">new_arr</code>)传播到与<code class="fe ne nf ng mu b">data</code>数组形状相同的数组中。请记住，广播的中心思想是试图复制较小数组中包含的数据，以匹配较大数组的形状。在这种情况下，没有办法复制一个大小为<code class="fe ne nf ng mu b">(3,)</code>的数组来匹配<code class="fe ne nf ng mu b">(2,2,2)</code>的形状。因此，给出值Error。</p><p id="28fb" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">虽然广播通常允许您使用不同大小的数组，但是有一个警告。<strong class="lt iu">并非所有数组都可以在一次操作中一起使用。</strong></p><h1 id="678e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">广播规则</strong></h1><p id="8437" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果广播不能通用，广播什么时候起作用，什么时候失效？</p><p id="40a6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">假设我们试图在两个数组之间执行一些操作，数组<em class="mn"> a </em>和<em class="mn"> b </em>。一般来说，广播的工作原理如下:</p><ul class=""><li id="7584" class="ni nj it lt b lu mo lx mp ma nk me nl mi nm mm nn no np nq bi translated">如果<em class="mn"> a </em>和<em class="mn"> b </em>的维数不同，那么维数较少的数组增加一个元素的维数，直到该数组的维数与另一个数组的维数相匹配。</li></ul><p id="87e2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这是什么意思？举个例子，比方说<code class="fe ne nf ng mu b">data = np.array([[1,2], [3,4]])</code> <em class="mn"> </em>我们正在努力做<code class="fe ne nf ng mu b">data + 5</code> <em class="mn">。</em>我们可以假设<em class="mn"> a = </em> <code class="fe ne nf ng mu b">data</code>，而<em class="mn"> b = </em> <code class="fe ne nf ng mu b">5</code>。这一步将把<em class="mn"> b </em>转换成<code class="fe ne nf ng mu b">np.array([[5]])</code>，现在是二维的，形状为<code class="fe ne nf ng mu b">(1,1)</code>。</p><ul class=""><li id="516f" class="ni nj it lt b lu mo lx mp ma nk me nl mi nm mm nn no np nq bi translated">一旦<em class="mn"> a </em>和<em class="mn"> b </em>的维数相等，迭代过程就开始了。我们遍历<em class="mn"> a </em>和<em class="mn">b<br/>*</em>的每个维度<em class="mn"> i </em>如果<em class="mn"> a </em>和<em class="mn"> b </em>的维度<em class="mn"> i </em>的形状相同，那么我们继续下一个维度<em class="mn"> i+1 <br/> * </em>否则如果<em class="mn"> b </em>在维度<em class="mn">I<em class="mn">中的形状为1<br/> *否则如果<em class="mn"> a </em>在尺寸<em class="mn"> i </em>中的形状为1，则复制<em class="mn"> a </em>的尺寸<em class="mn"> i+1、i+2、…、<code class="fe ne nf ng mu b"><em class="mn">max(len(a.shape), len(b.shape))</em></code><em class="mn">】</em>中的数据，直到形状与<em class="mn"> b </em>相同。(与上一个else if相同，但这一次，<em class="mn"> a </em>被复制，因为它的形状更小)。<br/> *否则，将引发“ValueError:操作数不能一起广播”，表示数组<em class="mn"> a </em>和<em class="mn"> b </em>不兼容，不能广播。</em></em></em></li></ul><p id="54b9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">回到<code class="fe ne nf ng mu b">data + 5</code>的例子，<em class="mn"> a </em>和<em class="mn"> b </em>都有两个维度，分别是<code class="fe ne nf ng mu b">a.shape=(2,2)</code> <em class="mn"> </em>和<code class="fe ne nf ng mu b">b.shape=(1,1)</code>。我们开始迭代过程。我们从尺寸<em class="mn"> 0 </em>开始，观察到<em class="mn"> b </em>在尺寸<em class="mn"> 0 </em>中的形状为1。因此，我们复制了<code class="fe ne nf ng mu b">[5]</code>，通过使其成为<code class="fe ne nf ng mu b"><em class="mn">b=np.array([[5], [5]])</em></code>，形状现在变成了2 ( <em class="mn"> a </em>在维度<em class="mn"> 0 </em>上的形状)。现在，我们有了<code class="fe ne nf ng mu b">b.shape=(2,1)</code> <em class="mn">。</em>接下来，我们继续下一个维度，维度<em class="mn"> 1 </em>，我们再次观察到b的形状为1。我们复制<code class="fe ne nf ng mu b">5</code>,使<em class="mn"> b </em>的形状为2(与a的形状相同),将其转换为<code class="fe ne nf ng mu b"><em class="mn">b=np.array([[5, 5], [5, 5]])</em></code>。由于没有更多的维度可以迭代，我们停止，导致<em class="mn"> a </em>和<em class="mn"> b </em>在所有维度上的形状相同。最后，我们可以将它们逐个元素相加，得到结果<code class="fe ne nf ng mu b">np.array([[6, 7], [8, 9]])</code>。</p><p id="2331" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">希望这一切都有意义。这里要注意的要点是，广播试图使两个数组的每个维度的形状相同，它通过多次复制该维度中形状为1的数组，直到达到目标形状。</p><h1 id="6f91" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">更多例子</strong></h1><p id="7b4f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我知道如果你是第一次学广播，有很多东西需要理解。别担心，这里还有一些例子可以帮助你更熟悉规则。</p><p id="43b7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于下面的每个示例，考虑如何转换一个数组以匹配另一个数组。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e679" class="my la it mu b gy mz na l nb nc">a = np.array([[2,4], [6,8]])<br/>b = np.array([1,3])<br/>a + b<br/># result: array([[ 3,  7],<br/>                 [ 7, 11]])</span></pre><p id="757f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这种情况下，<em class="mn"> b </em>转化为<code class="fe ne nf ng mu b">b=np.array([[1,3], [1,3]])</code>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1cdb" class="my la it mu b gy mz na l nb nc">a = np.array([[2,4], [6,8]])<br/>b = np.array([[1], [3]])<br/>a + b<br/># result: array([[ 3,  5],<br/>                 [ 9, 11]])</span></pre><p id="7544" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这里<em class="mn"> b </em>转化为<code class="fe ne nf ng mu b">b=np.array([[1,1], [3,3]])</code>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="15de" class="my la it mu b gy mz na l nb nc">a = np.array([[2,4], [6,8]])<br/>b = np.array([[1,3,5], [2,4,6]])<br/>a + b</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/ec7f7c14afff8a5acb7703771618d3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5P58618akqxMHFK0cavjlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行此示例时显示错误</p></figure><p id="8d3a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">最后，在最后一个例子中，出现了ValueError。这是因为<em class="mn"> a </em>具有<code class="fe ne nf ng mu b">(2,2)</code>的形状，<em class="mn"> b </em>具有<code class="fe ne nf ng mu b">(2,3)</code>的形状，并且正如你所看到的，在尺寸<em class="mn"> 1 </em>中<em class="mn"> a和b </em>都不具有1的形状，因此两者都不能被复制以匹配另一个。因此，这两个数组无法广播。</p><p id="0f42" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">希望你理解了这些例子，并且记住，一旦你练习和写更多的Numpy，你会对广播更加熟悉。随着时间的推移，这些规则会变得更加直观。</p><h1 id="7b89" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">总结</strong></h1><p id="9dd3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你在这里逗留，一定要给自己一个鼓励！总而言之，我们学习了什么是广播，它在哪里失败，以及它是如何工作的。广播在Numpy中使用非常频繁，因此了解它在幕后是如何工作的非常重要。</p><p id="d4ea" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我希望这篇文章很好地解释了广播背后的概念。如果你有任何问题，请告诉我，随时乐意帮忙！如果你需要的话，这里有到Jupyter笔记本的<a class="ae ky" href="https://github.com/itsuncheng/medium_code/blob/main/broadcasting_tutorial/broadcasting_examples.ipynb" rel="noopener ugc nofollow" target="_blank">链接</a>,其中包含了本文介绍的代码。</p><p id="edf4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果你刚刚写完这篇文章，但是不确定什么是矢量化或者它是如何工作的，一定要去看看我以前的<a class="ae ky" href="https://medium.com/towards-data-science/vectorization-must-know-technique-to-speed-up-operations-100x-faster-50b6e89ddd45" rel="noopener">文章</a>。请随意浏览我的其他文章来了解更多。下次见，再见。</p><p id="22ee" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我以前的一些文章:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/build-a-song-recommendation-system-using-streamlit-and-deploy-on-heroku-375a57ce5e85"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">使用Streamlit构建歌曲推荐系统并在Heroku上部署</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">了解如何使用Spotify音乐数据集的K近邻构建一个简单的歌曲推荐引擎</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/semantic-similarity-using-transformers-8f3cb5bf66d6"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">使用转换器的语义相似度</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">使用Pytorch和SentenceTransformers计算两个文本之间的语义文本相似度</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/top-nlp-books-to-read-2020-12012ef41dc1"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">2020年最佳NLP读物</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">这是我个人为自然语言处理推荐的书籍列表，供实践者和理论家参考</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/top-nlp-libraries-to-use-2020-4f700cdb841f"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">2020年将使用的顶级NLP库</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">AllenNLP，Fast.ai，Spacy，NLTK，TorchText，Huggingface，Gensim，OpenNMT，ParlAI，DeepPavlov</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="om l og oh oi oe oj ks nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/bert-text-classification-using-pytorch-723dfb8b6b5b"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">使用Pytorch的BERT文本分类</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">文本分类是自然语言处理中的一项常见任务。我们应用BERT，一个流行的变压器模型，对假新闻检测使用…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="on l og oh oi oe oj ks nv"/></div></div></a></div><h1 id="36ee" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="b1c9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://numpy.org/doc/stable/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">广播，Numpy </a></p><p id="d007" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><a class="ae ky" href="https://numpy.org/doc/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Numpy文档，Numpy </a></p><p id="68a9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><a class="ae ky" href="https://www.tutorialspoint.com/numpy/numpy_broadcasting.htm" rel="noopener ugc nofollow" target="_blank"> Numpy —广播、辅导点</a></p><p id="1419" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/python-broadcasting-with-numpy-arrays/" rel="noopener ugc nofollow" target="_blank"> Python |用Numpy数组广播，GeeksforGeeks </a></p></div></div>    
</body>
</html>