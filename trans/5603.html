<html>
<head>
<title>How to Detect Heteroskedasticity in Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测时间序列中的异方差</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-detect-heteroskedasticity-in-time-series-3413a8aa8da9#2022-12-19">https://towardsdatascience.com/how-to-detect-heteroskedasticity-in-time-series-3413a8aa8da9#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f41e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">时间序列中非恒定方差的检测和处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f16058c0851bc304b339fb8ac78e6c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OHzmDKiv2gwTCc0a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jannes Glas 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="65a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果时间序列的方差随时间变化，那么它就是异方差的。否则，数据集是同质的。</p><p id="1ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异方差影响时间序列的建模。因此，检测和处理这种情况非常重要。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="92ff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">介绍</h1><p id="bc3c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从一个直观的例子开始。</p><p id="2b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图 1 显示了热门航班乘客的时间序列。你可以看到不同系列的变化是不同的。在数列的后半部分，方差更大。这也是数据水平较高的地方。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/b95a38705130253cc1e345372e639d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EoQJdZnp44qx4Wwyfy-l7Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:某航空公司的月度乘客。<a class="ae ky" href="https://alkaline-ml.com/pmdarima/modules/generated/pmdarima.datasets.load_airpassengers.html" rel="noopener ugc nofollow" target="_blank">数据集在<em class="na"> pmdarima </em> Python 库中公开。</a>图片作者。</p></figure><p id="927c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方差的变化对于预测是有问题的。它会影响适当模型的拟合，从而影响预测性能。</p><p id="f7d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，仅目视检查是不实际的。你如何以一种更系统的方式发现和处理异方差？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4839" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">检测异方差</h1><p id="81f0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以使用统计测试来检查时间序列是否异方差。其中包括以下内容:</p><ul class=""><li id="f917" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu ng nh ni nj bi translated"><a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_white.html#statsmodels.stats.diagnostic.het_white" rel="noopener ugc nofollow" target="_blank">白色测试</a>；</li><li id="a80f" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_breuschpagan.html#statsmodels.stats.diagnostic.het_breuschpagan" rel="noopener ugc nofollow" target="_blank">布鲁赫-帕甘试验</a>；</li><li id="a06d" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated"><a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_goldfeldquandt.html#statsmodels.stats.diagnostic.het_goldfeldquandt" rel="noopener ugc nofollow" target="_blank">戈德菲尔德–Quandt 测试</a></li></ul><p id="ad97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试的主要输入是回归模型的残差(如普通最小二乘法)。零假设是残差以等方差分布。如果 p 值小于显著性水平，我们拒绝这个假设。这意味着时间序列是异方差的。显著性水平通常设置为高达<em class="np"> 0.05 </em>的值。</p><p id="90a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="np"> statsmodels </em> Python 库实现了上述三个测试。下面是一个片段，它将这些封装在一个类中:</p><pre class="kj kk kl km gt nq nr ns bn nt nu bi"><span id="0ff1" class="nv md it nr b be nw nx l ny nz">import pandas as pd<br/>import statsmodels.stats.api as sms<br/>from statsmodels.formula.api import ols<br/><br/>TEST_NAMES = ['White', 'Breusch-Pagan', 'Goldfeld-Quandt']<br/>FORMULA = 'value ~ time'<br/><br/><br/>class Heteroskedasticity:<br/><br/>    @staticmethod<br/>    def het_tests(series: pd.Series, test: str) -&gt; float:<br/>        """<br/>        Testing for heteroskedasticity<br/><br/>        :param series: Univariate time series as pd.Series<br/>        :param test: String denoting the test. One of 'white','goldfeldquandt', or 'breuschpagan'<br/><br/>        :return: p-value as a float.<br/><br/>        If the p-value is high, we accept the null hypothesis that the data is homoskedastic<br/>        """<br/>        assert test in TEST_NAMES, 'Unknown test'<br/><br/>        series = series.reset_index(drop=True).reset_index()<br/>        series.columns = ['time', 'value']<br/>        series['time'] += 1<br/><br/>        olsr = ols(FORMULA, series).fit()<br/><br/>        if test == 'White':<br/>            _, p_value, _, _ = sms.het_white(olsr.resid, olsr.model.exog)<br/>        elif test == 'Goldfeld-Quandt':<br/>            _, p_value, _ = sms.het_goldfeldquandt(olsr.resid, olsr.model.exog, alternative='two-sided')<br/>        else:<br/>            _, p_value, _, _ = sms.het_breuschpagan(olsr.resid, olsr.model.exog)<br/><br/>        return p_value<br/><br/>    @classmethod<br/>    def run_all_tests(cls, series: pd.Series):<br/><br/>        test_results = {k: cls.het_tests(series, k) for k in TEST_NAMES}<br/><br/>        return test_results</span></pre><p id="fd74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类别<em class="np">异方差</em>包含两个函数。函数<em class="np"> het_tests </em>应用了一个特定的测试(White、Breusch-Pagan 或 Goldfeld-Quandt)。函数<em class="np"> run_all_tests </em>一次性应用所有三个测试。这些函数的输出是相应测试的 p 值。</p><p id="4e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何将这些代码应用于图 1 中的时间序列。</p><pre class="kj kk kl km gt nq nr ns bn nt nu bi"><span id="c90d" class="nv md it nr b be nw nx l ny nz">from pmdarima.datasets import load_airpassengers<br/><br/># https://github.com/vcerqueira/blog/blob/main/src/heteroskedasticity.py<br/>from src.heteroskedasticity import Heteroskedasticity<br/><br/>series = load_airpassengers(True)<br/><br/>test_results = Heteroskedasticity.run_all_tests(series)<br/><br/># {'Breusch-Pagan': 4.55e-07,<br/># 'Goldfeld-Quandt': 8.81e-13,<br/># 'White': 4.34e-07}</span></pre><p id="538a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有测试的 p 值都接近于零。所以，你可以拒绝零假设。这些测试为异方差的存在提供了令人信服的证据。</p><p id="c8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是时间序列前半部分和后半部分的残差分布:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4b1605cd61cce8808da0f1e70e3065c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZ-odvKwd5jG0bfUTJWwOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:时间序列前半部分和后半部分的残差分布。图片作者。</p></figure><p id="b46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两部分的残差分布是不同的。Goldfeld-Quandt 检验使用这种类型的分割来检验异方差性。它检查两个数据子样本中残差的方差是否不同。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="19b6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">转换数据</h1><p id="c3df" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">时间序列中异方差的一个常见补救方法是转换数据。对时间序列取对数有助于稳定其可变性。</p><p id="4ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是与之前相同的时间序列，但采用对数标度:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/4e798ead7ed13e871f0114faea8a4402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wam0BtoFbBXrkb3cUNdGYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:与图 1 相似，但采用对数标度。这里，时间序列显示了一段时间内的稳定变化。</p></figure><p id="1aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，这个系列的可变性看起来很稳定。让我们使用对数标度的时间序列重新运行测试:</p><pre class="kj kk kl km gt nq nr ns bn nt nu bi"><span id="9f68" class="nv md it nr b be nw nx l ny nz">import numpy as np<br/><br/>test_results = Heteroskedasticity.run_all_tests(np.log(series))<br/><br/># {'Breusch-Pagan': 0.033,<br/># 'Goldfeld-Quandt': 0.18,<br/># 'White': 0.10}</span></pre><p id="3d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次 p 值更大。只有一个测试(Breusch-Pagan)拒绝了恒定方差的假设。假设显著性水平为<em class="np"> 0.05 </em>。</p><h2 id="04c6" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">恢复日志转换</h2><p id="cf51" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您正在使用经过对数转换的数据进行预测。在这种情况下，您需要将预测恢复到原始比例。这是通过变换的逆变换来完成的，在对数的情况下，您应该使用指数。</p><p id="b71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，预测流程的步骤如下:</p><ol class=""><li id="2d24" class="nb nc it lb b lc ld lf lg li nd lm ne lq nf lu oo nh ni nj bi translated">转换数据以稳定方差；</li><li id="18f8" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu oo nh ni nj bi translated">拟合预测模型；</li><li id="f593" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu oo nh ni nj bi translated">获取预测，并将其还原到原始比例。</li></ol><p id="7910" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。</p><pre class="kj kk kl km gt nq nr ns bn nt nu bi"><span id="7209" class="nv md it nr b be nw nx l ny nz">import numpy as np<br/>from pmdarima.datasets import load_airpassengers<br/>from pmdarima.arima import auto_arima<br/>from sklearn.model_selection import train_test_split<br/><br/>series = load_airpassengers(True)<br/><br/># leaving the last 12 points for testing<br/>train, test = train_test_split(series, test_size=12, shuffle=False)<br/># stabilizing the variance in the train<br/>log_train = np.log(train)<br/><br/># building an arima model, m is the seasonal period (monthly)<br/>mod = auto_arima(log_train, seasonal=True, m=12)<br/><br/># getting the log forecasts<br/>log_forecasts = mod.predict(12)<br/><br/># reverting the forecasts<br/>forecasts = np.exp(log_forecasts)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/c707baf31224df966e29ecef953fac77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-eDvYAX4QbfnE01q6Ng5Nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4:在对转换后的序列建模后，将预测恢复到原始规模。图片作者。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8f75" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外卖</h1><ul class=""><li id="b943" class="nb nc it lb b lc mu lf mv li oq lm or lq os lu ng nh ni nj bi translated">如果方差不是常数，时间序列就是异方差的；</li><li id="c808" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">您可以使用统计测试来测试时间序列是否异方差。这些包括白布鲁希-帕甘试验，或戈德菲尔德-夸特试验；</li><li id="e3fe" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">使用对数变换来稳定方差；</li><li id="c4a4" class="nb nc it lb b lc nk lf nl li nm lm nn lq no lu ng nh ni nj bi translated">不要忘记将预测恢复到原来的比例。</li></ul><p id="f901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，下一个故事再见！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e26a" class="oc md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">进一步阅读</h2><p id="f813" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">[1]圣母大学理查德·威廉斯的幻灯片讲义。<a class="ae ky" href="https://www3.nd.edu/~rwilliam/stats2/l25.pdf" rel="noopener ugc nofollow" target="_blank">https://www3.nd.edu/~rwilliam/stats2/l25.pdf</a></p><p id="12f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] <em class="np"> Statsmodels </em>用于<a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_goldfeldquandt.html#statsmodels.stats.diagnostic.het_goldfeldquandt" rel="noopener ugc nofollow" target="_blank">白色测试</a>、<a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_goldfeldquandt.html#statsmodels.stats.diagnostic.het_goldfeldquandt" rel="noopener ugc nofollow" target="_blank">戈德菲尔德-夸恩特测试</a>和<a class="ae ky" href="https://www.statsmodels.org/stable/generated/statsmodels.stats.diagnostic.het_breuschpagan.html" rel="noopener ugc nofollow" target="_blank">布鲁赫-帕甘测试</a>的文档。</p></div></div>    
</body>
</html>