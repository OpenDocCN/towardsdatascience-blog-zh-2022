<html>
<head>
<title>Cars Efficiency Predictions with PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PyTorch预测汽车效率</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cars-efficiency-predictions-with-pytorch-dd7060477c22#2022-10-18">https://towardsdatascience.com/cars-efficiency-predictions-with-pytorch-dd7060477c22#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/4146087c5774ed108253373adbb97be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*drIGqn10TrzrbIdJ"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@rockstaar_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rock star</a>拍摄</p></figure><div class=""/><div class=""><h2 id="bea6" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">了解如何在PyTorch中构建完整的深度学习管道</h2></div><h2 id="d783" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h2><p id="ce1d" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">众所周知，在过去的几个月里，汽油价格飞涨。由于成本因素和与环境相关的原因，人们正在用汽油加满最低必要量。但是，你有没有注意到，当你在互联网上查找你的汽车从A点到B点应该花多少汽油时，这些数字几乎从来都不符合现实？</p><p id="a06e" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在这篇文章中，我想开发一个简单的模型，可以预测一辆汽车的效率(或消耗)，以每加仑汽油行驶的英里数来衡量。</p><p id="fb67" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">目标是解决管道中的所有步骤，如数据处理、特征工程、培训和评估。</p><p id="f3db" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">所有这些都将使用PyTorch在Python中完成。特别是，我将依赖于Colab笔记本，我总是发现它对这些小项目非常方便！😄</p><h2 id="2aae" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">数据集</strong></h2><p id="e01c" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们将在这个项目中使用的数据集现在是一个里程碑，<a class="ae jd" href="https://archive.ics.uci.edu/ml/datasets/Auto%2BMPG" rel="noopener ugc nofollow" target="_blank"> <em class="mp">来自UCI库</em> </a>的自动MPG数据集。它由<strong class="lt jh"> 9个特征</strong>组成，包含<strong class="lt jh"> 398条记录</strong>。具体来说，变量名及其类型如下:</p><p id="962e" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><em class="mp"> 1。mpg </em>:连续<br/> 2。<em class="mp">气缸</em>:多值离散<br/> 3。<em class="mp">位移</em>:连续<br/> 4。<em class="mp">马力</em>:连续<br/> 5。<em class="mp">重量</em>:连续<br/> 6。<em class="mp">加速</em>:连续<br/> 7。<em class="mp">车型年</em>:多值离散<br/> 8。<em class="mp">原点</em>:多值离散<br/> 9。<em class="mp">汽车名称</em>:字符串(每个实例唯一)</p><h2 id="e464" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我们来编码吧！</h2><p id="cf59" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">首先，我们加载数据集并适当地重命名列。na_values属性用于使pandas识别类型为“？”的数据应被视为null。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7491" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在使用<em class="mp"> df.head() </em>来显示数据集。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">df.head()</p></figure><p id="51ca" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">使用<em class="mp"> df.describe() </em>函数，我们可以显示数据集的一些基本统计数据，以开始了解我们将找到哪些值。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">df.describe()</p></figure><p id="93b3" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">否则，我们可以使用<em class="mp"> df.info() </em>来查看是否有空值，并找出我们的变量的类型。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/9e9646f017b0fd0c9efefd7d497262a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*AEk7u71d4YCqTceTJy-Rwg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">df.inof()(图片由作者提供)</p></figure><p id="296f" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">我们首先看到马力特性包含空值，因此我们可以开始从数据集中删除对应于这些值的记录，并重置dataframe索引，如下所示。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7c00" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在如果我们去打印<em class="mp"> len(df) → 392 </em>，因为我们已经剔除了行。</p><p id="c3cf" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">接下来要做的是将数据集分成训练集和测试集。我们使用一个非常有用的sklearn函数来完成这个任务。让我们接着保存<em class="mp"> df_train.describe()。transpose() </em> table，因为我们将需要一些统计人员对一些特性进行预处理。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="21cd" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><em class="mp">训练统计:</em></p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="ee5d" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">数字特征</h2><p id="3171" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们现在要处理一些特征。我们经常把数字变量和分类变量区别对待。首先，我们从定义我们要归一化的数值变量开始。</p><p id="f532" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">要归一化一个特征，我们需要做的就是减去该特征的平均值，然后除以标准偏差，为此我们需要之前提取的统计数据。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="945b" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">如果我们现在根据原始数据集中的要素绘制归一化要素，您会注意到这些值由于标准化而发生了怎样的变化。那么它们将具有0平均值和1的标准偏差。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/564e55967d2e8515d7cff2ad981f7860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAJ56MdenJB3cE-sF1-Mug.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">标准化(图片由作者提供)</p></figure><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/7b4a1c2455c7ffca0f43416dbfb39c4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gYhxVwVoW13Ux2ziAY8UA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">标准化(图片由作者提供)</p></figure><p id="efa0" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">现在，关于Model_Year特性，我们对特定汽车型号是哪一年制造的并不感兴趣。但也许我们对区间或区间更感兴趣。例如，如果该型号是在73 '和76 '之间制造的，则该汽车是类型1。这些范围有点随意，您可以尝试更多的范围，看看哪个效果最好。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c32d0ae53865a5300be9c29f89197471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*R_kDPOApOU-mk6YMml26og.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">垃圾箱范围(图片由作者提供)</p></figure><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="637f" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">分类特征</strong></h2><p id="769e" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">就范畴特征而言，我们基本上有两种主要方法。第一种是使用<strong class="lt jh"> one-hot vectors </strong>将类别(字符串)转换成只包含一个1的二进制向量。例如，零类别将被编码为[1，0，0，0]，类别1将被编码为[0，1，0，0]，等等。</p><p id="3c07" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">否则，我们可以使用一个<strong class="lt jh">嵌入</strong>层，将每个类别映射到一个可以训练的<em class="mp">‘随机’</em>向量，这样我们就可以得到一个类别的向量表示，它可以管理大量的信息。</p><p id="609e" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><strong class="lt jh">当类别数量很大时，使用有限大小的嵌入会有很大的优势。</strong></p><p id="def0" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">在这种情况下，我们使用独热编码。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1502" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">让我们也提取我们需要预测的标签。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="0c08" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">PyTorch数据集和数据加载器</h2><p id="b4a9" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">现在我们的数据已经准备好了，我们创建一个<strong class="lt jh">数据集</strong>以便在训练期间更好地管理我们的批次。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="a2e2" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模型创建</h2><p id="3fdd" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们构建了一个小网络，它有两个隐藏层，一个是8个神经元，一个是4个神经元。</p><figure class="mq mr ms mt gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi na"><img src="../Images/1e8e88f67a6391bdfa80be6fda7a3af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIBmza8q7byHsOP7gRD_ew.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">模型(图片由作者提供)</p></figure><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h2 id="40ba" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">培养</h2><p id="ef58" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">现在我们定义损失函数，我们将使用<strong class="lt jh"> MSE </strong>和<strong class="lt jh">随机梯度下降</strong>作为优化器。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="de63" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated">为了预测新的数据点，我们可以将测试数据提供给模型。</p><figure class="mq mr ms mt gt is"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="3a8c" class="nb kw jg bd kx nc nd ne la nf ng nh ld km ni kn lh kp nj kq ll ks nk kt lp nl bi translated">最后的想法</h1><p id="79b5" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在这篇短文中，我们看到了如何使用PyTorch解决现实生活中的问题。我们从做一些EDA开始，以了解我们手上有什么样的数据集。然后，我向您展示了在预处理阶段如何区别对待数值变量和分类变量。将列值拆分成多个仓的技术被广泛使用。然后我们看到PyTorch如何允许我们用很少的步骤创建一个自定义数据集，我们可以逐批迭代。我们创建的模型是一个非常简单的模型，只有几层，但是使用正确的损失函数和适当的优化器可以让我们快速地训练我们的网络。我希望这篇文章对发现(或回顾)PyTorch的一些特性有所帮助。</p><h1 id="9014" class="nb kw jg bd kx nc nd ne la nf ng nh ld km ni kn lh kp nj kq ll ks nk kt lp nl bi translated">结束了</h1><p id="de71" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><em class="mp">马赛洛·波利蒂</em></p><p id="46c2" class="pw-post-body-paragraph lr ls jg lt b lu mk kh lw lx ml kk lz le mm mb mc li mn me mf lm mo mh mi mj ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/marcello-politi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，<a class="ae jd" href="https://twitter.com/_March08_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae jd" href="https://march-08.github.io/digital-cv/" rel="noopener ugc nofollow" target="_blank"> CV </a></p></div></div>    
</body>
</html>