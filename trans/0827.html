<html>
<head>
<title>A Python framework for solving boundary value problems using orthogonal collocation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用正交配置求解边值问题的 Python 框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-python-framework-for-solving-boundary-value-problems-using-orthogonal-collocation-705dfeec106b#2022-03-07">https://towardsdatascience.com/a-python-framework-for-solving-boundary-value-problems-using-orthogonal-collocation-705dfeec106b#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e034" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个高效直观的框架，包含两个简单的示例和一个复杂的实际应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/88e5a4bf57184b4d6b458574263238e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YF3BTnw4WZXX58TE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@dollargill?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">美元吉尔</a>拍摄的照片</p></figure><p id="f9f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> T </span>我第一次读到“正交配置”这个表达是在 Lee &amp; Froment (2008)关于苯乙烯反应器建模的文章中。原来二阶微分方程系统出现在许多工程课题中，大多与输运现象有关。因此，解决这些问题的方法在实践中非常有用。一旦一个过程被数学描述，它可以是数值优化问题的对象，在这种情况下，通常与过程设计和控制有关。</p><p id="6864" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这些内容激发了你的兴趣，看看所用 Python 框架的<a class="ae kv" href="https://github.com/bruscalia/collocation.git" rel="noopener ugc nofollow" target="_blank">代码库</a>，也可以在<a class="ae kv" href="https://www.researchgate.net/publication/358914432_A_Python_module_to_solve_boundary_value_problems_using_orthogonal_collocation" rel="noopener ugc nofollow" target="_blank"> ResearchGate </a>上找到。</p><p id="bfcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正交配置是由 Villadsen 和 Stewart (1967)提出的，对于求解如下所示的方程组非常有用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/8a99723c399bb0864ebdbc4ed8108f97.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*Jfd6wGZvGarE9URgjIFhvQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">二阶微分方程的基本系统。(图片由作者提供)。</p></figure><p id="c8fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案背后的数学可能非常复杂，但是，如果您可以像这样用适当的边界条件来制定您的方程组，我相信正交分配(python 框架)可以创造一些奇迹。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="98f9" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">示例 1</h1><p id="771b" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">让我们从只有一个因变量<em class="ng"> y. </em>的简单二阶问题开始</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/f8f2dd0aeb8d966a1bed475452a81372.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*2zyON3LMiKoMcoMmEnSHAQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">例 1 的方程式。(图片由作者提供)。</p></figure><p id="552f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从导入框架的主类开始，<em class="ng">正交分配</em>。</p><pre class="kg kh ki kj gt ni nj nk bn nl nm bi"><span id="3021" class="nn mk iq nj b be no np l nq nr">from collocation import OrthogonalCollocation</span></pre><p id="d694" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们必须创建一个在内部点返回零的函数和另一个在表面边界返回零的函数(因为<em class="ng"> x </em>中的原点被假定为对称条件)。两者都可以是<em class="ng"> x，y，y’，y”</em>的线性或非线性函数。</p><pre class="kg kh ki kj gt ni nj nk bn nl nm bi"><span id="3921" class="nn mk iq nj b be no np l nq nr">def fun_1(x, y, dy, d2y, k):<br/>    return d2y[0] + k * y[0] + 1<br/><br/>def bc_1(x, y, dy, d2y, k):<br/>    return dy[0] - 1</span></pre><p id="6aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在定义了函数之后，这个过程就差不多完成了，我们只用三行代码就可以解决这个问题(可能只有两行)。我在这里使用了<em class="ng"> k </em> =1，但是我们可以尝试不同的数字。请随意下载我的代码库中的<a class="ae kv" href="https://github.com/bruscalia/collocation/blob/main/notebooks/example_collocation.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a>，并尝试不同的功能。注意，当执行搭配时，<em class="ng"> scipy.optimize.root </em>用于求解问题中隐含的非线性方程组。<em class="ng">配置</em>中的所有附加关键字都被传递给<em class="ng">根</em>。</p><pre class="kg kh ki kj gt ni nj nk bn nl nm bi"><span id="b422" class="nn mk iq nj b be no np l nq nr">n_points = 6<br/><br/># Create problem<br/>problem_1 = OrthogonalCollocation(fun_1, bc_1, n_points, 1, x0=0.0, x1=1.0)<br/><br/># Initial estimation<br/>y01 = np.zeros([1, n_points + 1])<br/><br/># Collocation using scipy.optimize.root in backend<br/>problem_1.collocate(y01, args=k, method="hybr", tol=1e-6)</span></pre><p id="c986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在准备好了！配置点存储在我们的实例<em class="ng"> problem_1 的属性<em class="ng"> y </em>中。</em>它的形状是(<em class="ng"> m </em>，<em class="ng"> n </em>)，所以每行对应一个不同的变量，列对应不同的搭配点。我们还可以计算其他坐标的<em class="ng"> y </em>的插值多项式值，而不仅仅是配置点。为此，我将从我们的问题实例中使用<em class="ng">插值</em>方法。</p><p id="fb58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们绘制结果，并将它们与对等解算器<em class="ng">scipy . integrate . solve _ BVP</em>获得的结果进行比较，以确保框架运行良好。</p><pre class="kg kh ki kj gt ni nj nk bn nl nm bi"><span id="cb54" class="nn mk iq nj b be no np l nq nr">fig, ax = plt.subplots(figsize=[6, 4], dpi=200)<br/>x = np.linspace(0, 1, 50)<br/>ax.plot(x, problem_1.interpolate(x)[0], color="indigo", alpha=0.5, linestyle=":")<br/>ax.plot(problem_1.x, problem_1.y[0], color="indigo", marker=".", label="OC", linestyle=" ")<br/>ax.plot(res_scipy1.x, res_scipy1.y[0], color="green", alpha=0.5, linestyle=":", label="scipy")<br/>ax.set_ylabel("y")<br/>ax.set_xlabel("x")<br/>ax.legend()<br/>fig.tight_layout()<br/>plt.show()</span></pre><p id="2829" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/ceedbf6cae0e9ef858a386658101af66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYaqdzfrWnKUEmuHWcNz_A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">搭配举例 1。(图片由作者提供)。</p></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="0f5b" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">示例 2</h1><p id="9dfa" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">一个只有一个因变量的例子效果很好。在本节中，让我们尝试一个带有非线性项的方程组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/ea9f4d2c77ad47eb7a681a5893eb78e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*VHjLpEmf9cLCSc1Je0UDHQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">例 2 的方程式。(图片由作者提供)。</p></figure><p id="4e9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们再次公式化方程:</p><pre class="kg kh ki kj gt ni nj nk bn nl nm bi"><span id="6b51" class="nn mk iq nj b be no np l nq nr">def fun_2(x, y, dy, d2y, k1, k2):<br/>    return np.array([d2y[0] + k1 * y[1] + 1, d2y[1] + k2 * np.log(1 + y[0])])<br/><br/>def bc_2(x, y, dy, d2y, k1, k2):<br/>    return np.array([y[0], y[1] - 1])</span></pre><p id="b4c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里用<em class="ng"> k1 </em> =1 和<em class="ng"> k2 </em> =-1，让它更有挑战性。同样的第二步…</p><pre class="kg kh ki kj gt ni nj nk bn nl nm bi"><span id="8b87" class="nn mk iq nj b be no np l nq nr">problem_2 = OrthogonalCollocation(fun_2, bc_2, n_points, 1, x0=0.0, x1=1.0)<br/><br/>y02 = np.zeros([2, n_points + 1])<br/><br/>problem_2.collocate(y02, args=(k1, k2), method="hybr", tol=1e-6)</span></pre><p id="5403" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/06f2a9c0b035b4cec21fef7479e8b484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BDFNUGd_ODHuJQNACcylqQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">搭配举例 2。(图片由作者提供)。</p></figure><p id="4644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">求解器又一次返回了很好的结果！</p><p id="1544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，让我们尝试一个复杂的现实世界的问题。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="ff1f" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">苯乙烯反应器问题</h1><p id="0462" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">记得我提到过苯乙烯反应器吗？因此，我在这个问题上已经工作了一段时间，我已经能够开展一项有见地的研究，其中正交配置用于模拟颗粒内扩散。我相信这可以为真实世界的应用程序提供一个很好的例子。</p><p id="fa28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦基本方程能够描述该过程，该模型就可以预测在不同条件下(例如温度和压力)有多少过程输入(反应物)被转化成期望的输出(苯乙烯)。然后，它是一个优化任务的目标“什么是将输入转换成期望输出的最适当的操作条件？”。</p><p id="a35b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您对细节感兴趣，我邀请您看一下文章<a class="ae kv" href="https://doi.org/10.1016/j.ces.2021.116805" rel="noopener ugc nofollow" target="_blank"> <em class="ng">【基于多相动力学模型</em> </a> <em class="ng">的乙苯脱氢制苯乙烯轴流和径向反应器的模拟与优化】。</em></p><p id="6e9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单来说(尽可能)，存在扩散问题，催化剂颗粒内部的反应物浓度与表面不同，有效反应速率也不同，因此我们必须计算反应的<em class="ng">有效性</em> <em class="ng">因子</em>。</p><p id="0b79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" href="https://github.com/bruscalia/collocation/blob/main/notebooks/example_collocation.ipynb" rel="noopener ugc nofollow" target="_blank">示例笔记本</a>中，我测试了不同数量的搭配点，详细描述了方程，并将结果与 scipy 进行了比较。对于一篇短文来说，完整的公式是相当长的，所以我将在这里展示不同数量的搭配点的主要结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/a26151193f401e611a5d30f1416965a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIrMW_8qLSN-ldpIe6iTFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用不同配置点数的正交配置法计算催化剂颗粒内的苯乙烯分压。(图片由作者提供)。</p></figure><p id="9124" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，三个配点产生的结果已经非常精确，六个配点的结果几乎等于九个。与基准测试<em class="ng">scipy . integrate . solve _ BVP</em>相比，所有这些结果花费的计算时间不到四分之一…</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="bb56" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="7e35" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">用 Python 开发了一个简单而健壮的框架，用正交配置法求解对称边值问题。它易于使用，并通过了同行解决方案的验证。实现了一个复杂的真实世界的问题，其中用很少的配点结果是非常准确的。这个框架可以在这个<a class="ae kv" href="https://github.com/bruscalia/collocation" rel="noopener ugc nofollow" target="_blank"> GIT </a>仓库中获得。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="1179" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">参考</h1><p id="c3c4" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">李伟杰和弗罗蒙特，G. F .，2008。乙苯脱氢制苯乙烯:动力学模型和反应器模拟。<em class="ng">印度。英语。化学。第 47(23)卷，第 9183-9194 页。</em></p><p id="61d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">莱特，b，科斯塔，A. O. S .和科斯塔少年，E. F .，2021。基于非均相动力学模型的乙苯脱氢轴向流和径向流反应器的模拟与优化。<em class="ng">化学。英语。Sci。，</em>第 244 卷，第 116805 页。</p><p id="e564" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">维拉森，j .和斯图尔特，W. E .，1967 年。用正交配置法解边值问题。化学。英语。Sci。，第 22 卷第 11 期，第 1501—1483 页。</p></div></div>    
</body>
</html>