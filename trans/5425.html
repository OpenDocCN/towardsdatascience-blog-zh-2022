<html>
<head>
<title>Color Segmentation with K-means Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于 K-均值聚类的颜色分割</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/image-color-segmentation-by-k-means-clustering-algorithm-5792e563f26e#2022-12-06">https://towardsdatascience.com/image-color-segmentation-by-k-means-clustering-algorithm-5792e563f26e#2022-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a74c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用轮廓和 K-means 聚类，根据颜色识别和量化图像中的对象的详细指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6140fb0c399ee4a3e21f1376c3ba30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mAXPfNA-cLMCSCJBqMqBQ.png"/></div></div></figure><p id="d2a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">简介</strong></p><p id="14b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">颜色分割是计算机视觉中使用的一种技术，用于根据颜色来识别和区分图像中的不同对象或区域。聚类算法可以自动将相似的颜色分组在一起，而无需为每种颜色指定阈值。当处理具有大范围颜色的图像时，或者当事先不知道精确的阈值时，这可能很有用。</p><p id="c189" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将探讨如何使用 K-means 聚类算法来执行颜色分割，并计算每种颜色的对象数量。我们将使用“泡泡射手”游戏中的一幅图像作为例子，通过它们的轮廓找到并过滤泡泡对象，并应用 K-means 算法将具有相似颜色的泡泡分组在一起。这将允许我们计数和提取具有相似颜色的气泡的掩模，用于进一步的下游应用。我们将使用<code class="fe ln lo lp lq b">OpenCV</code>和<code class="fe ln lo lp lq b">scikit-learn</code>库进行图像分割和颜色聚类。</p><h2 id="d258" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated"><strong class="ak">用阈值法提取二值掩模</strong></h2><p id="b8ef" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">第一步是从背景中提取所有的气泡。为此，我们将首先使用<code class="fe ln lo lp lq b">cv2.cvtColor()</code>函数将图像转换为灰度，然后使用<code class="fe ln lo lp lq b">cv2.threshold()</code>将其转换为二值图像，其中像素为 0 或 255。阈值设置为 60，因此所有低于 60 的像素设置为 0，其他像素设置为 255。由于一些气泡在二值图像上有轻微的重叠，我们使用<code class="fe ln lo lp lq b">cv2.erode()</code>函数来分离它们。腐蚀是一种形态学操作，可以缩小图像中对象的大小。它可以用来消除小的白噪声，也可以用来分离连接的对象。</p><pre class="kg kh ki kj gt mp lq mq bn mr ms bi"><span id="3fad" class="mt ls iq lq b be mu mv l mw mx">image = cv2.imread(r'bubbles.jpeg', cv2.IMREAD_UNCHANGED)<br/>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br/>_ , mask = cv2.threshold(gray, 60, 255, cv2.THRESH_BINARY)<br/>mask = cv2.erode(mask, np.ones((7, 7), np.uint8))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/e46796d2b97e0cf1203a8a9ab14647a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xg1xaYJ8XVfI28LNBrImyw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">左:输入图像。右图:二进制图片|作者图片</p></figure><h2 id="a31f" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated"><strong class="ak">使用轮廓提取物体边界</strong></h2><p id="70b5" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">下一步是在二进制图像中查找对象。我们在二值图像上使用<code class="fe ln lo lp lq b">cv2.findContours()</code>函数来检测物体的边界。轮廓被定义为在图像中形成对象边界的连续曲线。当<em class="nd"> cv2。使用 RETR _ 外部</em>标志，仅返回最外面的轮廓。该算法输出轮廓列表，每个轮廓代表图像中单个对象的边界。</p><pre class="kg kh ki kj gt mp lq mq bn mr ms bi"><span id="9aa9" class="mt ls iq lq b be mu mv l mw mx">contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span></pre><h2 id="4dec" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated"><strong class="ak">过滤轮廓并提取平均颜色</strong></h2><p id="79aa" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">为了移除不代表气泡的轮廓，我们将迭代得到的轮廓，并且仅选择那些具有大面积(大于 3000 像素)的轮廓。这将允许我们分离气泡的轮廓，并丢弃任何较小的对象，如字母或背景的一部分。</p><pre class="kg kh ki kj gt mp lq mq bn mr ms bi"><span id="7c45" class="mt ls iq lq b be mu mv l mw mx">filtered_contours = []<br/>df_mean_color = pd.DataFrame()<br/>for idx, contour in enumerate(contours):<br/>    area = int(cv2.contourArea(contour))<br/><br/>    # if area is higher than 3000:<br/>    if area &gt; 3000:<br/>        filtered_contours.append(contour)<br/>        # get mean color of contour:<br/>        masked = np.zeros_like(image[:, :, 0])  # This mask is used to get the mean color of the specific bead (contour), for kmeans<br/>        cv2.drawContours(masked, [contour], 0, 255, -1)<br/><br/>        B_mean, G_mean, R_mean, _ = cv2.mean(image, mask=masked)<br/>        df = pd.DataFrame({'B_mean': B_mean, 'G_mean': G_mean, 'R_mean': R_mean}, index=[idx])<br/>        df_mean_color = pd.concat([df_mean_color, df])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/d51965c6c96361aea590d654de12fc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oj7AYqiN6Yznwm0VC3Q_nA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">过滤前(左)和过滤后(右)二值图像上的绿色等高线|作者的图像</p></figure><p id="0cfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了找到每个气泡的平均颜色，我们将首先通过在黑色图像上绘制白色轮廓来为每个气泡创建一个遮罩。然后，我们将使用原始图像和气泡的遮罩，使用<code class="fe ln lo lp lq b">cv2.mean()</code>函数来计算气泡的平均蓝色、绿色和红色(BGR)通道值。每个气泡的平均 BGR 值存储在熊猫数据帧中。</p><h2 id="5281" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated"><strong class="ak">用 K-means 算法对相似颜色进行聚类</strong></h2><p id="9b3c" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">最后，我们将应用 K-means 聚类算法将具有相似颜色的气泡分组在一起。我们将使用轮廓的平均颜色值作为来自<code class="fe ln lo lp lq b">sklearn</code>库的<code class="fe ln lo lp lq b">KMeans</code>算法的输入数据。<code class="fe ln lo lp lq b">n_clusters</code>超参数指定算法要创建的聚类数。在这种情况下，由于有 6 个气泡颜色，我们将设置值为 6。</p><p id="651a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">K-means 算法是一种流行的聚类方法，可用于将相似的数据点分组在一起。该算法的工作原理是将一组数据点作为输入，并将它们分成指定数量的聚类，每个聚类由一个质心表示。质心被初始化为数据空间内的随机位置，并且该算法迭代地将每个数据点分配给由最近质心表示的聚类。一旦所有数据点都被分配给一个聚类，质心就被更新为数据点在其聚类中的平均位置。重复该过程，直到质心收敛到稳定位置，并且数据点不再被重新分配给不同的聚类。通过使用以每个气泡的平均 BGR 值作为输入的 K-means 算法，我们可以将具有相似颜色的气泡分组在一起。</p><p id="55d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦初始化了<code class="fe ln lo lp lq b">KMeans</code>类，就会调用<code class="fe ln lo lp lq b">fit_predict</code>方法来执行聚类。<code class="fe ln lo lp lq b">fit_predict</code>方法返回每个对象的分类标签，然后将这些标签分配给数据集中一个新的“标签”列。这允许我们识别哪些数据点属于哪个聚类。</p><pre class="kg kh ki kj gt mp lq mq bn mr ms bi"><span id="7b3b" class="mt ls iq lq b be mu mv l mw mx">km = KMeans( n_clusters=6)<br/>df_mean_color['label'] = km.fit_predict(df_mean_color)</span></pre><p id="147a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后定义<code class="fe ln lo lp lq b">draw_segmented_objects</code>函数，用相同颜色的气泡创建一个新的蒙版图像。这是通过首先创建一个二进制蒙版来实现的:具有相同标签的所有气泡的轮廓在黑色图像上以白色绘制。然后，使用来自<code class="fe ln lo lp lq b">cv2</code>的<code class="fe ln lo lp lq b">bitwise_and</code>函数将原始图像与蒙版结合，产生一个只有相同标签的气泡可见的图像。为方便起见，使用<code class="fe ln lo lp lq b">cv2.putText()</code>功能将每种颜色的气泡数量绘制在图像上。</p><pre class="kg kh ki kj gt mp lq mq bn mr ms bi"><span id="bb72" class="mt ls iq lq b be mu mv l mw mx">def draw_segmented_objects(image, contours, label_cnt_idx, bubbles_count):<br/>    mask = np.zeros_like(image[:, :, 0])<br/>    cv2.drawContours(mask, [contours[i] for i in label_cnt_idx], -1, (255), -1)<br/>    masked_image = cv2.bitwise_and(image, image, mask=mask)<br/>    masked_image = cv2.putText(masked_image, f'{bubbles_count} bubbles', (200, 1200), cv2.FONT_HERSHEY_SIMPLEX,<br/>                        fontScale = 3, color = (255, 255, 255), thickness = 10, lineType = cv2.LINE_AA)<br/>    return masked_image</span></pre><p id="436a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为每组具有相同标签的气泡调用<code class="fe ln lo lp lq b">draw_segmented_objects</code>函数，为每种颜色生成一幅蒙版图像。每种颜色中珠子的数量可以通过在数据帧按颜色分组后计数数据帧中的行数来确定。</p><pre class="kg kh ki kj gt mp lq mq bn mr ms bi"><span id="6e32" class="mt ls iq lq b be mu mv l mw mx">img = image.copy()<br/>for label, df_grouped in df_mean_color.groupby('label'):<br/>    bubbles_amount = len(df_grouped)<br/>    masked_image = draw_segmented_objects(image, contours, df_grouped.index, bubbles_amount)<br/>    img = cv2.hconcat([img, masked_image])<br/><br/>plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB) )</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6140fb0c399ee4a3e21f1376c3ba30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_mAXPfNA-cLMCSCJBqMqBQ.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">原始图像(左)沿着每种颜色的分段图像|图像作者</p></figure><h2 id="daaf" class="lr ls iq bd lt lu lv dn lw lx ly dp lz la ma mb mc le md me mf li mg mh mi mj bi translated"><strong class="ak">结束语</strong></h2><p id="ca7e" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">使用 K-均值聚类进行颜色分割是一种基于颜色识别和量化图像中对象的强大工具。在本教程中，我们演示了如何使用 K-means 算法以及 OpenCV 和 scikit-learn 来执行颜色分割并计算图像中每种颜色的对象数量。这种技术可以应用于各种需要根据颜色对图像中的对象进行分析和分类的场景。</p><p id="27f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nd">为了您的方便，我们提供了一个包含完整代码的用户友好的 Jupiter 笔记本:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="44d1" class="ng ls iq bd lt nh ni nj lw nk nl nm lz jw nn jx mc jz no ka mf kc np kd mi nq bi translated">感谢您的阅读！</h1><p id="2eda" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated"><strong class="kt ir">想了解更多？</strong></p><ul class=""><li id="f2db" class="nr ns iq kt b ku kv kx ky la nt le nu li nv lm nw nx ny nz bi translated"><a class="ae oa" href="https://medium.com/@lihigurarie" rel="noopener"> <strong class="kt ir">探索</strong> </a>我写的附加文章</li><li id="d318" class="nr ns iq kt b ku ob kx oc la od le oe li of lm nw nx ny nz bi translated"><a class="ae oa" href="https://medium.com/@lihigurarie/subscribe" rel="noopener"> <strong class="kt ir">订阅</strong> </a> <strong class="kt ir"> </strong>在我发表文章时得到通知</li><li id="c8ed" class="nr ns iq kt b ku ob kx oc la od le oe li of lm nw nx ny nz bi translated">在<a class="ae oa" href="https://www.linkedin.com/in/lihi-gur-arie/" rel="noopener ugc nofollow" target="_blank">上关注我<strong class="kt ir"> Linkedin </strong>上关注我</a></li></ul></div></div>    
</body>
</html>