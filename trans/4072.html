<html>
<head>
<title>A Study of the Most Famous Random Number Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最著名的随机数发生器研究</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-study-of-the-most-famous-random-number-generator-13925cd55783#2022-09-09">https://towardsdatascience.com/a-study-of-the-most-famous-random-number-generator-13925cd55783#2022-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释线性同余生成器及其缺点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a7567a1d23e1bd6f95dcb2880de3e32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ws0J2iSrjro3_YxQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@edge2edgemedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edge2Edge媒体</a>拍摄</p></figure><p id="3887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你从事编程已经有一段时间了，那么你很可能在某个项目中从事过随机数生成的工作。</p><p id="bd15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我第一次在程序中使用随机数时，我没有质疑随机数生成是如何工作的。我一直假设生成的数字是真正随机抽取的。</p><p id="aa1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，一个简单的想法就可以提出这个问题。</p><p id="5ed6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任何程序都是由特定的指令序列组成的。如果我们向它提供一个输入，我们每次提供那个输入都会得到相同的输出。我们称这个属性为<strong class="ky ir">决定论</strong>。试图用程序生成随机数是试图从确定性工具中获得随机行为，这有点自相矛盾...</p><p id="6657" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">意识到用计算机不可能得到一个真正的随机数生成器，研究人员有了一个想法:得到看起来随机的序列就足够了。</p><p id="1d7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">毕竟，<em class="ls">没有人能够说出一个数字序列是否是随机抽取的</em>。只要每个数字都落在生成器正在处理的范围内，总是有非零的概率得到我们能想到的任何数字序列。</p><p id="345a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，随机数生成器可能会连续一千次返回相同的数字。概率确实低，但是<em class="ls">还是有可能的</em>。</p><p id="0c8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">普通人不会对连续几次返回相同数字的随机数发生器满意，也不会对如下序列满意:</p><ul class=""><li id="b383" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi">3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; …</li><li id="a1cc" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi">2 -&gt; 6 -&gt; 18 -&gt; 54 -&gt; 162 -&gt; …</li><li id="1f5c" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi">2 -&gt; 4 -&gt; 16 -&gt; 256 -&gt; 65536 -&gt; …</li></ul><p id="8dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样的例子有哪些共同点让我们不满足？它们有一个<em class="ls">易于检测的</em>图案。</p><p id="9d4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能会让你吃惊，但是你知道大多数随机生成器并不比这更复杂吗？</p><p id="e094" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直到最近还被广泛使用的最著名的随机数发生器并不返回前一个数的增量、乘以3或平方，而是执行以下操作:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/98fa74d62bebdd50f0cff3016519e003.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*wZSV8NyEO28VaylDf9nU3w.png"/></div></figure><p id="85be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<strong class="ky ir"> <em class="ls"> a </em> </strong>和<strong class="ky ir"> <em class="ls"> b </em> </strong>都是选择的常量。<strong class="ky ir"> <em class="ls"> M </em> </strong>定义了我们生成的数字的范围。</p><p id="e1ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用此功能，我们能够生成如下序列:</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="217b" class="mn mo iq mj b gy mp mq l mr ms">72 -&gt; 5 -&gt; 614 -&gt; 37 -&gt; 140 -&gt; …</span></pre><p id="9092" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为用户，我们在这个序列中看不到任何模式。所以我们可以说它是随机的。如果有人对这个函数足够熟悉，这可能是一种模式，让他们说这个序列可能是用这个特定的函数绘制的。</p><p id="9fee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个随机数发生器被称为<em class="ls">线性同余发生器</em>。</p><p id="f47c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的章节中，我们将讨论<em class="ls">这个随机发生器</em>有多糟糕，并尝试改进它。</p><h1 id="c72d" class="mt mo iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">线性同余发生器是好的随机发生器吗？</h1><p id="d31a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">为了评估随机数生成器的质量，我们将使用两种可视化效果:<strong class="ky ir">位图</strong>和<strong class="ky ir">随机漫步</strong>。这两种方法都评估我们生成的数字的特定位。</p><p id="2f19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们先通过固定<strong class="ky ir"><em class="ls">a</em></strong><strong class="ky ir"><em class="ls">b</em></strong><strong class="ky ir"><em class="ls">M</em></strong>来选择一个直线发电机。已经证明，最佳线性同余生成器满足以下条件:</p><ol class=""><li id="ad86" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr np lz ma mb bi translated"><strong class="ky ir"> <em class="ls"> M </em> </strong>和<strong class="ky ir"> <em class="ls"> b </em> </strong>互质</li><li id="8529" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr np lz ma mb bi translated"><strong class="ky ir"> <em class="ls"> a-1 </em> </strong>能被<strong class="ky ir"> <em class="ls"> M </em> </strong>的所有质因数整除</li><li id="6ab6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr np lz ma mb bi translated"><strong class="ky ir"> <em class="ls"> a-1 </em> </strong>能被<strong class="ky ir"> <em class="ls"> 4 </em> </strong>整除如果<strong class="ky ir"> <em class="ls"> M </em> </strong>能被<strong class="ky ir"> <em class="ls"> 4 </em> </strong>整除</li></ol><p id="f413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为函数<em class="ls">和</em>选择C语言中使用过的值(显然满足上述条件)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e9cde89e137ca4329e118fca4cb2e08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*iEULDms5zyovOOhlVhwcOw.png"/></div></figure><p id="372e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最高有效位</strong> <strong class="ky ir">位</strong>的位图给出如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a4fb445ef6ad8dacb0ca19e36e9f8900.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*LcfIErhSB74X7dUAmVJo4w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最高有效位的位图</p></figure><p id="9ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个生成数<strong class="ky ir"> <em class="ls"> Xn+1 </em> </strong>由一个像素表示。如果数字的最高有效位等于0，则该像素为黑色，否则为白色。</p><p id="a560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">位图确实是随机的，我们没有任何模式。</p><p id="9435" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看2D随机漫步给出了什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/be6889514b3dd4e5d02f1c5f2b416934.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/1*Fh4S2CusccT1A5YpRSDgQw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用第31位和第30位的随机游走</p></figure><p id="558f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过2D随机游走，我们同时评估2位。两位给<strong class="ky ir"> <em class="ls">四个</em> </strong>可能值。基于该值，我们在四个 方向<em class="ls">上、下、左、右</em>中的一个方向上移动。这里我们评估的是<strong class="ky ir"> <em class="ls"> Xn+1 </em> </strong>的两个最高有效位(<em class="ls">第31位和第30位</em>)。</p><p id="0b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随机漫步看起来真的是随机的，没有任何模式。我们可以说这是一个很好的随机数生成器吗？在评估其他位之前。</p><p id="ac81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来评价一下中间的，比如15号。以下是该位的位图和随机游走。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6028bd9da4c753ac2cc3b1a32e76889a.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*XFxlrOw8nFGA5Ajp8_S8lg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第15位位图</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f1cd8f9a9cb5375b88408b1f65b1c803.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/1*WSytw6t90SDHYau_hi-XJQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用第15和第16位的随机游走</p></figure><p id="a340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次情况不同，我们可以看到一些模式。在位图中，你可以看到一些相同颜色的线条。在随机漫步中，你可以看到这个形状在一个对角线轴上是对称的，并且永远重复...对于所谓的“随机”行为来说，这不是好消息。</p><p id="5dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看第一位(最右边的位)会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6009f08f42be6cd97c67db4008fee6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*XPvLeIU9LosRdU1ZVkul3A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第一位位图</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1ae8b1368b7ffd9481be0bb1e0b72acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/1*qFyKxb5A1UbfVIYTk63yzg.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用第1和第2位的随机游走</p></figure><p id="3da1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这两个结果中没有<em class="ls">什么</em>随机。如果放大位图，会发现黑白像素交替出现。在随机漫步中，它会<em class="ls">上、下、右、左</em>，并且永远重复。为什么会这样？</p><p id="aed1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一位是奇偶校验位，它表示数字是奇数还是偶数。如果你用这个随机数发生器产生任意的<strong class="ky ir"><em class="ls"/></strong>序列，你会看到<em class="ls">每个奇数后面跟着一个偶数，每个偶数后面跟着一个奇数，</em>就像我们在本文前面看到的序列。因此，第一位在值0和1之间交替。这解释了位图图形。对于随机游走，方向由第一位和第二位决定。正如我们将在接下来的章节中看到的，在四个步骤<em class="ls">之后有一个循环。</em></p><p id="146e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对剩下的比特做同样的操作，你会得出结论，当我们向右移动比特时，模式变得更清晰，随机性变得更差。</p><p id="6fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一节中，我们将研究为什么会发生这种情况。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="f66a" class="mt mo iq bd mu mv nz mx my mz oa nb nc jw ob jx ne jz oc ka ng kc od kd ni nj bi translated">第一点有什么问题</h1><p id="883a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">利用线性同余发生器，<strong class="ky ir"> <em class="ls"> X{n+1} </em> </strong>的第一位仅由<strong class="ky ir"> <em class="ls"> a </em> </strong>、<em class="ls"> </em> <strong class="ky ir"> <em class="ls"> Xn </em> </strong>和<strong class="ky ir"> <em class="ls"> b </em> </strong>的第一位决定。对于奇数<strong class="ky ir"> <em class="ls"> a </em> </strong>和奇数<strong class="ky ir"> <em class="ls"> b </em> </strong>，我们从等式得到:</p><ul class=""><li id="4432" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><strong class="ky ir">如果</strong> <em class="ls"> Xn </em>是奇数<strong class="ky ir">那么</strong> <em class="ls"> X{n+1} </em>是偶数</li><li id="47bc" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir">如果</strong> <em class="ls"> Xn </em>是偶数<strong class="ky ir">那么</strong> <em class="ls"> X{n+1} </em>是奇数</li></ul><p id="42fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这证明了上一节中位图的结果。</p><p id="1681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，也许不同的奇偶校验<strong class="ky ir"> <em class="ls"> a </em> </strong>或<strong class="ky ir"> <em class="ls"> b </em> </strong>可以解决第一位的问题？让我们看看下表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/adf6a4a25e47aae62cbd2b7cb5678503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PIbC3hWbvkkkdXB3kt4Qwg.png"/></div></div></figure><p id="e36a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个表中，只有奇数<strong class="ky ir"> <em class="ls"> a </em> </strong>和奇数<strong class="ky ir"> <em class="ls"> b </em> </strong>能够给我们所有可能的数字。因此，我们不能做得比我们得到的结果更好。我们说第一位的<strong class="ky ir">周期</strong>长度为<em class="ls">2，</em>因为我们有一个长度为2的序列，它永远重复。</p><h1 id="e376" class="mt mo iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">第二点怎么样</h1><p id="e876" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">类似地，让我们检查<strong class="ky ir"><em class="ls"/></strong>和<strong class="ky ir"> <em class="ls"> b </em> </strong>上的条件，这些条件允许获得第二位的所有可能值。这一次，<strong class="ky ir"> <em class="ls"> X{n+1} </em> </strong>的第二位同时取决于<strong class="ky ir"> <em class="ls"> a </em> </strong>、<strong class="ky ir"> <em class="ls"> b </em> </strong>、<strong class="ky ir"> <em class="ls"> Xn </em> </strong>的第一位和第二位。根据<strong class="ky ir"> <em class="ls"> a </em> </strong>和<strong class="ky ir"> <em class="ls"> b. </em> </strong>的前两位，下表给出了<strong class="ky ir"> <em class="ls"> X{n+1} </em> </strong>的前两位值的顺序</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/273e24387d55134372189f4be010727d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AgU_KythmHmEwwMuI06l4A.png"/></div></div></figure><p id="d175" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，前两位的序列也是重复的。但是只有以<strong class="ky ir"><em class="ls"/></strong>结尾的<strong class="ky ir"> <em class="ls"> a </em> </strong>给出了循环前<strong class="ky ir"> <em class="ls"> X{n+1} </em> </strong>所有可能的<strong class="ky ir">四个</strong>值。因此，这是一个关于<strong class="ky ir"><em class="ls"/></strong>的新条件，以获得前两位的所有可能值。</p><ol class=""><li id="c066" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr np lz ma mb bi translated"><strong class="ky ir"><em class="ls">a</em></strong><strong class="ky ir"><em class="ls">b</em></strong>应该是奇数</li><li id="8074" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr np lz ma mb bi translated"><strong class="ky ir"> <em class="ls">一个</em> </strong> <em class="ls">应该以</em> <strong class="ky ir"> <em class="ls"> 01 </em> </strong> <em class="ls">结尾。<br/>换句话说</em> <strong class="ky ir"> <em class="ls"> a mod 4 = 1 </em> </strong>。<br/> <em class="ls">换句话说</em> <strong class="ky ir"> <em class="ls"> a-1 </em> </strong>应该是<strong class="ky ir"> <em class="ls"> 4 </em> </strong>的倍数</li></ol><p id="b9f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里检索我们早先看到的关于最佳线性同余生成元的定理的条件之一(条件n 3)。因为<strong class="ky ir"> <em class="ls"> M=2 </em> </strong>是<strong class="ky ir"> <em class="ls"> 4 </em> </strong>，<strong class="ky ir"> <em class="ls"> a-1 </em> </strong>应该是<strong class="ky ir"> <em class="ls"> 4 </em> </strong>的倍数。</p><p id="4c3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前为止我们得到的信息是:</p><ul class=""><li id="efc2" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><strong class="ky ir"> 1 </strong>第一位:长度为2的时间段</li><li id="69cc" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> 2 </strong>第二位:长度为4的周期</li></ul><p id="4073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你迭代下面的比特，你会得到类似的结果:</p><ul class=""><li id="a82e" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><strong class="ky ir"> 3 </strong>第3位:最大长度为8的周期</li><li id="c3cf" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> 4 </strong>第6位:最长16的周期</li><li id="9575" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi">….</li><li id="d494" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><strong class="ky ir"> 31 </strong>第一位:周期长度最大为2</li></ul><p id="a57f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们在上面对<strong class="ky ir"> <em class="ls"> a </em> </strong>和<strong class="ky ir"> <em class="ls"> b </em> </strong>的前两位设定的两个条件都是<strong class="ky ir">足够的</strong>来获得所有剩余位的最大周期。这就是为什么最终定理中出现条件“<em class="ls"> a-1应为4的倍数，如果M是4的倍数</em>”。</p><p id="0af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，因为它们的周期更长，高位比低位具有更好的随机性。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="086c" class="mt mo iq bd mu mv nz mx my mz oa nb nc jw ob jx ne jz oc ka ng kc od kd ni nj bi translated">解决低位问题</h1><p id="6097" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">从前面的章节中，我们明白了为什么<strong class="ky ir"><em class="ls">I</em></strong>t16位有一段长度<strong class="ky ir"> <em class="ls"> 2^i </em> </strong>。这是因为第<strong class="ky ir"> <em class="ls"> i </em> </strong>第位的<em class="ls"> X{n+1} </em> <strong class="ky ir">只取决于第</strong>I位的<em class="ls"> Xn </em>。<strong class="ky ir"> <em class="ls"> 2^i </em> </strong>是我们可以用<strong class="ky ir"> <em class="ls"> i </em> </strong>位得到的最大组合数。</p><p id="d47b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们需要一种方法，让第一位也依赖于其他位。加法和乘法只向左传播比特。是否有任何向右侧传播位的操作？一<strong class="ky ir"> <em class="ls">师</em> </strong>！</p><p id="202e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:如果我们想使<strong class="ky ir"> 1 </strong>的第一位<strong class="ky ir">、T53【X { n+1 }、T55】依赖于<em class="ls">的第三位</em>、T59【Xn】、T61】。我们把<strong class="ky ir"> <em class="ls"> Xn </em> </strong>除以4，这相当于把<strong class="ky ir"> <em class="ls"> Xn </em> </strong>向右移动了两步。</strong></p><p id="6c4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用以下内容更新我们的线性同余发生器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/9c8e508415ff7059fe8ab3f05305d21b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*kP1LnFikiZfUkWO-Zvow-Q.png"/></div></div></figure><p id="58bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看这是否提高了第一位的随机性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c6f4af9697e729b57aea57ddc188da29.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*oXT0_ih4icL5YVPw_kiefQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">aX + b +的第1位位图(X &gt;&gt; 2)</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/eec2e10a32d0d462f36db40b92d62418.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/1*CeHJMff-SFvt_wh1LKfPtA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对于aX + b + (X &gt;&gt; 2)，使用第1和第2位进行随机游走</p></figure><p id="d1f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这大大提高了第一位的随机性！位图中有一些图案(见黑点)，但比黑白交替好得多。</p><p id="9ab3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我们是否仍然擅长第31位的<em class="ls">。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/862d96856155b4960fee5c6d688187f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/format:webp/1*Qk-kc5V389iwSU0D0xwViw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">aX + b + (X &gt;&gt; 2)的第31位位图</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c461c7bc965bfb1795ad072b920ffd72.png" data-original-src="https://miro.medium.com/v2/resize:fit:510/1*59nvjMyck1-6fvNkfcHacw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">对aX + b + (X &gt;&gt; 2)使用第31位和第30位的随机游走</p></figure><p id="5245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，不太好，现在我们得到了位图中的图案(见黑点)，你可以看到一个形状在随机游走中无限重复。</p><p id="ea21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以尝试另一个金额来转换。为此，我编写了一个程序，返回不同班次金额的周期。结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/73a836e72de9eab9fd4930f35de8910f.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*vyf811OvU_0RB35K4mY-WA.png"/></div></figure><p id="6d4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">没有任何金额给出2的最大期限。因此，这种形式的函数不能在不影响随机数发生器周期的情况下解决我们的问题。</p><p id="523c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">研究线性同余发生器的变体并不容易，这些变体既能解决低位问题，又能实现最大周期长度。<strong class="ky ir"><em class="ls">a</em></strong><strong class="ky ir"><em class="ls">b</em></strong>的调优对于<strong class="ky ir"> <em class="ls"> aX+b </em> </strong>来说已经被证明了，任何变体都要足够好的学习，以免陷入短周期。我尝试了不同版本的函数，如下所示。每次我的周期变短:</p><ul class=""><li id="b7fa" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated"><em class="ls">X { n+1 } =(aXn+b+</em><strong class="ky ir"><em class="ls">X&gt;&gt;2</em></strong><em class="ls">)mod M</em></li><li id="8983" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls">X { N+1 } =(aXn+b+</em><strong class="ky ir"><em class="ls">sum I从1到N(X&gt;&gt;I)</em></strong><em class="ls">)mod M</em></li><li id="895c" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls">X { N+1 } =(aXn+b+</em><strong class="ky ir"><em class="ls">xor I从1到N(X&gt;&gt;I)</em></strong><em class="ls">)mod M</em></li><li id="4465" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated"><em class="ls">X { N+1 } =(aXn+b+</em><strong class="ky ir"><em class="ls">N-1个最高有效位之和</em> </strong> <em class="ls"> ) mod M </em></li><li id="2eea" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi">…</li></ul><p id="2783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你试一试，也许你会发现一个变种，可以解决周期和低位的问题！</p><h1 id="976f" class="mt mo iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="70c9" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">令我非常惊讶的是，我发现最著名的随机数发生器之一根本不是随机的。在本文中，我们已经看到了线性同余生成器如何无法为它生成的数字的低位获得看似随机的序列。我们还使用了两种可视化方法来帮助用肉眼评估随机数生成器。</p><p id="7a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，有更先进的随机发生器，不存在低位的问题，如<a class="ae kv" href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="noopener ugc nofollow" target="_blank">梅森扭转器</a>，它不像线性同余发生器那么简单，但绝对值得花时间来理解它是如何工作的。</p></div></div>    
</body>
</html>