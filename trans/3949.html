<html>
<head>
<title>Table Joins Explained in 11 Minutes using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL在11分钟内解释表连接</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/table-joins-explained-in-11-minutes-using-sql-9a3c81fc5265#2022-09-01">https://towardsdatascience.com/table-joins-explained-in-11-minutes-using-sql-9a3c81fc5265#2022-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fb46492cc6362fa11343333b301301de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*udkp13xvydqGzkPe"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">photo by<a class="ae kf" href="https://unsplash.com/@tvick" rel="noopener ugc nofollow" target="_blank">@ TV ick</a>@ unsplash . com</p></figure><p id="7108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">【免责声明:此帖子包含一些我的Udemy课程的附属链接】</em></p><p id="e060" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您从事数据科学或机器学习领域的工作，您可能需要构建数据管道来帮助您组合不同的数据源。在项目层面，组合不同的数据集可能是数据科学家为取得项目成功而不得不忍受的最耗时的任务之一。</p><p id="dfce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">知道如何争论数据是数据科学家的一项关键技能，因为这使他们能够将更多功能纳入他们的管道，在这个过程中，数据连接概念是绝对关键的。虽然在你学会它们之后，它们看起来相当简单，但是它们有可能损害你的项目质量的小细节。为什么？</p><p id="dfb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在数据争论过程中，设计不良的连接是错误的主要来源之一。执行得不好的联接可能具有很大的破坏性，它可能会在一瞬间创建重复项或减少训练数据的维数。如果你没有注意到它们，这些错误将导致你在训练模型或基于错误数据做出结论时犯下大量错误。</p><p id="fa7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我的目标是用不到11分钟的时间解释数据连接。我将解释使用SQL(结构化查询语言)的不同类型的数据连接，但是如果您没有支配SQL，不要担心！我们将学习的一般原则适用于<code class="fe lf lg lh li b">pandas</code>或<code class="fe lf lg lh li b">R</code> <em class="le">合并</em>特征。开始吧！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="7e4c" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">什么是联接？</h1><p id="3332" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">基本上，数据连接是我们组合数据集的一种方式(主要是水平地)。使用数据连接有两个主要原因:</p><ul class=""><li id="33cd" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">从其他数据集中选取列。</li><li id="7b28" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">限制特定表的域。</li></ul><p id="15ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有更多的用例，但这两个可以说是最常用的。通过连接，表之间的数据通过一个<em class="le">键连接，一个</em>列将用于映射我们想要合并的多个表之间的行。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="0c8c" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">内部连接</h1><p id="bc07" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">让我们从一个可视化的图开始——著名的<em class="le">内部连接</em>图:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/77b15322b384a7a222abef7c5e7036fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*NgBrsLAre0AmBrZCAfDvYQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">内部联接图—作者图片</p></figure><p id="92dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">内部连接<strong class="ki iu">仅</strong>包括连接中涉及的两个表的域。这是什么意思？让我们从使用<code class="fe lf lg lh li b">customers</code>和关于<code class="fe lf lg lh li b">customer_country</code>的信息在SQL中创建一些示例数据集开始:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="f0a5" class="nq lr it li b gy nr ns l nt nu">CREATE TABLE sandbox.customers(<br/> customer_id INT AUTO_INCREMENT PRIMARY KEY,<br/> customer_name varchar(255) NOT NULL<br/>    );<br/>    <br/>CREATE TABLE sandbox.customer_country(<br/> customer_id INT PRIMARY KEY,<br/> customer_country varchar(255) NOT NULL<br/>    );</span><span id="ddf0" class="nq lr it li b gy nv ns l nt nu">insert into sandbox.customers (<br/> customer_name<br/>) values ('John'), ('Adam'), ('Anne'), ('May');</span><span id="9cf2" class="nq lr it li b gy nv ns l nt nu">insert into sandbox.customer_country (<br/> customer_id, customer_country<br/>) values (1, 'USA'), (3, 'USA'), (4, 'UK'), (5, 'UK');</span></pre><p id="ab4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这两个表各包含4行:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/15cb79467ade89c8c86ed71f525d4617.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*J98kLLxeUhUl71wYQo75tw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">客户表-按作者分类的图像</p></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0f7d610af401d80c7f989d63b9a746a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*1yQaq2NW9BzOUMeEXwY_zw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">客户国家表-按作者分类的图像</p></figure><ul class=""><li id="18f8" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">在<code class="fe lf lg lh li b">customer</code>桌上，我们有4个客户，分别是<code class="fe lf lg lh li b">John</code>、<code class="fe lf lg lh li b">Adam</code>、<code class="fe lf lg lh li b">Anne</code>和<code class="fe lf lg lh li b">May</code>；</li><li id="55c7" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">在<code class="fe lf lg lh li b">customer_country</code>桌上，我们也有4个客户，两个来自<code class="fe lf lg lh li b">USA</code>，两个来自<code class="fe lf lg lh li b">UK</code>；</li></ul><p id="9fd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很快，我们看到两个表中的域是不同的。在<code class="fe lf lg lh li b">customer</code>表中，我们有带有<code class="fe lf lg lh li b">ids</code> 1、2、3和4的客户。在<code class="fe lf lg lh li b">customer_country</code>表中，我们有<code class="fe lf lg lh li b">ids</code> 1、3、4和5。</p><p id="22ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们希望在同一个表中有客户的姓名和国家。我们怎么做呢？用<em class="le">加入</em>！</p><p id="3f9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">要执行任何数据连接，我们需要知道一些“成分”——记住下面的数字，因为我们将在整个帖子中使用它们:</strong></p><ul class=""><li id="6654" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">(1)我们想要组合的表—对于我们的例子，<code class="fe lf lg lh li b">customer</code>和<code class="fe lf lg lh li b">customer_country</code>；</li><li id="ca07" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">(2)我们想要使用的键——两个表中唯一存在的列是<code class="fe lf lg lh li b">id</code>，所以我们将使用这个列作为它们之间的连接器。</li><li id="c7e5" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">(3)我们希望保留在输出表中的域—对于第一个连接，我们只希望输出我们知道其来源的<code class="fe lf lg lh li b">customer_name</code>和<code class="fe lf lg lh li b">customer_country</code>的客户。</li><li id="95e1" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">(4)我们想要选取的列—我们想要一个带有<code class="fe lf lg lh li b">id</code>、<code class="fe lf lg lh li b">customer_name</code>和<code class="fe lf lg lh li b">customer_country</code>的输出表。</li></ul><p id="d626" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把它放在SQL连接语法中:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="a861" class="nq lr it li b gy nr ns l nt nu">select a.customer_id, a.customer_name, b.customer_country<br/>from sandbox.customers as a<br/>inner join <br/>sandbox.customer_country as b<br/>on a.customer_id = b.customer_id;</span></pre><p id="8a88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个<em class="le">查询</em>的结果:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/49b89f7846801ddeed8c9bd750b89039.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*xOmyjILBa6i0uqJ3qwQ60Q.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来自内部连接的结果—作者提供的图像</p></figure><p id="38b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分解我们的代码并将每一位映射到我们定义的“成分”:</p><ul class=""><li id="5beb" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">首先，我们使用<code class="fe lf lg lh li b">select a.customer_id, a.customer_name, b.customer_country</code>选择我们想要在表中输出的列。我们使用别名<code class="fe lf lg lh li b">a</code>来表示表<code class="fe lf lg lh li b">customer</code>和<code class="fe lf lg lh li b">b</code>来表示<code class="fe lf lg lh li b">customer_country</code>表——这是我们定义成分(4)的地方。</li><li id="a29a" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">使用<code class="fe lf lg lh li b">from sandbox.customers as a</code>，我们将<code class="fe lf lg lh li b">customer</code>表映射到它的别名，命名(1)的一个成分部分。</li><li id="da17" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">使用<code class="fe lf lg lh li b">inner join</code>，我们声明我们想要的表<code class="fe lf lg lh li b">a</code>和<code class="fe lf lg lh li b">b</code>之间的连接类型。这是定义成分(3)的关键，即输出的域。</li><li id="04cb" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">使用<code class="fe lf lg lh li b">sandbox.customer_country as b</code>，我们将<code class="fe lf lg lh li b">customer_country</code>映射到它的别名，命名成分(1)的另一部分。</li><li id="c90a" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">使用<code class="fe lf lg lh li b">on a.customer_id = b.customer_id</code>，我们声明连接两个表的连接或列的键。正如你所料，这是定义成分(2)的关键部分。</li></ul><p id="ac2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">引擎盖下发生了什么？如果我们使用<code class="fe lf lg lh li b">customer_id</code>作为连接器，SQL将执行以下操作:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/fcdbc27d040af4290da37def7ef5ad51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nSoFsSVJTVGdy6zI5F1b7g.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">内部连接中键的可视化表示—作者提供的图像</p></figure><p id="ab3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe lf lg lh li b">inner join</code>，只有在两个表中都有对应关系的客户才会出现在返回表中。</p><p id="d934" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">每一行都是由输出</strong>生成的一行，因此，在我们的输出数据中，只有在可视化表示上连接的客户(客户<code class="fe lf lg lh li b">1, 3, 4</code>)才会出现。这导致了一个重要的结论:如果您碰巧选择了内部连接，您可能会在整个管道中丢失实体(在我们的例子中是<code class="fe lf lg lh li b">customers</code>)。</p><p id="1adf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们给这个话题加点料。谁说我们必须使用单列作为键？为了展示一个新的例子，让我再创建两个表，每个月显示一些<code class="fe lf lg lh li b">customers</code>的收入和支出:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="a8ed" class="nq lr it li b gy nr ns l nt nu">CREATE TABLE sandbox.customer_income(<br/> customer_id INT,<br/> month INT,<br/> income decimal(19,4) NOT NULL,<br/>    primary key (customer_id, month)<br/>    );</span><span id="3525" class="nq lr it li b gy nv ns l nt nu">insert into sandbox.customer_income (<br/> customer_id, month, income<br/>) values (1, 202001, 10.03), (1, 202002, 10.03), (1, 202003, 20.52),<br/>  (3, 202001, 52.01), (3, 202002, 60.03);<br/>        <br/>        <br/>CREATE TABLE sandbox.customer_expense(<br/> customer_id INT,<br/> month INT,<br/> expense decimal(19,4) NOT NULL,<br/>    primary key (customer_id, month)<br/>    );</span><span id="74bd" class="nq lr it li b gy nv ns l nt nu">insert into sandbox.customer_expense (<br/> customer_id, month, expense<br/>) values (1, 202001, 2.25), (1, 202002, 3.20), (1, 202003, 15.50),<br/>  (3, 202001, 10.06), (3, 202002, 10.65), (3, 202003, 20.2);</span></pre><p id="1cf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们创建的数据:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/f44ab3fa44b8a301bd1efb36ebea0e01.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*dbJUfQE3DO_decLGPqRaVQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">每月客户收入—按作者分类的图片</p></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a4929bdb4ddde95f9654039eac7670a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*Tz29KbeTZ5M9KhgqGIm9vA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">每月客户费用—按作者分类的图片</p></figure><p id="b7de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想在一个表中合并收入和支出(例如，计算余额)，我们应该只使用<code class="fe lf lg lh li b">customer_id</code>键吗？让我们看看:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="a9ad" class="nq lr it li b gy nr ns l nt nu">select a.customer_id, a.month, a.income, b.expense<br/>from sandbox.customer_income as a<br/>inner join sandbox.customer_expense as b<br/>on a.customer_id = b.customer_id;</span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/cf3df6df2f9fd3fabc8a27ef00f4067d.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*T__4q402ilhHNxTe07dISg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">每月客户收入和支出—按作者分类的图片</p></figure><p id="32f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">啊哦！奇怪的事情发生了。让我们看看前三行——我们声明<code class="fe lf lg lh li b">customer_id = 1</code>在这个月(202001)有三笔不同的费用，这显然是不正确的，因为只有值<code class="fe lf lg lh li b">2.25</code>应该被映射。</p><p id="31a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里发生了什么？我们错误地定义了我们的成分2(关键)，而<code class="fe lf lg lh li b">SQL</code>只是以这种方式映射我们的数据(仅以<code class="fe lf lg lh li b">customer_id = 1</code>为例):</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/e85d2f62cae6c88dc47f40ca55786129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LARoU14j0fOEOWHoY9g7Sg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来自连接的多对多映射-按作者排列的图像</p></figure><p id="52dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很困惑，不是吗？我只通过<code class="fe lf lg lh li b">customer_id</code>来绘制图表，因为这正是我们通过将它作为一个键所完成的映射。</p><p id="2554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SQL将浏览表A寻找<code class="fe lf lg lh li b">customer_id = 1</code>，并且对于它在表B上找到的每个<code class="fe lf lg lh li b">customer_id = 1</code>实例，它都会生成一行，产生大量的副本！总结上图:</p><ul class=""><li id="2ad3" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">黑线是由表a的第一行生成的映射。</li><li id="f1d1" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">红线是表a第二行生成的映射。</li><li id="25d9" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">蓝线是表a第二行生成的映射。</li></ul><p id="8c9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是人们在争论数据时最常犯的错误之一— <strong class="ki iu">不明白标识两个表上的行的键是什么，从而产生错误的数据。</strong></p><p id="9ea2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何才能避免这种情况？我们显然希望在<code class="fe lf lg lh li b">customer_id</code>和每个<code class="fe lf lg lh li b">month</code>之间有一对一的关系，所以我们需要把它给我们的<code class="fe lf lg lh li b">join</code>:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="5360" class="nq lr it li b gy nr ns l nt nu">select a.customer_id, a.month, a.income, b.expense<br/>from sandbox.customer_income as a<br/>inner join sandbox.customer_expense as b<br/>on a.customer_id = b.customer_id and a.month = b.month;</span></pre><p id="66d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过在我们的<code class="fe lf lg lh li b">on</code>子句中传递<code class="fe lf lg lh li b">and a.month = b.month</code>来做到这一点！现在让我们看看输出:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/09e192b5111a5e4c3b6caf15b61dfc15.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*AvOajOK45tcWYg1S-UXPwQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">多键内部连接-作者图片</p></figure><p id="f25d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好多了！现在，我们正在进行以下映射:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/5973bf72018f17d8bcf32ab48d1d53f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TtDHGKIOPmmDaYQ96Vr8CQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">多键内部连接映射—作者图片</p></figure><p id="78a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们已经添加了正确的键，所以客户和月份之间的映射现在已经正确完成。不再有重复的支出和收入！</p><p id="2bb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们没有关于<code class="fe lf lg lh li b">customer_id = 3</code>的<code class="fe lf lg lh li b">month = 202003</code>输出的任何信息。为什么？因为我们选了一个<code class="fe lf lg lh li b">inner join</code>！</p><p id="812c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们在2020年3月从<code class="fe lf lg lh li b">customer_id = 3</code>获得<code class="fe lf lg lh li b">expense</code>是有意义的，即使我们没有从该客户获得任何<code class="fe lf lg lh li b">income</code>。</p><p id="a6e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何做到这一点？通过调整我们的第3个成分——我们希望传播到输出表的域！让我们看看，下一个。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="cf20" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">右连接</h1><p id="5ea1" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">再次从我们的视觉开始:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/a8200d18321a1bab76ac986a6485f81b.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*u26_N8-jFpu641kZOkTR_w.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">右连接图—作者图片</p></figure><p id="65e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将关键字<code class="fe lf lg lh li b">inner</code>改为<code class="fe lf lg lh li b">right</code>，稍微调整一下我们的查询:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="152d" class="nq lr it li b gy nr ns l nt nu">select a.customer_id, a.month, a.income, b.expense<br/>from sandbox.customer_income as a<br/>right join sandbox.customer_expense as b<br/>on a.customer_id = b.customer_id and a.month = b.month;</span></pre><p id="0905" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该查询生成的输出是:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi od"><img src="../Images/51c5a005569ccc0fc73993a6a64af6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*bZ_TWK26xipCpVi_9KAe5Q.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">右连接输出-按作者分类的图像</p></figure><p id="7922" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在有了从<code class="fe lf lg lh li b">customer_id = 3</code>到<code class="fe lf lg lh li b">month = 202003</code>的多出来的一行<code class="fe lf lg lh li b">expense</code>。然而，有些事情似乎有点奇怪，因为我们没有该行的<code class="fe lf lg lh li b">customer_id</code>或<code class="fe lf lg lh li b">month</code>的信息——为什么？</p><p id="95aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为在<code class="fe lf lg lh li b">right</code>或<code class="fe lf lg lh li b">left</code>连接中，我们需要从命令连接的主表中选择键。我们联接中的主表是什么？你能猜到吗？</p><p id="c347" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“右上”那张桌子，<code class="fe lf lg lh li b">customer_expense</code>，那上面有别名<code class="fe lf lg lh li b">b</code>！如果我们从该表中选择按键(<code class="fe lf lg lh li b">customer_id</code>和<code class="fe lf lg lh li b">month</code>):</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="dd1c" class="nq lr it li b gy nr ns l nt nu">select b.customer_id, b.month, a.income, b.expense<br/>from sandbox.customer_income as a<br/>right join sandbox.customer_expense as b<br/>on a.customer_id = b.customer_id and a.month = b.month;</span></pre><p id="99de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的输出表将更有意义:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/12b1eef6d1e20bcfb3e60b7dda828b54.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*2InXP4PJIgI0MakyQL_fXg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">具有正确键的右连接输出—按作者排序的图像</p></figure><p id="e3e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们继续之前，我们已经更改了以下内容:</p><ul class=""><li id="462f" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated"><code class="fe lf lg lh li b">select a.customer_id, a.month</code>被更改为<code class="fe lf lg lh li b">select b.customer_id, b.month</code>以匹配连接的主表。</li></ul><p id="4b33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从视觉上看，我们现在正在检索以下数据:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/56ac11463a9d2a94be49b87991a9d2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sTl1DmnNTRrcbYMQlxNJNA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">右连接映射-按作者分类的图像</p></figure><p id="1d17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，<code class="fe lf lg lh li b">right joins</code>从右边的表中检索数据(或者在我们的例子中是<code class="fe lf lg lh li b">table b</code>，不管左边的表中是否有这个键。</p><p id="f208" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们也可以执行左连接！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ddc7" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">左连接</h1><p id="bcc2" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在左侧连接中，“表A”命令连接:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8cd321a85385744f8cff474ebd021a53.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*tuMXgcHke1m1vktFgrPcTg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">左连接图—作者提供的图片</p></figure><p id="0ee3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于左连接示例，我将再次选择<code class="fe lf lg lh li b">customer</code>和<code class="fe lf lg lh li b">customer_country</code>表:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/15cb79467ade89c8c86ed71f525d4617.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*J98kLLxeUhUl71wYQo75tw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">客户表-按作者分类的图像</p></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/0f7d610af401d80c7f989d63b9a746a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*1yQaq2NW9BzOUMeEXwY_zw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">客户国家表-按作者分类的图像</p></figure><p id="8f6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经看到，如果我们使用一个<code class="fe lf lg lh li b">inner</code>子句连接两个表，我们将只输出两个表中都可用的<code class="fe lf lg lh li b">customer_ids</code>。但是，如果我们想要宣传<code class="fe lf lg lh li b">Adam</code>，即我们没有任何原产国信息的客户，该怎么办呢？也许对于我们正在做的这个案例来说，不一定要有<code class="fe lf lg lh li b">Adam</code>的<code class="fe lf lg lh li b">customer_country</code>。</p><p id="9543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将表<code class="fe lf lg lh li b">customer</code>视为表A，我们可以依靠表a <code class="fe lf lg lh li b">left join</code>来完成:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="6ba5" class="nq lr it li b gy nr ns l nt nu">select a.customer_id, a.customer_name, b.customer_country<br/>from sandbox.customers as a<br/>left join sandbox.customer_country as b<br/>on a.customer_id = b.customer_id;</span></pre><p id="6d65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该<code class="fe lf lg lh li b">left join</code>将输出:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/17307a88554a22d8f176aa4d7ef018aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*p3f7ggEKnZyPCwflwhYwjQ.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">左连接输出示例-按作者排序的图像</p></figure><p id="c758" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在映射图中，会发生以下情况:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/f7a83a9bf00ff5229b11bf3668748eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EX_YrCngXyhoXHeuQj3ozg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">左连接映射-按作者分类的图像</p></figure><p id="f9e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有<code class="fe lf lg lh li b">customer_id=5</code>没有被输出查询。为什么？因为它在我们在左连接中使用的“主”表上不可用，<code class="fe lf lg lh li b">customer</code>。</p><p id="881a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，当我们谈到<code class="fe lf lg lh li b">left joins</code>时，我们命名的第一个表就是主表。当我们谈到<code class="fe lf lg lh li b">right joins</code>时，主表将是关系中的第二个表。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="0715" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">完全外部连接</h1><p id="8c46" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">但是..如果我们想在输出中包含<code class="fe lf lg lh li b">customer_id=5</code>，即使我们不知道它的名字，该怎么办？我可能想要一份所有客户的汇总表，不管他们的身份如何— <code class="fe lf lg lh li b">full joins</code>随时为我们提供帮助:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/cec41867e7d79636e40f0dde1272d9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*JXJm2cpcJUQM8l7tfnLr4A.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">完整的外部连接图—作者提供的图片</p></figure><p id="0992" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，<code class="fe lf lg lh li b">MYSQL</code>没有直接的<code class="fe lf lg lh li b">full outer join</code>实现(像MS SQL或Oracle ),我们必须做一个变通方案:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="a373" class="nq lr it li b gy nr ns l nt nu">SELECT <br/> (case when a.customer_id IS NULL <br/>    THEN b.customer_id<br/>    ELSE a.customer_id <br/> END) as customer_id, <br/>    a.customer_name, <br/>    b.customer_country<br/>FROM (<br/>   SELECT customer_id FROM sandbox.customers UNION<br/>   SELECT customer_id FROM sandbox.customer_country<br/>) combined_keys LEFT JOIN<br/> sandbox.customers as a <br/> ON a.customer_id = combined_keys.customer_id LEFT JOIN<br/> sandbox.customer_country as b <br/> ON b.customer_id = combined_keys.customer_id;</span></pre><p id="2910" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该代码将输出:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/690e34b97394cf82b176f22af6c180cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*CNboIsDKviyGu6q0IzzOvw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">完整外部连接示例—作者图片</p></figure><p id="e3da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出包含两个表中所有可用的<code class="fe lf lg lh li b">customer_ids</code>，并与<code class="fe lf lg lh li b">customers</code>和<code class="fe lf lg lh li b">customer_country</code>上的可用信息相关联。在映射方面，我们正在做以下工作:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/4c9352f75272e531dfc3864c0eff2115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fULVJ1EsXsrEWb3n27FDzQ.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">完整的外部连接映射-作者图片</p></figure><p id="95af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">full joins</code>使我们能够查看我们的键的完整域，将它的每个实例映射到输出，而不管它们在哪个表中。<code class="fe lf lg lh li b">full joins</code>也是在缺失数据中寻找模式的好方法，因为它们映射了连接两边的表中可用信息的完整图景。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a279" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">左侧或右侧反连接</h1><p id="8ae1" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">最后，我们还可以执行<code class="fe lf lg lh li b">left</code>或<code class="fe lf lg lh li b">right</code>反连接——这将包括所有只在表A或表B上可用的行:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/bcd09ced5089d519254308fe1c444ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*JQAtCBbtdfUPCmk4KhX4lg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">左侧反连接-作者提供的图像</p></figure><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi om"><img src="../Images/cd88f4a93aac5d4f824d9a8d9819d045.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*o8_BgpiBIAyTARmyUjoN_g.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">右反连接-作者图片</p></figure><p id="8e50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在MySQL中实现一个<code class="fe lf lg lh li b">anti join</code>非常简单。我们只需添加连接到我们想要排除的表的键的子句<code class="fe lf lg lh li b">IS NULL</code>。例如，为了执行一个<code class="fe lf lg lh li b">left anti join</code>，我们选择我们已经学过的<code class="fe lf lg lh li b">left join</code>并添加一个新的子句:</p><pre class="ni nj nk nl gt nm li nn no aw np bi"><span id="76b4" class="nq lr it li b gy nr ns l nt nu">select a.customer_id, a.customer_name, b.customer_country<br/>from sandbox.customers as a<br/>left join sandbox.customer_country as b<br/>on a.customer_id = b.customer_id<br/>where b.customer_id IS NULL;</span></pre><p id="8ebb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe lf lg lh li b">left join</code>相比，唯一改变的代码是在键定义后添加了<code class="fe lf lg lh li b">where</code>子句。</p><p id="53b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将输出以下内容:</p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi on"><img src="../Images/79b4aaf37081fa61b979789946e9978f.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*44LyvcWD1U6bFmL_uJz6Dw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">左侧反连接示例-作者提供的图像</p></figure><p id="bc8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要对右反连接进行同样的操作，只需切换键和连接类型。对于一个<code class="fe lf lg lh li b">right</code>反连接，您将需要一个<code class="fe lf lg lh li b">right join</code>与一个<code class="fe lf lg lh li b">where</code>子句相结合，该子句将具有<code class="fe lf lg lh li b">a.customer_id IS NULL</code>。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><p id="16b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">表连接对于构建稳定和正确的数据管道极其重要。作为总结，以下是您需要了解的执行正确连接类型的要素:</p><ul class=""><li id="915b" class="mt mu it ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated">(1)我们要合并的表；</li><li id="7315" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">(2)我们要使用的密钥。</li><li id="53fd" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">(3)我们希望保留在输出表中的域。</li><li id="2581" class="mt mu it ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated">(4)我们要选取的列。</li></ul><p id="c685" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢你花时间阅读这篇文章！我在这篇文章中遗漏了一些连接，比如<code class="fe lf lg lh li b">cross join</code>或pure <code class="fe lf lg lh li b">anti-join</code>，但是我相信当你在其他资源中读到它们时，你将能够使用这些知识来更好地理解它们。</p><p id="acb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="le">我在</em></strong><a class="ae kf" href="https://www.udemy.com/course/sql-for-absolute-beginners/?couponCode=MEDIUM_SEPTEMBER" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"><em class="le">Udemy</em></strong></a><strong class="ki iu"><em class="le">上开设了一门关于从零开始学习SQL的课程，我在其中深入探讨了这些概念以及更多内容——这门课程适合绝对的初学者，我希望您能在我身边！</em>T13】</strong></p><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/8a261c8a8d78b42e54504dc3e1ba2641.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*X8lcAYO1OiBX_pm3AXJC4g.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://www.udemy.com/course/sql-for-absolute-beginners/?couponCode=MEDIUM_SEPTEMBER" rel="noopener ugc nofollow" target="_blank"> SQL绝对初学者教程</a> —图片由作者提供</p></figure><div class="op oq gp gr or os"><a href="https://medium.com/membership/@ivopbernardo" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">通过我的推荐链接加入Medium-Ivo Bernardo</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">阅读我在Medium上的所有故事，了解更多关于数据科学和分析的信息。加入中级会员，您将…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg jz os"/></div></div></a></div></div></div>    
</body>
</html>