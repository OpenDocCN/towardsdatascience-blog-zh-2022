<html>
<head>
<title>A Guide to Python Itertools Like No Other</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">独一无二的Python Itertools指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-python-itertools-like-no-other-454da1ddd5b8#2022-08-10">https://towardsdatascience.com/a-guide-to-python-itertools-like-no-other-454da1ddd5b8#2022-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9364" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过动画gif使你对这个惊人的库的理解具体化，并学习如何编写更优雅的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f10b29f2fdda7da1d06fc386b4eecea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eKuoKV5pqXfHi-2X"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@roum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃琳娜·鲁梅</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="811d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">目录</h1><ol class=""><li id="8913" class="ly lz it ma b mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><a class="ae ky" href="#a8a7" rel="noopener ugc nofollow">简介</a></li><li id="9f2b" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#8830" rel="noopener ugc nofollow"> itertools.product() </a></li><li id="7260" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#9d43" rel="noopener ugc nofollow">ITER tools . permutations()</a></li><li id="9f98" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#ca31" rel="noopener ugc nofollow">ITER tools . combinations()</a></li><li id="edf0" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#4cd3" rel="noopener ugc nofollow">ITER tools . combinations _ with _ replacement()</a></li><li id="59ec" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#b308" rel="noopener ugc nofollow"> itertools.count() </a></li><li id="5f78" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#03db" rel="noopener ugc nofollow"> itertools.cycle() </a></li><li id="2d25" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#5155" rel="noopener ugc nofollow"> itertools.repeat() </a></li><li id="56b6" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#90fb" rel="noopener ugc nofollow"> itertools.accumulate() </a></li><li id="e1f9" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#1106" rel="noopener ugc nofollow"> itertools.chain() </a></li><li id="507e" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#eb22" rel="noopener ugc nofollow"> itertools.compress() </a></li><li id="40cf" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#45c6" rel="noopener ugc nofollow"> itertools.dropwhile() </a></li><li id="8f6b" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#cb16" rel="noopener ugc nofollow"> itertools.takewhile() </a></li><li id="3ca4" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#642e" rel="noopener ugc nofollow">ITER tools . filter false()</a></li><li id="5621" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#c753" rel="noopener ugc nofollow"> itertools.starmap() </a></li><li id="a205" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#e923" rel="noopener ugc nofollow"> itertools.tee() </a></li><li id="02c5" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#0362" rel="noopener ugc nofollow">ITER tools . zip _ longest()</a></li><li id="614d" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#2dd3" rel="noopener ugc nofollow"> itertools.pairwise() </a></li><li id="63e3" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#9b2d" rel="noopener ugc nofollow"> itertools.groupby() </a></li><li id="c861" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#7d31" rel="noopener ugc nofollow"> itertools.islice() </a></li><li id="6b42" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="#a20a" rel="noopener ugc nofollow">结论</a></li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a8a7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="4617" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools</code>是Python中用于处理可重复项的内置模块。它提供了许多快速、节省内存的方法来循环遍历iterables，以获得不同的预期结果。这是一个强大但被低估的模块，每个数据科学家都应该知道，以便用Python编写干净、优雅和可读的代码。</p><p id="4f61" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">虽然有大量关于<code class="fe ni nj nk nl b">itertools</code>及其功能的资源，但它们通常专注于代码，使得不熟悉的读者很难立即理解每个方法的内部工作原理。本文采用了一种不同的方法——我们将使用动画gif带您浏览每一个<code class="fe ni nj nk nl b">itertools</code>方法，以说明它们实际上是如何工作的。希望这个指南能帮助你更好地想象和理解如何使用<code class="fe ni nj nk nl b">itertools</code>。</p><p id="dd0c" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated"><em class="nr">注意:因为我们采用了这种方法，许多动画插图被故意过度简化，以帮助读者理解。例如，如果GIF中的输出显示为“ABC”，并不意味着代码输出是字符串“ABC”。而是代表代码输出，</em> <code class="fe ni nj nk nl b"><em class="nr">[('A', 'B', 'C')]</em></code> <em class="nr">。同样，</em> <code class="fe ni nj nk nl b"><em class="nr">itertools</em></code> <em class="nr">方法通常返回一个生成器(它不会立即显示结果元素)作为输出。然而，在gif中，我们将输出表示为将输出包装在</em> <code class="fe ni nj nk nl b"><em class="nr">list()</em></code> <em class="nr">函数后得到的结果。</em></p><p id="e295" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">说到这里，让我们开始行动吧！</p><h1 id="8830" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated">itertools.product()</h1><p id="9cee" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.product()</code>是一种组合迭代器，给出给定可迭代列表的笛卡尔积<strong class="ma iu"> </strong>。每当您在代码中嵌套了for循环时，都是使用<code class="fe ni nj nk nl b">itertools.product()</code>的好机会。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/4f27d71a65b613dd10ce2d307450e7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5aM9SxoTZBrVVX3h_IPN-A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.product()`的动画演示</p></figure><p id="89b4" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">要计算iterable与其自身的乘积，可以用可选的<code class="fe ni nj nk nl b">repeat</code>参数指定重复的次数。</p><h1 id="9d43" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated">ITER tools . p<strong class="ak">er mutations()</strong></h1><p id="fc10" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">给你一个iterable的所有可能的排列，即没有重复元素的所有可能的排序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/ec652aaba6aa71467645e1b27b696453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_O0cYUtHhnq2y_nju4LmLA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.permutations()`的动画演示</p></figure><h1 id="ca31" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak">ITER tools . combinations()</strong></h1><p id="7696" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">对于给定的iterable，<code class="fe ni nj nk nl b">itertools.combinations()</code>返回长度为<em class="nr"> r </em>且没有重复元素的所有可能组合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e18525cb4ef143a4637196967c15dddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_1Sq8GpCbIkUOJnVz1UYdw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.combinations()`的动画演示</p></figure><p id="7fb8" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">图3中的GIF假定了<code class="fe ni nj nk nl b">r=3</code>，因此返回了<code class="fe ni nj nk nl b">('A','B','C')</code>的唯一组合。如果<code class="fe ni nj nk nl b">r=2</code>，<code class="fe ni nj nk nl b">itertools.combinations('ABC', 2)</code>将返回<code class="fe ni nj nk nl b">[('A','B'), ('A','C'),('B','C')]</code>。</p><h1 id="4cd3" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak">ITER tools . combinations _ with _ replacement()</strong></h1><p id="e390" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">对于给定的iterable，<code class="fe ni nj nk nl b">itertools.combinations_with_replacement()</code>返回长度为<em class="nr"> r </em>的所有可能组合，每个元素允许重复多次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/d76dc47ee44ee9fe399a12b53585cc6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yqvxcSPQiv3yKu7CVhOnGw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:ITER tools . combinations _ with _ replacement()的动画演示</p></figure><h1 id="b308" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.count() </strong></h1><p id="e0d6" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.count()</code>返回给定一个输入数的均匀间隔值，直到无穷大。因此，它被称为“无限迭代器”。默认情况下，这些值将平均间隔1，但这可以用<code class="fe ni nj nk nl b">step</code>参数设置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/1aa53d83b2859c0831e1547865d91768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*n942jFBBHYSUqWpa1CVyfA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.count()的动画演示</p></figure><h1 id="03db" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.cycle() </strong></h1><p id="45eb" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.cycle()</code>是另一个无限迭代器，它连续“循环”遍历一个可迭代对象，产生一个无限序列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/44d5c3e14a9254a14096d43d57e898ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pIgaVMGcLqHdBm2mI-CjFg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.cycle()的动画演示</p></figure><h1 id="5155" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.repeat() </strong></h1><p id="868f" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.repeat()</code>是第三种无限迭代器，它一遍又一遍地重复一个可迭代对象，产生一个无限序列，除非指定了<code class="fe ni nj nk nl b">times</code>。比如<code class="fe ni nj nk nl b">itertools.repeat('ABC', times=3)</code>会产生<code class="fe ni nj nk nl b">['ABC', 'ABC', 'ABC']</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e076221541fcd8c915c6e35ea2b050cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*a9yqdmzqZROKoBpBFHpXpg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.repeat()`的动画演示</p></figure><h1 id="90fb" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.accumulate() </strong></h1><p id="6138" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.accumulate()</code>生成一个迭代器，它累加iterable中每个元素的总和。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/be91ebf3b4b332f4f1b70b5f360695ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qF8uyJ4xBV9yNuxuORtQzA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.accumulate()'的动画演示</p></figure><p id="fbfc" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">默认情况下，它通过加法或串联进行累加。您还可以使用带有两个参数的<code class="fe ni nj nk nl b">func</code>参数来指定一个定制函数。例如，<code class="fe ni nj nk nl b">itertools.accumulate('ABCD', func=lambda x, y: y.lower()+x)</code>会产生<code class="fe ni nj nk nl b">['A', 'bA', 'cbA', 'dcbA']</code>。</p><h1 id="1106" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.chain() </strong></h1><p id="3bcd" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.chain()</code>获取多个可迭代对象，并将它们链接在一起，生成一个可迭代对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f97934481c76188aa5e65208e1bb763a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KgNtTcQ6icqryAFxkZ1feg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.chain()`的动画演示</p></figure><p id="918b" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">与此稍有不同的是<code class="fe ni nj nk nl b">itertools.chain.from_iterable()</code>，它接受一个iterables中的一个iterable，并将它的单个元素链接在一个iterable中。因此，<code class="fe ni nj nk nl b">itertools.chain.from_iterable([‘ABC’, ‘DEF’])</code>将产生与<code class="fe ni nj nk nl b">itertools.chain(‘ABC’, ‘DEF’)</code>相同的结果，即<code class="fe ni nj nk nl b">[‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’]</code>。</p><h1 id="eb22" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.compress() </strong></h1><p id="3fd6" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.compress()</code>基于布尔值的一个可迭代项过滤另一个可迭代项(称为“选择器”)。结果iterable将只包含来自输入iterable的元素，这些元素的位置对应于选择器的<code class="fe ni nj nk nl b">True</code>值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ec5bfdf31cd86640fac61260276b8bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*h-F50ZQSpl9jb_rWnXsxEA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.compress()的动画演示</p></figure><h1 id="45c6" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.dropwhile() </strong></h1><p id="20c6" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">在<code class="fe ni nj nk nl b">itertools.dropwhile</code>中，您“删除”条件为<code class="fe ni nj nk nl b">True</code>的“while”元素，并在条件第一次变为<code class="fe ni nj nk nl b">False</code>后“获取”元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/b4a77129b4fc29f7f9aa08fa9e173e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U0C2KA4cRHjJObmXiOJV2w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11:ITER tools . drop while()的动画演示</p></figure><p id="806a" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">对于图10所示的例子:</p><ul class=""><li id="3aaf" class="ly lz it ma b mb nm md nn mf oi mh oj mj ok ml ol mn mo mp bi translated">第一要素:条件为<code class="fe ni nj nk nl b">True</code> —下降</li><li id="d292" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml ol mn mo mp bi translated">第二元素:条件为<code class="fe ni nj nk nl b">True</code> —下降</li><li id="b79e" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml ol mn mo mp bi translated">第三个元素:条件为<code class="fe ni nj nk nl b">False</code> —保持所有元素</li></ul><h1 id="cb16" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.takewhile() </strong></h1><p id="445b" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.takewhile()</code>以相反的方式工作——在条件第一次变成<code class="fe ni nj nk nl b">False</code>之后，您“取”元素“而”条件是<code class="fe ni nj nk nl b">True</code>并且“放”元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/6ab7aa543a2e2e890fb5d7a1ceef246f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KF7bw7ksq5TO0Q9ytzco5w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图12:ITER tools . take while()的动画演示</p></figure><p id="a683" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">对于图11所示的例子:</p><ul class=""><li id="f3a0" class="ly lz it ma b mb nm md nn mf oi mh oj mj ok ml ol mn mo mp bi translated">第一个元素:条件为<code class="fe ni nj nk nl b">True</code> —保持</li><li id="6498" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml ol mn mo mp bi translated">第二元素:条件为<code class="fe ni nj nk nl b">True</code> —保持</li><li id="225e" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml ol mn mo mp bi translated">第三个元素:条件为<code class="fe ni nj nk nl b">False</code>——从此丢弃所有元素</li></ul><h1 id="642e" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak">ITER tools . filter false()</strong></h1><p id="7344" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.filterfalse()</code>顾名思义，只有在条件为<code class="fe ni nj nk nl b">False</code>的情况下，才保持输入的元素是可迭代的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/d4628bb80e4765176fc03a5926b6c5cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MduaCrsyDQsQRcce42_UlQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图13:ITER tools . filter false()`的动画演示</p></figure><h1 id="c753" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.starmap() </strong></h1><p id="42e3" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">通常，您可以使用<code class="fe ni nj nk nl b">map</code>将一个函数映射到一个iterable，比如一个列表。例如，<code class="fe ni nj nk nl b">map(lambda x: x*x, [1, 2, 3, 4])</code>会产生<code class="fe ni nj nk nl b">[1, 4, 9, 16]</code>。但是，如果你有一个iterables的iterable，比如一个元组列表，并且你的函数需要使用内部iterable的每个元素作为参数，你可以使用<code class="fe ni nj nk nl b">itertools.starmap()</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/e80967eaa6cb771a09ce539bf46d8f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*0fcDTXCpMGdPP6GNlOJaiw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图14:ITER tools . star map()`的动画演示</p></figure><p id="7c57" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">如果你感兴趣，可以看看下面这篇由<a class="op oq ep" href="https://medium.com/u/720e3a4ac60c?source=post_page-----454da1ddd5b8--------------------------------" rel="noopener" target="_blank"> Indhumathy Chelliah </a>撰写的文章，这篇文章详细分析了<code class="fe ni nj nk nl b">map</code>和<code class="fe ni nj nk nl b">starmap</code>之间的区别:</p><div class="or os gp gr ot ou"><a href="https://betterprogramming.pub/exploring-map-vs-starmap-in-python-6bcf32f5fa4a" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">探索Python中的Map()与Starmap()</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">让我们来了解一下不同之处</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">better编程. pub</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ks ou"/></div></div></a></div><h1 id="e923" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak"> itertools.tee() </strong></h1><p id="8d1d" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">给定一个iterable，<code class="fe ni nj nk nl b">itertools.tee()</code>产生多个独立的迭代器，由它的<code class="fe ni nj nk nl b">n</code>参数指定。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/067d73db0cf5e842d398e7629153761b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ImW1U1Ry96uM_k-hB9Bn5A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图15:ITER tools . tee()`的动画演示</p></figure><h1 id="0362" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated"><strong class="ak">ITER tools . zip _ longest()</strong></h1><p id="f527" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">内置的<code class="fe ni nj nk nl b">zip()</code>函数接受多个可迭代对象作为参数，并返回一个迭代器，我们可以用它来生成一系列由每个可迭代对象中的元素组成的元组。它要求输入的iterables长度相等。对于不同长度的可重复项，<code class="fe ni nj nk nl b">zip()</code>会导致一些信息的丢失。例如，<code class="fe ni nj nk nl b">zip(‘ABCD’, ‘12’)</code>将只返回<code class="fe ni nj nk nl b">[(‘A’, ‘1’), (‘B’, ‘2’)]</code>。</p><p id="bdbb" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.zip_longest()</code>减轻了这种限制。它的行为与<code class="fe ni nj nk nl b">zip()</code>完全相同，除了它基于最长的输入iterable“压缩”。默认情况下，不匹配的元素用<code class="fe ni nj nk nl b">None</code>填充，除非使用<code class="fe ni nj nk nl b">fillvalue</code>参数指定。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/73febbf5b464aa161b6cac881c31c1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-IDKWUmnPS2Wf24gLwewtQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图16:ITER tools . tee()`的动画演示</p></figure><h1 id="2dd3" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated">itertools.pairwise()</h1><p id="be39" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">在Python 3.10中新引入的<code class="fe ni nj nk nl b">itertools.pairwise()</code>从一个输入iterable生成连续的重叠对。如果您有一个可迭代的对象，比如一个列表或一个字符串，并且您想用一个包含两个元素的滚动窗口来迭代它，这是非常有用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/523f20c7b194a5660a9a79b04497ae96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z2n-XP70VLNj0bNyGnFSTg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图itertools.pairwise()'的动画演示</p></figure><p id="d1fc" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">这是奖金！如果你还没有使用Python 3.10，你可以定义自己的<code class="fe ni nj nk nl b">pairwise</code>函数(致谢:<a class="ae ky" href="https://mathspp.com/about" rel="noopener ugc nofollow" target="_blank"> Rodrigo </a>)。</p><pre class="kj kk kl km gt pm nl pn po aw pp bi"><span id="10a0" class="pq lh it nl b gy pr ps l pt pu">&gt;&gt;&gt; from itertools import tee<br/>&gt;&gt;&gt; def pairwise(it):<br/>&gt;&gt;&gt;    """Mimicks `itertools.pairwise()` method in Python 3.10."""<br/>&gt;&gt;&gt;     prev_, next_ = tee(it, 2) # Split `it` into two iterables.<br/>&gt;&gt;&gt;     next(next_) # Advance once.<br/>&gt;&gt;&gt;     yield from zip(prev_, next_) # Yield the pairs.</span></pre><h1 id="9b2d" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated">itertools.groupby()</h1><p id="476d" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">给定一个输入iterable，<code class="fe ni nj nk nl b">itertools.groupby()</code>返回连续的键和相应组的iterable。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/af56c1eed61c3c52b320fdfeba048099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UrGsxNJJtYS_1Xi2g6JUWA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图18:ITER tools . group by()的动画演示</p></figure><p id="3d87" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">默认情况下，<code class="fe ni nj nk nl b">itertools.groupby()</code>会在每次键值改变时生成一个中断或新组。对于图17中的例子，它将单个“A”(绿色)分组为一个单独的组，而不是将4个“A”分组在一起。如果期望的行为是根据iterable中的唯一元素进行分组，那么首先需要对输入iterable进行排序。</p><h1 id="7d31" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated">itertools.islice()</h1><p id="40cc" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated"><code class="fe ni nj nk nl b">itertools.islice()</code>是一个迭代器，在给定<code class="fe ni nj nk nl b">start</code>、<code class="fe ni nj nk nl b">stop </code>和<code class="fe ni nj nk nl b">step </code>参数的情况下，返回输入iterable中所需的元素。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pw"><img src="../Images/b12bd2cee5a28a9235ed336d537e5c3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*X0nDB6OjfKL16ikUZcBSNQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图19:` ITER tools . is lice()`的动画演示</p></figure><p id="c79a" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">您可能会想，“使用常规索引切片也可以做到这一点！”。比如<code class="fe ni nj nk nl b">‘AAABBACCC’[1:8:2]</code>会返回<code class="fe ni nj nk nl b">‘ABAC’</code>。事实证明，<code class="fe ni nj nk nl b">itertools.islice()</code>和常规的索引切片是有区别的:</p><ol class=""><li id="4a85" class="ly lz it ma b mb nm md nn mf oi mh oj mj ok ml mm mn mo mp bi translated">常规索引切片支持start、stop和step的负值，但<code class="fe ni nj nk nl b">itertools.islice()</code>不支持。</li><li id="f7d6" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated">常规索引切片创建了一个新的可迭代对象，而<code class="fe ni nj nk nl b">itertools.islice()</code>创建了一个迭代现有可迭代对象的交互器。</li><li id="4f00" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated">由于前面的原因，<code class="fe ni nj nk nl b">itertools.islice()</code>更节省内存，尤其是对于大的可重复项。</li></ol><h1 id="a20a" class="lg lh it bd li lj ns ll lm ln nt lp lq jz nu ka ls kc nv kd lu kf nw kg lw lx bi translated">结论</h1><p id="72e3" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">恭喜你走到这一步！这是大量的gif，但我希望它们能帮助你更好地欣赏令人惊叹的<code class="fe ni nj nk nl b">itertools</code>库，并且你正在编写优雅的Python代码！</p><p id="50d4" class="pw-post-body-paragraph mv mw it ma b mb nm ju mx md nn jx my mf no na nb mh np nd ne mj nq ng nh ml im bi translated">如果你觉得这篇文章有用，请在评论中告诉我。我也欢迎<em class="nr"> </em>讨论、问题和建设性反馈。以下是更多相关资源，可进一步加深您的理解:</p><ol class=""><li id="00fb" class="ly lz it ma b mb nm md nn mf oi mh oj mj ok ml mm mn mo mp bi translated"><a class="ae ky" href="https://docs.python.org/3/library/itertools.html#" rel="noopener ugc nofollow" target="_blank"/>的官方文档<code class="fe ni nj nk nl b"><a class="ae ky" href="https://docs.python.org/3/library/itertools.html#" rel="noopener ugc nofollow" target="_blank">itertools</a></code></li><li id="e9c7" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/python-iterables-vs-iterators-688907fd755f">Python中的Iterables vs迭代器</a>由<a class="op oq ep" href="https://medium.com/u/76c21e75463a?source=post_page-----454da1ddd5b8--------------------------------" rel="noopener" target="_blank"> Giorgos Myrianthous </a></li><li id="e543" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated"><a class="ae ky" href="https://medium.com/fintechexplained/advanced-python-itertools-library-the-gem-of-python-language-99da37dfcca2" rel="noopener">高级Python: Itertools库——Python语言的瑰宝</a>作者<a class="op oq ep" href="https://medium.com/u/d9b237bc89f0?source=post_page-----454da1ddd5b8--------------------------------" rel="noopener" target="_blank">法尔哈德·马利克</a></li><li id="f4e7" class="ly lz it ma b mb mq md mr mf ms mh mt mj mu ml mm mn mo mp bi translated">你应该如何——为什么——使用Python生成器</li></ol></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9682" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">在你走之前</h1><p id="644c" class="pw-post-body-paragraph mv mw it ma b mb mc ju mx md me jx my mf mz na nb mh nc nd ne mj nf ng nh ml im bi translated">如果你对类似的内容感兴趣，可以看看我下面列出的其他文章。通过<a class="ae ky" href="https://zeyalt.medium.com/" rel="noopener">媒体</a>关注我，或者通过<a class="ae ky" href="https://www.linkedin.com/in/zeyalt/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae ky" href="https://twitter.com/zeyalt_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。祝您愉快！</p><div class="or os gp gr ot ou"><a href="https://betterprogramming.pub/7-lesser-known-python-tips-to-write-elegant-code-fa06476e3959" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">编写优雅代码的7个鲜为人知的Python技巧</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">通过利用Python的内置函数和…发现用Python编写干净、优雅和可读代码的有用技巧</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">better编程. pub</p></div></div><div class="pd l"><div class="px l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://betterprogramming.pub/demystifying-look-ahead-and-look-behind-in-regex-4a604f99fb8c" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">揭开正则表达式中前瞻和后视的神秘面纱</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">使用易于理解的示例和动画gif简化正则表达式中的前视和后视</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">better编程. pub</p></div></div><div class="pd l"><div class="py l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/a-quick-and-easy-guide-to-conditional-formatting-in-pandas-8783035071ee"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">Pandas中条件格式的快速简易指南</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">了解如何对熊猫数据框架应用条件格式</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pz l pf pg ph pd pi ks ou"/></div></div></a></div><div class="or os gp gr ot ou"><a rel="noopener follow" target="_blank" href="/precision-and-recall-made-simple-afb5e098970f"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">精确度和召回变得简单</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">通过简单的例子、一步一步的解释和动画gif，使精确度和召回容易理解</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="qa l pf pg ph pd pi ks ou"/></div></div></a></div></div></div>    
</body>
</html>