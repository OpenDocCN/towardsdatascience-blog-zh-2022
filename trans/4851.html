<html>
<head>
<title>Understand Columnar and Row-Based Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解列式和基于行的数据库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-columnar-and-row-based-database-2cd29ae35bd0#2022-10-28">https://towardsdatascience.com/understand-columnar-and-row-based-database-2cd29ae35bd0#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9218" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">选择数据库前的重要一步</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71d56edf500749a9f06414b5d78caf07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KXMV80zcps4LAMDe"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Unsplash上<a class="ae ky" href="https://unsplash.com/@campaign_creators" rel="noopener ugc nofollow" target="_blank">活动创建者</a>的照片</p></figure><p id="33a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span>数据库系统中，数据可以以两种方式存储:面向行的数据存储和面向列的数据存储。通过改变数据在计算机硬盘上的存储方式，我们可以对数据库的性能产生很大的影响。这一选择还决定了它是针对事务性工作负载还是分析性工作负载进行了优化。</p><p id="08e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是解释什么是面向行和面向列的数据库。您还将了解它们的差异、优缺点以及不同的用例。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="44a6" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">数据是如何存储在磁盘上的？</h2><p id="fea6" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">为了更好地理解面向行和面向列的数据库，了解数据如何存储在磁盘中以及数据库如何读取它们是很重要的。</p><p id="4055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在硬盘上，数据被组织成最低级别的块，这是计算机一次读取磁盘的最小单位。数据库将从包含它所寻找的数据的块中加载所有信息。如果目标数据存储在较少的数据块中，数据库的运行速度会快得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/093283a088be1464ded41742aeb65c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*q5A7bQkQ40W11v07XMzSgw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据块(由<a class="nk nl ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----2cd29ae35bd0--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="d360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经发明了许多方法来以逻辑方式对数据进行分组以提高搜索效率，例如分区和聚类。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="ea0b" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">面向行的数据库</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ff1666ddae3d008fce276d68d7cb73d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*d83h5mpX1Mm_ZMr3BM165Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于行的存储(由<a class="nk nl ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----2cd29ae35bd0--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="4830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明不同存储的工作原理，我们来看一个例子。在上表中，每一行都有一个人的所有信息(如姓名、年龄、地址、邮政编码等)。</p><p id="2bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在面向行的数据库中，数据一次一行地存储在磁盘上。</strong>在本例中，块中的每个数据块都是表中的一行。这种设计非常适合OLTP(在线事务处理)应用程序，因为OLTP工作负载通常会加载一些事务，例如从单个实体中检索每个属性、向表中添加实体或从表中删除实体。Postgres和MySQL是一些最著名的面向行的数据库。写入新行很容易，因为它们只是将整行追加到现有块或新块中。</p><p id="6a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当需要同时访问大多数列时，行存储非常有用。因此，不建议使用非常宽的表，因为不可能总是需要所有的列。如果一次只需要几列，那么行存储是一个昂贵的选择，因为它将读取许多冗余信息。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="16c4" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">面向列的数据库</h2><p id="98f3" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在面向列的数据库中，数据一次一列地存储在磁盘上。对于同一个例子，每个数据块是一整列。这意味着所有的“名字”将被组合在一起，所有的“年龄”将被组合在一起，以此类推。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/c6ada19af3f08031caba7eb641d59770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*OKDbEaocn2xhKCIl26w3qg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于列的存储(由<a class="nk nl ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----2cd29ae35bd0--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="7a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得列存储对OLAP(在线分析处理)很有吸引力，因为它们最有可能执行在大量记录上聚合数据的分析工作负载。大多数查询只对列的子集感兴趣，并且它们是只读的。例如，计算顾客的平均年龄。流行的面向列的数据库是Amazon Redshift和BigQuery。</p><p id="b660" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，column-store的压缩率非常高，因为每一列都有相同的数据类型。如果您有大量数据，这一点很重要。此外，向现有表中添加新列也很容易，不需要重组所有数据。</p><p id="5abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多列数据库(如BigQuery)更喜欢非规范化的数据结构，这意味着需要进行的连接更少，因此查询可以运行得更快。另一方面，基于行的数据库更喜欢规范化数据，因为它允许更有效地将数据写入数据库。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8a4d" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">利弊</h2><p id="9926" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">面向行的数据库和面向列的数据库各有利弊。我在这里列出了一些，希望可以帮助你做决定。</p><p id="98bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">面向行的数据库</strong></p><p id="1914" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赞成的意见</p><ul class=""><li id="88b7" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">最适合OLTP应用。</li><li id="3f9c" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">插入和删除数据很容易。</li></ul><p id="9cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骗局</p><ul class=""><li id="a2dd" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">压缩率低，因此占用更多空间。</li><li id="ae1d" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">可能会读取不必要的数据。</li></ul><p id="e332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">面向列的数据库</strong></p><p id="43b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">赞成的意见</p><ul class=""><li id="dc9c" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">最适合OLAP应用。</li><li id="23d8" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">压缩率很高。简单而强大的方法，如RLE(游程编码)、位向量编码和空抑制，可以有效地用于每一列，并提供更好的压缩比，因为压缩算法对相同数据类型的值更有效。</li><li id="3b6f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">该查询根本不需要扫描不必要的列。</li><li id="82bf" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">高效的分析操作，如多行聚合。</li></ul><p id="8e73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">骗局</p><ul class=""><li id="51d1" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">读写完整记录比较慢。</li></ul><p id="43cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数云提供商中，这两种数据库类型都可供您使用，例如，Google云平台有基于行的解决方案，如Postgres和云存储，以及基于列的解决方案，如BigQuery。对于不同的用例，向基于行和基于列的数据库发送相同的数据也是一种常见的做法。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="8162" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">混合解决方案</h2><p id="b53f" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">许多公司希望在同一个数据库中处理OLTP事务和OLAP过程，以简化他们的操作。自然需要有一个混合商店。</p><p id="2f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有不同的方法来组织属性。一种方法是将相关属性组合在一起，形成一个迷你表。这些属性往往会被一起访问，因此查询可以利用行存储的优势。其余的属性可以存储在列式表中，并可以单独访问。Teradata等公司提出了一种混合行列存储解决方案，将这两种方法结合起来。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="32a9" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="e85a" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">在本文中，我们讨论了什么是面向行的数据库和面向列的数据库，以及它们的优缺点。希望你觉得有用，有启发。像往常一样，如果你有任何其他想法要分享，请留下你的评论。干杯！</p><h2 id="ba5d" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">参考</h2><div class="oc od gp gr oe of"><a href="https://www.sentinelone.com/blog/understanding-row-vs-column-oriented-databases/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">SentinelOne |了解面向行和面向列的数据库</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">可以理解的是，我们希望我们的数据库很快。我们希望为任何事情选择最合适的数据库…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.sentinelone.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>