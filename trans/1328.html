<html>
<head>
<title>Secure Your Docker Images with Docker Secrets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker机密保护您的Docker图像</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/secure-your-docker-images-with-docker-secrets-f2b92ec398a0#2022-04-04">https://towardsdatascience.com/secure-your-docker-images-with-docker-secrets-f2b92ec398a0#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6acb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">添加docker秘密，以防止您的docker图像泄露密码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf13c9cec27eabb7196f0323de5ccc54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ry7vZiufoQyA5PHY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用秘密锁住你的Docker图片(图片由<a class="ae ky" href="https://unsplash.com/@moneyphotos" rel="noopener ugc nofollow" target="_blank"> olieman.eth </a>在<a class="ae ky" href="https://unsplash.com/photos/RcvQHQB9zgA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上提供)</p></figure><p id="7cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您将机密信息泄漏到docker文件中时，您就将您的映像暴露给了各种攻击者，他们可以窃取您的凭据、控制您的容器，或者将恶意代码注入到您的容器中。这篇文章的重点是为您的Dockerfile <em class="lv">提供机密信息，而不要在生成的图像中留下任何痕迹。</em></p><p id="4916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您按照本文中的简单步骤操作时，您的映像中不会有任何机密信息。我们将讨论一个完整的示例，最后您将获得一个实现该解决方案的完整Dockerfile文件。我们来编码吧！</p><p id="1abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><em class="lv">TL；博士？</em> </strong> <em class="lv">向下滚动到“正确的方式——docker的秘密”<br/> </em> <strong class="lb iu"> <em class="lv">不熟悉Docker？</em> </strong> <em class="lv">查看</em> <a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener"> <strong class="lb iu"> <em class="lv">此文</em> </strong> </a></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="b663" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">我们在解决什么问题？</h2><p id="e01f" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">有时，您需要为Dockerfile提供像API密钥、凭证或证书这样的机密信息，例如git克隆一个私有存储库。</p><p id="a9c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要提供这些信息，而不是将其“烘焙”到图像中。如果您将凭证硬编码到docker文件中，或者将您的<code class="fe nb nc nd ne b">.env</code>文件复制到映像中，那么您的映像就会被滥用；例如，攻击者可以提取您的凭证或获得对您的容器的访问权限。即使您在docker文件中使用了某个文件后将其删除；它仍然存在于图像层中，我们稍后会发现。</p><h2 id="961f" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">解决方案:码头工人的秘密</h2><p id="b0e0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">Docker secrets允许您在Docker文件中使用机密信息，而不会留下任何痕迹。我们将在下一节探讨这是如何工作的以及为什么工作。首先，我们将设置我们的演示。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3fc9" class="nf me it bd mf ng nh ni mi nj nk nl ml jz nm ka mo kc nn kd mr kf no kg mu np bi translated">安装演示</h1><p id="47cf" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">对于本文，我们有一个真正简单的应用程序:<code class="fe nb nc nd ne b">myapp.py</code>，它只包含一行代码:<code class="fe nb nc nd ne b">print('hello’)</code>。当我们对这个脚本进行Dockerize化时，我们的Dockerfile可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e2f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">如果上面的docker文件你似乎不熟悉，请先阅读</em> <a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener"> <strong class="lb iu"> <em class="lv">这篇文章</em> </strong> </a> <em class="lv">关于docker的基础知识。</em></p><p id="aa79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe nb nc nd ne b">docker build . -t "my_app"</code>构建图像，并使用<code class="fe nb nc nd ne b">docker run my_app</code>运行容器。这只是在<a class="ae ky" href="https://mikehuls.medium.com/terminals-consoles-command-line-for-absolute-beginners-de7853c7f5e8" rel="noopener">命令行</a>上打印“hello”。太好了！一切正常。来介绍一下我们的问题。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="b880" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">添加私人内容</h2><p id="6720" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">假设我们的python应用程序想要使用我们放在私有pypi上的名为<code class="fe nb nc nd ne b">privatestuff</code>的包。我们可以用下面的pip命令安装这个包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b152" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何在docker文件中安装这个包？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="25c8" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">不好的方法——硬编码</h2><p id="9d98" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您可能想到的第一件事就是将您的凭证硬编码到docker文件中。千万别这样，这只是自找麻烦。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="53c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们只在第4行增加了一行。在这里，我们指定要安装来自<code class="fe nb nc nd ne b">my.pypicom/pypi</code>的<code class="fe nb nc nd ne b">privatestuff</code>包。除了将凭证放入我们的映像中，我们还将它们公开给每个有权访问docker文件的人。想象一下把这个项目(包含这个Dockerfile)推给github每个人都可以看到您的凭据！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="3d4d" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">也是不好的方法——构建参数</h2><p id="bdaa" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">尽管这看起来是个不错的选择，但它也非常糟糕。查看扩充的Dockerfile文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="74b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们需要三个参数，我们将通过下面的命令提供这些参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把参数传递给我们的docker文件，但是很容易从图像的层中提取它们。当我们检查docker图像的历史时，我们甚至可以看到这些值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="0937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令在我们的映像(名为“my_app”)的docker历史中进行搜索。我们用grep提取包含单词PYPI_PASS的所有文本行。这会以纯文本形式向我们显示我们的凭据！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/2b8c0fdabb0cc52a872f18e28225c8cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvGkFsm6l-0wCv8SfvQWwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker历史将显示您的构建参数(图片由作者提供)</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="06eb" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">稍微好一点，但仍然不好—使用和删除文件</h2><p id="9f8b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您可能会想到复制并删除带有凭据的a文件。在下面的例子中，我们复制了<code class="fe nb nc nd ne b">.netrc</code>；pip将使用该文件中的凭证。然后我们再次删除文件。</p><p id="e96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/mike-huls/79633dd8ef466d040f8c7c97b1d1cd22" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Mike-huls/79633 DD 8 ef 466d 040 f 8 c 7c 97 B1 D1 CD 22</a></p><p id="e45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Docker中，删除文件实际上并不会将它从映像中删除。因为Docker兑现了它的层；所有以前的层仍然存在于图像中。这意味着恶意用户可以轻松提取您的<code class="fe nb nc nd ne b">.netrc</code>文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/7df98afbe99315ad7e492cf4b1e33d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YGEGH6pUOqxC0Zo7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·莫斯霍尔德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e648" class="nf me it bd mf ng nu ni mi nj nv nl ml jz nw ka mo kc nx kd mr kf ny kg mu np bi translated">正确的方法——码头工人的秘密</h1><p id="c3d3" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们将通过这里的方法不仅是唯一安全的，而且非常容易实现！因为我是<code class="fe nb nc nd ne b">.env</code>文件的忠实粉丝，所以我们将在这个例子中使用一个。使用机密有三个简单的步骤:</p><h2 id="260e" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">1.创建一个。环境文件</h2><p id="6347" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">很简单。我们创建一个名为<code class="fe nb nc nd ne b">.env</code>的文件，并赋予它以下内容:</p><pre class="kj kk kl km gt nz ne oa ob aw oc bi"><span id="737e" class="md me it ne b gy od oe l of og">PYPI_URL=my.pypi.com/pypi<br/>PYPI_USER=m.huls<br/>PYPI_PASS=supersecretpassword</span></pre><p id="1bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">更多信息在使用环境文件</em> <a class="ae ky" href="https://mikehuls.medium.com/keep-your-code-secure-by-using-environment-variables-and-env-files-4688a70ea286" rel="noopener"> <strong class="lb iu"> <em class="lv">这里</em> </strong> </a> <strong class="lb iu"> <em class="lv">。</em> </strong> <em class="lv">更多关于用Docker </em> <a class="ae ky" href="https://mikehuls.medium.com/a-complete-guide-to-using-environment-variables-and-files-with-docker-and-compose-4549c21dc6af" rel="noopener"> <strong class="lb iu"> <em class="lv">使用env变量文件的信息在这里</em> </strong> </a> <em class="lv">。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="6d66" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">2.定义我们的docker构建命令</h2><p id="547b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">我们使用这个命令来构建我们的映像。在这里，我们将步骤1中的文件作为秘密传递给docker files<em class="lv">。</em></p><pre class="kj kk kl km gt nz ne oa ob aw oc bi"><span id="be0b" class="md me it ne b gy od oe l of og">docker build -t "my_app" --secret id=my_env,src=.env .</span></pre><p id="d9b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到上面的命令:加载<code class="fe nb nc nd ne b">.env</code>文件，并给它一个名为<code class="fe nb nc nd ne b">my_env</code>的键。我们可以在下一步使用这个键来访问<code class="fe nb nc nd ne b">.env</code>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="5a1e" class="md me it bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">3.修改Dockerfile，以便它装载机密</h2><p id="8c81" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">这里我们获取并使用我们在<code class="fe nb nc nd ne b">docker build</code>命令中传递的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，我们只是在docker文件中添加了一行额外的代码。我们<code class="fe nb nc nd ne b">mount</code> a <code class="fe nb nc nd ne b">secret</code>指定id <code class="fe nb nc nd ne b">my_env</code>(我们已经在步骤2中指定了)。接下来我们将<code class="fe nb nc nd ne b">source</code>的内容作为变量加载到<code class="fe nb nc nd ne b">.env</code>中。这就是为什么我们可以使用pip安装中指定的——extra-index-URL中的变量。</p><p id="f98c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的美妙之处在于，<code class="fe nb nc nd ne b">.env</code>文件的内容只能在引用它的<code class="fe nb nc nd ne b">RUN</code>命令中访问。这就是为什么我们必须使用<code class="fe nb nc nd ne b">&amp;&amp;</code>将支架和pip安装在一起。RUN命令完成后，秘密被丢弃，容器中不会留下任何存在的证据。Docker历史也不会包含任何信息，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/8244aeb3adf6b0be8a5a72ffeb700eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgmhDnLxtHiAWBUI692o6Q.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3fe1" class="nf me it bd mf ng nh ni mi nj nk nl ml jz nm ka mo kc nn kd mr kf no kg mu np bi translated">额外收获:这也是一个正确的方法，但更难实现</h1><p id="760c" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">您也可以使用两阶段构建；这将首先在一个阶段建立你的形象，然后只复制相关的东西到最后一个，留下所有不需要的信息，包括证书等。查看<a class="ae ky" href="https://mikehuls.medium.com/using-multi-stage-builds-to-make-your-docker-image-almost-10x-smaller-239068cb6fb0" rel="noopener"> <strong class="lb iu">这篇文章</strong> </a>了解Docker中多阶段构建的更多信息。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="94f3" class="nf me it bd mf ng nh ni mi nj nk nl ml jz nm ka mo kc nn kd mr kf no kg mu np bi translated">结论</h1><p id="5a36" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li my lk ll lm mz lo lp lq na ls lt lu im bi translated">在这篇文章中，我们已经经历了3种不处理docker图像中的秘密的方法和一种更简单、正确、安全的方法。硬编码凭证是非常愚蠢的，build-args不会救你，甚至删除图像中的凭证文件也会在删除后留在层中。</p><p id="2e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker secrets是一种非常安全且易于使用的机密信息，一旦使用，就可以将其删除。通过这篇文章，我希望你的docker图片更加安全。如果您有建议/澄清，请评论，以便我可以做出改进。同时，看看我的<a class="ae ky" href="http://mikehuls.com/articles" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">其他关于各种编程相关主题的文章</strong> </a>，比如:</p><ul class=""><li id="de49" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-for-absolute-beginners-what-is-docker-and-how-to-use-it-examples-3d3b11efd830" rel="noopener"> Docker适合绝对初学者</a></li><li id="29f2" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/docker-compose-for-absolute-beginners-how-does-it-work-and-how-to-use-it-examples-733ca24c5e6c" rel="noopener"> Docker为绝对初学者编写</a></li><li id="7225" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/turn-your-code-into-a-real-program-packaging-running-and-distributing-scripts-using-docker-9ccf444e423f" rel="noopener">把你的代码变成一个真正的程序:使用Docker打包、运行和分发脚本</a></li><li id="55bb" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-and-publish-your-own-python-package-ea45bee41cdc" rel="noopener">创建并发布自己的Python包</a></li><li id="23ae" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893" rel="noopener">创建您的定制私有Python包，您可以从您的Git库PIP安装该包</a></li><li id="ddb0" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/advanced-multi-tasking-in-python-applying-and-benchmarking-threadpools-and-processpools-90452e0f7d40" rel="noopener">Python中的高级多任务处理:应用线程池和进程池并进行基准测试</a></li><li id="5579" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">写你自己的C扩展来加速Python x100 </li><li id="ae28" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated">【Cython入门:如何在Python中执行&gt;每秒17亿次计算</li><li id="dc80" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><a class="ae ky" href="https://mikehuls.medium.com/create-a-fast-auto-documented-maintainable-and-easy-to-use-python-api-in-5-lines-of-code-with-4e574c00f70e" rel="noopener">用FastAPI用5行代码创建一个快速自动归档、可维护且易于使用的Python API</a></li></ul><p id="e887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p><p id="961d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">—迈克</p><p id="5bc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">页（page的缩写）学生:比如我正在做的事情？<a class="ae ky" href="https://mikehuls.medium.com/membership" rel="noopener">跟我来</a>！</p><div class="ow ox gp gr oy oz"><a href="https://mikehuls.medium.com/membership" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">通过我的推荐链接加入Medium—Mike Huls</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">mikehuls.medium.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div></div></div>    
</body>
</html>