<html>
<head>
<title>What is Variable Rate Shading and Why Big Players are Rushing to Get It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是可变比率阴影，为什么大玩家争相获取它</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-is-variable-rate-shading-and-why-big-players-are-rushing-to-get-it-ea90a71a5d98#2022-10-05">https://towardsdatascience.com/what-is-variable-rate-shading-and-why-big-players-are-rushing-to-get-it-ea90a71a5d98#2022-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7830" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">最先进的优化实现了40%以上的渲染成本降低</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cc07f6e464152868ce10117f72bdcbee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cDlexu3FlF5j-m7cPmWNtw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3942" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">小时候经常玩——魔兽世界:冰封状态，极品飞车:地下，波斯王子:时之沙，GTA:副城和使命召唤4:现代战争。当时，这些游戏看起来很疯狂——“贴近生活”的图形、逼真的动作和过热的电脑。</p><p id="50ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新游戏中场景和视觉效果的日益复杂，加上新技术，如增强和虚拟现实，更高的帧速率，达到每秒120帧，分辨率和动态范围推高了渲染成本。</p><p id="2e7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">GPU设计的最新进展开辟了一种新的方法来降低计算成本，同时对视觉质量的影响最小——可变速率着色(VRS)。</p><p id="2761" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">VRS允许动态选择像素块的阴影率—更低的阴影率—更高的效率和更低的质量。更高的着色率-更高的质量，但也有更高的计算要求。因此，目标是在质量和计算之间取得平衡。</p><p id="0e9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最先进的技术声称在不损失质量的情况下，渲染时间减少了40%。很好，不是吗？</p><p id="0f46" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面，我将简要介绍渲染管道、可变速率着色的一般方法，并讨论最新的解决方案，如来自NVIDIA、微软和AMD的解决方案，以及尚未上市的学术进展。</p><h1 id="b62c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">渲染管道</h1><p id="776d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">渲染管道的目标是获取世界的3D模型，并转换成可以在屏幕上显示的2D表示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/326634149d04a7516503fd0a6fde82dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHRZHaplrd23Q8dO1DkxTA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图形管道。图片由C. Vetter提供。</p></figure><p id="ab31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">场景的原始3D模型(顶点)在转换为像素之前要经过几个阶段。顶点首先通过顶点着色器跨图元(三角形或直线)进行插值。然后用几何着色器对这些进行细化。裁剪用于裁剪延伸到单位立方体之外的对象或对象的一部分(用于容纳显示的空间)。光栅化将形状的3D空间转换为光栅化图像(像素)。然后，片段着色器识别每个像素的颜色，并在帧缓冲操作后生成最终图像。</p><p id="3207" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文的重点是片段着色器。对于每个像素，我们需要从我们要显示的纹理中查找它的颜色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/77b97a2e99c3f56f55d185dd75bdd836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oe4P9FjJYrd9ruzeAWFF3A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">抽样示例。图片由作者提供。</p></figure><p id="6955" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对每个像素的颜色进行采样是非常昂贵的。例如，对于1920 × 1080分辨率，需要2，073，600次查找。正如我们将在下面看到的，这个数字可以通过VRS大大减少。</p><p id="a1e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你有兴趣了解更多关于图形管道的知识，请查看YouTube频道。</p><h1 id="a879" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">可变比率阴影—一般原则</h1><p id="c685" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">为每个像素查找颜色非常耗时，虽然我们可以依靠高度<a class="ae mp" rel="noopener" target="_blank" href="/scientific-computing-lessons-learned-the-hard-way-db651f8f643a">并行的GPU</a>来进行这些独立的计算，但实现高帧率仍然具有挑战性。VRS允许我们通过识别像素块来减少处理工作，我们可以通过查找一次来分配相同的颜色，而不会明显降低质量。</p><p id="f396" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑下图。对于某些区域，我们可以在没有明显变化的情况下降低颜色估计的准确性。这些可能是图像中快速移动的区域——例如，车轮后面的区域、眼睛焦点周围的区域、游戏中由于雾而能见度降低的区域，或者颜色均匀的区域。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/18230f40b9b1e779bca1ec17de1cb032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O9xiU6p3Eoqswt2A1BeVIQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第二层可变比率阴影。作者图片</p></figure><h2 id="e1b1" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">两种类型的虚拟现实</h2><p id="e412" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">根据VRS的实现方式，我们可以通过两种方式为像素块分配颜色:</p><ul class=""><li id="ac9a" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated"><strong class="kx ir">第1层</strong>是基于每次绘制着色率的<strong class="kx ir"> </strong>。例如，我们可以指定半透明背后的资产具有较低的着色率，或者指定策略游戏中的水应该以较低的着色率着色，而森林应该以较高的着色率着色。</li><li id="f7b4" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated"><strong class="kx ir"> Tier 2 </strong>类型允许在绘图中以更高的粒度指定阴影率。例如，我们可以选择指定了相同阴影率的像素块。描述如何应用VRS的数据结构称为VRS-map(也称为VRS-texture)。每个位置保存要应用于图块的着色率(具有相同着色率的像素区域)。拼贴大小和阴影率取决于硬件实现。然而，最常见的瓷砖尺寸是16x16和8x8以及1x1、1x2、2x1、2x2、2x4、4x2、4x4的阴影率。</li></ul><p id="880c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将重点介绍第2层VRS，因为它提供了更多的灵活性和潜在的节省。</p><h2 id="5d4d" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">总则</h2><p id="d50f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">像许多计算机图形技术一样，VRS利用人眼的低效率来减少计算，同时保持渲染图像的质量与参考图像一致。</p><p id="d9c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据可用的数据和硬件，我们可以基于以下因素降低阴影率:</p><ul class=""><li id="1da0" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated"><strong class="kx ir">有凹渲染</strong>。我们可以依靠眼睛跟踪，并使用有凹渲染来降低头戴式设备的眼睛焦点外围的图像的阴影率。然而，由于它需要额外的硬件能力，所以我不会在本文中涉及太多的细节。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/ca055c3cf724484f9a997d227c56ee12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_b73Y6WV4lcu-g__Ll_HCA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">有凹渲染。图片由作者提供。</p></figure><ul class=""><li id="8de2" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated"><strong class="kx ir">空间频率</strong>。也许降低阴影率最直接的方法是寻找颜色一致的区域。有许多方法可以做到这一点，但大多数方法依赖于梯度信息估计(例如边缘检测)来识别低频区域。</li><li id="e156" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated"><strong class="kx ir">议案。</strong>快速移动的物体将被我们的视觉系统平滑处理——使这些区域呈现出快速、平滑的变化，这与降低阴影率是完美的匹配。这些方法依赖于运动矢量，而运动矢量在实践中通常是不可用的。</li></ul><h2 id="3572" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">估计VRS地图</h2><p id="8c97" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">为了估计当前帧的VRS贴图，我们需要找到该帧中可以应用降低的阴影率的区域。然而，由于该帧还没有被渲染，我们将依赖于来自过去的、已经被渲染的帧的信息来估计当前帧的着色率。根据现有信息，我们可以:</p><ul class=""><li id="77e0" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">使用可从先前渲染阶段获得的运动矢量，然后重新投影先前帧以获得当前帧的估计；</li><li id="8237" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">例如，使用基于流、块匹配、基于神经网络和基于摄像机运动的方法，即时计算运动矢量。</li><li id="671e" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">使用没有重新投影的前一帧，假设场景中的变化很小，这在实践中经常成立。</li></ul><h1 id="6714" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">最先进的VRS</h1><p id="dc9c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">VRS是一项非常强大的技术，如果应用得当，可以显著提升游戏性能。因此，大多数主要的游戏引擎和GPU供应商都在寻找将VR集成到他们的生态系统中的方法。</p><h2 id="f2c3" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated"><strong class="ak">微软VRS (MSFT-VRS) </strong></h2><p id="88c6" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">来自微软的各种版本的VRS解决方案已经在2021年的游戏开发者大会上展示过，并在2022年的延期闪电和2022年的XboX中的应用中讨论过。Jacques van Rhyn也发表了一系列博客文章，强调技术细节和性能基准测试:<a class="ae mp" href="https://devblogs.microsoft.com/directx/variable-rate-shading-a-scalpel-in-a-world-of-sledgehammers/" rel="noopener ugc nofollow" target="_blank">博客文章#1 </a>、<a class="ae mp" href="https://devblogs.microsoft.com/directx/gears-tactics-vrs/" rel="noopener ugc nofollow" target="_blank">博客文章#2 </a>、<a class="ae mp" href="https://devblogs.microsoft.com/directx/gears-vrs-tier2/" rel="noopener ugc nofollow" target="_blank">博客文章#3 </a>。</p><p id="0dac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">微软的Tier 2 VRS通过对来自前一帧的sRGB彩色缓冲器的亮度运行Sobel边缘检测器来为当前帧生成VRS图。对最终颜色值运行边缘检测器具有优势；例如，它捕捉由于后期处理效果而模糊的区域。我们可以使用一个可配置的阈值，这取决于边缘检测器需要多强。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/83b030533491f49ec711d12ffbf6b06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpI4PKIcU7DBV_0Z8gP-HA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">边缘检测的示例-边缘被识别的区域会看到较高的阴影率。图片由作者提供。</p></figure><h2 id="a02d" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">NVIDIA自适应着色(NAS)</h2><p id="7c31" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">NVIDIA在一篇名为<a class="ae mp" href="https://dl.acm.org/doi/abs/10.1145/3320287" rel="noopener ugc nofollow" target="_blank">游戏中视觉无损内容和运动自适应阴影的论文中正式描述了其VRS解决方案</a>。正如这篇文章的名字所示，两个方面影响了VRS贴图的计算:<em class="nu">错误</em>，这将由应用较低的阴影率和<em class="nu">运动</em> <em class="nu">模糊</em>产生。</p><p id="d462" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">误差计算:</strong>下图给出了阴影率减半的1D信号的误差计算示例。该误差被定义为相邻像素的亮度导数。使用算术平均值、“均方误差”或“最大值”对每个图块的最终误差求和。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/238612527d2fae272113bec62f5e4021.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_AdA46YjaydrUCgug5-HLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><p id="e127" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于2D图像块，在水平和垂直方向上计算误差。因此，垂直和水平阴影率是独立评估的。</p><p id="8fa9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">运动模糊:</strong>由降低的阴影率引起的误差可能被运动模糊隐藏。NVIDIA区分了两种可能影响最终着色率的模糊类型:</p><ul class=""><li id="4013" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">由引擎作为特殊效果引入的模糊。</li><li id="1b58" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">液晶显示器的持续模糊。在渲染下一个屏幕之前，在屏幕上显示图像；这在物体运动中引入了不连续性。当眼睛以线性、连续的运动跟踪物体时，物体在视网膜上模糊，产生模糊的外观。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/660f27f2e261fe90cb79bab3e69dffb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xpo25q0NmQX4stTe3JJ2xw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><p id="93c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">游戏开发者大会上也展示了NAS，这里有<a class="ae mp" href="https://www.leiy.cc/publications/nas/nas-gdc19.pdf" rel="noopener ugc nofollow" target="_blank">张幻灯片</a>。对于那些想要尝试的人来说，NVIDIA已经发布了<a class="ae mp" href="https://github.com/NVIDIAGameWorks/nas-sample" rel="noopener ugc nofollow" target="_blank">可以为<a class="ae mp" href="https://www.vulkan.org" rel="noopener ugc nofollow" target="_blank"> Vulkan </a>编译的代码</a>。你可能也有兴趣看看这个<a class="ae mp" href="https://www.youtube.com/watch?list=TLGG6WmhwX92xDEyNTA5MjAyMg&amp;time_continue=1&amp;v=Hgl9eTJio8Q&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank"> SIGGRAPH演示</a>，NVIDIA在这里展示了其早期版本的VRS。</p><h2 id="5ff6" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">AMD保真FX</h2><p id="865f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">与微软和英伟达的解决方案类似，在他们的设计中，<a class="ae mp" href="https://www.youtube.com/watch?v=LqpqYx3AiAQ" rel="noopener ugc nofollow" target="_blank"> AMD FidelityFX VRS </a>依赖于估计相邻像素之间的梯度。</p><p id="f27c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">AMD VRS使用8×8的拼贴大小，并分析2×2区域内的像素对。基于区块内2×2块中的像素对之间的最大亮度增量来设置阴影率。类似于上面的方法，该方法具有控制质量和节省之间的折衷的可调阈值。</p><p id="dce9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果包括运动矢量，该方法可以基于运动的强度减少增量。</p><p id="d71c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">即使网上没有很多关于AMD解决方案的资源，你也可以在<a class="ae mp" href="https://github.com/GPUOpen-Effects/FidelityFX-VariableShading" rel="noopener ugc nofollow" target="_blank">代码中查看具体的实现</a>！</p><h1 id="9fcd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">动态采样率(DSR)</h1><p id="a007" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">与之前在空间域操作的方法不同，<a class="ae mp" href="https://arxiv.org/abs/2202.10533" rel="noopener ugc nofollow" target="_blank">动态采样率</a>分析离散余弦变换(DCT)空间中图块的频率信息。</p><p id="0732" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该方法分析系数的2D DCT矩阵，以确定该图块的当前采样率是否是最佳的。DCT系数被聚合成一个值，该值概括了图块中的高频信息量。当前帧的着色率基于预设的阈值和着色贴图的先前状态。</p><p id="ef71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过使用来自先前VRS图的信息来决定当前的着色率，该方法解决了时间不稳定性的问题。考虑一个静态场景的例子，在步骤[t-1]，我们决定降低阴影率。我们的决定基于这样的观察，即估计误差略低于保持较高遮光率的阈值。在步骤[t],具有降低的阴影率的区块看到误差稍微增长并超过阈值。因此，我们增加了阴影率。在帧[t+1]处，重复这种情况。同一拼贴的阴影率的这种变化导致闪烁。</p><p id="277b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了缓解阈值附近误差的微小变化导致闪烁的问题，该方法被实现为有限状态机。控制状态之间转换的阈值对于转换到增大和减小的遮光率是不同的。选择这些值是为了使值的微小变化不会导致图块的阴影率变化。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/a85bf7654441e493d5d00107379b10fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdg5eBC-y03IulUC6YqN8Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">采样率最终状态机。Marti Anglada 提供的图片。</p></figure><h1 id="b6ea" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">自适应采样和刷新率(ALSaRR)</h1><p id="9ef9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">本文中讨论的最复杂和感知最准确的可变速率着色工作称为<a class="ae mp" href="https://www.cl.cam.ac.uk/research/rainbow/projects/alsarr/" rel="noopener ugc nofollow" target="_blank">自适应局部着色和刷新率感知模型</a>。与其他旨在找到在质量和节约之间取得平衡的着色率的方法不同，该模型确定了固定预算下的最佳帧速率和VRS贴图。</p><p id="34c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该模型将运动矢量、亮度和MIP ID图作为输入。基于质量评估模型，该方法估计每个VRS-map配置的所有可能的质量水平。然后，该模型使用贪婪背包解算器，从粗略着色率图开始，并基于质量与带宽的排序比率逐渐增加着色率。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/cbc14ea26df8340652d2969694412a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbQmxmZk7tb6KKIe5nsR7Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ALSaRR管道。<a class="ae mp" href="https://www.cl.cam.ac.uk/research/rainbow/projects/alsarr/" rel="noopener ugc nofollow" target="_blank">图片由阿克谢·金达尔拍摄。</a></p></figure><p id="0cdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">流水线中最重要的部分是质量模块，它估计由较低的阴影率引入的误差。质量估计器完全基于感知模型。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/713b0bedef6da40ba19dc5df0c5a62c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C71OzeHZoCBYxUGestt9NQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图像质量模块。<a class="ae mp" href="https://www.cl.cam.ac.uk/research/rainbow/projects/alsarr/" rel="noopener ugc nofollow" target="_blank">图片由阿克谢·金达尔拍摄。</a></p></figure><p id="ee31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当对图像应用降低的阴影率时，该模型假设傅立叶空间中的质量退化管道。在此管道中，纹理首先由小中见大贴图选择进行转换；然后，通过应用的VRS对图像的所选小中见大贴图进行下采样。然后，该模型假设显示对象的运动引入了模糊，这是保持类型和眼睛运动模糊的组合。在模糊滤波器之后，剩余的频谱通过<a class="ae mp" rel="noopener" target="_blank" href="/deep-image-quality-assessment-30ad71641fac">对比灵敏度函数(CSF) </a>，滤除人眼不可见的频率。将结果与通过CSF的原始参考信号进行比较，并获得质量分数。</p><h1 id="e96a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">警告和总结</h1><p id="f3f8" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">估计VRS图所花费的时间不应大于所带来的计算节省。因此，VRS方法通常依赖于不需要太多计算工作的非常直接的计算机视觉技术。总体而言，由于问题的性质，第2层VRS在以更高的分辨率运行时会获得更高的性能增益。</p><p id="8a84" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述每个VRS解决方案都降低到2x2着色率，因为较粗糙的着色会引入明显的伪像。</p><h2 id="1f6e" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">资源</h2><p id="dbdc" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated"><a class="ae mp" href="https://www.youtube.com/c/cmyuksel" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>有很酷的计算机图形学讲座；</p><p id="84d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">微软VRS: </strong> <a class="ae mp" href="https://www.youtube.com/watch?v=pPyN9r5QNbs" rel="noopener ugc nofollow" target="_blank">在2021游戏开发者大会上的演示</a>，<a class="ae mp" href="https://www.youtube.com/watch?v=Sswuj7BFjGo" rel="noopener ugc nofollow" target="_blank">2022年VRS应用于differed lightning</a>，<a class="ae mp" href="https://www.youtube.com/watch?v=pPyN9r5QNbs" rel="noopener ugc nofollow" target="_blank">2022年XboX中的VRS</a>，<a class="ae mp" href="https://devblogs.microsoft.com/directx/variable-rate-shading-a-scalpel-in-a-world-of-sledgehammers/" rel="noopener ugc nofollow" target="_blank">博文#1 </a>，<a class="ae mp" href="https://devblogs.microsoft.com/directx/gears-tactics-vrs/" rel="noopener ugc nofollow" target="_blank">博文#2 </a>，<a class="ae mp" href="https://devblogs.microsoft.com/directx/gears-vrs-tier2/" rel="noopener ugc nofollow" target="_blank">博文#3 </a>。</p><p id="9696" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> NVIDIA VRS: </strong> <a class="ae mp" href="https://dl.acm.org/doi/abs/10.1145/3320287" rel="noopener ugc nofollow" target="_blank">论文</a>，<a class="ae mp" href="https://www.youtube.com/watch?list=TLGG6WmhwX92xDEyNTA5MjAyMg&amp;time_continue=1&amp;v=Hgl9eTJio8Q&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank"> SIGGRAPH演示文稿</a>，<a class="ae mp" href="https://www.leiy.cc/publications/nas/nas-gdc19.pdf" rel="noopener ugc nofollow" target="_blank">游戏开发者大会幻灯片</a>，<a class="ae mp" href="https://github.com/NVIDIAGameWorks/nas-sample" rel="noopener ugc nofollow" target="_blank">代码</a>。</p><p id="e87f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">AMD VRS:</strong><a class="ae mp" href="https://www.youtube.com/watch?v=LqpqYx3AiAQ" rel="noopener ugc nofollow" target="_blank">AMD fidelity FX VRS演示</a>，<a class="ae mp" href="https://github.com/GPUOpen-Effects/FidelityFX-VariableShading" rel="noopener ugc nofollow" target="_blank">代码</a></p><p id="9abb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> DSR VRS: </strong> <a class="ae mp" href="https://arxiv.org/abs/2202.10533" rel="noopener ugc nofollow" target="_blank">动态采样率论文</a></p><p id="0397" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> ALSaRR VRS: </strong> <a class="ae mp" href="https://www.cl.cam.ac.uk/research/rainbow/projects/alsarr/" rel="noopener ugc nofollow" target="_blank"> ALSaRR项目页面</a></p><p id="7202" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在准备这篇文章的时候，我还发现了<a class="ae mp" href="http://filmicworlds.com/blog/software-vrs-with-visibility-buffer-rendering/" rel="noopener ugc nofollow" target="_blank">这篇关于可变速率阴影的博客文章</a>，你可能会觉得有用。</p><p id="30dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述方法假设VRS的硬件实现。也有基于软件的实现，允许在技巧上有更多的灵活性，如<a class="ae mp" href="https://research.activision.com/publications/2020-09/software-based-variable-rate-shading-in-call-of-duty--modern-war" rel="noopener ugc nofollow" target="_blank"> CoD-VRS </a>。用于减少闪烁的一个非常酷的技巧是从依赖于多个先前帧的重投影帧中累积梯度，以试图平滑时间伪影，例如VRS-map闪烁。</p><h2 id="4074" class="ms ls iq bd lt mt mu dn lx mv mw dp mb le mx my md li mz na mf lm nb nc mh nd bi translated">喜欢作者？保持联系！</h2><p id="ebe9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我错过了什么吗？不要犹豫，直接在<a class="ae mp" href="https://www.linkedin.com/in/aliakseimikhailiuk/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>或<a class="ae mp" href="https://twitter.com/mikhailiuka" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上给我留言、评论或发消息吧！</p><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/scientific-computing-lessons-learned-the-hard-way-db651f8f643a"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">科学计算——惨痛的教训</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">深入介绍科学计算—从CPU、GPU和HPC集群到最常用的框架— OpenMP、MPI和…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kp oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/on-the-edge-deploying-deep-applications-on-constrained-devices-f2dac997dd4d"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">在边缘——在移动设备上部署深度学习应用</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">在受限设备上实现深度神经网络的效率-精度折衷的技术</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq kp oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/deep-image-quality-assessment-30ad71641fac"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">深度图像质量评估</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">深入研究全参考图像质量评估。从主观画质实验到深层客观…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="os l on oo op ol oq kp oc"/></div></div></a></div></div></div>    
</body>
</html>