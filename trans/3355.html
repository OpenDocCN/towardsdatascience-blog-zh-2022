<html>
<head>
<title>Tidy Production Pandas with Hamilton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与汉密尔顿一起整理生产熊猫</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tidy-production-pandas-with-hamilton-3b759a2bf562#2022-07-26">https://towardsdatascience.com/tidy-production-pandas-with-hamilton-3b759a2bf562#2022-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="76ee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">与汉密尔顿一起编写生产级熊猫代码。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d764871eaab6e0eed17139d121f12d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bW54rk2Rov-Be4w5xGC9NQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">你的熊猫与汉密尔顿代码。图片来自Pixabay。</p></figure><p id="edf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">“<strong class="kx ir"/>&amp;<a class="ae lr" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">熊猫</strong> </a>”这两个词通常不会被联系在一起，更不用说与单词“<strong class="kx ir">生产</strong>”联系在一起了。在这篇文章中，我会说如果你在生产中使用Pandas，你应该使用开源微框架<a class="ae lr" href="https://github.com/DAGWorks-Inc/hamilton" rel="noopener ugc nofollow" target="_blank"> Hamilton </a>，因为它可以让你在默认情况下编写整洁的生产级代码。</p><p id="cfa0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可能会想？这篇文章是关于熊猫的吗？是的，从整洁的代码的精神来看，但从如何实现的角度来看却不是。</p><p id="9de7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，在我们开始之前，先说明一下我们的术语:</p><p id="709f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">生产</strong>:我们所说的生产是指为了使业务流程正常运行，需要运行这段代码。例如，为机器学习模型创建特征，或者将数据转换为仪表板工具。</p><p id="f750" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">整洁:整洁意味着代码是可读的、可维护的和可测试的。我们过分强调了你的代码长时间存活的能力；您的产品代码通常比您预期的寿命更长，所以让我们让它更容易维护。另一种思考方式是，我们希望您的熊猫代码能够方便地促进软件工程最佳实践。</p><h1 id="dc1c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">熊猫生产问题</h1><p id="5c58" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">关于熊猫代码是否应该在产品中运行，业界有很多不同意见。虽然这对于快速的原型和研究来说显然是很棒的，但是熊猫繁重的代码库经常会被自己绊倒；软件工程最佳实践很难遵循。</p><p id="019f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这下一节应该是所有的头点头；在生产中使用熊猫时感觉到的常见油漆点。</p><h2 id="b0fd" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">集成测试和单元测试是一个挑战</h2><p id="4388" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">熊猫代码通常被写成线性python脚本。这很可能是因为它最初是从一个<a class="ae lr" href="https://jupyter.org/hub" rel="noopener ugc nofollow" target="_blank"> Jupyterhub </a>笔记本的不同单元中的代码开始的，这些单元本身是线性执行的。这种方法使得长时间测试变得困难。当然，当你开发脚本时，你也在“测试”它。但是一旦投入生产，时间可能会流逝，数据的背景可能会改变。例如，如果您需要调整正在运行的生产熊猫代码，您如何确信您所做的更改不会产生负面影响？单元测试很可能不存在，或者测试覆盖率参差不齐；编写内联Pandas操作很容易做到，但很难进行编程测试。而集成测试通常涉及到运行整个脚本。如果它进行大量的计算，这意味着测试所有东西的迭代周期很慢，或者可能完全跳过测试。</p><h2 id="be94" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">文档不存在</h2><p id="ef08" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">文档对于协作和代码维护至关重要。如果您习惯于编写内联创建一堆列的Pandas代码(因为这很容易做到)，那么您总是会牺牲文档。文档应该容易呈现，并与代码同步。一旦你开始把文档放在代码之外，它就很容易过时…</p><h2 id="b20c" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">代码很难重用</h2><p id="3442" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">通常会看到一个python文件包含所有的熊猫代码:提取数据的逻辑、执行转换的逻辑和保存输出的逻辑。这意味着这个脚本中的转换函数不容易访问或重用。有些人反驳说“我就重构”，但这种情况会发生几次呢？人们最终会剪切和粘贴代码，或者一遍又一遍地重新实现相同的逻辑。</p><h2 id="89b6" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">除了你，没人懂你的熊猫密码</h2><p id="8a49" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">作为一名前数据科学家，我切身体会到继承他人代码的可怕之处。熊猫是一个强大的工具，但每个人使用它的方式不同。考虑到上面提到的测试、文档和可重用性，至少可以说，拥有别人的Pandas代码是令人生畏的。</p><h1 id="8dd7" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">哈密尔顿</h1><p id="4b2f" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/DAGWorks-Inc/hamilton" rel="noopener ugc nofollow" target="_blank"> Hamilton </a>就是为了解决上面引出的问题而建造的——把一个杂乱的熊猫代码库变成一个<em class="ls">整洁的</em>。不，与你可能知道和喜爱的R tidyverse不完全相同，但在精神上是相同的…</p><h2 id="65b6" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">什么是汉密尔顿？</h2><p id="3453" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">Hamilton是用于指定<a class="ae lr" href="https://en.wikipedia.org/wiki/Dataflow" rel="noopener ugc nofollow" target="_blank">数据流</a>的声明性范例。这只是学术上的说法:</p><ol class=""><li id="a995" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">通过在函数定义中直接编码，您可以编写python函数来声明它们输出什么以及它们依赖什么。</li><li id="fcc8" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">您编写这些python函数来指定数据和计算应该如何流动，即数据流(也称为管道/工作流)。</li></ol><p id="2a2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在代码中，这意味着:</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="2cca" class="mq lu iq nr b gy nv nw l nx ny">df['age_mean'] = df['age'].mean()<br/>df['age_zero_mean'] = df['age'] - df['age_mean']</span></pre><p id="c874" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你写作</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="9d0e" class="mq lu iq nr b gy nv nw l nx ny"># a_function_module.py<br/>def age_mean(age: pd.Series) -&gt; float:<br/>    <em class="ls">"""Average of age"""<br/>    </em>return age.mean()<br/><br/>def age_zero_mean(age: pd.Series<strong class="nr ir">, </strong>age_mean: float) -&gt; pd.Series:<br/>    <em class="ls">"""Zero mean of age"""<br/>    </em>return age - age_mean</span></pre><p id="4da2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，您必须编写一些“<em class="ls">驱动程序</em>”代码来实际执行计算。“<em class="ls">驱动程序</em>”代码的职责是实例化什么函数可以并且应该被计算，以及如何计算。</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="4500" class="mq lu iq nr b gy nv nw l nx ny">import pandas as pd<br/>from hamilton import driver<br/>import a_function_module # where your transforms live</span><span id="86ac" class="mq lu iq nr b gy nz nw l nx ny">config_and_inputs = {'age': pd.Series([...])}<br/>dr = driver.Driver(config_and_inputs<strong class="nr ir">, </strong>a_function_module)</span><span id="ca43" class="mq lu iq nr b gy nz nw l nx ny"># here we're constructing a data frame with only two columns<br/>df = dr.execute(['age', 'age_zero_mean'])</span></pre><p id="ce04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们将跳过对汉密尔顿的详细介绍，而是链接到以前的介绍:</p><ul class=""><li id="ed1d" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq oa ni nj nk bi translated"><a class="ae lr" rel="noopener" target="_blank" href="/how-to-use-hamilton-with-pandas-in-5-minutes-89f63e5af8f5">如何在5分钟内对熊猫使用汉密尔顿</a></li><li id="34a3" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated"><a class="ae lr" rel="noopener" target="_blank" href="/functions-dags-introducing-hamilton-a-microframework-for-dataframe-generation-more-8e34b84efc1d">一般背景故事&amp;汉密尔顿简介</a></li></ul><p id="7020" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则你只需要<code class="fe ob oc od nr b">pip install sf-hamilton</code>就可以开始了。</p><h2 id="517f" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">为什么使用Hamilton会产生整洁的熊猫代码？</h2><p id="897b" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">以下是四个主要原因:</p><ol class=""><li id="015b" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">可测试代码，<strong class="kx ir">总是</strong>。</li><li id="0070" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">文档友好代码，<strong class="kx ir">总是</strong>。</li><li id="2a9f" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">可重用逻辑，<strong class="kx ir">总是</strong>。</li><li id="9ace" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">运行时数据质量检查，<strong class="kx ir">总是</strong>。</li></ol><p id="a39a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用下面的函数来讨论这几点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例哈密尔顿函数</p></figure><h2 id="7dff" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">可测试的代码，总是</h2><p id="2014" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">Hamilton迫使您编写与指定数据如何到达函数无关的函数。这意味着总是为<em class="ls">单元测试</em>提供输入是很简单的。在上面的函数中，提供<code class="fe ob oc od nr b">height_zero_mean</code>和<code class="fe ob oc od nr b">height_std_dev</code>只是为每一个拿出一个有代表性的熊猫系列来测试这个函数；在定义函数时，我们没有指定如何提供输入。</p><p id="f379" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">类似地，人们可以很容易地用Hamilton端到端地测试上述函数。你只需要将计算<code class="fe ob oc od nr b">height_zero_mean_unit_variance</code>指定给“<em class="ls">驱动</em>”代码，它就会执行产生<code class="fe ob oc od nr b">height_zero_mean_unit_variance.</code>所需的功能，这样即使是集成测试周期也会相对较快。您不需要运行整个脚本并计算一切来测试单个更改。即:</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="df8f" class="mq lu iq nr b gy nv nw l nx ny">df = dr.execute(['<!-- -->height_zero_mean_unit_variance<!-- -->'])</span></pre><h2 id="baa4" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">文档友好的代码，总是这样。</h2><p id="016b" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">Hamilton有四个有助于文档的功能:</p><ol class=""><li id="ed7f" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated"><strong class="kx ir">功能</strong>。通过使用函数作为抽象，人们可以自然地通过函数的<a class="ae lr" href="https://www.programiz.com/python-programming/docstrings" rel="noopener ugc nofollow" target="_blank"> docstring </a>插入文档。然后，这可以与工具连接，如<a class="ae lr" href="https://www.sphinx-doc.org/en/master/" rel="noopener ugc nofollow" target="_blank"> sphinx </a>来更广泛地展示这些。</li><li id="0690" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><strong class="kx ir">命名</strong>。汉密尔顿强迫<em class="ls">命名</em>成为你脑海中的焦点。由于驱动程序<code class="fe ob oc od nr b">.execute() </code>函数请求的列名与您(或同事)编写的函数相对应，描述性的、简洁的名称逐渐成为规范。此外，从函数名到函数参数，代码读起来自然而直观；使用Hamilton时，很难命名任何重要的东西`<a class="ae lr" href="https://en.wikipedia.org/wiki/Foobar" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> foobar </em> </a>`。</li><li id="4103" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><strong class="kx ir">可视化</strong>。Hamilton可以生成一个graphviz文件图像，该图像可以生成函数如何联系在一起的图形表示。这是帮助人们了解全局的重要工具。例如，请参见下面的可视化示例。</li><li id="7a1d" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated"><strong class="kx ir">标签</strong>。Hamilton使人们能够通过注释函数来分配标签(键值对)。如上例所示，<code class="fe ob oc od nr b">@tag(owner='Data-Science', pii='False')</code>提供了额外的元数据来帮助代码读者理解，例如，谁拥有代码，它是否包含个人识别信息。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f55d8da57cf8e81c7b41ebaad4d768e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HsFDqZAl7Tl0s12l9rF1fw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">汉密尔顿可以生成的示例渲染。经<a class="ae lr" href="https://outerbounds.com/blog/developing-scalable-feature-engineering-dags" rel="noopener ugc nofollow" target="_blank">https://outer bounds . com/blog/developing-scalable-feature-engineering-DAGs</a>许可拍摄。</p></figure><h2 id="aaee" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">可重用逻辑，永远如此。</h2><p id="b279" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">为了有用，上面的函数需要在python模块中管理。因为该模块没有耦合到“驱动程序”代码，所以很容易在各种上下文中引用该函数:</p><ol class=""><li id="c87e" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq nh ni nj nk bi translated">多个驱动程序可以使用同一个功能。这些驱动器可以不同地构造DAG，例如通过从不同的位置加载数据。所以从第一天起就有代码重用。</li><li id="453d" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">如果你有一个Python <a class="ae lr" href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" rel="noopener ugc nofollow" target="_blank"> REPL </a>，导入函数并运行它就很容易了。</li><li id="e7d5" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq nh ni nj nk bi translated">您可以发布该函数的模块并对其进行版本化，以实现重用和可重用性。</li></ol><p id="99b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，由于Hamilton强制所有核心逻辑位于与“驱动程序代码”分离的功能中，因此Hamilton很容易提供开箱即用的方法来扩展计算。像<a class="ae lr" href="https://ray.io/" rel="noopener ugc nofollow" target="_blank"> Ray </a>和<a class="ae lr" href="https://www.dask.org/" rel="noopener ugc nofollow" target="_blank"> Dask </a>这样的框架很容易打开和集成。你所需要做的就是在你的“驱动程序”代码中修改几行代码。更多信息参见汉密尔顿的<a class="ae lr" href="https://github.com/stitchfix/hamilton/tree/main/examples/ray" rel="noopener ugc nofollow" target="_blank">雷</a> &amp; <a class="ae lr" href="https://github.com/stitchfix/hamilton/tree/main/examples/dask" rel="noopener ugc nofollow" target="_blank">达斯克</a>例子。</p><h2 id="6ff7" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">运行时数据质量检查，总是。</h2><p id="8220" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">单元测试是有价值的，但是它不能代替在生产中验证假设。而不是使用单独的任务(甚至单独的函数)来检查数据。Hamilton支持使用简单的装饰器在运行时对函数的输出进行验证:</p><pre class="kg kh ki kj gt nq nr ns nt aw nu bi"><span id="c5ec" class="mq lu iq nr b gy nv nw l nx ny">@check_output(data_type=np.float64, range=(-5.0, 5.0), allow_nans=False)</span></pre><p id="5e16" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这使得不了解代码上下文的人很容易理解输出的一些基本属性。因为装饰器与转换函数定义相邻，所以维护起来要简单得多。没有单独的系统需要更新—您可以在一个拉取请求中完成所有工作！</p><p id="93fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当函数被执行并且验证失败时，当前的选项是记录一个警告或者抛出一个异常。这是一种非常快速简单的方法，可以确保生产中运行的内容符合您的期望。</p><p id="4988" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那些更喜欢潘德拉的力量的人，欢呼吧！Hamilton中的数据验证是完全集成的，您可以将一个<a class="ae lr" href="https://github.com/DAGWorks-Inc/hamilton/tree/main/examples/data_quality/pandera" rel="noopener ugc nofollow" target="_blank"> Pandera模式传递给decorator </a>。</p><h2 id="e192" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">额外好处</h2><p id="3c33" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">除了使你的熊猫代码库整洁之外，Hamilton还在你的熊猫开发工作流程的这些更宏观的方面提供帮助。</p><h2 id="fe53" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">更快的迭代周期。</h2><p id="584e" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">一旦Hamilton启动并运行，添加、更改和调整代码的灵活性就很简单了。您可以:</p><ul class=""><li id="ffc6" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq oa ni nj nk bi translated">以<a class="ae lr" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动的方式开发</a>。</li><li id="737d" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated">通过仅请求计算所需的内容，轻松测试您的更改</li><li id="a205" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated">通过跟踪计算数据谱系有条不紊地进行调试。您从函数开始，调试逻辑，如果问题出在其他地方，您可以通过函数的输入迭代递归。</li><li id="ec3e" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated">利用您预先定义的功能，非常容易地为多个上下文创建驱动程序。</li></ul><h2 id="57c1" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">更快的入职。</h2><p id="387b" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">由于编写了带有各种文档挂钩的函数，增加新员工变得简单多了。探索代码库可以用图形化的方式来完成，运行和测试代码也很容易解释。</p><h2 id="8333" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">花在代码维护和保养上的时间更少</h2><p id="5a6a" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">通过设计，Hamilton使得遵循软件工程最佳实践变得容易。这意味着维护、继承甚至移交代码是非常容易管理的。这也意味着很容易使您的所有转换逻辑看起来统一和美观(例如参见下一节中的链接),并保持这种方式。</p><h1 id="93b1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">现实的例子</h1><p id="8cd0" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我吹嘘了它的好处，但是代码实际上是什么样子的呢？以下是一些例子:</p><p id="ab0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">&gt;将Hamilton与<a class="ae lr" href="https://metaflow.org/" rel="noopener ugc nofollow" target="_blank"> Metaflow </a>结合:</p><ul class=""><li id="66e8" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq oa ni nj nk bi translated">参见<a class="ae lr" href="https://github.com/outerbounds/hamilton-metaflow/blob/main/absenteeism/normalized_features.py" rel="noopener ugc nofollow" target="_blank"> normalized_features.py </a>和<a class="ae lr" href="https://github.com/outerbounds/hamilton-metaflow/blob/main/absenteeism/feature_logic.py" rel="noopener ugc nofollow" target="_blank"> feature_logic.py </a>。🤔反问句:继承这段代码你会有什么感觉？</li><li id="2c98" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated"><a class="ae lr" href="https://outerbounds.com/blog/developing-scalable-feature-engineering-dags" rel="noopener ugc nofollow" target="_blank">附带博文</a></li></ul><p id="b585" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">&gt;汉密尔顿知识库中的一个示例:</p><ul class=""><li id="6f48" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq oa ni nj nk bi translated"><a class="ae lr" href="https://github.com/DAGWorks-Inc/hamilton/tree/main/examples/data_quality/simple" rel="noopener ugc nofollow" target="_blank">数据质量</a>(基于上述示例，但包括<code class="fe ob oc od nr b">@check_output</code>注释)。有关Pandera 的示例，请参见<a class="ae lr" href="https://github.com/DAGWorks-Inc/hamilton/tree/main/examples/data_quality/pandera" rel="noopener ugc nofollow" target="_blank">本示例</a>。</li></ul><h1 id="fa3b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">最后</h1><p id="10dd" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">代码的寿命比你通常预期的要长得多。确保它易于编写、维护，并能被您之后的人访问，这是使熊猫在生产环境中工作的一个关键因素。汉密尔顿熊猫帮你做到这一切。将汉密尔顿与Pandas一起使用会产生整洁的产品代码，无论是谁编写的，都可以在计算上(例如<a class="ae lr" href="https://github.com/stitchfix/hamilton/tree/main/examples/ray" rel="noopener ugc nofollow" target="_blank"> Ray </a>、<a class="ae lr" href="https://github.com/stitchfix/hamilton/tree/main/examples/dask" rel="noopener ugc nofollow" target="_blank"> Dask </a>)和组织上进行维护和扩展。</p><p id="bd15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们希望您能够:</p><ul class=""><li id="d9f4" class="nc nd iq kx b ky kz lb lc le ne li nf lm ng lq oa ni nj nk bi translated">💪如果你还没试过，试试汉密尔顿T2。刚刚<code class="fe ob oc od nr b">pip install sf-hamilton</code>开始。</li><li id="ec23" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated">github上的⭐️美国<a class="ae lr" href="https://github.com/DAGWorks-Inc/hamilton/" rel="noopener ugc nofollow" target="_blank"/>，</li><li id="2f95" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated">📝如果你发现了什么，给我们留个问题，</li><li id="5d08" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated">📣<a class="ae lr" href="https://join.slack.com/t/hamilton-opensource/shared_invite/zt-1bjs72asx-wcUTgH7q7QX1igiQ5bbdcg" rel="noopener ugc nofollow" target="_blank">加入我们的slack社区</a> —我们非常乐意帮助回答您可能有的问题或帮助您起步。</li></ul><h2 id="6e66" class="mq lu iq bd lv mr ms dn lz mt mu dp md le mv mw mf li mx my mh lm mz na mj nb bi translated">您可能感兴趣的其他汉密尔顿帖子:</h2><ul class=""><li id="8482" class="nc nd iq kx b ky ml lb mm le oh li oi lm oj lq oa ni nj nk bi translated"><a class="ae lr" rel="noopener" target="_blank" href="/how-to-use-hamilton-with-pandas-in-5-minutes-89f63e5af8f5">如何在5分钟内将汉密尔顿与熊猫配合使用</a></li><li id="6e90" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated"><a class="ae lr" rel="noopener" target="_blank" href="/how-to-iterate-with-hamilton-in-a-notebook-8ec0f85851ed">如何在笔记本环境中使用Hamilton</a></li><li id="e748" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated"><a class="ae lr" rel="noopener" target="_blank" href="/functions-dags-introducing-hamilton-a-microframework-for-dataframe-generation-more-8e34b84efc1d">一般背景故事&amp;汉密尔顿简介</a></li><li id="f46e" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated"><a class="ae lr" href="https://outerbounds.com/blog/developing-scalable-feature-engineering-dags" rel="noopener ugc nofollow" target="_blank">开发可扩展的特征工程DAGs </a> (Hamilton with Metaflow)</li><li id="c2e1" class="nc nd iq kx b ky nl lb nm le nn li no lm np lq oa ni nj nk bi translated"><a class="ae lr" href="https://medium.com/@thijean/the-perks-of-creating-dataflows-with-hamilton-36e8c56dd2a" rel="noopener">使用汉密尔顿创建数据流的额外好处</a>(汉密尔顿上的有机用户帖子！)</li></ul></div></div>    
</body>
</html>