<html>
<head>
<title>A Complete Guide to Tuples in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中元组的完全指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-complete-guide-to-tuples-in-python-af76241e8b59#2022-04-11">https://towardsdatascience.com/a-complete-guide-to-tuples-in-python-af76241e8b59#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ae5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是元组、元组实现、数据类型、索引、不变性和扩展功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c75782963c6b0c2870c41b725bfd116d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RTKNVNhg6Lh0hMnU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@paicooficial?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paico official</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="2fa8" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是元组？</h2><p id="f2df" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">元组是一种数据结构，类似于Python中的列表，但通常不太为人所知或与之交互。它们共享列表的相同特征，因为它们是有序的和可索引的，但是它们的不同之处在于它们是不可变的，并且它们是使用<code class="fe mo mp mq mr b">()</code>符号而不是<code class="fe mo mp mq mr b">[]</code>符号创建的。这意味着:</p><ul class=""><li id="d545" class="ms mt it lx b ly mu mb mv li mw lm mx lq my mn mz na nb nc bi translated"><strong class="lx iu">不可变</strong>:一旦创建就不能更改</li><li id="4c58" class="ms mt it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">有序</strong>:一旦创建，它们就保持它们的顺序</li><li id="91f3" class="ms mt it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">可索引</strong>:如果我们知道条目在元组中的位置，就可以访问信息</li><li id="f6df" class="ms mt it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated"><strong class="lx iu">可以包含重复记录:</strong>可以包含相同值的项目，没有任何问题。</li></ul><p id="ad42" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这很重要，因为这些特征会影响元组相对于列表的使用方式。不可变的主要区别在于，因为它们一旦被创建就不能被更改，所以它们可以在程序中使用，一旦你设置了一个值，你就不希望它们被意外地更改，同时仍然具有与列表相同的功能。这样的例子包括存储实验结果或设置在整个程序中不变的起始参数。</p><h2 id="0255" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">履行</h2><p id="8db9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">要创建元组，我们可以使用两种主要方法:</p><ul class=""><li id="26de" class="ms mt it lx b ly mu mb mv li mw lm mx lq my mn mz na nb nc bi translated">使用<code class="fe mo mp mq mr b">()</code>将我们想要包含的信息用逗号分隔的条目包含在元组中</li><li id="7c99" class="ms mt it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">使用<code class="fe mo mp mq mr b">tuple()</code>函数，该函数可用于将其他数据结构转换为元组或以列表作为参数</li></ul><p id="2d77" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这些可以简单地实现为:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="9e5c" class="kz la it mr b gy np nq l nr ns">#create the tuple<br/>cars = ("Ford", "Hyundai", "Toyota", "Kia")</span><span id="6ffb" class="kz la it mr b gy nt nq l nr ns">#create a second tuple<br/>fruits_tuple = tuple(("Strawberry", "peach", "tomato"))</span><span id="2409" class="kz la it mr b gy nt nq l nr ns">#create the third tuple<br/>vegetable_tuple = tuple(["potato", "onion", "celery"])</span><span id="8a81" class="kz la it mr b gy nt nq l nr ns">#print the result<br/>print(cars)<br/>print(type(cars))</span><span id="9d48" class="kz la it mr b gy nt nq l nr ns">print(fruits_tuple)<br/>print(type(fruits_tuple))</span><span id="c8ab" class="kz la it mr b gy nt nq l nr ns">print(vegetable_tuple)<br/>print(type(vegetable_tuple))</span><span id="da01" class="kz la it mr b gy nt nq l nr ns">#out:<br/>('Ford', 'Hyundai', 'Toyota', 'Kia')<br/>&lt;class 'tuple'&gt;<br/>('Strawberry', 'peach', 'tomato')<br/>&lt;class 'tuple'&gt;<br/>('potato', 'onion', 'celery')<br/>&lt;class 'tuple'&gt;</span></pre><p id="12c4" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这里需要注意的一点是，<code class="fe mo mp mq mr b">tuple()</code>函数只接受一个参数，这意味着我们可以将它传递给一个更早实现的数据结构，或者像我们在这里所做的那样，我们可以在<code class="fe mo mp mq mr b">()</code>中传递一个元组本身，或者在<code class="fe mo mp mq mr b">[]</code>中传递一个列表。</p><p id="63ca" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">我们还可以看到，我们已经能够检查我们通过使用<code class="fe mo mp mq mr b">type()</code>功能创建的数据结构的类型，该功能告诉我们我们有一个<code class="fe mo mp mq mr b">tuple</code>类。我们还可以看到，当打印出一个元组时，它由元组本身中的项目周围的<code class="fe mo mp mq mr b">()</code>来表示，并且这些项目保留了它们在原始数据结构中的顺序。</p><h2 id="5414" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">元组中的数据类型</h2><p id="11d1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">由于元组的行为类似于列表，这意味着我们也可以在元组中包含不同的数据类型。虽然我们在上面实现了内部只有字符串的元组，但是我们也可以创建内部有整数和浮点数的元组:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="f492" class="kz la it mr b gy np nq l nr ns">#create a list of just numbers<br/>num_tuple = (1, 2, 3, 4)</span><span id="07cd" class="kz la it mr b gy nt nq l nr ns">#create a list of just floats<br/>float_tuple = (1.2, 2.3, 4.5, 6.8)</span><span id="1f1d" class="kz la it mr b gy nt nq l nr ns">#print the results<br/>print(type(num_tuple))<br/>print(num_tuple)</span><span id="7919" class="kz la it mr b gy nt nq l nr ns">print("\n")</span><span id="687b" class="kz la it mr b gy nt nq l nr ns">print(type(float_tuple))<br/>print(float_tuple)</span><span id="6157" class="kz la it mr b gy nt nq l nr ns">#out:<br/>&lt;class 'tuple'&gt;<br/>(1, 2, 3, 4)<br/><br/><br/>&lt;class 'tuple'&gt;<br/>(1.2, 2.3, 4.5, 6.8)</span></pre><p id="229a" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">我们还可以在一个元组中组合不同的数据类型，这样我们就不必拥有一种以上的数据类型。例如，我们可以在里面放一个列表，甚至另一个元组！</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="1737" class="kz la it mr b gy np nq l nr ns">#different list<br/>random_tuple = ("Hello", 3, "Cheese", 6.2, [1,2,3], (4,6,7))</span><span id="7e77" class="kz la it mr b gy nt nq l nr ns">#print the result<br/>print(type(random_tuple))<br/>print(random_tuple)</span><span id="f388" class="kz la it mr b gy nt nq l nr ns">#out:<br/>&lt;class 'tuple'&gt;<br/>('Hello', 3, 'Cheese', 6.2, [1, 2, 3], (4, 6, 7))</span></pre><h2 id="845f" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">索引</h2><p id="20bf" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">就像列表一样，元组的一个重要特征是它们是项目的有序集合。这意味着一旦创建了元组，它们就有了明确定义的顺序，并且因为它们是不可变的，所以顺序不能改变。</p><p id="e4e6" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这种顺序允许我们访问元组中的值，我们知道这些值在该顺序中的给定位置。例如，如果我们根据汽车制造商的位置创建了一个我们想要访问的汽车制造商列表，如果我们忘记了我们计划访问的第一个制造商，我们可以通过使用列表的第一个索引来访问第一个制造商。当然，因为这是Python，所以一切都以0索引开始，所以我们可以用以下方式访问元组中的第一项:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="0083" class="kz la it mr b gy np nq l nr ns">#get the first item from the tuple<br/>print(cars[0])</span><span id="bb2e" class="kz la it mr b gy nt nq l nr ns">#out:<br/>Ford</span></pre><p id="6a70" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">为此，方括号用于输入索引号，这样<code class="fe mo mp mq mr b">tuple[0]</code>就是我们访问第一个索引的方式。</p><p id="db80" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">按照这个例子，可以使用<code class="fe mo mp mq mr b">tuple[1]</code>访问元组中的第二项，使用<code class="fe mo mp mq mr b">tuple[2]</code>访问第三项，依此类推。为此，只要索引属于您尝试访问的元组，任何解析为数字的内容都可以用来访问元组中的内容。如果您试图使用一个超出元组的索引，那么您将得到一个错误，告诉您该索引不在元组中。</p><p id="601d" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这种索引的一个有用的优点是，我们不仅可以向前计数，就像我们对汽车元组所做的那样，我们还可以向后计数。这意味着我们可以检查最后添加到元组中的项。例如，如果我们想要检查我们计划最后访问的制造商，我们将使用:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="c66f" class="kz la it mr b gy np nq l nr ns">#get the last item from the tuple<br/>print(cars[-1])</span><span id="3789" class="kz la it mr b gy nt nq l nr ns">#out:<br/>Kia</span></pre><p id="4782" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">为此，重要的是要注意倒计数从-1开始，并随着我们的进行而增加。这是因为如果我们从0开始，那么我们将会混淆我们想要列表中的第一项还是最后一项。</p><p id="0ad4" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">最后，我们还可以使用索引同时提取一个元组中的多个项，而不是单个项。我们可以使用与list相同的方式来实现这一点，使用<code class="fe mo mp mq mr b">tuple[start_item: end_item]</code>的切片符号，这样最后一项就不会出现在返回的元组中。这方面一个例子包括:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="b81a" class="kz la it mr b gy np nq l nr ns">#get the second and third from the tuple<br/>print(cars[1:3])</span><span id="6221" class="kz la it mr b gy nt nq l nr ns">#get all from the first index<br/>print(cars[1:])</span><span id="e6dc" class="kz la it mr b gy nt nq l nr ns">#get all until the fourth one<br/>print(cars[:3])</span><span id="8521" class="kz la it mr b gy nt nq l nr ns">#out:<br/>('Hyundai', 'Toyota')<br/>('Hyundai', 'Toyota', 'Kia')<br/>('Ford', 'Hyundai', 'Toyota')</span></pre><p id="7313" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">几个不同的规则适用于此，因为:</p><ul class=""><li id="b075" class="ms mt it lx b ly mu mb mv li mw lm mx lq my mn mz na nb nc bi translated">当使用<code class="fe mo mp mq mr b">[1:3]</code>打印第二个最低的项目时，由于最终索引不包含在结果中，所以只返回两个项目</li><li id="aa3a" class="ms mt it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">当打印<code class="fe mo mp mq mr b">[1:]</code>时，我们没有指定结束索引，这就是为什么在第四个索引之后，包括第四个索引，整个元组都被打印出来</li><li id="40dd" class="ms mt it lx b ly nd mb ne li nf lm ng lq nh mn mz na nb nc bi translated">当打印第四个索引之前的所有内容时，因为我们没有指定开头，所以打印了元组的开头</li></ul><p id="b675" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">也像列表一样，每当获取一个切片时，切片的类型将与您获取切片的对象的类型相同。在这里，因为我们获取一个元组的一部分，所以返回一个元组。</p><h2 id="1635" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">查找项目</h2><p id="1324" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">从上面我们可以看到，当我们知道项目的索引时，我们可以访问项目，但是如果我们只知道元组包含项目，而不知道它的位置，那该怎么办呢？例如，在我们的汽车列表中，我们知道我们必须访问丰田，但不知道我们必须访问制造商的顺序。然后，像列表一样，我们可以使用<code class="fe mo mp mq mr b">index()</code>方法找到项目的位置，如下所示:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="1a27" class="kz la it mr b gy np nq l nr ns">#get the index for Toyota<br/>print(cars.index("Toyota"))</span><span id="6ec3" class="kz la it mr b gy nt nq l nr ns">#out:<br/>2</span></pre><p id="6b38" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">尽管需要注意的是，当访问重复值的索引时，<code class="fe mo mp mq mr b">index()</code>方法将只返回该值的第一个索引的索引。</p><p id="e4e9" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">唯一的问题是，如果您拼错了该项或者该项不在元组中，该方法将抛出一个错误，并将停止代码运行。解决这个问题的一个简单方法是使用if/else语句，该语句可以使用:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="c81c" class="kz la it mr b gy np nq l nr ns">if "Toyota" in cars:<br/>    print("Toyota is at index:", cars.index("Toyota"))<br/>else:<br/>    print("Toyota not in tuple")</span><span id="5bc0" class="kz la it mr b gy nt nq l nr ns">#out:<br/>Toyota is at index: 2</span></pre><h2 id="2feb" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不变</h2><p id="5000" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">元组是不可变的意味着它们不能被改变。如果你试图使用索引和赋值来改变一个值，比如<code class="fe mo mp mq mr b">cars[0] = "Tesla"</code>，那么你将得到一个类型错误，说明“<strong class="lx iu">type error</strong>:‘tuple’对象不支持项赋值”，这表明你不能改变一个元组。</p><p id="c820" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">也就是说，如果你愿意，有一些方法可以解决这个问题，尽管元组的目的是你首先不要这么做。第一种方法是将元组转换为列表，更新值，然后将其转换回元组，如下所示:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="4122" class="kz la it mr b gy np nq l nr ns">#print the tuple<br/>print(cars)</span><span id="0588" class="kz la it mr b gy nt nq l nr ns">#change it to a list<br/>tuple_list = list(cars)</span><span id="a3dc" class="kz la it mr b gy nt nq l nr ns">#change the value<br/>tuple_list[0] = "Maserati"</span><span id="3d95" class="kz la it mr b gy nt nq l nr ns">#reassign back to the tuple<br/>cars = tuple(tuple_list)</span><span id="aef5" class="kz la it mr b gy nt nq l nr ns">#print the result<br/>print(cars)</span><span id="5576" class="kz la it mr b gy nt nq l nr ns">#out:<br/>('Ford', 'Hyundai', 'Toyota', 'Kia')<br/>('Maserati', 'Hyundai', 'Toyota', 'Kia')</span></pre><p id="f316" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">当然，如果你想这样做，那么你可能应该首先创建一个列表。</p><p id="b759" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">改变元组的另一种方法是将两个元组连接在一起形成一个新的元组。这并不一定要改变原来的元组，而是创建一个新的元组，所以这也是一种变通方法。这当然意味着你对一个元组所能做的唯一改变是在末尾或开头添加内容，而不是改变元组本身。这可以通过以下方式实现:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="38d2" class="kz la it mr b gy np nq l nr ns">#create new tuples<br/>tuple1 = ("a", "b", "c")<br/>tuple2 = (1,2,3)</span><span id="ff90" class="kz la it mr b gy nt nq l nr ns">#add together using the +<br/>tuple3 = tuple1 + tuple2<br/>print(tuple3)</span><span id="cc03" class="kz la it mr b gy nt nq l nr ns">#multiply an existing tuple together <br/>tuple4 = tuple1*2<br/>print(tuple4)</span><span id="492b" class="kz la it mr b gy nt nq l nr ns">#out:<br/>('a', 'b', 'c', 1, 2, 3)<br/>('a', 'b', 'c', 'a', 'b', 'c')</span></pre><h2 id="0264" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">内置功能</h2><p id="8385" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">最后，我们有几个内置的元组功能，就像我们处理列表一样，可以包括查找元组的长度，打印特定值的实例数，以及查找元组的最小值或最大值。这可以通过以下方式实现:</p><pre class="kj kk kl km gt nl mr nm nn aw no bi"><span id="7bcc" class="kz la it mr b gy np nq l nr ns">#print the length of the tuple<br/>print(len(tuple1))</span><span id="7552" class="kz la it mr b gy nt nq l nr ns">#print the count of values within a tuple<br/>print(tuple4.count("a"))</span><span id="0155" class="kz la it mr b gy nt nq l nr ns">#print the maximum value from a tuple<br/>print(max(tuple2))</span><span id="490f" class="kz la it mr b gy nt nq l nr ns">#print the minimum value from a tuple<br/>print(min(tuple2))</span><span id="36cb" class="kz la it mr b gy nt nq l nr ns">#out:<br/>3<br/>2<br/>3<br/>1</span></pre><p id="4b82" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这就是Python中元组的完整指南！元组在本质上明显类似于列表，因为它是有序的和可索引的。但是，它与列表的主要区别在于它不能被更改。这意味着当您不希望任何信息在创建后被更改时，例如当您不希望实验结果被覆盖或出于安全原因时，它会很有用。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="30fd" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">这是探索数据结构及其在Python中的使用和实现系列的第三篇文章。如果您错过了列表和集合中的前两个，您可以在以下链接中找到它:</p><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-lists-in-python-d049cf3760d4"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Python中列表的完整指南</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">关键特性、实现、索引、切片、定位项目、可变性和其他有用的功能</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-sets-in-python-99dc595b633d"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">Python中集合的完整指南</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">集合的关键特性、实现集合、访问项目、可变性和附加功能</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><p id="d233" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">未来的帖子将涵盖Python中的字典、链表、栈、队列和图形。为了确保您将来不会错过任何内容，请注册以便在发布时收到电子邮件通知:</p><div class="ob oc gp gr od oe"><a href="https://philip-wilkinson.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">每当菲利普·威尔金森发表文章时，就收到一封电子邮件。</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">每当菲利普·威尔金森发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="on l"><div class="ou l op oq or on os ks oe"/></div></div></a></div><p id="899d" class="pw-post-body-paragraph lv lw it lx b ly mu ju ma mb mv jx md li ni mf mg lm nj mi mj lq nk ml mm mn im bi translated">如果你喜欢你所阅读的内容，并且还不是一个媒体成员，考虑通过使用我下面的推荐代码注册来支持我自己和这个平台上其他了不起的作者:</p><div class="ob oc gp gr od oe"><a href="https://philip-wilkinson.medium.com/membership" rel="noopener follow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">通过我的推荐链接加入媒体-菲利普·威尔金森</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="on l"><div class="ov l op oq or on os ks oe"/></div></div></a></div></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><div class="kj kk kl km gt oe"><a rel="noopener follow" target="_blank" href="/an-introduction-to-sql-for-data-scientists-e3bb539decdf"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">数据科学家的SQL介绍</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">UCL数据科学学会工作坊9:什么是SQL，选择数据，查询数据，汇总统计，分组数据和…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ow l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/git-and-github-basics-for-data-scientists-b9fd96f8a02a"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">面向数据科学家的Git和GitHub基础知识</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">UCL数据科学研讨会8:什么是Git，创建本地存储库，提交第一批文件，链接到远程…</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="ox l op oq or on os ks oe"/></div></div></a></div><div class="ob oc gp gr od oe"><a rel="noopener follow" target="_blank" href="/london-convenience-store-classification-using-k-means-clustering-70c82899c61f"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">使用K-均值聚类的伦敦便利店分类</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">伦敦的便利店怎么分类？</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">towardsdatascience.com</p></div></div><div class="on l"><div class="oy l op oq or on os ks oe"/></div></div></a></div></div></div>    
</body>
</html>