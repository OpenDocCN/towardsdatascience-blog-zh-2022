<html>
<head>
<title>Efficient Data Manipulation With Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫的高效数据操作</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/efficient-data-manipulation-with-pandas-2cbc4e3824f9#2022-04-04">https://towardsdatascience.com/efficient-data-manipulation-with-pandas-2cbc4e3824f9#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9c2d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">停止用传统的方式使用熊猫，用“管道”代替</h2><div class=""/><div class=""><h2 id="d86e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">学习在熊猫中使用管道进行数据操作</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/095e8c13352a6c0e489816c5ead7209b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkJEJyW3M9P-xFYVtNRQIg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">资料来源:Unsplash，Lars Kienle</p></figure><p id="f156" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们都在用熊猫。它是几乎每个使用python的分析师的首选工具。我们中的许多人已经掌握了数据处理的艺术。我对我所知道的关于熊猫的知识和我应用知识的方式非常满意，直到我看到了马特·哈里森写的一本书。这本书改变了我熊猫的生活。我觉得我一直以来都被背叛了😅在这篇文章中，我将分享几件我学到并立即爱上它们的事情。让我们开始吧。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h2 id="fedd" class="mk ml it bd mm mn mo dn mp mq mr dp ms lq mt mu mv lu mw mx my ly mz na nb iz bi translated">一些我们喜欢的任务</h2><p id="ff01" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">在操作数据时，我们通常使用以下操作:</p><p id="21f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">1️⃣:列选择<br/> 2️⃣:过滤数据<br/> 3️⃣:更改列<br/> 4️⃣:创建新列<br/> 5️⃣:应用自定义函数<br/> 6️⃣:聚合数据<br/> 7️⃣:连接数据<br/> 8️⃣:可视化数据</p><p id="665b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这绝对不是一个完整的列表，但现在足够了。你一定注意到了上面任务中的等级。通常，我们以有序的方式应用这些任务。到目前为止一切顺利。然而，我们通常倾向于单独执行这些任务，即使您将这些任务放在一个函数中。我们缺少的是“管道”。</p><p id="ea8a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">“管道”的目的是将这些任务缝合在一起，并以一种内存高效的方式计算它们。这本身就是一个巨大的优势。然而，对我来说，管道最大的好处是代码的“可读性”。那么这个“管道”是什么呢？</p><blockquote class="nh ni nj"><p id="d07f" class="lh li nk lj b lk ll kd lm ln lo kg lp nl lr ls lt nm lv lw lx nn lz ma mb mc im bi translated">最后有一个完整的可复制的代码示例。只需浏览流程的虚拟代码片段(灰色的)。</p></blockquote><h2 id="650c" class="mk ml it bd mm mn mo dn mp mq mr dp ms lq mt mu mv lu mw mx my ly mz na nb iz bi translated">管道</h2><p id="90af" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">要构建管道，您实际上不必去任何其他特定的库。我们可以通过将数据帧包装在一个元组中来开始使用管道，就像这样:</p><pre class="ks kt ku kv gt no np nq nr aw ns bi"><span id="9d0c" class="mk ml it np b gy nt nu l nv nw">import pandas as pd</span><span id="e48e" class="mk ml it np b gy nx nu l nv nw"># read the data<br/>df = read_csv("some_data.csv")<br/># make a pipeline<br/>( <br/>  df<br/>)</span></pre><p id="ff9b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果您执行代码，这将显示<code class="fe ny nz oa np b">df</code>数据帧。没什么特别的。然而，这就是乐趣的开始。在圆括号内，在<code class="fe ny nz oa np b">df</code>下面，你可以开始调用所有你喜欢的方法，一个接一个，按照你想要的顺序。让我们试一试。</p><pre class="ks kt ku kv gt no np nq nr aw ns bi"><span id="d2de" class="mk ml it np b gy nt nu l nv nw">(<br/>  df<br/>  # select few columns<br/>  [['column_a','column_b','column_c']]<br/>  # filter the data where column_a's values are green &amp; blue<br/>  .query(" column_a == ['green','blue']")<br/>  # check the first 5 rows of the data<br/>  .head()</span><span id="057d" class="mk ml it np b gy nx nu l nv nw">)</span></pre><p id="50a6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">如果运行此代码，您将看到数据框的前五行，共三列，包含“column_a”值为“绿色”或“蓝色”的记录。这正是你点的。但是，如果我们运行并检查<code class="fe ny nz oa np b">df</code>，我们会发现<code class="fe ny nz oa np b">df</code>什么都没有发生，我们所做的所有更改都应用到内存中，并与<code class="fe ny nz oa np b">df</code>分开保存。太棒了😮。这种方法的一些好处是:</p><p id="9f53" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">👉:代码可读性很强<br/>👉:代码灵活，更改非常容易实现<br/>👉:我们不需要创建修改数据帧的单独引用<br/>👉:内存效率高<br/>👉:原始数据帧保持不变</p><h2 id="6539" class="mk ml it bd mm mn mo dn mp mq mr dp ms lq mt mu mv lu mw mx my ly mz na nb iz bi translated">它是如何工作的</h2><p id="76bb" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">圆括号中的每一行都是管道中的一个“步骤”。流水线的第一步必须是数据帧。每一步都必须从单独的一行开始。你走的每一步都需要一个数据框架方法，比如<code class="fe ny nz oa np b">.head()</code> <code class="fe ny nz oa np b">.query()</code> <code class="fe ny nz oa np b">.tail()</code> <code class="fe ny nz oa np b">.merge()</code>等。每一步的输出都成为下一步的输入。在我们的例子中，步骤<code class="fe ny nz oa np b">[['column_a','coumn_b'm'column_c']]</code>的输出是包含三列的数据帧。这成为过滤数据的<code class="fe ny nz oa np b">.query()</code>步骤的输入。过滤后的数据成为<code class="fe ny nz oa np b">.head()</code>步骤的输入，最后的输出显示给用户。</p><p id="ce88" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">重要的是保持这一势头。我的意思是，我们应该避免在第一步之后使用数据框的名称。例如，您想要对现有的列进行更改。我将使用<code class="fe ny nz oa np b">.assign()</code>方法，这是创建或更改现有列的方法。</p><p id="4925" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是你应该<strong class="lj jd">而不是</strong>做的:</p><pre class="ks kt ku kv gt no np nq nr aw ns bi"><span id="0b1b" class="mk ml it np b gy nt nu l nv nw">(<br/>df <br/># apply a filter<br/>.query("column_a == ['green','blue']")<br/># make a change to column_a<br/>.assign(column_a = df['column_b'])<br/>)</span></pre><p id="7369" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">通过引用<code class="fe ny nz oa np b">.assign()</code>步骤中的<code class="fe ny nz oa np b">df['column_b]</code>，我们实际上是在引用回<code class="fe ny nz oa np b">df</code>的原始状态(即它在第一步时的状态)，这是我们不想要的。我们想要的是仅在我们将过滤器应用到<code class="fe ny nz oa np b">column_a</code>(过滤数据的<code class="fe ny nz oa np b">.query()</code>步骤的输出)之后改变<code class="fe ny nz oa np b">column_a</code>。为了做到这一点，我们将在<code class="fe ny nz oa np b">assign()</code>步骤中使用一个函数(比如lambda)。这就是我们<strong class="lj jd">应该</strong>做的:</p><pre class="ks kt ku kv gt no np nq nr aw ns bi"><span id="1ce5" class="mk ml it np b gy nt nu l nv nw">(<br/>df <br/># apply a filter<br/>.query("column_a == ['green','blue']")<br/># make a change to column_a<br/>.assign(column_a = lambda x: x['column_b])<br/>)</span></pre><p id="82bc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这种情况下，lambda函数中的参数<code class="fe ny nz oa np b">x</code>引用的是<code class="fe ny nz oa np b">.query()</code>步骤的输出，而不是原来的<code class="fe ny nz oa np b">df</code>，正如我们所希望的那样。</p><p id="ace8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">最后一部分</strong></p><p id="8ce1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在我们进行最后一个可重复的例子之前，我需要向您介绍一个重要的方法，<code class="fe ny nz oa np b">.pipe()</code>方法。如果您想要应用熊猫数据框固有的不可用方法(如自定义函数)，此方法非常有用。<code class="fe ny nz oa np b">.pipe()</code>方法接受一个函数和该函数的参数。函数的第一个参数应该是数据框。函数的输出也应该是数据框。让我们看一个例子:</p><pre class="ks kt ku kv gt no np nq nr aw ns bi"><span id="bf35" class="mk ml it np b gy nt nu l nv nw"># define a custom function, first argument as a df. Function<br/># returns a df.<br/>def some_function(df:pd.DataFrame,column_name:str)-&gt;pd.DataFrame:<br/>  new_df = df[column_name]*4/df[column_name]^3<br/>  return new_df</span><span id="dbd5" class="mk ml it np b gy nx nu l nv nw"># start the pipeline<br/>(<br/>  df<br/>  .pipe(somefunction,"column_c")<br/>  .head()<br/>)</span></pre><p id="dfdc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">简而言之，<code class="fe ny nz oa np b">.pipe()</code>将帮助我们部署任何我们想要应用于我们的数据框架的定制解决方案/功能。</p><p id="d907" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jd">总结</strong></p><p id="a10f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Pandas piping是一种优秀的、节省内存的方式，可以为数据操作编写清晰可读的代码。它简单直观。您还可以将最终输出分配给另一个变量，例如</p><pre class="ks kt ku kv gt no np nq nr aw ns bi"><span id="1f6b" class="mk ml it np b gy nt nu l nv nw">df_1 = (<br/>         df<br/>         .query("column_a == 'blue'")<br/>         )</span></pre><p id="ab15" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们也可以把管道包装成一个函数，然后一直使用函数进行重复使用。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="ab66" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">最后，这里有一个可重复的代码，您可以使用它来进一步挖掘和实践。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者代码</p></figure><p id="6373" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖<br/>可以在<a class="ae od" href="https://fahadakbar-50702.medium.com/subscribe" rel="noopener"> <strong class="lj jd">上关注我</strong> </a> &amp;在<a class="ae od" href="https://www.linkedin.com/in/fahadakbar/" rel="noopener ugc nofollow" target="_blank"><strong class="lj jd">LinkedIn</strong></a>&amp;上联系我访问我的<a class="ae od" href="https://github.com/mfahadakbar/" rel="noopener ugc nofollow" target="_blank"> <strong class="lj jd"> GitHub </strong> </a> <strong class="lj jd">。<br/></strong>➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖➖</p><h1 id="dc38" class="oe ml it bd mm of og oh mp oi oj ok ms ki ol kj mv kl om km my ko on kp nb oo bi translated">您可能还对以下内容感兴趣:</h1><p id="74fe" class="pw-post-body-paragraph lh li it lj b lk nc kd lm ln nd kg lp lq ne ls lt lu nf lw lx ly ng ma mb mc im bi translated">👉<a class="ae od" rel="noopener" target="_blank" href="/make-your-data-science-life-easy-with-docker-c3e1fc0dee59">Docker</a><br/>让您的数据科学生活变得简单👉<a class="ae od" rel="noopener" target="_blank" href="/custome-estimator-with-pycaret-part-1-by-fahad-akbar-839513315965">使用PyCaret的自定义估算器，第1部分</a> <br/>👉<a class="ae od" rel="noopener" target="_blank" href="/custom-estimator-with-pycaret-part-2-by-fahad-akbar-aee4dbdacbf?sk=3556332049ac839d1d423615dab25bf0">使用PyCaret的自定义估算器，第2部分</a> <br/>👉<a class="ae od" href="https://fahadakbar-50702.medium.com/get-linux-in-windows-the-easy-way-three-simple-steps-by-fahad-akbar-aa5b142c943c?sk=a8e20dae33fde0563e69bb00966b5c17" rel="noopener">轻松获得Windows内部的Linux</a><br/>👉<a class="ae od" rel="noopener" target="_blank" href="/a-data-scientists-dream-python-big-data-multi-processing-pycaret-by-fahad-akbar-7cc213a12db">使用PyCaret进行多重处理</a></p></div></div>    
</body>
</html>