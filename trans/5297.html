<html>
<head>
<title>Building your First Shiny app in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 R 语言构建你的第一个闪亮的应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-your-first-shiny-app-in-r-82c7d1f5f309#2022-11-28">https://towardsdatascience.com/building-your-first-shiny-app-in-r-82c7d1f5f309#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a927" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用 R 构建一个闪亮的应用程序，并展示您的代码和交互工作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db711f115026426eeef90130cfc83ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I9EnCK5QsAl2Gz9b"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>@ unsplash.com 拍摄</p></figure><p id="88e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">【免责声明:此帖子包含一些我的 Udemy 课程的附属链接】</em></p><p id="8256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您已经使用 R 开发了您的数据科学模型或分析，现在您可能想以一种可视化和直观的方式展示结果。</p><p id="a883" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你对你的故事讲述做了一些调整，添加了一些情节，但是你觉得你的视觉效果有点静态，让你在整个故事讲述过程中重复代码或情节。此外，您很难在输出中隐藏您的代码，这是很关键的，您知道这会给业务或非技术用户带来一些困惑。</p><p id="e56e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很幸运，你有<code class="fe lw lx ly lz b">shiny</code>！<em class="lv"> </em> <a class="ae ky" href="https://shiny.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">闪亮</em> </a> <em class="lv"> </em>是一个很棒的构建 R 应用的库，你可以在其中嵌入 R 代码和结果，而不必构建自己的前端和后端。<code class="fe lw lx ly lz b">shiny</code>这些功能令人惊叹，使您能够即时提供应用，同时让您的用户与您的模型或分析结果进行交互。</p><p id="f4d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe lw lx ly lz b">shiny</code>的另一个很酷的事情是，它可以直接从 R 中使用，就像任何其他库一样——使用 R 代码，我们可以建立一个基本的 HTML 交互页面，可以用来显示图表、数据框或其他元素。</p><p id="9481" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将探索一点<code class="fe lw lx ly lz b">shiny</code>库，目的是帮助你构建你的第一个应用。我们将使用几个例子，例如:</p><ul class=""><li id="cd4d" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">建立一个简单的“hello world 应用程序”，了解后端和前端流程。</li><li id="cc20" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">构建一个简单的散点图应用程序。</li><li id="74ef" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">构建一个具有三种不同视图的应用程序，包括来自决策树的一些结果。</li></ul><p id="e5af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章的最后，你应该准备好使用 r 来使用这个库。虽然<code class="fe lw lx ly lz b">shiny</code>需要一些时间来掌握，但我们在这里学到的东西有望成为一个良好的开端，让你开始使用复杂的<code class="fe lw lx ly lz b">shiny</code>应用程序，以及用它连接你的数据帧和绘图。</p><p id="f85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="6093" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">我们第一个闪亮的香草应用</h1><p id="95c0" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">让我们从在我们的环境中安装<code class="fe lw lx ly lz b">shiny</code>开始:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="05ea" class="nw mw it lz b be nx ny l nz oa">install.packages(‘shiny’)</span></pre><p id="5113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完<code class="fe lw lx ly lz b">shiny</code>包后，我们可以使用常用的<code class="fe lw lx ly lz b">library</code>函数将它加载到我们的环境中:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="c3ff" class="nw mw it lz b be nx ny l nz oa">library(shiny)</span></pre><p id="07b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将声明一个<code class="fe lw lx ly lz b">fluidPage</code>。这个功能将是我们支配和与 web 应用前端交互的主要方式。就其核心而言，<code class="fe lw lx ly lz b">fluidPage</code>是一个非常标准的行列格式用户界面(它甚至包括一些<a class="ae ky" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> bootstrap </a>特性)，对于大多数基本数据产品来说，这应该足够了。它通常也是可调整的，能够在应用程序中整合许多部分，正如我们将在几分钟内看到的。</p><p id="4bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，<code class="fe lw lx ly lz b">fluidPage</code>可以认为是我们<code class="fe lw lx ly lz b">shiny</code> app 的前端层。在这里，我们将构建用户将看到的一切，以及它将如何与后端交互。</p><p id="e5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一页非常简单，只打印了<code class="fe lw lx ly lz b">"My first shiny page!"</code>:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="4045" class="nw mw it lz b be nx ny l nz oa">sp &lt;- fluidPage(<br/>  "My first shiny page!"<br/>)</span></pre><p id="3426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了运行我们的应用程序，我们还需要设置我们的后端——这可以通过定义一个将传递给我们的<code class="fe lw lx ly lz b">shinyApp</code>的自定义函数来完成。现在，我们的<code class="fe lw lx ly lz b">server</code>函数将完全为空(目前我们在后端没有使用任何东西):</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="95c9" class="nw mw it lz b be nx ny l nz oa">server &lt;- function(input, output) {<br/>}</span></pre><p id="5651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lw lx ly lz b">shinyApp</code>，我们可以通过前端(<code class="fe lw lx ly lz b">sp</code>)后端层(<code class="fe lw lx ly lz b">server</code>)启动我们的第一个应用程序:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="c379" class="nw mw it lz b be nx ny l nz oa">shinyApp(sp, server)</span></pre><p id="5ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码后，应该会弹出一个新窗口！这个窗口是我们的<em class="lv">闪亮的</em>应用程序被提供的地方:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0b0d146b6a97039593df475474cf162d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tqfl2o9XF_H9HJFIrKoHyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的第一款闪亮应用——作者图片</p></figure><p id="3f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序将在本地主机<a class="ae ky" href="http://127.0.0.1:7388/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:7388/ </a>上的我们的计算机中提供。您应该在 R 控制台上的<code class="fe lw lx ly lz b">shinyApp</code>命令下面看到您的本地主机地址:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/f04a189842447a7fe4dece4a310b453e.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*VZvitfeky8RrOlWN8kHPCQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">闪亮的应用程序地址——作者图片</p></figure><p id="8073" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你运行应用程序时，你也可以在浏览器上输入地址，这也将带你到你的应用程序。</p><p id="48ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，目前我们的应用程序是无用的——我们没有任何输入或输出，如果能够与我们的应用程序进行交互，那将非常有用！接下来，让我们使用<code class="fe lw lx ly lz b">mtcars</code>数据框架，构建一个带有 2D 散点图的简单应用程序！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="a0c3" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">构建交互式绘图应用程序</h1><p id="7ceb" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">当然，我们不仅仅局限于编写一个基本的文本应用程序。例如，假设我们想在我们的应用程序上显示一个与此类似的图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/20042fe766909f6e7fa8d6b633d996bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*0sGd0EN-_GIfRms8DlHTXQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重量与 mpg mtcars 曲线图—图片由作者提供</p></figure><p id="b2e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在使用玩具数据集<code class="fe lw lx ly lz b">mtcars</code>绘制汽车<em class="lv">重量</em>与<em class="lv">油耗(每加仑英里数)</em>的散点图:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="0789" class="nw mw it lz b be nx ny l nz oa">library(ggplot2)<br/><br/>ggplot(<br/>  data = mtcars,<br/>  aes(x=mpg, y=wt)<br/>) + geom_point(color='darkgreen')</span></pre><p id="e1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以做的一件很酷的事情是在<code class="fe lw lx ly lz b">shiny</code>应用程序中提供散点图。此外，为了让我们的应用程序更有趣，我们希望有动态的<code class="fe lw lx ly lz b">x</code>和<code class="fe lw lx ly lz b">y</code>列，使用用户的输入。</p><p id="1c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然看起来很难做到这一点，但我们可以简单地通过改变我们的后端和前端层的一些部分来做到这一点。让我们从让用户从<code class="fe lw lx ly lz b">mtcars</code>中可用的列列表中选择两列开始:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="1c43" class="nw mw it lz b be nx ny l nz oa">sp &lt;- fluidPage(<br/>  <br/>  selectInput(<br/>    inputId = 'var1',<br/>    label = 'Column X Axis',<br/>    choices = colnames(mtcars)<br/>  ),<br/>  <br/>  selectInput(<br/>    inputId = 'var2',<br/>    label = 'Column Y Axis',<br/>    choices = colnames(mtcars)<br/>  )<br/>  <br/>)</span></pre><p id="9bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">selectInput</code>函数创建一个下拉框，其中包含<code class="fe lw lx ly lz b">mtcars</code>中所有可用的列。<code class="fe lw lx ly lz b">selectInput</code>是<code class="fe lw lx ly lz b">shiny</code>中众多可用的<a class="ae ky" href="https://debruine.github.io/shinyintro/inputs.html" rel="noopener ugc nofollow" target="_blank">输入法</a>之一，我们可以将<code class="fe lw lx ly lz b">colnames(mtcars)</code>传递给 choices 参数，它将负责用所有元素填充我们的下拉列表。</p><p id="8a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">inputId</code>在大多数<code class="fe lw lx ly lz b">shiny</code>应用中极其重要——它是我们在前端和后端之间发送信息的方式。在这种情况下，每当我们指向后端的一个<code class="fe lw lx ly lz b">var1</code>或<code class="fe lw lx ly lz b">var2</code>时，R 将获取我们在下拉框中指定的值。在某些场景中，我们来自前端的变量必须包含在<code class="fe lw lx ly lz b">reactive</code>上下文中，我们将在我们将要构建的第三个应用程序中看到这一点。</p><p id="ef78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们把这个新的<code class="fe lw lx ly lz b">sp</code>赋予我们的应用，我们的前端就有了新的东西:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="495d" class="nw mw it lz b be nx ny l nz oa">shinyApp(sp, server)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/2ae722b4e520f624586c797479e76942.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Zk9hXe8rcLKq2I2IX96mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绘图应用程序-作者提供的图片</p></figure><p id="a7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有意思！我们的前端现在有两个下拉框，我们可以在其中选择<code class="fe lw lx ly lz b">X</code>和<code class="fe lw lx ly lz b">Y</code>轴的列。但是..我们怎样才能把这些元素赋予我们的情节呢？这就是后端层的用武之地:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="3d4b" class="nw mw it lz b be nx ny l nz oa">server &lt;- function(input, output) {<br/>  output$scatter &lt;- renderPlot({<br/>      ggplot(<br/>      data = mtcars,<br/>      aes_string(x=input$var1, y=input$var2)<br/>    ) + geom_point(color='darkgreen')<br/>  })<br/>}</span></pre><p id="1217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们可以使用标准的输入和输出参数。当我们在<code class="fe lw lx ly lz b">shinyApp</code>的上下文中使用<code class="fe lw lx ly lz b">server</code>函数时，输入和输出将在应用程序内部被解析。例如，<code class="fe lw lx ly lz b">input$var1</code>将从页面中的第一个<code class="fe lw lx ly lz b">selectInput</code>中选取数据，因为第一个<code class="fe lw lx ly lz b">selectInput</code>的 id 是<code class="fe lw lx ly lz b">var1</code>。</p><p id="a534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们现在运行我们的<code class="fe lw lx ly lz b">shinyApp</code>时，我们的应用看起来会有点不同:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="956b" class="nw mw it lz b be nx ny l nz oa">shinyApp(sp, server)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/eae9b204f7d2158816592b44dbe57c81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KK7gc4cWFj6FS-Y2v9kH_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有散点图的绘图应用程序-图片由作者提供</p></figure><p id="5706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有我们的闪亮的应用程序可用的情节！在当前的视图中，散点图并没有说太多，因为我们正在绘制<code class="fe lw lx ly lz b">mpg</code>对<code class="fe lw lx ly lz b">mgp</code>，同一个变量。有趣的是，如果我们改变下拉列表中的列，我们的绘图将自动更新:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/4cd00be8370e3b983fc9c01e08388871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QZCRXGBIz-yQLGPWpmPpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绘图应用程序，散点图 mpg 与 wt-作者提供的图片</p></figure><p id="140a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷！所以，基本上，每次我们切换 id 为<code class="fe lw lx ly lz b">var1</code>的<code class="fe lw lx ly lz b">selectInput</code>时，存储的列都存储在变量中，并提供给服务器上的<code class="fe lw lx ly lz b">input$var1</code>。同样的道理也适用于<code class="fe lw lx ly lz b">input$var2</code>和<code class="fe lw lx ly lz b">var2</code>。从逻辑上讲，id 是我们用来连接后端和前端层的参考。</p><p id="d798" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以在前端方面进一步调整我们的应用程序。例如，我们可以将我们的布局拆分成一个并排的应用程序，使用<code class="fe lw lx ly lz b">sidebarLayout</code>并将每个部分包装在<code class="fe lw lx ly lz b">sidebarPanel</code>和<code class="fe lw lx ly lz b">mainPanel</code>中:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="51a7" class="nw mw it lz b be nx ny l nz oa">sp &lt;- fluidPage(<br/>  <br/>  sidebarLayout(<br/>    <br/>    sidebarPanel(<br/>      selectInput(<br/>        inputId = 'var1',<br/>        label = 'Column X Axis',<br/>        choices = colnames(mtcars)<br/>      ),<br/>      <br/>      selectInput(<br/>        inputId= 'var2',<br/>        label = 'Column Y Axis',<br/>        choices = colnames(mtcars)<br/>      )<br/>    ),<br/>    <br/>    mainPanel(<br/>      plotOutput("scatter")<br/>    )<br/>  )<br/>)</span></pre><p id="dc34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的应用程序现在将具有以下外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c9ef81869cfaff0e31995cca88307131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*52TSLm265EvBOyA-B9JdGA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有侧边栏布局的绘图应用程序-图片由作者提供</p></figure><p id="7835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的新布局是一个两列格式的图，我们可以操纵。我们选择了一个<code class="fe lw lx ly lz b">sideBar</code>布局，但是，还有更多的布局可供我们选择，这里有<a class="ae ky" href="https://shiny.rstudio.com/articles/layout-guide.html" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="95d5" class="mv mw it bd mx my mz na nb nc nd ne nf jz ng ka nh kc ni kd nj kf nk kg nl nm bi translated">基于模型构建应用程序</h1><p id="8f3c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们已经使用绘图应用程序构建了第一个有用的<code class="fe lw lx ly lz b">shiny</code>应用程序！我们研究的主要层次是:</p><ul class=""><li id="c4ba" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">我们可以使用自定义的<code class="fe lw lx ly lz b">server</code>函数创建一个后端。</li><li id="da4f" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">我们可以使用<code class="fe lw lx ly lz b">fluidPage</code>设计前端</li></ul><p id="fd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们在<code class="fe lw lx ly lz b">shiny</code>中开发的大多数单页面应用程序来说，这种机制是重复的。如果你对多页面应用很好奇，也可以查一下<a class="ae ky" href="https://github.com/Appsilon/shiny.router" rel="noopener ugc nofollow" target="_blank"> shiny.router </a>。</p><p id="d0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的最后一个例子，让我们使用三列布局的<code class="fe lw lx ly lz b">shiny</code>提供一个基本的决策树模型。</p><p id="aae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将在我们的<code class="fe lw lx ly lz b">mtcars</code>数据之上训练一个决策树，尝试基于<code class="fe lw lx ly lz b">wt</code>、<code class="fe lw lx ly lz b">cyl</code>和<code class="fe lw lx ly lz b">hp</code>来预测<code class="fe lw lx ly lz b">mpg</code>:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="be1e" class="nw mw it lz b be nx ny l nz oa">library(rpart)<br/><br/>dtree &lt;- rpart(data=mtcars, mpg ~ wt + cyl + hp,<br/>               control = list(minsplit=1))</span></pre><p id="4f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这是一个可笑的决策树和模型训练过程，它甚至不包含一个适当的训练-测试分割。这里的目标只是在<code class="fe lw lx ly lz b">shiny</code>的上下文中使用一个基本模型，所以现在让我们忽略这些细节。</p><p id="400d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这个<code class="fe lw lx ly lz b">dtree</code>对象保存到一个<code class="fe lw lx ly lz b">rds</code>文件中:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="d740" class="nw mw it lz b be nx ny l nz oa">saveRDS(object=dtree, file='decisiontree.rds')</span></pre><p id="983a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要构建以下应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/306ecbbf8c7dcfcb6741750fb97dfd56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMAJZf91bvP8tEcZ3mX7lA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计划中的应用程序—作者图片</p></figure><p id="ea15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们需要三列，这是一个混合了<code class="fe lw lx ly lz b">fluidRow</code>和<code class="fe lw lx ly lz b">column</code>的优秀用例。让我们从构建一个三列布局开始，从我们的前端开始:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="04ff" class="nw mw it lz b be nx ny l nz oa"><br/>sp &lt;- fluidPage(<br/>  <br/>  fluidRow(<br/>    <br/>    column(4, 'Column 1!'),<br/>    <br/>    column(4, 'Column 2!'),<br/>  <br/>    column(4, 'Column 3!')       <br/>  )<br/>)<br/><br/>server &lt;- function(input, output) {<br/>}<br/>shinyApp(sp, server)</span></pre><p id="7ec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe lw lx ly lz b">shinyApp</code>将具有以下外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/204d0aa92fb1d89678cce18a1205a319.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6r-yeYZyNar9iBaos877g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三栏应用程序—作者图片</p></figure><p id="52e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们的<code class="fe lw lx ly lz b">Column 1!</code>、<code class="fe lw lx ly lz b">Column 2!</code>和<code class="fe lw lx ly lz b">Column 3!</code>在应用程序的前端等距分布。关于<code class="fe lw lx ly lz b">fluidRow</code>和<code class="fe lw lx ly lz b">column</code>很酷的一点是，它们以一种“boostrapy”的方式运行，这意味着，如果我们不使用全屏，我们的列将被堆叠，而不是将数据压缩成不可读的东西。</p><p id="e62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从第一列开始，我们希望有一个所有可用汽车的列表，以便我们可以选择我们将在中间一列突出显示的汽车—这样做很容易，因为我们已经了解了<code class="fe lw lx ly lz b">selectInput</code>:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="dc40" class="nw mw it lz b be nx ny l nz oa"><br/>sp &lt;- fluidPage(<br/>  <br/>  fluidRow(<br/>    <br/>    column(4, <br/>        selectInput(<br/>          inputId = 'selectedcar',<br/>          label = 'Car List',<br/>          choices = rownames(mtcars)<br/>        )<br/>    ),<br/>    <br/>    column(4, 'Column 2!'),<br/>  <br/>    column(4, 'Column 3!')       <br/>  )<br/>)<br/><br/>server &lt;- function(input, output) {<br/>}<br/>shinyApp(sp, server)</span></pre><p id="3436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左栏中，我们现在可以选择特定的汽车:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/4bd2bdd99705ff4de2788e62e85aba7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNqmn0Chyb3fAJQoRR-fVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三栏应用程序—作者图片</p></figure><p id="2ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二列中，我们希望用突出显示的选定汽车来绘制我们的预测图。为此，我们需要做几件事情，即与后端交互:</p><ul class=""><li id="b2f4" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">加载我们的模型并预测所有汽车的重量。</li><li id="3ab5" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">建立一个 MPG 与 HP 的二维图表(如果您愿意，您也可以添加另一个选择第二个变量的下拉列表)</li><li id="d260" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">高亮显示所选汽车的散点。</li></ul><p id="5b34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何构建符合这些要求的后端的示例:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="684e" class="nw mw it lz b be nx ny l nz oa">server &lt;- function(input, output) {<br/>  model &lt;- readRDS('decisiontree.rds')<br/>  predictions &lt;- data.frame(cbind(<br/>    mtcars$hp,<br/>    predict(object = model, mtcars)<br/>  ))<br/>  <br/>  colnames(predictions) &lt;- c('hp','pred_mpg')<br/>  <br/>  sc &lt;- reactive({<br/>    selected_car &lt;- input$selectedcar<br/>  })<br/><br/>  output$scatter &lt;- renderPlot({<br/>    <br/>    select_car &lt;- sc()<br/>    <br/>    (<br/>      plot_all_cars &lt;- ggplot(<br/>        data = predictions,<br/>        aes(x=hp, y=pred_mpg)<br/>      ) <br/>      + geom_point(colour="darkgreen") <br/>      + geom_point(data=predictions[select_car, ], aes(x=hp, y=pred_mpg), colour="red", size=5)<br/>    )<br/>  }) </span></pre><p id="95ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一步一步地详述我们的后端代码:</p><ul class=""><li id="ded2" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">首先，我们使用<code class="fe lw lx ly lz b">model&lt;-readRDS('decisiontree.rds')</code> <br/>加载我们的模型，并使用<code class="fe lw lx ly lz b">predict</code>函数从我们的模型中获得预测。</li><li id="0b55" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">然后，我们定义我们的<code class="fe lw lx ly lz b">predictions object.</code>的<code class="fe lw lx ly lz b">colnames</code></li><li id="4377" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">之后，我们设置了一个<code class="fe lw lx ly lz b">reactive</code>对象。<code class="fe lw lx ly lz b">reactive</code>对象是会影响任何其他对象的对象(需要计算)。例如，在这种情况下，<code class="fe lw lx ly lz b">select_car</code>将影响应用于<code class="fe lw lx ly lz b">geom_point</code>图中的<code class="fe lw lx ly lz b">dataframe</code>的过滤器。由于这需要在后台进行一些计算，我们需要在这个对象上设置一个反应上下文，定义它用函数<code class="fe lw lx ly lz b">sc()</code>调用。</li><li id="6fc0" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">最后，我们用两个<code class="fe lw lx ly lz b">geom_point</code>来定义<code class="fe lw lx ly lz b">plot_all_cars</code>:一个用于所有汽车，另一个(将作为亮点)用于我们选择的汽车。注意<code class="fe lw lx ly lz b">select_car</code>将包含从<code class="fe lw lx ly lz b">sc</code>返回的反应对象，我们将使用左边的下拉菜单加载该对象。</li></ul><p id="f0b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看我们的应用程序的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/1660516a692d3d8d66b10bef2868316c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ITfNd8rk8sYEPvPxT2Qe5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三栏应用程序(突出显示马自达 RX4 Wag)-作者图片</p></figure><p id="3dad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们突出显示另一辆车，我们的图的突出显示会发生变化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/55d8e37362fe139b02bb1b2c2cbec517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VVoaE0e5m7xLk9BxTvgNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三栏应用程序(突出显示克莱斯勒帝国)-作者图片</p></figure><p id="efb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前端，我们只需改变我们的第二列，为它添加一个<code class="fe lw lx ly lz b">plotOutput</code>模块:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="baf0" class="nw mw it lz b be nx ny l nz oa">sp &lt;- fluidPage(<br/>  <br/>  fluidRow(<br/>    <br/>    column(4, <br/>        selectInput(<br/>          inputId = 'selectedcar',<br/>          label = 'Car List',<br/>          choices = rownames(mtcars)<br/>        )<br/>    ),<br/>    <br/>    column(4, <br/>           plotOutput('scatter')<br/>           ),<br/>  <br/>    column(4, 'Column 3!')       <br/>  )<br/>)</span></pre><p id="cc69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只剩下一件事了！在右栏中绘制我们的决策树——让我们在后端也这样做，但是，首先，我们需要加载<code class="fe lw lx ly lz b">rattle</code>库:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="a58c" class="nw mw it lz b be nx ny l nz oa">library(rattle)</span></pre><p id="5a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，对我们的后端和前端层进行一些更改:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="41bc" class="nw mw it lz b be nx ny l nz oa">server &lt;- function(input, output) {<br/>  model &lt;- readRDS('decisiontree.rds')<br/>  predictions &lt;- data.frame(cbind(<br/>    mtcars$hp,<br/>    predict(object = model, mtcars)<br/>  ))<br/>  <br/>  colnames(predictions) &lt;- c('hp','pred_mpg')<br/>  <br/>  sc &lt;- reactive({<br/>    selected_car &lt;- input$selectedcar<br/>  })<br/><br/>  output$scatter &lt;- renderPlot({<br/>    <br/>    select_car &lt;- sc()<br/>    <br/>    (<br/>      plot_all_cars &lt;- ggplot(<br/>        data = predictions,<br/>        aes(x=hp, y=pred_mpg)<br/>      ) <br/>      + geom_point(colour="darkgreen") <br/>      + geom_point(data=predictions[select_car, ], aes(x=hp, y=pred_mpg), colour="red", size=5)<br/>    )<br/>  })<br/>  <br/>  output$dtree_plot &lt;- renderPlot({<br/>    fancyRpartPlot(model, sub='')<br/>  })<br/>  <br/>}<br/><br/>sp &lt;- fluidPage(<br/>  <br/>  fluidRow(<br/>    <br/>    column(4, <br/>        selectInput(<br/>          inputId = 'selectedcar',<br/>          label = 'Car List',<br/>          choices = rownames(mtcars)<br/>        )<br/>    ),<br/>    <br/>    column(4, <br/>           plotOutput('scatter')<br/>           ),<br/>  <br/>    column(4, <br/>           plotOutput('dtree_plot')<br/>          )       <br/>  )<br/>)</span></pre><p id="a644" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级简单！对于上面的后端代码，我们添加了:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="4076" class="nw mw it lz b be nx ny l nz oa">output$dtree_plot &lt;- renderPlot({<br/>    fancyRpartPlot(model, sub='')<br/>  })</span></pre><p id="479f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的前端引用它之后，我们最终的应用程序如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7a7c347c5cf3de10ae6d009b5bd39a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJ6oV4lIAFrdzS_eKf4TKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三栏应用程序—作者图片</p></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="ba50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，用 R 构建<code class="fe lw lx ly lz b">shiny</code>应用程序非常简单。在这篇文章中，我们检查了一些重要的组件，例如:</p><ul class=""><li id="f226" class="ma mb it lb b lc ld lf lg li mc lm md lq me lu mf mg mh mi bi translated">使用<code class="fe lw lx ly lz b">fluidPage</code>构建我们应用程序的前端。</li><li id="015d" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">使用自定义函数<code class="fe lw lx ly lz b">server</code>构建我们应用程序的后端。</li><li id="2e0f" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">使用<code class="fe lw lx ly lz b">ids</code>和<code class="fe lw lx ly lz b">reactive</code>元件连接我们的前端和后端。</li><li id="4574" class="ma mb it lb b lc mj lf mk li ml lm mm lq mn lu mf mg mh mi bi translated">使用不同的 UI 元素，如<code class="fe lw lx ly lz b">fluidRow</code>或<code class="fe lw lx ly lz b">sidebarPanel</code>。</li></ul><p id="a415" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章给了你一些可以为你的项目开发的很酷的应用的想法。作为结论:<code class="fe lw lx ly lz b">shiny</code>包含一堆可调整的元素，很难记住所有的元素。你可以保存的一个更重要的页面是<a class="ae ky" href="https://shiny.rstudio.com/articles/#first-app" rel="noopener ugc nofollow" target="_blank">闪亮文章</a>，这是图书馆的官方文档，它将指导你了解我们在这篇文章中没有涉及的其他内容。</p><p id="4828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你花时间阅读这篇文章！</p><p id="a044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们构建的应用程序的完整代码:</p><pre class="kj kk kl km gt ns lz nt bn nu nv bi"><span id="f637" class="nw mw it lz b be nx ny l nz oa">library(shiny)<br/><br/># First App<br/><br/>sp &lt;- fluidPage(<br/>  "My first shiny page!"<br/>)<br/>server &lt;- function(input, output) {<br/>}<br/>shinyApp(sp, server)<br/><br/># Second App<br/>sp &lt;- fluidPage(<br/>  <br/>  sidebarLayout(<br/>    <br/>    sidebarPanel(<br/>      selectInput(<br/>        inputId = 'var1',<br/>        label = 'Column X Axis',<br/>        choices = colnames(mtcars)<br/>      ),<br/>      <br/>      selectInput(<br/>        inputId= 'var2',<br/>        label = 'Column Y Axis',<br/>        choices = colnames(mtcars)<br/>      )<br/>    ),<br/>    <br/>    mainPanel(<br/>      plotOutput("scatter")<br/>    )<br/>  )<br/>)<br/><br/>server &lt;- function(input, output) {<br/>  output$scatter &lt;- renderPlot({<br/>      ggplot(<br/>      data = mtcars,<br/>      aes_string(x=input$var1, y=input$var2)<br/>    ) + geom_point(color='darkgreen')<br/>  })<br/>}<br/>shinyApp(sp, server)<br/><br/># Training model<br/>library(rpart)<br/><br/>dtree &lt;- rpart(data=mtcars, mpg ~ wt + cyl + hp,<br/>               control = list(minsplit=1))<br/><br/># Save dtree file<br/>saveRDS(object=dtree, file='decisiontree.rds')<br/><br/># Third App<br/>sp &lt;- fluidPage(<br/>  <br/>  fluidRow(<br/>    <br/>    column(4, <br/>        selectInput(<br/>          inputId = 'selectedcar',<br/>          label = 'Car List',<br/>          choices = rownames(mtcars)<br/>        )<br/>    ),<br/>    <br/>    column(4, <br/>           plotOutput('scatter')<br/>           ),<br/>  <br/>    column(4, <br/>           plotOutput('dtree_plot')<br/>          )       <br/>  )<br/>)<br/><br/><br/>server &lt;- function(input, output) {<br/>  model &lt;- readRDS('decisiontree.rds')<br/>  predictions &lt;- data.frame(cbind(<br/>    mtcars$hp,<br/>    predict(object = model, mtcars)<br/>  ))<br/>  <br/>  colnames(predictions) &lt;- c('hp','pred_mpg')<br/>  <br/>  sc &lt;- reactive({<br/>    selected_car &lt;- input$selectedcar<br/>  })<br/><br/>  output$scatter &lt;- renderPlot({<br/>    <br/>    select_car &lt;- sc()<br/>    <br/>    (<br/>      plot_all_cars &lt;- ggplot(<br/>        data = predictions,<br/>        aes(x=hp, y=pred_mpg)<br/>      ) <br/>      + geom_point(colour="darkgreen") <br/>      + geom_point(data=predictions[select_car, ], aes(x=hp, y=pred_mpg), colour="red", size=5)<br/>    )<br/>  })<br/>  <br/>  output$dtree_plot &lt;- renderPlot({<br/>    fancyRpartPlot(model, sub='')<br/>  })<br/>  <br/>}<br/><br/>shinyApp(sp, server)</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><p id="36e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">如果你想参加我的 R 课程，请随时加入这里(</em> <a class="ae ky" href="https://www.udemy.com/course/r-for-absolute-beginners/?couponCode=MEDIUMREADERSSEP" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> R 编程绝对初学者</em> </a> <em class="lv">)或这里(</em> <a class="ae ky" href="https://www.udemy.com/course/r-for-data-science-first-step-data-scientist/?couponCode=MEDIUMOCTOBER" rel="noopener ugc nofollow" target="_blank"> <em class="lv">数据科学训练营</em> </a> <em class="lv">)。我的 R 课程适合初学者/中级开发人员，我希望有你在身边！</em></p></div></div>    
</body>
</html>