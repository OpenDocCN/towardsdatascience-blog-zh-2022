<html>
<head>
<title>How to Build a Unique MD5 Row Hash Using SQL in BigQuery (Plus a Few Related Things)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在BigQuery中使用SQL构建唯一的MD5行散列(加上一些相关的东西)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-unique-md5-row-hash-using-sql-in-bigquery-plus-a-few-related-things-e6f71820f38b#2022-08-05">https://towardsdatascience.com/how-to-build-a-unique-md5-row-hash-using-sql-in-bigquery-plus-a-few-related-things-e6f71820f38b#2022-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="24bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用原生BigQuery功能在SQL中生成动态的、唯一的行标识符</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0a12148d18cac425f7188e9925dba7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JYegQQAH3DncFoC6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不是那种杂碎。在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@newhighmediagroup?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Richard T </a>拍摄的照片</p></figure><h1 id="7864" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机</h1><p id="577c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可能有许多不同的原因想要为BigQuery数据集中的每一行数据构建散列，但它们主要与BigQuery中没有强制主键这一事实有关。</p><p id="b994" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着您的数据可能包含重复的行，无论是来自上游数据收集或传输错误、错误配置的数据摄取工具，还是仅仅因为意外加载了某个内容两次。</p><p id="bab1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者别的什么。谁知道呢？</p><p id="b65f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无论重复的来源是什么，你都应该试着理解<em class="ms">它们是什么</em>，并可能把它们过滤掉(如果你关心这类事情，也要找出根本原因……仅供参考，你可能应该这样做)。</p><p id="5dd1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果<em class="ms">的数据中确实有</em>的重复行，那么一旦你开始应用更复杂的转换(如连接),你就有放大错误并使下游流程、模型和决策无效的风险，这会耗费来之不易的信任，并可能导致其他不可预测的、不想要的结果。</p><p id="7599" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者也许没人会注意到。那会更好还是更坏？</p><p id="3df2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无论您的数据来自何处，在任何数据质量保证流程(以及数据转换流程)中，确认源数据的每一行都是独一无二的，这始终是一个有价值的步骤，既能让您安心，又能让下游数据消费者和系统放心。</p><p id="d1b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank">散列函数</a>的一个简化定义是，它是一个从任意字符串输入中输出唯一的固定长度字符串的函数。它实际上比这更专业一点，因为它是一个字节数组，但它的行为像一个字符串，所以这是一个很好的看待它的方式。</p><p id="c5da" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">需要理解的最重要的几点是:</p><ul class=""><li id="3b41" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm my mz na nb bi translated"><em class="ms">对输入的任何</em>更改都会导致不同的散列</li><li id="495d" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">它只有一种工作方式——您<em class="ms">不能</em>从散列中反算输入，但是您<em class="ms">可以</em>验证输入是否相同</li><li id="d919" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm my mz na nb bi translated">散列使您能够检查输入是否完全相同，这对于有效的验证非常有用，尤其是在不同的系统之间，因为这样您就可以使用相同算法的特定语言实现</li></ul><h1 id="3c3e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">情况</h1><p id="3266" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将部署一些不同的本地函数和技术，以优雅、简洁和动态的方式解决这个问题。</p><p id="2850" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这些例子，我们将使用<code class="fe nh ni nj nk b">zoo_elephants</code>表，它包含一些虚构的大象的西瓜年消费量的完全虚构的数据，并且是公共的，因此任何经过身份验证的BigQuery用户都可以查询。数据中没有重复项(但我们希望/需要证明这一点)。要检查BigQuery控制台中的数据，请执行以下查询:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="d784" class="np la it nk b gy nq nr l ns nt">SELECT *<br/>FROM flowfunctions.examples.zoo_elephants</span></pre><p id="0807" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您将在结果面板中看到数据，带有简单的模式:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="88db" class="np la it nk b gy nq nr l ns nt">animal STRING,<br/>name STRING,<br/>year INT64,<br/>watermelons INT64</span></pre><h1 id="48c0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">解决办法</h1><ol class=""><li id="a69f" class="mt mu it lt b lu lv lx ly ma nu me nv mi nw mm nx mz na nb bi translated"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions#to_json_string" rel="noopener ugc nofollow" target="_blank"><strong class="lt iu">TO _ JSON _ STRING()</strong>T7】</a></li></ol><p id="2c58" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一个极其健壮和强大的函数，它(在许多用例中)使您能够向一个公共表表达式添加一列，该表达式是每行的JSON表示。要了解其工作原理，请尝试以下查询:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="af62" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>)<br/></span><span id="be5a" class="np la it nk b gy ny nr l ns nt">SELECT *, <br/>TO_JSON_STRING(inbound_zoo_elephants) AS row_json<br/>FROM inbound_zoo_elephants</span></pre><p id="8c1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您将看到输出数据现在有一个额外的列，包含数据的JSON表示，例如第一行的<code class="fe nh ni nj nk b">row_json</code>列包含值:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="e753" class="np la it nk b gy nq nr l ns nt">{"animal":"Elephant","name":"Beepbeep","year":2018,"watermelons":1032}</span></pre><p id="cbe4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果在函数中添加一个<code class="fe nh ni nj nk b">true</code>可选<code class="fe nh ni nj nk b">pretty_print</code>参数:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="b2df" class="np la it nk b gy nq nr l ns nt">TO_JSON_STRING(inbound_zoo_elephants, true) AS row_json</span></pre><p id="2b1f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后你可以把它打印得很漂亮，用换行符来表示行中的数据:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="ebea" class="np la it nk b gy nq nr l ns nt">{<br/>"animal": "Elephant",<br/>"name": "Beepbeep",<br/>"year": 2018,<br/>"watermelons": 1032<br/>}</span></pre><p id="3850" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个输出较长，但更容易阅读，这可能是有用的。然而，在我们的用例中，额外的空白是不必要的。</p><p id="c69b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 2。</strong> <a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#md5" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> MD5() </strong> </a></p><p id="18a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在对于散列函数…有几个不同的选项，给出不同长度和类型的输出。我们将使用一个简单的<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#md5" rel="noopener ugc nofollow" target="_blank"> MD5 </a>，尽管它显然被<a class="ae ky" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank">加密破解</a>，返回16个字符，足以满足我们的用例。其他选项有<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#farm_fingerprint" rel="noopener ugc nofollow" target="_blank"> FARM_FINGERPRINT </a>(返回一个可变长度的有符号整数)<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#sha1" rel="noopener ugc nofollow" target="_blank"> SHA1 </a>、<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#sha256" rel="noopener ugc nofollow" target="_blank"> SHA256 </a>和<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions#sha512" rel="noopener ugc nofollow" target="_blank"> SHA512 </a>，分别返回20、32和64字节，对于密码用例更安全。然而，MD5显然是最短的一个，因此它占用较少的屏幕空间(加上这不是一个加密用例)，所以我们要用它:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="4a8a" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>),</span><span id="795a" class="np la it nk b gy ny nr l ns nt">add_row_json AS (<br/>SELECT *,<br/>TO_JSON_STRING(inbound_zoo_elephants) AS row_json<br/>FROM inbound_zoo_elephants<br/>)<br/></span><span id="d7ae" class="np la it nk b gy ny nr l ns nt">SELECT *,<br/>MD5(row_json) AS row_hash<br/>FROM add_row_json</span></pre><p id="9628" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您将看到第一行的<code class="fe nh ni nj nk b">row_hash_column</code>值类似于:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="ca70" class="np la it nk b gy nq nr l ns nt">xFkt7kQAks91FtJTt5d5lA==</span></pre><p id="b179" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这包含字母数字以及特殊字符，这将有助于我们的目标，但<em class="ms">可能会导致其他问题。</em></p><p id="3547" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，您需要三次单击它来选择它，如果您双击它，那么您只会得到第一个特殊字符(在本例中:=)之前的字符串。如果你像我一样，是一个容易犯人为错误的人，这可能是个问题。</p><p id="dffa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">继续，试着选择它。然后取消选择它。然后再次选择它。挺烦的吧？</p><p id="ddb5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> 3。</strong> <a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions#to_hex" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">到_十六进制</strong> </a></p><p id="0e8d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将用来整理这个输出的最后一个函数将把上一步的杂乱的输出转换成一个整洁的十六进制字符串，它本质上是一个包含数字和字母组合的字符串。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="dce5" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>),</span><span id="1460" class="np la it nk b gy ny nr l ns nt">add_row_json AS (<br/>SELECT *,<br/>TO_JSON_STRING(inbound_zoo_elephants) AS row_json<br/>FROM inbound_zoo_elephants<br/>),</span><span id="4476" class="np la it nk b gy ny nr l ns nt">add_row_hash AS (<br/>SELECT *,<br/>MD5(row_json) AS row_hash<br/>FROM add_row_json<br/>)<br/></span><span id="1475" class="np la it nk b gy ny nr l ns nt">SELECT *,<br/>TO_HEX(row_hash) AS hex_row_hash<br/>FROM add_row_hash</span></pre><p id="eb58" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">执行这段代码，您会看到<code class="fe nh ni nj nk b">hex_row_hash</code>列的值类似于:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="43af" class="np la it nk b gy nq nr l ns nt">c4592dee440092cf7516d253b7977994</span></pre><p id="13fa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在是32个可爱的小写十六进制字符。</p><p id="1f4e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">试着双击它，你会意识到选择它的体验是一种更加人性化的交互。在一生中，这将为您节省大约<code class="fe nh ni nj nk b">33%</code>点击选择该选项所需的次数，这相当于更低的错误率和更低的重复性劳损几率。</p><p id="6648" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，输出将只包含小写字母，所以如果您特别喜欢大写字母(我没有)，那么您可以合理地将<code class="fe nh ni nj nk b">TO_HEX</code>行改为:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="09a2" class="np la it nk b gy nq nr l ns nt">UPPER(TO_HEX(row_hash)) AS hex_row_hash</span></pre><p id="1296" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这给出了输出:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="6510" class="np la it nk b gy nq nr l ns nt">DCBADCD29D37091C34BAFE4EE114DBA0</span></pre><p id="7c1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，这是一个多余的步骤，所以我们不会这样做。另外，我只喜欢对SQL关键字使用大写字母，因为我发现用我人类的(也有些蹩脚的)眼睛扫描和理解代码结构更快更容易。</p><p id="18d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，现在公共表表达式结构的查询已经很清楚了，每个CTE名称都清楚地描述了它所采取的特定操作:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="36d7" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>),</span><span id="e24d" class="np la it nk b gy ny nr l ns nt">add_row_json AS (<br/>SELECT *,<br/>TO_JSON_STRING(inbound_zoo_elephants) AS row_json<br/>FROM inbound_zoo_elephants<br/>),</span><span id="82ff" class="np la it nk b gy ny nr l ns nt">add_row_hash AS (<br/>SELECT *,<br/>MD5(row_json) AS row_hash<br/>FROM add_row_json<br/>),</span><span id="1b78" class="np la it nk b gy ny nr l ns nt">add_row_hash_hex AS (<br/>SELECT *,<br/>TO_HEX(row_hash) AS hex_row_hash<br/>FROM add_row_hash<br/>)</span><span id="a43c" class="np la it nk b gy ny nr l ns nt">SELECT *<br/>FROM add_row_hash_hex</span></pre><p id="b901" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于开发和调试来说，这是一个非常有用的结构，但是非常冗长，不太有用。作为第一步，现在我们知道所有的步骤都起作用了，我们可以重构代码，使其更加简洁:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="6820" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>)</span><span id="b306" class="np la it nk b gy ny nr l ns nt">SELECT *,<br/>TO_HEX(MD5(TO_JSON_STRING(inbound_zoo_elephants))) AS hex_row_hash<br/>FROM inbound_zoo_elephants</span></pre><p id="53fd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是较短的，但仍然不可重复使用。让我们把它打包成一个简单的函数，以便在需要的时候快速简单地重用它。</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="146c" class="np la it nk b gy nq nr l ns nt">CREATE OR REPLACE FUNCTION `flowfunctions.hash.hex_md5_row_hash`(row_json STRING) <br/>AS (<br/>TO_HEX(MD5(row_json)) <br/>);</span></pre><p id="82eb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以通过更改<code class="fe nh ni nj nk b">project_id</code>(上面代码中的<code class="fe nh ni nj nk b">flowfunctions</code>)和<code class="fe nh ni nj nk b">dataset_name</code>(代码中的<code class="fe nh ni nj nk b">hash</code>)在您自己的项目和数据集中重新创建它。</p><p id="3eb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实际上，我喜欢添加一行描述，以便用户可以就地查看文档，这样可以最大限度地减少任务切换，并添加有价值的本机可用元数据。此外，知道将<code class="fe nh ni nj nk b">row_json</code>参数作为<code class="fe nh ni nj nk b">TO_JSON_STRING (cte_name)</code>传入也很重要，所以我在描述选项中解释了这一点:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="48f7" class="np la it nk b gy nq nr l ns nt">CREATE OR REPLACE FUNCTION `flowfunctions.hash.hex_md5_row_hash`(row_json STRING)<br/>OPTIONS (<br/>description="Returns: [STRING] Hexadecimal encoding of an MD5 hash of the JSON string representation of a row.  The row_json argument should be passed as TO_JSON_STRING(cte_name) where cte_name is the name of a prior common table expression"<br/>)<br/>AS (<br/>TO_HEX(MD5(row_json))<br/>);</span></pre><p id="1a4f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">太好了！现在在<a class="ae ky" href="https://console.cloud.google.com/bigquery?ws=!1m5!1m4!6m3!1sflowfunctions!2shash!3shex_md5_row_hash" rel="noopener ugc nofollow" target="_blank">控制台</a>中看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/a4a8ca747ec74ed462b893a286461d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_YOOsklJj1uykDVEPePFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">漂亮整洁。</p></figure><h1 id="784e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">执行</h1><p id="3c3b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们可以这样调用函数:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="7eff" class="np la it nk b gy nq nr l ns nt">SELECT flowfunctions.hash.hex_md5_row_hash(row_json STRING)</span></pre><p id="1dea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者镜像前一个查询的语法:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="85f1" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>)</span><span id="ee28" class="np la it nk b gy ny nr l ns nt">SELECT *,<br/>flowfunctions.hash.hex_md5_row_hash(inbound_zoo_elephants) AS hex_row_hash<br/>FROM inbound_zoo_elephants</span></pre><p id="921b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这可能比前一个版本更冗长，所以您可能实际上只想使用前一个版本，消除不必要的(在本例中)函数依赖:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="a73e" class="np la it nk b gy nq nr l ns nt">TO_HEX(MD5(TO_JSON_STRING(inbound_zoo_elephants))) AS hex_row_hash</span></pre><p id="1a34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">无论哪种方式，为了实现最终证明数据集中没有重复项的目标，我们需要在查询中再执行一个步骤来比较总行数和唯一行数:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="c25e" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>),</span><span id="b38e" class="np la it nk b gy ny nr l ns nt">add_row_hash AS (<br/>SELECT *,<br/>TO_HEX(MD5(TO_JSON_STRING(inbound_zoo_elephants))) AS hex_row_hash<br/>FROM inbound_zoo_elephants<br/>)</span><span id="600c" class="np la it nk b gy ny nr l ns nt">SELECT<br/>COUNT(*) AS records,<br/>COUNT(DISTINCT hex_row_hash) AS unique_records<br/>FROM add_row_hash</span></pre><p id="b41a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它返回:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/d7ec11a7fab753071cc8fdd8b0077ab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*90Q6mP7FKwTChCbqfQSCvg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">太棒了。</p></figure><p id="b8c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于<code class="fe nh ni nj nk b">records</code>的值与<code class="fe nh ni nj nk b">unique_records</code>匹配，我们可以得出结论，每一行都是唯一的。太好了，我们可以继续我们的分析，而不用担心重复及其影响。</p><p id="f724" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">实际上，考虑到前面提到的我糟糕的视力，我将添加一个红色/绿色图标，这样我就不需要做任何复杂的心算了:</p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="5224" class="np la it nk b gy nq nr l ns nt">WITH<br/>inbound_zoo_elephants AS (<br/>SELECT *<br/>FROM flowfunctions.examples.zoo_elephants<br/>),</span><span id="a86e" class="np la it nk b gy ny nr l ns nt">add_row_hash AS (<br/>SELECT *,<br/>TO_HEX(MD5(TO_JSON_STRING(inbound_zoo_elephants))) AS hex_row_hash<br/>FROM inbound_zoo_elephants<br/>)</span><span id="ebdf" class="np la it nk b gy ny nr l ns nt">SELECT<br/>COUNT(*) AS records,<br/>COUNT(DISTINCT hex_row_hash) AS unique_records,<br/>CASE <br/>WHEN COUNT(*) = COUNT(DISTINCT hex_row_hash) <br/>THEN '🟢' ELSE '🔴' <br/>END AS unique_check_icon<br/>FROM add_row_hash</span></pre><p id="a6b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">唷，现在我不需要在脑子里比较任何数字，绿灯让我知道一切都好:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/55c85df022866356e083a8e551b76647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NTKguzO7rNJCcmCBKn2zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">很好看。</p></figure><p id="d4c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">虽然在这样一个简单的例子中使用这种技术显然有点不必要，但实际上它确实有助于在更复杂的查询中快速识别潜在的差异和问题。</p><p id="ee37" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以快速可靠的方式检查更多行的列匹配或相似性，而不必离开BigQuery控制台工作流，这是一个强大的小生产力提升。小幅度的生产力提升积少成多…</p><h1 id="3618" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="2959" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你可能会想:</p><ol class=""><li id="2d88" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm nx mz na nb bi translated">这篇文章不应该是关于简单的行散列，而不是行复制测试、固执己见的SQL结构断言、无意义的函数开发或让BigQuery显示愚蠢的交通灯吗？</li><li id="08c1" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm nx mz na nb bi translated">难道你不能用更少的代码，使用不同的and联合和子查询之类的东西来实现同样的事情吗？</li></ol><p id="589e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对此我会回答:</p><ol class=""><li id="77dd" class="mt mu it lt b lu mn lx mo ma mv me mw mi mx mm nx mz na nb bi translated">是啊，我知道。然而，这种看待问题的方式引出了一些相邻的有用的技术，这些技术值得研究，因为它们可以在许多其他方面得到应用。另外，我问你一个问题:你更喜欢哪种类型的旅行……a)直接到达目的地而不分心的旅行，还是b)到达目的地但沿途发现许多新奇有趣的地方的旅行？</li><li id="eede" class="mt mu it lt b lu nc lx nd ma ne me nf mi ng mm nx mz na nb bi translated">是啊，管它呢。在生活和代码中，总是有很多方法可以实现任何事情。有些人有缺点，有些人有机会，但大多数人两者都有。实际上，您可能想知道<em class="ms">哪些</em>行实际上是重复的，这样您就可以标记和/或过滤和/或用于数据质量保证，这种技术为您提供了这种能力。现在，您还将拥有一个可靠的惟一连接键，它可以充当(非强制)主键。此外，复杂的嵌套子查询和怪异的自连接扭曲可能很快变得无法阅读或直觉，根据<a class="ae ky" href="https://transformationflow.github.io/the-zen-of-sql/" rel="noopener ugc nofollow" target="_blank">SQL的禅</a>:</li></ol><blockquote class="oc od oe"><p id="c38b" class="lr ls ms lt b lu mn ju lw lx mo jx lz of mp mc md og mq mg mh oh mr mk ml mm im bi translated">TFSQL10.1:可读性计数</p></blockquote><p id="804b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">写干净的、模块化的、顺序的代码是一个好主意，目标是使它不仅功能性强、效率高，而且易于阅读和理解。不过，我跑题了:</p><p id="840c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">在BigQuery中构建唯一行散列的简单方法:</strong></p><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="96ba" class="np la it nk b gy nq nr l ns nt">TO_HEX(MD5(TO_JSON_STRING(input_data)))</span></pre><p id="a4b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你需要一个如何定义<code class="fe nh ni nj nk b">input_data</code>的解释，那么检查上面的<code class="fe nh ni nj nk b">TO_JSON_STRING()</code>部分。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="bf92" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您觉得这(以及其他相关材料)有用和/或有趣，请跟我来，并查看我的开源项目<a class="ae ky" href="https://transformationflow.io" rel="noopener ugc nofollow" target="_blank">转换流程</a>以获得更多工具和技术来扩展您的BigQuery超能力。</p><p id="cb2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你还不是会员，<a class="ae ky" href="https://jim-barlow.medium.com/membership" rel="noopener">加入Medium </a>这个活跃、充满活力和激情的数据人社区，每月只需5美元就能获得无限的故事。也有很多其他人，但是如果你对数据感兴趣，那么这里就是你要去的地方…</p></div></div>    
</body>
</html>