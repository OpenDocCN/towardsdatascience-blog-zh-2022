<html>
<head>
<title>Design Patterns for Distributed Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式事务的设计模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/distributed-transactions-cdc-event-sourcing-outbox-cqrs-patterns-ee0cf70339b1#2022-03-30">https://towardsdatascience.com/distributed-transactions-cdc-event-sourcing-outbox-cqrs-patterns-ee0cf70339b1#2022-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c2b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解事件来源、命令查询责任分离(CQRS)、变更数据捕获(CDC)和发件箱模式</h2></div><p id="8ec9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终演变为微服务架构的领域驱动的分布式应用架构具有许多优势，如交付服务的速度和敏捷性、小型和专注的团队、可扩展的设计、较小的代码库、容错和数据隔离。在适应微服务架构方面存在各种挑战，架构师和开发人员通常会遇到设计复杂性、数据完整性问题、治理和版本问题。</p><p id="aa97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，有架构驱动的解决方案和设计模式可以克服这些挑战。在这篇文章中，我们将主要关注解决<em class="lb">数据一致性挑战</em>，这是由于整个数据架构中的分布式事务。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/7293279384d8d7165baf2723dc5fb53a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XPVJK6od_Oldq3l2"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">由<a class="ae ls" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c7cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将简要介绍以下内容:</p><ul class=""><li id="2930" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ly lz ma mb bi translated">活动采购</li><li id="f60a" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">变更数据捕获(CDC)</li><li id="6b26" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">命令查询响应分离</li><li id="ee6c" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated">发件箱模式</li></ul><div class="mh mi gp gr mj mk"><a href="https://linkedin.com/in/p-jainani" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">Pankaj Jainani -云架构师</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">我是云解决方案架构师、人工智能工程师、DevOps 顾问、Scrum Master、技术经理……</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">linkedin.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my lm mk"/></div></div></a></div><p id="beaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们分别讨论每个问题之前，让我们先描述两个重要的概念:</p><ul class=""><li id="053d" class="lt lu iq kh b ki kj kl km ko lv ks lw kw lx la ly lz ma mb bi translated"><em class="lb">领域事件</em>:它们是参与者与应用程序交互产生的业务事件。它们代表真实世界的事件，如<em class="lb">loan approval、FraudDetected、ChartUpdated 或 OrderCancelled。</em>领域事件与事件源相关联。</li><li id="7eb1" class="lt lu iq kh b ki mc kl md ko me ks mf kw mg la ly lz ma mb bi translated"><em class="lb">变更事件:</em>随着底层数据库中数据状态的变化而产生。这些是数据库事务日志，与变更数据捕获相关联。</li></ul><h2 id="c7c6" class="mz na iq bd nb nc nd dn ne nf ng dp nh ko ni nj nk ks nl nm nn kw no np nq nr bi translated">活动采购</h2><p id="3f91" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">由业务逻辑生成的应用程序状态的变化被捕获为软件日志中的域事件。该日志允许遍历到时间线中任意点的应用程序的特定状态。日志是一个<em class="lb">只追加</em>存储，并且是不可变的。它们可以在任何时间点重复播放，并且是真实的单一来源。日志中的域事件按 ID 分组，以捕捉对象在任一时间点的状态。<em class="lb">快照</em>是一种重新创建对象状态的机制。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nx"><img src="../Images/069aea5389b4664bf343af95bffdf60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nh2em6k7lPujtBOz6YvGUg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd ny">事件来源</strong>[图片由作者提供]</p></figure><h2 id="8842" class="mz na iq bd nb nc nd dn ne nf ng dp nh ko ni nj nk ks nl nm nn kw no np nq nr bi translated">变更数据捕获(CDC)</h2><p id="3cd9" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">如上所述，来自数据库事务日志的<em class="lb">变更事件</em>被下游消费者捕获和消费。因此，它是一种机制，通过这种机制，我们可以通过一些集成模式将应用程序状态共享给外部系统。</p><p id="d535" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">物化视图是 CDC 方法的关键概念，有一个外部过程将变更事件物化并转发给下游消费者。</p><p id="8bd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个消息代理，它处理事件消息并将其转发给下游的消费者，并保证<em class="lb">至少一次</em>交付。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nz"><img src="../Images/3c8339467a3d5ce94bd5a33570b9b7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1P4THyBFk4RM5kICBIe1Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd ny">改变数据捕捉(CDC) </strong>【图片由作者提供】</p></figure><h2 id="3285" class="mz na iq bd nb nc nd dn ne nf ng dp nh ko ni nj nk ks nl nm nn kw no np nq nr bi translated"><strong class="ak">发件箱模式</strong></h2><p id="fdf3" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">发件箱模式确保应用程序状态(存储在应用程序数据库中)及其各自的域事件(转发给外部使用者)在单个事务下是一致的和持久的。发件箱表在应用程序的数据库中实现，以收集与事务对应的域事件。一旦我们有了事务保证机制，我们就可以使用发件箱表通过 CDC 传播事件交付，如上所述，与 CDC 连接器集成的代理将消息转发给外部消费者。</p><p id="ed93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发件箱的重要之处在于，它只是一个临时的传出事件数据存储库，域事件在下游处理后会立即被删除。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oa"><img src="../Images/6d87cd71fd65f382a1e907e370c176d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXBPx66hf6Pm9Ixfq7C0aw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd ny">发件箱图案</strong>【图片由作者提供】</p></figure><h2 id="f488" class="mz na iq bd nb nc nd dn ne nf ng dp nh ko ni nj nk ks nl nm nn kw no np nq nr bi translated">命令查询责任分离(CQRS)</h2><p id="08a7" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">它通常与事件源相关联，有时用发件箱模式实现。作为视图<em class="lb">的只读数据投影</em>是 CQRS 实现的关键概念。对于不同的消费者，从相同的数据集可以得到多个这样的预测。这构成了分离<em class="lb">查询</em>部分 w.r.t. CQRS 实现的基础。</p><p id="77ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，CQRS 的<em class="lb">命令</em>方面适用于应用程序执行的动作，以生成作为域事件的响应。这使得能够生成投影的状态。因此，这与它与事件源的联系密切相关。</p><p id="717c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须注意，将<em class="lb">命令</em>与<em class="lb">查询</em>分离会导致两个数据模型的最终一致性。CQRS 模式的实现比带有发件箱的 CDC 更复杂。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nx"><img src="../Images/c11097e36b125d36e9a43b96d537fec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbeCpm6DQt5xdcIrzyA0EQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd ny">命令查询责任分离(CQRS) </strong>【图片由作者提供】</p></figure><h2 id="3d32" class="mz na iq bd nb nc nd dn ne nf ng dp nh ko ni nj nk ks nl nm nn kw no np nq nr bi translated">结论</h2><p id="e936" class="pw-post-body-paragraph kf kg iq kh b ki ns jr kk kl nt ju kn ko nu kq kr ks nv ku kv kw nw ky kz la ij bi translated">本文简要介绍了分布式事务架构实现的各种设计模式。有各种全面的文献和文档解释了实现这些模式的细节、某些注意事项、优点和缺点。实际的实现也因用例而异，并且依赖于对实现技术的选择。</p><p id="09aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在后续的文章中，我们将通过解决一个业务用例，同时利用云原生平台服务，详细阐述每个模式的实现。</p><div class="mh mi gp gr mj mk"><a href="https://linkedin.com/in/p-jainani" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">Pankaj Jainani -云架构师</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">我是云解决方案架构师、人工智能工程师、DevOps 顾问、Scrum Master、技术经理……</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">linkedin.com</p></div></div><div class="mt l"><div class="ob l mv mw mx mt my lm mk"/></div></div></a></div></div></div>    
</body>
</html>