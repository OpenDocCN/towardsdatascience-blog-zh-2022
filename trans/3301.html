<html>
<head>
<title>Design Patterns with Python for Machine Learning Engineers: Abstract Factory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向机器学习工程师的Python设计模式:抽象工厂</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/design-patterns-with-python-for-machine-learning-engineers-abstract-factory-f761f89a3c12#2022-07-22">https://towardsdatascience.com/design-patterns-with-python-for-machine-learning-engineers-abstract-factory-f761f89a3c12#2022-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/354d43d42cff7447acf5d568eaf575e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UHDKqfQDjCQGB7gi"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">奥马尔·弗洛雷斯在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="feb5" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">了解如何通过采用设计模式来构建代码</h2></div><h2 id="a63a" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">简介</strong></h2><p id="d485" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">一个模式描述了一个经常重复出现的问题，并根据类/对象组织提出了一个可能的解决方案<br/>，这个解决方案<br/>通常被认为可以有效地解决问题本身。<br/>设计模式有四个主要特征:</p><ul class=""><li id="98c2" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><strong class="lt jh">名称:</strong>帮助我们用一两个词来识别问题和解决方案的助记参考。</li><li id="c6d8" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">问题:</strong>问题的描述和模式提供解决方案的环境。</li><li id="920a" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">解决方案:</strong>描述了构成<br/>解决方案的基本元素以及它们之间的关系。</li><li id="6d1e" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">后果:</strong>规定应用建议的解决方案可能带来的后果。</li></ul><p id="25e3" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">设计模式有几个类别，但有两个主要标准:</p><p id="ad83" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">图案所指:</strong></p><ul class=""><li id="b879" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><strong class="lt jh">对象</strong>:在<br/>执行时可以改变的对象之间的关系。</li><li id="23da" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">类</strong>:关注类和子类之间的关系。</li></ul><p id="9fe0" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><strong class="lt jh">模式的作用(目的):</strong></p><ul class=""><li id="f4c9" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><strong class="lt jh">创建</strong>:关于创建对象的过程。</li><li id="fc03" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">结构</strong>:关注类和对象的组成。</li><li id="2c3a" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">行为</strong>:定义类和对象如何交互，以及<br/>在它们之间分配职责。</li></ul><p id="9b60" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">但是存在多少设计模式呢？在下图中，您将看到一个设计模式列表，该列表根据它们的范围和目的组织在一个表格中。在下面的文章中，我们将介绍最常见的设计模式。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/37ed83549bbdf3068e115ce4fe0b6939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZukZlYEh8XQHTByAchAkw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">设计模式(作者图片)</p></figure><h2 id="4201" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何定义一个设计模式？</h2><p id="e2a8" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">设计模式是由一些描述和促进其使用的基本属性定义的。这些属性是:</p><ul class=""><li id="855a" class="mk ml jg lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><strong class="lt jh">结构</strong>:通过UML图形化表示所涉及的类以及它们之间的关系<br/>。(1) <strong class="lt jh">参与者</strong>:参与模式的班级，他们的关系和责任。(2) <strong class="lt jh">协作</strong>:各个阶层如何协作实现目标。</li><li id="3c4f" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">后果</strong>:使用该模式的优缺点以及使用该模式可能产生的副作用。</li><li id="5ac4" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">实现</strong>:实现<br/>的技术和建议，也参考具体的编程语言。</li><li id="a80e" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">示例源代码</strong>:为实现提供<br/>指南的代码片段。</li><li id="130e" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">已知用途</strong>:在现有系统中使用的例子。</li><li id="4d08" class="mk ml jg lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt jh">相关模式</strong>:与其他模式的区别和最重要的关系。</li></ul><h1 id="6a6d" class="ni kw jg bd kx nj nk nl la nm nn no ld km np kn lh kp nq kq ll ks nr kt lp ns bi translated">抽象工厂</h1><p id="d39f" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在我看来，理解如何定义设计模式的最简单的方法是展示一个例子，让我们从抽象工厂开始。</p><p id="e417" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">我们经常发现自己不得不创造一些相似但彼此不同的新对象。假设我们必须创建几辆汽车，它们都将共享几个属性，例如有四个轮子和一个方向盘，它们还将共享几个功能，例如<em class="nt">加速</em>和<em class="nt">停止(刹车)</em>。<br/>但是如果我们想要创造出有自己特色的汽车，比如<em class="nt">“老爷车”</em>和<em class="nt">“赛车”</em>，这些汽车将会有特定于子类的属性和功能。</p><p id="0325" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这正是设计模式帮助我们的地方，帮助我们轻松、动态地管理这些共享属性和功能但又互不相同的对象的创建。抽象工厂推荐的第一件事是为每个产品显式声明接口(不能被实例化的类)，例如一辆<em class="nt">汽车</em>和一辆<em class="nt">自行车</em>产品。然后你可以让所有的产品变体实现这些接口，这样我们就可以确信它们将共享所有对象共有的属性和功能，比如<em class="nt"> accelerate() </em>和<em class="nt"> stop() </em>。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/919713b176062b4dec28eade1c205a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5A1u9DYlGqp50X8jmymxFg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="438a" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">现在我们定义一个抽象工厂的接口，也就是说，一个类的接口，其功能允许我们创建一个类型为<em class="nt"> Car </em>或<em class="nt"> Bike </em>的新对象。将实际创建类型为<em class="nt"> race </em>或<em class="nt"> vintage </em>的汽车的工厂必须实现该接口的方法。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/da92297bebf02d25cb51042ef2e10706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6h7aWb4lw-HO0flAFi1rDw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="8099" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">这样，每个特定的子产品都有一个工厂，并且在创建每个单独的对象时，不必添加属性和函数。</p><p id="c6bb" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">此外，使用RaceFactory等工厂规格的客户将获得一辆赛车。几个月后，当他去买一辆新自行车时，它也将是一辆赛车，因为它来自同一家工厂，所以他不必担心有不同风格的产品。</p><figure class="ne nf ng nh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/507755bd16540fda8b9f23d7c739b015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r96jfCD-dqp4S-3jAW5xbQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">抽象工厂UML(作者图片)</p></figure><h2 id="0d62" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">让我们编码</h2><p id="b7cf" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">如果到目前为止你仍然不清楚这种设计模式是为了什么以及它是如何工作的，欢迎加入我们的俱乐部！如果你和我一样，编程会让你头脑清醒。</p><p id="9cdc" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">首先，我们创建一个AbstractFactory，在Python中，抽象类是继承ABC的类，如下例所示。这个抽象类有两个方法，一个创建汽车，一个创建自行车。所以任何继承这个抽象类的类都必须以自己的方式实现这两个方法。</p><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="d0cf" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在RaceFactory和VintageFactory，我们都有制造汽车和自行车的方法。您会看到两者都返回类型为Car和Bike的对象(用符号表示:<strong class="lt jh"> <em class="nt"> - &gt; Car </em> </strong>)。<br/>但实际上，Car和Bike是抽象类，实际的类是RaceCar和VintageCar (RaceBik和VintageBike)。通过这种方式，每个工厂将生产与之相关的汽车(或自行车)。<br/>在这种情况下，RaceCar (RaceBike)和VintageCar (VintagBike)唯一不同的是，它打印的是<em class="nt">“快”</em>而不是<em class="nt">“慢”</em>。</p><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="035b" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">现在，客户将选择其中一家工厂(将其作为输入)，然后他将创建一辆汽车和一辆自行车，他将确保汽车和自行车具有相同的风格，它们要么是赛车型，要么是复古型。</p><p id="8328" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated">在创建它们之后，他将使用Car和Bike类提供的方法对它们进行测试。</p><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="3c83" class="ni kw jg bd kx nj nk nl la nm nn no ld km np kn lh kp nq kq ll ks nr kt lp ns bi translated">最后的想法</h1><p id="155f" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">设计模式描述了一个经常重复出现的问题，并根据类/对象组织提出了一种可能的解决方案，这种解决方案通常被认为可以有效地解决问题本身。我们经常面临这样的问题:想要实例化一个对象而不精确地指定类，但是尊重多个对象之间的一致性，为此，学习如何使用抽象工厂是非常有用的。<br/>在未来的文章中，我将阐述机器学习工程师需要了解的其他设计模式，以便能够编写干净的结构化代码。</p><h1 id="fa18" class="ni kw jg bd kx nj nk nl la nm nn no ld km np kn lh kp nq kq ll ks nr kt lp ns bi translated">结束了</h1><p id="e96c" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated"><em class="nt">马赛洛·波利蒂</em></p><p id="da56" class="pw-post-body-paragraph lr ls jg lt b lu mm kh lw lx mn kk lz le na mb mc li nb me mf lm nc mh mi mj ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/marcello-politi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，<a class="ae jd" href="https://twitter.com/_March08_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae jd" href="https://march-08.github.io/digital-cv/" rel="noopener ugc nofollow" target="_blank"> CV </a></p></div></div>    
</body>
</html>