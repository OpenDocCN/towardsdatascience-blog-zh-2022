<html>
<head>
<title>Imputation on the Modern Data Stack</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代数据堆栈上的插补</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/imputation-on-the-modern-data-stack-6c0e37e20e7a#2022-03-03">https://towardsdatascience.com/imputation-on-the-modern-data-stack-6c0e37e20e7a#2022-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="226a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">规模估算</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e2e1acbb214a01dccb0b0ecb9cc8c3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i__5i2gp2gxtT4wK"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="eac3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于大多数机器学习算法不处理空值，缺失值插补是特征工程管道的标准部分。这种插补有多种技术，从非常简单到创建复杂的模型来推断值应该是多少。</p><p id="0aa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最简单的方法是为缺失值估算一个值，最常见的是要素的平均值或中值。对于基于树的方法，输入极值(大于要素的最大值或小于最小值)也是可行的。通常，数据科学家认为这些简单的技术不足以替代丢失的值。在这些情况下，可以创建一个模型，根据该观察的其他特征来估算值。这可以从相对简单的(kNN 模型)到与原始机器学习工作范围相似的复杂模型。虽然这种基于模型的方法可能很有吸引力，但现代机器学习算法的强大功能意味着，输入单个值并创建一个缺失指标也可以轻松完成。在这个博客中，我们将估算平均值，但是对代码的简单修改将允许我们估算其他值。</p><h2 id="d17e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Python 中的插补</h2><p id="a172" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在 Python 中，有两种常用的方法来执行这种插补。首先，这个插补可以用熊猫来做。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="60f3" class="ls lt iq mr b gy mv mw l mx my">df['varname'] = df['varname'].fillna(df['varname'].mean())</span></pre><p id="8c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建缺失的指标，需要首先创建它</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3ed8" class="ls lt iq mr b gy mv mw l mx my">df['varname_mi'] = df['varname'].isna()<br/>df['varname'] = df['varname'].fillna(df['varname'].mean())</span></pre><p id="53f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，这在 Scikit-learn 中作为特性工程管道的一部分来完成。使用<code class="fe mz na nb mr b">train_test_split</code>创建训练和测试分区，可以创建一个<code class="fe mz na nb mr b">SimpleImputer</code>来替换丢失的值。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6f15" class="ls lt iq mr b gy mv mw l mx my">from sklearn.impute import SimpleImputer<br/>from sklearn.model_selection import train_test_split</span><span id="c9d1" class="ls lt iq mr b gy nc mw l mx my">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state=1066)</span><span id="577b" class="ls lt iq mr b gy nc mw l mx my">imp = SimpleImputer(missing_values=np.NaN, strategy='mean')<br/>X_train = imp.fit_transform(X_train)<br/>X_test = imp.transform(X_test)</span></pre><p id="8b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与 pandas 不同，<code class="fe mz na nb mr b">SimpleImputer</code>可以通过改变调用来同时创建一个缺失值指示器，包括将参数<em class="nd"> add_indicator </em>设置为<em class="nd"> True。</em></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c6f4" class="ls lt iq mr b gy mv mw l mx my">imp = SimpleImputer(missing_values=np.NaN, <br/>                    strategy='mean',<br/>                    add_indicator=True)</span></pre><h2 id="eb78" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">挑战</h2><p id="8035" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这两种情况下，这些方法都适用于可在单个工作站上管理的数据集。在数据集包含数百千兆字节或万亿字节数据的问题中，这种方法不再有效。虽然 Dask 之类的包可以让您处理这些大规模数据集，但您仍然需要将数据移动到您的机器或集群中。对于这些大小的数据集，移动数据的时间可能会很长。即使数据大小易于管理，当最终模型投入生产时，这些基于 Python 的方法仍会造成问题，因为这些插补需要在生产代码中重复。当生产环境不是 Python 或者不支持加载 Python 对象时，这可能是一个挑战。</p><h2 id="022a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">利用云数据仓库的力量进行插补</h2><p id="9739" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用 RasgoQL 可以缓解这两个问题。RasgoQL 在数据仓库中执行插补，并允许您保存所有特征工程步骤，以便在预测时可以在仓库中重新运行。</p><p id="d55f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使用 RasgoQL 的转换，首先用<code class="fe mz na nb mr b">RasgoQL</code>连接到系统。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8847" class="ls lt iq mr b gy mv mw l mx my">import rasgoql<br/>creds = rasgoql.SnowflakeCredentials.from_env()<br/>rql = rasgoql.connect(creds)</span></pre><p id="a086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并用<code class="fe mz na nb mr b">rql.dataset(fqtn=&lt;Fully Qualified Table Name&gt;)</code>得到需要对其进行缺失值插补的数据集(数据仓库中的一个表或视图)。所有支持的转换都可以在这里<a class="ae kv" href="https://docs.rasgoql.com/primitives/transform" rel="noopener ugc nofollow" target="_blank">找到</a>或者以编程方式列出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1342" class="ls lt iq mr b gy mv mw l mx my">transforms = rql.list_transforms()<br/><strong class="mr ir">print(transforms)</strong></span></pre><p id="e9b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">若要转换数据，请对数据集调用转换名称。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7cca" class="ls lt iq mr b gy mv mw l mx my">newset = dataset.impute(imputations={'VARIABLE_1': 'mean',<br/>                                     'VARIABLE_2': 'mean'},<br/>                                     flag_missing_vals=False)</span></pre><p id="2bb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，插补转换采用需要插补的字段字典，并允许不同的插补方法:<em class="nd">平均值、中值、众数</em>或单个值。此外，将<em class="nd"> flag_missing_vals </em>设置为<em class="nd"> True </em>将导致为插补字典中的每个字段创建缺失指标特征。</p><h2 id="772c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">转换链接</h2><p id="0521" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">通过将多个调用附加到转换函数上，或者通过在前一个转换的输出上运行一个转换函数，可以将多个转换相互链接起来。这允许您从相对简单的转换构建更复杂的转换，并通过一个 SQL 调用创建最终的数据集。转换链的结果可以被视为一个数据帧，它包含:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5084" class="ls lt iq mr b gy mv mw l mx my">df_transform = newset.preview()<br/>print(df_transform)</span></pre><p id="5f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，<code class="fe mz na nb mr b">preview</code>返回十行。要将整个数据作为数据帧下载，调用<code class="fe mz na nb mr b">to_df</code>。</p><p id="713c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这些转换是在云数据仓库上运行的，所以它运行的是 SQL 代码。转换链的 SQL 语句可以通过运行</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5277" class="ls lt iq mr b gy mv mw l mx my">print(newset.sql())</span></pre><p id="dc93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这段代码创建了转换链，但是它还没有执行，结果保存在仓库中。为了保存它，需要通过调用链上的<code class="fe mz na nb mr b">save</code>来创建一个新表。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f005" class="ls lt iq mr b gy mv mw l mx my">newset.save(table_name='&lt;NEW TABLE NAME&gt;',<br/>            table_type='view')</span></pre><p id="6269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该数据被保存为视图。为了将其保存为表格，请将<strong class="ky ir"> table_type </strong>改为<strong class="ky ir">‘表格’</strong>。</p><p id="c733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，Rasgo 已经针对数据仓库中存储的全部数据运行了缺失值插补，并将结果作为任何 Python 环境中的数据帧返回，并且可以使用标准工具用于建模或可视化。此外，如果这被保存为视图，当新数据被添加到数据仓库中的基础表时，不需要重新运行数据准备阶段，因为估算数据会自动运行并可供下载。</p><p id="26ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种准备是自动运行的，这影响了将数据准备管道投入生产的能力。无需打包 python 代码或将其重写为生产系统中使用的语言，数据会自动在仓库中保持最新，相关数据行可通过已创建的插补提取。</p><p id="8715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，不用浪费几周或几个月的时间重写(或等待软件工程重写)和测试代码的输出，数据立即可用。</p><p id="8b9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，由于这种插补在数据仓库中立即可用，这意味着其他数据科学家和分析师不再需要提取原始数据并准备供自己使用。相反，最终转换后的数据可以直接从仓库中提取，并用于建模、可视化或报告。</p><p id="6c12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了了解这些工具的强大功能，我们创建了一个数据集，其中包括几个关键字段中缺失的数据，并上传到我们的数据仓库。在创建和不创建缺失指标的情况下，对缺失字段的平均值进行估算。最后，为两种情况训练一个<a class="ae kv" href="https://catboost.ai/" rel="noopener ugc nofollow" target="_blank"> CatBoost </a>分类器，并计算对数损失和 AUC。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="27ac" class="ls lt iq mr b gy mv mw l mx my">y = transformed_df[target]<br/>X = transformed_df.drop(columns=[target])<br/>X_train, X_test, y_train, y_test = train_test_split(X, y,     <br/>                                                    test_size=.2,                  <br/>                                                  random_state=1066)</span><span id="c439" class="ls lt iq mr b gy nc mw l mx my">categorical_features = X_train.select_dtypes(exclude=[np.number])</span><span id="2197" class="ls lt iq mr b gy nc mw l mx my">train_pool = Pool(X_train, y_train, categorical_features)<br/>test_pool = Pool(X_test, y_test, categorical_features)</span><span id="b670" class="ls lt iq mr b gy nc mw l mx my">model = CatBoostClassifier(iterations=1000, <br/>                           max_depth=5,<br/>                           learning_rate=0.05,<br/>                           random_seed=1066,<br/>                           logging_level='Silent', <br/>                           loss_function='Logloss')</span><span id="6ce5" class="ls lt iq mr b gy nc mw l mx my">model.fit(X_train, <br/>          y_train, <br/>          eval_set=test_pool, <br/>          cat_features=categorical_features, <br/>          use_best_model=True, <br/>          early_stopping_rounds=50)</span><span id="8aa1" class="ls lt iq mr b gy nc mw l mx my">y_predict = model.predict_proba(X_test)</span><span id="9b08" class="ls lt iq mr b gy nc mw l mx my">logloss = log_loss(y_test, y_predict[:, 1])<br/>auc = roc_auc_score(y_test, y_predict[:, 1])</span><span id="636c" class="ls lt iq mr b gy nc mw l mx my">print(logloss, auc)</span></pre><p id="3384" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给出了最终结果</p><ul class=""><li id="ca15" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">无缺失指标:AUC: 0.6881，对数损失:0.2574</li><li id="dd9e" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">缺失指标:AUC: 0.7045，对数损失 0.2563</li></ul><p id="3f14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，使用 CatBoost，缺少指标的模型比没有指标的模型略胜一筹</p><p id="8e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想查看 RasgoQL，可以在这里找到文档<a class="ae kv" href="https://docs.rasgoql.com/" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到资源库<a class="ae kv" href="https://github.com/rasgointelligence/RasgoQL" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>