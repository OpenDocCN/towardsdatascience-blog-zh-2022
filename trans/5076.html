<html>
<head>
<title>XGBoost: Transfer business knowledge using monotonic constraints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost:使用单调约束传递业务知识</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/xgboost-transfer-business-knowledge-using-monotonic-constraints-35c61cbcb8f9#2022-11-11">https://towardsdatascience.com/xgboost-transfer-business-knowledge-using-monotonic-constraints-35c61cbcb8f9#2022-11-11</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><figure class="gl gn jt ju jv jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi js"><img src="../Images/ae99a578d71d353c4b1d3384b86d56e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xlxfdwluI5zSWk3v"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk">Photo by <a class="ae kh" href="https://unsplash.com/@cdd20?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">愚木混株 cdd20</a> on <a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></p></figure><p id="09d5" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">几天前，我和我的一个好朋友 Julia Simon 讨论在一个基于决策树的模型中考虑商业知识。</p><p id="bedc" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">她想到了一个非常简单的问题，即预测的值随着给定的特征严格地增加。她想知道是否有可能强制模型确保这种约束。</p><p id="9d2e" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">答案是肯定的，而且在很久以前就已经添加到 XGBoost 中了(根据 XGBoost changelogs 的说法是 2017 年 12 月左右)，但它并不是 XGBoost 的一个非常知名的特性:单调约束。</p><p id="7d24" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">让我们看看这是如何实现的，底层的数学是什么，以及它是如何工作的。</p></div><div class="ab cl lg lh hz li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="io ip iq ir is"><blockquote class="ln lo lp"><p id="633d" class="ki kj lq kk b kl km kn ko kp kq kr ks lr ku kv kw ls ky kz la lt lc ld le lf io bi translated">在我的书<a class="ae kh" href="https://amzn.to/3EctIej" rel="noopener ugc nofollow" target="_blank">实用梯度提升</a>中有更多关于决策树的梯度提升:</p></blockquote><div class="lu lv gp gr lw lx"><a href="https://amzn.to/3EctIej" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iw gy z fp mc fr fs md fu fw iu bi translated">实用的渐变增强:深入探究 Python 中的渐变增强</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">这本书的梯度推进方法是为学生，学者，工程师和数据科学家谁希望…</h3></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kb lx"/></div></div></a></div></div><div class="ab cl lg lh hz li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="io ip iq ir is"><h1 id="45d9" class="ml mm iv bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">单调约束</h1><p id="4a4e" class="pw-post-body-paragraph ki kj iv kk b kl nj kn ko kp nk kr ks kt nl kv kw kx nm kz la lb nn ld le lf io bi translated">先来定义一下<code class="fe no np nq nr b">monotonic constraint</code>。首先，在数学中，<code class="fe no np nq nr b">monotonic</code>是一个适用于函数的术语，意思是当那个函数的输入增加时，函数的输出或者严格地增加或者减少。</p><p id="4c13" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">例如，函数 x 是严格单调的:</p><figure class="nt nu nv nw gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ns"><img src="../Images/498d438e6d7c18ae00fbde41486f0961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7SyJtyLGbRf_xAWg50M1w.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">x 是严格单调的。作者的锅。</p></figure><p id="54ed" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">相反，x 函数不是单调的，至少在其整个域 R:</p><figure class="nt nu nv nw gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ns"><img src="../Images/47056343e1dd2ae47a044e0b60cd0c51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uepxcZRw4VRs5z9AZ5J_7w.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">x 在 R. Plot 上不是单调的。</p></figure><p id="4068" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">限于 R+，x 是单调的，同样代表 R-。</p><p id="eb1a" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">从数学上讲，说 f 是<code class="fe no np nq nr b">monotonic</code>意味着</p><p id="40f9" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">f(x1)&gt; f(x2)如果 x1 &gt; x2 在单调递增的情况下。</p><p id="660e" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">或者</p><p id="7763" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">f(x_1) &lt; f(x_2)如果 x_1 &lt; x_2 在单调递减的情况下。</p><h1 id="8707" class="ml mm iv bd mn mo nx mq mr ms ny mu mv mw nz my mz na oa nc nd ne ob ng nh ni bi translated">为什么需要单调约束？</h1><p id="c3c2" class="pw-post-body-paragraph ki kj iv kk b kl nj kn ko kp nk kr ks kt nl kv kw kx nm kz la lb nn ld le lf io bi translated">在许多情况下，数据科学家预先知道要预测的值和某些特征之间的关系。例如，瓶装水的销售水平与温度成正比，因此在预测瓶装水销售的模型中实施这种约束可能会很有趣。</p><p id="f47d" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">使用<code class="fe no np nq nr b">monotonic</code>约束是向 XGBoost 模型添加这种约束的简单方法。</p><p id="8daa" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">让我们看一个简单的例子。假设我们正在尝试对以下等式建模，其中预测<code class="fe no np nq nr b">y</code>的值取决于<code class="fe no np nq nr b">x</code>，如下所示:</p><p id="1fd8" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">y = 3*x。</p><p id="94be" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这是一个非常简单的关系，其中<code class="fe no np nq nr b">y</code>与<code class="fe no np nq nr b">x</code>严格成正比。然而，在现实生活中收集数据时，会引入噪声，这会导致数据点在局部不符合该关系。在这些情况下，有必要确保模型是<code class="fe no np nq nr b">monotonic</code>，理论公式也是如此。</p><p id="6691" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">下面的代码显示了如何使用 XGBoost 和<code class="fe no np nq nr b">monotonic</code>约束:</p><h1 id="6a71" class="ml mm iv bd mn mo nx mq mr ms ny mu mv mw nz my mz na oa nc nd ne ob ng nh ni bi translated">XGBoost 中的<code class="fe no np nq nr b">monotonic</code>约束是如何实现的？</h1><p id="b7ae" class="pw-post-body-paragraph ki kj iv kk b kl nj kn ko kp nk kr ks kt nl kv kw kx nm kz la lb nn ld le lf io bi translated">我在以前的文章中展示了如何从头开始实现决策树的梯度推进:</p><div class="lu lv gp gr lw lx"><a rel="noopener follow" target="_blank" href="/diy-xgboost-library-in-less-than-200-lines-of-python-69b6bf25e7d9"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iw gy z fp mc fr fs md fu fw iu bi translated">用不到 200 行 python 代码 DIY XGBoost 库</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">XGBoost 解释了梯度推进方法和惠普调整，通过建立自己的梯度推进库…</h3></div><div class="oc l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mf l"><div class="od l mh mi mj mf mk kb lx"/></div></div></a></div><p id="63cd" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这段代码可以很容易地修改成集成<code class="fe no np nq nr b">monotonic</code>约束。处理代码中的约束通常需要开发一个求解器，而且通常是相当复杂的代码。各种方法都是可能的。在本文中，您可以看到如何使用基于几何的迭代方法来实现这样的求解器:</p><div class="lu lv gp gr lw lx"><a rel="noopener follow" target="_blank" href="/building-an-iterative-solver-for-linear-optimization-under-constraints-using-geometry-d8df2a18b37e"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iw gy z fp mc fr fs md fu fw iu bi translated">使用几何构建约束条件下线性优化的迭代求解器</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">通过使用几何图形构建自己的迭代求解器，了解线性优化的工作原理。</h3></div><div class="oc l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">towardsdatascience.com</p></div></div><div class="mf l"><div class="oe l mh mi mj mf mk kb lx"/></div></div></a></div><p id="f141" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">然而，在梯度提升应用于决策树的情况下，<code class="fe no np nq nr b">monotonic</code>约束可以很容易地实现。这种实现的简单性来自于使用<strong class="kk iw">二进制</strong>决策树作为底层模型。</p><p id="e436" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">实际上，每个节点处理的决策是一个值和一个阈值之间的比较。因此，加强单调性只需要在决策节点级别考虑这种单调性。</p><p id="989c" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">例如，如果右节点包含列<code class="fe no np nq nr b">A</code>小于阈值<code class="fe no np nq nr b">T</code>的行，则右节点的增益必须小于左节点的增益。</p><h2 id="1d15" class="of mm iv bd mn og oh dn mr oi oj dp mv kt ok ol mz kx om on nd lb oo op nh oq bi translated">XGBoost 如何处理单调约束？</h2><p id="cbfd" class="pw-post-body-paragraph ki kj iv kk b kl nj kn ko kp nk kr ks kt nl kv kw kx nm kz la lb nn ld le lf io bi translated">为了了解我们如何实现这种约束，让我们看看 XGBoost 是如何在其 C++代码中实现的:</p><figure class="nt nu nv nw gt jw"><div class="bz fp l di"><div class="or os l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">从 XGBoost 代码中提取。</p></figure><p id="1f26" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">代码实际上非常简单。它只是确保单调性在增益级别得到尊重。如果不是这样，代码就人为地将增益设置为<code class="fe no np nq nr b">negative_infinity</code>，以确保这种分裂不会被保持。</p><p id="9433" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">因此，不能确保单调性的决策节点被丢弃。</p><h1 id="f194" class="ml mm iv bd mn mo nx mq mr ms ny mu mv mw nz my mz na oa nc nd ne ob ng nh ni bi translated">单调约束的应用及效果</h1><p id="02fd" class="pw-post-body-paragraph ki kj iv kk b kl nj kn ko kp nk kr ks kt nl kv kw kx nm kz la lb nn ld le lf io bi translated">下面的代码片段显示了如何向 XGBoost 模型添加<code class="fe no np nq nr b">monotonic</code>约束:</p><figure class="nt nu nv nw gt jw"><div class="bz fp l di"><div class="or os l"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">用单调约束训练 XGBoost 模型。作者代码</p></figure><p id="18cd" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在这个教育示例中，两个 XGBoost 模型被训练来学习一个简单的理论模型，其中<code class="fe no np nq nr b">y = 6.66 x</code>。添加了一些严格的负面噪声，以确保训练数据不是<code class="fe no np nq nr b">monotone</code>，即有时是<code class="fe no np nq nr b">y_j &lt; y_i</code>，即使是<code class="fe no np nq nr b">x_i &lt; x_j</code>。</p><p id="2392" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">第一个模型在没有任何约束的情况下被训练，而第二个模型添加了一个<code class="fe no np nq nr b">monotonic</code>约束。</p><p id="96e1" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">注意，这是通过定义参数<code class="fe no np nq nr b">monotone_constraint</code>来实现的。此参数是一个元组，必须包含与模型中的特征一样多的项目。</p><p id="c7fe" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">当与特征<code class="fe no np nq nr b">f_i</code>相关联的项目<code class="fe no np nq nr b">c_i</code>为 0 时，不应用约束。当<code class="fe no np nq nr b">c_i = 1</code>时，执行<em class="lq">增加</em>的单调约束，而当<code class="fe no np nq nr b">c_i = -1</code>时，执行<em class="lq">减少</em>的单调约束。</p><p id="1aca" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">结果预测显示在该图中:</p><figure class="nt nu nv nw gt jw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/71a1842142f56ecdc3c1d7957b92a6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*xJ5QaoW2Zk0yOAiqQwDRWg.png"/></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">原始数据、无约束和有约束的预测。作者的情节。</p></figure><p id="2534" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">放大图可以更好地显示约束的效果:</p><figure class="nt nu nv nw gt jw gh gi paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="gh gi ou"><img src="../Images/51af70552d01ef90f53d59cd48e24db6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4t4DlUNxqB8fUYpbGZNiw.png"/></div></div><p class="kd ke gj gh gi kf kg bd b be z dk translated">绿色表示的受约束预测值正在严格增加。作者的情节。</p></figure><p id="9d7d" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">它清楚地表明，没有约束的模型不能确保单调性，因为预测并不总是增加的。相反，约束模型只生成增加的预测。</p></div><div class="ab cl lg lh hz li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="io ip iq ir is"><h1 id="e5d5" class="ml mm iv bd mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni bi translated">结论</h1><p id="bbdb" class="pw-post-body-paragraph ki kj iv kk b kl nj kn ko kp nk kr ks kt nl kv kw kx nm kz la lb nn ld le lf io bi translated">单调约束是将业务知识转移到模型的一种简单方法。这是一个非常简单而有效的方法来引导模型走向相关的模型化。</p><p id="6736" class="pw-post-body-paragraph ki kj iv kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果你想了解更多关于梯度增强及其应用的知识，我写了一本关于这个主题的书，<a class="ae kh" href="https://amzn.to/3XjRk9N" rel="noopener ugc nofollow" target="_blank">实用梯度增强</a>，它详细介绍了数学基础，并提供了实用信息来充分利用 XGBoost、LightGBM 和 CatBoost:</p><div class="lu lv gp gr lw lx"><a href="https://amzn.to/3EctIej" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd iw gy z fp mc fr fs md fu fw iu bi translated">实用的渐变增强:深入探究 Python 中的渐变增强</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">这本书的梯度推进方法是为学生，学者，工程师和数据科学家谁希望…</h3></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kb lx"/></div></div></a></div></div></div>    
</body>
</html>