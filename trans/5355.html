<html>
<head>
<title>Ace your Machine Learning Interview — Part 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">赢得机器学习面试——第八部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ace-your-machine-learning-interview-part-8-a9b94b8ed468#2022-11-30">https://towardsdatascience.com/ace-your-machine-learning-interview-part-8-a9b94b8ed468#2022-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/114632f470cbae6e501528740eedcd43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9IAz-sUAfJ59wBLP"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="https://unsplash.com/@cowomen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">女同胞</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><div class=""/><div class=""><h2 id="8fcd" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">使用 Python 从头开始使用 AdaBoost 进行集成学习</h2></div><p id="2471" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的系列文章“Ace your Machine Learning Interview”中，我继续谈论集成学习，特别是，我将重点关注 Boosting 算法，并特别提到<strong class="kx jh"> AdaBoost </strong>。我希望我回顾机器学习基础知识的这一系列对你面对下一次面试有用！😁</p><p id="e47a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您对本系列之前的文章感兴趣，我在这里留下了链接:</p><ol class=""><li id="880d" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/ace-your-machine-learning-interview-part-1-e6a5897e6844"> <em class="ma"> Ace your Machine Learning 面试—第一部分</em> </a> <em class="ma">:深入线性、套索和岭回归及其假设</em></li><li id="6112" class="lr ls jg kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/ace-your-machine-learning-interview-part-1-e6a5897e6844"><em class="ma">Ace your Machine Learning 访谈—第二部分</em> </a> <em class="ma"> 2:使用 Python 深入研究分类问题的逻辑回归</em></li><li id="1145" class="lr ls jg kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/ace-your-machine-learning-interview-part-1-e6a5897e6844"><em class="ma">Ace your Machine Learning 面试—部分</em> </a> <em class="ma"> 3:使用 Python 深入研究朴素贝叶斯分类器</em></li><li id="6b59" class="lr ls jg kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae jd" href="https://medium.com/p/e30b695ce63/edit" rel="noopener"><em class="ma">Ace your Machine Learning 访谈—第四部分</em> </a> <em class="ma">:深入研究使用 Python 的支持向量机</em></li><li id="ad71" class="lr ls jg kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae jd" href="https://medium.com/p/e30b695ce63/edit" rel="noopener"><em class="ma">Ace your Machine Learning 访谈—第五部分</em> </a> <em class="ma"> 5:使用 Python 深入研究内核支持向量机</em></li><li id="8a52" class="lr ls jg kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae jd" href="https://medium.com/p/5f0d84e435a1/edit" rel="noopener"><em class="ma">Ace your Machine Learning 面试—第六部分</em> </a> <em class="ma">:使用 Python 深入决策树</em></li><li id="0edb" class="lr ls jg kx b ky mb lb mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae jd" href="https://medium.com/p/2688de34805f/edit" rel="noopener"><em class="ma">Ace your Machine Learning 面试—第七部分</em> </a> <em class="ma">:使用 Python </em>研究硬投票分类器的集成学习</li></ol><h2 id="44a6" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">介绍</h2><p id="8c57" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">我们在上一篇文章中讨论了什么是集成学习，我们已经看到并实现了基于多数投票的简单集成方法。</p><p id="8874" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们通过特别参考<strong class="kx jh">自适应增强或 AdaBoost </strong>来更详细地讨论一种称为 Boosting 的集成方法。你可能以前听说过这种算法，例如，它经常被用来赢得 Kaggle 比赛。</p><p id="fa85" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">AdaBoost 的基本思想最早是在罗伯特·e·沙皮雷的论文<a class="ae jd" href="http://rob.schapire.net/papers/strengthofweak.pdf" rel="noopener ugc nofollow" target="_blank"><em class="ma"/></a>中陈述的。</p><p id="6000" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个想法是以一种组合的方式使用各种 ML 算法，这些算法被称为弱学习器，因为它们本身不是很好，它们只能比随机猜测好一点。通过依次使用这些弱学习器，可以获得非常强的结果。</p><h2 id="3bec" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">最初的 AdaBoost 想法</h2><p id="d254" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">按照最初的设想，<strong class="kx jh">增强最初是基于我们已经看到的叫做粘贴</strong>的技术。</p><p id="212a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，实现了几个弱学习器，并且每个弱学习器在训练集数据的子集上被训练，而没有替换。我们将称为<strong class="kx jh"> <em class="ma"> wl_1、wl_2、…、wl_n </em>的弱学习器被顺序训练</strong>，并且每个<em class="ma"> wl_i+1 </em>在训练集的随机子集上被训练，来自<em class="ma"> wl_i </em>的 50%的错误分类数据点被添加到该训练集中。通过这种方式，错误分类的数据点被赋予了更大的权重。</p><p id="d472" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，他们会将所有落后的弱学习者合并成一个多数投票函数。</p><h2 id="f6ab" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">adaboost 算法</h2><p id="7a0a" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">基本思想保持不变，但现在 AdaBoost 算法略有不同。首先，<strong class="kx jh">不再使用粘贴，而是在整个可用的训练集</strong>上训练每个弱学习者。此外，使用另一种机制来给予被先前的弱学习者错误分类的点更多的重要性。弱学习者<strong class="kx jh"> <em class="ma"> wl_i+1 </em>将简单地给<em class="ma"> wl_i </em>的错误分类的点更多的权重，给良好分类的点</strong>更少的权重。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/dd691ebc47f107905b1d65e4810e2281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKGukC0CWLK2M49yxzsMkQ.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">加权误分类数据点(图片由作者提供)</p></figure><p id="4b2d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在实现这个算法之前，让我们看一下伪代码来了解一下。</p><figure class="nf ng nh ni gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/976589ae979f76d80171fd7768b7580f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0x-VnZcMsCEALVR41K_3Xg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">伪代码 Adaboost(图片由作者提供)</p></figure><h2 id="2f61" class="mg mh jg bd mi mj mk dn ml mm mn dp mo le mp mq mr li ms mt mu lm mv mw mx my bi translated">我们来编码吧！</h2><p id="8cf6" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">所以首先我们初始化两个数组<em class="ma"> y </em>和<em class="ma"> y_hat </em>，它们将是+1 和-1 的二进制向量。这些将代表真实的类和预测的类。之后，我们创建一个布尔列表，每个条目告诉我们预测是否正确。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="58c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们初始化权重。首先，每个数据点的权重是相同的，因为我们有 10 个数据点，每个数据点的权重是 0.1。</p><p id="3283" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这些初始权重和预测，我们继续计算误差和系数α，我们将需要计算伪代码中所示的新更新的权重。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7c38" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们准备计算新的权重，然后对它们进行归一化。注意，根据预测是正确还是不正确，我们有两个不同的公式来更新权重。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="65ec" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们在第二步中有了新的权重。你可以选择做 m 步，把所有的东西放在一个 for 循环中。</p><p id="a358" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">幸运的是，各种库已经有了更有效的实现。所以<strong class="kx jh">让我们看看如何使用 sklearn 来使用 AdaBoost！</strong></p><p id="ba32" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下虹膜数据集由 sklearn 在开放许可下提供，可以在<a class="ae jd" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_iris.html#" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1512" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们导入数据，并将其分为训练集和测试集。注意:为简单起见，我们将在该数据集中仅使用两个要素。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b79a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在只需几行代码，我们就可以创建一个基于 500 个简单决策树的 AdaBoost，每个决策树都有<em class="ma"> max_depth = 1 </em>。我们看到我们得到了比仅仅使用决策树更好的结果。</p><figure class="nf ng nh ni gt is"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b259" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！通过几个简单的步骤，您可以创建 AdaBoost 算法并获得您的预测。</p><h1 id="c787" class="nm mh jg bd mi nn no np ml nq nr ns mo km nt kn mr kp nu kq mu ks nv kt mx nw bi translated">最后的想法</h1><p id="0d77" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated">所以在关于集成学习的第二篇论文中，我们看到了一种叫做 AdaBoost 的新算法。所谓的弱学习者是按顺序训练的，这被认为是不好的，因为这种顺序训练会浪费我们很多时间。然后，我们将能够<strong class="kx jh">通过关注未满足的情况</strong>，使每个预测器纠正其前任。<strong class="kx jh">所以新的预测器更关注疑难病例。对于新的预测因子，我们增加了疑难病例的权重。</strong></p><p id="968c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关注我的“Ace you 机器学习面试”系列新文章！😁</p><h1 id="89df" class="nm mh jg bd mi nn no np ml nq nr ns mo km nt kn mr kp nu kq mu ks nv kt mx nw bi translated">结束了</h1><p id="39cd" class="pw-post-body-paragraph kv kw jg kx b ky mz kh la lb na kk ld le nb lg lh li nc lk ll lm nd lo lp lq ij bi translated"><em class="ma">马赛洛·波利蒂</em></p><p id="5dca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/marcello-politi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，<a class="ae jd" href="https://twitter.com/_March08_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae jd" href="https://march-08.github.io/digital-cv/" rel="noopener ugc nofollow" target="_blank"> CV </a></p></div></div>    
</body>
</html>