<html>
<head>
<title>How to organize and track your PyTorch training by creating a run manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过创建跑步管理器来组织和跟踪您的PyTorch培训</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-organize-and-track-your-pytorch-training-by-creating-a-run-manager-878cc830ea90#2022-10-04">https://towardsdatascience.com/how-to-organize-and-track-your-pytorch-training-by-creating-a-run-manager-878cc830ea90#2022-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="04c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果您正在寻找一种方法来组织、管理和记录培训过程中的步骤和操作，并且不想使用PyTorch Lightning，请不要再找了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b54f702a04e0e466cd24f0471f5501a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CfuPm_J-myA3BNwn"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Marcel strau在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将按照培训设置的经典层次结构，将培训经理的逻辑分为几个阶段:</p><ul class=""><li id="1013" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">最高级的阶段是<strong class="lb iu">训练运行</strong>，它涵盖了一组超参数(时期数、模型配置、学习率、优化器等)的整个训练。)</li><li id="ab51" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">接下来，我们有<strong class="lb iu">时期</strong>，这个阶段代表整个数据集通过我们的模型的一次通过</li><li id="e17c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">对于每个时期，我们有两个步骤:训练步骤<strong class="lb iu">和验证步骤</strong>。在训练步骤中，我们通过前向和后向传递执行实际学习，在验证中，我们计算保留样本的选择指标。</li></ul><p id="2a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为<strong class="lb iu">的额外收获</strong>，我还将向您展示一种从可用值列表中生成每个运行参数集的方法(<em class="mj">提示:笛卡尔乘积</em>)。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="7335" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">培训过程</h2><p id="7d9e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">首先，让我们定义一个已经使用管理器的培训流程，这样我们就有了一个应该如何使用它的示例，这将有助于我们稍后定义实际功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="bd96" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">运行管理器</h2><p id="7886" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">接下来，让我们考虑我们希望我们的管理器收集和记录什么信息，以便我们对运行管理器的样子有一个概念:</p><ul class=""><li id="5260" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们想知道当前的纪元和运行</li><li id="577f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每个时期的平均损失</li><li id="8093" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">每个时期的精确度(我们可以使用其他指标:F1、精确度、召回率、MSE、MAE等。)</li><li id="beb2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">纪元和运行花了多长时间</li><li id="6dbd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">把所有事情都记录到tensorboard上也不错</li></ul><p id="871a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于损失和精度，我们想把它们分开成训练和验证，这样可以更好的了解模型的真实表现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="85fa" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">运行和新纪元的开始</h2><p id="e726" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">正如我在本文开始时提到的，我们有两个主要循环，外部循环通过创建定义特定运行的集合来遍历所有超参数的组合(我们将立即看到如何生成它们)，内部循环遍历多个时期(也是一个潜在的超参数)，这是学习发生的部分。</p><p id="5db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要在新的运行和新的时期开始时通知运行管理器，以便相应地对数据进行分组，并重置基于状态的变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="305e" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated"><em class="nr">奖金</em></h2><p id="aa10" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在机器学习模型的训练过程中，一些参数是不可微的，并且在更高的水平上定义学习过程。我们称之为<em class="mj">超参数。</em></p><p id="e49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，没有办法确定它们的最佳价值，所以我们只能全部尝试(<strong class="lb iu">免责声明</strong>:有一些方法可以改进搜索，但这超出了本文的范围)。</p><p id="7b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们的任务是从我们为超参数提出的值中生成所有可能的组合，这些组合定义了每次运行。为此，我们将使用python的内置<strong class="lb iu"> itertools </strong>包中的<strong class="lb iu">产品</strong>函数:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="b9ad" class="mr ms it nt b gy nx ny l nz oa">from <strong class="nt iu">itertools </strong>import <strong class="nt iu">product</strong></span><span id="d1f5" class="mr ms it nt b gy ob ny l nz oa">h_params = {<br/>    "<strong class="nt iu">lr</strong>": [0.001, 0.0001],<br/>    "<strong class="nt iu">num_epochs</strong>": [10, 50]<br/>}</span><span id="207c" class="mr ms it nt b gy ob ny l nz oa"><strong class="nt iu">runs</strong> = []<br/>for <strong class="nt iu">run</strong> in <strong class="nt iu">product</strong>(*h_params.values()):<br/>    <strong class="nt iu">runs</strong>.append(<strong class="nt iu">run</strong>)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="4c66" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">纪元和运行结束</h2><p id="6782" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">接下来，我们将在一个步骤中涵盖几个阶段，所有阶段都是相互关联的，这样会更有意义。</p><p id="70e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面我们已经看到了表示一个运行和一个时期开始的方法。在每个时期，我们必须迭代整个数据集，由于与计算和收敛优化相关的各种原因，我们分批进行(<strong class="lb iu">小批量随机梯度下降</strong>)。因此，我们必须将与此步骤相关的一些信息记录到我们的运行管理器中，这将帮助我们计算整个时期的总损失和准确性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="fe03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦纪元结束，我们必须计算上述指标，将它们保存到本地集合并记录到Tensorboard。我们将有两个子步骤，分别用于培训和验证:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="b578" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">最后</h2><p id="67f5" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">一旦一切完成，您将有很好的tensorboard图来分析模型的性能和每个时期的记录历史，您可以将它们打包到pandas数据帧中或作为CSV或JSON保存到磁盘。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="1342" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">结论</h2><p id="636e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这里给出的训练过程是非常普通的，但是，它表明通过使用RunManager类型的模块，您可以有一个更清晰和更容易理解的代码。</p><p id="2931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在文章开头提到的，你应该检查Pytorch闪电。</p><p id="c41e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，我希望您会发现这篇文章很有帮助，如果您想了解最新的编程和机器学习新闻以及一些优质的模因:)，您可以在Twitter <a class="ae ky" href="https://twitter.com/SurdoiuT" rel="noopener ugc nofollow" target="_blank">这里</a>关注我，或者在LinkedIn <a class="ae ky" href="https://www.linkedin.com/in/tudor-marian-surdoiu/" rel="noopener ugc nofollow" target="_blank">这里</a>联系我。</p><h2 id="f105" class="mr ms it bd mt mu mv dn mw mx my dp mz li na nb nc lm nd ne nf lq ng nh ni nj bi translated">参考</h2><ul class=""><li id="95eb" class="lv lw it lb b lc nk lf nl li oc lm od lq oe lu ma mb mc md bi translated"><a class="ae ky" href="https://www.youtube.com/c/deeplizard" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/c/deeplizard</a></li><li id="ff96" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://pytorch.org/docs/stable/tensorboard.html" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/docs/stable/tensorboard.html</a></li></ul></div></div>    
</body>
</html>