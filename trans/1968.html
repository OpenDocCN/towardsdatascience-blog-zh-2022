<html>
<head>
<title>How to Create Reusable R Containers for SageMaker Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为SageMaker作业创建可重用的R容器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-reusable-r-containers-for-sagemaker-jobs-a3d481daf5cd#2022-05-04">https://towardsdatascience.com/how-to-create-reusable-r-containers-for-sagemaker-jobs-a3d481daf5cd#2022-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1d4c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为R开发人员在SageMaker上创建可重用容器的指南</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c483d12c2b74d59db4ea0aecdf1280e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kO4WWWdnGgqpchOynAa5g.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">图片来源于unsplash.com</p></figure><p id="314d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SageMaker非常棒，它给了您充分的灵活性，让您可以使用自己的运行时和语言来使用它的服务。如果没有可用的运行时或语言适合您的代码，您首先需要克服最初的障碍，创建一个兼容的docker容器(T2)，SageMaker可以使用。</p><p id="365a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博客中，我们深入探讨了如何在SageMaker中创建这样的<em class="ls"> R-containers </em>，并试图更深入地理解SageMaker的工作方式<em class="ls">。这使我们在容器构建阶段做出的一些决策更加清晰。要获得利用这些R容器的ML管道的端到端示例，请查看这个<a class="ae lt" href="https://github.com/aws-samples/rstudio-on-sagemaker-workshop/tree/main/03_SageMakerPipelinesAndDeploy" rel="noopener ugc nofollow" target="_blank"> GitHub </a>示例。</em></p><h1 id="cf37" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">码头集装箱简而言之</h1><p id="621a" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">您可能已经阅读了这篇文章，但是不知道docker容器是什么。我不会试图解释docker或containers是什么，因为已经有大约一百万篇这样的文章写得比我更好。</p><p id="19f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，容器是一个标准的软件单元，它将代码及其所有依赖项打包在一个“对象”中，可以跨不同的系统安全可靠地执行。</p><p id="737d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个博客，你需要广泛地熟悉一些概念，即什么是docker文件、图像、容器注册表和容器。如果你对容器很好奇，想了解更多，可以从这里<a class="ae lt" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">开始了解更多。</a></p><h1 id="28a7" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">为什么是容器+ SageMaker？</h1><p id="b7e7" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">SageMaker是以模块化的方式构建的，允许我们使用自己的容器来提供服务。这给了我们使用我们选择的库、编程语言和/或运行时的灵活性，同时仍然利用使用其服务的全部好处。</p><h1 id="4efa" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">用于SageMaker处理的r容器</h1><p id="2627" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">为处理作业创建一个R容器可能是我们在SageMaker上可能需要的所有容器中最简单的。<br/>docker文件可以如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="099d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当容器被创建并注册到<a class="ae lt" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> ECR，Amazon Elastic Container Registry</a>时，我们可以运行一个处理作业。这类似于我们通常运行处理作业的方式，我们只需将参数<em class="ls"> image_uri </em>即新创建的图像的uri传递给作业。这种处理作业运行的例子(也作为流水线的一部分)可以在<a class="ae lt" href="https://github.com/aws-samples/rstudio-on-sagemaker-workshop/blob/main/03_SageMakerPipelinesAndDeploy/pipeline.R#L33" rel="noopener ugc nofollow" target="_blank">流水线的第33行中找到。上面分享的例子中的R </a>。当处理作业运行时，SageMaker使用以下命令运行容器:</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="34d0" class="my lv iq mu b gy mz na l nb nc">docker run [AppSpecification.ImageUri]</span></pre><p id="49a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，将运行入口点命令，并且将运行传递到<em class="ls"> ScriptProcessor </em>的<em class="ls">代码</em>参数中的脚本。在这种情况下，我们的入口点是命令<em class="ls"> Rscript </em>，因此这个容器可以被所有需要执行任意代码的处理作业重用，当然假设必要的包依赖关系对它可用。</p><p id="0575" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进一步的定制是可能的，如果你有兴趣更深入地了解SageMaker容器是如何具体处理作业的，请随意阅读相关文档页面。</p><h1 id="6736" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">用于SageMaker培训和部署的容器</h1><p id="83f3" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">与上面这个简单明了的例子相比，为训练作业创建一个R容器(也可以在部署模型时重用)需要更多的步骤。</p><p id="8a24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模板Dockerfile文件可以如下所示:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="555b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到，一旦我们安装了模型/代码所需的必要包，我们还复制了一个run.sh和一个entrypoint。r文件。让我们看看这些文件是什么，为什么需要它们。</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="f7db" class="my lv iq mu b gy mz na l nb nc">#!/bin/bash<br/>echo "ready to execute"<br/>Rscript /opt/ml/entrypoint.R $1</span></pre><p id="b59e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">run.sh脚本非常简单，它所做的只是运行<em class="ls">入口点。R </em>脚本在$1下传递命令行参数。我们这样做是因为SageMaker使用以下命令运行docker容器进行培训和服务:</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="3aaf" class="my lv iq mu b gy mz na l nb nc">docker run image train</span></pre><p id="d219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="8994" class="my lv iq mu b gy mz na l nb nc">docker run image serve</span></pre><p id="598b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这取决于我们称之为培训还是部署方法。基于参数$1，即“train”或“serve ”,我们想区分下一步。这里需要bash脚本将这个参数传递给Rscript执行，因为没有直接的方法从R代码中读取docker run参数。如果你知道更好/更简单的方法，请在评论中告诉我！</p><p id="2d60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看入口点。r脚本:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9315" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这现在变得更加SageMaker具体的方式，让我们打开它！SageMaker有一个定义非常好的文件结构，它保存文件并期望在/opt/ml/下找到文件。具体来说，我们在这里使用的是:</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="433c" class="my lv iq mu b gy mz na l nb nc">/opt/ml/<br/>    - input/config/hyperparameters.json<br/>    - code/<br/>    - model/<br/>        - &lt;model artifacts&gt;<br/>        - code/</span></pre><p id="1c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> hyperparameters.json </em>文件<br/>当创建一个训练评估器时，我们将希望传入一些自定义代码来定义和训练我们的模型。通过之后，SageMaker会将这些文件(可能是您需要通过培训的文件的整个目录)压缩到一个名为“<em class="ls">source dir . tar . gz”</em>的文件中，并将它上传到S3的一个位置。一旦我们开始一个训练作业，SageMaker将在/opt/ml/input/config/位置创建hyperparameters.json文件，该文件包含任何传递的hyper参数，但也包含关键字"<em class="ls">sage maker _ submit _ directory "</em>，其值为"<em class="ls"> sourcedir.tar.gz" </em>文件上载到的S3位置。<br/>在训练模式下，我们需要下载并解压缩我们的训练代码。这正是上面if语句的第一部分所做的。</p><p id="d7ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">代码</em>目录<br/>遵循SageMaker如何在内置算法和托管框架容器上下载和解包训练代码的约定，我们正在提取/opt/ml/code/目录中的训练代码。然而，这不是一个要求，而是遵循服务标准的一个好的实践。</p><p id="e249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">模型</em>目录<br/>这是SageMaker自动下载模型工件和与推理相关的代码的目录。<br/>上面代码片段中if语句的第二部分利用了这一点，来获取<em class="ls"> deploy。R </em>脚本。这里需要注意的是，这个Dockerfile &amp;代码示例假设我们的推理代码将包含一个<em class="ls">部署。R </em>文件，该文件将为部署而运行。如果您遵循不同的命名习惯，请随意重命名该文件。<br/>在这个代码示例中，在训练过程中，一旦创建了模型，模型的工件就保存在/opt/ml/model文件夹下。我们还将推理代码保存在同一目录下的子文件夹code/中。这样，当SageMaker压缩文件以创建model.tar.gz文件时，这个文件也将包含部署代码所必需的内容。</p><p id="a569" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上是一个架构/设计决策，用来将推理代码与模型本身捆绑在一起。对于您的用例来说，想要分离这两者并保持推理代码独立于模型工件是完全合理的。这当然是可能的，由你来决定采用哪种方法。</p><p id="59cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还请注意，模型工件保存在S3上的一个单独的<em class="ls">model.tar.gz</em>文件中，然而，在部署期间，SageMaker会自动下载并解压缩这个文件，所以我们不必在部署期间自己手动这么做。</p><p id="6d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Pro提示:您可能希望有不同的容器用于训练和部署，在这种情况下，可以简化上述步骤，跳过run.sh脚本的使用。</em></p><p id="ef7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进一步的定制是可能的，如果你有兴趣深入了解SageMaker容器如何专门用于训练和推理工作，请随意阅读<a class="ae lt" href="https://docs.aws.amazon.com/sagemaker/latest/dg/docker-containers-create.html" rel="noopener ugc nofollow" target="_blank">相关文档页面</a>。</p><h1 id="d607" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">建造集装箱</h1><p id="03c9" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">如果你熟悉构建容器，你会意识到下面的过程没有什么本质上的特别。我们所需要做的就是根据提供的docker文件构建容器，并向ECR注册图像，SageMaker作业将在运行时提取图像。如果你已经知道如何建立和注册一个图像到ECR，请随意跳过这篇文章的这个部分。</p><p id="7a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于SageMaker上RStudio的用户或者任何不能或不愿意让docker守护进程在他们的开发环境上运行的人，我建议将容器的实际构建外包给另一个AWS服务，即<a class="ae lt" href="https://aws.amazon.com/codebuild/" rel="noopener ugc nofollow" target="_blank"> AWS CodeBuild </a>。幸运的是，我们不需要主动与该服务交互，这要感谢有用的实用程序<a class="ae lt" href="https://github.com/aws-samples/sagemaker-studio-image-build-cli" rel="noopener ugc nofollow" target="_blank"> SageMaker Docker Build </a>，它对我们隐藏了所有这些复杂性。<br/>使用如下命令安装该实用程序:</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="fcbc" class="my lv iq mu b gy mz na l nb nc">py_install("sagemaker-studio-image-build", pip=TRUE)</span></pre><p id="5257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们准备好了。构建容器只需要一个命令:</p><pre class="kh ki kj kk gt mt mu mv mw aw mx bi"><span id="b8e8" class="my lv iq mu b gy mz na l nb nc">sm-docker build . --file {Dockerfile-Name} --repository {ECR-Repository-Name:Optional-Tag}</span></pre><h1 id="3b50" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="c130" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">SageMaker的处理、培训和托管功能非常全面，通过自带容器，我们可以按照自己的方式构建模型和应用程序。</p><p id="0a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博客中，我们探索了如何创建我们自己的、可重用的、支持R的docker容器，我们可以用它来满足我们的处理、培训和部署需求。</p><p id="8a35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文中使用的完整代码示例可以在这个<a class="ae lt" href="https://github.com/aws-samples/rstudio-on-sagemaker-workshop/tree/main/03_SageMakerPipelinesAndDeploy" rel="noopener ugc nofollow" target="_blank"> Github资源库</a>中找到。</p><p id="e70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在SageMaker上为R构建自己的容器，请在评论中联系我，或者在LinkedIn中与我联系，SageMaker愿意就此进行讨论！</p></div></div>    
</body>
</html>