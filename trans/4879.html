<html>
<head>
<title>The essence of drawing Sankey Plot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绘制桑基图的本质</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-essence-of-drawing-sankey-plot-491fb2cb234#2022-10-30">https://towardsdatascience.com/the-essence-of-drawing-sankey-plot-491fb2cb234#2022-10-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e0c2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我想分享两种用纯Python生成Sankey图最重要部分的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/40f8b8481ae4e1f3744dade69561056d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbgxuLm_nld5_NhWS5B_Aw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://www.biorxiv.org/content/10.1101/2021.10.16.464640v2.full" rel="noopener ugc nofollow" target="_blank">作者自己的研究论文</a></p></figure><p id="a1bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Sankey plot是一种非常好的、简洁的方式来可视化值如何从源类别流向目标类别。在上面显示的左图中，我使用了Sankey图来展示每个造血群体(干细胞、红系祖细胞)如何根据其突变谱进一步分为更细的亚群体。除了这个例子之外，桑基图也被广泛用于显示<a class="ae kv" href="https://developers.google.com/chart/interactive/docs/gallery/sankey#:~:text=A%20sankey%20diagram%20is%20a,the%20connections%20are%20called%20links." rel="noopener ugc nofollow" target="_blank">能量流变化</a>、<a class="ae kv" href="https://www.azavea.com/blog/2017/08/09/six-sankey-diagram-tool/" rel="noopener ugc nofollow" target="_blank">关于活动的统计</a>等等。</p><p id="3a41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然有几个现成的软件包可以在一行中绘制桑基图(即<a class="ae kv" href="https://github.com/anazalea/pySankey" rel="noopener ugc nofollow" target="_blank"> pySankey </a>、<a class="ae kv" href="https://plotly.com/python/sankey-diagram/" rel="noopener ugc nofollow" target="_blank"> Plotly </a>、<a class="ae kv" href="https://r-graph-gallery.com/sankey-diagram.html" rel="noopener ugc nofollow" target="_blank"> networkD3 </a>)，但我发现弄清楚桑基图实际上是由什么组成的是一个非常有趣的练习，这样我们就可以从头开始制作自己的桑基图，并进行所需的修改。</p><p id="0dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将一个复杂的Sankey图分成几部分，我们会发现最重要的部分只是两个垂直的条(矩形),分别代表左侧和右侧每个类别的数量，以及连接这两个矩形的曲线。今天分享两种在Matplotlib包中绘制这些零件的图的方法。</p><p id="5251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程中的代码可以在<a class="ae kv" href="https://github.com/frankligy/python_visualization_tutorial/tree/main/sankey" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a8b7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">设置网格和边栏</h1><p id="08f4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，我们需要在两边画出矩形，这个任务可以从不同的角度来看。一种方法是将它们视为两条线之间的区域，这样我们可以使用<code class="fe mw mx my mz b">ax.fill_between</code>函数来填充颜色。另一种方法是将它们视为独立的矩形，并利用<code class="fe mw mx my mz b">matplotlib</code>包中内置的<code class="fe mw mx my mz b">Rectangle</code>补丁。在这里，让我们使用第二种方法进行演示，但是您也可以尝试第一种方法。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="bc59" class="ne ma iq mz b gy nf ng l nh ni">from matplotlib.patches import Rectangle<br/>fig,ax = plt.subplots()<br/>ax.set_xlim([0,1])<br/>ax.set_ylim([0,1])<br/>ax.grid()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/4c96122b7e13f9710ec84f61e7278565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTMoFCV8r2BPclteye1gyg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="8ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在指定了画布和我们要绘制的轴之后，我们可以开始绘制这两个矩形。如果你不熟悉canvas(fig)和ax，也许<a class="ae kv" rel="noopener" target="_blank" href="/making-publication-quality-figures-in-python-part-i-fig-and-axes-d86c3903ad9b">我之前的教程集</a>能有点帮助。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="3f20" class="ne ma iq mz b gy nf ng l nh ni">rec_left = Rectangle(xy=(0.1,0.6),width=0.2,height=0.2,facecolor='orange',edgecolor='k')<br/>ax.add_patch(rec_left)<br/><br/>rec_right = Rectangle(xy=(0.7,0.2),width=0.2,height=0.2,facecolor='green',edgecolor='k')<br/>ax.add_patch(rec_right)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/6a2a73eafe9733ecc852d064f26092b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VqIhWQN5rV_cCMOkQOkSDQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="8a64" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated">方法1:使用Matplotlib路径对象</h1><p id="14b4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接下来的任务是绘制曲线条带，我想先介绍一下Matplotlib中强大的<code class="fe mw mx my mz b">Path</code>模块。这个模块有时被认为是一个低级API，但它实际上是Python中最常用的可视化的基础，因为一切都可以归结为涂鸦，对吗？</p><p id="3f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">Path</code>模块允许你随意绘制任何形状的线条，这是由两个参数控制的，按照惯例命名为<code class="fe mw mx my mz b">verts</code>和<code class="fe mw mx my mz b">codes</code>。<code class="fe mw mx my mz b">verts</code>是一个2D NumPy数组或嵌套列表，其中每个元素都是一个元组，这个2D数组的每个元素或每一行都代表锚点的(x，y)坐标，这样，如果你想用5个锚点画一条线，你的<code class="fe mw mx my mz b">vert</code>的长度应该是5。同时，<code class="fe mw mx my mz b">codes</code>参数定义了在画线时如何解释每个锚点。让我们看一个简单的例子:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="1e11" class="ne ma iq mz b gy nf ng l nh ni">from matplotlib.path import Path<br/>from matplotlib.patches import PathPatch</span><span id="535d" class="ne ma iq mz b gy nq ng l nh ni">verts = [(0.3,0.8),(0.5,0.8),(0.7,0.4),(0.3,0.6),(0.3,0.8)]<br/>codes = [Path.MOVETO, Path.LINETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]<br/>p = Path(verts,codes)<br/>ax.add_patch(PathPatch(p,fc='none'))</span></pre><p id="af08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剧情会看那个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/46329258490a02c86325f82b09efede7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2F0v8bkKZhryqNj-E0Kug.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="595e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这个例子能让你了解<code class="fe mw mx my mz b">verts</code>和<code class="fe mw mx my mz b">codes</code>是如何合作完成任务的。然而，正如你所看到的，到目前为止，我们仍然只是处理直线，那么我们希望绘制的曲线呢？</p><p id="7253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在<code class="fe mw mx my mz b">codes</code>列表中包含另外两个名为<code class="fe mw mx my mz b">CURVE3</code>和<code class="fe mw mx my mz b">CURVE4</code>的代码。<code class="fe mw mx my mz b">CURVE3</code>代表我们所说的二次贝塞尔曲线，而<code class="fe mw mx my mz b">CURVE4</code>代表三次贝塞尔曲线。如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f080ca4964fb35d5952c828f5bb55432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmBJl_OrhtYrCAJ_cEQ8lA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0bdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想画一条二次贝塞尔曲线，你需要指定三个锚点(CURVE3)和中间的一个来控制曲率。类似地，你总共需要四个点来画一个三次贝塞尔曲线(曲线4)。我们将使用CURVE4进行条带可视化。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="78eb" class="ne ma iq mz b gy nf ng l nh ni">verts = [(0.3,0.8), (0.5,0.8), (0.5,0.4), (0.7,0.4)]<br/>codes = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4]<br/>p = Path(verts,codes)<br/>ax.add_patch(PathPatch(p,fc='none',alpha=0.6))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/72f56ff456f392799c8076bd647b8901.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0dBKjEsLwanKSPOVShJ7A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ef4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们如何实现最终目标变得更加清晰，代码如下所示:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="90cf" class="ne ma iq mz b gy nf ng l nh ni">verts = [(0.3,0.8), (0.5,0.8), (0.5,0.4), (0.7,0.4), (0.7,0.2), (0.5,0.2), (0.5,0.6), (0.3,0.6), (0.3,0.8)]<br/>codes = [Path.MOVETO, Path.CURVE4, Path.CURVE4, Path.CURVE4, Path.LINETO, Path.CURVE4, Path.CURVE4, Path.CURVE4, Path.CLOSEPOLY]<br/>p = Path(verts,codes)<br/>ax.add_patch(PathPatch(p,fc='red',alpha=0.6))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/4ab3e697ddd091f3ca12f3ce1c93d939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5lwEvpBvwSebwiNV0dm-TA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">方法1:使用路径对象。</p></figure><h1 id="e204" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated">方法2:使用Numpy卷积</h1><p id="9a66" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">另一种思考条带的方式是将它重新构建为一个信号处理问题，这个想法来自于<a class="ae kv" href="https://github.com/anazalea/pySankeyhttps://github.com/anazalea/pySankey" rel="noopener ugc nofollow" target="_blank"> pySankey </a>包的实现。当给定两个信号<code class="fe mw mx my mz b">f(x)</code>和<code class="fe mw mx my mz b">g(x)</code>时，线性卷积算子可以总结出信号<code class="fe mw mx my mz b">g(x)</code>对信号<code class="fe mw mx my mz b">f(x)</code>的影响，从而得到卷积信号函数<code class="fe mw mx my mz b">f(x)*g(x)</code>。这个函数已经被实现为<code class="fe mw mx my mz b">numpy.convolve</code>，它是如何计算的在这篇<a class="ae kv" href="http://en.dsplib.org/content/conv/conv.html" rel="noopener ugc nofollow" target="_blank">文章</a>中有很好的说明。请注意，这里我们使用了<code class="fe mw mx my mz b">mode='valid'</code>，因此只计算两个信号完全重叠的位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/145ed661975bb0ebb5788b7eac6311b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQSqK-XU1xnM_P8FKqOkEQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卷积如何帮助生成曲线带？</p></figure><p id="44e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照这个逻辑，我们可以修改我们的代码:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="482f" class="ne ma iq mz b gy nf ng l nh ni">yu = np.array(50*[0.8] + 50*[0.4])<br/>yu_c = np.convolve(yu, 0.05*np.ones(20),mode='valid')<br/>yu_cc = np.convolve(yu_c, 0.05*np.ones(20),mode='valid')<br/>yd = np.array(50*[0.6] + 50*[0.2])<br/>yd_c = np.convolve(yd, 0.05*np.ones(20),mode='valid')<br/>yd_cc = np.convolve(yd_c, 0.05*np.ones(20),mode='valid')<br/>ax.fill_between(np.linspace(0.3,0.7,62),yd_cc,yu_cc,color='blue',alpha=0.6)</span></pre><p id="fa00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们基本上对上面的虚拟例子做了两次同样的事情，第一次是对上半部分的曲线，另一次是对下半部分的曲线，这样，我们可以利用方便的<code class="fe mw mx my mz b">ax.fill_between</code>函数用想要的颜色填充区域来完成任务。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e09d8a24dce4cfbf181bcd7a5d3b7a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AqUVOsuRaORsUsDtoRaFGg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">方法2:利用数值卷积</p></figure><h1 id="c7e6" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated">结论</h1><p id="9d00" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">好了，就这些了，非常感谢你的阅读，希望你喜欢这个简短的教程。如果你喜欢这篇文章，请在medium上关注我，非常感谢你的支持。在我的<a class="ae kv" href="https://twitter.com/FrankLI55917967" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae kv" href="https://www.linkedin.com/in/guangyuan-li-399617173/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上联系我，也请让我知道你是否有任何问题或你希望在未来看到什么样的教程！</p></div></div>    
</body>
</html>