<html>
<head>
<title>Algorithms Explained #6: Tree Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释#6:树遍历</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-explained-6-tree-traversal-1a006ba00672#2022-10-12">https://towardsdatascience.com/algorithms-explained-6-tree-traversal-1a006ba00672#2022-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a5d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python中的例子解释树遍历算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd518d4192a252e9ca99d5f9f652483c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNsr5HvuHkk2aW_NakP3jw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/clker-free-vector-images-3736/" rel="noopener ugc nofollow" target="_blank"> Clker-Free-Vector-Images </a>来自<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="5a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树由一组由边连接的节点表示。它们被认为是分层的非线性数据结构，因为树中的数据存储在多个层次上。树具有以下属性:</p><ul class=""><li id="ff6b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="me">根节点:</em>每棵树都有一个节点被指定为根节点，它是树的最顶端的节点，并且是没有任何父节点的节点。</li><li id="e5c9" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">父节点:</em>父节点是它之前的节点，除了根节点之外的每个节点都有一个父节点。</li><li id="a2ef" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">子节点:</em>子节点是其后的节点。根据树的类型，每个节点可以有不同数量的子节点。</li></ul><h1 id="0f16" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">树形数据结构的类型</h1><p id="d415" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">有一些通用树具有上面列出的属性，并且对节点数量没有其他限制。还有各种类型的树数据结构，对于不同的用例有更多的限制，下面是一些常见的:</p><ol class=""><li id="5964" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nh mb mc md bi translated"><em class="me">二叉树:</em>二叉树是一种节点最多可以有两个子节点的树，正如“二进制”标签所暗示的。</li><li id="373e" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nh mb mc md bi translated"><em class="me">二叉查找树(BST)</em>:BST是二叉树的一个特例，其中的节点是按照它们的值排序的。对于每个父节点，左边的子节点是一个较小的值，而右边的子节点是一个较大的值。这种结构使得查找很快，因此对于搜索和排序算法很有用。</li><li id="af27" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nh mb mc md bi translated"><em class="me">堆:</em>堆是一种特殊的树数据结构，有两种类型的堆:I)最小堆是一种树结构，其中每个父节点小于或等于其子节点；ii)最大堆是一种树形结构，其中每个父节点大于或等于其子节点。这种类型的数据结构对于实现优先级队列很有用，在优先级队列中，项目按权重排列优先级。请注意，Python有一个名为<code class="fe ni nj nk nl b">heapq</code>的内置库，其中包含对堆数据结构执行不同操作的函数。</li></ol><h1 id="ea34" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">树遍历算法</h1><p id="e491" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在回顾了树数据结构的常见类型之后，下面是一些常见的树遍历算法及其在Python中的实现的例子。</p><h2 id="02fb" class="nm ml it bd mm nn no dn mq np nq dp mu li nr ns mw lm nt nu my lq nv nw na nx bi translated">广度优先搜索(BFS)</h2><p id="6d53" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">面包优先搜索(BFS)是一种常用算法，用于按系统顺序遍历二叉查找树(BST)或图。它从第0层的根节点开始，一次访问一个节点，从一侧横向移动到另一侧，直到找到所需的节点或访问完所有节点。该算法在深入搜索之前先进行大范围搜索，因此被称为面包优先搜索。</p><p id="6674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BFS的时间复杂度是O(n ),因为树的大小由项目搜索长度决定，并且每个节点被访问一次。下面是Python中的实现:</p><pre class="kj kk kl km gt ny nl nz oa aw ob bi"><span id="7a0b" class="nm ml it nl b gy oc od l oe of">def bfs(graph, source):<br/>   """Function to traverse graph/ tree using breadth-first search</span><span id="9e0f" class="nm ml it nl b gy og od l oe of">   Parameters:<br/>   graph (dict): dictionary with node as key and <br/>                 list of connected nodes as values.<br/>   source (str): source node to start from, usually <br/>                 the root node of the tree.</span><span id="e11f" class="nm ml it nl b gy og od l oe of">   Returns:<br/>   bfs_result (list): list of visited nodes in order.<br/>   """<br/>   # Define variables<br/>   bfs_result = []<br/>   queue = []</span><span id="7c66" class="nm ml it nl b gy og od l oe of">   # Add source node to queue<br/>   queue.append(source)</span><span id="66d8" class="nm ml it nl b gy og od l oe of">   while queue:<br/>     # Visit node at front of queue<br/>     node = queue.pop(0)</span><span id="c250" class="nm ml it nl b gy og od l oe of">     # Check if we have visited this node before<br/>     if node not in bfs_result:<br/>        # Mark node as visited<br/>        bfs_result.append(node)<br/>        # Add all neighbor nodes to queue<br/>        for neighbor in graph.get(node, []):<br/>           queue.append(neighbor)</span><span id="8113" class="nm ml it nl b gy og od l oe of">   return bfs_result</span></pre><h2 id="724a" class="nm ml it bd mm nn no dn mq np nq dp mu li nr ns mw lm nt nu my lq nv nw na nx bi translated">深度优先搜索</h2><p id="c653" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">深度优先搜索(DFS)是树遍历算法的另一种变体，它也从根节点开始，但沿着一个分支向下移动，并尽可能沿着一个分支向下移动。如果所需的节点不在该分支中，它会返回并选择另一个分支。该算法一直这样做，直到找到期望的节点或者所有节点都被访问过。该算法在进入另一个分支之前首先向下探索一个分支(深度)，因此被称为深度优先搜索。</p><p id="a4b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于与BFS相同的原因，DFS的时间复杂度也是O(n)。下面是Python中的实现:</p><pre class="kj kk kl km gt ny nl nz oa aw ob bi"><span id="6e47" class="nm ml it nl b gy oc od l oe of">def dfs(graph, source):<br/>   """Function to traverse graph/ tree using depth-first search</span><span id="ae63" class="nm ml it nl b gy og od l oe of">   Parameters:<br/>   graph (dict): dictionary with node as key and <br/>                 list of child nodes as values.<br/>   source (str): source node to start from, usually <br/>                 the root node of the tree.</span><span id="efde" class="nm ml it nl b gy og od l oe of">   Returns:<br/>   dfs_result (list): list of visited nodes in order.<br/>   """<br/>   # Define variables<br/>   dfs_result = []<br/>   queue = []</span><span id="4d7b" class="nm ml it nl b gy og od l oe of">   # Add source node to queue<br/>   queue.append(source)</span><span id="b623" class="nm ml it nl b gy og od l oe of">   while queue:<br/>      # Get last item in queue<br/>      node = queue.pop()</span><span id="bb79" class="nm ml it nl b gy og od l oe of">      # Check if we have visited node before<br/>      if node not in dfs_result:<br/>         dfs_result.append(node)<br/>         # Add neighbors to queue<br/>         for neighbor in graph.get(node, []):<br/>            queue.append(neighbor)</span><span id="4465" class="nm ml it nl b gy og od l oe of">   return dfs_result</span></pre><h2 id="53ff" class="nm ml it bd mm nn no dn mq np nq dp mu li nr ns mw lm nt nu my lq nv nw na nx bi translated">结论</h2><p id="aa47" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">树是表示分层和非线性数据的有用数据结构。最常用的树数据结构类型是二叉树(树中的每个节点最多有两个子节点)、二叉查找树(二叉树，其中节点按值排序)和堆(树，其中父节点少于或多于它们的子节点，取决于它是最小堆还是最大堆)。</p><p id="0d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在算法方面，面包优先搜索和深度优先搜索是重要的树遍历算法，具有许多实际应用，从GPS导航系统中的路径寻找和路线规划到调度到网络拓扑。在下一篇文章中，我们将介绍一个用于信息编码的树遍历的特殊例子，称为霍夫曼码。</p><p id="ea49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多请看本算法讲解系列:<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>(本期文章)。</p></div></div>    
</body>
</html>