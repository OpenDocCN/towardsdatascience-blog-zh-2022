<html>
<head>
<title>Building a simple recommendation engine in Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Neo4j构建一个简单的推荐引擎</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-simple-recommendation-engine-in-neo4j-45770d8747eb#2022-04-08">https://towardsdatascience.com/building-a-simple-recommendation-engine-in-neo4j-45770d8747eb#2022-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89c9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们用plain Cypher构建一个简单的推荐引擎</h2></div><p id="2d4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像Neo4j这样的图形数据库是创建推荐引擎的优秀工具。它们允许我们检查可能包含各种数据源的数据点的大环境。他们强大的存储模型非常适合我们希望分析节点周围环境的应用。如果你想了解是什么让图比关系模型更强大，请阅读这里的。</p><p id="37df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我描述了我们如何只用Cypher直接在Neo4j中实现一个简单的推荐引擎。该方法基于基本的自然语言处理和简单的条件概率来寻找最可能的匹配项。这个实现可以在一个查询中用几行代码来完成。当用户与应用程序交互时，我们实时运行查询。这个简单的方法产生了非常令人满意的结果，是一个很好的第一个版本。这为我们节省了很多供应和维护额外外部系统的麻烦，我们需要这些系统来进行更复杂的方法。尽管它工作得很好，但是这个解决方案也有一些限制。</p><h1 id="87e1" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">领域:队长，任务，事件，领域和项目</h1><p id="8e40" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">DayCaptain是一个个人时间规划应用程序，允许用户创建由任务和事件组成的一天计划。任务和事件的主要属性是它们的标题，这是一个指定它的短字符串。组织这些对象的一种方法是将它们分配给(生活)区域和项目。一个领域是一个更大且持久的主题，而一个项目是有时间限制的。项目本身可以被分配到一个区域，在这种情况下，它们继承该区域。在本文的其余部分，我们不写“任务和事件”,现在我们只关注任务。</p><p id="7968" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，目标是当用户开始在前端输入时，检测新任务的区域分配。例如:用户创建一个任务，开始在DayCaptain中编写“部署ETL管道”。当他打字时，我们想通过分析使用这些单词的其他任务来检测单词最可能出现的区域。</p><h1 id="dffa" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">标记化和词干化—准备工作</h1><p id="9b72" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">目前，我们只考虑任务的标题属性。为了将它转化为可工作的特性，我们需要提取它的表征并对它们进行词干处理。我们使用<a class="ae lb" href="https://nlp.stanford.edu/software/" rel="noopener ugc nofollow" target="_blank"> StanfordNLP </a>框架在用户创建新任务和事件时处理每个输入字符串，并将它们的令牌用法作为关系存储在图中。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/4700eb15eb2d3f49dcea1cfbf88f06f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6ZHdn7CNQtW1b6yy.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">数据模型:任务的主要属性是标题。它链接到词干标记，并被分配给一个区域。(图片由作者提供)</p></figure><h1 id="2cd9" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">集合、面积和条件概率</h1><p id="776a" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们的目标是为用户当前正在键入的一组单词找到最可能的区域分配。所以，我们要找到概率<code class="fe mp mq mr ms b">P(A|T)</code>最大的区域。换句话说:给定一个记号T，我们想找到包含这个单词的概率最大的区域A。</p><p id="5ef0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从一个简单的例子开始:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/0d4c831d63abc31b750a3051329cf836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oKd9MtED8PhuSeeY.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">任务与令牌和区域有关系——介于两者之间。(图片由作者提供)</p></figure><p id="7c5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，正如我们所看到的，任务(或事件)位于区域和令牌之间，并且基本上形成了它们的分配。当我们创建由标记组成的新任务和事件，并将它们与区域相关联时，我们在区域和标记之间获得更多这样的间接关系。这些间接关系正是我们要分析来寻找建议的。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/a67017a9fc20e9e21fb253d6e8175272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KcqFBsCBv_uifi_r.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">当任务位于区域和令牌之间时，它们在它们之间形成间接关系。(图片由作者提供)</p></figure><p id="f420" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，根据上图，我们还可以在区域和令牌之间构建一个分配矩阵。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/48ecc3e0ef49e7533a029ac4301016cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nMw2j2zmj0ttDDHL.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">利用这些间接关系，我们可以构造一个面积和记号的频率矩阵。(图片由作者提供)</p></figure><p id="ef88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">手头有了所有这些数字，我们可以很容易地计算出<code class="fe mp mq mr ms b">P(A|T) = P(A &amp; T) / P(T)</code>的条件概率。以下是一些例子:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/98e53ef50cc46c0aea10c4816f8b6b96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rpNX-CJBsIbfvHnh.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">使用我们的频率矩阵，我们可以很容易地计算条件概率看到一个地区给定一个令牌。(图片由作者提供)</p></figure><p id="56f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说明这种概率的一个非常直观的方法是将它们视为面积。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/99904b93f30888aa616eafc8ffe34148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*id3rCoJnhCBZtTJS.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">频率也可以用面积来表示。(图片由作者提供)</p></figure><p id="cdf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的推荐查询很简单。然而，这个例子只适用于单个令牌。问题是:我们如何将多个单词组合成这样一个概率计算？</p><h1 id="22ad" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">查找多个单词的推荐</h1><p id="1e27" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">每个任务和事件可以，并且可能由多个令牌组成。为了将我们的模型扩展到这种情况，作为区域的图示特别有用。</p><p id="d864" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:我们想找到任务“准备Neo4j研讨会”的区域分配。然后，我们想找到概率<code class="fe mp mq mr ms b">P(A|”Neo4j” &amp; “workshop”)</code>。从微积分，我们可以推断，我们需要找到<code class="fe mp mq mr ms b">P(A &amp; “Neo4j” &amp; “workshop”)</code>和<code class="fe mp mq mr ms b">P(“Neo4j” &amp; “workshop”)</code>。如果我们查看我们的面积图(或我们的矩阵),我们可以得出这些概率是什么。计算如下:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/32b73092ee337dbe6193c25431de2a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DijVTJB5CK2mHQfeF5NLRg.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">双令牌条件概率的计算。(图片由作者提供)</p></figure><p id="7b33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们已经从例子中看到的，我们不需要赋值的全局计数，因为它总是相互抵消。因此，我们的推荐查询非常简单，只需确定每个区域内的分配数量。以下是查询:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">最终区域检测查询。</p></figure><p id="7a7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">该查询的一些注释:</strong>在real DayCaptain中，也有在区域和任务之间建模的项目。<code class="fe mp mq mr ms b">Information</code>标签是任务和事件的超类(或者基本上是所有东西，它有一个标题属性)。此外，查询被简化为不考虑用户。在我们的生产案例中，我们实际上将这个查询限制到特定的用户。</p><h1 id="b3ed" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">这很简单——但是效果如何呢？</h1><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/69fd8a43d521527416d56f5610417957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qybl6dtHbH5D137n.gif"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">行动中的区域检测🚀(图片由作者提供)</p></figure><p id="50b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对推荐引擎进行了定量评估，甚至在相同的数据上将其与深度神经网络模型进行了比较。结果非常令人满意。在这两种情况下，我们将数据集分为训练集和测试集。尽管在我们的简单方法中没有训练阶段，但我们想测试推荐引擎是否能在它以前没有见过的数据点上很好地工作。</p><p id="3887" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有大量来自我自己的数据，因为我已经使用DayCaptain超过4年了。对于这两种方法，我们测量了他们对已知任务或事件预测正确结果的次数。这两种方法都在大约95%的时间里预测了正确的区域。</p><h1 id="67e5" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">伙计，这很酷——但这意味着什么呢？</h1><p id="a436" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">让我们对此进行简短的讨论:我们的简单统计(或概率)推荐方法使用非常简单的数学和大量的直觉来产生非常有用的结果。它非常简单明了地用普通密码实现，并且直接在我们的Neo4j后端运行。没有添加外部系统的开销，没有我们需要管理的培训周期或模型，维护代码的开销也很低。我们实际上能够实时查询结果(在用户输入时多次查询),而不需要对结果做任何准备。与嵌入word2vec的深度神经网络模型等更复杂的方法相比，它产生了同样好的结果。</p><p id="55b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这种方法的主要缺点是:它局限于一个简单的特性集。一旦我们想在我们的推荐中考虑更多的特性，我们必须在我们的查询中显式地建模它们。它可能变得非常复杂，难以理解，甚至无法维护。更不用说寻找正确的方法将多个特性组合成一个合理的结果的复杂开发过程了。</p><h1 id="0d30" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">让我们把这个围起来。</h1><p id="43f8" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">Neo4j强大的查询模型允许我们在数据库中构建强大的推荐。我们创建了一个非常简单但非常强大的预测查询，为我们的用户提供最佳体验。我们的方法实际上是80/20，我们取得了一些非常好的结果。对我们来说，主要优势是直接在我们的图形数据库中实现，因为它为我们节省了大量供应、培训和监控额外系统的工作。然而，这种方法的应用限于一小部分特征，因为查询可能变得相当复杂，并且需要很大的努力来维护和扩展。这里描述的方法无疑是构建初始工作解决方案的良好起点。</p><h1 id="fbed" class="lc ld iq bd le lf lg lh li lj lk ll lm jw ln jx lo jz lp ka lq kc lr kd ls lt bi translated">让我们组队吧——让我听听你的意见。</h1><p id="8618" class="pw-post-body-paragraph kf kg iq kh b ki lu jr kk kl lv ju kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我希望你喜欢阅读这篇文章，并希望你能从中受益。如果您有任何问题或不同意见，我热忱欢迎您留下评论或直接联系我。点击订阅按钮阅读更多类似内容。🚀</p></div></div>    
</body>
</html>