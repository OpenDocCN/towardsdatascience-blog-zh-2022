<html>
<head>
<title>A complete guide to git for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者git完全指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-complete-guide-to-git-for-beginners-a31cb1bf7cfc#2022-10-04">https://towardsdatascience.com/a-complete-guide-to-git-for-beginners-a31cb1bf7cfc#2022-10-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9612" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">键盘命令、功能和用法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be265de150071bc1dae3288e5f23681f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iY_86U1JK7eNnNOA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@praveentcom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Praveen Thirumurugan </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Git是所有数据科学家和软件工程师都应该知道如何使用的工具。无论您是单独从事一个项目，还是作为大型分布式团队的一部分，了解如何有效地使用Git都可以为您的项目节省大量时间。git的好处是，它可以作为您工作的版本控制系统，这样您就可以放心地进行编辑、更改和添加新功能，因为您知道如果需要的话，您总是可以回到您工作的前一个版本。这让开发人员和数据科学家有信心继续开发他们的工作，并在现有项目和分析中引入新的系统、功能和工作流，同时能够确保始终有一个工作版本。</p><p id="d39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是对git初学者的介绍，涵盖了有效使用git所需的基本命令和功能。本文涵盖的主题包括:</p><ol class=""><li id="0b28" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#e234" rel="noopener ugc nofollow"> <strong class="lb iu">什么是饭桶？</strong> </a></li><li id="0cdd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#7477" rel="noopener ugc nofollow"> <strong class="lb iu">设置存储库</strong> </a></li><li id="1ee0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#05bc" rel="noopener ugc nofollow"> <strong class="lb iu">进行修改</strong> </a></li><li id="b1f9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#2488" rel="noopener ugc nofollow"> <strong class="lb iu">创建特征</strong> </a></li><li id="8ab8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#518d" rel="noopener ugc nofollow"> <strong class="lb iu">修复bug或错误</strong> </a></li><li id="78a0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#8cc5" rel="noopener ugc nofollow"> <strong class="lb iu">附加功能</strong> </a></li><li id="0c2e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#7745" rel="noopener ugc nofollow"> <strong class="lb iu">结论</strong> </a></li></ol><h2 id="e234" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">Git是什么？</h2><p id="f7b0" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，什么是git？嗯，根据<a class="ae ky" rel="noopener" target="_blank" href="/ucl-data-science-society-introduction-to-numpy-7d962d63f47d"> Git网站</a>:</p><blockquote class="nh ni nj"><p id="2064" class="kz la nk lb b lc ld ju le lf lg jx lh nl lj lk ll nm ln lo lp nn lr ls lt lu im bi translated"><em class="it"> Git是一款</em> <a class="ae ky" href="https://git-scm.com/about/free-and-open-source" rel="noopener ugc nofollow" target="_blank"> <em class="it">免费开源</em> </a> <em class="it">分布式版本控制系统，旨在快速高效地处理从小到大的各种项目。</em></p></blockquote><p id="c16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着它是一个管理文件版本的软件系统，主要是代码文件，这样您就不必处理诸如“文件v.2”、“文件v.3”和“文件final final”等版本问题。相反，使用git提交使得文件名保持不变，但是如果需要的话，您可以返回到文件的前一个版本，或者多个文件。这避免了相当混乱的工作目录。</p><h2 id="7477" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">设置存储库</h2><p id="63fa" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">git使用存储库工作，存储库通常由一个单独的文件夹表示，如果需要，还可以有子文件夹。您与git的第一个交互将是将您的工作文件夹转换成git存储库，允许您利用git提供的所有功能。</p><p id="54b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过创建一个新的空文件夹，然后设置一个本地存储库来展示这一点。这假设您已经在系统上安装了<a class="ae ky" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">git</a>。为此，我们可以使用<code class="fe no np nq nr b">mkdir</code>命令创建一个新文件夹，如下所示:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f3e0" class="mj mk it nr b gy nw nx l ny nz">mkdir new_project</span></pre><p id="1b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以使用命令行导航到该文件夹:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="fec2" class="mj mk it nr b gy nw nx l ny nz">cd new_project</span></pre><p id="8c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的命令行现在应该显示您位于<code class="fe no np nq nr b">new_project</code>目录中。一旦出现这种情况，我们就可以继续在文件夹中初始化一个新的git存储库。这个命令相对简单，用<code class="fe no np nq nr b">init</code>命令如下:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f498" class="mj mk it nr b gy nw nx l ny nz">git init</span></pre><p id="21b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你这样做了，一个<code class="fe no np nq nr b">.git</code>文件夹应该出现在你的目录中(虽然现在看不到)。此外，根据您安装的git版本，<code class="fe no np nq nr b">master</code>或<code class="fe no np nq nr b">main</code>应该出现在命令行中您当前所在的目录之后。如果是这样，您现在应该有一个工作的git存储库，这样您就可以利用git的所有关键功能了！</p><h2 id="05bc" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">做出改变</h2><p id="f3e3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">git的主要好处是能够有效地管理您创建和编辑的文件的不同版本。Git允许您跟踪所做的更改，同时如果需要的话，还可以返回并编辑或删除它们。这让开发人员有信心进行编辑和更改，而不用担心丢失以前的工作。</p><p id="c08c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，您需要知道如何添加您创建的文件以及您对git所做的更改，然后将这些更改存储在系统中。这个过程的第一步是“暂存”文件，这样git知道您在特定文件中所做的更改将被记住(提交)。为此，您只需使用以下命令:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="0c25" class="mj mk it nr b gy nw nx l ny nz">git add &lt;filename&gt;</span></pre><p id="2ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将“暂存”您在该文件中所做的任何更改，直到您使用该命令。这些变化将会出现在一个“暂存”区域，但是还不会发生任何变化。</p><p id="b05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让git区分您希望它记住的对文件的更改，您需要将这些更改“提交”到您的存储库中。“提交”可以清楚地区分你所做的改变，让你能够找到你感兴趣的具体改变。当您提交更改时，您有效地将这些更改保存到本地存储库中，并附带一条消息，说明这些更改意味着什么，无论是功能、代码结构的更改还是新特性的创建。用于此目的的命令是:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e263" class="mj mk it nr b gy nw nx l ny nz">git commit -m "&lt;insert clear message here"&gt;</span></pre><p id="fa73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将提交您之前使用<code class="fe no np nq nr b">add</code>命令进行的所有更改。</p><p id="4fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是要确保每个提交都有一个明确的附加消息，以便您可以在必要时返回并找到它。虽然这对你来说似乎不那么重要(我当然记得那是什么变化！)如果你是团队的一员，有人可能会看到你所做的改变，这一点很重要。这意味着尽可能简洁明了地描述提交的目的通常是最佳实践。</p><p id="04c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您在提交中所做的所有更改都将存储在您的本地git存储库中。这对于版本控制来说更好，但是如果您的笔记本电脑突然没电了，您想使用不同的笔记本电脑工作，或者您是团队的一员，这可能是一个问题。为此，您可能希望将您机器上的本地存储库链接到一个远程存储库，您或任何人只要有互联网连接就可以从任何地方访问它。</p><p id="f1ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些服务可以用于远程存储库，但最常用的是Github。为了能够将您的本地存储库连接到远程github one，您需要一个<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub帐户</a>，并且已经设置了一个远程存储库来链接您的本地存储库。一旦设置了远程存储库，您将需要找到远程存储库URL，它看起来应该像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/17299860f9eb61fc1e5a8e2f9292e7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*kwGkJSICUNqxttHE.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要简单地将本地存储库与远程存储库连接起来，可以使用以下命令添加链接:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d42e" class="mj mk it nr b gy nw nx l ny nz">git remote add origin &lt;REMOTE URL&gt;</span></pre><p id="2ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了验证已经建立了连接，使用<code class="fe no np nq nr b">git remove -v</code>,它应该会打印出您指定的远程URL。如果它显示正确的URL，那么您现在连接到了一个远程存储库！</p><p id="8a10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，当您连接到远程存储库时，到目前为止您提交的更改实际上还不会出现在那里。这是因为您必须告诉您的本地存储库，您想要将您的提交“推”到远程存储库。这仅仅需要使用<code class="fe no np nq nr b">git push</code>命令:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9226" class="mj mk it nr b gy nw nx l ny nz">git push</span></pre><p id="2993" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会将您所做的所有提交推送到远程存储库，这意味着您可以从世界上的任何地方访问您所创建的代码！当然前提是你能上网。通过刷新您的远程存储库来确保这已经生效，并确保您所做的更改也出现在那里。</p><p id="6667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您以后想要获取您或者其他人在存储库中所做的任何更改，您可以简单地使用<code class="fe no np nq nr b">git pull</code>命令。这意味着任何其他人都可以对您的代码做出贡献，并且您可以将这些更改带到您的本地存储库中！</p><h2 id="2488" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">创建特征</h2><p id="48b3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated"><strong class="lb iu">特征分支</strong></p><p id="9d6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为任何项目的一部分，根据您正在开发的产品，将需要添加新的功能或分析。在某些情况下，您不希望在您的存储库的<code class="fe no np nq nr b">main</code>分支上创建那个特性，因为您想先看看它是如何工作的以及它是否成功。那么最好的方法就是用git创建工作分支，将工作流相互分离，确保您的<code class="fe no np nq nr b">main</code>分支保持“干净”和工作。</p><p id="4358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分支允许您对您的工作进行增量变更，而不需要对您的存储库的<code class="fe no np nq nr b">main</code>分支进行变更。维护一个稳定和干净的<code class="fe no np nq nr b">main</code>分支允许一个连续的稳定构建线，只有当新特性稳定并准备集成到产品中时，新特性才会被添加进去(至少在理论上是这样的！).</p><p id="fba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用以下命令创建分支:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="6ac3" class="mj mk it nr b gy nw nx l ny nz">git branch &lt;branch_name&gt;</span></pre><p id="3f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后您可以使用<code class="fe no np nq nr b">checkout</code>命令导航到其中:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="bbe0" class="mj mk it nr b gy nw nx l ny nz">git checkout &lt;branch_name&gt;</span></pre><p id="9a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这样做了，现在应该显示<code class="fe no np nq nr b">&lt;branch name&gt;</code>,而不是在命令行中显示<code class="fe no np nq nr b">master</code>或<code class="fe no np nq nr b">main</code>,表明您当前正在处理您的分支。这个新分支将把来自<code class="fe no np nq nr b">main</code>分支的最后一次提交作为它的“根”,你在这个分支中所做的任何改变都将建立在这个原始点上。</p><p id="3cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都很好，但是当您完成了新特性的创建之后呢？你是如何将这些令人惊奇的工作放回“主”分支的？嗯，主要有两种方法:<strong class="lb iu">合并</strong>和<strong class="lb iu">重置</strong>。</p><p id="b7e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">合并</strong></p><p id="6252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将分支引入到<code class="fe no np nq nr b">main</code>中最常用的方式，也是最先学会的方式是通过<strong class="lb iu">合并</strong>。本质上，这就像它所说的那样，将特性分支“合并”到一个现有的分支中，但是这将通过在您的存储库中创建一个新的提交来实现。这样做的好处是，它将维护您已经提交的历史和顺序，包括清楚地标识分支的根在哪里。</p><p id="c601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要合并一个分支，您需要<strong class="lb iu">在您想要将提交引入</strong>的分支中。这意味着如果你想将一个特性分支合并到<code class="fe no np nq nr b">main</code>中，那么你需要检查<code class="fe no np nq nr b">main</code>分支。然后，您可以使用该命令:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="3121" class="mj mk it nr b gy nw nx l ny nz">git merge &lt;branch_name&gt;</span></pre><p id="067a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后会要求您添加一条提交消息，因为合并过程将通过提交来完成。一个常见的基本提交消息通常是:“merge <branch_name> into main ”,它简单地说明了它做了什么。</branch_name></p><p id="f830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用<code class="fe no np nq nr b">gitk</code>查看git提交历史，您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/8d70b5dabf1ce32a08cc989b4ba0ea30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*1d2sxu4LaIZjcEYv.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0d56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二次提交后特性分支从<code class="fe no np nq nr b">master</code>分支出来的地方，一个提交给主分支，两个提交给特性分支，并且它们与新提交的创建合并。</p><p id="e764" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">重设基础</strong></p><p id="9fd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在特性分支中进行合并的替代方法是改变提交的基础。这将从特性分支获取提交，并简单地将它们添加到主分支的顶部。与合并相比，这样做的好处是确保线性提交历史清晰易读。缺点是提交的历史变得不太清楚。</p><p id="1f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与合并不同的是，<strong class="lb iu">重定基础是从你想要移动的分支执行的，</strong>在这种情况下是特征分支。这意味着您需要确保已检出您创建的要素分支，并运行以下命令:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="9b49" class="mj mk it nr b gy nw nx l ny nz">git rebase &lt;main branch name&gt;</span></pre><p id="6ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<main branch="" name="">可以是master或者main，这取决于您正在使用的git版本，甚至是您想要添加提交的另一个分支。然后，您应该会看到这样的内容:</main></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/62fa3bab5429b78c8001fbec8bdb0546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*xywAONMvtsv0nACy.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保主分支与特性分支所做的更改保持一致，您需要使用以下命令将主分支指针向上拖动到<code class="fe no np nq nr b">rebase_branch</code>的最新提交:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="cebe" class="mj mk it nr b gy nw nx l ny nz">git branch -f master rebase_branch</span></pre><p id="8de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，rebase_branch和master分支应该指向同一个提交，并且您已经将rebase_branch中的所有提交都rebase到了master中。当您签出主分支时，不能运行此操作，否则强制将不起作用，因为您不能移动当前正在处理的分支。</p><h2 id="518d" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">修复bug或错误</strong></h2><p id="75b8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">有时候在开发时，你会想要撤销你在之前的提交中所做的更改。这可能是由于引入了错误，您所做的更改是多余的，或者您只是想撤销以前所做的。有三个命令可以帮你做到这一点:<code class="fe no np nq nr b">reset</code>、<code class="fe no np nq nr b">revert</code>和<code class="fe no np nq nr b">amend</code>。这些命令可以撤销代码或错误，并让开发人员有信心在第一时间提交代码，因为更改总是可以撤销的。</p><p id="e0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Git复位</strong></p><p id="0c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">git reset</code>是将分支的当前tup移回到先前提交的tup的一种方式。这样做可以从当前分支中删除不再需要的提交，或者撤销已经做出的任何更改。</p><p id="8b79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行这个，你只需使用<code class="fe no np nq nr b">git reset</code>和你想重置回。一个例子是将当前分支从分支的当前<code class="fe no np nq nr b">HEAD</code>向后移动两次提交，使用:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="f0c9" class="mj mk it nr b gy nw nx l ny nz">git reset HEAD~2</span></pre><p id="e531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将更改提交历史记录:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/aa5530c9e1241abf85cc5ce5b75ae18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*uRn4nT1d1Lhj7M2DAZHt4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e5f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收件人:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/dbe0753a6c4cc409850a29d4519866bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*rrGO8aRrEYVLJk147HcLRQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="75b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中提交B和C基本上已经从该历史中移除。但是，这对存储库本身的影响将取决于该命令使用的标志:</p><ul class=""><li id="a20c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated"><code class="fe no np nq nr b">--soft</code>将重置提交，但会将这些提交的更改保存在目录中，并保存这些更改以备重新提交。</li><li id="9946" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated"><code class="fe no np nq nr b">--mixed</code>(默认)将重置提交，并将提交的更改保存在目录中，但不会将更改存放到提交中。</li><li id="317c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated"><code class="fe no np nq nr b">--hard</code>将从目录中完全删除提交中所做的所有更改，就好像它们从未发生过一样，这是最极端的重置。</li></ul><p id="ccc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是<code class="fe no np nq nr b">git reset</code>改变了提交历史，当提交已经公开时，应该很少使用它。</p><p id="09a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Git回复</strong></p><p id="19b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您已经提交了想要更改的提交。在这种情况下，应该使用<code class="fe no np nq nr b">git revert</code>。这是因为<code class="fe no np nq nr b">git reset</code>通过创建一个新的提交来撤销提交的更改，从而保留了之前的提交历史。当提交已经被推送时会更好。</p><p id="e33a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe no np nq nr b">git revert</code>没有改变历史，您需要指定您想要撤销的提交。为此，您需要找到想要撤销的提交的提交引用。这可以使用<code class="fe no np nq nr b">git log</code>或<code class="fe no np nq nr b">git reflog</code>找到。一旦你有了那个参考，你简单的使用:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="97ec" class="mj mk it nr b gy nw nx l ny nz">git revert &lt;commit reference&gt;</span></pre><p id="10ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">撤消提交中所做的更改。例如，如果我们想要从下面的提交<code class="fe no np nq nr b">B</code>中恢复更改，对存储库的影响看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/af1a77643fc52ce6210f3425fc197999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*biEjmXquGJRD54qT.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中进行新的提交，撤销b中的所有改变。这不改变任何先前的提交，并且保持干净的提交历史。</p><p id="5e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Git修正</strong></p><p id="4062" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，您只想更改属于先前提交的代码。在这种情况下，使用<code class="fe no np nq nr b">git reset</code>或<code class="fe no np nq nr b">git revert</code>似乎有点愚蠢。相反，您可以利用<code class="fe no np nq nr b">git amend</code>，它允许您对之前的提交进行更改。</p><p id="a9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用它的一个简单方法是更改提交消息，如果你输入错误或者不够清楚的话。为此，您只需使用:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="fb99" class="mj mk it nr b gy nw nx l ny nz">git commit --amend -m "&lt;new commit message&gt;"</span></pre><p id="7c16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将用新的提交消息替换旧的提交消息。</p><p id="ba7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在其他情况下，您希望更改上次提交的部分代码，例如删除代码或添加更多代码。添加新文件很简单，一旦修改已经完成，就可以使用<code class="fe no np nq nr b">git commit --amend</code>来完成。这将把更改添加到以前的提交中，而不是创建一个新的。这方面的工作流示例如下所示:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="36bc" class="mj mk it nr b gy nw nx l ny nz">git add some_amazing_python.py<br/>git commit -m "Some amazing work"</span><span id="4ab2" class="mj mk it nr b gy oe nx l ny nz">#edit the files to remove an unecessary import<br/>#and make it cleaner</span><span id="c874" class="mj mk it nr b gy oe nx l ny nz">git add some_amazing_python.py<br/>git commit --amend --no-edit</span></pre><p id="5fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里添加了<code class="fe no np nq nr b">--no-edit</code>标志，因为我们不想改变提交消息，只改变文件。</p><h2 id="8cc5" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">附加功能</h2><p id="53a7" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">git具有广泛的功能，超出了像本文这样的小文章所能涵盖的范围。然而，另外两个有用的附加功能是<code class="fe no np nq nr b">git cherry-pick</code>和<code class="fe no np nq nr b">git stash</code>，因为它们经常在许多git工作流中使用。</p><p id="1fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">精挑细选</strong></p><p id="9656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">git cherry-pick</code>是一个有用的工具，它允许您从存储库中的任何地方复制单个提交的更改，并将其放在当前分支的开头。这可能是有用的，例如当您在不同的分支上共同处理类似的功能时，以减少生产中的错误数量，或者从代码库中的其他地方引入额外的功能。</p><p id="48b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe no np nq nr b">git cherry-pick</code>，您需要知道您感兴趣的变更的提交引用，然后使用:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="e1f2" class="mj mk it nr b gy nw nx l ny nz">git cherry-pick &lt;commit reference&gt;</span></pre><p id="76b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把在指定提交中所做的更改放在当前分支的顶部。</p><p id="5225" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Git stash </strong></p><p id="4e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其他情况下，你可能正在做一些代码，但是你不得不中途停下来做其他的事情。这可能是因为你的同事在一个bug上需要帮助，你有其他任务要完成，或者你想暂时做点别的事情。您所做的更改可能还没有准备好提交，但是您可能不想丢失您所做的更改。为此，可以使用<code class="fe no np nq nr b">git stash</code>来保存未提交的更改，您稍后可以访问这些更改，而无需进行新的提交。</p><p id="2c82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要想藏起来，你只需打电话:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="2cbd" class="mj mk it nr b gy nw nx l ny nz">git stash</span></pre><p id="7819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将从您对暂存和跟踪文件所做的所有更改中创建一个存储库。这将把它们从当前工作目录中删除，并恢复到上次提交时的状态。</p><p id="6965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您创建了存储并想要返回工作，您可以使用两个不同的命令来取回更改:</p><ul class=""><li id="5149" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu od mb mc md bi translated"><code class="fe no np nq nr b">git stash apply</code>——它将获取您存储在存储库中的更改，将它们应用到当前分支上的当前工作目录中，但会保持存储库完整，以备将来使用。</li><li id="b8ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu od mb mc md bi translated"><code class="fe no np nq nr b">git stash pop</code> —它还会将您存储在存储库中的更改应用到正确分支上的当前工作目录中，但在应用更改后会删除存储库。</li></ul><p id="6aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这很有用，但不应该经常使用，因为存储不像实际提交那样容易维护。</p><h2 id="7745" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">结论</strong></h2><p id="eb01" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Git是一个非常有用的工具，所有数据科学家和软件工程师都应该知道如何有效地使用它。这至少应该包括知道如何建立一个存储库，将它连接到一个远程数据源，创建和管理特性分支，以及能够在必要时撤销任何以前的提交。了解所有这些应该会给你信心去创建代码，并成为团队中一个有效的成员。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><p id="b9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一篇高度概括的文章，总结了在《走向数据科学》中已经发表的其他几篇文章。有关这些主题的详细解释，请访问以下链接:</p><div class="om on gp gr oo op"><a rel="noopener follow" target="_blank" href="/mastering-git-merge-and-rebase-f2a7c5c348a9"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">掌握Git:合并和重建基础</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">它们是什么，如何使用它们？</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener follow" target="_blank" href="/mastering-git-reset-v-revert-12701108a451"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">掌握Git:重置v还原</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">你应该使用哪一个，为什么？</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pe l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener follow" target="_blank" href="/mastering-git-git-cherry-pick-fbeb23eea04d"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">掌握Git: Git精选</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">如何将单个提交精选到您当前的分支</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pf l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener follow" target="_blank" href="/mastering-git-amending-commits-f46c2afc9508"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">掌握Git:修改提交</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">如何使用git amend更改您之前的提交</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="pg l pa pb pc oy pd ks op"/></div></div></a></div><div class="om on gp gr oo op"><a rel="noopener follow" target="_blank" href="/mastering-git-git-stash-cf4042dca068"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">掌握Git:“Git stash”</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">如何使用git stash来存储您不准备提交的更改</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">towardsdatascience.com</p></div></div><div class="oy l"><div class="ph l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>