<html>
<head>
<title>Measuring string similarity in BigQuery using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL度量BigQuery中的字符串相似性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/measuring-string-similarity-in-bigquery-using-sql-33c490638c89#2022-06-13">https://towardsdatascience.com/measuring-string-similarity-in-bigquery-using-sql-33c490638c89#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eba4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Levenshtein距离来发现相似或重复的值，清理您的数据，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05055f42a65838191c9b4fd87f10e222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n-sccYjDo2fSi-Qo"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由S <a class="ae ky" href="https://unsplash.com/@suraj09?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> uraj Kardile </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h2 id="9ffc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用Levenshtein距离方法</h2><p id="0f28" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">该方法可用于(Soundex，LIKE statement，Regexp)执行<strong class="lx iu">字符串相似性或字符串匹配</strong>，以识别两个相似但不相同的元素(文本、字符串、输入)。</p><p id="b16e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">此方法可用于各种应用程序，包括识别重复项、处理拼写错误的用户输入数据、清理客户数据等等。</p><blockquote class="mt"><p id="5fdf" class="mu mv it bd mw mx my mz na nb nc mn dk translated">Levenshtein方法的思想是计算两个字符串之间的最小编辑距离。</p></blockquote><p id="159c" class="pw-post-body-paragraph lv lw it lx b ly nd ju ma mb ne jx md li nf mf mg lm ng mi mj lq nh ml mm mn im bi translated">但是什么是“编辑”距离呢？它由三个动作组成:<strong class="lx iu">插入</strong>、<strong class="lx iu">替换</strong>、<strong class="lx iu">、</strong>删除。这三个动作被算法赋予相等的权重，基本上是1。</p><p id="b815" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了帮助理解这些机制，这里有几个例子:</p><ul class=""><li id="659e" class="ni nj it lx b ly mo mb mp li nk lm nl lq nm mn nn no np nq bi translated"><strong class="lx iu">Bigquer→Bigquery</strong>:<strong class="lx iu"/>字母<code class="fe nr ns nt nu b">y</code>加在最后，所以距离会是1(我们做了1个加法)。</li><li id="34fa" class="ni nj it lx b ly nv mb nw li nx lm ny lq nz mn nn no np nq bi translated"><strong class="lx iu">音乐→ mujic </strong> : <strong class="lx iu"> </strong>字母<code class="fe nr ns nt nu b">j</code>是来自音乐的字母<code class="fe nr ns nt nu b">s</code>的替换，距离也是1(我们做了1次替换)。</li><li id="ed61" class="ni nj it lx b ly nv mb nw li nx lm ny lq nz mn nn no np nq bi translated"><strong class="lx iu">薯条→ frij </strong> : <strong class="lx iu"> </strong>字母<strong class="lx iu"> </strong> <code class="fe nr ns nt nu b">french</code>和空格被<strong class="lx iu">追加</strong>，字母<code class="fe nr ns nt nu b">j</code>是<strong class="lx iu">代替<code class="fe nr ns nt nu b">e</code>，字母<code class="fe nr ns nt nu b">s</code>被<strong class="lx iu">删除</strong>。(我们增加了7处，替换了1处，删除了1处)</strong></li></ul><p id="6aa3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这种方法在比较一个完整字符串和另一个完整字符串时特别有效(在比较一个句子中的关键字或比较一个句子和另一个句子时效果较差)。</p><p id="47a8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">你可以在维基百科上找到关于该算法的更多信息。</p><div class="oa ob gp gr oc od"><a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">莱文斯坦距离-维基百科</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在信息论、语言学和计算机科学中，Levenshtein距离是一个字符串度量，用于测量…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><p id="0afc" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在我们已经学习了理论和应用，让我们看看如何在SQL中应用它。</p><h2 id="0ec1" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建持久函数</h2><p id="d884" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">您可以将UDF定义为持久的或临时的<strong class="lx iu">。</strong>主要区别在于持久函数可以被多个查询重用和访问(就像在项目中创建数据集一样),而临时函数只适用于您当前在编辑器中运行的查询。</p><p id="3ec9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">就个人而言，我喜欢使用我称之为<strong class="lx iu">实用程序</strong>的数据集，因为它允许我存储<strong class="lx iu">表和函数，我可以在其他数据集和查询中重用</strong>。</p><p id="e2e9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">下面是我们将在BigQuery中用到的<strong class="lx iu"> Javascript UDF函数</strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为Javascript UDF的Levenshtein距离函数</p></figure><p id="7a03" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当执行此查询时，它将出现在您的项目结构中，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/ea2ddae6e3d32cdf42dfc617df044a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MoR1ccr_4rpG_0JeCMRfoQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数出现在您指定的数据集中的例程下(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="c594" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">请注意，该函数不是返回版本数量的实际差异(如果我们做了1个加法，则返回1)，而是将<strong class="lx iu">返回一个0到1范围内的值</strong>。其中1表示完全相似，0表示完全不相似。</p><p id="84d1" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在我们的第一个理论示例中，<strong class="lx iu">big quer→big query</strong>:<strong class="lx iu"/>添加了字母<code class="fe nr ns nt nu b">y</code>，表示距离为1。我们的函数将首先计算版本数除以最长的输入字符串，在本例中，8个字符的<strong class="lx iu">big query</strong>(1个加法/ 8个长度)是距离。</p><p id="b230" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了得到相似度，<strong class="lx iu">我们简单的反过来，</strong>用1-(1/8) <strong class="lx iu"> = 0，875 </strong></p><p id="6205" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是首先，让我们看一个真实的SQL查询！</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h2 id="5737" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在SQL查询中使用函数</h2><p id="9c38" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">既然这个函数已经被保存为一个持久的UDF，您可以简单地通过写下它的位置来调用它。在我们的示例中，将使用以下方式调用它:</p><p id="6398" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><code class="fe nr ns nt nu b">`datastic.utility.levenshtein`(source,target)</code></p><p id="bbad" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们准备了几个案例来测试我们的方法产生的相似性得分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">评估Levenshtein距离函数的测试案例</p></figure><p id="5b96" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该查询将输出以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/fdf64b06dfcb9742eeff721eabe47d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*gkkeY5D-ZvBBmqdTFrAyig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们每个测试案例的Levenshtein距离的结果(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="15f5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">第一种情况，多了一个字母，导致两个词的相似度<strong class="lx iu">为0.88！</strong></p><p id="d26b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这两种极端情况也被证明:对于相同的单词组合<strong class="lx iu"> medium | medium </strong>，结果是相似度为1，而对于相反的单词组合<strong class="lx iu"> france | PIzz </strong>，结果是相似度为0。</p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><h2 id="9ee1" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">公开可用数据的真实示例</h2><p id="82e0" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们想要解决的用例是<strong class="lx iu">从我们的CRM </strong>中更正用户国家数据。我们注意到有很多拼错的数据，我们将使用BigQuery公共数据来帮助我们。</p><p id="fceb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该表包含BigQuery提供的数据，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4d58" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">并包含以下格式的所有国家名称:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/c6422f012586a5a515edb66e989edcea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*wlb4FPMa42RLm2SCGm1hIA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">BigQuery公共国家数据表(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="f5bd" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">现在，我们的CRM数据表包含以下信息，<strong class="lx iu">一封电子邮件和一个国家</strong>(显然有一些拼错的单词)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/3db49a7c4b7b3545b655700bf7f8e7ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*OYymQYYUFE4korNrUuyEdQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的客户数据表(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="a8bb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">让我们尝试解决我们现实世界的用例。为此，我们将执行以下查询，该查询由四个步骤组成:</p><ul class=""><li id="9e99" class="ni nj it lx b ly mo mb mp li nk lm nl lq nm mn nn no np nq bi translated">从BigQuery加载国家数据</li><li id="a8de" class="ni nj it lx b ly nv mb nw li nx lm ny lq nz mn nn no np nq bi translated">正在加载我们的CRM数据</li><li id="908e" class="ni nj it lx b ly nv mb nw li nx lm ny lq nz mn nn no np nq bi translated">应用一个<code class="fe nr ns nt nu b">CROSS JOIN</code>语句并计算我们的Levenshtein函数</li><li id="4812" class="ni nj it lx b ly nv mb nw li nx lm ny lq nz mn nn no np nq bi translated">对结果进行排序，找出最相似的国家</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5a88" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">还有，塔达姆🎉，结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/6c66ecfb9cb3ee4f8019180eff3e9555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*6bgr8pnseFVtVc3PGbYSNg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Levenshtein函数在我们的CRM数据集上的结果(图片由作者提供)</p></figure><p id="7c83" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">正如你所看到的，这个方法有一些注意事项，因为我们有时会返回多行，因为两组字符串非常相似(这是西班牙<strong class="lx iu">的情况，西班牙</strong>与西班牙<strong class="lx iu">相似，巴林和台湾</strong></p><p id="a8b8" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们决定使用一个<code class="fe nr ns nt nu b">CROSS JOIN</code>语句来连接我们的两个数据表。这意味着我们将把CRM表中的每一行与country表中所有可能的国家进行比较。在我们的示例中，我们的CRM数据有7行，我们的国家数据集有250行，这将产生结果<strong class="lx iu"> 7x250=1750行</strong>。</p><p id="a81c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">通过使用QUALIFY子句对最相似的国家进行排名，可以减少这一结果，但是根据您的使用情况，<code class="fe nr ns nt nu b">CROSS JOIN</code>解决方案将需要大量的计算。</p><h2 id="9c30" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">利用更大的数据集走得更远</h2><p id="7273" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">对于我们的例子，我们使用了一个小的CRM数据集(7行)。相比之下，我在一个拥有<strong class="lx iu">800万客户</strong>的数据集上重用了同一个country表(250行)，使用BigQuery 花费了大约<strong class="lx iu"> 33秒，这还是相当快的。如果您要使用更大的数据集(可能有数十亿行)，那么我会推荐使用数组而不是使用连接，在BigQuery中使用连接会减少所需的资源。</strong></p><p id="b47e" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">要解决的第二个困难是当我们的Levenshtein距离函数返回多个结果时选择最佳相似性。我的建议是将Levenshtein方法与其他方法结合起来，如正则表达式或Soundex，这将为相似性得分提供额外的权重，并可能允许更好的选择。</p></div></div>    
</body>
</html>