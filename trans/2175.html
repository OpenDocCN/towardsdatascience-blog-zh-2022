<html>
<head>
<title>6 Techniques to Power Feature Engineering in Your Next Machine Learning Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的下一个机器学习项目中支持特征工程的6种技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/6-tips-to-power-feature-engineering-in-your-next-machine-learning-project-d61530eee11b#2022-05-15">https://towardsdatascience.com/6-tips-to-power-feature-engineering-in-your-next-machine-learning-project-d61530eee11b#2022-05-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="5d08" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">从数据创建新要素的技术</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ad9edc428ffc1ba6a31d83cf3211e38f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Myn0QCinyB33NKD2"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Vishnu Mohanan 在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="cc18" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">什么是特征工程？</h1><p id="be61" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">机器学习中的特征工程是从现有数据中创建新特征。从学习的角度来看，原始数据中包含的信息可能是不够的。因此，您可能需要将这些数据转换为新的要素或列，以帮助您以更有助于学习的方式表示数据。建立模型的一般过程如下。</p><ol class=""><li id="296e" class="mo mp iu lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/exploratory-data-analysis-with-python-1b8ae98a61c5">探索性数据分析，包括数据清洗</a></li><li id="4847" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">特征工程(本文)</li><li id="cd48" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/4-methods-to-power-feature-engineering-for-your-next-ml-model-5d32fffbe511">功能选择</a></li><li id="e8bd" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/demystify-machine-learning-model-selection-e3f913bab7e7">型号选择</a></li><li id="ecb8" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><a class="ae kz" rel="noopener" target="_blank" href="/evaluating-ml-models-with-a-confusion-matrix-3fd9c3ab07dd">模型训练和评估</a></li></ol><p id="524e" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">在所有这些步骤中，<strong class="lu iv">可以说最重要的是特征工程</strong>步骤。通过仅默认原始数据，您可能会错过提供有价值的上下文来解释行为发生的原因。无论是预测用户还是机器的行为，特征工程对于项目的成功都是至关重要的。可能需要做些什么的几个例子:</p><ol class=""><li id="ba6d" class="mo mp iu lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated">缩放数字数据和编码分类数据</li><li id="ab13" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">将长格式文本转换成数值</li><li id="df99" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">计算日期或时间之间的差异</li><li id="1ea9" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">将数据聚合到一行中，例如求和、计数或计算平均值</li><li id="39af" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">创建聚合日期窗口</li><li id="d618" class="mo mp iu lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">将来自不同来源的数据合并到一组观测数据中</li></ol><p id="cc50" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">我喜欢维基百科上提供的定义。它总结了使用领域知识提取新特征的思想:</p><p id="31d0" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated"><em class="nh">特征工程或特征提取是利用领域知识从原始数据中提取特征(特性、性质、属性)的过程。与仅向机器学习过程提供原始数据相比，动机是使用这些额外的特征来提高来自机器学习过程的结果的质量。</em></p><p id="3bd8" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">我们可以从这一点开始。领域知识。</p><h1 id="8e4e" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">领域知识</h1><p id="e02a" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">特征工程的一个关键部分是将<strong class="lu iv">业务</strong>和<strong class="lu iv">领域知识</strong>应用到您的数据中，以创建最佳特征。关于如何创建要素，并没有单一的方法或规则，但是许多方法都要求您了解它们可能相关的背景。</p><p id="4d0e" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">在本例中，我们将使用的数据集是由作者合成生成的，代表购买软件的公司，并随机生成使用数据来模拟用户在日常使用软件时可能尝试的事件。</p><p id="7f14" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">在集思广益讨论您可能想要创建的功能时，请考虑数据的背景。我们将创建几个特征来表示帐户对此的活跃程度。我们将在下面演示其中的一些。</p><p id="5e59" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">首先，我们需要理解数据的结构和关系。</p><h1 id="d358" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">理解我们的数据结构</h1><p id="82a4" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">让我们用一个<a class="ae kz" href="https://www.lucidchart.com/pages/er-diagrams" rel="noopener ugc nofollow" target="_blank">实体关系图</a>或ERD来看这个可视化。实体关系图是可视化信息表格的最佳方式。我们可以在单个图像中看到我们需要的一切以及来自列、类型和关系的数据。</p><p id="2ae4" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">在我们的第一个表<strong class="lu iv"> OPPORTUNITIES </strong>中，我们有一个<strong class="lu iv">组合键</strong>，它构成了由<strong class="lu iv"> ACCOUNT_ID </strong>、<strong class="lu iv"> OPPORTUNITY_ID </strong>、<strong class="lu iv"> RENEWAL_DATE </strong>和<strong class="lu iv"> PRODUCT_CODE </strong>组成的<strong class="lu iv">主键</strong>。主键允许我们唯一地识别一个机会。在<strong class="lu iv">事件</strong>表中，我们有一个<strong class="lu iv">外键</strong>与<strong class="lu iv"> ACCOUNT_ID </strong>的关系。对于每个账户，我们有零到多个潜在事件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ni"><img src="../Images/34c0e1225be51f29afec21f3d9b88a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ESsl4WMidd-eU2bN.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者图片</p></figure><p id="34f1" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">现在我们对数据结构有了一个大致的了解，我们可以导入我们的数据并开始特征工程的过程。</p><h1 id="a3a8" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">加载和清理数据</h1><p id="42fa" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">第一步是加载和清理我们的数据。在这里，我们还可以了解数据的大小和形状。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="8145" class="no lb iu nk b be np nq l nr ns">import pandas as pd<br/><br/>df_opp = pd.read_csv('opps.csv')<br/>df_event = pd.read_csv('events.csv')<br/><br/>print(df_opp.shape)<br/>print(df_event.shape)</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="9116" class="no lb iu nk b be np nq l nr ns">(1000, 8)<br/>(1000000, 7)</span></pre><p id="d069" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">我们看到大约有1，000个机会和1，000，000个事件。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="99f6" class="no lb iu nk b be np nq l nr ns">df_opp.info()</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="6156" class="no lb iu nk b be np nq l nr ns">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 1000 entries, 0 to 999<br/>Data columns (total 7 columns):<br/> #   Column      Non-Null Count  Dtype <br/>---  ------      --------------  ----- <br/> 0   ACCOUNT_ID  1000 non-null   object<br/> 1   OPP_ID      1000 non-null   object<br/> 2   ORDER_DATE  1000 non-null   object<br/> 3   PRODUCT     1000 non-null   object<br/> 4   QUANTITY    1000 non-null   int64 <br/> 5   START       998 non-null    object<br/> 6   END         998 non-null    object<br/>dtypes: int64(1), object(6)<br/>memory usage: 54.8+ KB</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="74f4" class="no lb iu nk b be np nq l nr ns">df_event.info()</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="0ad7" class="no lb iu nk b be np nq l nr ns">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 1048575 entries, 0 to 1048574<br/>Data columns (total 7 columns):<br/> #   Column      Non-Null Count    Dtype <br/>---  ------      --------------    ----- <br/> 0   ACCOUNT_ID  1048575 non-null  object<br/> 1   COMPANY_ID  1048575 non-null  object<br/> 2   USER_ID     1048575 non-null  object<br/> 3   PROJECT_ID  977461 non-null   object<br/> 4   DATE        1048575 non-null  object<br/> 5   TYPE        1048575 non-null  object<br/> 6   COUNT       1048575 non-null  int64 <br/>dtypes: int64(1), object(6)<br/>memory usage: 56.0+ MB</span></pre><p id="5f06" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">这两个表主要包含带有一个数字列的字符串(对象)。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="846c" class="no lb iu nk b be np nq l nr ns">df_event.head()</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="c267" class="no lb iu nk b be np nq l nr ns">ACCOUNT_ID COMPANY_ID USER_ID PROJECT_ID       DATE<br/>0  account420       org1      u1         p1 2019-05-10   <br/>1  account399       org2      u2         p2 2019-05-06   <br/>2  account399       org2      u3         p3 2019-06-24   <br/>3  account122       org3      u4         p4 2019-04-30   <br/>4   account61       org4      u5         p5 2019-08-07   <br/><br/>                                                TYPE  COUNT  <br/>0  099664351c56c479154c4b1e649a727e3ac099cc26747c...      3  <br/>1  78478722fa50547376912d1bc1b21d5f5fb60188015342...      1  <br/>2  9e5fd45ed38136db73e76b46ad11a0200b7a4cbaae9bc1...      2  <br/>3  85c11686c1e1d3072f30b05ff74fd93b92c5d37a1b7ba3...      1  <br/>4  31ea88da80c3371a7e70ac8a9299974290c47e83b46170...      1</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="7148" class="no lb iu nk b be np nq l nr ns">df_opp.head()</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="3668" class="no lb iu nk b be np nq l nr ns">ACCOUNT_ID OPP_ID ORDER_DATE<br/>0   account1   opp1 2020-04-23   <br/>1   account1   opp1 2020-04-23   <br/>2   account2   opp2 2020-04-16   <br/>3   account2   opp2 2020-04-16   <br/>4   account3   opp3 2020-04-09   <br/><br/>                                             PRODUCT  QUANTITY<br/>0  cd5ba48bb6ce3541492df6f2282ca555a65397c168dc59...         4<br/>1  1a5a6aac31b1d9e08401bd147df106c600254b2df05a3f...         2<br/>2  28746a25d12d36a1c0956436cfd6959f0db252e3020928...         1<br/>3  1a5a6aac31b1d9e08401bd147df106c600254b2df05a3f...         8<br/>4  1a5a6aac31b1d9e08401bd147df106c600254b2df05a3f...         3<br/><br/>         START         END  <br/>0 2020-04-24    2021-04-23  <br/>1 2020-04-24    2021-04-23  <br/>2 2020-04-17    2021-04-16  <br/>3 2020-04-17    2021-04-16  <br/>4 2020-04-10    2021-04-09</span></pre><p id="4c6b" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">这个过程的一个典型部分是确保我们没有空值。在检查了数据(未显示)之后，我们有了一些东西。在我们的<strong class="lu iv"> OPP </strong>表中有一些空值，为了简单起见，我们将删除这些空值，对于<strong class="lu iv">事件</strong>表，<strong class="lu iv">项目标识</strong>有一些空值，我们可以用另一个值填充，例如<strong class="lu iv">公司标识</strong>。需要理解处理空值的业务环境；这只是两个例子。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="6fe7" class="no lb iu nk b be np nq l nr ns"># Drop any null values from important variables<br/>df_opp.dropna(inplace=True)<br/><br/># Fill any missing PROJECT_IDS with the COMPANY_ID<br/>df_event['PROJECT_ID'].fillna(df_event['COMPANY_ID'], inplace=True)</span></pre><h1 id="7151" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">缩放数字数据和编码分类数据</h1><p id="2042" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">一个非常简单的数据转换是对数字数据进行缩放和对分类数据进行编码。虽然数据的数值缩放不是特征工程，但它很重要，因为许多算法不喜欢未缩放的数据。</p><p id="9421" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">转换分类数据的一种常见方法是使用一种称为<strong class="lu iv">单热编码</strong>或<strong class="lu iv"> OHE </strong>的过程。OHE获取分类数据并将它们扩展到新列中，其中每个分类值都有一个新列，一个二进制值指示该分类是否在该行中。OHE阻止模型预测序数值之间的值。更多关于OHE的信息，请查看:<a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">一个热门编码</a>。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="39e0" class="no lb iu nk b be np nq l nr ns">column_trans = ColumnTransformer(transformers=<br/>        [('num', MinMaxScaler(), selector(dtype_exclude="object")),<br/>        ('cat', OneHotEncoder(), selector(dtype_include="object"))],<br/>        remainder='drop')</span></pre><p id="9131" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">这方面的典型过程是包装和利用柱变压器。你可以在这里阅读更多关于这个过程的内容:<a class="ae kz" rel="noopener" target="_blank" href="/using-pipelines-in-sci-kit-learn-516aa431dcc5">停止一步一步地构建你的模型。利用管道实现流程自动化！</a></p><h1 id="6f41" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">将长格式文本转换为数值</h1><p id="86e3" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">处理长文本数据的另一种常见方法是将文本的<strong class="lu iv">长度</strong>表示为一个<strong class="lu iv">数字</strong>，这在产品评论等情况下很有用。例如，长篇评论通常与更多负面或正面评论联系在一起吗？是不是越长的评论越有用，与之相关的产品就越畅销？您可能需要对此进行试验。我们的数据集没有长格式文本，但这里有一个如何做到这一点的例子。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="0d63" class="no lb iu nk b be np nq l nr ns">df['text_len'] = df.apply(lambda row: len(row['text']), axis = 1)</span></pre><h1 id="c090" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">计算日期或时间之间的差异</h1><p id="d9c5" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">通常，日期本身在机器学习中不是一个有用的特征。与2012年5月1日相比，2021年1月5日意味着什么？我们需要把这些转化成对学习更有用的东西。例如，无论客户是否会继续购买或订阅我们的理论产品，我们都在谈论销售机会。可能更有用的是捕捉客户最近是否活跃。不活跃的客户很可能不会重新购买我们的软件。</p><p id="bcfb" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">首先，您需要确保任何日期实际上都是日期-时间格式。为此，我们可以利用Pandas <code class="fe nu nv nw nk b">to_datetime</code>功能。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="1a29" class="no lb iu nk b be np nq l nr ns"># Convert dates to datetime type<br/>df_event['DATE'] = pd.to_datetime(df_event['DATE'])<br/>df_opp['ORDER_DATE'] = pd.to_datetime(df_opp['ORDER_DATE'])<br/>df_opp['START'] = pd.to_datetime(df_opp['START'])<br/>df_opp['END'] = pd.to_datetime(df_opp['END'])</span></pre><p id="7c57" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">接下来，我们可以构建新的列来表示自他们上次使用软件以来的天数。在我们转换成日期-时间格式后，这是一个简单的减法操作，并将其存储为一个名为<strong class="lu iv"> DAYS_LAST_USED </strong>的新列。</p><p id="b57d" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated"><strong class="lu iv">注意:</strong> <em class="nh">这个计算在我们的笔记本中是最后完成的，但是更适合这篇文章。</em></p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="484c" class="no lb iu nk b be np nq l nr ns"># Add a column for the number of days transpired since the last known event and the renewal date<br/>df['DAYS_LAST_USED'] = (df['ORDER_DATE'] - df['DATE']).dt.days</span></pre><h1 id="5d3c" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">将数据聚合到一行中，例如求和、计数或计算平均值</h1><p id="8272" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">关键的一步是确保我们只有一行或<strong class="lu iv">一个观察来代表每个独特的机会</strong>。正如我们在导入过程中看到的那样，有1，000个客户，但有1，000，000个事件。我们需要将每个客户或机会的事件汇总到一行中。对于我们的例子，我们将通过<strong class="lu iv"> ACCOUNT_ID </strong>来聚集事件。</p><p id="ba48" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated"><strong class="lu iv">熊猫</strong>对此有一个惊人的特点<code class="fe nu nv nw nk b">groupby</code>叫<code class="fe nu nv nw nk b">.agg</code>。我们可以在一次操作中用不同的聚合操作符聚合所有的列。在这里，您可以传递一个类似于<code class="fe nu nv nw nk b">sum</code>或<code class="fe nu nv nw nk b">count</code>的字符串。你可以使用像<code class="fe nu nv nw nk b">mean</code>和<code class="fe nu nv nw nk b">std</code>这样的Numpy函数，甚至可以传递一个自定义函数；它非常强大。点击阅读更多<a class="ae kz" href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.SeriesGroupBy.aggregate.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4b84" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">注意<code class="fe nu nv nw nk b">nunique</code>——这是一种计算一列中唯一值数量的强大方法。对于分类数据非常强大。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="9010" class="no lb iu nk b be np nq l nr ns">df_agg = df_event.groupby(['ACCOUNT_ID'], as_index=False).agg(<br/>    {<br/>        # how many unique projects are they using <br/>        'PROJECT_ID':"nunique", <br/><br/>        # how many different unique orgs <br/>        'COMPANY_ID':"nunique", <br/><br/>        # how many total unique users <br/>        'USER_ID':'nunique', <br/><br/>        # are the using the software recently<br/>        'DATE':max, <br/><br/>        # how many different features are they using <br/>        'TYPE':"nunique", <br/><br/>        # what is their utilization <br/>        'COUNT':sum <br/>    }<br/>)<br/><br/>df_agg.head()</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="0b21" class="no lb iu nk b be np nq l nr ns">ACCOUNT_ID  PROJECT_ID  COMPANY_ID  USER_ID       DATE  TYPE  COUNT<br/>account1             6           1        6 2019-09-23    21    216<br/>account10          116           1       19 2019-10-23   309  87814<br/>account100           9           1        5 2019-10-29   188   1582<br/>account101           3           1        1 2019-09-18    31    158<br/>account102          35           1        3 2019-10-30   214  14744</span></pre><p id="d018" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">聚合完成后，我们现在有了一个简单的数据框，其中每一列都有一个数字表示，包括产品最后一次使用的最大日期，然后可以使用它将其转换为数值，如上所示。</p><h1 id="510d" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">创建聚合日期窗口</h1><p id="c4ca" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">另一个优秀的特性工程技术是基于滚动时间框架创建不同的聚合计数。例如，客户在过去一周、一个月或一个季度的活跃程度如何？与计算自帐户上次活动以来的天数类似，我们计算了这些时间窗口内的使用量。当然，越来越多的活跃用户，越来越近，越来越有可能暗示着继续使用软件的愿望。</p><p id="dbf8" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">Pandas在处理<strong class="lu iv">时间序列数据</strong>方面具有令人难以置信的功能。你可以在这里了解更多信息。使用时间序列函数的一个注意事项是，您需要一个基于日期时间的索引。所以我们要做的第一件事是将索引设置到我们的<strong class="lu iv">日期</strong>列。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="2f8a" class="no lb iu nk b be np nq l nr ns">df_ts = df_event.set_index('DATE')</span></pre><p id="35d1" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">接下来，我们可以使用一个操作，该操作允许我们通过<code class="fe nu nv nw nk b">last</code>天数(周、月、年)来<strong class="lu iv">聚合</strong>,并使用一个<code class="fe nu nv nw nk b">groupby</code>操作和聚合器，比如我们上面所做的<code class="fe nu nv nw nk b">sum</code>。因为我们想要存储其中的一些值，所以我们将首先计算它们，将它们保存为新的数据框，并将该列重命名为更具描述性的名称。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="c820" class="no lb iu nk b be np nq l nr ns">df_14 = df_ts.last('14D').groupby('ACCOUNT_ID')[['COUNT']].sum()<br/>df_14.rename(columns={"COUNT": "COUNT_LAST_14"}, inplace=True)<br/><br/>df_30 = df_ts.last('30D').groupby('ACCOUNT_ID')[['COUNT']].sum()<br/>df_30.rename(columns={"COUNT": "COUNT_LAST_30"}, inplace=True)<br/><br/>df_60 = df_ts.last('60D').groupby('ACCOUNT_ID')[['COUNT']].sum()<br/>df_60.rename(columns={"COUNT": "COUNT_LAST_60"}, inplace=True)</span></pre><p id="dc4a" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">最后，我们将<code class="fe nu nv nw nk b">merge</code>这些放回到我们的主聚合数据框架中，添加我们的三个新特性。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="d1fe" class="no lb iu nk b be np nq l nr ns">df_agg = pd.merge(df_agg, df_14, on="ACCOUNT_ID", how='left')<br/>df_agg = pd.merge(df_agg, df_30, on="ACCOUNT_ID", how='left')<br/>df_agg = pd.merge(df_agg, df_60, on="ACCOUNT_ID", how='left')<br/><br/># Finally - fill null values with Zeros for future modeling<br/>df_agg.fillna(0, inplace=True)</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="7dae" class="no lb iu nk b be np nq l nr ns">df_agg.sample(10)</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="cd55" class="no lb iu nk b be np nq l nr ns">COUNT_LAST_14  COUNT_LAST_30  COUNT_LAST_60  <br/>340        12107.0        46918.0          87659  <br/>472           88.0         1502.0           2042  <br/>295           47.0          262.0            412  <br/>453          955.0         5921.0          13915  <br/>242          175.0          663.0            946  <br/>286          165.0         1106.0           2066  <br/>461          469.0         3722.0           7984  <br/>85           503.0         1954.0           4183  <br/>46           157.0         1808.0           3165  <br/>444            0.0            2.0              2</span></pre><h1 id="f448" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">将来自不同来源的数据合并到一组观测数据中</h1><p id="11bb" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">最后，我们需要将我们新聚合的<strong class="lu iv">事件</strong>表和我们所有的特性合并到<strong class="lu iv"> OPPS </strong>数据框架中。我们可以用上面同样的<code class="fe nu nv nw nk b">merge</code>函数来做这件事。</p><pre class="kk kl km kn gu nj nk nl bn nm nn bi"><span id="372b" class="no lb iu nk b be np nq l nr ns"># Merge the datasets on Account ID<br/>df = pd.merge(df_opp, df_agg, on="ACCOUNT_ID")<br/>df</span></pre><pre class="nt nj nk nl bn nm nn bi"><span id="6f25" class="no lb iu nk b be np nq l nr ns">ACCOUNT_ID OPP_ID ORDER_DATE<br/>0   account1   opp1 2020-04-23   <br/>1   account1   opp1 2020-04-23   <br/>2   account2   opp2 2020-04-16   <br/>3   account2   opp2 2020-04-16   <br/>4   account3   opp3 2020-04-09   <br/><br/>                                  PRODUCT    QUANTITY      START<br/>0  cd5ba48bb6ce3541492df6f2282ca555a65...           4 2020-04-24<br/>1  1a5a6aac31b1d9e08401bd147df106c6002...           2 2020-04-24<br/>2  28746a25d12d36a1c0956436cfd6959f0db...           1 2020-04-17<br/>3  1a5a6aac31b1d9e08401bd147df106c6002...           8 2020-04-17<br/>4  1a5a6aac31b1d9e08401bd147df106c6002...           3 2020-04-10<br/><br/>         END  PROJECT_ID       DATE  DAYS_LAST_USED  TYPE  COUNT<br/>0 2021-04-23           6 2019-09-23             213    21    216<br/>1 2021-04-23           6 2019-09-23             213    21    216<br/>2 2021-04-16          22 2019-10-16             183   185  19377<br/>3 2021-04-16          22 2019-10-16             183   185  19377<br/>4 2021-04-09          27 2019-10-08             184    64    556<br/><br/>   COUNT_LAST_14  COUNT_LAST_30  COUNT_LAST_60  DAYS_LAST_USED  <br/>0            7.0          136.0            216             213  <br/>1            7.0          136.0            216             213  <br/>2         1157.0        10109.0          19314             183  <br/>3         1157.0        10109.0          19314             183  <br/>4            7.0          372.0            556             184</span></pre><p id="5e92" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">现在你知道了！在我们最终的数据框中，我们有大约1000行(删除了空值后)附加了新创建的要素。我们可以基于这些新特征来执行特征选择。</p><p id="5609" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">关于本文的完整代码，请访问<a class="ae kz" href="https://github.com/broepke/FeatureEngineering" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><h1 id="d45f" class="la lb iu bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">结论</h1><p id="831b" class="pw-post-body-paragraph ls lt iu lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn in bi translated">特征工程可以说是机器学习中最关键的一步。特征工程通过使用领域和业务知识从数据中构造新信息，在数据中创建新列。我们讨论了处理分类数据的多种技术、处理日期时间数据的多种方法，以及如何将多个观察值聚合成可以合并回原始数据的新表示。虽然这只是触及了这个话题的表面，但我希望它能让你开始你的旅程！</p><p id="3c17" class="pw-post-body-paragraph ls lt iu lu b lv mq jv lx ly mr jy ma mb ne md me mf nf mh mi mj ng ml mm mn in bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，考虑注册成为一名媒体成员。一个月5美元，让你可以无限制地访问成千上万篇文章。如果你使用 <a class="ae kz" href="https://medium.com/@broepke/membership" rel="noopener"> <em class="nh">我的链接</em> </a> <em class="nh">注册，我会赚一小笔佣金，不需要你额外付费。</em></p></div></div>    
</body>
</html>