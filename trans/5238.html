<html>
<head>
<title>The Easiest Way to Forecast Time Series Using N-BEATS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 N 拍预测时间序列的最简单方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-easiest-way-to-forecast-time-series-using-n-beats-d778fcc2ba60#2022-11-23">https://towardsdatascience.com/the-easiest-way-to-forecast-time-series-using-n-beats-d778fcc2ba60#2022-11-23</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="2416" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">从理论到实践，了解 N-BEATS 的工作原理，并使用 Python 将其应用到实际预测项目中</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/2d110ea7ebf1eabb912784832c4a697e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rsvfS94A5u8oMoyf"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>由<a class="ae la" href="https://unsplash.com/@pablodelafuente?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pablo de la Fuente </a>拍摄的照片</p></figure><p id="9aa1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果你和我一样，对时间序列预测感兴趣，很可能你偶然发现了 N-BEATS 模型。该模型承诺使用纯深度学习架构获得最先进的结果。换句话说，它不需要时间序列的特定成分，如趋势或季节性。</p><p id="1a2b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你可能读过 Oreshkin 等人写的关于 N-BEATS 的<a class="ae la" href="https://arxiv.org/pdf/1905.10437.pdf" rel="noopener ugc nofollow" target="_blank"> 2020 论文</a>。虽然这篇论文信息量很大，但它并不容易阅读，你在这里可能意味着你同意我的观点。</p><p id="d52c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">所以，在这篇文章中，我将首先使用更多的直觉和更少的等式来解释 N-BEATS。然后，我将使用 Python 将它应用于现实生活中的预测场景，并评估它的性能。</p><p id="0dab" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们开始吧！</p><blockquote class="lx"><p id="242a" class="ly lz iv bd ma mb mc md me mf mg lw dk translated"><strong class="ak"> <em class="mh">用 Python 中我的</em> </strong> <a class="ae la" href="https://www.datasciencewithmarco.com/pl/2147608294" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> <em class="mh">免费时间序列小抄</em> </strong> </a> <strong class="ak"> <em class="mh">学习最新的时间序列分析技巧！获得统计和深度学习技术的实现，全部在 Python 和 TensorFlow 中！</em>T19】</strong></p></blockquote><h1 id="7eea" class="mi mj iv bd mk ml mm mn mo mp mq mr ms kb mt kc mu ke mv kf mw kh mx ki my mz bi translated">理解 N 节拍</h1><p id="c479" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">N-BEATS 代表<strong class="ld iw">N</strong>eural<strong class="ld iw">B</strong>as<strong class="ld iw">E</strong>x expansion<strong class="ld iw">A</strong>analys 代表<strong class="ld iw">I</strong>N<strong class="ld iw">T</strong>ime<strong class="ld iw">S</strong>系列。</p><p id="1380" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">顾名思义，N-BEATS 的核心功能在于<strong class="ld iw">基础扩展</strong>。因此，在深入模型的架构之前，让我们首先澄清什么是基础扩展。</p><h2 id="1b5f" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">基础扩展</h2><p id="7947" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">基础扩展是一种扩充数据的方法。这通常是为了模拟非线性关系。</p><p id="e581" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">常见的基展开是多项式基展开。例如，假设我们只有两个特性，如下所示。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/323639f50c834f28deeedabd90932d37.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*VGYtAMImaCj8JlNYfP_-5Q.png"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">一组两个特征。图片由作者提供。</p></figure><p id="960f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，如果我们进行 2 次多项式基展开，我们的特征集变成:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ns"><img src="../Images/0eaf94388f423a792f4180d51f0e5fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*Pajhn8LyqvjlsSIjoq0J8w.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">特征集上 2 次多项式基展开的结果。我们注意到，我们只是简单地将现有特征的平方相加。这允许我们拟合二次模型，以便我们可以捕捉非线性关系。图片由作者提供。</p></figure><p id="d97c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如您所见，2 次多项式基展开的结果是我们简单地将我们的特征的平方添加到特征集中。</p><p id="4025" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，这意味着我们现在可以用二次多项式模型来拟合我们的数据，有效地模拟非线性关系！</p><p id="01be" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当您对数据进行线性趋势或多项式曲线拟合时，这基本上就是在 Excel 中发生的事情。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nt"><img src="../Images/37c32c620fe62901a0695933c57f0237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a83WD1Krmb3ljFeblr7juw.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">基础扩展前(左)和基础扩展后(右)。在左边，我们停留在线性模型上，但是添加特征的平方允许我们有一个更适合的非线性模型。图片由作者提供。</p></figure><p id="d4d9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看上面的图，我们可以看到，当我们不进行基展开时，我们只有一条直线，如左图所示。然而，在右边，一旦我们执行了 2 次多项式基展开，我们就得到一个二次模型，它与我们的数据更加吻合。</p><p id="b69a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当然，基展开并不限于多项式；我们可以计算对数、幂等。主要的收获是，基础扩展用于增加我们的特征集，以便对非线性关系建模。</p><p id="5af4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在 N 拍的情况下，基展开不是我们定的。取而代之的是，该模型被训练来寻找最佳的基展开方法，以便拟合数据并进行预测。换句话说，我们让神经网络找到最佳的数据扩充方法来拟合我们的数据集，因此得名:神经基础扩展。</p><p id="9d15" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们已经熟悉了基础扩展的概念，让我们继续讨论模型的架构。</p><h2 id="a38c" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated"><strong class="ak">N 拍的架构</strong></h2><p id="079d" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">在设计 N-BEATS 的架构时，有三个关键原则:</p><ol class=""><li id="d52d" class="nu nv iv ld b le lf lh li lk nw lo nx ls ny lw nz oa ob oc bi translated">基础架构应该简单、通用，但富有表现力</li><li id="4d5f" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi translated">该架构不应依赖于特定于时间序列的组件(如趋势或季节性)</li><li id="2731" class="nu nv iv ld b le od lh oe lk of lo og ls oh lw nz oa ob oc bi translated">该架构是可扩展的，以使输出可解释</li></ol><p id="85e9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">基于这些考虑，N-BEATS 的创造者设计了这样一个模型:</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi oi"><img src="../Images/dab0a25167c2bc7b2b553dc6039b3a9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dfmx9FMpWHJR61RKpfsk0A.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">N 拍的架构。图片由 B. Oreshkin、D. Carpov、N.Chapados 和 Y. Bengio 拍摄，来自<a class="ae la" href="https://arxiv.org/pdf/1905.10437.pdf" rel="noopener ugc nofollow" target="_blank"> N-BEATS:可解释时间序列预测的神经基础扩展分析</a></p></figure><p id="cb27" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从上图可以吸收很多信息，一步一步来。</p><p id="f001" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从图的右上方看，我们可以看到一个时间序列分为回顾期和预测期。回望期提供给模型，而预测期包含允许我们评估模型预测的实际值。</p><p id="f084" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请注意，输入序列的长度是预测长度的倍数。因此，对于长度为<em class="oj"> H </em>的预测范围，输入序列通常应该具有从 2 <em class="oj"> H </em>到 6 <em class="oj"> H </em>的长度。</p><p id="461f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后在上图中从右到左，我们看到 N-BEATS(右边黄色矩形)是由分层的<em class="oj">栈</em>组成的，这些栈本身又是由<em class="oj">块</em>(中间橙色矩形)组成的，我们可以看到每个<em class="oj">块</em>是如何构造的(左边蓝色矩形)。</p><p id="d458" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们可以看到一个<em class="oj">块</em>由四个完全连接的层组成。这个网络产生两样东西:一个预测和一个反向预测。预测只是对未来值的预测，而反向预测是来自模型的值，我们可以立即将其与输入序列进行比较，并评估模型的拟合度。</p><p id="6e89" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">注意，网络在<em class="oj">块</em>级找到扩展系数(在图中表示为<em class="oj">θ</em>)，然后执行基扩展(在图中表示为函数<em class="oj"> g </em>)。</p><p id="7f63" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这种架构中，只有第一个<em class="oj">模块</em>获得实际的输入序列。随后的<em class="oj">块</em>获得来自第一<em class="oj">块</em>的残差。这意味着只有未被第一个<em class="oj">模块</em>捕获的信息被传递到下一个模块。</p><p id="4f8c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这导致输入序列的顺序处理，其中每个<em class="oj">模块</em>试图捕捉前一个模块遗漏的信息。</p><p id="f189" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">将不同的<em class="oj">块</em>组合在一起，然后给我们一个<em class="oj">堆栈</em>，它输出一个部分预测。然后，我们将更多的<em class="oj">堆栈</em>添加到模型中，并且每个<em class="oj">堆栈</em>将输出其部分预测。然后，每个部分预测的组合产生最终预测。</p><h2 id="76c3" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">使模型可解释</h2><p id="8a76" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">在这一点上，我们理解了 N-BEATS 的内部工作原理，但是这个模型究竟如何解释呢？</p><p id="3ede" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，它不是。负责基扩展的函数，在图中表示为<em class="oj"> g </em>，是一个可学习的函数。这意味着我们让神经网络设计一个特定于问题的函数来获得最佳结果。</p><p id="e417" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然而，将函数<em class="oj"> g </em>限制在我们能理解的范围内是可能的。在时间序列预测中，我们经常使用趋势和季节性等元素来通知我们的预测，我们可以强制函数<em class="oj"> g </em>来表示趋势分量或季节性分量。</p><p id="611b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了表示趋势，我们使用多项式基。为了表示季节性，我们使用傅立叶基础。</p><p id="a313" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，在该架构的可解释版本中，我们强制模型只有两个堆栈:一个堆栈专门用于预测趋势组件，另一个专门用于预测季节组件。然后，每个预测被组合以形成最终输出。</p><p id="a4a6" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">通用架构和可解释架构之间的区别如下所示。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/c256088601864ec72d3f36110380adc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*5fbVrsDbmraSNChu_XRJbw.jpeg"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">N-BEATS 的通用架构和可解释架构之间的差异。在左边，通用架构有我们想要的那么多栈，但是我们失去了可解释性。在右边，我们强制模型只有两个堆栈，代价是可能会降低性能。图片由作者提供。</p></figure><h2 id="5ea9" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">包扎</h2><p id="6ff6" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">总结一下，N-BEATS 有两种配置。通用配置允许模型找到针对我们的问题的最佳基本展开。可解释的配置迫使一个堆栈专门预测趋势，另一个堆栈专门预测季节性。</p><p id="9da6" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">网络中的剩余连接允许模型捕捉被先前块遗漏的信息。最后，将每个堆栈的部分预测的组合进行组合，以获得最终预测。</p><p id="4134" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我希望我设法让 N 拍相当容易理解。现在，让我们继续在使用 Python 的预测项目中实际应用 N-BEATS。</p><h1 id="bdd8" class="mi mj iv bd mk ml mm mn mo mp mq mr ms kb ol kc mu ke om kf mw kh on ki my mz bi translated">使用 N 节拍进行预测</h1><p id="e30e" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">我们现在准备在预测项目中应用 N-BEATS 模型。在这里，我们将预测每小时 94 号州际公路西行交通量。注意，我们只使用了 UCI 机器学习知识库上的<a class="ae la" href="https://archive.ics.uci.edu/ml/datasets/Metro+Interstate+Traffic+Volume" rel="noopener ugc nofollow" target="_blank">完整数据集</a>的一个样本，该样本由明尼苏达州交通部好心提供。</p><p id="f565" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们将在这个项目中使用 Darts 库，因为它使得在时间序列应用中应用最先进的模型(如 N-BEATS)变得非常容易。</p><p id="3dbc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">所有代码都是 Python 语言，你可以在<a class="ae la" href="https://github.com/marcopeix/time-series-analysis/blob/master/NBEATS.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得完整的源代码和数据集。</p><p id="c3de" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们走吧！</p><h2 id="54f4" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">读取数据</h2><p id="ac2a" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">当然，每个项目都从导入必要的库开始。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="9cf3" class="ot mj iv op b be ou ov l ow ox">import pandas as pd<br/>import numpy as np<br/>import datetime<br/>import matplotlib.pyplot as plt<br/><br/>from darts import TimeSeries<br/><br/>import warnings<br/>warnings.filterwarnings('ignore')</span></pre><p id="2d15" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们实际上读取我们的数据，并将其存储在数据帧中。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="3fde" class="ot mj iv op b be ou ov l ow ox">df = pd.read_csv('data/daily_traffic.csv')</span></pre><p id="db32" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">由于我们使用的是 dart，我们将从 DataFrame 转到 TimeSeries 对象，这是 dart 中的基本对象。Darts 中的每个模型都必须有一个 TimeSeries 对象作为输入，它还输出一个 TimeSeries 对象。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="c465" class="ot mj iv op b be ou ov l ow ox">series = TimeSeries.from_dataframe(df, time_col='date_time')</span></pre><p id="d622" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，我们可以使用<code class="fe oy oz pa op b">plot</code>方法轻松地可视化我们的数据。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="ffd2" class="ot mj iv op b be ou ov l ow ox">series.plot()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pb"><img src="../Images/82826b2f4197c73269b10b474016cdde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oc6bNI-d_oP0NaDIAkgd4A.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">每小时 94 号州际公路西行交通量。我们已经可以看到每日的季节性和每周的季节性。图片由作者提供。</p></figure><p id="fb2b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看上面的图，我们已经发现我们有两个季节周期:每周和每天。很明显，白天路上的车比晚上多，工作日的车比周末多。</p><p id="295f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这实际上可以用飞镖来验证。它带有一个<code class="fe oy oz pa op b">check_seasonality</code>函数，可以告诉我们一个季节周期是否具有统计意义。</p><p id="6291" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这种情况下，因为我们有每小时的数据，所以每日季节性的周期为 24(一天中的 24 小时)，每周季节性的周期为 168(一周中的 24*7 小时)。</p><p id="298a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">所以，让我们确保这两个季节都很重要。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="393e" class="ot mj iv op b be ou ov l ow ox">from darts.utils.statistics import check_seasonality<br/><br/>is_daily_seasonal, daily_period = check_seasonality(series, m=24, max_lag=400, alpha=0.05)<br/>is_weekly_seasonal, weekly_period = check_seasonality(series, m=168, max_lag=400, alpha=0.05)<br/><br/>print(f'Daily seasonality: {is_daily_seasonal} - period = {daily_period}')<br/>print(f'Weekly seasonality: {is_weekly_seasonal} - period = {weekly_period}')</span></pre><p id="4f1b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">上面的代码块将打印出两个季节周期都是重要的，稍后我们将如何对该信息进行编码以将其输入到我们的模型中。</p><h2 id="7f5d" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">拆分数据</h2><p id="9200" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">预测项目中的一个自然步骤，将我们的数据分成训练集和测试集。在这种情况下，我们为测试集保留最近五天的数据，并将其余数据用于训练。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="35a3" class="ot mj iv op b be ou ov l ow ox">train, test = series[:-120], series[-120:]<br/><br/>train.plot(label='train')<br/>test.plot(label='test')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pb"><img src="../Images/a1ba904aac0ac20717d16e97b94213eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GgJweN3EUPWZg7lBQX_nDQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">训练/测试分割了我们的数据。最后五天用于测试集。图片由作者提供。</p></figure><h2 id="278c" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">基线模型</h2><p id="2c12" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">在使用 N-BEATS 之前，最好先有一个基线模型。这是一个简单的模型，作为确定更复杂的模型是否更好的基准。</p><p id="65e1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">基线模型通常依赖于简单的统计或简单的启发式。在这种情况下，一种简单的预测方法是简单地重复上一个季节。在这里，由于我们有两个季节性周期，我们将使用每周季节性，以考虑周末的交通量较低。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="468c" class="ot mj iv op b be ou ov l ow ox">from darts.models.forecasting.baselines import NaiveSeasonal<br/><br/>naive_seasonal = NaiveSeasonal(K=168)<br/>naive_seasonal.fit(train)<br/><br/>pred_naive = naive_seasonal.predict(120)</span></pre><p id="7e18" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在上面的代码块中，我们简单地获取了训练集中最后一周的数据，并在将来重复它。当然，由于我们的预测范围只有五天而不是七天，我们在第五天截断了预测。</p><p id="129d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下面，我们可以看到来自基线模型的预测。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="3538" class="ot mj iv op b be ou ov l ow ox">test.plot(label='test')<br/>pred_naive.plot(label='Baseline')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pb"><img src="../Images/64e37941a1e0b1273eba5018a45fa828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RkcEpl5UhNc3egq_2YcKQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">来自基线模型的预测。图片由作者提供。</p></figure><p id="94aa" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们使用平均绝对误差(MAE)来评估基线的性能。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="9d72" class="ot mj iv op b be ou ov l ow ox">from darts.metrics import mae<br/><br/>naive_mae = mae(test, pred_naive)<br/><br/>print(naive_mae)</span></pre><p id="21a0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这给了我们一个 249 的 MAE，这就是我们试图用 N 拍来打破的分数。</p><h2 id="b41f" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">无协变量的 n 拍</h2><p id="e5e9" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">我们最终达到了应用 N 拍来解决问题的地步。</p><p id="41e1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们知道我们有两个季节周期，但是让我们在不给出信息的情况下尝试 N-BEATS。在我们帮助它之前，我们将让模型自己工作。</p><p id="d58f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们从导入 N-BEATS 和数据缩放器开始，以加速模型的训练。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="7218" class="ot mj iv op b be ou ov l ow ox">from darts.models import NBEATSModel<br/>from darts.dataprocessing.transformers import Scaler</span></pre><p id="5ef4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们在 1 和 0 之间调整数据。请注意，我们只在训练集上安装了缩放器，因为模型不应该有来自测试集的信息。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="df61" class="ot mj iv op b be ou ov l ow ox">train_scaler = Scaler()<br/>scaled_train = train_scaler.fit_transform(train)</span></pre><p id="8e32" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们初始化 N 拍模型。输入长度将包含一整周的数据，模型将输出 24 小时的数据。在这种情况下，我们使用通用架构。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="0c97" class="ot mj iv op b be ou ov l ow ox">nbeats = NBEATSModel(<br/>    input_chunk_length=168, <br/>    output_chunk_length=24,<br/>    generic_architecture=True,<br/>    random_state=42)</span></pre><p id="20da" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，我们简单地在缩放的训练集上拟合模型。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="1563" class="ot mj iv op b be ou ov l ow ox">nbeats.fit(<br/>    scaled_train,<br/>    epochs=50)</span></pre><p id="ecee" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">一旦模型完成训练，我们就可以在测试集的范围内进行预测。当然，预测也是成比例的，所以我们需要反向转换。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="6c06" class="ot mj iv op b be ou ov l ow ox">scaled_pred_nbeats = nbeats.predict(n=120)<br/><br/>pred_nbeats = train_scaler.inverse_transform(scaled_pred_nbeats)</span></pre><p id="d322" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，我们评估了 N-BEATS 的性能。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="ee80" class="ot mj iv op b be ou ov l ow ox">mae_nbeats = mae(test, pred_nbeats)<br/><br/>print(mae_nbeats)</span></pre><p id="05ab" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这给出了 MAE 为 292，高于基线。这意味着 N-BEATS 的表现并不比我们天真的预测要好。</p><p id="7600" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，让我们将协变量添加到模型中，看看我们是否可以改善它的性能。</p><h2 id="9cf0" class="nf mj iv bd mk ng nh dn mo ni nj dp ms lk nk nl mu lo nm nn mw ls no np my nq bi translated">有协变量的 n 拍</h2><p id="ce65" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">在本文的前面，我们确定了在我们的时间序列中有两个重要的季节周期。我们可以对这些信息进行编码，并将其作为协变量传递给模型。</p><p id="5832" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">换句话说，我们向模型添加了两个特性，告诉它我们在一天和一周中的位置。通过这种方式，模型了解到周末的交通流量较低，并且夜间的交通流量低于白天。</p><p id="b36b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">飞镖很方便地带有一个，使用<code class="fe oy oz pa op b">datetime_attribute_timeseries</code>很容易实现这一点。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="1ca4" class="ot mj iv op b be ou ov l ow ox">from darts import concatenate<br/>from darts.utils.timeseries_generation import datetime_attribute_timeseries as dt_attr<br/><br/>cov = concatenate(<br/>    [dt_attr(series.time_index, 'day', dtype=np.float32), dt_attr(series.time_index, 'week', dtype=np.float32)],<br/>    axis='component'<br/>)</span></pre><p id="13a7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们也对协变量进行缩放，将其输入到模型中。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="bfa5" class="ot mj iv op b be ou ov l ow ox">cov_scaler = Scaler()<br/>scaled_cov = cov_scaler.fit_transform(cov)</span></pre><p id="d8ed" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请注意，我们不需要将协变量分割成训练集和测试集，因为 Darts 会在训练过程中自动进行适当的分割。</p><p id="7477" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，我们重复初始化 N 拍和拟合的过程。这一次，我们也传递协变量。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="6d36" class="ot mj iv op b be ou ov l ow ox">nbeats_cov = NBEATSModel(<br/>    input_chunk_length=168, <br/>    output_chunk_length=24,<br/>    generic_architecture=True,<br/>    random_state=42)<br/><br/>nbeats_cov.fit(<br/>    scaled_train,<br/>    past_covariates=scaled_cov,<br/>    epochs=50<br/>)</span></pre><p id="a176" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">一旦模型被训练，我们就产生预测。记住再次反转变换，因为预测在 0 和 1 之间缩放。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="4570" class="ot mj iv op b be ou ov l ow ox">scaled_pred_nbeats_cov = nbeats_cov.predict(past_covariates=scaled_cov, n=120)<br/><br/>pred_nbeats_cov = train_scaler.inverse_transform(scaled_pred_nbeats_cov)</span></pre><p id="7438" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们也可以用下面的代码块来可视化我们的预测。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="0f49" class="ot mj iv op b be ou ov l ow ox">test.plot(label='test')<br/>pred_nbeats.plot(label='N-BEATS')</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pb"><img src="../Images/919ba6c1c5fcd764058ea4d9e0bc88cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2v6RAwVdvRpkbmndeeiiqQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">来自 N 拍的预测。图片由作者提供。</p></figure><p id="c4ce" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">同样，我们使用 MAE 评估模型的性能。</p><pre class="kl km kn ko gt oo op oq bn or os bi"><span id="bd98" class="ot mj iv op b be ou ov l ow ox">mae_nbeats_cov = mae(test, pred_nbeats_cov)<br/><br/>print(mae_nbeats_cov)</span></pre><p id="45f8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这给了我们一个 288 的 MAE。这比不使用协变量要好，但仍然比基线模型差。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi pc"><img src="../Images/92a335f4325c9eaa6d2f3185056b67b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JLSTtzvpUaspl8-Ig5tySQ.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">每个模型预测的平均绝对误差。我们看到，添加协变量有助于模型，但其性能仍然比基线差。图片由作者提供。</p></figure><p id="317f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated"><strong class="ld iw">对结果的说明</strong></p><p id="6a21" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">获得的结果并不令人兴奋，但要有所保留。请记住，我们正在处理一个相当小而简单的数据集。这可能是因为我从<a class="ae la" href="https://archive.ics.uci.edu/ml/datasets/Metro+Interstate+Traffic+Volume" rel="noopener ugc nofollow" target="_blank">完整数据集</a>中提取的样本本质上只是重复性的，这解释了为什么基线如此之好。</p><p id="aa30" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">尽管如此，您现在已经知道如何在预测项目中实施 N-BEATS，并且您还可以体会到拥有基线模型的重要性。</p><h1 id="6e9c" class="mi mj iv bd mk ml mm mn mo mp mq mr ms kb ol kc mu ke om kf mw kh on ki my mz bi translated">结论</h1><p id="806e" class="pw-post-body-paragraph lb lc iv ld b le na jw lg lh nb jz lj lk nc lm ln lo nd lq lr ls ne lu lv lw io bi translated">N-BEATS 是一个最先进的深度学习模型，用于时间序列预测，它依赖于基础扩展的原则。该模型可以学习特定问题的基础扩展功能，或者我们可以限制它们具有可解释的输出。</p><p id="d677" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我希望你喜欢这本书，并且你学到了新的东西！</p><p id="0860" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">干杯🍺</p></div></div>    
</body>
</html>