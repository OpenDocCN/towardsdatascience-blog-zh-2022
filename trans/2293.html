<html>
<head>
<title>Root-Finding Methods in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的求根方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/root-finding-methods-from-scratch-in-python-84040c81a8ba#2022-05-20">https://towardsdatascience.com/root-finding-methods-from-scratch-in-python-84040c81a8ba#2022-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="54a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python的二分法、牛顿法和割线法数学求根算法</h2></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="d883" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">介绍</h2><p id="c40d" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">数值<strong class="ln iu">根</strong> - <strong class="ln iu">寻找</strong>算法迭代计算<em class="me">连续函数</em>的<em class="me">零点</em>的更好近似，也称为<strong class="ln iu">根</strong>。</p><p id="d668" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me">本文介绍了四种标准求根算法背后的理论，以及它们在Python中的实现。</em></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/91d89da0e7afc261c5ed630469be5d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odNoY0V_-xlmsllZ"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">照片由<a class="ae na" href="https://unsplash.com/@estherrj?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Esther Jiao </a>在<a class="ae na" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="73cc" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">以等式1为例:</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/b15a47bcdff9c0de4b2c830db18ae94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjFOzSZgBzd-h2QUO6_Prw.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">等式1 —示例函数(图片由作者提供)</p></figure><p id="4d29" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">图1是在区间[-1，5]上等式1的<em class="me">图。一个<strong class="ln iu">零</strong>或<strong class="ln iu">根</strong>是f(x)等于0时x的任意<strong class="ln iu"> </strong> <em class="me">值。即</em>曲线穿过x轴的位置。在这种情况下，根位于<em class="me"> x₀ = 1 </em>和<em class="me"> x </em> ₁ <em class="me"> = 2 </em>之间。</em></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nc"><img src="../Images/ffda48c9c53d0b7d23b9b16c5fbc0a5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tb9Vqqr71IJXzJ9NiC3Kcg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图1 —等式1的曲线图(图片由作者提供)</p></figure><p id="7607" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me">本文的目标是使用一些数值运算来逼近Python中的根。</em></p><p id="f4c4" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">实现这一目标的三种方法是:</p><ol class=""><li id="0a4f" class="nd ne it ln b lo mf lr mg ky nf lc ng lg nh md ni nj nk nl bi translated">二分法</li><li id="781b" class="nd ne it ln b lo nm lr nn ky no lc np lg nq md ni nj nk nl bi translated">牛顿方法</li><li id="256e" class="nd ne it ln b lo nm lr nn ky no lc np lg nq md ni nj nk nl bi translated">割线法</li></ol></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="e417" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">二分法</h2><p id="abdc" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><strong class="ln iu">二分法</strong>通过<em class="me">在中点</em>重复划分区间来逼近连续函数的根。</p><p id="93b9" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">该技术适用于两个符号相反的值已知的情况。</p><blockquote class="nr ns nt"><p id="c147" class="ll lm me ln b lo mf ju lq lr mg jx lt nu mh lv lw nv mi ly lz nw mj mb mc md im bi translated"><em class="it">如果区间</em>【x₀，x₁】<em class="it">上有一个</em> f(x) <em class="it">的根，那么</em>【f(x₀】<em class="it"/>【f(x₁】<em class="it">一定有不同的符号。即</em><strong class="ln iu">【f(x₀)f(x₁】&lt;0</strong>。</p></blockquote><p id="d4ac" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">如有必要，复习这篇<a class="ae na" href="https://medium.com/@andrewdaviesul/checking-if-a-solution-exists-intermediate-value-theorem-53d85890350" rel="noopener">介值定理</a>文章。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/@andrewdaviesul/checking-if-a-solution-exists-intermediate-value-theorem-53d85890350" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Python中的介值定理</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">用介值定理检验函数的解是否存在</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo mu oa"/></div></div></a></div><p id="84c2" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">设<em class="me"> x₀ </em>和<em class="me"> x₁ </em>为估计区间的起点和终点。然后，用等式2计算出<em class="me">【x₀，x₁】</em>之间的中点(<em class="me"> x₂ </em>)。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/2bb20b7e272aa83146af4132764c0766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SYi4usTAnClJ2lcEJwEKrg.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">等式2 —二分法(图片由作者提供)</p></figure><p id="476e" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">接下来的猜测要么是<em class="me"> x₀ </em>和<em class="me"> x₂ </em>的中点，要么是<em class="me"> x₂ </em>和<em class="me"> x₁ </em>的中点，就看根落在哪边了。<strong class="ln iu">收敛缓慢</strong> <em class="me">。</em></p><p id="bed3" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">要点1给出了二分法的示例实现。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="op oq l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">要点Python中的二分法</p></figure><p id="942e" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me">存储</em>逐次根逼近和<em class="me">绘图</em>图2说明了算法的<strong class="ln iu">迭代性质</strong>。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nc"><img src="../Images/f1c505342b66eaac4f3df2c1f33bbdc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*05rQNs6AS_PmmEoel-cHow.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图2-对分根估计的迭代改进(图片由作者提供)</p></figure><p id="2398" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">对等式1运行二分法，在<em class="me">【1，2】</em>之间指定一个<em class="me">区间</em>，在<strong class="ln iu">x</strong>≈<strong class="ln iu">1.324718475</strong>处返回一个<em class="me">解</em>。查看图1可以看出，这个值在期望值附近。</p><p id="dad1" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">这个过程大约需要<em class="me"> 18次迭代</em>才能达到这个结果。评估改进是逐渐发生的<em class="me"/>。</p><p id="a8b2" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">关于该算法的最后一点是，可以使用等式3<em class="me">估计实现特定<strong class="ln iu">误差界限</strong>所需的最小迭代次数</em>。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/389e1073ca2e00b2517c3e574c8e7423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N4EICyUDgTcG7ApHGbCMcw.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">等式3 —迭代次数(图片由作者提供)</p></figure><p id="8199" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated"><em class="me"> x₀ </em>和<em class="me"> x₁ </em>是区间起点和终点，例如<em class="me">【1，2】。</em></p><div class="nx ny gp gr nz oa"><a href="https://scicomp.stackexchange.com/questions/16458/deriving-the-error-bound-for-bisection-method" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">二分法误差界限的推导</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">这是一个家庭作业问题，我想知道是否有人可以解释一下。设$x_n = \frac{a_n + b_n}{2}…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">scicomp.stackexchange.com</p></div></div><div class="oj l"><div class="or l ol om on oj oo mu oa"/></div></div></a></div><p id="7f15" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">使用Gist 3中的Python代码实现该等式。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="op oq l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">要点2 —误差界限和迭代计数器</p></figure></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="dbdd" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">牛顿方法</h2><p id="2472" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">可能是最著名的求根算法，<strong class="ln iu">牛顿法</strong> <em class="me">逼近实值连续函数</em>的零点。从解的<em class="me">初始猜测</em>开始，等式4 <strong class="ln iu">迭代</strong>使用<em class="me">函数</em>和<em class="me">导数</em>在<strong class="ln iu"> <em class="me"> xₙ </em> </strong>处的值的知识来改进近似。</p><ul class=""><li id="3920" class="nd ne it ln b lo mf lr mg ky nf lc ng lg nh md os nj nk nl bi translated"><strong class="ln iu"> <em class="me"> n </em> </strong>:迭代计数器</li><li id="369e" class="nd ne it ln b lo nm lr nn ky no lc np lg nq md os nj nk nl bi translated"><strong class="ln iu"><em class="me">xₙ₊₁</em></strong><em class="me">:</em>下一步估计</li><li id="300e" class="nd ne it ln b lo nm lr nn ky no lc np lg nq md os nj nk nl bi translated"><strong class="ln iu"><em class="me">xₙ</em></strong><em class="me">:</em>目前最好的估计</li><li id="5b50" class="nd ne it ln b lo nm lr nn ky no lc np lg nq md os nj nk nl bi translated"><strong class="ln iu"><em class="me">f(xₙ)</em></strong><em class="me">:</em>函数在<em class="me"> xₙ </em>求值</li><li id="97c4" class="nd ne it ln b lo nm lr nn ky no lc np lg nq md os nj nk nl bi translated"><strong class="ln iu"> <em class="me"> f'(xₙ) </em> </strong>:在<em class="me"> xₙ </em>的<em class="me"> f </em>的导数</li></ul><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/960550246375a4b61cd8cb92b1bc3da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zx9HplolepuEb1yAa1g0jA.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">等式4——牛顿法(图片由作者提供)</p></figure><p id="e084" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">显然，这个过程需要f(x) 的<em class="me">一阶导数，因此<em class="me"> f(x) </em>必须是<strong class="ln iu">可微的</strong>。</em></p><p id="cfa0" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">Gist 3提供了Python代码来实现牛顿法的<em class="me">迭代解</em>。它使用<strong class="ln iu"> Sympy </strong>库来评估<em class="me"> f'(xₙ) </em>。在每次通过循环时，参数值被<em class="me">代入</em>到等式1中，以确定<em class="me"> xₙ₊₁ </em>。</p><p id="6cb4" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">一个<strong class="ln iu">公差</strong> <strong class="ln iu">极限</strong>控制过程何时中断，当<em class="me"> f(xₙ) </em>接近<em class="me">零点</em>时触发该条件。</p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="op oq l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">要点3——具有符号评估的牛顿法的迭代解</p></figure><p id="9887" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">如上，保存每个<em class="me"> </em>猜测和<em class="me">绘图</em>图3显示了牛顿法<em class="me">如何逼近</em>正确解。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nc"><img src="../Images/f8ec12e5f5e9a7d50cbabc86951265f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxMfiKqV9Ja99HD4MwL-Ig.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图3 —牛顿零猜测的改进(图片由作者提供)</p></figure><p id="01ec" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">初始猜测为<em class="me"> x = 9 </em>，该方法返回的结果为<em class="me">f(x)= 0</em>@<strong class="ln iu"><em class="me">x = 1.324718834</em></strong>。需要8次迭代才能达到1e-5的精度。</p><blockquote class="nr ns nt"><p id="3090" class="ll lm me ln b lo mf ju lq lr mg jx lt nu mh lv lw nv mi ly lz nw mj mb mc md im bi translated">牛顿法的收敛速度比二分法快得多，但有其局限性，这取决于所讨论的函数的导数。</p></blockquote></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="6558" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">割线法</h2><p id="011f" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated"><em class="me">割线法</em>与二分法非常相似，只是<strong class="ln iu">不是在中点处划分，而是通过连接端点</strong>的割线来划分区间。</p><p id="977e" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">等式4将在Python中迭代地<em class="me">或递归地</em>或<em class="me">实现。</em></p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/60870e0cfc7bf455d462a4d774f53e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VekF9t0Aq4j2GopHtVJ2A.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">等式4 —割线法(图片由作者提供)</p></figure><p id="911a" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">Gist 4 <strong class="ln iu">中的Python方法递归地使用割线方法求解根。</strong></p><figure class="ml mm mn mo gt mp"><div class="bz fp l di"><div class="op oq l"/></div><p class="mw mx gj gh gi my mz bd b be z dk translated">要点4——具有符号评估的牛顿法的迭代解</p></figure><p id="ce81" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">从初始值<em class="me"> x₀ </em> = 1和<em class="me"> x₁ </em> = 2开始，该过程在8次递归调用内，在<strong class="ln iu"> x = 1.324717957 </strong>处输出<em class="me"> f(x) </em>的根。图4 <em class="me">显示了</em>每次走刀产生的割线。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nc"><img src="../Images/3a280c8c57cd3b91175de915e0201b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6jQ4FgZMfUfo9kuOTq3uA.png"/></div></div><p class="mw mx gj gh gi my mz bd b be z dk translated">图4——割线法可视化(图片由作者提供)</p></figure><p id="0ab3" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">割线法是<em class="me">仅次于牛顿法的</em>。最适用于需要<strong class="ln iu">比二分法更快收敛</strong>的情况，但是对函数<em class="me"> f(x) </em>求<em class="me">解析导数</em>太困难或者<em class="me">不可能。</em></p></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h1 id="7d5e" class="ot kq it bd kr ou ov ow ku ox oy oz kx jz pa ka lb kc pb kd lf kf pc kg lj pd bi translated">结论</h1><p id="8201" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">实现求根算法对于学工程和数学的学生来说很有价值。再者，还有很多其他的方法，用户可以<strong class="ln iu">探索</strong>和<em class="me"> </em>扩展自己的<em class="me"> </em> <strong class="ln iu"> <em class="me">知识</em> </strong> <em class="me"> </em>和<em class="me">编码技能</em>，比如<em class="me">布伦特的</em>或者<em class="me">斯特芬森的</em>方法。</p><p id="61b6" class="pw-post-body-paragraph ll lm it ln b lo mf ju lq lr mg jx lt ky mh lv lw lc mi ly lz lg mj mb mc md im bi translated">如果你对<em class="me"> Python </em>、<em class="me">工程学</em>和<em class="me">数据科学</em>感兴趣，请关注并查看我的其他文章。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/@andrewdaviesul/membership" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">通过我的推荐链接加入媒体-安德鲁·约瑟夫·戴维斯</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="pe l ol om on oj oo mu oa"/></div></div></a></div><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/fundamentals-of-matrix-algebra-with-python-part-1-85aaa17e3632"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">Python的矩阵代数基础|第1部分</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">使用Python理解和实现基本矩阵代数概念和运算</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="pf l ol om on oj oo mu oa"/></div></div></a></div></div><div class="ab cl ki kj hx kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="im in io ip iq"><h2 id="ca85" class="kp kq it bd kr ks kt dn ku kv kw dp kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">参考</h2><p id="d452" class="pw-post-body-paragraph ll lm it ln b lo lp ju lq lr ls jx lt ky lu lv lw lc lx ly lz lg ma mb mc md im bi translated">[1] <a class="ae na" href="https://www.pearson.com/uk/educators/higher-education-educators/program/Adams-Calculus-A-Complete-Course-8th-Edition/PGM1010104.html" rel="noopener ugc nofollow" target="_blank">微积分:完整教程，第八版</a> —罗伯特·A·亚当斯，美国北卡罗来纳大学教堂山分校</p></div></div>    
</body>
</html>