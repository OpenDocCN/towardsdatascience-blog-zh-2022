<html>
<head>
<title>Python 3.11: New Features That You Will Truly Enjoy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.11:您将真正喜欢的新特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-3-11-new-features-that-you-will-truly-enjoy-9fd67882fdf#2022-11-22">https://towardsdatascience.com/python-3-11-new-features-that-you-will-truly-enjoy-9fd67882fdf#2022-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a76e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">世界各地志愿者的努力值得称赞</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2eb6eeb8b835331894b74bd5fcdc8d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TSqiowTzxo-_BOw3hLpSQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://unsplash.com/photos/LJ9KY8pIH3E" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="116a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 3.11 于 2022 年 10 月 24 日发布，为我们提供了一些令人着迷的改进。你可以在这里看到<a class="ae ky" href="https://docs.python.org/3.11/whatsnew/3.11.html" rel="noopener ugc nofollow" target="_blank">所有 pep 的完整文档。在本文中，我将为您带来 5 个很酷的新功能，外加额外的奖励，我想您会喜欢的。</a></p><h2 id="29d0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><a class="ae ky" href="https://peps.python.org/pep-0657/" rel="noopener ugc nofollow" target="_blank"> PEP 657 </a>:错误追溯定位器</h2><p id="ac32" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在 Python 3.11 之前，当出现异常时，错误回溯中唯一的信息是描述错误的<strong class="lb iu">行</strong>。举个例子，</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="2c3f" class="my lw it mu b be mz na l nb nc">x, y, z = 1, 2, 0<br/>a, b, c = 3, 4, 5<br/>result = (x / y / z) * (a / b / c)</span></pre><p id="f4be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码会抛出一个错误，因为我们在除<code class="fe nd ne nf mu b">X/Y by Z</code>，等于 0。下面是错误消息，它很有意义，但不提供信息，因为我们仍然不知道代码的哪一部分导致了这个问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2cff3646816c62b29477561d02007519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*EPkd_gdwEIv7TKKho8qGPw.png"/></div></figure><p id="92c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 3.11 中，我们会看到这个，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/856548087d767aa4ef14f2e449b4f28a.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*ijN3xW4oAKHKyTIXI-ZDyg.png"/></div></figure><p id="7e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在错误定位器<code class="fe nd ne nf mu b">~~^~~</code>的帮助下，很明显根本原因是<strong class="lb iu"> Y 或 Z 为零</strong>。当您的代码变得复杂时，这种带注释的回溯将更加强大。</p><h2 id="da03" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><a class="ae ky" href="https://peps.python.org/pep-0673/" rel="noopener ugc nofollow" target="_blank">人教版 673 </a>:自身型</h2><p id="30ae" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于类型提示，以前，如果我们需要引用当前类本身，我们必须显式定义一个类型变量，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/39080802d9617bf207f06c530fe21fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fEpZw0wvMgwG7tKW0m6WLA.png"/></div></div></figure><p id="3df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在在 3.11 中，我们可以使用一个<code class="fe nd ne nf mu b">Self </code>类型，它指的是封装类本身。这将消除定义类型变量的麻烦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/743b5ee1111171269057bbf40998e9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fjlb5urJmi7Ioiu82ZnWwQ.png"/></div></div></figure><h2 id="37ec" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><a class="ae ky" href="https://docs.python.org/3.11/whatsnew/3.11.html#asyncio" rel="noopener ugc nofollow" target="_blank">改进的{asyncio} </a>:异步上下文管理器</h2><p id="49a1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于异步编程，代码仍然是一次执行一步，但是系统不会等待这一步完成后再进入下一步。</p><p id="d45c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 中，这是由<code class="fe nd ne nf mu b">{asyncio}</code>模块处理的。我们创建几个异步任务，等待每个任务运行，然后用<code class="fe nd ne nf mu b">asyncio.gather()</code>收集它们。比如，让我们去跑跑腿，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f0dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在终端中运行它会得到这样的输出，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/93f56c402f634ceb055fd0a14cfb1d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*-7ZDyYwezjEPLq2C-Xle9A.png"/></div></figure><p id="01e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在用<code class="fe nd ne nf mu b">asyncio.gather</code>等待任务之前手动监控任务<code class="fe nd ne nf mu b">list </code>是很麻烦的。3.11 中引入了一个新的特性/类<code class="fe nd ne nf mu b">TaskGroup()</code>，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf mu b">TaskGroup</code>的功能是作为一个上下文管理器，保存您的一组任务，这些任务将在退出时等待所有的任务。另外，语法更简单。</p><h2 id="449a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><a class="ae ky" href="https://peps.python.org/pep-0654/" rel="noopener ugc nofollow" target="_blank"> PEP 654 </a>:异常组</h2><p id="efa0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">异常处理的一个类似的<em class="nn">“分组”</em>特性是 3.11 中增加的<strong class="lb iu">异常组</strong>。我们可以把它想象成几个常规的异常被包装在一个异常中，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6582def8e0d94877d8dc9c78f1de9953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c0ZgDJLQ0QnuILvzjn92oA.png"/></div></div></figure><p id="3d71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，当一个错误触发了<code class="fe nd ne nf mu b">ExceptionGroup</code>时，它引发了两个子异常，显示在它自己的面板中。</p><p id="39bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理<code class="fe nd ne nf mu b">ExceptionGroup </code>，Python 3.11 还添加了一个新的关键字<code class="fe nd ne nf mu b">except*</code>，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/86f904165483d66dae251c52d4ee297b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4omOsW4wT4sJDSZ3-GSgDA.png"/></div></div></figure><p id="f03a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过<code class="fe nd ne nf mu b">except*</code>，可以处理<code class="fe nd ne nf mu b">ExceptionGroup </code>中包含的多个错误。当在{ <a class="ae ky" href="https://docs.python.org/3.11/whatsnew/3.11.html#asyncio" rel="noopener ugc nofollow" target="_blank"> <em class="nn"> asyncio </em> </a> }中使用许多异步任务一起运行时，这个特性会更有效。</p><h2 id="8285" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><a class="ae ky" href="https://peps.python.org/pep-0678/" rel="noopener ugc nofollow" target="_blank"> PEP 678 </a>:自定义异常注释</h2><p id="1aa7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">错误处理的另一个很棒的新特性是带有<code class="fe nd ne nf mu b">add_note</code>的异常注释，它允许您添加定制的消息。举个例子，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/e8fa268934e8239ed966363ea207a605.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CiokdEOCn-tRI-PwaxwONg.png"/></div></div></figure><h2 id="3494" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">奖励<a class="ae ky" href="https://peps.python.org/pep-0659/" rel="noopener ugc nofollow" target="_blank"> PEP 659 </a>:更快的执行速度</h2><p id="7c1b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">值得一提的是，由于更快的 CPython 计划，Python 3.11 预计将比其前辈 T22 快<strong class="lb iu">10%-60%。</strong></p><h2 id="7dac" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论:该不该升级到 Python 3.11？</h2><p id="1673" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">看情况！就个人而言，<strong class="lb iu">我反对升级生产环境</strong>，因为你的项目中使用的某些库可能还不兼容 Python 3.11。</p><p id="df26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想测试一下，我建议你在 Google colab 上测试一下。您可以运行以下命令将 Python 版本升级到 3.11，</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="f8d8" class="my lw it mu b be mz na l nb nc">!sudo apt-get update -y<br/>!sudo apt-get install python3.11<br/>!sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.7 1<br/>!sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.11 2</span></pre><p id="a90b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们只介绍了最有趣的新特性；请务必查看<a class="ae ky" href="https://docs.python.org/3/whatsnew/3.11.html" rel="noopener ugc nofollow" target="_blank">官方发布文件</a>了解所有改进和变更。</p><p id="c09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nn"> ***🎥加入我们的 YouTube 数据科学家和开发者社区</em> </strong> <a class="ae ky" href="https://www.youtube.com/channel/UCbGx9Om38Ywlqi0x8RljNdw" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nn">【数据与 Kat 对话】</em> </strong> </a> <strong class="lb iu"> <em class="nn">😄热门视频:</em> </strong> <a class="ae ky" href="https://www.youtube.com/watch?v=Cw2Co8enZhM" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="nn">为什么有的人学编码比较快？</em> </strong> </a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nl l"/></div></figure></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="1d41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nn">想要更多数据科学和编程技巧？使用</em> </strong> <a class="ae ky" href="https://yilistats.medium.com/membership" rel="noopener"> <strong class="lb iu"> <em class="nn">我的链接</em> </strong> </a> <strong class="lb iu"> <em class="nn">注册 Medium，获得我所有内容的全部访问权限。</em> </strong></p><p id="2fe8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">你可能会觉得鼓舞人心的其他博客，</strong></p><div class="nz oa gp gr ob oc"><a href="https://levelup.gitconnected.com/3-small-sql-errors-that-cost-a-data-science-job-offer-7ee920084aed" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">3 个小小的 SQL 错误让一份数据科学工作付出了代价</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">其中一个让我失去了一份 21.2 万美元的工作</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq ks oc"/></div></div></a></div><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/6-sql-tricks-every-data-scientist-should-know-f84be499aea5"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd iu gy z fp oh fr fs oi fu fw is bi translated">每个数据科学家都应该知道的 6 个 SQL 技巧</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">提高分析效率的 SQL 技巧</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ol l"><div class="or l on oo op ol oq ks oc"/></div></div></a></div></div></div>    
</body>
</html>