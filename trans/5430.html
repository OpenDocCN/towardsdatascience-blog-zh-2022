<html>
<head>
<title>PDF Parsing Dashboard with Plotly Dash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有 Plotly 破折号的 PDF 解析仪表板</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pdf-parsing-dashboard-with-plotly-dash-256bf944f536#2022-12-06">https://towardsdatascience.com/pdf-parsing-dashboard-with-plotly-dash-256bf944f536#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af4d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">介绍如何在下一个仪表板中阅读和显示 PDF 文件。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4374662cfadc2d2fc0365a3e6ad60f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmClRai2y1ja4KTapHlbBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PDF 解析器(图片来自作者)</p></figure><h1 id="c1a5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="2466" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我最近对在我的自然语言处理(NLP)项目中使用 PDF 文件产生了兴趣，你可能想知道，为什么？ PDF 文档包含大量信息，可以提取这些信息并用于创建各种类型的机器学习模型以及在不同数据中寻找模式。<em class="mm">问题？</em> PDF 文件在 Python 中很难处理。此外，当我开始在 Plotly dash 上为一个客户创建仪表板时，我几乎找不到关于如何在 Plotly 仪表板中摄取和解析 PDF 文件的信息。这种信息的缺乏将在今天改变，我将与你分享你如何上传和使用 PDF 文件在一个 Plotly 仪表板！</p><h1 id="a151" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">包裹</h1><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="0b3f" class="ms kz it mo b be mt mu l mv mw">import pandas as pd <br/>from dash import dcc, Dash, html, dash_table<br/>import base64<br/>import datetime<br/>import io<br/>import PyPDF2<br/>from dash.dependencies import Input, Output, State<br/>import re<br/>import dash_bootstrap_components as dbc<br/>import spacy<br/>from spacy.lang.en.stop_words import STOP_WORDS<br/>from string import punctuation<br/>from heapq import nlargest</span></pre><p id="0269" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">上面的大多数包是您在部署 Dash 应用程序时通常会找到的。例如，<strong class="ls iu"> dash </strong>是我们将使用的主要 Plotly API，而<em class="mm"> dcc、dash、html 和 dash_table </em>是我们添加功能所需的一些主要方法。当阅读 Python 中的 PDF 时，我倾向于使用<a class="ae nc" href="https://pypi.org/project/PyPDF2/" rel="noopener ugc nofollow" target="_blank"><em class="mm">py pdf 2</em></a><em class="mm"/>但是还有其他 API 可以探索，你应该总是使用最适合你的项目的 API。</p><h1 id="49cb" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">支持功能</h1><p id="b659" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">支持功能有助于增加 dash 应用程序的交互性。我为这个应用程序创建了两个不同的类，允许 PDF 被分开解析。第一个类是<strong class="ls iu"> <em class="mm"> pdfReader 类。</em> </strong>这个类中的函数都与将 PDF 读入 Python 并将其内容转换成可用形式有关。此外，一些功能能够提取 PDF 中固有的元数据(即<em class="mm">创作日期、作者等。)</em></p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="f892" class="ms kz it mo b be mt mu l mv mw">class pdfReader:    <br/>    def __init__(self, file_path: str) -&gt; str:<br/>        self.file_path = file_path<br/>    <br/>    def PDF_one_pager(self) -&gt; str:<br/>        """A function that returns a one line string of the <br/>            pdfReader object.<br/>            <br/>            Parameters:<br/>            file_path(str): The file path to the pdf.<br/>            <br/>            Returns:<br/>            one_page_pdf (str): A one line string of the pdf.<br/>        <br/>        """<br/>        content = ""<br/>        p = open(self.file_path, "rb")<br/>        pdf = PyPDF2.PdfFileReader(p)<br/>        num_pages = pdf.numPages<br/>        for i in range(0, num_pages):<br/>            content += pdf.getPage(i).extractText() + "\n"<br/>        content = " ".join(content.replace(u"\xa0", " ").strip().split())<br/>        page_number_removal = r"\d{1,3} of \d{1,3}"<br/>        page_number_removal_pattern = re.compile(page_number_removal, re.IGNORECASE)<br/>        content = re.sub(page_number_removal_pattern, '',content)<br/>        <br/>        return content<br/>  <br/>    def pdf_reader(self) -&gt; str:<br/>        """A function that can read .pdf formatted files <br/>            and returns a python readable pdf.<br/>            <br/>            Returns:<br/>            read_pdf: A python readable .pdf file.<br/>        """<br/>        opener = open(self.file_path,'rb')<br/>        read_pdf = PyPDF2.PdfFileReader(opener)<br/>    <br/>        return read_pdf<br/>  <br/>  <br/>    def pdf_info(self) -&gt; dict:<br/>        """A function which returns an information dictionary<br/>        of an object.<br/>         <br/>        Returns:<br/>        dict(pdf_info_dict): A dictionary containing the meta<br/>        data of the object.<br/>        """<br/>        opener = open(self.file_path,'rb')<br/>        read_pdf = PyPDF2.PdfFileReader(opener)<br/>        pdf_info_dict = {}<br/>        for key,value in read_pdf.documentInfo.items():<br/>            pdf_info_dict[re.sub('/',"",key)] = value<br/>        return pdf_info_dict<br/>  <br/>    def pdf_dictionary(self) -&gt; dict:<br/>        """A function which returns a dictionary of <br/>            the object where the keys are the pages<br/>            and the text within the pages are the <br/>            values.<br/>            <br/>            Returns:<br/>            dict(pdf_dict): A dictionary of the object within the<br/>            pdfReader class.<br/>        """<br/>        opener = open(self.file_path,'rb')<br/>        #try:<br/>        #    file_path = os.path.exists(self.file_path)<br/>        #    file_path = True<br/>        #break<br/>        #except ValueError:<br/>        #   print('Unidentifiable file path')<br/>        read_pdf = PyPDF2.PdfFileReader(opener)<br/>        length = read_pdf.numPages<br/>        pdf_dict = {}<br/>        for i in range(length):<br/>            page = read_pdf.getPage(i)<br/>            text = page.extract_text()<br/>            pdf_dict[i] = text<br/>            return pdf_dict<br/><br/>    def get_publish_date(self) -&gt; str:<br/>          """A function of which accepts an information dictionray of an object<br/>              in the pdfReader class and returns the creation date of the<br/>              object (if applicable).<br/>              <br/>              Parameters:<br/>              self (obj): An object of the pdfReader class<br/>              <br/>              Returns:<br/>              pub_date (str): The publication date which is assumed to be the <br/>              creation date (if applicable).<br/>          """<br/>          info_dict_pdf = self.pdf_info()<br/>          pub_date= 'None'<br/>          try:<br/>              publication_date = info_dict_pdf['CreationDate']<br/>              publication_date = datetime.date.strptime(publication_date.replace("'", ""), "D:%Y%m%d%H%M%S%z")<br/>              pub_date = publication_date.isoformat()[0:10] <br/>          except:<br/>              pass<br/>          return str(pub_date)</span></pre><p id="9721" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">创建的第二个类是<strong class="ls iu"> <em class="mm"> pdfParser </em> </strong>，这个类执行我们希望在 Python 中的 PDF 上使用的主要解析操作。这些功能包括:</p><ol class=""><li id="16a6" class="nd ne it ls b lt mx lw my lz nf md ng mh nh ml ni nj nk nl bi translated"><strong class="ls iu"> get_emails() </strong> -能够在一串文本中找到所有邮件的功能。</li><li id="e45b" class="nd ne it ls b lt nm lw nn lz no md np mh nq ml ni nj nk nl bi translated">这个函数可以在一串文本中定位日期。对于这个控制面板，我们将找到下载 PDF 的日期。</li><li id="638e" class="nd ne it ls b lt nm lw nn lz no md np mh nq ml ni nj nk nl bi translated"><strong class="ls iu"> get_summary() </strong> -能够基于单词的重要性和用户希望从原始文本中放入摘要中的文本的百分比来创建文本主体的摘要的功能。</li><li id="662d" class="nd ne it ls b lt nm lw nn lz no md np mh nq ml ni nj nk nl bi translated"><strong class="ls iu"> get_urls() </strong> -这个函数将在一个文本字符串中找到所有的 URL 和域名。</li></ol><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="fb18" class="ms kz it mo b be mt mu l mv mw">class pdfParser:<br/>    def __init__(self):<br/>        return<br/>    <br/>    @staticmethod <br/>    def get_emails(text: str) -&gt; set:<br/>        """A function that accepts a string of text and<br/>            returns any email addresses located within the <br/>            text<br/>            <br/>            Parameters:<br/>            text (str): A string of text<br/>            <br/>            Returns:<br/>            set(emails): A set of emails located within<br/>            the string of text.<br/>        """<br/>        email_pattern = re.compile(r'[\w.+-]+@[\w-]+\.[\w.-]+')<br/>        email_set = set()<br/>        email_set.update(email_pattern.findall(text))<br/>  <br/>        return str(email_set)<br/>    <br/>    @staticmethod<br/>    def get_dates(text: str, info_dict_pdf : dict) -&gt; set:<br/>        date_label = ['DATE']<br/>        nlp = spacy.load('en_core_web_lg')<br/>        doc = nlp(text)<br/><br/>        dates_pattern = re.compile(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})')<br/>        dates = set((ent.text) for ent in doc.ents if ent.label_ in date_label)<br/>        filtered_dates = set(date for date in dates if not dates_pattern.match(date))<br/>                             <br/>        return str(filtered_dates)<br/>    <br/>    @staticmethod<br/>    def get_summary(text: str, per: float) -&gt; str:<br/><br/>        """A function that accepts of a string of text as input<br/>           and a percentange value as input and returns a summary<br/>           of the text.<br/><br/>           Parameters:<br/>           text (str): A string of text to be summarized.<br/>           Per (int): Percentage value that effects the number of words <br/>           in a summary.<br/><br/>           Returns:<br/>           summary (str): A summary of the text."""<br/><br/>        nlp = spacy.load('en_core_web_sm')<br/>        doc= nlp(text)<br/>        word_frequencies={}<br/>        for word in doc:<br/>            if word.text.lower() not in list(STOP_WORDS):<br/>                if word.text.lower() not in punctuation:<br/>                    if word.text not in word_frequencies.keys():<br/>                        word_frequencies[word.text] = 1<br/>                    else:<br/>                        word_frequencies[word.text] += 1<br/>        max_frequency=max(word_frequencies.values())<br/>        for word in word_frequencies.keys():<br/>            word_frequencies[word]=word_frequencies[word]/max_frequency<br/>        sentence_tokens= [sent for sent in doc.sents]<br/>        sentence_scores = {}<br/>        for sent in sentence_tokens:<br/>            for word in sent:<br/>                if word.text.lower() in word_frequencies.keys():<br/>                    if sent not in sentence_scores.keys():                            <br/>                        sentence_scores[sent]=word_frequencies[word.text.lower()]<br/>                    else:<br/>                        sentence_scores[sent]+=word_frequencies[word.text.lower()]<br/>        select_length=int(len(sentence_tokens)*per)<br/>        summary=nlargest(select_length, sentence_scores,key=sentence_scores.get)<br/>        final_summary=[word.text for word in summary]<br/>        summary=''.join(final_summary)<br/>        return summary<br/><br/>  @staticmethod<br/>  def get_urls_domains(text: str) -&gt; set:<br/>      """A function that accepts a string of text and<br/>          returns any urls and domain names located within<br/>          the text.<br/>         <br/>          Parmeters:<br/>          text (str): A string of text. <br/>         <br/>          Returns:<br/>          set(urls): A set of urls located within the text<br/>          set(domain_names): A set of domain names located within the text.<br/>      """<br/>      #f = open('/Users/benmccloskey/Desktop/pdf_dashboard/cfg.json')<br/>      #data = json.load(f)<br/>      #url_endings = [end for end in data['REGEX_URL_ENDINGS']['url_endings'].split(',')]<br/>      url_end = 'com,gov,edu,org,mil,net,au,in,ca,br,it,mx,ai,fr,tw,il,uk,int,arpa,co,us,info,xyz,ly,site,biz,bz'<br/>      url_endings = [end for end in url_end.split(',')]<br/>      url_regex = '(?:(?:https?|ftp):\\/\\/)?[\\w/\\-?=%.]+\\.(?:' + '|'.join(url_endings) + ')[^\s]+'<br/>      url_reg_pattern = re.compile(url_regex, re.IGNORECASE)<br/>      url_reg_list = url_reg_pattern.findall(text)<br/>  <br/>  <br/>      url_set = set()<br/>      url_set.update(url_reg_list)<br/>      <br/>      domain_set = set()<br/>      domain_regex = r'^(?:https?:\/\/)?(?:[^@\/\n]+@)?(?:www\.)?([^:\/\n]+)'<br/>      domain_pattern = re.compile(domain_regex, re.IGNORECASE)<br/>      for url in url_set:<br/>          domain_set.update(domain_pattern.findall(url))<br/>  <br/>      return str(url_set), str(domain_set)</span></pre><h1 id="2e45" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">仪表板</h1><p id="1ce4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在今天的例子中，我们将解析由 Alex Krizhevsky Ilya Sutskever 和 Geoffrey e . hint on【1】撰写的论文<a class="ae nc" href="https://proceedings.neurips.cc/paper/2012/file/c399862d3b9d6b76c8436e924a68c45b-Paper.pdf" rel="noopener ugc nofollow" target="_blank"><em class="mm">ImageNet class ification with Deep 卷积神经网络</em> </a> <em class="mm"> </em>。</p><h2 id="8619" class="nr kz it bd la ns nt dn le nu nv dp li lz nw nx lk md ny nz lm mh oa ob lo oc bi translated">设置</h2><p id="9894" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">您需要创建一个目录来保存您希望在仪表板中分析的 PDF 文件。然后，您需要初始化 Dash 应用程序。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="42f3" class="ms kz it mo b be mt mu l mv mw">directory = '/Users/benmccloskey/Desktop/pdf_dashboard/files'<br/><br/>app = Dash(__name__, external_stylesheets=[dbc.themes.CYBORG],suppress_callback_exceptions=True)<br/></span></pre><p id="11fa" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">我做了一个名为“文件”的文件夹，我把我想上传的 PDF 文件放在这个文件夹里。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f4a8ea745897a1bc3aa424e6f6ff76ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB2uLwY2wb5ULhVg3hnUAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PDF 解析器仪表板(图片来自作者)</p></figure><p id="4146" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">如上所示，仪表板在初始化时非常简单，但这是意料之中的！没有向应用程序提供任何信息，此外，我不希望应用程序在开始时太忙。</p><h2 id="46c0" class="nr kz it bd la ns nt dn le nu nv dp li lz nw nx lk md ny nz lm mh oa ob lo oc bi translated">骷髅</h2><p id="25b6" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">下一步是创建 dash 应用程序的框架。这真的是 dash 应用程序的脚手架，我们可以在上面放置不同的部分，最终创建最终的架构。首先，我们将添加一个标题，并按照我们想要的方式设计它。你可以在这里得到与不同颜色相关的数字<a class="ae nc" href="https://www.computerhope.com/htmcolor.htm" rel="noopener ugc nofollow" target="_blank"/>！</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="2709" class="ms kz it mo b be mt mu l mv mw">app.layout = html.Div(children =[html.Div(children =[html.H1(children='PDF Parser', <br/>                                          style = {'textAlign': 'center',<br/>                                                   'color' : '#7FDBFF',})])</span></pre><p id="aa48" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">第二，我们可以使用<em class="mm"> dcc。上传</em>允许我们实际上传数据到我们的 dash 应用程序。</p><p id="49e1" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">这是我第一次接受挑战的地方。</p><p id="cd6c" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">Plotly Dash 提供的示例没有显示如何读取 PDF 文件。我配置了以下代码块，并将其附加到 Plotly 提供的摄取代码中。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="f124" class="ms kz it mo b be mt mu l mv mw">if 'csv' in filename:<br/>            # Assume that the user uploaded a CSV file<br/>            df = pd.read_csv(<br/>                io.StringIO(decoded.decode('utf-8')))<br/>        elif 'xls' in filename:<br/>            # Assume that the user uploaded an excel file<br/>            df = pd.read_excel(io.BytesIO(decoded))<br/>        elif 'pdf' in filename:<br/>            pdf = pdfReader(directory + '/' + filename)<br/>            text = pdf.PDF_one_pager()<br/>            emails = pdfParser.get_emails(text)<br/>            ddate = pdf.get_publish_date()<br/>            summary = pdfParser.get_summary(text, 0.1)<br/>            df = pd.DataFrame({'Text':[text], 'Summary':[summary],<br/>                               'Download Date' : [ddate],'Emails' : [emails]})</span></pre><p id="2e20" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">需要的主要改变是强制该函数查看文件名是否在标题末尾有“pdf”。然后，我能够从我最初启动的目录中提取 pdf。<em class="mm">请注意:在代码的当前状态下，任何上传到仪表板的 PDF 文件，如果不在目录文件夹中，将无法被仪表板读取和解析。这是未来的更新！</em> <strong class="ls iu">如果你有任何与文本相关的功能，你可以在这里添加。</strong></p><p id="b05e" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">如前所述，我用来阅读 PDF 文件的包是<em class="mm"> PyPDF2 </em>，还有很多其他的包可以使用。在仪表板的开始启动类大大减少了框架内的混乱。我发现的另一个有用的技巧是，在上传 pdf 文件时解析它，并在代码的后面一行保存数据帧。对于本例，我们将显示与 PDF 文件相关的<em class="mm">文本、摘要、下载日期、</em>和<em class="mm">电子邮件地址</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/38ae5e17eec286d3c9fa3599c628ccec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtZwoia_cALEKj2SY8x-aA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">上传功能(图片来自作者)</p></figure><p id="7356" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">单击上传按钮后，将会打开文件目录的弹出窗口，您可以选择想要解析的 pdf 文件(不要忘记，对于此设置，PDF 必须位于您的仪表板的工作目录中！).</p><p id="51fc" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">文件上传后，我们可以通过返回带有日期时间的文件名来完成该功能，并创建一个 Plotly dash 清单，列出我们希望仪表板解析和显示的 PDF 中的不同功能。下面显示的是实例化回调之前仪表板的完整主体。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="0191" class="ms kz it mo b be mt mu l mv mw">app.layout = html.Div(children =[html.Div(children =[html.H1(children='PDF Parser', <br/>                                          style = {'textAlign': 'center',<br/>                                                   'color' : '#7FDBFF',})]),<br/>                                 <br/>                                 <br/>html.Div([<br/>    dcc.Upload(<br/>        id='upload-data',<br/>        children=html.Div([<br/>            'Drag and Drop or ',<br/>            html.A('Select Files')<br/>        ]),<br/>        style={<br/>            'width': '100%',<br/>            'height': '60px',<br/>            'lineHeight': '60px',<br/>            'borderWidth': '1px',<br/>            'borderStyle': 'dashed',<br/>            'borderRadius': '5px',<br/>            'textAlign': 'center',<br/>            'margin': '10px'<br/>        },<br/>        # Allow multiple files to be uploaded<br/>        multiple=True<br/>    ), <br/>    #Returns info, above the datatable,<br/>    html.Div(id='output-datatable'),<br/>    html.Div(id='output-data-upload')#output for the datatable,<br/>]),<br/><br/>  ])<br/>                                                       <br/>                                                       <br/>def parse_contents(contents, filename, date):<br/>    content_type, content_string = contents.split(',')<br/><br/>    decoded = base64.b64decode(content_string)<br/>    try:<br/>        if 'csv' in filename:<br/>            # Assume that the user uploaded a CSV file<br/>            df = pd.read_csv(<br/>                io.StringIO(decoded.decode('utf-8')))<br/>        elif 'xls' in filename:<br/>            # Assume that the user uploaded an excel file<br/>            df = pd.read_excel(io.BytesIO(decoded))<br/>        elif 'pdf' in filename:<br/>            pdf = pdfReader(directory + '/' + filename)<br/>            text = pdf.PDF_one_pager()<br/>            emails = pdfParser.get_emails(text)<br/>            ddate = pdf.get_publish_date()<br/>            summary = pdfParser.get_summary(text, 0.1)<br/>            df = pd.DataFrame({'Text':[text], 'Summary':[summary],<br/>                               'Download Date' : [ddate],'Emails' : [emails],<br/> '                      URLs' : [urls], 'Domain Names' : [domains]})<br/>    except Exception as e:<br/>        print(e)<br/>        return html.Div([<br/>            'There was an error processing this file.'<br/>        ])<br/><br/>    return html.Div([<br/>        html.H5(filename),#return the filename<br/>        html.H6(datetime.datetime.fromtimestamp(date)),#edit date<br/>        dcc.Checklist(id='checklist',options = [<br/>            {"label": "Text", "value": "Text"},<br/>             {"label": "summary", "value": "Summary"},<br/>            {"label": "Download Date", "value": "Download Date"},<br/>            {"label": "Email Addresses", "value": "Email Addresses"}<br/>        ],<br/>            value = []),<br/>        html.Hr(),<br/>        dcc.Store(id='stored-data' ,data = df.to_dict('records')),<br/><br/>        html.Hr(),  # horizontal line<br/><br/>    ])</span></pre><h2 id="76c9" class="nr kz it bd la ns nt dn le nu nv dp li lz nw nx lk md ny nz lm mh oa ob lo oc bi translated">仪表板清单</h2><p id="f167" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">检查表</strong>。这是我们开始向仪表板添加一些功能的地方。使用<em class="mm"> dcc。Checklist </em>函数，我们可以创建一个列表，允许用户选择他们想要显示的 PDF 的哪些特性。例如，用户可能只想一次看一个特征，这样他们就不会不知所措，可以检查一个特定的模式。或者，用户可能希望将摘要与整个正文进行比较，以查看摘要中是否缺少任何可能需要添加的信息。使用清单的方便之处在于，您可以查看 pdf 中不同批次的功能，这有助于减少感官超负荷。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d362f5a789c028aaff2be160fe9bad08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiF_Ngm0FCRvRSFcYsYdKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">清单(图片来自作者)</p></figure><p id="0a8b" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">pdf 上传后，将显示一个清单，其中没有选择任何项目。在下一节中，看看当我们在清单中选择不同的参数时会发生什么！</p><h2 id="102c" class="nr kz it bd la ns nt dn le nu nv dp li lz nw nx lk md ny nz lm mh oa ob lo oc bi translated">复试</h2><p id="7485" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">回调在 Plotly 仪表盘中极其重要。它们向仪表板添加功能，并使其与用户交互。第一个回调用于上传功能，并确保我们的数据可以上传。</p><p id="a0fe" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">第二个回调显示数据表中的不同数据。它通过调用上传 PDF 时最初创建的已保存数据框来实现这一点。根据选择了清单中的哪些框，将决定数据表中当前显示的信息。</p><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="7df0" class="ms kz it mo b be mt mu l mv mw">@app.callback(Output('output-datatable', 'children'),<br/>              Input('upload-data', 'contents'),<br/>              State('upload-data', 'filename'),<br/>              State('upload-data', 'last_modified'))<br/>def update_output(list_of_contents, list_of_names, list_of_dates):<br/>    if list_of_contents is not None:<br/>        children = [<br/>            parse_contents(c, n, d) for c, n, d in<br/>            zip(list_of_contents, list_of_names, list_of_dates)]<br/>        return children<br/><br/><br/>@app.callback(Output('output-data-upload', 'children'),<br/>              Input('checklist','value'),<br/>              Input('stored-data', 'data'))<br/><br/>def table_update(options_chosen, df_dict):<br/>    if options_chosen == []:<br/>        return True<br/>    df_copy = pd.DataFrame(df_dict)<br/>    text = df_copy['Text']<br/>    emails = df_copy['Emails']<br/>    ddate = df_copy['Download Date']<br/>    summary = df_copy['Summary']<br/>    value_dct = {}<br/>    for val in options_chosen:<br/>        if val == 'Text':<br/>            value_dct[val] = text<br/>        if val == 'Summary':<br/>            value_dct['Summary'] = summary<br/>        if val == 'Download Date':<br/>            value_dct['Download Date'] = ddate<br/>        if val == 'Email Addresses':<br/>             value_dct['Email'] = emails<br/>    dff =  pd.DataFrame(value_dct)<br/>    return dash_table.DataTable(<br/>            dff.to_dict('records'),<br/>            [{'name': i, 'id': i} for i in dff.columns],<br/>            export_format="csv"<br/>            style_data={<br/>                'whiteSpace': 'normal',<br/>                'height': 'auto',<br/>                'textAlign': 'left',<br/>                  'backgroundColor': 'rgb(50, 50, 50)',<br/>                  'color': 'white'},<br/>            style_header={'textAlign' : 'left',<br/>                    'backgroundColor': 'rgb(30, 30, 30)',<br/>                    'color': 'white'<br/>                    })</span></pre><p id="6a2f" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">例如，如果我们想查看位于 PDF 中的<em class="mm">电子邮件</em>、<em class="mm">网址</em>和<em class="mm">域名</em>该怎么办？通过检查清单中的这三个选项，该数据将填充表格并显示在仪表板上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/f1d549daed7f7082e2f6eba7547bcc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYs3M72MNK8E-6n9zSrssA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">清单示例(图片来自作者)</p></figure><p id="d3ea" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">最后，虽然我们可以轻松地将条目复制并粘贴到我们选择的另一个电子表格或数据库中，但左上角的“导出”按钮允许我们下载表格并将其保存到 CSV 文件中！</p><p id="aa9e" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">就是这样！这几个代码块就是在 Plotly 仪表板中对 pdf 执行基本解析功能所需的全部内容。</p><h1 id="724f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="c420" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">今天，我们探讨了数据科学家将 PDF 上传到 Plotly 仪表板并向用户显示特定内容的一个方向。这对于必须从 pdf 中提取特定信息的人来说非常有用。可能是客户的电子邮件、姓名和电话号码)并需要分析这些信息。虽然这个仪表板是基本的，但它可以针对不同风格的 pdf 进行调整。例如，您可能想要创建一个分析仪表板，显示您正在阅读的研究论文 PDF 中的引文，以便您可以保存或使用这些引文来查找其他论文。今天试着把这段代码写出来，如果你添加了任何酷的功能，请告诉我！</p><p id="ce8f" class="pw-post-body-paragraph lq lr it ls b lt mx ju lv lw my jx ly lz mz mb mc md na mf mg mh nb mj mk ml im bi translated">如果你喜欢今天的阅读，请关注我，并告诉我你是否还有其他想让我探讨的话题！如果你没有中等账号，就通过我的链接 <a class="ae nc" href="https://ben-mccloskey20.medium.com/membership" rel="noopener"> <strong class="ls iu">这里</strong> </a> <strong class="ls iu">报名吧！另外，在</strong><a class="ae nc" href="https://www.linkedin.com/in/benjamin-mccloskey-169975a8/" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu">LinkedIn</strong></a><strong class="ls iu">上加我，或者随时联系！感谢阅读！</strong></p><h1 id="a19a" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">完整代码</h1><pre class="kj kk kl km gt mn mo mp bn mq mr bi"><span id="596d" class="ms kz it mo b be mt mu l mv mw">import pandas as pd <br/>from dash import dcc, Dash, html, dash_table<br/>import base64<br/>import datetime<br/>import io<br/>import PyPDF2<br/>from dash.dependencies import Input, Output, State<br/>import re<br/>import dash_bootstrap_components as dbc<br/>import spacy<br/>from spacy.lang.en.stop_words import STOP_WORDS<br/>from string import punctuation<br/>from heapq import nlargest<br/><br/>directory = '/Users/benmccloskey/Desktop/pdf_dashboard/files'<br/><br/>external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']<br/><br/>app = Dash(__name__, external_stylesheets=[dbc.themes.CYBORG],suppress_callback_exceptions=True)<br/><br/>class pdfReader:    <br/>    def __init__(self, file_path: str) -&gt; str:<br/>        self.file_path = file_path<br/>    <br/>    def PDF_one_pager(self) -&gt; str:<br/>        """A function that returnss a one line string of the <br/>            pdfReader object.<br/>            <br/>            Returns:<br/>            one_page_pdf (str): A one line string of the pdf.<br/>        <br/>        """<br/>        content = ""<br/>        p = open(self.file_path, "rb")<br/>        pdf = PyPDF2.PdfFileReader(p)<br/>        num_pages = pdf.numPages<br/>        for i in range(0, num_pages):<br/>            content += pdf.getPage(i).extractText() + "\n"<br/>        content = " ".join(content.replace(u"\xa0", " ").strip().split())<br/>        page_number_removal = r"\d{1,3} of \d{1,3}"<br/>        page_number_removal_pattern = re.compile(page_number_removal, re.IGNORECASE)<br/>        content = re.sub(page_number_removal_pattern, '',content)<br/>        <br/>        return content<br/>  <br/>    def pdf_reader(self) -&gt; str:<br/>        """A function that can read .pdf formatted files <br/>            and returns a python readable pdf.<br/>            <br/>            Returns:<br/>            read_pdf: A python readable .pdf file.<br/>        """<br/>        opener = open(self.file_path,'rb')<br/>        read_pdf = PyPDF2.PdfFileReader(opener)<br/>    <br/>        return read_pdf<br/>  <br/>  <br/>    def pdf_info(self) -&gt; dict:<br/>        """A function which returns an information dictionary<br/>        of an object associated with the pdfReader class.<br/>        <br/>        Returns:<br/>        dict(pdf_info_dict): A dictionary containing the meta<br/>        data of the object.<br/>        """<br/>        opener = open(self.file_path,'rb')<br/>        read_pdf = PyPDF2.PdfFileReader(opener)<br/>        pdf_info_dict = {}<br/>        for key,value in read_pdf.documentInfo.items():<br/>            pdf_info_dict[re.sub('/',"",key)] = value<br/>        return pdf_info_dict<br/>  <br/>    def pdf_dictionary(self) -&gt; dict:<br/>        """A function which returns a dictionary of <br/>            the object where the keys are the pages<br/>            and the text within the pages are the <br/>            values.<br/>            <br/>            Returns:<br/>            dict(pdf_dict): A dictionary of the object within the<br/>            pdfReader class.<br/>        """<br/>        opener = open(self.file_path,'rb')<br/><br/>        read_pdf = PyPDF2.PdfFileReader(opener)<br/>        length = read_pdf.numPages<br/>        pdf_dict = {}<br/>        for i in range(length):<br/>            page = read_pdf.getPage(i)<br/>            text = page.extract_text()<br/>            pdf_dict[i] = text<br/>            return pdf_dict<br/><br/>    def get_publish_date(self) -&gt; str:<br/>          """A function of which accepts an information dictionray of an object<br/>              in the pdfReader class and returns the creation date of the<br/>              object (if applicable).<br/>              <br/>              Returns:<br/>              pub_date (str): The publication date which is assumed to be the <br/>              creation date (if applicable).<br/>          """<br/>          info_dict_pdf = self.pdf_info()<br/>          pub_date= 'None'<br/>          try:<br/>              publication_date = info_dict_pdf['CreationDate']<br/>              publication_date = datetime.datetime.strptime(publication_date.replace("'", ""), "D:%Y%m%d%H%M%S%z")<br/>              pub_date = publication_date.isoformat()[0:10] <br/>          except:<br/>              pass<br/>          return str(pub_date)<br/>    <br/><br/>class pdfParser:<br/>    def __init__(self):<br/>        return<br/>    <br/>    @staticmethod <br/>    def get_emails(text: str) -&gt; set:<br/>        """A function that accepts a string of text and<br/>            returns any email addresses located within the <br/>            text<br/>            <br/>            Parameters:<br/>            text (str): A string of text<br/>            <br/>            Returns:<br/>            set(emails): A set of emails located within<br/>            the string of text.<br/>        """<br/>        email_pattern = re.compile(r'[\w.+-]+@[\w-]+\.[\w.-]+')<br/>        email_set = set()<br/>        email_set.update(email_pattern.findall(text))<br/>  <br/>        return str(email_set)<br/>    <br/>    @staticmethod<br/>    def get_dates(text: str, info_dict_pdf : dict) -&gt; set:<br/>        date_label = ['DATE']<br/>        nlp = spacy.load('en_core_web_lg')<br/>        doc = nlp(text)<br/><br/>        dates_pattern = re.compile(r'(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})')<br/>        dates = set((ent.text) for ent in doc.ents if ent.label_ in date_label)<br/>        filtered_dates = set(date for date in dates if not dates_pattern.match(date))<br/>                             <br/>        return str(filtered_dates)<br/>    <br/>    @staticmethod<br/>    def get_summary(text, per):<br/>        """A function that accepts of a string of text as input<br/>           and a percentange value as input and returns a summary<br/>           of the text.<br/><br/>           Parameters:<br/>           text (str): A string of text to be summarized.<br/>           Per (int): Percentage value that effects the number of words <br/>           in a summary.<br/><br/>           Returns:<br/>           summary (str): A summary of the text."""<br/><br/>        nlp = spacy.load('en_core_web_sm')<br/>        doc= nlp(text)<br/>        word_frequencies={}<br/>        for word in doc:<br/>            if word.text.lower() not in list(STOP_WORDS):<br/>                if word.text.lower() not in punctuation:<br/>                    if word.text not in word_frequencies.keys():<br/>                        word_frequencies[word.text] = 1<br/>                    else:<br/>                        word_frequencies[word.text] += 1<br/>        max_frequency=max(word_frequencies.values())<br/>        for word in word_frequencies.keys():<br/>            word_frequencies[word]=word_frequencies[word]/max_frequency<br/>        sentence_tokens= [sent for sent in doc.sents]<br/>        sentence_scores = {}<br/>        for sent in sentence_tokens:<br/>            for word in sent:<br/>                if word.text.lower() in word_frequencies.keys():<br/>                    if sent not in sentence_scores.keys():                            <br/>                        sentence_scores[sent]=word_frequencies[word.text.lower()]<br/>                    else:<br/>                        sentence_scores[sent]+=word_frequencies[word.text.lower()]<br/>        select_length=int(len(sentence_tokens)*per)<br/>        summary=nlargest(select_length, sentence_scores,key=sentence_scores.get)<br/>        final_summary=[word.text for word in summary]<br/>        summary=''.join(final_summary)<br/>        return summary<br/>    <br/><br/>app.layout = html.Div(children =[html.Div(children =[html.H1(children='PDF Parser', <br/>                                          style = {'textAlign': 'center',<br/>                                                   'color' : '#7FDBFF',})]),<br/>                                 <br/>                                 <br/>html.Div([<br/>    dcc.Upload(<br/>        id='upload-data',<br/>        children=html.Div([<br/>            'Drag and Drop or ',<br/>            html.A('Select Files')<br/>        ]),<br/>        style={<br/>            'width': '100%',<br/>            'height': '60px',<br/>            'lineHeight': '60px',<br/>            'borderWidth': '1px',<br/>            'borderStyle': 'dashed',<br/>            'borderRadius': '5px',<br/>            'textAlign': 'center',<br/>            'margin': '10px'<br/>        },<br/>        # Allow multiple files to be uploaded<br/>        multiple=True<br/>    ), <br/>    #Returns info, above the datatable,<br/>    html.Div(id='output-datatable'),<br/>    html.Div(id='output-data-upload')#output for the datatable,<br/>]),<br/><br/>  ])<br/>                                                       <br/>                                                       <br/>def parse_contents(contents, filename, date):<br/>    content_type, content_string = contents.split(',')<br/><br/>    decoded = base64.b64decode(content_string)<br/>    try:<br/>        if 'csv' in filename:<br/>            # Assume that the user uploaded a CSV file<br/>            df = pd.read_csv(<br/>                io.StringIO(decoded.decode('utf-8')))<br/>        elif 'xls' in filename:<br/>            # Assume that the user uploaded an excel file<br/>            df = pd.read_excel(io.BytesIO(decoded))<br/>        elif 'pdf' in filename:<br/>            pdf = pdfReader(directory + '/' + filename)<br/>            text = pdf.PDF_one_pager()<br/>            emails = pdfParser.get_emails(text)<br/>            ddate = pdf.get_publish_date()<br/>            summary = pdfParser.get_summary(text, 0.1)<br/>            df = pd.DataFrame({'Text':[text], 'Summary':[summary],<br/>                               'Download Date' : [ddate],'Emails' : [emails]})<br/>    except Exception as e:<br/>        print(e)<br/>        return html.Div([<br/>            'There was an error processing this file.'<br/>        ])<br/><br/>    return html.Div([<br/>        html.H5(filename),#return the filename<br/>        html.H6(datetime.datetime.fromtimestamp(date)),#edit date<br/>        dcc.Checklist(id='checklist',options = [<br/>            {"label": "Text", "value": "Text"},<br/>             {"label": "summary", "value": "Summary"},<br/>            {"label": "Download Date", "value": "Download Date"},<br/>            {"label": "Email Addresses", "value": "Email Addresses"}<br/>        ],<br/>            value = []),<br/><br/>        html.Hr(),<br/>        dcc.Store(id='stored-data' ,data = df.to_dict('records')),<br/><br/>        html.Hr(),  # horizontal line<br/><br/>    ])<br/><br/>@app.callback(Output('output-datatable', 'children'),<br/>              Input('upload-data', 'contents'),<br/>              State('upload-data', 'filename'),<br/>              State('upload-data', 'last_modified'))<br/>def update_output(list_of_contents, list_of_names, list_of_dates):<br/>    if list_of_contents is not None:<br/>        children = [<br/>            parse_contents(c, n, d) for c, n, d in<br/>            zip(list_of_contents, list_of_names, list_of_dates)]<br/>        return children<br/><br/><br/>@app.callback(Output('output-data-upload', 'children'),<br/>              Input('checklist','value'),<br/>              Input('stored-data', 'data'))<br/><br/>def table_update(options_chosen, df_dict):<br/>    if options_chosen == []:<br/>        return True<br/>    df_copy = pd.DataFrame(df_dict)<br/>    text = df_copy['Text']<br/>    emails = df_copy['Emails']<br/>    ddate = df_copy['Download Date']<br/>    summary = df_copy['Summary']<br/>    value_dct = {}<br/>    for val in options_chosen:<br/>        if val == 'Text':<br/>            value_dct[val] = text<br/>        if val == 'Summary':<br/>            value_dct['Summary'] = summary<br/>        if val == 'Download Date':<br/>            value_dct['Download Date'] = ddate<br/>        if val == 'Email Addresses':<br/>             value_dct['Email'] = emails<br/>    dff =  pd.DataFrame(value_dct)<br/>    return dash_table.DataTable(<br/>            dff.to_dict('records'),<br/>            [{'name': i, 'id': i} for i in dff.columns],<br/>            style_data={<br/>                'whiteSpace': 'normal',<br/>                'height': 'auto',<br/>                'textAlign': 'left',<br/>                  'backgroundColor': 'rgb(50, 50, 50)',<br/>                  'color': 'white'},<br/>            style_header={'textAlign' : 'left',<br/>                    'backgroundColor': 'rgb(30, 30, 30)',<br/>                    'color': 'white'<br/>                    })<br/><br/>if __name__ == '__main__':<br/>    app.run_server(debug=True)</span></pre><ol class=""><li id="bf58" class="nd ne it ls b lt mx lw my lz nf md ng mh nh ml ni nj nk nl bi translated">克里日夫斯基、亚历克斯、伊利亚·苏茨基弗和杰弗里·e·辛顿。"使用深度卷积神经网络的图像网络分类."<em class="mm">ACM 的通信</em>60.6(2017):84–90。</li></ol></div></div>    
</body>
</html>