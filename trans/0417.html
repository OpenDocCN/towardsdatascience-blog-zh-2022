<html>
<head>
<title>End-to-end Pytorch model in five minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">五分钟内完成端到端Pytorch模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-to-end-pytorch-model-in-five-minutes-a72da7bd4ebb#2022-02-16">https://towardsdatascience.com/end-to-end-pytorch-model-in-five-minutes-a72da7bd4ebb#2022-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d82c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">标准化数据加载器、模型、培训和验证——因此您不必</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7f7b04ec765c96e34c270d76349c15c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cjRpo66SQuQsHKho"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@oceanng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ocean Ng </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在五分钟内编写一个Pytorch模型，需要经历四个步骤:</p><ol class=""><li id="93d3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">导入和预处理(数据集)数据，并对其进行批处理(数据加载器)</li><li id="025b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用<code class="fe mg mh mi mj b">nn.Module</code>建立模型</li><li id="d499" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编写一个训练循环并运行它</li><li id="53b4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在验证集上验证</li></ol><p id="dcab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为MNIST已经被做死了，我们将介绍如何导入火炬视觉数据集，并在五分钟内编写一些代码。由于这个原因，它不会很漂亮，但它会工作。</p><h1 id="75da" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">下载和导入数据</h1><p id="d95b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">因为MNIST已经被做死了，我们将搜索标准的<a class="ae kv" href="https://pytorch.org/vision/stable/datasets.html" rel="noopener ugc nofollow" target="_blank">火炬视觉数据集</a>，看看是否有其他我们想要尝试和预测的东西。让我们来看看Kuzushiji-MNIST，它是MNIST数据集的平假名(日语)替代物，由70，000幅图像组成。你可以在论文<a class="ae kv" href="https://arxiv.org/abs/1812.01718" rel="noopener ugc nofollow" target="_blank"> <em class="nh">日本古典文学的深度学习</em> </a> <em class="nh">中了解创建数据集背后的动机。</em></p><p id="deb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们找到每个通道的均值和标准差。这背后的原因是，我们显然希望归一化我们的训练数据，但Pytorch变换需要预先给定归一化均值和标准差。因此，我们将使用数据集来查找这些值，然后重新导入它，并传递带有预定义值的规范化转换。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="6a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意,<code class="fe mg mh mi mj b">kmnist</code>是一个数据集，所以循环遍历它会在每个实例上给我们一个图像和一个标签。因此，如果我们循环遍历数据集中的每一幅图像，并沿着额外的第四维堆叠它们，我们将得到所有图像的张量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="4908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在计算每个通道的平均值。请注意，调用<code class="fe mg mh mi mj b">imgs.view(1,-1)</code>会将所有张量挤入第二维，导致我们有一个尾随的第一维。因此，我们取第二维像素值的平均值(因此为<code class="fe mg mh mi mj b">dim=1</code>)。我们也对标准差做同样的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="566b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以重新导入我们的数据，使用一个<code class="fe mg mh mi mj b">Normalize</code>变换以及一个将数组转换为张量的变换。请注意，<code class="fe mg mh mi mj b">Normalize</code>转换将像素值的平均值和标准偏差作为参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了数据集，我们需要将这些数据输入到<code class="fe mg mh mi mj b">DataLoader</code>中进行批量处理。如果你在CPU上，一定要设置小一点的批量，设置<code class="fe mg mh mi mj b">num_workers=1</code>(这是GPU的事情，不用太在意)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="1178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以查看数据集中的一些样本。我不打算在这里遍历代码，它应该是不言自明的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/5b9a3231a5932c9278615df090195349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a5CRN3MJq7TPgek-ZZ1u2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><h1 id="3d2f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">构建模型</h1><p id="447b" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这不是一个关于如何从理论上构建深度学习模型的教程。因此，我们将在这里展示这个模型，并且只评论三件事。首先，您需要将您的模型实例化为<code class="fe mg mh mi mj b">nn.Module</code>的实例，方法是将其传递给该类。第二，你需要通过通常的Python方法初始化超类(教程<a class="ae kv" href="https://realpython.com/python-super/" rel="noopener ugc nofollow" target="_blank">这里</a>)。最后，你需要一个模型初始化，在这里我们定义所有的模型层，然后是一个正向方法，告诉模型如何接受输入并通过这些层传递。仅此而已。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个阶段，通过从数据加载器中给模型一个例子来调试模型总是很重要的。然后，我们将这个图像传递给模型，并检查它是否输出了正确大小的东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="d206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完美。我们构建了一个模型，该模型采用K-MNIST图像，并输出10个类别，代表从0到9的每个可能数字的10种不同概率。</p><h1 id="1498" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">编写和运行训练循环</h1><p id="e8dd" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">像往常一样，我们的训练步骤是老一套。向前传球。计算损失。重置梯度(Pytorch专业)。反向传播计算相对于损失的梯度。用这些梯度更新我们的权重。仅此而已(记得将模型设置为<code class="fe mg mh mi mj b">train</code>模式)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="bdc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们实例化我们的模型，设置Adam优化器，并使用交叉熵损失(因为这是一个多类分类问题)。如果你的问题需要你改变这些，优化器和损失函数分别在<code class="fe mg mh mi mj b">torch.optim</code>和<code class="fe mg mh mi mj b">torch.nn</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b0cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后将这些参数传递给训练循环，让它运行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="91fd" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">验证模型</h1><p id="48ea" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们希望事情尽可能简单，所以我们要让我们的验证循环的结构反映训练循环。迭代验证数据加载器中的图像和标签。向前传递，通过找到输出张量中值最高的索引来获得预测(记住，我们输出10个概率的向量)。记住使用<code class="fe mg mh mi mj b">.data.squeeze()</code>来获得实际的标量本身。最后，通过对预测等于标签的所有时间求和(使用<code class="fe mg mh mi mj b">np.sum()</code>和<code class="fe mg mh mi mj b">.item()</code>来避开梯度)，除以标签的总数，打印出准确度。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">验证集准确率为95%。对于五分钟的编码来说还不错。</p><h1 id="f0ce" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论和进一步措施</h1><p id="f76e" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">您可以为自己做几件事来使您的模型变得更好:</p><ul class=""><li id="9279" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nl ly lz ma bi translated"><em class="nh">在模型训练时打印验证集指标:</em>显然，很高兴看到训练损失随着每个时期而减少。但是在我们训练后验证它之前，我们真的不知道模型的表现如何。如果您打印验证准确性，您将对模型的成功有更好的了解。</li><li id="5e30" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nl ly lz ma bi translated"><em class="nh">实施提前停止:</em>一旦验证准确度在一定数量的时期内未能提高(称为耐心)，则返回到最佳执行时期并使用这些权重。</li><li id="9be8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nl ly lz ma bi translated"><em class="nh">看看其他指标:</em>另一个真正强大的指标是曲线下面积(AUC)，通过对所有类使用加权平均精确召回率，可以从二进制到多类分类采用该指标(有关这方面的介绍，请参见此处的<a class="ae kv" href="https://scikit-learn.org/stable/modules/model_evaluation.html#roc-metrics" rel="noopener ugc nofollow" target="_blank"/>)。</li><li id="02be" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nl ly lz ma bi translated"><em class="nh">实现剩余网络架构:</em>自从引入CNN以来，计算机视觉已经走过了漫长的道路。您可以尝试其他架构来提高性能。你甚至可能想试一试计算机视觉转换器。</li></ul><p id="2a5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已。希望这篇文章能够消除大多数Pytorch入门教程中包含的许多不必要的排场。我发现，一旦我知道了深度学习的理论基础，我真的希望有一种资源来帮助我自己构建这些模型的纯端到端过程。我希望这能为你提供这样的资源。</p></div></div>    
</body>
</html>