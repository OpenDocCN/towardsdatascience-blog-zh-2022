<html>
<head>
<title>Create Your requirements.txt Using This Technique</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用这种技术创建requirements.txt</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-your-requirements-txt-using-this-technic-4f5e9376a02e#2022-04-13">https://towardsdatascience.com/create-your-requirements-txt-using-this-technic-4f5e9376a02e#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="efce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止使用没有附加过滤器的“pip冻结”</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a7baaa289e71a6febf35e1e661b10a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mfc_mWfWzU-giTiXwvFMYA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@theforestbirds?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joel&amp;Jasmin fr estbird</a>在<a class="ae kv" href="https://unsplash.com/s/photos/snow-landscape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7696" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">简介</strong></p><p id="b3b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">requirements.txt</code>文件是Python数据科学或机器学习项目中非常重要的文档，因为它不仅列出了运行代码所必需的包，还注册了它们各自的版本。这些数据增加了项目的可重复性，例如，允许其他人在他们的机器上创建一个新的虚拟环境，激活它，并运行<code class="fe ls lt lu lv b">pip install -r requirments.txt</code>。因此，用户将在本地安装相同的软件包，具有相同的版本，所有这一切都在几秒钟内完成。</p><p id="f550" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">传统</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">requirements.txt</strong></code>的问题<strong class="ky ir">文件</strong></p><p id="08be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个<code class="fe ls lt lu lv b">requirements.txt</code>文件最常用的技术是当所有的包都已经安装好的时候运行<code class="fe ls lt lu lv b">pip freeze &gt; requirements.txt</code>。然而，这种方法的问题是，它不仅将您通过<code class="fe ls lt lu lv b">pip install &lt;package_name&gt;</code>实际安装的Python包保存到<code class="fe ls lt lu lv b">requirements.txt</code>中，还保存了它们自己的依赖包。这就是我的意思。</p><p id="a4b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑下面的场景:在一个新的虚拟环境中，我将只安装Pandas和Django作为我的项目的Python额外包。所以，我只是跑:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9084" class="ma mb iq lv b gy mc md l me mf">pip install pandas django</span></pre><p id="2fa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这两个重要的Python模块依赖于其他包才能正常工作。例如，Pandas是建立在Numpy之上的，所以前者将在运行<code class="fe ls lt lu lv b">pip install pandas</code>时自动安装，以便我们可以使用后者。</p><p id="9181" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django也是如此:当执行<code class="fe ls lt lu lv b">pip install django</code>时，其他包会同时自动安装，因为Django依赖它们来运行。如果您现在执行<code class="fe ls lt lu lv b">pip freeze &gt; requirements.txt</code>，您将不会有一个只有两行的新文件，而是有9行(一个用于Pandas，一个用于Django，七个不必要的用于它们的依赖项)。</p><p id="5b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是纯<code class="fe ls lt lu lv b">pip freeze</code>方法最让我恼火的地方:它用不必要的信息污染了你的<code class="fe ls lt lu lv b">requirements.txt</code>(所有额外的依赖包)。拥有一个实际上只列出你使用<code class="fe ls lt lu lv b">pip</code>安装的软件包的<code class="fe ls lt lu lv b">requirements.txt</code>不是更好吗？如果你的答案是肯定的，请继续阅读，我将向你展示如何用<code class="fe ls lt lu lv b">grep</code> Linux命令做到这一点。</p><p id="70a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我现在创建一个</strong> <code class="fe ls lt lu lv b"><strong class="ky ir">requirements.txt</strong></code> <strong class="ky ir">文件</strong></p><p id="5766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我只安装了Django和Pandas，所以我想在我的<code class="fe ls lt lu lv b">requirements.txt</code>中只列出这两个。以下命令正是这样做的:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c981" class="ma mb iq lv b gy mc md l me mf">pip freeze | grep -i pandas &gt;&gt; requirements.txt</span><span id="2f2e" class="ma mb iq lv b gy mg md l me mf">pip freeze | grep -i django &gt;&gt; requirements.txt</span></pre><p id="662d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这两个命令之间唯一的区别是包名。</p><p id="5fa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，新的命令结构有一个管道(符号<code class="fe ls lt lu lv b">|</code>)。它允许<code class="fe ls lt lu lv b">pip freeze</code>的输出被用作<code class="fe ls lt lu lv b">grep</code>命令的输入，这将只保留出现单词<code class="fe ls lt lu lv b">pandas</code>和<code class="fe ls lt lu lv b">django</code>的行。添加<code class="fe ls lt lu lv b">-i</code>标志使<code class="fe ls lt lu lv b">grep</code>不区分大小写是必要的，因为有些封装在<code class="fe ls lt lu lv b">pip freeze</code>中以首字母列出。然后我们使用<code class="fe ls lt lu lv b">&gt;&gt;</code>符号将这个新的过滤列表附加到<code class="fe ls lt lu lv b">requirements.txt</code>文件中。</p><p id="fed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">创建一个BASH函数来自动化这个过程</strong></p><p id="ffd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进一步说，我认为有一个bash函数是很有趣的，当使用任意数量的Python包名作为参数调用时，可以用<code class="fe ls lt lu lv b">pip</code>安装它们，并自动将它们的信息附加到一个<code class="fe ls lt lu lv b">requirements.txt</code>文件中。因此，在网上做了一些研究后，我创建了bash函数，如下所示:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a42d" class="ma mb iq lv b gy mc md l me mf">pip_requirements() {</span><span id="cc70" class="ma mb iq lv b gy mg md l me mf">if test "$#" -eq 0<br/>then <br/>  echo $'\nProvide at least one Python package name\n' <br/>else <br/>  for package in "$@"<br/>  do<br/>    pip install $package<br/>    pip freeze | grep -i $package &gt;&gt; requirements.txt<br/>  done<br/>fi</span><span id="f784" class="ma mb iq lv b gy mg md l me mf">}</span></pre><p id="c913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的终端会话中创建了这个函数之后，您将能够调用它来代替纯粹的<code class="fe ls lt lu lv b">pip install</code>命令。这里有一个例子:</p><p id="3bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">pip_requirements django pandas seaborn streamlit</code></p><p id="0dfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，只需上面的命令，您就可以安装这四个Python包，并创建一个只有它们的名称和版本号的干净的<code class="fe ls lt lu lv b">requirements.txt</code>。</p><p id="5bef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结束语</strong></p><p id="b424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我的<code class="fe ls lt lu lv b">requirement.txt</code>文件摆脱了不必要的信息，我想我可以睡得更好，甚至生活得更幸福！</p><p id="b80d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">玩笑归玩笑，尽管这些过程对某些人来说似乎太麻烦了，但我确实认为一个更干净的<code class="fe ls lt lu lv b">requirements.txt</code>文件结合了Python从我们的项目中删除不必要代码的理念。当我们想要快速检查项目所有者实际上安装了什么样的包来构建他们的代码时，这也会有所帮助。</p><p id="bac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">亲爱的读者，非常感谢你花时间和精力阅读我的文章。</p><div class="mh mi gp gr mj mk"><a rel="noopener follow" target="_blank" href="/build-a-django-crud-app-by-using-class-based-views-12bc69d36ab6"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">使用基于类的视图构建Django CRUD应用程序</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">是的，对姜戈来说就是这么简单和快速</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">towardsdatascience.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kp mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a rel="noopener follow" target="_blank" href="/django-first-steps-for-the-total-beginners-a-quick-tutorial-5f1e5e7e9a8c"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">Django初学者的第一步:快速教程</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">了解如何在Django应用程序中嵌入Plotly图形，以及其他主题</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">towardsdatascience.com</p></div></div><div class="mt l"><div class="mz l mv mw mx mt my kp mk"/></div></div></a></div><div class="mh mi gp gr mj mk"><a href="https://medium.com/analytics-vidhya/python-and-openpyxl-gather-thousands-of-excel-workbooks-into-a-single-file-eff4e8c9b514" rel="noopener follow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">Python和Openpyxl:将数千个Excel工作簿收集到一个文件中</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">使用Python成为电子表格向导！</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">medium.com</p></div></div><div class="mt l"><div class="na l mv mw mx mt my kp mk"/></div></div></a></div><p id="968f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有很多关于Python和Django的文章。如果你喜欢这篇文章，<a class="ae kv" href="https://fabriciusbr.medium.com/" rel="noopener">可以考虑在媒体</a>上关注我，并在我发表新文章后订阅接收媒体通知。</p><p id="89c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nb">编码快乐！</em></p></div></div>    
</body>
</html>