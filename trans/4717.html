<html>
<head>
<title>From Raw Videos to GAN Training</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从原始视频到GAN培训</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-raw-videos-to-gan-training-implementing-a-data-pipeline-and-a-lightweight-deep-learning-6274de917be9#2022-10-20">https://towardsdatascience.com/from-raw-videos-to-gan-training-implementing-a-data-pipeline-and-a-lightweight-deep-learning-6274de917be9#2022-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="679b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在AWS上使用ClearML实现数据管道和轻量级深度学习数据湖</h2></div><h1 id="a711" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">介绍</h1><p id="fb05" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae lt" href="https://hourone.ai/" rel="noopener ugc nofollow" target="_blank"> Hour One </a>是一家以人工智能为中心的初创公司，其主要产品是将文本转换成<em class="lu">虚拟人类主持人</em>的视频。</p><p id="6d64" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">仅基于文本生成真实、流畅和引人注目的人类演讲者用多种语言说话和打手势的视频是一项具有挑战性的任务，这需要训练复杂的深度学习模型——以及大量的训练数据。</p><p id="5767" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">这篇文章描述了我使用<a class="ae lt" href="https://github.com/allegroai/clearml" rel="noopener ugc nofollow" target="_blank"> ClearML </a>和AWS为Hour One构建的数据管道和数据管理解决方案的设计和实现。</p><p id="ae62" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">该解决方案基于轻量级版本的<br/> <a class="ae lt" rel="noopener" target="_blank" href="/deep-lake-an-architectural-blueprint-for-managing-deep-learning-data-at-scale-part-i-effafd488e7c"> Deep Lake架构模式</a>。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/bab19d82141a013510c4268b3ebd183b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpO43o1SrOpu3D0fle_86A.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">视频深度学习的数据管道和数据管理。作者图片</p></figure><p id="e05e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">注意:我与ClearML项目或其支持者没有任何关系。</p><h1 id="e3ac" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">从视频到准备好的数据集</h1><p id="2248" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Hour One的人工智能模型需要将文本作为输入，并生成逼真的视频作为输出。</p><p id="23c6" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">实现这一点的一种方法是通过在真人展示各种文本的视频上训练模型。</p><p id="285e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">该模型然后尝试预测视频中的下一帧或帧序列，同时最小化损失函数，这有助于确保输出是真实的和高质量的。</p><p id="513b" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">从数据准备和管理的角度来看，这需要:</p><p id="7a47" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">将视频数据转换为有用的表示形式— </strong>使训练人员能够专注于输入的正确“特征”。<br/> <br/>例如，以一种用于频谱分析的格式表示音频，或者将视频像素编码成一种可以馈入模型的紧凑格式。</p><p id="b074" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">丰富提供详细监督的数据层— <br/> </strong>天真地，被训练来预测图像的模型可以尝试最小化与地面真实图像的简单像素距离。<br/>然而，这个损失函数可能不是考虑真实性、平滑性或一致性的最佳方式。</p><p id="ebad" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">为了支持更详细的监督，在训练期间可以使用附加的注释或数据层。<br/>例如，考虑一层关于视频中每一帧中人脸确切位置的信息(“注释”)。</p><p id="5a2e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">这些层可以由人工注释器以编程方式生成，也可以两者都有。</p><p id="8442" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">清理数据以确保其适合训练— </strong>例如，删除不包含对着摄像机说话的人的部分。<br/>一些清洗逻辑需要在转换的甚至是丰富的数据上运行。</p><p id="f513" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">捕获元数据</strong> —为了帮助构建多样化且平衡的数据集，我们需要将数据映射到多个领域维度，例如演讲者的性别、照明条件、语音质量等。</p><p id="7126" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">元数据可以描述整个视频、视频的片段或视频内非常短的序列，例如帧级别。</p><p id="0023" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">作为从源获取数据的一部分，可以提供描述整个视频的一些基本维度。</p><p id="6412" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">在其他情况下，需要计算元数据，例如通过附加的深度学习算法对数据进行推断。</p><p id="eb11" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">长期存储数据+元数据— </strong>所有形式的数据都需要长期存储，<strong class="kz ir"> </strong>包括原始的、经过转换和丰富的以及精选的数据集。</p><p id="9677" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">使数据可搜索— </strong>该解决方案需要允许<strong class="kz ir"> </strong>研究人员通过搜索具有所需属性/维度/元数据组合的实例的数据来快速构建数据集，例如“获取100个训练实例，其中多达40%应该具有闪烁的字符”。</p><p id="0a60" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">构建和存储版本化的训练数据集— </strong>一旦为数据集选择了实例，它就应该以版本化的方式存储，并在需要时被拉入训练机器。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mq"><img src="../Images/b6981eb0a97eb03d23bca2329a78e7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LjxSpeLqFY0Vcx1gtB7-8w.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">光深湖的视频资料。作者图片</p></figure><p id="2fdf" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">让我们深入了解解决方案每个部分的需求。</p><h1 id="c59b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">要求</h1><h2 id="3343" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">管道</h2><p id="ea3d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据流水线子系统的目标是执行处理步骤的DAG，并发出数据，这些数据随后将被存储在数据管理子系统中。</p><p id="a48b" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">输入和触发</strong></p><p id="01dd" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">管道的输入是一个文件，其中包含指向原始视频的指针，以及一些关于其内容的元数据。</p><p id="16dc" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">流水线通常在获取新数据后被触发，并且只处理新的数据增量。</p><p id="70d0" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">有时，我们可能会选择从头开始对所有数据运行它，或者对输入数据的特定子集运行它。</p><p id="30c5" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">加工</strong></p><p id="8afb" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">管道应该运行多个异构的数据处理步骤。一些步骤可以运行外部过程，一些可以运行模型的推断，一些可以执行图像或信号处理。</p><p id="141b" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">每个步骤的输出可以被过程中的下一个步骤、训练过程或两者使用。</p><p id="821f" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">扩展性和进化</strong></p><p id="6de3" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">一些低级处理阶段被认为是相对稳定的，不太可能经常改变。</p><p id="f0af" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">管道的其他部分，如浓缩逻辑，将继续高速发展——我们需要<strong class="kz ir">允许研究人员在不依赖工程师的情况下在管道</strong>中增加浓缩阶段。</p><p id="bd25" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">子DAG执行和回填</strong></p><p id="a91a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">当管道逻辑发展时，新的逻辑需要在整个数据语料库上运行。在数据工程中，这通常被称为“回填”或“填充”。</p><p id="44b4" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">在我们的案例中，由于数据的大小和处理的复杂性，在整个数据语料库上重新运行整个管道是一项昂贵且耗时的工作。</p><p id="7b3e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">因此，流水线需要支持触发部分执行，即<strong class="kz ir">只运行用户指定的子DAG </strong>。</p><p id="a324" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">结果缓存</strong></p><p id="32ed" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">作为一个相关的要求，我们希望管道能够“<strong class="kz ir">缓存感知</strong>”——即跳过昂贵的处理阶段，以防自上次执行以来数据、代码和配置没有任何变化。</p><p id="e4b0" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">输出处理语义</strong></p><p id="7713" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">当对旧数据运行管道时，我们可能会决定覆盖旧数据，或者将输出作为新版本的数据追加。</p><p id="b9d3" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">横向扩展<br/> </strong>随着数据量的不断增长，我们需要一个能够在多台机器上运行的解决方案<strong class="kz ir"/>。</p><p id="ce4d" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">在这种模式下工作时，应该可以通过UI或调度程序调用管道。</p><p id="400c" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">本地运行<br/> </strong>与此同时，能够在本地将管道作为完全标准的Python流程运行非常有用——从源代码、包或Docker容器内部运行，而不依赖于云基础设施，也不发布其输出，主要用于开发和本地测试。</p><p id="7092" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir"> CPU和GPU </strong></p><p id="2a13" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">流水线中的一些阶段执行适合CPU的视频裁剪或编码/解码等活动，一些阶段执行深度学习模型的推断(例如，检测演员面部周围的边界框)，这些活动受益于GPU加速。</p><p id="6955" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">用户应该能够以声明的方式指定哪些任务应该在哪个处理单元上运行。</p><h2 id="c511" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">数据管理</h2><p id="1380" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据管理子系统的目标是长期存储数据和元数据。此外，它应该:</p><ol class=""><li id="4bbc" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ni nj nk nl bi translated">使数据可搜索并可访问以构建数据集</li><li id="b959" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">以版本控制的方式支持新数据集的创建</li><li id="4027" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">允许用户下载数据集进行培训</li></ol><p id="b04e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">存储</strong></p><p id="e4dd" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">对于长期存储，我们需要一种可扩展的对象存储技术，如S3。</p><p id="9d6a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">媒体存储格式</strong></p><p id="da63" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">我们希望以标准格式存储较大的媒体文件，包括原始文件和预处理文件，以便尽可能使用标准工具(例如. mp4、.哇哇，还有。png)</p><p id="6986" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">元数据存储和模式<br/> </strong>遵循<a class="ae lt" rel="noopener" target="_blank" href="/deep-lake-an-architectural-blueprint-for-managing-deep-learning-data-at-scale-part-i-effafd488e7c"> Deep Lake架构模式</a>，元数据应该使用提供结构的格式存储，并且是可查询的。</p><p id="e093" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">同时，我们需要在模式管理中允许高度的灵活性，而不引入复杂或僵化的数据引擎。</p><p id="f7f4" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">数据版本化<br/> </strong>媒体文件的底层和繁重的预处理逻辑不会经常改变，如果改变了，通常覆盖以前的版本是安全的。</p><p id="19d0" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">另一方面，丰富逻辑往往会随着时间而变化，在数据足迹方面更轻(想想边界框和地标坐标)，因此它们的输出应该被版本化。</p><p id="6086" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">训练数据集应该受版本控制。</p><h1 id="3791" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">ClearML 101</h1><p id="af7f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><a class="ae lt" href="https://clear.ml/docs/latest/docs/" rel="noopener ugc nofollow" target="_blank"> ClearML </a>是一个开源的MLOps项目，它结合了实验跟踪、数据集管理、远程代码执行和用Python编写的作业管道。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nr"><img src="../Images/c5e10f6bd0d3059c041e1994dc78a931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wpKcLakjr8fP3JDI.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">ClearML HL架构。图片来自ClearML github项目<a class="ae lt" href="https://raw.githubusercontent.com/allegroai/clearml-docs/main/docs/img/clearml_architecture.png" rel="noopener ugc nofollow" target="_blank">https://raw . githubusercontent . com/allegro ai/clear ml-docs/main/docs/img/clear ml _ architecture . png</a></p></figure><h2 id="ad51" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">任务和实验跟踪</h2><p id="1fa6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在高层次上，您可以用几行代码来检测Python程序，以将其连接到ClearML。一个被检测的Python程序被称为一个<strong class="kz ir"> <em class="lu">任务</em> </strong>。</p><p id="0039" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">当<em class="lu">任务</em>执行时，例如在您的本地机器上，插装代码自动收集信息，例如命令行参数、git diff和latest commit、解释器可用的Python包列表，甚至ML工具的特定状态，例如PyTorch指标。</p><p id="6d5a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">然后，被跟踪的元数据被发送到ClearML服务器并存储在那里，可以通过UI和API访问。</p><p id="b4d7" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">您还可以在任务执行期间从代码中显式报告数据。这对于例如在训练过程中跟踪指标是有用的。</p><h2 id="b96c" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">远程执行</h2><p id="0221" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当ClearML跟踪一个<em class="lu">任务</em>时，服务器会存储复制它所需的所有信息——包括在远程机器上运行它。</p><p id="1b0a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">为了在远程机器上执行一个任务，您“克隆”它(通过UI或API调用)，并把它放在一个<em class="lu">队列中。</em></p><p id="6110" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">运行在远程机器上的一个<a class="ae lt" href="https://clear.ml/docs/latest/docs/clearml_agent/" rel="noopener ugc nofollow" target="_blank"> <em class="lu">阿根</em> </a> t轮询新<em class="lu">任务</em>的队列，一旦它将一个任务出队，它就将其作为一个(本地)Python进程来执行。运行<em class="lu">代理</em>的远程机器称为<em class="lu">工作器</em>。</p><h2 id="d3b9" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">管道</h2><p id="13b3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">任务的DAG被称为<strong class="kz ir"> <em class="lu">流水线。<br/> </em> </strong>流水线的流程由一个<strong class="kz ir"> <em class="lu">控制器</em> </strong> <em class="lu"> </em>任务——另一个触发任务执行的Python函数，在它们之间传递参数和信息。</p><p id="8d2a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><em class="lu">控制器</em>通常会执行<em class="lu">任务</em>，将它们发送到<strong class="kz ir"> <em class="lu">队列</em> </strong>，在那里它们将被<strong class="kz ir"> <em class="lu">工作器</em> </strong> <em class="lu">拾取。</em></p><h2 id="a2a4" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">数据集</h2><p id="bdd3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一个<strong class="kz ir"> <em class="lu">数据集</em> </strong>是一种特殊的<em class="lu">任务</em>，其中用户报告“数据”而不是像正常实验中那样报告度量。</p><p id="9983" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">数据可以是任何东西，但通常是存储在某个文件系统上的文件，如挂载的磁盘、NFS或对象存储。</p><p id="2579" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">数据集可以用与Git类似的方式进行版本化，每次提交版本时，它只存储与以前版本的差异。</p><p id="77ea" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">关于数据集的元数据存储在ClearML服务器中，而实际数据(例如数据集中包含的文件)可以存储在您选择的存储设备中，例如S3或NFS服务器，只要它可供需要下载和使用它的<em class="lu">工作者</em>机器使用。</p><h1 id="6c5b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">为什么是ClearML</h1><h2 id="d60f" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">功能适用性</h2><p id="6781" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">ClearML支持所有主要的功能需求:</p><ul class=""><li id="856e" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ns nj nk nl bi translated">在Python中定义和运行媒体处理管道</li><li id="ffaf" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">在CPU和GPU上以远程/分布式执行方式运行管道。</li><li id="3046" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">长期存储大量二进制或半结构化文件，并将其管理和保存到数据集中。</li><li id="ae6c" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">允许下游处理步骤和训练过程容易地使用数据集。</li></ul><p id="7918" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">ClearML可以执行所有这些任务。</p><p id="7a88" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">然而，如果你一直在关注，你会注意到ClearML <em class="lu">并没有</em>提供一种可以在数据集内存储的数据上运行的查询语言，而这是我们需求的一部分。</p><p id="8ddb" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">然而，正如我们将看到的，我们有一个解决这个限制的方案，成功地完成了工作。</p><h2 id="baf6" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">赞成的意见</h2><p id="df07" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然有许多工具可以实现这一功能，但Hour One AI团队已经采用ClearML进行实验跟踪。</p><p id="7d64" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">与此同时，该团队在运行关系数据仓库或云基础设施方面的经验要少得多，因此该工具的Pythonic式和熟悉的界面对其有利。</p><p id="f51a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">作为一个更普遍的优势，该工具是开源的，并且有一个活跃的社区。</p><p id="1edf" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">最后，我们知道ClearML非常灵活，一旦你掌握了任务和远程执行机制，你就可以构建非常复杂的工作流——所以我们知道我们可以让它工作。</p><h2 id="2cb9" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">骗局</h2><p id="3302" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该工具的自动特性是有代价的——当事情不按预期运行时，需要时间来理解发生了什么。</p><p id="9517" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">调试没有按预期执行的ClearML代码需要打开工具的代码，通过它进行调试，在slack上提出问题，并且通常具有分布式计算、云API、Python依赖管理、docker内部机制等方面的工作知识。</p><p id="a100" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">退一步说，文档可能是不完整的。</p><p id="9b9d" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">最后，灵活性也是一个缺点——因为ClearML不是一个固执己见的工具。这意味着你通常可以让它做你想做的事情，但你需要知道你在做什么才能让你的工作流有意义。</p><h1 id="a444" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">系统设计</h1><h2 id="2652" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">高水平（位）</h2><ul class=""><li id="48b8" class="nd ne iq kz b la lb ld le lg nt lk nu lo nv ls ns nj nk nl bi translated">该工作流被实现为一个ClearML <strong class="kz ir"> <em class="lu">管道</em> </strong>(具体来说——使用<a class="ae lt" href="https://clear.ml/docs/latest/docs/pipelines/pipelines_sdk_function_decorators/" rel="noopener ugc nofollow" target="_blank"> PipelineDecorator </a>)。</li><li id="3648" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">流水线中的每个<strong class="kz ir"> <em class="lu">任务</em> </strong>以一个<strong class="kz ir"> <em class="lu">数据集</em> </strong> ID为输入，生成一个或多个<strong class="kz ir"> <em class="lu">数据集</em> </strong>作为输出。</li><li id="4901" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">关于生成数据的元数据(包括世系)长期存储在<strong class="kz ir"> <em class="lu">数据集中。</em> </strong>数据本身以多种不同的格式驻留在S3上。</li><li id="7394" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">使用<strong class="kz ir"> <em class="lu"> ClearML队列</em> </strong>和<strong class="kz ir"> <em class="lu">自动缩放器</em> </strong>来缩放流水线</li><li id="2c8e" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">大多数其他需求(缓存、子DAG执行、使用相同的代码库在本地和远程运行)都是通过仔细分离关注点以及使用低级ClearML API来实现的。</li></ul><h2 id="3d37" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">逻辑流程</h2><p id="6661" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">按照图表从左到右:</p><ul class=""><li id="51ba" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ns nj nk nl bi translated">管道由一个参数触发，该参数将管道指向一个包含原始视频链接的文件。<br/>文件被添加到代表“所有原始数据”的数据集中。</li><li id="8202" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">第一个任务是根据文件中存在的元数据将原始视频分割成更短的部分(“片段”)。<br/>结果是分割的视频和元数据文件，每个都存储为ClearML数据集。</li><li id="2576" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">下一步是对来自分离视频的视频和音频数据的基本预处理。<br/>每个都存储到ClearML数据集中。</li><li id="167c" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">进一步丰富和净化音频和视频信号——另外约10项任务。</li></ul><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nw"><img src="../Images/6b2432bc698510c486b87950bb014dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NOe8_WZ-q4HGZ_jMjUAFWA.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">管道逻辑流和输出数据集。作者图片</p></figure><h2 id="a9fa" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">数据管理</h2><ul class=""><li id="bcb7" class="nd ne iq kz b la lb ld le lg nt lk nu lo nv ls ns nj nk nl bi translated">每个<em class="lu">任务</em>的每次运行都会生成一个或多个独立的ClearML <em class="lu">数据集</em>。</li><li id="2ce3" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">每个<em class="lu">数据集</em>对象包含一个指向<em class="lu">任务</em>的指针，任务为沿袭创建了数据集<em class="lu">对象(反之亦然)。<br/>这使我们能够提取特定管道运行产生的所有不同数据集。</em></li><li id="83f7" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">每个数据集包含其包含的视频片段的索引。</li><li id="96d1" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">大型媒体文件以它们的标准格式存储在S3上，ClearML <em class="lu">数据集</em>使用<a class="ae lt" href="https://clear.ml/docs/latest/docs/references/sdk/dataset/#add_external_files" rel="noopener ugc nofollow" target="_blank">外部文件</a>机制保存它们在S3上的位置的引用。</li><li id="16c6" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">较小的文件被克隆并以ClearML格式存储(也在S3上)。</li></ul><p id="3e8a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">元数据模式和查询处理</strong></p><p id="b0c1" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">正如上面所讨论的，我们希望允许研究人员在不需要了解关系数据库和其他外部工具的情况下轻松地发展模式。</p><p id="0b6f" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">此外，管道计算的许多元数据是半结构化的，例如，视频中每一帧的边界框或面部标志。</p><p id="f5c2" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">数据的结构使得通过关系查询引擎进行查询有点困难。</p><p id="9d0d" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">我们决定避免向解决方案中添加另一个移动部分，并保持它纯粹基于ClearML。下面是我们实现查询的方法:</p><ol class=""><li id="21ad" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ni nj nk nl bi translated">研究者获得他们想要查询的数据集id的列表。典型地，这些将包括元数据或注释(不是媒体)。</li><li id="b834" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">使用ClearML工具，用户下载这些数据集并将其合并到本地数据集副本中。<br/>例如——获取代表人脸边界框和界标的数据集。</li><li id="c8f9" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">研究人员使用numpy或Pandas code等标准工具执行“查询”,以便选择她想要训练的数据。<br/>例如，迭代表示面部边界框的Numpy数组，并且仅过滤掉边界框的总面积大于X并且所有界标都落在边界框内的元素。<br/>该“查询”结果中的每个元素将包含一个指针，该指针指向它所源自的帧和视频。</li><li id="917a" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">研究人员以编程方式创建一个新的数据集，其中包含ClearML中经过过滤的视频。</li><li id="630c" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">稍后，训练代码将数据集从(4)下载到本地磁盘，并开始训练。</li></ol><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nx"><img src="../Images/cf002143a407c698b7c86edfc8a9b77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sb13P37-YO3N-I1BEMldag.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">使用ClearML数据集的查询流。作者图片</p></figure><p id="0c10" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">实际上，构建数据集的过程涉及满足数据集结构约束的线性规划。</p><h2 id="ca3b" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">基于远程和集群的执行</h2><p id="cb0a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该过程工作如下:</p><ol class=""><li id="d5d1" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ni nj nk nl bi translated">用户触发管道执行——通过在她的机器上运行管道或者通过UI</li><li id="997c" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">ClearML服务器接收呼叫</li><li id="006b" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">ClearML服务器将代表流水线逻辑(<strong class="kz ir"> <em class="lu">【控制器】</em> </strong>)的任务的执行排入<strong class="kz ir"> <em class="lu">队列</em> </strong></li><li id="9724" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">运行在某台机器上的一个<strong class="kz ir"> <em class="lu">代理</em> </strong>拉这个任务</li><li id="d2d4" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><strong class="kz ir"> <em class="lu">代理</em> </strong>开始执行管道方法代码。</li><li id="29a9" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><strong class="kz ir"> <em class="lu">控制器</em> </strong>为流水线中的每一步产生ClearML <strong class="kz ir"> <em class="lu">任务</em> </strong>，并将它们放入<strong class="kz ir"> <em class="lu">队列</em> </strong></li><li id="f9eb" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">额外的工人机器拉出这些<strong class="kz ir"> <em class="lu">任务</em> </strong>并在本地启动它们</li><li id="2e37" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">每个任务逻辑调用ClearML数据集API来创建它的输出<strong class="kz ir"> <em class="lu">数据集</em> </strong>，其中元数据存储在ClearML服务器上，实际数据存储在S3上。</li></ol><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ny"><img src="../Images/760d30afcbee74e96907c5456b50d70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*sBVdQij44V4vOj2lYOQX_A.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">带有远程任务执行的ClearML管道。作者图片</p></figure><p id="58c0" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">自动缩放</strong></p><p id="e64e" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">让数十台机器持续运行以等待任务排队是没有意义的。</p><p id="5198" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">ClearML提供了一个自动缩放器，能够根据队列的状态上下旋转机器。</p><p id="c010" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">自动缩放流程非常复杂:</p><ol class=""><li id="d664" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ni nj nk nl bi translated">“自动缩放逻辑”实际上是一个ClearML任务，它被放在一个专用队列中(例如“DevOps”队列)。</li><li id="5833" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">一台专用的机器(总是运行的)运行一个代理来监听这个队列。</li><li id="e963" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">代理选择自动缩放任务，该任务基本上永远运行</li><li id="f850" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">任务逻辑包括轮询队列和使用配置，为每个队列启动各种类型的机器</li><li id="2e82" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">使用云提供商API(例如AWS上的Boto3)来启动机器。</li><li id="4f76" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">衍生的机器有一个<a class="ae lt" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html" rel="noopener ugc nofollow" target="_blank">用户数据</a>启动脚本，该脚本用凭证设置它们，并以守护模式启动ClearML代理</li><li id="b4e2" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated">启动脚本完成后，代理将监听队列</li></ol><p id="9d9b" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">小字:</p><ul class=""><li id="d28a" class="nd ne iq kz b la lv ld lw lg nf lk ng lo nh ls ns nj nk nl bi translated">秘密管理由你负责。ClearML希望您输入AWS凭证和git。ssh凭证保存到一个配置文件中，并将其保存在ClearML服务器中——从基本的安全实践来看，这是行不通的。</li><li id="2d3a" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">代理需要访问S3，因此新机器需要能够承担具有适当权限的角色。</li><li id="2b92" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ns nj nk nl bi translated">用户数据脚本是以非常间接的方式生成的——从配置到自动缩放代码到AWS API调用等等。任何错误都很难修复/测试。</li></ul><p id="3b5a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">我们必须找到替代解决方案，例如，使用适当的实例配置文件，并将机密存储在机密管理解决方案中。</p><p id="5850" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">支持GPU和CPU任务</strong></p><p id="b4a9" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">这是通过两个队列实现的，一个用于CPU任务，一个用于GPU任务。</p><p id="76f2" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">每个任务(Python函数)都用它应该被发送到的队列的名称进行了注释。</p><h2 id="7adb" class="mr kg iq bd kh ms mt dn kl mu mv dp kp lg mw mx kr lk my mz kt lo na nb kv nc bi translated">代码级设计笔记</h2><p id="183e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">管道代码库非常简单。以下是我们构建管道的伪示例。</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="08d0" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第7–8行— </strong>主控制器逻辑有一个<em class="lu">pipeline decorator . pipeline()decorator</em><strong class="kz ir">。</strong>此外，它的参数(通常解析自命令行参数)应该可以使用json或pickle进行序列化。</p><p id="2eb1" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第9行</strong> —任何导入都应该在函数内部执行(远程运行时需要)。</p><p id="531a" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第13行</strong> —我们使用一个工厂来创建一个“追踪器”对象。<strong class="kz ir">追踪器是大部分魔法发生的地方。</strong>它有两个实现——一个本地跟踪器(或多或少是无操作的),和一个ClearML跟踪器(实际上针对ClearML执行调用)。</p><p id="9213" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">基于命令行标志实例化正确的类。</p><p id="4a68" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第15–19行</strong> —该流程通过在方法(任务)之间传递数据集id来实现。</p><p id="4d50" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">当这些代码以远程模式在ClearML上运行时，这些调用触发远程任务的创建，并将它们所依赖的先前任务的结果发送给它们。</p><p id="9a01" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">现在让我们来分析一下任务:</p><figure class="mb mc md me gt mf"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a40f" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第1行</strong> —该任务是一个带有ClearML装饰器的纯Python函数。</p><p id="003b" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第3–5行</strong> —该函数执行导入，如果我们希望能够远程运行它，就需要执行导入，然后它初始化自己的<strong class="kz ir">跟踪器</strong>实例。</p><p id="f8b4" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第7–9行</strong>-跟踪器对象负责获取缓存的结果(如果存在)，或者，如果不存在，则将输入数据集下载到本地文件夹。</p><p id="f502" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">第14–15行</strong> —使用跟踪器，我们将第11–12行生成的数据上传到名为“split_videos_media”的ClearML数据集。</p><p id="5115" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">本地运行</strong></p><p id="6404" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">要打开本地运行，我们需要在管道方法之前调用<em class="lu">pipeline decorator . run _ locally()</em>。</p><p id="478f" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">还支持其他一些运行模式，比如:在本地运行管道任务，将任务作为本地进程或远程任务运行。</p><p id="a7a7" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">仅在子Dag上运行</strong></p><p id="2284" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">这也由tracker对象处理，它能够遍历DAG并自动跳过所有不需要的任务。</p><p id="ded2" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">血统追踪</strong></p><p id="6935" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">tracker对象用管道运行ID标记所有任务，并用它创建的数据集列表标记每个任务——这些数据集作为工件存储在ClearML中。</p><p id="bfc3" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated"><strong class="kz ir">附加功能</strong></p><p id="3944" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">跟踪器负责所有的命名、数据收集和报告约定，以便任务作者可以专注于他们的业务逻辑。它还能够将外部任务作为监听器附加到管道执行中，按计划运行等等。</p><h1 id="fd42" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">摘要</h1><p id="9f35" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为训练深度学习模型准备大规模媒体数据需要对原始数据运行多个处理和浓缩步骤。</p><p id="18d5" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">它还要求以一种结构良好的方式存储处理过的数据，这种方式支持版本控制，并使研究人员能够查询数据以构建数据集。</p><p id="846c" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">ClearML可以用来实现以上所有功能。</p><p id="7b5c" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">它的亮点在于其纯粹的Pythonic接口、直观的数据集范式以及对许多非功能性需求的支持，如自动伸缩，尽管这些都是有代价的。</p><p id="19bf" class="pw-post-body-paragraph kx ky iq kz b la lv jr lc ld lw ju lf lg lx li lj lk ly lm ln lo lz lq lr ls ij bi translated">虽然ClearML没有提供数据查询机制，但它仍然可以组织数据，以便拉动数据并在本地执行查询可以完成工作，特别是如果查询发生在数据生命周期中定义明确的点上。</p></div></div>    
</body>
</html>