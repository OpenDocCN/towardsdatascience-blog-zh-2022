<html>
<head>
<title>Python Concurrency — Multiprocessing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python并发性——多重处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-concurrency-multiprocessing-327c02544a5a#2022-08-17">https://towardsdatascience.com/python-concurrency-multiprocessing-327c02544a5a#2022-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0307" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python并发系列的第2部分。多重处理模块使我们能够执行真正的并行任务。然而，有许多事情需要注意。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd93b4c10d86dc2a0e63e1d92d705c0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ApuyM63RkZ0SHzDx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="a126" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">浏览Python并发系列:</h2><p id="b5b6" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated"><em class="mv">上一篇:</em></p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">Python并发性——线程和GIL</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Python并发系列的第1部分。线程是全局解释器锁(GIL)</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ks mz"/></div></div></a></div><p id="3de0" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">接下来的故事:</em></p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/python-concurrency-concurrent-futures-15b56dc9a14d"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">Python并发性——concurrent . futures</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">Python并发系列的第3部分。多线程和多处理带来的界面简单性。</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="nt l nk nl nm ni nn ks mz"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="39c1" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">多处理宣传多核心使用。是不是很多Python用户祈祷的答案？是最终绕过<a class="ae ky" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325"> GIL </a>的方法吗？</p><p id="9ae2" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">首先，这并不新鲜。现在其实已经挺老了。早在2008年，Python 2.6就引入了<em class="mv">多处理</em>模块。</p><p id="6832" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">事实上，我们可以将不同的任务提交给在不同内核中同时执行的不同操作系统进程。然而，这可能不是我们期望的解决方案。有两个主要原因:</p><ul class=""><li id="df27" class="nu nv it me b mf no mi np lp nw lt nx lx ny mu nz oa ob oc bi translated">我们首先需要编写并行代码，在多个内核中运行计算。也就是说，将一个较大的任务分成许多可以并行执行的较小的作业。这样的努力并不总是可能的。</li><li id="e837" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">设计多进程应用程序时，许多细节需要微调。实现流程之间的协调、通信和同步不是一件容易的事情。</li></ul><p id="e211" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">在这个故事中，我们将介绍流程创建和流程间数据共享的基础知识，同时指出哪里可能出错、如何出错以及如何避免出错。故事的最后一部分致力于一个激动人心的话题:多进程和<a class="ae ky" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325">多线程</a>。</p><h2 id="cedf" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">故事结构</h2><ul class=""><li id="159f" class="nu nv it me b mf mg mi mj lp oi lt oj lx ok mu nz oa ob oc bi translated">加速一个过程</li><li id="4e1a" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">子进程和守护进程</li><li id="d019" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">上下文</li><li id="9ce2" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">跨流程共享变量</li><li id="9eec" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">竞争条件和锁</li><li id="5b36" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">队列和管道</li><li id="f515" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">进程池</li><li id="4ec0" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">进程间数据交换的性能</li><li id="d341" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">多处理+多线程？？？</li><li id="0008" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">这个故事的寓意</li></ul><h2 id="b4ff" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">加速一个过程</h2><p id="c3e3" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">如果你熟悉<em class="mv">线程</em>模块，当你使用<em class="mv">多重处理</em>模块时，你会有宾至如归的感觉。相似概念的接口几乎相同。一个恰当的例子是加速一个新过程的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="ebdd" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">做事… <br/>事情做完了</p></blockquote><p id="be92" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">进程</em>对象的初始化参数与<em class="mv">线程</em>对象中的基本相同。主要区别在于，我们需要使用习语来启动新流程:</p><p id="f23d" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><code class="fe ot ou ov ow b">if __name__ == ‘__main__’:</code></p><p id="7af1" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">否则，我们会得到一个RuntimeError，除非是在使用<code class="fe ot ou ov ow b">fork</code>上下文时(我们将在下一节讨论更多关于上下文的内容)。</p><p id="085a" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">与线程不同，我们可以创建许多真正并行的进程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="2dcd" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">1做事… <br/> 0做事… <br/> 2做事… <br/> 4做事… <br/> 3做事… <br/> 1做事<br/> 0做事<br/> 2做事<br/> 4做事<br/> 3做事</p></blockquote><p id="3e4b" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">这是正确的；<a class="ae ky" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325"> GIL </a>不干涉进程；它们是同时发生的。</p><h2 id="5f5f" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">子进程和守护进程</h2><p id="ba85" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">任何进程都可以启动新的进程；即，它可以有“子”进程，除非“父”进程是一个<em class="mv">守护进程</em>进程。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="e234" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">父母睡眠5秒… <br/>孩子睡眠5秒… <br/>父母完成<br/>孩子完成</p></blockquote><p id="dbf3" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">在这个例子中，<code class="fe ot ou ov ow b">foo</code>进程从主进程开始；是的，您可能创建的所有流程都是主Python流程的子流程。然后，<code class="fe ot ou ov ow b">foo</code>进程启动它自己的子进程(<code class="fe ot ou ov ow b">foo_child</code>)。所以这个孩子实际上是Python主进程的“孙子”。</p><p id="0920" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">像守护线程一样，程序不会等待守护进程完成；即，当所有非守护进程完成时，程序将退出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="1503" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">父进程休眠5秒… <br/>守护进程子进程休眠10秒… <br/>父进程完成</p></blockquote><p id="db3c" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">在这个例子中，子进程，一个守护进程，比父进程睡眠时间更长；因此，程序不等子进程完成就退出。我们从来没有看到“儿童完成”打印。</p><p id="7ad5" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">总而言之，守护进程与普通进程有两个不同之处:</p><ul class=""><li id="7c9b" class="nu nv it me b mf no mi np lp nw lt nx lx ny mu nz oa ob oc bi translated">它们不能有子进程。</li><li id="2212" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">程序在退出前不会等待它们完成。</li></ul><h2 id="3789" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">上下文</h2><p id="6a53" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">多处理环境允许我们选择子进程如何开始，也就是说，它从父进程继承了什么。有三种选择:</p><ul class=""><li id="70b2" class="nu nv it me b mf no mi np lp nw lt nx lx ny mu nz oa ob oc bi translated">产卵:启动一个全新的Python进程。新进程不会从父进程继承不必要的对象。特别是，它不复制线程锁。<strong class="me iu">这是macOS和Windows的默认方法。</strong></li><li id="a815" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated"><em class="mv"> fork </em>:是父进程的副本。虽然它不复制线程，但它复制线程锁。<strong class="me iu">在Unix中是默认的。这种方法被认为是线程不安全的，尤其可能导致macOS上的子进程崩溃。</strong></li><li id="a4ee" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated"><em class="mv"> forkserver </em>:第一次启动时，它创建一个新的Python进程和一个服务器。每当我们想要启动一个新流程时，我们就连接到服务器并请求最初创建的新Python流程的一个分支。</li></ul><p id="3fe7" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">查看<a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>了解每种方法的更多信息。</p><p id="e825" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">三种方法中，“fork”最快最不安全，“spawn”最慢最安全。</p><p id="34de" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">我们所说的过程安全是指什么？</p><p id="75b7" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">除了使用“fork”方法时报告的macOS崩溃之外，安全意味着线程安全，特别是关于线程锁。在故事的最后一部分，我们将探讨多线程多进程程序是如何陷入死锁的。</p><p id="3868" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">原则上，使用“fork”创建流程应该比使用“spawn”方法更快。我们来测试一下。</p><p id="645c" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">下面的脚本用给定的上下文创建了<code class="fe ot ou ov ow b">n_procs</code>。它测量创建每个进程所花费的时间，并将它们保存到一个JSON文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="354c" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">要运行脚本:</p><p id="55e1" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><code class="fe ot ou ov ow b">$ python [script name].py [number or processes] [context (spawn, fork or forkserver)</code></p><p id="105e" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">结果如下:</p><blockquote class="on oo op"><p id="54c2" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">最小最大值=(1.795373，9.288665)，平均值= 3。18666.866676666867</p><p id="50ac" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated"><em class="it"> fork: </em> minmax=(1.151489，8.550412)，mean = 1 . 155041967365</p><p id="7017" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated"><em class="it">forkserver:</em>minmax =(1.133119，87.569707)，mean = 3.8111726700000004</p></blockquote><p id="5f19" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">时间以毫秒表示。</em></p><p id="6a85" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">正如我们所看到的，的确,“spawn”方法是最慢的。</p><p id="d052" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">“forkserver”方法很有趣；最小创建时间比“fork”方法要短，但是它的平均值要大。这种方法的文献不多；我以前没有在生产中使用过它，但是用它做更多的实验可能是值得的。</p><h2 id="feba" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">跨流程共享变量</h2><p id="0332" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">所以“spawn”上下文是避免问题的首选方式。你能猜到如果两个子进程试图修改主进程中定义的一个全局变量会发生什么吗？什么都没有，变量什么都不会发生。因为子流程是一个新的Python流程，所以全局变量在实际应用中表现为不同的变量。看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="87c7" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">进程号初始化0 <br/>进程号完成100 <br/>进程号初始化0 <br/>进程号完成100 <br/>主进程完成，编号0</p></blockquote><p id="e80d" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">我们错误地期望看到在主流程中定义的数字变成200。期望的行为是在两个过程中各加100。进程的行为不是这样的；在“spawn”上下文中，它们不共享内存。问题来了，我们如何在进程间共享变量？</p><p id="fce8" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">多处理</em>模块实现了两个对象在进程间共享数据，<code class="fe ot ou ov ow b"><em class="mv">Value</em></code>和<code class="fe ot ou ov ow b"><em class="mv">Array</em></code>。</p><p id="cd02" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><code class="fe ot ou ov ow b">Value</code>对象用于共享单值变量，如数字或字符串。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="21cf" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">进程号初始化0 <br/>进程号初始化0 <br/>进程号完成100 <br/>进程号完成101 <br/>主完成，号101</p></blockquote><p id="1c85" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">正确结果:</p><blockquote class="on oo op"><p id="2fa6" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">进程号初始化0 <br/>进程号完成100 <br/>进程号初始化100 <br/>进程号完成200 <br/>主进程完成，数量200</p></blockquote><p id="12b2" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">我们通过从<em class="mv">数组</em>模块中声明它的typecode来实例化<code class="fe ot ou ov ow b">Value</code>(用“l”表示有符号长整型)并使用<code class="fe ot ou ov ow b"><em class="mv">value</em></code>属性访问它的值。</p><p id="84a5" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">出了问题；我们没有得到预期的200英镑。现在怎么办？比赛条件。我们成功地在进程间共享变量；现在，我们需要实现同步机制。</p><h2 id="35ca" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">竞争条件和锁</h2><p id="86f7" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">即使有<a class="ae ky" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325"> GIL </a>的帮助，在执行多线程时避免竞争情况也是至关重要的。现在我们有了真正的并行执行，事情变得更糟了。当使用线程时，我们可以避免使用锁，通常情况下，我们会没事的。当在执行写操作的进程之间使用共享变量时，锁是必须的。</p><p id="18e9" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">幸运的是，<em class="mv">多处理</em>模块有一个锁，它实现了与<em class="mv">线程</em>模块中的锁相同的简单接口。通过向上一节示例中的示例添加锁，我们可以获得正确的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="1bf2" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">进程号初始化0 <br/>进程号完成100 <br/>进程号初始化100 <br/>进程号完成200 <br/>主完成，号200</p></blockquote><p id="d9a3" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">最后我们在主流程中定义的<code class="fe ot ou ov ow b">number</code>得了200。</p><p id="7e9f" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">在<a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">模块</a>中还有其他有用的同步原语，请务必查看。它们非常相似，但也有一些不同，这可能使其中一个更适合您的特定用例。</p><h2 id="6f5f" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">队列和管道</h2><p id="85fe" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">共享变量很好，但是队列呢？它们对于<a class="ae ky" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325">多线程</a>非常有用。我们能在多个过程中使用它们吗？让我们试试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="37c4" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">睡眠5秒……<br/>睡完了，q放</p><p id="990f" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">…死锁</p></blockquote><p id="d6d9" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">结果是行不通的。程序陷入了僵局。我们不能天真地在多处理代码中使用线程安全对象；否则，我们可能会陷入困境。幸运的是，在<em class="mv">多重处理</em>模块中有一个多重处理安全队列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="0644" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">睡眠5秒… <br/>完成睡眠后，q放<br/> foo 4秒。54630.64636646666</p></blockquote><p id="3b8a" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">一切都像预期的那样工作。</p><p id="69f9" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">队列非常适合于进程间的单向通信；一个进程将东西放入队列，另一个进程获取它们。没有比这更简单的了。但是如果我们需要双向沟通呢？有一个奇妙的对象实现了这一点，即<em class="mv">管道:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="on oo op"><p id="7e20" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">proc 1休眠5秒… <br/> proc 1完成休眠，连接发送<br/> proc 2 foo 5.0035919869551435秒<br/> proc 2休眠5秒… <br/> proc 2完成休眠，发送ack并关闭连接2 <br/> proc 1接收ack并关闭连接</p></blockquote><p id="f9d3" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">从例子中可以看出，当我们实例化<code class="fe ot ou ov ow b"><em class="mv">Pipe</em></code>时，我们得到了连接的两端。然后我们给每个进程传递一个，并使用<code class="fe ot ou ov ow b">send</code>和<code class="fe ot ou ov ow b">recv</code>进行通信。太棒了，不是吗？提醒一句，<code class="fe ot ou ov ow b">recv</code>方法会阻塞。</p><h2 id="7ade" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">进程池</h2><p id="bde4" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">正如我们已经知道的，产生一个过程是缓慢的。通常，我们只在相对较短的时间内需要其他进程。大多数情况下，它们用于减轻主进程的CPU密集型负担(可能是并行计算)。任务被卸载到另一个进程，一旦完成，我们就把结果返回给主进程。每次都创建新的流程是无效的。进入进程池。<code class="fe ot ou ov ow b"><em class="mv">Pool</em></code>为我们负责流程创建和沟通。此外，池界面是为提交任务而设计的。相比之下，香草<code class="fe ot ou ov ow b"><em class="mv">Process</em></code> <em class="mv"> </em>界面就通用多了。</p><p id="9316" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">在流程池中的方法中，我们将讨论三种最常用的方法:</p><ul class=""><li id="6aef" class="nu nv it me b mf no mi np lp nw lt nx lx ny mu nz oa ob oc bi translated"><code class="fe ot ou ov ow b">map</code>:模拟Python的普通地图</li><li id="a8b0" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated"><code class="fe ot ou ov ow b">apply</code>:发送一个函数到池中进行计算，等待(阻塞)直到结果准备好</li><li id="4b67" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated"><code class="fe ot ou ov ow b">apply_async</code>:将一个函数发送到池中进行计算，然后以异步方式检索结果</li></ul><p id="9609" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">下面的脚本使用阶乘函数(<code class="fe ot ou ov ow b">get_factorial</code>)的一个简单(计算上很糟糕)的实现作为计算的目标。</p><p id="5553" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">每种方法都有一个函数。这些函数接受一个<code class="fe ot ou ov ow b">Pool </code>实例和一个整数列表来计算阶乘。此外，函数测量执行时间并返回它。</p><p id="3fb4" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">main函数创建一个包含8个进程的处理池，并从这三种方法中的每一种方法中获取前20个整数(包括零)的列表的解决方案。它为<code class="fe ot ou ov ow b">n_trials</code>重复计算。</p><p id="e83c" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">毕竟，计算完成后，结果保存在JSON文件中供进一步分析:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="9219" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">结果是:</p><blockquote class="on oo op"><p id="9aba" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">map: minmax=(0.801848，47.466579)，mean = 1.4865362500000003</p><p id="8bf9" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">应用:最小最大值=(3.544991，6.260502)，平均值=4.26371475</p><p id="d394" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated">apply_async: minmax=(0.792829，2.11585)，mean=1.12916867</p></blockquote><p id="7da9" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><code class="fe ot ou ov ow b">apply</code>是iterable最慢的方法。这是有意义的，因为我们在提交对应于iterable的下一个元素的另一个任务之前等待结果。<code class="fe ot ou ov ow b">apply</code>不太适合iterables。我们使用<code class="fe ot ou ov ow b">apply_async</code>来避免等待每个任务。然而，我震惊地意识到<code class="fe ot ou ov ow b">apply_async</code>比<code class="fe ot ou ov ow b">map</code>方法更快(或者至少是可比的)。</p><p id="ff1e" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">处理iterables时，给<code class="fe ot ou ov ow b">apply_async</code>一个机会；不会让人失望的。</p><h2 id="cb1c" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">进程间数据交换的性能</h2><p id="b54b" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">使用多处理作为并行计算手段的主要注意事项是移动数据。也就是说，使数据对需要它的过程可用。这一部分将测试在所有三个<em class="mv">多处理</em>环境中移动数据所花费的时间。</p><p id="b4b9" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">测试的计算是添加一个矩阵列。整个矩阵以及列的索引被提交给许多过程。每列一个过程。当然，这是一种相对低效的求和方式。尽管如此，它在测试中达到了两个目的:</p><ul class=""><li id="09db" class="nu nv it me b mf no mi np lp nw lt nx lx ny mu nz oa ob oc bi translated">即使我们只需要一列，也必须将整个矩阵移动到每个过程中。</li><li id="7baf" class="nu nv it me b mf od mi oe lp of lt og lx oh mu nz oa ob oc bi translated">单独遍历列(我们有意避免NumPy的向量化)相当于一个有许多类似试验的测试。因此，使测试在统计意义上更加稳健。</li></ul><p id="f230" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">在下面的代码中，函数<code class="fe ot ou ov ow b">sum_matrix_columns</code>定义了要提交给流程的任务。main函数遍历矩阵列，为每一列创建一个过程。请注意，这些过程不是并行的；它们是连续的。测量每个进程的时间，然后保存到JSON文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="97fd" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">要运行该脚本，我们需要提供上下文、矩阵行数和矩阵列数作为参数，即，</p><p id="8bbc" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><code class="fe ot ou ov ow b">$ python [script name].py [context(spawn, fork or forkserver) ] [matrix rows] [matrix columns]</code></p><p id="493f" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">结果是:</p><blockquote class="on oo op"><p id="2a60" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated"><em class="it">spawn:</em>minmax =(284.932112，464.454816)，mean = 297.296767676767</p><p id="1b01" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated"><em class="it">叉:</em> minmax=(0.963039，316.494265)，mean=15.52602248</p><p id="8ed2" class="mc md mv me b mf no ju mh mi np jx mk oq nq mm mn or nr mp mq os ns ms mt mu im bi translated"><em class="it">forkserver:</em>minmax =(176.789977，319.979666)，mean = 188.88676658675</p></blockquote><p id="5001" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">时间以毫秒表示。</em></p><p id="919d" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">我们可以清楚地看到，“fork”上下文更快，因为它没有从头开始一个过程；太糟糕了，有时不是很安全。相反，“产卵”是最慢的。然而，这种差异是惊人的，“fork”和“spawn”之间的性能差异约为20倍。</p><h2 id="aa13" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">多处理+多线程？？？</h2><p id="67c7" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">我们把最好的留到了最后。一个非常有趣的话题:当我们在一个多进程程序中使用多线程时会发生什么？在上下文部分，我们讨论了“fork”不会将线程复制到子进程中的事实。但这意味着什么，为什么会不安全？</p><p id="d38b" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">它在线程的意义上变得不安全，因为多线程程序中使用的锁可能会突然失去所有所有权，导致死锁。锁的所有者是最后锁定它的线程；只有那个线程可以打开它。</p><p id="3709" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="b1d3" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">main函数启动一个线程(在主进程中)，然后启动一个子进程。反过来，子进程启动另一个线程。因此，这是一个多进程、多线程的程序。目标函数请求锁定<code class="fe ot ou ov ow b">max_iter</code>的迭代。如果它得到锁，它就睡觉。</p><p id="12e3" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">如果我们使用“spawn”的“forkserver”运行代码，程序将花费几秒钟(等待所有迭代)然后退出。这是预期的行为。然而，如果我们使用“fork”上下文运行程序，它将会一直处于死锁状态。这是为什么呢？</p><p id="e6ce" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">“fork”上下文的问题是它不从父线程复制线程。但是，它确实从父对象复制了锁。<br/>因此，就子进程而言，锁没有所有者；所有者是子子进程中不再存在的线程。</p><p id="1613" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">最后一个例子非常清楚地说明了这一点；如果一定要做一个多线程+多进程的应用，明智的做法是不要使用“fork”上下文。</p><h2 id="6212" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这个故事的寓意</h2><p id="0d89" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">我们已经证实，在某些情况下,“分叉”上下文是最快的，快了一个数量级。虽然官方文档说使用macOS可能会崩溃，但我还没有亲眼目睹过。事实上，这种方法的速度有时值得冒险。</p><p id="a09b" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated">我会说，如果子进程对程序至关重要，就要避免“fork”。然而，如果子进程只执行CPU密集型任务，速度是最重要的，并且不涉及线程，那么您可能会陷入危险的境地，并使用“fork”。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="7be9" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">我希望这个故事对你有用。</em> <a class="ae ky" href="https://medium.com/subscribe/@diego-barba" rel="noopener"> <em class="mv">订阅</em> </a> <em class="mv">到我的邮件列表如果你想知道更多这样的故事。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="9016" class="pw-post-body-paragraph mc md it me b mf no ju mh mi np jx mk lp nq mm mn lt nr mp mq lx ns ms mt mu im bi translated"><em class="mv">喜欢这个故事？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</em></p><div class="mw mx gp gr my mz"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">阅读迭戈·巴尔巴(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">medium.com</p></div></div><div class="ni l"><div class="ox l nk nl nm ni nn ks mz"/></div></div></a></div></div></div>    
</body>
</html>