<html>
<head>
<title>Implementing Piping Mechanisms From Scratch With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python从头开始实现管道机制</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-piping-mechanisms-from-scratch-with-python-802f13430140#2022-04-01">https://towardsdatascience.com/implementing-piping-mechanisms-from-scratch-with-python-802f13430140#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a733" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">总是有一种用Python重现一些迷人语法的驱动力。管道是一个有趣的例子。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bccab7e338e2a43017b5fd48590b24c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Huf4Bw-azrfUhQKwobG0IQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@towfiqu999999" rel="noopener ugc nofollow" target="_blank"> Towfiqu barbhuiya </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的教程中，我们看到了如何使用<a class="ae ky" href="https://medium.com/@tarek.samaali.92/dancing-with-python-dunder-methods-b5d89172b622" rel="noopener"> Dunder方法</a>实现高级行为，以及functools 模块提供的<a class="ae ky" href="https://betterprogramming.pub/itertools-functools-two-python-lone-soldiers-d2ee1f0c7460" rel="noopener ugc nofollow" target="_blank">分部方法如何利用参数多样性。</a></p><p id="c3cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我感兴趣的是使用这两个Python支柱来实现一个类似于<a class="ae ky" href="https://pypi.org/project/pipey/" rel="noopener ugc nofollow" target="_blank"> PIPEY </a>的行为，即构建一个管道机制，该机制将对一段数据实现一系列连续的操作，如下所示:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4077" class="ma mb it lw b gy mc md l me mf">pipe | operation1 &gt;&gt; operation2 &gt;&gt; operation3 &gt;&gt; ..  &gt;&gt; operationN</span></pre><p id="8720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个管道是可调用的，它将数据作为输入。</p><p id="4db3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将:</p><ul class=""><li id="a445" class="mg mh it lb b lc ld lf lg li mi lm mj lq mk lu ml mm mn mo bi translated">首先，构建一个基本的<code class="fe mp mq mr lw b">Partial</code>可定制类，它将充当<code class="fe mp mq mr lw b">functools.partial</code>模块。</li><li id="2efc" class="mg mh it lb b lc ms lf mt li mu lm mv lq mw lu ml mm mn mo bi translated">给<code class="fe mp mq mr lw b">Partial</code>级注入更多的能力。</li><li id="4083" class="mg mh it lb b lc ms lf mt li mu lm mv lq mw lu ml mm mn mo bi translated">通过一个<code class="fe mp mq mr lw b">Pipe</code>类链接起来。</li></ul><h1 id="3381" class="mx mb it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">实验</h1><p id="1163" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">正如你已经知道的，在<code class="fe mp mq mr lw b">functools</code>中提供的<code class="fe mp mq mr lw b">partial</code>方法用来冻结一个函数的一部分参数，然后给出一个新的函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/edc0c80dcf07f665ce8aeab383380ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gm84ijYgZ047ibKSxxD9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5cae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mp mq mr lw b">partial</code>模块大致有如下实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="16dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在官方文档中提到的同一个例子上测试它:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6a15" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; basetwo = Partial(int, base=2)<br/>&gt;&gt;&gt; basetwo('1001')<br/>... 9</span></pre><p id="caa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe mp mq mr lw b">Partial</code>类将作为下一部分的构建模块。</p><p id="0dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了模拟算术行为，能够使用反射右移<code class="fe mp mq mr lw b">( &gt;&gt; )</code>并且能够使用可调用的管道，我们必须实现两个特殊的方法:<code class="fe mp mq mr lw b">__rshift__</code>和<code class="fe mp mq mr lw b">__call__</code>。让我先给你演示一下是怎么做的，然后再解释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实例初始化方面，与第一个基本<code class="fe mp mq mr lw b">Partial</code>实现的区别在于属性的性质。我们需要构造一种累加器，在右移另一个<code class="fe mp mq mr lw b">Partial</code>实例时从中受益。</p><p id="1524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<code class="fe mp mq mr lw b">__rshift__</code>方法是如何编写的，它总结起来就是将<code class="fe mp mq mr lw b">other</code>的部分信息(函数、参数和关键字参数)附加到第一个信息上，从而跟踪管道的定位和执行顺序。一旦建立了管道，可调用的部分链从左到右启动计算。第一个可调用函数计算结果，该结果又成为下一个函数的输入。</p><p id="868d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们举个例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2122" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; first_pipeline = Partial(pow,2) &gt;&gt; Partial(pow,3) &gt;&gt; Partial(pow, 5) <br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; first_pipeline(4)<br/>... 1152921504606846976<br/>&gt;&gt;&gt; ((4 ** 2) ** 3 ) ** 5 <br/>... 1152921504606846976</span></pre><p id="5f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以停下来一会儿，惊叹于语法的美丽和结果的可信程度。</p><p id="636d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们当然不希望每次在管道中添加内容时都要明显地调用Partial。</p><p id="fa6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们写下我们需要的调整过的幺正函数。让我们定义一个<code class="fe mp mq mr lw b">power</code>函数和一个<code class="fe mp mq mr lw b">add</code>函数:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="c06a" class="ma mb it lw b gy mc md l me mf">power = lambda x: Partial(lambda x_, n: pow(x_, n), x)<br/>add = lambda x: Partial(lambda x_, n: x_ + n, x)</span></pre><p id="8f00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看并不十分优雅，但让我们深入研究一下:<br/>在幂的例子中，部分变量冻结了<code class="fe mp mq mr lw b">x</code>变量，这样我们就能够改变幂项。</p><p id="9fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mp mq mr lw b">Partial(lambda x_, n: pow(x_, n), x)</code>冻结lambda函数的第一个参数<code class="fe mp mq mr lw b">x_</code>。<br/>因为<code class="fe mp mq mr lw b">x</code>是一个变量，它可以表示输入或者先前调用的结果，所以将这个<code class="fe mp mq mr lw b">Partial</code>包装到另一个<code class="fe mp mq mr lw b">lambda</code>函数中是有意义的。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e68c" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; power = lambda x: Partial(lambda x_, n: pow(x_, n), x)<br/>&gt;&gt;&gt; add = lambda x: Partial(lambda x_, n: x_ + n, x)<br/>&gt;&gt;&gt; element = power(2) &gt;&gt; add(4) &gt;&gt; power(2) &gt;&gt; add(2)<br/>&gt;&gt;&gt; element(16)<br/>&gt;&gt;&gt; 67602</span></pre><p id="a15f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速检查:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="847f" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; ((((16 ** 2) + 4 ) ** 2 ) + 2)<br/>&gt;&gt;&gt; 67602</span></pre><p id="aa32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常管用！</p><p id="5d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">投资更多优雅如何？让我们把它们组装成一个<code class="fe mp mq mr lw b">Pipe</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cf66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了我们的<code class="fe mp mq mr lw b">Pipe</code>事情变得更有意义:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7353" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; element = Pipe() | power(2) &gt;&gt; add(4) &gt;&gt; power(2) &gt;&gt; add(2)<br/>&gt;&gt;&gt; element <br/>... &lt;__main__.Pipe at 0x7f869c3606a0&gt;<br/>&gt;&gt;&gt; element(16)<br/>... 67602</span></pre><p id="b2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mp mq mr lw b">element</code>不再是一个<code class="fe mp mq mr lw b">Partial</code>实例，而是一个<code class="fe mp mq mr lw b">Pipe</code>实例，它基本上提供了一种更高级的制作管道的方法。通常，Python会抛出一个<code class="fe mp mq mr lw b">TypeError</code>来警告你一种类型的冲突。但是因为我们在<code class="fe mp mq mr lw b">Partial</code>类中指出了它应该如何处理两个<code class="fe mp mq mr lw b">Partial</code>实例的反射右移，所以它很好地认识到如何用更多的抽象来完成。</p><p id="d33f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用另一种类型的数据来测试我们的机制，比如说..名单！显然，我们宣布接下来的作品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="917e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mp mq mr lw b">add_list</code>和<code class="fe mp mq mr lw b">power_list</code>需要额外的参数，因此使用外部<code class="fe mp mq mr lw b">lambda</code>函数。<code class="fe mp mq mr lw b">sorted_list</code>和<code class="fe mp mq mr lw b">uniq_list</code>都不需要额外的参数。将它们包装成<code class="fe mp mq mr lw b">Partial</code>类就足够了。</p><p id="7257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最后一个例子:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="cbf0" class="ma mb it lw b gy mc md l me mf">&gt;&gt;&gt; list_elements = [1,2,3,3,4]<br/>&gt;&gt;&gt; element_list = Pipe() | add_list(2) &gt;&gt; power_list(3) &gt;&gt; sorted_list &gt;&gt; uniq_list<br/>&gt;&gt;&gt; element_list(list_elements)<br/>... [64, 27, 125, 216]</span></pre><p id="53bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们有不同类型的数据，该机制也能正常运行。</p><h1 id="1c86" class="mx mb it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="c39d" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如果你做到了这一步，我非常感谢你的耐心和好奇心。</p><p id="a797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个相当有趣的实验，用来测试我们在高级python工具中看到的一些隐藏功能。不可避免地，它们让我们质疑我们能达到的语法优雅程度。</p></div></div>    
</body>
</html>