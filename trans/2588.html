<html>
<head>
<title>Which models are interpretable?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哪些模型是可解读的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/which-models-are-interpretable-5c7d2d0aa208#2022-06-05">https://towardsdatascience.com/which-models-are-interpretable-5c7d2d0aa208#2022-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="970d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一些可解释的机器学习模型概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/36e8b5c8a8fb3d5914a2bcb1e0eddaee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*HxjSGgudbvDhTCzY.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="f6f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模型解释是有监督机器学习中的一项基本任务。解释模型如何表示信息对于理解支配我们数据的动态是至关重要的。我们来看几个容易解读的模型。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="0e6c" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">为什么我们需要解释我们的模型？</h1><p id="b5f8" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">数据科学家的角色是从原始数据中提取信息。他们不是工程师，也不是软件开发者。他们挖掘内部数据，从矿井中提取黄金。</p><p id="f8c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">了解一个模型做什么和如何工作是这项工作的一部分。尽管有时黑盒模型比其他模型更好，但如果我们需要从数据中学习一些东西，它并不是一个好主意。相反，一些本质上非常擅长解释如何将数据转化为信息的模型，必须总是优先选择和深入研究。</p><p id="fb35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">机器学习模型是一种将信息翻译成合适且可理解的语言的方法，这种语言就是数学。如果我们能把一些东西翻译成数学，我们就能从中学到更多，因为我们可以根据需要掌握数学。因此，模型不仅仅是我们可以用来预测顾客是否会购买某样东西的算法。这是一种理解“为什么”具有特定特征的客户可能会购买某些东西，而另一个具有不同特征的客户不会购买任何东西的方式。</p><p id="8c89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，模型解释对于给我们所寻找的信息以适当的形式是至关重要的。</p><h1 id="3383" class="lx ly it bd lz ma mu mc md me mv mg mh jz mw ka mj kc mx kd ml kf my kg mn mo bi translated">通过特征重要性进行解释</h1><p id="5e27" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">解释模型如何“思考”我们的数据以提取信息的一种可能方式是查看特征的重要性。重要性通常是正数。该数字越大，模型对该特定功能的重要性就越高。</p><p id="6047" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本文中，我将展示一些模型，这些模型使用Python和scikit-learn库为我们提供了它们自己对特性重要性的解释。让我们永远记住，不同的模型赋予我们不同的功能重要性。这是完全正常的，因为每个模型都是一种看待信息这个奇妙而复杂的棱镜的方式。我们从来没有完整的视图，所以特性的重要性很大程度上取决于我们选择的模型。</p><p id="97a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们先导入一些库和scikit-learn的“wine”数据集。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="89a1" class="ne ly it na b gy nf ng l nh ni">import numpy as np <br/>from sklearn.datasets <br/>import load_wine,load_diabetes <br/>from sklearn.tree import DecisionTreeClassifier <br/>from sklearn.ensemble import RandomForestClassifier,GradientBoostingClassifier </span><span id="1c0f" class="ne ly it na b gy nj ng l nh ni">from sklearn.linear_model import * <br/>from sklearn.svm import LinearSVC,LinearSVR <br/>import xgboost as xgb <br/>import matplotlib.pyplot as plt <br/>from sklearn.pipeline import make_pipeline <br/>from sklearn.preprocessing import StandardScaler</span></pre><p id="b109" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们加载数据集并存储要素的名称。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a1ef" class="ne ly it na b gy nf ng l nh ni">X,y = load_wine(return_X_y=True) <br/>features = load_wine()['feature_names']</span></pre><p id="32fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们准备计算不同类型模型的特征重要性。</p><h1 id="0046" class="lx ly it bd lz ma mu mc md me mv mg mh jz mw ka mj kc mx kd ml kf my kg mn mo bi translated">决策树</h1><p id="4d12" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">基于树的模型根据特征在整个树中提供的叶子纯度的总改善来计算特征的重要性。如果一个特征能够正确地分割数据集并提高特征的纯度，那么它肯定是重要的。为了简单起见，基于树的模型中的重要性分数被归一化，使得它们总和为1。</p><p id="8ae1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在scikit-learn中，每个基于决策树的模型都有一个名为<em class="nk"> feature_importances_ </em>的属性，其中包含了特性的重要性。拟合我们的模型后就可以访问了。</p><p id="4b53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看一个简单的决策树模型会发生什么。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f271" class="ne ly it na b gy nf ng l nh ni">tree = DecisionTreeClassifier() <br/>tree.fit(X,y) <br/>plt.barh(features,tree.feature_importances_)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/779c35ee32ff44deee164a71139902d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0iqi8vQ9LSSiESqZ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="6a02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们所见，一些特征的重要性等于0。也许它们并不比例如“脯氨酸”特性更能提高纯度。</p><p id="4817" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个非常重要的基于树的模型是随机森林，它对特征重要性非常有用。一般来说，集成模型对每个弱学习者给出的每个特征的重要性分数进行平均，然后像在决策树中一样将最终分数再次归一化。</p><p id="8f77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是如何计算随机森林模型的要素重要性。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6251" class="ne ly it na b gy nf ng l nh ni">rf = RandomForestClassifier() <br/>rf.fit(X,y) <br/>plt.barh(features,rf.feature_importances_)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/b184f0b5ca9d45ae66647cb8935063a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/0*ydkiB7irrbkTjQY0.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="7631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，随机森林给出的特征重要性可用于执行<a class="ae nr" href="https://www.yourdatateacher.com/2021/10/11/feature-selection-with-random-forest/" rel="noopener ugc nofollow" target="_blank">特征选择</a>。</p><p id="fdef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">甚至梯度推进决策树模型也能给我们自己对特征重要性的解释。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c2ef" class="ne ly it na b gy nf ng l nh ni">gb = GradientBoostingClassifier() <br/>gb.fit(X,y) <br/>plt.barh(features,gb.feature_importances_)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/37d47dec51f5d8e3eb77f528b22d1363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/0*nP9V1JuVi2QGvvqT.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="79e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">即使对于XGBoost也是如此。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b688" class="ne ly it na b gy nf ng l nh ni">xgboost = xgb.XGBClassifier() <br/>xgboost.fit(X,y) <br/>plt.barh(features,xgboost.feature_importances_)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ff5284e94a4840747202f28788ee12ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/0*SMCgwSgm-sOhvmZX.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="8286" class="lx ly it bd lz ma mu mc md me mv mg mh jz mw ka mj kc mx kd ml kf my kg mn mo bi translated">线性模型</h1><p id="7292" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">线性模型也能给我们特征的重要性。实际上，它是一个特性的系数的绝对值。如果我们使用多类线性模型进行分类，我们将对与单个要素相关的系数的绝对值进行求和。</p><p id="d2ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在计算要素重要性时，所有线性模型都需要标准化或规范化的要素。默认情况下，一些模型需要这种变换，但是如果我们想要相互比较系数，我们总是必须应用它。这就是为什么我将使用scikit中的pipeline对象——在训练模型之前学习标准化我们的数据。</p><p id="c599" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个线性核支持向量机的例子。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3119" class="ne ly it na b gy nf ng l nh ni">svm = make_pipeline(StandardScaler(),LinearSVC()) <br/>svm.fit(X,y) <br/>plt.barh(features,np.abs(svm[1].coef_).sum(axis=0))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/53eb7bf5ca4f4f20e7048d9fcb42cea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/0*iLOatxkpP4yfCCvc.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="cb80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这同样适用于逻辑回归。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ae17" class="ne ly it na b gy nf ng l nh ni">logit = make_pipeline(StandardScaler(),LogisticRegression()) </span><span id="313c" class="ne ly it na b gy nj ng l nh ni">logit.fit(X,y) <br/>plt.barh(features,np.abs(logit[1].coef_).sum(axis=0))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/355e487870b82ece9b7b4892fb71d3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*bOA1W1OxteEbNbUa.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="49c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可用于特征重要性的其他线性模型是回归模型，因此我们必须加载一个回归数据集来查看它们是如何工作的。对于下面的例子，我将使用“糖尿病”数据集。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0e93" class="ne ly it na b gy nf ng l nh ni">X,y = load_diabetes(return_X_y=True) </span><span id="2fd2" class="ne ly it na b gy nj ng l nh ni">features = load_diabetes()['feature_names']</span></pre><p id="165d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看线性回归是如何计算特征重要性的。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a415" class="ne ly it na b gy nf ng l nh ni">lr = make_pipeline(StandardScaler(),LinearRegression()) </span><span id="1647" class="ne ly it na b gy nj ng l nh ni">lr.fit(X,y) </span><span id="b178" class="ne ly it na b gy nj ng l nh ni">plt.barh(features,np.abs(lr[1].coef_))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2edd2d6e24f135fa0532a634b7e013e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*1yHu6xbdoZsVDSm3.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="df2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">套索回归是一个非常强大的模型，可以用于特征重要性(也可以用于<a class="ae nr" href="https://www.yourdatateacher.com/2021/05/05/feature-selection-in-machine-learning-using-lasso-regression/" rel="noopener ugc nofollow" target="_blank">特征选择</a></p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2e79" class="ne ly it na b gy nf ng l nh ni">lasso = make_pipeline(StandardScaler(),Lasso()) </span><span id="c370" class="ne ly it na b gy nj ng l nh ni">lasso.fit(X,y) </span><span id="7058" class="ne ly it na b gy nj ng l nh ni">plt.barh(features,np.abs(lasso[1].coef_))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ec99b4c201ae822c18f2de9876c5d4f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/0*7ImteMef7b_KyxCR.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="b585" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">套索回归最亲密的朋友是岭回归，它也很有帮助。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="da71" class="ne ly it na b gy nf ng l nh ni">ridge = make_pipeline(StandardScaler(),Ridge()) </span><span id="0a1e" class="ne ly it na b gy nj ng l nh ni">ridge.fit(X,y) <br/>plt.barh(features,np.abs(ridge[1].coef_))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5f001e88da9eec75748f0573b8e8acf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/0*8Bq-yEnLxBd4dkBa.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="4192" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将看到的最后一个模型混合了套索和岭回归，它是弹性净回归。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2a9a" class="ne ly it na b gy nf ng l nh ni">en = make_pipeline(StandardScaler(),ElasticNet()) </span><span id="54fb" class="ne ly it na b gy nj ng l nh ni">en.fit(X,y) </span><span id="4483" class="ne ly it na b gy nj ng l nh ni">plt.barh(features,np.abs(en[1].coef_))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/495b7013e5870a8cb92a2e1e0a681199.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/0*fh4sCLTFdhJ6Bh8g.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><h1 id="2f1d" class="lx ly it bd lz ma mu mc md me mv mg mh jz mw ka mj kc mx kd ml kf my kg mn mo bi translated">结论</h1><p id="76ce" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">模型解释通常是通过计算特征重要性来完成的，一些模型给了我们他们自己对特征重要性的解释。对于那些不能给出特征重要性的模型，我们可以使用一些模型不可知的方法，比如SHAP(例如，对<a class="ae nr" href="https://www.yourdatateacher.com/2021/05/17/how-to-explain-neural-networks-using-shap/" rel="noopener ugc nofollow" target="_blank">解释神经网络</a>非常有用)。正确使用特征重要性比模型本身的预测能力更能提高数据科学项目的价值。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="9bb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nk">原载于2022年6月5日</em><a class="ae nr" href="https://www.yourdatateacher.com/2022/06/06/which-models-are-interpretable/" rel="noopener ugc nofollow" target="_blank"><em class="nk">【https://www.yourdatateacher.com】</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>