<html>
<head>
<title>Modern Recommendation Systems with Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于神经网络的现代推荐系统</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modern-recommendation-systems-with-neural-networks-3cc06a6ded2c#2022-04-16">https://towardsdatascience.com/modern-recommendation-systems-with-neural-networks-3cc06a6ded2c#2022-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/bf7a59d41b19f964ce71b34753c515bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgqxDMP5qD1HE_uM33zZrg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><div class=""/><div class=""><h2 id="87fe" class="pw-subtitle-paragraph kf jh ji bd b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dk translated">使用Python和TensorFlow构建混合模型</h2></div><h2 id="9f2f" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">摘要</h2><p id="0967" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">在本文中，我将展示如何使用Python和TensorFlow构建具有神经网络的现代推荐系统。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mm"><img src="../Images/7572ec45d456c1ad3c0f76dfb88e806b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LiAKVM2g9RYY_2pl"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">亚历山大·沙托夫在<a class="ae mr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3c90" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Recommender_system" rel="noopener ugc nofollow" target="_blank"> <strong class="lv jj">推荐系统</strong> </a>是预测用户对多个产品偏好的模型。它们被用于各种领域，如视频和音乐服务、电子商务和社交媒体平台。</p><p id="4583" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">最常见的方法利用产品特征(基于内容)、用户相似性(协作过滤)、个人信息(基于知识)。然而，随着神经网络的日益普及，公司已经开始尝试将它们结合在一起的新的混合推荐系统。</p><p id="783c" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">在本教程中，我将展示如何使用传统模型，以及如何从头开始构建一个现代推荐系统。我将展示一些有用的Python代码，这些代码可以很容易地应用于其他类似的情况(只需复制、粘贴、运行)，并通过注释遍历每一行代码，以便您可以复制这个示例(下面是完整代码的链接)。</p><div class="is it gp gr iu mx"><a href="https://github.com/mdipietro09/DataScience_ArtificialIntelligence_Utils/blob/master/machine_learning/example_recommendation.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jj gy z fp nc fr fs nd fu fw jh bi translated">data science _ artificial intelligence _ Utils/example _ re commendation . ipynb at master…</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">数据科学项目和人工智能用例的示例…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">github.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ja mx"/></div></div></a></div><p id="8b2a" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">我将使用由<a class="ae mr" href="https://en.wikipedia.org/wiki/GroupLens_Research" rel="noopener ugc nofollow" target="_blank"> GroupLens Research </a>创建的<strong class="lv jj"> MovieLens </strong>数据集，该数据集包含数百名用户评价的数千部电影(链接如下)。</p><div class="is it gp gr iu mx"><a href="https://grouplens.org/datasets/movielens/latest/" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jj gy z fp nc fr fs nd fu fw jh bi translated">MovieLens最新数据集</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">这些数据集会随着时间的推移而变化，不适合用于报告研究结果。我们将保留下载…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">grouplens.org</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl ja mx"/></div></div></a></div><p id="b588" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">特别是，我将经历:</p><ul class=""><li id="6ddd" class="nn no ji lv b lw ms lz mt lg np lk nq lo nr ml ns nt nu nv bi translated">设置:导入包、读取数据、预处理</li><li id="cdcf" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated">冷启动问题</li><li id="7773" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated">使用<em class="ob"> tensorflow </em>和<em class="ob"> numpy </em>的基于内容的方法</li><li id="fad9" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated">使用<em class="ob"> tensorflow/keras的传统协同过滤和神经协同过滤</em></li><li id="0a66" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated">具有<em class="ob"> tensorflow/keras </em>的混合(上下文感知)模型</li></ul></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h2 id="8a1d" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">设置</h2><p id="06c6" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">首先，我将导入以下<strong class="lv jj">包</strong>:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="90c8" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj">## for data</strong><br/>import <strong class="ok jj">pandas </strong>as pd<br/>import <strong class="ok jj">numpy </strong>as np<br/>import <strong class="ok jj">re</strong><br/>from <strong class="ok jj">datetime </strong>import datetime</span><span id="50d9" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## for plotting</strong><br/>import <strong class="ok jj">matplotlib</strong>.pyplot as plt<br/>import <strong class="ok jj">seaborn </strong>as sns</span><span id="f617" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## for machine learning</strong><br/>from <strong class="ok jj">sklearn </strong>import metrics, preprocessing</span><span id="0d27" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## for deep learning</strong><br/>from <strong class="ok jj">tensorflow</strong>.keras import models, layers, utils  <strong class="ok jj">#(2.6.0)</strong></span></pre><p id="92c7" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">然后我将读取<strong class="lv jj">数据</strong>，包括产品数据(本例中为电影)和用户数据。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="9763" class="kx ky ji ok b gy oo op l oq or">dtf_products = pd.read_excel("data_movies.xlsx", sheet_name="products")</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/cefa0b4716301be67ca4cf380c8dcd7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zdHcdSdeo1AojMfmVQSSw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="fdb1" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">在product表中，每行代表一个项目，右边的两列包含它的特性，这些特性是静态的(您可以将其视为电影元数据)。让我们读取用户数据:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="3b28" class="kx ky ji ok b gy oo op l oq or">dtf_users = pd.read_excel("data_movies.xlsx", sheet_name="users").head(10000)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/2ac93d4e7b85c52d20994950f7b11070.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6PQHLyt_OQoGELAEO1PsAw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="561c" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">这个表格的每一行都是一对用户-产品，显示用户对产品的评分，这是<strong class="lv jj">目标变量</strong>。显然，并不是每个用户都看过所有的产品。事实上，这就是为什么我们需要推荐系统。他们必须预测用户会给新产品什么样的评价，如果预测的评价是高/积极的，那么就推荐它。此外，这里还有一些关于目标变量上下文的信息(当用户给出评级时)。</p><p id="10ec" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">让我们做一些<strong class="lv jj">数据清理</strong>和<strong class="lv jj">特征工程</strong>来更好地理解我们拥有什么以及我们如何使用它。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="62ee" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># Products</strong><br/>dtf_products = dtf_products[~dtf_products["genres"].isna()]</span><span id="ab02" class="kx ky ji ok b gy os op l oq or">dtf_products["product"] = range(0,len(dtf_products))</span><span id="48f4" class="kx ky ji ok b gy os op l oq or">dtf_products["name"] = dtf_products["title"].apply(lambda x: re.sub("[\(\[].*?[\)\]]", "", x).strip())</span><span id="338f" class="kx ky ji ok b gy os op l oq or">dtf_products["date"] = dtf_products["title"].apply(lambda x: int(x.split("(")[-1].replace(")","").strip()) <br/>if "(" in x else np.nan)</span><span id="30f2" class="kx ky ji ok b gy os op l oq or">dtf_products["date"] = dtf_products["date"].fillna(9999)<br/>dtf_products["old"] = dtf_products["date"].apply(lambda x: 1 if x &lt; 2000 else 0)</span><span id="d3ac" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Users</strong><br/>dtf_users["user"] = dtf_users["userId"].apply(lambda x: x-1)</span><span id="f7dc" class="kx ky ji ok b gy os op l oq or">dtf_users["timestamp"] = dtf_users["timestamp"].apply(lambda x: datetime.fromtimestamp(x))</span><span id="00b9" class="kx ky ji ok b gy os op l oq or">dtf_users["daytime"] = dtf_users["timestamp"].apply(lambda x: 1 if 6&lt;int(x.strftime("%H"))&lt;20 else 0)</span><span id="1e9e" class="kx ky ji ok b gy os op l oq or">dtf_users["weekend"] = dtf_users["timestamp"].apply(lambda x: 1 if x.weekday() in [5,6] else 0)</span><span id="49a8" class="kx ky ji ok b gy os op l oq or">dtf_users = dtf_users.merge(dtf_products[["movieId","product"]], how="left")</span><span id="289e" class="kx ky ji ok b gy os op l oq or">dtf_users = dtf_users.rename(columns={"rating":"y"})</span><span id="b7e6" class="kx ky ji ok b gy os op l oq or"><br/><strong class="ok jj"># Clean</strong><br/>dtf_products = dtf_products[["product","name","old","genres"]].set_index("product")</span><span id="a165" class="kx ky ji ok b gy os op l oq or">dtf_users = <br/>dtf_users[["user","product","daytime","weekend","y"]]</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ov"><img src="../Images/c7a645228c92fa1407dfdf82d3c36d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IEfFHhoc3XjhOcQBzKF5LQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="9352" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">请注意，我从<em class="ob">时间戳</em>列中提取了2个上下文变量:<em class="ob">白天</em>和<em class="ob">周末</em>。我将把它们保存到数据帧中，因为我们以后可能需要它们。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="c65e" class="kx ky ji ok b gy oo op l oq or">dtf_context = dtf_users[["user","product","daytime","weekend"]]</span></pre><p id="e3dd" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">关于产品，下一步是创建<em class="ob">产品-特性</em>矩阵:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="31c2" class="kx ky ji ok b gy oo op l oq or">tags = [i.split("|") for i in dtf_products["genres"].unique()]<br/>columns = list(set([i for lst in tags for i in lst]))<br/>columns.remove('(no genres listed)')</span><span id="21bc" class="kx ky ji ok b gy os op l oq or">for col in columns:<br/>    dtf_products[col] = dtf_products["genres"].apply(lambda x: 1 if col in x else 0)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ow"><img src="../Images/a17b89941f4b71ba34c7ed9aaf1883f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eK7Vu-1VAbzTCjDa9247vg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="f712" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">矩阵是稀疏的，因为大多数产品没有所有的功能。让我们把它形象化，以便更好地理解情况。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="f53c" class="kx ky ji ok b gy oo op l oq or">fig, ax = plt.subplots(figsize=(20,5))<br/>sns.heatmap(dtf_products==0, vmin=0, vmax=1, cbar=False, ax=ax).set_title("Products x Features")<br/>plt.show()</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ox"><img src="../Images/96f9296f78f4c0e12c506cb698b305c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ktsnkbGWnl0YmGF1pP7SzQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="36d1" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">对于<em class="ob">用户-产品</em>矩阵，稀疏性变得更糟:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="63d6" class="kx ky ji ok b gy oo op l oq or">tmp = dtf_users.copy()<br/>dtf_users = tmp.pivot_table(index="user", columns="product", values="y")<br/>missing_cols = list(set(dtf_products.index) - set(dtf_users.columns))<br/>for col in missing_cols:<br/>    dtf_users[col] = np.nan<br/>dtf_users = dtf_users[sorted(dtf_users.columns)]</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oy"><img src="../Images/45e5ddc814bcf76c92f4a0d4ebfba0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NwynnIcA4Zw1iXoDgFzqeA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oz"><img src="../Images/aef73ade0bae05837c0573a1e117471b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rK4D4oETb0cyNI-UM4_6tg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="bd90" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">深入模型之前的最后一步是<strong class="lv jj">预处理</strong>。因为我们将处理神经网络，所以缩放数据总是好的实践。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="569c" class="kx ky ji ok b gy oo op l oq or">dtf_users = pd.DataFrame(preprocessing.MinMaxScaler(feature_range=(0.5,1)).fit_transform(dtf_users.values), <br/>columns=dtf_users.columns, index=dtf_users.index)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pa"><img src="../Images/92d7a365e2b503f186dc85efb4035976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*67RVu7PmNYoXVAnq5lYjnw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="284e" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">最后，我们将数据分成<em class="ob">训练</em>和<em class="ob">测试</em>组。我将垂直拆分数据集，这样所有用户都将参加<em class="ob">培训</em>和<em class="ob">测试</em>，而80%的产品用于培训，20%用于测试。像这样:</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pb"><img src="../Images/8223cb789f50349c59f7ef086718e72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JsrB3FyWA6rX8zTM7Yd5xg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="f51a" class="kx ky ji ok b gy oo op l oq or">split = int(0.8*dtf_users.shape[1])<br/>dtf_train = dtf_users.loc[:, :split-1]<br/>dtf_test = dtf_users.loc[:, split:]</span></pre><p id="dffd" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">好了，现在我们可以开始了…也许吧。</p><h2 id="40c6" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">冷启动</h2><p id="e867" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">想象一下，拥有一个全新的类似网飞的应用程序，第一个用户订阅。我们需要能够提供建议，而不依赖于用户以前的互动，因为还没有记录。当一个用户(或一个产品)是新的，我们就有了<a class="ae mr" href="https://en.wikipedia.org/wiki/Cold_start_(recommender_systems)" rel="noopener ugc nofollow" target="_blank"> <strong class="lv jj">冷启动问题</strong> </a>。这个系统无法在用户和产品之间建立任何联系，因为它没有足够的数据。</p><p id="dcb6" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">为了解决这个问题，主要的技术是<strong class="lv jj">基于知识的方法</strong>:例如，询问用户的偏好以创建初始简档，或者使用人口统计信息(即青少年的高中节目和儿童的卡通)。</p><p id="1bd4" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">如果只有几个用户，可以使用基于内容的方法。然后，当我们有足够的评级(即每个用户至少10个产品，总用户超过100个)时，可以应用更复杂的模型。</p><h2 id="fce4" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">基于内容</h2><p id="3bd4" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Recommender_system#Content-based_filtering" rel="noopener ugc nofollow" target="_blank"> <strong class="lv jj">基于内容的方法</strong> </a>是基于产品内容。例如，如果<em class="ob">用户A </em>喜欢<em class="ob">产品1、</em>和<em class="ob">产品2 </em>与<em class="ob">产品1 </em>相似，那么<em class="ob">用户A </em>可能也会喜欢<em class="ob">产品2 </em>。如果两个产品具有相似的特征，则它们是相似的。</p><p id="3736" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">简而言之，这种想法是用户实际上对产品的功能而不是产品本身进行评级。换个角度说，如果我喜欢音乐和艺术相关的产品，那是因为我喜欢那些特性(音乐和艺术)。基于此，我们可以估计我有多喜欢具有相同功能的其他产品。这种方法最适合于已知产品数据但不知道用户数据的情况。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/28ef1a281838ad749151380fa345d98a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FOkxZ4feOf030nanWNZRmA.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="c657" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">让我们从数据中挑选一个用户作为我们第一个已经使用了足够多产品的用户的例子，让我们创建<em class="ob">训练</em>和<em class="ob">测试</em>向量。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="41f6" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># Select a user</strong><br/>i = 1<br/>train = dtf_train.iloc[i].to_frame(name="y")<br/>test = dtf_test.iloc[i].to_frame(name="y")</span><span id="8804" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># add all the test products but hide the y</strong><br/>tmp = test.copy()<br/>tmp["y"] = np.nan<br/>train = train.append(tmp)</span></pre><p id="8fd4" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">现在我们需要估计用户给每个特性的权重。我们有<em class="ob">用户-产品</em>向量和<em class="ob">产品-特性</em>矩阵。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="966d" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># shapes</strong><br/>usr = train[["y"]].fillna(0).values.T<br/>prd = dtf_products.drop(["name","genres"],axis=1).values<br/>print("Users", usr.shape, " x  Products", prd.shape)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/8bef4742e25be874f48324bdaa9dab09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YAwgkSFM17z5NmtMIzaKgg.png"/></div></div></figure><p id="a19f" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">通过将这两个对象相乘，我们获得了一个<em class="ob">用户特征</em>向量，其中包含了用户给每个特征的估计权重。这些权重应重新应用于<em class="ob">产品-功能</em>矩阵，以获得预测评级。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="8e4a" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># usr_ft(users,fatures) = usr(users,products) x prd(products,features)</strong><br/>usr_ft = np.dot(usr, prd)</span><span id="aae8" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># normalize</strong><br/>weights = usr_ft / usr_ft.sum()</span><span id="84ff" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># predicted rating(users,products) = weights(users,fatures) x prd.T(features,products)</strong><br/>pred = np.dot(weights, prd.T)</span><span id="3a42" class="kx ky ji ok b gy os op l oq or">test = test.merge(pd.DataFrame(pred[0], columns=["yhat"]), how="left", left_index=True, right_index=True).reset_index()<br/>test = test[~test["y"].isna()]<br/>test</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pe"><img src="../Images/d93771c54b4874a2b4854d093df61475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jGsMUl0tybpbqe3XghkIg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="bde6" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">如你所见，我使用简单的<em class="ob"> numpy开发了这个简单的方法。</em>只使用raw <em class="ob"> tensorflow </em>也可以做到这一点:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="8519" class="kx ky ji ok b gy oo op l oq or">import tensorflow as tf</span><span id="8e8c" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># usr_ft(users,fatures) = usr(users,products) x prd(products,features)</strong><br/>usr_ft = tf.matmul(usr, prd)</span><span id="bf3c" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># normalize</strong><br/>weights = usr_ft / tf.reduce_sum(usr_ft, axis=1, keepdims=True)</span><span id="987c" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># rating(users,products) = weights(users,fatures) x prd.T(features,products)</strong><br/>pred = tf.matmul(weights, prd.T)</span></pre><p id="be63" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">如何<strong class="lv jj">评价</strong>我们的预测推荐？我通常使用<a class="ae mr" href="https://en.wikipedia.org/wiki/Accuracy_and_precision" rel="noopener ugc nofollow" target="_blank">精确度</a>和<a class="ae mr" href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank" rel="noopener ugc nofollow" target="_blank">平均倒数排名(MRR) </a>。后者是一种统计度量，用于评估任何按正确概率排序的可能响应列表。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="ba5b" class="kx ky ji ok b gy oo op l oq or">def <strong class="ok jj">mean_reciprocal_rank</strong>(y_test, predicted):<br/>    score = []<br/>    for product in y_test:<br/>        mrr = 1 / (list(predicted).index(product) + 1) if product <br/>        in predicted else 0<br/>        score.append(mrr)<br/>    return np.mean(score)</span></pre><p id="e53c" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">请注意，指标会根据我们推荐的产品数量而变化。因为我们将预测的<em class="ob">前k个</em>项目与<em class="ob">测试</em>集中的项目进行比较，所以顺序也很重要。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="5cb4" class="kx ky ji ok b gy oo op l oq or">print("--- user", i, "---")</span><span id="a974" class="kx ky ji ok b gy os op l oq or">top = 5<br/>y_test = test.sort_values("y", ascending=False)["product"].values[:top]<br/>print("y_test:", y_test)</span><span id="8e60" class="kx ky ji ok b gy os op l oq or">predicted = test.sort_values("yhat", ascending=False)["product"].values[:top]<br/>print("predicted:", predicted)</span><span id="9601" class="kx ky ji ok b gy os op l oq or">true_positive = len(list(set(y_test) &amp; set(predicted)))<br/>print("true positive:", true_positive, "("+str(round(true_positive/top*100,1))+"%)")<br/>print("accuracy:", str(round(<strong class="ok jj">metrics</strong>.<strong class="ok jj">accuracy_score</strong>(y_test,predicted)*100,1))+"%")<br/>print("mrr:", <strong class="ok jj">mean_reciprocal_rank</strong>(y_test, predicted))</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pf"><img src="../Images/e7114e8eb021cedf86b74ee93f56d12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCfboEm2A7NfUN9A4y367g.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="3622" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">我们得到了4个正确的产品，但订单不匹配。这就是为什么准确性和MRR低。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="9a2c" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># See predictions details</strong><br/>test.merge(<br/>       dtf_products[["name","old","genres"]], left_on="product", <br/>       right_index=True<br/>).sort_values("yhat", ascending=False)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/ba99e07c6b040182c85eeb23f32dcb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_R1xcBlYHuc0G0JVtm8mCQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="e83d" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">协同过滤</h2><p id="7309" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated"><a class="ae mr" href="https://en.wikipedia.org/wiki/Collaborative_filtering" rel="noopener ugc nofollow" target="_blank"><strong class="lv jj"/></a>协同过滤是基于相似用户喜欢相似产品的假设。例如，如果<em class="ob">用户A </em>喜欢<em class="ob">产品1 </em>，并且<em class="ob">用户B </em>与<em class="ob">用户A </em>相似，那么<em class="ob">用户B </em>可能也会喜欢<em class="ob">产品1 </em>。两个用户喜欢相似的产品，就是相似的。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pc"><img src="../Images/9428cd019a74a65697dfc068567e6634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ss7r5nIfCQJM_QepIugXgg.gif"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="842b" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">这种方法不需要产品特性就能起作用，相反，它需要来自许多用户的许多评级。继续我们平台的例子，想象我们的第一个用户不再孤单，我们有足够的用户来应用这个模型。</p><p id="3d83" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">当网飞在2009年举办了一场最佳算法的公开比赛，人们提出了几种实现方式时，协同过滤开始流行起来。它们可以分为两类:</p><ul class=""><li id="8851" class="nn no ji lv b lw ms lz mt lg np lk nq lo nr ml ns nt nu nv bi translated"><strong class="lv jj">基于记忆— </strong>用相关度寻找相似用户，<a class="ae mr" href="https://en.wikipedia.org/wiki/Cosine_similarity" rel="noopener ugc nofollow" target="_blank">余弦相似度</a>，以及<a class="ae mr" href="https://en.wikipedia.org/wiki/Cluster_analysis" rel="noopener ugc nofollow" target="_blank">聚类</a>。</li><li id="ca39" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated"><strong class="lv jj">基于模型— </strong>通过应用监督机器学习和<a class="ae mr" href="https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)" rel="noopener ugc nofollow" target="_blank">矩阵分解</a>来预测用户将如何评价某个产品，矩阵分解将大的<em class="ob">用户-产品</em>矩阵分解为两个较小的因子，分别代表<em class="ob">用户</em>矩阵和<em class="ob">产品</em>矩阵。</li></ul><p id="bf2d" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">在Python中，对用户最友好的包是<a class="ae mr" href="https://pypi.org/project/scikit-surprise/" rel="noopener ugc nofollow" target="_blank"> <em class="ob"> surprise </em> </a>，这是一个简单的库，用于构建和分析具有显式评级数据的推荐系统(类似于<em class="ob"> scikit-learn </em>)。它既可以用于基于记忆的方法，也可以用于基于模型的方法。或者，可以使用<em class="ob"> tensorflow/keras </em>为更复杂的基于模型的方法创建嵌入，这正是我要做的。</p><p id="340c" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">首先，我们需要以下形式的数据:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="a80f" class="kx ky ji ok b gy oo op l oq or">train = dtf_train.stack(dropna=True).reset_index().rename(columns={0:"y"})<br/>train.head()</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/0c498be51096e62f2f28cc1f0f03483a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4cqohn0fictBxoQI4eNBHQ.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者的图片(对测试集做同样的事情)</p></figure><p id="d1c6" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">主要思想是利用神经网络的嵌入层来创建<em class="ob">用户</em>和<em class="ob">产品</em>矩阵。重要的是要理解输入是用户-产品对，输出是评级。当预测一对新的用户-产品时，该模型将在<em class="ob">用户</em>嵌入空间中查找用户，在<em class="ob">产品</em>空间中查找产品。因此，您需要提前指定用户和产品的总数。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="a947" class="kx ky ji ok b gy oo op l oq or">embeddings_size = 50<br/>usr, prd = dtf_users.shape[0], dtf_users.shape[1]</span><span id="4e83" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Users (1,embedding_size)</strong><br/>xusers_in = layers.Input(name="xusers_in", shape=(1,))</span><span id="6ff1" class="kx ky ji ok b gy os op l oq or">xusers_emb = layers.Embedding(name="xusers_emb", input_dim=usr, output_dim=embeddings_size)(xusers_in)</span><span id="b936" class="kx ky ji ok b gy os op l oq or">xusers = layers.Reshape(name='xusers', target_shape=(embeddings_size,))(xusers_emb)</span><span id="15cb" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Products (1,embedding_size)</strong><br/>xproducts_in = layers.Input(name="xproducts_in", shape=(1,))</span><span id="e470" class="kx ky ji ok b gy os op l oq or">xproducts_emb = layers.Embedding(name="xproducts_emb", input_dim=prd, output_dim=embeddings_size)(xproducts_in)</span><span id="b3ff" class="kx ky ji ok b gy os op l oq or">xproducts = layers.Reshape(name='xproducts', target_shape=(embeddings_size,))(xproducts_emb)</span><span id="70c2" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Product (1)</strong><br/>xx = layers.Dot(name='xx', normalize=True, axes=1)([xusers, xproducts])</span><span id="2c09" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Predict ratings (1)</strong><br/>y_out = layers.Dense(name="y_out", units=1, activation='linear')(xx)</span><span id="463f" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Compile</strong><br/>model = models.Model(inputs=[xusers_in,xproducts_in], outputs=y_out, name="CollaborativeFiltering")<br/>model.compile(optimizer='adam', loss='mean_absolute_error', metrics=['mean_absolute_percentage_error'])</span></pre><p id="2c26" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">请注意，我通过使用<a class="ae mr" href="https://en.wikipedia.org/wiki/Mean_absolute_error" rel="noopener ugc nofollow" target="_blank">平均绝对误差</a>作为损失，将此用例视为回归问题，即使我们毕竟不需要分数本身，而是需要预测产品的排序。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="c6fb" class="kx ky ji ok b gy oo op l oq or">utils.plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/4482301bd037f458ecc00ad83794209c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y29Mwgkv3hjL3424POT40Q.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="2bac" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">让我们<strong class="lv jj">训练和测试</strong>模型。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="5627" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># Train</strong><br/>training = model.fit(x=[train["user"], train["product"]], y=train["y"], epochs=100, batch_size=128, shuffle=True, verbose=0, validation_split=0.3)</span><span id="c16b" class="kx ky ji ok b gy os op l oq or">model = training.model</span><span id="6c8b" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># Test<br/></strong>test["yhat"] = model.predict([test["user"], test["product"]])<br/>test</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/e40d3fa0ddd5ddaf4aa6a91affec8b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EmDME5AbtAop-0UW8RRqeg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="6f5d" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">我们可以通过比较为我们亲爱的第一个用户生成的推荐来评估这些预测(与前面的代码相同):</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/bec1c8310062bb0f5a6902994a3c6cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8z9MjK7NtSbXQqis4MFljw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="73f4" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">目前，所有最先进的推荐系统都利用了深度学习。特别地，<strong class="lv jj">神经协同过滤</strong> (2017)结合了来自神经网络的非线性和矩阵分解。该模型不仅用于传统的协同过滤，还用于完全连接的深度神经网络，从而充分利用嵌入空间。额外的部分应该捕获矩阵分解可能遗漏的模式和特征。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/ed9c06c34351c7c1d0dc5ea27c745b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18Sym5c-DdY6tfUHjuUFNg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="957c" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">用Python的术语来说:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="9162" class="kx ky ji ok b gy oo op l oq or">embeddings_size = 50<br/>usr, prd = dtf_users.shape[0], dtf_users.shape[1]</span><span id="6976" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># Input layer</strong><br/>xusers_in = layers.Input(name="xusers_in", shape=(1,))<br/>xproducts_in = layers.Input(name="xproducts_in", shape=(1,))</span><span id="009e" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># A) Matrix Factorization<br/>## embeddings and reshape</strong><br/>cf_xusers_emb = layers.Embedding(name="cf_xusers_emb", input_dim=usr, output_dim=embeddings_size)(xusers_in)<br/>cf_xusers = layers.Reshape(name='cf_xusers', target_shape=(embeddings_size,))(cf_xusers_emb)</span><span id="a800" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## embeddings and reshape</strong><br/>cf_xproducts_emb = layers.Embedding(name="cf_xproducts_emb", input_dim=prd, output_dim=embeddings_size)(xproducts_in)<br/>cf_xproducts = layers.Reshape(name='cf_xproducts', target_shape=(embeddings_size,))(cf_xproducts_emb)</span><span id="99b5" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## product</strong><br/>cf_xx = layers.Dot(name='cf_xx', normalize=True, axes=1)([cf_xusers, cf_xproducts])</span><span id="43ef" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># B) Neural Network</strong><br/><strong class="ok jj">## embeddings and reshape</strong><br/>nn_xusers_emb = layers.Embedding(name="nn_xusers_emb", input_dim=usr, output_dim=embeddings_size)(xusers_in)<br/>nn_xusers = layers.Reshape(name='nn_xusers', target_shape=(embeddings_size,))(nn_xusers_emb)</span><span id="8b97" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## embeddings and reshape</strong><br/>nn_xproducts_emb = layers.Embedding(name="nn_xproducts_emb", input_dim=prd, output_dim=embeddings_size)(xproducts_in)<br/>nn_xproducts = layers.Reshape(name='nn_xproducts', target_shape=(embeddings_size,))(nn_xproducts_emb)</span><span id="44c4" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## concat and dense</strong><br/>nn_xx = layers.Concatenate()([nn_xusers, nn_xproducts])<br/>nn_xx = layers.Dense(name="nn_xx", units=int(embeddings_size/2), activation='relu')(nn_xx)</span><span id="f634" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/># Merge A &amp; B</strong><br/>y_out = layers.Concatenate()([cf_xx, nn_xx])<br/>y_out = layers.Dense(name="y_out", units=1, activation='linear')(y_out)</span><span id="3ddc" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># Compile</strong><br/>model = models.Model(inputs=[xusers_in,xproducts_in], outputs=y_out, name="Neural_CollaborativeFiltering")<br/>model.compile(optimizer='adam', loss='mean_absolute_error', metrics=['mean_absolute_percentage_error'])</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/d42ffbfec76e53de9f59a4f4eae7f1f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKRmPAzHmq1z07UjIKyleA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">utils.plot_model(model，to_file='model.png '，show_shapes=True，show_layer_names=True)</p></figure><p id="99bf" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">您可以使用与以前相同的代码运行它，并检查它是否比传统的协同过滤执行得更好。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/1e2389449724900f99eb5fede20b2792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F3w0UbZAf16FMUiLaXZxHw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><h2 id="fc06" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">混合模型</h2><p id="8fdc" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">让我们先回顾一下现实世界提供了什么样的数据:</p><ul class=""><li id="656e" class="nn no ji lv b lw ms lz mt lg np lk nq lo nr ml ns nt nu nv bi translated"><strong class="lv jj">目标变量</strong> —评级可以是显式的(即用户留下反馈)或隐式的(即如果用户看完整部电影，则假设是正面反馈)，无论如何它们都是必要的。</li><li id="b5de" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated"><strong class="lv jj">产品特征</strong> —项目(即电影类型)的标签和描述，主要用于基于内容的方法。</li><li id="06cf" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated"><strong class="lv jj">用户资料</strong> —关于用户的描述性信息可以是人口统计信息(即性别和年龄)或行为信息(即偏好、在屏幕上的平均时间、最频繁的使用时间)，通常用于基于知识的推荐。</li><li id="576a" class="nn no ji lv b lw nw lz nx lg ny lk nz lo oa ml ns nt nu nv bi translated"><strong class="lv jj">上下文</strong> —关于评级情况的附加信息(即时间、地点、搜索历史)，通常也包含在基于知识的推荐中。</li></ul><p id="f7af" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">现代推荐系统在预测我们的口味时，会将它们结合起来。例如，YouTube推荐下一个视频时，使用了谷歌知道的关于你的所有信息，而谷歌知道的很多。</p><p id="e67c" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">在这个例子中，我有产品特性和关于用户何时给出评级的数据，我将把它们用作上下文(或者，它也可以用来建立用户简档)。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="fe07" class="kx ky ji ok b gy oo op l oq or">features = dtf_products.drop(["genres","name"], axis=1).columns<br/>print(features)</span><span id="ab93" class="kx ky ji ok b gy os op l oq or">context = dtf_context.drop(["user","product"], axis=1).columns<br/>print(context)</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi po"><img src="../Images/4f8446f5dc40eaa0ad0fdefe356be766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ojyn6hRCx38CWwcB_Cf3Bg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="4048" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">让我们将额外信息添加到<em class="ob">训练</em>集合中:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="4fb4" class="kx ky ji ok b gy oo op l oq or">train = dtf_train.stack(dropna=True).reset_index().rename(columns={0:"y"})</span><span id="d76d" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## add features</strong><br/>train = train.merge(dtf_products[features], how="left", left_on="product", right_index=True)</span><span id="6562" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## add context</strong><br/>train = train.merge(dtf_context, how="left")</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pp"><img src="../Images/eec5e4f9c9d5cc4d20520ae8f39e6801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i95uSviWRl2PkKIXh9Idkg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="da03" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">请注意，您可以对<em class="ob">测试</em>集做同样的事情，但是如果您想要模拟真实的生产，您应该为上下文插入一个静态值。简单来说，如果我们在周一晚上为我们平台的用户做预测，上下文变量应该是<em class="ob">白天=0 </em>和<em class="ob">周末=0 </em>。</p><p id="385d" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">现在我们拥有了构建<strong class="lv jj">上下文感知混合模型</strong>的所有要素。神经网络的灵活性允许我们添加任何我们想要的东西，所以我将采用神经协同过滤网络结构，并尽可能多地包含模块。</p><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pq"><img src="../Images/b9d127a0483b9167a1c4dc13cb029f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lDwcaXFxHdN2yfxMEVbMg.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="45a0" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">尽管代码看起来很难，我们只是在已经使用的基础上增加了几层。</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="a161" class="kx ky ji ok b gy oo op l oq or">embeddings_size = 50<br/>usr, prd = dtf_users.shape[0], dtf_users.shape[1]<br/>feat = len(features)<br/>ctx = len(context)</span><span id="fedc" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/>################### COLLABORATIVE FILTERING ########################<br/># Input layer</strong><br/>xusers_in = layers.Input(name="xusers_in", shape=(1,))<br/>xproducts_in = layers.Input(name="xproducts_in", shape=(1,))</span><span id="1a63" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># A) Matrix Factorization<br/>## embeddings and reshape</strong><br/>cf_xusers_emb = layers.Embedding(name="cf_xusers_emb", input_dim=usr, output_dim=embeddings_size)(xusers_in)<br/>cf_xusers = layers.Reshape(name='cf_xusers', target_shape=(embeddings_size,))(cf_xusers_emb)</span><span id="67a3" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## embeddings and reshape</strong><br/>cf_xproducts_emb = layers.Embedding(name="cf_xproducts_emb", input_dim=prd, output_dim=embeddings_size)(xproducts_in)<br/>cf_xproducts = layers.Reshape(name='cf_xproducts', target_shape=(embeddings_size,))(cf_xproducts_emb)</span><span id="e510" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## product</strong><br/>cf_xx = layers.Dot(name='cf_xx', normalize=True, axes=1)([cf_xusers, cf_xproducts])</span><span id="9391" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># B) Neural Network<br/>## embeddings and reshape</strong><br/>nn_xusers_emb = layers.Embedding(name="nn_xusers_emb", input_dim=usr, output_dim=embeddings_size)(xusers_in)<br/>nn_xusers = layers.Reshape(name='nn_xusers', target_shape=(embeddings_size,))(nn_xusers_emb)</span><span id="467e" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## embeddings and reshape</strong><br/>nn_xproducts_emb = layers.Embedding(name="nn_xproducts_emb", input_dim=prd, output_dim=embeddings_size)(xproducts_in)<br/>nn_xproducts = layers.Reshape(name='nn_xproducts', target_shape=(embeddings_size,))(nn_xproducts_emb)</span><span id="42ce" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj">## concat and dense</strong><br/>nn_xx = layers.Concatenate()([nn_xusers, nn_xproducts])<br/>nn_xx = layers.Dense(name="nn_xx", units=int(embeddings_size/2), activation='relu')(nn_xx)</span><span id="a6fb" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/>######################### CONTENT BASED ############################<br/># Product Features</strong><br/>features_in = layers.Input(name="features_in", shape=(feat,))<br/>features_x = layers.Dense(name="features_x", units=feat, activation='relu')(features_in)</span><span id="3f05" class="kx ky ji ok b gy os op l oq or"><br/><strong class="ok jj">######################## KNOWLEDGE BASED ###########################<br/># Context</strong><br/>contexts_in = layers.Input(name="contexts_in", shape=(ctx,))<br/>context_x = layers.Dense(name="context_x", units=ctx, activation='relu')(contexts_in)</span><span id="e61f" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"><br/>########################## OUTPUT ##################################<br/># Merge all</strong><br/>y_out = layers.Concatenate()([cf_xx, nn_xx, features_x, context_x])<br/>y_out = layers.Dense(name="y_out", units=1, activation='linear')(y_out)</span><span id="1d3f" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># Compile</strong><br/>model = models.Model(inputs=[xusers_in,xproducts_in, features_in, contexts_in], outputs=y_out, name="Hybrid_Model")<br/>model.compile(optimizer='adam', loss='mean_absolute_error', metrics=['mean_absolute_percentage_error'])</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pr"><img src="../Images/b94b881b3fce60e5f0b6095a649e7c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2o3FYsqSXM7V7XhMEAQdA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">utils.plot_model(model，to_file='model.png '，show_shapes=True，show_layer_names=True)</p></figure><p id="9044" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">这种混合模型需要更多的输入，所以不要忘记输入新数据:</p><pre class="mn mo mp mq gt oj ok ol om aw on bi"><span id="ea84" class="kx ky ji ok b gy oo op l oq or"><strong class="ok jj"># Train</strong><br/>training = model.fit(x=[train["user"], train["product"], <strong class="ok jj">train[features]</strong>, <strong class="ok jj">train[context]</strong>], y=train["y"], <br/>                     epochs=100, batch_size=128, shuffle=True, verbose=0, validation_split=0.3)</span><span id="5a57" class="kx ky ji ok b gy os op l oq or">model = training.model</span><span id="77a8" class="kx ky ji ok b gy os op l oq or"><strong class="ok jj"># Test</strong><br/>test["yhat"] = model.predict([test["user"], test["product"], <strong class="ok jj">test[features]</strong>, <strong class="ok jj">test[context]</strong>])</span></pre><figure class="mn mo mp mq gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ps"><img src="../Images/ce83a3cfd409d7d3a96b4d2719b9aba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uC86YByCmmHoyp7EQCv4Iw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">作者图片</p></figure><p id="216b" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">与其他方法相比，对于该特定用户，混合模型获得了最高的准确性，因为三个预测产品具有匹配的订单。</p><h2 id="124e" class="kx ky ji bd kz la lb dn lc ld le dp lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">结论</h2><p id="8e73" class="pw-post-body-paragraph lt lu ji lv b lw lx kj ly lz ma km mb lg mc md me lk mf mg mh lo mi mj mk ml im bi translated">这篇文章是一个教程，展示了如何用神经网络设计和构建推荐系统。我们看到了基于数据可用性的不同用例:对单用户场景应用基于内容的方法，对多用户产品应用协作过滤。更重要的是，我们了解了如何使用神经网络来改进传统技术，并构建可以包含上下文和任何其他附加信息的现代混合推荐系统。</p><p id="9573" class="pw-post-body-paragraph lt lu ji lv b lw ms kj ly lz mt km mb lg mu md me lk mv mg mh lo mw mj mk ml im bi translated">我希望你喜欢它！如有问题和反馈，或者只是分享您感兴趣的项目，请随时联系我。</p><blockquote class="pt"><p id="b4c3" class="pu pv ji bd pw px py pz qa qb qc ml dk translated">👉<a class="ae mr" href="https://linktr.ee/maurodp" rel="noopener ugc nofollow" target="_blank">我们来连线</a>👈</p></blockquote></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><blockquote class="qd qe qf"><p id="02ed" class="lt lu ob lv b lw ms kj ly lz mt km mb qg mu md me qh mv mg mh qi mw mj mk ml im bi translated">本文是系列<strong class="lv jj">用Python进行机器学习</strong>的一部分，参见:</p></blockquote><div class="is it gp gr iu mx"><a rel="noopener follow" target="_blank" href="/deep-learning-with-python-neural-networks-complete-tutorial-6b53c0b06af0"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jj gy z fp nc fr fs nd fu fw jh bi translated">Python深度学习:神经网络(完整教程)</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">用TensorFlow建立、绘制和解释人工神经网络</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="qj l ni nj nk ng nl ja mx"/></div></div></a></div><div class="is it gp gr iu mx"><a rel="noopener follow" target="_blank" href="/machine-learning-with-python-classification-complete-tutorial-d2c99dc524ec"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jj gy z fp nc fr fs nd fu fw jh bi translated">用Python进行机器学习:分类(完整教程)</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">数据分析和可视化、特征工程和选择、模型设计和测试、评估和解释</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="qk l ni nj nk ng nl ja mx"/></div></div></a></div><div class="is it gp gr iu mx"><a rel="noopener follow" target="_blank" href="/machine-learning-with-python-regression-complete-tutorial-47268e546cea"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jj gy z fp nc fr fs nd fu fw jh bi translated">Python机器学习:回归(完整教程)</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">数据分析和可视化、特征工程和选择、模型设计和测试、评估和解释</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="ql l ni nj nk ng nl ja mx"/></div></div></a></div><div class="is it gp gr iu mx"><a rel="noopener follow" target="_blank" href="/clustering-geospatial-data-f0584f0b04ec"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd jj gy z fp nc fr fs nd fu fw jh bi translated">聚类地理空间数据</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">使用交互式地图绘制机器学习和深度学习聚类</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="qm l ni nj nk ng nl ja mx"/></div></div></a></div></div></div>    
</body>
</html>