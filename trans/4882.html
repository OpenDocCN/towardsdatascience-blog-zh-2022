<html>
<head>
<title>The Art of Speeding Up Python Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速Python循环的艺术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-art-of-speeding-up-python-loop-4970715717c#2022-10-31">https://towardsdatascience.com/the-art-of-speeding-up-python-loop-4970715717c#2022-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f1cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中没有“最好的”循环技术，只有最合适的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1072963f4abfdd650e88d40120d1f8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03BYCqpaHMe3kHRLs5NAFQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/photos/HUJDz6CJEaM" rel="noopener ugc nofollow" target="_blank">图片</a>来自<a class="ae ky" href="https://unsplash.com/@chrisliverani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>来自<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="c829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">" Python中最快的循环技术是什么？"</p><p id="df38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个合理的问题，但往往过于简单化。如果有一种循环方法比其他方法更好，那么其他的技术就会被弃用。</p><p id="af72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，没有“最好”。</p><p id="3724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如生活中的大多数事情一样，会有这样的情况，其中一个明显优于其他人，而在其他一些情况下，这绝对是垃圾。它们视情况而定。用Python思考循环优化的更好方式应该是这样的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/f47c5df44c4b870cbe219398f5df2d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VP2r97Vj1wcxkNQG6Dh6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对您的用例来说，最佳的循环技术取决于一系列的决策。图片由作者提供。</p></figure><p id="4304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们中的每一个都有其自身的用处。我不想再写另一篇速度测试文章，我想强调是什么使它们独一无二，何时使用它们，以及如何使它们变得更好？你会惊讶地发现，通过一个简单的语法调整，我们可以将它们的性能提高8000倍。</p><p id="403e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环技术的类型:</p><ul class=""><li id="39a8" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">循环迭代</li><li id="c5d3" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">列表理解</li><li id="6c2d" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">λ函数</li><li id="0da5" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">矢量化运算</li></ul><h1 id="860a" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">循环迭代</h1><p id="e4d6" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated"><em class="nq"> For-loops </em>是传授给Python初学者的入门级循环技术，因为它们易于阅读且用途广泛。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="64b5" class="nw mu it ns b gy nx ny l nz oa">items = ['bat', 'cat', 'dog']<br/>for item in items:<br/>  print(item)</span><span id="b958" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; bat<br/>&gt;&gt; cat<br/>&gt;&gt; dog</strong></span></pre><p id="347e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，许多人认为for循环是高效编程的对立面。它们很慢，因为Python的for循环实现有非常大的开销(例如:类型检查等——稍后讨论),每次迭代都要执行。</p><p id="4c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种主要类型的for循环，即(I)索引循环和(ii)行循环。</p><h2 id="f95f" class="nw mu it bd mv oc od dn mz oe of dp nd li og oh nf lm oi oj nh lq ok ol nj om bi translated">索引循环</h2><p id="8349" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">一个索引循环接受一个数字序列(例如:[0，1，2，…])并为序列中的每个元素运行代码逻辑。</p><p id="2d52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一次迭代中，Python在执行循环中的代码之前，将变量<code class="fe on oo op ns b">idx</code>赋给序列的第一个元素(在本例中为0)。然后，<code class="fe on oo op ns b">idx</code>被重新分配给第二个、第三个……元素，循环重复，直到序列结束。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="5821" class="nw mu it ns b gy nx ny l nz oa">for idx in ['bat', 'cat', 'dog']:<br/>  print(f'Hello, I am index {idx}.')</span><span id="33bc" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; Hello, I am index bat.<br/>&gt;&gt; Hello, I am index cat.<br/>&gt;&gt; Hello, I am index dog.</strong></span></pre><p id="7635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们需要控制序列的起始索引、结束索引和步长时，索引循环非常有用。</p><p id="ff5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果你想从第1000行循环到第2000行…</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="c4e0" class="nw mu it ns b gy nx ny l nz oa">res = 0<br/>for idx in range(1000, 2000):<br/>  res += df.loc[idx, 'int']</span></pre><p id="5a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你只需要第1000到2000行的第5个元素…</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="51e4" class="nw mu it ns b gy nx ny l nz oa">res = 0<br/>for idx in range(1000, 2000, 5):<br/>  res += df.loc[idx, 'int']</span></pre><p id="7259" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">索引循环非常灵活，但是它们通常被认为是缓慢的循环技术。虽然在某种程度上是真的，但也不尽然！出于基准测试的目的，这里有一个简单的循环，它返回<code class="fe on oo op ns b">int</code>列的总和。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="e1a0" class="nw mu it ns b gy nx ny l nz oa">%%timeit<br/>res = 0<br/>for idx in range(0, 100000):<br/>  res += df.loc[idx, 'int']</span><span id="d180" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; 486 ms ± 4.28 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</strong></span></pre><p id="6bda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以实现相同的功能，但通过一个简单的优化技巧— <code class="fe on oo op ns b">np.arange()</code>可以获得更好的性能。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="137f" class="nw mu it ns b gy nx ny l nz oa">%%timeit<br/>res = 0<br/>for idx in np.arange(0, 100000):<br/>  res += df.loc[idx, 'int']</span><span id="2ba6" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; 60.3 µs ± 355 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)</strong></span></pre><p id="6bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的代码，但是<code class="fe on oo op ns b">np.arange()</code>比<code class="fe on oo op ns b">range()</code>快8000倍<strong class="lb iu">。</strong></p><p id="a224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因如下。</p><p id="2d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op ns b">range()</code>是一个内置的Python类范围，仅存储所需数字序列的起点、终点和步长。只有当我们开始遍历序列时，数字列表才会在幕后迭代生成。这可以节省内存，因为我们不需要一直存储整个序列，但由于生成数字的开销，这会影响性能。</p><p id="2538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe on oo op ns b">np.arange()</code>则是第三方库(Numpy)功能。在功能上，它们类似于<code class="fe on oo op ns b">range()</code>，但是NumPy实现在C级上执行许多操作，包括循环，这比Python的性能好得多。它们针对使用向量进行了优化，避免了很多与Python相关的开销。</p><blockquote class="oq or os"><p id="c171" class="kz la nq lb b lc ld ju le lf lg jx lh ot lj lk ll ou ln lo lp ov lr ls lt lu im bi translated">由于<code class="fe on oo op ns b">range()</code>和<code class="fe on oo op ns b">np.arange()</code>做的是同样的事情，我推荐在需要索引循环的时候总是使用<code class="fe on oo op ns b">np.arange()</code>。</p></blockquote><h2 id="24ef" class="nw mu it bd mv oc od dn mz oe of dp nd li og oh nf lm oi oj nh lq ok ol nj om bi translated">行循环</h2><p id="c33f" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">行循环遍历熊猫数据帧的行—第1行、第2行、…、第n行。每次迭代时，它返回特定迭代的<strong class="lb iu">行索引</strong>和<strong class="lb iu">行数据</strong>。行循环最常见的实现是<code class="fe on oo op ns b">DataFrame.iterrows()</code>函数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="9fa7" class="nw mu it ns b gy nx ny l nz oa">for idx, row in df.iterrows():<br/>  print(f'row_idx: {idx}, row_data: {row}')</span><span id="112c" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; row_idx: 0, row_data:<br/>animal             bat<br/>animal_type        mammals<br/>Name: 0, dtype: object</strong></span><span id="cb81" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; row_idx: 1, row_data: <br/>animal             dog<br/>animal_type        mammals<br/>Name: 1, dtype: object</strong></span><span id="f89f" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; ...</strong></span></pre><p id="f519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于行循环返回行索引<em class="nq">和</em>行数据，这给了我们额外的能力——重命名行数据的能力。根据上面的例子，我们可以将行数据放入一个<code class="fe on oo op ns b">row</code>变量中，并通过<code class="fe on oo op ns b">row['col_name']</code>访问它。</p><p id="c9c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代替我们通常在索引循环中使用的<code class="fe on oo op ns b">df.loc[idx, 'col_name']</code>,现在代码看起来，嗯，可能更简洁一点。但是真正的改进是在我们解包并重命名每个单独的列时开始的，就像这样…</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="6878" class="nw mu it ns b gy nx ny l nz oa"># Better<br/>res = 0<br/>for idx, row in df.iterrows():<br/>  res += row['col3']</span><span id="c966" class="nw mu it ns b gy ob ny l nz oa"># Even better<br/>%%timeit<br/>res = 0<br/>for idx, (col1, col2, col3) in df.iterrows():<br/>  res += col3</span><span id="0c0f" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; 4.86 s ± 28.4 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</strong></span></pre><p id="0fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净多了，对吧？</p><p id="85fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，就性能而言，行循环落后于索引循环。我们执行相同的逻辑，但是…</p><ul class=""><li id="1d81" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe on oo op ns b">np.arange()</code>耗时0.0000603秒。</li><li id="0405" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe on oo op ns b">range()</code>跑了0.486秒。</li><li id="b6a2" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe on oo op ns b">DataFrame.iterrows()</code>跑了4.86秒。</li></ul><p id="9f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是——就像Index Loop一样——我们可以通过简单的改变来优化它。用<code class="fe on oo op ns b">itertuples()</code>代替<code class="fe on oo op ns b">iterrows()</code>。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="7fef" class="nw mu it ns b gy nx ny l nz oa">%%timeit<br/>res = 0<br/>for row in df.itertuples():<br/>  res += getattr(row, 'int')</span><span id="5708" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; 160 ms ± 13.4 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</strong></span></pre><p id="1213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，<code class="fe on oo op ns b">itertuples()</code>比<code class="fe on oo op ns b">iterrows()</code>快<strong class="lb iu"> 30x </strong>。但是为什么呢？<code class="fe on oo op ns b">iterrows()</code>和<code class="fe on oo op ns b">itertuples()</code>有什么区别？</p><p id="2f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于好奇的灵魂，这里有一篇很棒的<a class="ae ky" href="https://medium.com/swlh/why-pandas-itertuples-is-faster-than-iterrows-and-how-to-make-it-even-faster-bc50c0edd30d" rel="noopener">文章</a>详细解释了它。TLDR版本…</p><ul class=""><li id="9c96" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe on oo op ns b">iterrows()</code>返回<code class="fe on oo op ns b">Series</code>对象中的行数据。它不保留数据类型，所以在循环时必须执行大量的类型检查。更多的检查=更慢的循环。</li><li id="23c4" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe on oo op ns b">itertuples()</code>返回<code class="fe on oo op ns b">tuple</code>中的行数据。它保留了数据类型，因此只需要最少的类型检查。更少的检查=更快的循环，快得多。在我们的例子中，<code class="fe on oo op ns b">itertuples()</code>比<strong class="lb iu"> ~30倍于</strong>。</li></ul><blockquote class="oq or os"><p id="c6e2" class="kz la nq lb b lc ld ju le lf lg jx lh ot lj lk ll ou ln lo lp ov lr ls lt lu im bi translated">如果我们需要访问行数据，最好使用行循环而不是索引循环。此外，优先考虑<code class="fe on oo op ns b">itertuples()</code>而不是<code class="fe on oo op ns b">iterrows()</code>，因为它要快得多。</p></blockquote><h1 id="c6eb" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">列表理解</h1><p id="ce71" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">Python List Comprehension是基于现有列表的值创建一个<code class="fe on oo op ns b">list</code>对象的一种简单而巧妙的方法。它有下面的一般表达式。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="eb28" class="nw mu it ns b gy nx ny l nz oa">List = [expression(i) for i in another_list if filter(i)]</span></pre><p id="5ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，不要…</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="8043" class="nw mu it ns b gy nx ny l nz oa">%%timeit<br/>for (idx, animal, animal_type, _) in df.itertuples():<br/>    if animal == 'dog':<br/>        animal_type = 'mammals'<br/>    elif animal == 'frog':<br/>        animal_type = 'amphibians'<br/>    elif animal == 'goldfish':<br/>        animal_type = 'fish'<br/>    else:<br/>        animal_type = 'others'</span><span id="126f" class="nw mu it ns b gy ob ny l nz oa">df.loc[idx, 'animal_type'] = animal_type</span><span id="0ff9" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; 1min 41s ± 393 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</strong></span></pre><p id="8ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把这些废话浓缩成几行代码。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="582b" class="nw mu it ns b gy nx ny l nz oa">%%timeit<br/>df['animal_type'] = ['mammals' if animal == 'dog' else<br/>                     'amphibians' if animal == 'frog' else<br/>                     'fish' if animal == 'goldfish' else<br/>                     'others' for animal in df['animal']]</span><span id="f21f" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; 16.7 ms ± 92.3 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</strong></span></pre><p id="90c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">列表理解不仅更紧凑、更容易掌握，而且比普通循环迭代得更快。在这种情况下，列表理解比行循环快6048倍！</p><p id="4791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可悲的是，有一个限制。</p><p id="b3ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我没有使用与其他部分相同的示例(我们根据<code class="fe on oo op ns b">int</code>列的总和进行性能基准测试)？</p><p id="3524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不能。</p><p id="1a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">List comprehension的语法很简单，但是保持简单的意图也限制了它能做什么。例如，我们不能有一个变量在迭代时存储当前值的总和。即使我尝试了一种类似黑客的方式，在一个列表理解范围之外的函数中指定<code class="fe on oo op ns b">current_sum</code>，它仍然使用初始值<code class="fe on oo op ns b">current_sum</code>，而不是在每次迭代时更新。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="3f27" class="nw mu it ns b gy nx ny l nz oa">old_list = [10, 20, 30, 40, 50]<br/>print(f'old_list is... {old_list}')</span><span id="ffc7" class="nw mu it ns b gy ob ny l nz oa">current_sum = 0<br/>def get_cumulative_sum(x, current_sum):<br/>    current_sum += x<br/>    return current_sum</span><span id="54dc" class="nw mu it ns b gy ob ny l nz oa">new_list = [get_cumulative_sum(x, current_sum) for x in old_list]<br/>print(f'new_list is... {new_list}')</span><span id="86bd" class="nw mu it ns b gy ob ny l nz oa"><strong class="ns iu">&gt;&gt; old_list is... [10, 20, 30, 40, 50]<br/>&gt;&gt; new_list is... [10, 20, 30, 40, 50]</strong></span></pre><p id="9307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，每个列表理解都可以在for循环中重写，但不是每个for循环都可以在列表理解中重写。如果你正在写一些复杂的逻辑，避免列表理解。</p><blockquote class="oq or os"><p id="896c" class="kz la nq lb b lc ld ju le lf lg jx lh ot lj lk ll ou ln lo lp ov lr ls lt lu im bi translated">总而言之，列表理解只是迭代的语法糖。它通常比普通的循环要快，但是应该只用于简单的代码逻辑以保持可读性。</p></blockquote><h1 id="605c" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">λ函数</h1><p id="aeac" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">在Python中定义函数时(通常的方式)，我们需要给函数命名。Lambda是另一种方法，它允许我们创建函数，但是没有名字。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="70c1" class="nw mu it ns b gy nx ny l nz oa"># The usual way<br/>def multiply_two(x):<br/>  return x * 2</span><span id="63fc" class="nw mu it ns b gy ob ny l nz oa"># Lambda function<br/>multiply_two = lambda x: x * 2</span></pre><p id="bce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型的“无名”函数被称为立即调用函数表达式(IIFE)。它们一创建就被执行，不需要显式调用来调用函数。</p><p id="fc6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用外行人的话来说，生命跑得更快。</p><p id="0174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是Lambda only <em class="nq">创建</em>生命函数，它不执行函数——这就是为什么我们通常看到Lambda函数与Panda的<code class="fe on oo op ns b">DataFrame.apply()</code>一起使用。它将一个函数(lambda或not)作为参数，并将其应用于每一行(或每一列)。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="ea30" class="nw mu it ns b gy nx ny l nz oa"># Apply the function to each column.<br/>output = df.apply(lambda x: x*2, axis=0)</span><span id="baa2" class="nw mu it ns b gy ob ny l nz oa"># Apply the function to each row.<br/>output = df.apply(lambda x: x*2, axis=1)</span></pre><p id="05df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这些功能到底有多快呢？让我们比较一下列表理解和lambda函数。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="bee8" class="nw mu it ns b gy nx ny l nz oa">%%timeit<br/>def get_type(animal):<br/>    if animal == 'dog':<br/>        animal_type = 'mammals'<br/>    elif animal == 'frog':<br/>        animal_type = 'amphibians'<br/>    elif animal == 'goldfish':<br/>        animal_type = 'fish'<br/>    else:<br/>        animal_type = 'others'<br/>    return animal_type</span><span id="40c1" class="nw mu it ns b gy ob ny l nz oa"># List comprehension<br/>df['animal_type'] = [get_type(x) for x in df['animal']]<br/><strong class="ns iu">&gt;&gt; 21.7 ms ± 140 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</strong></span><span id="a5cc" class="nw mu it ns b gy ob ny l nz oa"># Lambda function<br/>df['animal_type'] = df['animal'].apply(lambda x: get_type(x))<br/><strong class="ns iu">&gt;&gt; 24.6 ms ± 187 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</strong></span></pre><p id="6252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然列表理解和lambda函数是根本不同的概念，但它们有非常相似的特征…</p><ul class=""><li id="a13f" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">性能—相同。</li><li id="0b05" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">灵活性——两者都更适合简单的代码逻辑。我们不能创建跟踪先前迭代输出的变量。</li></ul><blockquote class="oq or os"><p id="eb2b" class="kz la nq lb b lc ld ju le lf lg jx lh ot lj lk ll ou ln lo lp ov lr ls lt lu im bi translated">总结一下，lambda函数和列表理解是po-tae-toe和po-tah-toh。使用您更喜欢的语法。就我个人而言，我更喜欢列表理解，因为它们读起来更直观。</p></blockquote><h1 id="37b9" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">矢量化运算</h1><p id="4c96" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">矢量化操作就像搬房子。你宁愿…</p><ul class=""><li id="9456" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">装载一件家具，开到你的新家，卸下，然后重复？</li><li id="e850" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">把所有东西都装上，开到你的新家，一次卸完？</li></ul><p id="236c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后者肯定更有效，它非常类似于矢量化运算的工作方式。</p><p id="2310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在非矢量化操作中，CPU将单个值加载到内存中，执行计算，然后返回一个输出。它在每次循环迭代中重复这个步骤。但更有意思的是，CPU的内存可以存储不止一个值——这意味着大部分CPU容量都处于闲置状态。</p><p id="3561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在向量化操作中，CPU尽可能多地加载内存，这样我们就可以一次完成计算<em class="nq"/>。开销的节省有助于大幅提高性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/bf186e73ae7d94647441e8eb0d37b532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-_Uslu_7eqYJPFpvA6w3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非向量化操作不会最大限度地利用CPU资源。图片由作者提供。</p></figure><p id="c479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了最大化CPU容量之外，矢量化运算还经常在用低级语言(例如:C)编写的优化的预编译代码中实现。这些语言本质上比Python更具性能，而且它们还避免了数据类型检查等开销。</p><p id="9084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理论已经足够了——这里有一个简单的矢量化操作。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="b7a0" class="nw mu it ns b gy nx ny l nz oa"># Non-vectorised operation<br/>def calc_result(row):<br/>    return row['col1'] +(row['col2'] * row['col3'])<br/>df['result'] = df.apply(calc_result, axis=1)<br/><strong class="ns iu">&gt;&gt; 984 ms ± 16.3 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</strong></span><span id="b928" class="nw mu it ns b gy ob ny l nz oa"># Vectorised operation<br/>df['result'] = df['col1'] + (df['col2'] * df['col3'])<br/><strong class="ns iu">&gt;&gt; 227 µs ± 1.39 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</strong></span></pre><p id="b933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">矢量化运算的执行速度比非矢量化运算快<strong class="lb iu">到4350倍</strong>。代码很直观，读起来也更清晰。</p><p id="d1ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了对数字执行数学运算，矢量化运算还可以执行非计算运算，对其他数据类型也是如此。Jake VanderPlas在他的Python数据科学手册中分享了一个关于可能的字符串类型矢量化操作的<a class="ae ky" href="https://jakevdp.github.io/PythonDataScienceHandbook/03.10-working-with-strings.html" rel="noopener ugc nofollow" target="_blank">好参考</a>。</p><pre class="kj kk kl km gt nr ns nt nu aw nv bi"><span id="90b1" class="nw mu it ns b gy nx ny l nz oa"># Two examples of Vectorised Operation for String-type<br/>df['result'] = df['String'].str.extract('([A-Za-z]+)', expand=<strong class="ns iu">False</strong>)<br/>df['result'] = df['String'].str.split('T').str[0]</span><span id="abae" class="nw mu it ns b gy ob ny l nz oa"># Two examples of Vectorised Operation for DateTime-type<br/>df['result'] = df['Date'].dt.day_name()<br/>df['result'] = df['Date'].dt.year</span></pre><p id="0b2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，矢量化运算同时加载和运行所有内容这一事实也意味着它只能对每个输入值执行相同的运算。如果我们想将一列除以2，它必须将该列中的所有值除以2，没有例外。</p><blockquote class="oq or os"><p id="6cbe" class="kz la nq lb b lc ld ju le lf lg jx lh ot lj lk ll ou ln lo lp ov lr ls lt lu im bi translated">换句话说，矢量化运算是最快的迭代方式之一，并且具有最简洁的语法。它们非常适合对整个数据序列应用简单统一的操作。但是如果我们试图应用条件逻辑(例如；if-then)，请改用Lambda函数或List Comprehension。</p></blockquote><h1 id="e836" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结束语</h1><p id="97dc" class="pw-post-body-paragraph kz la it lb b lc nl ju le lf nm jx lh li nn lk ll lm no lo lp lq np ls lt lu im bi translated">我希望这能帮助你看到每种循环技术的优点和局限性。“最佳”循环技术总是依赖于您正在实现的逻辑类型。</p><p id="9336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一点，这个比较并不详尽。为了简单起见，故意省略了一些小细节。这里的信息<em class="nq">通常</em>是正确的，但是对于不同的用例，你可能会遇到稍微不同的性能(例如:在字符串上矢量化的操作比较慢)。我建议你自己对循环计时，如果你真的想榨出优化的汁液，就使用<a class="ae ky" href="https://stackoverflow.com/questions/23885147/how-do-i-use-line-profiler-from-robert-kern" rel="noopener ugc nofollow" target="_blank">线条分析器</a>。</p><p id="f45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之前，祝你好运和成功。</p></div></div>    
</body>
</html>