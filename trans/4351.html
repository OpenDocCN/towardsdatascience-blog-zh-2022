<html>
<head>
<title>The Easy Python CI/CD Pipeline Using Docker Compose and GitHub Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose和GitHub操作的简单Python CI/CD管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-easy-python-ci-cd-pipeline-using-docker-compose-and-github-actions-80498f47b341#2022-09-27">https://towardsdatascience.com/the-easy-python-ci-cd-pipeline-using-docker-compose-and-github-actions-80498f47b341#2022-09-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="da81" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在VPS上持续部署真实世界的项目</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/bc45ab8079590ced7381af19a3ea29cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jTbFhBlhQf99WvyL"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@guilhermestecanella?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">古伊列梅·斯特卡内拉</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="db60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在远程服务器上管理一个实时项目实际上需要一些领域，我们希望在这些领域减少人工干预，用自动化服务来代替。答:首先，每次我们向GitHub库推送新代码时，我们可能需要按顺序执行以下任一操作:</p><ul class=""><li id="2716" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">对我们的项目进行测试</li><li id="7dff" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">用新版本更新Docker映像</li><li id="1b07" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">将带有新建映像的应用程序部署到我们的服务器</li></ul><p id="ef70" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与这些过程中的每一个相关联的复杂性本身并不是微不足道的，当您每次都需要按顺序执行它们时，这就变成了一件苦差事。因此，自动化集成和部署在开发人员眼中具有巨大的价值。</p><p id="5997" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这里，我们看一下用Docker compose和GitHub动作自动化CI/CD管道的简单方法。</p><h1 id="4d98" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">用discord.py和FastAPI构建discord bot</h1><p id="2219" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">我想在我最近从事的一个项目中展示整个管道，这是一个用<em class="nh"> discord.py </em>编写的discord机器人，用于在discord服务器中引入优雅的轮询服务。</p><p id="c73a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">bot存储库位于<a class="ae kz" href="https://github.com/yashprakash13/Pollsome" rel="noopener ugc nofollow" target="_blank">这里</a>。以下是我正在处理的项目结构:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/41f9a74a510b6b75b35d8c884032b7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*z3ulgMeux0THe_Z0zj4VPw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">项目结构</p></figure><p id="d5ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您想跟进，可以在您的虚拟环境中使用以下命令简单地安装该项目的两个主要需求:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="017e" class="no ml iu nk b gz np nq l nr ns">pip install discord.py fastapi "uvicorn[standard]" python-dotenv</span></pre><p id="9513" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe nt nu nv nk b"><strong class="lc iv">discord.py</strong></code>是允许我们构建discord应用程序的主要库。<code class="fe nt nu nv nk b"><strong class="lc iv">FastAPI</strong></code>和它的ASGI网络服务器<code class="fe nt nu nv nk b"><strong class="lc iv">uvicorn</strong></code>将在部署时保持机器人在服务器上存活。最后，<code class="fe nt nu nv nk b"><strong class="lc iv">python-dotenv</strong></code>是一个简单的库，它将帮助我们在项目中使用<a class="ae kz" rel="noopener" target="_blank" href="/the-quick-guide-to-using-environment-variables-in-python-d4ec9291619e?source=your_stories_page-------------------------------------"> <em class="nh">环境变量</em> </a>。</p><blockquote class="nw nx ny"><p id="0e33" class="la lb nh lc b ld le jv lf lg lh jy li nz lk ll lm oa lo lp lq ob ls lt lu lv in bi translated">注意:如果你正在跟进，你可能想在<a class="ae kz" href="https://discord.com/developers/applications" rel="noopener ugc nofollow" target="_blank"> discord开发者门户</a>中制作一个应用程序和一个机器人，并获取它的令牌。<br/>我们将在项目根目录下的<code class="fe nt nu nv nk b"><strong class="lc iv">.env</strong></code>文件中使用这个令牌，如上图所示。</p></blockquote><p id="1b1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在快速看一下机器人代码，好吗？</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="9abd" class="no ml iu nk b gz np nq l nr ns">import asyncio</span><span id="9543" class="no ml iu nk b gz oc nq l nr ns">import discord</span><span id="009b" class="no ml iu nk b gz oc nq l nr ns">from dotenv import load_dotenv</span><span id="b6cc" class="no ml iu nk b gz oc nq l nr ns">import os</span><span id="3568" class="no ml iu nk b gz oc nq l nr ns">from discord.ext.commands import Bot</span><span id="7359" class="no ml iu nk b gz oc nq l nr ns">load_dotenv()</span><span id="0acf" class="no ml iu nk b gz oc nq l nr ns">TOKEN = os.environ.get('DISCORD_TOKEN')</span></pre><p id="2661" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们首先加载环境变量，并使用我们的dotnev库访问令牌。</p><p id="602d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们将我们的机器人定义如下:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="cede" class="no ml iu nk b gz np nq l nr ns">intents = discord.Intents.all()</span><span id="4c42" class="no ml iu nk b gz oc nq l nr ns">bot = Bot(command_prefix='!', help_command=None, intents=intents)</span></pre><p id="2346" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">命令前缀</strong>允许我们使用机器人只响应特定的命令。</p><p id="c95b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了使本文简单，我们只希望机器人做一件事:</p><ul class=""><li id="e292" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">读取消息中是否输入了特定命令，如果是，则回复它。</li></ul><p id="c536" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们想从传入的消息中捕获文本，我们用<code class="fe nt nu nv nk b"><strong class="lc iv">on_message</strong></code>函数来完成:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="f045" class="no ml iu nk b gz np nq l nr ns">@bot.event</span><span id="49e9" class="no ml iu nk b gz oc nq l nr ns">async def on_message(message):</span><span id="4d9c" class="no ml iu nk b gz oc nq l nr ns">    # Do not reply to self</span><span id="7552" class="no ml iu nk b gz oc nq l nr ns">    if message.author == bot.user:</span><span id="6e83" class="no ml iu nk b gz oc nq l nr ns">        return</span><span id="6ab1" class="no ml iu nk b gz oc nq l nr ns">    # Do not reply to any other bot</span><span id="a73a" class="no ml iu nk b gz oc nq l nr ns">    if message.author.bot:</span><span id="4274" class="no ml iu nk b gz oc nq l nr ns">        return </span><span id="ec1a" class="no ml iu nk b gz oc nq l nr ns">    # get the message content</span><span id="f3e3" class="no ml iu nk b gz oc nq l nr ns">    msg = message.content.lower()</span><span id="93ef" class="no ml iu nk b gz oc nq l nr ns">    # reply to the ping message</span><span id="a2c8" class="no ml iu nk b gz oc nq l nr ns">    if "!ping" in msg:</span><span id="d143" class="no ml iu nk b gz oc nq l nr ns">        await message.reply("Pong!", mention_author=False)</span></pre><p id="a4b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们把它包装在我们的异步API中，好吗？</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="4621" class="no ml iu nk b gz np nq l nr ns">from fastapi import FastAPI</span><span id="f3e2" class="no ml iu nk b gz oc nq l nr ns">app = FastAPI()</span><span id="2404" class="no ml iu nk b gz oc nq l nr ns">@app.get("/")</span><span id="8052" class="no ml iu nk b gz oc nq l nr ns">def main():</span><span id="43c5" class="no ml iu nk b gz oc nq l nr ns">    return "The bot is alive!"</span><span id="1a0a" class="no ml iu nk b gz oc nq l nr ns"># run the bot as a FastAPI async function</span><span id="feb6" class="no ml iu nk b gz oc nq l nr ns">@app.on_event("startup")</span><span id="074e" class="no ml iu nk b gz oc nq l nr ns">async def run():</span><span id="5185" class="no ml iu nk b gz oc nq l nr ns">    """</span><span id="ad2b" class="no ml iu nk b gz oc nq l nr ns">    to run the bot as a FastAPI async func</span><span id="be94" class="no ml iu nk b gz oc nq l nr ns">    """</span><span id="cc62" class="no ml iu nk b gz oc nq l nr ns">    try:<br/>        asyncio.create_task(bot.start(TOKEN))</span><span id="1446" class="no ml iu nk b gz oc nq l nr ns">    except:</span><span id="9200" class="no ml iu nk b gz oc nq l nr ns">        await bot.logout()</span></pre><p id="b71c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，使用以下shell命令运行bot:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="b5e6" class="no ml iu nk b gz np nq l nr ns">$ uvicorn run_bot:app --reload --port 8443 --host 0.0.0.0</span></pre><p id="aa83" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">服务器运行时，您将看到以下输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj od"><img src="../Images/edf63748f7d4a11ec1d83265fd0c1f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPxVnMqgUqlh-u3PV5z75Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">服务器状态</p></figure><p id="196d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你应该也能在你的服务器上看到你的机器人上线。</p><p id="b989" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，让我们将整个工作流容器化，以便在我们的VPS上轻松部署。</p><h1 id="07ee" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">构建Docker设置</h1><p id="1962" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">现在我们有了一个可用的API，下一步就是封装我们的应用程序。让我们构建一个docker文件来开始这项工作:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="fac5" class="no ml iu nk b gz np nq l nr ns">touch Dockerfile</span></pre><p id="cd04" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们想从以下几点开始:</p><ul class=""><li id="d2c0" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">下载并安装合适的Python版本</li><li id="ad8b" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">将我们的项目文件夹复制到容器中，</li><li id="9d1a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">从<code class="fe nt nu nv nk b"><strong class="lc iv">requirements.txt</strong></code>安装所有依赖项</li><li id="c5d1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">最后，暴露出需要的端口</li></ul><p id="2619" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们将这些行添加到我们的<code class="fe nt nu nv nk b"><strong class="lc iv">Dockerfile</strong></code>:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="254c" class="no ml iu nk b gz np nq l nr ns">FROM python:3.10.2-slim-bullseye</span><span id="041d" class="no ml iu nk b gz oc nq l nr ns"># Set environment variables</span><span id="3b1b" class="no ml iu nk b gz oc nq l nr ns">ENV PIP_DISABLE_PIP_VERSION_CHECK 1</span><span id="298f" class="no ml iu nk b gz oc nq l nr ns">ENV PYTHONDONTWRITEBYTECODE 1</span><span id="151a" class="no ml iu nk b gz oc nq l nr ns">ENV PYTHONUNBUFFERED 1</span><span id="3700" class="no ml iu nk b gz oc nq l nr ns">COPY . /pollsome_src</span><span id="c27d" class="no ml iu nk b gz oc nq l nr ns">WORKDIR /pollsome_src</span><span id="a392" class="no ml iu nk b gz oc nq l nr ns">RUN pip install -r requirements.txt</span><span id="ae96" class="no ml iu nk b gz oc nq l nr ns">EXPOSE 8443</span></pre><p id="71dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以在这里停下来，使用docker build命令来构建/更新/停止我们的容器，但是我们可以更进一步，为更简单的设置创建一个<code class="fe nt nu nv nk b"><strong class="lc iv">docker-compose </strong></code>文件:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="030a" class="no ml iu nk b gz np nq l nr ns">touch docker-compose.yml</span></pre><p id="15a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以我们希望我们的docker-compose文件使用Dockerfile来执行我们上面提到的所有步骤，并使用uvicorn命令运行我们的API (bot)。</p><p id="ba9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们这样做:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="70b4" class="no ml iu nk b gz np nq l nr ns">version: "3.9"</span><span id="3aa5" class="no ml iu nk b gz oc nq l nr ns">services:</span><span id="46f1" class="no ml iu nk b gz oc nq l nr ns">   bot:</span><span id="7a04" class="no ml iu nk b gz oc nq l nr ns">     build: .</span><span id="9b5f" class="no ml iu nk b gz oc nq l nr ns">     volumes:</span><span id="0207" class="no ml iu nk b gz oc nq l nr ns">       - .:/pollsome_src</span><span id="1ff1" class="no ml iu nk b gz oc nq l nr ns">     ports:</span><span id="6fec" class="no ml iu nk b gz oc nq l nr ns">       - "8443:8443"</span><span id="9f08" class="no ml iu nk b gz oc nq l nr ns">     command: uvicorn run_bot:app --reload --port 8443 --host 0.0.0.0</span></pre><p id="3047" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们可以简单地使用下面的命令来构建一个新的映像，并基于该映像启动一个容器:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="d9e0" class="no ml iu nk b gz np nq l nr ns">docker compose up --build -d --remove-orphans</span></pre><p id="b3de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们想停止容器，或者显示一些日志，我们可以这样做:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="4768" class="no ml iu nk b gz np nq l nr ns">docker compose down</span><span id="86e1" class="no ml iu nk b gz oc nq l nr ns"># and</span><span id="db10" class="no ml iu nk b gz oc nq l nr ns">docker compose logs</span></pre><p id="a47e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">可选步骤:</strong>构建一个<strong class="lc iv"> Makefile </strong>，用于使用更简单、更易于使用的命令执行这些任务集。</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="d6c4" class="no ml iu nk b gz np nq l nr ns">touch Makefile</span></pre><p id="b7e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后将以下指令插入文件中:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="17b0" class="no ml iu nk b gz np nq l nr ns">build:<br/>    docker compose up --build -d --remove-orphans</span><span id="a92f" class="no ml iu nk b gz oc nq l nr ns">up:<br/>    docker compose up -d</span><span id="595b" class="no ml iu nk b gz oc nq l nr ns">down:<br/>    docker compose down</span><span id="a478" class="no ml iu nk b gz oc nq l nr ns">show_logs:<br/>    docker compose logs</span></pre><p id="5040" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">太好了！现在我们已经为我们的API建立了完整的基础！</p><p id="0768" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来测试一下:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="d5c3" class="no ml iu nk b gz np nq l nr ns">make build</span></pre><p id="3d41" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您将看到以下输出:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oe"><img src="../Images/524f55f29578d9ef05484d6bf340e279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KvXcroarTKI9NxpffrzpAw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">生成输出</p></figure><p id="a935" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要停止容器，请执行以下操作:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="dfc2" class="no ml iu nk b gz np nq l nr ns">make down</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/d7413dbbb71036c5c19005c719a8a218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*KYK1MVgmSg5AGMbkPvnZzA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">降低输出</p></figure><p id="dc9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，提交代码并将其推送到GitHub存储库。</p><h1 id="ba8d" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">远程服务器上手动部署</h1><p id="808c" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">让我们继续在租来的虚拟主机上部署我们的项目。</p><p id="e039" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一步是SSH到您的服务器并克隆存储库。</p><blockquote class="nw nx ny"><p id="e3f3" class="la lb nh lc b ld le jv lf lg lh jy li nz lk ll lm oa lo lp lq ob ls lt lu lv in bi translated">如果你想知道如何用SSH在你的远程服务器上设置GitHub访问，那么先按照这些指示做<a class="ae kz" href="https://medium.com/this-code/set-up-github-via-ssh-on-a-remote-server-9348e3855f46?source=your_stories_page-------------------------------------" rel="noopener">。</a></p></blockquote><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="967a" class="no ml iu nk b gz np nq l nr ns">git clone <a class="ae kz" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:yourusername/repositoryname.git</span></pre><p id="55f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您的系统上已经安装了docker，请输入:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="cde8" class="no ml iu nk b gz np nq l nr ns">make build</span></pre><p id="34b1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并看到您的映像构建和容器启动。</p><p id="cd21" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">干得好！我现在称之为“部署握手”的第一部分已经结束。现在，我们只想通过外部服务来自动化这个过程。</strong></p><h1 id="9a7f" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用GitHub动作自动化部署</h1><p id="4d3f" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">现在，我们希望发生以下情况:</p><ul class=""><li id="10b1" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">一旦我们在本地机器上对我们的代码做了新的更改，我们就提交并把它推送到我们的在线Github库。</li><li id="dba3" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">这个动作应该执行一个工作流来登录到我们的VPS，把最新的代码放到VPS上，从新代码构建一个新的Docker映像，并为它启动一个容器。</li><li id="798c" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">作为一个清理过程，它还去除了旧的悬挂图像。</li></ul><p id="02c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，我们使用了<strong class="lc iv"> GitHub动作</strong>。</p><p id="03da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们项目的根目录下，让我们创建一个新文件，如下所示:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="3922" class="no ml iu nk b gz np nq l nr ns">mkdir -p .github/workflows<br/>touch .github/workflows/main.yml</span></pre><p id="0ea6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在文件中，首先我们要将工作流命名为:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="6621" class="no ml iu nk b gz np nq l nr ns">name: Bot CI-CD</span></pre><p id="77aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们要创建工作流<strong class="lc iv"> <em class="nh">触发器</em> </strong>。</p><p id="4844" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">触发器定义了这些流程何时执行。还记得我们希望他们将代码推送到主分支吗？我们这么说吧:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="4bb4" class="no ml iu nk b gz np nq l nr ns">on:<br/>    # Triggers the workflow on push or pull request events but only for the main branch<br/>    <br/>    push:</span><span id="8dfd" class="no ml iu nk b gz oc nq l nr ns">    branches: [main]</span><span id="e0e7" class="no ml iu nk b gz oc nq l nr ns">    pull_request:</span><span id="da98" class="no ml iu nk b gz oc nq l nr ns">    branches: [main]</span><span id="a6ab" class="no ml iu nk b gz oc nq l nr ns">    # Run this workflow manually from the Actions tab on Repo homepage<br/>    workflow_dispatch:</span></pre><p id="550a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">顺便说一下，我们可能还想从存储库主页上的<strong class="lc iv"> Actions </strong>选项卡中手动运行这个工作流。<code class="fe nt nu nv nk b"><strong class="lc iv">workflow_dispatch</strong></code>触发器对此有所帮助。</p><p id="b3d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们要指定一个部署“作业”。为此，我们首先需要在GitHub存储库中定义一些环境变量。</p><p id="4171" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">转到<code class="fe nt nu nv nk b"><strong class="lc iv">Settings -&gt; Secrets -&gt; Actions</strong></code>并添加新的存储库密码。</p><p id="64d1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">逐一补充以下秘密:</p><ul class=""><li id="2b85" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">VPS_SSH_HOST —这是您的服务器的主机IP地址。</li><li id="87f8" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">VPS_SSH_USERNAME —这是您的user@ipaddress登录的用户名。</li><li id="a144" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">VPS_SSH_SECRET —这是您在服务器上为GitHub访问设置的私有SSH密钥。</li><li id="cfa8" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">VPS_SSH_PORT —这是SSH访问的端口号。通常是端口22。</li><li id="6bf5" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">SSH_PASSPHRASE —这是在创建SSH密钥期间提供的密码。</li><li id="b30f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">PROJECT_PATH —这是项目根目录的完整项目路径。例如，<code class="fe nt nu nv nk b"><strong class="lc iv">/home/username/path/to/your/projectrootdirectory</strong></code></li></ul><p id="8c02" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，我们终于可以在yaml文件中指定部署作业了:</p><pre class="kk kl km kn gu nj nk nl nm aw nn bi"><span id="ea80" class="no ml iu nk b gz np nq l nr ns">jobs:<br/>    deploy:<br/>        runs-on: ubuntu-latest<br/>        steps:<br/>            - name: Deploy to VPS<br/>              uses: appleboy/ssh-action@master<br/>              with:<br/>                  # VPS IP<br/>                  host: ${{ secrets.VPS_SSH_HOST }}<br/>                  <br/>                  # VPS username<br/>                  username: ${{ secrets.VPS_SSH_USERNAME }}<br/>                  <br/>                  # SSH key (copy it from your local machine)<br/>                  key: ${{ secrets.VPS_SSH_SECRET }}</span><span id="906d" class="no ml iu nk b gz oc nq l nr ns">                  # SSH port<br/>                  port: ${{ secrets.VPS_SSH_PORT }}</span><span id="52d8" class="no ml iu nk b gz oc nq l nr ns">                  # passphrase<br/>                  passphrase: ${{ secrets.SSH_PASSPHRASE }}</span><span id="68ec" class="no ml iu nk b gz oc nq l nr ns">                  script: |</span><span id="53a0" class="no ml iu nk b gz oc nq l nr ns">                      cd ${{ secrets.PROJECT_PATH }}</span><span id="8363" class="no ml iu nk b gz oc nq l nr ns">                      git pull origin main</span><span id="4902" class="no ml iu nk b gz oc nq l nr ns">                      make down</span><span id="ad4b" class="no ml iu nk b gz oc nq l nr ns">                      make build</span><span id="94eb" class="no ml iu nk b gz oc nq l nr ns">                      echo "Deleting old image(s)..."</span><span id="de3b" class="no ml iu nk b gz oc nq l nr ns">                      docker image prune -a -f</span></pre><p id="f0f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用<code class="fe nt nu nv nk b"><strong class="lc iv">uses: appleboy/ssh-action@master</strong></code> <strong class="lc iv"> </strong>来指定SSH的登录动作。这是GitHub为了方便<a class="ae kz" href="https://github.com/appleboy/ssh-action" rel="noopener ugc nofollow" target="_blank">从这里</a>采取的一个自定义动作。</p><p id="eb81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好了，我们准备好行动了！现在，推动您的存储库来看看魔法吧！</p></div><div class="ab cl og oh hy oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="in io ip iq ir"><h1 id="1967" class="mk ml iu bd mm mn on mp mq mr oo mt mu ka op kb mw kd oq ke my kg or kh na nb bi translated">结论</h1><p id="4bcf" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">好了，这就是我们如何通过使用Docker和GitHub操作创建CI/CD管道来自动化我们项目的集成和部署。</p><p id="48db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想看一看<a class="ae kz" href="https://github.com/yashprakash13/Pollsome" rel="noopener ugc nofollow" target="_blank">库</a>，就在这里。</p><p id="153c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在掌握了这个简单的工作流程之后，您还可以尝试一些事情:创建多个docker容器，并使用Docker Swarm通过CI/CD acton管理它们。在中型或大型项目中，为容器设置自动日志以进行持续监控也是一项很好的任务。</p><h2 id="b14a" class="no ml iu bd mm os ot dn mq ou ov dp mu lj ow ox mw ln oy oz my lr pa pb na pc bi translated"><a class="ae kz" href="https://ipom.medium.com/membership" rel="noopener">别忘了订阅阅读更多来自我。</a></h2></div><div class="ab cl og oh hy oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="in io ip iq ir"><p id="5026" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另外几个故事引起了你的兴趣:</p><div class="pd pe gq gs pf pg"><a href="https://betterprogramming.pub/the-easy-python-auto-code-formatting-guide-e8300c82797b" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fp"><div class="pi ab pj cl cj pk"><h2 class="bd iv gz z fq pl fs ft pm fv fx it bi translated">简单的Python自动代码格式化指南</h2><div class="pn l"><h3 class="bd b gz z fq pl fs ft pm fv fx dk translated">只需设置一次，在提交时编写并自动格式化您的代码——使用这些工具没有任何麻烦。</h3></div><div class="po l"><p class="bd b dl z fq pl fs ft pm fv fx dk translated">better编程. pub</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu kt pg"/></div></div></a></div><div class="pd pe gq gs pf pg"><a rel="noopener follow" target="_blank" href="/26-github-repositories-to-inspire-your-next-data-science-project-3023c24f4c3c"><div class="ph ab fp"><div class="pi ab pj cl cj pk"><h2 class="bd iv gz z fq pl fs ft pm fv fx it bi translated">26个GitHub存储库，激发您的下一个数据科学项目</h2><div class="pn l"><h3 class="bd b gz z fq pl fs ft pm fv fx dk translated">用这个有趣的代码列表开始新的一年，包括库、路线图和项目书签</h3></div><div class="po l"><p class="bd b dl z fq pl fs ft pm fv fx dk translated">towardsdatascience.com</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu kt pg"/></div></div></a></div><div class="pd pe gq gs pf pg"><a href="https://medium.com/geekculture/21-vscode-keyboard-shortcuts-you-should-know-1b96a65e9428" rel="noopener follow" target="_blank"><div class="ph ab fp"><div class="pi ab pj cl cj pk"><h2 class="bd iv gz z fq pl fs ft pm fv fx it bi translated">你应该知道的21个VSCode键盘快捷键</h2><div class="pn l"><h3 class="bd b gz z fq pl fs ft pm fv fx dk translated">使用您最喜欢的代码编辑器提高编码效率</h3></div><div class="po l"><p class="bd b dl z fq pl fs ft pm fv fx dk translated">medium.com</p></div></div><div class="pp l"><div class="pw l pr ps pt pp pu kt pg"/></div></div></a></div></div></div>    
</body>
</html>