<html>
<head>
<title>Map, Filter, Reduce - Higher-Order Functions for Functional Data Pipeline Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">映射、过滤、归约-用于功能数据管道设计的高阶函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/map-filter-reduce-higher-order-functions-for-functional-data-pipeline-design-929935222475#2022-02-07">https://towardsdatascience.com/map-filter-reduce-higher-order-functions-for-functional-data-pipeline-design-929935222475#2022-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1a45" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入探讨高阶函数，以及如何使用它们为函数式数据管道设计数据转换</h2></div><h1 id="45b4" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">概述</h1><p id="2627" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我上一篇关于“控制流”的<a class="ae lt" rel="noopener" target="_blank" href="/functional-control-flow-writing-programs-without-loops-ce07e6137bba">函数式编程特性的文章中，我提供了函数组合的概述，并讨论了高阶函数和递归作为“函数迭代”形式的使用。</a></p><p id="c418" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在本帖中，我们将深入探讨高阶函数，以及它们如何用于设计函数式数据管道。</p><p id="7095" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在此之前，我们先来看看典型的数据管道是什么样子的。</p><h1 id="979a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">数据处理和数据管道设计模式</h1><p id="7c3d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据处理的经典方法是编写一个使用<strong class="kz ir">数据管道</strong>设计模式的程序。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/777b8cf0ee064091db8cf596f3e9b17b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K9fJM2t9dH8vn-eh.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">数据管道设计模式(图片来自作者)</p></figure><p id="e4b8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在典型的数据管道中，我们从源中读取数据，以某种期望的方式转换数据，并收集输出作为新数据。这就是通常所说的“提取、转换、加载”(ETL)过程。</p><ul class=""><li id="175d" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated"><strong class="kz ir">提取</strong>:在数据提取阶段，从源系统中提取数据并验证其正确性。</li><li id="a2e0" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated"><strong class="kz ir"> Transform </strong>:在数据转换阶段，一系列的函数被应用到提取的数据，以便为装载到目标数据存储做准备。</li><li id="a2b3" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated"><strong class="kz ir"> Load </strong>:在数据加载阶段，数据被加载到目标数据存储中——它可以是平面文件(比如 CSV 或 Parquet)或数据仓库。</li></ul><h1 id="513f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">用于数据转换的高阶函数</h1><p id="74a7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是 S3 桶中从数据库源到平面文件的典型 ETL 过程的简化示意图:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi nd"><img src="../Images/811296034fe11af17cc875b635e90692.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pdwrl5CKuKfI4SG_.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">ETL 过程的草图(图片由作者提供)</p></figure><p id="bbd0" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">数据提取和数据加载阶段取决于程序外部的源数据和目标数据存储的状态，而数据转换阶段则取决于程序本身内部的输入数据和应用于数据的函数。因此，数据转换可以自然地表达为由一系列函数组成的函数操作，也称为<strong class="kz ir">函数组合</strong>。</p><p id="911a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">对于支持函数作为一级对象的编程语言，函数组合可以用高阶函数的形式来表示。虽然我们可以编写自己的高阶函数，但有一些有用的内置高阶函数通常用于数据转换:</p><ul class=""><li id="3d15" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated"><code class="fe ne nf ng nh b">map</code></li><li id="40b6" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated"><code class="fe ne nf ng nh b">filter</code></li><li id="c5f6" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated"><code class="fe ne nf ng nh b">reduce</code></li></ul><p id="87fd" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">本文的重点是探索这些内置的高阶函数，并讨论如何将它们用于设计功能性数据管道。</p><h1 id="0e65" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><code class="fe ne nf ng nh b">map</code></h1><p id="aeae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe ne nf ng nh b">map</code>函数接受一个函数作为输入，将该函数应用于值集合中的每个元素，并返回一个新的函数输出值集合。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/d544e244df614ea41e90ca047c3d6de5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tfru4Th-C_qTxSgx.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated"><code class="fe ne nf ng nh b">map</code>功能示意图(图片由作者提供)</p></figure><p id="a408" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">例如，当我们用一个<code class="fe ne nf ng nh b">addSmile</code>操作映射一个形状集合时，我们通过将操作应用于形状来“映射”集合中的每个形状。使用<code class="fe ne nf ng nh b">addSmile</code>操作映射形状的输出被合并到一个新的形状集合中，并在输入形状中添加了一个微笑。</p><p id="3009" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">关于 Python 和 Scala 中的<code class="fe ne nf ng nh b">map</code>实现的详细讨论可以在<a class="ae lt" rel="noopener" target="_blank" href="/functional-control-flow-writing-programs-without-loops-ce07e6137bba">我之前的帖子</a>中找到。</p><h1 id="ea6c" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><code class="fe ne nf ng nh b">filter</code></h1><p id="c25c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe ne nf ng nh b">filter</code>函数接受返回布尔值(也称为<em class="ni">谓词</em>)的函数作为输入，将该函数应用于值集合中的每个元素，并将从该函数返回<code class="fe ne nf ng nh b">true</code>的元素作为新集合返回。</p><p id="c64b" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">谓词应该接受一个与集合中的元素类型相同的参数，用该元素评估结果，并返回<code class="fe ne nf ng nh b">true</code>到<strong class="kz ir">将元素</strong>保留在新集合中或<code class="fe ne nf ng nh b">false</code>将其过滤掉。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/e9355d0de08f2fb5162d842b6fe79eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w4pkb-ap6JD5wwDH.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated"><code class="fe ne nf ng nh b">filter</code>功能示意图(图片由作者提供)</p></figure><p id="71e5" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">例如，当我们将<code class="fe ne nf ng nh b">hasFiniteEdges</code>条件应用于形状集合时，我们根据集合中的每个形状是否满足<code class="fe ne nf ng nh b">hasFiniteEdges</code>条件来“过滤”它。从<code class="fe ne nf ng nh b">hasFiniteEdges</code>函数返回<code class="fe ne nf ng nh b">true</code>的形状被合并到一个新的形状集合中，不满足条件的形状从集合中被过滤掉。</p><p id="d01f" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">当我们查看 Python 内置函数<code class="fe ne nf ng nh b">filter</code>的文档时，会发现<code class="fe ne nf ng nh b">filter</code>函数接受一个谓词函数和一个 iterable 作为输入参数，并根据谓词函数返回 true [1]的 iterable 的元素构造一个迭代器。</p><p id="086e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在 Scala 中，包<code class="fe ne nf ng nh b">scala.collections</code>中的每个集合类及其子集都包含由 ScalaDoc [2]上的以下函数签名定义的<code class="fe ne nf ng nh b">filter</code>方法:</p><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="4332" class="nn kg iq nh b gy no np l nq nr">def filter(p: (A) =&gt; Boolean): Iterable[A]    // for collection classes<br/>def filter(p: (A) =&gt; Boolean): Iterator[A]    // for iterators that access elements of a collection</span></pre><p id="7561" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">函数签名的意思是，<code class="fe ne nf ng nh b">filter</code>接受一个谓词输入参数<code class="fe ne nf ng nh b">p</code>，该参数将类型<code class="fe ne nf ng nh b">A</code>的一般输入转换为布尔值，并返回一个新的迭代器，该迭代器由满足谓词<code class="fe ne nf ng nh b">p</code>的可迭代集合(类型<code class="fe ne nf ng nh b">A</code>)的所有元素组成。</p><p id="0931" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">为了使用<strong class="kz ir">函数方法</strong>从现有的数字集合中创建一个新的偶数集合，可以使用<code class="fe ne nf ng nh b">filter</code>函数通过对每个元素应用一个偶数谓词并将满足偶数谓词条件的元素收集到一个新的集合中来过滤掉集合中的奇数。</p><ul class=""><li id="afb7" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated">在 Python 中:</li></ul><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="f362" class="nn kg iq nh b gy no np l nq nr">def isEven(x):<br/>    return x % 2 == 0</span><span id="068f" class="nn kg iq nh b gy ns np l nq nr">def main(args):<br/>    collection = [1,2,3,4,5]<br/>    evenNums = list(filter(isEven, collection))<br/>    print(evenNums)</span></pre><ul class=""><li id="ac97" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated">在 Scala 中:</li></ul><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="4b60" class="nn kg iq nh b gy no np l nq nr">object FilterEven {</span><span id="c6db" class="nn kg iq nh b gy ns np l nq nr">  def isEven(x: Int): Int = {<br/>    x % 2 == 0<br/>  }</span><span id="6e5f" class="nn kg iq nh b gy ns np l nq nr">  def main(args: Array[String]) {<br/>    val collection = List[1,2,3,4,5]<br/>    val evenNums = collection.filter(isEven)<br/>    println(evenNums)<br/>  }</span><span id="0006" class="nn kg iq nh b gy ns np l nq nr">}</span></pre><p id="615e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在这两个实现中，<code class="fe ne nf ng nh b">filter</code>函数接受一个应用于值集合中每个元素的输入谓词，并返回一个包含满足该谓词的元素的新集合。</p><h1 id="feda" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><code class="fe ne nf ng nh b">reduce</code></h1><p id="e014" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe ne nf ng nh b">reduce</code>函数接受一个<em class="ni">组合函数</em>(通常为二元运算)作为输入，将该函数应用于值集合中的连续元素，并返回一个累积结果。</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/8cd2920bc862e422c015c925a5b38ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4NIY8SE3nlIK_bxD.png"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated"><code class="fe ne nf ng nh b">reduce</code>功能示意图(图片由作者提供)</p></figure><p id="cd78" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">例如，当我们将<code class="fe ne nf ng nh b">composeAll</code>操作应用于形状集合时，我们通过使用<code class="fe ne nf ng nh b">composeAll</code>操作将<strong class="kz ir">部分结果</strong>和迭代中的形状折叠成单个结果，并将合成结果用作下一次迭代的部分结果，从而将集合中的形状“缩减”成单个结果。在迭代结束时，使用<code class="fe ne nf ng nh b">composeAll</code>操作减少形状的输出作为单个结果返回(形状的组合)。</p><p id="9813" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">当我们在<code class="fe ne nf ng nh b">functools</code>库中查看 Python <code class="fe ne nf ng nh b">reduce</code>函数的文档时，会发现<code class="fe ne nf ng nh b">reduce</code>函数接受一个带有两个参数和一个 iterable(带有一个可选的初始值，可以在计算中放在 iterable 的项之前)的函数作为输入参数，并从左到右【3】将函数累积应用于 iterable <strong class="kz ir">的项。</strong></p><p id="7396" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在 Scala 中，包<code class="fe ne nf ng nh b">scala.collections</code>中的每个集合类及其子集都包含由 ScalaDoc [2]上的以下函数签名定义的<code class="fe ne nf ng nh b">reduce</code>方法:</p><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="d7ca" class="nn kg iq nh b gy no np l nq nr">def reduce(B &gt;: A)(op: (B, B) =&gt; B): B</span></pre><p id="07fd" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">函数签名的意思是，<code class="fe ne nf ng nh b">reduce</code>接受一个结果类型为<code class="fe ne nf ng nh b">B</code>(类型为<code class="fe ne nf ng nh b">A</code>的超类型)的二元运算符<code class="fe ne nf ng nh b">op</code>，该运算符将集合中的两个元素转换为类型为<code class="fe ne nf ng nh b">B</code>的值，并返回在集合中所有元素(类型为<code class="fe ne nf ng nh b">A</code>)之间应用该运算符的结果。二元运算符<code class="fe ne nf ng nh b">op</code>需要返回存储在集合中的相同数据类型<code class="fe ne nf ng nh b">A</code>或类型<code class="fe ne nf ng nh b">B</code>的超类型，以便<code class="fe ne nf ng nh b">reduce</code>方法可以对操作的结果和集合中正在应用操作的下一个元素执行后续操作。</p><p id="ea57" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">仔细观察<code class="fe ne nf ng nh b">reduce</code>方法的 ScalaDoc，会发现以下操作条件:</p><ol class=""><li id="0f3f" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls nt mv mw mx bi translated">二元运算符必须是<strong class="kz ir">关联的</strong>。</li><li id="d1ab" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls nt mv mw mx bi translated">对元素执行操作的顺序可能是<strong class="kz ir">不确定的</strong>。</li></ol><p id="7e0b" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">二元运算符的关联属性是一个必要条件，以确保在归约<strong class="kz ir">过程中执行运算的顺序不会改变不同运行的结果</strong>——只要被运算元素的顺序不变。</p><p id="cf37" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">虽然关联属性对于从归约函数返回确定性结果是必要的(引用透明的必要条件)，但它不是充分条件，因为在<em class="ni">非交换二元运算符</em>的情况下，如减法和除法，运算的顺序会产生不同的结果。</p><p id="2d66" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">如果我们想要<em class="ni">指定对集合的元素执行操作的顺序</em>该怎么办？</p><p id="58f8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在 Scala 中，我们在集合类中有<code class="fe ne nf ng nh b">reduceLeft</code>和<code class="fe ne nf ng nh b">reduceRight</code>方法，它们分别以从左到右和从右到左的顺序对集合中的所有元素累积应用二元运算符。<code class="fe ne nf ng nh b">reduceLeft</code>和<code class="fe ne nf ng nh b">reduceRight</code>方法由 ScalaDoc [2]上的以下函数签名定义:</p><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="2c6b" class="nn kg iq nh b gy no np l nq nr">def reduceLeft[B &gt;: A](op: (B, A) =&gt; B): B<br/>def reduceRight[B &gt;: A](op: (A, B) =&gt; B): B</span></pre><p id="1b38" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">与<code class="fe ne nf ng nh b">reduce</code>的函数签名相比，<code class="fe ne nf ng nh b">reduceLeft</code>和<code class="fe ne nf ng nh b">reduceRight</code>方法的函数签名的主要区别在于:</p><ol class=""><li id="716e" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls nt mv mw mx bi translated">结果类型为<code class="fe ne nf ng nh b">B</code>(类型为<code class="fe ne nf ng nh b">A</code>的超类型)的二元运算符<code class="fe ne nf ng nh b">op</code>获取部分结果(类型为<code class="fe ne nf ng nh b">B</code>)和集合中的下一个元素<strong class="kz ir">(类型为</strong> <code class="fe ne nf ng nh b"><strong class="kz ir">A</strong></code> <strong class="kz ir"> ) </strong>，并将它们简化为类型为<code class="fe ne nf ng nh b">B</code>的值。</li><li id="9883" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls nt mv mw mx bi translated">二元运算中部分结果和集合中元素的顺序表示运算符沿着集合应用的<strong class="kz ir">方向。</strong></li></ol><p id="f455" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">为了使用<strong class="kz ir">函数方法</strong>获得数字集合的累积和，可使用<code class="fe ne nf ng nh b">reduce</code>函数，通过在集合的连续数字之间应用加法运算符并执行运算，将数字集合缩减为单个值。</p><ul class=""><li id="4702" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated">在 Python 中:</li></ul><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="a93c" class="nn kg iq nh b gy no np l nq nr">def main(args):<br/>    from functools import reduce<br/>    collection = [1,3,5,2,4]<br/>    totalSum = reduce(lambda x,y: x + y, collection)<br/>    print(totalSum)</span></pre><ul class=""><li id="39ae" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated">在 Scala 中:</li></ul><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="6f77" class="nn kg iq nh b gy no np l nq nr">object SumNumbers {</span><span id="c327" class="nn kg iq nh b gy ns np l nq nr">  def main(args: Array[String]) {<br/>    val collection = List[1,3,5,2,4]<br/>    val totalSum = collection.reduce((x, y) =&gt; x + y)            <br/>    println(totalSum)<br/>  }</span><span id="c5f3" class="nn kg iq nh b gy ns np l nq nr">}<!-- --> </span></pre><p id="d55c" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在这两个实现中，<code class="fe ne nf ng nh b">reduce</code>函数接受一个二元运算符，该运算符应用于值集合中的连续元素之间，并返回一个结果。</p><p id="e821" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">使用二进制加法运算符对数字集合进行从左到右的归约(Scala 中的<code class="fe ne nf ng nh b">reduceLeft</code>方法)的计算方式如下:</p><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="2d4c" class="nn kg iq nh b gy no np l nq nr">[1,3,5,2,4].reduceLeft((x, y) =&gt; x + y) // initialize var acc = null<br/>(((1 + 3) + 5) + 2) + 4 // take first value, acc = 1<br/>((4 + 5) + 2) + 4 // acc = 1 + 3 = 5<br/>(9 + 2) + 4 // acc = 4 + 5 = 9<br/>11 + 4 // acc = 9 + 2 = 11<br/>15 // acc = 11 + 4 = 15 returned upon end of collection</span></pre><p id="a71f" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">类似地，从右到左归约(Scala 中的<code class="fe ne nf ng nh b">reduceRight</code>方法)按以下方式计算:</p><pre class="ma mb mc md gt nj nh nk nl aw nm bi"><span id="2098" class="nn kg iq nh b gy no np l nq nr">[1,3,5,2,4].reduceRight((x, y) =&gt; x + y)// initialize var acc = null<br/>1 + (3 + (5 + (2 + 4))) // take first value from right, acc = 4<br/>1 + (3 + (5 + 6)) // acc = 4 + 2 = 6<br/>1 + (3 + 11))// acc = 6 + 5 = 11<br/>1 + 14 // acc = 11 + 3 = 14<br/>15 // acc = 14 + 1 = 15 returned upon end of collection</span></pre><p id="3432" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">由于加法运算符是<em class="ni">关联和交换的</em>，运算符应用的顺序不会影响结果，因此<code class="fe ne nf ng nh b">reduce</code>方法可以安全地用于 Scala 实现中。</p><p id="ed15" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">注意<strong class="kz ir">递归模式</strong>如何在归约过程中计算加法运算？<code class="fe ne nf ng nh b">reduce</code>函数是函数式编程中<code class="fe ne nf ng nh b">fold</code>的一个特例，指的是一族高阶函数，将递归数据结构中的元素递归组合成一个结果。</p><p id="0665" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">内置的收集方法<code class="fe ne nf ng nh b">sum</code>、<code class="fe ne nf ng nh b">product</code>、<code class="fe ne nf ng nh b">min</code>和<code class="fe ne nf ng nh b">max</code>是基于<code class="fe ne nf ng nh b">reduce</code>函数[4]及其对应的二元运算符定义的:</p><ul class=""><li id="27af" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls mu mv mw mx bi translated">总和:<code class="fe ne nf ng nh b">+</code></li><li id="1a70" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">产品:<code class="fe ne nf ng nh b">*</code></li><li id="fd4d" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">最小:<code class="fe ne nf ng nh b">math.Ordering.min</code></li><li id="caf3" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls mu mv mw mx bi translated">麦克斯:<code class="fe ne nf ng nh b">math.Ordering.max</code></li></ul><p id="e191" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">虽然<code class="fe ne nf ng nh b">reduce</code>函数有助于使用关联二元运算符将值集合缩减为单个值，但使用这些内置集合方法代替<code class="fe ne nf ng nh b">reduce</code>可以提高可读性，而无需为数据管道设计中的预期用例重新发明轮子。</p><h1 id="198a" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">把它们放在一起</h1><p id="5a3a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">总而言之，内置高阶函数在构建数据管道内的数据转换序列时非常有用:</p><ol class=""><li id="8378" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls nt mv mw mx bi translated"><code class="fe ne nf ng nh b">map</code>用于将函数应用于集合中的所有元素</li><li id="970e" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls nt mv mw mx bi translated"><code class="fe ne nf ng nh b">filter</code>用于根据布尔条件选择集合中的元素</li><li id="dd40" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls nt mv mw mx bi translated"><code class="fe ne nf ng nh b">reduce</code>通过在连续元素之间使用一个关联运算符，将元素集合简化为一个结果</li></ol><p id="0770" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">当<code class="fe ne nf ng nh b">map</code>和<code class="fe ne nf ng nh b">filter</code>返回一个可以用后续高阶函数处理的新集合时，<code class="fe ne nf ng nh b">reduce</code>返回一个累积值。因此，在设计具有功能组合的功能数据管道时，通常将<code class="fe ne nf ng nh b">reduce</code>方法及其衍生方法作为最终转换步骤来实施。</p><h1 id="f833" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">下一步是什么</h1><p id="213c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本帖中，我们将了解:</p><ol class=""><li id="110e" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls nt mv mw mx bi translated">数据管道设计模式</li><li id="393f" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls nt mv mw mx bi translated">用于数据转换的高阶函数:映射、过滤、归约</li></ol><p id="40e8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在我们探索高阶函数的 map-filter-reduce 三元组时，我们简要地提到了与函数式编程相关的两个有趣的概念:</p><ol class=""><li id="33b6" class="mp mq iq kz b la lu ld lv lg mr lk ms lo mt ls nt mv mw mx bi translated"><code class="fe ne nf ng nh b">reduce</code>作为<code class="fe ne nf ng nh b">fold</code>的特例</li><li id="af44" class="mp mq iq kz b la my ld mz lg na lk nb lo nc ls nt mv mw mx bi translated">集合类作为带有内置方法的数据容器</li></ol><p id="825d" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在本系列接下来的几篇文章中，我将详细阐述这些概念及其在设计函数式数据管道中的应用。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="7fd5" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">想要更多关于我作为数据专业人员的学习历程的幕后文章吗？查看我的网站:https://ongchinhwee.me ！</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="3167" class="kf kg iq bd kh ki ob kk kl km oc ko kp jw od jx kr jz oe ka kt kc of kd kv kw bi translated">参考</h1><p id="e346" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">[1] <a class="ae lt" href="https://docs.python.org/3/library/functions.html#filter" rel="noopener ugc nofollow" target="_blank">内置函数— Python 3.10.2 文档</a></p><p id="469d" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">[2] <a class="ae lt" href="https://www.scala-lang.org/api/2.13.8/scala/collection/Iterable.html" rel="noopener ugc nofollow" target="_blank"> Scala 标准库 2 . 13 . 8—Scala . collections . iterable</a></p><p id="d026" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">[3] <a class="ae lt" href="https://docs.python.org/3/library/functools.html#functools.reduce" rel="noopener ugc nofollow" target="_blank"> functools —可调用对象上的高阶函数和操作— Python 3.10.2 文档</a></p><p id="c6b3" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">[4]<a class="ae lt" href="https://github.com/scala/scala/blob/v2.13.8/src/library/scala/collection/IterableOnce.scala" rel="noopener ugc nofollow" target="_blank">trait iterable once ops—Scala/iterable once . Scala at v 2 . 13 . 8</a></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="c7c9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><em class="ni">原载于 2022 年 2 月 5 日</em><a class="ae lt" href="https://ongchinhwee.me/learning-scala-functional-programming-features-control-flow/" rel="noopener ugc nofollow" target="_blank"><em class="ni">https://ongchinhwee . me</em></a><em class="ni">。</em></p></div></div>    
</body>
</html>