<html>
<head>
<title>A Guide To The Apply-Family In R - Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R 系列应用指南-第 1 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-guide-to-the-apply-family-in-r-part-1-a4073c0dad3e#2022-03-25">https://towardsdatascience.com/a-guide-to-the-apply-family-in-r-part-1-a4073c0dad3e#2022-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eca7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">lapply、sapply、apply 和 tapply 函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4a41cde7fdcbac71ed1de81779368cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IpVU52m0DysODw2i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克·科诺诺夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">R 中的 apply-family 是 R 中的一个内置包，它允许您在探索和分析数据时避免循环。我发现 apply-functions 对于在 r 中处理数据非常有用。它们允许你编写简短有效的代码。起初，我对不同的应用功能有点困惑，不知道何时以及如何使用哪一个。使用哪一种取决于数据的结构，在某种程度上，还取决于您希望输出的结构。在本指南第 1 部分中，我将详细介绍每个应用函数，并展示它们是如何工作的，以帮助您避免任何混淆。<a class="ae ky" href="https://medium.com/@andreagustafsen/a-guide-to-the-apply-family-in-r-part-2-227da1c1bc92" rel="noopener">本指南的第 2 部分</a>展示了一些应用功能的实际应用。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@andreagustafsen/a-guide-to-the-apply-family-in-r-part-2-227da1c1bc92" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">R 中的应用系列指南—第 2 部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用应用函数的实例。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="9819" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南还以 jupyter 笔记本和 pdf 文件的形式出现在本<a class="ae ky" href="https://github.com/TalkingDataScience/apply-family" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="018c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南中涵盖的应用功能有:</p><ul class=""><li id="e800" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu"> lapply() </strong>:循环遍历一个列表，并对该列表的每个元素应用一个函数(lapply 返回一个列表)。</li><li id="0e0d" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu"> sapply() </strong>:简化结果的 lapply 版本(如果可能的话，sapply 返回一个向量或矩阵)。</li><li id="6be0" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">在数组的页边(行或列)上应用</strong>:()循环，这对于获取矩阵或高维数组的摘要很有用。</li><li id="2745" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu"> tapply() </strong>:“表格应用”的简称。对向量的子集应用函数。</li><li id="e796" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">侧栏:匿名函数</strong>:在*apply 函数中使用的函数</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5729" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">拉普利()</h1><p id="b92e" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated"><code class="fe of og oh oi b">lapply()</code>需要三个参数:</p><ul class=""><li id="dd39" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><code class="fe of og oh oi b">x</code>一个列表</li><li id="5a8d" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe of og oh oi b">FUN</code>一个函数</li><li id="b689" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><code class="fe of og oh oi b">...</code>可用于向函数传递参数</li></ul><p id="da35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe of og oh oi b">x</code>不是一个列表，它将被强制为一个列表，并且<code class="fe of og oh oi b">lapply</code>总是返回一个列表。</p><p id="c7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例:</strong>循环遍历一个包含三个元素的列表，<em class="oj"> a </em>，<em class="oj"> b </em>和<em class="oj"> c，</em>并取每个元素的平均值。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="9237" class="oo nj it oi b gy op oq l or os"><em class="oj"># Create a list of three vectors</em><br/>my_list <strong class="oi iu">&lt;-</strong> (list(a <strong class="oi iu">=</strong> 1<strong class="oi iu">:</strong>100, b <strong class="oi iu">=</strong> rnorm(100, 10, 4), c <strong class="oi iu">=</strong> rnorm(100, 20, 5)))</span><span id="ad87" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="f167" class="oo nj it oi b gy ot oq l or os">$a<br/> [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19<br/>[20] 20<br/><br/>$b<br/> [1] 11.126883  9.486250  4.888522 17.979359 10.488388<br/> [6] 11.386035  9.533153 11.840724  6.894381  9.320159<br/>[11]  8.011970  5.168468 11.168965  5.949377  7.602794<br/>[16]  3.415012  9.000652  8.590869 11.081774  5.504183<br/><br/>$c<br/> [1] 27.71358 22.78353 21.27341 14.18033 19.44619 21.22942<br/> [7] 19.80918 24.49109 24.79348 20.92665 22.03669 23.37730<br/>[13] 28.31326 11.24070 17.55119 22.98123 18.12479 18.27029<br/>[19] 25.84009 13.60632</span></pre><p id="b9ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用<code class="fe of og oh oi b">lapply()</code>来寻找每个列表的平均值。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="a1ee" class="oo nj it oi b gy op oq l or os"><em class="oj"># Take the mean of each vector</em><br/>lapply(my_list, mean)</span><span id="6ada" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="7d90" class="oo nj it oi b gy ot oq l or os">$a<br/>[1] 50.5<br/><br/>$b<br/>[1] 10.8271<br/><br/>$c<br/>[1] 20.0546</span></pre><p id="3a9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例:</strong> R 将在向量<em class="oj"> x </em>上循环，并为每次循环生成 x 个随机正态变量。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="4f6c" class="oo nj it oi b gy op oq l or os"><em class="oj"># Create vector (1, 2, 3, 4, 5)</em><br/>x <strong class="oi iu">&lt;-</strong> 1<strong class="oi iu">:</strong>5<br/><br/><em class="oj"># Generate a list with five elements, each containing x number of random normal variables</em><br/>lapply(x, rnorm)</span><span id="3bee" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="ee8f" class="oo nj it oi b gy ot oq l or os">[[1]]<br/>[1] -0.392326<br/><br/>[[2]]<br/>[1] -0.4011685  0.2915179<br/><br/>[[3]]<br/>[1] -1.0637220 -0.1090642  0.1463136<br/><br/>[[4]]<br/>[1] -0.91545274  1.66578574  0.48180671 -0.08540264<br/><br/>[[5]]<br/>[1]  1.0197346  1.2672367 -0.2227637  0.7901403  0.4313318</span></pre><p id="58c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子续:</strong>我们可以通过将函数的参数传递给<code class="fe of og oh oi b">...</code>参数来指定函数的参数。因此，如果我们想要指定我们上面生成的随机数的 man 和标准差，我们可以简单地将平均值和 sd 传递给<code class="fe of og oh oi b">...</code>参数。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="b0e9" class="oo nj it oi b gy op oq l or os"><em class="oj"># Create vector (1, 2, 3, 4, 5)<br/></em>x <strong class="oi iu">&lt;-</strong> 1<strong class="oi iu">:</strong>5</span><span id="347f" class="oo nj it oi b gy ot oq l or os"><em class="oj"># Generate numbers from the normal distribution with mean 10 and sd 2</em><br/>lapply(x, rnorm, mean <strong class="oi iu">=</strong> 10, sd <strong class="oi iu">=</strong> 2) <em class="oj">#default is mean = 0 and sd = 1</em></span><span id="b0d5" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="897c" class="oo nj it oi b gy ot oq l or os">[[1]]<br/>[1] 9.978319<br/><br/>[[2]]<br/>[1]  7.501266 12.984743<br/><br/>[[3]]<br/>[1] 10.87127 10.20457 10.63069<br/><br/>[[4]]<br/>[1] 8.652868 7.390537 9.390650 7.895302<br/><br/>[[5]]<br/>[1] 10.655694 12.378678  7.262178 13.547734  6.125808</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="20f0" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">侧栏:匿名函数</h1><p id="8b0b" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated"><code class="fe of og oh oi b">*apply</code>家族函数大量使用了匿名函数，所以在我们进入下一个应用函数之前，我想为那些不熟悉的人解释一下匿名函数。</p><p id="4c0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想应用一个在 R 中不存在的函数，我们需要直接在 apply 函数中编写自己的函数。</p><p id="8f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例:</strong>假设我们有两个矩阵，我们想要提取特定的行或列，我们可以通过传递匿名函数来实现。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="37e9" class="oo nj it oi b gy op oq l or os"><em class="oj"># Create a list of two matrices</em><br/>mat_list <strong class="oi iu">&lt;-</strong> list(matrix(1<strong class="oi iu">:</strong>4, nrow <strong class="oi iu">=</strong> 2), matrix(1<strong class="oi iu">:</strong>9, nrow <strong class="oi iu">=</strong> 3))<br/></span><span id="8de7" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="94de" class="oo nj it oi b gy ot oq l or os">[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>     [,1] [,2] [,3]<br/>[1,]    1    4    7<br/>[2,]    2    5    8<br/>[3,]    3    6    9</span></pre><p id="071c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们通过将匿名函数<code class="fe of og oh oi b">function(row2) row2[2,]</code>添加到<code class="fe of og oh oi b">lapply()</code>函数中，从每个矩阵中提取第二行。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="eee0" class="oo nj it oi b gy op oq l or os"># Using an anonymous function in lapply()<br/>lapply(mat_list, function(row2) row2[2,])</span><span id="dca5" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="070b" class="oo nj it oi b gy ot oq l or os">[[1]]<br/>[1] 2 4<br/><br/>[[2]]<br/>[1] 2 5 8</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4ca0" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">萨普利()</h1><p id="66df" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">与<code class="fe of og oh oi b">lapply</code>唯一不同的是<code class="fe of og oh oi b">sapply</code>总是尽量简化结果。<code class="fe of og oh oi b">lapply</code>函数的输出总是一个列表。<code class="fe of og oh oi b">sapply</code>中的输出将是:</p><ul class=""><li id="eb39" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">如果结果是一个每个元素长度为 1 的列表:输出是一个向量</li><li id="7bfb" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">如果结果是一个列表，其中每个元素都是长度大于 1 的向量:则输出是一个矩阵</li><li id="bc15" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">否则一个列表</li></ul><p id="9bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">例子:</strong>结果是一个向量。<br/>取列表中每个元素的平均值。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="0456" class="oo nj it oi b gy op oq l or os"><em class="oj"># This function gives two elements of length 1, result as a vector</em><br/>my_list <strong class="oi iu">&lt;-</strong> (list(a <strong class="oi iu">=</strong> 1<strong class="oi iu">:</strong>10, b <strong class="oi iu">=</strong> 11<strong class="oi iu">:</strong>20, c <strong class="oi iu">=</strong> 21<strong class="oi iu">:</strong>30, d <strong class="oi iu">=</strong> 31<strong class="oi iu">:</strong>40))<br/>sapply(my_list, mean)</span><span id="e2a3" class="oo nj it oi b gy ot oq l or os">Output:</span><span id="0897" class="oo nj it oi b gy ot oq l or os">   a    b    c    d <br/> 5.5 15.5 25.5 35.5</span></pre><p id="d3e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">示例:</strong>结果是一个矩阵<br/>从列表中的每个元素提取第一列。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="f2d8" class="oo nj it oi b gy op oq l or os"><em class="oj"># Create three 2x2 matrices</em><br/>mat3 <strong class="oi iu">&lt;-</strong> list(matrix(1<strong class="oi iu">:</strong>4, 2, 2), matrix(5<strong class="oi iu">:</strong>8, 2, 2), matrix(9<strong class="oi iu">:</strong>12, 2, 2))</span><span id="d616" class="oo nj it oi b gy ot oq l or os">[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>     [,1] [,2]<br/>[1,]    5    7<br/>[2,]    6    8<br/><br/>[[3]]<br/>     [,1] [,2]<br/>[1,]    9   11<br/>[2,]   10   12</span><span id="5740" class="oo nj it oi b gy ot oq l or os"><em class="oj"><br/># Using an anonymous function. sapply gives three vectors of equal length 2, result is a matrix</em><br/>sapply(mat3, function(col1) col1[, 1])</span><span id="1794" class="oo nj it oi b gy ot oq l or os">[,1] [,2] [,3]<br/>[1,]    1    5    9<br/>[2,]    2    6   10</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="f37e" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">应用()</h1><p id="dff1" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">用于在数组的<strong class="lb iu">边距</strong>上计算函数(最常用于矩阵的行或列或高维数组)。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="c9eb" class="oo nj it oi b gy op oq l or os"><em class="oj"># Show arguments for apply</em><br/>args(apply)</span><span id="6440" class="oo nj it oi b gy ot oq l or os">Output:<br/>function (X, MARGIN, FUN, ..., simplify = TRUE)</span></pre><p id="2d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数 MARGIN 指定应该保留哪个边距。MARGIN=1 在行上循环，MARGIN=2 在列上循环。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="126c" class="oo nj it oi b gy op oq l or os"><em class="oj"># 10x5 matrix of random variables from the uniform dist between 1 and 10</em><br/>my_uniform_mat <strong class="oi iu">&lt;-</strong> matrix(runif(50, 1, 10), nrow <strong class="oi iu">=</strong> 10, ncol <strong class="oi iu">=</strong> 5)</span><span id="2b5a" class="oo nj it oi b gy ot oq l or os"> [,1]     [,2]    [,3]     [,4]     [,5]<br/> [1,] 9.807216 6.332778 5.966729 9.176292 6.185254<br/> [2,] 5.874502 2.430018 4.512795 4.094072 1.192640<br/> [3,] 7.030518 8.663532 7.566979 8.009686 8.510568<br/> [4,] 3.012011 7.210664 3.890397 7.204866 7.544637<br/> [5,] 2.586223 2.420773 1.039854 9.737979 9.016665<br/> [6,] 4.423740 2.240283 1.934197 7.976354 8.697875<br/> [7,] 2.302334 1.734337 4.326069 4.121796 2.230787<br/> [8,] 2.085405 1.386700 6.370785 3.052539 6.207375<br/> [9,] 8.385375 7.476500 7.475415 7.098384 2.844853<br/>[10,] 8.135351 3.386021 5.700849 9.158787 9.694943</span><span id="4ee2" class="oo nj it oi b gy ot oq l or os"><em class="oj"># Means for all rows</em><br/>apply(my_uniform_mat, 1, mean)</span><span id="d20a" class="oo nj it oi b gy ot oq l or os">[1] 5.785832 5.912120 5.016462 5.821229 6.741198 4.767206 5.913186<br/>[8] 4.669230 7.142562 6.813925</span><span id="cd97" class="oo nj it oi b gy ot oq l or os"><em class="oj"># Means for all columns</em><br/>apply(my_uniform_mat, 2, mean)</span><span id="1093" class="oo nj it oi b gy ot oq l or os">[1] 5.517655 5.274760 6.643334 5.002985 6.852742</span></pre><p id="d7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得一提的是，在 R:</p><ul class=""><li id="5048" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">rowRums = apply(x，1，sum)</li><li id="a8f5" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">colSums = apply(x，2，sum)</li><li id="30b1" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">rowMeans = apply(x，1，mean)</li><li id="399c" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">colMeans = apply(x，2，mean)</li></ul><p id="ba06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些功能经过优化，比使用应用功能更有效。但是我们可以评估其他函数，比如分位数。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="eefa" class="oo nj it oi b gy op oq l or os">my_uni_mat &lt;- matrix(runif(200, min= 0, max = 19), 20, 10)</span><span id="b756" class="oo nj it oi b gy ot oq l or os"># specifying which quantiles in the ... argument<br/>apply(my_uni_mat, 1, quantile, probs = c(0.25, 0.75))</span><span id="b5e7" class="oo nj it oi b gy ot oq l or os">[,1]     [,2]      [,3]      [,4]      [,5]      [,6]<br/>25%  3.486147 2.070579  3.440077  3.747711  6.430088  6.211664<br/>75% 14.243051 9.824579 13.108914 12.592477 13.620125 16.071445<br/>         [,7]      [,8]      [,9]     [,10]    [,11]     [,12]<br/>25%  5.519152  9.668082  4.548434  3.128967 2.584743  3.056771<br/>75% 14.633494 14.353726 15.403053 15.980496 9.856545 14.886065<br/>        [,13]    [,14]    [,15]     [,16]     [,17]     [,18]<br/>25%  9.444413  7.85192 4.428376  6.784206  8.607954  5.840153<br/>75% 15.118429 15.50309 8.562812 15.423813 13.430605 13.439571<br/>        [,19]     [,20]<br/>25%  8.773012  3.403049<br/>75% 11.887930 12.880902</span></pre><p id="13d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三维数组和折叠其中一个维度的示例。</p><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="1c50" class="oo nj it oi b gy op oq l or os"># Think 10 2x2 matrices stacked together<br/>x &lt;- array(rnorm(2 * 2 * 10), c(2, 2, 10))<br/>apply(x, MARGIN = c(1, 2), FUN = mean)</span><span id="7178" class="oo nj it oi b gy ot oq l or os">[,1]       [,2]<br/>[1,] -0.33305439 -0.5067485<br/>[2,]  0.04002034 -0.1403010</span></pre><p id="7f9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该操作与<code class="fe of og oh oi b">rowMeans(x, dim = 2).</code>相同</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="9316" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">塔普利()</h1><p id="a80f" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated"><code class="fe of og oh oi b">tapply</code>对向量的子集应用函数。为此，我们需要指定一个 vector (arg INDEX)来标识我们将要计算的数值向量的元素。</p><p id="a632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以有一个男性和女性的数据集，我们想分别评估两组的平均身高。</p><p id="7d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">tapply:</code>的论点</p><ul class=""><li id="9a84" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">x:一个向量</li><li id="c540" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">指数:一个因素或一系列因素</li><li id="f88e" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">乐趣:我们想要应用的功能</li><li id="18b0" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">…:要传递给 FUN 的其他参数</li></ul><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="2eea" class="oo nj it oi b gy op oq l or os"><em class="oj"># Create a data frame</em><br/>person <strong class="oi iu">&lt;-</strong> c("Kalle", "Anders", "Karin", "Sigrid", "Herman", "Pelle", "Hanna", "Anna")<br/>sex <strong class="oi iu">&lt;-</strong> factor(c("Male", "Male", "Female", "Female", "Male", "Male", "Female", "Female"))<br/>height <strong class="oi iu">&lt;-</strong> c(195, 190, 155, 165, 178, 201, 169, 170)<br/>nationality <strong class="oi iu">&lt;-</strong> factor(c("Swedish", "Swedish", "Norwegian", "Danish", "Swedish", "Danish", "Swedish", "Danish"))<br/><br/>my_df <strong class="oi iu">&lt;-</strong> data.frame(person, sex, height, nationality)<br/>my_df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/74ea5cbcf31c61c97be6e4d3bbf4ca65.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*8Akpic1CgIBBbhvzMKdVjg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><pre class="kj kk kl km gt ok oi ol om aw on bi"><span id="ef93" class="oo nj it oi b gy op oq l or os"><em class="oj"># Get the mean for each sex</em><br/>tapply(X <strong class="oi iu">=</strong> my_df<strong class="oi iu">$</strong>height, INDEX <strong class="oi iu">=</strong> sex, FUN <strong class="oi iu">=</strong> mean)</span><span id="b842" class="oo nj it oi b gy ot oq l or os">Female   Male <br/>164.75 191.00</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="ca1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个指南对你有用。如果你想看几个你可能想使用这些应用功能的实际例子，请务必阅读本指南的第 2 部分。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@andreagustafsen/a-guide-to-the-apply-family-in-r-part-2-227da1c1bc92" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">R 中的应用系列指南—第 2 部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">使用应用函数的实例。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>