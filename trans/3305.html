<html>
<head>
<title>Write composable Spark SQL analytics in JupyterLab</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JupyterLab中编写可组合的Spark SQL分析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/jupyterlab-sql-cell-editor-e6ac865b42df#2022-07-22">https://towardsdatascience.com/jupyterlab-sql-cell-editor-e6ac865b42df#2022-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0b3f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用JupyterLab SQL cell magic editor为您的Spark SQL笔记本增添一点魔力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9c0cb1be7bf610c669507f8d9426ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-D917qupMpq1fNKM1eXOA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Julia Kadel在Unsplash上拍摄的照片</p></figure><p id="ff71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">jupyterlab-sql-editor是一个ipython魔术，它使您能够用Spark SQL编写可组合的分析。这个jupyterlab扩展有一组丰富的特性:</p><ul class=""><li id="ec2f" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">自动完成<br/> -表名、列名、嵌套子字段<br/> -表连接<br/> -函数</li><li id="83fc" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">SQL语法突出显示和格式化</li><li id="595d" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">多显示输出<br/> - html和纯文本<br/> -交互式数据网格和json树<br/> -数据帧和视图的捕获</li></ul><h1 id="282b" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">编辑SQL语句</h1><p id="a6a9" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">jupyterlab-sql-editor用sql格式和语法高亮扩展了jupyterlab。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/f63c32fe6e1993150e32d5c0c2c542b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MZ4tN4H2vkc6nyvIQ0Bfow.gif"/></div></div></figure><p id="7925" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">jupyterlab-sql-editor还注册了一个提供自动补全功能的LSP服务器。按<tab>键触发自动完成表格和列名，包括嵌套子字段。使用<code class="fe nd ne nf ng b"><strong class="kx ir">%%sparksql --refresh all</strong></code>命令更新自动完成器使用的本地缓存文件。refresh命令枚举在当前spark上下文中找到的函数、表和列。</tab></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/fc13cb283daf8701408aab3f410dede6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wj8xO78PJGAPFtrCSKyF-A.gif"/></div></div></figure><p id="276a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">自动完成Spark SQL <a class="ae ni" href="https://spark.apache.org/sql/" rel="noopener ugc nofollow" target="_blank">函数</a>的文档和用法示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/0106c4b5d9dea092f6e9a7b4a8f5ab72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KjmU20gzlZfwI36jeVQ-ew.png"/></div></div></figure><p id="97b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还有一些高级用户特性，比如自动填充SELECT语句中的所有列名，以及自动建议匹配列名的连接条件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/488e93b22c9242f48861b921098dd867.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GAHNtir8OB2UZq2YX86uHQ.gif"/></div></div></figure><h1 id="1f93" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">显示结果</h1><p id="36cb" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">sparksql magic是一种执行sparksql语句的便捷方式。在本例中，我们执行一条语句，并将结果作为文本打印出来。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="813c" class="np mg iq ng b gy nq nr l ns nt"><strong class="ng ir">%%sparksql</strong> --output text</span><span id="541b" class="np mg iq ng b gy nu nr l ns nt">SELECT * from range(1, 1000)</span></pre><p id="9165" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用python做同样的事情。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="5f9f" class="np mg iq ng b gy nq nr l ns nt">statement = 'select * from range(1, 1000)'<br/>df = spark.sql(statement)<br/>df.show()</span></pre><p id="7a41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，这不是真正的魔法。sparksql魔术将单元格的主体作为语句，执行它并打印结果。该扩展简单地封装了样板python代码，并通过命令行选项使其随时可用。</p><p id="8d6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Jupyterlab-sql-editor支持一组丰富的输出格式，如交互式数据网格。我们使用彭博的ipydatagrid，它可以对Spark查询返回的结果进行后处理(排序、过滤和搜索)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/aca86680827e175a88d80af3854f42ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yjubVFb01hB4zQICLgYi0g.gif"/></div></div></figure><p id="82c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">树小部件显示结果的模式。这对于包含复杂嵌套数据结构的列特别有用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/8a15ac266f592844ae2ccfffceb70b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XMNIiCUkNJO0PaoGje3wnw.gif"/></div></div></figure><p id="c1a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用JSON输出导航复杂嵌套列的内容。这个输出使用标准的ipython树小部件，它可以在任何嵌套字段中进行搜索。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/43c6ec1286a74a7ce479e2efdd6faecf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AFa0HgBm0MZ5X4QiBITHJQ.gif"/></div></div></figure><p id="6d65" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，我们已经看到了如何查询数据，但是您并不局限于查询。您可以执行Spark SQL支持的任何SQL语句。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="4161" class="np mg iq ng b gy nq nr l ns nt"><strong class="ng ir">%%sparksql</strong><br/>CREATE TABLE prod.db.sample (<br/>    id bigint COMMENT 'unique id',<br/>    data string)<br/>USING iceberg</span><span id="a2db" class="np mg iq ng b gy nu nr l ns nt"><strong class="ng ir">%%sparksql</strong><br/>ALTER TABLE prod.db.sample<br/>ADD COLUMNS (<br/>    new_column string comment 'new_column docs'<br/>  )</span></pre><p id="dd36" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对简单的单行语句使用行魔法<code class="fe nd ne nf ng b"><strong class="kx ir">%sparksql</strong></code></p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="d675" class="np mg iq ng b gy nq nr l ns nt"><strong class="ng ir">%sparksql </strong>SET spark.sql.variable.substitute=false<br/><strong class="ng ir">%sparksql</strong> DROP TABLE prod.db.sample<br/><strong class="ng ir">%sparksql</strong> CALL prod.system.set_current_snapshot('db.sample', 1)</span></pre><h1 id="38f6" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">使用SQL编写可组合分析</h1><p id="78b3" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">通用表表达式(CTE)是将大型SQL语句分成更易于管理的部分的标准方法。Jupyterlab-sql-editor不仅支持CTE，还允许您将sql语句捕获或别名为视图，然后可以在以后的单元格中重用。这种机制利用了Spark dataframe的<code class="fe nd ne nf ng b"><strong class="kx ir">createOrReplaceTempView</strong></code>功能。使用<code class="fe nd ne nf ng b"><strong class="kx ir">--view</strong></code>选项创建一个临时视图。要防止立即执行查询，请使用<code class="fe nd ne nf ng b"><strong class="kx ir">--output skip</strong></code>选项。使用此选项时，仅创建视图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/96f2cfcbd50fe8bbfb926087027c6a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mU57acioW36abQXw8wYMMA.png"/></div></div></figure><p id="1f69" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">自动完成也适用于临时视图。使用<code class="fe nd ne nf ng b"><strong class="kx ir">%%sparksql --refresh local</strong></code>选项用您创建的任何本地视图更新您的自动完成缓存文件。</p><h1 id="401c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">数据框架和SQL之间的互操作</h1><p id="55fc" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">到目前为止，我们已经看到了如何使用SQL视图来创建可组合的SQL分析。然而，您不仅限于SQL，您可以在SQL和dataframe之间来回切换。您的部分分析可能更适合dataframe API，因为其他部分可能更适合SQL方言。Jupyterlab-sql-editor使方言之间的切换变得非常容易。使用<code class="fe nd ne nf ng b"><strong class="kx ir">--dataframe</strong></code>选项将SQL语句转换为数据帧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/4b4efb6ba0d01ea679b6fba603344074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eKOMR3DlGCPmsuGzsgTJuw.png"/></div></div></figure><p id="a644" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给定任何数据帧，通过调用<code class="fe nd ne nf ng b"><strong class="kx ir">df.createOrReplaceTempView()</strong></code>切换回SQL。例如，您可能使用Spark ML、Spark GraphFrames，或者简单地使用像CSV这样的数据源。Spark中的许多库都创建数据帧。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="3b2e" class="np mg iq ng b gy nq nr l ns nt">df = spark.read.csv(path)<br/>df.createOrReplaceTempView(‘my_csv_table’)</span></pre><p id="6a52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后参考您在<code class="fe nd ne nf ng b"><strong class="kx ir">%%sparksql</strong></code>中创建的视图</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="7786" class="np mg iq ng b gy nq nr l ns nt"><strong class="ng ir">%%sparksql</strong><br/>SELECT * FROM my_csv_table</span></pre><p id="b077" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记得运行<code class="fe nd ne nf ng b"><strong class="kx ir">%%sparksql --refresh local</strong></code>来更新您的本地缓存，享受自动完成功能！</p><h1 id="7d24" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">装置</h1><p id="4622" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">jupyterlab-sql-editor有两个主要的依赖项。<a class="ae ni" href="https://github.com/jupyter-lsp/jupyterlab-lsp" rel="noopener ugc nofollow" target="_blank"> jupyterlab-lsp </a>和<a class="ae ni" href="https://github.com/joe-re/sql-language-server" rel="noopener ugc nofollow" target="_blank"> sql-language-server </a>。安装扩展非常容易。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="6279" class="np mg iq ng b gy nq nr l ns nt">pip install jupyterlab-lsp jupyterlab-sql-editor</span></pre><p id="d608" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">安装sql-language-server项目以提供自动完成功能。</p><pre class="kg kh ki kj gt nl ng nm nn aw no bi"><span id="98b6" class="np mg iq ng b gy nq nr l ns nt">sudo npm install -g sql-language-server</span></pre><p id="2628" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有关配置选项的完整列表，请参见<a class="ae ni" href="https://github.com/CybercentreCanada/jupyterlab-sql-editor/blob/main/CONTRIBUTING.md" rel="noopener ugc nofollow" target="_blank">详细安装</a>指南。</p><h1 id="2e8f" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="c27a" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">在本文中，我们展示了如何利用<code class="fe nd ne nf ng b"><strong class="kx ir">%%sparksql</strong></code>在Spark SQL中轻松编写可组合的分析。我们关注的是Spark，但是jupyterlab-sql-editor也包含了一个<code class="fe nd ne nf ng b"><strong class="kx ir">%%trino</strong></code>魔法！将来可能会添加更多的SQL引擎。欢迎投稿！这是我们的git repo<a class="ae ni" href="https://github.com/CybercentreCanada/jupyterlab-sql-editor" rel="noopener ugc nofollow" target="_blank">cyber centre Canada/jupyterlab-SQL-editor</a>。</p><p id="f30a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在<a class="ae ni" href="https://medium.com/p/1179e818fe17" rel="noopener">的后续文章</a>中，我们将介绍jupyterlab-sql-editor对使用Jinja和DBT的sql模板的支持。</p><h1 id="adcf" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">多谢</h1><p id="0883" class="pw-post-body-paragraph kv kw iq kx b ky mx jr la lb my ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">致这些项目的贡献者:</p><p id="cd79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae ni" href="https://github.com/jupyter-lsp/jupyterlab-lsp" rel="noopener ugc nofollow" target="_blank">krassowski/jupyterlab-LSP</a><br/><a class="ae ni" href="https://github.com/joe-re/sql-language-server" rel="noopener ugc nofollow" target="_blank">Joe-re/SQL-language-server</a><br/><a class="ae ni" href="https://github.com/zeroturnaround/sql-formatter" rel="noopener ugc nofollow" target="_blank">zero turnaround/SQL-formatter</a><br/><a class="ae ni" href="https://github.com/cryeo/sparksql-magic" rel="noopener ugc nofollow" target="_blank">cryeo/spark SQL-magic</a><br/><a class="ae ni" href="https://github.com/bloomberg/ipydatagrid" rel="noopener ugc nofollow" target="_blank">Bloomberg/ipydatagrid</a></p></div></div>    
</body>
</html>