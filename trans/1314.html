<html>
<head>
<title>Build An Image &amp; PDF Text Extraction Tool with Tesseract OCR Using Client-side JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用客户端JavaScript通过Tesseract OCR构建图像和PDF文本提取工具</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-an-image-pdf-text-extraction-tool-with-tesseract-ocr-using-client-side-javascript-6126031001#2022-04-03">https://towardsdatascience.com/build-an-image-pdf-text-extraction-tool-with-tesseract-ocr-using-client-side-javascript-6126031001#2022-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46c8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><a class="ae ki" href="https://mozilla.github.io/pdf.js/" rel="noopener ugc nofollow" target="_blank">pdf . js</a>+<a class="ae ki" href="https://tesseract.projectnaptha.com/" rel="noopener ugc nofollow" target="_blank">tessera CT . js</a>——OCR&amp;Web技术的融合。包括完整的代码实现。</h2></div><p id="94ab" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">大约十年前，光学字符识别(OCR)工具，如<a class="ae ki" href="https://github.com/tesseract-ocr/tesseract/" rel="noopener ugc nofollow" target="_blank"> Tesseract OCR </a>引擎，只能通过C/C+等二进制格式执行，或者打包成包装类，包括Windows可执行文件(。exe)、Python包或Java软件开发工具包(JDK)。</p><p id="c26e" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">随着Web Assembly ( <a class="ae ki" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WASM </a>)编译器的出现，Tesseract OCR后来被编译成了JavaScript插件<a class="ae ki" href="https://tesseract.projectnaptha.com/" rel="noopener ugc nofollow" target="_blank"> Tesseract.js </a>(衷心感谢同为媒介作家的<a class="lf lg ep" href="https://medium.com/u/8d7beadc096e?source=post_page-----6126031001--------------------------------" rel="noopener" target="_blank"> Jerome Wu </a>)。这反过来通过组合另一个JavaScript插件<a class="ae ki" href="https://mozilla.github.io/pdf.js/" rel="noopener ugc nofollow" target="_blank"> PDF.js </a>的功能，实现了一个<strong class="kl iu"> PDF转文本应用</strong>的完整客户端JavaScript实现。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/78f4901331d61c26511bfac42d92b540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpLqMW2nShvkHuO28XDOZw.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者插图</p></figure><blockquote class="lx ly lz"><p id="120a" class="kj kk ma kl b km kn ju ko kp kq jx kr mb kt ku kv mc kx ky kz md lb lc ld le im bi translated"><em class="it">总共有2个</em> <strong class="kl iu"> <em class="it">与OCR相关的附带项目</em> </strong> <em class="it">作为我对OCR实现的自我探索之旅的一部分得以实施。它们如下所示:</em></p></blockquote><h2 id="0318" class="me mf it bd mg mh mi dn mj mk ml dp mm ks mn mo mp kw mq mr ms la mt mu mv mw bi translated">第1部分:图像到文本</h2><div class="mx my gp gr mz na"><a href="https://javascript.plainenglish.io/build-a-text-to-speech-app-using-client-side-javascript-98cd72df73bb" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">使用客户端JavaScript构建一个文本到语音的应用程序</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">OCR技术(Tesseract.js)和Web语音API的融合。包括完整的代码实现。</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lr na"/></div></div></a></div><h2 id="3f5b" class="me mf it bd mg mh mi dn mj mk ml dp mm ks mn mo mp kw mq mr ms la mt mu mv mw bi translated">第二部分:PDF-to-Text✶</h2><p id="720a" class="pw-post-body-paragraph kj kk it kl b km np ju ko kp nq jx kr ks nr ku kv kw ns ky kz la nt lc ld le im bi translated">✶类似于<a class="ae ki" href="https://javascript.plainenglish.io/build-a-text-to-speech-app-using-client-side-javascript-98cd72df73bb" rel="noopener ugc nofollow" target="_blank">第一部分:使用客户端JavaScript构建一个文本到语音的应用</a>，文本提取的主要原理保持不变。唯一需要的额外中间步骤是<strong class="kl iu">将上传的PDF文档页面转换成图像</strong>，这将在后面的实施步骤中详细说明。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="8dfe" class="me mf it bd mg mh mi dn mj mk ml dp mm ks mn mo mp kw mq mr ms la mt mu mv mw bi translated">使用Tesseract OCR构建PDF转文本应用程序</h2><blockquote class="lx ly lz"><p id="e051" class="kj kk ma kl b km kn ju ko kp kq jx kr mb kt ku kv mc kx ky kz md lb lc ld le im bi translated"><em class="it">对于该应用，需要实现一个</em> <strong class="kl iu"> <em class="it">自托管</em> </strong> <em class="it">版本的Tesseract.js v2，以支持</em> <strong class="kl iu"> <em class="it">离线使用</em></strong><em class="it"/><strong class="kl iu"><em class="it">可移植</em> </strong> <em class="it">。</em></p></blockquote><p id="cd67" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">第一步。</strong>检索Tesseract.js v2的以下4个文件</p><p id="8f97" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">-<a class="ae ki" href="https://raw.githubusercontent.com/incubated-geek-cc/Text-To-Speech-App/main/js/tesseract/tesseract.min.js" rel="noopener ugc nofollow" target="_blank">tessera CT . min . js</a><br/>-<a class="ae ki" href="https://raw.githubusercontent.com/incubated-geek-cc/Text-To-Speech-App/main/js/tesseract/worker.min.js" rel="noopener ugc nofollow" target="_blank">worker . min . js</a><br/>-<a class="ae ki" href="https://raw.githubusercontent.com/incubated-geek-cc/Text-To-Speech-App/main/js/tesseract/tesseract-core.wasm.js" rel="noopener ugc nofollow" target="_blank">tessera CT-core . wasm . js</a><br/>-<a class="ae ki" href="/incubated-geek-cc/Text-To-Speech-App/blob/main/js/tesseract/lang-data/4.0.0_best/eng.traineddata.gz?raw=true" rel="noopener ugc nofollow" target="_blank">eng.traineddata.gz</a>*</p><p id="0ba8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">*为简单起见，所有要提取的文本都假定为<strong class="kl iu">英文</strong></p><ul class=""><li id="6230" class="ob oc it kl b km kn kp kq ks od kw oe la of le og oh oi oj bi translated">导入插件</li></ul><pre class="li lj lk ll gt ok ol om bn on oo bi"><span id="922c" class="op mf it ol b be oq or l os ot">&lt;script src='js/tesseract/tesseract.min.js'&gt;&lt;/script&gt;</span></pre><ul class=""><li id="07f6" class="ob oc it kl b km kn kp kq ks od kw oe la of le og oh oi oj bi translated">继续将相应的工作属性指定为常量</li><li id="5a51" class="ob oc it kl b km ou kp ov ks ow kw ox la oy le og oh oi oj bi translated">将worker实例化封装到一个<code class="fe oz pa pb ol b">async function</code></li></ul><pre class="li lj lk ll gt ok ol om bn on oo bi"><span id="084a" class="op mf it ol b be oq or l os ot">const tesseractWorkerPath='js/tesseract/worker.min.js';<br/>const tesseractLangPath='js/tesseract/lang-data/4.0.0_best';<br/>const tesseractCorePath='js/tesseract/tesseract-core.wasm.js';<br/>var worker;<br/>async function initTesseractWorker() {<br/>  worker = Tesseract.createWorker({<br/>    workerPath: tesseractWorkerPath,<br/>    langPath:  tesseractLangPath,<br/>    corePath: tesseractCorePath<br/>  });    <br/>  await worker.load();<br/>  await worker.loadLanguage('eng');<br/>  await worker.initialize('eng');<br/>  return new Promise((resolve) =&gt; resolve('worker initialised.'));<br/>}</span></pre><p id="a469" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">注意:</strong>由于app是自托管的，相对路径需要重新定义为本地相对路径。</p><p id="cec8" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">第二步。</strong>检索<a class="ae ki" href="https://mozilla.github.io/pdf.js/" rel="noopener ugc nofollow" target="_blank"> PDF.js </a>的以下2个文件</p><ul class=""><li id="61df" class="ob oc it kl b km kn kp kq ks od kw oe la of le og oh oi oj bi translated"><a class="ae ki" href="https://raw.githubusercontent.com/incubated-geek-cc/Text-To-Speech-App/main/js/pdf/pdf.min.js" rel="noopener ugc nofollow" target="_blank"> pdf.min.js </a></li><li id="4022" class="ob oc it kl b km ou kp ov ks ow kw ox la oy le og oh oi oj bi translated"><a class="ae ki" href="https://raw.githubusercontent.com/incubated-geek-cc/Text-To-Speech-App/main/js/pdf/pdf.worker.min.js" rel="noopener ugc nofollow" target="_blank"> pdf.worker.min.js </a></li></ul><p id="3860" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">注意:</strong> PDF插件最初是由Mozilla开发的，用于通过JavaScript渲染PDF。原始文件可以在<a class="ae ki" href="https://github.com/mozilla/pdf.js" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="46d4" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">在浏览器中导入插件:</p><pre class="li lj lk ll gt ok ol om bn on oo bi"><span id="1a61" class="op mf it ol b be oq or l os ot">&lt;script src='js/pdf/pdf.min.js'&gt;&lt;/script&gt;</span></pre><p id="19fe" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">第三步。</strong>为PDF上传创建用户界面</p><ul class=""><li id="535b" class="ob oc it kl b km kn kp kq ks od kw oe la of le og oh oi oj bi translated">HTML文件输入和PDF页码显示</li></ul><pre class="li lj lk ll gt ok ol om bn on oo bi"><span id="9bae" class="op mf it ol b be oq or l os ot">&lt;input id='uploadPDF' type='file' /&gt;<br/>&lt;hr&gt;<br/>Pg &lt;span id='currentPageNo'&gt;&lt;/span&gt; of &lt;span id='totalPages'&gt;&lt;/span&gt;</span></pre><ul class=""><li id="c367" class="ob oc it kl b km kn kp kq ks od kw oe la of le og oh oi oj bi translated">JavaScript代码片段</li></ul><pre class="li lj lk ll gt ok ol om bn on oo bi"><span id="0ff6" class="op mf it ol b be oq or l os ot">const pdfWorkerPath='js/pdf/pdf.worker.min.js';<br/>const pixelRatio=window.devicePixelRatio*2;<br/>var uploadPDF=document.getElementById('uploadPDF');<br/>var currentPageNo=document.getElementById('currentPageNo');<br/>var totalPages=document.getElementById('totalPages');<br/>var _PDF_DOC, _PAGE, noOfPages, currentPage=1;<br/>var _CANVAS=document.createElement('canvas');<br/>function readFileAsDataURL(file) {<br/>  return new Promise((resolve,reject) =&gt; {<br/>    let fileredr = new FileReader();<br/>    fileredr.onload = () =&gt; resolve(fileredr.result);<br/>    fileredr.onerror = () =&gt; reject(fileredr);<br/>    fileredr.readAsDataURL(file);<br/>  });<br/>}<br/>const loadImage = (url) =&gt; new Promise((resolve, reject) =&gt; {<br/>  const img = new Image();<br/>  img.addEventListener('load', () =&gt; resolve(img));<br/>  img.addEventListener('error', (err) =&gt; reject(err));<br/>  img.src = url;<br/>});<br/>uploadPDF.addEventListener('change', function(evt) {<br/>  let file = evt.currentTarget.files[0];<br/>  if(!file) return;<br/>  readFileAsDataURL(file).then((pdf_url) =&gt; {<br/>    pdfjsLib.GlobalWorkerOptions.workerSrc=pdfWorkerPath;<br/>    (async () =&gt; {<br/>      _PDF_DOC = await pdfjsLib.getDocument({ url: pdf_url });<br/>      noOfPages = _PDF_DOC.numPages;<br/>      totalPages.innerHTML = noOfPages;<br/>      while(currentPage&lt;=noOfPages) {<br/>        await initPdfTesseractWorker();<br/>        currentPageNo.innerHTML=currentPage;<br/>        _PAGE = await _PDF_DOC.getPage(pageNo);<br/>        let pdfOriginalWidth = _PAGE.getViewport(1).width;<br/>        let viewport = _PAGE.getViewport(1);<br/>        let viewpointHeight=viewport.height;<br/>        _CANVAS.width=pdfOriginalWidth*pixelRatio;<br/>        _CANVAS.height=viewpointHeight*pixelRatio;<br/>        _CANVAS['style']['width'] = `${pdfOriginalWidth}px`;<br/>        _CANVAS['style']['height'] = `${viewpointHeight}px`;<br/>        _CANVAS.getContext('2d').scale(pixelRatio, pixelRatio);<br/>        var renderContext = {<br/>          canvasContext: _CANVAS.getContext('2d'),<br/>          viewport: viewport<br/>        };<br/>        await _PAGE.render(renderContext);<br/>        let b64str=_CANVAS.toDataURL();<br/>        let loadedImg = await loadImage(b64str);<br/>        let result=await worker.recognize(loadedImg);<br/>        let extractedData=result.data;<br/>    <br/>        let wordsArr=extractedData.words;<br/>        let combinedText='';<br/>        for(let w of wordsArr) {<br/>          combinedText+=(w.text)+' ';<br/>        }<br/>        inputTxt.insertAdjacentText('beginend', combinedText);<br/>        await worker.terminate();<br/>        currentPage++;<br/>      }<br/>    })();<br/>  }, false);<br/>});</span></pre><p id="66a5" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">解释:</strong></p><ul class=""><li id="7c76" class="ob oc it kl b km kn kp kq ks od kw oe la of le og oh oi oj bi translated"><code class="fe oz pa pb ol b">pdfjsLib.GlobalWorkerOptions.workerSrc=pdfWorkerPath;</code>将PDF插件的工作路径分配给其全局名称空间</li><li id="4796" class="ob oc it kl b km ou kp ov ks ow kw ox la oy le og oh oi oj bi translated">变量<code class="fe oz pa pb ol b">_CANVAS</code>是以编程方式创建的，因为PDF.js插件将每个页面呈现在一个HTML画布元素上</li><li id="9ef2" class="ob oc it kl b km ou kp ov ks ow kw ox la oy le og oh oi oj bi translated">上传PDF文档时，文件以base64字符串的形式作为变量<code class="fe oz pa pb ol b">pdf_url</code>读取，以检索<code class="fe oz pa pb ol b">_PDF_DOC</code>对象</li><li id="44e3" class="ob oc it kl b km ou kp ov ks ow kw ox la oy le og oh oi oj bi translated">编写while循环是为了处理上传的PDF文档的各个页面。对于呈现在画布元素上的每个页面，图像数据被提取为变量<code class="fe oz pa pb ol b">b64Str</code>，然后被解析为实用函数<code class="fe oz pa pb ol b">loadImage()</code>。这将返回一个<code class="fe oz pa pb ol b">Image()</code>元素，供Tesseract的工作人员提取嵌入的文本。</li><li id="7b08" class="ob oc it kl b km ou kp ov ks ow kw ox la oy le og oh oi oj bi translated">对于处理的每一页图像，<code class="fe oz pa pb ol b">inputTxt.insertAdjacentText('beginend', combinedText)</code>将所有提取的文本添加到输入域<code class="fe oz pa pb ol b">inputText</code>中，直到PDF的所有页面都被处理。</li></ul><p id="28f9" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated"><strong class="kl iu">要点:</strong>在每个while循环中，单个页面图像由单个实例化的worker处理。因此，对于后续的单个页面，需要再次实例化单个工作人员来提取嵌入的文本内容。</p><h2 id="3064" class="me mf it bd mg mh mi dn mj mk ml dp mm ks mn mo mp kw mq mr ms la mt mu mv mw bi translated">实施预览:</h2><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/38126d9bdb1c62ea1645b2ab86077cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*qO3olCr6LsSdOydbHS1fTA.gif"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者截屏|上传sample.pdf文件时，会提取每页的文本，并相应地附加到下面的文本字段。</p></figure><h2 id="b28d" class="me mf it bd mg mh mi dn mj mk ml dp mm ks mn mo mp kw mq mr ms la mt mu mv mw bi translated">完整的源代码可以在我的GitHub repo: <a class="ae ki" href="https://github.com/incubated-geek-cc/Text-To-Speech-App" rel="noopener ugc nofollow" target="_blank">文本到语音转换应用</a>或者在<a class="ae ki" href="https://incubated-geek-cc.github.io/Text-To-Speech-App/" rel="noopener ugc nofollow" target="_blank">演示</a>中试用！</h2><ul class=""><li id="183f" class="ob oc it kl b km np kp nq ks pd kw pe la pf le og oh oi oj bi translated">请注意，从<strong class="kl iu">第一部分</strong>添加了额外的功能。它们是:</li></ul><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi pg"><img src="../Images/4584b36b4ec08337870b3ff5be33fc19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fw0nxrzQkwUYsy6KL3ZNig.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者图片|带<strong class="bd ph">的按钮(👆*) </strong>可供用户选择，了解更多实施细节</p></figure><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi pi"><img src="../Images/93a42a6c83c563bed06a1bac647d6a76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ukcZ7cKa0w3Qm3jFnpiHSA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">作者图片|选择<strong class="bd ph">【┏🠋┓下载文本】</strong>使用户能够下载文本字段中所有提取的文本内容</p></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="8df1" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">非常感谢你坚持到这篇文章的结尾！❤希望这个实现对您有所帮助。</p><p id="f28c" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">如果您对更多GIS、数据分析和Web应用相关的内容感兴趣，请随时<a class="ae ki" href="https://medium.com/@geek-cc" rel="noopener">关注我的Medium </a>。会非常感激—😀</p><p id="c108" class="pw-post-body-paragraph kj kk it kl b km kn ju ko kp kq jx kr ks kt ku kv kw kx ky kz la lb lc ld le im bi translated">— 🌮<a class="ae ki" href="https://www.buymeacoffee.com/geekcc" rel="noopener ugc nofollow" target="_blank">请给我买一份玉米卷🎀˶❛◡❛)</a></p><div class="mx my gp gr mz na"><a href="https://geek-cc.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">通过我的推荐链接加入灵媒——李思欣·崔</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">获得李思欣·崔和其他作家在媒体上的所有帖子！😃您的会员费直接…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">geek-cc.medium.com</p></div></div><div class="nj l"><div class="pj l nl nm nn nj no lr na"/></div></div></a></div></div></div>    
</body>
</html>