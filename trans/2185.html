<html>
<head>
<title>Python 3.11 Is Indeed Faster Than 3.10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.11确实比3.10快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-3-11-is-indeed-faster-than-3-10-1247531e771b#2022-05-16">https://towardsdatascience.com/python-3-11-is-indeed-faster-than-3-10-1247531e771b#2022-05-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d999" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">与冒泡排序和递归函数并排比较证实了这一点</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/bd6d6bbb49eebe02b46377e5a9b067e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wtpsFhDgEN1A41IHauJSZg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/fashion-man-people-woman-6076414/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/photo/fashion-man-people-woman-6076414/" rel="noopener ugc nofollow" target="_blank"> KoolShooters </a>摄影。</p></figure><p id="cd91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python 3.11重新发布版出来了。我很想知道里面有什么新东西。</p><p id="81cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我打开变更日志时，我看到的第一件事完全吸引了我的注意力。</p><blockquote class="lw"><p id="8077" class="lx ly iu bd lz ma mb mc md me mf lv dk translated">Python 3.11比Python 3.10快了<strong class="ak">10-60%</strong>。平均而言，我们在标准基准测试套件上测量到1.25倍的加速。详见<a class="ae kz" href="https://docs.python.org/3.11/whatsnew/3.11.html#faster-cpython" rel="noopener ugc nofollow" target="_blank">更快的CPython </a>。— <a class="ae kz" href="https://docs.python.org/3.11/whatsnew/3.11.html" rel="noopener ugc nofollow" target="_blank"> Python 3.11 Changelog。</a></p></blockquote><p id="a3b9" class="pw-post-body-paragraph la lb iu lc b ld mg jv lf lg mh jy li lj mi ll lm ln mj lp lq lr mk lt lu lv in bi translated">这是我渴望的东西。</p><p id="2e50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在运行Python的生产系统上工作没有任何问题。但是Python速度不快的事实困扰着我。出于性能原因，我们总是需要使用Cython或Tuplex来转换关键代码。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/challenging-cython-the-python-module-for-high-performance-computing-2e0f874311c0"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">挑战cy thon——高性能计算的Python模块。</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">现代的替代方案看起来很有希望，Python可以以闪电般的速度运行。</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc kt mo"/></div></div></a></div><p id="1892" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着Python 3.11的发布，我相信它会走到尽头。</p><p id="9bed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，我想亲自尝试一下。它如何加快我在数据科学领域的日常工作？</p><p id="e0f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我特别感兴趣的是看看它在处理熊猫数据帧方面是否有任何改进。</p><p id="dee7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我决定亲自测试一下。</p><p id="9091" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，让我们用一些斐波纳契数来试试。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/how-to-speed-up-python-data-pipelines-up-to-91x-80d7accfe7ec"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">如何将Python数据管道加速到91X？</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">一个5分钟的教程可以为您的大数据项目节省数月时间。</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="nd l mz na nb mx nc kt mo"/></div></div></a></div><h1 id="07ac" class="ne nf iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">如何安装Python 3.11预发布版本？</h1><p id="425f" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">Windows用户可以从<a class="ae kz" href="https://www.python.org/downloads/release/python-3110b1/" rel="noopener ugc nofollow" target="_blank">发布页面</a>下载安装程序。如果你在Linux上像我一样，这里是你需要得到它。</p><pre class="kk kl km kn gu ob oc od oe aw of bi"><span id="2ee9" class="og nf iu oc b gz oh oi l oj ok"># If you're on Ubuntu 22.04 (Jammy Jellyfish,) you may not need the following line<br/>$ sudo add-apt-repository ppa:deadsnakes/ppa</span><span id="7ff1" class="og nf iu oc b gz ol oi l oj ok">$ sudo apt install Python3.11</span></pre><p id="180a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我不得不经常在两个版本之间切换。因此，我创建了单独的虚拟环境来存放两个Python版本。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/poetry-to-complement-virtualenv-44088cc78fd1"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">你不会还在用Virtualenv吧？</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">有一种更好的方法来管理依赖项、打包和发布Python项目。</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="om l mz na nb mx nc kt mo"/></div></div></a></div><p id="cb2d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以用下面的命令来完成:</p><pre class="kk kl km kn gu ob oc od oe aw of bi"><span id="77b6" class="og nf iu oc b gz oh oi l oj ok">$ virtualenv env10 --python=3.10<br/>$ virtualenv env11 --python=3.11</span><span id="7c12" class="og nf iu oc b gz ol oi l oj ok"># To activate v11 you can run,<br/>$ source env11/bin/activate</span></pre><h1 id="f6bd" class="ne nf iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">Python 3.11相比Python 3.10有多快？</h1><p id="cc7f" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">我创建了一个小函数来生成一些斐波那契数来找出答案。</p><pre class="kk kl km kn gu ob oc od oe aw of bi"><span id="50e4" class="og nf iu oc b gz oh oi l oj ok">def fib(n: int) -&gt; int:<br/>    return n if n &lt; 2 else fib(n - 1) + fib(n - 2)</span></pre><p id="d60c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后我测量了这个函数在两个Python版本中的性能。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/how-to-detect-memory-leakage-in-your-python-application-f83ae1ad897d"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">如何检测Python应用程序中的内存泄漏</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">标准的Python库，可以显示每一行的内存使用和执行时间</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="on l mz na nb mx nc kt mo"/></div></div></a></div><p id="ecd1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们用Timeit运行斐波那契数生成器来确定执行时间。以下命令将重复生成过程十次，并显示最佳执行时间。</p><pre class="kk kl km kn gu ob oc od oe aw of bi"><span id="16e4" class="og nf iu oc b gz oh oi l oj ok"># To generate the (n)th Fibonacci number<br/>python -m timeit -n 10 "from fib import fib;fib(n)"</span></pre><p id="f426" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是Python 3.10和Python 3.11的对比结果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oo"><img src="../Images/fc6acf18845986b8b600cb02d55fc522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFpR1P0q0694z_IgMOwtbA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python 3.11和Python 3.10的并行性能比较—图片由<a class="ae kz" href="https://thuwarkesh.medium.com" rel="noopener">作者提供。</a></p></figure><p id="65c1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如你所见，Python 3.11的每一次尝试都优于Python 3.10。执行时间在3.11版本中大致减半。</p><p id="cd57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">呜！太不寻常了！</p><p id="5f6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是我想检查它在熊猫任务中的表现。不幸的是，到目前为止，Numpy和Pandas还没有支持Python 3.11的版本。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/how-to-do-a-ton-of-analysis-in-the-blink-of-an-eye-16fa9affce06"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">如何在眨眼之间用Python做一吨的分析？</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">使用这些Python探索性数据分析，将您的数据探索时间缩短到原来的十分之一…</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="op l mz na nb mx nc kt mo"/></div></div></a></div><h1 id="1f38" class="ne nf iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">冒泡排序的性能基准。</h1><p id="19a4" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">由于我无法对熊猫进行基准测试，我在考虑一个涉及数字的替代方案。这将最终对数据科学家的生活产生影响。</p><p id="df1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，我想测试一下<a class="ae kz" href="https://www.programiz.com/dsa/bubble-sort" rel="noopener ugc nofollow" target="_blank">冒泡排序</a>。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/how-to-serve-massive-computations-using-python-web-apps-590e51624bc6"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">如何使用Python Web应用服务于大规模计算？</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">克服Python的局限性，并通过web请求将其用于繁重的数据分析和机器学习。</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="oq l mz na nb mx nc kt mo"/></div></div></a></div><p id="12a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下面的代码中，我们试图测量对一百万个数字进行排序所需的时间。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="5aac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的代码在代码内部生成了一百万个随机数。然而，<code class="fe ot ou ov oc b">timeit</code>函数被设置为仅测量冒泡排序函数执行的持续时间。</p><p id="bc63" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果是惊人的！</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/d6ea38645ceae7f492ea948e4452a738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dK3QgHfAVjO-shwcpnb1bg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python 3.11在冒泡排序挑战上的表现优于3.10——图片由<a class="ae kz" href="https://thuwarakesh.medium.com" rel="noopener">作者提供。</a></p></figure><p id="1086" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python 3.11只用了21秒就完成了排序，而3.10的对应版本用了39秒。</p><h1 id="bcb4" class="ne nf iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">I/O操作是否存在性能差异？</h1><p id="5d5d" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">一个有趣的性能挑战是我们的程序在磁盘上读写信息的速度。</p><p id="1ed3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您正在处理一个庞大的文件列表，或者在不使用数据库的情况下存储/检索数据，I/O性能是至关重要的。</p><div class="ml mm gq gs mn mo"><a rel="noopener follow" target="_blank" href="/python-web-apps-are-a-terrible-idea-for-analytics-projects-36f1bd33e84b"><div class="mp ab fp"><div class="mq ab mr cl cj ms"><h2 class="bd iv gz z fq mt fs ft mu fv fx it bi translated">Python Web应用对于分析项目来说是一个糟糕的想法。</h2><div class="mv l"><h3 class="bd b gz z fq mt fs ft mu fv fx dk translated">纯Python栈忽略了严重的缺点。以下是如何弥补的方法。</h3></div><div class="mw l"><p class="bd b dl z fq mt fs ft mu fv fx dk translated">towardsdatascience.com</p></div></div><div class="mx l"><div class="ox l mz na nb mx nc kt mo"/></div></div></a></div><p id="f433" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个简单的测试，将Python 3.11和它的3.10兄弟进行对比。</p><p id="7615" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我有两个程序。第一个将一百万个文件写入磁盘。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="8f90" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们使用<code class="fe ot ou ov oc b">timeit</code>函数来打印持续时间。通过设置<code class="fe ot ou ov oc b">number</code>参数，我们可以多次重复该任务并取平均值。</p><p id="2f72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二个程序也使用了<code class="fe ot ou ov oc b">timeit</code>函数。但是它只涉及读取一百万个文件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="or os l"/></div></figure><p id="abcf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是我们运行两个版本得到的输出。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/6ef88499a05ffe8641314fb781609b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lezXrXSWfQkpBnIVYVl9gg.png"/></div></div></figure><p id="959f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管Python 3.10似乎比Python 3.11有优势，但这并不显著。事实上，多次运行这个实验会得出不同的结论。</p><h1 id="a686" class="ne nf iu bd ng nh ni nj nk nl nm nn no ka np kb nq kd nr ke ns kg nt kh nu nv bi translated">最后的想法</h1><p id="f352" class="pw-post-body-paragraph la lb iu lc b ld nw jv lf lg nx jy li lj ny ll lm ln nz lp lq lr oa lt lu lv in bi translated">3.11似乎是Python历史上一个了不起的版本。</p><p id="acbd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python 3.11仍然是预发布版本。因此，你不能指望你所有的第三方软件包都能正常工作。现在连Numpy和熊猫都不行了。</p><p id="cb67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，关于3.11版本的一个有趣的说法是，它比前一个版本快60%。</p><p id="5194" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我做了一些实验来验证这个说法。而且Python 3.11确实更快。</p><p id="15a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以复制代码并亲自尝试。</p></div><div class="ab cl oy oz hy pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="in io ip iq ir"><blockquote class="pf pg ph"><p id="6eb7" class="la lb pi lc b ld le jv lf lg lh jy li pj lk ll lm pk lo lp lq pl ls lt lu lv in bi translated"><em class="iu">感谢阅读，朋友！在</em><a class="ae kz" href="https://www.linkedin.com/in/thuwarakesh/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv"><em class="iu">LinkedIn</em></strong></a><em class="iu"/><a class="ae kz" href="https://twitter.com/Thuwarakesh" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv"><em class="iu">Twitter</em></strong></a><em class="iu">，以及</em><a class="ae kz" href="https://thuwarakesh.medium.com/" rel="noopener"><strong class="lc iv"><em class="iu">Medium</em></strong></a><em class="iu">上跟我打招呼。</em></p><p id="e15a" class="la lb pi lc b ld le jv lf lg lh jy li pj lk ll lm pk lo lp lq pl ls lt lu lv in bi translated"><em class="iu">还不是中等会员？请使用此链接</em> <a class="ae kz" href="https://thuwarakesh.medium.com/membership" rel="noopener"> <strong class="lc iv"> <em class="iu">成为会员</em> </strong> </a> <em class="iu">因为，在没有额外费用的情况下，我为你引荐赚取一小笔佣金。</em></p></blockquote></div></div>    
</body>
</html>