<html>
<head>
<title>Kubernetes Ingress Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes Ingress解释道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubernetes-ingress-explained-1aeadb30f273#2022-06-29">https://towardsdatascience.com/kubernetes-ingress-explained-1aeadb30f273#2022-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TLS证书入口实用介绍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9d9450ac3f9e42fb2e38e83f3fe8a87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j3SAZpYp0oAzMqhG.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://pixabay.com/photos/maze-graphic-render-labyrinth-2264/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="d417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据Kubernetes官方文档:</p><blockquote class="lv lw lx"><p id="3b61" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">入口将来自群集外部的HTTP和HTTPS路由暴露给群集中的服务。流量路由由入口资源上定义的规则控制。</p></blockquote><p id="be54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，入口充当Kubernetes集群中部署的服务和外部用户或客户端之间某种形式的受控流量路由链接。</p><p id="4d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个更简单的例子来说明这一点。让我们想象一下，Medium上的所有文章都部署在某个集群上，其中每个发布本质上都是一个Kubernetes部署。所有这些部署都有一个附带的服务(<em class="ly">网络的行话</em>)，它带有一些IP地址和端口号，以便读者可以访问文章。如果没有入口这样的东西，读者将不得不给这些原始的网址，这肯定不是人类友好的。例如，您不知道正在阅读本文的本地IP和端口。就是不实用。相反，您可以简单地在Kubernetes集群中部署一个入口，并为每个出版物提供一个具有各种路由规则的人性化单点入口'<code class="fe mc md me mf b"><strong class="lb iu"><em class="ly">medium[dot]com</em></strong></code>'，以便读者可以从浏览器访问'<code class="fe mc md me mf b"><strong class="lb iu"><em class="ly">medium[dot]com/publication1</em></strong></code>'，入口控制器会自动将该流量定向到正确的服务以及包含该出版物所请求资源的随附pod。现在，让我们在之前的文章 中创建的集群<a class="ae ky" rel="noopener" target="_blank" href="/embracing-kubernetes-for-machine-learning-setup-1-3-51c02686edfb"> <strong class="lb iu">中尝试一些入口部署。</strong></a></p><p id="efa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将设置一些额外的配置，通过TLS证书启用HTTPS支持，测试这种HTTPS支持，最后在集群上从头开始部署一个简单的应用程序。</p><h2 id="9128" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">需要额外设置</h2><ul class=""><li id="07b0" class="mz na it lb b lc nb lf nc li nd lm ne lq nf lu ng nh ni nj bi translated"><a class="ae ky" href="https://github.com/FiloSottile/mkcert" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> mkcert </strong> </a> —一个用于制作本地可信开发证书的工具，该证书将为在我们的集群上运行的服务启用<code class="fe mc md me mf b"><em class="ly">https</em></code>。安装完成后，让我们生成一个本地证书，该证书指向一些开发URL以及一个通配符URL <code class="fe mc md me mf b"><strong class="lb iu">*.</strong>myminikube.demo</code>,它将通过以下两个命令用于入口设置:</li></ul><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="3c19" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">mkcert -install</strong></span><span id="be74" class="mg mh it mf b gy ns np l nq nr"><strong class="mf iu">mkcert "*.myminikube.demo" localhost 127.0.0.1</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/6a9a41555f606a7eee80ff6257f7458a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdXeIPJtTSd2QDnT8utIFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">mkcert安装(图片来源:作者)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c2f176740194e5e09b56fbc8d5d1563a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*POXrkMFxvy_MJH5ZuUS0fQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成TLS证书(图片来源:作者)</p></figure><p id="13e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存好这个TLS证书和密钥(两个<strong class="lb iu">)。pem </strong>文件)放在你想要的任何目录中，并从中创建一个Kubernetes秘密。通过<code class="fe mc md me mf b">kubectl</code>为这篇文章创建了一个名为<code class="fe mc md me mf b"><strong class="lb iu">mkcert-tls-secret</strong></code>的秘密:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="399d" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl create secret -n kube-system tls mkcert-tls-secret --cert=</strong>&lt;DIRECTORY_CONTAINING_PEM&gt;/_wildcard.myminikube.demo+2.pem<strong class="mf iu"> --key=</strong>&lt;DIRECTORY_CONTAINING_KEY_PEM&gt;/_wildcard.myminikube.demo+2-key.pem</span></pre><blockquote class="lv lw lx"><p id="0404" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意:这两个文件的名字会因系统而异，但是这个概念仍然适用。同样在生产环境中，证书通常由证书管理器自动管理。例如，这个生成的证书将于2024年到期。</p></blockquote><p id="c65c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们通过使用位于<code class="fe mc md me mf b">kube-system</code>名称空间中的<code class="fe mc md me mf b">mkcert-tls-secret</code>重新配置该证书，将它集成到ingress插件中:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="4c25" class="mg mh it mf b gy no np l nq nr">$ <strong class="mf iu">minikube addons configure ingress</strong><br/>-- Enter custom cert(format is "namespace/secret"): <strong class="mf iu">kube-system/</strong><strong class="mf iu">mkcert-tls-secret</strong><br/>✅  ingress was successfully configured</span></pre><p id="0512" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">禁用当前ingress加载项，然后再次启用它以使更改生效:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="27f2" class="mg mh it mf b gy no np l nq nr">$ <strong class="mf iu">minikube addons disable ingress</strong><br/>🌑  "The 'ingress' addon is disabled<br/><br/>$ <strong class="mf iu">minikube addons enable ingress</strong><br/>🔎  Verifying ingress addon...<br/>🌟  The 'ingress' addon is enabled</span></pre><p id="f90f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们验证入口控制器现在有一个默认的SSL证书</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="f710" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl -n ingress-nginx get deployment ingress-nginx-controller -o yaml | grep "kube-system"</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/5797b4d8f9313fd79350c88e410ceb7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUSHDjjRhMySj_VLKixQsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查部署的SSL证书(图片来源:作者)</p></figure><p id="5ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该看到这个秘密名称(上面设置的)是默认的SSL证书</p><ul class=""><li id="f9ae" class="mz na it lb b lc ld lf lg li nw lm nx lq ny lu ng nh ni nj bi translated"><strong class="lb iu">使用Minikube IP和入口路由编辑hosts文件</strong> : Hosts文件现在需要使用为我们即将部署的入口预留的任何所需URL进行更新。因为我们使用了通配符选项，所以通过这种主机格式<code class="fe mc md me mf b"><strong class="lb iu">&lt;SERVICE&gt;</strong>.myminikube.demo</code>，我们有无限的入口部署选项。<em class="ly">对于云提供商来说，这种入口设计选择也非常经济高效，因为您需要为每个负载平衡URL付费，但在我们的案例中，1个URL可以用于不限数量的入口。</em>我们将测试Ingress waters，为我们在上一篇文章中启用的日志和仪表板附加服务设置一个，最后为实际应用设置一个。使用<code class="fe mc md me mf b">sudo</code>权限编辑主机文件地址，使用您的<code class="fe mc md me mf b"><strong class="lb iu">minikube ip</strong></code>地址，后跟所需的入口主机名<code class="fe mc md me mf b"><strong class="lb iu">hello.myminikube.demo dashboard.myminikube.demo logs.myminikube.demo</strong></code> <strong class="lb iu"> : </strong></li></ul><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="b6dc" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">sudo vi /etc/hosts<br/>cat /etc/hosts</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/0027660c5d726d3d96215c724c70ea4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ii2rukAlfH1TmXnh7fohMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的主机文件(图片来源:作者)</p></figure><p id="bf59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无聊的准备工作终于结束了。让我们也用我们新的TLS证书体验一下入口部署的乐趣。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h2 id="3848" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">使用HTTPS证书测试部署</h2><p id="c404" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">入口只是充当集群外部的客户端和集群中运行的服务之间的路由链接。因此，人们可以在脑海中想象一个入口和位于Kubernetes服务之上的东西。我们的计划是在之前的文章中启用这两个插件后，测试日志和仪表板服务的两个入口部署。唯一的问题是，这些服务运行在两个不同的名称空间中(本质上是隔离的环境)。<strong class="lb iu"> <em class="ly">让入口为不同名称空间中的服务工作的技巧是在每个名称空间中都有一个入口</em> </strong> <em class="ly">。</em>如果仪表板和日志服务在同一个名称空间中，那么一个入口文件就足够了。让我们通过以下方式从这些服务中获取一些重要的元数据:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="ba66" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">minikube service list</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/351999829a004adc7ce16e7162ce2e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iEjuqKazxqkIZJvrg02xUA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集群中运行的服务列表(图片来源:作者)</p></figure><p id="3052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志服务在<code class="fe mc md me mf b">kube-system</code>中，而仪表板服务在<code class="fe mc md me mf b">kubernetes-dashboard</code>中。现在从这两个服务中获取所需的元数据:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="afeb" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl get services -n kubernetes-dashboard --output=wide<br/>kubectl get services -n kube-system --output=wide</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/b56040cf242ca897d7d5c37526cc9667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k0G6M0Q1-Gg43mHA2d2lXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用kubectl检查服务(图片来源:作者)</p></figure><p id="4419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这些命令中，注意服务的<code class="fe mc md me mf b">NAME</code>和<code class="fe mc md me mf b">PORT(S)</code>。仪表板服务名为<code class="fe mc md me mf b">kubernetes-dashboard</code>，运行在集群内的端口<code class="fe mc md me mf b">80</code>上，而日志服务名为<code class="fe mc md me mf b">logviewer</code>，运行在端口<code class="fe mc md me mf b">3000</code>上。现在，让我们最后写入口yaml文件。</p><p id="204c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我的经历来看，大多数人看到一堆<code class="fe mc md me mf b">.yaml</code>文件，变得如此不知所措。你不需要记住语法之类的东西。VS代码  <strong class="lb iu"> </strong>中的<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-kubernetes-tools.vscode-kubernetes-tools" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Kubernetes扩展为每个Kubernetes组件提供了一些精彩的片段。打开一个<code class="fe mc md me mf b">.yaml</code>文件，开始输入类似<code class="fe mc md me mf b">ingress</code>的组件，一个代码片段应该会弹出来。用一个<code class="fe mc md me mf b">tab</code>接受它，你应该有一个好的入口模板。</strong></a></p><p id="dcd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志服务的入口组成如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="987a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们快速浏览一下添加到初始模板中的关键组件。</p><ul class=""><li id="8dfb" class="mz na it lb b lc ld lf lg li nw lm nx lq ny lu ng nh ni nj bi translated"><strong class="lb iu"> <em class="ly">注释:</em> </strong> <code class="fe mc md me mf b">kubernetes.io/ingress.class: “nginx”</code>只是将<code class="fe mc md me mf b">nginx</code>设置为入口控制器，而<code class="fe mc md me mf b">nginx.ingress.Kubernetes.io/ssl-redirect</code>使用相同的SSL证书为该入口启用重定向。</li><li id="2118" class="mz na it lb b lc on lf oo li op lm oq lq or lu ng nh ni nj bi translated"><strong class="lb iu"> <em class="ly">名称和命名空间:</em> </strong>入口的名称是用Kubernetes中的典型约定设置的<code class="fe mc md me mf b">name-&lt;component&gt;</code>。所以<code class="fe mc md me mf b">logs-ingress</code>用于演示。还指定了<code class="fe mc md me mf b">namespace</code>,因此Kubernetes将知道部署入口的名称空间。</li><li id="c55b" class="mz na it lb b lc on lf oo li op lm oq lq or lu ng nh ni nj bi translated"><strong class="lb iu"> <em class="ly"> spec: </em> </strong>启用HTTPS就像参照托管TLS证书的<code class="fe mc md me mf b">secretName</code> ( <code class="fe mc md me mf b">mkcert-tls-secret</code>)在<code class="fe mc md me mf b">spec</code>部分下的<code class="fe mc md me mf b">tls</code>子部分中指定所需的主机名(<code class="fe mc md me mf b">logs.myminikube.demo</code>)一样简单。</li><li id="1e76" class="mz na it lb b lc on lf oo li op lm oq lq or lu ng nh ni nj bi translated"><strong class="lb iu"> <em class="ly">主持人:</em> </strong>规则小节是路由魔术发生的地方。这是HTTP路径和集群中运行的相关后端服务的链接位置。在HTTP路径<code class="fe mc md me mf b">logs.minikube.demo/</code>上，我们链接前面提到的运行在端口<code class="fe mc md me mf b">3000</code>上的<code class="fe mc md me mf b">logviewer</code>服务。</li></ul><blockquote class="lv lw lx"><p id="3b8d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">差不多就是这样。您将在Kubernetes的世界中读到的<code class="fe mc md me mf b">.yaml</code>文件的大部分都是样板代码，所以不要被它们所影响！</p></blockquote><p id="5751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面仪表板的入口文件看起来与日志文件相同，唯一的区别是后端服务(<code class="fe mc md me mf b">kubernetes-dashboard</code>)、规则主机(<code class="fe mc md me mf b">dashboard.myminikube.demo</code>)和端口号(<code class="fe mc md me mf b">80</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了我们定义的入口配置和整齐打包的<code class="fe mc md me mf b">.yaml</code>文件，<code class="fe mc md me mf b">kubetcl</code>可以应用它们来实现定义的更改。只需通过以下方式申请:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="37ba" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl apply -f dashboard_ingress.yaml &amp;&amp; \ kubectl apply -f logs_ingress.yaml</strong></span></pre><p id="b9df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的系统和资源，部署的入口可能需要几秒或几分钟才能完全运行，因为入口控制器必须为该部署分配一个IP地址，URL才能工作。只需使用<code class="fe mc md me mf b">kubectl</code>检查几次，直到您看到分配的IP地址:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="3ee1" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl get ingress -n kubernetes-dashboard<br/>kubectl get ingress -n kube-system</strong></span></pre><p id="6313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分配IP地址后，我们就可以开始访问部署中定义的主机了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/487b0718c434eb32832f2dd8946a6b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64a8sMz0Ewyuv596oNp2lw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用kubectl检查入口(图片来源:作者)</p></figure><p id="2fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我更喜欢用bash脚本自动执行这个“<em class="ly">等待分配IP的</em>序列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本可重复用于检查任何名称空间中的任何入口，并在IP正常工作时返回该入口的URL:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="60a1" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">sh check_ingress.sh "ingress-demo"<br/>sh check_ingress.sh "kubernetes-dashboard"</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/bd59ed0bf846e9c6f253322552fdff7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Oz69yQJdb3fQ-cVDNnH_Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查IP地址的Bash脚本(图片来源:作者)</p></figure><p id="317b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仪表板入口应在<code class="fe mc md me mf b"><a class="ae ky" href="https://dashboard.myminikube.demo" rel="noopener ugc nofollow" target="_blank">https://dashboard.myminikube.demo</a></code>可用。在浏览器中访问该URL，您应该会看到带有HTTPS证书的典型Kubernetes仪表板</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0d5c62785999f53658064e2d9e07a3fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEbZgy1MCRsJSZxC9lnL-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTTPS检查仪表板入口(图片来源:作者)</p></figure><p id="4889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用相同的HTTPS证书，应在<code class="fe mc md me mf b"><a class="ae ky" href="https://logs.myminikube.demo" rel="noopener ugc nofollow" target="_blank">https://logs.myminikube.demo</a></code>上提供相同的日志入口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/b373205ddfda96663147aff42fc253a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*x01M0lWfsUANW8JxZ8MmJA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">HTTPS检查日志入口(图片来源:作者)</p></figure><p id="5cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以确认TLS证书按预期工作，入侵也可以利用它们。现在，从零开始快速部署流行的hello world容器应用程序怎么样？</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h2 id="c832" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">使用HTTPS部署Hello World应用程序</h2><p id="e65f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li oh lk ll lm oi lo lp lq oj ls lt lu im bi translated">让我们首先为这个部署创建一个名称空间文件，以保持一切都是独立的。这很简单，因为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="93c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的一点是，在名称空间可以被其他组件调用之前，它需要是可用的，所以顺序对于<code class="fe mc md me mf b">namespaces</code>很重要。应用文件以实现更改:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="d556" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl apply -f hello_namespace.yaml</strong></span></pre><p id="3e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们创建一个部署文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1eec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到这个名为<code class="fe mc md me mf b">myapp</code>的部署所使用的名称空间。在此部署中，我们指定希望运行应用程序的10个副本(拷贝)。这个数字是任意的。容器映像<code class="fe mc md me mf b">gcr.io/google-samples/hello-app:1.0</code>在设置了一些资源限制的情况下使用。端口<code class="fe mc md me mf b">8000</code>被这个容器使用。应用文件以创建展开:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="7b07" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl apply -f hello_deployment.yaml</strong></span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="c212" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pods运行该应用程序的10个副本，这些副本在集群内部运行，让我们在部署之上构建一个服务，以便客户端可以从集群外部与正在运行的应用程序进行交互。上面配置了一个<code class="fe mc md me mf b">NodePort</code>服务，目标是内部<code class="fe mc md me mf b">8000</code>端口，并在同一个端口<code class="fe mc md me mf b">8000</code>上向用户公开该端口。将该服务与kubectl一起应用，它将被分配一个我们本可以使用的IP地址，但我们不希望这样，因为我们可以有一个漂亮而真实的URL:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="e368" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl apply -f hello_service.yaml</strong></span></pre><p id="8f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们为这个服务构建了一个入口，这样来自集群外的客户端对<code class="fe mc md me mf b"><strong class="lb iu">hello.myminikube.demo</strong></code>的任何调用都将被重定向到上面定义的服务！还记得我们正在运行10个副本吗？入口控制器将自动处理我们正在运行的10个副本中的1个的请求流。现在想象一下，如果有10，000份拷贝分发给1，000名不同的工人！太疯狂了，不是吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用这个入口并使用<code class="fe mc md me mf b">check_ingress</code> bash脚本来检查分配的IP的可用性:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="0fe5" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl apply -f hello_ingress.yaml</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/4403e9c19cf855e28e8b0c525e6d8491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*8czEXDhqcwTLXBwFS6VuRQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用bash脚本检查IP(图片来源:作者)</p></figure><p id="59d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦分配，访问给定的URL(<code class="fe mc md me mf b">https://hello.myminikube.demo</code>)，你应该会看到一个<code class="fe mc md me mf b">Hello, world!</code>消息以及应用程序的<code class="fe mc md me mf b">Version</code>和一个<code class="fe mc md me mf b">Hostname</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/6c8cf4e9b5ce1fb6c3d75ba51ee0dbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*oCTsDhVtQpws61dnkJNKdQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用TLS证书的Hello world应用程序(图片来源:作者)</p></figure><p id="a7a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刷新页面几次，并在每次页面刷新时注意<code class="fe mc md me mf b">Hostname</code>的最后部分。该值应该最多更改10个唯一的值，代表我们在集群中运行应用程序的10个副本容器。</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="1923" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">curl </strong><a class="ae ky" href="https://hello.myminikube.demo" rel="noopener ugc nofollow" target="_blank"><strong class="mf iu">https://hello.myminikube.demo</strong></a></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/d18ae51bb8f111c8cecd58c3650544b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*npbeYV2o2NUkCiw4uNHitQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过“curl”向应用程序发出多个Get请求(图片来源:作者)</p></figure><p id="c595" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！现在，您有望对Kubernetes Ingress有足够的了解，开始在您的项目中使用它们。不要忘记通过删除它们来清理部署，以便为其他更重要的部署节省资源。</p><p id="8ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除所有的资源非常容易，因为我们将所有的东西都隔离在一个名称空间中。只需运行:</p><pre class="kj kk kl km gt nk mf nl nm aw nn bi"><span id="d744" class="mg mh it mf b gy no np l nq nr"><strong class="mf iu">kubectl delete namespaces ingress-demo   </strong>                                              <br/>namespace "ingress-demo" deleted</span></pre></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="d778" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经创建了一个<a class="ae ky" href="https://github.com/PyDataBlog/K8s-Ingress-Demo" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GitHub库</strong> </a>，其中包含了本文使用的所有脚本，以供将来参考和扩展。玩得开心点！在下一篇文章之前，继续探索Kubernetes的世界。</p></div></div>    
</body>
</html>