<html>
<head>
<title>I Have Been Merging Pandas Dataframes Completely Wrong</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我一直在合并熊猫数据帧，完全错了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-most-efficient-way-to-merge-join-pandas-dataframes-7576e8b6c5c#2022-03-03">https://towardsdatascience.com/the-most-efficient-way-to-merge-join-pandas-dataframes-7576e8b6c5c#2022-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce1d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么几乎每个人都在低效地写它们，以及一些解决它的技巧！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a03d84628cfa9eb82022903b622ca7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WA9T2EA78hiGcsBF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="c109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数数据科学家来说，更令人困惑的熊猫概念之一是熊猫合并和熊猫加入之间的区别。大多数人亲自告诉我“使用合并就好了”，网上很少有资源解释哪一个肯定更好。正因为如此，我决定对这两个功能进行压力测试，在我的结果中…我意识到我多年来一直在错误地合并。</p><h2 id="57c3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">设置问题</h2><p id="c773" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了测试这个问题，我创建了一个2823行8列的假销售数据数据帧。因为我想测试合并，所以我将简单地将这个单个数据帧转换成2个更精简格式的数据帧。从SQL表中提取数据时可能会看到的格式。其中一个表是Orders，由ORDERNUMBER字段索引，另一个表是Customers表，由CUSTOMERNAME索引，包含关于客户的所有元数据。我们的目标是连接这两个表，以确定每个订单应该运送到哪里。它们唯一重叠的列是CUSTOMERNAME字段。下面的代码显示了我是如何执行分割的！</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="598e" class="lv lw it mu b gy my mz l na nb">#Create the dataframe (random lists not shown, in github)<br/>df = pd.DataFrame(index=range(2823),columns=["ORDERNUMBER", "QUANTITYORDERED", "ITEMNAME", "PRICEEACH", "CUSTOMERNAME", "CUSTOMERADDRESS"])</span><span id="8c6d" class="lv lw it mu b gy nc mz l na nb">df["ORDERNUMBER"] = df.index<br/>df["QUANTITYORDERED"] = np.random.randint(1, 6, df.shape[0])<br/>df["ITEMNAME"] = np.random.choice(list(item_ordered), len(df))<br/>df["PRICEEACH"] = np.random.randint(1, 10, df.shape[0])<br/>df["CUSTOMERNAME"] = np.random.choice(list(customers), len(df))<br/>df["CUSTOMERADDRESS"] = df['CUSTOMERNAME'].map(customers)<br/>df.set_index("ORDERNUMBER")</span><span id="fc44" class="lv lw it mu b gy nc mz l na nb">#create the ORDERS table, selecting the first 4columns<br/>df_orders = df.iloc[:, : 4]</span><span id="200b" class="lv lw it mu b gy nc mz l na nb">#Create the CUSTOMERS table by selecting the last columns and indexing by unique customers<br/>df_unique_customers = df.iloc[:, 4:]<br/>df_unique_customers = df_unique_customers.groupby("CUSTOMERNAME").first()</span><span id="1243" class="lv lw it mu b gy nc mz l na nb">#Create a duplicate of the customer dataframe, but indexed from 0 instead of by customer (for testing)<br/>df_unique_customers_unindexed = df_unique_customers.reset_index()</span></pre><p id="d261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到，我还创建了一个客户数据框的副本，它的索引为0，而不是用于测试目的的客户索引。以下是我们的数据框的示例！(你也可以在这里查看完整的笔记本<a class="ae ky" href="https://github.com/jeremydiba/pandas-merge-sample/blob/main/merge_join_test.ipynb" rel="noopener ugc nofollow" target="_blank"/>)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3f215f3716245ecbec1191d2f698ddd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j167LSM9GG0pcMAb-2_rKQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按作者排序数据框|图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b2c3e23cfac6c5eb193e6860aa9c5d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V3Os2c3Jpt70sl0im0QtYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户数据框|作者图片</p></figure><h2 id="9d4d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">合并与连接</h2><p id="d129" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">除了语法之外，表面上的差异并不显著。<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.join.html" rel="noopener ugc nofollow" target="_blank"> Join </a>充当连接两个数据帧的方法，但它只对正确数据帧的索引起作用。对于左侧数据框，可以选择左侧索引或列(在我们的示例中我们需要使用列，因为客户在我们的订单数据框中不是唯一的)。</p><p id="9d99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html" rel="noopener ugc nofollow" target="_blank">合并</a>本质上是一样的东西，但是更加灵活。可以在任一数据框中指定用于连接的任何列或索引。本质上，就语法而言，merge只是一个更易于使用的连接。但这并不一定适用于他们的表现。</p><p id="877e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我想执行一个左连接，左边是订单数据框，右边是客户数据框。我能够用1种方式用Join正确地做到这一点，用4种方式用merge做到这一点。如果您不熟悉不同类型的联接之间的区别，<a class="ae ky" href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener ugc nofollow" target="_blank">这里有一个复习工具</a>！(或者，如果你正在寻找一个完整的课程，<a class="ae ky" href="https://datasciencedojo.com/python-for-data-science/?ref=jdibattista3" rel="noopener ugc nofollow" target="_blank">试试这个</a></p><p id="5f33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这些不同连接的熟练程度，我将在一个循环中运行每个连接10000次，以获得一个连接的平均成本。</p><h2 id="1022" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">执行左连接/合并的5种方式</h2><p id="f892" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我将从几个合并开始，因为这是非常容易产生低效查询的地方</p><h2 id="5ef6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">错误的合并方式—在非索引列上合并</h2><ul class=""><li id="6480" class="nf ng it lb b lc mo lf mp li nh lm ni lq nj lu nk nl nm nn bi translated">df_combined = df_orders。<strong class="lb iu">合并</strong>(df _ unique _ customers _ un indexed，how='left '，on="CUSTOMERNAME ")</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5aa7" class="lv lw it mu b gy my mz l na nb">Time for 10000 joins<br/>18.28343653678894<br/>average time per join<br/>0.001828343653678894</span></pre><ul class=""><li id="deb0" class="nf ng it lb b lc ld lf lg li no lm np lq nq lu nk nl nm nn bi translated">df_combined = df_orders。<strong class="lb iu">合并</strong>(df _ unique _ customers _ un indexed，how='left '，left_on="CUSTOMERNAME "，right_on="CUSTOMERNAME ")</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="8e65" class="lv lw it mu b gy my mz l na nb">Time for 10000 joins<br/>18.183201789855957<br/>average time per join<br/>0.0018183201789855957</span></pre><p id="7947" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以上两种方法都从每个表中选择列CUSTOMERNAME。这是相当简单的，我假设大多数人使用合并，以及人们如何在合并时失去很多速度。这些通常是等价的查询，底部给出了相当一致的1–2%的提升。</p><p id="cfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据一般经验，使用非索引列确实会导致相当大的速度损失，我们将在下面的合并中解决这个问题。</p><h2 id="dc1a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">莫名其妙的次优方式</h2><ul class=""><li id="fa22" class="nf ng it lb b lc mo lf mp li nh lm ni lq nj lu nk nl nm nn bi translated">df_combined = df_orders。<strong class="lb iu">合并</strong> (df_unique_customers，how='left '，on="CUSTOMERNAME ")</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2c78" class="lv lw it mu b gy my mz l na nb">Time for 10000 joins<br/>16.125476121902466<br/>average time per join<br/>0.0016125476121902466</span></pre><p id="6656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过简单地为我们计划加入的列设置索引(可以使用set_index(“客户名称”)来完成)，我们看到速度比没有索引的列立即提高了10–15%。</p><p id="e14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，因为merge必须推断“on”是指列还是索引，所以这仍然不是最理想的，而且我和大多数人都认为，<strong class="lb iu">从来不知道</strong>！我在任何地方都没有看到这种解释，通过避免这种情况，您可以创建下面的最佳查询！</p><h2 id="a868" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">最快的方法</h2><ul class=""><li id="2c0c" class="nf ng it lb b lc mo lf mp li nh lm ni lq nj lu nk nl nm nn bi translated">df_combined = df_orders。<strong class="lb iu">合并</strong> (df_unique_customers，how='left '，left_on="CUSTOMERNAME "，right_index=True)</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ede5" class="lv lw it mu b gy my mz l na nb">Time for 10000 joins<br/>14.555766582489014<br/>average time per join<br/>0.0014555766582489014</span></pre><ul class=""><li id="11f9" class="nf ng it lb b lc ld lf lg li no lm np lq nq lu nk nl nm nn bi translated">df_combined = df_orders。<strong class="lb iu">加入</strong> (df_unique_customers，on="CUSTOMERNAME "，how="left ")</li></ul><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="a8ae" class="lv lw it mu b gy my mz l na nb">Time for 10000 joins<br/>14.551718711853027<br/>average time per join<br/>0.0014551718711853028</span></pre><p id="4627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们得出了正确且最快的编写连接的方法。事实证明，如果语法是最优的，那么join的性能总是很好，merge的性能几乎完全相同。编写完美的查询比没有索引的查询提高了20%以上，比正确索引但编写糟糕的查询提高了10%。</p><h2 id="208b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="6ecb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您可以编写一个join语句，我建议您这样做，因为它几乎可以保证最佳的性能。</p><p id="ac30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并不意味着合并没有用。当左右两列都不唯一，因此不能作为索引时，可以使用Merge。只要满足以下条件，合并也和联接一样有效:</p><ol class=""><li id="09d5" class="nf ng it lb b lc ld lf lg li no lm np lq nq lu nr nl nm nn bi translated">如果可能的话，在索引上进行合并</li><li id="5474" class="nf ng it lb b lc ns lf nt li nu lm nv lq nw lu nr nl nm nn bi translated">避免了“on”参数，取而代之的是，使用关键字left_on、left_index、right_on和right_index(如果适用)显式地<em class="nx">声明要合并的两列。</em></li></ol><p id="9fa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇短文能帮助你加快加入熊猫的步伐！如果您认为需要回来参考，请务必保存/标记该故事！如果你喜欢这篇文章，欢迎<a class="ae ky" href="https://jerdibattista.medium.com/" rel="noopener">关注我</a>，阅读我写的更多内容。我倾向于每个月深入一个主题一次，这通常涉及数据科学技巧、新的包或ML空间中我认为需要更好解释的任何东西！</p><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/the-most-efficient-if-elif-else-in-pandas-d4a7d4502d50"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">熊猫中效率最高的if-elif-else</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">以及为什么你写的效率很低</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>