<html>
<head>
<title>Data Retrieval with SQL — Tutorial and Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SQL 进行数据检索—教程和示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-retrieval-with-sql-tutorial-examples-a4b6b4b8f816#2022-11-30">https://towardsdatascience.com/data-retrieval-with-sql-tutorial-examples-a4b6b4b8f816#2022-11-30</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="c409" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">带示例和备忘单的 SQL 教程</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/691f910d66e7c66062894246dd81b6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*os8m-3wjelJheTBEMzsJSw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">一个组织良好的图书馆。E 2 </p></figure><p id="6eb3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们都听说过各种公司，如谷歌、脸书和苹果，如何通过各自的网站、服务和产品收集客户信息和活动。现在，让我们假设其中一家公司的数据科学家想要查看存储的客户数据，以找到业务问题的解决方案。在开始分析和建模之前，科学家将使用结构化查询语言或 SQL(类似于“sequel”)来检索存储的数据。在这篇文章中，我们将回顾什么是 SQL，并通过例子学习如何使用它。</p><p id="7ed5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我关于<a class="ae kz" href="https://medium.com/@fmnobar/data-scientist-role-requirements-bbae1f85d4d5" rel="noopener">亚马逊数据科学家角色要求的主要帖子</a>中，我将“数据检索”确定为每个数据科学家都应该具备的首要能力，并将在面试过程中接受测试。作为一名科学家，我发现自己在数据检索和数据分析/建模之间来回穿梭，因此我认为数据检索是我们数据科学家候选人的一项关键能力。</p><p id="3d5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将通过附带的脚本来介绍数据科学家日常工作中使用的一些最常见的 SQL 函数，这样您也可以在我们一起解决问题的过程中跟随并继续学习。这一部分以 16 个问题和答案的形式出现，我在回答中进一步解释了每个主题。我建议您跟随并尝试编写自己的查询，以最大限度地学习。最后，我还将提供我在学习 SQL 时开发的备忘单。</p><p id="67ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们开始吧！</p><div class="lw lx gq gs ly lz"><a href="https://medium.com/@fmnobar/membership" rel="noopener follow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">加入我的介绍链接-法扎德 Mahmoodinobar 媒体</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">阅读法扎德(以及媒体上的其他作家)的每一个故事。你的会员费直接支持法扎德和其他…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="64d0" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">先决条件</h1><p id="f135" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">为了使用您可以理解的真实示例，首先我们将创建两个名为“people”和“salary”的临时表，然后这两个临时表将用于余下的练习。这种方法的好处是，您可以复制和粘贴表创建部分，然后按照以下步骤进行练习，以最大限度地增加学习机会。请注意，此时您不需要理解表格创建部分的工作，因为这只是为问答部分创建我们需要的内容。</p><p id="6318" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请将下面的内容复制并粘贴到您最喜欢的 SQL 工具中，然后运行。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="9e44" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">数据科学家最常用的 SQL 概念</h1><h2 id="8fa9" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">1.基础</h2><p id="3d75" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">现在让我们看看我们在上面的两个临时表中创建了什么。我将把这些框成问题和答案，这样你也可以先尝试解决每个问题，然后再看我提供的答案。我提供的只是解决这些问题的一种方法——通常有不止一种正确的方法可以得到相同的答案。</p><p id="baf0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q1:检索</strong> <code class="fe og oh oi oj b"><strong class="lc iv">people</strong></code> <strong class="lc iv">表中所有可用的数据。</strong></p><p id="d87e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A1:</p><p id="f445" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一般来说，我将首先提供答案，然后解释发生了什么以及不同的 SQL 概念是如何工作的，无论是在同一个问题下还是在下一个问题下。例如，Q2 将解释在 Q1 发生了什么。</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="2546" class="oo mw iu oj b be op oq l or os">SELECT<br/> *<br/>FROM<br/> people;</span></pre><p id="acb5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/e77e7ae9bac8f9edb059706ba958de0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T1PBOE2RAqyLW2QJ.png"/></div></div></figure><p id="fe91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了将来参考，这是表<code class="fe og oh oi oj b">salary</code>的样子，使用如下:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="ec8b" class="oo mw iu oj b be op oq l or os">SELECT<br/> *<br/>FROM<br/> salary;</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ou"><img src="../Images/ce7b9c28efb8d8baf46f5b4cd4a6701b.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*NGzOiJVTEJZlpvky.png"/></div></figure><p id="76bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="ov">专业提示:</em> </strong>此时，我建议您给这两个表拍个快照——我在下面添加了如何拍快照的说明。在这篇文章中，你会想要回头参考这些表来编写查询，然后上下滚动，发现这两个表并不有趣。为了方便起见，我提供了如何在 Mac 和 Windows 上拍摄快照的说明:</p><ul class=""><li id="5895" class="ow ox iu lc b ld le lg lh lj oy ln oz lr pa lv pb pc pd pe bi translated"><strong class="lc iv"> Mac 用户— </strong>同时按住这三个键:Shift、Command 和 4，然后选择要拍摄快照的区域。如果您不希望手动选择快照区域，同时按下 Shift、Command 和 3 将打印屏幕。</li><li id="d598" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv pb pc pd pe bi translated"><strong class="lc iv"> Windows 用户— </strong>同时按下这三个键:Windows 键+ Shift + S，然后使用 Snip 和 Sketch 工具创建一个快照(我在 Mac 上，所以这是基于谷歌搜索的—希望它能起作用)。</li></ul><p id="cd5d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Q2:解释一下在之前的查询中发生了什么。</p><p id="eaae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A2: <code class="fe og oh oi oj b">SELECT</code>语句用于从给定的数据库(即表)中选择数据。<code class="fe og oh oi oj b">FROM</code>用于指示应该从哪个数据库中选择数据(本例中为“people”)。最后<code class="fe og oh oi oj b">*</code>简单地说从数据库中选择一切。</p><p id="3939" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q3:仅检索以下各列的数据:</strong> <code class="fe og oh oi oj b"><strong class="lc iv">['name', 'gender', 'job_title']</strong></code> <strong class="lc iv">。</strong></p><p id="16df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A3:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="4065" class="oo mw iu oj b be op oq l or os">SELECT<br/> name,<br/> gender,<br/> job_title<br/>FROM<br/> people;</span></pre><p id="314b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pk"><img src="../Images/ff9eaab59183ae0e72f120454dd04607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/0*TL5OHz79hY0auI_j.png"/></div></figure><p id="2eb6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一步很简单——我们可以明确指出要选择哪些列。</p><h2 id="856e" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">2.过滤</h2><p id="9fe7" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">哪些人在纽约工作？</p><p id="7902" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A4:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="580e" class="oo mw iu oj b be op oq l or os">SELECT<br/> name<br/>FROM<br/> people<br/>WHERE<br/> location = 'new_york';</span></pre><p id="a32a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pl"><img src="../Images/fa41c8bfea300c697918e751e5c226e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/0*CUGX2X4R6GfpQP4D.png"/></div></figure><p id="207f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如本例所示，我们可以使用<code class="fe og oh oi oj b">WHERE</code>过滤结果。</p><h2 id="8325" class="nu mw iu bd mx nv nw dn nb nx ny dp nf lj nz oa nh ln ob oc nj lr od oe nl of bi translated">3.聚集</h2><p id="2fc5" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">聚合帮助我们对数据进行一些基本的分析。例子包括<code class="fe og oh oi oj b">COUNT()</code>、<code class="fe og oh oi oj b">MAX()</code>、<code class="fe og oh oi oj b">MIN()</code>、<code class="fe og oh oi oj b">AVG()</code>、<code class="fe og oh oi oj b">SUM()</code>。</p><p id="257d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有多少人住在西雅图或菲尼克斯？</p><p id="154d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A5:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="f579" class="oo mw iu oj b be op oq l or os">SELECT<br/> count(person_id)<br/>FROM<br/> people<br/>WHERE<br/> location IN ('seattle', 'phoenix');</span></pre><p id="977e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pm"><img src="../Images/23c907aa5db7861c5bbfef700f42bb88.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/0*Jzwj12meEAGQ5OpR.png"/></div></figure><p id="8d2e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每个城市有多少人居住？</p><p id="47c8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A6:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="3b94" class="oo mw iu oj b be op oq l or os">SELECT<br/> location,<br/> count(person_id)<br/>FROM<br/> people<br/>GROUP BY<br/> location;</span></pre><p id="d9de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pn"><img src="../Images/5771c3d8c70692878fff2e31c1604552.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/0*7VmTLuEDuPoamkPu.png"/></div></figure><p id="0dff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从上一个问题中我们已经知道了<code class="fe og oh oi oj b">COUNT()</code>的作用，但是现在在查询的末尾还有一个新概念。<code class="fe og oh oi oj b">GROUP BY</code>语句将具有相同值的数据行组合在一起，用于聚合函数，如<code class="fe og oh oi oj b">COUNT()</code>、<code class="fe og oh oi oj b">MAX()</code>、<code class="fe og oh oi oj b">MIN()</code>、<code class="fe og oh oi oj b">AVG()</code>和<code class="fe og oh oi oj b">SUM()</code>。</p><p id="9582" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">凤凰城和纽约的总工资是多少？</p><p id="8340" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A7:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="7cf5" class="oo mw iu oj b be op oq l or os">SELECT<br/> location,<br/> SUM(salary) AS total_salary<br/>FROM<br/> people<br/>WHERE<br/> location = 'phoenix'<br/> OR location = 'new_york'<br/>GROUP BY<br/> location;</span></pre><p id="98c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj po"><img src="../Images/459a115797dfd3ff051ef076b78b1e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/0*_L1CiG_KX20kNz8d.png"/></div></figure><p id="1aaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个例子中有两个新的知识。首先，在这个例子中，我们给<code class="fe og oh oi oj b">SUM()</code>列分配了一个别名，结果列现在被命名为<code class="fe og oh oi oj b">total_salary</code>。如果我们没有这样做，该列将如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj po"><img src="../Images/2eacbbb0355d9d4b26dc081fb201e5d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/0*ST-UBc47Fp6hweFl.png"/></div></figure><p id="6003" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二次学习是另一种方法。注意在<code class="fe og oh oi oj b">WHERE</code>中，我们使用的是<code class="fe og oh oi oj b">OR</code>，这决定了<code class="fe og oh oi oj b">location</code>可以是<code class="fe og oh oi oj b">phoenix</code>也可以是<code class="fe og oh oi oj b">new_york</code>。或者，我们可以使用<code class="fe og oh oi oj b">location IN ('phoenix', 'new_york')</code>，类似于我们在 Q5 中使用的方法。这不会改变结果，只是一种替代方法。</p><h1 id="1d34" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">4.连接</h1><p id="c672" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">这是最有用的特性之一。当试图理解查询时，它有助于可视化数据。让我们先看一个例子，然后我会解释发生了什么。</p><p id="fd5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q8:检索个人姓名、他们的位置和薪水，以及每个位置的平均薪水。</strong></p><p id="1323" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">回答 8:请注意，这是一个我们以前没有解决过的新型问题。个人姓名、工作地点及其工资见表<code class="fe og oh oi oj b">people</code>，而按工作地点划分的平均工资见表<code class="fe og oh oi oj b">salary</code>。我们需要的是将这两个表<code class="fe og oh oi oj b">JOIN</code>在一起，这是可能的，因为这两个表有共同的城市名称(尽管列在<code class="fe og oh oi oj b">people</code>中被命名为<code class="fe og oh oi oj b">location</code>，在<code class="fe og oh oi oj b">salary</code>中被命名为<code class="fe og oh oi oj b">city</code>)。我们的结构如下:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="d721" class="oo mw iu oj b be op oq l or os">SELECT<br/> p.name,<br/> p.location,<br/> p.salary,<br/> s.average_salary<br/>FROM<br/> people p<br/> LEFT JOIN salary s ON p.location = s.city;</span></pre><p id="e1fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pu"><img src="../Images/b0f942f442889cc7b3e3b770a1265c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*U7QmIeu9kHRSqztb.png"/></div></figure><p id="8fac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么到底发生了什么？让我们更仔细地看看联接:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="29ba" class="oo mw iu oj b be op oq l or os">FROM<br/> people p<br/> LEFT JOIN salary s ON p.location = s.city</span></pre><p id="b4c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面说看表<code class="fe og oh oi oj b">people</code>然后将其连接到表<code class="fe og oh oi oj b">salary</code>。然后，我们需要指出每个表中共享相同值的列(想象一下，只有在这两个特定的列中有公共值时，才把这两个表缝合在一起)。具有相互值的列是来自<code class="fe og oh oi oj b">people</code>的<code class="fe og oh oi oj b">location</code>和来自<code class="fe og oh oi oj b">salary</code>的<code class="fe og oh oi oj b">city</code>。最后，我们在这里使用别名的概念。例如，表<code class="fe og oh oi oj b">people</code>现在的别名是<code class="fe og oh oi oj b">p</code>，而表<code class="fe og oh oi oj b">salary</code>的别名是<code class="fe og oh oi oj b">s</code>。当我们想要从<code class="fe og oh oi oj b">people</code>中指示列<code class="fe og oh oi oj b">location</code>时，我们可以将其指示为<code class="fe og oh oi oj b">people.location</code>或<code class="fe og oh oi oj b">p.location</code>。这同样适用于我们如何将列<code class="fe og oh oi oj b">city</code>从<code class="fe og oh oi oj b">salary</code>表示为<code class="fe og oh oi oj b">s.city</code>。注意结构总是如<code class="fe og oh oi oj b">table_name.column_name</code>所示。最后，我们在这个例子中使用了一个<code class="fe og oh oi oj b">LEFT JOIN</code>。下面我将讨论这意味着什么，以及还有什么其他方式来连接表。</p><p id="0ce9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如上所述，我们在这个例子中使用了一个<code class="fe og oh oi oj b">LEFT JOIN</code>。在思考<code class="fe og oh oi oj b">JOIN</code>如何工作时，记住下面的图片是有帮助的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pv"><img src="../Images/7ecc93b369b54bb6666e5b4c08d77cba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9hdCUHIdw5oemqFh.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">连接的可视化(由作者创建)</p></figure><p id="a078" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是一些最常见的<code class="fe og oh oi oj b">JOIN</code>类型:</p><ul class=""><li id="1ce0" class="ow ox iu lc b ld le lg lh lj oy ln oz lr pa lv pb pc pd pe bi translated"><code class="fe og oh oi oj b">JOIN</code>或<code class="fe og oh oi oj b">INNER JOIN</code>:返回左表和右表中有匹配值的数据。</li><li id="ec5d" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv pb pc pd pe bi translated"><code class="fe og oh oi oj b">LEFT JOIN</code>或<code class="fe og oh oi oj b">LEFT OUTER JOIN</code>:返回左表数据和右表所有匹配的数据。</li><li id="49a1" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv pb pc pd pe bi translated"><code class="fe og oh oi oj b">RIGHT JOIN</code>或<code class="fe og oh oi oj b">RIGHT OUTER JOIN</code>:这是<code class="fe og oh oi oj b">LEFT JOIN</code>的反面。它返回右表中的数据和左表中所有匹配的数据。</li><li id="93b2" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv pb pc pd pe bi translated"><code class="fe og oh oi oj b">FULL JOIN</code>或<code class="fe og oh oi oj b">FULL OUTER JOIN</code>:当左表或右表匹配时，返回左表或右表的所有数据</li></ul><h1 id="2193" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">5.条件式</h1><p id="0dde" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><strong class="lc iv"> Q9:在</strong> <code class="fe og oh oi oj b"><strong class="lc iv">people</strong></code> <strong class="lc iv">中创建一个新列，将职位细分为技术和非技术。只返回姓名、职位名称，新的类别命名为</strong> <code class="fe og oh oi oj b"><strong class="lc iv">job_group</strong></code> <strong class="lc iv">和工资。</strong></p><p id="db03" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A9:为了回答这个问题，首先我们需要使用以下查询来查看<code class="fe og oh oi oj b">people</code>中有哪些独特的职位:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="6b00" class="oo mw iu oj b be op oq l or os">SELECT<br/> DISTINCT job_title<br/>FROM<br/> people;</span></pre><p id="88b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，<code class="fe og oh oi oj b">DISTINCT</code>是添加到<code class="fe og oh oi oj b">SELECT</code>中的语句，只返回该列中的唯一值，如下面的结果所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pw"><img src="../Images/ecc5047ba927ae4bd114795682f9f17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/0*lsrHOCMDRQsB9Uzk.png"/></div></figure><p id="b7b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们已经知道了现有的职位名称，我们可以按照指示将它们分为技术和非技术。在本练习中，使用您的最佳判断来确定什么是技术角色，什么是非技术角色，重要的是学习如何在查询中实现此逻辑。比如<code class="fe og oh oi oj b">financial_analyst</code>是非技术角色，而<code class="fe og oh oi oj b">data_scientist</code>是技术角色。以下查询就是这样做的:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="e2b7" class="oo mw iu oj b be op oq l or os">SELECT<br/> name,<br/> job_title,<br/> CASE<br/>  WHEN job_title IN ('software_developer', 'data_scientist') THEN 'tech'<br/>  WHEN job_title IN ('financial_analyst', 'physician') THEN 'non-tech'<br/>  ELSE job_title<br/> END AS job_group,<br/> salary<br/>FROM<br/> people;</span></pre><p id="4d8c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj px"><img src="../Images/b78b26517d175758a5d7b276bfca3c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/0*lwnT6A8FoqeHWJ69.png"/></div></figure><p id="b7cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过更仔细地看我们为这个问题所做的来讨论一下<code class="fe og oh oi oj b">CASE</code>表达式是如何工作的:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="a3f3" class="oo mw iu oj b be op oq l or os">CASE<br/>  WHEN job_title IN ('software_developer', 'data_scientist') THEN 'tech'<br/>  WHEN job_title IN ('financial_analyst', 'physician') THEN 'non-tech'<br/>  ELSE job_title<br/> END AS job_group,</span></pre><p id="4695" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了实现这个逻辑，我们首先从<code class="fe og oh oi oj b">CASE</code>表达式开始，然后使用<code class="fe og oh oi oj b">WHEN</code>确定条件，例如:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="d614" class="oo mw iu oj b be op oq l or os">WHEN job_title IN ('software_developer', 'data_scientist') THEN 'tech'</span></pre><p id="c8b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的脚本首先查看列<code class="fe og oh oi oj b">job_title</code>，如果任意行的该列的值为<code class="fe og oh oi oj b">software_developer</code>或<code class="fe og oh oi oj b">data_scientist</code>，则输出<code class="fe og oh oi oj b">tech</code>。同样的逻辑也适用于<code class="fe og oh oi oj b">non-tech</code>类别。</p><p id="db26" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后就是<code class="fe og oh oi oj b">ELSE job_title</code>。该子句说明，如果在上面的<code class="fe og oh oi oj b">WHEN</code>条件下遇到了列中没有的值，则返回列<code class="fe og oh oi oj b">job_title</code>中存在的值。例如，如果我们在列<code class="fe og oh oi oj b">job_title</code>中有一行的值为<code class="fe og oh oi oj b">chef</code>，因为<code class="fe og oh oi oj b">chef</code>不在我们包含在<code class="fe og oh oi oj b">WHEN</code>条件中的那些条件中(即<code class="fe og oh oi oj b">software_developer</code>、<code class="fe og oh oi oj b">data_scientist</code>、<code class="fe og oh oi oj b">financial_analyst</code>和<code class="fe og oh oi oj b">physician</code>)，那么该子句将返回列<code class="fe og oh oi oj b">job_title</code>中的原始值，即<code class="fe og oh oi oj b">chef</code>。</p><p id="efda" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">脚本的最后一部分是<code class="fe og oh oi oj b">END AS job_group</code>。<code class="fe og oh oi oj b">CASE</code>表达式以<code class="fe og oh oi oj b">END</code>结束，而<code class="fe og oh oi oj b">AS job_group</code>是给结果列的别名。这就是在结果表中将列命名为<code class="fe og oh oi oj b">job_group</code>的原因。</p><blockquote class="py pz qa"><p id="c78d" class="la lb ov lc b ld le jv lf lg lh jy li qb lk ll lm qc lo lp lq qd ls lt lu lv in bi translated"><strong class="lc iv"> Pro 提示:</strong>从<code class="fe og oh oi oj b">WHEN</code>开始的条件语句的顺序很重要。一旦条件为真，它将停止读取其余条件并返回结果。如果不满足任何条件，它将返回<code class="fe og oh oi oj b">ELSE</code>子句中的值。</p></blockquote><p id="7e49" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q10:哪个</strong> <code class="fe og oh oi oj b"><strong class="lc iv">job_group</strong></code> <strong class="lc iv">平均赚钱多？将结果从最高的</strong> <code class="fe og oh oi oj b"><strong class="lc iv">job_group</strong></code>到最低的<strong class="lc iv">排序。</strong></p><p id="66d8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A10:我会用两种方法来回答这个问题，每种方法都会引入新的概念。首先，我将介绍一种方法来展示如何在查询的输出中直接使用<code class="fe og oh oi oj b">FROM</code>，然后我将介绍一种不同的方法来演示<code class="fe og oh oi oj b">WITH</code>子句的应用。</p><p id="30f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="ov">方法 1: </em> </strong></p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="a4c1" class="oo mw iu oj b be op oq l or os">SELECT<br/> job_group,<br/> AVG(salary) AS average_salary<br/>FROM<br/> (<br/>  SELECT<br/>   person_id,<br/>   CASE<br/>    WHEN job_title IN ('software_developer', 'data_scientist') THEN 'tech'<br/>    WHEN job_title IN ('financial_analyst', 'physician') THEN 'non-tech'<br/>    ELSE job_title<br/>   END AS job_group,<br/>   salary<br/>  FROM<br/>   people<br/> )<br/>GROUP BY<br/> job_group<br/>ORDER BY<br/> average_salary DESC;</span></pre><p id="3f29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qe"><img src="../Images/6807a528f0687dfeb582ed3488db17cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*u0_7adRu4GFt44QR.png"/></div></figure><p id="f2e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么到底发生了什么？过去我们总是在<code class="fe og oh oi oj b">FROM</code>后面包含一个表名，但是这里的新概念是我们也可以包含一个内部查询来代替表名。首先运行<code class="fe og oh oi oj b">FROM</code>之后的内部查询，然后将结果用作临时表，从外部查询中选择数据。</p><p id="0798" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="ov">方法二:</em> </strong></p><p id="4691" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将首先介绍这种方法中使用的查询，然后解释查询中的每个步骤。让我们首先从查询开始:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="174d" class="oo mw iu oj b be op oq l or os">WITH count_table AS(<br/> SELECT<br/>  CASE<br/>   WHEN job_title IN ('software_developer', 'data_scientist') THEN 'tech'<br/>   WHEN job_title IN ('financial_analyst', 'physician') THEN 'non-tech'<br/>   ELSE job_title<br/>  END AS job_group,<br/>  count(person_id) as total_count<br/> FROM<br/>  people<br/> GROUP BY<br/>  1<br/>),<br/>total_salary_table AS(<br/> SELECT<br/>  CASE<br/>   WHEN job_title IN ('software_developer', 'data_scientist') THEN 'tech'<br/>   WHEN job_title IN ('financial_analyst', 'physician') THEN 'non-tech'<br/>   ELSE job_title<br/>  END AS job_group,<br/>  SUM(salary) as total_salary<br/> FROM<br/>  people<br/> GROUP BY<br/>  1<br/>)<br/>SELECT<br/> ct.job_group,<br/> tst.total_salary / ct.total_count as average_salary<br/>FROM<br/> count_table ct<br/> INNER JOIN total_salary_table tst ON ct.job_group = tst.job_group<br/>ORDER BY<br/> average_salary DESC;</span></pre><p id="0f65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们更仔细地看看发生了什么。</p><p id="6450" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们将使用<code class="fe og oh oi oj b">WITH</code>子句创建一个名为<code class="fe og oh oi oj b">count_table</code>的临时表。这个临时表格显示了每个<code class="fe og oh oi oj b">job_group</code>内有多少个人，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qf"><img src="../Images/5dc0ed2362c090e7f4e7c6ce758629cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/0*52pCVjGUiD79G_pY.png"/></div></figure><p id="38e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，我们将创建第二个名为<code class="fe og oh oi oj b">total_salary_table</code>的临时表，显示每个<code class="fe og oh oi oj b">job_group</code>的总工资，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qg"><img src="../Images/d22011b7be02335db6c2b9af53ccd768.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/0*JqCM7aJHQZeWYCFa.png"/></div></figure><p id="bdc7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们有了这两个表，我们可以将它们连接在一起，找出每个<code class="fe og oh oi oj b">job_group</code>的平均工资，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qe"><img src="../Images/9135d427ef8281d78bc43249a534446a.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/0*5R4Yjp0GC9Wnrdi7.png"/></div></figure><p id="8186" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里的结果与预期的方法 1 的结果相匹配。</p><h1 id="eec8" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">6.窗口功能</h1><p id="19cd" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">这些功能在最初的时候更难想象，所以如果你不能马上理解，不要失望。浏览几个例子，你会开始更好地理解它们。我们通常在面试中包括这些，所以我建议你理解并练习这些。</p><p id="d427" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">窗口函数通常在一组相关的表格行中执行计算。换句话说，它们在某种程度上类似于带有一些警告的聚合。与聚合不同，窗口函数不会将行组合在一起。这将通过例子变得更加清楚。</p><p id="a9c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">窗口功能的几个例子是:<code class="fe og oh oi oj b">COUNT()</code>、<code class="fe og oh oi oj b">AVG()</code>、<code class="fe og oh oi oj b">SUM()</code>、<code class="fe og oh oi oj b">ROW_NUMBER()</code>、<code class="fe og oh oi oj b">RANK()</code>、<code class="fe og oh oi oj b">DENSE_RANK()</code>、<code class="fe og oh oi oj b">LAG</code>和<code class="fe og oh oi oj b">LEAD</code>，它们的结构如下:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="8fd4" class="oo mw iu oj b be op oq l or os">window_function(column_name) OVER (<br/> PARTITION BY <br/>  column_name<br/> ORDER BY<br/>  column_name ROWS BETWEEN UNBOUNDED PRECEDING<br/>  AND UNBOUNDED FOLLOWING<br/>) AS output_alias;</span></pre><p id="fa7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上面的例子显示了如何构造窗口函数的最常见的元素，但并不是所有的都是必要的。我知道到目前为止这是没有意义的，所以让我们在实践中看看其中的一些，以便更好地理解它们。</p><p id="cb7a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q11:从最高工资到最低工资，按性别创建一个总体工资等级。</strong></p><p id="3c0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A11:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="1283" class="oo mw iu oj b be op oq l or os">SELECT<br/> name,<br/> gender,<br/> salary,<br/> RANK() OVER(<br/>  ORDER BY<br/>   salary DESC<br/> ) AS salary_rank_overall,<br/> RANK() OVER(<br/>  PARTITION BY gender<br/>  ORDER BY<br/>   salary DESC<br/> ) AS salary_rank_by_gender<br/>FROM<br/> people<br/>ORDER BY<br/> salary_rank_overall,<br/> salary_rank_by_gender;</span></pre><p id="753f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qh"><img src="../Images/48c0d79fcdff63fe3baacf0f84882397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gnba1JWnHy9qtYDZ.png"/></div></div></figure><p id="0054" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如您在结果中看到的，使用<code class="fe og oh oi oj b">RANK()</code>窗口功能，我们能够从整体角度以及在每个男性或女性类别中对工资进行排名。在<code class="fe og oh oi oj b">OVER()</code>中，我们指出我们希望通过<code class="fe og oh oi oj b">gender</code>来分解(或“划分”)排名，并通过添加<code class="fe og oh oi oj b">ORDER BY salary DESC</code>从最高工资到最低工资进行排序。</p><p id="60f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q12:创建每个薪金的运行总和(即，第 2 行的总和应为第 1 行+第 2 行，第 3 行的总和应为第 1 行+第 2 行+第 3 行的总和，依此类推)，并按性别、年龄(从年长到年轻)排序。还包括一列显示每一行的总工资。</strong></p><p id="da31" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A12:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="d585" class="oo mw iu oj b be op oq l or os">SELECT<br/> name,<br/> gender,<br/> birth_year,<br/> salary,<br/> SUM(salary) OVER(<br/>  ORDER BY<br/>   birth_year ROWS between UNBOUNDED PRECEDING<br/>   And CURRENT ROW<br/> ) AS running_total_salary_overall,<br/> SUM(salary) OVER(<br/>  PARTITION BY gender<br/>  ORDER BY<br/>   birth_year ROWS between UNBOUNDED PRECEDING<br/>   And CURRENT ROW<br/> ) AS running_total_salary_by_gender,<br/> SUM(salary) OVER(<br/>  ORDER BY<br/>   birth_year ROWS between UNBOUNDED PRECEDING<br/>   And UNBOUNDED FOLLOWING<br/> ) AS total_salary<br/>FROM<br/> people<br/>ORDER BY<br/> running_total_salary_overall,<br/> running_total_salary_by_gender;</span></pre><p id="91fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qi"><img src="../Images/ffa0904d86776a7d9e138a12d8444d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y8xvAQWBVKWbNL0S.png"/></div></div></figure><p id="7970" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦你仔细阅读了下面的解释并与结果进行了比较，我相信你也会体会到窗口函数的强大。</p><p id="ed56" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这份报告使用了一些新的陈述，所以让我们更仔细地看一下。我们先来看以下内容:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="2e8b" class="oo mw iu oj b be op oq l or os">SUM(salary) OVER(<br/>  ORDER BY<br/>   birth_year ROWS between UNBOUNDED PRECEDING<br/>   And CURRENT ROW<br/> ) AS running_total_salary_overall,</span></pre><p id="77ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe og oh oi oj b">SUM(salary)</code>只是简单地把工资加起来，但是工资应该如何加起来才是更有趣的部分，在<code class="fe og oh oi oj b">OVER()</code>语句中有说明。首先，薪水按照个人出生年份从低到高排序，如<code class="fe og oh oi oj b">ORDER BY birth_year</code>(没有<code class="fe og oh oi oj b">DESC</code>告诉我们是升序)。然后<code class="fe og oh oi oj b">ROWS</code>告诉如何将<code class="fe og oh oi oj b">SUM()</code>应用于这些数据行。在这种情况下，求和应用于每行(<code class="fe og oh oi oj b">UNBOUNDED PRECEDING</code>)之前的所有行，包括行本身(<code class="fe og oh oi oj b">CURRENT ROW</code>)。</p><p id="e58f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，如果我们希望每一行的总和包括特定行之前和之后的所有内容，会怎么样呢？这可以通过以下方式实现:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="a069" class="oo mw iu oj b be op oq l or os">ROWS between UNBOUNDED PRECEDING<br/>   And UNBOUNDED FOLLOWING</span></pre><p id="ea9f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该结构用于计算查询的以下部分中的<code class="fe og oh oi oj b">total_salary</code>，您可以在结果部分中看到:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="e02f" class="oo mw iu oj b be op oq l or os">SUM(salary) OVER(<br/>  ORDER BY<br/>   birth_year ROWS between UNBOUNDED PRECEDING<br/>   And UNBOUNDED FOLLOWING<br/> ) AS total_salary</span></pre><p id="812e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为对于每一行，我们希望得到给定行之前和之后所有行的总和，本质上我们要求查看在每一行的<code class="fe og oh oi oj b">total_salary</code>下显示的该列的总和，这对于每一行都是相同的<code class="fe og oh oi oj b">868,000</code>值。</p><h1 id="f5fd" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">8.杂项—联合运算符、空处理和日期管理</h1><p id="06ac" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">到目前为止，我们已经介绍了一些可以帮助您编写自己的查询的更常见的概念。在这一部分，我将涉及一些额外的话题，这些话题也能在面试中帮助你。</p><p id="074a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与上次类似，让我们首先创建两个名为<code class="fe og oh oi oj b">misc_part1</code>和<code class="fe og oh oi oj b">misc_part2</code>的新表，然后浏览概念。现在，只需复制、粘贴并运行下面的脚本，为练习的这一部分创建临时表。</p><p id="9e4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="ov">加分项(可选):</em> </strong>既然你对不同的 SQL 概念已经比较熟悉了，那就看看你复制粘贴的内容，看你能不能按照逻辑来。您可以看到，我们首先定义一个表，然后指定表中的列以及与每列相关联的数据类型，接着为每列添加值(以一行值的格式)。就是这样！现在，您可以创建自己的临时表，并开始从中检索数据！</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="eeca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们看看这些表是什么样子的。我将用下面的例子来看一下<code class="fe og oh oi oj b">mist_part1</code>:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="487a" class="oo mw iu oj b be op oq l or os">SELECT<br/> *<br/>FROM<br/> misc_part1:</span></pre><p id="3773" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qj"><img src="../Images/d34adba554fa43ff11e6fa4bd29ac202.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*eZGrV80tOCi8QPQC.png"/></div></figure><p id="a426" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后会用下面的来看<code class="fe og oh oi oj b">misc_part2</code>:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="8456" class="oo mw iu oj b be op oq l or os">SELECT<br/> *<br/>FROM<br/> misc_part2;</span></pre><p id="1afe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qj"><img src="../Images/053ce58e8cb17b1e351718f59a28fd2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*aivo6NodKX-8PuYA.png"/></div></figure><p id="9ed8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以把这两个表想象成一些关于客户最后一次被联系的营销数据，以及他们是如何被联系的，比如通过电子邮件、电话等等。光看数据就有三个观察结果:</p><ol class=""><li id="4a4c" class="ow ox iu lc b ld le lg lh lj oy ln oz lr pa lv qk pc pd pe bi translated">这两个表有相同的列名，所以作为我们练习的一部分，也许有机会将它们合并，我们将在<code class="fe og oh oi oj b">UNION</code>下进一步探讨。</li><li id="cbb9" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv qk pc pd pe bi translated">有些值丢失了，这在<code class="fe og oh oi oj b">people</code>和<code class="fe og oh oi oj b">salary</code>表中并不存在。比如看<code class="fe og oh oi oj b">misc_part2</code>，单元格<code class="fe og oh oi oj b">B5</code>和<code class="fe og oh oi oj b">B6</code>都是空的。<code class="fe og oh oi oj b">misc_part1</code>也有一些缺失值。我们将讨论空处理。</li><li id="1bef" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv qk pc pd pe bi translated">两个表都包含一个日期格式列，这是我们在<code class="fe og oh oi oj b">people</code>和<code class="fe og oh oi oj b">salary</code>表中没有的。我们将使用这些值进行一些日期操作。</li></ol><p id="b85c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与上次类似，您可以随意抓取这两个表格以供参考，然后让我们继续使用相同的问答格式来介绍一些新概念。</p><h1 id="d41c" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">8.1.联合运算符</h1><p id="b7c5" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><strong class="lc iv"> Q13:我看到两个表包含相同的列。你能把它们组合成一张桌子吗？按名称对结果进行排序，并确定哪一行属于哪一个表。</strong></p><p id="7a31" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">回答 13:请记住，我们从两个表开始，每个表包含 8 行数据(不包括标题)，因此我们希望合并后的表包含 16 行数据(不包括标题)。</p><p id="096f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这可以使用以下格式的<code class="fe og oh oi oj b">UNION ALL</code>来完成:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="d4ae" class="oo mw iu oj b be op oq l or os">SELECT<br/> *,<br/> 1 AS misc_table_number<br/>FROM<br/> misc_part1<br/>UNION ALL<br/>SELECT<br/> *,<br/> 2 AS misc_table_number<br/>FROM<br/> misc_part2<br/>ORDER BY<br/> name;</span></pre><p id="a8f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ql"><img src="../Images/aed5e8e1df3a1094f3d912423cc475d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/0*4WbDsN6LUZA1wRpt.png"/></div></figure><p id="a63f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果包括我们预期的 16 行数据(不包括标题)。我们来说说发生了什么。</p><p id="af39" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe og oh oi oj b">UNION ALL</code> operator 将来自每个查询的数据堆叠起来。要使其正常工作，需要满足一些条件:</p><ol class=""><li id="7cc1" class="ow ox iu lc b ld le lg lh lj oy ln oz lr pa lv qk pc pd pe bi translated"><code class="fe og oh oi oj b">UNION ALL</code>运算符中的每个<code class="fe og oh oi oj b">SELECT</code>必须具有相同的列数。例如，在我们的练习中，每个表包括 4 列。</li><li id="d64e" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv qk pc pd pe bi translated">每个<code class="fe og oh oi oj b">SELECT</code>语句的对应列必须具有相同的数据类型。例如，两个表中的<code class="fe og oh oi oj b">name</code>都是<code class="fe og oh oi oj b">VARCHAR(30)</code>数据类型，或者两个表中的<code class="fe og oh oi oj b">last_contacted</code>都是<code class="fe og oh oi oj b">DATE</code>数据类型。</li><li id="ddc2" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv qk pc pd pe bi translated">每个<code class="fe og oh oi oj b">SELECT</code>语句的列必须是相同的顺序。换句话说，在我们的示例表中，两个表的顺序应该是<code class="fe og oh oi oj b">name</code>、<code class="fe og oh oi oj b">last_contacted</code>、<code class="fe og oh oi oj b">contact_type</code>、<code class="fe og oh oi oj b">misc_table_number</code>。在我们的例子中也满足了这个条件，这就是我们能够使用<code class="fe og oh oi oj b">UNION ALL</code>的原因。</li></ol><p id="4aa2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> Q14:查看 Q13 的结果，看起来两个表都包含相同的</strong> <code class="fe og oh oi oj b"><strong class="lc iv">david</strong></code> <strong class="lc iv">和</strong> <code class="fe og oh oi oj b"><strong class="lc iv">elizabeth</strong></code> <strong class="lc iv">数据。您能否创建相同的表，但只包含唯一的行(例如，对结果进行重复数据删除)？不需要显示哪些表行属于哪个表行。</strong></p><p id="a351" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A14:这可以通过使用<code class="fe og oh oi oj b">UNION</code>而不是<code class="fe og oh oi oj b">UNION ALL</code>很容易地完成。换句话说，<code class="fe og oh oi oj b">UNION</code>只选择不同的值，而<code class="fe og oh oi oj b">UNION ALL</code>选择所有的值。查询如下所示:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="affe" class="oo mw iu oj b be op oq l or os">SELECT<br/> *<br/>FROM<br/> misc_part1<br/>UNION<br/>SELECT<br/> *<br/>FROM<br/> misc_part2<br/>ORDER BY<br/> name;</span></pre><p id="5e6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qj"><img src="../Images/e7b0a753e8236a53a181403e5aa732d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/0*FTVscCN3C5NqZWah.png"/></div></figure><p id="9172" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正如预期的那样，结果现在只包括不同的行，行的总数现在是 14(不包括标题)，而不是我们在 Q13 中看到的 16。</p><h1 id="205e" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">8.2.零处理</h1><p id="0f67" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><strong class="lc iv"> Q15:创建一个名为</strong> <code class="fe og oh oi oj b"><strong class="lc iv">combined_table</strong></code> <strong class="lc iv">的临时表，其中包含组合表的不同行(类似于 Q14)。在</strong> <code class="fe og oh oi oj b"><strong class="lc iv">last_contacted</strong></code> <strong class="lc iv">值缺失的地方，输入值为</strong> <code class="fe og oh oi oj b"><strong class="lc iv">1901-01-01</strong></code> <strong class="lc iv">。我们还知道，缺少的</strong> <code class="fe og oh oi oj b"><strong class="lc iv">contact_type</strong></code> <strong class="lc iv">是</strong> <code class="fe og oh oi oj b"><strong class="lc iv">phone_call</strong></code> <strong class="lc iv">，所以也要填充它们。</strong></p><p id="6f5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A15:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="e208" class="oo mw iu oj b be op oq l or os">WITH combined_table as (<br/> SELECT<br/>  *<br/> FROM<br/>  misc_part1<br/> UNION<br/> SELECT<br/>  *<br/> FROM<br/>  misc_part2<br/> ORDER BY<br/>  name<br/>)<br/>SELECT<br/> name,<br/> NVL(last_contacted, '1901-01-01') as last_contacted,<br/> COALESCE(contact_type, 'phone_call') AS contact_type<br/>FROM<br/> combined_table;</span></pre><p id="27ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj qm"><img src="../Images/04d7398c814a76f574f5a2aef4dd7fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*aefKxS1KJQCd3dX5.png"/></div></figure><p id="b352" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果正如我们所料，所以让我们谈谈发生了什么。</p><p id="3762" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在这个练习中使用了两个空函数，就我们的目的而言，它们都是相似的。当表达式为空时，它们都返回替代值。我想两个都用来展示，但你可以选择使用任何一个。让我们更仔细地看看它们:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="ddd7" class="oo mw iu oj b be op oq l or os">NVL(last_contacted, '1901-01-01') as last_contacted,<br/>COALESCE(contact_type, 'phone_call') AS contact_type</span></pre><p id="1af2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一个是说当在列<code class="fe og oh oi oj b">last_contacted</code>中遇到 NULL 时，用<code class="fe og oh oi oj b">1901-01-01</code>替换它。类似地，第二个是说当在<code class="fe og oh oi oj b">contact_type</code>列中遇到 NULL 时，用<code class="fe og oh oi oj b">phone_call</code>替换它，如问题中所指示的。</p><p id="67c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="ov">专业提示:</em> </strong>根据 SQL 环境的不同，语句可能略有不同，但概念保持不变。例如，<code class="fe og oh oi oj b">COALESCE()</code>用于 MySQL、SQL Server、Oracle 和 MS Access，而<code class="fe og oh oi oj b">NVL()</code>主要用于 Oracle。</p><h1 id="46ce" class="mv mw iu bd mx my pp na nb nc pq ne nf ka pr kb nh kd ps ke nj kg pt kh nl nm bi translated">8.3.日期管理</h1><p id="35a5" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated"><strong class="lc iv"> Q16:从</strong> <code class="fe og oh oi oj b"><strong class="lc iv">combined_table</strong></code> <strong class="lc iv">开始，为年、季度、月和最后一次联系个人的日期创建单独的列(如果有这样的日期)。</strong></p><p id="b5fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">A16:让我们先看看结构和结果，然后再讨论。</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="3668" class="oo mw iu oj b be op oq l or os">WITH combined_table as (<br/> SELECT<br/>  *<br/> FROM<br/>  misc_part1<br/> UNION<br/> SELECT<br/>  *<br/> FROM<br/>  misc_part2<br/> ORDER BY<br/>  name<br/>)<br/>SELECT<br/> name,<br/> last_contacted,<br/> DATE_PART(year, last_contacted) AS year_contacted,<br/> DATE_PART(quarter, last_contacted) AS quarter_contacted,<br/> DATE_PART(month, last_contacted) AS month_contacted,<br/> DATE_PART(day, last_contacted) AS day_contacted,<br/> contact_type<br/>FROM<br/> combined_table<br/>WHERE<br/> last_contacted IS NOT NULL;</span></pre><p id="3eea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj qn"><img src="../Images/510a3c06d24c0f247a2ea1165b25c4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WHI16emU_RZ3K21-.png"/></div></div></figure><p id="de57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这个练习中有两个新概念。第一种方法是从日期中提取一个特定的部分(例如，年、季度、月或日)，可以按如下方式实现:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="42db" class="oo mw iu oj b be op oq l or os">DATE_PART(year, last_contacted) AS year_contacted,</span></pre><p id="da5e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">想法很简单。<code class="fe og oh oi oj b">year</code>标识要提取日期的哪一部分，然后是原始日期所在的列名，在本例中是<code class="fe og oh oi oj b">last_contacted</code>。</p><p id="6fdc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第二个概念是过滤掉具有空值的行，这是使用以下方法实现的:</p><pre class="kk kl km kn gu ok oj ol bn om on bi"><span id="6a2b" class="oo mw iu oj b be op oq l or os">WHERE<br/> last_contacted IS NOT NULL</span></pre><p id="ed72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="ov"> Pro 提示:</em> </strong>在 SQL Server 中，不用<code class="fe og oh oi oj b">DATE_PART()</code>，一用<code class="fe og oh oi oj b">DATEPART()</code>。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="3e56" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">小抄</h1><p id="ee41" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">我在这里附上了我为自己开发的备忘单。在你开始使用它之前，我有两个关于这个和其他备忘单的临别建议:</p><ol class=""><li id="751b" class="ow ox iu lc b ld le lg lh lj oy ln oz lr pa lv qk pc pd pe bi translated">如果可能的话，随着时间的推移建立你自己的备忘单，而不是依赖一个准备好的备忘单。与别人分享的相比，当你自己创建和更新它的时候，你会学到更多。</li><li id="048b" class="ow ox iu lc b ld pf lg pg lj ph ln pi lr pj lv qk pc pd pe bi translated">如果您没有时间创建自己的备忘单，请使用现有的备忘单并将其制作成您自己的备忘单。我的意思是，从现有的小抄开始，然后添加、修改、编辑它，在某个时候它会变成<em class="ov">“你的”</em>小抄，你会在这个过程中继续学习。</li></ol><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="21d6" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">摘要</h1><p id="afd4" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">在这篇文章中，我们首先讨论了使用 SQL 进行数据检索对于数据科学家的重要性。然后，在 16 道练习题和答案的帮助下，我们继续学习最常见的 SQL 概念。最后，提供了 SQL 中一些更常见概念的参考表，以供将来参考。</p></div><div class="ab cl mo mp hy mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="in io ip iq ir"><h1 id="db89" class="mv mw iu bd mx my mz na nb nc nd ne nf ka ng kb nh kd ni ke nj kg nk kh nl nm bi translated">感谢阅读！</h1><p id="0671" class="pw-post-body-paragraph la lb iu lc b ld nn jv lf lg no jy li lj np ll lm ln nq lp lq lr nr lt lu lv in bi translated">如果你觉得这篇文章有帮助，请<a class="ae kz" href="https://medium.com/@fmnobar" rel="noopener">在媒体</a>上关注我，订阅接收我的最新文章！</p></div></div>    
</body>
</html>