<html>
<head>
<title>Data Cleaning: Automatically Removing Bad Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据清理:自动删除坏数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-cleaning-automatically-removing-bad-data-c4274c21e299#2022-04-07">https://towardsdatascience.com/data-cleaning-automatically-removing-bad-data-c4274c21e299#2022-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fc54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从数字和字符列中清除错误的数据类型条目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36bf7f985317da9c8ce4fef36509ed6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4hdsPMuU6E5M8654"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@norevisions?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上没有修改</a></p></figure><p id="dae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入数据集后，清理数据几乎总是您需要采取的首要步骤之一。熊猫有很多很棒的清洁功能，比如<code class="fe lv lw lx ly b">isnull()</code>、<code class="fe lv lw lx ly b">dropna()</code>、<code class="fe lv lw lx ly b">drop_duplicates()</code>等等。然而，有两种主要情况没有被涵盖:</p><ul class=""><li id="653e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">一个可能的数字列散布着字符串和布尔值</li><li id="870f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">一个有抱负的字符列有零星的数值和布尔值</li></ul><p id="0fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">隔离和移除这些不良数据尤其具有挑战性——在这里，我将向您展示实现这一目标的工具。但是首先，在做任何进一步的分析之前，有另一个很好的理由删除这些坏数据… <em class="mn">对象类型</em>。</p><h2 id="ef48" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">对象类型</h2><p id="967d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">虽然pandas通常在导入期间很好地解释了我们的列的数据类型，但是当坏数据引入非常不同的数据类型的元素时，它几乎总是出错。最终结果是列的数据类型(<code class="fe lv lw lx ly b">dtype</code>)被设置为可怕的<strong class="lb iu"> <em class="mn">对象</em> </strong>。</p><p id="746e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有什么不好？首先，在排序、绘制和过滤数据，以及合并来自另一个数据框架的数据时，它会令人头疼。更糟糕的是，对象消耗了大量的计算资源，使得你处理数据的其他事情——包括EDA和机器学习——慢了很多。当然，要修复一个列的数据类型，我们首先需要所有的数据都与新的数据类型一致，否则我们会在转换过程中出错。这意味着清除所有不属于错误类型的数据。</p><p id="df34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在Pandas中根本没有清理混合类型数据的功能，这通常导致一系列排序方法来梳理它们的位置并逐个删除它们。相反，通过一些相当简单的自定义函数，我们可以自动化整个过程！</p><h2 id="e161" class="mo mp it bd mq mr ms dn mt mu mv dp mw li mx my mz lm na nb nc lq nd ne nf ng bi translated">设置</h2><p id="cde0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了给我们一些数据来玩，这里有一个包含重复元素的快速数据框架，第一列代表我们的未来数字列，第二列代表我们的未来字符列，但两者都有不同dtypes的大量坏数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查<code class="fe lv lw lx ly b">df.head()</code>和<code class="fe lv lw lx ly b">df.dtypes</code>我们看到我们的数据，以及可怕的两列的<strong class="lb iu">对象</strong> dtype。还要注意，在这种对象形式中，我们无法直接检测NaNs这是我们在清理数据时需要注意的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/70c9ab097528c00eaee69851091b448b.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*blswmbP8dinPjYi-o0guAQ.png"/></div></figure><h1 id="ab70" class="np mp it bd mq nq nr ns mt nt nu nv mw jz nw ka mz kc nx kd nc kf ny kg nf nz bi translated">从数字列中清除字符和布尔值</h1><p id="0a1c" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">首先，让我们创建一个简单的函数来列出<code class="fe lv lw lx ly b">num_col</code>中包含非数值的所有行的内容和行号。这里需要注意的一点是，我们选择不报告空值(nan)。这就留给了用户稍后使用<code class="fe lv lw lx ly b">dropna()</code>来删除它们，或者在清理完所有其他内容后，根据需要将它们转换为其他值。</p><p id="b810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们遍历每一行并尝试将值转换成一个<code class="fe lv lw lx ly b">float</code>。因为NaN被认为是一个浮点值，所以这些行被保留。同时，如果该值不是数字或安南，<code class="fe lv lw lx ly b">float()</code>函数将返回一个ValueError。在我们的函数中，它触发打印违规的值和行号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在现有的数据帧上使用它，它会立即捕获两个重复的非浮点值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0af0d118600620d8869cb7c0412712c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*tNbw08_ri08CpgeO2u28qA.png"/></div></figure><p id="ba23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们现在知道所有非数字值隐藏在数据帧中的什么地方。检查之后，我们可以起草一个非常相似的函数来完全删除这些不匹配的行。一旦找到它们，我们现在可以简单地删除该行——当然，我们总是可以自定义ValueError后面的行，改为将它赋给我们喜欢的另一个(数字)值。</p><p id="ab67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在循环完dataframe列之后，我们使用<code class="fe lv lw lx ly b">astype()</code>试图将整列强制转换为<code class="fe lv lw lx ly b">float</code> dtype。为什么？因为当我们在<code class="fe lv lw lx ly b">try:</code>中调用<code class="fe lv lw lx ly b">float()</code>时，我们正在做的就是……尝试。它没有做任何永久的改变。如果出现任何问题，<code class="fe lv lw lx ly b">astype()</code>函数将抛出错误，让我们知道它在哪里遇到了问题。该语句还将那些非空的<code class="fe lv lw lx ly b">'nan'</code>条目转换成我们可以检测到的适当的nan。最后，我们重置索引，这样当我们在其他列上使用这个函数时，索引将是连续的，并与我们的<code class="fe lv lw lx ly b">cnt</code>计数器一起工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行我们的函数之后，我们可以检查我们的列的dtype，并且最后一次运行<code class="fe lv lw lx ly b">char_finder()</code>来确保没有错误类型的值出现。瞧啊。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e7b23362558b6c4ce6e702494b1db5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*Jxoo1sD6Lc46B4KB_uU_xg.png"/></div></figure><h1 id="0b27" class="np mp it bd mq nq nr ns mt nt nu nv mw jz nw ka mz kc nx kd nc kf ny kg nf nz bi translated">从字符列中删除数字和布尔值</h1><p id="e7a7" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">硬币的另一面可能有点棘手。<em class="mn">技术上来说</em>‘8’是一个字符……<em class="mn">技术上来说</em>‘真’是一个词……但它们很可能不属于我们的字符列。我们在这里遇到的一个棘手的挑战是，尽管我们在创建它时在我们的<code class="fe lv lw lx ly b">name_col</code>中输入了一个布尔值<code class="fe lv lw lx ly b">True</code>和<code class="fe lv lw lx ly b">24.5</code>，但是在Panda将列转换为对象时，它实际上把一切都当作字符串(<code class="fe lv lw lx ly b">'True’</code>和<code class="fe lv lw lx ly b">'24.5'</code>)。结果，就像我们之前的函数一样，<code class="fe lv lw lx ly b">float()</code>实际上是在测试<code class="fe lv lw lx ly b">float('True')</code>，这导致了ValueError (p.s. <code class="fe lv lw lx ly b">float(True)</code>等于1.0)。如此处所示，我们的<code class="fe lv lw lx ly b">'True'</code>元素没有被认为是类型<code class="fe lv lw lx ly b">bool</code>的实例，因为它认为它是一个字符串。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/29e24ead1eaff5a394815528178c8bbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*yRiNtEX2dk1xdOcl42p66w.png"/></div></div></figure><p id="4b4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这一点，我们必须加入额外的逻辑来显式测试<code class="fe lv lw lx ly b">'True'</code>和<code class="fe lv lw lx ly b">'False'</code>，因为像<code class="fe lv lw lx ly b">bool()</code>这样的函数不像<code class="fe lv lw lx ly b">float()</code>这样的数字函数那样特殊，并且会为任何字符的<strong class="lb iu">赋予一个<code class="fe lv lw lx ly b">True</code>值。</strong></p><p id="93ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们也特别注意将任何NaNs留在原位。为此，我们做了一个嵌套的<code class="fe lv lw lx ly b">int(float())</code>转换。内部的<code class="fe lv lw lx ly b">float()</code>像以前一样，试图把我们的字符串像‘24.5’变成24.5。<code class="fe lv lw lx ly b">int()</code>然后将像24.5这样的浮点数转换成24，这对于这种检查算法来说很好——但是nan不是整数，会抛出ValueError。这很好！我们希望nan被发送到ValueError部分，因为非错误(即数字)在底部的<code class="fe lv lw lx ly b">else:</code>语句中被标记。考虑到这一点，我们的数字/布尔查找器函数和结果如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经识别了所有的数值和布尔值！在我们创建fixer函数之前，请记住我们的nan仍然是这个列中的字符串。我们需要在我们的<code class="fe lv lw lx ly b">elif</code>语句中显式地处理它，以便手动将它们转换回nan。我们可以在我们的输出中看到这一点，因为<code class="fe lv lw lx ly b">nan</code>现在被表示为<code class="fe lv lw lx ly b">&lt;NA&gt;</code>，并且<code class="fe lv lw lx ly b">df.isnull().sum()</code>能够检测到它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="706a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们的两个dataframe列有效地清除了所有错误类型的数据，如下所示。我们还将它们转换成适当的数据类型，这将允许所有进一步的清理、EDA或机器学习。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/cf938f738e85bbdab61e79fefab95aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*8eLHTKcuG2562SLHHaRUUA.png"/></div></figure><p id="507c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们只需要决定如何处理nan(现在我们可以检测它们了！)—如果它们构成了大量的行，我们可以考虑删除整列—否则我们通常使用<code class="fe lv lw lx ly b">df.dropna()</code>来简单地删除所有NaN行。</p><h1 id="e5c3" class="np mp it bd mq nq nr ns mt nt nu nv mw jz nw ka mz kc nx kd nc kf ny kg nf nz bi translated">额外积分—速度分析</h1><p id="b824" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">通常，for循环是我们在操作数据帧时最不想做的事情。For循环在计算上可能非常慢。作为一个思考练习，这些相同的函数可以使用panda的<code class="fe lv lw lx ly b">apply()</code>函数来实现，然后可以使用更加矢量化的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们检查一下时间(当然是在重置两次之间的df之后)，我们会发现我们原来的解决方案非常快，即使对于具有42，000行的数据帧也是如此。更令人惊讶的是，它的执行速度比这个<code class="fe lv lw lx ly b">apply()</code>解决方案快两倍多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/cf702d29f88c57adf7730d58ea58ba9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIKb4GqlfcJlkbV98Gobaw.png"/></div></div></figure><p id="69a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然其他矢量化解决方案确实存在，但我发现用几毫秒的时间清理每一列是非常容易管理的。</p><h1 id="518a" class="np mp it bd mq nq nr ns mt nt nu nv mw jz nw ka mz kc nx kd nc kf ny kg nf nz bi translated">摘要</h1><p id="8ed2" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">这里显示的所有代码，以及一个只有功能的jupyter笔记本都可以从我的github 中获得。我还包括了将所有坏数据转换成nan的<code class="fe lv lw lx ly b">char_fixer_nan()</code>和<code class="fe lv lw lx ly b">num_fixer_nan()</code>，以防对您的目的更有用。使用<code class="fe lv lw lx ly b">%run ColumnCleaner.ipynb</code>将这些功能保存到本地后，也可以很容易地导入到您的任何笔记本中。</p><p id="4d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜寻和清除错误类型的数据并不有趣，这些功能是出于需要而产生的。我真的希望这能帮助每个人加快特别脏的数据集的清理过程。如果你觉得这个有用，请跟我来！ 欢呼声此起彼伏，快乐的编码声此起彼伏。</p></div></div>    
</body>
</html>