<html>
<head>
<title>How to add a DEBUG mode for your Python Logging Mid-Run</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python日志运行中期添加调试模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-add-a-debug-mode-for-your-python-logging-mid-run-3c7330dc199d#2022-04-27">https://towardsdatascience.com/how-to-add-a-debug-mode-for-your-python-logging-mid-run-3c7330dc199d#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="f6fa" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Python技巧和窍门</h2><div class=""/><div class=""><h2 id="5554" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">动态配置日志记录的调试模式</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/5a6567fb21b9ab5f497a3301412a6074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*our7AHCQavPmJitvVwyAag.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者创建的图片|使用了来自<a class="ae ld" href="http://canva.com/" rel="noopener ugc nofollow" target="_blank">canva.com</a>的免费内容许可元素</p></figure><p id="d50a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">让我们面对它，python的日志工作是复杂的。如果您想在python应用程序中添加- debug-mode或- verbose，该怎么办？您希望激活它会在日志“调试”级别创建一个控制台输出或日志文件，而您的默认值是“信息”级别。当你有一个脚本时，这很容易，你只需要做一个:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="bb0d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这很简单。但是没有足够的教程或简单的解释来跨模块这么做。这只是改变脚本记录器。我会给你一个框架，你可以应用到你所有的应用。</p><h1 id="6568" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">我们想要达到的目标</h1><h2 id="3ecd" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">标准</h2><p id="43db" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">让我们简单地说出我们想要什么。我们需要以下标准:</p><ul class=""><li id="455e" class="nk nl it lg b lh li lk ll ln nm lr nn lv no lz np nq nr ns bi translated">跨多个模块进行日志记录的简单框架。</li><li id="6260" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">一种在所有模块的日志记录应用程序的中途改变特性的方法，无论是日志记录级别、处理程序、配置文件等等。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/cd43d00ddac782ca3a1cec1a63a6a4ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*zsXYs41nDMn4XCgO8bAwkA.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">任何人(大多数情况下是用户)都可以在应用程序运行的任何时候启动日志调试模式，无论是作为输入还是中途|作者创建的图像|使用来自canva.com<a class="ae ld" href="http://canva.com/" rel="noopener ugc nofollow" target="_blank">的免费内容许可元素</a></p></figure><p id="b7b4" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">当你在<strong class="lg jd"> ONE </strong>脚本中开始时，有大量的教程涵盖了日志记录的基础知识。但是为什么新手找登录过<strong class="lg jd">多个模块</strong>的教程那么难？</p><p id="c8f0" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这家伙同意了，谢天谢地他已经写下来了:</p><div class="nz oa gp gr ob oc"><a rel="noopener follow" target="_blank" href="/the-reusable-python-logging-template-for-all-your-data-science-apps-551697c8540"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jd gy z fp oh fr fs oi fu fw jc bi translated">适用于所有数据科学应用的可重复使用的Python日志模板</h2><div class="oj l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op kx oc"/></div></div></a></div><p id="6f8b" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">他的方向是正确的，但是，这并没有帮助我们选择改变所有动态日志的方面。这需要一些信息。</p><h2 id="eeab" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">关于记录器的必需背景信息</h2><p id="53a4" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">我不会深入解释Python日志包的概念。我假设您对python日志包有一些基本的了解。我不想重新发明轮子，所以这里有一个文档链接:</p><p id="778d" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/logging.html</a></p><p id="d382" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">和一个链接到一个很好的解释伐木工。</p><p id="7757" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://www.geeksforgeeks.org/logging-in-python/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/logging-in-python/</a></p><p id="b139" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">然而，有几个相关的概念我需要提及:</p><ul class=""><li id="b1de" class="nk nl it lg b lh li lk ll ln nm lr nn lv no lz np nq nr ns bi translated">有多种方法来配置记录器:编写函数/类，dictConfig，使用logging.basicConfig，一个配置YAML文件等。第一个是我发现在运行应用程序时最通用的，所以这是我遵循的框架</li><li id="3c60" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">每当您启动logging.getLogger(__name__)时，都会创建一个子记录器。如果括号是空的，那么它就是根日志记录器。众所周知，为每个模块创建一个子类是最佳实践。</li><li id="bf1e" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">这个超级重要。当子记录器未指定记录级别(即信息、调试、警告等)时。)那么它将继承父类的设置。在大多数情况下，我们的例子是根日志记录器。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a0f4c2fce6920e6a12f181a507753033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*zbE9UNkPKOpft51KF1sTLw.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者创建的图像</p></figure><p id="384a" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">你明白我的意思了吧。我们将在每个模块中初始化一个子类，但是将从根日志记录器继承级别。我们可以在应用程序中途改变根日志记录器的日志级别，这将应用于所有子日志记录器。</p><h1 id="e111" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">框架:步骤和解释</h1><p id="fcc1" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">这个框架真的很难在一篇文章中解释，所以我把完整的例子放在GitHub的仓库里:</p><div class="nz oa gp gr ob oc"><a href="https://github.com/Causb1A/logging-debug-mode" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jd gy z fp oh fr fs oi fu fw jc bi translated">GitHub-caus B1 A/logging-debug-mode:补充TDS文章的存储库</h2><div class="oj l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">github.com</p></div></div><div class="ok l"><div class="or l om on oo ok op kx oc"/></div></div></a></div><p id="c6e8" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">如果你正在努力遵循下面列出的步骤。从main.py开始一步一步调试存储库代码，然后你就会明白它是如何工作的了。</p><p id="9139" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">下面是我们将要实现的目标:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="ot ou di ov bf ow"><div class="gh gi os"><img src="../Images/be92c0eba2b547fec836cf3dcf172d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3BtUGrEnH41OiY8cuPOAmg.png"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者创建的图像</p></figure><p id="c657" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">如上所述，我们将创建一个main.py来启动应用程序，它连接到logger类的文件夹和模块中。Module_1和Module_2都是运行应用程序所需的python模块，但是module_1从module_2中获取了一个函数。所有模块都使用一个名为Logger()的实例化类。<em class="ox">你不必为此使用单例类，你可以有一个普通的类或函数。我用它来为将来的实现保持日志的通用性。</em></p><p id="33ba" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">为了启动“调试模式”,我们将在module_1.py中有一个函数，用于启动根记录器中的调试级别。</p><h2 id="0ef9" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">步骤1:文件创建</h2><p id="98e1" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">像这样创建文件:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d0341b39dce381ac3cbf1cf81f79bae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*7-UU70MrSR6YGM4d1D72KQ.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者创建的图像</p></figure><p id="86b1" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">忽略pycache。</p><ol class=""><li id="1bc7" class="nk nl it lg b lh li lk ll ln nm lr nn lv no lz oz nq nr ns bi translated">有一个名为logger的文件夹，并确保有一个__init__。巴拉圭</li><li id="793d" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz oz nq nr ns bi translated">有一个名为my_app(或您的应用程序名称)的文件夹，并确保有__init__。巴拉圭</li><li id="c3a9" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz oz nq nr ns bi translated">在你的日志文件夹中放一个logger.py</li><li id="bd00" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz oz nq nr ns bi translated">创建一个main.py作为主运行文件</li><li id="be71" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz oz nq nr ns bi translated">将你的应用程序模块放在我的应用程序或者你的模块所在的任何其他文件夹中</li><li id="2878" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz oz nq nr ns bi translated">可选:放置一个测试文件夹并在此测试记录器特性</li></ol><h2 id="632c" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">步骤2:日志记录类</h2><p id="d24d" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">它位于logger.py中的Logger文件夹中。就像我前面说的，它不一定是一个类，也不一定是一个单独的类。您可以只定义函数而不定义类。只要确保你相应地修改了框架。</p><p id="ccb5" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><strong class="lg jd">对于那些问:什么是单例类？</strong></p><p id="57f9" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">python中的单例类允许你创建一个类的实例。这个实例贯穿程序的整个生命周期。想象一个你实例化一次的类对象。这个类不能被再次实例化。您可以在任何python模块中的整个程序中访问和更改该实例的变量，而不必再次实例化该类。</p><p id="24aa" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">对于单例类的细节以及它们为什么工作，我不会重新发明轮子。这里有一个很好的解释:</p><p id="6504" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated"><a class="ae ld" href="https://www.geeksforgeeks.org/singleton-pattern-in-python-a-complete-guide/#:~:text=A%20Singleton%20pattern%20in%20python,of%20access%20for%20a%20resource." rel="noopener ugc nofollow" target="_blank">点击此处前往极客了解极客的解释</a></p><p id="e8e9" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">我们在这里使用它的原因是为了拥有一个具有我们想要的特性的全局记录器类。所以每次我们启动一个子日志类，它都遵循我们定义的相同框架。我为将来的实现留下了一个单独的类，例如，它可以作为一个全局类来保存所有的子记录器作为属性。或者在类的属性发生变化后，可以用它来重新定义日志。我发现拥有一个全局单实例类更加通用；儿童记录器的集中访问点。对于我们所说的“调试模式”，这不是必需的。</p><p id="8333" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">下面是logger.py文件。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="79ee" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这些函数对于文档字符串来说是不言自明的，但是需要注意几个重要的元素。</p><ul class=""><li id="23de" class="nk nl it lg b lh li lk ll ln nm lr nn lv no lz np nq nr ns bi translated">def __new__(cls):这是使这个类成为单例的部分，它检查实例是否为none。如果是，它将实例化一个实例。否则，它将返回相同的实例。因为这是一个日志记录器，我们不需要再实例化。</li><li id="35c9" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">def get_logger(self，logger_name):这是我们将在所有模块中调用的函数，用于启动子记录器。</li><li id="22a5" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">处理程序:这里我们创建了两个处理程序，一个终端输出和一个文件处理程序。将来，您也可以使用这个单例类来处理处理程序。</li><li id="2c79" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">def add_handlers():函数add handlers检查它是否没有复制处理程序。如果您的应用程序中碰巧需要重新创建一个子记录器，这个函数将停止重复的处理程序。如果将来您希望重新编写这个类以适应更多的处理程序管理，请小心不要重复处理程序。</li><li id="d305" class="nk nl it lg b lh nt lk nu ln nv lr nw lv nx lz np nq nr ns bi translated">def set_debug_mode(self，debug_mode:bool):该函数将调试根记录器设置为调试级别。这意味着所有子记录器都将从调试根记录器继承这个特性。</li></ul><h2 id="c434" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">第三步:不要忘记__init__。py！</h2><p id="f3b7" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">我们希望logger文件夹像一个包一样被对待。所以在__init__内。记录器文件夹的py，放入:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="05a8" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">第四步:主页面</h2><p id="a4c7" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">在main.py或运行整个应用程序的主模块中，必须启动logger类，并将根级别日志设置为INFO。这必须在您运行应用程序中的任何其他内容之前发生。</p><p id="14fe" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">见下方my main.py</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="24fb" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">注意，我调用logger()实例化该类来创建一个子Logger？每次调用Logger()时，我们会实例化一个类吗？singleton类中的get_logger函数？不，因为单例类的目的是只有一个实例，所以它将返回相同的现有实例。</p><h2 id="9373" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">步骤5:在任何模块中使用logger类</h2><p id="83d8" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">为了在每个模块中使用singleton logger类，我们需要导入logger类并调用get_logger。记住，良好的日志记录实践意味着您需要为每个模块创建一个子日志记录器，所以一定要将模块__name__放在每个函数中。</p><p id="08ee" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">下面是Github资源库中“module_2.py”的一个例子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="8f40" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">步骤6:在应用程序中途更改调试级别</h2><p id="df87" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">现在，我们要做的是，在应用程序中途将root logger更改为debug模式。还记得步骤2中有一个set_debug_mode函数吗？该函数将根级别日志记录器更改为debug。在Github存储库中的module_1.py中，我通过调用该函数来更改类属性。</p><p id="6b9f" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">参见下面的module_1.py。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c399" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">函数does_something()只是一个示例函数，向您展示用例。</p><p id="ef15" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">这个模块有什么作用？</p><p id="fe10" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">函数run()是整理一切以显示用例的函数。让我们一步一步来。</p><p id="15e5" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">第16行:这调用了函数does_something()记住，此时日志记录仍处于日志记录状态。信息级别。所以在控制台/日志文件中，你只会看到信息。</p><p id="34b2" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">第18行:这调用了另一个模块中的函数does_something_module_2()。在步骤4中可以看到相同的模块。记住，日志还在日志。信息级别，所以只会看到信息。</p><p id="ffbb" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">第23行:将根日志记录器级别更改为DEBUG。所有模块子记录器都将从此继承。</p><p id="48a2" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">第26行:与第16行相同，但是这一次启动了调试模式，日志级别为Logging.DEBUG</p><p id="5602" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">第29行:与第18行相同，但是现在启动了调试模式，日志级别为logging。甚至在另一个模块中调试。你已经完成了，你已经在一个模块中初始化了调试模式，并且它在每个其他的模块中继续初始化日志类。</p><p id="a524" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">以下是运行该文件时的输出。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/f1a164ce8fc7a893c349b95a367b74e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*S0EQhfMrOUssi_q6xCk-FA.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">作者创建的图像</p></figure><h2 id="bc68" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">步骤7:应用到您的应用程序中</h2><p id="a944" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">要将框架应用到您的应用程序:遵循步骤1–6，但是不使用module_1.py、module_2.py和main.py，而是将记录器放在您的模块中。</p><p id="ef7e" class="pw-post-body-paragraph le lf it lg b lh li kd lj lk ll kg lm ln lo lp lq lr ls lt lu lv lw lx ly lz im bi translated">当将根级别更改为调试级别时，可以有一个函数来触发它。例如，解析来自调试模式或用户输入的参数。不管你想触发什么。</p><h2 id="5111" class="mu md it bd me mv mw dn mi mx my dp mm ln mz na mo lr nb nc mq lv nd ne ms iz bi translated">额外测试功能</h2><p id="fb8a" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">我已经在测试库中包含了一些测试函数，只是为了测试singleton类的各种特性。测试是不言自明的。</p><h1 id="a7e7" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">我们取得的成就</h1><p id="3db1" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">我们在存储库和步骤1–7中实现的是，我们已经将logger类框架应用于应用程序，并在应用程序中途触发日志记录级别的更改。</p><h1 id="13a2" class="mc md it bd me mf mg mh mi mj mk ml mm ki mn kj mo kl mp km mq ko mr kp ms mt bi translated">最后的话</h1><p id="3051" class="pw-post-body-paragraph le lf it lg b lh nf kd lj lk ng kg lm ln nh lp lq lr ni lt lu lv nj lx ly lz im bi translated">希望这有助于您在python应用程序中更多地管理日志，并为您更多地使用singleton类打开大门。</p><blockquote class="pb"><p id="ed9b" class="pc pd it bd pe pf pg ph pi pj pk lz dk translated">如果你喜欢这篇文章，请留下掌声和关注支持！</p></blockquote><p id="5139" class="pw-post-body-paragraph le lf it lg b lh pl kd lj lk pm kg lm ln pn lp lq lr po lt lu lv pp lx ly lz im bi translated">或者，如果您有兴趣加入Medium社区，这里有一个推荐链接:</p><div class="nz oa gp gr ob oc"><a href="https://medium.com/@adrian.causby15/membership" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd jd gy z fp oh fr fs oi fu fw jc bi translated">通过我的推荐链接加入Medium-Adrian caus by</h2><div class="oj l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ok l"><div class="pq l om on oo ok op kx oc"/></div></div></a></div></div></div>    
</body>
</html>