<html>
<head>
<title>Hyperparameters in Deep RL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深层 RL 中超参数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/hyperparameters-in-deep-rl-f8a9cf264cd6#2022-03-04">https://towardsdatascience.com/hyperparameters-in-deep-rl-f8a9cf264cd6#2022-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RL 实践课程—第 6 部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a0b4d3b2942c1e68eef24626a811ca9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tz6prJMrgpHmdZhtH3aVPQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@boxedwater?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">盒装水更好</a>上<a class="ae ky" href="https://unsplash.com/s/photos/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="2d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深层 RL 中的超参数对于训练成功的代理是至关重要的。在今天的课程中，我们将学习如何找到让你成为快乐的深度 RL 开发者的方法。</p><h1 id="f1c0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">欢迎来到❤️课程</h1><p id="ec46" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">欢迎来到强化学习实践课程的第 6 部分，它将带你从零到英雄🦸‍♂️.</p><p id="b655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是目前为止我们所做的:</p><ol class=""><li id="143a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/hands-on-reinforcement-learning-course-part-1-269b50e39d08">强化学习简介</a></li><li id="422c" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/hands-on-reinforcement-learning-course-part-2-1b0828a1046b">表格 Q-学习</a></li><li id="e02d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/hands-on-reinforcement-learning-course-part-3-5db40e7938d4">表格萨萨</a></li><li id="57d8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/hands-on-reinforcement-learning-course-part-4-55da5eae851f">线性 Q 学习</a></li><li id="fe5d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/hands-on-reinforcement-learning-course-part-5-bdb2e7fa243c">深度 Q 学习</a></li><li id="3b83" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">👉🏻<strong class="lb iu">深 RL 中的超参数</strong>(今日)</li></ol><p id="c1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第 5 部分中，我们使用深度 Q 学习构建了一个完美的代理来解决 Cart Pole 环境。</p><p id="a515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用了一组超参数，我和你们分享过。然而，我没有解释我是如何得到它们的。</p><p id="04d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想成为强化学习的真正专家，你需要学习如何调整超参数。为此，你需要使用正确的工具。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/5e6832ef7fc0cf65d8b507329eefb768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcJiBq8O0Se30bMLT7oTiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">孔子知道得很清楚！(图片由作者提供)</p></figure><p id="4baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们将使用 Python 生态系统中最好的超参数搜索开源库:Optuna。</p><p id="69b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本课所有代码在<a class="ae ky" href="https://github.com/Paulescu/hands-on-rl" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">本 Github repo </strong> </a> <strong class="lb iu">中。</strong> Git 克隆它来跟随着今天的问题。</p><p id="3822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想分享爱吗？请<a class="ae ky" href="https://github.com/Paulescu/hands-on-rl" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">给它一个 Github 里的⭐吧！</strong>T25】</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://github.com/Paulescu/hands-on-rl"><div class="gh gi nh"><img src="../Images/ca9c591228e931253a465b3028369672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D16eGnlRB8AEH_hE.jpeg"/></div></a><p class="ku kv gj gh gi kw kx bd b be z dk translated">实践学习课程 Github repo</p></figure><h1 id="f61a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第六部分</h1><h1 id="44d1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">内容</h1><ol class=""><li id="9bbf" class="ms mt it lb b lc mn lf mo li ni lm nj lq nk lu mx my mz na bi translated"><a class="ae ky" href="#4c98" rel="noopener ugc nofollow">问题</a></li><li id="361f" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="#236f" rel="noopener ugc nofollow">解决方案:贝叶斯搜索</a></li><li id="e861" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="#2f7e" rel="noopener ugc nofollow">使用 Optuna 进行超参数搜索</a></li><li id="7a37" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="#9b3d" rel="noopener ugc nofollow">重述✨ </a></li><li id="e72d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="#a528" rel="noopener ugc nofollow">作业📚</a></li><li id="98ef" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">下一步是什么？❤️ </li></ol><h1 id="4c98" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.问题是</h1><p id="2d71" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">机器学习模型有参数和超参数。</p><h2 id="fb77" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated"><em class="nx">这两者有什么区别？</em></h2><p id="3677" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">参数是你在训练你的模型后找到<strong class="lb iu">的数字。例如，将状态映射到最佳 q 值的神经网络的参数。</strong></p><p id="b3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，超参数是在训练模型之前需要设置的数字。你不能通过训练找到它们，但是你需要事先正确地猜测它们。一旦设置了这些参数，就可以训练模型并找到剩余的参数。</p><p id="e960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超参数存在于机器学习的周围。例如，在有监督的机器学习问题中(就像我们在第 5 部分中解决的问题)，您需要设置学习率。数值太低，模型会陷入局部最小值。数字太大，模型将振荡太多，永远不会收敛到最佳参数。</p><p id="525a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深度强化学习中，事情变得更加具有挑战性。</p><h2 id="89f0" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated"><em class="nx">为什么？</em></h2><p id="d1a7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因为</p><ul class=""><li id="dff9" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ny my mz na bi translated">深度 RL 算法比监督机器学习模型有<strong class="lb iu">更多</strong>超参数。</li><li id="1901" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ny my mz na bi translated">更重要的是，深度 RL 中的超参数对最终的训练结果有着巨大的影响。换句话说，深度 RL 算法对您预先设置的超参数非常敏感。环境越复杂，超参数越关键。</li></ul><p id="0d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/hands-on-reinforcement-learning-course-part-5-bdb2e7fa243c#2d1f">第 5 部分</a>中，我们看到了两组超参数，与 q 值网络的相同参数化相结合，如何导致两个非常不同的代理，具有非常不同的性能。其中一个代理是 okayish(平均奖励 180 左右)，另一个是完美解决(平均奖励 500)。</p><p id="5ba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么问题是…</p><blockquote class="nz"><p id="217e" class="oa ob it bd oc od oe of og oh oi lu dk translated">如何才能找到** <strong class="ak">好的** </strong>超参数？🤔</p></blockquote><p id="bdf7" class="pw-post-body-paragraph kz la it lb b lc oj ju le lf ok jx lh li ol lk ll lm om lo lp lq on ls lt lu im bi translated">为了找到好的超参数，我们采用试错法。</p><p id="60cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，这是 4 个步骤:</p><ol class=""><li id="1910" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">我们选择一组超参数，</li><li id="76f5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">培训代理人，</li><li id="f16a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">评估代理。</li><li id="503a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果我们对结果满意，我们就完成了。否则，我们选择一组新的超参数，并重复整个过程。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/c117a56b8bf7af63a77d2ebadede2d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eyAoG2HfSbfI9slk_acReg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">找到好的超参数的 4 个步骤(图片由作者提供)</p></figure><h2 id="ec8d" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">网格搜索</h2><p id="1328" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果超参数的数量很少(例如 2-3 个)，我们可以尝试所有可能的组合，并选择效果最好的一个。这个方法叫做<strong class="lb iu">网格搜索</strong>，对于很多有监督的 ML 问题都很管用。</p><p id="5665" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们的算法只有 2 个超参数，每个超参数取 5 个可能值中的 1 个，我们最终得到 5×5 = 25 个组合。我们可以使用每个超参数组合训练代理 25 次，并找到最好的组合。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8a94e0e470d6c3df44d9e7fcd43f5762.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*b79JERfzo3AlI5opXNa-GA.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个非常小的超参数空间(图片由作者提供)</p></figure><p id="fbff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，在深层 RL 问题中，有更多的超参数，例如 10–20 个。并且每个超参数可以取许多可能的值。</p><p id="5854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个巨大的网格，我们需要在其中进行搜索，其中组合的数量<strong class="lb iu">相对于超参数的数量和每个超参数可以取值的数量呈指数增长</strong>。在这种情况下，网格搜索不再是可行的搜索方式。</p><p id="3c72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有 10 个超参数，并且每个超参数可以从 10 个可能值中取 1，则网格大小为 10，000，000，000(1 后跟 10 个 0)。如果我们的训练循环需要 10 分钟来完成(这是一个非常乐观的估计)，它将花费我们</p><p id="38e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">10 分钟 x 10，000，000，000 = <strong class="lb iu"> 190，258 年</strong>😵‍💫</p><p id="1736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用简单的话来说就是……不可能。</p><p id="a6b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以并行搜索，并将这个数字减少几个数量级。例如，如果您有一个可以运行多达 100，000 个并行进程的大型计算机集群，这将花费您大约 2 年的时间…</p><p id="d20a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，这是一个非常低效的解决问题的方法，你不觉得吗？</p><h2 id="b67c" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">随机搜索</h2><p id="2fce" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">网格搜索的另一种选择是<strong class="lb iu">随机搜索</strong>，常用于有监督的 ML 问题。</p><p id="06a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想法很简单:不是检查每一个<code class="fe oq or os ot b">N</code>可能的<em class="ou"> </em>超参数组合(其中<code class="fe oq or os ot b">N</code>是一个非常大的数字，例如 1，000，000，000)，我们随机地尝试它们的一个子集，大小为<code class="fe oq or os ot b">T</code>(其中<code class="fe oq or os ot b">T</code>比<code class="fe oq or os ot b">N</code>小得多，例如 100)，并且训练和评估代理<code class="fe oq or os ot b">T</code>次。从这些<code class="fe oq or os ot b">T</code>试验中，我们选择效果最佳的超参数组合。</p><p id="7e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机搜索是一种更有效的搜索方式，在速度和解决方案的质量方面比网格搜索好得多。</p><p id="5322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用随机搜索(顾名思义),您实际上是在每次迭代中旋转轮盘来决定下一步尝试什么超参数。这似乎是一种很愚蠢的搜索方式，不是吗？</p><p id="b8be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一定有更聪明的办法，对吧？🤔</p><h1 id="236f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.解决方案:贝叶斯搜索</h1><p id="7801" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了更好地搜索(无论你在生活中搜索什么)，通常一个好主意是记住你过去尝试了什么，并使用这些信息来决定下一步最好尝试什么。</p><p id="d133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是<strong class="lb iu">贝叶斯搜索</strong>方法所做的。</p><p id="919a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贝叶斯搜索方法跟踪过去的迭代结果，以决定<em class="ou"> </em>接下来在超参数空间中最有希望尝试的区域是什么。</p><p id="3cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用贝叶斯搜索，你在一个<strong class="lb iu">代理模型</strong>的帮助下探索空间，这给你一个<em class="ou">估计</em>每个超参数组合有多好。随着你运行更多的迭代，算法更新代理模型，这些估计变得越来越好。</p><p id="b4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，您的代理模型足以将您的搜索指向好的超参数。瞧，这就是你得到它们的方式！</p><p id="00be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贝叶斯搜索方法优于随机搜索，是在深度学习中使用的完美选择。</p><p id="3553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同的贝叶斯搜索算法在构建代理模型的方式上有所不同。最流行的方法之一是<strong class="lb iu">树形结构的 Parzen 估计器(又名 TPE)。这就是我们今天要用的方法。</strong></p><h2 id="99ca" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">说👋去奥普图纳</h2><p id="c65a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">幸运的是，有一个令人惊叹的开源 Python 库叫做<a class="ae ky" href="https://optuna.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Optuna </strong> </a>，它实现了贝叶斯搜索方法。</p><p id="0616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Optuna 有一个干净的 API，抽象出 TPE 和其他贝叶斯搜索方法背后的所有细节。这是一个完美的即插即用库，我们可以在没有深入理解贝叶斯方法背后的数学知识的情况下开始使用。</p><blockquote class="ov ow ox"><p id="548e" class="kz la ou lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><em class="it">如果你想深入了解贝叶斯搜索和树形结构 Parzen 估计器背后的本质细节，我推荐你阅读 Will Koehrsen 的这篇精彩文章:</em> <br/>📝<a class="ae ky" rel="noopener" target="_blank" href="/a-conceptual-explanation-of-bayesian-model-based-hyperparameter-optimization-for-machine-learning-b8172278050f">机器学习的贝叶斯超参数优化的概念解释</a></p></blockquote><p id="59ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了贝叶斯方法和 Optuna，我们就可以找到解决问题的超参数了。</p><p id="ff86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们开始吧！</p><h1 id="2f7e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.使用 Optuna 进行超参数搜索</h1><p id="baba" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/Paulescu/hands-on-rl/blob/main/03_cart_pole/notebooks/09_hyperparameter_search.ipynb" rel="noopener ugc nofollow" target="_blank">👉🏽notebooks/09 _ hyperparameter _ search . ipynb</a></p><p id="a364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从加载环境开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="7936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了可视化每个超参数运行的参数和评估指标，我喜欢使用<a class="ae ky" href="https://www.mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLflow </a>。</p><p id="9e23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MLflow 是一个非常模块化的库，旨在实现 ML 模型的操作化。其中一个组件叫做<a class="ae ky" href="https://www.mlflow.org/docs/latest/tracking.html" rel="noopener ugc nofollow" target="_blank"> MLFlow Tracking </a>，顾名思义，它可以帮助我们跟踪模型开发过程中需要的一切。当您运行大量超参数实验，并且想要记录每次运行中使用的确切配置时，这一点非常重要。</p><p id="343f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在名为<code class="fe oq or os ot b">hyperparameter_search</code>的实验中将 MLflow 指标记录到<code class="fe oq or os ot b">MLFLOW_RUNS_DIR</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><blockquote class="ov ow ox"><p id="c399" class="kz la ou lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><em class="it">🔎</em> <strong class="lb iu"> <em class="it">超参数搜索结果可视化</em> </strong></p><p id="5aef" class="kz la ou lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><em class="it">要查看 MLFLow 仪表板，您需要进入命令行，并使用 cd 进入今天课程的根目录。</em></p><p id="a8d8" class="kz la ou lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><em class="it">这是我电脑里的样子<br/> </em> <code class="fe oq or os ot b"><em class="it">$ cd ~/src/online-courses/hands-on-rl/03_cart_pole</em></code></p><p id="a75f" class="kz la ou lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><em class="it">然后你启动 MLFLow 跟踪服务器:<br/> </em> <code class="fe oq or os ot b"><em class="it">$ mlflow ui --backend-store-uri mlflow_runs/</em></code></p><p id="68f3" class="kz la ou lb b lc ld ju le lf lg jx lh oy lj lk ll oz ln lo lp pa lr ls lt lu im bi translated"><em class="it">并点击控制台上打印的 URL，在我的例子中是</em><a class="ae ky" href="http://127.0.0.1:5000" rel="noopener ugc nofollow" target="_blank"><em class="it">http://127 . 0 . 0 . 1:5000</em></a></p></blockquote><p id="5fed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了用 Optuna 优化超参数，我们封装了</p><ul class=""><li id="304d" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ny my mz na bi translated">超参数采样</li><li id="aff5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ny my mz na bi translated">培养</li><li id="c745" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ny my mz na bi translated">以及 RL 代理的评估</li></ul><p id="8ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个<code class="fe oq or os ot b">objective()</code>函数中，它返回我们想要优化的指标。</p><h2 id="f57b" class="nl lw it bd lx nm nn dn mb no np dp mf li nq nr mh lm ns nt mj lq nu nv ml nw bi translated">目标函数</h2><p id="e8e4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我们的例子中，<code class="fe oq or os ot b">objective()</code>函数通过调用<code class="fe oq or os ot b">sample_hyper_parameters()</code>对超参数进行采样，训练 200 集的代理，并对 1000 集的新集进行评估。这个函数的输出就是这 1000 集中的平均奖励。这是我们想要最大化的度量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="595c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe oq or os ot b">sample_hyper_parameters()</code>根据下式采样并返回超参数值</p><ul class=""><li id="21b4" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ny my mz na bi translated">我们指定的范围</li><li id="5108" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ny my mz na bi translated">而 Optuna 使用的采样器，默认是 TPE。</li></ul><p id="e50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看<code class="fe oq or os ot b"><a class="ae ky" href="https://github.com/Paulescu/hands-on-rl/blob/00a8061d322c4aa2c666f84b10ad12c6c334811d/03_cart_pole/src/optimize_hyperparameters.py#L17" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">src/optimize_hyperparameters.py</strong></a></code> <strong class="lb iu"> </strong>中的函数<code class="fe oq or os ot b">sample_hyper_parameters()</code>定义，您将会看到我们只提供了对超参数有意义的宽区间或宽范围的值。我们不需要实现任何贝叶斯抽样方法，因为 Optuna 会为我们做。</p><p id="61dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是创建一个 Optuna 研究对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="e8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">观察我们如何将<code class="fe oq or os ot b">storage</code>参数设置为本地<code class="fe oq or os ot b">sqlite</code>文件。这很重要，因为它允许我们在运行代码的计算机或进程由于任何原因崩溃时继续搜索。</p><p id="2356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们用<code class="fe oq or os ot b">study.optimize()</code>开始搜索，并告诉 Optuna 最多尝试 100 次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="0147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的 MacBook 中，达到 500 分的超参数大约需要 15 分钟，也就是完美代理。</p><p id="f1b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议你在 MLflow 仪表板上监控结果，一旦你看到一个代理达到 500 奖励，就中断 Optuna 搜索。</p><p id="13f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我看到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/24e487b8653dbfa293ed9d7b46fdecd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nU3scZUhVHal3Jaq8hapxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">agent_id = 298 是我的赢家(图片由作者提供)</p></figure><p id="9165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，为了让你相信你已经完美地解决了<code class="fe oq or os ot b">CartPole</code>问题，我鼓励你加载你最好的代理(在我的例子中是【T1)……</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="08ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…并再次评估它。你应该每集都得 500 分！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/409e506387350b105d83f049e2809f2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VDModVP1cGcdjWmHbvzpxw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">满分。！(图片由作者提供)</p></figure><p id="3856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答对了。</p><p id="cec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝贺你成功来到这里。我们最终学会了如何调整超参数，以最大限度地提高 Deep Q 代理的性能。</p><p id="0848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一次漫长的<code class="fe oq or os ot b">CartPole</code>冒险之旅。</p><p id="b407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候坐下来，放松一下，回头看看我们刚刚走过的路。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/ee0df8353960440deed77306dee0e1c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DBVaQvYrp-8frTMNoBXBQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">秘鲁帕拉卡斯(图片由作者提供)</p></figure><h1 id="9b3d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.重述✨</h1><p id="6769" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这些是今天的关键要点:</p><ul class=""><li id="9f15" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu ny my mz na bi translated"><strong class="lb iu">深层 RL 的超参数很关键</strong>。你需要实验来找到好的，如果你不遵循智能搜索策略，这可能会非常耗时。在大多数情况下，单靠蛮力(即网格搜索)是不可行的。</li><li id="1921" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ny my mz na bi translated"><strong class="lb iu">贝叶斯搜索方法</strong>是解决这个问题的最佳工具之一。他们探索并了解下一步在超参数空间中最有希望尝试的领域。它们比随机搜索收敛得更快。</li><li id="1c9e" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu ny my mz na bi translated"><strong class="lb iu"> Optuna </strong>是一个非常棒的用于超参数搜索的开源库。这是一个即插即用的解决方案，抽象出贝叶斯搜索背后的所有细节。通过几行代码，您可以构建一个强大的超参数实验管道。</li></ul><h1 id="a528" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.家庭作业📚</h1><p id="f639" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/Paulescu/hands-on-rl/blob/main/03_cart_pole/notebooks/10_homework.ipynb" rel="noopener ugc nofollow" target="_blank">👉🏽笔记本/10 _ 家庭作业. ipynb </a></p><p id="0bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候把手弄脏了:</p><ol class=""><li id="eb38" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/Paulescu/hands-on-rl" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Git 克隆</strong> </a>把 repo 到你的本地机器上。</li><li id="a150" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://github.com/Paulescu/hands-on-rl/tree/main/02_mountain_car#quick-setup" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">设置</strong> </a>本课的环境<code class="fe oq or os ot b">03_cart_pole</code></li><li id="0aff" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">打开<code class="fe oq or os ot b"><a class="ae ky" href="https://github.com/Paulescu/hands-on-rl/blob/main/03_cart_pole/notebooks/10_homework.ipynb" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">03_cart_pole/notebooks/10_homework.ipynb</strong></a></code></li></ol><p id="0635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天的挑战是找到一个更小的网络来完美地解决 CartPole 问题。</p><p id="757d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细观察函数<code class="fe oq or os ot b">sample_hyper_parameters()</code>，你会发现我保持了神经网络结构的固定(即<code class="fe oq or os ot b">nn_hidden_layers = [256, 256]</code>)。</p><p id="70fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能用只有一个隐藏层的 Q 网络找到一个完美的代理吗？</p><h1 id="aefc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.下一步是什么？❤️</h1><p id="4208" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在接下来的讲座中，我们将介绍新的深度 RL 算法。但是，在我们到达那里之前，我想分享一个技巧来加快你的训练循环。</p><p id="ee2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一课中，我将分享我用来在 GPU 上训练深度 RL 模型的一个技巧，价格合理… $0。</p><p id="0748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想知道怎么做吗？</p><p id="7e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敬请关注。</p><p id="11fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那之前，</p><p id="541a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和平、爱和学习。</p></div><div class="ab cl pg ph hx pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="im in io ip iq"><p id="09e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想成为机器学习专家，接触机器学习和数据科学的顶级课程吗？</p><p id="24df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉🏽订阅<a class="ae ky" href="https://datamachines.xyz/subscribe/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ou">【数据机】</em>通迅</strong> </a> <strong class="lb iu">。</strong></p><p id="65d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉🏽<a class="ae ky" href="https://pau-labarta-bajo.medium.com/" rel="noopener"> <strong class="lb iu">跟着我</strong> </a>上媒。</p><p id="2410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">👉🏽<a class="ae ky" href="https://github.com/Paulescu/hands-on-rl" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">给科目 GitHub 回购</strong> </a>一个⭐</p><p id="7084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你愉快，🧡❤️💙</p><p id="eea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">避寒胜地</p></div></div>    
</body>
</html>