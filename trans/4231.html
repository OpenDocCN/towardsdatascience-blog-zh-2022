<html>
<head>
<title>Normalize any Continuously Distributed Data with a Couple of Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用几行代码规范化任何连续分布的数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/normalize-any-continuously-distributed-data-with-a-couple-of-lines-of-code-5b68454fd2f6#2022-09-20">https://towardsdatascience.com/normalize-any-continuously-distributed-data-with-a-couple-of-lines-of-code-5b68454fd2f6#2022-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db6d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用逆变换采样来改进您的模型</h2></div><p id="e313" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">规范化数据是数据科学中的一项常见任务。有时，它允许我们加快梯度下降或提高模型精度，在某些情况下，它绝对至关重要。例如，我在上一篇文章中描述的模型不能处理非正态分布的目标。一些标准化技术，比如取对数，可能在大多数时候都有效，但是在这种情况下，我决定尝试一些对任何数据都有效的技术，不管它最初是如何分布的。下面我将描述的方法是基于<a class="ae lb" href="https://en.wikipedia.org/wiki/Inverse_transform_sampling" rel="noopener ugc nofollow" target="_blank">逆变换采样</a>:主要思想是基于数据的统计特性构造这样的函数F，所以F(x)是正态分布的。下面是怎么做的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/8f9c309c75813560611b1bbeb9ba5ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPI_IAzFAFf77BsErhGmJA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">作者图片</p></figure><p id="bc94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我说的算法是基于逆变换采样法。这种方法广泛应用于伪随机数生成器中，从任何给定的分布中生成数字。有了均匀分布的数据，你总是可以用任何给定的累积密度函数(或简称为CDF)将其转换成分布。CDF显示了小于给定值的分布数据点的比例，并且基本上表示了分布的所有统计特性。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/9a5f875a89a853f3bd347e726d2b5067.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*A9OgLGrWnzscNYjK9-a5Yw.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">均值和单位方差为零的正态分布的CDF。显示几乎所有的点都大于-4小于4，其中50%小于0(图片作者提供)</p></figure><p id="84eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">主要思想是，对于任何连续分布的数据，xᵢ(cdf(xᵢ)是均匀分布的。换句话说，要得到均匀分布的数据，只需取每个点的CDF。这种说法的数学证明超出了本文的范围，但是上述操作实际上只是对所有值进行排序，并用每个值的编号来替换它，这给了它一种直观的感觉。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/0f30820a80c1976d214b12aa15181a23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/1*SJZgmR751jHkz6yzU3wIgw.gif"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">将一些杂乱的数据转换成统一的数据(图片由作者提供)</p></figure><p id="3f6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的gif中，你可以看到它是如何工作的。我生成了一些杂乱的分布式数据，然后计算它的CDF(红线)并用它转换日期。现在数据均匀分布。</p><p id="dd71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算CDF比看起来容易。记住，CDF是比给定数据小的一部分数据。</p><pre class="ld le lf lg gt lu lv lw lx aw ly bi"><span id="841f" class="lz ma iq lv b gy mb mc l md me">def CDF(x, data):  <br/>   return sum(data &lt;= x) / len(data)</span></pre><p id="dace" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得一提的是，CDF通常是一个双射函数，这意味着转换是可逆的。我们可以利用这一事实将得到的均匀分布转换成我们想要的任何分布，比如正态分布。为了做到这一点，我们需要计算我们想要得到的分布的逆CDF。一般来说，这不是最容易的任务。我们需要的函数叫做百分点函数，简称PPF。对我们来说幸运的是，任何主要发行版的PPF都可以通过SciPy库访问，不需要自己计算。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/bbba53648db8a12b96062db3d46db06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*y0dILbZnmsC-WdTWPhFj5Q.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">均值和单位方差为零的正态分布的PPF。它显示第50百分位是0，超过60%的点位于-1和1之间(图片由作者提供)</p></figure><p id="48d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是如何解释它:对于任何介于0和1之间的参数x，PPF返回该点的最大值，以适合第x个百分位数。同时，作为CDF的反函数，它看起来像第一张图片中的函数，只是旋转了90度。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/ebbd2a8edeed60ffffc3d7c323a28fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/1*pD2bV6NYJ1b6kpjQR6tXCA.gif"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">从均匀分布获得正态分布(图片由作者提供)</p></figure><p id="c339" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个理想的正态分布。最后，要创建一个转换初始数据的函数，我们只需将这两个操作合并成一个函数:</p><pre class="ld le lf lg gt lu lv lw lx aw ly bi"><span id="7d6a" class="lz ma iq lv b gy mb mc l md me">from scipy.stats import norm</span><span id="560e" class="lz ma iq lv b gy mg mc l md me">def normalize(x, data):<br/>   x_uniform = CDF(x, data)<br/>   return norm.ppf(x_uniform)</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f0e02f78b2f679fb2dbe47d806b7ce12.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/1*zLhumPOuJd_7bA6XSZ-xVQ.gif"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">将初始杂乱分布转换为具有零均值和单位方差的正态分布(图片由作者提供)</p></figure><p id="9b18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上图中的红线代表最终的变换函数。</p><p id="f062" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，我们可以很容易地将数据转换成任何其他分布，只需用一个期望的分布替换PPF。下面是我们把杂乱的数据转换成对数正态分布。注意变换曲线是如何不同的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/520dcbc49392bf205847f93f9bb25973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/1*4l9abDsyyYk-C-9m--0rxg.gif"/></div></figure><p id="5a57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意最后的变换总是单调的。这意味着在变换后没有两点被交换。如果一个点的初始要素值大于另一个点的初始要素值，则在变换后，该点的变换值也将更大。这一事实允许该算法应用于数据科学任务。</p><p id="d544" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，与更常见的方法不同，本文描述的算法不需要任何关于初始分布的假设。同时，输出数据极其精确地遵循正态分布。这种方法已被证明可以提高假设输入数据分布的模型的准确性。比如上一篇文章的<a class="ae lb" href="https://medium.com/towards-data-science/using-bayesian-statistics-to-predict-cafes-popularity-with-geodata-3286deaffc2" rel="noopener">贝叶斯模型</a>在没有数据归一化的情况下R ~ 0.2，在归一化数据的情况下R为0.34。线性模型也显示，在标准化数据上，R提高了3-5个百分点。</p><p id="fd0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样。感谢您的时间，我希望这篇文章对您有用！</p></div></div>    
</body>
</html>