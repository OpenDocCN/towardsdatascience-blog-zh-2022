<html>
<head>
<title>10 Atrocious Python Mistakes To Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的 10 个可怕的 Python 错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/10-atrocious-python-mistakes-to-avoid-12fb228d60a1#2022-02-15">https://towardsdatascience.com/10-atrocious-python-mistakes-to-avoid-12fb228d60a1#2022-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dfe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 程序员经常犯的一些常见错误，但可能不应该犯</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd090b2a89ef2832076efd43fe63569f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nNyRAEUxmJbajaO6VJB_w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-963931/" rel="noopener ugc nofollow" target="_blank"> Klinkow </a>提供)</p></figure><h1 id="fc6c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="7715" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated"><span class="l mo mp mq bm mr ms mt mu mv di">在</span>我们编程和/或数据科学职业生涯中的某个时刻，我们可能不得不学习一门新语言，并了解它的所有知识。在许多情况下，我们可以用多种方式来解决问题。然而，当谈到编程时，有时有“正确的”方法来处理一些事情，有时有“错误的”方法来处理一些事情。Python 也不例外，如果说有什么事情倾向于仅仅因为它的可访问性而将这些问题变成现实的话；任何说英语的人都可能会假设 Python 中最基本的东西，当有多种更好的方法可供选择时，很容易陷入一种技术来解决问题。</p><p id="5a44" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">今天，我想看看一些新的 Python 程序员做的一些糟糕的事情，并谈谈为什么有更好的方法来处理和解决他们的 Python 代码中的问题。虽然其中一些不一定是功能性的，这意味着您的代码可能会以两种方式运行，但它们确实提供了更好地了解的好处。此外，他们中的许多人使代码更加简洁，或者有时加快了代码的速度。不管是哪一种情况，编程技能都在不断提高，这些是我的一些建议，它们将改善您的 Python 技能中包含的外观和技术！</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="5451" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">№1:将 Python 视为一种完全解释的语言</h1><p id="fb3b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然在一些数据科学场景中，Python 将被更多地解释——例如当我们使用 Jupyter 内核时，许多人可能会惊讶地发现 Python 只是被部分地解释了。语言不仅被解释，而且被编译。在您使用 Python 的经验中，您可能已经注意到。pyc 文件和 Python 文件一起运行。这些文件包含编译后的 Python，信不信由你。</p><p id="76ad" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然而，还有另一个重要的区别。通常，编译器将代码放入一个新文件中，该文件模拟汇编中处理器的调用。然而，在 Python 的情况下，编译后的版本是字节码——这意味着它们仍然需要 C 来管理内存并推送到注册表，但是它们不需要在每次运行 Python 代码时都进行解释。请记住，虽然这种区别更多的是一种想法，而不是一个实际问题，但在您按下 return 键后，改变您对 Python 工作方式的看法(至少在一定程度上)是一个好主意。</p><h1 id="2521" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№2:总是在范围内循环</h1><p id="a3c6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我认为在线教程的一个问题是在范围内循环，在线教程只是展示一个选择的例子。简而言之，我们对范围的循环太多了。当你来自另一种语言时，这很有意义，因为在其他语言中，我们通常只考虑循环遍历索引，而不是元素。然而，在 Python 中，事实并非如此，最终会比您想象的更多地阻碍您的代码。</p><p id="472a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">相反，您可以直接循环元素，就像这样</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bb21" class="ns la it no b gy nt nu l nv nw">x = [5, 10, 15]<br/>for n in x:<br/>    pass</span></pre><p id="e44e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">范围通常也用于一次获取多个列表的元素，但是如果是这种情况，使用 enumerate()或 zip()可能会更好。有很多方法可以完成这类事情，但是如果你马上索引你的值，迭代枚举的全部意义就是索引你的结构，那么让这些值成为循环不变量就更有意义了。</p><h1 id="3b2b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№3:导入*</h1><p id="bc7b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我认为网上教程中的一个错误是引入 star 的想法。导入 star 有其使用案例，例如，我认为在笔记本中从 NumPy 导入 star 很有意义，因为如果您正在处理矩阵等，您可能需要 NumPy 中的所有内容。导入 star 的问题是，我们现在从这个模块全局定义名字，用新的定义在运行时环境中乱丢东西，其中大部分我们可能不会使用。</p><p id="0872" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">即使这样，您也可以在 Python 中给名称空间起别名，所以如果您想导入整个模块，那么只给模块起别名更有意义。通过别名，您可以将名称空间/模块的调用转换成一两个字母，因此拥有所有这些全局定义的方法、值等就没有什么意义了。那可能最终会打乱你的通话。而是直接导入或者别名如下。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8196" class="ns la it no b gy nt nu l nv nw">import numpy as np<br/>from numpy.linalg import dot</span></pre><h1 id="0c42" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№4:字符串串联</h1><p id="2ebf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在 Python 中，字符串连接非常简单，用加法运算符就可以完成。虽然这绝对是一种很好的方法，并且使用这个操作符连接字符串没有任何问题，但是在某些情况下使用 f 字符串可能更有意义。当然，有些时候使用加法运算符更有意义，因为有时您只是连接一个或两个值，例如，如果运算符版本用于类似这样的情况，我不会发疯:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9b53" class="ns la it no b gy nt nu l nv nw">"hi" + "hi"</span></pre><p id="ddfd" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">然而，如果你有很多值，不管什么原因，使用 f 字符串更有意义。这些类型的字符串允许您插入带有某种程度插值的字符串。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6a05" class="ns la it no b gy nt nu l nv nw">f"Hello my name is {name} and I like {food}"</span></pre><h1 id="84fe" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№5:手动关闭文件</h1><p id="53f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">新的 Python 程序员犯的一个大错误是以这样的方式处理文件:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1c97" class="ns la it no b gy nt nu l nv nw">file = open("whatever.txt", 'r')<br/>file.write("spaghetti")<br/>file.close()</span></pre><p id="c100" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这种方法的问题是，如果在创建文件对象和关闭文件之间出现任何异常，文件将保持打开状态。相反，使用 with 块是一个更好的主意。这实际上不仅仅是文件的情况，通常是流的情况，尤其是开放这种语法是一个好主意。这是因为每当我们这样做的时候，我们就创建了一个新的范围级别，在这个范围中定义了文件，在语句运行之后，这个范围就被删除了，因此，在那个时刻创建的所有对象都被立即删除了。相反，应该这样编写上面的示例:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f86c" class="ns la it no b gy nt nu l nv nw">with open("whatever.txt", 'r') as file:<br/>    file.write("spaghetti")<br/>    file.close()</span></pre><h1 id="ee70" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№6:使用裸露例外</h1><p id="96e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">另一个新手常犯的错误是在 try/except 块中使用简单的异常。这是一个坏主意的原因是因为这些异常是开放式的。每当一个例外是开放式的，我们就为任何可能出现的例外留有余地。例如，我们可以在块下处理一个中断异常。然后我们的代码无缘无故地运行，因为它被中断了，而不是中断简单地停止我们正在做的事情，它做得更多。相反，您应该在其中插入一个真正的异常。</p><h1 id="ddf3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№7:可变默认值</h1><p id="faca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我经常看到 Python 代码不应该做的事情是为位置参数提供可变的默认值。参数默认值是在定义给定函数时设置的，而不是在运行时设置的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9cb6" class="ns la it no b gy nt nu l nv nw">def hello(x : int, y = []):</span></pre><p id="dda9" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这意味着对这个函数的每个调用现在都共享 y，所以如果我们要向 y 追加一些东西，那么我们 hello()函数的每个后续调用都将使用这个 y 作为缺省值，我们将使用一个现在充满值的 y。相反，应该将它设置为 None 作为占位符，然后用一个有条件的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="ab0a" class="ns la it no b gy nt nu l nv nw">def hello(X : int, y = None):<br/>    if y is None:<br/>        y = []</span></pre><h1 id="989d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№8:错过理解</h1><p id="441a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">理解是完成很多事情的捷径。此外，作用域和类似的东西可以在我们不使用理解的时候打开，这样只会耗尽内存和编译时间。我们可以对列表、字典甚至生成器使用理解。下面是一个简单的列表理解的例子，与迭代的对应部分相比，它节省了时间:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f647" class="ns la it no b gy nt nu l nv nw">lst = [5 * 5 for _ in range(1, 10)]</span><span id="c7da" class="ns la it no b gy nx nu l nv nw">lst = []<br/>for _ in range(1, 10):<br/>    lst.append(5 * 5)</span></pre><h1 id="de80" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№9:使用==检查类型</h1><p id="17e8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在 Python 中可以做的一件愚蠢的事情是用==一前一后地调用 type()方法，以便检查特定对象的类型。首先，在这种情况下使用 is 关键字可能是一个更好的主意，但这可能有问题的另一个原因是 Python 将子类表示为同一个类，所以如果我们问一个命名的元组是否是元组，我们会得到 true——尽管从技术上讲这不是元组。我同意；Python 可以使用某种单一调度系统，它要求参数在提供时是某种类型，而不是在函数的后面，然而，不管我们认为什么可能更好，这仍然是事实。也就是说，在某些情况下，您可能希望像这样检查您的类型，但在大多数情况下，这是绝对应该避免的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="fdf4" class="ns la it no b gy nt nu l nv nw">if typeof(x) == tuple:<br/>    pass</span></pre><p id="f8c6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">根据 Liskov 替换原则，子类型应该能够替换其父类型。这种用==检查类型的想法直接违反了这个原则。我不相信所有这些花哨的标签和定义，但肯定有理由认为这是一个坏主意。相反，您可能应该使用 isinstance()方法，该方法能够直接检查给定的 pyobject 是否是构造函数的实例。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="cf50" class="ns la it no b gy nt nu l nv nw">if isinstance(x, tuple):</span></pre><h1 id="0745" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">№10:单身人士的平等</h1><p id="3d03" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我长期以来犯的一个错误是检查平等性而不是同一性。按位相等运算符==，是我们熟悉的东西，而且它很有效，所以很多人最终都这么做是有道理的。但是，如果我们想检查某个东西是真、假还是被定义为无，我们应该使用 is。这是因为 is 和==在语义上是不同的，虽然它们可能都在这些场景中工作，但是一个对另一个的使用对于代码的逻辑是很重要的。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5595" class="ns la it no b gy nt nu l nv nw">if x is None</span></pre></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="3101" class="kz la it bd lb lc ni le lf lg nj li lj jz nk ka ll kc nl kd ln kf nm kg lp lq bi translated">结论</h1><p id="0f40" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python 是一种很棒的编程语言，但是结合吸收少量代码和简单地不知道任何更好的东西，它确实让你很容易暴露自己没有经验。此外，有些事情你可以继续以更糟糕的方式去做，导致错误，或者在某些情况下是错误的，但在其他情况下不是，即使你已经非常有经验了。</p><p id="bba6" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">要明确的是，对于其中的一些人来说，犯这些错误并没有什么错。您的代码可能仍然会运行，但您的代码也会脱颖而出。像这样的编程可能会很成问题。感谢您阅读这篇文章，我希望它对您复习 Python 技巧有所帮助，并为您可能偶然学到的东西提供更多的背景知识！</p></div></div>    
</body>
</html>