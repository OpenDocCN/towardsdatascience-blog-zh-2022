<html>
<head>
<title>How to Mitigate Memory Issues in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何缓解 Python 中的内存问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-mitigate-memory-issues-in-python-c791b2c5ce7e#2022-11-15">https://towardsdatascience.com/how-to-mitigate-memory-issues-in-python-c791b2c5ce7e#2022-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个小窍门，可以节省你的时间、精力和成本。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cba63e6572914326fa1c3537b237c7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IkbH-5noT_ntLxut"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@flipsnack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Flipsnack </a>拍摄的照片</p></figure><p id="a09e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，由于 Python 中管理内存的方式，我遇到了一个问题，在内存受限的环境中使用 Pandas 数据帧和 Numpy 数组可能会变得很严重。这个问题让我花了两天时间，而不是预计的两个小时来实现一个标准的数据处理任务。真扫兴！</p><p id="6ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们所有的时间都是很昂贵的，所以我写下了我的学习，这样将来的我，也许你可以避免这个问题，节省时间，成本和精力。你准备好了吗？我的故事来了。</p><h1 id="90de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">故事</h1><p id="e556" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我必须使用一个<a class="ae ky" href="https://aws.amazon.com/ecs/" rel="noopener ugc nofollow" target="_blank"> AWS 弹性容器服务</a> (ECS)任务在云中处理一堆拼花文件。我想:没有比这更简单的了，我将使用<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>依次加载每个文件，应用我的机器学习模型，保存结果，我就完成了。没什么特别的，只是一个基本的数据处理任务。我的代码大致如下:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="9e99" class="mx lw it mt b be my mz l na nb">import pandas as pd<br/><br/>class Processor:<br/>  def run(self, file_names: list[str]) -&gt; None: <br/>    for file_name in file_names:<br/>      data = pd.read_parquet(file_name)<br/>      result = self._process(data)<br/>      self._save(result)</span></pre><p id="15e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要在 ECS 上做到这一点，您必须编写一个 docker 文件，并设置一个 ECS 任务，相应的容器将在其中运行。在那里，您必须指定想要使用多少 CPU 和多少内存。显然，你走得越高，它就变得越贵，你给的钱就越多。由于我的每个文件只有几百兆大，我想我可以选择一个小的大小，因此不必在 AWS 上花费太多。所以我选择了两个 CPU 和 8g 内存。对我来说，考虑到我的数据量，这听起来已经有点夸张了。但我想保险起见，并认为现在可能会出错吗？</p><h2 id="6fff" class="nc lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">问题是</h2><p id="ac50" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因此，我满怀信心地部署了我的容器，并开始了 ECS 任务。第一个文件已成功加载和处理。是啊。第二个文件已成功加载和处理。是的。第三次、第四次和第五次也是如此，但之后…</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="40f3" class="mx lw it mt b be my mz l na nb">Container exited with code 137. Reason was OutOfMemoryError: <br/>Container killed due to memory usage</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/eb917b504fdee9a457cb9f13ea03937f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NadddvgXIK6O8Tjp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯蒂芬·拉德福德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bde3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么？我没想到会发生这种事。8 Gb 的内存怎么可能不够处理一个只有几百兆大小的文件？更重要的是，由于每个文件的大小完全相同，为什么这个问题只发生在第六个文件之后，而不是直接发生在第一个文件上？关于 Python 中如何管理内存，肯定有什么地方出错了，或者说是我没有考虑到的地方。</p><p id="7307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我谷歌了一下 Python 中的内存管理，学习了<a class="ae ky" rel="noopener" target="_blank" href="/memory-management-and-garbage-collection-in-python-c1cb51d1612c">引用计数和垃圾收集</a>的基础知识。简单来说，引用计数就是计算 python 对象在代码中被主动引用的频率。如果一个对象在任何地方都不再被引用，也就是说，它的引用计数器为零，Python 垃圾收集器可以介入并释放这个对象占用的内存。很好，听起来很琐碎。</p><h2 id="99f2" class="nc lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">无效的解决方案</h2><p id="06b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">因此，我认为加强这种行为将解决我的问题，我终于可以完成我的任务。那你做了什么？为了将引用计数器减少到零，我在引用数据的变量上使用了<code class="fe np nq nr mt b"><strong class="lb iu">del</strong></code> <strong class="lb iu"> </strong>。为了强制垃圾收集器在那之后立即运行，我显式地使用了来自<a class="ae ky" href="https://docs.python.org/3/library/gc.html" rel="noopener ugc nofollow" target="_blank"> gc </a>模块的<code class="fe np nq nr mt b"><strong class="lb iu">collect</strong></code>函数。有了这个，我的更新版本大致如下</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="3ac2" class="mx lw it mt b be my mz l na nb">import pandas as pd<br/>import gc<br/><br/>class Processor:<br/>  def run(self, file_names: list[str]) -&gt; None: <br/>    for file_name in file_names:<br/>      data = pd.read_parquet(file_name)<br/>      result = self._process(data)<br/>      self._save(result)<br/>      del result<br/>      del data<br/>      gc.collect()</span></pre><p id="9cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怀着非常高的希望，我部署了这个更新版本，启动了容器，等待处理第六个文件。猜猜发生了什么？<em class="ns">由于内存使用，容器被杀死。</em></p><p id="bb88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">妈的，一点进步都没有<em class="ns">。很明显，在我最基本的代码中还隐藏着一些我无法影响的东西，它们一直占据着我的内存。</em></p><p id="c1d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们现在应该做些什么来解决这样一个常见的数据工程问题呢？选择更多的内存并进一步增加杰夫·贝索斯的财富是唯一的出路吗？幸运的是，这个问题的答案是<strong class="lb iu"> <em class="ns">不是</em> </strong>。有一种方法应该总是有效的，尽管感觉有点粗糙。</p><h2 id="9d58" class="nc lw it bd lx nd ne dn mb nf ng dp mf li nh ni mh lm nj nk mj lq nl nm ml nn bi translated">工作解决方案</h2><p id="fffb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了确保在一个函数完成后释放内存或其他资源，您所要做的就是在不同的进程中执行该函数。当该进程完成时，<em class="ns">操作系统</em> (OS)释放该进程已经获得的所有资源。这总是独立于底层操作系统工作。需要注意的是，启动一个进程会降低整体性能。</p><p id="9f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 Python 的进程中运行函数的一种方式是通过标准的<a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多处理模块</a>。然而，这要求函数及其所有参数都是可选择的。参见这个<a class="ae ky" href="https://docs.python.org/3/library/pickle.html#what-can-be-pickled-and-unpickled" rel="noopener ugc nofollow" target="_blank">网站</a>获取可供选择的类型列表。在我的例子中，情况并非如此，因为我想运行一个类的方法，使用默认的 pickle 库是不可选择的。该死的。</p><p id="d51a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，有一个名为<a class="ae ky" href="https://loky.readthedocs.io/en/stable/API.html" rel="noopener ugc nofollow" target="_blank"> loky </a>的不错的第三方库，它使用了引擎盖下的<a class="ae ky" href="https://github.com/cloudpipe/cloudpickle" rel="noopener ugc nofollow" target="_blank"> cloudpickle </a>模块，几乎可以腌制任何东西。太好了！</p><p id="7878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些，我的最终解决方案看起来像</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="53ff" class="mx lw it mt b be my mz l na nb">import pandas as pd<br/>import gc<br/>from loky import get_reusable_executor<br/># I only need one workere as I don't want to do multiprocessing<br/>executor = get_reusable_executor(max_workers=1)<br/><br/>class Processor:<br/>  def _execute(self, file_name:str) -&gt; None:<br/>    data = pd.read_parquet(file_name)<br/>    result = self._process(data)<br/>    self._save(result)<br/><br/>  def run(self, file_names: list[str]) -&gt; None: <br/>    for file_name in file_names:<br/>      executor.submit(self._execute, file_name).result()<br/>      </span></pre><p id="f520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里你可以看到我已经为 <em class="ns">循环</em>拉出了<em class="ns">的内部部分，在这里数据被加载、处理并存储到一个单独的函数中。这个函数我现在使用 loky executor 在一个专用的进程中运行这个函数，它确保了一旦完成就释放内存。这样，我的任务成功地处理了所有文件，我甚至能够进一步减少所需的内存量。最后，</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/8b63d9e2715ea06c136484f830050045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ouE7NNiQZyjuk8Oz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rayhennessy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷·轩尼诗</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="7a86" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">包裹</h1><p id="80f6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我的短文中，我谈到了 Python 应用程序中没有释放内存的问题。在像 AWS ECS 这样内存受限的环境中运行时，这个问题可能会很严重。通过将一个函数的执行放在一个专用的进程中，您可以确保在函数完成时释放内存等资源。希望，这对你以后有所帮助。</p><p id="58cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您关注这篇文章。一如既往，如果有任何问题、意见或建议，请随时联系我或关注我，无论是在 Medium 还是通过<a class="ae ky" href="https://www.linkedin.com/in/simon-hawe-75832057" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>。</p></div></div>    
</body>
</html>