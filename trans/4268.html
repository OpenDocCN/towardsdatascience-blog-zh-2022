<html>
<head>
<title>Enabling continuous integration for DBT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现DBT的持续集成</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/enabling-continuous-integration-for-dbt-f77a5b8ce994#2022-09-21">https://towardsdatascience.com/enabling-continuous-integration-for-dbt-f77a5b8ce994#2022-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9938" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Github Actions和Docker自动化测试、宏、种子文件、完整dbt加载等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94c71cd9eaa900b643f909af5c6c21f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7H0nmIp0OOvlVgQg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0a48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名数据工程师，我认为工作要求的一句俏皮话是“能够解决问题”。我喜欢我工作的这一部分。对我来说，处理一个任务或问题并为它建立一个解决方案是非常值得的。</p><p id="a69a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我喜欢在工作中解决问题和开发解决方案，但我<em class="ls">不</em>特别是<em class="ls"> </em>喜欢重复的任务。当我发现自己一遍又一遍地做同样的事情时，我经常问自己“这里缺少了什么？我能做些什么来简化或自动化这一过程？”</p><p id="09c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题是最近用<a class="ae kv" href="https://docs.getdbt.com/docs/introduction" rel="noopener ugc nofollow" target="_blank"> dbt </a>(数据构建工具)提出来的。我使用dbt来构建数据仓库和模型，供业务分析师和执行报告在下游使用。dbt是一个非常棒的工具，它有很多我不会在本文中介绍的好处。尽管对于dbt的所有优点来说，我目前并不喜欢为生产准备dbt代码的过程。</p><p id="4918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个标准的dbt命令链，希望在打开PR进行审查之前运行。该链通常如下所示，可能需要大约20-30分钟来运行，具体取决于我们拥有的模型和测试的数量:</p><pre class="kg kh ki kj gt lt lu lv bn lw lx bi"><span id="56e9" class="ly lz iq lu b be ma mb l mc md">dbt deps<br/>dbt seed<br/>dbt snapshot<br/>dbt run<br/>dbt run-operation {{ macro_name }}<br/>dbt test</span></pre><p id="3e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使错过这些命令中的一个，也可能导致生产管道中的故障，从而导致下游消费者的大规模中断。</p><p id="d6d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我知道开发和测试干净的代码有多重要，但我不想等着输入每一个命令并希望它们成功。我更愿意提交我的提交，打开一个PR，让一个自动化的工作流为我处理这个过程，同时我开始一个新的任务。然后我可以稍后回来检查运行的结果。</p><p id="e248" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现这一点，我构建了一个自动化的CI工作流，它利用了一个Docker容器，该容器可以启动、安装dbt及其依赖项，并通过GitHub操作运行我的存储库中可用的模型和测试。</p><h2 id="66cc" class="me lz iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">要求</h2><ol class=""><li id="702d" class="mw mx iq ky b kz my lc mz lf na lj nb ln nc lr nd ne nf ng bi translated">用模型和数据源配置的现有dbt项目(我使用的是雪花)</li><li id="7942" class="mw mx iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">GitHub回购</li><li id="3b6e" class="mw mx iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">Dockerfile文件</li></ol></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h2 id="8eb7" class="me lz iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">码头集装箱</h2><p id="e1c7" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">我将<code class="fe nw nx ny lu b">python:3.9-bullseye</code>作为Docker容器的基础<a class="ae kv" href="https://hub.docker.com/layers/library/python/3.9-bullseye/images/sha256-a8bb865d30b5eb878f26d19479fe8ec258efe410a459271476e07eef854e9d66?context=explore" rel="noopener ugc nofollow" target="_blank">图像</a>。从那里，我将dbt目录复制到容器中，安装所需的dbt包，并添加构建参数来处理dbt的环境雪花凭证*。</p><p id="f915" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件的后半部分，我将目标环境切换到<code class="fe nw nx ny lu b">test</code>并执行PR批准所需的必要dbt命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d455" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">传入构建参数，然后将这些值设置为DBT的容器环境变量，这似乎有些重复，但是我无法找到一种方法来使用docker构建命令设置环境变量，就像您可以使用构建参数一样。如果你对此有更好的想法，那么我们来聊聊吧！</p><h2 id="39bb" class="me lz iq bd mf mg mh dn mi mj mk dp ml lf mm mn mo lj mp mq mr ln ms mt mu mv bi translated">工作流文件</h2><p id="906b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">接下来，应该构建docker容器，并在打开pull请求和添加其他提交时运行列出的dbt命令。然而，我只希望这个动作在<code class="fe nw nx ny lu b">/dbt</code>目录中发生变化时执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3e36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了执行这个工作流文件，我建议对您的dbt数据源凭证使用类似的存储库机密。这个文件应该放在项目根目录下的<code class="fe nw nx ny lu b">.github/workflows</code>目录中。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="7d4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这两个文件，您的项目应该可以开始了！每当打开包含对<code class="fe nw nx ny lu b">/dbt</code>目录所做更改的PR时，就会触发一个工作流来启动Docker容器并运行Docker文件中列出的指定dbt命令。</p><p id="1649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是为数据仓库构建可靠的CI(持续集成)管道的第一步。CI的<a class="ae kv" href="https://about.gitlab.com/topics/ci-cd/benefits-continuous-integration/#:~:text=Continuous%20integration%20(CI)%20makes%20software,the%20overall%20pace%20of%20innovation." rel="noopener ugc nofollow" target="_blank">好处</a>可以包括使开发更容易、更快、风险更小。在将变更推向生产之前，对其进行彻底的测试，这可以建立信任，并获得涉众和开发团队的支持。我强烈建议在您的数据仓库生命周期中实现和自动化CI流程(如果还没有实现的话)。</p><p id="fea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对这篇文章的内容有其他问题，请联系我，如果我的其他一些帖子引起了你的注意，请查看一下！</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="38fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">*注意:我只是在一个私有的org存储库中构建带有GitHub动作的Docker容器。我能够管理该存储库的适当机密，并使用这些机密来存储该配置项的凭据。我不建议将你的容器推送到注册中心，因为在存储库机密和凭证方面存在潜在的安全隐患。</p></div></div>    
</body>
</html>