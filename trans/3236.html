<html>
<head>
<title>A Case Study in Optimizing Programs Through Code Review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过代码评审优化程序的案例研究</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-case-study-in-optimizing-programs-through-code-review-302f994fe7ec#2022-07-18">https://towardsdatascience.com/a-case-study-in-optimizing-programs-through-code-review-302f994fe7ec#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5b8d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据科学项目的持续改进需要坚持不懈的努力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42c9ebb9a6e5fd622ed501b279a647d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WM1nhr0c1ekJ9qX7"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</p></figure><p id="0782" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">拥有相对成熟的数据科学团队的组织的一个更不受重视的方面是持续改进的强大文化。对于负责创建和维护复杂软件解决方案的技术团队来说，参与到提高团队代码库整体质量的实践中尤为重要。无论是已经在生产中的现有过程，还是完成可重复任务的标准化包/代码，定期和严格的代码审查通过减少错误、安全问题和资源使用的可能性，使主要和第三利益相关者都受益。</p><p id="bbb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">审查别人写的代码，通常很少有文档或上下文，有时会很困难和不愉快。但香肠就是这么做的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="7c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我举例说明了一个例子，在这个例子中，我能够显著减少程序运行所需的最大计算空间和总处理时间。真正酷的是，我最初并没有想这么做；它起源于一个旨在重组程序以在一组已建立的KPI上表现更好的计划。<strong class="ky ir">有时候最好的事情发生在你意想不到的时候。</strong></p><p id="2839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，一些背景。在某一点上，程序(用Python编写)从一组对象中随机抽取样本，并记录该组的关键指标。它这样做了很多次。目标是确定一个样本对象，使关键指标的值最大化，供以后使用。在检查代码的正确性时，我发现了一些明显增加了整体运行时和内存使用的东西，这些东西是不需要存在的。</p><p id="9a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题在于随机抽样的结果是如何储存的。因为在后面的步骤中需要这个样本，所以程序最初创建了一个列表，使用一个<em class="lz"> for </em>循环来存储每次迭代的每个样本的pandas数据帧。虽然这达到了它的目的，但内存中列表的大小是作为两个变量的函数而增加的:<em class="lz">for循环中的迭代次数，以及所取样本的大小。对于相对较小的样本和迭代，该过程运行良好。但是，如果将样本量从1，000增加到100，000，迭代次数从5，000增加到500，000，会发生什么呢？它可以极大地改变所需的内存使用量，而且不管您的技术架构如何，效率低下的程序都会因不必要的计算资源和浪费的时间而给组织带来实实在在的损失。</em></p><p id="6be5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们快速构建一组示例数据来说明这个问题。我们将使用一个特定时间范围内销售的购物者id的例子；它可以是特定于一组产品、销售渠道、地理位置等的销售。—发挥你的想象力！</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="b8e9" class="mf mg iq mb b gy mh mi l mj mk">import pandas as pd<br/>import numpy as np</span><span id="945f" class="mf mg iq mb b gy ml mi l mj mk"># Set how many iterations to run, &amp; size of ID sample in each iteration<br/>n_iters = 100000<br/>smpl_sz = 500000</span><span id="0064" class="mf mg iq mb b gy ml mi l mj mk"># Create a sample df with 10MM unique IDs<br/># - Generate some dummy sales data to play with later<br/>id_samp = pd.DataFrame(range(10000000,20000000))<br/>id_samp.columns = ['Customer_ID']<br/>id_samp['Sales_Per_ID'] = np.random.normal(loc = 1000, scale = 150, size = len(id_samp))<br/>print(id_samp.head())</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/28aa54e25141d401acd32f414df22bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*BVFCQye7NvlEwGfPUxfyFA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Spyder中上述代码生成的输出的作者图片</p></figure><p id="0014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，程序最初将每个样本存储在主列表中，这将样本大小引入了内存存储等式。对于更昂贵的数据对象，例如字符串或用户创建的对象与整数相比，这种情况会变得更糟。</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="c4d4" class="mf mg iq mb b gy mh mi l mj mk"># Original version<br/># Initialize data objects to store sample, info for each iteration’s sample<br/>metric_of_interest = []<br/>samples = []</span><span id="59ec" class="mf mg iq mb b gy ml mi l mj mk"># In the loop, store each sample as it's created<br/>for i in range(n_iters):<br/> samp = id_samp.sample(n = smpl_sz, axis = ‘rows’, random_state = i)<br/> samples.append(samp)<br/> # Do something with the sample &amp; record add’l info as necessary<br/> metric_of_interest.append(samp[‘Sales_Per_ID’].mean())</span></pre><p id="f219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的关键是，我们不需要在创建时存储每个样本，以便以后访问它。我们可以利用随机抽样函数的固有属性，使用一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Random_seed" rel="noopener ugc nofollow" target="_blank">随机种子</a>来获得可重复性。我不会深究使用随机种子作为最佳实践；但是这里有<a class="ae kv" rel="noopener" target="_blank" href="/how-to-use-random-seeds-effectively-54a4cd855a79">的另一篇媒体文章</a>有一个相当彻底的解释，在这里你可以看到一些关于使用种子/随机状态的<a class="ae kv" href="https://numpy.org/doc/stable/reference/random/generator.html" rel="noopener ugc nofollow" target="_blank"> NumPy </a>和<a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sample.html" rel="noopener ugc nofollow" target="_blank"> Pandas </a>文档。主要的收获是一个整数值可以用来“挑选”采样过程的开始；所以如果你存储了这个值，你就可以复制这个样本。<em class="lz">这样，我们能够通过优化我们的存储方法来消除样本大小和数据类型对内存使用的影响</em>。</p><p id="82d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果将是创建一个随机选择的整数组，每个循环迭代有1个值来创建样本。下面我展示了我自己独特的随机选择这些整数的方法，但是这可以通过很多方式来实现。</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="72bd" class="mf mg iq mb b gy mh mi l mj mk"># Create a random sample of integers for use as ID sample random state seed<br/>#Here, we pull a seq of nums 50x greater than num iters to samp from<br/>rndm_st_sd_pop = pd.Series(range(0,n_iters*50))<br/>rndm_st_sd_samp = rndm_st_sd_pop.sample(n = n_iters, axis = ‘rows’)<br/>del(rndm_st_sd_pop)<br/>print(rndm_st_sd_samp.head())</span></pre><p id="8765" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">注意:在本例中，索引和随机种子值相等</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/ade97c3da0da8e58b84dae3053287f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*rCBYPdduZXh2u0EA947OJw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Spyder中上述代码生成的输出的作者图片</p></figure><p id="5757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以遍历您的随机种子样本，并将每个值作为参数提供给采样函数。请记住，无论使用何种语言，任何值得使用的采样函数都应该有这个参数。</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="b707" class="mf mg iq mb b gy mh mi l mj mk"># Initialize data object(s) to store info for each iter’s sample<br/>metric_of_interest = []</span><span id="1a0f" class="mf mg iq mb b gy ml mi l mj mk"># In the loop, use the random state/seed to produce a sample you can easily reproduce later<br/>for i in rndm_st_sd_samp:<br/> samp = id_samp.sample(n = smpl_sz, axis = ‘rows’, random_state = i)<br/> # Do something with the sample &amp; record add’l info as necessary<br/> metric_of_interest.append(samp[‘Sales_Per_ID’].mean())</span><span id="1f3c" class="mf mg iq mb b gy ml mi l mj mk"># Bind the info saved for each iter to resp seed val for easy lookup<br/>sample_data = pd.DataFrame(<br/>    {'Avg_Sales_Per_ID': metric_of_interest,<br/>     'Smpl_Rndm_St_Seed': rndm_st_sd_samp })<br/>sample_data.reset_index(inplace = True)<br/>print(sample_data.head())</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/3791f079e029ff53ef53310de745f9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*AyU_kp4wTtrQUYNWz38DpA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Spyder中上述代码生成的输出的作者图片</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="1f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，对包和特定使用语言的深刻理解，加上代码审查的标准化过程，导致了运行时性能的实质性提高。这只是影响代码性能和可靠性的一种方式的一个例子，希望能启发你重新审视你很久以前写的东西。至于关于正式审查代码的进一步信息，这里是Stack Overflow的博客中对主题的一个非常好的讨论；还有一个专门讨论这个话题的<a class="ae kv" href="https://codereview.stackexchange.com/" rel="noopener ugc nofollow" target="_blank">栈交换</a>社区。</p></div></div>    
</body>
</html>