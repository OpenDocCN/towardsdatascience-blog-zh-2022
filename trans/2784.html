<html>
<head>
<title>Clean a Messy Date Column with Mixed Formats in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清理Pandas中格式混乱的日期列</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clean-a-messy-date-column-with-mixed-formats-in-pandas-1a88808edbf7#2022-06-16">https://towardsdatascience.com/clean-a-messy-date-column-with-mixed-formats-in-pandas-1a88808edbf7#2022-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b66f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理Pandas Dataframe中混乱的日期字符串列的提示和技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/863d795b15fb8d9820c346d82e109464.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XAeR6CX-PRFfGllAWw6Hww.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/photos/broom-ragpicker-mop-picker-toilet-1837434/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>提供</p></figure><p id="0973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的<code class="fe lv lw lx ly b">datetime</code>列是一个格式混乱的字符串，那么在Pandas中使用<code class="fe lv lw lx ly b">datetime</code>有时会很棘手。您将需要做一些预处理，并将混合格式转换为标准的<code class="fe lv lw lx ly b">datetime</code>类型，以便执行任何后续的数据分析。</p><p id="6091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的例子。在这个数据框架中，我们有一个名为‘joining _ date’的列，它看起来是一个<code class="fe lv lw lx ly b">datetime</code>列，但实际上是一个字符串列。此外，日期都是以不同的格式排列的。</p><p id="9f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于ID a0001，日期字符串排列在DD中。首先写入日期的MM.YYYY格式。对于ID a0005，日期字符串以DD-MM-YY格式显示，其中也首先写入日期。对于ID a0002，日期字符串以MM/DD/YYYY格式排列，首先写入月份，这在美国很常见。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/50a8970010212fe76a62cabf8ee3feea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MAVnU6b1d44hxi_cPv0nDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们能做些什么来简单有效地清理这个混杂格式的日期字符串列呢？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="733f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先试试Pandas的<code class="fe lv lw lx ly b">to_datetime()</code>方法，它可以很容易地将任何有效的日期字符串解析为<code class="fe lv lw lx ly b">datetime</code>。如果我们在没有任何附加参数的情况下简单地执行以下操作，我们会得到如下所示的结果:</p><pre class="kj kk kl km gt mh ly mi mj aw mk bi"><span id="29aa" class="ml mm it ly b gy mn mo l mp mq">df['joining_date'] = pd.to_datetime(df['joining_date'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/749b3785d139620082d43fe521bb1732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*frT4qXhy0EMisbC5l48sQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，使用<code class="fe lv lw lx ly b">pd.to_datetime()</code>方法，我们能够将混合格式的日期字符串解析为标准格式的<code class="fe lv lw lx ly b">datetime</code>(默认为YYYY-MM-DD)。由于<code class="fe lv lw lx ly b">pd.to_datetime()</code>默认解析月首(MM/DD、MM DD或MM-DD)格式的字符串，它将日首格式的日期字符串的日和月混淆了(例如，DD。MM.YYYY表示带有红色叉号的日期)。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="8293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要解决这个问题，我们可以简单地在下面的代码中添加参数<code class="fe lv lw lx ly b">dayfirst=True</code>:</p><pre class="kj kk kl km gt mh ly mi mj aw mk bi"><span id="523e" class="ml mm it ly b gy mn mo l mp mq">df['joining_date'] = pd.to_datetime(df['joining_date'], dayfirst=True)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/d18c6596454d22d2f8c5a6377ed91c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXyVl5dMGEjvb13fEM6Yfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="79e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的。因此，这解决了之前的问题，但产生了新的问题。对于格式为MM/DD/YYYY(第7行)的日期字符串，由于我们将参数<code class="fe lv lw lx ly b">dayfirst=</code>设置为<code class="fe lv lw lx ly b">True</code>，因此它将2016年5月3日转换为2016–03–05，将5视为日，将3视为月。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="5dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个新问题，我们可以应用<code class="fe lv lw lx ly b">np.where()</code>条件，只为首先写入日期的日期字符串设置参数<code class="fe lv lw lx ly b">dayfirst=</code>到<code class="fe lv lw lx ly b">True</code>。</p><pre class="kj kk kl km gt mh ly mi mj aw mk bi"><span id="c37d" class="ml mm it ly b gy mn mo l mp mq">df['joining_date_clean'] = np.where(df['joining_date'].str.contains('/'), pd.to_datetime(df['joining_date']), pd.to_datetime(df['joining_date'], dayfirst=True))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/323bcc76589c9748ebc09f6b588e89b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6eEJ5nHIolhgGhOs6Tn4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d9ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有用！现在我们有了一个更加简洁的日期列。请注意，通过使用<code class="fe lv lw lx ly b">dt.strftime()</code>方法，您还可以指定默认格式之外的输出日期格式。例如，您可以通过指定<code class="fe lv lw lx ly b">dt.strftime(‘%m/%d/%Y’)</code>来选择将输出日期显示为MM/DD/YYYY。</p><pre class="kj kk kl km gt mh ly mi mj aw mk bi"><span id="ea70" class="ml mm it ly b gy mn mo l mp mq">df['joining_date_clean'] = np.where(df['joining_date'].str.contains('/'), pd.to_datetime(df['joining_date']).dt.strftime('%m/%d/%Y'), pd.to_datetime(df['joining_date'], dayfirst=True).dt.strftime('%m/%d/%Y'))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/3055955ffb64adf76f151d4823cbb92f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UvfLIBeMqozaIqOM211sZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就对了。不需要做任何复杂的字符串操作，我们就可以将原始数据集中杂乱的日期字符串转换成标准的<code class="fe lv lw lx ly b">datetime</code>列。我希望您学到了一些在Pandas中处理混乱的日期字符串列的技巧。感谢阅读，希望你喜欢这个简短的教程。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6b6e" class="mv mm it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">数据源:</h1><p id="a95b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">本文中使用的样本数据集是作者出于演示目的创建的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="6ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以通过这个<a class="ae ky" href="https://medium.com/@insightsbees/membership" rel="noopener">推荐链接</a>注册成为Medium会员(每月5美元)来获得我的作品和Medium的其他内容。通过这个链接注册，我将收到你的会员费的一部分，不需要你额外付费。谢谢大家！</p></div></div>    
</body>
</html>