<html>
<head>
<title>Crack SQL Interview Question: Window Functions with Partition-By</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">破解SQL面试问题:带分区的窗口函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/crack-sql-interview-question-window-functions-with-partition-by-599d792c07c3#2022-09-21">https://towardsdatascience.com/crack-sql-interview-question-window-functions-with-partition-by-599d792c07c3#2022-09-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="259c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用有用的程序解决SQL问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2dc8a8da965743daaf6ad72e728fa88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2pis_sCeWnKVX8YL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@marvelous?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马文·迈耶</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将回顾亚马逊数据科学访谈中的一个SQL问题。希望本文中解释的过程能够帮助您更有效地编写SQL查询。</p><p id="4ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL问题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1959" class="ma mb it lw b gy mc md l me mf"><strong class="lw iu">Marketing Campaign Success</strong></span><span id="fde6" class="ma mb it lw b gy mg md l me mf">You have a table of in-app purchases by user. Users that make their first in-app purchase are placed in a marketing campaign where they see call-to-actions for more in-app purchases. Find the number of users that made additional in-app purchases due to the success of the marketing campaign.</span><span id="e261" class="ma mb it lw b gy mg md l me mf">The marketing campaign doesn't start until one day after the initial in-app purchase so users that only made one or multiple purchases on the first day do not count, nor do we count users that over time purchase only the products they purchased on the first day.</span><span id="353f" class="ma mb it lw b gy mg md l me mf">Source: <a class="ae ky" href="https://platform.stratascratch.com/coding/514-marketing-campaign-success-advanced?code_type=1" rel="noopener ugc nofollow" target="_blank">stratascratch.com</a></span></pre><p id="9a93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表格:营销活动</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/15e90dd1f851c13044e40bb68cf67555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4txk6xPXAZCu3OxzRwtxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="da79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步:让我们先检查一下原始数据。</p><ul class=""><li id="82ff" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">user_id:该字段标识一个唯一的用户。我们确实需要这个字段来计算不同用户的数量。</li><li id="483c" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">created_at:该字段指示进行交易的日期。这可用于识别给定交易是在第一天(首次应用内购买时)还是在营销活动期间(首次应用内购买后一天开始)进行的</li><li id="f883" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">product_id:该字段标识唯一的产品。与created_at结合使用，它们可以用来识别给定的产品是在第一天购买的还是在营销活动期间购买的，或者两者都有。</li><li id="0c05" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">数量和价格:这两个字段表示与给定交易相关的数量和价格。他们与这个问题无关。</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="4cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第二步</strong>:大家集思广益，如何解决问题。</p><p id="7b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个练习最重要的任务是找出如何识别</p><ul class=""><li id="8a74" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">在营销活动期间购买新产品的用户(即成功)</li><li id="dcbf" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">在营销活动的第一天购买了相同产品的用户(即失败)</li><li id="49ca" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">在营销活动中没有购买任何产品的用户(即失败)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/20dae9350feb9e49304c87dad4b987b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHj07KBnr_4KQrfuWsXI-A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="de4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们将用户分类到正确的类别中，我们就可以很容易地统计出由于营销活动的成功而购买新产品的不同用户的数量。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="11e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">第三步</strong>:让我们准备好数据，准备好分析。</p><p id="86b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">方法一:利用窗口功能，</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">MIN()</strong></code> <strong class="lb iu">配合</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">OVER-PARTITION-BY</strong></code></p><p id="343e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要构造两个新的变量</p><ul class=""><li id="dee6" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">first_purchase_date:这个字段将给出给定用户进行应用内购买的第一天。</li><li id="f477" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">first_product_purchase_date:该字段将给出用户购买给定产品的第一天</li></ul><p id="f2e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以运行以下脚本来产生这两个变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="244d" class="ma mb it lw b gy mc md l me mf">SELECT *,</span><span id="effc" class="ma mb it lw b gy mg md l me mf">MIN(created_at) OVER (PARTITION BY user_id) AS first_purchase_date,</span><span id="8424" class="ma mb it lw b gy mg md l me mf">MIN(created_at) OVER (PARTITION BY user_id, product_id) AS first_product_purchase_date</span><span id="bfb9" class="ma mb it lw b gy mg md l me mf">FROM marketing_campaign</span></pre><p id="e85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细了解一下代码:</p><ul class=""><li id="ed52" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><code class="fe ne nf ng lw b"><strong class="lb iu">MIN()</strong></code> <strong class="lb iu"> </strong>:这是我们用来计算每个分区中最早购买日期的窗口函数。还有其他的窗口函数，比如max，sum，行号，rank等。</li><li id="3a73" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><code class="fe ne nf ng lw b"><strong class="lb iu">OVER</strong></code> <strong class="lb iu"> </strong>:表示我们这里使用的函数是窗口函数，不是<a class="ae ky" rel="noopener" target="_blank" href="/data-manipulation-sql-vs-pandas-116bb33a9abf">聚合函数</a>。</li><li id="ff6a" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><code class="fe ne nf ng lw b"><strong class="lb iu">PARTITION BY</strong></code> <strong class="lb iu"> </strong>:对数据表中的行进行分区，这样我们就可以定义窗口函数将应用于哪些行。在本练习中，“first_purchase_date”是在user_id分区上计算的，而“first_product_purchase_date”是在user_id和product_id分区上计算的。</li></ul><p id="7533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们可以生成如下的表格。让我们检查一下新变量是否有意义。例如，user_id 10在2019年1月1日进行了第一次应用内购买。该用户购买了三种不同的产品，101、111和119，最早购买日期分别为2019年1月1日、2019年3月31日和2019年1月2日。有了这两个变量，我们很容易得出结论，user_id 10在营销活动中购买了两个新产品。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/a9e717ff57b2400ef6daf02cd484ddb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0ko22LvwAy9anXzEQ_sOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建这两个新变量后，我们可以使用<code class="fe ne nf ng lw b">WHERE first_purchase_date &lt; first_product_purchase_date</code>标记营销活动期间(从首次应用内购买日期后一天开始)购买的新产品用户。</p><p id="f6d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">方法二:利用窗口功能，</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">DENSE_RANK()</strong></code> <strong class="lb iu">配合</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">OVER-PARTITION-BY</strong></code></p><p id="2fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们需要构造两个新变量。</p><ul class=""><li id="4fc1" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated">user_date_rank:该字段将为我们提供给定用户的购买日期顺序。例如，<code class="fe ne nf ng lw b">user_date_rank = 1</code>代表给定用户进行应用内购买的第一天。<code class="fe ne nf ng lw b">user_date_rank = 2</code>代表第二早的日期，以此类推。因此，<code class="fe ne nf ng lw b">user_date_rank &gt; 1 </code>代表营销活动期间的购买记录。</li><li id="437f" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated">product_date_rank:该字段将给出给定用户和产品的购买日期顺序。例如，<code class="fe ne nf ng lw b">product_date_rank = 1 </code>表示用户购买给定产品的第一天。</li></ul><p id="b82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以运行以下脚本来产生这两个变量。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1b2c" class="ma mb it lw b gy mc md l me mf">SELECT  *,</span><span id="0084" class="ma mb it lw b gy mg md l me mf">DENSE_RANK() OVER (PARTITION BY user_id ORDER BY created_at) AS user_date_rank,</span><span id="4288" class="ma mb it lw b gy mg md l me mf">DENSE_RANK() OVER (PARTITION BY user_id, product_id ORDER BY created_at) AS product_date_rank</span><span id="aeb3" class="ma mb it lw b gy mg md l me mf">FROM marketing_campaign</span></pre><p id="9f11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们详细了解一下代码:</p><ul class=""><li id="5457" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><code class="fe ne nf ng lw b"><strong class="lb iu">DENSE_RANK</strong></code>:这是一个常用的窗口功能。此函数给出每个分区中每行的排名，即使出现平局，也有连续的排名值。比如1，2，2，3，…<code class="fe ne nf ng lw b"><strong class="lb iu">RANK</strong></code> <strong class="lb iu"> </strong>是一个交替排序函数。不同的是，如果出现平局，后者会在排名值上产生差距。例如，1、2、2、4……对于这个练习，<code class="fe ne nf ng lw b"><strong class="lb iu">DENSE_RANK</strong></code>用起来更合适。</li><li id="06d5" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><code class="fe ne nf ng lw b"><strong class="lb iu">ORDER BY</strong></code> <strong class="lb iu"> </strong>用于对每个分区内的观测值进行排序。在本练习中，我们将对每个分区中的购买日期进行排序。</li></ul><p id="4e7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们可以生成如下的表格。让我们检查这些新变量。例如，user_id 10在2019年1月1日、2019年1月2日和2019年3月31日这三个不同的日期进行了购买，这些日期从最早到最晚分别以订单号(即，“user _ date _ rank”)1、2、3排序。该用户购买了三种不同的产品，101、119和111。“product_date_rank”中的订单编号1、1和1表示该用户只购买了这三种产品一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/304bf8b187cf39166c13715711935bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYlexSS5fwxcNdZVNigZmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们创建这两个新变量之后，我们可以使用<code class="fe ne nf ng lw b">WHERE user_date_rank &gt; 1</code>来检查在营销活动期间是否进行了购买。我们还可以使用<code class="fe ne nf ng lw b">WHERE product_date_rank = 1</code>检查给定产品是否是第一次购买。结合这两个条件，我们可以标记给定用户在营销活动中购买的新产品的记录。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="165a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤4 </strong>:一旦在步骤3中准备好数据，我们就可以计算在营销活动中购买新产品的不同用户的数量。我们只需要使用聚合函数<code class="fe ne nf ng lw b">COUNT(DISTINCT)</code>和<code class="fe ne nf ng lw b">WHERE </code>语句来保存符合标准的记录。</p><p id="4c2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最终解决使用方法1:使用窗口功能，</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">MIN()</strong></code> <strong class="lb iu">与</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">OVER-PARTITION-BY</strong></code></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8cc2" class="ma mb it lw b gy mc md l me mf">WITH cte AS (</span><span id="5981" class="ma mb it lw b gy mg md l me mf">SELECT</span><span id="3171" class="ma mb it lw b gy mg md l me mf">user_id,</span><span id="99c9" class="ma mb it lw b gy mg md l me mf">MIN(created_at) OVER (PARTITION BY user_id) AS first_purchase_date,</span><span id="69a7" class="ma mb it lw b gy mg md l me mf">MIN(created_at) OVER (PARTITION BY user_id, product_id) AS first_product_purchase_date</span><span id="4bab" class="ma mb it lw b gy mg md l me mf">FROM marketing_campaign</span><span id="a517" class="ma mb it lw b gy mg md l me mf">)</span><span id="2ef1" class="ma mb it lw b gy mg md l me mf">SELECT COUNT(DISTINCT(user_id))</span><span id="a989" class="ma mb it lw b gy mg md l me mf">FROM cte</span><span id="44e4" class="ma mb it lw b gy mg md l me mf">WHERE first_purchase_date &lt; first_product_purchase_date;</span></pre><p id="407a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最终解决使用方法二:使用窗口功能，</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">DENSE_RANK()</strong></code> <strong class="lb iu">与</strong> <code class="fe ne nf ng lw b"><strong class="lb iu">OVER-PARTITION-BY</strong></code></p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3df1" class="ma mb it lw b gy mc md l me mf">WITH cte AS (</span><span id="7b2e" class="ma mb it lw b gy mg md l me mf">SELECT</span><span id="3692" class="ma mb it lw b gy mg md l me mf">user_id,</span><span id="6830" class="ma mb it lw b gy mg md l me mf">DENSE_RANK() OVER (PARTITION BY user_id ORDER BY created_at) AS user_date_rank,</span><span id="b1a6" class="ma mb it lw b gy mg md l me mf">DENSE_RANK() OVER (PARTITION BY user_id, product_id ORDER BY created_at) AS product_date_rank</span><span id="7377" class="ma mb it lw b gy mg md l me mf">FROM marketing_campaign</span><span id="2747" class="ma mb it lw b gy mg md l me mf">)</span><span id="8306" class="ma mb it lw b gy mg md l me mf">SELECT COUNT(DISTINCT user_id)</span><span id="2434" class="ma mb it lw b gy mg md l me mf">FROM cte</span><span id="b919" class="ma mb it lw b gy mg md l me mf">WHERE user_date_rank &gt; 1 AND product_date_rank = 1;</span></pre><p id="2161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">答案:23 </strong></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="f6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想探索更多的<strong class="lb iu"> SQL面试问题</strong>，请查看我的文章:</p><ul class=""><li id="0ec1" class="mp mq it lb b lc ld lf lg li mr lm ms lq mt lu mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/geekculture/comprehensive-sql-cheat-sheet-f821c5abf85a" rel="noopener"> <strong class="lb iu">综合SQL备忘单</strong> </a></li><li id="3b40" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/practical-sql-questions-for-data-science-interview-3b5c9d726baa"> <strong class="lb iu">破解SQL面试问题有用程序</strong> </a></li><li id="6ae4" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/sql-for-data-analysis-subquery-vs-cte-699ef629d9eb"> <strong class="lb iu">破解SQL面试问题:子查询vs CTE</strong></a></li><li id="2def" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-join-vs-case-when-statement-116d40a361f0"> <strong class="lb iu">破解SQL面试问题:Join vs Case-When语句</strong> </a></li><li id="b89d" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-window-functions-with-partition-by-599d792c07c3"> <strong class="lb iu">破解SQL面试题:带分区的窗口函数-By </strong> </a></li><li id="0beb" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/crack-sql-interview-question-date-part-function-aff0b15478d9"> <strong class="lb iu">破解SQL面试问题:Date_Part函数</strong> </a></li><li id="e7bd" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-questions-row-number-rank-and-dense-rank-ef439749f3ff" rel="noopener"> <strong class="lb iu">破解SQL面试题:ROW_NUMBER、RANK和DENSE_RANK </strong> </a></li><li id="082e" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://python.plainenglish.io/crack-sql-interview-question-unnest-string-to-array-1b75578cbe75" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">破解SQL面试问题:UNNEST，STRING_TO_ARRAY </strong> </a></li><li id="7334" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-generate-series-string-agg-split-part-fbc0e5e42d7d" rel="noopener"> <strong class="lb iu">破解SQL面试问题:GENERATE_SERIES，STRING_AGG，SPLIT_PART </strong> </a></li><li id="3fb1" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-self-join-and-non-equi-join-1cb2a181104a" rel="noopener"> <strong class="lb iu">破解SQL面试问题:自连接和非等同连接</strong> </a></li><li id="69fa" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-any-operator-d39e07e0e224" rel="noopener"> <strong class="lb iu">破解SQL面试问题:任意运算符</strong> </a></li><li id="cfbb" class="mp mq it lb b lc my lf mz li na lm nb lq nc lu mu mv mw mx bi translated"><a class="ae ky" href="https://medium.com/geekculture/crack-sql-interview-question-subquery-d9db4763eef4" rel="noopener"> <strong class="lb iu">破解SQL面试问题:子查询</strong> </a></li></ul><h1 id="cc48" class="nj mb it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">感谢您的阅读！！！</h1><p id="6f00" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">如果你喜欢这篇文章，并且想<strong class="lb iu">请我喝杯咖啡，请<a class="ae ky" href="https://ko-fi.com/aaronzhu" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</strong></p><p id="a278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以注册一个<a class="ae ky" href="https://aaron-zhu.medium.com/membership" rel="noopener"> <strong class="lb iu">会员</strong> </a>来解锁我的文章的全部访问权限，并且可以无限制地访问介质上的所有内容。如果你想在我发表新文章时收到电子邮件通知，请<a class="ae ky" href="https://aaron-zhu.medium.com/subscribe" rel="noopener"> <strong class="lb iu">订阅</strong> </a>。</p></div></div>    
</body>
</html>