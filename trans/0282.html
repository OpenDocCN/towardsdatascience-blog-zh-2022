<html>
<head>
<title>Assign Experiment Variants at Scale in A/B tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在A/B测试中按比例分配实验变量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/assign-experiment-variants-at-scale-in-a-b-tests-e80fedb2779d#2022-02-11">https://towardsdatascience.com/assign-experiment-variants-at-scale-in-a-b-tests-e80fedb2779d#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f14a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们如何改进Wish在线实验的随机分配算法</h2></div><p id="544a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">供稿人:<a class="ae lb" href="https://medium.com/@qike_max_li" rel="noopener">奇克(Max)李</a>，<a class="ae lb" href="https://www.linkedin.com/in/samirjamkhande/" rel="noopener ugc nofollow" target="_blank">萨米尔·詹汉德</a></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/38d3c52403d4e147966900fc6d65d88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vJnsmzRSDgGw6OOn"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@edge2edgemedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Edge2Edge媒体</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="1a3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近在Wish，我们在一个<a class="ae lb" href="https://www.optimizely.com/optimization-glossary/aa-testing/" rel="noopener ugc nofollow" target="_blank"> A/A测试</a>中发现了一个<a class="ae lb" href="https://www.microsoft.com/en-us/research/group/experimentation-platform-exp/articles/diagnosing-sample-ratio-mismatch-in-a-b-testing/" rel="noopener ugc nofollow" target="_blank">采样比不匹配</a> (SRM)。SRM是指实验者设定的采样比与观察到的采样比不匹配。SRM指出了改变实验结果的潜在数据质量问题[1]。微软分享了<a class="ae lb" href="https://www.microsoft.com/en-us/research/group/experimentation-platform-exp/articles/diagnosing-sample-ratio-mismatch-in-a-b-testing/" rel="noopener ugc nofollow" target="_blank">一个例子</a>，其中A/B测试结果在解析SRM后翻转。但是，SRM怎么可能出现在A/A测试中呢？</p><p id="871b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">经过数周的调查，我们找到了原因，根源在于我们的随机化算法。随机化算法将最终用户映射到实验变量，随机化被广泛视为建立因果关系的黄金标准。</p><p id="b618" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很难想象像掷骰子这样简单的事情会在网上实验中出错。随着我们在Wish不断改进我们的实验平台，现在越来越多的人意识到细节决定成败。在这篇文章中，我们分享了我们如何识别随机化算法中的缺陷的经验，一个好的随机化算法的要求是什么，我们如何改进该算法，以及我们如何评估它。</p><p id="146b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最近在<a class="ae lb" href="https://www.re-work.co/summits/deep-learning-summit-2022/speakers" rel="noopener ugc nofollow" target="_blank"> RE上发表了这项研究。工作深度学习峰会</a>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="efc9" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">随机化导致SRM</h1><p id="e640" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">SRM的出现是因为我们的随机化不是完全随机的。在本节中，我们将介绍我们最初的两步算法是如何工作的，以及它是如何导致SRM的。</p><p id="2a09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最初的算法有两个步骤。第一步是确定用户是否应该参与实验。比如我们设置曝光率为10%的时候，10%的流量会被纳入实验。第二步为用户分配一个实验区(例如，控制区、治疗区)。具体来说，算法如下:</p><ul class=""><li id="2e15" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated">在步骤1中，我们首先使用<a class="ae lb" href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function" rel="noopener ugc nofollow" target="_blank">fowler–noll–VO</a>(fnv)散列函数将(实验<a class="ae lb" href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noopener ugc nofollow" target="_blank"> salt </a>，用户ID，‘exposure’)的串联字符串映射到散列值Hᵉ。实验盐是一个特定于每个实验的20个字符的随机字符串，字符串“Exposure”是一个常量后缀。给定散列值的<a class="ae lb" href="https://en.wikipedia.org/wiki/Hash_function#Uniformity" rel="noopener ugc nofollow" target="_blank">均匀性属性</a>，散列值Hᵉ遵循均匀分布。然后，我们将Hᵉ修改100，以获得范围从0到99的均匀随机整数Rᵉ。如果Rᵉ大于暴露率乘以100，则该用户被排除在实验之外。</li><li id="e500" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated">类似地，在第二步中，我们将一个串接的字符串(实验<a class="ae lb" href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29" rel="noopener ugc nofollow" target="_blank">盐</a>，用户ID，‘桶’)映射到另一个范围从0到99的均匀随机整数Rᵇ。如果Rᵇ在0到49之间，我们指定用户进行控制；如果Rᵇ在50到99之间，我们指定用户进行治疗。</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nf"><img src="../Images/d1eb4ecab1951160bf01a0d25c342691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rI--zYs1dHNW4WPkVhIMdw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">原始算法</p></figure><p id="eb25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个用户，我们生成两个统一的随机数Rᵉ和Rᵇ，用于确定暴露和分配桶。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b40c7b2f6b9d8bfe6177310d00e7f518.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*xuVP9HRhnG9BM7H6YuO3bQ.png"/></div></figure><p id="e83c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个串联的字符串有不同的后缀:第一步是“Exposure”，第二步是“Bucket”。因此，Rᵉ和Rᵇ这两个随机数应该是<strong class="kh ir">独立的</strong>。此外，这种独立保证了Rᵇ对任何给定Rᵉ的统一分配，即:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9b7fd80448c843cfd3f819b12eba962d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*nR0H3wL2BrlnkKflrlcUdQ.png"/></div></figure><p id="6b0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，事实证明Rᵇ|Rᵉ并不统一。换句话说，这个两步算法在Rᵉ和Rᵇ.之间创建了一个<strong class="kh ir">依赖关系</strong>例如，对于Rᵉ &lt;为10的用户(即曝光率= 10%)，图1 中<strong class="kh ir">的左面显示了Rᵇ|Rᵉ &lt; 50的分布。这种依赖性与FNV散列函数和mod操作有关。在评估部分，我们演示了当我们更改哈希函数并删除mod操作时，依赖性消失。导致依赖性的潜在机制超出了本研究的范围。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ni"><img src="../Images/e6b6d06d6526b63f377430a0579810b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJEDAvfIZ1W0d-NHsxUlLA.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd nj">图一。</strong>Rᵇ|rᵉ的分布&lt; 50(左)和rᵇ的边缘分布</p></figure><p id="a37f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，Rᵇ|Rᵉ &lt;50 (left panel in <strong class="kh ir">图1 </strong>并不是均匀的，而是有一个周期性的模式。假设我们将1%的流量分配给控制，如果他/她的Rᵉ &lt; 50和Rᵇ =1，我们会将“控制”分配给用户，这对应于图1 中<strong class="kh ir">左侧面板的最左边的条。由于最左边的条明显更短(Rᵇ =1的用户更少)，分配给控制的实际流量将小于1%。此外，我们检查了Rᵇ|Rᵉ在其他暴露率下的分布，这些分布是不均匀的(数据未显示)。</strong></p><p id="4f71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rᵇ|Rᵉ的分布&lt;100(exposure rate 100%) is uniform (the right panel in <strong class="kh ir">图一</strong>。当曝光率为100%时，我们基于Rᵇ为用户分配一个实验桶，而不考虑用户的Rᵉ值。即当曝光率为100%时，Rᵇ|Rᵉ &lt; 100的分布与Rᵇ.的<a class="ae lb" href="https://en.wikipedia.org/wiki/Marginal_distribution" rel="noopener ugc nofollow" target="_blank">边际分布</a>相同同样，Rᵉ的边际分布也是均匀的(数据未显示)。</p><p id="a6bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，Rᵇ和Rᵉ的边际分布都是均匀的，但当暴露率小于100%时，Rᵇ|Rᵉ<exposure_rate/></p><h1 id="744b" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">什么是好的随机化算法？</h1><p id="2988" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">随机化算法对于确保有效的实验结果至关重要。随机样本是A/B检验中统计检验的一个基本假设。随机化平衡了实验桶之间观察到的和未观察到的用户特征，因此，在实验下的产品特征和实验结果中的任何结果差异之间建立了因果关系。微软[2]推荐了决定一个好的随机化算法的四个要求:</p><blockquote class="nk nl nm"><p id="d235" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">1.用户必须同样有可能看到实验的每个变体(假设50-50的比例)。不应该偏向任何特定的变体。</p><p id="8c96" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">2.单个用户的重复分配必须一致；用户在每次连续访问该网站时，应被分配到相同的变体。</p><p id="bfc2" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">3.当多个实验同时运行时，实验之间必须没有相关性。一个用户在一个实验中被分配到一个变体，必须对在任何其他实验中被分配到一个变体的概率没有影响。</p><p id="ec26" class="kf kg nn kh b ki kj jr kk kl km ju kn no kp kq kr np kt ku kv nq kx ky kz la ij bi translated">4.该算法应该支持单调上升，这意味着可以缓慢增加接受治疗的用户的百分比，而不改变之前已经被分配到该治疗的用户的分配。</p></blockquote><p id="bdbd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了微软推荐的四个要求之外，快速的计算速度也是必不可少的，因为我们不缓存赋值，这是内存密集型的。微软在其论文[2]的第4.1.1节讨论了缓存赋值的缺点。</p><h1 id="1b36" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">我们重新设计了算法来满足要求</h1><p id="1b4c" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">考虑到这些要求，我们设计了新的算法。具体来说，我们遵循以下步骤:</p><ol class=""><li id="3265" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la nr mx my mz bi translated">连接salt和用户ID。</li><li id="e275" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la nr mx my mz bi translated">应用散列函数将串接的字符串S映射到散列值H。注意，由于散列值的<a class="ae lb" href="https://en.wikipedia.org/wiki/Hash_function#Uniformity" rel="noopener ugc nofollow" target="_blank">一致性属性</a>，H遵循均匀分布。</li><li id="0918" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la nr mx my mz bi translated">假设哈希函数为64位，则H除以float(0xFFFFFFFFFFFFFFFF)并乘以10，000，得到范围为0到9，999的统一随机数整数R。</li><li id="9ce8" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la nr mx my mz bi translated">将R除以100。如果R/100 &gt;= exposure_rate(例如10%)乘以100，我们将忽略该用户，并且该用户将被排除在该实验的任何计算中。</li><li id="38e9" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la nr mx my mz bi translated">r模100。假设有两个实验桶:控制，处理。如果提醒是R (R/100 ≥ exposure_rate ⋅ 100)的前两位&lt; control bucket percentage (e.g. 50%) time 100, assign control. Otherwise, assign treatment.</li></ol><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ns"><img src="../Images/83fc4e364b69577fc2c3148f2b07fa6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MB6ycMk0ZgjpC7syx2_kvQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">The New Algorithm</p></figure><p id="6bdb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">In essence, we map the concatenated string of experiment salt and user ID (can also be cookie ID, session ID, etc.) to a uniform random integer R ranging from 0 to 9,999. Then we group these 10,000 integers into 100 subsets according to the <strong class="kh ir">。曝光率每增加1%，我们就在实验中增加一个用户子集。在实验中包括的每个子集内(即分配不是“忽略”)，我们根据r的最后两位数</strong>(r mod 100&lt;control _ bucket _ percentage⋅100)将用户划分为控制或处理。</p><p id="d09d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在该算法中，我们生成一个随机数R。R的前两位用于确定曝光，后两位用于分配存储桶。R的前两位和后两位是独立的。换句话说，知道R的前两位数并不能提供关于R的后两位数的线索。尽管确定暴露和分配桶在设计上是独立的，但我们仍然需要一个好的哈希函数来确保实验之间桶分配的相关性。</p><p id="58ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有数百个散列函数，并且不是每个散列函数都保证期望的随机化特性[2]，[3]。在下一节中，我们将比较以下四种算法</p><ul class=""><li id="9488" class="mr ms iq kh b ki kj kl km ko mt ks mu kw mv la mw mx my mz bi translated"><strong class="kh ir"> Algo 1 </strong>:独创的两步算法。</li><li id="1af1" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><strong class="kh ir"> Algo 2 </strong>:带FNV哈希函数的新算法。</li><li id="d57c" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><strong class="kh ir"> Algo 3 </strong>:带<a class="ae lb" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank"> MD5 </a>哈希函数的新算法。</li><li id="ed43" class="mr ms iq kh b ki na kl nb ko nc ks nd kw ne la mw mx my mz bi translated"><strong class="kh ir"> Algo 4 </strong>:带有<a class="ae lb" href="https://en.wikipedia.org/wiki/Jenkins_hash_function#SpookyHash" rel="noopener ugc nofollow" target="_blank"> SpookyHash </a>功能的新算法。</li></ul><h1 id="f374" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">算法评估</h1><p id="2147" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们根据一个好的随机化算法的四个要求评估了这四个算法，并测试了它们的速度。简而言之，用SpookyHash函数实现的新算法满足四个要求，并且比我们原来的随机化算法快大约四倍。</p><p id="8415" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有四种算法都满足第二和第四个要求。它们都满足第二个要求(一致性赋值)，因为所有的计算都是确定性的，包括散列函数。此外，通过设计，所有四种算法都满足第四个要求。</p><h1 id="24a5" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">均匀性测试</h1><p id="a7cc" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">第一个要求需要随机数的均匀分布(例如，我们最初的两步算法中的rᵇ；新算法中的R mod 100)用于桶分配。给定任何暴露率，用于分配存储桶的随机数应均匀分布。在均匀分布的情况下，用户看到实验的任何变化的机会与桶比率成比例。我们通过可视化随机数的分布和<a class="ae lb" href="https://en.wikipedia.org/wiki/Chi-squared_test" rel="noopener ugc nofollow" target="_blank">卡方检验</a>来评估均匀性，并假设随机数遵循均匀分布。</p><p id="79fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">图2 </strong>展示了算法2、3、4在10%和100%暴露率下的均匀分布。在<strong class="kh ir">图1 </strong>中，我们展示了曝光率为10%时原始两步算法(Algo 1)的非均匀分布(左图)和曝光率为100%时的均匀分布(右图)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nt"><img src="../Images/b049df1b96c084cb89dae8d3a99ccee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZqpDJRcBJDOurM6V"/></div></div></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nu"><img src="../Images/144d279bfc0e4e2d36271e6211675e36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ev2p2_DFvFwWeblf"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd nj">图二。</strong>算法2、3和4在暴露率为10%和100%时产生均匀分布</p></figure><p id="fc7f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">卡方测试的结果与可视化结果一致，只有曝光率为10%的Algo 1未通过均匀性测试。当卡方的p值低于5%时，我们拒绝分布均匀的零假设。Algo 1在100%以外的其他曝光率下未通过均匀性测试(数据未显示)。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nv lt l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="ak">表1 </strong>四种算法的一致性测试</p></figure><h1 id="2313" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">独立性检验</h1><p id="b612" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">为了验证第三个要求，实验之间的独立性，我们将用于桶分配的随机数可视化(例如，两步算法中的rᵇ；R mod 100)并应用<a class="ae lb" href="https://en.wikipedia.org/wiki/Chi-squared_test" rel="noopener ugc nofollow" target="_blank">卡方检验</a>来检验桶分配在实验之间独立的零假设。</p><p id="fc36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">图3 </strong>绘制了从两个不同实验中随机选择的相同1000个用户的随机数。算法1和算法2都呈现出清晰的模式，这表明了来自两个实验的实验桶分配之间的相关性。2016年，雅虎[4]也报道了关于FNV引入相关性的相同问题。他们报告说，FNV产生均匀分布，但没有通过独立性测试，这与我们的发现一致。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nw"><img src="../Images/02fa18121afc873966cb821c5956f12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkrgMqqXCMtVy44yCQy2KQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="bd nj">图三。</strong>用于分配两个实验的实验桶的随机数</p></figure><p id="99bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们进一步应用卡方检验来检验假设50%的用户处于控制状态而50%的用户处于治疗状态的两个实验之间没有相关性的零假设。与图3所示相同，只有算法3和4通过了独立性测试。当我们在各种场景(例如，不同的曝光率，不同的实验桶比率)中测试四种算法时，我们得到了相似的结果</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nv lt l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><strong class="ak">表2 </strong>四种算法的独立性测试</p></figure><p id="3532" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然Algo 2(具有FNV散列函数的新算法)通过了一致性测试，但是Algo 2引入了实验之间的相关性。如果用户在实验2中处于控制桶中，则实验之间的相关性使得她比预期更有可能被分配到实验1中的控制桶，反之亦然。</p><h1 id="d366" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">计算速度</h1><p id="0cdd" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">wish的实验服务每秒有数十万次查询(QPS)，QPS在一家超高速增长的公司中快速增长。因此，实验桶评估延迟至关重要。高QPS是为每个用户评估大量并发实验的结果。实验桶评估引入的延迟会增加整体用户请求-响应延迟，并会对用户体验产生负面影响。在我们的延迟测试中，我们发现Algo 3比Algo 4慢大约50%。所以我们最终在生产中实现了算法4</p><h1 id="3aed" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">生产测试部署</h1><p id="38a9" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">我们在生产中使用新的随机化算法执行了A/A测试，并测试了SRM、实验的相互依赖性等。从延迟角度来看，我们发现新的随机化比原始随机化快大约4倍。A/A测试的结果也表明新的随机化满足上面讨论的良好随机化的四个要求。</p><p id="5ce2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">部署分阶段进行。我们只在新的实验中引入了新的随机化算法。现有的实验运行旧的随机化算法，直到它们的结束日期。使用这种方法，我们不需要重置正在运行的实验。</p><h1 id="2ba6" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="c135" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">虽然受控实验已经得到了很好的研究，但在大规模应用在线受控实验(也称为A/B测试)时，存在独特的挑战。看似简单的随机化可能很难正确。然而，良好的随机化对于建立因果结论是至关重要的。我们改进的随机化算法不仅满足统计要求，而且速度更快。</p><h1 id="4861" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">感谢</h1><p id="0f1a" class="pw-post-body-paragraph kf kg iq kh b ki mm jr kk kl mn ju kn ko mo kq kr ks mp ku kv kw mq ky kz la ij bi translated">感谢齐超对这个项目的贡献。我们还要感谢Pai Liu和Shawn Song的支持，以及Pavel Kochetkov、Lance Deng、Caroline Davey、Gus Silva、Iryna Shvydchenko和Delia Mitchell的反馈。</p><p id="23ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Wish的数据科学家热衷于构建一个值得信赖的实验平台。如果你对解决这一领域的挑战性问题感兴趣，我们正在为数据科学团队<a class="ae lb" href="https://smrtr.io/6VnPr" rel="noopener ugc nofollow" target="_blank">招聘</a>。</p><pre class="ld le lf lg gt nx ny nz oa aw ob bi"><span id="861f" class="oc lv iq ny b gy od oe l of og">References <br/>1. Fabijan, A., Gupchup, J., Gupta, S., Omhover, J., Qin, W., Vermeer, L., &amp; Dmitriev, P. (2019, July). Diagnosing sample ratio mismatch in online controlled experiments: a taxonomy and rules of thumb for practitioners. In <em class="nn">Proceedings of the 25th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining</em> (pp. 2156-2164).<br/>2. Kohavi, R., Henne, R. M., &amp; Sommerfield, D. (2007, August). Practical guide to controlled experiments on the web: listen to your customers not to the hippo. In <em class="nn">Proceedings of the 13th ACM SIGKDD international conference on Knowledge discovery and data mining</em> (pp. 959-967).<br/>3. Xu, Y., Chen, N., Fernandez, A., Sinno, O., &amp; Bhasin, A. (2015, August). From infrastructure to culture: A/B testing challenges in large scale social networks. In <em class="nn">Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em> (pp. 2227-2236).<br/>4. Zhao, Z., Chen, M., Matheson, D., &amp; Stone, M. (2016, October). Online experimentation diagnosis and troubleshooting beyond aa validation. In <em class="nn">2016 IEEE International Conference on Data Science and Advanced Analytics (DSAA)</em> (pp. 498-507). IEEE.</span></pre></div></div>    
</body>
</html>