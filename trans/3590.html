<html>
<head>
<title>Using SQL to calculate trends based on historical status</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SQL根据历史状态计算趋势</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-sql-to-calculate-trends-based-on-historical-status-2ee75f23c4e4#2022-08-09">https://towardsdatascience.com/using-sql-to-calculate-trends-based-on-historical-status-2ee75f23c4e4#2022-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ee0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们怎样才能捕捉到存在但没有活动时间戳的事物的趋势呢？</h2></div><p id="65c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到捕获时间戳，我处理过的大多数数据集都非常健壮。无论是销售、产品还是人才获取数据，API和数据仓库工具都需要能够为应用程序上发生的特定操作或事务提供时间戳。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/e46e7cb6eaaaa6a943b848c5e2645572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0B-814Sg72W6DLncpyRaZw.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">大多数web应用程序会为其网站上发生的事件生成一个时间戳，以及事件内容的记录。图片由Malvestida通过<a class="ae lu" href="https://unsplash.com/photos/FfbVFLAVscw" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>提供。</p></figure><p id="8551" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我一直纠结的一个分析是基于某个时间点的某件事的状态的时间序列趋势。例如，假设我正在与人才获取团队合作，我们正在尝试了解2022年我们的职业页面上有多少工作岗位，按月分列。一个标准的数据集可能包含帖子的创建日期、帖子的发布日期以及帖子被删除的日期(基于操作的时间戳)。然而，可能不会有内置的时间戳显示“1月15日，发布是实时的。1月16日、17日和18日也有直播，还有……”</p><p id="0c42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我想找到2022年1月1日至2022年1月31日期间在我的工作网站上发布的所有帖子(但可能在这些日期或之前发布)，我过去使用的一种解决方法是:</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="b3ed" class="ma mb it lw b gy mc md l me mf">if posting_publish_date ≤ 2022–01–01 and (posting_closed_date is null or posting_closed_date &gt; 2022–01–31) then True</span></pre><p id="535c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将帮助我创建一个标志，以过滤在兴趣期当天或之前发布、在兴趣期之后关闭或尚未关闭的帖子(因此，在2022年1月1日至1月31日之间有效)。但是，如果我想做一个时间序列分析，需要一个月的细分，而不是一个“时间点”的数字呢？</p><p id="6270" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于那些不熟悉人才获取数据的人来说，另一个例子是，如果我想按月跟踪销售周期中处于潜在客户创造阶段的机会数量。</p><p id="0521" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我也许能够捕捉到他们何时进入潜在客户创造阶段以及何时退出，但如果我只是想知道每个月潜在客户创造的机会数量，而不管他们何时进入该阶段，该怎么办？基于传统数据集，这些数据集仅在有行动时(即opp进入或退出阶段)捕获时间戳，我只能显示进入或退出阶段的机会数量，而不能显示刚刚进入阶段的机会数量。</p><p id="2588" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这些例子中的任何一个引起了你的共鸣，就你想尝试的或者过去已经尝试过的分析而言，那么这个教程就是为你准备的！</p><h1 id="1987" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤1:为日历日期生成一列</h1><p id="dc69" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">该列是您的线图的隐喻x轴。您希望创建一个列来存储一年中的每个日期，即使当天没有任何活动。我通常会生成比一年更长的日期，所以数据集在未来几年仍然有效。</p><p id="5ead" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些SQL风格有一个<a class="ae lu" href="https://www.postgresql.org/docs/current/functions-srf.html" rel="noopener ugc nofollow" target="_blank"> generate_series </a>函数，它将为您创建这个日历列。如果你像我一样不幸，并且你正在使用的SQL风格还不支持generate_series(像亚马逊雅典娜🥺)，你可以使用来自<a class="ae lu" href="https://help.looker.com/hc/en-us/articles/4420211251987-Generate-Date-Series-Create-a-calendar-view-of-future-dates-Community-" rel="noopener ugc nofollow" target="_blank"> Looker </a>的这段代码，它对我有效(我在亚马逊雅典娜上为PostgreSQL稍微修改了一下):</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="a72d" class="ma mb it lw b gy mc md l me mf">SELECT parse_datetime('2020–01–01 08:00:00', 'yyyy-MM-dd H:m:s') + (interval '1' day * d) as cal_date from <br/>FROM ( SELECT<br/>ROW_NUMBER() OVER () -1 as d<br/>FROM<br/>(SELECT 0 as n UNION SELECT 1) p0,<br/>(SELECT 0 as n UNION SELECT 1) p1,<br/>(SELECT 0 as n UNION SELECT 1) p2,<br/>(SELECT 0 as n UNION SELECT 1) p3,<br/>(SELECT 0 as n UNION SELECT 1) p4,<br/>(SELECT 0 as n UNION SELECT 1) p5,<br/>(SELECT 0 as n UNION SELECT 1) p6,<br/>(SELECT 0 as n UNION SELECT 1) p7,<br/>(SELECT 0 as n UNION SELECT 1) p8,<br/>(SELECT 0 as n UNION SELECT 1) p9,<br/>(SELECT 0 as n UNION SELECT 1) p10<br/>)</span></pre><p id="5cc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将“2020–01–01”替换为您计划开始历史分析的日期。</p><h1 id="e6eb" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">步骤2:在日历列和感兴趣的表之间进行左连接</h1><p id="f027" class="pw-post-body-paragraph ki kj it kk b kl mx ju kn ko my jx kq kr mz kt ku kv na kx ky kz nb lb lc ld im bi translated">现在您已经有了calendar列，您需要通过left join添加活动表。为什么离开加入？如果我们继续上面的销售周期示例，可能会有没有阶段移动的日期(即周末、节假日、淡季)，如果我们依赖于阶段移动日期列，我们将会丢失该日期的一行。但是，如果我们将日历表作为主表，并通过left join添加stage activity表，那么所有的日历日期都将出现(不管那天是否发生了任何移动)。</p><p id="fbdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一部分有点棘手——决定加入哪个时间戳。这将取决于您试图跟踪的指标。如果我试图寻找所列日期的潜在机会，我会使用这样的语句:</p><pre class="lf lg lh li gt lv lw lx ly aw lz bi"><span id="4379" class="ma mb it lw b gy mc md l me mf">Select c.cal_date, count(distinct opp_id) as "historical_prospects" from calendar c<br/>left join opportunities o<br/>on o.stage_entered ≤ c.cal_date <br/>and (o.stage_exited is null or o.stage_exited &gt; c.cal_date)</span></pre><p id="301b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将找到在感兴趣的日期当天或之前进入该阶段的所有人，并且这些人或者仍然在该阶段中，或者在感兴趣的日期之后退出该阶段。该脚本的最后一个数据框将为我提供一列日历日期，以及在该日期处于潜在客户发现阶段的相应机会数。</p><h1 id="f25c" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">总结和进一步应用</h1><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nc"><img src="../Images/9b752f9b1ae1af7e4ac889348fefc4dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8jV-T6AVQRkNIo4Y03uJA.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">在查找和分析历史数据时，肯定有更简单的方法！照片由Aditya via <a class="ae lu" href="https://unsplash.com/photos/dvPd91Pdh5c" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>提供</p></figure><p id="ce72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我关于如何基于时间点状态找到历史趋势的教程就结束了。希望我的解释和伪代码足够清晰，能让大家理解我的主旨和逻辑！可以想象，除了我在本文中分享的两个例子之外，还有更多应用。</p><p id="a933" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以对上面的示例进行更复杂的分析，例如过滤来自特定来源(即2019年1月期间处于潜在客户阶段并以LinkedIn作为来源标签的每个人)的管道阶段中的机会。</p><p id="f0be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请随时留下评论和反馈，让我知道你是否有不同的方法来实现这种类型的历史时序分析！我总是喜欢在StackOverflow上看到有人用50行代码，用5行代码就能完成我做的事情😅</p></div></div>    
</body>
</html>