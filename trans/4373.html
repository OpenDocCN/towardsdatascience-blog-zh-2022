<html>
<head>
<title>Serving Transformer Models in Shiny Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在闪亮的应用程序中提供变压器模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/serving-transformer-models-in-shiny-apps-9a1bed4b41a6#2022-09-27">https://towardsdatascience.com/serving-transformer-models-in-shiny-apps-9a1bed4b41a6#2022-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/b0b194380d86d6f59de4e73a4cb45560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*O3YkAbFu9VR4HiKYg49zWw.png"/></div><p class="iv iw gj gh gi ix iy bd b be z dk translated">“一个穿着蛇皮衣服的闪亮变形机器人”——用稳定扩散文本到图像模型生成——<a class="ae iz" href="https://huggingface.co/spaces/stabilityai/stable-diffusion" rel="noopener ugc nofollow" target="_blank">https://huggingface.co/spaces/stabilityai/stable-diffusion</a></p></figure><div class=""/><div class=""><h2 id="5719" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">结合R和Python的精华来创建令人敬畏的NLP产品的分步指南</h2></div><p id="0eeb" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很长一段时间以来，R一直是我处理大多数数据科学相关任务的首选工具。我特别喜欢我可以快速流畅地轻松完成工作。特别是，tidyverse的出现真正改变了数据争论、探索性分析和数据可视化的游戏规则。此外，Shiny——一个用于构建多功能且漂亮的web应用程序的框架——变得越来越流行。</p><p id="e18b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，当涉及到机器和深度学习时，Python似乎比Sci-kit Learn、PyTorch和Tensorflow/Keras等ML/DL框架领先几步。因此，我发现自己越来越多地使用(并且喜欢)Python。</p><p id="2f08" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对我来说，令人沮丧的部分是我经常想在闪亮的应用程序中部署和展示计算机视觉和NLP模型。尽管Shiny最近才可以用于Python，但Shiny for Python目前仍处于非常早期的开发阶段。Python用户确实可以使用类似的工具，例如Streamlit和Gradio非常适合展示ML模型，但我发现它们与Shiny相比有些局限性——特别是在创建自定义用户界面时。当然，我需要探索Python的更多选项，但是我真的喜欢开发闪亮的应用程序。</p><p id="9359" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我开始学习如何做到以下几点:</p><ol class=""><li id="25dc" class="ln lo jc kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">使用R的reticulate包在闪亮的app中使用Python代码。</li><li id="22cd" class="ln lo jc kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">实现预训练的转换器模型来处理用户输入。</li><li id="55c6" class="ln lo jc kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">将包含R和Python功能的应用程序容器化，并为transformer模型提供服务。</li></ol><p id="31f6" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将通过所有三个步骤来了解它是如何完成的。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="eb3a" class="mi mj jc bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">第1部分:启动并运行reticulate:一个非常简单的例子</h1><p id="b1ab" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">我必须承认，开始使用reticulate并弥合R和Python之间的差距有些棘手，需要一些尝试、错误和毅力。好消息是，现在你可能不需要这么做了。在这里，我将展示一种在R和Shiny中使用python代码的方法。</p><h2 id="31ef" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">第一步:准备好</h2><p id="501d" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">首先，确保你已经安装了所有需要的包，包括shiny和reticulate，并开始一个新的Shiny应用程序项目。</p><p id="b914" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们需要设置一个Python环境。有不同的方法可以做到这一点，例如根据reticulate文档使用virtualenv。这里，我们将使用conda从一个YAML文件中设置我们的环境，在该文件中我们指定了所有必要的依赖项。在项目的主目录中创建一个名为environment.yml的新文件，包含以下内容:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="0d5e" class="nf mj jc nw b gy oa ob l oc od">name: my_env<br/>channels:<br/>  - conda-forge<br/>  - defaults<br/>dependencies:<br/>  - python=3.8<br/>  - pip<br/>  - pip:<br/>    - numpy</span></pre><p id="8684" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们已经指定环境应该被称为my_env，其中Python v. 3.8将与pip一起安装，pip是一个安装程序，它反过来获取numpy包，我们将需要它来创建一个简单的函数。</p><p id="576b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以通过在ourRStudio会话中打开一个终端并运行以下命令来创建环境:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="a049" class="nf mj jc nw b gy oa ob l oc od">conda env create -f environment.yml</span></pre><p id="146e" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以使用命令<code class="fe oe of og nw b">conda env list</code>检查环境是否已经创建。要激活环境，请运行以下命令:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="9d93" class="nf mj jc nw b gy oa ob l oc od">conda activate my_env</span></pre><p id="2701" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，为了让reticulate找到我们刚刚安装的Python版本，复制并保存命令<code class="fe oe of og nw b">which python</code>的输出以备后用。它应该以类似于“../miniconda 3/envs/my _ env/bin/python "。</p><h2 id="b36a" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤2:用reticulate和Python连接Shiny</h2><p id="6f5b" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">如果您已经将项目初始化为一个闪亮的web应用程序，您应该已经有一个名为app.r的文件。对于这个最小的示例，我们将保持它的简单性，并修改已经为我们制作的应用程序。在该脚本的顶部，插入以下几行:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="eb5b" class="nf mj jc nw b gy oa ob l oc od">library(shiny)<br/>library(reticulate)</span><span id="cc54" class="nf mj jc nw b gy oh ob l oc od">Sys.setenv(RETICULATE_PYTHON="python-path-in-my_env")<br/>reticulate::use_condaenv("my_env")</span></pre><p id="b1f7" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您也可以在一个名为。请改用Rprofile。</p><h2 id="7438" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤3:创建和实现Python函数</h2><p id="afc0" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">现在，我们可以创建一个简单的Python函数，我们将在app.r的服务器代码中使用该函数。首先创建一个脚本，您可以使用以下代码行调用python_functions.py:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4821" class="nf mj jc nw b gy oa ob l oc od">import numpy as np</span><span id="b84a" class="nf mj jc nw b gy oh ob l oc od">def make_bins(x, length):<br/>  <br/>  low = min(x)<br/>  high = max(x)<br/>  length = int(length)</span><span id="77c0" class="nf mj jc nw b gy oh ob l oc od">  return np.linspace(low,high,length).tolist()</span></pre><p id="20d6" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数找到一个向量的最小值和最大值，并使用Numpy的<code class="fe oe of og nw b">linspace()</code>函数返回一个从最低到最高的等距数字列表。列表的长度等于<code class="fe oe of og nw b">length</code>，将由应用程序的用户交互设置。定义好函数后，我们可以继续前进到app.r并修改脚本以使用我们的python函数。</p><p id="5185" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上一步中我们在app.r中插入的两行代码的正下方，我们添加了以下代码行:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4104" class="nf mj jc nw b gy oa ob l oc od">reticulate::py_run_file("python_functions.py")</span></pre><p id="7b40" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一行使我们的<code class="fe oe of og nw b">make_bins()</code>功能在我们启动一个闪亮的会话时可用。现在，删除或注释掉服务器代码中的以下行:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="603a" class="nf mj jc nw b gy oa ob l oc od">bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)</span></pre><p id="6f26" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们用以下内容替换该行:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="4423" class="nf mj jc nw b gy oa ob l oc od">bins &lt;- py$make_bins(x, input$bins + 1)</span></pre><p id="f25a" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意<code class="fe oe of og nw b">py$</code>部分，它表示该函数是python函数。我们终于可以运行应用程序，并希望看到它的工作！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="4b5a" class="mi mj jc bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">第2部分:使用变压器！</h1><p id="5fd4" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">因此，现在我们将尝试实现一个transformer模型来确定给定的输入文本是正面的还是负面的。我们将使用的模型叫做<em class="oi">蒸馏-基础-无壳-情感</em>，你可以在huggingface网站上了解更多关于<a class="ae iz" href="https://huggingface.co/bhadresh-savani/distilbert-base-uncased-emotion/tree/main" rel="noopener ugc nofollow" target="_blank">的信息。如果您还没有这样做，我鼓励您探索这个站点、可用的模型以及支持的NLP和计算机视觉任务。</a></p><h2 id="6edd" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤1:更新conda环境</h2><p id="4d68" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">我们首先需要通过以下方式将软件包torch和transformers添加到我们的environment.yml文件中:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e716" class="nf mj jc nw b gy oa ob l oc od">name: my_env<br/>channels:<br/>  - conda-forge<br/>  - defaults<br/>dependencies:<br/>  - python=3.8<br/>  - pip<br/>  - pip:<br/>    - torch<br/>    - transformers</span></pre><p id="ac78" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以使用以下命令更新环境:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="a249" class="nf mj jc nw b gy oa ob l oc od">conda deactivate;<br/>conda env update -f environment.yml --prune</span></pre><p id="bc61" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oe of og nw b">—-prune</code>标志确保在更新环境时删除不必要的包。</p><h2 id="9586" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤2:更新python_functions.py</h2><p id="781f" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">安装了torch和transformers之后，我们就可以编写新的Python函数来使用这个模型了。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="5c32" class="nf mj jc nw b gy oa ob l oc od">import torch<br/>from transformers import pipeline<br/>import numpy as np</span><span id="c93e" class="nf mj jc nw b gy oh ob l oc od">def get_model():<br/>  model = pipeline("text-classification", model='bhadresh-savani/distilbert-base-uncased-emotion', top_k=-1)<br/>  return model</span><span id="b299" class="nf mj jc nw b gy oh ob l oc od">def get_predictions(input_text, classifier):<br/>  predictions = classifier(input_text)<br/>  return predictions</span></pre><p id="551d" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一次运行<code class="fe oe of og nw b">get_model()</code>时，模型被下载，这可能需要一两分钟。这是一个好主意，在一个闪亮的会话之外运行<code class="fe oe of og nw b">get_predictions()</code>来了解输出是什么样子的。</p><h2 id="d470" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤3:创建一个公开模型的基本应用程序</h2><p id="0001" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">现在，我们终于可以构建一个利用该模型的应用程序了。我在下面提供了一个简单的工作脚本，如果您已经完成了前面的步骤，您可以尝试一下。</p><figure class="nr ns nt nu gt is"><div class="bz fp l di"><div class="oj ok l"/></div><p class="iv iw gj gh gi ix iy bd b be z dk translated">作者图片</p></figure><p id="1867" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你会注意到我们在第10行用<code class="fe oe of og nw b">model &lt;- py$get_model()</code>加载了情感分类模型。</p><p id="5645" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，在第31–33行，我们将模型应用于用户提供的一些输入文本，并将输出转换为数据框，这使得绘图更加容易。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="622c" class="nf mj jc nw b gy oa ob l oc od">predictions &lt;- py$get_predictions(input$text)</span><span id="caac" class="nf mj jc nw b gy oh ob l oc od">df &lt;- map_df(predictions[[1]], unlist)</span></pre><p id="412a" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将Python函数的输出转换成R可以处理的数据类型有时会很棘手。如果你在自己的项目中遇到麻烦，你可能会发现<a class="ae iz" href="https://rstudio.github.io/reticulate/" rel="noopener ugc nofollow" target="_blank">网格式文档</a>很有用(参见“类型转换”)。</p><p id="ee1c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面你可以看到应用程序会是什么样子。</p><figure class="nr ns nt nu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi ol"><img src="../Images/2fccb3b0b98c8b083113cf186e32dfb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VptF6XZAutJRmIH8mnm5Q.png"/></div></div><p class="iv iw gj gh gi ix iy bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="8b29" class="mi mj jc bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">第3部分:用Docker封装应用程序</h1><p id="f7eb" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">Docker和容器技术提供了一种运行代码和应用程序并完全控制环境的好方法。我们首先需要创建一个docker文件，这通常会非常困难和耗时。在这里，我将展示一个将Python、R、Shiny和transformer模型组合在一个Docker图像中的解决方案。它可能不是最有效的，并且一些依赖项和命令可能是多余的。因此，您可以通过修改docker文件来指定如何构建图像，从而减少构建图像所需的时间以及图像的大小。</p><h2 id="b341" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤1:编写Dockerfile文件</h2><p id="b384" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">Dockerfile文件的第一行表示基本图像。默认情况下，使用最新版本。通常，在将应用程序投入生产时，选择特定的版本是明智的。接下来的几行安装了一些依赖项，包括r。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="90a0" class="nf mj jc nw b gy oa ob l oc od">FROM continuumio/miniconda3</span><span id="de42" class="nf mj jc nw b gy oh ob l oc od">RUN apt-get update -y; apt-get upgrade -y; \<br/>    apt-get install -y vim-tiny vim-athena ssh r-base-core \<br/>    build-essential gcc gfortran g++</span></pre><p id="84d5" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，我更喜欢使用Rocker项目创建的Docker映像，这使得编写Docker文件来封装闪亮的应用程序和其他基于R的应用程序变得非常容易。然而，当我将Python添加到组合中时，我遇到了一些问题，并决定尝试一种不同的方式。</p><p id="0122" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，像以前一样安装并激活我们的环境。我必须承认，我还不完全确定下面有多少环境变量是绝对必要的。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="c641" class="nf mj jc nw b gy oa ob l oc od">COPY environment.yml environment.yml<br/>RUN conda env create -f environment.yml</span><span id="960c" class="nf mj jc nw b gy oh ob l oc od">RUN echo "conda activate my_env" &gt;&gt; ~/.bashrc</span><span id="764d" class="nf mj jc nw b gy oh ob l oc od">ENV CONDA_EXE /opt/conda/bin/conda<br/>ENV CONDA_PREFIX /opt/conda/envs/my_env<br/>ENV CONDA_PYTHON_EXE /opt/conda/bin/python<br/>ENV CONDA_PROMPT_MODIFIER (my_env)<br/>ENV CONDA_DEFAULT_ENV my_env<br/>ENV PATH /opt/conda/envs/my_env/bin:/opt/conda/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></pre><p id="50bd" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们用下面一行下载我们的模型:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="cd80" class="nf mj jc nw b gy oa ob l oc od">RUN python -c "from transformers import pipeline; pipeline('text-classification', model='bhadresh-savani/distilbert-base-uncased-emotion')"</span></pre><p id="2fc0" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与运行时相反，在构建时这样做很重要。如果我们在运行时这样做，每个会话都将从下载模型开始！</p><p id="d5f1" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装R包有不同的方法。这种方式非常简单。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="c8f6" class="nf mj jc nw b gy oa ob l oc od">RUN R -e "install.packages(c('dplyr','purrr','ggplot2','shiny','reticulate'), repos = '<a class="ae iz" href="http://cran.us.r-project.org'" rel="noopener ugc nofollow" target="_blank">http://cran.us.r-project.org'</a>)"</span></pre><p id="991f" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，这实际上是一行。您还可以看到我们正在安装dplyr、purrr和ggplot2，它们是我们实际需要的tidyverse包。因此，我们需要加载这些特定的包并从app.r中删除<code class="fe oe of og nw b">library(tidyverse)</code>。</p><p id="5f35" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">出于某种原因，我无法在此时安装整个tidyverse。此外，这样做将花费相当长的时间，并导致图像比必要的要大。</p><p id="abc9" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将项目文件夹中的所有内容复制到映像的工作目录，授予写/读/写权限，公开一个端口，并指定实际运行应用程序的最终命令。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="08d2" class="nf mj jc nw b gy oa ob l oc od">COPY . ./</span><span id="b418" class="nf mj jc nw b gy oh ob l oc od">RUN chmod ugo+rwx ./</span><span id="cf3b" class="nf mj jc nw b gy oh ob l oc od">EXPOSE 3838</span><span id="8edc" class="nf mj jc nw b gy oh ob l oc od">CMD ["R", "-e", "shiny::runApp('/', host = '0.0.0.0', port = 3838)"]</span></pre><p id="ca63" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面你可以看到整个Dockerfile文件。</p><figure class="nr ns nt nu gt is"><div class="bz fp l di"><div class="oj ok l"/></div><p class="iv iw gj gh gi ix iy bd b be z dk translated">作者图片</p></figure><h2 id="2498" class="nf mj jc bd mk ng nh dn mo ni nj dp ms la nk nl mu le nm nn mw li no np my nq bi translated">步骤2:构建图像</h2><p id="a071" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">如果我们简单地将我们的Dockerfile称为“Dockerfile”，默认情况下，当我们运行以下命令时，Docker将查找这个文件:</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="1079" class="nf mj jc nw b gy oa ob l oc od">docker build -t mysimpleapp .</span></pre><p id="20ca" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">t代表“tag ”,我们将此图像标记为“mysimpleapp”。末尾的点表示构建上下文是当前目录。</p><p id="719f" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果由于磁盘空间限制而遇到麻烦，您可以在Docker设置中增加允许的磁盘空间，或者，如果您有不需要的大型悬空图像，您可以运行<code class="fe oe of og nw b">docker system prune</code>或<code class="fe oe of og nw b">docker system prune -a</code>。请注意，后一个命令将删除所有未使用的图像！</p><p id="da29" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，让我们的手指交叉，我们可以尝试运行我们的应用程序！</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="6538" class="nf mj jc nw b gy oa ob l oc od">docker run -it -p 3838:3838 mysimpleapp</span></pre><p id="dc5f" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">-it标志意味着我们希望以交互模式运行，这样我们就可以在启动时看到容器“内部”发生了什么。这可能有助于防止意外出错。</p><p id="acfe" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在您的控制台中，您应该会看到R启动，然后是“监听<a class="ae iz" href="http://0.0.0.0:3838" rel="noopener ugc nofollow" target="_blank"> http://0.0.0.0:3838 </a>”。将您的浏览器指向此地址，并检查应用程序是否正常工作。</p><p id="a63c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在这里部署了一个稍微高级一点的应用<a class="ae iz" href="https://wineapp-tae5nnlp5a-ew.a.run.app/" rel="noopener ugc nofollow" target="_blank">。这款我称之为Wine Finder的应用程序使用了一个名为</a><a class="ae iz" href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2" rel="noopener ugc nofollow" target="_blank"> all-MiniLM-L6-v2 </a>的语义搜索模型，让用户通过输入描述他们正在寻找的葡萄酒品质的查询来搜索他们可能喜欢的葡萄酒。例如，一个查询可能被表述为<em class="oi">“浓郁的红色浆果味道”</em>。该应用程序包括大约130，000种葡萄酒的描述，然后根据与查询的相关性进行排名。数据集在这里<a class="ae iz" href="https://www.kaggle.com/datasets/zynicide/wine-reviews" rel="noopener ugc nofollow" target="_blank">可用</a>。下面你可以看到这个应用程序的样子。</p><figure class="nr ns nt nu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="om on di oo bf op"><div class="gh gi oq"><img src="../Images/f26af5a2c54086c8cc66df28cb339112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kzrMiUODrTBB1cXYxFzOzQ.png"/></div></div><p class="iv iw gj gh gi ix iy bd b be z dk translated">作者图片</p></figure><p id="1bb5" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">加载可能会有点慢，因为我已经允许该服务在不使用时基本关闭。这导致了“冷启动”，这比让服务持续运行要便宜得多。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="7e33" class="mi mj jc bd mk ml mm mn mo mp mq mr ms ki mt kj mu kl mv km mw ko mx kp my mz bi translated">摘要</h1><p id="d2b2" class="pw-post-body-paragraph kr ks jc kt b ku na kd kw kx nb kg kz la nc lc ld le nd lg lh li ne lk ll lm ij bi translated">我们已经看到了如何在闪亮的应用程序中实现python函数和transformer模型，以及如何将它们包装在docker映像中，准备作为web服务进行部署。使用AWS和Microsoft Azure等云提供商将docker图像部署为web应用程序相对容易。但是，对于个人项目，我认为谷歌云是目前最便宜的选择。如果你想在Google Cloud上部署一个闪亮的应用，请务必查看<a class="ae iz" rel="noopener" target="_blank" href="/dockerizing-and-deploying-a-shiny-dashboard-on-google-cloud-a990ceb3c33a">我的使用Google Cloud Run部署闪亮应用的分步指南</a>。无论您使用这些提供程序中的哪一个，过程都大致相同。您需要有一个帐户，将您的docker映像推送到容器注册表，然后使用该映像建立一个web服务。</p><p id="c9ac" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还没有介绍在Shinyapp.io上直接运行python代码的闪亮应用程序的部署。该过程与本教程中的<a class="ae iz" href="https://github.com/ranikay/shiny-reticulate-app" rel="noopener ugc nofollow" target="_blank">描述略有不同。请注意，如果您计划在应用程序中公开transformer模型，shinyapps.io可能不是一个可行的选项，至少如果您在免费层上，就不是。但是，如果您不需要应用程序实际包含大型transformer模型和/或大量数据，您可以考虑简单地为给定模型调用Huggingface推断API。</a></p></div></div>    
</body>
</html>