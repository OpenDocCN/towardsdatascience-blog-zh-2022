<html>
<head>
<title>Theta Model for Time Series Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测的Theta模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/theta-model-for-time-series-forecasting-642ad1d00358#2022-11-02">https://towardsdatascience.com/theta-model-for-time-series-forecasting-642ad1d00358#2022-11-02</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="5ef5" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">关于如何在Python中应用Theta模型进行时间序列预测的实践教程</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/1581dffc095478ee2ba40c4dd712ebe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PLKcBeTe_jceClf9"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">汉斯·雷尼尔斯在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="b886" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当谈到时间序列预测时，我们通常会将注意力转向SARIMAX系列或指数平滑中的模型。然而，有一种预测技术很少被提及:Theta模型。</p><p id="56e5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">尽管简单，Theta模型可以产生精确的预测。它在最大的学术时间序列预测竞赛M-3竞赛中表现如此出色，以至于在随后的几年中成为一个基准。</p><p id="d292" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这篇文章中，我们首先从理论的角度探索模型的内部工作原理。然后，我们将Theta模型应用于预测实践，并将其性能与SARIMA模型和指数平滑模型进行比较。当然，所有的代码都是Python的。</p><p id="0eec" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们开始吧！</p><blockquote class="lx"><p id="2b67" class="ly lz iv bd ma mb mc md me mf mg lw dk translated"><strong class="ak">用Python中我的</strong> <a class="ae la" href="https://www.datasciencewithmarco.com/pl/2147608294" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">免费时间序列小抄</strong> </a> <strong class="ak">学习最新的时间序列分析技术！获得统计和深度学习技术的实现，全部在Python和TensorFlow中！</strong></p></blockquote><h1 id="b4b5" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb ms kc mt ke mu kf mv kh mw ki mx my bi translated">Theta模型是如何工作的</h1><p id="1207" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">Theta模型基本上依赖于分解。我们知道时间序列可以分解成三个部分:趋势部分、季节部分和残差部分。</p><p id="b85c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，合理的方法是将一个序列分解成它的每个组成部分，预测每个组成部分的未来，然后组合每个组成部分的预测来创建您的最终预测。</p><p id="4672" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">不幸的是，这在实践中行不通，特别是因为很难分离残差并预测它们。</p><p id="3774" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">所以Theta模型是这个想法的一个发展，但是它依赖于将序列分解成一个长期部分和一个短期部分。</p><p id="1b8e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在形式上，Theta模型基于修改时间序列的局部曲率的概念。这个修改由一个名为<em class="ne"> theta </em>的参数管理(因此得名theta模型)。这种修改应用于系列的第二个差异，这意味着它是差异两次。</p><p id="00a4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">当<em class="ne">θ</em>在0和1之间时，系列“放气”。这意味着短期波动较小，我们强调长期影响。当<em class="ne">θ</em>达到0时，数列转换为线性回归线。这种行为如下图所示。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi nf"><img src="../Images/d410f9c59a3e20d3d418d6d9a5231de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*koWNcK8OQmbr1CPEhSjWpg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">当θ在0和1之间时级数的收缩。注意，当它等于0时，我们得到一条线性回归线。图片由V. Assimakopoulos，K. Nikolopoulos从<a class="ae la" href="https://www.researchgate.net/publication/223049702_The_theta_model_A_decomposition_approach_to_forecasting" rel="noopener ugc nofollow" target="_blank">theta模型:预测的分解方法</a></p></figure><p id="b2cd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">或者，当<em class="ne">θ</em>大于1时，则短期波动被放大，因此我们强调短期效应。在那种情况下，我们也说这个系列是“膨胀”的。这种行为如下图所示。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ng"><img src="../Images/d483eaed5ca1fead7443a09540f2008b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-kbFl6WCVjE9SZWQ7KCKg.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">当θ大于1时级数的膨胀。注意短期波动是如何被放大的。来自<a class="ae la" href="https://www.researchgate.net/publication/223049702_The_theta_model_A_decomposition_approach_to_forecasting" rel="noopener ugc nofollow" target="_blank">的V. Assimakopoulos，K. Nikolopoulos的图片theta模型:预测的分解方法</a></p></figure><p id="a08c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">对于每一个θ值，我们说我们创建了一条“θ线”。理论上，我们可以生成尽可能多的θ线，预测每一条线的未来，然后将它们组合起来进行最终预测。</p><p id="ef1e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在实践中，我们经常只使用两条θ线:一条是<em class="ne">θ</em>为0，一条是<em class="ne">θ</em>为2。第一条theta线(<em class="ne"> theta </em> = 0)给出了数列的趋势信息，而第二条theta线(<em class="ne"> theta </em> = 2)放大了短期波动。然后，我们预测每一行，并结合预测。</p><h2 id="7f58" class="nh mi iv bd mj ni nj dn mn nk nl dp mr lk nm nn mt lo no np mv ls nq nr mx ns bi translated">季节性呢？</h2><p id="0932" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">Theta模型的程序适用于非季节性数据。但是，它仍然可以用于季节性数据，因为季节性可以很容易地被删除，并在结束时再次添加。</p><p id="1664" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">因此，Theta模型的实现遵循以下步骤:</p><ol class=""><li id="cc88" class="nt nu iv ld b le lf lh li lk nv lo nw ls nx lw ny nz oa ob bi translated"><strong class="ld iw">去除季节性</strong>:进行季节性测试。如果检测到季节性，则通过分解去除。</li><li id="7267" class="nt nu iv ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated"><strong class="ld iw">分解成两条θ线</strong>:我们生成两条θ线；一个是<em class="ne">θ</em>= 0，表示为Z(0)，一个是<em class="ne">θ</em>= 2，表示为Z(2)。</li><li id="1d7b" class="nt nu iv ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">外推:我们将两条θ线外推至未来。Z(0)是使用线性回归外推的，因为它本身是线性回归线。使用简单的指数平滑外推Z(2)。</li><li id="e420" class="nt nu iv ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated"><strong class="ld iw">组合</strong>:我们组合两条θ线的外推，以获得一条预测线。</li><li id="f650" class="nt nu iv ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated"><strong class="ld iw">把季节性加回来</strong>:如果季节性在第一步中被移除，我们在最后把它加回来。</li></ol><p id="d8b1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在我们了解了Theta模型的工作原理，让我们在预测练习中应用它！</p><h1 id="5921" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb oh kc mt ke oi kf mv kh oj ki mx my bi translated">使用Theta模型进行预测</h1><p id="f1f3" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">在这个练习中，我们将预测从1958年3月到2001年12月在莫纳罗亚天文台记录的二氧化碳浓度。数据每周都被记录下来。</p><p id="0d53" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在任何时候，都可以在<a class="ae la" href="https://github.com/marcopeix/time-series-analysis/blob/master/theta_model.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上随意查阅源代码。</p><p id="e43f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">第一步当然是导入必要的库并加载数据。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="5935" class="nh mi iv ol b gy op oq l or os">import numpy as np<br/>import pandas as pd<br/>import statsmodels.api as sm<br/>import matplotlib.pyplot as plt</span><span id="a1a3" class="nh mi iv ol b gy ot oq l or os"># Load the data<br/>df = sm.datasets.co2.load_pandas().data<br/>df.head()</span></pre><p id="2fcf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后我们可以可视化我们的数据集。结果如下图所示。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="35b2" class="nh mi iv ol b gy op oq l or os">fig, ax = plt.subplots()</span><span id="3193" class="nh mi iv ol b gy ot oq l or os">ax.plot(df['co2'])<br/>ax.set_xlabel('Time')<br/>ax.set_ylabel('CO2 concentration (ppmw)')</span><span id="93f8" class="nh mi iv ol b gy ot oq l or os">fig.autofmt_xdate()<br/>plt.tight_layout()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ou"><img src="../Images/0b53c7540cbd481e5b33c64b6b4018a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1QfhY103ft3LAARynOY4cw.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">从1958年3月到2001年12月的每周CO2浓度。请注意，我们在数据集的开头有一些缺失的值。图片由作者提供。</p></figure><p id="37e7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">查看上图，我们注意到三个重要元素:</p><ol class=""><li id="7cc6" class="nt nu iv ld b le lf lh li lk nv lo nw ls nx lw ny nz oa ob bi translated">我们的系列有一个积极的趋势，因为二氧化碳浓度随着时间的推移而增加。</li><li id="ca11" class="nt nu iv ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">我们的系列具有年度季节性，因为冬季的二氧化碳含量高于夏季。</li><li id="5a23" class="nt nu iv ld b le oc lh od lk oe lo of ls og lw ny nz oa ob bi translated">我们在数据集的开头有一些缺失的值。</li></ol><p id="fc83" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">所以，让我们去掉缺失的值。这里，我们简单地使用两个已知点来插值缺失值。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="6960" class="nh mi iv ol b gy op oq l or os">df = df.interpolate()</span></pre><p id="1b26" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这就解决了任何缺失的值，我们准备好继续进行预测了。</p><h2 id="38e3" class="nh mi iv bd mj ni nj dn mn nk nl dp mr lk nm nn mt lo no np mv ls nq nr mx ns bi translated">预测</h2><p id="4aa3" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">对于这种情况，我们为测试集保留最近两年的观察结果。由于我们有周数据，并且一年有52周，这意味着最后104个点是用于测试集的，其余的是用于训练的。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="486d" class="nh mi iv ol b gy op oq l or os">train = df[:-104]<br/>test = df[-104:]</span></pre><p id="84e6" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们必须设定一个预测范围。在这里，我们将其设置为52周，或一年。这意味着我们想要建立一个模型来预测未来52周的二氧化碳浓度。</p><p id="b7ac" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">由于我们的测试集有104周的数据，我们将执行滚动预测。这意味着我们在训练集上训练模型，预测未来52周，然后在更新的训练集上重新训练模型，该训练集包括另外52周的数据，以预测未来52周。</p><p id="29d1" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">用文字描述滚动预测是相当混乱的，所以这里有一个图表来形象化整个过程。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/7b6ec32511ee515465bb74b5871a23e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*9pOUXIfrD_R9tydeLJXNQw.jpeg"/></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">可视化滚动预测。在第一遍中，我们预测了测试集的前52周。在第二遍中，我们预测了测试集的最后52周，但是使用了更新的训练集。图片由作者提供。</p></figure><p id="80cd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从上图中，我们可以看到我们预测了104周的整个测试集，但是一次预测了52周。这样，我们就可以在做出新的预测之前模拟收集新数据并添加到训练集的过程。</p><p id="09d4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在继续之前，我们还需要选择一个基线模型。在这里，由于我们有季节性数据，一个合理的基线将是简单地预测已知的最后一个季节。因为我们有每年的季节性，并且每年有52次观察，这相当于在未来重复最后的52个数据点。</p><p id="6ab4" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">有了所有这些设置，我们现在可以构建我们的函数来进行滚动预测。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="23d5" class="nh mi iv ol b gy op oq l or os">from statsmodels.tsa.forecasting.theta import ThetaModel</span><span id="a4b8" class="nh mi iv ol b gy ot oq l or os">def rolling_forecast(df: pd.DataFrame, train_len: int, horizon: int, window: int, method: str) -&gt; list:<br/>    <br/>    total_len = train_len + horizon<br/>    end_idx = train_len</span><span id="45f3" class="nh mi iv ol b gy ot oq l or os">if method == 'last_season':<br/>        pred_last_season = []<br/>        <br/>        for i in range(train_len, total_len, window):<br/>            last_season = df[:i].iloc[-window:].values<br/>            pred_last_season.extend(last_season)<br/>            <br/>        return pred_last_season<br/>    <br/>    elif method == 'theta':<br/>        pred_theta = []<br/>        <br/>        for i in range(train_len, total_len, window):<br/>            tm = ThetaModel(endog=df[:i], period=52)<br/>            res = tm.fit()<br/>            predictions = res.forecast(window)<br/>            pred_theta.extend(predictions)<br/>            <br/>        print(res.summary()) #Optional</span><span id="3627" class="nh mi iv ol b gy ot oq l or os">return pred_theta</span></pre><p id="6622" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从上面可以看出，我们的函数需要一个时间序列数据集、训练集的初始长度、测试集的长度以及一个窗口或一个范围。</p><p id="0854" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">训练集和测试集的长度很容易从我们之前进行的划分中恢复，我们的窗口将是52周，如前所述。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="2db6" class="nh mi iv ol b gy op oq l or os">TRAIN_LEN = len(train)<br/>HORIZON = len(test)<br/>WINDOW = 52</span></pre><p id="d3ab" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我们现在准备预测我们的时间序列，使用基线模型和Theta模型。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="1656" class="nh mi iv ol b gy op oq l or os">test = test.copy()</span><span id="727c" class="nh mi iv ol b gy ot oq l or os">test.loc[:, 'pred_last_season'] = pred_last_season<br/>test.loc[:, 'pred_theta'] = pred_theta</span><span id="be88" class="nh mi iv ol b gy ot oq l or os">test.head()</span></pre><h2 id="626b" class="nh mi iv bd mj ni nj dn mn nk nl dp mr lk nm nn mt lo no np mv ls nq nr mx ns bi translated">添加三重指数平滑</h2><p id="b22f" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">为了便于比较，让我们在这种情况下也应用三重指数平滑法。这样，我们可以将Theta模型的性能与基线和另一个相对简单的模型进行比较。</p><p id="17df" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为此，我们必须更新我们的<em class="ne"> rolling_forecast </em>函数来实现三重指数平滑。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="c0b4" class="nh mi iv ol b gy op oq l or os">from statsmodels.tsa.holtwinters import ExponentialSmoothing</span><span id="6de1" class="nh mi iv ol b gy ot oq l or os">def rolling_forecast(df: pd.DataFrame, train_len: int, horizon: int, window: int, method: str) -&gt; list:<br/>    <br/>    total_len = train_len + horizon<br/>    end_idx = train_len</span><span id="5cfb" class="nh mi iv ol b gy ot oq l or os">if method == 'last_season':<br/>        pred_last_season = []<br/>        <br/>        for i in range(train_len, total_len, window):<br/>            last_season = df[:i].iloc[-window:].values<br/>            pred_last_season.extend(last_season)<br/>            <br/>        return pred_last_season<br/>    <br/>    elif method == 'theta':<br/>        pred_theta = []<br/>        <br/>        for i in range(train_len, total_len, window):<br/>            tm = ThetaModel(endog=df[:i], period=52)<br/>            res = tm.fit()<br/>            predictions = res.forecast(window)<br/>            pred_theta.extend(predictions)</span><span id="ce3b" class="nh mi iv ol b gy ot oq l or os">return pred_theta<br/>            <br/>    elif method == 'tes':<br/>        pred_tes = []<br/>        <br/>        for i in range(train_len, total_len, window):<br/>            tes = ExponentialSmoothing(<br/>                df[:i],<br/>                trend='add',<br/>                seasonal='add',<br/>                seasonal_periods=52,<br/>                initialization_method='estimated'<br/>            ).fit()<br/>            <br/>            predictions = tes.forecast(window)<br/>            pred_tes.extend(predictions)</span><span id="e2ec" class="nh mi iv ol b gy ot oq l or os">return pred_tes</span></pre><p id="e917" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，我们简单地运行它来添加来自三重指数平滑的预测。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="f120" class="nh mi iv ol b gy op oq l or os">pred_tes = rolling_forecast(df, TRAIN_LEN, HORIZON, WINDOW, 'tes')</span><span id="667f" class="nh mi iv ol b gy ot oq l or os">test.loc[:, 'pred_tes'] = pred_tes</span><span id="00ee" class="nh mi iv ol b gy ot oq l or os">test.head()</span></pre><h2 id="d8a0" class="nh mi iv bd mj ni nj dn mn nk nl dp mr lk nm nn mt lo no np mv ls nq nr mx ns bi translated">估价</h2><p id="4851" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">现在，我们已经有了来自基线、Theta模型和三重指数平滑的预测，让我们评估每一个并确定冠军模型。</p><p id="2514" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里，我们使用平均绝对百分比误差，或MAPE，来评估我们的模型。</p><p id="3bb7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在实际测量性能之前，让我们首先将模型的预测与实际值进行对比。结果如下图所示。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="e99a" class="nh mi iv ol b gy op oq l or os">fig, ax = plt.subplots()</span><span id="4a1c" class="nh mi iv ol b gy ot oq l or os">ax.plot(df['co2'])<br/>ax.plot(test['co2'], 'b-', label='actual')<br/>ax.plot(test['pred_last_season'], 'r:', label='baseline')<br/>ax.plot(test['pred_theta'], 'g-.', label='Theta')<br/>ax.plot(test['pred_tes'], 'k--', label='TES')</span><span id="d053" class="nh mi iv ol b gy ot oq l or os">ax.set_xlabel('Time')<br/>ax.set_ylabel('CO2 concentration (ppmv)')<br/>ax.axvspan('2000-01-08', '2001-12-29', color='#808080', alpha=0.2)</span><span id="f4d3" class="nh mi iv ol b gy ot oq l or os">ax.legend(loc='best')</span><span id="e99c" class="nh mi iv ol b gy ot oq l or os">ax.set_xlim('1998-03-07', '2001-12-29')</span><span id="a2a9" class="nh mi iv ol b gy ot oq l or os">fig.autofmt_xdate()<br/>plt.tight_layout()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ou"><img src="../Images/e9da15dd695af51cc20df4df86243a5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x6jih_7Ul1aF_4F4PH7LsA.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">我们可以看到，从基线得到的预测值与实际值相差最远。否则，三重指数平滑似乎更接近实际值。图片由作者提供。</p></figure><p id="fb1c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看上面的图，我们可以看到基线的预测值与实际值相差最远。我们还看到来自三重指数平滑的线(黑色虚线)似乎最接近实际值。</p><p id="2896" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">让我们通过实际计算MAPE来验证一下。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="ffda" class="nh mi iv ol b gy op oq l or os">def mape(y_true, y_pred):<br/>    return round(np.mean(np.abs((y_true - y_pred) / y_true)) * 100, 2)</span><span id="a2cc" class="nh mi iv ol b gy ot oq l or os">mape_baseline = mape(test['co2'], test['pred_last_season'])<br/>mape_theta = mape(test['co2'], test['pred_theta'])<br/>mape_tes = mape(test['co2'], test['pred_tes'])</span></pre><p id="048f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">注意，在写这篇文章的时候，MAPE还没有在scikit-learn的稳定版本中实现，但是它很快就要实现了！</p><p id="6f88" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，让我们用柱状图直观地展示每个模型的MAPE。</p><pre class="kl km kn ko gt ok ol om on aw oo bi"><span id="048e" class="nh mi iv ol b gy op oq l or os">fig, ax = plt.subplots()</span><span id="3be3" class="nh mi iv ol b gy ot oq l or os">x = ['Baseline', 'Theta', 'TES']<br/>y = [mape_baseline, mape_theta, mape_tes]</span><span id="cf09" class="nh mi iv ol b gy ot oq l or os">ax.bar(x, y, width=0.4)<br/>ax.set_xlabel('Exponential smoothing models')<br/>ax.set_ylabel('MAPE (%)')<br/>ax.set_ylim(0, 1)</span><span id="2277" class="nh mi iv ol b gy ot oq l or os">for index, value in enumerate(y):<br/>    plt.text(x=index, y=value + 0.05, s=str(value), ha='center')<br/>    <br/>plt.tight_layout()</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ou"><img src="../Images/31800e5b05b20eeda342da80cfa21cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UDwXGIotjjhWv123Ebyw4Q.png"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">在这里，三重指数平滑显然是赢家，因为它实现了最低的MAPE。图片由作者提供。</p></figure><p id="7ac3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看上面的图，我们可以看到我们的冠军模型是三重指数平滑，因为它实现了0.12%的MAPE。</p><p id="3e35" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">至于Theta模型，它优于基线，但不如三重指数平滑。</p><h1 id="e9d9" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb oh kc mt ke oi kf mv kh oj ki mx my bi translated">结论</h1><p id="c15d" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">虽然Theta模型在这种特定情况下不是冠军模型，但它仍然是一个很好的预测方法，可以放在您的工具箱中。</p><p id="029b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">它的分解方法使它成为预测时间序列的一种灵活而快速的方法。至少，它可以作为比较其他更复杂模型的坚实基准。</p><p id="fe47" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">本文到此为止！祝贺你坚持到最后，我希望你喜欢它并且学到了新的东西！</p><p id="8207" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">一定要下载我用Python写的<a class="ae la" href="https://www.datasciencewithmarco.com/pl/2147608294" rel="noopener ugc nofollow" target="_blank">免费时间序列预测小抄</a>，涵盖统计和深度学习模型！</p><p id="62a5" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">干杯🍺</p><h1 id="9197" class="mh mi iv bd mj mk ml mm mn mo mp mq mr kb oh kc mt ke oi kf mv kh oj ki mx my bi translated">资源</h1><p id="76f7" class="pw-post-body-paragraph lb lc iv ld b le mz jw lg lh na jz lj lk nb lm ln lo nc lq lr ls nd lu lv lw io bi translated">Grzegorz Dudek — <a class="ae la" href="https://www.e3s-conferences.org/articles/e3sconf/pdf/2019/10/e3sconf_pe2019_01004.pdf" rel="noopener ugc nofollow" target="_blank">使用Theta方法的短期负荷预测</a></p><p id="f3a8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">罗布·j·海德曼，叶鬼·比拉— <a class="ae la" href="https://robjhyndman.com/papers/Theta.pdf" rel="noopener ugc nofollow" target="_blank">揭开西塔方法的面纱</a></p><p id="139d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">动词 （verb的缩写）Assimakopoulos，k . Nikolopoulos—<a class="ae la" href="https://www.researchgate.net/publication/223049702_The_theta_model_A_decomposition_approach_to_forecasting" rel="noopener ugc nofollow" target="_blank">theta模型:预测的分解方法</a></p><p id="bcbc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">K.Nikolopoulos，V. Assimakopoulos，N. Bougioukos，a . Litsa—<a class="ae la" href="https://www.researchgate.net/publication/288135300_The_Theta_Model_An_Essential_Forecasting_Tool_for_Supply_Chain_Planning" rel="noopener ugc nofollow" target="_blank">Theta模型:供应链规划的重要预测工具</a></p></div></div>    
</body>
</html>