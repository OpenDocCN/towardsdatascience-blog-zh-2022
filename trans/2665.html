<html>
<head>
<title>Transactions in a Big Data World</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大数据世界中的交易</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/transactions-in-a-data-world-609ebe9384b2#2022-06-08">https://towardsdatascience.com/transactions-in-a-data-world-609ebe9384b2#2022-06-08</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="1bfe" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">为什么酸支持对模型预测再现性至关重要？</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/416ba785eb27249878cfbfdc7e78f9b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjjgsNMGTl83guviYw4MqA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图:大数据交易(基于来自<a class="ae kz" href="https://www.pexels.com/photo/woman-in-red-long-sleeve-writing-on-chalk-board-3769714/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@olly?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Andrea Piacquadio </a>的图片)</p></figure><p id="d495" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">摘要</strong>。带有ACID保证的事务曾经是数据库管理系统的支柱。然而，随着流媒体和NoSQL的出现，交易被认为过于严格，难以在大数据平台上实施。最终的一致性成为了这类平台的标准，其中一些分布式节点之间可能是不一致的——返回不同的值；所有节点在稍后的时间点收敛到相同的值。</p><p id="f1bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">然而，大数据平台/框架现在已经成熟，我们看到了提供ACID支持的平台的复兴，例如三角洲湖、胡迪和冰山。在本文中，我们为大数据世界中的事务提供了案例，为如何在这种场景中实现事务提供了必要的背景。我们展示了一个具体的应用，说明了ACID事务如何在实现数据历史化方面发挥关键作用。</em></p><h1 id="4348" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">处理</h1><p id="45b2" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">事务可被视为由操作Begin和Commit/Abort封装的一组操作，具有以下属性(ACID):</p><ul class=""><li id="b738" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated"><strong class="lc iv">原子性</strong>:要么所有操作都执行，要么都不执行。在失败(中止)的情况下，属于该事务的任何操作的效果都被取消(回滚)。</li><li id="f5e6" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><strong class="lc iv">一致性</strong>:每个事务将系统从一种一致状态转移到另一种一致状态。</li><li id="ab8e" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><strong class="lc iv">隔离</strong>:为了提高性能，通常会同时执行几个事务。隔离要求这种并发执行的效果等同于串行执行的效果。这是通过确保事务的中间结果在成功完成(提交)之前不会被外部化来实现的。</li><li id="9434" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><strong class="lc iv">持久性</strong>:一旦事务提交，其效果是持久的，即它们不应被任何系统或软件崩溃所破坏。</li></ul><p id="5958" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，让我们考虑一下传统的银行交易<em class="lw"> t_b </em>，它涉及到从一个账户<em class="lw"> A </em>向另一个账户<em class="lw"> B </em>转账。该交易由两个操作组成——第一个操作从账户<em class="lw"> A </em>中取钱，第二个操作将钱存入账户<em class="lw"> B </em>。不用说，事务的任何部分执行都会导致不一致的状态。原子性属性确保提取和存放操作要么都成功，要么都失败。隔离属性确保对两个帐户<em class="lw"> A </em>和<em class="lw"> B </em>的更改对其他事务不可见，直到<em class="lw"> t_b </em>提交。原子性和隔离性共同保证了系统的一致性(账号<em class="lw"> A </em>和<em class="lw"> B </em>)。</p><p id="26ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">负责实现事务的软件通常被称为事务管理器(TM)。我们可以将TM的功能分为以下几个部分:</p><ul class=""><li id="6911" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">并发控制管理器(CCM):CCM确保隔离属性。并发控制机制允许以受控的方式在并发事务之间共享资源。</li><li id="9ce2" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">恢复管理器(RM):RM负责在出现故障或软件/硬件崩溃时提供原子性和持久性属性。</li><li id="982b" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">日志管理器(LM):LM负责将执行细节写入稳定存储。虽然日志在恢复中起着重要的作用，但它也用于分析和提高系统性能和效率。</li></ul><blockquote class="ni nj nk"><p id="eea4" class="la lb lw lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">虽然事务已被接受为提供容错和可靠性的标准手段，但当我们试图在分布式环境中应用它们时，新的挑战出现了。</p></blockquote><h2 id="cfe1" class="no ly iu bd lz np nq dn md nr ns dp mh lj nt nu mj ln nv nw ml lr nx ny mn nz bi translated">分布式事务— 2PC</h2><p id="8d65" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">分布式事务由在通过通信网络连接的不同地点执行的操作组成。分布式事务起源于一个站点(也称为主/根站点),逐渐涉及其他站点，在这些站点中，属于事务的操作被转发以供执行。集中式和分布式系统中事务处理的主要区别如下:</p><ul class=""><li id="8a22" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">决策制定:提交/中止事务的决策不限于单个TM。相反，需要根据所有相关地点的TMs的决定做出集体决定。</li><li id="cc75" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">多点故障:对于集中式系统，系统要么工作，要么不工作。然而，在分布式系统中，我们可能会遇到部分故障，即一些相关站点发生故障，而其他站点仍在工作。</li></ul><p id="0203" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们需要一种协议来确保在所有涉及的站点一致地执行相同的决策(提交/中止),而不管部分故障。两阶段提交(2PC)协议可能是针对上述问题的最广泛接受的解决方案。主站点的TM充当协调者，而所有其他相关站点的TM承担参与者的角色。顾名思义，2PC协议包括两个阶段。在<em class="lw">第一</em>阶段，协调器TM向所有参与者TM发送准备消息。每个参与者TM根据它是否想要提交/中止来投票赞成/反对。如果协调器TM从其所有参与者TM接收到“是”，那么它通过向所有参与者TM发送提交消息来开始协议的第二阶段<em class="lw">。然而，如果它从至少一个参与者TM接收到“否”,则它通过向所有参与者TM发送中止消息来启动第二阶段。最后，协调器TM等待来自参与者TMs的确认，以完成第二阶段。</em></p><h2 id="040f" class="no ly iu bd lz np nq dn md nr ns dp mh lj nt nu mj ln nv nw ml lr nx ny mn nz bi translated">补偿—传奇</h2><p id="8b57" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">虽然上述协议对于紧密耦合的分布式应用程序工作良好，但是它对于长时间运行和松散耦合的应用程序的适用性是有限的。为了确保ACID属性(在集中式场景中)，需要持有锁，直到事务提交。</p><blockquote class="ni nj nk"><p id="15e4" class="la lb lw lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">从性能角度来看，这并不是一个理想的情况，尤其是对于长时间运行的事务——必须持有锁，直到所有涉及的(协调者和参与者)站点都准备好提交。</p></blockquote><p id="e7cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对上述限制的一个优雅的解决方案是嵌套事务的概念[1]。嵌套事务允许相关站点的TMs通过以受控方式外部化中间结果，在事务本地完成后立即释放它们的锁。基本上，全局事务(提交给根TM)被分成许多可以并发执行的子事务。虽然保证了全局事务的ACID属性，但是子事务并没有完全隔离，因为它们的结果向它们的父事务公开。甚至不能保证子事务的持久性，因为如果其父事务中止，可能需要取消它的效果(在提交后)。</p><p id="d5f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然嵌套事务的概念在某种程度上解决了性能问题，但它仍然需要相关的TMs的某些保证。然而，考虑到松散耦合的分布式系统的自治性和异构性需求，这样的保证可能并不总是可行的。Sagas [2]或开放嵌套事务[3]通过允许子事务产生的中间结果不受任何限制地公开来缓解这个问题。</p><blockquote class="ni nj nk"><p id="f8d9" class="la lb lw lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">Sagas依靠补偿事务的概念[4]来确保失败时的原子性。基本上，对于每个事务t，指定了能够在语义上消除事务t的影响的补偿事务t_c。</p></blockquote><p id="91a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在失败的情况下，通过以与它们各自事务的原始执行顺序相反的顺序执行补偿事务来保证原子性。补偿交易的典型例子是“取消预订”或“撤销”,分别能够撤销“预订票”或“存款”交易的效果。在这里，记住补偿并不总是可能的，尤其是对于现实生活中的交易。</p><blockquote class="ni nj nk"><p id="a6b7" class="la lb lw lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">总的来说，不同级别的补偿可能会有不同的成本。</p></blockquote><p id="2197" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，让我们考虑经典的旅行预订场景(图1)。如果酒店或航班预订需要补偿，那么可以通过分别在酒店或航班预订站点调用补偿(取消)操作，或者通过在复合旅行预订站点调用补偿操作(取消旅行)来实现。现在，如果我们假设用户是复合旅游预订网站的高级会员，并因此在所有取消费用上获得15%的折扣，那么(从用户的角度来看)在复合旅游预订网站调用取消旅游操作是有益的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oa"><img src="../Images/e104c81db99b9f992c64d3d6252acc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FiCxsvC2OIP5Z9ilFrKl6Q.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图1:补偿事务场景(作者图片)</p></figure><h1 id="ad6a" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">大数据环境中的交易</h1><p id="e8e1" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">在本节中，我们将介绍一些提供ACID支持的关键数据平台/框架。然后，我们展示了一个具体的应用程序，它支持upsert / merge操作，这对于实现数据历史化至关重要。</p><p id="be4b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://github.com/delta-io/delta" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> Delta Lake </strong> </a>是一个开源框架，为Apache Spark和大数据工作负载带来了ACID事务。人们可以下载开源的Delta Lake，在HDFS内部使用。该框架允许从任何支持Apache Spark数据源的存储系统读取数据，并写入Delta Lake，Delta Lake以Parquet格式存储数据。有关技术细节，请参考[5]。</p><blockquote class="ni nj nk"><p id="b2de" class="la lb lw lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">ACID事务提供了Delta Lake的关键“时间旅行”功能，允许探索特定时间点的数据，支持访问和回滚到对审计和模型预测再现性至关重要的数据的早期版本。</p></blockquote><p id="ddbb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里可以利用的替代数据平台/框架包括Apache <a class="ae kz" href="https://hudi.apache.org/" rel="noopener ugc nofollow" target="_blank">胡迪</a>和Apache <a class="ae kz" href="https://iceberg.apache.org/" rel="noopener ugc nofollow" target="_blank">冰山</a>。<strong class="lc iv">胡迪</strong>遵循传统的基于“事务日志”的方法，使用带有时间戳的数据文件和日志文件来跟踪数据文件中记录的变化。<strong class="lc iv"> Iceberg </strong>使用以下元数据层次结构提供ACID支持:</p><ul class=""><li id="a285" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">表“元数据文件”</li><li id="84ca" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">对应于表快照的“清单列表”</li><li id="c734" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">定义数据文件组的“清单”,这些数据文件可以是多个快照的一部分</li></ul><p id="ddd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">表写入会创建一个新的快照，它可以与并发查询并行运行(返回最后一个快照值)。并发写入遵循乐观并发控制协议，提交的第一个事务成功；导致所有其他冲突并发事务的重启。</p><p id="bf16" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们展示了ACID事务如何在数据历史化中发挥关键作用。</p><h2 id="568e" class="no ly iu bd lz np nq dn md nr ns dp mh lj nt nu mj ln nv nw ml lr nx ny mn nz bi translated">数据历史化</h2><p id="fffe" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">历史化是跟踪数据随时间变化的过程。它适用于数据平台的所有层(图2):摄取到“原始”(青铜)中的源数据，到“精炼”(银)中的净化数据，到“精选”(金)中的转换数据。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/2129af7ccf5f92eb319865ddc0ceb7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCFak1EaPonUN3Yg8DU1zg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图2:分层数据架构(图片由作者提供)</p></figure><p id="0af7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">主要有两种数据历史化方法:</p><ul class=""><li id="4aa5" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">渐变维度类型2 ( <strong class="lc iv"> SCD2 </strong>):每次一个或多个列值发生变化时，变化历史都会为标识符添加一条新记录。例如，关于分别在AWS和Oracle云平台上实现SCD2的详细信息，请参考[6，7]。</li><li id="48af" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated"><strong class="lc iv">快照历史</strong>每当来自源系统的数据交付到达时，添加一个新的标识符记录，无论它是否包含更改。<br/>原始的&amp;暂存层)，易于实现和对晚到达数据的鲁棒性。</li></ul><p id="16b0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">混合方法:</strong></p><p id="9c41" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">原始/暂存层的快照历史</em> <strong class="lc iv"> : </strong>实现一个永久暂存区，作为源数据交付的永久存档。这允许在对源数据进行显式建模之前对其进行加载和历史记录，并作为一种预防管理层/聚合数据存储中的建模错误的措施。</p><p id="67af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">利用SCD2管理层/聚合数据存储:</em></p><p id="33ab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于<strong class="lc iv">策划层来说，SCD2 </strong>仍然是最流行的历史化技术。创建新记录时，前一个记录需要过期。这包括<strong class="lc iv">多个</strong>操作(参见下面的示例表进行说明):</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/dbf1a4d7e7aa8a138f0a8bc15df2bacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeIZ9i-YXcmgYkGJ6F0TWg.png"/></div></div></figure><ul class=""><li id="65ec" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">在当前数据集中查找记录，将现有记录的eff_end_data设置为新记录的eff_start_date，并将现有记录的is_current标志设置为“false”</li><li id="7ba8" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">插入新记录。</li></ul><blockquote class="ni nj nk"><p id="abc0" class="la lb lw lc b ld le jv lf lg lh jy li nl lk ll lm nm lo lp lq nn ls lt lu lv in bi translated">Delta Lake /胡迪/ Iceberg对ACID事务的支持使得以可靠和可伸缩的方式执行这种<strong class="lc iv"> Upsert </strong>(合并)操作成为可能。</p></blockquote><h1 id="71a3" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">参考</h1><ol class=""><li id="1c66" class="mu mv iu lc b ld mp lg mq lj od ln oe lr of lv og na nb nc bi translated">T.E.B .莫斯。<em class="lw">嵌套事务:一种可靠的分布式计算方法</em>。麻省理工学院计算机科学实验室博士论文，1981年。</li><li id="d323" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv og na nb nc bi translated">H.加西亚.莫利纳和k .塞勒姆。<em class="lw">传奇</em>。在斯通布雷克，医学博士。数据库系统阅读，旧金山，加州，1987，290-300。</li><li id="9e06" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv og na nb nc bi translated">G.维库姆，执事，沙德，谢克。<em class="lw">联邦数据库系统中的开放式嵌套事务</em>。IEEE数据工程通报，16(2):4–7，1993年6月。</li><li id="cbab" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv og na nb nc bi translated">D.比斯瓦斯。<em class="lw">Web服务组合世界中的补偿</em>。在:语义Web服务和Web过程组合。SWSWPC 2004。计算机科学讲义，第3387卷。<a class="ae kz" href="https://doi.org/10.1007/978-3-540-30581-1_7" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1007/978-3-540-30581-1_7</a></li><li id="5f9c" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv og na nb nc bi translated">米（meter的缩写））阿姆布鲁斯特等人。艾尔<em class="lw">。Delta lake:云对象存储上的高性能ACID表存储。</em>过程。VLDB捐赠。13，12(2020年8月)，3411–3424。<a class="ae kz" href="https://doi.org/10.14778/3415478.3415560" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.14778/3415478.3415560</a></li><li id="7e3d" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv og na nb nc bi translated">D.格林施泰因。<em class="lw">在亚马逊EMR上用阿帕奇Spark和阿帕奇胡迪构建缓变维度类型2(SCD 2)</em>，2021，<a class="ae kz" href="https://aws.amazon.com/blogs/big-data/build-slowly-changing-dimensions-type-2-scd2-with-apache-spark-and-apache-hudi-on-amazon-emr/" rel="noopener ugc nofollow" target="_blank">https://AWS . Amazon . com/blogs/big-data/Build-缓变维度类型2-SCD 2-with-Apache-Spark-and-Apache-胡迪-on-amazon-emr/ </a></li><li id="6d73" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv og na nb nc bi translated">A.杜武里。<em class="lw">Oracle云基础设施(OCI)数据集成中的缓变维度(SCD)类型2实施</em>，2020，<a class="ae kz" href="https://blogs.oracle.com/dataintegration/post/slowly-changing-dimensions-scd-type-2-implementation-in-oracle-cloud-infrastructure-oci-data-integration" rel="noopener ugc nofollow" target="_blank">https://blogs . Oracle . com/Data Integration/post/slow-Changing-Dimensions-SCD-Type-2-Implementation-in-Oracle-Cloud-infra structure-OCI-Data-Integration</a></li></ol></div></div>    
</body>
</html>