<html>
<head>
<title>Use Python to Create Three-Body Orbits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python创建三体轨道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/use-python-to-create-three-body-orbits-329ffb5b2627#2022-05-31">https://towardsdatascience.com/use-python-to-create-three-body-orbits-329ffb5b2627#2022-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对卫星在两个较大质量影响下的运动轨迹进行数值积分和可视化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e444a5d6a7f29bb27ee2ae9db26db272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*uGrPf4NWoPM9YN0RdiiOvg.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">动画CR3BP轨道(惯性框架)[由作者创建]</p></figure><p id="add0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在轨道力学中，三体(3BP)是研究一个可忽略的质量在两个较大质量(行星、月亮、恒星等)的影响下如何移动。).当必须考虑两个较大质量的引力时，这些结果用于设计航天器轨道。例如，詹姆斯·韦伯望远镜的轨道和当前轨道就是利用3BP设计的。通常，当人们想到轨道时，他们会想到一个可以忽略不计的质量，围绕着一颗行星或恒星的椭圆轨道。有了三体，系统中增加了一个额外的大质量物体，这增加了推导描述较小物体运动的方程的难度。</p><p id="3a60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了创建和可视化3BP中的轨道，我们必须推导出可忽略质量的运动方程。我在这里跳过推导的细节，但是如果你感兴趣，这篇<a class="ae lq" href="https://medium.com/illumination/orbital-mechanics-the-three-body-problem-90be80e47113" rel="noopener">文章</a>描述了如何推导三体方程。我鼓励您浏览那篇文章，以充分理解您将要使用Python求解的变量和方程。我们将学习循环受限三体(CR3BP)。在这个广义三体的限制性版本中，两个较大的质量(或原色)以圆形轨道围绕它们各自的质量中心运行。这简化了航天器(或其他可忽略质量)的运动方程。下图显示了CR3BP的设置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/714a2067179b806032984bad2934e8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6BjBtjUbmqIt2KwGfBsRg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">三体问题图[作者创作]</p></figure><p id="e72e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">针对<strong class="kw iu"><em class="lw"/></strong>(航天器、小行星等)推导出CR3BP运动方程。)在旋转框架中(<em class="lw"> x </em>、<em class="lw"> y </em>、<em class="lw"> z-hat </em>框架):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/f4f56162183bf26799c47452e921b997.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/1*ZAs9nEokrQxmUutC8xvleA.gif"/></div></figure><p id="5aea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方程有点吓人，但是一旦你知道每个变量是什么，它们就不会太糟糕。这里，<strong class="kw iu"> <em class="lw"> x </em> </strong>，<strong class="kw iu"> <em class="lw"> y </em> </strong>，<strong class="kw iu"><em class="lw">z</em></strong>(<strong class="kw iu"><em class="lw">ρ</em></strong>矢量)是<strong class="kw iu"> <em class="lw"> m₃ </em> </strong>相对于初选质心的位置坐标，在旋转坐标系(<em class="lw"> x </em>，<em class="lw"> y </em>，<em class="lw"> z-hat【中这些项上的点表示时间导数，所以一个点表示速度项，两个点表示加速度项。<strong class="kw iu"> <em class="lw"> </em> </strong>是一种无量纲质量比的初选。<strong class="kw iu"> <em class="lw"> r₁ </em> </strong>和<strong class="kw iu"> <em class="lw"> r₂ </em> </strong>分别是<strong class="kw iu"> <em class="lw"> m₃ </em> </strong>离各自主光源的距离。</em></p><p id="ea6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的运动方程是使用无量纲变量导出的。上面提到的文章详细介绍了如何使用无量纲参数，如果你真的想了解三体，这很重要。此处不涉及太多细节，以下参数用于删除和添加尺寸(km、kg、s等。)如有必要。我们可以用<strong class="kw iu"> <em class="lw"> M* </em> </strong>来操纵质量单位(kg)<strong class="kw iu"><em class="lw">【L *</em></strong>来操纵长度单位(km)<strong class="kw iu"><em class="lw"/></strong>来操纵时间单位(s)。这将在编码部分进一步解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/e7f49d1092f299d727fba34cae2a1a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*zQ7eM3883zqM5xZ5q85FQw.gif"/></div></figure><p id="caa1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了求解CR3BP，我们将使用ODE求解器对<strong class="kw iu"> <em class="lw"> m₃ </em> </strong>的运动方程进行数值积分。为了做到这一点，我们需要定义一个状态向量和一个时间导数状态向量。对于我们的问题，状态向量包括旋转坐标系中的位置和速度向量。时间导数状态向量就是状态向量的时间导数。这些将使用Python的<code class="fe lz ma mb mc b">odeint</code>数字积分器。这里的双点<strong class="kw iu"> <em class="lw"> x </em> </strong>、<strong class="kw iu"> <em class="lw"> y </em> </strong>、<strong class="kw iu"> <em class="lw"> z </em> </strong>都来自上面定义的运动方程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/3970c4d00e26de8bf3a12cf3c5ae9eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/1*VS6JnySMn2z1i0_dYqJmXA.gif"/></div></figure><p id="c793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以将旋转坐标系(<strong class="kw iu"> <em class="lw"> x </em> </strong>，<strong class="kw iu"> <em class="lw"> y </em> </strong>，<strong class="kw iu"> <em class="lw"> z </em> </strong>)中的一个矢量转换为惯性系(<strong class="kw iu"> <em class="lw"> X </em> </strong>，<strong class="kw iu"> <em class="lw"> Y </em> </strong>，<strong class="kw iu"> <em class="lw"> Z </em></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/7341d00ce6a5b8ef5ba069f04eefc54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/1*ko_VoLoZS2eSYgLIllLTrA.gif"/></div></figure><p id="2811" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我知道这只是对问题的一个简单概述，但是你不需要完全理解CR3BP就能编码一个解决方案。我假设你对数值积分以及如何用Python实现它有所了解。如果你需要这方面的一些指导，我写了另一篇<a class="ae lq" rel="noopener" target="_blank" href="/how-to-numerically-integrate-dynamics-problems-w-python-85d9783aa088?source=your_stories_page-------------------------------------">文章</a>可能会有帮助，互联网上还有很多其他资源。事不宜迟，让我们直接进入代码吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="5fa4" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">导入包</strong></h2><p id="068f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">对于这段代码，我们需要导入几个包。以下列表简要描述了此代码中使用的包:</p><ul class=""><li id="fbd1" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated"><em class="lw"> NumPy </em>用于创建和操作数组(为便于调用，定义为<code class="fe lz ma mb mc b">np</code>)</li><li id="5dfe" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">来自<em class="lw"> SciPy </em>库的<code class="fe lz ma mb mc b"><em class="lw">odeint</em></code>用于数值积分</li><li id="22b8" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><em class="lw"> matplotlib </em>中的<code class="fe lz ma mb mc b"><em class="lw">pyplot</em></code> <em class="lw"> </em>用于可视化数值积分的结果(为方便调用，定义为<code class="fe lz ma mb mc b">plt</code></li></ul><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="5ee1" class="mm mn it mc b gy oc od l oe of"># Importing Packages<br/>import numpy as np<br/>from scipy.integrate import odeint<br/>import matplotlib.pyplot as plt</span></pre><h2 id="cbd9" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">创建数值积分函数</strong></h2><p id="ced1" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">下一步是创建一个用户定义的Python函数，<code class="fe lz ma mb mc b">model_CR3BP</code>，它将在<code class="fe lz ma mb mc b">odeint</code>中用来对我们的状态向量进行数值积分。<code class="fe lz ma mb mc b">odeint</code>函数采用当前状态向量来创建时间导数状态向量。请注意，我们从状态向量中提取位置和速度分量，以创建状态向量时间导数。</p><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="9ee1" class="mm mn it mc b gy oc od l oe of"># CR3BP Model<br/>def model_CR3BP(state, t):<br/>    x = state[0]<br/>    y = state[1]<br/>    z = state[2]<br/>    x_dot = state[3]<br/>    y_dot = state[4]<br/>    z_dot = state[5]<br/>    x_ddot = x+2*y_dot-((1-mu)*(x+mu))/((x+mu)**2+y**2+z**2)**(3/2)\ <br/>             -(mu*(x-(1-mu)))/((x-(1-mu))**2+y**2+z**2)**(3/2)<br/>    y_ddot = y-2*x_dot-((1-mu)*y)/((x+mu)**2+y**2+z**2)**(3/2)\<br/>             -(mu*y)/((x-(1-mu))**2+y**2+z**2)**(3/2)<br/>    z_ddot = -((1-mu)*z)/((x+mu)**2+y**2+z**2)**(3/2)\<br/>             -(mu*z)/((x-(1-mu))**2+y**2+z**2)**(3/2)<br/>    dstate_dt = [x_dot, y_dot, z_dot, x_ddot, y_ddot, z_ddot]<br/>    return dstate_dt</span></pre><h2 id="4b97" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">定义无量纲参数</strong></h2><p id="a6d5" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这里，我们为我们选择的系统定义几个参数。本文我选择了地月系统，但如果你想选择另一个系统(冥王星-卡戎，太阳-木星等。)，可以相应地调整质量和半长轴变量。这里，<strong class="kw iu"> <em class="lw"> m₁ </em> </strong>和<strong class="kw iu"> <em class="lw"> m₂ </em> </strong>分别是地球和月球的质量。<strong class="kw iu"> <em class="lw"> a </em> </strong>是月球轨道的半长轴(如果他们有一个完美的圆形轨道的话)。我用月球轨道的平均距离来表示<strong class="kw iu"><em class="lw"/></strong>，因为月球实际上是以圆形轨道绕地球运行的。接下来，使用本文开头的等式定义无量纲参数。</p><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="fb0e" class="mm mn it mc b gy oc od l oe of"># Defining ND Parameters<br/>G = 6.67408E-20  # Univ. Gravitational Constant [km3 kg-1 s-2]<br/>mEarth = 5.97219E+24  # Mass of the Earth [kg]<br/>mMoon = 7.34767E+22  # Mass of the Moon [kg]<br/>a = 3.844E+5  # Semi-major axis of Earth and Moon [km]<br/>m1 = mEarth<br/>m2 = mMoon<br/>Mstar = m1+m2  # ND Mass Parameter<br/>Lstar = a  # ND Length Parameter<br/>Tstar = (Lstar**3/(G*Mstar))**(1/2)  # ND Time Parameter<br/>mu = m2/Mstar<br/>print('\u03BC = ' + str(mu))</span></pre><h2 id="b94d" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">定义ODE解算器输入</strong></h2><p id="04b1" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在，除了用户定义的模型，<code class="fe lz ma mb mc b">odeint</code>还需要两个输入:初始条件和积分的时间间隔。我定义了一组任意的初始条件，来创建你们一开始看到的轨道。你可以尝试你自己的初始条件或者使用这个<a class="ae lq" href="https://ssd.jpl.nasa.gov/horizons/app.html#/" rel="noopener ugc nofollow" target="_blank"> NASA JPL工具</a>中的星历数据。接下来，我们定义初始状态向量<code class="fe lz ma mb mc b">state_0</code>，以及感兴趣的时间数组<code class="fe lz ma mb mc b">t</code>。请注意，使用上面的ND参数移除了尺寸。公里和秒单位通过除以或乘以<strong class="kw iu"> <em class="lw"> T* </em> </strong>和<strong class="kw iu"> <em class="lw"> L* </em> </strong>来移除。</p><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="8830" class="mm mn it mc b gy oc od l oe of"># Initial Conditions [Initial State Vector]<br/>X_0 = 50000/Lstar  # ND x<br/>Y_0 = 0            # ND y<br/>Z_0 = 0            # ND z<br/>VX_0 = 1.08*Tstar/Lstar  # ND x_dot<br/>VY_0 = 3.18*Tstar/Lstar  # ND y_dot<br/>VZ_0 = 0.68*Tstar/Lstar  # ND z_dot<br/>state_0 = [X_0, Y_0, Z_0, VX_0, VY_0, VZ_0]  # ND ICs<br/><br/># Time Array<br/>t = np.linspace(0, 15, 1000)  # ND Time</span></pre><h2 id="ef32" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">数值积分模型</strong></h2><p id="8b59" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">下一步是组合我们已经编码的内容，并在<code class="fe lz ma mb mc b">odeint</code>函数中使用它们。这里，我们使用<code class="fe lz ma mb mc b">model_CR3BP</code>、<code class="fe lz ma mb mc b">state_0</code>和<code class="fe lz ma mb mc b">t</code>。数值积分的输出是我们在时间数组中定义的每一步的状态向量。从结果中我们可以拉出定义<strong class="kw iu"><em class="lw"/></strong>位置的<strong class="kw iu"><em class="lw">x</em></strong><strong class="kw iu"><em class="lw">y</em></strong><strong class="kw iu"><em class="lw">z</em></strong>坐标(在旋转坐标系中)。接下来，使用本文开头的等式，我们可以将转动状态转换为惯性状态。</p><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="4a55" class="mm mn it mc b gy oc od l oe of"># Numerically Integrating<br/>sol = odeint(model_CR3BP, state_0, t)<br/><br/># Rotational Frame Position Time History<br/>X_rot = sol[:, 0]<br/>Y_rot = sol[:, 1]<br/>Z_rot = sol[:, 2]<br/><br/># Inertial Frame Position Time History<br/>X_Iner = sol[:, 0]*np.cos(t) - sol[:, 1]*np.sin(t)<br/>Y_Iner = sol[:, 0]*np.sin(t) + sol[:, 1]*np.cos(t)<br/>Z_Iner = sol[:, 2]</span></pre><h2 id="a3f2" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">添加主要位置时间历史</strong></h2><p id="a932" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">这一步是可选的，但是包括两次初选的时间历程对于理解<strong class="kw iu"><em class="lw"/></strong>的运动可能是重要的。原色的位置在旋转框架中是固定的(对于CR3BP ),并且可以通过使用原色的质心并转换到nd单位来简单地导出。接下来，使用与前面相同的旋转坐标系到惯性坐标系的转换，我们可以确定原色的惯性运动时间历程。</p><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="45dd" class="mm mn it mc b gy oc od l oe of"># Constant m1 and m2 Rotational Frame Locations for CR3BP Primaries<br/>m1_loc = [-mu, 0, 0]<br/>m2_loc = [(1-mu), 0, 0]<br/><br/># Moving m1 and m2 Inertial Locations for CR3BP Primaries<br/>X_m1 = m1_loc[0]*np.cos(t) - m1_loc[1]*np.sin(t)<br/>Y_m1 = m1_loc[0]*np.sin(t) + m1_loc[1]*np.cos(t)<br/>Z_m1 = m1_loc[2]*np.ones(len(t))<br/>X_m2 = m2_loc[0]*np.cos(t) - m2_loc[1]*np.sin(t)<br/>Y_m2 = m2_loc[0]*np.sin(t) + m2_loc[1]*np.cos(t)<br/>Z_m2 = m2_loc[2]*np.ones(len(t))</span></pre><h2 id="4209" class="mm mn it bd mo mp mq dn mr ms mt dp mu ld mv mw mx lh my mz na ll nb nc nd ne bi translated"><strong class="ak">可视化数据</strong></h2><p id="7fc1" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">最后一步是绘制每个质量的旋转和惯性系运动。为了区分轨道，我们将用绿色代表<strong class="kw iu"> <em class="lw">、m₃ </em> </strong>，黑色代表月球，蓝色代表地球。我们还可以设置这些轴，使它们显示相等的轴长，以便更准确地观察系统。</p><pre class="kj kk kl km gt ny mc nz oa aw ob bi"><span id="56d8" class="mm mn it mc b gy oc od l oe of"># Rotating Frame Plot<br/>fig = plt.figure()<br/>ax = plt.axes(projection='3d')<br/><br/># Adding Figure Title and Labels<br/>ax.set_title('Rotating Frame CR3BP Orbit (\u03BC = ' + str(round(mu, 6)) + ')')<br/>ax.set_xlabel('x [ND]')<br/>ax.set_ylabel('y [ND]')<br/>ax.set_zlabel('z [ND]')<br/><br/># Plotting Rotating Frame Positions<br/>ax.plot3D(X_rot, Y_rot, Z_rot, c='green')<br/>ax.plot3D(m1_loc[0], m1_loc[1], m1_loc[2], c='blue', marker='o')<br/>ax.plot3D(m2_loc[0], m2_loc[1], m2_loc[2], c='black', marker='o')<br/><br/># Setting Axis Limits<br/>xyzlim = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()]).T<br/>XYZlim = np.asarray([min(xyzlim[0]), max(xyzlim[1])])<br/>ax.set_xlim3d(XYZlim)<br/>ax.set_ylim3d(XYZlim)<br/>ax.set_zlim3d(XYZlim * 3 / 4)<br/><br/><br/># Inertial Frame Plot<br/>fig = plt.figure()<br/>ax = plt.axes(projection='3d')<br/><br/># Adding Figure Title and Labels<br/>ax.set_title('Inertial Frame CR3BP Orbit (\u03BC = ' + str(round(mu, 6)) + ')')<br/>ax.set_xlabel('X [ND]')<br/>ax.set_ylabel('Y [ND]')<br/>ax.set_zlabel('Z [ND]')<br/><br/># Plotting Inertial Frame Positions<br/>ax.plot3D(X_Iner, Y_Iner, Z_Iner, c='green')<br/>ax.plot3D(X_m1, Y_m1, Z_m1, c='blue')<br/>ax.plot3D(X_m2, Y_m2, Z_m2, c='black')<br/><br/># Setting Axis Limits<br/>ax.set_xlim3d(XYZlim)<br/>ax.set_ylim3d(XYZlim)<br/>ax.set_zlim3d(XYZlim * 3 / 4)<br/>plt.show()</span></pre><p id="0984" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/eb8b06303fd0f846f85ba318e994ab93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*La5ccWq3EUcYS5cYvtf0Pg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">CR3BP轨道(旋转框架)[作者创作]</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/63ccfd570e38a994443cd023b383c15e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*x_MWPGW5Vq-6tfUW8SJoHw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">CR3BP轨道(惯性系)[作者创作]</p></figure><p id="1a26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的图显示了<strong class="kw iu"><em class="lw"/></strong>m₃和主要质量的轨道的惯性和旋转框架结果。如你所见，对于这组初始条件，飞船有一个混乱的轨道。如果调整初始条件，可以创造出各种不同的轨道(有些甚至是周期性的)。我鼓励你打乱初始条件，自己做实验。为了使文章和代码尽可能简短，我省略了如何根据情节制作动画。如果您有兴趣添加它，请查看下面的分步指南:</p><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/how-to-animate-plots-in-matlab-fa42cf994f3e"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何在MATLAB中制作动画</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">一种简单的数据动画制作方法</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ko oj"/></div></div></a></div></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="386d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读文章！这是对圆形受限三体以及如何对运动方程进行数值积分的简要概述。这是一个高级的轨道力学话题，所以学习起来可能会很有挑战性。如果你有任何问题，请随时联系这里或<a class="ae lq" href="https://www.linkedin.com/in/zachary-fizell-915532215/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>。请关注我关于轨道力学、编码和机器学习的每周文章！</p><p id="bc9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您觉得这篇文章很有趣，您可能也会觉得以下内容很有趣:</p><div class="og oh gp gr oi oj"><a href="https://medium.com/illumination/astrodynamics-two-body-problem-ec2c5e148184" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何解决两体问题</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">通过推导两体系统的运动方程，学习轨道力学的基础知识</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ko oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a rel="noopener follow" target="_blank" href="/use-python-to-create-two-body-orbits-a68aed78099c"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">使用Python创建两体轨道</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">了解如何使用Python来确定航天器在较大物体重力影响下的运动</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ko oj"/></div></div></a></div></div></div>    
</body>
</html>