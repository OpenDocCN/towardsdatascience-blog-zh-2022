<html>
<head>
<title>Moving code from Python to Julia: Beware of false friends</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将代码从Python移植到Julia:小心虚假的朋友</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/moving-code-from-python-to-julia-beware-of-false-friends-160573a5d552#2022-05-03">https://towardsdatascience.com/moving-code-from-python-to-julia-beware-of-false-friends-160573a5d552#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/73a842a43c4a87878c5fefbaef5d0e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3mltihs-Ds_e5N10VYwXhg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@bdchu614?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="d5d9" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">一般来说，将代码从Python转移到Julia是很容易的。但是有些陷阱你应该知道。</h2></div><h1 id="62af" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">虚假的朋友</h1><p id="f03c" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">学习外语时，你会遇到拼写和发音与母语中你所知道的单词相似的单词。但有时这些看似熟悉的词在另一种语言中却有着完全不同的含义。例如德语动词“<em class="mj"> bekommen </em>”看似等同于英语“t <em class="mj"> o成为</em>”，实际上是“t <em class="mj"> o获得</em>”或“t <em class="mj"> o接收</em>”。当说德语的人学习英语时，这有时会导致一些相当有趣的句子，比如“<em class="mj">她在11岁生日时变成了一只猫</em>”。当然这里的意图不是表达女孩在生日那天变异成了一只猫，而是她得到了一只猫作为生日礼物。这种看似相关的词就叫做“<em class="mj">假朋友</em>”。</p><p id="65e1" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">当您从一种您熟悉的编程语言切换到一种新的编程语言时，例如当您从Python切换到Julia时，也会出现同样的情况。这两种语言有一些概念上的差异，但也有一些方面非常相似，似乎可以互换——但实际上并不是所有的都可以互换！</p><h1 id="73ef" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">Python列表和Julia数组</h1><p id="5ece" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">最近，我在阅读René的文章《Julia和Python的黄金时间》时，遇到了一个很好的例子。他展示了一个计算质数的Python函数(最初来自<a class="ae jd" href="https://code.activestate.com/recipes/117119/" rel="noopener ugc nofollow" target="_blank">这里是</a>),将它1:1地翻译给Julia，做了一些基准测试，当注意到Julia实现的性能低于预期时有点失望(Python ca。7.5秒，朱莉娅·卡。4.5s；我在我的环境中重复了基准测试，分别得到了9.5 s和7.5 s)。</p><p id="277c" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">让我们看一下这段代码，看看发生了什么，可以做些什么来改善这种情况(<em class="mj">注</em>:对于进一步的分析，完全理解这段代码并不重要。我们只会对它的某些方面有更深入的了解；尤其是使用的数据结构。)</p><p id="86a4" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">首先是Python代码:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">上述文章中的原始Python代码</p></figure><p id="186b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这是对朱莉娅的翻译:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">上面引用的文章中的原始Julia代码</p></figure><p id="9d02" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><em class="mj">注</em>:茱莉亚版本有小错误。第15行中的<code class="fe mv mw mx my b">delete!</code>语句必须放在for循环之后，以便与Python代码相同。在本文中，已经使用了修正的版本来创建基准数字。</p><h2 id="3ae1" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">使用的数据结构(ab)</h2><p id="98f1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这些函数中使用的主要数据结构是</p><ul class=""><li id="7079" class="nl nm jg lp b lq mk lt ml lw nn ma no me np mi nq nr ns nt bi translated">在Python中:一个<em class="mj">字典</em>中的<code class="fe mv mw mx my b">D</code>列出了</li><li id="5344" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">在Julia中:一个<em class="mj">字典</em> <code class="fe mv mw mx my b">D</code>中的<em class="mj">数组</em> <br/>(或者更确切地说是<code class="fe mv mw mx my b">Vector</code> s，它是一维数组的同义词)。</li></ul><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/d96f736126217550a259c21e530d3988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dW__6Fr7BYKw_gx218iR8Q.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">上面代码中使用的数组字典D[图片由作者提供]</p></figure><p id="4195" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">分析(Julia-)代码，我们看到，这个字典<code class="fe mv mw mx my b">D</code>最初是空的，它的槽被递增地填充，或者通过分配一个具有一个元素的数组(第8行)，分配一个空数组(第13行)，或者通过使用<code class="fe mv mw mx my b">push!</code>(第9行和第14行)向这些数组添加单个数字(如果它们已经存在)。如上图中的例子所示，在函数执行过程中，大多数数组只包含一个元素。随着时间的推移，一些数组不再需要并被删除(第15行)。</p><p id="e2da" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">所以基本上，下面的“翻译”步骤已经完成:在Julia版本中，数组已经被用作Python列表的“替代物”。这两种数据结构在几个方面非常相似，如示例所示，甚至可以或多或少以相同的方式使用。</p><p id="c6fc" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">但是:Python列表被设计成动态的数据结构，可以在生命周期中以很小的增量增长和收缩。用Julia数组也可以这样做，但是不应该这样做！Julia数组(正如它们的名字已经告诉我们的那样)不是列表，而是数组，传统上是静态的<em class="mj">结构。所以它们的设计有着不同的目的。</em></p><p id="dc58" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">以上面例子中的方式使用Julia数组是最低效的使用方式之一。Julias <code class="fe mv mw mx my b">@time</code>宏显示，在超过6500万次单独的分配调用中，<code class="fe mv mw mx my b">n</code> = 1，000，000的函数调用分配了大约4 GB的内存。那不可能有效率！</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="f951" class="mz kw jg my b gy oe of l og oh">7.532386 seconds (65.79 M allocations: 3.933 GiB, 19.15% gc time)</span></pre><h2 id="45aa" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">丰富</h2><p id="f227" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们深入了解一些细节，看看在第13 &amp; 14行中发生了什么，以展示这些用于创建和增长数据结构的微小步骤对性能的影响有多大:</p><ul class=""><li id="27ee" class="nl nm jg lp b lq mk lt ml lw nn ma no me np mi nq nr ns nt bi translated">在第13行中，函数<code class="fe mv mw mx my b">get!</code>被调用仅仅是因为它的副作用:如果插槽<code class="fe mv mw mx my b">p+q</code>为空，开发人员想要在插槽<code class="fe mv mw mx my b">D</code>处为字典<code class="fe mv mw mx my b">D</code>分配一个空数组，或者如果已经有一个数组，则什么也不做。<br/><code class="fe mv mw mx my b">get!</code>的实际用途是读取特定槽位的值。</li><li id="9507" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">这样做是为了在第14行将值<code class="fe mv mw mx my b">p</code>追加到数组中。即第13行保证了在任何情况下该位置都存在一个数组。</li></ul><p id="83a2" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我们可以用下面的代码替换这两行，这样可以更清楚地表达这些意图:</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="2f82" class="mz kw jg my b gy oe of l og oh">if haskey(D, p+q)<br/>    push!(D[p+q], p)   # append `p` to the array, if there is one<br/>else<br/>    D[p+q] = [p]       # assign a new array `[p]`, if there is none<br/>end</span></pre><p id="3f56" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因此，如果<code class="fe mv mw mx my b">p+q</code>处的槽为空(即<code class="fe mv mw mx my b">else</code>部分)，则在<em class="mj">一个</em>步骤中分配一个包含<code class="fe mv mw mx my b">p</code>的新数组，而不是原始代码中的<em class="mj">两个</em>。</p><p id="e9fe" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个小小的改变，用一个(稍微大一点的)步骤代替了两个小步骤，减少了大约43%的运行时间和50%的内存分配！</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="f000" class="mz kw jg my b gy oe of l og oh">4.242410 seconds (26.15 M allocations: 2.047 GiB, 13.62% gc time)</span></pre><p id="dbb9" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">除此之外，仅仅为了副作用而使用函数(如第13行)无论如何都是不好的做法，因为它隐藏了真正的意图。这使得代码更难阅读和理解。此外，如果没有清楚地表达出来，编译器应该如何理解真正的含义(并生成最佳代码)？</p><h1 id="1bf8" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">移动算法，而不是代码</h1><p id="8175" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">但这不是你应该改进代码的方式。决定性的一点是，Python代码不应该被逐行翻译(这将导致一些类似Python的Julia代码)，而是算法作为一个整体应该以Julian的方式来考虑和实现。</p><blockquote class="oi"><p id="613a" class="oj ok jg bd ol om on oo op oq or mi dk translated">算法，而不是代码，应该从一种语言转移到另一种语言。</p></blockquote><h2 id="b856" class="mz kw jg bd kx na os dn lb nc ot dp lf lw ou nf lh ma ov nh lj me ow nj ll nk bi translated">厄拉多塞筛</h2><p id="b400" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">让我们这样做:上面使用的算法是著名的厄拉多塞的<a class="ae jd" href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="noopener ugc nofollow" target="_blank">筛子。是的，如果你想知道，上面的代码是“筛子”的一个相当特殊的实现。</a></p><p id="3dbe" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">计算1到<em class="mj"> n </em>范围内素数的厄拉多塞筛的主要思想如下:</p><ul class=""><li id="e9e3" class="nl nm jg lp b lq mk lt ml lw nn ma no me np mi nq nr ns nt bi translated">列出从1到n的所有数字。</li><li id="2d39" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">最初我们假设所有这些数字都是质数。我们可以省略1，因为根据定义，2是最小的素数。</li><li id="dbd2" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">丢弃所有已经识别的素数的倍数的数:<br/> -丢弃所有2的倍数<br/> -丢弃所有3的倍数<br/> -省略4，因为它已经被识别为2的倍数<br/> -丢弃所有5的倍数…等等。</li><li id="9a89" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">当我们到达<code class="fe mv mw mx my b">sqrt(n)</code>时，我们可以停止这个过程，因为此时我们已经检查了所有大于该阈值的倍数。例如，对于<em class="mj"> n </em> = 100(此阈值为10)，我们不必检查11的倍数，因为我们在检查2的倍数时已经检查了2 x 11，在检查3的倍数时已经检查了3 x 11，等等。</li><li id="a566" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">当检查一个数<em class="mj"> k </em>的倍数时，我们不必从1 x <em class="mj"> k </em>开始。从<em class="mj"> k </em> x <em class="mj"> k </em>开始就足够了，因为已经检查了所有较低的倍数。例如，当检查5的倍数时，我们可以从25开始，因为2 x 5、3 x 5和4 x 5已经在之前的过程中检查过了。</li></ul><p id="5740" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><em class="mj">注</em>:本说明中的参数<em class="mj"> n </em>与上述代码中的含义不同。这里它表示素数搜索范围的上限。在上面的实现中，<em class="mj"> n </em>是将被识别的素数的数量。所以用<em class="mj"> n </em> = 1，000，000产生一百万个质数。在接下来的部分中，我们将实现一个函数<code class="fe mv mw mx my b">fastPrimes</code>，它遵循这里给出的算法的“经典”版本，其中<em class="mj"> n </em>是上限。为了用<code class="fe mv mw mx my b">fastPrimes</code>得到与上面代码相同的结果，我们必须用<em class="mj"> n </em> = 15，495，863来调用它，因为这是前一百万个素数中最大的一个。</p><h2 id="40f6" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">在Julia中实现</h2><p id="e5dc" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">实现“筛子”算法的基础是一个适当的数据结构。一个直接反映一串数字的概念连同信息“<em class="mj">的结构是质数？</em>"是一个布尔值数组。如果我们希望实现也是内存高效的，那么我们选择一个<code class="fe mv mw mx my b">BitArray</code>。这是一个布尔数组的变体，它只使用一位内存存储每个布尔。</p><p id="e44a" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这种考虑和上面的算法描述直接导致了下面的代码:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><ul class=""><li id="b493" class="nl nm jg lp b lq mk lt ml lw nn ma no me np mi nq nr ns nt bi translated">在第2行中，我们创建了一个具有<em class="mj"> n </em>个元素的<code class="fe mv mw mx my b">BitArray</code>(所有元素都设置为<em class="mj">真)</em>和<em class="mj"> </em>，我们省略了1(第3行)。</li><li id="16ef" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">从第4行开始的for循环检查从2到<code class="fe mv mw mx my b">sqrt(n)</code>的所有倍数。</li><li id="514c" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">已经被标记为不是质数的数字被省略(第5行)。</li><li id="0a5b" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">从第6行开始的for循环遍历从<em class="mj"> i x i </em>开始的所有<em class="mj"> i </em>的倍数，并将它们标记为非质数。</li><li id="c5be" class="nl nm jg lp b lq nu lt nv lw nw ma nx me ny mi nq nr ns nt bi translated">就是这样！第10行的语句只是用来将所有质数都标有<em class="mj"> true </em>的<code class="fe mv mw mx my b">BitArray</code>转换成一个质数数组。</li></ul><p id="d6f1" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这个函数的运行时间大约是76 ms，并且它只使用大约11 MB的内存，正如<code class="fe mv mw mx my b">BenchmarkTools</code>包的结果所示。与最初的实现相比，使用不到0.3%的内存，速度快了近100倍。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ox"><img src="../Images/d1903dc56b3fa9586e38eb1517efd037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEVqycr4IM5va7zSwbsSkA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">“fastPrimes”的基准测试结果[图片由作者提供]</p></figure><h2 id="4527" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">用Python实现</h2><p id="23c1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这种方法当然也导致了Python中更好的数字。代码如下:</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aabb" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">由于Python中数组的索引从0开始，我们在这里创建一个大小为<em class="mj"> n+1 </em>的数组，并忽略索引0处的元素。</p><p id="4918" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">这段代码使用与Julia示例中相同的参数化运行了大约2.5 s。所以比原代码快了差不多4倍。不幸的是，用于进行基准测试的Python <code class="fe mv mw mx my b">timeit</code>模块并没有产生关于所分配内存的信息。</p><h2 id="cbdd" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">结果</h2><p id="b604" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">下图总结了本文介绍的不同变体的性能，并再次显示了正确使用Julia可以获得哪些出色的结果。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oy"><img src="../Images/b4be8c6fa503f8d2febe957b01e6b468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUtoYxxE5n2NIp0cjL8Z3g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">不同变体的性能[图片由作者提供]</p></figure><p id="45a8" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">基准测试使用了以下环境:苹果M1，8 GB内存，Julia 1.7.1，Python 3.9.7。</p><p id="2de9" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">对于Julia变体，我们还可以看到与分配的内存相关的性能。这两项措施都有可能取得重大进展。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oy"><img src="../Images/6974a50585a257b13c20f75b073a41c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJ28I4ULsFHEWciu7FyiAQ.png"/></div></div></figure><h1 id="81fe" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">旁注</h1><p id="c6bf" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Julia相对于Python的主要优势是性能和奇特的概念，比如多重调度。但是我认为还有更多:它也是关于日常使用中更重要的实际的东西，比如简单性、一致性和运行良好的包管理器。</p><p id="c978" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">当我准备这篇文章时，我再次被这些问题绊倒。几年前促使我寻找Python替代品的问题，为什么我想与你分享它们。</p><h2 id="d581" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">朱莉娅</h2><p id="a49f" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在Julia中可以使用<code class="fe mv mw mx my b">@time</code>宏对函数进行计时，该宏包含在基本库中，如下所示:</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="ff58" class="mz kw jg my b gy oe of l og oh">@time fastPrimes(100)</span></pre><p id="bf9f" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">使用相同的模式，您可以通过详细版本<code class="fe mv mw mx my b">@timev</code>获得更多的信息:</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="ebf2" class="mz kw jg my b gy oe of l og oh">@timev fastPrimes(100)</span></pre><p id="45e1" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">如果您想要“真正的”基准测试，自动进行几次迭代并获得一些有用的统计数据等。，可以使用<code class="fe mv mw mx my b">BenchmarkTools</code>包。因为它是第三方软件包，所以必须先安装。因此我切换到包模式，输入<code class="fe mv mw mx my b">add BenchmarkTools</code>，包管理器在不到一分钟的时间内下载、安装并预编译了这个包。Julia有一个<em class="mj">包管理器，它是根据该语言设计和开发的。</em></p><p id="a23b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">进入<code class="fe mv mw mx my b">using BenchmarkTools</code>后，可以使用该包的功能。它和上面的宏有着相同的使用模式(尽管是完全不同的包，由不同的人开发)。你称之为:</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="9bff" class="mz kw jg my b gy oe of l og oh">@benchmark fastPrimes(100)</span></pre><h2 id="79dc" class="mz kw jg bd kx na nb dn lb nc nd dp lf lw ne nf lh ma ng nh lj me ni nj ll nk bi translated">计算机编程语言</h2><p id="1791" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在Python中，您可以利用来自同名模块的<code class="fe mv mw mx my b">timeit</code>-方法。它也包含在基本库中。为了给<code class="fe mv mw mx my b">fastPrimes</code>函数计时，我不得不使用下面的表达式:</p><pre class="mp mq mr ms gt oa my ob oc aw od bi"><span id="e8a8" class="mz kw jg my b gy oe of l og oh">timeit.Timer(‘fastPrimes(100)’, setup=’from __main__ import fastPrimes; gc.enable()’).timeit(number = 1)</span></pre><p id="d19b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated"><code class="fe mv mw mx my b">from __main__ import</code>是必要的，这样<code class="fe mv mw mx my b">timeit</code>就可以“看到”<code class="fe mv mw mx my b">fastPrimes</code>功能。<code class="fe mv mw mx my b">gc.enable()</code>打开垃圾收集器，因为<code class="fe mv mw mx my b">timeit</code>在默认情况下关闭它，这既不是真实情况，也不能与Julia设置相比。</p><p id="447b" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">不，这既不容易理解也不容易使用。我花了很长时间才弄明白如何正确使用<code class="fe mv mw mx my b">timeit</code>！</p><p id="5046" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">由于<code class="fe mv mw mx my b">timeit</code>只测量运行时间，但不给出关于内存分配的信息(像Julia工具那样)，我在寻找一个更好的替代方法。网上不同地方提到的另外两个Python基准测试函数不符合这些要求。但是第三个模块<code class="fe mv mw mx my b">benchmarkit</code>似乎做到了。所以我试着安装了它。Python有<em class="mj">两个</em>包管理器(PIP和Conda)；两者都是独立于语言开发的。</p><p id="ce06" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">因为我的计算机上有一个Anaconda环境，所以我首先尝试用<code class="fe mv mw mx my b">conda</code>进行安装。但是在康达宇宙中<code class="fe mv mw mx my b">benchmarkit</code>模块是未知的。所以我切换到<code class="fe mv mw mx my b">pip</code>，它开始在我的电脑上加载兆字节的软件。几分钟后，它通知我它现在将安装<code class="fe mv mw mx my b">pandas</code>模块，这让我很恼火，因为那个模块已经安装好了。时间一分一秒地过去了……然后几十条错误信息淹没了我的屏幕。此后，它报告说在我的电脑上发现了一个<code class="fe mv mw mx my b">pandas</code>安装，这让我的心情有所好转。大约15分钟后(使用M1 iMac和100 MBit/s的互联网连接！)一切似乎都准备好了。所以我输入了<code class="fe mv mw mx my b">import benchmarkit</code> …导致一条消息告诉我，这个模块没有安装。也就是说，在摆弄了这么长时间之后，我除了一个可能更乱的Python装置之外一无所有！</p><p id="b00e" class="pw-post-body-paragraph ln lo jg lp b lq mk kh ls lt ml kk lv lw mm ly lz ma mn mc md me mo mg mh mi ij bi translated">我想我不必提及使用<code class="fe mv mw mx my b">benchmarkit</code>的基准测试将遵循与使用<code class="fe mv mw mx my b">timeit</code>完全不同的模式。</p></div></div>    
</body>
</html>