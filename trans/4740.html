<html>
<head>
<title>Importing Objects from a Python Module Can Be Risky</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Python模块导入对象可能有风险</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/importing-objects-from-a-python-module-can-be-risky-59dac696c51f#2022-10-21">https://towardsdatascience.com/importing-objects-from-a-python-module-can-be-risky-59dac696c51f#2022-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c9ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您是否知道在导入原始对象后，您是否会处理它们？或许用他们的复制品？也许有些是原创，有些是复制品？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33c19bcc9500e5256af3734be6789461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_BqnIzzNvdK13QCt2rdnJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">哪匹马是原作，哪匹是复制品？太难说了！来源:图片由作者提供。</p></figure><p id="fb6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该导入模块(<code class="fe lu lv lw lx b">import module</code>)还是从模块(<code class="fe lu lv lw lx b">from module import obj1, obj2</code>)导入对象并不是一个新问题。在这篇文章中，我不打算重新发明轮子。我们知道导入一个模块有更多的优点，但是在某些情况下，直接从一个模块导入对象也很好；可以让一个app快一点，代码可以短一点。如果你想更多地了解这个话题，马克·卢茨的书(Lutz 2013)提供了很好的阅读材料。</p><p id="fd22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于进口，有一个事实很容易忘记。这两个方法<em class="ly">中的一个不从另一个模块导入</em> <em class="ly">对象</em>，而是由<em class="ly">创建它们的副本</em>。虽然通常这不会造成很大的差别，但有时会，而且差别会很大。</p><p id="68d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我比较了从模块中复制对象和导入对象。我将展示<em class="ly">导入一个模块</em>相对于<em class="ly">从一个模块</em>导入对象的一个优点，这个优点有时可以省去你很多麻烦。</p><h1 id="0575" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">导入模块:原始对象的作用</h1><p id="7502" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">假设我们有一个由三个模块组成的应用程序:</p><ul class=""><li id="6ede" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated"><code class="fe lu lv lw lx b">helpers</code>，包含主应用中使用的变量和函数；</li><li id="d888" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><code class="fe lu lv lw lx b">action</code>，包含应用的主要功能；</li><li id="efee" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><code class="fe lu lv lw lx b">__main__</code>，负责运行应用程序。</li></ul><p id="237b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是<code class="fe lu lv lw lx b">helpers</code>的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bbe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我尽可能让它简单。现在<code class="fe lu lv lw lx b">action</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="222b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，<code class="fe lu lv lw lx b">run_app()</code>是应用程序的主要功能。它将在负责运行应用程序的<code class="fe lu lv lw lx b">__main__ </code>模块中被调用。当然，在我们的例子中，<code class="fe lu lv lw lx b">__main__</code>也过于简化了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3b27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这符合预期。当我们导入<code class="fe lu lv lw lx b">helpers</code>模块时，我们可以使用它的<code class="fe lu lv lw lx b">foo()</code>函数和<code class="fe lu lv lw lx b">helpers_value</code>全局变量。注意<code class="fe lu lv lw lx b">helpers_value</code>不是大写，因为它不是常数；它只是一个全局变量。这里，“全局”是指模块的全局；但这是意料之中的:这就是Python中范围的工作方式(Lutz 2013，拉马尔霍2022)。然后，我们改变<code class="fe lu lv lw lx b">helpers.helpers_value</code>和<code class="fe lu lv lw lx b">helpers.foo</code>，这个改变反映在原来的位置，也就是在<code class="fe lu lv lw lx b">helpers</code>里。我们可以通过调用<code class="fe lu lv lw lx b">action.run_app()</code>看到这一点，这个函数调用<code class="fe lu lv lw lx b">helpers.helpers_value</code>和<code class="fe lu lv lw lx b">helpers.foo</code>。</p><h1 id="7df1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">从模块导入:实际复制</h1><p id="982c" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">现在，让我们改变在<code class="fe lu lv lw lx b">__main__</code>中导入<code class="fe lu lv lw lx b">helpers</code>对象的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8e19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那是相当不同的！发生了什么事？</p><p id="3599" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们更改了<code class="fe lu lv lw lx b">helpers_value</code>和<code class="fe lu lv lw lx b">foo</code>，但这并不影响位于<code class="fe lu lv lw lx b">helpers</code>的原始对象。这是因为<code class="fe lu lv lw lx b">import from</code>创建了导入对象的副本。这一点至关重要，所以让我强调一下:</p><blockquote class="nm"><p id="5875" class="nn no it bd np nq nr ns nt nu nv lt dk translated"><code class="fe lu lv lw lx b">import from</code>创建导入对象的副本。</p></blockquote><p id="e9b0" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">因此，虽然我们对<code class="fe lu lv lw lx b">helpers_value</code>和<code class="fe lu lv lw lx b">foo()</code>的更改影响了这些副本，但它们不影响来自<code class="fe lu lv lw lx b">helpers</code>模块的原始值。<code class="fe lu lv lw lx b">action.run_app()</code>功能不使用这些副本；它使用来自<code class="fe lu lv lw lx b">helpers</code>的原始对象，这就是为什么我们在两种情况下观察到不同的行为。</p><h1 id="7bd7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated"><strong class="ak"> <em class="ob">这是什么意思？</em>T25】</strong></h1><p id="7316" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">这意味着很多，也改变了很多。幸运的是，在大多数情况下，这些都不重要，因为我们很少在一个模块中改变另一个模块中的对象。然而，有时我们会，然后我们必须小心。</p><p id="0c14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使事情变得更加复杂，我们需要考虑两种情况:从模块中导入不可变对象和导入可变对象。</p><h2 id="480c" class="oc ma it bd mb od oe dn mf of og dp mj lh oh oi ml ll oj ok mn lp ol om mp on bi translated">不可变对象</h2><p id="507a" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">当您从一个模块中导入一个不可变的对象时，就像在<code class="fe lu lv lw lx b">from helpers import helpers_value</code>中一样，创建了该对象的一个副本。因此，您的全局名称空间现在将包含两个名为<code class="fe lu lv lw lx b">helpers_value</code> : <code class="fe lu lv lw lx b">helpers.helpers_value</code>和<code class="fe lu lv lw lx b">__main__.helpers_value</code>的对象。你预料到会发生这种事吗？</p><p id="474f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同理，<code class="fe lu lv lw lx b">foo()</code>功能也没有在原地改动:导入后有两个<code class="fe lu lv lw lx b">foo()</code>功能:<code class="fe lu lv lw lx b">helpers.foo()</code>和<code class="fe lu lv lw lx b">__main__.foo()</code>。</p><p id="44a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当我们导入一个模块(<code class="fe lu lv lw lx b">import helpers</code>)时，我们直接从模块中使用原始的(不可变的)对象；当它们改变时，我们使用改变的对象。</p><p id="1160" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，当我们直接从一个模块(<code class="fe lu lv lw lx b">from helpers import foo, helpers_value</code>)导入不可变对象时，Python会制作它们的副本，我们使用这些副本——而不是原始对象。因此，当原始对象在模块中改变时，这不会影响我们正在使用的对象——因为我们正在使用它们的副本。</p><h2 id="7ff9" class="oc ma it bd mb od oe dn mf of og dp mj lh oh oi ml ll oj ok mn lp ol om mp on bi translated">可变对象</h2><p id="9347" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">可变对象不能被复制，对其原始对象的任何更改或所谓的副本都是对原始对象进行的。这是因为Python不会创建可变对象的副本；相反，会创建一个引用原始对象的新名称。</p><p id="3350" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可变对象的这个特性影响了导入的工作方式。</p><p id="8706" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们简化我们的应用程序。现在它将只包含一个对象，一个字典，这是一个可变的Python对象。所以，<code class="fe lu lv lw lx b">helpers</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8662" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">action</code>模块包含<code class="fe lu lv lw lx b">run_app()</code>函数，它现在简单地返回<code class="fe lu lv lw lx b">helpers_value</code>字典:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ce1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是<code class="fe lu lv lw lx b">__main__</code>模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="87b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你看到发生了什么吗？这一次，虽然我们从<code class="fe lu lv lw lx b">helpers</code>导入了<code class="fe lu lv lw lx b">helpers_value</code>，但是我们得到了一个不同的结果:原来的对象被就地改变了。</p><p id="08d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是可变对象的典型行为。Python不会创建它们的副本；相反，它会创建指向同一对象的不同名称。因此，更改分配给这些名称中任何一个的对象的值都会产生相同的效果:原始对象会受到影响。</p><h1 id="cd69" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">合并导入</h1><p id="ea03" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">结合这两种类型的导入不会改变任何事情。不可变对象的行为类似于不可变对象，可变对象的行为类似于可变对象。让我们看看它是如何工作的。你可以把它当作一次练习。</p><p id="f43d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一次，我们将只使用两个模块，<code class="fe lu lv lw lx b">helpers</code>和<code class="fe lu lv lw lx b">__main__</code>。前者将定义两个对象，一个不可变，一个可变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="29b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">__main__</code>中，我们将以两种方式导入它们，然后改变对象。在继续之前，尝试猜测下面代码片段的输出。在每个<code class="fe lu lv lw lx b">print()</code>之后，我在你应该猜测输出的地方添加了引号。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d141" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是输出结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0518" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你没弄错。理解导入对象和模块的这个方面将帮助您避免当您的应用程序包含几个具有某种依赖层次结构的模块时可能发生的奇怪错误(例如，<code class="fe lu lv lw lx b">module1</code>导入<code class="fe lu lv lw lx b">module2</code>，后者导入<code class="fe lu lv lw lx b">module3</code>)。</p><h1 id="1a49" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">摘要</h1><p id="cd07" class="pw-post-body-paragraph ky kz it la b lb mr ju ld le ms jx lg lh mt lj lk ll mu ln lo lp mv lr ls lt im bi translated">正如我上面提到的，理解Python导入的这些复杂性应该有助于您在由几个模块组成的应用程序中避免错误。请记住:</p><ul class=""><li id="572f" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated"><code class="fe lu lv lw lx b">import module</code>使您能够将该模块中的对象用作<code class="fe lu lv lw lx b">module.obj</code>。这意味着你使用<em class="ly">原始对象</em>，位于<code class="fe lu lv lw lx b">module</code>的那个。因此，对这个对象的任何更改，在代码中的任何地方作为<code class="fe lu lv lw lx b">module.obj = …</code>完成，都将反映在对<code class="fe lu lv lw lx b">module.obj</code>的调用中。</li><li id="e3e9" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">在<em class="ly">不可变对象</em>的情况下，<code class="fe lu lv lw lx b">from module import obj</code>创建对象的副本。这意味着该副本位于模块范围内(在您导入<code class="fe lu lv lw lx b">obj</code>的模块中)。改变这个副本的值(即<code class="fe lu lv lw lx b">obj</code>)不会影响原对象(<code class="fe lu lv lw lx b">module.obj</code>)。</li><li id="18af" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">在<em class="ly">可变对象</em>的情况下，<code class="fe lu lv lw lx b">from module import obj</code>仅创建对象的新名称。因此，改变它的值(即<code class="fe lu lv lw lx b">obj = …</code>)会影响原来的对象(<code class="fe lu lv lw lx b">module.obj</code>)。</li><li id="6da8" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">因此，导入模块(<code class="fe lu lv lw lx b">import module</code>)而不是从中导入对象(<code class="fe lu lv lw lx b">from module import obj</code>)更安全。这是因为您总是在直接位于模块中的对象上工作，而不会创建它们的副本。因此，跟踪原始对象(位于<code class="fe lu lv lw lx b">module</code>的对象)发生的事情就足够了，无论其他各种模块对这个对象做什么，它们都会对原始对象这样做。当你需要创建一个副本时，你可以在你需要的地方显式地做。</li></ul><p id="eec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一点也许是最关键的。当你确实需要一个副本时，创建它，但是在你需要这个副本的地方明确地做它。通过特定的导入方式来创建副本，肯定是隐性的、间接的、不明确的。初学者甚至一些中级python爱好者可能会忘记，或者根本不知道，<code class="fe lu lv lw lx b">from module import obj</code>创建了<code class="fe lu lv lw lx b">module.obj</code>的副本或新名称，并且<code class="fe lu lv lw lx b">__main__</code>模块的作用域现在包含两个对象:</p><ul class=""><li id="1434" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">在不可变对象的情况下，<code class="fe lu lv lw lx b">module.obj</code>和<code class="fe lu lv lw lx b">obj</code>对象；</li><li id="cfb0" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">在可变对象的情况下，它实际上是一个有两个名字的对象:<code class="fe lu lv lw lx b">module.obj</code>和<code class="fe lu lv lw lx b">obj.</code></li></ul><p id="3e20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，当您在一个模块中更改另一个模块中的对象时，所有这些都很重要。那你一定要小心，这是我们讨论的所有这些事情都可能发生的时候。</p><p id="2428" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为通过导入来避免创建对象副本的混乱要好得多。这就是为什么，至少在这种情况下，导入一个模块比从它导入对象更安全。</p><h1 id="f77c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">资源</h1><ul class=""><li id="5a64" class="mw mx it la b lb mr le ms lh oo ll op lp oq lt nb nc nd ne bi translated">Lutz M. (2013年)。<em class="ly">学习Python </em>。第五版。奥莱利媒体。</li><li id="8f7f" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">拉马尔霍湖(2022年)。<em class="ly">流畅的Python。清晰、简洁、有效的编程</em>。第二。版本。奥赖利。</li></ul></div></div>    
</body>
</html>