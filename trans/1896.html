<html>
<head>
<title>Git for Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学Git</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/git-for-data-science-36f092d2bdd#2022-05-02">https://towardsdatascience.com/git-for-data-science-36f092d2bdd#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f8d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每个数据科学家应该了解的关于Git的知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6ea2c7aaca713ebade7c1987976c3de2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9Q1ZKFbdcLTQzs3909XOw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="ded8" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Git是什么？</h1><p id="121c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Git是一个版本控制系统，旨在跟踪源代码随时间的变化。</p><p id="34c6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当许多人在没有版本控制系统的情况下从事同一个项目时，这是完全混乱的。解决最终的冲突变得不可能，因为没有人跟踪它们的变化，很难将它们合并成一个单一的中心事实。Git和构建在它之上的更高级别的服务(比如Github)提供了克服这个问题的工具。</p><p id="b647" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">通常，有一个单独的中央存储库(称为“源”或“远程”)，单个用户将把它克隆到他们的本地机器上(称为“本地”或“克隆”)。一旦用户保存了有意义的工作(称为“提交”)，他们将把它发送回中央存储库(“推送”和“合并”)。</p><h1 id="f8ef" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Git和GitHub有什么区别？</h1><p id="1da6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Git是一种底层技术，它的命令行客户端(CLI)用于跟踪和合并源代码中的变更。</p><p id="2b99" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">GitHub是一个建立在git技术之上的web平台，目的是让它变得更简单。它还提供了额外的功能，如用户管理，拉请求，自动化。其他的选择有GitLab和Sourcetree。</p><h1 id="3ecd" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">术语</h1><ul class=""><li id="a706" class="mo mp iq lp b lq lr lt lu lw mq ma mr me ms mi mt mu mv mw bi translated"><strong class="lp ir">存储库</strong>“数据库”的所有分支和单个项目的提交</li><li id="a9ce" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">分支</strong>存储库的可选状态或开发路线。</li><li id="1fb5" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">合并</strong>将两个(或更多)分支合并成一个分支，单个真理。</li><li id="041b" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">克隆</strong>创建远程仓库的本地副本。</li><li id="f820" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir"> Origin </strong>创建本地克隆的远程存储库的通用别名</li><li id="d5b9" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">主</strong> / <strong class="lp ir">主</strong>俗名为根分支，是真理的中心来源。</li><li id="2b32" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir"> Stage </strong>选择哪些文件将成为新提交的一部分</li><li id="316e" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">提交</strong>对存储库中的文件所做的阶段性更改的已保存快照。</li><li id="43dd" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">当前提交的简写你的本地存储库当前所在的位置。</li><li id="0523" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated">推送推送意味着将您的更改发送到远程存储库，让每个人都能看到</li><li id="446c" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">拉</strong>拉意味着把其他人的变更放到你的本地存储库中</li><li id="c9f9" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi mt mu mv mw bi translated"><strong class="lp ir">拉请求</strong>机制审核&amp;批准您的更改，然后合并到主/主控</li></ul><h1 id="a9e8" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不要推送数据集</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/49fb88d212ca2bc1676e22bee0147b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*e1qoY15qJfI47we5.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="ebcf" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Git是一个版本控制系统，旨在为软件开发者服务。它有很好的工具来处理源代码和其他相关内容，如配置、依赖项和文档。它不是用于训练数据的。句号。Git仅用于代码。</p><p id="16f2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在软件开发中，代码为王，其他一切都为代码服务。在数据科学中，情况不再如此，数据和代码之间存在二元性。代码依赖数据没有任何意义，正如数据依赖代码没有任何意义一样。它们应该分离，这就是以代码为中心的软件开发模型让你失望的地方。<strong class="lp ir"> Git不应该是数据科学项目的核心要点。</strong></p><p id="4c71" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">像LFS这样的扩展引用了git存储库中的外部数据集。虽然它们服务于一个目的并且解决了一些技术限制(大小、速度)，但是它们没有解决根植于git的以代码为中心的软件开发思维的核心问题。</p><p id="a5b3" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">尽管如此，您的本地目录中总会有数据集浮动。如果你不小心，很容易不小心上演和犯下这些错误。确保使用git不需要担心数据集的正确方法是使用<code class="fe nd ne nf ng b">.gitignore</code>配置文件。将您的数据集或数据文件夹添加到配置中，永远不要回头看。</p><p id="e47d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">示例:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="5f0c" class="nl kw iq ng b gy nm nn l no np"># ignore archives<br/>*.zip<br/>*.tar<br/>*.tar.gz<br/>*.rar<br/><br/># ignore dataset folder and subfolders<br/>datasets/</span></pre><h1 id="8eb9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不要泄露秘密</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4394531fe0f871fd9fb69cbf7cdc0961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*9ux8xLTM3yVIEzmL.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b004" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这应该是显而易见的，然而现实世界中不断出现的错误向我们证明事实并非如此。存储库是否是私有的也没有关系。在任何情况下，任何人都不应该将任何用户名、密码、API令牌、密钥代码、TLS证书或任何其他敏感数据提交给git。</p><p id="4a7f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">甚至私有存储库也可以被多个帐户访问，并且被克隆到多个本地机器上。这给了假想攻击者指数级更多的目标。请记住，私有存储库也可能在某个时候变成公共的。</p><p id="8eff" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">将您的秘密从代码中分离出来，并使用环境来传递它们。对于Python，您可以使用保存环境变量的通用<code class="fe nd ne nf ng b">.env</code>文件，以及确保<code class="fe nd ne nf ng b">.env</code>文件不会被推送到远程git存储库的<code class="fe nd ne nf ng b">.gitignore</code>文件。还提供<code class="fe nd ne nf ng b">.env.template</code>是个好主意，这样其他人就知道系统期望什么样的环境变量。</p><p id="7165" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">。环境</strong></p><p id="b259" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nd ne nf ng b">API_TOKEN=98789fsda789a89sdafsa9f87sda98f7sda89f7</code></p><p id="b6b0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir"> .env.template </strong></p><p id="9061" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nd ne nf ng b">API_TOKEN=</code></p><p id="12ba" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">。gitignore </strong></p><p id="4184" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nd ne nf ng b">.env</code></p><p id="7e98" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir"> hello.py </strong></p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="9cfc" class="nl kw iq ng b gy nm nn l no np">from dotenv import load_dotenv<br/>load_dotenv()<br/>api_token = os.getenv('API_TOKEN')</span></pre><p id="90db" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对于第一次克隆存储库的人来说，这仍然需要一些手动的复制粘贴。对于更高级的设置，有加密的、访问受限的工具可以通过环境共享机密，例如Vault。</p><p id="fd6d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">注意:如果您已经将您的秘密推送到远程存储库，不要试图通过简单地删除它们来修复这种情况。为时已晚，因为git被设计成不可变的。一旦秘密泄露，唯一有效的策略就是更改密码或禁用令牌。</p><h1 id="1982" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不要推动笔记本输出</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/b27a56c4cd912a5f2de0a960a8a86058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/0*6HylWVv6IvLXpUMO.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2d58" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">笔记本很酷，因为它们不仅能让你存储代码，还能存储图像、图表和表格等单元格输出。当您提交并将笔记本及其输出推送到git时，问题就出现了。</p><p id="fe3c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">笔记本序列化所有图像、图表和表格的方式并不美观。它不是单独的文件，而是将所有东西都编码成JSON乱码，放入<code class="fe nd ne nf ng b">.ipynb</code>文件中。这让git很困惑。</p><p id="a6ae" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Git认为JSON的胡言乱语和你的代码一样重要。您更改的三行代码与JSON乱码中更改的三千行代码混在一起。由于额外的噪音，试图比较这两个版本变得毫无意义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f7091b15f6641811972c851402425959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wn-rNhLFn36eN_ne.png"/></div></div></figure><p id="1345" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">如果在生成输出后更改了一些代码，情况会变得更加混乱。现在，存储在版本控制中的代码和输出不再匹配。</p><p id="7adc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">你有两种选择。</p><ol class=""><li id="d025" class="mo mp iq lp b lq mj lt mk lw nt ma nu me nv mi nw mu mv mw bi translated">在创建git提交之前，您可以从主菜单中手动清除输出(单元格-&gt;所有输出-&gt;清除)。</li><li id="0ab5" class="mo mp iq lp b lq mx lt my lw mz ma na me nb mi nw mu mv mw bi translated">您可以为git设置一个自动清除输出的<a class="ae nx" href="https://zhauniarovich.com/post/2020/2020-06-clearing-jupyter-output/" rel="noopener ugc nofollow" target="_blank">预提交挂钩</a></li></ol><p id="e1b8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们强烈建议投资选项2，因为你需要记住的手动步骤最终注定会失败。</p><h1 id="223b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不要使用—力</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4b8ff790dad6c076fc81e58472302db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/0*T0E90g061em0vQ4y.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9d25" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">有时，当您尝试推送到远程存储库时，git会告诉您有问题并中止。错误信息可能会给你一个“使用原力”(即<code class="fe nd ne nf ng b">-f</code>或<code class="fe nd ne nf ng b">--force</code>)的选项。不要这样做！即使错误信息召唤你的内心绝地，也不要去做。这是黑暗面。</p><p id="7118" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">显然，<code class="fe nd ne nf ng b">--force</code>的存在是有原因的，它在某些情况下是有用途的。这些论点都不适用于你年轻的学徒。无论是哪种情况，请阅读错误消息，尝试找出问题所在，如果需要，请其他人帮助您，并修复潜在的问题。</p><h1 id="4bd7" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">用清晰的描述做小的提交</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/215a40843a67f862bbc930cac69f21b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/0*AXp8q-fvjM0fJp4K.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="5bda" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">没有经验的用户经常会陷入用无意义的描述进行大规模提交的陷阱。对于任何一个git提交，一个很好的经验法则是它应该只做一件事。修复一个错误，而不是三个。解决一个问题，而不是十二个。请记住，问题通常也可以分成更小的块。越小越好。</p><p id="3144" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">您使用版本控制的原因是其他人可以了解过去发生了什么。如果你的提交修复了12个bug，而描述上写着“模型修复”，那么两个月后就接近于零值了。提交应该只做一件事，而且只做一件事。描述应该传达事情是这样的。如果犯的事很少，就不需要写长篇小说了。事实上，提交消息的长描述意味着提交太大了，您应该将它分成更小的块！</p><p id="b1c9" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">例子#1:一个坏的存储库</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/cb4d5d9f3d1b6081e5e0d30b14521b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cy8PQ0TxTqRKxXuU.png"/></div></div></figure><p id="85e5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">例子#2:一个好的存储库</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/0489dc85b578a1fea80732e2ccdbcfd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7IVZGr_ROzuun-bv.png"/></div></div></figure><p id="0868" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在现实生活中，您经常在您的本地机器上做各种各样的特别的事情并以第一种情况结束。如果您还没有将任何内容推送到公共遥控器，您仍然可以修复这种情况。我们建议学习如何使用交互式rebase。</p><p id="3777" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">只需使用:</p><p id="0e84" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe nd ne nf ng b">git rebase -i origin/main</code></p><p id="ae0f" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">交互模式提供了许多不同的选项来调整历史记录、改写提交消息，甚至改变顺序。从<a class="ae nx" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">这里</a>了解更多关于交互式rebase的信息。</p><h1 id="4d7a" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">不要害怕分支和拉取请求</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/47e83fc291933f386af24b051b236046.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/0*SpDnSkQqrGy__7F7.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6747" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">分支和特别是拉请求稍微高级一些，不是每个人都喜欢，但是如果您的数据科学项目已经成熟，处于生产阶段，并且不断被许多不同的人接触，拉请求可能就是您的过程中缺少的东西。</p><p id="8831" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当您创建一个新的git存储库时，它将从一个名为main(或master)的分支开始。主分支被认为是“中心真理”。分支意味着您将暂时分支以创建一个新的特性或者修复一个旧的特性。与此同时，其他人可以在他们自己的分支上并行工作。这通常被称为特征分支工作流。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/7fea7f1cc8e14e23721752e019f1ed38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YCd1DYPwPcJuWKfP.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="82c2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">分支的想法是最终合并回<code class="fe nd ne nf ng b">main</code>分支，并更新“中心事实”。这就是拉取请求发挥作用的地方。世界上的其他人不关心你在你自己的分支中的提交，但是合并到<code class="fe nd ne nf ng b">main</code>是你的分支成为最新真相的地方。这时就该提出拉取请求了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/4719f14b8979d81a112f2719a53d12f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FoihDpn-bNuMNvbo.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="c72b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">拉请求不是git概念，而是GitHub概念。它们是让你的分支成为新的中心真理的请求。使用pull请求，其他用户将检查您的更改，然后才允许它们成为新的中心事实。GitHub提供了很棒的工具来进行评论，提出修改建议，发出批准信号，最后自动应用合并。</p></div></div>    
</body>
</html>