<html>
<head>
<title>How to Handle Optimization Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理优化问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-handle-optimization-problems-daf97b3c248c#2022-03-27">https://towardsdatascience.com/how-to-handle-optimization-problems-daf97b3c248c#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/39871075f345a9e8f468767f103b6ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JfnY8ySDaTP4apPB"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>拍摄</p></figure><div class=""/><div class=""><h2 id="c29a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated"><strong class="ak">带有解决方案和代码的简单示例</strong></h2></div><h1 id="5f05" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">变量、约束和目标</h1><p id="ad41" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了定义一个优化问题，你需要三样东西:变量、约束和目标。变量可以取不同的值，规划求解将试图找到变量的最佳值。约束是不允许的事情或界限，通过正确设置它们，你肯定会找到一个在现实生活中可以实际使用的解决方案。目标是你在最优化问题中的目标，这是你想要最大化或最小化的。如果现在还不完全清楚的话，<a class="ae jd" href="https://hennie-de-harder.medium.com/why-every-data-scientist-should-learn-mathematical-optimization-3ac102663456" rel="noopener">这里有一个更全面的介绍</a>。不要犹豫继续，因为示例将引导您并更详细地解释概念。</p><h1 id="0170" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">代码示例</h1><p id="2f7a" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">想象你是一个小包裹递送公司的 CEO。该公司发现交付流程可以改进。他们希望首先交付最有价值的包裹组合，并为每次旅行确定最短的路线。他们最不想改进的就是任务的划分。一些员工抱怨，因为他们想更频繁地送货，而不是分拣包裹。</p><blockquote class="mj mk ml"><p id="7211" class="ln lo mm lp b lq mn kh ls lt mo kk lv mp mq ly lz mr ms mc md mt mu mg mh mi ij bi translated">如果您想自己尝试这些示例，您需要一个安装了以下包的工作 python 环境:<a class="ae jd" href="https://pypi.org/project/Pyomo/" rel="noopener ugc nofollow" target="_blank"> pyomo </a>、<a class="ae jd" href="https://pypi.org/project/pandas/" rel="noopener ugc nofollow" target="_blank"> pandas </a>和<a class="ae jd" href="https://pypi.org/project/numpy/" rel="noopener ugc nofollow" target="_blank"> numpy </a>。您还应该下载一个像 cbc 或<a class="ae jd" href="https://www.gnu.org/software/glpk/" rel="noopener ugc nofollow" target="_blank"> glpk </a>这样的<a class="ae jd" href="https://www.coin-or.org/download/binary/Cbc/" rel="noopener ugc nofollow" target="_blank">解算器，并在可执行路径中使用它。一些关于</a><a class="ae jd" href="https://www.w3schools.com/python/python_lists_comprehension.asp" rel="noopener ugc nofollow" target="_blank">列表理解</a>和<a class="ae jd" href="https://docs.python.org/3/tutorial/introduction.html" rel="noopener ugc nofollow" target="_blank"> python 编程</a>的知识会很有帮助，不在本文讨论范围之内。</p></blockquote><h2 id="1f71" class="mv kw jg bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">示例 1:选择要交付的包裹</h2><p id="fb08" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">包裹的价值越高，这个包裹对顾客就越重要。快递公司有一张表格，上面列有包裹及其价值和重量:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/67f31c72448473d9da4dce4f23f8ee11.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*2ZF7A3_4QpEK-eBuId7JoA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">每个包裹的包装号，包括价值和重量。</p></figure><p id="27a9" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">该公司希望选择总价值最高且总重量小于 600 的包裹(这是送货车可以处理的最大重量)。应该选择哪些包？目标很明确:我们希望最大化所选包的总价值。约束条件是所选包裹的总重量应小于或等于 600。我们可以将变量定义为每个包的二进制变量，如果没有选择包，则等于零，如果选择了包，则等于一。</p><p id="6b23" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">开始编程吧。</p><p id="9987" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">首先，我们导入包，加载表并从表中提取数据(这使得下一部分中的代码可读性更好):</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="7634" class="mv kw jg nn b gy nr ns l nt nu">import numpy as np<br/>import pandas as pd<br/>import pyomo.environ as pyo<br/>from pyomo.opt import SolverFactory<br/>import time</span><span id="8deb" class="mv kw jg nn b gy nv ns l nt nu"># load dataframe with package details<br/>data = pd.read_excel('package_details.xlsx')</span><span id="18a9" class="mv kw jg nn b gy nv ns l nt nu"># extracting the indici, weights and values from the dataframe<br/>indici = list(data.index.values)<br/>weights = data['Weight'].values<br/>values = data['Value'].values</span></pre><p id="39d1" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">现在我们可以开始使用 pyomo:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="e2e2" class="mv kw jg nn b gy nr ns l nt nu"># create a concrete model<br/>model = pyo.ConcreteModel()</span><span id="bf42" class="mv kw jg nn b gy nv ns l nt nu"># define the VARIABLES (in the end 0=not selected, 1=selected)<br/>model.x = pyo.Var(indici, within=pyo.Binary)<br/>x = model.x</span><span id="8574" class="mv kw jg nn b gy nv ns l nt nu"># define the CONSTRAINT, the total weight should be less than 600<br/>model.weight_constraint = pyo.Constraint(expr= sum([x[p]*weights[p] for p in indici]) &lt;= 600)</span><span id="89e2" class="mv kw jg nn b gy nv ns l nt nu"># define the OBJECTIVE, we want to maximize the value of the selected packages<br/>model.objective = pyo.Objective(expr= sum([x[p]*values[p] for p in indici]), sense=pyo.maximize)</span><span id="960f" class="mv kw jg nn b gy nv ns l nt nu"># print the complete model<br/>model.pprint()</span></pre><p id="123d" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">回想一下，该变量是一个二元决策变量，将等于 0(未选择)或 1(已选择)。该约束确保所选包装的总重量不超过 600。为此，我们应该用包裹的重量乘以<code class="fe nw nx ny nn b">x</code>变量，然后将这些值相加。该目标计算所选包的值的总和(将<code class="fe nw nx ny nn b">x</code>与一个包的值相乘并求和)，我们希望最大化该目标(<code class="fe nw nx ny nn b">sense=pyo.maximize</code>)。<code class="fe nw nx ny nn b">model.pprint()</code>显示已定义的模型:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/df4437c7c2fbfa8b017ff001466f1344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwLRDzxlEtIfwWdVdQ6PPA.png"/></div></div></figure><p id="bde6" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">仅此而已！现在是时候调用求解器了，它会给出我们应该选择的包:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="2e1a" class="mv kw jg nn b gy nr ns l nt nu"># replace the executable path by your own<br/>opt = SolverFactory('cbc', executable='C:\cbc\\bin\cbc.exe')<br/>results = opt.solve(model)</span></pre><p id="e7c6" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">几秒钟之内，求解器就找到了最优解！我们可以在原始数据框架中添加一个解决方案列。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="baf7" class="mv kw jg nn b gy nr ns l nt nu">solution = [int(pyo.value(model.x[p])) for p in indici]<br/>data['solution'] = solution</span></pre><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a6880d34cbf6e9d95084e8e97a02159c.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*oMzJ4gdEQSBEH1Mu-l9zsQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">添加了解决方案列。</p></figure><blockquote class="mj mk ml"><p id="8495" class="ln lo mm lp b lq mn kh ls lt mo kk lv mp mq ly lz mr ms mc md mt mu mg mh mi ij bi translated">能不能把这个问题改成选择最大数量的包，而不是所选包的最大总值？</p></blockquote><p id="f691" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">问题解决了，让我们继续下一个！</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ob"><img src="../Images/28dabf7f229339787f54d57a2ce7381e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZEagqO9_wHon8ubh"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">斯蒂芬·门罗在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="f4d6" class="mv kw jg bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">示例 2:确定交付选定包裹的顺序</h2><p id="988b" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了尽可能快地递送选定的包裹，我们想走最短的路线。我们从取货点开始，我们想在那里结束去取新的包裹。我们如何对这个问题建模并使用优化来解决它？这个问题比上一个问题稍微难一点。让我们定义目标、约束和变量。</p><p id="56b1" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">目标是最小化路线的总距离。约束条件是:我们要从取货点开始，到取货点结束，每个包裹都要投递，所以我们需要访问所有的地址至少一次。我们还需要确保创建一条完整的路线，而不是多条小路线。最后但同样重要的是，变量。我们用二进制变量创建一个 from，to 矩阵，其中 1 表示选择了这条路，0 表示没有选择。如果我们从地址 6 到地址 2。</p><p id="519d" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">对于这个问题，我们需要一个距离矩阵。在下面的矩阵中检查从地址 6 到地址 2 的距离是否等于 16。地址 0 是我们的起点(也是终点)。我们需要交付 8 个包裹，由其他 8 个地址代表。</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ede106ae3c62d37d8ed0de371d11b36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*MG358TS26wPkVg5jcp11Kw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">距离矩阵。</p></figure><p id="7138" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">创建随机距离矩阵的代码:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="a617" class="mv kw jg nn b gy nr ns l nt nu">import random<br/>import pandas as pd</span><span id="1df7" class="mv kw jg nn b gy nv ns l nt nu">indici = range(9)<br/>distances = pd.DataFrame(index=indici, columns=indici)</span><span id="8b01" class="mv kw jg nn b gy nv ns l nt nu">for from_ in indici:<br/>   for to in indici:<br/>      if from_ == to:<br/>         distances.loc[from_, to] = 0<br/>      elif pd.isna(distances.loc[from_, to]):<br/>         dist = random.choice(range(1, 30))<br/>         distances.loc[from_, to] = dist<br/>         distances.loc[to, from_] = dist</span></pre><p id="9433" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">首先，我们声明模型、地址(列出距离矩阵的索引值)和变量:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="dca3" class="mv kw jg nn b gy nr ns l nt nu">model = pyo.ConcreteModel()</span><span id="25ac" class="mv kw jg nn b gy nv ns l nt nu">addresses = distances.index</span><span id="848b" class="mv kw jg nn b gy nv ns l nt nu"># declaring the VARIABLE matrix, again with only binary values<br/>model.x = pyo.Var(addresses, addresses, within=pyo.Binary)<br/>x = model.x</span></pre><p id="a56e" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">在这个例子中，变量是一个矩阵:我们通过对地址循环两次来创建它。所以<code class="fe nw nx ny nn b">x[2,3]</code>对应的是从地址 2 到地址 3 的路由。</p><p id="8ce5" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">现在是时候声明约束了。这次我们将使用约束列表，因为我们想要同时添加多个约束。</p><p id="4a8f" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">第一个约束列表将保存我们往返于同一个地址的值。我们不想激活它们，所以我们设置所有的变量值，其中 from 和 to 点都等于零:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d76c" class="mv kw jg nn b gy nr ns l nt nu">model.diagonal = pyo.ConstraintList()<br/>for a in addresses:<br/>   model.diagonal.add(expr= x[a, a] == 0)</span></pre><p id="0231" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">下一个约束是关于访问每个地址一次。这意味着每个地址都应该恰好是一个“收件人”地址和一个“发件人”地址。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="fdee" class="mv kw jg nn b gy nr ns l nt nu">model.visit_once = pyo.ConstraintList()<br/>for a in addresses:<br/>   model.visit_once.add(expr=sum([x[a, to] for to in addresses])==1)<br/>   model.visit_once.add(expr=sum([x[fr, a] for fr in addresses])==1)</span></pre><p id="c94d" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">而最后的约束:我们不想绕圈子，我们要完整的路线！所以如果我们从地址 0 旅行到地址 5，我们不想从地址 5 旅行到地址 0！这两条路线中的任何一条都不应该被激活，所以<code class="fe nw nx ny nn b">x[0, 5] + x[5, 0] &lt;= 1</code>。这个约束确保我们得到一个完整的路线，而不是多个较小的路线。查看<a class="ae jd" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">米勒-塔克-泽姆林公式，了解该约束的解释</a>。这里我们引入一个叫做<code class="fe nw nx ny nn b">u</code>的虚拟变量。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="b22e" class="mv kw jg nn b gy nr ns l nt nu">n = len(addresses)<br/>model.u = pyo.Var(addresses, within=pyo.NonNegativeIntegers, bounds=(1, n))<br/>u = model.u</span><span id="a7a1" class="mv kw jg nn b gy nv ns l nt nu">model.no_circles = pyo.ConstraintList()<br/>for a1 in range(1, n):<br/>   for a2 in range(1, n):<br/>      if a1 != a2:<br/>         model.no_circles.add(expr= u[a1]-u[a2]+x[a1,a2]*n &lt;= n-1)</span></pre><p id="8a0b" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">约束，检查！对于目标，我们希望最小化激活路线的距离总和。我们对地址组合进行循环，并将 x 的值乘以路由的距离。这些值的总和给出了总距离。这一次我们需要呼叫<code class="fe nw nx ny nn b">pyo.minimize</code>，因为我们想把总距离减到最小。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="a508" class="mv kw jg nn b gy nr ns l nt nu"># declaring the OBJECTIVE</span><span id="4507" class="mv kw jg nn b gy nv ns l nt nu">sum_of_distances = sum([x[a1, a2]*distances.loc[a1, a2] for a1 in addresses for a2 in addresses])</span><span id="5d42" class="mv kw jg nn b gy nv ns l nt nu">model.obj = pyo.Objective(expr=sum_of_distances, sense=pyo.minimize)</span></pre><p id="4e4c" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">现在是解决问题的时候了。调用求解器并打印结果:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="8aa1" class="mv kw jg nn b gy nr ns l nt nu">opt = SolverFactory('cbc', executable='C:\cbc\\bin\cbc.exe')<br/>results = opt.solve(model)</span><span id="de28" class="mv kw jg nn b gy nv ns l nt nu">print(pyo.value(model.obj)) # gives 62 (for this distance matrix)</span><span id="49b2" class="mv kw jg nn b gy nv ns l nt nu">solution = []<br/>for a1 in addresses:<br/>   solution.append([pyo.value(model.x[a1, a2]) for a2 in addresses])</span></pre><p id="28c2" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">目标的值是 62，因此该路由的总距离等于 62。在你的情况下，它可能是另一个数，因为你可能有另一个距离矩阵。解决方案矩阵如下所示:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0a5bf077149681d14556ac5fe912e13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*euDZkttv_ohTT7m0mAWSpw.png"/></div></figure><p id="2a86" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">每行有一个 1，每列也有一个 1。所以我们每个地址都去一次。要使这个解决方案更具可读性，请使用以下代码:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="dd5a" class="mv kw jg nn b gy nr ns l nt nu">def print_route(solution):<br/>   sol_ind = list(np.where(np.array(solution[i]) == 1)[0][0] for i in range(len(solution)))<br/>   one_dict = {k:sol_ind[k] for k, _ in enumerate(sol_ind)}</span><span id="02f7" class="mv kw jg nn b gy nv ns l nt nu">   sol_str = '0 -&gt; '<br/>   nxt = one_dict[0]<br/>   sol_str += str(nxt)<br/>   while True: <br/>      nxt = one_dict[nxt]<br/>      sol_str += ' -&gt; '<br/>      sol_str += str(nxt)<br/>      if nxt == 0:<br/>         break</span><span id="1a9d" class="mv kw jg nn b gy nv ns l nt nu">   print(sol_str)</span><span id="bc7a" class="mv kw jg nn b gy nv ns l nt nu">print_route(solution)</span></pre><p id="4259" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">结果:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/285615f4654423fe58f3565e65f10461.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*YK5MHX6my9dA5iYq5aLWXw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">解决方案印刷精美。在拾取点(地址 0)开始和结束。</p></figure><p id="c4cc" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">因此，从起点(起点，地址 0)，我们去地址 2，地址 8，地址 5，地址 4，等等，直到我们回到了起点。我们递送了所有包裹，我们可以肯定这是可用的最短路线之一！</p><blockquote class="mj mk ml"><p id="9d1a" class="ln lo mm lp b lq mn kh ls lt mo kk lv mp mq ly lz mr ms mc md mt mu mg mh mi ij bi translated">注意:这个问题是<a class="ae jd" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行商问题</a>的变种。</p></blockquote><p id="aa0a" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">你已经解决了两个问题，很好！让我们继续最后一个！</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/6766d85d91f27a621d2db23ffc69ea31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p5yrOyGI_3msLjXn"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">安妮·斯普拉特在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="2260" class="mv kw jg bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">示例 3:任务划分</h2><p id="a6e7" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">最后一个问题是关于任务分工。目前，你有六名员工，你想让他们保持快乐和精力充沛。但同时，工作是需要做的！那么，你如何才能同时完成这两项任务，完成工作，并让员工开心呢？简单，你创建另一个优化模型！您定义需要完成的任务，如清洁、分拣包裹、递送包裹和在服务中心。在接下来的一个月里，你要定义每项任务需要多少次轮班，以及每次轮班需要多长时间。这给出了您需要员工工作的总小时数，您希望给每个员工相同的工作时间，执行他们喜欢的任务。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="6746" class="mv kw jg nn b gy nr ns l nt nu"># no of shifts needed for the upcoming month<br/>DELIVERIES = 45<br/>SORTING = 20<br/>SERVICE_CENTER = 20<br/>CLEANING = 10</span><span id="6856" class="mv kw jg nn b gy nv ns l nt nu">task = {'DELIVERY': DELIVERIES, 'SORT': SORTING, 'SERVICE': SERVICE_CENTER, 'CLEAN': CLEANING}</span><span id="fd63" class="mv kw jg nn b gy nv ns l nt nu"># time needed for every shift<br/>time_p_shift = {'DELIVERY': 8, 'SORT': 4, 'SERVICE': 6, 'CLEAN': 3}</span><span id="5671" class="mv kw jg nn b gy nv ns l nt nu"># total time needed <br/>total_hours = sum([task[k]*timepershift[k] for k in task.keys()])</span></pre><p id="bba5" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">接下来，你定义你的员工，让他们决定他们喜欢做什么样的轮班。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="41ea" class="mv kw jg nn b gy nr ns l nt nu">employees = {'John':['DELIVERY', 'CLEAN'], 'Jack':['DELIVERY'], 'Joshua':['SORT', 'CLEAN'], 'Janice':['DELIVERY', 'SERVICE'], 'Joyce':['DELIVERY', 'CLEAN', 'SERVICE', 'SORT'], 'Joy':['CLEAN', 'SERVICE', 'SORT']}</span><span id="b494" class="mv kw jg nn b gy nv ns l nt nu">emp_list = employees.keys()</span></pre><p id="1d2c" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">约翰喜欢送货和打扫卫生，而乔伊喜欢打扫卫生，呆在服务台，整理包裹(她可能没有驾照)。现在您可以计算每个人应该工作的平均小时数，您将在目标中使用该值:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="dec6" class="mv kw jg nn b gy nr ns l nt nu">avg_hours_pp = total_hours/len(emp_list)</span><span id="c5b8" class="mv kw jg nn b gy nv ns l nt nu">final_df = pd.DataFrame(index=emp_list, columns=task.keys())</span></pre><p id="b643" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated"><code class="fe nw nx ny nn b">final_df</code>最终将获得最佳值:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/029004a01fdae0f357072c778e8af587.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/format:webp/1*RF2bvbrdO8mVwkvKA206vw.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">final_df 将在稍后接收最佳变量值。</p></figure><p id="d831" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">约翰这个月应该有六个送货班。</p><p id="a9f9" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">数据处理完后，我们就可以开始建模了。我们使用员工和任务创建一个变量矩阵。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="1cdb" class="mv kw jg nn b gy nr ns l nt nu">model = pyo.ConcreteModel()</span><span id="42ce" class="mv kw jg nn b gy nv ns l nt nu">model.Employees = pyo.Set(initialize=emp_list)<br/>model.Tasks = pyo.Set(initialize=task.keys())</span><span id="da7b" class="mv kw jg nn b gy nv ns l nt nu"># define the VARIABLE matrix x using the employees and the tasks<br/>model.x = pyo.Var(model.Employees, model.Tasks, within=pyo.Integers, bounds=(0, None))</span><span id="2e44" class="mv kw jg nn b gy nv ns l nt nu"># define the hours of work per task<br/>model.hours = pyo.Param(model.Tasks, initialize=time_p_shift)</span></pre><p id="07cf" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">我们希望每个班次都有人，因此我们需要添加约束条件，以确保我们有足够的人员来完成每项任务:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d53c" class="mv kw jg nn b gy nr ns l nt nu">model.shifts_needed = pyo.ConstraintList()<br/>for t in model.Tasks:<br/>   model.shifts_needed.add(expr= sum([model.x[employee, t] for employee in model.Employees]) == task[t])</span></pre><p id="9eb9" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">我们希望排除人们不想做的某些任务:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="5e61" class="mv kw jg nn b gy nr ns l nt nu">model.excluded = pyo.ConstraintList()<br/>for employee in model.Employees:<br/>   incl = employees[employee]<br/>   excl_tasks = list(task.keys()-incl)<br/>   for t in excl_tasks:<br/>      model.excluded.add(expr= model.x[employee, t] == 0)</span></pre><p id="b2fe" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">我们的目标是给所有员工同等数量的工作，只分配他们想做的任务。我们如何才能做到这一点？我们之前计算了平均小时数。我们希望最大限度地缩短从人们收到信息的时间到<code class="fe nw nx ny nn b">avg_hours_pp</code>的绝对距离。因为如果这个距离等于零，每个人得到的功都是一样的。</p><p id="cc67" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">计算绝对距离是可能的，但不像使用<code class="fe nw nx ny nn b">abs()</code>那么简单。Pyomo 处理不了绝对函数，因为问题变得非线性了。因此，我们在这里引入两个新变量:<code class="fe nw nx ny nn b">model.posdelta</code>表示与<code class="fe nw nx ny nn b">avg_hours_pp</code>的正距离，而<code class="fe nw nx ny nn b">model.negdelta</code>表示负距离。使用约束列表，我们设置这些变量值:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="9177" class="mv kw jg nn b gy nr ns l nt nu">model.posdelta = pyo.Var(model.Employees, bounds=(0, None))<br/>model.negdelta = pyo.Var(model.Employees, bounds=(0, None))</span><span id="69ad" class="mv kw jg nn b gy nv ns l nt nu"># defining the variables posdelta en negdelta using CONSTRAINTLIST<br/>model.distance_from_avg = pyo.ConstraintList()<br/>for employee in model.Employees:<br/>   model.distance_from_avg.add(expr= sum([model.x[employee, t]*model.hours[t] for t in model.Tasks]) + model.posdelta[employee] - model.negdelta[employee] == avg_hours_pp)</span><span id="46f7" class="mv kw jg nn b gy nv ns l nt nu"># defining the OBJECTIVE, minimize posdelta + negdelta<br/>model.obj = pyo.Objective(expr= pyo.summation(model.posdelta) + pyo.summation(model.negdelta), sense=pyo.minimize)</span></pre><p id="3523" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">是时候调用求解器并显示结果了:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="871d" class="mv kw jg nn b gy nr ns l nt nu">opt = SolverFactory('cbc', executable='C:\cbc\\bin\cbc.exe')<br/>results = opt.solve(model)</span><span id="fc7c" class="mv kw jg nn b gy nv ns l nt nu">def create_result_frame(model, df):<br/>   solution = pd.DataFrame(np.reshape(pyo.value(model.x[:, :]), (df.shape[0], df.shape[1])), index=emp_list, columns=task.keys())<br/>   solution = solution.astype('int')<br/>   return solution</span><span id="65cf" class="mv kw jg nn b gy nv ns l nt nu">solution = create_result_frame(model, final_df)</span></pre><p id="c965" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated"><code class="fe nw nx ny nn b">solution</code>数据帧看起来像这样:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1db8246e3f31215b24af8d79f826ff67.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*m3fWSVMvqUpUuetcrbudtA.png"/></div></figure><p id="e2a4" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">它告诉我们每个人应该轮班多少次。最重要的问题是:任务是否平均分配？</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d4ea" class="mv kw jg nn b gy nr ns l nt nu">for emp in model.Employees:<br/>   print(f'{emp}:', int(sum([pyo.value(model.x[emp, t])*pyo.value(model.hours[t]) for t in model.Tasks])), 'hours')</span></pre><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/c1c9bfe4d967ea3704251051f59dae18.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/1*iE-E8h_UQ4wr5F8MEOcHxw.png"/></div></figure><p id="2f9a" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated">是的，每个人的工作量都差不多！</p><blockquote class="mj mk ml"><p id="7e62" class="ln lo mm lp b lq mn kh ls lt mo kk lv mp mq ly lz mr ms mc md mt mu mg mh mi ij bi translated">如果你想了解更多关于处理绝对值、线性化和其他高级概念的信息，<a class="ae jd" href="https://hennie-de-harder.medium.com/taking-your-optimization-skills-to-the-next-level-de47a9c51167" rel="noopener">请看这里</a>。</p></blockquote></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="f4d4" class="kv kw jg bd kx ky op la lb lc oq le lf km or kn lh kp os kq lj ks ot kt ll lm bi translated">结论</h1><p id="3044" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们在本帖中处理的问题是<a class="ae jd" href="https://en.wikipedia.org/wiki/Linear_programming" rel="noopener ugc nofollow" target="_blank">整数线性规划</a>的例子。这是一种在许多不同行业中使用的技术，具有强大的功能。如果你的问题变得更大，像 CBC 这样的开源求解器将需要很长时间才能运行。你可能想切换到商业解算器，如<a class="ae jd" href="https://www.gurobi.com/" rel="noopener ugc nofollow" target="_blank"> Gurobi </a>或<a class="ae jd" href="https://www.ibm.com/nl-en/analytics/cplex-optimizer" rel="noopener ugc nofollow" target="_blank"> CPLEX </a>。如果你想让你的优化技巧更上一层楼，我可以推荐<a class="ae jd" href="https://www.udemy.com/course/optimization-with-python-linear-nonlinear-and-cplex-gurobi/" rel="noopener ugc nofollow" target="_blank">这个 Udemy 课程</a>。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h2 id="dd5b" class="mv kw jg bd kx mw mx dn lb my mz dp lf lw na nb lh ma nc nd lj me ne nf ll ng bi translated">有关系的</h2><div class="ip iq gp gr ir ou"><a rel="noopener follow" target="_blank" href="/why-every-data-scientist-should-learn-mathematical-optimization-3ac102663456"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jh gy z fp oz fr fs pa fu fw jf bi translated">为什么每个数据科学家都应该学习数学优化</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">数据科学课程的重点是数据可视化，特征工程，数据处理，(非)监督学习…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi ix ou"/></div></div></a></div><div class="ip iq gp gr ir ou"><a rel="noopener follow" target="_blank" href="/taking-your-optimization-skills-to-the-next-level-de47a9c51167"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jh gy z fp oz fr fs pa fu fw jf bi translated">让您的优化技能更上一层楼</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">软约束、线性化、多目标等等</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">towardsdatascience.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi ix ou"/></div></div></a></div></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="81b5" class="pw-post-body-paragraph ln lo jg lp b lq mn kh ls lt mo kk lv lw mq ly lz ma ms mc md me mu mg mh mi ij bi translated"><em class="mm">别忘了</em> <a class="ae jd" href="https://hennie-de-harder.medium.com/subscribe" rel="noopener"> <em class="mm">订阅</em> </a> <em class="mm">如果你想在我发表新文章时收到电子邮件。</em></p></div></div>    
</body>
</html>