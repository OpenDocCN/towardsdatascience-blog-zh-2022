<html>
<head>
<title>Measuring User Engagement with Cohort Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用群组分析测量用户参与度</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/measuring-user-engagement-with-cohort-analysis-96c46b386862#2022-10-12">https://towardsdatascience.com/measuring-user-engagement-with-cohort-analysis-96c46b386862#2022-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eafe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">SQL用于举重，熊猫用于深潜</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/751027eb72c2b4769604060eb67f020a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vlcesyEEzVoCUx6a"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">威廉·沃比在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b907" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公司需要能够测量用户参与度和保留度，以量化各种信息，例如(I)它如何随时间演变，(ii)它对外部事件和季节性的敏感程度，以及(iii)不同的用户群如何参与他们的产品。该产品通常是一个应用程序，用户可以与之交互，以获得一些服务。因此，<strong class="ky ir">参与度</strong>可以简单地定义为<strong class="ky ir">用户在应用</strong>上的活动。</p><h1 id="39ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1-简介</h1><p id="bc6d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇文章中，我将向你展示一个如何用“群组分析”调查用户参与度的例子。</p><blockquote class="mp mq mr"><p id="1266" class="kw kx ms ky b kz la jr lb lc ld ju le mt lg lh li mu lk ll lm mv lo lp lq lr ij bi translated">"一群人是指在一定时期内具有共同特征的一群人."</p></blockquote><p id="0f88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让事情更简单，让我们假设这个共同特征是用户第一次打开公司应用的那一周。这会将该用户的状态设置为活动用户。如果用户下周没有打开应用程序，那么它的状态将是不活动的。在此基础上，可以为活动和非活动用户提供以下状态定义，这将有助于我们跟踪不同的群组。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/c9902142132a242d135adfa1ba92ae40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zK55gAFeA7o-kpvJTfHxow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="7466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">按照这个逻辑，我们可以看到，在任何给定的一周，</strong></p><ul class=""><li id="3f6d" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">保留用户、重新获得用户和流失用户的总数等于前几周至该周所有新用户的累计总和。</li><li id="ef9b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">留存率为(留存用户总数)/(留存用户总数+流失用户总数)</li></ul><p id="497f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤</strong></p><p id="8c74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#05cb" rel="noopener ugc nofollow"> <strong class="ky ir"> a)虚拟数据库</strong> </a></p><p id="0eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#0327" rel="noopener ugc nofollow"> <strong class="ky ir"> b) SQL查询</strong> </a></p><p id="66e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#6aff" rel="noopener ugc nofollow"> <strong class="ky ir"> c)回归熊猫</strong> </a></p><p id="8fb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#2395" rel="noopener ugc nofollow"> <strong class="ky ir"> d)表格转换</strong> </a></p><p id="9cd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#9d91" rel="noopener ugc nofollow"> <strong class="ky ir"> e)时间队列</strong> </a></p><p id="6c4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#c703" rel="noopener ugc nofollow"> <strong class="ky ir"> f)行为群组</strong> </a></p><p id="1cdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#2509" rel="noopener ugc nofollow"> <strong class="ky ir">结论</strong> </a></p><h1 id="56cf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">双流程</h1><p id="02e6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们生成一个虚拟用户活动数据库，并开始处理它。</p><h2 id="05cb" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated"><strong class="ak"> 2.a)虚拟数据库</strong></h2><p id="257d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通常，公司都有自己的数据库来收集用户活动数据。然而，为了便于说明，我们将生成自己的用户活动表(使用pandas和NumPy)并将其推送到SQL数据库，这样我们就可以使用SQL查询来完成繁重的工作。我们的activity表将有3个基本列:(i) user_id，(ii) activity_day，以及(iii)在那一天为该用户打开的app_opens。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="d2bb" class="nl lt iq ny b gy oc od l oe of">from matplotlib import pyplot as plt<br/>import numpy as np<br/>import pandas as pd<br/>import string<br/>import seaborn as sns</span><span id="8d98" class="nl lt iq ny b gy og od l oe of">pd.set_option('display.max_rows', 400)<br/>pd.set_option('display.max_columns', 200)<br/>pd.set_option('display.max_colwidth', 150)</span><span id="1214" class="nl lt iq ny b gy og od l oe of"># ['A', 'B', ..., 'AA', 'AB', ..., 'ZY', 'ZZ']<br/>ALPHABETICAL_LIST = (list(string.ascii_uppercase) + <br/>                     [letter1+letter2 for letter1 in string.ascii_uppercase <br/>                      for letter2 in string.ascii_uppercase])</span><span id="986f" class="nl lt iq ny b gy og od l oe of">%matplotlib inline<br/>plt.rcParams["figure.figsize"] = (40,20)</span></pre><p id="66b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虚拟用户活动表将是</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="658e" class="nl lt iq ny b gy oc od l oe of">userid_list = [letter+'{:02d}'.format(i) for letter in ALPHABETICAL_LIST <br/>               <br/>               for i in range(1,21)][:14000]</span><span id="70ed" class="nl lt iq ny b gy og od l oe of">np.random.seed(0)</span><span id="593f" class="nl lt iq ny b gy og od l oe of">app_opens = np.concatenate(( <br/>    np.random.choice(range(10,13), size=len(userid_list)),<br/>    np.random.choice(range(8,11), size=len(userid_list)),<br/>                ))</span><span id="57b9" class="nl lt iq ny b gy og od l oe of">user_ids = np.concatenate((<br/>                           userid_list, <br/>                           userid_list, <br/>                           ))</span><span id="85df" class="nl lt iq ny b gy og od l oe of">app_activations = np.datetime64('2020-01-06') + np.random.choice(np.arange(0, 180), len(userid_list))</span><span id="4c5f" class="nl lt iq ny b gy og od l oe of">activity_days = np.concatenate((<br/>                           app_activations, <br/>                           app_activations + 7, <br/>                           ))</span><span id="804e" class="nl lt iq ny b gy og od l oe of">random_user_ids = [x for x in userid_list]</span><span id="2422" class="nl lt iq ny b gy og od l oe of">for days_passed in range(14,106, 7):<br/>        <br/>    user_id_sample = int(np.floor(len(random_user_ids) * 0.98))</span><span id="a378" class="nl lt iq ny b gy og od l oe of">if user_id_sample!=0:<br/>    <br/>        random_user_ids = [random_user_ids[x] for x in <br/>                           <br/>                           np.random.choice(range(len(random_user_ids)),</span><span id="bb0b" class="nl lt iq ny b gy og od l oe of">size=user_id_sample,</span><span id="b621" class="nl lt iq ny b gy og od l oe of">replace=False)]</span><span id="0b97" class="nl lt iq ny b gy og od l oe of">user_ids = np.concatenate((user_ids, random_user_ids))<br/>        <br/>        app_opens = np.concatenate((app_opens, <br/>                                    <br/>                                    np.random.choice(range(3,7), <br/>                                                     <br/>                                                     size=user_id_sample, <br/>                                                    <br/>                                                    p=[0.2, 0.3, 0.3, 0.2]<br/>                                                     <br/>                                                    ),<br/>                                    ))<br/>        <br/>        activity_days = np.concatenate((activity_days, <br/>                                        <br/>                                        [app_activations[userid_list.index(x)]+days_passed for x in random_user_ids]<br/>                                        <br/>                                        ))</span><span id="ac54" class="nl lt iq ny b gy og od l oe of">df_user_activity = pd.DataFrame(zip(user_ids, activity_days, app_opens), <br/>                                columns=['user_id', 'activity_day', 'app_opens'])</span><span id="8506" class="nl lt iq ny b gy og od l oe of">df_user_activity = df_user_activity.groupby(['user_id'], <br/>                                            group_keys=False<br/>                                           ).apply(lambda df: df.sample(len(df)-2)<br/>                                                  ).sort_index().reset_index(drop=True)</span><span id="be8b" class="nl lt iq ny b gy og od l oe of">df_user_activity['count'] = df_user_activity.groupby(['user_id'])['activity_day'].transform(len)</span><span id="f6d6" class="nl lt iq ny b gy og od l oe of">df_user_activity.loc[df_user_activity['count']==1, 'app_opens'] = np.minimum(5, df_user_activity['app_opens'])</span><span id="7c10" class="nl lt iq ny b gy og od l oe of">df_user_activity = df_user_activity.drop(['count'], axis=1)</span><span id="7c5d" class="nl lt iq ny b gy og od l oe of">df_user_activity</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/2b056bf68867732758bd440699186360.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*lQP3OOZTaLlHzEd-c-Oaew.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="2f8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将这个表写入SQL数据库。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="7029" class="nl lt iq ny b gy oc od l oe of">from sqlalchemy import create_engine<br/>import os</span><span id="79d7" class="nl lt iq ny b gy og od l oe of">SQL_ENGINE = create_engine('sqlite:///'+ 'medium_project.db',<br/>                           connect_args={'check_same_thread': False}).connect()</span><span id="91f4" class="nl lt iq ny b gy og od l oe of">df_user_activity.to_sql(name='user_activity',<br/>                  index=False,<br/>                  con=SQL_ENGINE,<br/>                  if_exists='replace')</span></pre><h2 id="0327" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">2.b) SQL查询</h2><p id="2dbe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下面的查询帮助我实现了我想要进行队列分析的观点。对于上述时间段(42周)，我创建了一个表，显示user_id、week和weekly_flags(比如new、retained、recreated和churned)。该表有13，720个唯一的user _ ids * 42周= 576，240行。</p><p id="c07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">在查询上，</strong></p><p id="b659" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ms">我创建了一个周周期表来连接user_activity_daily数据，为每个用户带来缺失的周。我的目标是实现一个表格视图，其中，对于每个用户id，我们有42周的行和他们每周打开的应用程序总数。我首先将每个活动日转化为一年一周的视图，为用户应用分组(应用打开总数)。后来，我将它加入到周期表中，对于不相关的周，我将app_opens转换为0，最后，我计算生命周期(累计)、前一周(滞后)和前一生命周期(滞后累计)weekly_app_opens，以分配新的、保留的、活动的、搅动的、重新获得的标志。注意:row_number()列将重复相同的daily_activity行42次。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者对用户活动的sql查询</p></figure><p id="59a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我将这个表保存为CSV之后，我返回了Pandas用于我的剩余分析。</p><p id="2ae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ms">虽然这不在本文的讨论范围之内，但是如果需要的话，这个表可以进一步与其他SQL表连接，以便将与用户段相关的信息显示在视图中。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/d7e224e46d2dc49e3753c255baec06bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K5TrgNl2sLGxOah89Qajow.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="6aff" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">2.c)回归熊猫</h2><p id="bcc4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">下表显示了每周新增、保留、活跃、恢复和流失的用户总数。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="f67f" class="nl lt iq ny b gy oc od l oe of">df_overall_summary = df_weekly_activity.groupby(<br/>                    ['year_week']<br/>                          )['new_flag', <br/>                            'retained_flag', <br/>                            'active_flag', <br/>                            'churned_flag', <br/>                            'regained_flag'].sum().reset_index()</span><span id="922b" class="nl lt iq ny b gy og od l oe of">df_overall_summary</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/823ceece1266b009006cb4b2fed34495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*_emHPgM-Dc4M-kq0du4riw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="46ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们查看上述数据框的前3行，我们可以看到，在2020年的第一周，435名用户首次打开了该应用程序。接下来的一周，在这435人中，除了523名新加入者之外，还有72人(在那一周)和363人仍然活跃。</p><p id="1ee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经有了基于用户的每周活动视图，让我们进一步分析和可视化群组。</p><h2 id="2395" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">2.d)表格转换</h2><p id="cdde" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我将通过将同一周的订阅者分组来查看所有用户的活动旅程。我的目标是确定第n周之后每个人的活动量是否下降。我们将在第X周(100%活跃)、第X+1周、第X+2周、第X+3周、第X+4周等时间段调查在第X周拥有新标志的用户的平均活跃用户数。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="9e19" class="nl lt iq ny b gy oc od l oe of">df_weekly_activity['new_flag_cumsum'] = df_weekly_activity.groupby(['user_id'])['new_flag'].cumsum()</span><span id="703c" class="nl lt iq ny b gy og od l oe of"># Filterin out the rows where the user didn't started its journey<br/># (they weren't even a new user yet).</span><span id="f114" class="nl lt iq ny b gy og od l oe of">df_cohort_prep = df_weekly_activity[df_weekly_activity['new_flag_cumsum']&gt;0].reset_index(drop=True)<br/>df_cohort_prep = df_cohort_prep.merge(<br/>    <br/>df_cohort_prep[df_cohort_prep['new_flag']==1][['user_id', 'year_week']].rename(columns={'year_week': 'joined_on'}),<br/>                    <br/>how='left', on=['user_id']                    <br/>                    <br/>                    )</span><span id="3e88" class="nl lt iq ny b gy og od l oe of">df_cohort['Nth_Week'] = (df_cohort['year_week'].str[:4].astype(int) * 52 + <br/>                         df_cohort['joined_on'].str[:4].astype(int) * 52 * -1 + <br/>                         df_cohort['year_week'].str[-2:].astype(int) + <br/>                         df_cohort['joined_on'].str[-2:].astype(int) * -1 <br/>                         + 1<br/>                         )</span></pre><h2 id="9d91" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">2.e)时间群组</h2><p id="ab30" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">第一周总是100%,因为这时候用户是公司的新用户。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="9c49" class="nl lt iq ny b gy oc od l oe of">df_heatmap = pd.pivot_table(<br/>               df_cohort[df_cohort['Nth_Week']&lt;20],<br/>               index=['joined_on'], <br/>               columns=['Nth_Week'], <br/>               values=['active_flag'], <br/>               aggfunc=lambda x: np.sum(x) / len(x)<br/>               )</span><span id="eba8" class="nl lt iq ny b gy og od l oe of">df_heatmap.loc[''] = np.nan</span><span id="38ef" class="nl lt iq ny b gy og od l oe of">df_heatmap = df_heatmap.sort_index(axis=0)</span><span id="b639" class="nl lt iq ny b gy og od l oe of">df_heatmap.loc[' '] = np.nan</span><span id="ed74" class="nl lt iq ny b gy og od l oe of">fig2 = plt.figure(figsize=(24,16))</span><span id="c444" class="nl lt iq ny b gy og od l oe of">ax1=sns.heatmap(df_heatmap.values, <br/>            xticklabels=[b for a,b in df_heatmap.columns],<br/>            yticklabels=df_heatmap.index.tolist(),<br/>            vmin=df_heatmap.min(axis=1).min(), <br/>            vmax=df_heatmap.max(axis=1).max(),    <br/>            annot=True, <br/>            fmt=".2%", <br/>            cmap='YlGnBu', <br/>            linewidths=.005, <br/>            linecolor='#029386',<br/>            cbar=False, <br/>               )</span><span id="540e" class="nl lt iq ny b gy og od l oe of">ax1.set_title('Active Users %')</span><span id="defc" class="nl lt iq ny b gy og od l oe of">plt.subplots_adjust(hspace=0.35, wspace=0.2)</span><span id="0927" class="nl lt iq ny b gy og od l oe of">ax1.set_yticklabels(ax1.get_yticklabels(), rotation=0)</span><span id="156e" class="nl lt iq ny b gy og od l oe of">ax1.set_xlabel('Nth Week at [Company X]')</span><span id="253b" class="nl lt iq ny b gy og od l oe of">ax1.set_ylabel('Joined On Week')</span><span id="3e1b" class="nl lt iq ny b gy og od l oe of">fig2.savefig("Weekly Active Users % Medium.png", bbox_inches = 'tight')</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/3ad2652028b5512c8637fab31b99ef11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVGGU1jCWohv12JOCqNeuA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看到，用户活跃度在第2周下降到80–85 %,并继续下降，对于许多群组来说，活跃度在第16周下降到0%。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="9ce9" class="nl lt iq ny b gy oc od l oe of">df_heatmap = pd.pivot_table(<br/>               df_cohort[df_cohort['Nth_Week']&lt;20], <br/>               index=['joined_on'], <br/>               columns=['Nth_Week'], <br/>               values=['weekly_app_opens'], <br/>               aggfunc=lambda x: np.mean(x)<br/>               )</span><span id="02b0" class="nl lt iq ny b gy og od l oe of">df_heatmap.loc[''] = np.nan</span><span id="676a" class="nl lt iq ny b gy og od l oe of">df_heatmap = df_heatmap.sort_index(axis=0)</span><span id="b1ee" class="nl lt iq ny b gy og od l oe of">df_heatmap.loc[' '] = np.nan</span><span id="5fa3" class="nl lt iq ny b gy og od l oe of">fig2 = plt.figure(figsize=(24,16))</span><span id="f0f6" class="nl lt iq ny b gy og od l oe of">ax1=sns.heatmap(df_heatmap.values, <br/>            xticklabels=[b for a,b in df_heatmap.columns],<br/>            yticklabels=df_heatmap.index.tolist(),<br/>            vmin=df_heatmap.min(axis=1).min(), <br/>            vmax=df_heatmap.max(axis=1).max(),    <br/>            annot=True, <br/>            #fmt=".2%", <br/>            cmap='YlGnBu', <br/>            linewidths=.005, <br/>            linecolor='#029386',<br/>            cbar=False, <br/>               )</span><span id="d83a" class="nl lt iq ny b gy og od l oe of">ax1.set_title('App Opens Avg.')</span><span id="f878" class="nl lt iq ny b gy og od l oe of">plt.subplots_adjust(hspace=0.35, wspace=0.2)</span><span id="44b1" class="nl lt iq ny b gy og od l oe of">ax1.set_yticklabels(ax1.get_yticklabels(), rotation=0)</span><span id="aba6" class="nl lt iq ny b gy og od l oe of">ax1.set_xlabel('Nth Week at [Company X]')</span><span id="0e71" class="nl lt iq ny b gy og od l oe of">ax1.set_ylabel('Joined On Week')</span><span id="4141" class="nl lt iq ny b gy og od l oe of">fig2.savefig("Weekly App Opens Avg Medium.png", bbox_inches = 'tight')</span></pre><p id="6fef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">平均而言，用户在第一周打开应用程序10-11次，第二周打开6-7次。在完全搅拌之前，他们每周打开应用程序2-2.5次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/b0e2fbc57786198b65a50492f1b98efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mJp2vlN2Rjq3MRCVIF6K7A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="c703" class="nl lt iq bd lu nm nn dn ly no np dp mc lf nq nr me lj ns nt mg ln nu nv mi nw bi translated">2.f)行为群组</h2><p id="020a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">找到用户永远无法恢复的行索引。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="514a" class="nl lt iq ny b gy oc od l oe of">df_churned_forever_index = df_cohort[<br/>    <br/>df_cohort['active_flag'].eq(1)[::-1].astype(int).groupby(df_cohort['user_id']).cumsum().eq(0).sort_index(axis=0)</span><span id="2138" class="nl lt iq ny b gy og od l oe of">].groupby('user_id', sort=False<br/>                  )['Nth_Week'].idxmin().reset_index().rename(columns={'Nth_Week': 'index_value'})</span></pre><p id="a500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅保留用户之间的行是新的，并且在我们的时间窗口的剩余时间内会发生变化。</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="427c" class="nl lt iq ny b gy oc od l oe of">df_cohort = df_cohort.merge(<br/>    <br/>df_churned_forever_index,<br/>                    <br/>how='left', on=['user_id']                    <br/>                    <br/>                    )</span><span id="489d" class="nl lt iq ny b gy og od l oe of">df_cohort_churned_forever = df_cohort[df_cohort.index&lt;=df_cohort['index_value']].reset_index(drop=True)</span></pre><p id="4727" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于所有流失的用户，有多少是在2周、3周、… N周后流失的，他们的每周应用打开次数是多少？</p><pre class="kg kh ki kj gt nx ny nz oa aw ob bi"><span id="20eb" class="nl lt iq ny b gy oc od l oe of">df_users_churning_week = df_cohort_churned_forever.groupby(<br/>                            ['user_id']<br/>                                 )['Nth_Week'].max().reset_index()</span><span id="6df5" class="nl lt iq ny b gy og od l oe of">list_to_append_leaving_users = []</span><span id="4c53" class="nl lt iq ny b gy og od l oe of">for Nth_WEEK in range(2,15):<br/>    <br/>    list_of_users_leaving_n_week = df_users_churning_week[</span><span id="2b91" class="nl lt iq ny b gy og od l oe of">(df_users_churning_week['Nth_Week']==Nth_WEEK)</span><span id="22bf" class="nl lt iq ny b gy og od l oe of">]['user_id'].tolist()</span><span id="0886" class="nl lt iq ny b gy og od l oe of">list_to_append_leaving_users.append(df_cohort_churned_forever[<br/>        df_cohort_churned_forever['user_id'].isin(list_of_users_leaving_n_week)<br/>                             ].groupby(['Nth_Week'])['weekly_app_opens'].mean().reset_index().rename(<br/>        columns={'weekly_app_opens': '{} Users Leaving in Week {}'.format(<br/>            len(list_of_users_leaving_n_week), Nth_WEEK)}).set_index(['Nth_Week']))<br/>    <br/>df_churned_users_weekly_app_opens = pd.concat(list_to_append_leaving_users, sort=False, axis=1)</span><span id="2f5c" class="nl lt iq ny b gy og od l oe of">df_churned_users_weekly_app_opens.reset_index()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/c1f8eacfad1e89d36d05d0f1e155f414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HTmL_Jw0wtcCYadQ2D7K-A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="42f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，在第二周流失且从未恢复的用户是那些在第一周平均打开应用4.7次的用户。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/08af717f49b0cc55e3ab6a5aae6c9e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TzS7UJIT5s3Ve3jOj2a6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="2509" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3-结论</h1><p id="9cc1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果不增加用户的活跃度，公司也会想保持用户的活跃度。此外，如果有任何用户参与度可能下降的危险信号，他们希望通过观察趋势来了解这一点。在这篇文章中，我分享了一些Python和SQL代码，来演示如何从用户活动表中分析保留。</p><p id="51c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，创建了多个群组:</p><p id="59e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一次性群组(第2.e节，根据一段时间内的活动对用户进行分组)</p><p id="6c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2-行为群组(第2.f节，找到被搅得一蹶不振的用户)</p></div></div>    
</body>
</html>