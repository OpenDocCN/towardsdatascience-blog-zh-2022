<html>
<head>
<title>8 More Python Best Practices for Writing Industry-Standard Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写行业标准代码的8个Python最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/8-more-python-best-practices-for-writing-industry-standard-code-64d97f42da5e#2022-06-14">https://towardsdatascience.com/8-more-python-best-practices-for-writing-industry-standard-code-64d97f42da5e#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9169" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我进入软件行业后学到的一些Python最佳实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9a7f98503b8e2ed0b67a7447dbda78b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X7s2Wo3VgQBNPKl_bKhzbA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由来自<a class="ae kv" href="https://www.pexels.com/photo/woman-programming-on-a-notebook-1181359/" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kv" href="https://www.pexels.com/@divinetechygirl/" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜·莫里洛</a>拍摄</p></figure><p id="91d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近读了Anmol Tomar的一篇关于Python最佳实践的好文章<a class="ae kv" rel="noopener" target="_blank" href="/python-best-practices-for-writing-industry-standard-code-66b848783e0b">。它涉及简单而有效的最佳实践，可以提高您的代码质量。然后我觉得“嗯，我可以在Anmol的这个列表中再添加几个。”因此，我在这里，写这篇博客。在进入这个行业之前，我没有遵循这些最佳实践。但是在成为团队的一员后，我从我的同事那里学到了这些最佳实践，并希望我知道并尽早遵循这些小步骤。</a></p><p id="465b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“行业标准代码”听起来可能有些花哨。但它只不过是可读的、可重用的、可修改的代码。在工业界，我们在团队中工作。如果我在为一家公司工作时写了一些代码，我写的代码就归这家公司所有。一段时间后，一个完全不同的人，为同一家公司工作，应该能够阅读我的代码，理解它，对它进行改进，或者修复它的一个错误，或者将它与另一个软件集成。如果这是不可能的，软件业将不会超越个人。因此，只要你写的代码简单易懂，别人可以改进，你就是在写“行业标准代码”。</p><p id="1b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里列出的8个最佳实践是Anmol在他的文章<a class="ae kv" rel="noopener" target="_blank" href="/python-best-practices-for-writing-industry-standard-code-66b848783e0b">中提到的内容的补充。也一定要读一读。永远不会有“最佳实践”的详尽列表这些是我在这个行业学到的一些简单的方法，帮助我提高了我的编码水平，并在一个协作的环境中工作。所以永远不要把它当作一组有限的最佳实践。</a></p><h2 id="eda3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">1.不要在你的代码中使用随机值。将它们定义为常量。</h2><p id="a0a2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">比方说，您正在编写的这段代码有一行将质量(kg)转换为重量(N)。这是一个简单的一行程序，你必须将质量变量乘以9.8 ms⁻。所以我们倾向于写一行像下面这样的代码。</p><blockquote class="mq mr ms"><p id="879b" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">不良做法</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c9c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">技术上是正确的。但是当有人在没有上下文的情况下阅读你的代码时，他们会想为什么是9.8，它从哪里来。因此，将它定义为一个命名的常量并随后使用它总是好的。</p><blockquote class="mq mr ms"><p id="779e" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">良好实践</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7367" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python不像大多数其他语言那样有常量定义。因此我们把它定义为另一个变量。但是我们使用<code class="fe mz na nb nc b">ALL_CAPS</code>作为命名约定来表示它是一个常量。定义常量时，最好在源文件的顶部定义(在导入之后)。如果项目很大，并且许多源文件共享项目级常量，您可以在一个<code class="fe mz na nb nc b">constants.py</code>文件中定义所有常量，并根据需要将它们导入到所需的源文件中。</p><h2 id="397c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">2.使用动词作为函数和方法名</h2><p id="fa65" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这听起来可能不太重要，但请听我说完。假设你正在编写一个函数来计算一个给定数字的质因数。很可能我们倾向于这样定义函数:</p><blockquote class="mq mr ms"><p id="c215" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">不良做法</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后当调用函数并将其输出赋给一个变量时，我们会想知道该给这个变量取什么名字，因为<code class="fe mz na nb nc b">prime_factors</code>已经被占用了。如果我们想在函数中定义一个局部变量，情况也是如此。但是如果我们稍微思考一下，我们几乎总是写一个函数或方法来“做某事”。函数和方法对数据执行操作。因此，将您的函数和方法命名为<code class="fe mz na nb nc b">&lt;do&gt;_&lt;something&gt;</code>是一个好主意。在这个特殊的例子中，我更喜欢下面的函数名。</p><blockquote class="mq mr ms"><p id="1dca" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">良好实践</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我将使用<code class="fe mz na nb nc b">prime_factors</code>作为变量名来捕获函数调用的结果。</p><h2 id="7d5d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">3.根据访问范围要求将成员定义为私有或受保护</h2><p id="b824" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将类的属性和方法定义为私有或受保护不是Python的语言特性。但这可以通过一个普遍公约来实现。公开仅必要的属性和方法始终是最佳实践。其他的都应该保护类的私有成员。受保护的成员是可以从类及其子类中访问的属性和方法，而私有成员只能从类本身中访问。</p><p id="451a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Python中，以下约定用于定义受保护成员和私有成员。以单下划线<code class="fe mz na nb nc b">_</code>为前缀的成员受到保护，以双下划线<code class="fe mz na nb nc b">__</code>为前缀的成员是私有成员。</p><blockquote class="mq mr ms"><p id="c503" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">良好实践</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我上面提到的，在Python中这只是一个约定。我们仍然有办法接近这些成员。但好的程序员不会。这向可能扩展您的程序的后续程序员表明，这些属性和方法并不意味着可以从外部访问。</p><p id="7b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使您没有以面向对象的方式使用Python(因为大多数人都没有)，您仍然可以对不打算在其他地方导入的函数采用相同的约定。只需在这样的函数名前面加上下划线。这将表明该函数是文件的本地函数，不应该被导入到其他地方。</p><h2 id="4728" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">4.不要导入*</h2><p id="2083" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">过去我已经做过很多次了。当我想导入一些我在别处定义的组件时，我只需这样做:</p><blockquote class="mq mr ms"><p id="a342" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">不良做法</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="738d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们在代码中执行<code class="fe mz na nb nc b">import *</code>时，模块中的所有实体都将被导入到当前的名称空间中。这严重影响了代码的可读性。当您有两行这样的代码时，读者将会忘记您所使用的实体是从哪里导入的。更糟糕的是，这种导入可能会隐藏早期导入或本地定义中的名称。</p><p id="3b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在访问许多实体，最好的办法是导入整个包或模块。然后，您可以稍后以<code class="fe mz na nb nc b">&lt;module&gt;.&lt;class&gt;</code>的身份访问这些类或函数。如果只导入一两个组件，使用<code class="fe mz na nb nc b">from &lt;package&gt; import &lt;class&gt;</code>格式。但很少使用它。</p><blockquote class="mq mr ms"><p id="84b9" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">良好实践</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="dfe2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">5.使用代码格式化程序</h2><p id="82c4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果我说许多样式(格式)最佳实践可以被强制或自动应用到您的代码中，那会怎么样？是的，开始使用代码格式化程序或linter。在工业环境中，大多数组织都将linter作为CI(持续集成)管道的一部分。当您尝试将一些代码推送到组织的repo时，它将被自动标记，如果没有遵循任何规定的最佳实践，它将引发一个错误，阻止代码的合并。</p><p id="f5a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以还是开始用比较好。<a class="ae kv" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">布莱克</a>是一个很好的代码格式化程序。它可以帮助你按照PEP8标准的规定格式化你的代码。一些ide有内置的代码格式化程序，你可以通过一个简单的快捷方式来使用它。Linters不仅仅是代码格式化程序。它们是静态代码分析器。它们可以用来检查是否使用了正确的变量命名约定，检查错误等。Pylint 可以作为介绍棉绒的起点。</p><h2 id="6c1e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">6.编写单元测试</h2><p id="ef14" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这可能会非常耗时。但是，当在团队中工作或从事长期项目时，这是必不可少的。编写适当的单元测试使你的代码“标准化”。单元测试是一种机制，通过它可以测试源代码中各个逻辑单元的功能。您可以简单地隔离逻辑错误并防止它们向上传播。当在一个团队中工作时，这是必不可少的，因为如果一个功能上有缺陷的代码被合并，它会在与其他组件交互时导致错误。相信我，从长远来看，编写适当的单元测试实际上是节省时间的。Python内置的<a class="ae kv" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> unittest </a>库非常适合对你的python代码进行单元测试。</p><h2 id="4c09" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">7.记录错误</h2><p id="4ab9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">你的代码不是没有错误的。即使在林挺、单元测试、手工测试之后，偶尔在生产中失败的可能性也很高。相信我，没事的。这在业内是常有的事。重要的是你是否已经先发制人地采用了机制来捕捉哪里出了问题。只有当你有一个指向哪里出了问题的指针时，你才能修复错误。所以在代码中启用强制错误记录。这很简单——使用python <a class="ae kv" href="https://docs.python.org/3/library/logging.html" rel="noopener ugc nofollow" target="_blank">日志</a>。</p><blockquote class="mq mr ms"><p id="e67e" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated">良好实践</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还可以根据项目的需要使用警告、信息和调试级别的日志记录。请记住，日志文件是您的“黑匣子”，如果您的代码在生产中失败，您将不得不使用它进行“事后分析”。</p><h2 id="bebc" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">8.生成包含版本的requirements.txt文件</h2><p id="c516" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您在机器学习、数据科学或任何其他领域工作，并且这些领域的包在不断发展并获得重大更新，那么这就更容易理解了。您将创建一个虚拟环境，安装一些包并处理一个项目，然后交付。那你一段时间都不会碰这个项目。之后，你应该做一些改进。现在您尝试重新创建环境，您的代码很有可能会中断。嗯，原因是软件包经历更新，有时可能包含重大变更。</p><p id="8397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过遵循下面提到的最佳实践来简单地解决这个问题。</p><ol class=""><li id="a58c" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">每个项目都有单独的虚拟环境</li><li id="8897" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">为每个项目使用一个<code class="fe mz na nb nc b">requirements.txt</code>文件来跟踪已安装的包</li><li id="8e56" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">当跟踪软件包时，使用确切的软件包版本来跟踪它们。</li></ol><p id="b90d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三点很重要。如果您在repo中总是有工作包版本，那么每次您尝试重新创建环境时，都会安装该包的确切版本。因此，不会有任何突破性的变化。</p><p id="a8bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以手动跟踪您安装的软件包，或者如果您正在维护一个适当的最小环境，您可以使用下面的shell命令来自动生成文件。</p><pre class="kg kh ki kj gt nr nc ns nt aw nu bi"><span id="b9ed" class="ls lt iq nc b gy nv nw l nx ny">pip freeze &gt; requirements.txt</span></pre><blockquote class="mq mr ms"><p id="59e9" class="kw kx mt ky b kz la jr lb lc ld ju le mu lg lh li mv lk ll lm mw lo lp lq lr ij bi translated"><strong class="ky ir">编辑</strong>:正如<a class="nz oa ep" href="https://medium.com/u/37afeaaf9b9a?source=post_page-----64d97f42da5e--------------------------------" rel="noopener" target="_blank">塞萨尔·弗洛里斯</a>在评论中提到的，使用<code class="fe mz na nb nc b">pip freeze</code>可能会导致问题，因为它也会跟踪二级依赖关系。因此，手动跟踪包裹将是最好的选择。</p></blockquote><p id="2ac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要更多关于requirements.txt的信息，这里有一篇<a class="ae kv" href="https://learnpython.com/blog/python-requirements-file/" rel="noopener ugc nofollow" target="_blank">好文章</a>。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="397e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我进入软件行业后学到的8个基本Python最佳实践。我希望这篇文章对你有用。此外，如果您认为应该包括任何评论/更多最佳实践，请在评论部分提出。</p><h2 id="c190" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">参考</h2><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/python-best-practices-for-writing-industry-standard-code-66b848783e0b"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">编写行业标准代码的Python最佳实践</h2><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://www.tutorialsteacher.com/python/public-private-protected-modifiers" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Python中的公共、受保护、私有成员</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">经典的面向对象语言，如C++和Java，通过公共的、私有的…</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">www.tutorialsteacher.com</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://stackoverflow.com/questions/9916878/importing-modules-in-python-best-practice" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">在Python中导入模块-最佳实践</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">我是Python的新手，因为我想扩展我用R学到的技能。</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">stackoverflow.com</p></div></div><div class="ot l"><div class="pb l ov ow ox ot oy kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://github.com/psf/black" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">GitHub - psf/black:不妥协的Python代码格式化程序</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">“任何你喜欢的颜色。”Black是不折不扣的Python代码格式化程序。使用它，您同意放弃对…的控制权</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="pc l ov ow ox ot oy kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://pypi.org/project/pylint/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">皮林特</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">Pylint是Python 2或3的静态代码分析器。最新版本支持Python 3.7.2及以上版本。皮林特分析…</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">pypi.org</p></div></div><div class="ot l"><div class="pd l ov ow ox ot oy kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://docs.python.org/3/library/unittest.html" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">单元测试-单元测试框架- Python 3.10.5文档</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">源代码:Lib/unittest/__init__。py(如果你已经熟悉了测试的基本概念，你可能想…</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://docs.python.org/3/library/logging.html" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">日志记录-Python-Python 3 . 10 . 5文档的日志记录工具</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">源代码:Lib/logging/__init__。py这个模块定义了实现灵活事件记录的函数和类…</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://learnpython.com/blog/python-requirements-file/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">Python需求文件以及如何创建它</h2><div class="oz l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">Python需求文件是跟踪Python模块的好方法。这是一个简单的文本文件，保存一个…</h3></div><div class="os l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">learnpython.com</p></div></div><div class="ot l"><div class="pe l ov ow ox ot oy kp ol"/></div></div></a></div></div></div>    
</body>
</html>