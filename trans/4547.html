<html>
<head>
<title>Why Every Software Engineer Should Learn SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么每个软件工程师都应该学习SQL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-every-software-engineer-should-learn-sql-ae3d7192a8d9#2022-10-08">https://towardsdatascience.com/why-every-software-engineer-should-learn-sql-ae3d7192a8d9#2022-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="daf7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过合理利用数据库来加速你的程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/899e6866a38cfe79e5cd29fa23213186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FzbdE1JZPzKdSi3Y"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">托比亚斯·菲舍尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d9b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎每个软件应用程序都依赖于将数据存储在可访问的地方。对于小的脚本和程序，这通常是在计算机的内存中，或者有时只是作为本地磁盘上的纯文本或二进制文件。</p><p id="abf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，较大的应用程序几乎肯定会使用存在于程序本身外部的数据库，而目前最流行的数据库技术是关系数据库。大多数关系数据库都可以使用结构化查询语言(SQL)进行查询，因此对于软件工程师来说，除了对SQL有基本的了解之外，还必须编写与数据库交互的高效代码。</p><p id="c95d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在想“哦，但是我已经知道如何从我的数据库中选择数据，肯定不会比这难太多”，再想想吧！我见过很多代码使用一个<code class="fe ls lt lu lv b">for</code>循环来完成一项任务，而使用SQL <code class="fe ls lt lu lv b">JOIN</code>子句可以更快更简单地完成这项任务。</p><p id="aab1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将使用一个非常基本的例子来展示正确使用SQL的强大功能。本文的代码是用Python编写的，使用的是<a class="ae kv" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a> ORM库，但是我将包括程序打算模拟的原始SQL，以便更加与语言无关。</p><p id="0f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然示例和测试看起来很简单，但这是根据我在生产中看到的真实代码改编的，所以请注意！</p><p id="0898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TL；DR:SQL<code class="fe ls lt lu lv b">JOIN</code>实现要快得多。</p><h1 id="ed62" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">这个例子</h1><p id="730e" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我将使用的例子是一个在线商店。该数据库将包含一个<code class="fe ls lt lu lv b">users</code>表和一个<code class="fe ls lt lu lv b">orders</code>表，其中将存储网站用户的信息以及这些用户下的任何订单。每个表都有一个ID列，而<code class="fe ls lt lu lv b">orders</code>表包含一个<code class="fe ls lt lu lv b">user_id</code>列，该列包含一个引用<code class="fe ls lt lu lv b">users</code>表的外键。</p><h2 id="6662" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">计算机编程语言</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="2ceb" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">结构化查询语言</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="c5ac" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">测试设置</h1><p id="1a0a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">如您所见，每个<code class="fe ls lt lu lv b">order</code>都有一个<code class="fe ls lt lu lv b">payment_status</code>列，其中包含一个布尔值，表示订单是否成功支付。目的是测试一个函数，该函数找到至少有一个失败订单的用户，并返回一组描述这些用户的<code class="fe ls lt lu lv b">User</code>对象。</p><p id="fcdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试将在本地dockerised MySQL数据库上运行，该数据库使用以下<code class="fe ls lt lu lv b">docker-compose.yml</code>文件创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该数据库将预加载一些使用Python <code class="fe ls lt lu lv b">faker</code>库生成的用户和订单。该测试将针对10、100和1000个用户和订单的每种组合运行，并使用Python <code class="fe ls lt lu lv b">timeit</code>库对100多次迭代进行计时。</p><p id="06b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免数据库缓存使用的不一致性，每个查询都将带有前缀<code class="fe ls lt lu lv b">SQL_NO_CACHE</code>标志。</p><p id="3233" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将有两个测试函数。我们将使用一个简单的Python实现，包括查询失败的订单，然后遍历结果，并在每次迭代中对<code class="fe ls lt lu lv b">users</code>表运行select语句，以生成一组至少包含一个失败订单的<code class="fe ls lt lu lv b">User</code>对象。第二个实现将使用SQL <code class="fe ls lt lu lv b">JOIN</code>和<code class="fe ls lt lu lv b">DISTINCT</code>在单个查询中生成同一组用户。</p><p id="33a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数的代码如下所示。</p><h2 id="be73" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">计算机编程语言</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="54b6" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">结构化查询语言</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="c7a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从代码中可以清楚地看出，使用SQL <code class="fe ls lt lu lv b">JOIN </code>的实现将只进行一次数据库查询，而更简单的Python实现将进行最少1次最多N次查询，其中N是<code class="fe ls lt lu lv b">orders</code>表中的行数。</p><h1 id="18e4" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结果呢</h1><p id="5091" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">毫不奇怪，该函数的纯SQL实现比依赖Python <code class="fe ls lt lu lv b">for</code>循环的实现要快得多。</p><p id="e80f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在10个用户和10个订单的情况下，Python函数在5.97毫秒内完成，而SQL实现只花了1.04毫秒。随着<code class="fe ls lt lu lv b">orders</code>表中行数的增加，运行时间也增加了，但Python的情况开始变得糟糕。</p><p id="469e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在10个用户和1000个订单的情况下，SQL实现仍然保持在1.28毫秒，而Python实现每次测试花费了458.49毫秒！当然，这是因为SQL实现只进行了一次数据库调用，而Python实现进行了大约500次调用。</p><p id="a1f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有趣的是，就运行时而言，<code class="fe ls lt lu lv b">users</code>列中的行数对Python实现的影响很小，但对SQL实现的影响较大。这可能是因为MySQL服务器需要做更多的工作来在更大的列表中查找<code class="fe ls lt lu lv b">DISTINCT</code>用户，而Python版本是逐个用户地构建<code class="fe ls lt lu lv b">set</code>对象。</p><p id="2d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的结果可以在下面看到，还有一些图表显示了每个函数的性能如何随数据库中的行数而变化。</p><h2 id="b4b7" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">基准输出</h2><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="8a6b" class="mu ly iq lv b gy nm nn l no np">n_users: 10, n_orders: 10<br/>Python: 5.97ms, SQL: 1.04ms</span><span id="fec7" class="mu ly iq lv b gy nq nn l no np">n_users: 10, n_orders: 100<br/>Python: 46.22ms, SQL: 1.22ms</span><span id="94a5" class="mu ly iq lv b gy nq nn l no np">n_users: 10, n_orders: 1,000<br/>Python: 458.49ms, SQL: 1.28ms</span><span id="fc4a" class="mu ly iq lv b gy nq nn l no np">n_users: 100, n_orders: 10<br/>Python: 4.85ms, SQL: 0.96ms</span><span id="7569" class="mu ly iq lv b gy nq nn l no np">n_users: 100, n_orders: 100<br/>Python: 48.08ms, SQL: 1.40ms</span><span id="4e7f" class="mu ly iq lv b gy nq nn l no np">n_users: 100, n_orders: 1,000<br/>Python: 441.89ms, SQL: 2.53ms</span><span id="3f26" class="mu ly iq lv b gy nq nn l no np">n_users: 1,000, n_orders: 10<br/>Python: 4.97ms, SQL: 1.04ms</span><span id="c02c" class="mu ly iq lv b gy nq nn l no np">n_users: 1,000, n_orders: 100<br/>Python: 46.54ms, SQL: 1.57ms</span><span id="57a6" class="mu ly iq lv b gy nq nn l no np">n_users: 1,000, n_orders: 1,000<br/>Python: 451.37ms, SQL: 5.75ms</span></pre><h2 id="c65e" class="mu ly iq bd lz mv mw dn md mx my dp mh lf mz na mj lj nb nc ml ln nd ne mn nf bi translated">图表</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/ff06035e48c56e97ff814637027da8f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*AkBfdG-9ovwj2Gu_384a_g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/6c6fe09e7372b1a61e85e0f01173b616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*bBYehUms4xDx1vAtg4Hh7g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/a8c769c6e7e2a64d2201f89d899e4773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*-_f5IctP4aIodXUV8NEt4g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f8e3ee6d7d63874fa029db18b5745546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*6F0If7IiMxEApqlvwYdVIQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="3ca3" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="fcbc" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">虽然上述两种实现都可以被优化以获得更高的性能，但是SQL实现每次都会胜出。最棒的是，用的SQL其实很简单，谁都可以学！</p><p id="2e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网上有很多学习SQL的免费资源，所以如果你是一名软件工程师或者有抱负的人，就去那里开始学习吧！好处将是巨大的。</p><p id="c3b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您喜欢这篇文章，您可能也会喜欢我的关于我的Python库<code class="fe ls lt lu lv b">quiffen</code>的文章，这个库用于解析来自<code class="fe ls lt lu lv b">QIF</code>文件的金融信息:</p><div class="ns nt gp gr nu nv"><a rel="noopener follow" target="_blank" href="/parsing-qif-files-to-retrieve-financial-data-with-python-f599cc0d8c03"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">使用Python解析QIF文件以检索金融数据</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">Quiffen包的基本概述以及它如此有用的原因</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">towardsdatascience.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><p id="4523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我也可以在<a class="ae kv" href="http://isaacharrisholt.com/newsletter" rel="noopener ugc nofollow" target="_blank">我的博客</a>，在<a class="ae kv" href="https://twitter.com/IsaacHarrisHolt" rel="noopener ugc nofollow" target="_blank">推特</a>和<a class="ae kv" href="https://www.linkedin.com/in/isaac-harris-holt/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我，所以如果你有任何问题，请随时聊天！</p><p id="9580" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">-艾萨克</p><p id="b096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，我在下面列出了我运行的基准测试的完整代码，所以你可以自己尝试一下！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div></div>    
</body>
</html>