<html>
<head>
<title>Step by Step Identity Resolution With Python And Zingg</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 和 Zingg 逐步进行身份解析</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/step-by-step-identity-resolution-with-python-and-zingg-e0895b369c50#2022-11-22">https://towardsdatascience.com/step-by-step-identity-resolution-with-python-and-zingg-e0895b369c50#2022-11-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="de4c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种基于机器学习的开源方法，用于大规模解析身份</h2></div><p id="960c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从数据中生成有用见解的主要挑战之一是孤立和脱节的数据集，这些数据集的数据质量很差。由于企业数据管道中的多个信息源，经常会引入数据不一致和重复记录。对于从事欺诈检测、个性化和推荐的数据科学家来说，这是一个巨大的问题。对于数据分析师来说，由于基础数据不一致，很难报告准确的客户终身价值、最有价值客户、新增客户和其他指标。</p><p id="e016" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，看看下面的客户数据</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1e9dad14297bb41db99335a7bf22c666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEpQkRagQ36js58G2R4xgg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">多条记录属于同一客户且没有唯一标识符的客户数据。作者图片</p></figure><p id="238b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到同一客户有多行，如下所示</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a9f67a94252a874572edbd4816222994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHWQpo2Wg9yUiDwAxpawQg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">同一客户的不同记录。作者图片</p></figure><p id="cc5c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个 ssn 列，但是不能保证它总是唯一的。在上面的示例中，第二条记录的 ssn 与其他记录不一致。然而，快速人工验证确认这 3 个记录属于同一个客户。</p><p id="3c42" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是属于同一个客户的不同记录的另一个例子。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/f3f6f3eaae8fcd90064d27517d6aa739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F0Yn6yANmqW_HrmJZJi-ug.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="a4bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义跨属性的规则并将它们组合起来以评估匹配的记录既耗时又容易出错。建立这样一个系统很容易需要几个月的时间，并延迟实际的分析。试图利用数据列大规模执行身份解析也不容易。</p><p id="1d66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总体而言，构建身份解析系统面临以下挑战</p><ol class=""><li id="8607" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated">随着记录数量的增加，查找重复项所需的比较总数变得难以管理。我们对一个属性的 N 个记录进行比较的总数由下式给出</li></ol><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/fcd7fe2aa28de3f7a344306dc911c58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*CSewOrNhASnByRrxkDFuBw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="27e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我们的数据集大小 N 的增加，比较的数量会迅速增加</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/aea6274a2b7be6bcd699c143c3d31666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*i0T1ub8E71N2Br5o8yc1-w.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">缩放身份分辨率。作者图片</p></figure><p id="3be2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.理解使用哪些属性来识别重复项并为具有许多属性和变化的大型数据集决定匹配标准是很困难的。</p><p id="0732" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构建身份解析系统时，通常包括以下步骤</p><ul class=""><li id="e465" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la mc lx ly lz bi translated">预处理:尽可能规范化数据，例如去掉常见的单词，去掉前导和尾随空格，使属性变成小写或大写，清理标点符号等。这样做是为了我们可以定义特定于属性的匹配规则。</li><li id="3d9f" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">索引:由于将每个记录与其他记录进行比较会显示出可伸缩性问题，所以我们将数据集分成更小的块，然后在块内执行比较。这减少了处理，并且将系统扩展到更大的数据量变得容易得多。</li><li id="de87" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">属性级规则定义:根据标准比较相关属性，例如，当且仅当电子邮件完全匹配时，我们才会认为两条记录的电子邮件属性相似。</li><li id="53f0" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">记录级规则定义:上面定义的属性级比较被汇总到记录级相似性的组合定义中。例如，名字和姓氏匹配，但电子邮件不完全匹配。</li><li id="4dbb" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">组相似性:如果两个记录分别与第三个记录匹配，但彼此不匹配，可能是由于缺少属性，我们如何处理这种情况？</li></ul><p id="72f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们自己建造这个当然是可行的，但是值得我们花费时间吗？让我们探索一个开源选项— <a class="ae mi" href="https://github.com/zinggAI/zingg" rel="noopener ugc nofollow" target="_blank"> Zingg </a>。我们将使用<a class="ae mi" href="https://readthedocs.org/projects/zingg/" rel="noopener ugc nofollow" target="_blank"> Zingg 的 Python api </a>，为我们的客户数据构建一个身份解析管道。</p><p id="5382" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个基于 ML 的工具，Zingg 负责上述步骤，以便我们可以大规模地执行身份解析。</p><p id="d474" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了执行实体解析，Zingg 定义了五个阶段——findTrainingData、标签、训练、匹配和链接。</p><ol class=""><li id="166c" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la lw lx ly lz bi translated"><strong class="kh ir"> findTrainingData </strong>:作为一个有监督的机器学习系统，Zingg 从训练数据中学习匹配。findTrainingData 阶段从我们的数据中选择样本对，用户可以通过这些样本对建立训练集。</li><li id="1e42" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la lw lx ly lz bi translated"><strong class="kh ir"> label </strong>:这个阶段调出交互式标签，显示在 findTrainingData 中选择的对。标签器提示用户将它们标记为匹配或非匹配。如果用户不确定或不能决定，用户可以选择不确定作为选项。</li><li id="14b5" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la lw lx ly lz bi translated"><strong class="kh ir">训练</strong>:使用标记的数据，Zingg 学习相似性规则以识别潜在的重复。Zingg 不会将数据集中的每条记录与数据集中的每条其他记录进行比较，这将导致大型数据集的可伸缩性问题。相反，Zingg 首先学习如何将相似的记录组合成块。它还根据训练集学习合适的相似性规则，从而减少所需的比较总数。模型被保存到磁盘上，以供较新的数据使用。</li><li id="4a17" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la lw lx ly lz bi translated"><strong class="kh ir">匹配</strong>:应用经过训练的模型来预测可用于解析身份的匹配分数。</li><li id="069d" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la lw lx ly lz bi translated"><strong class="kh ir">链接</strong>:跨数据集查找匹配</li></ol><p id="567e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> findTrainingData </strong>和<strong class="kh ir"> label </strong>阶段通常运行几次，样品由用户标记。Zingg 通过<strong class="kh ir"> findTrainingData </strong>仔细选择不匹配、明显匹配和边缘案例样本，以建立一个具有足够变化的健壮训练集来训练模型。</p><p id="957e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们有了大约 30-40 个匹配样本，我们就可以通过运行<strong class="kh ir">训练</strong>阶段来训练和保存模型。一旦模型被训练，随着具有相同属性的新数据集的到来，可以执行<strong class="kh ir">匹配</strong>或<strong class="kh ir">链接</strong>阶段。</p><p id="e90a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对客户<strong class="kh ir"> </strong>数据使用 Zingg 并解析身份。</p><h1 id="e893" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">步骤 1:安装 Zingg</h1><p id="7a85" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">开始使用 Zingg 的最快方法是使用 Zingg docker 映像。让我们获得 docker 图像并开始使用它。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="8267" class="nl mk iq nh b be nm nn l no np">docker pull zingg/zingg:0.3.4<br/>docker run -u &lt;uid&gt; -it zingg/zingg:0.3.4 bash</span></pre><p id="4ef6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有关使用 Zingg docker 的更多信息，请点击此处的<a class="ae mi" href="https://docs.zingg.ai/zingg/stepbystep/installation/docker" rel="noopener ugc nofollow" target="_blank">链接查看官方文档。</a></p><p id="8fbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用<a class="ae mi" href="https://github.com/zinggAI/zingg/tree/main/examples/febrl" rel="noopener ugc nofollow" target="_blank"> febrl 示例</a>加载到 Postgres 中名为<strong class="kh ir"> customers </strong>的表中。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nq"><img src="../Images/77ca34c8a9e9af53fe8eb21b253c7ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6uUE1I1d5o36W0KUzD5YQ.png"/></div></div></figure><h1 id="a132" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">步骤 2:定义输入位置和匹配条件</h1><p id="58bb" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">Zingg python 包已经安装在 docker 容器中，所以我们将直接使用它。需要记住的重要一点是，Zingg Python 程序是 PySpark 程序，必须使用 Zingg 发行版提供的 zingg.sh 脚本运行。</p><p id="2ea2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为我们的<strong class="kh ir">客户</strong>表定义输入。我们创建一个名为 FebrlExamplePostgresql.py 的 Python 脚本，并导入必要的包</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="3294" class="nl mk iq nh b be nm nn l no np">from zingg.client import *<br/>from zingg.pipes import *</span></pre><p id="f31a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们希望用作输出一部分的每一列，我们创建一个 FieldDefinition 对象。FieldDefinition 接受属性的名称、数据类型和匹配类型。例如，我们可以这样定义名字列</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="785d" class="nl mk iq nh b be nm nn l no np">fname = FieldDefinition("fname", "string", MatchType.FUZZY)</span></pre><p id="d9f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">匹配类型配置 Zingg 关于我们希望如何为每个字段执行匹配。Zingg 提供了不同的匹配标准，其中一些是</p><ul class=""><li id="f6f6" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la mc lx ly lz bi translated">模糊:与缩写、错别字和其他变体的广义匹配，适用于名称等字段</li><li id="3997" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">精确:不允许有变化，适用于国家代码等字段</li><li id="2f1d" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">DONT _ 使用:具有这种匹配类型的字段在处理过程中被忽略，但会出现在输出中</li></ul><p id="932e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据我们的列数据文档<a class="ae mi" href="https://docs.zingg.ai/zingg/stepbystep/configuration/field-definitions" rel="noopener ugc nofollow" target="_blank">这里的</a>，我们可以使用更多的匹配类型。</p><p id="a395" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下 Python 程序为 Zingg 构建参数，并向其中添加所有字段定义。</p><pre class="lc ld le lf gt ng nh nr ns aw nt bi"><span id="e271" class="nu mk iq nh b gy nv nw l nx np">#build the arguments for zingg<br/>args = Arguments()</span><span id="ddd5" class="nu mk iq nh b gy ny nw l nx np">#set field definitions<br/>fname = FieldDefinition("fname", "string", MatchType.FUZZY)<br/>lname = FieldDefinition("lname", "string", MatchType.FUZZY)<br/>streetnumber = FieldDefinition("streetnumber", "string", MatchType.FUZZY)<br/>street = FieldDefinition("street","string", MatchType.FUZZY)<br/>address = FieldDefinition("address", "string", MatchType.FUZZY)<br/>locality = FieldDefinition("locality", "string", MatchType.FUZZY)<br/>areacode = FieldDefinition("areacode", "string", MatchType.FUZZY)<br/>state = FieldDefinition("state", "string", MatchType.FUZZY)<br/>dateofbirth = FieldDefinition("dateofbirth", "string", MatchType.FUZZY)<br/>ssn = FieldDefinition("ssn", "string", MatchType.FUZZY)</span><span id="e88f" class="nu mk iq nh b gy ny nw l nx np">fieldDefs = [fname, lname, streetnumber, street, address, locality, areacode<br/>state, dateofbirth, ssn]</span><span id="5049" class="nu mk iq nh b gy ny nw l nx np">args.setFieldDefinition(fieldDefs)</span></pre><h1 id="5ee9" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">第三步:用 Postgres 连接 Zingg</h1><p id="77bb" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">Zingg 允许我们使用相关的配置为每种类型的数据平台连接到各种数据源和接收器，如<a class="ae mi" href="https://docs.zingg.ai/zingg/connectors" rel="noopener ugc nofollow" target="_blank">文档</a>中所述。Zingg 的 Python API 提供了一个通用管道，通过它我们可以定义管道的数据源和接收器。</p><p id="2dfd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将 Zingg 与 Postgres 中的<strong class="kh ir"> customers </strong>表连接起来，我们创建了一个管道对象，并将其命名为 customerDataStaging。我们将格式设置为 jdbc。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="c2f6" class="nl mk iq nh b be nm nn l no np">customerDataStaging = Pipe("customerDataStaging", "jdbc")</span></pre><p id="3af9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定管道的属性来连接我们的 Postgres 数据库。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="0466" class="nl mk iq nh b be nm nn l no np">customerDataStaging.addProperty("url","jdbc:postgresql://localhost:5432/postgres")<br/>customerDataStaging.addProperty("dbtable", "customers")<br/>customerDataStaging.addProperty("driver", "org.postgresql.Driver")<br/>customerDataStaging.addProperty("user","suchandra")<br/>customerDataStaging.addProperty("password","1234")</span></pre><p id="2a55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将我们的输出写到<strong class="kh ir"> customers_unified </strong>表中，我们创建了另一个具有相关属性的管道对象。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="818e" class="nl mk iq nh b be nm nn l no np">customerIdentitiesResolved = Pipe("customerIdentitiesResolved", "jdbc")<br/>customerIdentitiesResolved.addProperty("url","jdbc:postgresql://localhost:5432/postgres")<br/>customerIdentitiesResolved.addProperty("dbtable", "customers_unified")<br/>customerIdentitiesResolved.addProperty("driver", "org.postgresql.Driver")<br/>customerIdentitiesResolved.addProperty("user","suchandra")<br/>customerIdentitiesResolved.addProperty("password","1234")</span></pre><p id="df6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要 Zingg 的 JDBC 驱动程序来连接 Postgres。让我们<a class="ae mi" href="https://jdbc.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank">下载</a>Postgres JDBC 驱动程序，并将驱动程序的路径添加到 zingg.conf 的 spark.jars 属性中，如这里<a class="ae mi" href="https://docs.zingg.ai/zingg/stepbystep/zingg-runtime-properties" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><h1 id="84d2" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">步骤 4:查找要标记的对—查找训练数据</h1><p id="793f" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">我们已经定义了输入模式以及输入和输出数据源和接收器。现在让我们指定存储模型和模型标识符的目录。我们还指定数据集的一部分用于选择标记数据，以便可以快速创建我们的训练数据。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="f524" class="nl mk iq nh b be nm nn l no np">args.setZinggDir("models")<br/>args.setModelId("customer360")<br/>args.setNumPartitions(4)<br/>args.setLabelDataSampleSize(0.5)</span></pre><p id="ab91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们调用 Zingg 客户端并指定适当的<phase_name>，它可能是<strong class="kh ir"> findTrainingData </strong>、<strong class="kh ir"> label </strong>、<strong class="kh ir"> train </strong>或<strong class="kh ir"> match </strong>。我们将阶段名作为命令行的输入。</phase_name></p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="ad60" class="nl mk iq nh b be nm nn l no np">options = ClientOptions([ClientOptions.PHASE,&lt;PHASE_NAME&gt;])<br/>#Zingg execution for the given phase<br/>zingg = Zingg(args, options)<br/>zingg.initAndExecute()</span></pre><p id="6532" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是完整的代码</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="d442" class="nl mk iq nh b be nm nn l no np">from zingg.client import *<br/>from zingg.pipes import *<br/>import sys<br/>#build the arguments for zingg<br/>args = Arguments()<br/>#phase name to be passed as a command line argument<br/>phase_name = sys.argv[1]<br/>#set field definitions<br/>fname = FieldDefinition("fname", "string", MatchType.FUZZY)<br/>lname = FieldDefinition("lname", "string", MatchType.FUZZY)<br/>streetnumber = FieldDefinition("streetnumber", "string", MatchType.FUZZY)<br/>street = FieldDefinition("street","string", MatchType.FUZZY)<br/>address = FieldDefinition("address", "string", MatchType.FUZZY)<br/>locality = FieldDefinition("locality", "string", MatchType.FUZZY)<br/>areacode = FieldDefinition("areacode", "string", MatchType.FUZZY)<br/>state = FieldDefinition("state", "string", MatchType.FUZZY)<br/>dateofbirth = FieldDefinition("dateofbirth", "string", MatchType.FUZZY)<br/>ssn = FieldDefinition("ssn", "string", MatchType.FUZZY)<br/>fieldDefs = [fname, lname, streetnumber, street, address, locality, areacode<br/>state, dateofbirth, ssn]<br/>#add field definitions to Zingg Client arguments<br/>args.setFieldDefinition(fieldDefs)<br/>#defining input pipe<br/>customerDataStaging = Pipe("customerDataStaging", "jdbc")<br/>customerDataStaging.addProperty("url","jdbc:postgresql://localhost:5432/postgres")<br/>customerDataStaging.addProperty("dbtable", "customers")<br/>customerDataStaging.addProperty("driver", "org.postgresql.Driver")<br/>customerDataStaging.addProperty("user","suchandra")<br/>customerDataStaging.addProperty("password","1234")<br/>#add input pipe to arguments for Zingg client<br/>args.setData(customerDataStaging)<br/>#defining output pipe<br/>customerIdentitiesResolved = Pipe("customerIdentitiesResolved", "jdbc")<br/>customerIdentitiesResolved.addProperty("url","jdbc:postgresql://localhost:5432/postgres")<br/>customerIdentitiesResolved.addProperty("dbtable", "customers_unified")<br/>customerIdentitiesResolved.addProperty("driver", "org.postgresql.Driver")<br/>customerIdentitiesResolved.addProperty("user","suchandra")<br/>customerIdentitiesResolved.addProperty("password","1234")<br/>#add output pipe to arguments for Zingg client<br/>args.setOutput(customerIdentitiesResolved)<br/>#save latest model in directory models/599<br/>args.setModelId("customer360")<br/>#store all models in directory models/<br/>args.setZinggDir("models")<br/>#sample size for selecting data for labelling<br/>args.setNumPartitions(4)<br/>#fraction of total dataset to select data for labelling<br/>args.setLabelDataSampleSize(0.5)<br/>options = ClientOptions([ClientOptions.PHASE,phase_name])<br/>#Zingg execution for the given phase<br/>zingg = Zingg(args, options)<br/>zingg.initAndExecute()</span></pre><p id="49c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用 Zingg 命令行运行我们的客户身份解析 Python 程序。如前所述，我们将使用 Zingg 脚本来处理所有的依赖关系。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="c7b2" class="nl mk iq nh b be nm nn l no np">zingg.sh <br/>--properties-file /zingg-0.3.4-SNAPSHOT/config/zingg.conf<br/>--run /zingg-0.3.4-SNAPSHOT/examples/febrl/CustomerIdentityResolution.py findTrainingData</span></pre><p id="ae5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是在<strong class="kh ir"> findTrainingData </strong>阶段的一些输出日志。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nz"><img src="../Images/101f36e449bd3c3c55b68fb70cf1083e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkElRDKexjJS-nRdoSXv3A.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">对客户数据进行采样，以找到潜在的配对来显示给用户。作者图片</p></figure><h1 id="5119" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">步骤 5:将记录标记为匹配或非匹配，以构建训练集</h1><p id="452a" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">我们现在可以运行 Zingg <strong class="kh ir"> label </strong>阶段，并标记程序先前选择的记录。</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="ce96" class="nl mk iq nh b be nm nn l no np">zingg.sh <br/>--properties-file /zingg-0.3.4-SNAPSHOT/config/zingg.conf<br/>--run /zingg-0.3.4-SNAPSHOT/examples/febrl/CustomerIdentityResolution.py label</span></pre><p id="4582" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到了成对的记录</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oa"><img src="../Images/c0d0d266911fccc1fa11c49d291e548d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHg-ujHPOaJD5ckK3liIMA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">通过用户对选择样本的反馈来建立用于身份解析的训练集。作者图片</p></figure><p id="cdf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要指定它们是否匹配、不匹配或者我们不确定它们是否匹配。上述记录看起来不匹配，因此我们将其标记为 0</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ob"><img src="../Images/b47fe08bbd9677e4e4fa1503004548cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nuYmle0vZCtrpv7PkOEWaA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">训练 Zingg 进行身份解析。作者图片</p></figure><p id="f863" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，这些记录看起来非常相似，因此我们将它们标记为 1</p><p id="3594" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一对我们该怎么办？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oc"><img src="../Images/a346936e571e62700f76c592900c6bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AGsuwx6zpwFRhH3a5vxIgw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">用 Zingg 进行模糊匹配。作者图片</p></figure><p id="e268" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不太可能有两个不同的人住在同一个地方，同一个地区，有相同的出生日期和社会安全号，这两个记录可能是同一个人的姓氏输入不正确，但是也可能是不同的人。对于我们不确定的情况，我们将其标记为 2。</p><h1 id="7e2c" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">步骤 6:运行 Zingg Python 阶段——训练</h1><p id="13ce" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">由于我们的数据集很小，一轮 findTrainingData 和 label 就足够了。所以现在，我们可以通过跑步来建立我们的模型</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="2087" class="nl mk iq nh b be nm nn l no np">zingg.sh <br/>--properties-file /zingg-0.3.4-SNAPSHOT/config/zingg.conf<br/>--run /zingg-0.3.4-SNAPSHOT/examples/febrl/CustomerIdentityResolution.py train</span></pre><p id="5f89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">训练和交叉验证参数打印在屏幕上。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/24aa31d26e3d9124b8bf440858343491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0SeIwpeUwR2LHkH6xvMrw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">用于身份解析的训练机器学习模型。作者图片</p></figure><h1 id="4c7b" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">步骤 7:准备好解析身份！</h1><p id="9d6f" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">Zingg 模特都准备好了，来配吧</p><pre class="lc ld le lf gt ng nh ni bn nj nk bi"><span id="63d6" class="nl mk iq nh b be nm nn l no np">zingg.sh <br/>--properties-file /zingg-0.3.4-SNAPSHOT/config/zingg.conf<br/>--run /zingg-0.3.4-SNAPSHOT/examples/febrl/CustomerIdentityResolution.py match</span></pre><p id="2bee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，Zingg 将输出写入我们在 Python 程序中指定的表中。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oe"><img src="../Images/59cf73c912ff8ae4f35eb389a256aa4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmDWNhYuykCba5b722GMzA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">Zingg 的客户身份解析。作者图片</p></figure><p id="f6e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Zingg 添加了 3 个新列</p><ul class=""><li id="72c6" class="lr ls iq kh b ki kj kl km ko lt ks lu kw lv la mc lx ly lz bi translated">Z_CLUSTER —由 Zingg 分配的唯一 ID，具有相同分类的所有记录都匹配或重复。</li><li id="252d" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">Z_MINSCORE —它表示与该分类中任何其他记录最不匹配的记录</li><li id="41cc" class="lr ls iq kh b ki md kl me ko mf ks mg kw mh la mc lx ly lz bi translated">Z_MAXSCORE —它表示该记录与该分类中任何其他记录匹配的最大值</li></ul><p id="a3d8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些列并应用合适的阈值，我们可以解析身份。我们还可以从注释者那里获得人工评审。</p><p id="f589" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看 Zingg 如何解释我们之前看到的 eglinton 和 jaiden rollins 的重复记录。</p><p id="8324" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以集群 15 为例</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi of"><img src="../Images/2610c82c6e03cea09dbd30b4b0d7a6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*12rREgVgrAjx9ACNDaU9pQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">客户记录匹配。作者图片</p></figure><p id="329c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有 3 个完全匹配的记录，应该被解析到同一个客户。每个记录显示大于 0.95 的最大和最小分数，这意味着每个记录具有大于 0.95 的最大匹配以及相同聚类内的最小匹配也大于 0.95。我们可以将阈值设置为 0.95，并自动将高于该阈值的记录标记为确定匹配，无需人工干预。</p><p id="b72c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，聚类 37 显示了明显的匹配记录</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi og"><img src="../Images/9ec595fca68365dbee8765216cfc8680.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HCcCcMEeMvQmUhq7nRfE5g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">用 Zingg 匹配客户。作者图片</p></figure><p id="9003" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看第 20 组</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi oh"><img src="../Images/22c2307f374b85035900885e961d4ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrjsOLnYw5xB3J1TFnAwJA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">身份解析的人工审查和数据管理。作者图片</p></figure><p id="414d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这显示分数低于我们选择的阈值，因此我们将把它传递给人类进行审查。</p><p id="0fce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">身份解析是构建我们的数据平台和产品的关键步骤。它使我们能够了解谁是我们的核心业务实体。作为一个用于身份解析的定制工具，Zingg 抽象出了构建模糊记录匹配系统的复杂性和工作量。Zingg 负责数据预处理、属性和记录级别的相似性定义和可伸缩性。因此，我们可以将客户、供应商、供应品、产品和零件数据用于关键业务分析和运营，而不必担心信息缺失或不完整。</p></div></div>    
</body>
</html>