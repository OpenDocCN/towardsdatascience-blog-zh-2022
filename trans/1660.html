<html>
<head>
<title>3D Point Cloud Clustering Tutorial with K-means and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K-means和Python的三维点云聚类教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3d-point-cloud-clustering-tutorial-with-k-means-and-python-c870089f3af8#2022-04-20">https://towardsdatascience.com/3d-point-cloud-clustering-tutorial-with-k-means-and-python-c870089f3af8#2022-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="004d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/hands-on-tutorials" rel="noopener" target="_blank">实践教程</a>，3D Python</h2><div class=""/><div class=""><h2 id="a9cb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">创建3D语义分割数据集的完整python实践指南。了解如何使用K-Means聚类通过无监督分割来转换未标记的点云数据。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/75026f0e64e2d24e02bb1b505a49648e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/1*PftKKNVjX1uYFiJ3HHXzLA.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">来自航空激光雷达数据的机场的3D点云无监督分割。聚类方案组合的示例，如K-Means聚类。F. Poux</p></figure><p id="19a9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你正在寻找一个语义分割的(监督的)深度学习算法——关键词警报😁—你肯定发现自己在寻找一些高质量的标签+大量的数据点。</p><p id="6cdd" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在我们的3D数据世界中，3D点云的未标记特性使得回答这两个标准特别具有挑战性:没有任何好的训练集，很难“训练”任何预测模型。</p><p id="9e58" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们是否应该探索python技巧，并将其添加到我们的“箭筒”中，以快速生成出色的3D标注点云数据集？</p><p id="3863" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">让我们开始吧！🤿</p><h1 id="8dc3" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">无监督工作流聚类前言</h1><blockquote class="mr ms mt"><p id="0705" class="ld le mu lf b lg lh kd li lj lk kg ll mv ln lo lp mw lr ls lt mx lv lw lx ly im bi translated">为什么无监督的分割和聚类是“人工智能的主体”？</p></blockquote><p id="c147" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">通过监督系统的深度学习(DL)非常有用。在过去的几年里，DL架构深刻地改变了技术领域。然而，如果我们想要创造出出色的机器，深度学习将需要一次质的更新——拒绝“越大越好”的概念。今天有几种方法可以达到这个里程碑，最重要的是，无人监督或自我监督的方向是游戏规则的改变者。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ffd5f71d97b6f20548d083a015c609fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*XfSt9dHtzjYVz9_4eW9XPg.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">点云不同细节层次的聚类策略。F. Poux</p></figure><blockquote class="mr ms mt"><p id="e1fc" class="ld le mu lf b lg lh kd li lj lk kg ll mv ln lo lp mw lr ls lt mx lv lw lx ly im bi translated">聚类算法通常用于探索性数据分析。它们也构成了人工智能分类管道中的大部分过程，以无监督/自学的方式创建良好标记的数据集。</p></blockquote><p id="2998" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这句话摘自上一篇文章“高维数据聚类的基础知识”，总结了我们快速探索创建半自动标签管道的实用方法的驱动因素。激动人心！但是当然，如果你觉得你需要一些快速的理论更新，你可以在下面的文章中找到完整的解释。</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/fundamentals-to-clustering-high-dimensional-data-3d-point-clouds-3196ee56f5da"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd jd gy z fp nh fr fs ni fu fw jc bi translated">高维数据聚类的基础(3D点云)</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">为什么无监督分割和聚类是“人工智能的主体”？图解概念，以掌握微妙之处和应用…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kx nc"/></div></div></a></div><h2 id="fbcf" class="nr ma it bd mb ns nt dn mf nu nv dp mj lm nw nx ml lq ny nz mn lu oa ob mp iz bi translated">如何定义聚类？</h2><p id="a714" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">一句话，聚类意味着将相似的项目或数据点组合在一起。K-means是计算这种聚类的特定算法。</p><p id="f619" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">那么我们可能想要聚类的那些数据点是什么呢？这些点可以是任意点，例如使用激光雷达扫描仪记录的3D点。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/6ea171ff48c7811cca94dc00f49675af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/1*cfwuHqkt0ZQYi3mo-O4Y1g.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">3D点云中的点分组示例，尝试使用K-Means查找主要欧几里德区域。F. Poux</p></figure><p id="c99a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">但是它们也可以表示空间坐标、数据集中的颜色值(图像、点云等)或其他特征，例如从图像中提取的关键点描述符，以构建单词字典包。</p><div class="ks kt ku kv gt ab cb"><figure class="oh kw oi oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/8e7ce39ec8efb55cdae7558b4c0c7314.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*4nalD8jjBRVOQM9rWiOwYw.png"/></div></figure><figure class="oh kw or oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/b2cbafb8d59a012ffc7ae94bdd9c103d.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*_6VOV1SuBq1-ddoHxK7V7g.png"/></div></figure><figure class="oh kw os oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/8d0263a41dd03ca1c11a84289b1ee8e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:546/format:webp/1*iPkGXB3WsZ3bOOBa88TO7A.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk ot di ou ov translated">从两幅立体图像中提取SIFT特征点，并在聚类步骤后使用摄影测量重建相应的三维点云。更多信息，了解如何在<a class="ae ow" href="https://learngeodata.eu/3d-reconstructor-formation/" rel="noopener ugc nofollow" target="_blank"> 3D地理数据学院</a>用开源软件做到这一点。F. Poux</p></figure></div><div class="mz na gp gr nb nc"><a href="https://learngeodata.eu/3d-reconstructor-formation/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd jd gy z fp nh fr fs ni fu fw jc bi translated">摄影测量三维重建课程-三维地理数据学院</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">该地层包括一些客户鲜为人知的私人技术，但受到专家的高度赞赏…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">learngeodata.eu</p></div></div><div class="nl l"><div class="ox l nn no np nl nq kx nc"/></div></div></a></div><p id="888d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以将它们视为空间中的任意向量，每个向量包含一组属性。然后，我们在一个定义的“特征空间”中收集许多这样的向量，我们希望用少量的代表来表示它们。但这里的大问题是，那些代表应该是什么样子？</p><h1 id="abc1" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">k均值聚类</h1><p id="1200" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">K-Means是计算这种聚类的一种非常简单和流行的算法。这是一个典型的无人监管的过程，所以我们不需要任何标签，如在分类问题。</p><p id="65db" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我们唯一需要知道的是一个距离函数。告诉我们两个数据点相距多远的函数。以最简单的形式，这就是欧几里德距离。但是根据您的应用，您可能还想选择不同的距离函数。然后，我们可以确定两个数据点是否彼此相似，从而确定它们是否属于同一个聚类。</p><h2 id="0116" class="nr ma it bd mb ns nt dn mf nu nv dp mj lm nw nx ml lq ny nz mn lu oa ob mp iz bi translated">K-Means是如何工作的？</h2><p id="9431" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">它用K个代表来表示所有的数据点，这就是该算法的名字。所以K是我们放入系统的用户定义的数字。例如，取所有的数据点，用空间中的三个点来表示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f1353d8a4945ca8964d8c2a3a43a6faf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8qi3Z7mpzEVymLlr4X-EiQ.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">K的意思是工作。首先，我们在特征空间中有一些数据点(欧几里得空间中的X、Y和Z)。然后，我们计算K个代表，并运行K-Means将数据点分配给该代表所代表的聚类。F. Poux</p></figure><p id="9783" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以在上面的例子中，蓝色的点是输入数据点，我们设置K=3。这意味着我们希望用三种不同的代表来表示这些数据点。那么由红色点表示的那些代表将数据点的相应分配定向到“最佳”代表。然后我们得到三组点，绿色、紫色和黄色。</p><p id="f886" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">K-means以最小化数据点与其最接近的代表点之间的平方距离的方式来实现。实现这一点的算法部分由两个简单的迭代步骤构成:初始化和赋值:</p><ol class=""><li id="e216" class="oz pa it lf b lg lh lj lk lm pb lq pc lu pd ly pe pf pg ph bi translated">我们随机初始化K个质心点作为代表，并计算每个数据点到最近质心的数据关联。所以我们在这里做的是最近邻查询。</li><li id="8bd3" class="oz pa it lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">每个数据点都被分配到它最近的质心，然后我们在我们的空间中重新配置每个质心的位置。这是通过计算分配给质心的所有数据点的主向量来实现的，这改变了质心的位置。</li></ol><p id="4fc5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">所以在算法的下一次迭代中，我们会得到一个新的赋值，然后是一个新的质心位置，我们重复这个过程直到收敛。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/da4c6a362ff490353af26971415fe575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*YrjbW7VlnQSC3J3tXONAZw.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">K-Means是如何工作的？直观解释。F. Poux</p></figure><p id="aefb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">💡<strong class="lf jd">提示:</strong>T5】我们要注意，K-Means并不是一个最优算法。这意味着K-Means试图最小化距离函数，但我们不能保证找到全局最小值。因此，根据您的起始位置，您可能会得到不同的K均值聚类结果。假设我们想以一种快速的方式实现K-Means。在这种情况下，我们通常需要在我们的空间中有一个近似的最近邻函数，因为这是用该算法完成的最耗时的操作。好消息，稍后我会在中提示 <code class="fe pn po pp pq b"><em class="mu">k-means++</em></code> <em class="mu">😉。</em></p><p id="ee90" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">因此，K-Means是一种相对简单的两步迭代方法，用于寻找高维空间中潜在的大量数据点的代表。既然理论已经结束，让我们通过五个步骤深入到有趣的python代码实现中🤲！</p><h1 id="da33" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">1.点云工作流定义</h1><h2 id="237e" class="nr ma it bd mb ns nt dn mf nu nv dp mj lm nw nx ml lq ny nz mn lu oa ob mp iz bi translated">航空激光雷达点云数据集</h2><p id="3e82" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">我们实践教程的第一步是收集一个好的数据集！这一次，我想分享另一个寻找酷炫激光雷达数据集的绝佳地点:法国国家地理研究所的地理服务。法国ign的LiDAR HD活动启动了一个开放式数据收集，在这里你可以获得法国一些地区清晰的3D点云！</p><div class="mz na gp gr nb nc"><a href="https://geoservices.ign.fr/lidarhd#telechargement" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd jd gy z fp nh fr fs ni fu fw jc bi translated">激光雷达高清</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">激光雷达高清节目框架中的3D采集点的年度报告</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">地理服务公司</p></div></div><div class="nl l"><div class="pr l nn no np nl nq kx nc"/></div></div></a></div><p id="8876" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我进入上面的门户，选择一个切片，从中提取一个子切片，删除地理参考信息，准备一些激光雷达文件的额外属性部分，然后在我的<a class="ae ow" href="https://drive.google.com/drive/folders/1Ih_Zz9a6UcbUlaA-puEB_is7DYvXrb4w?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Open Data Drive文件夹</a>中提供它。你感兴趣的数据是<code class="fe pn po pp pq b">KME_planes.xyz</code>和<code class="fe pn po pp pq b">KME_cars.xyz</code>。如果你想在网上看到它们，你可以跳转到Flyvast WebGL摘录。</p><h2 id="44e1" class="nr ma it bd mb ns nt dn mf nu nv dp mj lm nw nx ml lq ny nz mn lu oa ob mp iz bi translated">整体循环策略</h2><p id="2572" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">我建议遵循一个简单的程序，您可以复制该程序来标记您的点云数据集，如下图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi ps"><img src="../Images/47b1589203eb5e2bbacf2e58bb9aed58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gy0egZFpAqLH1MDqMEo0A.png"/></div></div><p class="kz la gj gh gi lb lc bd b be z dk translated">标注3D点云数据集的半监督工作流。F. Poux</p></figure><p id="6faa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">🤓<strong class="lf jd"> <em class="mu">注</em> </strong>:这个策略是从我在<a class="ae ow" href="https://learngeodata.eu/" rel="noopener ugc nofollow" target="_blank"> 3D地理数据学院</a>主持的在线课程的一个文档中摘录的。本教程将涵盖第7步到第10步，其他步骤将在课程中深入讨论，或者按照下面的编码指南进行。</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/how-to-automate-3d-point-cloud-segmentation-and-clustering-with-python-343c9039e4f5"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd jd gy z fp nh fr fs ni fu fw jc bi translated">如何使用Python实现3D点云分割和聚类的自动化</h2><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="pt l nn no np nl nq kx nc"/></div></div></a></div><h1 id="8618" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">2.设置我们的3D python上下文</h1><p id="e2b0" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">在这个动手操作的点云教程中，我主要关注高效和最小的库使用。我们可以用其他库做所有的事情，比如<code class="fe pn po pp pq b">open3d</code>、<code class="fe pn po pp pq b">pptk</code>、<code class="fe pn po pp pq b">pytorch3D</code> …但是为了掌握python，我们将用<code class="fe pn po pp pq b">NumPy</code>、<code class="fe pn po pp pq b">Matplotlib</code>和<code class="fe pn po pp pq b">ScikitLearn</code>做所有的事情。启动脚本的六行代码:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="0166" class="nr ma it pq b gy py pz l qa qb">import numpy as np<br/>import matplotlib.pyplot as plt<br/>from mpl_toolkits import mplot3d<br/>from sklearn.cluster import KMeans<br/>from sklearn.cluster import DBSCAN</span></pre><p id="64ff" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">很好，从这里开始，我建议我们相对地表达我们的路径，将包含我们的数据集的<code class="fe pn po pp pq b">data_folder</code>与<code class="fe pn po pp pq b">dataset</code>名称分开，以便在运行中容易地切换:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="5aa0" class="nr ma it pq b gy py pz l qa qb">data_folder=”../DATA/”<br/>dataset=”KME_planes.xyz”</span></pre><p id="6ebc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从那里，我想说明一个用<code class="fe pn po pp pq b">Numpy</code>加载你的点云的好技巧。直观的方法是将所有内容加载到一个<code class="fe pn po pp pq b">pcd</code>点云变量中，比如<code class="fe pn po pp pq b">pcd=np.loadtxt(data_folder+dataset)</code>。但是因为我们将对这些特性稍加研究，所以让我们通过动态地解包变量中的每一列来节省一些时间。<code class="fe pn po pp pq b">Numpy</code>到底有多酷？😆</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="23b6" class="nr ma it pq b gy py pz l qa qb">x,y,z,illuminance,reflectance,intensity,nb_of_returns = np.loadtxt(data_folder+dataset,skiprows=1, delimiter=’;’, unpack=True)</span></pre><p id="5883" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不错！我们现在有一切可以玩的东西了！由于K-Means的本质，我们必须小心地面元素的无所不在，这将提供一些奇怪的东西，如下所示:</p><div class="ks kt ku kv gt ab cb"><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/c5fa71ee175f26764e5d9052d919691f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*4gjzJM06BJSllEctJHUL1g.png"/></div></figure><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/75d25e558d62c26c5baff08d10cdee95.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*BInDD4o_ByrMU8g90osxtg.png"/></div></figure><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/0b9d45ff32667ed59f34c856d0767048.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*UaD_9EL_KhgFNVuy50ODVA.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk qd di qe ov translated">一些K-Means在3D点云上的结果，基于各种属性，没有智能注入。请注意，当仅使用空间属性时，第一幅图像上有规则的三角形分隔。不理想，嗯？弗·普克斯。</p></figure></div><p id="b6b5" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了避免奇怪的结果，我们应该处理我们认为的异常值，即地面。下面是一个直接的窍门，不需要注入太多约束性的知识。</p><h1 id="cff2" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">3.点云快速选择</h1><p id="f0e9" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">让我通过<code class="fe pn po pp pq b">Matplotlib</code>用一个微小的监督步骤来说明如何处理这个问题。它还允许我给你一些代码，这些代码在创建支线剧情和线条分层时总是很方便的。我们将检查两个视图上的2D图，我们点的平均值落在哪里，看看这是否有助于在后面的步骤中过滤掉背景。</p><p id="4af0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">首先，让我们制作一个subplot元素，它将保存我们在<code class="fe pn po pp pq b">X, Z</code>视图上的点，并绘制pour空间坐标的平均值:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="5276" class="nr ma it pq b gy py pz l qa qb">plt.subplot(1, 2, 1) # row 1, col 2 index 1<br/>plt.scatter(x, z, c=intensity, s=0.05)<br/>plt.axhline(y=np.mean(z), color=’r’, linestyle=’-’)<br/>plt.title(“First view”)<br/>plt.xlabel(‘X-axis ‘)<br/>plt.ylabel(‘Z-axis ‘)</span></pre><p id="a391" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">💡<strong class="lf jd">提示:</strong>如果你观察线条内部，我使用强度场作为我们的图的着色元素。我可以这样做，因为它已经在一个<code class="fe pn po pp pq b">[0,1]</code>间隔被标准化了。<code class="fe pn po pp pq b">s</code>代表尺寸，允许我们给我们的点一个尺寸。😉</p><p id="9c8a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，让我们做同样的把戏，但这次是在<code class="fe pn po pp pq b">Y, Z</code>轴上:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="0245" class="nr ma it pq b gy py pz l qa qb">plt.subplot(1, 2, 2) # index 2<br/>plt.scatter(y, z, c=intensity, s=0.05)<br/>plt.axhline(y=np.mean(z), color=’r’, linestyle=’-’)<br/>plt.title(“Second view”)<br/>plt.xlabel(‘Y-axis ‘)<br/>plt.ylabel(‘Z-axis ‘)</span></pre><p id="743d" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在那里，我们可以使用以下命令绘制该图:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="0803" class="nr ma it pq b gy py pz l qa qb">plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi qf"><img src="../Images/add52b8c67bf88b3aa7ca3c09b3ed066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXJTWDi0Tc-Bpbo20E2U8w.png"/></div></div></figure><p id="b103" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">哈哈，好听，hun？代表平均值的红线看起来可以让我们很好地过滤掉接地元素！所以，让我们利用它吧！</p><h1 id="ad4a" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">4.点云过滤</h1><p id="6c01" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">好的，我们想要找到一个掩码，允许我们去掉不满足查询的点。我们感兴趣的查询只考虑具有高于平均值的<code class="fe pn po pp pq b">Z</code>值的点，具有<code class="fe pn po pp pq b">z&gt;np.mean(z)</code>。我们将把结果存储在变量<code class="fe pn po pp pq b">spatial_query</code>中:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="fe0f" class="nr ma it pq b gy py pz l qa qb">pcd=np.column_stack((x,y,z))<br/>mask=z&gt;np.mean(z)<br/>spatial_query=pcd[z&gt;np.mean(z)]</span></pre><p id="128b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">💡<strong class="lf jd">提示:</strong><em class="mu"/><code class="fe pn po pp pq b"><em class="mu">Numpy</em></code><em class="mu">的</em> <code class="fe pn po pp pq b"><em class="mu">column_stack</em></code> <em class="mu">函数非常方便，但要小心使用，因为如果应用于太大的矢量，它会产生开销。尽管如此，它使得使用一组特征向量变得非常方便。</em></p><p id="0014" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，您可以通过查看过滤后的点数来快速验证它是否有效:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="ca67" class="nr ma it pq b gy py pz l qa qb">pcd.shape==spatial_query.shape<!-- --> <br/>[Out] False</span></pre><p id="91e0" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">现在，让我们用以下命令绘制结果，这次是3D的:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="4622" class="nr ma it pq b gy py pz l qa qb">#plotting the results 3D<br/>ax = plt.axes(projection=’3d’)<br/>ax.scatter(x[mask], y[mask], z[mask], c = intensity[mask], s=0.1)<br/>plt.show()</span></pre><p id="95ec" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">同样，如果您想要一个与我们的激光雷达高清数据相适应的俯视图:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="f94b" class="nr ma it pq b gy py pz l qa qb">#plotting the results 2D<br/>plt.scatter(x[mask], y[mask], c=intensity[mask], s=0.1)<br/>plt.show()</span></pre><div class="ks kt ku kv gt ab cb"><figure class="oh kw qg oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/3afea21d076ac6ca86d8b2c3bbecd6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*hblaMUFJBWNsqaIsAnD6Tw.png"/></div></figure><figure class="oh kw qh oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/bcb13d2e833145dde10f3fd9559bb1ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*NK5VygfKNky5MmN6Bg-llA.png"/></div></figure></div><p id="961c" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">很好，我们去掉了恼人的离群点，现在我们可以专注于这两个平面，并尝试为每个平面附加语义。</p><h1 id="7d3c" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">5.k-均值聚类实现</h1><p id="dc2a" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">高水平<code class="fe pn po pp pq b">Scikit-learn</code>图书馆的建设会让你开心。只需一行代码，我们就可以拟合聚类K均值机器学习模型。我将强调标准符号，其中我们的数据集通常表示为<code class="fe pn po pp pq b">X</code>来训练或适应。在第一种情况下，让我们创建一个特征空间，仅保存屏蔽后的X，Y特征:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="14c7" class="nr ma it pq b gy py pz l qa qb">X=np.column_stack((x[mask], y[mask]))</span></pre><p id="37e8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">从那里，我们将运行我们的k-means实现，K=2，看看我们是否可以自动检索两个平面:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="4a1c" class="nr ma it pq b gy py pz l qa qb">kmeans = KMeans(n_clusters=2).fit(X)<br/>plt.scatter(x[mask], y[mask], c=kmeans.labels_, s=0.1)<br/>plt.show()</span></pre><p id="7efc" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">💡<strong class="lf jd">提示:</strong> <em class="mu">我们通过调用sklearn.cluster._kmeans上的</em> <code class="fe pn po pp pq b"><em class="mu">.labels_</em></code> <em class="mu">方法，从k-means实现中检索标签的有序列表。k表示</em> <code class="fe pn po pp pq b">kmeans</code> <em class="mu">对象。这意味着我们可以直接将列表传递给散点图的颜色参数。</em></p><p id="88a2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如下所示，我们在两个集群中正确地检索了两个平面！增加簇的数量(K)将提供不同的结果，您可以在这些结果上进行实验。</p><div class="ks kt ku kv gt ab cb"><figure class="oh kw qi oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/38d0fc1e2bce78cb5f36c4da68097723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*4vEo4-jE8D6kD9dpBKyVtA.png"/></div></figure><figure class="oh kw qi oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/9f0d55e2ef9f8e72e386b27a8633c6de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*egUJa4cc33xaSQwCOxByMw.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk qj di qk ov translated">三维点云实例分割与零件分割可能的工作流程，由K-Means参数化给出。F. Poux</p></figure></div><p id="1a7b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">选择正确的集群数量最初可能并不那么明显。如果我们想有一些启发法来帮助以无人监督的方式决定这个过程，我们可以使用肘方法。我们正在使用肘方法中的参数K，因此是我们想要提取的聚类数。</p><p id="786b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了实现该方法，我们将循环<code class="fe pn po pp pq b">K</code>，例如，在<code class="fe pn po pp pq b">[1:20]</code>的范围内，使用<code class="fe pn po pp pq b">K</code>参数执行K-Means聚类，并计算WCSS(类内平方和)值，我们将把该值存储在一个列表中。</p><p id="71fa" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">💡<strong class="lf jd">提示:</strong><em class="mu"/><code class="fe pn po pp pq b">init</code><em class="mu">参数是初始化质心的方法，这里我们设置为</em> <code class="fe pn po pp pq b">k-means++</code> <em class="mu">进行聚类，重点是加速收敛。然后，</em> <code class="fe pn po pp pq b">wcss</code> <em class="mu">值到</em> <code class="fe pn po pp pq b">kmeans.inertia_</code> <em class="mu">表示每一个点与一个簇中的质心之间的平方距离之和。</em></p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="1ade" class="nr ma it pq b gy py pz l qa qb">X=np.column_stack((x[mask], y[mask], z[mask]))<br/>wcss = [] <br/>for i in range(1, 20):<br/> kmeans = KMeans(n_clusters = i, init = ‘k-means++’, random_state = 42)<br/> kmeans.fit(X)<br/> wcss.append(kmeans.inertia_)</span></pre><p id="1406" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">🦩 <strong class="lf jd">有趣的事实:</strong>如果你注意了k线的细节，你可能会想为什么是42？嗯，没有什么聪明的理由😆。数字42是科学界一直在开的一个玩笑，来源于传说中的<a class="ae ow" href="https://en.wikipedia.org/wiki/The_Hitchhiker%27s_Guide_to_the_Galaxy_(novel)" rel="noopener ugc nofollow" target="_blank">银河系漫游指南</a>，其中一台名为<em class="mu">深度思考</em>的巨型计算机计算出<em class="mu">“生命终极问题的答案……”</em></p><p id="82e8" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">然后，一旦我们的<code class="fe pn po pp pq b">wcss</code>列表完成，我们可以根据<code class="fe pn po pp pq b">K</code>值绘制图形<code class="fe pn po pp pq b">wcss</code>，这看起来像一个肘(也许这与方法的名称有关？🤪).</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="2cc5" class="nr ma it pq b gy py pz l qa qb">plt.plot(range(1, 20), wcss)<br/>plt.xlabel(‘Number of clusters’)<br/>plt.ylabel(‘WCSS’) <br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><div class="gh gi ql"><img src="../Images/626e82a8067d60e2965a7b05cc769995.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XV8CxqqzlXEqvF750LZp3A.png"/></div></div></figure><p id="a1ff" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这看起来很神奇，因为我们看到我们创造肘部形状的值位于2个集群中，这非常有意义😁。</p><h2 id="8a39" class="nr ma it bd mb ns nt dn mf nu nv dp mj lm nw nx ml lq ny nz mn lu oa ob mp iz bi translated">与DBSCAN的聚类比较</h2><p id="d21e" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">在上一篇文章中，我们深入研究了DBSCAN的集群技术。</p><div class="mz na gp gr nb nc"><a rel="noopener follow" target="_blank" href="/how-to-automate-3d-point-cloud-segmentation-and-clustering-with-python-343c9039e4f5"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd jd gy z fp nh fr fs ni fu fw jc bi translated">如何使用Python实现3D点云分割和聚类的自动化</h2><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">towardsdatascience.com</p></div></div><div class="nl l"><div class="pt l nn no np nl nq kx nc"/></div></div></a></div><p id="64a4" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你跟随它，你可能想知道在3D点云的情况下K-Means比DBSCAN真正的好处是什么？好吧，让我举例说明你可能想转换的情况。我提供了航空激光雷达数据集的另一部分，其中包含三辆相互靠近的汽车。如果我们用<code class="fe pn po pp pq b">K=3</code>运行K-Means，我们会得到:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="7704" class="nr ma it pq b gy py pz l qa qb">data_folder="../DATA/"<br/>dataset="KME_cars.xyz"<br/>x,y,z,r,g,b = np.loadtxt(data_folder+dataset,skiprows=1, delimiter=';', unpack=True)<br/>X=np.column_stack((x,y,z))<br/>kmeans = KMeans(n_clusters=3).fit(X)</span></pre><div class="ks kt ku kv gt ab cb"><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/21661be73c904de6f456a9e57ad40968.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*RfPKixMQmTTteCmcVyoaEg.png"/></div></figure><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/dbb7564f34d31d42a14abce605d46e6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*g_k0wxeewc4IFZmkQd1Y7Q.png"/></div></figure><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/e3852d20ff1a489affed5a11717d7264.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*KjaZ-uI5aRHwRXNT71G5hQ.png"/></div></figure></div><p id="bc02" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如你所见，即使我们不能在空间上描绘出物体，我们也能得到很好的聚类。用DBSCAN是什么样子的？好吧，让我们看看下面的代码行:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="6687" class="nr ma it pq b gy py pz l qa qb">#analysis on dbscan<br/>clustering = DBSCAN(eps=0.5, min_samples=2).fit(X)<br/>plt.scatter(x, y, c=clustering.labels_, s=20)<br/>plt.show()</span></pre><div class="ks kt ku kv gt ab cb"><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/81de9548f7a85b49744083e2cfcda8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*fbsmVgEVCPcM-49dh7BqHg.png"/></div></figure><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/a053e8078559b48f4682e51d5d8a758d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*G2IX-QkiIGWpzHw9smusZQ.png"/></div></figure><figure class="oh kw qc oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/f3cdc2c005f34251e1c860bc317bab63.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*tSkVL4_CtLVbqHjdY586kA.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk qd di qe ov translated">D3点云的DBSCAN聚类。ε值分别被设置为0.1、0.2和0.5。F. Poux</p></figure></div><p id="981b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">正如你所看到的，除了设置epsilon参数有困难之外，我们不能描绘，至少用这些特征，右边的两辆车。在这种情况下，K-均值为1–0🙂。</p><h2 id="7754" class="nr ma it bd mb ns nt dn mf nu nv dp mj lm nw nx ml lq ny nz mn lu oa ob mp iz bi translated">玩弄特征空间。</h2><p id="5d20" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">现在，我们只使用空间特征来说明K-Means。但是我们可以使用任何功能的组合，这使得它在不同的应用程序上使用起来非常灵活！</p><p id="3d6a" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">出于本教程的目的，您还可以使用照度、强度、返回次数和反射率进行实验。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f579758e362046f2a25f1bdec076d12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*bxUP21AXKJMpKKk9y4tHow.gif"/></div><p class="kz la gj gh gi lb lc bd b be z dk translated">从航空激光雷达高清数据集中提取三维点云特征。F. Poux</p></figure><p id="0467" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">下面是使用这些功能的两个示例:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="7341" class="nr ma it pq b gy py pz l qa qb">X=np.column_stack((x[mask], y[mask], z[mask], illuminance[mask], nb_of_returns[mask], intensity[mask]))<br/>kmeans = KMeans(n_clusters=3, random_state=0).fit(X)<br/>plt.scatter(x[mask], y[mask], c=kmeans.labels_, s=0.1)<br/>plt.show()</span></pre><p id="1bb3" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">或者再次</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="b461" class="nr ma it pq b gy py pz l qa qb">X=np.column_stack((z[mask] ,z[mask], intensity[mask]))<br/>kmeans = KMeans(n_clusters=4, random_state=0).fit(X)<br/>plt.scatter(x[mask], y[mask], c=kmeans.labels_, s=0.1)<br/>plt.show()</span></pre><div class="ks kt ku kv gt ab cb"><figure class="oh kw qi oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/8ddebcd3111ec0f17e362e2ba73984e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*lNIlMGkSNx5Nc1Kh7a8Mtg.png"/></div></figure><figure class="oh kw qi oj ok ol om paragraph-image"><div role="button" tabindex="0" class="on oo di op bf oq"><img src="../Images/46864266cb4d7b55d569c38be9494fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*5ogXmwzxxtnKuIzEOLkXFQ.png"/></div><p class="kz la gj gh gi lb lc bd b be z dk qj di qk ov translated">K-Means使用不同的特征空间和K值在3D点云上产生结果。F. Poux</p></figure></div><p id="d299" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">为了更深入，我们可以更好地描述每个点周围的局部邻域，例如，通过主成分分析。事实上，这可以允许提取一大组或多或少相关的几何特征。这将超出当前文章的范围，但是您可以肯定，我将在以后的某个特定问题上深入研究它。你也可以通过<a class="ae ow" href="https://learngeodata.eu/point-cloud-processor-formation/" rel="noopener ugc nofollow" target="_blank">点云处理器在线课程</a>直接钻研PCA专业知识。</p><div class="mz na gp gr nb nc"><a href="https://learngeodata.eu/point-cloud-processor-formation/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd jd gy z fp nh fr fs ni fu fw jc bi translated">点云处理在线课程- 3D地理数据学院</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">编队学习先进的点云处理和三维自动化。开发新的python地理数据技能和开源…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">learngeodata.eu</p></div></div><div class="nl l"><div class="qm l nn no np nl nq kx nc"/></div></div></a></div><p id="25a2" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">最后，我们只剩下将数据导出到一致的结构中，例如. xyz ASCII文件，该文件仅保存空间坐标和可在外部软件中读取的标签信息:</p><pre class="ks kt ku kv gt pu pq pv pw aw px bi"><span id="ce35" class="nr ma it pq b gy py pz l qa qb">result_folder=”../DATA/RESULTS/”<br/>np.savetxt(result_folder+dataset.split(“.”)[0]+”_result.xyz”, np.column_stack((x[mask], y[mask], z[mask],kmeans.labels_)), fmt=’%1.4f’, delimiter=’;’)</span></pre><p id="035b" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果你想让它直接工作，我还创建了一个Google Colab脚本，你可以在这里访问:<a class="ae ow" href="https://colab.research.google.com/drive/1HMC3bBGiuxsv7X49Apjv4L7MmPqOZU3W?usp=sharing" rel="noopener ugc nofollow" target="_blank">到Python Google Colab脚本</a>。</p><h1 id="ef62" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">结论</h1><p id="2907" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">热烈祝贺🎉！您刚刚学习了如何通过K-Means聚类开发一个自动半监督分割，当语义标记与3D数据一起不可用时，它非常方便。我们了解到，我们仍然可以通过研究数据中固有的几何模式来推断语义信息。</p><p id="ddfb" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">真心的，干得好！但是，这条道路肯定不会就此结束，因为您刚刚释放了在细分级别进行推理的智能过程的巨大潜力！</p><p id="cdc9" class="pw-post-body-paragraph ld le it lf b lg lh kd li lj lk kg ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">未来的帖子将深入探讨点云空间分析、文件格式、数据结构、对象检测、分割、分类、可视化、动画和网格划分。</p><h1 id="6e7c" class="lz ma it bd mb mc md me mf mg mh mi mj ki mk kj ml kl mm km mn ko mo kp mp mq bi translated">更进一步</h1><p id="50ca" class="pw-post-body-paragraph ld le it lf b lg oc kd li lj od kg ll lm oe lo lp lq of ls lt lu og lw lx ly im bi translated">存在用于点云的其他高级分割方法。这是一个我深入参与的研究领域，你已经可以在文章[1-6]中找到一些设计良好的方法。一些更高级的3D深度学习架构的综合教程即将推出！</p><ol class=""><li id="52e0" class="oz pa it lf b lg lh lj lk lm pb lq pc lu pd ly pe pf pg ph bi translated"><strong class="lf jd"> Poux，F. </strong>，&amp; Billen，R. (2019)。基于体素的三维点云语义分割:无监督的几何和关系特征与深度学习方法。<em class="mu"> ISPRS国际地理信息杂志</em>。8(5), 213;https://doi.org/10.3390/ijgi8050213——杰克·丹格蒙德奖(<a class="ae ow" href="https://www.geographie.uliege.be/cms/c_5724437/en/florent-poux-and-roland-billen-winners-of-the-2019-jack-dangermond-award" rel="noopener ugc nofollow" target="_blank">链接到新闻报道</a>)</li><li id="5fa6" class="oz pa it lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated"><strong class="lf jd"> Poux，F. </strong>，纽维尔，r .，纽约，g .-a .&amp;比伦，R. (2018)。三维点云语义建模:室内空间和家具的集成框架。<em class="mu">遥感</em>、<em class="mu"> 10 </em> (9)、1412。<a class="ae ow" href="https://doi.org/10.3390/rs10091412" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/rs10091412</a></li><li id="f47f" class="oz pa it lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated"><strong class="lf jd"> Poux，F. </strong>，Neuville，r .，Van Wersch，l .，Nys，g .-a .&amp;Billen，R. (2017)。考古学中的3D点云:应用于准平面物体的获取、处理和知识集成的进展。<em class="mu">地学</em>，<em class="mu"> 7 </em> (4)，96。<a class="ae ow" href="https://doi.org/10.3390/GEOSCIENCES7040096" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/GEOSCIENCES7040096</a></li><li id="f200" class="oz pa it lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">Poux，F. ，Mattes，c .，Kobbelt，l .，2020年。室内三维点云的无监督分割:应用于基于对象的分类，摄影测量、遥感和空间信息科学国际档案。第111-118页。<a class="ae ow" href="https://doi:10.5194/isprs-archives-XLIV-4-W1-2020-111-2020" rel="noopener ugc nofollow" target="_blank">https://doi:10.5194/ISPRS-archives-XLIV-4-W1-2020-111-2020</a></li><li id="2dff" class="oz pa it lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">Poux，F. ，Ponciano，J.J .，2020。用于3d室内点云实例分割的自学习本体，ISPRS摄影测量、遥感和空间信息科学国际档案。第309-316页。<a class="ae ow" href="https://doi:10.5194/isprs-archives-XLIII-B2-2020-309-2020" rel="noopener ugc nofollow" target="_blank">https://doi:10.5194/ISPRS-archives-XLIII-B2-2020-309-2020</a></li><li id="70e4" class="oz pa it lf b lg pi lj pj lm pk lq pl lu pm ly pe pf pg ph bi translated">巴斯尔，男，维高温，男，<strong class="lf jd">普克斯，女</strong>，【2020】。用于建筑物内部分类的点云和网格特征。<em class="mu">遥感</em>。12, 2224.<a class="ae ow" href="https://doi:10.3390/rs12142224" rel="noopener ugc nofollow" target="_blank">https://doi:10.3390/RS 12142224</a></li></ol></div></div>    
</body>
</html>