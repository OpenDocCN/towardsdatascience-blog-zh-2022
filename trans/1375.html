<html>
<head>
<title>Towards Quantum Measurement Error Mitigation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朝向量子测量误差减轻</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/towards-quantum-measurement-error-mitigation-e6f134883f34#2022-04-05">https://towardsdatascience.com/towards-quantum-measurement-error-mitigation-e6f134883f34#2022-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将CDR与量子态层析连接起来</h2></div><p id="d3ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_towmitig&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><p id="d81a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子计算机是惊人的设备。然而，它们也容易出错。因此，我们需要实现量子误差缓解方法来减少误差对我们的计算结果的负面影响。</p><p id="c028" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在之前的一系列帖子中，我们<a class="ae le" href="https://pyqml.medium.com/mitigating-quantum-errors-using-clifford-data-regression-98ab663bf4c6" rel="noopener">学习了Clifford数据回归方法</a>，并在<a class="ae le" rel="noopener" target="_blank" href="/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c">模拟环境</a>和<a class="ae le" rel="noopener" target="_blank" href="/practical-error-mitigation-on-a-real-quantum-computer-41a99dddf740">真实量子计算机</a>上减少了错误。</p><p id="e460" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果令人鼓舞。然而，当我试图用它参加IBM的量子开放科学奖时，出现了一个意想不到的障碍。</p><p id="41c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">IBM要求我们使用Trotterization模拟一个三粒子海森堡哈密顿量。不，这不是问题。问题是，他们通过量子态断层扫描来评估任何提交物。这是一种通过测量重建量子态的方法。更具体地说，问题是他们在Qiksit内部使用了<code class="fe lf lg lh li b">StateTomographyFitter</code>。这种实现建立在实验计数的基础上。但是CDR方法适用于期望值。</p><p id="84c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我稍微说明一下这个问题。下图描述了一个1量子位量子电路的简单情况。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/a88fafb55f65905042bc8a76dbe8c48b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_2RGI2wDBWDs03f_yATew.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">作者图片</p></figure><p id="8d7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我们看一个量子位，它不是0就是1。就是这样。哪一个取决于几率和内部量子态。假设量子位在|+⟩.状态在这种状态下，测量0和1具有相同的概率。但是，当量子电路只运行一次时，我们不能对概率下结论。</p><p id="c249" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是当我们重复运行它，比如说1000次，我们会看到0次和1500次，除了微小的统计差异。</p><p id="fd9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，目前的量子计算机是嘈杂的设备。我们有时用零来衡量一，反之亦然。所以，结果变得模糊。例如，我们将测量0 412次，而不是500次。</p><p id="5510" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行量子电路的原始结果是测量。因为我们几乎总是多次执行电路，所以我们对测量进行计数。</p><p id="0bbf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，我们来看看这样一个电路的Qiskit中的源代码。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b55d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们定义了一个具有单个量子位的量子电路，并将哈达玛门应用于它。这个转换门将量子位(从初始状态|0⟩)放入状态|+⟩.在电路的末端，我们测量量子位。下图显示了电路图。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/2ae69952dc3fe126472ca569f35eeecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruf5EDTjyh2bKzGvBaCC0g.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">作者图片</p></figure><p id="8c14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们运行这个电路1000次。我们通过获取一个<code class="fe lf lg lh li b">backend</code>(这里是一个无噪声的统计模拟器)并调用<code class="fe lf lg lh li b">execute</code>函数来实现这一点。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c5ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到一个Qiskit结果对象(<a class="ae le" href="https://qiskit.org/documentation/stubs/qiskit.result.Result.html" rel="noopener ugc nofollow" target="_blank"> Qiskit引用</a>)。这个物体的基本功能是<code class="fe lf lg lh li b">get_counts</code>，因为它告诉我们在观察量子位时看到了什么。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><pre class="lk ll lm ln gt mb li mc md aw me bi"><span id="acc7" class="mf mg it li b gy mh mi l mj mk">{'1': 499, '0': 501}</span></pre><p id="8c0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个简单的Python字典，将测量结果作为键，将我们观察到这个结果的次数作为值。现在轮到我们来解释这些数字并做一些有意义的事情了。从这里看，这些结果和其他统计数据一样好。我们可以用它们来计算进一步的值，比如期望值。这是实验测量的概率期望值。它类似于经典的期望值。例如，考虑投掷一枚公平的硬币，正面和反面着地的概率相等。如果将值1赋给正面，0赋给反面，则期望值为0.5∫1+0.5∫0 = 0.5。这对于|+⟩.的量子位也是一样的</p><p id="7ed8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，当你看到量子计算中期望值的计算时，它看起来像这个⟨𝜓|𝑍|𝜓⟩.字母“psi”(𝜓)表示量子态，中间的z象征可观测。在这种情况下，它是Z轴。</p><p id="add2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里重要的是，这个符号引入了可观测的概念。当我们之前在Qiskit中测量我们的量子位时，我们隐含地选择了Z-observable，因为这是Qiskit中量子位的默认测量基础。所以，我们本质上谈论的是同一个概念。在<a class="ae le" rel="noopener" target="_blank" href="/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c">这篇文章</a>中，我们更详细地观察了可观察到的现象。我们需要知道的一件事是，不只有一个可观测的，而是很多个。想象一个像地球一样的球体。可观察点是你观察地球的特定点。从不同的角度看世界是不同的，然而，这是同一个世界。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ml"><img src="../Images/4777d1ff1a38b9239cc1345ce320f0af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c6kZ8IYZgmNvs1W9HCCctA.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">作者图片</p></figure><p id="c3b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本质上，计数和期望值是紧密联系在一起的。他们都有他们的用途。虽然计数包含有关不同测量的更多信息，但是期望值更适合使用，因为它是一个单一的数字。</p><p id="90c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我在之前的帖子中描述的奋斗点。虽然量子错误缓解方法CDR使用了期望值的简单性，但是IBM用来评估错误缓解性能的量子状态层析成像与计数一起工作。</p><p id="bcc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了参与IBM的挑战，现在我们的工作是将两者整合起来。</p><p id="c6fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我选择让CDR适应不变状态层析，因为后者是IBM的评估方法。我相信乱用他们的评估工具可能会取消我的参赛资格。</p><p id="42b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们需要更改CDR方法来更改计数字典，而不是单个数字。</p><p id="d7be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们简单回顾一下CDR。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mm"><img src="../Images/0ee80ec90f3b7602543af4f1a2f4edcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THqMWoQywY4SYAupPqm_Fw.png"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">作者图片</p></figure><p id="5e6f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CDR方法有三个步骤。首先，我们生成训练数据。然后，在这一步，我们运行我们的量子电路两次。一旦在经典计算机上获得可观察的期望值的精确值。一次是在真实的量子计算机上产生噪声值。</p><p id="93f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第二步中，我们创建噪声值和精确值之间关系的线性模型。从一组数据点构建线性模型称为回归。因此得名CDR —克利福德数据回归。</p><p id="d547" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们使用该模型，通过预测无噪声值，将有噪声的期望值转化为减轻的期望值。</p><p id="c10d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些步骤都需要配合Qiskit <a class="ae le" href="https://qiskit.org/documentation/stubs/qiskit.result.Result.html" rel="noopener ugc nofollow" target="_blank">的实验结果</a>。但是，问题是这是Qiskit <code class="fe lf lg lh li b">execute</code>函数创建的对象。它以只读方式存储大部分数据，我们无法再对其进行更改。</p><p id="94ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们可以运用一个小技巧。我们编写自己的<code class="fe lf lg lh li b">Result</code>类，允许我们在以后更改计数。</p><p id="d1e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从概念上讲，我们创建了一个新的Python类，它服务于状态层析使用的一个函数。这是<code class="fe lf lg lh li b">get_counts</code>功能。因此，当状态层析函数查询计数时，它会得到一个响应。但是由于我们实现了这个新类，我们也可以提供一个覆盖计数的函数。</p><p id="c51d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的清单描述了我们的<code class="fe lf lg lh li b">OwnResult</code>类的源代码。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8232" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该类将现有的Qiskit结果作为初始化参数。此外，我们将<code class="fe lf lg lh li b">_counts</code>指定为一个成员变量，用一个空字典对其进行初始化。这将保存我们更改的计数。功能代码除了两个小东西，都是从原源代码复制的。首先，每当我们引用结果的属性时，比如<code class="fe lf lg lh li b">data</code>，我们需要查看<code class="fe lf lg lh li b">self._result.data</code>而不是<code class="fe lf lg lh li b">self.data</code>。第二，在第41-45行，我们研究了实际计数的自定义成员函数。如果它们存在(<code class="fe lf lg lh li b">if str(key) in self._counts.keys()if str(key) in self._counts.keys()</code>)，我们返回改变的计数(<code class="fe lf lg lh li b">self._counts[str(key)]self._counts[str(key)]</code>)。如果它们不存在，我们返回原始计数(<code class="fe lf lg lh li b">self._result.data(key)["counts"]</code>)</p><p id="ea32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看它是如何工作的。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><pre class="lk ll lm ln gt mb li mc md aw me bi"><span id="bbde" class="mf mg it li b gy mh mi l mj mk">original result:  {'1': 499, '0': 501}<br/>Changed counts:   {'0': 100, '1': 900}</span></pre><p id="727e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们看看是否可以在状态层析成像中使用我们的<code class="fe lf lg lh li b">OwnResult</code>。</p><p id="8628" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的代码片段中，我们创建了与之前使用的电路相同的简单电路。唯一的区别是我们省略了测量，因为我们需要从中创建<code class="fe lf lg lh li b">state_tomography_circuits</code>。然后，我们在无噪声的<code class="fe lf lg lh li b">Qasm-Simulator</code>上运行这些电路，并存储其结果。</p><p id="9716" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，现在我们准备好了激动人心的部分。我们循环通过实验列表中的电路(<code class="fe lf lg lh li b">st_qcs</code>)。对于每个电路，我们将计数设置为具有任意值的固定字典。我们现在不关心这些值，因为我们只想验证<code class="fe lf lg lh li b">StateTomographyFitter</code>是否与我们的<code class="fe lf lg lh li b">OwnResult</code>一起工作。</p><p id="8b42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们根据原始结果和更改后的结果计算保真度。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><pre class="lk ll lm ln gt mb li mc md aw me bi"><span id="63f5" class="mf mg it li b gy mh mi l mj mk">original fidelity: 0.49800015998080377<br/>changed fidelity:  0.7886751345948128</span></pre><p id="3df3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出显示，我们根据更改的计数计算的保真度与我们根据原始计数计算的保真度有很大不同。显然，<code class="fe lf lg lh li b">StateTomographyFitter</code>与我们的自定义计数一起工作。这为在下一步中减少错误创造了先决条件。</p><p id="89c8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_towmitig&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手用Python学习量子机器</strong> </a> <strong class="kk iu">。</strong></p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里可以免费获得前三章。</p></div></div>    
</body>
</html>