<html>
<head>
<title>Python Magic Methods You Might Not Have Heard About</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能没听说过的 Python 魔术方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-magic-methods-you-havent-heard-about-53d11eba448f#2022-12-14">https://towardsdatascience.com/python-magic-methods-you-havent-heard-about-53d11eba448f#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="88eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">还有许多鲜为人知的 Python 魔术方法——让我们来看看它们的作用以及如何在我们的代码中使用它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5393c114bc6cc07173cb9e11b0757830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pTG-tp71CR6Wf4HO2NS1Sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@aahubs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aaron Huber </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6da9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 的神奇方法——也称为<em class="lv"> dunder </em>(双下划线)方法——可以用来实现很多很酷的东西。大多数时候我们用它们来做简单的事情，比如构造函数(<code class="fe lw lx ly lz b">__init__</code>)、字符串表示(<code class="fe lw lx ly lz b">__str__</code>、<code class="fe lw lx ly lz b">__repr__</code>)或者算术运算符(<code class="fe lw lx ly lz b">__add__</code> / <code class="fe lw lx ly lz b">__mul__</code>)。然而，还有很多你可能没有听说过的神奇方法，在这篇文章中，我们将探索所有这些方法(甚至是隐藏的和未记录的)！</p><h1 id="1817" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">迭代器长度</h1><p id="8563" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们都知道可以用来在容器类上实现<code class="fe lw lx ly lz b">len()</code>功能的<code class="fe lw lx ly lz b">__len__</code>方法。但是，如果你想得到一个实现迭代器的类对象的长度呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你所需要做的就是实现<code class="fe lw lx ly lz b">__length_hint__</code>方法，正如你在上面看到的，它也存在于内置迭代器(而不是生成器)中。此外，如您所见，它还支持动态长度变化。尽管如此——顾名思义——这实际上只是一个<em class="lv">提示</em>,而且可能完全不准确:对于列表迭代器，你会得到精确的结果，而对于其他迭代器则不一定。然而，即使它不准确，它对优化也很有帮助，正如不久前介绍它的<a class="ae ky" href="https://peps.python.org/pep-0424/" rel="noopener ugc nofollow" target="_blank"> PEP 424 </a>中所解释的。</p><h1 id="93c6" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">元编程</h1><p id="c9b8" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">您很少看到的大部分神奇方法都与元编程有关，虽然元编程可能不是您每天都必须使用的，但是有一些方便的技巧您可以使用它。</p><p id="f23b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一个技巧是使用<code class="fe lw lx ly lz b">__init_subclass__</code>作为扩展基类功能的快捷方式，而不必处理元类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9f6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用它向基类添加关键字参数，可以在定义子类时设置。在真实的用例中，您可能会在想要处理所提供的参数的情况下使用它，而不仅仅是分配给一个属性。</p><p id="3c82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可能看起来非常晦涩，很少有用，但您可能已经遇到过很多次了，因为它可以在构建 API 时使用，用户可以像在<a class="ae ky" href="https://docs.sqlalchemy.org/en/14/orm/inheritance.html" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy models </a>或<a class="ae ky" href="https://github.com/pallets/flask/blob/9b44bf2818d8e3cde422ad7f43fb33dfc6737289/src/flask/views.py#L162" rel="noopener ugc nofollow" target="_blank"> Flask Views </a>中那样子类化您的父类。</p><p id="d0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会发现使用的另一个元类魔术方法是<code class="fe lw lx ly lz b">__call__</code>。这个方法允许你定制当你<em class="lv">调用</em>一个类实例时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="21e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，您可以用它来创建不能被调用的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个只有静态方法的类，因此没有很好的理由去创建这个类的实例，这是很有用的。</p><p id="88be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想到的另一个类似的用例是单例模式——一个最多只能有一个实例的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="638b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们通过实现一个只能有一个实例的全局记录器类来演示这一点。这个概念可能看起来有点复杂，但是这个实现非常简单——<code class="fe lw lx ly lz b">Singleton</code>类拥有一个私有的<code class="fe lw lx ly lz b">__instance</code>——如果没有，它就被创建并赋给属性，如果已经存在，它就被返回。</p><p id="0703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设您有一个类，并且您想在不调用<code class="fe lw lx ly lz b">__init__</code>的情况下创建它的一个实例。这个<code class="fe lw lx ly lz b">__new__</code>魔法方法可以帮上忙:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，您可能需要绕过创建实例的通常过程，上面的代码显示了您如何做到这一点。我们不调用<code class="fe lw lx ly lz b">Document(...)</code>，而是调用<code class="fe lw lx ly lz b">Document.__new__(Document)</code>，这将创建一个裸实例，而不调用<code class="fe lw lx ly lz b">__init__</code>。因此，实例属性——在本例中是<code class="fe lw lx ly lz b">text</code>——没有初始化，为了解决这个问题，我们可以使用<code class="fe lw lx ly lz b">setattr</code>函数(顺便说一下，这也是一个神奇的方法——<code class="fe lw lx ly lz b">__setattr__</code>)。</p><p id="1af5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么你会想这么做。一个例子是实现可选的构造函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们定义<code class="fe lw lx ly lz b">from_file</code>方法，它作为一个构造器，首先用<code class="fe lw lx ly lz b">__new__</code>创建实例，然后在不调用<code class="fe lw lx ly lz b">__init__</code>的情况下配置它。</p><p id="b2db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来元编程相关的魔术方法我们将在这里看一看是<code class="fe lw lx ly lz b">__getattr__</code>。当普通属性访问失败时，调用此方法。这可以用来将对缺失方法的访问/调用委托给另一个类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="afd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想用一些额外的函数定义 string 的自定义实现，比如上面的<code class="fe lw lx ly lz b">custom_operation</code>。然而，我们不想重复实现每一个单独的字符串方法，例如<code class="fe lw lx ly lz b">split</code>、<code class="fe lw lx ly lz b">join</code>、<code class="fe lw lx ly lz b">capitalize</code>等等。因此，我们使用<code class="fe lw lx ly lz b">__getattr__</code>来调用这些现有的字符串方法，以防在我们的类中找不到它们。</p><p id="722b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这对于普通方法来说效果很好，但是请注意，在上面的例子中，魔法方法<code class="fe lw lx ly lz b">__add__</code>提供的连接等操作并没有被委托。因此，如果我们希望它们也能工作，那么我们就必须重新实现它们。</p><h1 id="5f0a" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">反省</h1><p id="1b97" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">我们将试用的最终元编程相关魔术方法是<code class="fe lw lx ly lz b">__getattribute__</code>。这张看起来和之前的<code class="fe lw lx ly lz b">__getattr__</code>很像。然而有一点小小的不同——正如已经提到的,<code class="fe lw lx ly lz b">__getattr__</code>仅在属性查找失败时被调用，而<code class="fe lw lx ly lz b">__getattribute__</code>在属性查找尝试之前被调用<em class="lv">。</em></p><p id="375a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，您可以使用<code class="fe lw lx ly lz b">__getattribute__</code>来控制对属性的访问，或者您可以创建一个 decorator 来记录每次访问实例属性的尝试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="979c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">logger</code> decorator 函数从记录它所修饰的类的原始<code class="fe lw lx ly lz b">__getattribute__</code>方法开始。然后用自定义方法替换它，在调用原始的<code class="fe lw lx ly lz b">__getattribute__</code>方法之前，首先记录被访问属性的名称。</p><h1 id="c7f9" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">魔法属性</h1><p id="05ea" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">到目前为止，我们只讨论了魔术方法，但是 Python 中也有相当多的魔术变量/属性。其中一个是<code class="fe lw lx ly lz b">__all__</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个神奇的属性可以用来定义从一个模块中导出哪些变量和函数。在这个例子中，我们用单个文件(<code class="fe lw lx ly lz b">__init__.py</code>)在<code class="fe lw lx ly lz b">.../some_module/</code>中创建了一个 Python 模块。在这个文件中，我们定义了 2 个变量和一个函数，我们只导出其中的 2 个变量(<code class="fe lw lx ly lz b">func</code>和<code class="fe lw lx ly lz b">some_var</code>)。如果我们试图在其他 Python 程序中导入<code class="fe lw lx ly lz b">some_module</code>的内容，我们只能得到 2 个导出的内容。</p><p id="8345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过要注意的是，<code class="fe lw lx ly lz b">__all__</code>变量只影响上面显示的<code class="fe lw lx ly lz b">*</code>导入，你仍然可以通过<code class="fe lw lx ly lz b">import some_other_var from some_module</code>这样的导入来导入未导出的函数和变量。</p><p id="fb2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能见过的另一个双下划线变量(模块属性)是<code class="fe lw lx ly lz b">__file__</code>。这个变量只是标识了访问它的文件的路径:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结合<code class="fe lw lx ly lz b">__all__</code>和<code class="fe lw lx ly lz b">__file__</code>，你可以加载一个文件夹中的所有模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="df1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个我们要尝试的是<code class="fe lw lx ly lz b">__debug__</code>属性。显然，这可以用于调试，但更具体地说，它可以用于更好地控制断言:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe lw lx ly lz b">python example.py</code>正常运行这段代码，我们会看到<code class="fe lw lx ly lz b">"debugging logs"</code>被打印出来，但是如果我们使用<code class="fe lw lx ly lz b">python3 -O example.py</code>，优化标志(<code class="fe lw lx ly lz b">-O</code>)会将<code class="fe lw lx ly lz b">__debug__</code>设置为假，并去掉调试消息。因此，如果您在生产环境中使用<code class="fe lw lx ly lz b">-O</code>运行您的代码，您将不必担心调试遗留下来的被遗忘的<code class="fe lw lx ly lz b">print</code>调用，因为它们将被全部去除。</p><h1 id="9e20" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">隐藏和未记录</h1><p id="6a06" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">以上所有的方法和属性可能有些陌生，但是它们都在 Python 文档中。然而，有几个没有明确记录和/或有些隐藏。</p><p id="37f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以运行以下代码来发现几个新代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些，还有很多在 Python bug tracker<a class="ae ky" href="https://github.com/python/cpython/issues/67827" rel="noopener ugc nofollow" target="_blank">BPO 23639</a>中列出。正如在那里指出的，它们中的大多数是不应该被访问的实现细节或私有名称。所以他们不被记录可能是最好的。</p><h1 id="fc9f" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">自己做？</h1><p id="8bd9" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">现在，有了这么多神奇的方法和属性，你真的能自己创造吗？你可以，但你不应该。</p><p id="75ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">双下划线名称是为 Python 语言的未来扩展保留的，不应用于您自己的代码。如果您决定在您的代码中使用这样的名称，那么您将冒着在将来将它们添加到 Python 解释器中的风险，这很可能会破坏您的代码。</p><h1 id="66b7" class="ma mb it bd mc md me mf mg mh mi mj mk jz ml ka mm kc mn kd mo kf mp kg mq mr bi translated">结束语</h1><p id="3c38" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在这篇文章中，我们看了一些我认为有用或有趣的鲜为人知的神奇方法和属性，然而在文档中列出了更多可能对你有用的方法和属性。大多数可以在<a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#special-method-names" rel="noopener ugc nofollow" target="_blank"> Python 数据模型文档</a>中找到。然而，如果你想更深入地挖掘，你可以尝试在 Python 文档中搜索<code class="fe lw lx ly lz b">"__"</code>，这将会出现<a class="ae ky" href="https://docs.python.org/3/search.html?q=__&amp;check_keywords=yes&amp;area=default" rel="noopener ugc nofollow" target="_blank">更多的方法和属性</a>来探索和使用。</p><p id="6f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文原帖</em><a class="ae ky" href="https://martinheinz.dev/blog/87" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="fa32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@martin.heinz/membership" rel="noopener">成为会员</a>阅读媒体上的每一个故事。<strong class="lb iu">你的会员费直接支持我和你看的其他作家。</strong>你还可以在媒体上看到所有的故事。</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/@martin.heinz/membership" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">通过我的推荐链接加入媒体-马丁·海因茨</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">阅读马丁·海因茨(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><p id="9afe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能也喜欢…</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/@martin.heinz/python-cli-tricks-that-dont-require-any-code-whatsoever-e7bdb9409aeb" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">不需要任何代码的 Python CLI 技巧</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用 Python 命令行工具启动 web 服务器、打开浏览器、解析 JSON、压缩文件等等，而无需…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://betterprogramming.pub/all-the-ways-to-introspect-python-objects-at-runtime-80e6991b4cc6" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">运行时自省 Python 对象的所有方法</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">在运行时检查 Python 对象和获取代码信息的技巧和诀窍</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">better 编程. pub</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>