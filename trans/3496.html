<html>
<head>
<title>DETR: End-to-End Object Detection with Transformers and Implementation of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DETR:使用变压器的端到端对象检测和Python实现</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/detr-end-to-end-object-detection-with-transformers-and-implementation-of-python-8f195015c94d#2022-08-03">https://towardsdatascience.com/detr-end-to-end-object-detection-with-transformers-and-implementation-of-python-8f195015c94d#2022-08-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e625" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">变压器架构的使用不仅在速度方面提供了优势，而且在一些特定类型的对象检测问题方面也提供了优势</h2></div><p id="02df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在脸书的研究团队发表的“DETR:用变形金刚进行端到端的物体检测”论文中，最新的变形金刚技术被用于物体检测问题。这种算法比传统的目标识别技术有许多优点。通过使用这种算法，在本文的后面阶段已经用python解决了一个示例对象检测问题。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/479ef49f47585799286643de1dedc8c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RC6RXanchGeZoTeoYrRz3Q.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae ls" href="https://unsplash.com/photos/4YoINz4XvnQ" rel="noopener ugc nofollow" target="_blank">托古列夫的Unsplash</a></p></figure><p id="d8b1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过在目标检测问题中使用不同的方法，已经产生了许多解决方法。在第一种方法中，存在由用于检测目标对象的分类和回归阶段组成的两阶段架构。在第一阶段，使用选择性搜索或区域提议网(RPN)来生成区域提议。之后，执行分类和回归过程。R-CNN、快速R-CNN和更快R-CNN是该架构最知名的算法。虽然这些算法的准确率很高(特别是对于微小的物体)，但在速度上并没有达到理想的水平。在另一种方法中，目标检测在单个阶段中完成。这种方法不使用选择性搜索或RPN。存在用于对象检测过程的单个神经网络模型。虽然这是一种比第一种方法快得多的技术，但它在检测小尺寸物体方面的性能相对较差。</p><p id="0234" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2020年，脸书研究团队在一篇名为“利用变压器进行端到端物体检测”的文章中介绍了一种新技术。据宣布，一种新的对象检测模型是使用变压器架构创建的，变压器架构通常用于NLP(自然语言处理)解决方案。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lt"><img src="../Images/15819e33a950e2fcf27eaa3a617349da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ka5RKEqHnkObGyqn2p6zDw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图一。DETR模式— <a class="ae ls" href="https://arxiv.org/abs/2005.12872" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="c5e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DETR架构基本上由三层组成(图1)。</p><ul class=""><li id="9297" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated">CNN层用于从图像(主干)中提取特征</li><li id="5bbb" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">变压器中的编码器-解码器结构</li><li id="9595" class="lu lv iq kh b ki md kl me ko mf ks mg kw mh la lz ma mb mc bi translated">涉及在预测对象和真实对象之间执行二分匹配的集合损失函数</li></ul><p id="b4c1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一阶段，通过主干层从图像中提取特征图。可以使用许多不同的模型，例如RestNet-50或ResNet-101。以这种方式，二维结构信息被保留。在接下来的阶段中，数据被展平，因此我们得到一个一维结构。在位置编码之后，它被传送到编码器-解码器机制。最后，每个输出被转发到前馈网络。最后一层由3个节点组成。在使用Relu激活函数的情况下，获得预测对象的归一化中心坐标以及对象的预测高度和宽度值。当在节点中使用softmax激活函数时，预测相关对象的类别。因此，不需要非最大抑制(NMS)。</p><p id="be65" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">抑制(NMS):它是物体识别算法的基本课题之一。在模型的预测期间，可以用多于一帧来估计目标对象。这些框架有些可能是倾斜的，有些可能太大。对于NMS，在这些类型的帧中选择最合适的一个。联合值的交集用于此过程。</em></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mi"><img src="../Images/0e753ee4928510e787b5e9a7cae19da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m61-cgSLnQyErRC1MOBqsw.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图2算法中使用的变压器架构— <a class="ae ls" href="https://arxiv.org/pdf/2005.12872.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="36dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在位置编码部分，根据元素在数组中的位置重新创建每个元素(或NLP世界中的标记)的向量。因此，同一个字在数组中的不同位置可以有不同的向量。</p><p id="be38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在编码器层，执行高维特征矩阵到低维特征矩阵的缩减。它由每个编码器层中的多头自关注、规格化器和前馈网络模块组成。</p><p id="9dd5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在解码器层，有多头自关注，规范和前馈网络模块一样，编码器。n个对象查询被转换为输出嵌入。在下一阶段，使用前馈网络执行最终估计过程。</p><p id="fc3e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注:由于将对变压器架构进行更全面的研究，因此这些章节很短。然而，如果您想获得有关变压器的更多详细信息，您可以访问相关文章</em><a class="ae ls" href="https://arxiv.org/abs/1706.03762" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lb"/></strong></a><em class="lb">。</em></p><p id="f97d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变压器架构的使用不仅在速度方面，而且在对象检测问题的某些特定类型的问题方面提供了很大的优势。通过这种架构，根据对象检测算法的图像内容进行预测。因此，在图像中上下文很重要的情况下，使用这种方法可以获得更高的成功。当递归神经网络用于对象检测项目时，已经看到精度较低并且模型运行较慢。因为操作是连续的。由于这些操作是从变压器架构中并行执行的，因此我们得到了一个更快的模型。</p><h1 id="6f6b" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">Python项目</h1><p id="f655" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">项目中使用的数据集已经从Kaggle下载。这里可以访问<a class="ae ls" href="https://www.kaggle.com/c/global-wheat-detection" rel="noopener ugc nofollow" target="_blank">。数据集在Kaggle上获得了麻省理工学院的许可。如果你想得到详细的信息，你可以使用</a><a class="ae ls" href="https://en.wikipedia.org/wiki/MIT_License" rel="noopener ugc nofollow" target="_blank">这个链接</a>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/5bb35fc9a10f14933d557600c66fe45d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*PRLI8s2p8AZsUl1nc0CDvg.png"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图三。来自Kaggle的样本数据集— <a class="ae ls" href="https://www.kaggle.com/c/global-wheat-detection" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="91ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个数据集中有不同类型的小麦(图3)。本项目旨在正确检测这些小麦类型。存储库用于轻松完成训练和预测过程(<a class="ae ls" href="https://github.com/ademakdogan/plant_detector" rel="noopener ugc nofollow" target="_blank">https://github.com/ademakdogan/plant_detector</a>)。下载数据集时，可以在图4中看到原始的标记数据。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nh"><img src="../Images/c7637a5f3d7bb618d7094ad658c6aa56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vGLa1XUuVzui06aNkCm9VQ.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图4。原始标记数据</p></figure><p id="2dea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，这种标记结构应该根据存储库进行更改。由于这种改变，csv文件中的列名应该分别为<strong class="kh ir"> <em class="lb"> image_name、page_width、page_height、x、y、width、height、labels </em> </strong>。csv文件的转换版本可以在图5中看到。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ni"><img src="../Images/3df0c30269b91ce77be123144b72cfdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnfOPeIYdquv-wAAiVsjMg.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图五。转换的数据</p></figure><p id="ed99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里应该注意的是，图像名称及其扩展名被写在<em class="lb">图像名称</em>列中。事实上，这个存储库可以很容易地用于所有对象检测项目，其中可用数据可以以这种格式进行更改。编写一个只将数据转换为上述格式的转换器就足够了。</p><h2 id="8656" class="nj mk iq bd ml nk nl dn mp nm nn dp mt ko no np mv ks nq nr mx kw ns nt mz nu bi translated">1-数据准备</h2><p id="634e" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">获得的数据必须适应DETR算法。以下代码可用于此目的。</p><p id="cd51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于培训:</p><pre class="ld le lf lg gt nv nw nx ny aw nz bi"><span id="ec63" class="nj mk iq nw b gy oa ob l oc od">python data_preparation.py -c /Users/.../converted_train.csv -i True</span></pre><p id="c5b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用于测试:</p><pre class="ld le lf lg gt nv nw nx ny aw nz bi"><span id="8310" class="nj mk iq nw b gy oa ob l oc od">python data_preparation.py -c /Users/.../converted_test.csv -i False</span></pre><p id="de2d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行名为data_preparation的python脚本后，在名为<em class="lb"> /data/json_files </em>的文件夹下创建了<em class="lb"> custom_train.json </em>和<em class="lb"> custom_test.json </em>文件。如果在文件的创建中没有问题，则开始训练阶段。</p><h2 id="08b4" class="nj mk iq bd ml nk nl dn mp nm nn dp mt ko no np mv ks nq nr mx kw ns nt mz nu bi translated">2-培训</h2><p id="3585" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">训练也可以简单地用下面的代码来完成。在开始训练之前，可以根据需要更改config.json文件中的参数。</p><pre class="ld le lf lg gt nv nw nx ny aw nz bi"><span id="effc" class="nj mk iq nw b gy oa ob l oc od">python train.py -n &lt;train_image_folder_path&gt; -t &lt;test_image_folder_path&gt;</span></pre><p id="9927" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为训练过程的结果，获得了以下结果。</p><blockquote class="oe of og"><p id="11bd" class="kf kg lb kh b ki kj jr kk kl km ju kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated">平均精度(AP)@[IoU = 0.50:0.95 | area = all | maxDets = 100]= 0.326<br/>平均精度(AP)@[IoU = 0.50 | area = all | maxDets = 100]= 0.766<br/>平均精度(AP)@[IoU = 0.75 | area = all | maxDets = 100]= 0.229<br/>平均精度(AP)@[IoU = 0.56 = 0.410 <br/>平均召回率(AR)@[IoU = 0.50:0.95 | area = all | maxDets = 1]= 0.020<br/>平均召回率(AR)@[IoU = 0.50:0.95 | area = all | maxDets = 10]= 0.161<br/>平均召回率(AR)@[IoU = 0.50:0.95 | area = all | maxDets = 100]= 0.465</p></blockquote><p id="f7bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当分析结果时，可以清楚地看到，由于epoch低，成功率不是很高。很明显，当config.json中的max_steps参数增加时，将获得更高的精度。但是，根据硬件功率的不同，训练时间将会增加。培训也可以通过docker完成。</p><pre class="ld le lf lg gt nv nw nx ny aw nz bi"><span id="1794" class="nj mk iq nw b gy oa ob l oc od">make docker</span></pre><p id="eb0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上面的命令在项目的主目录中创建了一个新的docker映像。默认情况下，这个docker图像的名称是“detr”。如果希望更改图像名称，可以使用makefile。自动完成必要的安装后，使用以下命令开始培训过程。</p><pre class="ld le lf lg gt nv nw nx ny aw nz bi"><span id="b9b3" class="nj mk iq nw b gy oa ob l oc od">make docker_run v=&lt;full_path_of_the_project&gt; n=&lt;train_image_folder_path&gt; t=&lt;test_image_folder_path&gt;</span></pre><p id="5614" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个过程的结果是，在model文件夹下创建了一个名为model.ckpt的模型文件。之后，使用该模型执行预测过程。</p><h2 id="4a11" class="nj mk iq bd ml nk nl dn mp nm nn dp mt ko no np mv ks nq nr mx kw ns nt mz nu bi translated">3-预测</h2><p id="4d6a" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">使用作为训练结果获得的模型，可以创建许多不同的预测场景。以下命令可用于项目中的预测用法示例。</p><pre class="ld le lf lg gt nv nw nx ny aw nz bi"><span id="eef6" class="nj mk iq nw b gy oa ob l oc od">python prediction.py -p /Users/..../test/sample.jpg</span></pre><p id="9252" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果如下图所示。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ok"><img src="../Images/053012a78c974956a2c2652a6fc350f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LREIy4V6hBpJ4rgRWyGP7w.png"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">图六。示例图像预测</p></figure><h1 id="f519" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="8a1a" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">本文分析了基于变压器(DETR)的端到端目标检测方法，并与其他目标检测方法进行了比较。给出了关于构成该体系结构的各层的一般信息。第一阶段使用ResNet架构提取特征。在第二层中，在使用二分匹配技术计算损失值之后，将变换层用于编解码机制。DETR速度很快，因为它具有并行处理能力，并且不使用锚盒和NMS等限制性技术。此外，在图像中的内容很重要的情况下，它比其他对象检测架构更强大。为了给这种情况树立一个榜样，用<a class="ae ls" href="https://www.kaggle.com/c/global-wheat-detection" rel="noopener ugc nofollow" target="_blank">全球小麦检测</a>数据集做了一个样本项目。要检测的对象通常是相互关联的；因此，尽管历元数量很少，该模型也能够进行检测。</p><p id="f062" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例项目使用了Python。代码是共享的，因此这个架构可以更容易地使用。这些代码可在https://github.com/ademakdogan/plant_detector的<a class="ae ls" href="https://github.com/ademakdogan/plant_detector" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"/></a><strong class="kh ir"/>获得。从Kaggle下载的<a class="ae ls" href="https://www.kaggle.com/c/global-wheat-detection" rel="noopener ugc nofollow" target="_blank">数据集</a> (MIT-licensed)用于我们的示例项目。本项目对数据预处理、训练和预测阶段进行了详细说明。</p><p id="c4e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同的对象检测算法将在以后的文章中详细讨论。</p><p id="0ac5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">Github:</strong><a class="ae ls" href="https://github.com/ademakdogan" rel="noopener ugc nofollow" target="_blank">https://github.com/ademakdogan</a></p><p id="5c5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">领英:</strong><a class="ae ls" href="https://www.linkedin.com/in/adem-akdo%C4%9Fan-948334177/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/adem-akdo%C4%9Fan-948334177/</a></p><h1 id="d1a1" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">参考</h1><p id="d2df" class="pw-post-body-paragraph kf kg iq kh b ki nb jr kk kl nc ju kn ko nd kq kr ks ne ku kv kw nf ky kz la ij bi translated">[1]尼古拉·卡里翁、弗朗西斯科·马萨、加布里埃尔·西纳伊夫、尼古拉·乌苏尼尔、亚历山大·基里洛夫、谢尔盖·扎戈鲁科。利用变压器进行端到端目标检测。2020</p><p id="26a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[2]<a class="ae ls" href="https://github.com/facebookresearch/detr" rel="noopener ugc nofollow" target="_blank">https://github.com/facebookresearch/detr</a></p><p id="1693" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[3]曹希鹏，彭远，，冯，牛昆.CF-DETR:用于端到端物体检测的粗到细转换器。2022</p></div></div>    
</body>
</html>