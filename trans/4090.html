<html>
<head>
<title>How to Perform Bulk Inserts With SQLAlchemy Efficiently in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用SQLAlchemy高效地执行批量插入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-perform-bulk-inserts-with-sqlalchemy-efficiently-in-python-23044656b97d#2022-09-11">https://towardsdatascience.com/how-to-perform-bulk-inserts-with-sqlalchemy-efficiently-in-python-23044656b97d#2022-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3cf4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习用Python高效地将大量记录插入数据库的不同方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/624c6c4ea3f983124f70b9418d92358a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lYeRB6jx_SPvKwSh.jpg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片由Pixabay中的<a class="ae ku" href="https://pixabay.com/photos/freighter-cargo-ship-industry-port-315201/" rel="noopener ugc nofollow" target="_blank"> PublicDomainPictures </a>提供</p></figure><p id="1170" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用SQLAlchemy通过<a class="ae ku" href="https://betterprogramming.pub/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1" rel="noopener ugc nofollow" target="_blank">普通SQL查询</a>或<a class="ae ku" href="https://levelup.gitconnected.com/learn-the-basics-and-get-started-with-sqlalchemy-orm-from-scratch-66c8624b069" rel="noopener ugc nofollow" target="_blank">对象关系映射器(ORM) </a>与关系数据库交互非常方便。然而，当涉及到批量插入时，也就是说，将大量记录插入到一个表中，我们可能经常会遇到性能问题。在本帖中，我们将介绍批量插入的不同方法，并通过实践教程比较它们的性能。您将对这些方法有更好的理解，并可以选择最适合您实际情况的方法。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="3787" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">安装SQLAlchemy</h2><p id="5436" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">为了使它成为可以跟随的实践教程，我们需要在我们的计算机上安装所需的库。建议在虚拟环境<a class="ae ku" href="https://lynn-kwong.medium.com/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">中安装软件包</a>，这样就不会弄乱你的系统库。我们将使用<a class="ae ku" href="https://docs.conda.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> conda </em> </a>创建一个虚拟环境，因为我们可以在虚拟环境中安装特定版本的Python:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e6eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为本教程安装的软件包:</p><ul class=""><li id="89eb" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><a class="ae ku" href="https://pypi.org/project/SQLAlchemy/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a> —将用于与数据库交互的主包。</li><li id="8d61" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae ku" href="https://pypi.org/project/mysqlclient/" rel="noopener ugc nofollow" target="_blank">MySQL client</a>—MySQL数据库的高性能驱动程序。如果您在安装<em class="mw"> mysqlclient </em>或使用它时遇到一些问题，您可以安装<a class="ae ku" href="https://pypi.org/project/PyMySQL/" rel="noopener ugc nofollow" target="_blank"> PyMySQL </a>，它没有系统依赖性问题。如果需要使用PyMySQL作为驱动程序，请查看这篇文章。</li><li id="f910" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae ku" href="https://pypi.org/project/cryptography/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">密码术</em> </a> —由SQLAlchemy用于认证。</li><li id="ab3c" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae ku" href="https://pypi.org/project/ipython/" rel="noopener ugc nofollow" target="_blank"> <em class="mw"> ipython </em> </a> —用于更方便地执行交互式python代码。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="fc18" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">设置本地MySQL服务器</h2><p id="946e" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">在本教程中，我们将使用本地MySQL服务器，而不是SQLite，以使其更类似于实际用例。可以使用Docker方便地设置服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2c3c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，MySQL Docker容器附带了一个卷，因此即使容器重新启动，数据也可以持久保存。此外，root密码被指定为一个环境变量，因此可以在以后用于身份验证。最后，为容器分配了一个高端口(13306 ),因此它不会与其他现有的MySQL服务器发生潜在冲突。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="0bca" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">设置数据库连接</h2><p id="e740" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">现在让我们设置数据库连接元数据，它将在即将引入的测试中使用。两个<a class="ae ku" rel="noopener" target="_blank" href="/understand-context-managers-in-python-and-learn-to-use-them-in-unit-tests-66cff907ce8e">上下文管理器</a>被创建，分别产生一个<code class="fe nn no np nq b"><a class="ae ku" href="https://docs.sqlalchemy.org/en/14/orm/session_api.html#sqlalchemy.orm.Session" rel="noopener ugc nofollow" target="_blank">Session</a></code>和一个<code class="fe nn no np nq b"><a class="ae ku" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection" rel="noopener ugc nofollow" target="_blank">Connection</a></code>对象。<code class="fe nn no np nq b">Session</code>对象将用于执行orm模型的操作，而<code class="fe nn no np nq b">Connection</code>对象用于处理SQLAlchemy核心API或直接执行普通SQL查询。一些清理工作也在上下文管理器中完成，因此我们可以连续运行多个测试。有关SQLAlchemy引擎、连接和会话的更详细介绍，请查看<a class="ae ku" href="https://levelup.gitconnected.com/learn-the-basics-and-get-started-with-sqlalchemy-orm-from-scratch-66c8624b069" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="f587" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">设置数据库连接元数据的代码片段如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="083c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">警报:</p><ul class=""><li id="1904" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">应该使用<code class="fe nn no np nq b">127.0.0.1</code>而不是<code class="fe nn no np nq b">localhost</code>作为上面DB URL中的主机名，否则，可能会出现连接问题。</li></ul></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="d4b6" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">为测试创建一个ORM类</h2><p id="b8c4" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">我们将创建一个简单的<code class="fe nn no np nq b">customers</code>表，它有两个字段，即<code class="fe nn no np nq b">id</code>和<code class="fe nn no np nq b">name</code>，其中<code class="fe nn no np nq b">id</code>的主键默认自动递增。顺便说一下，这个表将位于上面DB URL中指定的<code class="fe nn no np nq b">data</code>模式中。该表的ORM类如下所示。该表将在上下文管理器创建会话或连接时创建，并将在<code class="fe nn no np nq b">cleanup</code>参数为<code class="fe nn no np nq b">True</code>时删除。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="3b88" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">逐个添加ORM对象</h2><p id="281c" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">现在让我们用不同的方法将大量记录添加到表中，并比较它们的性能。第一个是<code class="fe nn no np nq b">Session.add()</code>，当您使用ORM与数据库交互时，这是非常常用的。</p><p id="a4f4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将首先向数据库添加20，000条记录，但不指定主键:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5377" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该测试功能大约需要5秒钟。所花费的时间会因电脑的性能而异，并且每次运行时会略有不同。如果太快或太慢，可以微调<code class="fe nn no np nq b">num</code>参数。如果你想检查数据库中插入的数据，设置<code class="fe nn no np nq b">cleanup</code>为<code class="fe nn no np nq b">False</code>。</p><p id="cc3a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于ORM，有一个快捷方法<code class="fe nn no np nq b">Session.add_all()</code>，它将ORM实例列表作为参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="48cd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">使用<code class="fe nn no np nq b">Session.add()</code>和<code class="fe nn no np nq b">Session.add_all()</code>的性能应该非常相似，因为数据直到运行<code class="fe nn no np nq b">Session.commit()</code>才保存到数据库，而运行<code class="fe nn no np nq b">Session.commit()</code>是真正的时间限制步骤。</p><p id="327b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实际上，用5秒钟插入20，000条记录可能是应用程序的一个主要性能问题。如果数据库位于远程服务器上，情况可能会更严重。低性能有两个主要原因:</p><ul class=""><li id="f963" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">需要为每条记录创建一个ORM实例。</li><li id="dac2" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">由于ORM的<a class="ae ku" href="https://martinfowler.com/eaaCatalog/unitOfWork.html" rel="noopener ugc nofollow" target="_blank">工作单元</a>设计，主键和其他默认值需要返回到ORM实例。</li></ul><p id="1263" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第二个更有影响力，如果我们为创建的ORM实例提供主键，就可以证明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2130" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">警报:</p><ul class=""><li id="0ea6" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">如果主键是自动递增的，并且是像这里这样显式指定的，则它不能为零，否则数据可能无法成功插入。你可以试着把<code class="fe nn no np nq b">id=idx+1</code>改成<code class="fe nn no np nq b">id=idx</code>，看看自己是否也会这样。</li></ul><p id="a22f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">事实证明，如果提供主键，性能可以得到显著提高。这太棒了！然而，这并不是使用SQLAlchemy执行批量插入的最有效的方式，有时它可能不适用于指定主键，所以请耐心等待。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="2e64" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">使用Session.bulk _ save _对象</h2><p id="2c6f" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">SQLAlchemy有一些专门为批量操作设计的方法。对于批量插入，有<code class="fe nn no np nq b">Session.bulk_save_objects()</code>和<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>。<code class="fe nn no np nq b">Session.bulk_save_objects()</code>将ORM实例列表作为参数，类似于<code class="fe nn no np nq b">Session.add_all()</code>，而<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>将映射/字典列表作为参数。我们这里用<code class="fe nn no np nq b">Session.bulk_save_objects()</code>，后面用<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>。</p><p id="823a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在开始使用它之前，我们应该知道<code class="fe nn no np nq b">Session.bulk_save_objects()</code>的两个主要注意事项:</p><ul class=""><li id="03df" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">大多数ORM的好处，比如外键关系和属性的自动更新，对于通过这种方法传递的ORM实例是不可用的。如果我们想有这些好处，那么就不应该用这种方法，而应该用<code class="fe nn no np nq b">Session.add_all()</code>来代替。</li><li id="22d1" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">我们不应该返回插入的ORM实例的主键，否则，性能会大大降低。如果我们需要返回主键，我们也应该使用<code class="fe nn no np nq b">Session.add_all()</code>来代替。</li></ul><p id="c2af" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在下面的代码片段中，我们将执行三个测试并比较它们的性能:</p><ul class=""><li id="c306" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">使用返回主键的<code class="fe nn no np nq b">Session.bulk_save_objects()</code>。</li><li id="e846" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">使用<code class="fe nn no np nq b">Session.bulk_save_objects()</code>而不返回主键。</li><li id="0e20" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">使用<code class="fe nn no np nq b">Session.bulk_save_objects()</code>并明确指定主键。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2577" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当运行这三个测试时，它表明当返回主键时，性能确实急剧下降。然而，与<code class="fe nn no np nq b">Session.add_all()</code>的情况不同，是否为ORM实例指定主键并没有多大关系。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="e41e" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">使用bulk_insert_objects</h2><p id="b063" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">另一个用于批量插入的SQLAlchemy方法是<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>。顾名思义，映射列表(Python中的字典)作为该方法的参数传递。直接使用映射的好处是避免创建ORM实例的开销，这通常不是问题，但是当需要创建和保存大量ORM实例时，这就变得很重要了。</p><p id="6246" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在下面的代码片段中，我们将执行两个测试并比较它们的性能:</p><ul class=""><li id="3791" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">使用没有指定主键的<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>。</li><li id="b83f" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">使用指定主键的<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c63b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以上测试速度极快。如果没有指定主键，它比<code class="fe nn no np nq b">Session.bulk_save_objects()</code>快两倍，而【】又比<code class="fe nn no np nq b">Session.add_all()</code>快五倍。此外，与<code class="fe nn no np nq b">Session.bulk_save_objects()</code>类似，如果为要保存的映射指定了主键，也没有多大关系。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="e43e" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">使用SQLAlchemy核心API</h2><p id="da97" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">SQLAlchemy ORM模型建立在核心API之上。如果性能是唯一的目标，我们应该使用直接插入的核心API，避免ORM模型的所有开销。</p><p id="0710" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以使用<a class="ae ku" href="https://docs.sqlalchemy.org/en/14/core/tutorial.html" rel="noopener ugc nofollow" target="_blank"> SQL表达式语言</a>来访问SQLAlchemy的核心API。使用SQL表达式语言的好处是能够直接访问核心API，从而实现高性能，同时提供适用于所有类型的关系数据库的后端/数据库中立语言。我们将在下一节介绍普通MySQL查询的直接用法。</p><p id="43ed" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以使用ORM类的<code class="fe nn no np nq b">__table__</code>属性来访问提供<code class="fe nn no np nq b"><a class="ae ku" href="https://docs.sqlalchemy.org/en/14/core/dml.html#sqlalchemy.sql.expression.Insert" rel="noopener ugc nofollow" target="_blank">Insert</a></code>结构的底层<code class="fe nn no np nq b"><a class="ae ku" href="https://docs.sqlalchemy.org/en/14/core/metadata.html#sqlalchemy.schema.Table" rel="noopener ugc nofollow" target="_blank">Table</a></code>对象。类似于<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>，映射/字典列表可以传递给<code class="fe nn no np nq b">Insert</code>构造。然而，一个SQLAlchemy <code class="fe nn no np nq b"><a class="ae ku" href="https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection" rel="noopener ugc nofollow" target="_blank">Connection</a></code>对象用于执行插入表达式，而不是一个<code class="fe nn no np nq b"><a class="ae ku" href="https://docs.sqlalchemy.org/en/14/orm/session_api.html#sqlalchemy.orm.Session" rel="noopener ugc nofollow" target="_blank">Session</a></code>对象。</p><p id="aa6b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在下面的代码片段中，我们将执行两个测试并比较它们的性能:</p><ul class=""><li id="0b32" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">使用核心API插入没有主键的字典列表。</li><li id="60fb" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated">使用核心API插入指定了主键的字典列表。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="860b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上面的测试甚至比使用<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>、<em class="mw">还要快，但比</em>快不了多少，因为这里完全避免了使用ORM模型的开销。此外，如果为要保存的映射指定了主键，也没有多大关系。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="4cdc" class="ly lz it bd ma mb mc dn md me mf dp mg le mh mi mj li mk ml mm lm mn mo mp mq bi translated">使用普通SQL查询</h2><p id="23b9" class="pw-post-body-paragraph kv kw it kx b ky mr ju la lb ms jx ld le mt lg lh li mu lk ll lm mv lo lp lq im bi translated">如果你是一个只想处理普通SQL查询而根本不想处理核心API或ORM的守旧派，你可以使用<code class="fe nn no np nq b">Connection.exec_driver_sql()</code>来执行批量插入，它直接利用底层DBAPI，与使用上面所示的核心API具有相同的性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="749c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你想了解更多关于在SQLAlchemy中执行普通SQL查询的信息，请查看这篇文章。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="fffb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所有例子的代码都可以在<a class="ae ku" href="https://gist.github.com/lynnkwong/be9532672302eed25675e2adbfa5a1c2" rel="noopener ugc nofollow" target="_blank">这里</a>找到。一旦安装了库并设置了MySQL服务器，就可以直接运行它。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="4d53" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，介绍了批量插入的不同SQLAlchemy方法。以简单易懂的方式介绍了它们的代码，并系统地比较了它们的性能。</p><p id="39b7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">总之，如果您使用普通的SQL查询，您不需要担心SQLAlchemy的性能，因为它直接调用底层的DBAPI。应该优化的是查询本身。</p><p id="52a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你坐在中间，不使用普通的SQL查询或ORM模型，而是使用所谓的表达式语言，你可以使用直接访问核心API的<code class="fe nn no np nq b">Insert</code>构造来执行批量插入，这也非常有效。</p><p id="65a7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，如果您使用ORM模型，并且希望在插入后访问ORM实例的更新状态，那么您应该使用<code class="fe nn no np nq b">Session.add_all()</code>。如果可能，请提供主键，因为这样可以显著提高性能。另一方面，如果您使用ORM模型，并且不需要访问更新的数据，您可以使用与核心API效率相当的<code class="fe nn no np nq b">Session.bulk_insert_mappings()</code>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="6aee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">相关文章:</p><ul class=""><li id="7d4f" class="mz na it kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated"><a class="ae ku" href="https://betterprogramming.pub/how-to-execute-plain-sql-queries-with-sqlalchemy-627a3741fdb1" rel="noopener ugc nofollow" target="_blank">如何用Python中的SQLAlchemy执行普通SQL查询</a></li><li id="a56f" class="mz na it kx b ky ni lb nj le nk li nl lm nm lq ne nf ng nh bi translated"><a class="ae ku" href="https://levelup.gitconnected.com/learn-the-basics-and-get-started-with-sqlalchemy-orm-from-scratch-66c8624b069" rel="noopener ugc nofollow" target="_blank">学习基础知识并开始使用SQLAlchemy ORM </a></li></ul></div></div>    
</body>
</html>