<html>
<head>
<title>Long and Wide Formats in Data, Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据中的长和宽格式，已解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/long-and-wide-formats-in-data-explained-e48d7c9a06cb#2022-02-25">https://towardsdatascience.com/long-and-wide-formats-in-data-explained-e48d7c9a06cb#2022-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/89b958c5371a285f41748786d7aa032a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*556dins5G1WqvrVCgcz1pw.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自<a class="ae jd" href="https://www.pexels.com/photo/panda-bear-on-green-grass-3608263/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae jd" href="https://www.pexels.com/@laurathexplaura?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">劳拉拍摄的爆炸</a></p></figure><div class=""/><div class=""><h2 id="08ef" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">如何以熊猫的方式对待他们</h2></div><p id="9932" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">表格是一种二维的、非常常用的存储和准备数据的形式，这可以通过两种方式实现:宽格式和长格式。每一个都有一些优点和缺点，我会尽我所能在这篇文章中用一些例子来描述。所以让我们开始吧。</p><p id="e846" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh"> TL/DR </strong>。最好使用长格式来存储数据，并在数据分析过程的最后使用宽格式来降低数据维度。使用 Pandas 从一种格式转换到另一种格式就像编写一行代码一样简单。</p><h2 id="0538" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">宽幅</h2><p id="3ebd" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">你可以把宽幅想象成“Excel”的样子。想想这个。你有销售人员和去年每笔销售的数据，按月分组，你如何用表格的方式表示呢？好吧，你在行中写下销售人员的名字，在列中写下年月的名字，然后在每个行/列的交叉点上写下每个销售人员的销售额($)。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="87d4" class="lr ls jg mu b gy my mz l na nb">name    jan    feb    mar    apr  ... dec<br/>jim     $100   $200   $200   $300     $300<br/>mike    $200   $250   $50    $100     $170</span></pre><p id="4119" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为太宽了，所以我用了三个点(…)来不写四月和十二月之间的月份。您可能会说:“假设您有一个数据，按销售人员和月份分组的销售额，一个宽格式的表格可以轻松处理所有事情”。你是对的，到目前为止没问题。让我们把这个变得更难一点。假设您现在不仅有销售额($)，还有每个销售人员售出的商品数量。你再做一张像这样的桌子。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="400a" class="lr ls jg mu b gy my mz l na nb">name    jan    feb    mar    apr  ... dec<br/>jim     10     10     10     30       30<br/>mike    5      20     7      25       5</span></pre><p id="6d3f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在您有两个宽格式的表格。如果您现在要收集每个销售人员每月工作的小时数，您现在会有 3 张表。我开始觉得这越来越重复了，你不觉得吗？</p><p id="1c45" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很难想出一种方法来让我放心地将这些数据存储在数据库中。三个表存储相同月份的相同人员的数据，唯一的区别是存储的数据类型？如果我们现在想为每个销售人员存储 20 个点的数据(特征)该怎么办？我想你已经明白这个问题了。让我们试着解决它。</p><p id="8a44" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些数据可以存储在一个可以生成所有这些表的表中吗？输入长格式。</p><p id="2e33" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是首先，只是为了继续扩大(再次双关)这种混乱的丑陋…让我们假设您尝试使用一种广泛的方法来解决这个问题，如<em class="nc">“我为名称添加一列，为月份添加另一列，然后为每个功能添加一列”</em>；像这样的解决方案。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="2364" class="lr ls jg mu b gy my mz l na nb">name    month    sales   items_count   hours_worked<br/>jim     jan      bla     bla           bla<br/>mike    feb      bla     bla           bla<br/>...</span></pre><p id="8fee" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">嗯……这可能行得通，你不觉得吗？至少你只有一张桌子。是的，但是如果由于某种原因你的需求改变了，你需要添加(或删除)特性，你将不得不<em class="nc">物理地</em>修改这个表。另一个问题可能是，如果一个销售人员可能没有所有的功能，但只有一个子集(或一个):你会有许多空单元格。如果你用的是一个只有几行几列的 Excel 笔记本，这不成问题，但是，如果这些数据存储在一个比如说 Postgres 数据库中，每次你的数据结构改变时，你都必须运行一些<a class="ae jd" href="https://www.postgresql.org/docs/9.1/sql-altertable.html" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> alter </em>命令</a>，而且还会因为空单元格而浪费空间。我不太喜欢这个想法。你呢？</p><p id="4ad3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在真的，进入长格式。</p><h2 id="c5ae" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">长格式</h2><p id="3e7a" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">没有太多的序言，让我向您展示上述相同的数据，但使用长格式。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0920" class="lr ls jg mu b gy my mz l na nb">name    month    kpi     value</span><span id="bb9c" class="lr ls jg mu b gy nd mz l na nb">jim     jan      amount  100<br/>jim     feb      amount  120<br/>...<br/>jim     jan      items   10<br/>jim     feb      items   10<br/>...<br/>mike    dec      amount  170<br/>...<br/>mike    dec      items   5</span></pre><p id="85d5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为它太长了(又是双关语),我再次用了三点来说明表中没有显示所有的信息。现在我们不是每月一个专栏，而是每个特性一个专栏，再加上一个月和名字专栏。这种方法的优点如下。</p><ul class=""><li id="8b87" class="ne nf jg kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">如果丢失了一些数据，也不会浪费空间。如果发生这种情况，那么行将不存在，如此而已。</li><li id="479f" class="ne nf jg kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">如果由于某种原因添加了新功能，您不必修改表结构，只需根据需要通过添加具有新功能的行来修改数据。</li></ul><h2 id="b81d" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">另一个长格式示例</h2><p id="2dee" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">想想这个问题。你正在记录网站上的互动，有三种类型:查看、点击和转换。当前的任务是生成一个表格，显示每天有多少浏览、点击和转换。</p><p id="e640" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们假设当一个交互发生时，你接收到两条信息:交互的日期和时间及其类型。了解了这一点，长格式表将如下所示。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="f127" class="lr ls jg mu b gy my mz l na nb">type    date<br/>view    2021-12-12 23:00<br/>click   2021-12-12 23:30</span></pre><p id="e49b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于每次交互，数据都存储在一个新行中，每一行都记录了事件的类型和记录时间。现在，让我们处理报告部分。要做到这一点，一些 Python 和熊猫的魔法会很方便。</p><h2 id="724d" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">代码</h2><p id="8533" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">假设创建了这个表，并且每天都记录数据，我们可以使用一个函数来获取它。在这种情况下，该函数伪造数据，在现实世界中，该函数将从数据库或其他数据源中检索数据。</p><p id="05b3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先要导入 Numpy 和 Pandas，并创建一个函数来伪造数据。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b589" class="lr ls jg mu b gy my mz l na nb">def build_dataframe(periods=100):<br/>    """<br/>    Creates columns with random data.<br/>    """</span><span id="31d8" class="lr ls jg mu b gy nd mz l na nb">import random</span><span id="5d46" class="lr ls jg mu b gy nd mz l na nb">random.seed(10)</span><span id="a78d" class="lr ls jg mu b gy nd mz l na nb">data = {<br/>        'type': random.choices(population=['impressions', 'clicks', 'conversions'], weights=[100, 10, 1], k=periods)<br/>    }</span><span id="51fd" class="lr ls jg mu b gy nd mz l na nb">from datetime import date, timedelta<br/>    from random import choices<br/>    <br/>    # create some random dates in a test period <br/>    test_date1, test_date2 = date(2020, 1, 1), date(2020, 2, 1)<br/>        <br/>    res_dates = [test_date1]<br/>    <br/>    # loop to get each date till end date<br/>    while test_date1 != test_date2:<br/>        test_date1 += timedelta(days=1)<br/>        res_dates.append(test_date1)<br/>    <br/>    # random dates<br/>    res = choices(res_dates, k=periods)<br/>    <br/>    df = pd.DataFrame(data)<br/>    df['date'] = res<br/>    <br/>    return df</span><span id="5a8e" class="lr ls jg mu b gy nd mz l na nb"># retrieve the data</span><span id="448e" class="lr ls jg mu b gy nd mz l na nb">long_df = build_dataframe(periods=500)</span></pre><p id="f14b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不会详细谈论这里发生的事情，因为这不太相关。检索到的数据如下所示。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/deb337c0b4daf3fc1b8e442e37106519.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*XOvgn0qviGD-trtXJMwz5A.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">build_dataframe 函数检索由两列描述的 500 行数据。图片由作者提供。</p></figure><p id="9e21" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个数据点都包含预期的事件类型和日期。我们有数据要处理。在继续之前，让我们考虑一下我们要实现的宽表格格式应该是什么样子。</p><p id="06bc" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们希望每个日期有一行，三列:印象，点击和转换。每行/列的交叉点将包含每个日期的每个事件的计数。表格输出应该如下所示。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="b2ac" class="lr ls jg mu b gy my mz l na nb">date         impressions     clicks     conversions<br/>2020-01-01   1000            20         1<br/>...<br/>2020-01-15   500             2          n/a<br/>...</span></pre><p id="4bf0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意转换列中的<em class="nc"> n/a </em>值，这意味着在长格式源中没有该类型/日期组合的数据。</p><p id="77ca" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今后的任务概述如下。</p><ol class=""><li id="d5c4" class="ne nf jg kx b ky kz lb lc le ng li nh lm ni lq nt nk nl nm bi translated">创建一个列来保存事件计数</li><li id="6e22" class="ne nf jg kx b ky nn lb no le np li nq lm nr lq nt nk nl nm bi translated">对长格式表进行分组，以便每个可能的日期/类型组合都有一行</li><li id="71d2" class="ne nf jg kx b ky nn lb no le np li nq lm nr lq nt nk nl nm bi translated">使用 Pandas pivot 函数构建宽格式表格输出</li><li id="87c2" class="ne nf jg kx b ky nn lb no le np li nq lm nr lq nt nk nl nm bi translated">使用 Pandas melt 函数重建长格式表格输入</li></ol><p id="1003" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成所有后者的代码如下。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="a6e7" class="lr ls jg mu b gy my mz l na nb"># Step 1: add a count column to able to summarize when grouping<br/>long_df['count'] = 1</span><span id="0746" class="lr ls jg mu b gy nd mz l na nb"># Step 2: group by date and type and sum<br/>grouped_long_df = long_df.groupby(['date', 'type']).sum().reset_index()</span><span id="cc29" class="lr ls jg mu b gy nd mz l na nb"># Step 3: build wide format from long format<br/>wide_df = grouped_long_df.pivot(index='date', columns='type', values='count').reset_index()</span><span id="b354" class="lr ls jg mu b gy nd mz l na nb"># Step 4: build long format from wide format<br/>new_long_df = new_long_df = pd.melt(wide_df, id_vars=['date'], var_name='type', value_vars=['impressions', 'clicks', 'conversions'], value_name='count')</span></pre><p id="2a34" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">哇！只需四行代码就可以完成所需的转换。如果你熟悉熊猫，步骤 1 和 2 是不言自明的，所以让我们解释一下步骤 3 和 4 中发生了什么。</p><p id="b9f6" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">第三步</strong></p><p id="792b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">熊猫<em class="nc"> pivot </em>函数需要一个长格式输入，其中作为索引参数传递的所需列的值对于每个索引/列(日期/类型)组合都是唯一的。这就是为什么需要对原始的长格式表进行分组，以便每个日期/类型组合有一行。Pandas 将为 type 列中的每个值创建一个列，并将 count 列中的值放在 date/type 交集中，如 values 参数所述。让我们看看 wide_df 变量中包含的表。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e65b8e77997f527947ee26d4fe0bbdce.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*GPIUtKm5PD-yCSVeB9FRrg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">wide_df 的内容。图片由作者提供。</p></figure><p id="56df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，每个日期有一行，有 3 个数据列:印象、点击和转换。当 Pandas 在任何给定日期找不到某个类型的相应值时，就会插入一个 NaN 值。这太棒了！</p><blockquote class="nv nw nx"><p id="944a" class="kv kw nc kx b ky kz kh la lb lc kk ld ny lf lg lh nz lj lk ll oa ln lo lp lq ij bi translated">随着第三步的完成，我们可以说我们的工作已经完成了。我们生成了一个表，其中包含检索到的每个日期的事件计数。<strong class="kx jh">干得好！</strong></p></blockquote><p id="3b5d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以把这个放在一个<a class="ae jd" href="https://jonathanserrano.medium.com/a-streamlit-dashboard-5-steps-from-zero-to-docker-deployed-b06b9df940c8" rel="noopener"> Streamlit 仪表盘</a>里？</p><p id="6a0e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们集中精力完成最后一步。</p><p id="b087" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">第四步</strong></p><p id="acae" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Pandas <em class="nc"> melt </em>函数从宽格式数据帧构建一个长格式数据帧。该函数希望您告诉它 1)哪一列将用作新行引用(id_vars)，在我们的示例中是日期列，2)哪些列将被堆叠到新列中(value_vars)，3)它的名称是什么(var_name)，最后 4)包含堆叠列值的列的名称是什么(value_name)。</p><p id="fa0c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果存储在 new_long_df 变量中，如下所示。</p><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/570538f4cb06f7520c59bc2e3c1b9be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*x9xzC54UZc6IriaH4mZByg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">new_long_df 数据帧内容。图片由作者提供。</p></figure><p id="f619" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来和 build_dataframe 函数创建的 dataframe 非常相似！然而<em class="nc">非常相似</em>是不够的，我们应该通过比较 new_long_df 和 grouped_long_df 中包含的一个日期的数据来进一步挖掘。</p><p id="4754" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">日期 2020 年 1 月 1 日怎么样？让我们通过查询两个数据框来尝试一下。</p><p id="fa7f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一个 new_long_df。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="88f7" class="lr ls jg mu b gy my mz l na nb">new_long_df[new_long_df['date'] == datetime.date(2020, 1, 1)]</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c298e7764aa6c6a02352f22b5e3fe884.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*63B7bbF5YsHth-2DrP0AiQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">new_long_df 中包含的日期为 2020 年 1 月 1 日的数据。图片由作者提供。</p></figure><p id="42c3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在原 grouped_long_df。</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0962" class="lr ls jg mu b gy my mz l na nb">grouped_long_df[grouped_long_df['date'] == datetime.date(2020, 1, 1)]</span></pre><figure class="mp mq mr ms gt is gh gi paragraph-image"><div class="gh gi od"><img src="../Images/82b7086361d1186a9203515bd5cb9036.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*DEaqfuo6gQNVT2H_ry3ykg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">grouped_long_df 日期为 2020 年 1 月 1 日的内容。图片由作者提供。</p></figure><p id="1271" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这对于我来说已经足够了:两个数据框都同意当天有 1 次点击，18 次展示，零转化！</p><h2 id="8740" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结论</h2><p id="40f6" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这篇文章试图通过一些例子来描述什么是长表格和宽表格，以及如何使用 Python 和 Pandas 来处理它们。每种格式最适合某些任务:长格式允许更密集地存储数据，而宽格式在报表中需要表格格式时具有更强的解释力。根据您期望完成的任务，选择哪种格式效果最好由您决定。</p><p id="18d7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在这里找到一个谷歌 Colab 笔记本<a class="ae jd" href="https://colab.research.google.com/gist/jonaths/c81432384c2e9aa8b246c79e3f17a173/long_short_format.ipynb" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="dc54" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nc">如果你喜欢这些内容，请关注我并分享！</em></p></div></div>    
</body>
</html>