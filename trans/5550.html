<html>
<head>
<title>Solving Optimization Problems With A Quantum Computer Is Surprisingly Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用量子计算机解决最优化问题出奇的容易</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/solving-optimization-problems-with-a-quantum-computer-is-surprisingly-easy-b89afd3bbbb3#2022-12-14">https://towardsdatascience.com/solving-optimization-problems-with-a-quantum-computer-is-surprisingly-easy-b89afd3bbbb3#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="abc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用量子近似优化算法(QAOA)解决图划分问题</h2></div><p id="25b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_qaoaex&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用 Python </strong> </a> <strong class="kk iu">。</strong></p><p id="a714" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lf">你可以在</em> <a class="ae le" href="https://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank"> <em class="lf">下的</em></a><a class="ae le" href="https://www.kaggle.com/csanhueza/the-marvel-universe-social-network" rel="noopener ugc nofollow" target="_blank"><em class="lf">Kaggle</em></a><em class="lf">上访问这篇文章中使用的数据集。</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/baf7e7b6e86f03760432ac9ef2208818.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qln4JW0wnqaPa_aOltek0A.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">作者图片</p></figure><p id="284a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您有一个计算密集型任务。例如，你打算从头开始训练 GPT-3。但是你不想等几百年才能完成训练。为了加快速度，你必须将所有需要的计算并行化。但是，当然，你不能简单地用 GPU 来解决问题。但是，您必须指定如何在可用的 GPU 之间分配计算。此外，你必须收集所有的解决方案部分，并把它们放回一起，以获得一个训练有素的 GPT-3。这些任务，分离和合并，需要沟通。</p><p id="6fd5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题是图划分问题的一个实例。所以，我们用图来表示这个问题。然后，一个节点代表一个需要的计算，一条边代表它们之间的通信。</p><p id="e55f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用权重来表示相关计算或通信的成本。假设我们有不止一个处理器来执行计算。由此产生的问题是如何分配它们。为了有效地并行化这样一个问题的计算，我们需要在处理器之间平衡计算，并最小化所需的通信。我们需要把图分成子图。</p><p id="d646" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">形式上，我们要求将节点𝑁集划分为两个大小相等的子集，以最小化连接这两个子集的边的数量。</p><p id="5272" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Qiskit 在他们的<code class="fe lw lx ly lz b">qiskit_optimization.applications</code>模块中提供了这个问题公式的实现。它允许我们用几行代码解决问题。</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="5a86" class="me mf it lz b be mg mh l mi mj">from qiskit_optimization.applications import GraphPartition<br/><br/>graph_partition = GraphPartition(use_network(8))<br/><br/>qaoa_optimizer = MinimumEigenOptimizer(QAOA(<br/>    quantum_instance=QuantumInstance(Aer.get_backend("qasm_simulator"))<br/>))<br/><br/>result = qaoa_optimizer.solve(<br/>    graph_partition.to_quadratic_program()<br/>)<br/><br/>print("solution:", graph_partition.interpret(result))<br/>print("time:", result.min_eigen_solver_result.optimizer_time)<br/>#CAPTION Solving the graph partitioning problem</span></pre><pre class="mk ma lz mb bn mc md bi"><span id="f4e6" class="me mf it lz b be mg mh l ml mj">solution: [[4, 5, 6, 7], [0, 1, 2, 3]]<br/>time: 18.636014461517334</span></pre><p id="917e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们导入问题公式<code class="fe lw lx ly lz b">GraphPartition</code>(第 1 行)并创建一个基于八节点网络的实例(第 3 行)。</p><p id="45de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lf">备注:</em> <code class="fe lw lx ly lz b"><em class="lf">use_network</em></code> <em class="lf">和</em> <code class="fe lw lx ly lz b"><em class="lf">draw_graph</em></code> <em class="lf">功能是创建指定规模网络的便利功能。为了完整起见，你可以在本文末尾找到它们的实现。</em></p><p id="0876" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建一个相应的优化器(<code class="fe lw lx ly lz b">MinimumEigenOptimizer</code>)并提供一个特征求解器的实例(这里是<code class="fe lw lx ly lz b">QAOA</code>)和一个<code class="fe lw lx ly lz b">QuantumInstance</code>(第 5-7 行)。最后，我们基于它的二次程序表示(第 10 行)来解决这个问题(第 9 行)。结果我们得到了两个数组。让我们看看他们。</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="5684" class="me mf it lz b be mg mh l mi mj">draw_graph(use_network(8),  ''.join(str(int(x)) for x in result.x[::-1]))<br/>#CAPTION Display the solution</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mm"><img src="../Images/dcfde2a06a6cb1b03729ff013c5e448c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7WeQaSe0ew9pXynLNOBWA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">作者图片</p></figure><p id="f4da" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乍一看，分离似乎是合理的。我们给每组分配了四个节点。然而，它不是最佳的。直觉上，我们期望有两个连接组的解决方案。但是，第一组被分成了两半。但是，看看这三个节点<code class="fe lw lx ly lz b">0</code>、<code class="fe lw lx ly lz b">2</code>、<code class="fe lw lx ly lz b">3</code>。它们的边缘重量很大，所以切割它们的成本很高。但是，如果我们的目标是两个完全相连的组，我们将不可避免地穿过这个子组。</p><p id="5e40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，两个节点<code class="fe lw lx ly lz b">2</code>和<code class="fe lw lx ly lz b">3</code>本身具有非常高的权重。因此，将它们放在同一个集合中似乎不是最佳的。让我们尝试改进解决方案，指定对<code class="fe lw lx ly lz b">QAOA</code>(第 5-7 行)的重复次数，并重复该过程。</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="47f4" class="me mf it lz b be mg mh l mi mj">qaoa_optimizer = MinimumEigenOptimizer(QAOA(<br/>    quantum_instance=QuantumInstance(Aer.get_backend("qasm_simulator")),<br/>    reps=3<br/>))<br/>#CAPTION Specify repititions</span></pre><pre class="mk ma lz mb bn mc md bi"><span id="167e" class="me mf it lz b be mg mh l ml mj">solution: [[1, 5, 6, 7], [0, 2, 3, 4]]<br/>time: 45.2559118270874</span></pre><pre class="mk ma lz mb bn mc md bi"><span id="8b08" class="me mf it lz b be mg mh l mi mj">draw_graph(use_network(8),  ''.join(str(int(x)) for x in result.x[::-1]))<br/>#CAPTION Display the solution</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mn"><img src="../Images/ce183fa93ac44dfeb63a2aba4183d4ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-d6cFlk_R_R6NjPIGvJrA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">作者图片</p></figure><p id="7a9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，该解决方案没有分离节点<code class="fe lw lx ly lz b">2</code>和<code class="fe lw lx ly lz b">3</code>。但是，它减少了切割边的数量(3，4 之前)及其总重量(16，18 之前)。值得看看<code class="fe lw lx ly lz b">GraphPartition</code>类的实现(见<a class="ae le" href="https://qiskit.org/documentation/optimization/_modules/qiskit_optimization/applications/graph_partition.html#GraphPartition" rel="noopener ugc nofollow" target="_blank">源代码</a>)。</p><p id="9b3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在下面描述的函数<code class="fe lw lx ly lz b">to_quadratic_program</code>中找到相关代码。</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="9192" class="me mf it lz b be mg mh l mi mj">class GraphPartition(GraphOptimizationApplication):<br/>    def to_quadratic_program(self) -&gt; QuadraticProgram:<br/>        mdl = Model(name="Graph partition")<br/>        n = self._graph.number_of_nodes()<br/>        x = {i: mdl.binary_var(name=f"x_{i}") for i in range(n)}<br/>        for w, v in self._graph.edges:<br/>            self._graph.edges[w, v].setdefault("weight", 1)<br/>        objective = mdl.sum(<br/>            self._graph.edges[i, j]["weight"] * (x[i] + x[j] - 2 * x[i] * x[j])<br/>            for i, j in self._graph.edges<br/>        )<br/>        mdl.minimize(objective)<br/>        mdl.add_constraint(mdl.sum([x[i] for i in x]) == n // 2)<br/>        op = from_docplex_mp(mdl)<br/>        return op<br/>#CAPTION The graph partitioning problem in Qiskit</span></pre><p id="45e2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数首先定义<code class="fe lw lx ly lz b">Model</code>(第 3 行)、变量(第 4-5 行)，以及未指定的边的默认权重(第 6-7 行)。</p><p id="c075" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的部分是定义我们要最小化的目标函数(第 8-11 行)(第 12 行)。只有当一条边连接两个不同类的节点时，它才对这条边的权重求和(第 9 行)。这里，<code class="fe lw lx ly lz b">i</code>和<code class="fe lw lx ly lz b">j</code>表示边缘的位置(在第 10 行中定义)。<code class="fe lw lx ly lz b">x[i]</code>和<code class="fe lw lx ly lz b">x[j]</code>表示这些节点的分配。他们不是<code class="fe lw lx ly lz b">0</code>就是<code class="fe lw lx ly lz b">1</code>。所以。只有当<code class="fe lw lx ly lz b">x[i]</code>和<code class="fe lw lx ly lz b">x[j]</code>不同时，术语<code class="fe lw lx ly lz b">(x[i] + x[j] - 2 * x[i] * x[j])</code>才是<code class="fe lw lx ly lz b">1</code>。否则整个学期都是<code class="fe lw lx ly lz b">0</code>。</p><p id="4ae0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，这个程序包含一个约束。所有节点分配的总和必须等于节点总数除以 2。因此，正好一半的节点必须在类<code class="fe lw lx ly lz b">0</code>中，另一半在类<code class="fe lw lx ly lz b">1</code>中。</p><p id="3517" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，这个目标函数没有考虑节点的权重。因此，让我们自定义它并考虑节点的权重。</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="5fab" class="me mf it lz b be mg mh l mi mj">class NodeWeightedGraphPartition(GraphPartition):<br/>    def to_quadratic_program(self) -&gt; QuadraticProgram:<br/>        mdl = Model(name="Graph partition")<br/>        n = self._graph.number_of_nodes()<br/>        x = {i: mdl.binary_var(name=f"x_{i}") for i in range(n)}<br/>        for w, v in self._graph.edges:<br/>            self._graph.edges[w, v].setdefault("weight", 1)<br/>        objective = mdl.sum(<br/>            self._graph.edges[i, j]["weight"] * (x[i] + x[j] - 2 * x[i] * x[j])<br/>            for i, j in self._graph.edges<br/>        ) + mdl.sum(<br/>            self._graph.nodes[i]["weight"] * (1-2*x[i])<br/>            for i in self._graph.nodes<br/>        )**2<br/>        mdl.minimize(objective)<br/>        mdl.add_constraint(mdl.sum([x[i] for i in x]) == n // 2)<br/>        op = from_docplex_mp(mdl)<br/>        return op<br/>#CAPTION The extended graph partitioning problem</span></pre><p id="d205" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建一个新的类<code class="fe lw lx ly lz b">NodeWeightedGraphPartition</code>，它有父类<code class="fe lw lx ly lz b">GraphPartition</code>。所以，我们只需要覆盖我们想要改变的函数——<code class="fe lw lx ly lz b">to_quadratic_program</code>函数。</p><p id="1c7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所做的唯一更改是将节点的权重添加到<code class="fe lw lx ly lz b">objective</code>函数的计算中(第 11-14 行)。除了切割边的权重，我们将所有节点的权重相加，每个乘以<code class="fe lw lx ly lz b">(1-2*x[i])</code>，其中<code class="fe lw lx ly lz b">i</code>是节点的索引，<code class="fe lw lx ly lz b">x[i]</code>是节点的类。术语<code class="fe lw lx ly lz b">1-2*x[i]</code>要么是<code class="fe lw lx ly lz b">1</code>(如果<code class="fe lw lx ly lz b">x[i]</code>是<code class="fe lw lx ly lz b">0</code>)要么是<code class="fe lw lx ly lz b">-1</code>(如果<code class="fe lw lx ly lz b">x[i]</code>是<code class="fe lw lx ly lz b">1</code>)。通过对这些值求和，我们最终得到两个类的节点权重之间的总差值。因为这个可以小于零，我们取平方。因此，我们对来自两个同等权重类别的解进行惩罚。</p><p id="7187" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看结果如何。</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="cb7d" class="me mf it lz b be mg mh l mi mj">node_graph_partition = NodeWeightedGraphPartition(use_network(8))<br/><br/>qaoa_optimizer = MinimumEigenOptimizer(QAOA(<br/>    quantum_instance=QuantumInstance(Aer.get_backend("qasm_simulator"))<br/>))<br/><br/>result = qaoa_optimizer.solve(<br/>    node_graph_partition.to_quadratic_program()<br/>)<br/><br/>print("solution:", node_graph_partition.interpret(result))<br/>print("time:", result.min_eigen_solver_result.optimizer_time)</span></pre><pre class="mk ma lz mb bn mc md bi"><span id="61d3" class="me mf it lz b be mg mh l ml mj">solution: [[0, 3, 6, 7], [1, 2, 4, 5]]<br/>time: 1.92722749710083</span></pre><pre class="mk ma lz mb bn mc md bi"><span id="de14" class="me mf it lz b be mg mh l mi mj">draw_graph(use_network(8),  ''.join(str(int(x)) for x in result.x[::-1]))<br/>#CAPTION Display the solution</span></pre><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mo"><img src="../Images/4890fb67e5bc2d46d616437a3b40a987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVkb9YZ4PBvhirtEksOJZQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">作者图片</p></figure><p id="2ce5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们获得了与以前完全不同的解决方案。现在，节点<code class="fe lw lx ly lz b">2</code>和<code class="fe lw lx ly lz b">3</code>被分配到不同的类。但是，切割边缘的总数(6)和它们的重量(63)增加了。</p><h2 id="a706" class="mp mf it bd mq mr ms dn mt mu mv dp mw kr mx my mz kv na nb nc kz nd ne nf ng bi translated">结论</h2><p id="7160" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">最重要的是要清楚我们要求我们的算法优化什么。</p><p id="2833" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子计算是一个强大的工具，在未来将变得越来越重要。尽管大多数关于这个话题的资源都非常依赖数学，但你并不需要成为数学家来理解它。像 IBM 的 Qiskit 这样的库，在避免使用量子经典优化算法的大部分复杂性方面做得非常出色。</p><p id="86cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，这些库并没有让您摆脱对优化目标的理解。你需要确保明确你要解决的问题。如果你在问题表述上马虎，你可能会得到错误问题的正确答案。</p><div class="nm nn gp gr no np"><a href="https://pyqml.medium.com/membership" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">通过我的推荐链接加入 Medium 弗兰克齐克特|量子机器学习</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">开始使用量子机器学习(并完全访问媒体上的每个故事)完全访问所有…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">pyqml.medium.com</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od lq np"/></div></div></a></div><p id="729d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要错过下一集，订阅我的<a class="ae le" href="https://pyqml.substack.com/" rel="noopener ugc nofollow" target="_blank">子栈频道</a>。</p><p id="b9dc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_qaoaex&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手用 Python 学习量子机器</strong> </a> <strong class="kk iu">。</strong></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_qaoaex&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="a890" class="mp mf it bd mq mr ms dn mt mu mv dp mw kr mx my mz kv na nb nc kz nd ne nf ng bi translated">附录</h2><p id="5cbe" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">下面的清单包含了本文中使用的便利函数的源代码。我们使用“漫威宇宙”数据集。在<a class="ae le" href="https://creativecommons.org/licenses/by/3.0/" rel="noopener ugc nofollow" target="_blank">attribute 3.0 un ported(CC BY 3.0)</a>许可下，它可以在<a class="ae le" href="https://www.kaggle.com/csanhueza/the-marvel-universe-social-network" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上免费获得</p><pre class="lh li lj lk gt ma lz mb bn mc md bi"><span id="7d01" class="me mf it lz b be mg mh l mi mj">def select_heroes(size):<br/>     return dict(item for cnt, item in enumerate({<br/>        'MEDUSA/MEDUSALITH AM': 0,<br/>        'ARCLIGHT/PHILLIPA SO': 1,<br/>        'WOLVERINE/LOGAN ': 2,<br/>        'SCARLET WITCH/WANDA ': 3,<br/>        'ARAGORN': 4,<br/>        'OVERMIND/GROM': 5,<br/>        'BATTLEAXE/': 6,<br/>        'ION/': 7,<br/>        'PINK PEARL/': 8,<br/>        "BLACK PANTHER/T'CHAL": 9,<br/>        'PRINCESS ZANDA': 10,<br/>        'INFERNO III/SAMANTHA': 11,<br/>        'MOTHER NIGHT/SUSAN S': 12,<br/>        'VIPER II': 13,<br/>        'IRON MAIDEN/': 14,<br/>        'CARNIVORE/COUNT ANDR': 15,<br/>        'HULK III/BRUCE BANNE': 16,<br/>        'DEADPOOL/JACK/WADE W': 17,<br/>        'BLIND AL/ALTHEA': 18,<br/>        'WEASEL/JACK HAMMER': 19,<br/>        'MONTGOMERY': 20<br/>    }.items()) if cnt &lt; size)<br/>#CAPTION Select a subset of heroes<br/><br/>def use_network(size):<br/>    data = pd.read_csv('./data/hero-network.csv')<br/>    heroes = select_heroes(size)<br/>    <br/>    # filter the relations from the raw data<br/>    relations = data[(data.hero1.isin(heroes.keys())) &amp; (data.hero2.isin(heroes.keys()))]<br/>    relations = pd.DataFrame(np.sort(relations.values, axis=1), columns=relations.columns)<br/><br/>    # build unique relations with counts<br/>    relations['relation'] = [' - '.join(x) for x in np.sort(relations.to_numpy(), axis=1)]    <br/>    summed_relations = relations.groupby(['relation']).size().reset_index().rename(columns={0:'count'})<br/>    summed_relations = pd.merge(summed_relations, relations, on='relation', how='right').drop_duplicates(subset=['hero1', 'hero2'])<br/><br/>    # count the overall appearences of the heroes<br/>    count_series1 = data.groupby(['hero1']).size()<br/>    count_series2 = data.groupby(['hero2']).size()<br/>    appearences = count_series1.add(count_series2, fill_value=0)<br/><br/>    # create the graph<br/>    graph = nx.Graph()<br/>    graph.add_nodes_from(heroes.values())<br/>    graph.add_edges_from([(<br/>            heroes[rel[1][2]],<br/>            heroes[rel[1][3]]<br/>        ) for rel in summed_relations.iterrows()])<br/><br/>    # add node weight<br/>    for hero in heroes:<br/>        graph.nodes[heroes[hero]]["weight"] = appearences[hero]<br/>        graph.nodes[heroes[hero]]["name"] = hero<br/>    <br/>    # add edge weights<br/>    edge_weights = dict((<br/>            (heroes[rel[1][2]], heroes[rel[1][3]]),<br/>            rel[1][1]<br/>        ) for rel in summed_relations.iterrows())<br/>    nx.set_edge_attributes(graph, edge_weights, "weight")<br/>    <br/>    return graph<br/>#CAPTION Create the network graph<br/><br/>def draw_graph(graph, solution=None, seed=None):<br/>    labels = dict( (key, f"{key}-{val:.0f}") for (key, val) in nx.get_node_attributes(graph, 'weight').items())<br/>    edge_labels = nx.get_edge_attributes(graph, 'weight')<br/>    <br/>    plt.figure(1,figsize=(16,6)) <br/>    plt.tight_layout()<br/>    plt.subplots_adjust(bottom=-.5, right=0.5, left=-.5)<br/><br/>    node_color = ["b" if solution[-1-i] == '0' else "y" for i in range(len(solution))] if solution is not None else "#ABABAB"<br/>    <br/>    pos = nx.spring_layout(graph, seed=seed)<br/>    nx.draw_networkx_nodes(graph, pos=pos, node_color=node_color, node_size=800)<br/>    nx.draw_networkx_edges(graph, pos, width=4, edge_color ="#CDCDCD")<br/>    nx.draw_networkx_labels(graph,pos=pos, labels=labels, font_color="#000", font_size=12)<br/>    nx.draw_networkx_edge_labels(graph, edge_labels=edge_labels, pos=pos)<br/>    plt.show()<br/>#CAPTION Draw the simple graph</span></pre></div></div>    
</body>
</html>