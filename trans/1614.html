<html>
<head>
<title>Midimax Compression for Large Time-Series Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大型时序数据的Midimax压缩</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/midimax-data-compression-for-large-time-series-data-daf744c89310#2022-04-18">https://towardsdatascience.com/midimax-data-compression-for-large-time-series-data-daf744c89310#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a222" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于Python的时序曲线轻量级快速压缩算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d8b488ade62ee5141166ed2638a58d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1zTeGe1trFpRno2U"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼古拉斯·卡佩罗在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5b97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">动机</strong></p><p id="d759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可视化是用我们的数据进行推理的强大而关键的一步。然而，绘制大型时间序列数据会产生很大的文件大小，这会降低用户交互速度，并使RAM、磁盘、网络等计算资源紧张。在我的工作中，来自机械监控传感器的时间序列数据可能以1 Hz(每秒1个点)到数千Hz的速率记录，每个传感器每天轻松生成100k+个点，几天内生成数百万个点。除了数据长度的挑战之外，为了观察相关性，绘图通常需要多个变量，从而加剧了资源限制。</p><p id="6da1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文介绍了一种称为“Midimax”的数据压缩算法，该算法专门用于通过减少数据大小来提高时间序列图的性能。该名称表示从原始时间序列数据中分离出窗口的最小值、中间值和最大值点的基本方法。开发Midimax算法时考虑了以下三个目标:</p><ol class=""><li id="bce9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它不应该引入非实际数据。这意味着只返回原始数据的一个子集，因此没有平均、中值插值、回归和统计聚合。在绘图时避免对底层数据进行统计操作是有好处的，但是我们在这里不讨论它们。</li><li id="4854" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它必须速度快，计算量小。它必须在消费者电脑和笔记本电脑上运行。理想情况下，它应该在不到3秒的时间内处理100k个点，从而允许扩展到更长的数据和更多的变量。</li><li id="7fd2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它应该最大限度地获取信息。这意味着它应该尽可能多地捕捉原始数据中的变化。这就是需要最小点和最大点的地方。</li><li id="4dae" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">(与第3点相关)由于单独取最小值和最大值可能给出夸大方差的错误观点，因此取中间点来保留关于信号稳定性的信息。</li></ol></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="23cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">工作原理</strong></p><p id="9fc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解Midimax的工作原理，这里有一段伪代码:</p><ol class=""><li id="dd99" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">向算法输入时间序列数据(例如Python熊猫序列)和压缩因子(浮点数)。</li><li id="7d27" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将时间序列数据分割成大小相等的非重叠窗口，其中大小计算如下:<em class="mn"> window_size = floor(3 *压缩因子)。</em>3代表从每个窗口获取的最小值、中间值和最大值。因此，要实现2倍的压缩系数，窗口大小必须为6。更大的系数需要更宽的窗口。</li><li id="04ce" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">按升序对每个窗口中的值进行排序。</li><li id="ec60" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">选择最小和最大点的第一个和最后一个值。这将确保我们最大化差异并保留信息。</li><li id="07e5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">选择中间值，其中中间位置定义为<em class="mn">med _ index = floor(window _ size/2)。</em>因此，即使窗口大小为偶数，也不会进行插值。在Python中，索引从0开始。</li><li id="17fc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">根据原始索引(即时间戳)对选取的点进行重新排序。</li></ol><p id="5177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图1中的示例显示了1秒采样率的原始数据(蓝线)和系数为2的压缩输出(绿点)。这意味着压缩后减少了50%的点，因此在50秒处只有25个绿点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/763252cf1469c64449ff79a1eb9b1d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJ0aymi9Uw_yzUeD--hxbg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图Midimax的输出示例。蓝线是原始数据。绿点是压缩数据。(图片由作者提供)。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/23393d59785fb607a6a4c719fa98f038.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*wsJCKpaYp-K-ELW1VbDc0Q.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1放大到前6个数据点。(图片由作者提供)。</p></figure><p id="b1f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">完整代码</strong></p><p id="7826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Python编写的完整代码可以从GitHub获得。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会注意到Python代码中的一些算法改进，这些改进在上面的伪代码中没有提到。这些增加减少了处理空值或常量重复值时的计算量。当窗口包含常量值时，代码仅返回1个点，而不是3个冗余点。空值和冻结值的存在将导致更高的最终压缩因子。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="603d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">表演</strong></p><p id="2bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进行了性能测试，以生成具有一百万个点的模拟时间序列数据的<a class="ae kv" href="https://docs.bokeh.org/en/latest/" rel="noopener ugc nofollow" target="_blank">散景</a>图。作为基准测试的参考，测试的计算环境设置为:Windows 10 64位笔记本电脑，16 GB RAM，SSD磁盘，英特尔酷睿i5 1.7 GHz处理器，Python 3.7.10，Pandas 0.25.1，Bokeh 2.3.2。</p><p id="9f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输入数据由正弦波加100，000个数据点的高斯噪声生成，并在传递到压缩函数之前保存为Pandas系列。数据的开始部分绘制在上面的图1中。</p><p id="8b1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示绘图性能的Python代码如下:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="f84c" class="mx my iq mt b gy mz na l nb nc">import time<br/>import numpy as np<br/>import pandas as pd</span><span id="65ba" class="mx my iq mt b gy nd na l nb nc">n = 100000 # points<br/>timesteps = pd.to_timedelta(np.arange(n), unit=’s’)<br/>timestamps = pd.to_datetime(“2022–04–18 08:00:00”) + timesteps</span><span id="9977" class="mx my iq mt b gy nd na l nb nc">sine_waves = np.sin(2 * np.pi * 0.02 * np.arange(n))<br/>noise = np.random.normal(0, 0.1, n)<br/>signal = sine_waves + noise<br/>ts_data = pd.Series(signal, index=timestamps).astype(‘float32’)</span><span id="c0e0" class="mx my iq mt b gy nd na l nb nc"># Run compression<br/>timer_start = time.time()<br/>ts_data_compressed = compress_series(ts_data, 2)<br/>timer_sec = round(time.time() — timer_start, 2)<br/>print(‘Compression took’, timer_sec, ‘seconds.’)</span><span id="5703" class="mx my iq mt b gy nd na l nb nc">&gt; Compression took 0.45 seconds.</span></pre><p id="fc21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上面的代码片段所示，该算法在1.42秒内完成了将100k个点压缩2倍的<strong class="ky ir">。由于要处理的窗口数量较少，压缩因子越高，完成得越快。对相同数据运行4和8的压缩因子分别在0.74秒和0.44秒内完成。通过因子2压缩100万个点在14.87秒内完成。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ff15184e9726cf35b56d9a98ee3d52bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*AuG17SA2UlnZRylT3I0Iqg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2)压缩系数为2和4的Midimax算法运行时间。(图片由作者提供)。</p></figure><p id="c65c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图2描绘了不同压缩因子和数据大小的算法运行时间。我们可以观察到运行时间随着数据点的数量线性增长。这种线性行为允许在应用程序纵向扩展时预测性能。</p><p id="527a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">衡量性能的另一个标准是绘图的最终文件大小。100万点的散景图HTML文件大小在2X压缩之前<strong class="ky ir">为15.6 MB，在2X压缩之后</strong>为7.8 MB。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="f1e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">实用用法指南</strong></p><p id="9698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在图1中，我们可以看到，压缩因子为2导致了原始模式的良好重建。信号重建的质量高度依赖于数据的原始采样率。如果原始数据没有被充分采样，那么压缩只会恶化最终质量。建议用户首先在数据子集上尝试不同的压缩因子，以在大小减少和丢失细节之间找到适当的平衡。</p><p id="8693" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Midimax算法旨在提高视觉性能，而不是帮助使用大量数据进行建模。尽管该算法提供了具有良好趋势重构的压缩，但输出数据的分布与原始数据相比有很大的不同。使用它进行进一步的分析必须仔细考虑。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="4376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论</strong></p><p id="7d6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Midimax是一种简单的轻量级算法，用于减少数据大小，以便在消耗较少计算资源的同时快速绘制大型时间序列图。与任何压缩方法一样，细节会丢失，但在视觉分析的情况下，用户更感兴趣的是观察总体趋势，而不是小噪声。该算法被证明可以使用较少数量的点捕捉原始数据的变化，并在几秒钟内处理大量数据。</p><p id="6103" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitHub库:<a class="ae kv" href="https://github.com/edwinsutrisno/midimax_compression" rel="noopener ugc nofollow" target="_blank">https://github.com/edwinsutrisno/midimax_compression</a></p></div></div>    
</body>
</html>