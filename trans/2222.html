<html>
<head>
<title>Why You Should STOP Using ‘OR’ in SQL Joins Right Now</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么现在应该停止在SQL连接中使用“OR”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/why-you-should-stop-using-or-in-sql-joins-right-now-d5b6e83464cf#2022-05-17">https://towardsdatascience.com/why-you-should-stop-using-or-in-sql-joins-right-now-d5b6e83464cf#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="98d4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向查询运行时优化迈出“急需”的一步</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fbb022a8472e3d9d531aa42dc7cb011c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XddiadX3fvpfaAoe"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">何塞·阿拉贡内塞斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fa12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据我的经验，在Python之后，结构化查询语言(SQL)是众多数据科学家在他们的机器学习/数据科学项目中最受欢迎的工具。玩数据库并看到它们通过SQL中定义的各种机制相互交互是令人愉快的，其中之一当然是<strong class="ky ir"> SQL JOINS！</strong></p><p id="57ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对连接不熟悉，我强烈推荐<a class="ae kv" href="https://www.w3schools.com/sql/sql_join.asp" rel="noopener ugc nofollow" target="_blank">这篇</a>文章，以便在继续之前理解它们。说到这里，让我们转到为什么我把你带到这里，当然，为什么我说你应该立即停止在SQL连接中使用条件“OR”。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="26f4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">实验一:</strong></h1><p id="f018" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">考虑下面的查询，它采用两个表，即<em class="mw"> Table1 </em>和<em class="mw"> Table2，</em>，并在<strong class="ky ir"><em class="mw">【col 3】</em></strong>或<strong class="ky ir"><em class="mw">【col 2】</em></strong>中的值相等的情况下，在两个表之间执行内部连接。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/b0a0f493edef112065c4c1ff17fcc647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9K5I9iIKl5gUoYe9mw2CXw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">涉及内部连接的SQL查询(作者使用snappify.io创建的图像)</p></figure><p id="b396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，我相信您会想，这个查询有什么问题，对吗？但是当我实现了一个类似的查询，涉及到一个带有内部连接的条件“OR ”,每个表上有将近一万条(10⁴)记录时，查询表现异常。它花了将近<strong class="ky ir"> 3小时55分钟</strong>来执行，这促使我解决这里涉及的问题。我用一个条件“AND”代替条件“OR”进行了一个类似的实验，它在几分钟内就被执行了。</p><h1 id="aa26" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">实验二:</h1><p id="2dc9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在StackOverflow上快速查找将我带到了<a class="ae kv" href="https://stackoverflow.com/questions/5901791/is-having-an-or-in-an-inner-join-condition-a-bad-idea" rel="noopener ugc nofollow" target="_blank">这里</a>，这表明我们可以将条件“OR”转换为“UNION”操作，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7ba883b48d282054a1224343bcaef7ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXsv2pEUKL3qBkM7DK8bVQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">涉及内部连接和联合的SQL查询(作者使用snappify.io创建的图像)</p></figure><p id="aae5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本质上，我们可以将连接条件分成多个查询，并使用“SQL UNION”方法将结果连接起来。你可以在这里阅读SQL中的UNION。</p><p id="506c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令我惊讶的是，这个查询仅用了2分钟就在实验1中使用的相同表上执行了<strong class="ky ir">。</strong></p><p id="67e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了消除随机性并确保资源的不可用性不会对运行时间产生影响，我将上述实验重复了三次。下面的柱状图描述了实验1和实验2在这三次试验中的平均运行时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/35ae87e3fd2acdaad8f0fae9445cd2d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*KuA0SjYd6ItRlTspm0lH5A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实验1和实验2的运行时间是三次试验的平均值。</p></figure><p id="47c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的观察确实提出了许多关于SQL的查询规划器如何优化SQL查询的问题。要知道为什么条件“或”特别有问题，让我们重复下面的问题。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="59c7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题SQL中的连接到底是如何执行的？</h1><p id="9887" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这里，如果您首先理解要连接两个表，通过执行嵌套搜索来采用简单的方法是不可行的，这将会有所帮助，因为我们通常要处理大量的数据。例如，一个通常的嵌套搜索，每个表中只有一百万行(10⁶)，相当于一个<strong class="ky ir">万亿</strong>循环操作(10)。</p><p id="fa7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了优化这一点，SQL利用散列连接通过查找两个输入之间的匹配行来合并表，这通常比使用嵌套循环更有效。这里，每一行都用一个特定的散列函数映射到它的散列值，两个表的比较发生在一个特定的散列桶中。</p><h1 id="3263" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">问题2:实验1中接近四个小时的查询运行时间是否表明它选择了嵌套连接？</h1><p id="7842" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">是的。实验1中的连接很可能是使用嵌套循环中的表扫描来执行的，如果表很大，这显然会很慢。</p><h1 id="1b95" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated"><strong class="ak">问题3:如果连接通常在SQL中被优化，为什么SQL在实验1中仍然采用嵌套操作？</strong></h1><p id="9ab7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这个问题特别与实验1中使用的连接条件有关，即，</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="5267" class="nk ma iq ng b gy nl nm l nn no">condition1 <strong class="ng ir">OR</strong> condition2</span></pre><p id="1a5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以从观察到的运行时推断出，上述连接条件对于散列连接是不可优化的。换句话说，SQL不够聪明，无法优化连接条件或认识到查询本质上等同于多个查询的“联合”——除非像实验2中那样明确指定。这就是它花费了令人难以置信的大量时间来执行的原因。</p><h1 id="31c2" class="lz ma iq bd mb mc my me mf mg mz mi mj jw na jx ml jz nb ka mn kc nc kd mp mq bi translated">问题4:为什么实验2中的查询更快？</h1><p id="76a0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如上所述，SQL无法识别实验1中的查询可能等同于两个查询的“联合”。这使得原始查询不可优化，我们没有其他选择，只能显式地将这些信息嵌入到查询中，并手动将其拆分，以协助SQL的优化模块。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="f200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就把我们带到了这篇文章的结尾。总之，请注意，据我所知，这些限制特别存在于SQL连接中。你还可以在其他地方自由使用条件句“或”，如“WHERE”<em class="mw">、</em>、【HAVING】、<em class="mw">、</em>等。</p><p id="c661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢阅读，我希望你喜欢它。</p><p id="1407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢您的想法和反馈。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/968b234282cc46225b411bc6b017c0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4fUhCU8zLuBoLpeRC1YMsA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">憨豆先生的迷因是用clideo.com创造的。</p></figure></div></div>    
</body>
</html>