<html>
<head>
<title>Sample Ratio Mismatch: So many Questions. How to Answer Them?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">样本比例不匹配:这么多问题。怎么回答他们？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sample-ratio-mismatch-so-many-questions-how-to-answer-them-a86a1893e35#2022-04-20">https://towardsdatascience.com/sample-ratio-mismatch-so-many-questions-how-to-answer-them-a86a1893e35#2022-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2097" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有什么比数据验证问题更能让A/B测试程序泄气了SRM是最具破坏性的问题之一。但是SRM的测试到底有多准确呢？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/216186d4824c44d9bc868f5906ff2a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBeKt6OCUrRPb-JViAr3Ig.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="916b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设您有一个A/B测试，您希望每个测试组中的用户各占一半。相反，控制组和变异组的误差在7%左右。总共有8，000名用户被分配到该实验中。</p><p id="6fcd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们应该停止测试吗？我是说，我们有多确定问题存在？我们可以使用我在上一篇文章中描述的<a class="ae lr" rel="noopener" target="_blank" href="/the-essential-guide-to-sample-ratio-mismatch-for-your-a-b-tests-96a4db81d7a4"> Chi测试。<strong class="kx ir">如果</strong> <strong class="kx ir"> Chi测试为阴性</strong>，我们可能会问:看到这么大的差异正常吗？<strong class="kx ir">如果</strong> <strong class="kx ir"> Chi测试呈阳性</strong>，我们会问:这是假阳性的几率有多大？</a></p><p id="135c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">停止测试是非常具有破坏性的，我们不希望不必要地这样做。我们需要确定我们做出了正确的决定。</p><p id="9b34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我经常被问到的其他问题是:假阳性(I型错误)的风险是什么样的？此外，什么样的流量最适合进行高度准确的SRM检查？</p><p id="5d38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些问题或许可以用简单的数学和正态分布曲线等来回答。但我觉得用模拟来代替会很有趣。模拟为我们提供了<strong class="kx ir">真实的实验数据</strong>，我们可以对其进行询问和探索。我发现用模拟数据来解释事情更容易。</p><p id="8173" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的目标是在一个实验中模拟各种不同的网页流量负载，并进行分配和统计。这意味着流量将被随机分配到两个桶:A和b。由于我们不期望两组之间有任何差异，我们可以将这些视为A/A实验，并使用它们来探索随机机会可能发生的情况。</p><p id="9db2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望这能帮助我们回答我之前提出的一些问题。最后还有一个额外的问题，我也将探讨:SRM的持续检查</p><p id="3013" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将使用Python。所以，请随意在Jupyter笔记本或类似的东西上跟我一起出去玩(或对我的发现进行同行评审)。如果你对代码不感兴趣，完全信任我(你怎么了)，那么你要么直接跳到<strong class="kx ir">步骤5 </strong>，要么直接到我的<strong class="kx ir">结论</strong>文末回顾我的发现和结论。</p><h1 id="1a4d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">阶段1:模拟随机分配</h1><p id="3d92" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我的第一个任务是模拟测试工具在两个测试组之间随机分配流量的方式。这是我们的函数:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7a95" class="mu lt iq mq b gy mv mw l mx my">from random import randint</span><span id="17cf" class="mu lt iq mq b gy mz mw l mx my">def traffic_sim(<strong class="mq ir">traffic</strong>):<br/>    a,b =0,0<br/>    for x in range(<strong class="mq ir">traffic</strong>):<br/>        if randint(0,1) == 0:<br/>            a +=1<br/>        else:<br/>            b += 1<br/>    return (a,b)</span></pre><p id="e6b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> traffic </strong>参数是我想要在两组(<strong class="kx ir"> A </strong>和<strong class="kx ir"> B) </strong>之间分配的总流量。我使用<strong class="kx ir"> randint(0，1) </strong>得到一个随机布尔值(0或1)。我用这个将我的假想用户分配到我的两个测试组。这有点像数字版的掷硬币。</p><p id="0c94" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数的输出是一个元组(一个包含两个值的列表)。一个数字代表A，另一个代表b。</p><p id="54e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用100个示例用户来运行它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d21e" class="mu lt iq mq b gy mv mw l mx my">traffic_sim(<strong class="mq ir">100</strong>)</span></pre><p id="c9f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的输出是:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="36e2" class="mu lt iq mq b gy mv mw l mx my">(55, 45)</span></pre><p id="ed48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们在A中有55个用户，在b中有45个用户，我们期望的是50/50。但这是我们得到的。不算太坏。</p><p id="7aed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很明显，这个流量是超级低的。但这是测试这个功能的好方法。稍后我会以更高的音量回到这个话题。现在，我很好奇我的第一个例子<em class="na"> (55，45) </em>在使用Chi时是否有效。</p><h1 id="ce01" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步骤2:使用Chi进行SRM检查</h1><p id="1061" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这里就不多解释这个功能了，因为<a class="ae lr" rel="noopener" target="_blank" href="/the-essential-guide-to-sample-ratio-mismatch-for-your-a-b-tests-96a4db81d7a4">你可以看我之前提到的关于这个</a> <em class="na">的文章(这是我最后一次链接文章了，老实说)</em>。</p><p id="ccd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是功能。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="02c8" class="mu lt iq mq b gy mv mw l mx my">from scipy.stats import chisquare</span><span id="5e07" class="mu lt iq mq b gy mz mw l mx my">def srm_check(tup):<br/>    diff = max(tup) - min(tup)<br/>    total_traffic = (sum(tup))<br/>    expected = sum(tup)/2<br/>    perc_diff = (diff/(sum(tup)/2))*100<br/>    chi = chisquare(tup, f_exp=expected)<br/>    srm = False<br/>    if chi[1] &lt; 0.01:<br/>        srm = True<br/>    return ({"srm":srm, 'diff':perc_diff})</span></pre><p id="6538" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我传入一个值元组(<strong class="kx ir"> tup </strong>)，它表示我的A和B流量分配，然后返回一个字典，其中包含SRM的True或False。我还得到了各组之间的百分比差异。如果我传入我的元组(55，45)，我得到这个:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2de7" class="mu lt iq mq b gy mv mw l mx my">{'srm': False, 'diff': 20.0}</span></pre><p id="f0a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，即使差异为20%，SRM检查也是错误的。有道理。这么低的成交量，看到20%的几率在预期的随机几率之内。</p><p id="bef6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这很好。但是，同样，这是低流量。放松点。我们稍后会讨论更多的内容。</p><h2 id="6f43" class="mu lt iq bd lu nb nc dn ly nd ne dp mc le nf ng me li nh ni mg lm nj nk mi nl bi translated">步骤3:定义多个样本</h2><p id="a8b5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为单个模拟测试运行SRM限制太多。我想<strong class="kx ir">模拟成千上万次测试，以便更好地了解风险</strong>。我想要一个函数，返回我能看到的可能分裂的数目。</p><p id="1a97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我的函数:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="32fb" class="mu lt iq mq b gy mv mw l mx my">def get_samples(<strong class="mq ir">traffic</strong>, <strong class="mq ir">samples</strong>):<br/>    list_results = []<br/>    for x in range(<strong class="mq ir">samples</strong>):<br/>        list_results.append( <strong class="mq ir">srm_check</strong>( <strong class="mq ir">traffic_sim</strong>(traffic) ) )<br/>    newlist = sorted(list_results, key=lambda d: d['diff']) <br/>    return newlist</span></pre><p id="4d28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此功能期望<strong class="kx ir"> <em class="na">流量</em> </strong>和<strong class="kx ir"> <em class="na">样本</em> </strong>参数。</p><ul class=""><li id="8528" class="nm nn iq kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated"><strong class="kx ir"> <em class="na">交通量</em> </strong> <em class="na"> — </em>我们要使用的总交通量。到目前为止，我们一直使用100</li><li id="46c7" class="nm nn iq kx b ky nv lb nw le nx li ny lm nz lq nr ns nt nu bi translated"><strong class="kx ir"> <em class="na">样本</em> — </strong>我们要生成多少个模拟样本。到目前为止，我们只使用了1</li></ul><p id="2cd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该函数运行我的流量模拟和SRM函数，以获得我想要的样本数。我将对其他函数的调用设为粗体。</p><p id="6a15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我返回的是一个测试结果列表，每个结果都详细说明了SRM是真还是假。结果按差异的升序排序(最小差异到最大差异)。</p><p id="7db2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们运行这个函数来获得<strong class="kx ir"> 10 </strong>个实验结果，每个实验分配有<strong class="kx ir"> 100 </strong>个用户。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f87c" class="mu lt iq mq b gy mv mw l mx my">get_samples( traffic=100, samples= 10 )</span></pre><p id="ef61" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我明白了。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="7942" class="mu lt iq mq b gy mv mw l mx my">[{'srm': False, 'diff': 0.0},<br/> {'srm': False, 'diff': 4.0},<br/> {'srm': False, 'diff': 8.0},<br/> {'srm': False, 'diff': 8.0},<br/> {'srm': False, 'diff': 12.0},<br/> {'srm': False, 'diff': 12.0},<br/> {'srm': False, 'diff': 16.0},<br/> {'srm': False, 'diff': 20.0},<br/> {'srm': False, 'diff': 20.0},<br/> {'srm': False, 'diff': 36.0}]</span></pre><p id="e815" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于每个实验，我验证SRM是否存在，并得到两组之间的%差异。如果测试证实SRM为“真”,我们认为这是假阳性。</p><p id="709d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如你在上面看到的，这里没有假阳性，尽管我看到其中一个有36%的差异。哎哟。</p><p id="e945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="na">注意:我们看到如此大的差异的原因是因为我们的正态分布在这个体积上是宽的，这意味着在我们选择的概率范围内有可能得到各种各样的结果。</em></p><p id="f925" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">尽管如此，这是低流量。冷静点。我们快到了。在我推出更多的流量之前，我还有几个函数要做…</p><h1 id="7c0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第四步:获得假阳性率，等等</h1><p id="17da" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">回顾十个实验的列表很容易。我想最终用成千上万的实验来完成这个测试。手动检查成千上万的测试是一项繁重的工作。</p><p id="55ae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想创建一个函数来告诉我实验样本的假阳性率。</p><p id="f590" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="na">注意:由于我们使用的p值为&lt; 0.01，我们预计这一比率约为1%。让我们看看这是否成立。</em></p><p id="77cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我的函数。它获取我从上面的<strong class="kx ir"> srm_check </strong>函数生成的样本列表，并以百分比形式输出误报率。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3b30" class="mu lt iq mq b gy mv mw l mx my">def get_false_positive_rate(<strong class="mq ir">list_dictionary</strong>):<br/>    false_positive = 0<br/>    for item in list_dictionary:<br/>        if item['srm'] == True:<br/>            false_positive += 1<br/>    return ( false_positive / len(list_dictionary) )*100</span></pre><p id="c587" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我想看看A和B赋值之间的平均差是多少。这将让我知道我可能会在我的样本实验之间看到什么样的差异:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0523" class="mu lt iq mq b gy mv mw l mx my">def get_mean_diff(list_dictionary):<br/>    my_list = []<br/>    for item in list_dictionary:<br/>        my_list.append(item['diff'])<br/>    return (sum(my_list)/len(my_list))</span></pre><p id="889a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我很好奇<strong class="kx ir">在不触发SRM警报的情况下，A/B组<strong class="kx ir">之间的最大差异</strong>是多少？</strong>这将使我对声明SRM的最小可检测效果有所了解。</p><p id="d1a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同时想知道<strong class="kx ir">观察到的组间最大差异是多少？</strong> ( <em class="na">在这种情况下，SRM将被声明为真。)</em></p><p id="92b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面这个函数可以处理上述两个问题。它接受样本列表和我们想要使用的SRM值(即真或假)。该函数返回在我的数据集中找到的最高数字。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ff29" class="mu lt iq mq b gy mv mw l mx my">def get_max_diff(<strong class="mq ir">list_dictionary</strong>, <strong class="mq ir">srm_value</strong>):<br/>    my_list = [0]<br/>    for item in <strong class="mq ir">list_dictionary</strong>:<br/>        if item['srm'] == <strong class="mq ir">srm_value</strong>:<br/>            my_list.append(item['diff'])<br/>    return (max(my_list) )</span></pre><p id="b716" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，让我们来看看我的数据的<strong class="kx ir">传播</strong>，并得到标准差。这将让我知道实验样本的正态分布曲线有多宽。下面的函数可以做到这一点:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d66a" class="mu lt iq mq b gy mv mw l mx my">def get_stdev(<strong class="mq ir">list_dictionary</strong>):<br/>    my_list = []<br/>    for item in <strong class="mq ir">list_dictionary</strong>:<br/>        my_list.append(item['diff'])<br/>    return statistics.stdev(my_list)</span></pre><p id="8cb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我想将所有这些作为一个<strong class="kx ir"> dataframe </strong>返回，这样我就可以很容易地在一个表格中浏览结果。该函数将执行以下操作:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="eb9e" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd</span><span id="a726" class="mu lt iq mq b gy mz mw l mx my">def get_dataframe(traffic, samples):<br/>    results = []<br/>    for item in traffic:<br/>        list_dictionary = get_samples (item, samples)<br/>        results.append({<br/>            'Total traffic': item, <br/>            'SRM Type I rate':str(get_false_positive_rate(list_dictionary))+'%',<br/>            'Avg diff (SRM=False)': str(get_mean_diff(list_dictionary))+'%',<br/>            'Standard deviation': get_stdev(list_dictionary),<br/>            'Max diff (SRM=False)': str(get_max_diff(list_dictionary, False))+'%',<br/>            'Max diff (SRM=True)': str(get_max_diff(list_dictionary, True))+'%' <br/>        })</span></pre><p id="1ac9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个函数也将作为我的<strong class="kx ir">主函数</strong>。所以，我告诉这个函数:</p><ul class=""><li id="58df" class="nm nn iq kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated">我要模拟<strong class="kx ir">多少流量作为列表</strong> *。</li><li id="4556" class="nm nn iq kx b ky nv lb nw le nx li ny lm nz lq nr ns nt nu bi translated">我想运行的实验数量。我使用的实验(或样本)越多，我期望的准确度就越高。</li></ul><p id="9c6b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个主函数然后调用我的其他函数，为我提供一个漂亮的结果表。</p><p id="89c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://gist.github.com/iqbalali/0ed8374185e3acd45a4b720ae5bc2130" rel="noopener ugc nofollow" target="_blank">在这里看完整的python代码</a>。</p><p id="6f58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="na">*我使用的是流量列表，所以我可以一次发送多个流量。</em></p><p id="44d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太好了。让我们来看看实际情况...</p><h1 id="6a4f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第五步:评估我的结果</h1><p id="55a9" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我想模拟<strong class="kx ir">10000次实验</strong>，检查它们的SRM。实验将有不同的流量:<strong class="kx ir">1000、2000、3000</strong>等。<strong class="kx ir"> </strong>一直到<strong class="kx ir"> 2万总用户</strong>。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f42c" class="mu lt iq mq b gy mv mw l mx my">traffic = [1000,2000,3000,4000,5000,<br/>       6000,7000,8000,9000,10000,<br/>       11000,12000,13000,14000,15000,<br/>       16000,17000,18000,19000,200000]</span><span id="4921" class="mu lt iq mq b gy mz mw l mx my">get_dataframe(traffic=traffic, samples=10000)</span></pre><p id="7f30" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">小心不要用这个弄坏你的机器。这是机器需要处理的核心任务。这是我的结果。您的结果可能略有不同，但应该不会相差太远:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/19e536ccf29801fb745f8a2a78973c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKCBzdF9LBbq6dyLtdquaw.png"/></div></div></figure><p id="de8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">I型比率</strong>是我们的误报率，对于所有交通量，它大致保持在<strong class="kx ir"> 1% </strong>。这是意料之中的，因为我们使用的p值为<strong class="kx ir"> &lt; 0.01 </strong>。</p><p id="5373" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">平均差异是事情变得有趣的地方。请记住，这是我们测试组之间的平均差异。越接近零越好。在低流量(1000和2000)时，平均差异较大(5.0%和3.6%)。随着流量的增加，这种差异逐渐变小。</p><p id="2734" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">标准偏差是我们检查数据分布的地方。这告诉我们，在不同的交通流量条件下，我们的每个样本实验的差异有多大。</p><p id="a0b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">最大差异(SRM =假)</strong>是SRM警报跳闸前测试组之间的最大差异。接近零是最好的。我们可以看到，当流量较低(1，000和2，000)时，SRM警报将在较高的差异百分比(16%和11.4%)时触发。随着时间的推移，这种情况会逐渐减少。</p><p id="c7b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">最大差异(SRM=True) </strong>是随机分配用户时观察到的最大差异。我们的SRM检查将触发这些值的正值。我们可以看到在低流量时有很高的百分比差异。不过，这些数字是不稳定的。每次我们运行模拟，我们得到非常不同的值，有时比你在表中看到的要大。</p><p id="8caf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="na">Re:</em><strong class="kx ir"><em class="na">Max difference(SRM = True)</em></strong><em class="na">。这实际上是有意义的，因为当其他数字通过使用Chi测试计算来控制时，最大差异(SRM=True)是我们由于随机机会而看到的最大差异，并且不受任何种类的花哨统计的控制。很少会看到这些数字，但是追踪异常值的趋势还是很有趣的。</em></p><p id="8fc7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们将结果绘制成线图时的样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/896e12f8301562d5f2a40bad8edd2313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lau08tM0PzJ2aPlOqj1wKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。绘制流量增加时A/B测试的SRM图</p></figure><p id="c9b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的流量越多，我们能看到的偶然差异就越小。在分配了10，000多个用户的情况下，SRM触发前测试组之间的百分比差异为&lt;5%. At 65,000+ users this % difference drops to &lt; 2%. So, the Chi Test becomes more accurate.</p><p id="2319" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">A quick note from Lukas Vermeer on this before we continue:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/95675d97102b22b1be79a7c0267e8ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvfJRoHtVm4gC9BS_gctKw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Lukas Vermeer’s note on LinkedIn: you can also use the power calculation.</p></figure><p id="62b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Basically, you can run a power test to get a similar value as <strong class="kx ir">最大差异(SRM=False) </strong>。这可能比运行这种昂贵的模拟更容易，但话说回来，我喜欢做困难的事情！</p><p id="ff9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一张标准偏差图，展示了数据的分布如何随着流量的增加而减少:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/3723cc011b6ef2cbbbf2575bbc368b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kmMD7RAyH2Yn-yGMkmPXXQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。标准偏差随着交通量的增加而减小</p></figure><p id="f538" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以看到，在分配了15，000个用户时，标准偏差降至1以下。随着组间差异的扩大，总体标准偏差逐渐变好。</p><p id="4fce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我将是第一个承认这一切有点“嗯，废话。很明显。”但我在这里的目标是说明所有这些是如何工作的。它可能有助于点亮人们头脑中的灯泡。</p><p id="76a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是等等，还有更多…</p><h1 id="ecb2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">第六步:持续监控</h1><p id="a0f6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">所有这些都很好，但持续监控存在一个问题。以下是迈克尔·林顿为我们带来的更多信息:</p><blockquote class="oe of og"><p id="ef98" class="kv kw na kx b ky kz jr la lb lc ju ld oh lf lg lh oi lj lk ll oj ln lo lp lq ij bi translated">"..许多从业者通过<strong class="kx ir">重复执行显著性测试</strong>来错误地持续监控他们的实验，通常是以一种特别的方式，没有任何<strong class="kx ir">多重性校正</strong>，不知不觉地增加了他们出现I型错误的机会。</p></blockquote><p id="72dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="na">引用Michael Lindon的文章:</em> <a class="ae lr" href="https://medium.com/engineers-optimizely/a-better-way-to-test-for-sample-ratio-mismatches-srms-and-validate-experiment-implementations-6da7c0d64552" rel="noopener"> <strong class="kx ir"> <em class="na">测试样本比率不匹配(SRM)和验证实验实施的更好方法</em> </strong> </a> <strong class="kx ir"> <em class="na">。</em>T25】</strong></p><p id="3ee4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，我们检查得越频繁，看到假阳性的风险就越高。正是因为这个原因，我们用一个p值<strong class="kx ir"> &lt; </strong> <strong class="kx ir"> 0.01 </strong>来检测SRM(再次使用<a class="ae lr" rel="noopener" target="_blank" href="/the-essential-guide-to-sample-ratio-mismatch-for-your-a-b-tests-96a4db81d7a4">，详见我之前的文章</a>)。<a class="ae lr" href="https://www.lukasvermeer.nl/srm/" rel="noopener ugc nofollow" target="_blank"> Lukas Vermeer的SRM Chrome扩展工具</a>也使用了<strong class="kx ir"> &lt; </strong> <strong class="kx ir"> 0.01。</strong></p><p id="31dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是更高的显著性标准，有望降低假阳性的风险。但是真的吗？</p><p id="cef3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们通过快速修改我的脚本来找出答案:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bbd5" class="mu lt iq mq b gy mv mw l mx my">def traffic_sim(<strong class="mq ir">increment</strong>, <strong class="mq ir">checks</strong>):<br/>    traffic = []<br/>    a,b =0,0<br/>    for c in range(<strong class="mq ir">checks</strong>):<br/>        for i in range(<strong class="mq ir">increment</strong>):<br/>            if randint(0,1) == 1:<br/>                a +=1<br/>            else:<br/>                b += 1<br/>        traffic.append((a,b))<br/>    return (traffic)</span></pre><p id="648f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我有两个循环。我们使用这些循环来创建元组列表(针对A和B流量)。这个元组列表按值递增:“<strong class="kx ir">递增”。</strong>列表中的项目数量模拟了我们要做的<strong class="kx ir">检查的数量</strong>。</p><p id="db0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这应该模拟用户随着流量的增加反复检查SRM。</p><p id="2d6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，这里我模拟了<strong class="kx ir"> 10次检查</strong>，其中用户以100个用户的<strong class="kx ir">增量进行检查。</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2e3d" class="mu lt iq mq b gy mv mw l mx my">traffic_sim(100, 10)</span></pre><p id="660f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9ffc" class="mu lt iq mq b gy mv mw l mx my">[(46, 54),<br/> (97, 103),<br/> (151, 149),<br/> (210, 190),<br/> (257, 243),<br/> (310, 290),<br/> (359, 341),<br/> (417, 383),<br/> (467, 433),<br/> (516, 484)]</span></pre><p id="350f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，是的，我知道。发送更多的流量。不仅如此，这只模拟了一个<strong class="kx ir">单一实验</strong>。为什么要同时增加我们的样本量和<strong class="kx ir">检查SRM型</strong>错误。</p><p id="e90a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以使用以下附加函数来实现这一点:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="95f2" class="mu lt iq mq b gy mv mw l mx my">def get_false_pos_incremental(samples, increment, checks):<br/>    list_dictionary = []<br/>    for x in range(samples):<br/>        traff = traffic_sim(increment, checks)<br/>        for t in traff:<br/>            list_dictionary.append( srm_check( t ) )</span><span id="bfdb" class="mu lt iq mq b gy mz mw l mx my">    return ( get_false_positive_rate(list_dictionary) )</span></pre><p id="ca60" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我要运行的“<strong class="kx ir">样本”</strong>数量的另一个循环。</p><p id="6b3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还运行Chi测试来检查SRM(前面定义的同一个函数)。最后，我将结果传递到我之前定义的"<strong class="kx ir">get _ false _ positive _ rate "</strong>函数中，以获得误报的百分比。</p><p id="f452" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://gist.github.com/iqbalali/276cbe67fb6bfa807fb06e02c482eda8" rel="noopener ugc nofollow" target="_blank">在这里查看完整的Python代码</a>。</p><p id="1d8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我运行这个:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a826" class="mu lt iq mq b gy mv mw l mx my">get_false_pos_incremental(samples=10000, increment=100, checks=1000)</span></pre><p id="1f2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是<strong class="kx ir">10000个实验者</strong>，检查SRM<strong class="kx ir">1000次</strong>，而流量则以<strong class="kx ir"> 100个总用户</strong>递增。</p><p id="c684" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">那么，结果如何呢？当我们将Chi测试p值设置为&lt; 0.01时，像这样连续监测会有什么风险导致I型错误？</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="20f6" class="mu lt iq mq b gy mv mw l mx my">1%</span></pre><p id="6de9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">根据我的结果，持续监测的风险是1% —也就是说，与监测一次测试没有区别。</p><p id="239b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:我完全同意我的代码和随后的发现接受同行评审。所以现在，对这些发现要持保留态度，直到被证实。我希望我的逻辑没有出错。如果有，请告诉我，我会在 <a class="ae lr" href="https://www.linkedin.com/in/iqbalhussainali/" rel="noopener ugc nofollow" target="_blank"> <em class="na"> LinkedIn </em> </a> <em class="na">上更新这个帖子和消息，解释需要做出的更正。目前，我坚持这个结论。</em></p><p id="3733" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编辑:我错了！上述1%基于所有SRM声明为真的流量检查。如果我要在测试级别模拟用户检查SRM，代码将需要更新为以下内容:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f74d" class="mu lt iq mq b gy mv mw l mx my">def get_false_pos_incremental(samples, increment, checks):<br/>    list_dictionary = []<br/>    for x in range(samples):<br/>        traff_increment_list = traffic_sim(increment, checks)<br/>        srm = {'srm': False, 'diff': 0}<br/>        for t in traff_increment_list:<br/>            if (srm_check(t)['srm']):<br/>                srm = srm_check(t)<br/>        list_dictionary.append(srm)<br/>    return ( get_false_positive_rate(list_dictionary) </span></pre><p id="cdb6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢罗尼·科哈维纠正我的错误。实际结果要高得多:17%左右！！这是否改变了我下面的结论？不完全是。必须始终检查SRM，但要密切注意tred。</p><h1 id="1b0c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="9434" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">最后，让我们回顾一下你现在可能会问自己的一些问题(如果我错过了什么，请务必在这里或LinkedIn上给我打电话)。</p><h2 id="9336" class="mu lt iq bd lu nb nc dn ly nd ne dp mc le nf ng me li nh ni mg lm nj nk mi nl bi translated"><strong class="ak">流量低时运行SRM检查可靠吗？</strong></h2><p id="d5fd" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果您使用Chi测试，那么什么时候运行检查并不重要。假阳性率总是1%。但是，当流量较低时，您可能会看到较大的差异。</p><h2 id="6307" class="mu lt iq bd lu nb nc dn ly nd ne dp mc le nf ng me li nh ni mg lm nj nk mi nl bi translated"><strong class="ak">我应该何时开始运行SRM检查？</strong></h2><p id="fb68" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">您可以并且应该尽早运行SRM检查，但是使用Chi来确定SRM。不要只看你观察到的百分比差异。</p><h2 id="9c87" class="mu lt iq bd lu nb nc dn ly nd ne dp mc le nf ng me li nh ni mg lm nj nk mi nl bi translated">持续监控SRM是否有风险？</h2><p id="2b5f" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">根据我的发现不是。持续监测SRM时出现I型错误的风险为1%当卡方检验p值为&lt;0.01.</p><p id="0cdb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">EDIT: Correction! Yes, there is a risk of a false positive. In order to be mindful of this, we need to monitor each test for trends in SRM.</p><h2 id="b072" class="mu lt iq bd lu nb nc dn ly nd ne dp mc le nf ng me li nh ni mg lm nj nk mi nl bi translated"><strong class="ak">时，是否存在组间差异正常化的最佳分配数？</strong></h2><p id="8331" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">随着时间的推移，组之间的差异百分比越来越小，SRM检查的准确性也越来越好<em class="na">(因为，它对较小的差异变得更加敏感)</em>随着流量的增加。</p><p id="8464" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不能给你一个标准化作业的最佳数量。这是一个渐进的过程。有关详细信息，请参见上面的“步骤5”。</p><p id="2df9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之，尽早测试SRM。经常测试。使用Chi测试，这很简单。您甚至可以在电子表格中运行它！详情见我之前的文章。</p><p id="9cac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">希望这些都有用。如果您有问题，请随时联系并询问。很高兴谈论它。</p><h1 id="7a98" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于我这个“作者”</h1><p id="ae39" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我是伊克巴尔·阿里。我帮助公司开展实验项目。这意味着设计、开发、培训和咨询他们，以便在内部建立有效的实验流程。</p><p id="c584" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我也是一名<a class="ae lr" href="https://iqbala.com/" rel="noopener ugc nofollow" target="_blank">漫画作家</a> <strong class="kx ir">，</strong>train line前优化主管，<a class="ae lr" href="https://abdecisions.com/" rel="noopener ugc nofollow" target="_blank"> A/B决策工具</a>的创造者。这里是我的<a class="ae lr" href="https://www.linkedin.com/in/iqbalhussainali/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> LinkedIn </strong> </a>如果你想联系。或者跟随我来到这里。</p></div></div>    
</body>
</html>