<html>
<head>
<title>Five Killer Optimization Techniques Every Pandas User Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个熊猫用户应该知道的五个黑仔优化技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/five-killer-optimization-techniques-every-pandas-user-should-know-266662bd1163#2022-07-17">https://towardsdatascience.com/five-killer-optimization-techniques-every-pandas-user-should-know-266662bd1163#2022-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4875" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据分析运行时优化的一步</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f3a27ef3ab58e3d088885099e7c20537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aGty_aThlP_5zNyr"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@bradneathery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布拉德在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上整理</a></p></figure><p id="515f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计和构建现实世界适用的机器学习模型的动机一直吸引着数据科学家大规模利用优化、高效和准确的方法。优化在可持续交付真实世界和面向用户的软件解决方案中扮演着基础性角色。</p><p id="9ee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我知道不是每个人都在大规模构建解决方案，但是了解各种优化和省时技术仍然是有帮助的，并且高度适用于甚至一般的数据科学/机器学习用例。</p><p id="8f8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在本文中，我将向您介绍一些令人难以置信的技术，来减少使用Pandas进行常规表格数据分析、管理和处理任务的运行时间。为了得到一个简要的概述，我将在这篇文章中讨论以下主题:</p><p id="af83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="#14b5" rel="noopener ugc nofollow"><strong class="ky ir"># 1 CSV输入/输出</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#469f" rel="noopener ugc nofollow"><strong class="ky ir"># 2基于分类数据的过滤</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#7c21" rel="noopener ugc nofollow"><strong class="ky ir"># 3合并数据帧</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#c4a5" rel="noopener ugc nofollow"><strong class="ky ir"># 4 Value _ counts()vs group by()</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#327d" rel="noopener ugc nofollow"><strong class="ky ir">】</strong></a></p><p id="08b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，你可以在这里获得这篇文章<a class="ae kv" href="https://deepnote.com/workspace/avi-chawla-695b-aee6f4ef-2d50-4fb6-9ef2-20ee1022995a/project/Pandas-Optimization-Techniques-aae1af3a-70dd-467b-ae4e-57d5b4e23169/%2Fnotebook.ipynb" rel="noopener ugc nofollow" target="_blank">的笔记本。</a></p><p id="9500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧🚀！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="14b5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">CSV上的#1输入/输出</h1><p id="cb9c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">CSV文件是目前最流行的读取和存储数据帧的来源，不是吗？这是因为CSV在使用<code class="fe mw mx my mz b">pd.read_csv()</code>和<code class="fe mw mx my mz b">df.to_csv()</code>方法的输入和输出操作环境中提供了极大的灵活性，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><ol class=""><li id="baac" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">CSV可以在Excel中打开，并以Excel允许的任何方式进行操作。</li><li id="a591" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">通过将列指定为列表并将其作为<code class="fe mw mx my mz b">pd.read_csv()</code>方法的<code class="fe mw mx my mz b">usecols</code>参数传递，CSV使您能够在需要时只读取列的子集。</li><li id="01fe" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如果需要的话，可以使用<code class="fe mw mx my mz b">pd.read_csv()</code>方法的<code class="fe mw mx my mz b">nrows</code>参数来只读前<code class="fe mw mx my mz b">n</code>行，等等。</li></ol><p id="f213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然我承认使用CSV文件有许多优点，但同时，如果您正在寻找运行时优化，它们远不是首选方法。让我解释一下。</p><p id="1073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pandas对CSV文件的输入输出操作是序列化的，这不可避免地使它们非常低效和耗时。虽然有足够的并行化空间，但不幸的是，Pandas还没有这种功能。</p><p id="db7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此之前，如果您无法阅读CSV文件，有两种非常快速的方法可供选择，我在下面的流程图中描述了这两种方法:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/e847d153ccd654301990c5824987c226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*zffBhF7MYQbk7IEnpZP9oA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">确定读取CSV的替代方法的流程图(图片由作者提供)。</p></figure><h2 id="342d" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">路径1</h2><p id="6c01" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您的CSV文件是静态的，并且您认为您会多次读取它，可能是在同一个管道中或在重新加载内核之后，请立即将其保存为一个<strong class="ky ir">泡菜</strong>或<strong class="ky ir">羽毛</strong>或<strong class="ky ir">拼花</strong>文件。但是为什么呢？这一点我已经在下面的帖子中讨论过了:</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/why-i-stopped-dumping-dataframes-to-a-csv-and-why-you-should-too-c0954c410f8f"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">为什么我停止向CSV转储数据帧，为什么您也应该这样做</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">是时候告别pd.to_csv()和pd.read_csv()了</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div><p id="ee40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码块演示了从CSV格式到所需格式的转换:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ov nb l"/></div></figure><p id="629c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当您想要读回数据帧时，不要从CSV文件中读取它，而是使用您创建的新文件读取它。Pandas中重新加载数据集的相应方法如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ow nb l"/></div></figure><p id="9a7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这些单独的文件中的每一个都将把记录解释为熊猫数据帧。这可以使用Python中的<code class="fe mw mx my mz b">type()</code>方法进行验证，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox nb l"/></div></figure><p id="00d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的条形图描述了所有四种文件格式在运行时的预期速度提升:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/0799a27e9a1509f357107e4998700a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iu5frq2SXx_eApE9Cf4ecA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以各自的格式加载和保存数据帧所花费的时间。(图片由作者提供)</p></figure><p id="19be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了获得这四种格式的运行时间，我用Python生成了一个包含一百万行三十列的随机数据集——包括字符串、浮点和整数数据类型。我测量了负载和保存运行时间十次，以减少随机性，并从观察结果中得出公正的结论。以上结果显示了十次实验的平均值。</p><h2 id="3314" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">路径2</h2><p id="6f3a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您的CSV文件不是静态的，或者您只打算使用一次CSV文件，那么转换为新的格式是没有意义的。取而代之的是路径2，即使用<a class="ae kv" href="https://datatable.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">数据表</a>库进行输入和输出操作。您可以在Jupyter笔记本中使用以下命令安装DataTable:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz nb l"/></div></figure><p id="1ec1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用数据表时，CSV文件将被解释为数据表数据帧，<strong class="ky ir">而不是</strong>熊猫数据帧。因此，在加载CSV文件后，您需要将其转换为Pandas DataFrame。我在下面实现了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa nb l"/></div></figure><p id="f008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，如果您想将Pandas数据帧存储到CSV中，最好选择DataTable路线，而不是Pandas。这里，要使用datatable生成CSV文件，首先需要将Pandas数据帧转换为DataTable数据帧，然后将其存储在CSV文件中。这在下面实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa nb l"/></div></figure><div class="kg kh ki kj gt ab cb"><figure class="pb kk pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0eb13bf73f41c34f4f4d619eb6f3add0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*1CGOrZKU3CHi2YVGkFx14A.png"/></div></figure><figure class="pb kk pc pd pe pf pg paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/02d80e81bf48790f006a28874c55d759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Zw3cQ8Wyd_5HNFgxmGYoEw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ph di pi pj translated"><strong class="bd pk">左图</strong>:描绘使用Pandas和DataTable将数据帧存储到CSV所需时间的折线图。<strong class="bd pk">右侧</strong>:描绘使用Pandas和DataTable从CSV读取数据帧所用时间的折线图。(图片由作者提供)</p></figure></div><p id="4302" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上面的折线图所示，DataTable通过Pandas为CSV文件提供高速输入和输出操作。</p><h2 id="5b0b" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">关键要点/最终想法</h2><ol class=""><li id="ca1e" class="nc nd iq ky b kz mr lc ms lf pl lj pm ln pn lr nh ni nj nk bi translated">如果由于某些限制，您必须使用CSV文件，千万不要使用Pandas <code class="fe mw mx my mz b">read_csv()</code>和<code class="fe mw mx my mz b">to_csv()</code>方法。相反，更喜欢datatable的输入输出方法，如上所示。</li><li id="05bf" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如果您将重复读取同一个CSV文件，请将其转换为Pickle、Feather和Parquet之一，然后使用新文件进行输入操作。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="469f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">#2基于分类数据的过滤</h1><p id="049a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">数据过滤是熊猫中另一种常见且广泛使用的操作。核心思想是选择符合特定条件的数据帧片段。</p><p id="2bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示，考虑一个我自己创建的超过400万条记录的虚拟数据框架。下图显示了前五行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/b5d2db839256141bdb82851fe694dbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79zsktMGQZpqGv7--7OQsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虚拟数据集的前五行(作者图片)</p></figure><p id="e92e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码块演示了我的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pp nb l"/></div></figure><p id="8bd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您想要过滤所有属于“Amazon”的记录。这可以通过以下方式完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pq nb l"/></div></figure><p id="162c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进行相同过滤的另一种方法是使用<code class="fe mw mx my mz b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html" rel="noopener ugc nofollow" target="_blank">groupby()</a></code>并使用如下所示的<code class="fe mw mx my mz b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.GroupBy.get_group.html#pandas.core.groupby.GroupBy.get_group" rel="noopener ugc nofollow" target="_blank">get_group()</a></code>方法获得单个组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr nb l"/></div></figure><p id="aa5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与通常的过滤方法相比，后一种方法提供了高达<strong class="ky ir"> 14倍</strong>的加速，这在运行时间上是一个巨大的改进。</p><p id="4970" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<code class="fe mw mx my mz b">get_group()</code>方法将单个组作为熊猫数据帧返回。因此，您可以继续进行通常的分析。我们可以通过检查方法1和方法2中获得的数据帧类型来验证这一点，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pa nb l"/></div></figure><h2 id="a616" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">关键要点/最终想法</h2><ol class=""><li id="3e12" class="nc nd iq ky b kz mr lc ms lf pl lj pm ln pn lr nh ni nj nk bi translated">如果您要对分类数据执行数据框架的重复过滤，最好首先使用<code class="fe mw mx my mz b">groupby()</code>方法对数据进行分组。之后，使用<code class="fe mw mx my mz b">get_group()</code>方法获取所需的组。</li><li id="3854" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">警告:这种方法仅适用于基于分类数据的过滤。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7c21" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">#3合并数据帧</h1><p id="13f9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Pandas中的合并是指根据一个连接条件合并两个数据帧。这类似于结构化查询语言(SQL)中的连接。您可以在Pandas中使用<code class="fe mw mx my mz b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html#pandas.DataFrame.merge" rel="noopener ugc nofollow" target="_blank">pd.merge()</a></code>方法执行合并，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ps nb l"/></div></figure><p id="a4de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然上述链接数据帧的方法没有任何问题，但是有一个更快的方法可以使用<code class="fe mw mx my mz b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.join.html" rel="noopener ugc nofollow" target="_blank">join()</a></code>方法来连接两个数据帧。</p><p id="e78b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码块中，我使用<code class="fe mw mx my mz b">merge()</code>方法和<code class="fe mw mx my mz b">join()</code>方法实现了合并操作。这里，我们使用两种方法来测量合并操作所花费的时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pt nb l"/></div></figure><p id="b31a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mw mx my mz b">join()</code>方法，我们注意到相对于熊猫的标准<code class="fe mw mx my mz b">merge()</code>方法，改进超过<strong class="ky ir"> 4倍</strong>。</p><p id="536e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe mw mx my mz b">join()</code>方法首先希望您更改索引列，并将其设置为您希望在其上执行表间连接的特定列。这是在熊猫身上用<code class="fe mw mx my mz b">set_index()</code>方法完成的，如上图所示。</p><p id="ed3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在多个列上执行一个连接条件，您也可以使用<code class="fe mw mx my mz b">join()</code>方法来完成。首先，将希望执行连接条件的列作为列表传递给<code class="fe mw mx my mz b">set_index()</code>方法。然后，像以前一样调用<code class="fe mw mx my mz b">join()</code>方法。下面演示了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pu nb l"/></div></figure><h2 id="2791" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">关键要点/最终想法</h2><ol class=""><li id="dcd9" class="nc nd iq ky b kz mr lc ms lf pl lj pm ln pn lr nh ni nj nk bi translated">在执行连接时，始终更改两个数据帧的索引，并将其设置为要对其执行连接条件的列。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c4a5" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">#4 Value_counts()与GroupBy()</h1><p id="e0cf" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们在Pandas中使用<code class="fe mw mx my mz b">value_counts()</code>来查找一个序列中各个元素的频率。例如，考虑我们在第2节中使用的虚拟雇员数据框架。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/b5d2db839256141bdb82851fe694dbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79zsktMGQZpqGv7--7OQsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虚拟数据集的前五行(作者图片)</p></figure><p id="156d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe mw mx my mz b">value_counts()</code>方法找到该数据集中属于每个公司的员工人数，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pv nb l"/></div></figure><p id="8a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mw mx my mz b">groupby()</code>也可以进行类似的频率计算。下面的代码演示了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pw nb l"/></div></figure><p id="5028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">value_counts()</code>的输出按频率降序排列。另一方面，<code class="fe mw mx my mz b">groupby()</code>上<code class="fe mw mx my mz b">size()</code>的输出在索引列上排序，在本例中是<code class="fe mw mx my mz b">Company Name</code>。</p><p id="a83f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们不关心输出如何排列或排序，我们可以测量两种方法的运行时间差异，以获得所需的频率，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr nb l"/></div></figure><p id="9b3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这两种方法本质上做的是相同的事情(如果我们忽略一次输出的顺序)，但两者之间有一个显著的运行时间差异— <code class="fe mw mx my mz b">groupby()</code>比<code class="fe mw mx my mz b">value_counts()</code>慢<strong class="ky ir"> 1.5倍</strong>。</p><p id="de05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您想要获得归一化频率时，事情会变得更糟，归一化频率表示序列中各个元素的百分比/分数。在这种情况下，运行时间比较如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pr nb l"/></div></figure><p id="ee94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，尽管这两种方法做的是同样的事情，但两者之间有一个显著的运行时间差异——与<code class="fe mw mx my mz b">value_counts()</code>相比，<code class="fe mw mx my mz b">groupby()</code>要慢<strong class="ky ir">2</strong>T20】倍。</p><h2 id="ab82" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">关键要点/最终想法</h2><ol class=""><li id="874d" class="nc nd iq ky b kz mr lc ms lf pl lj pm ln pn lr nh ni nj nk bi translated">对于基于频率的测量，最好使用<code class="fe mw mx my mz b">value_counts()</code>而不是<code class="fe mw mx my mz b">groupby()</code>。</li><li id="97c2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated"><code class="fe mw mx my mz b">value_counts()</code>可一次用于多列。因此，如果您想要计算来自多个列的值的组合的频率，请使用<code class="fe mw mx my mz b">value_counts()</code>而不是<code class="fe mw mx my mz b">groupby()</code>来完成。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="327d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">#5迭代数据帧</h1><p id="a8f0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">循环或迭代数据帧是单独访问每一行并对记录执行一些预定义操作的过程。虽然在这种情况下，最好的办法是首先避免循环，而选择向量化的方法，但是在某些情况下，循环是必要的。</p><p id="caff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pandas中有三种方法可以实现迭代。下面，我们将讨论它们，并比较它们在下面几节中使用的雇员虚拟数据集上的运行时间。要重新查看，下图显示了数据框的前五行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/b5d2db839256141bdb82851fe694dbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*79zsktMGQZpqGv7--7OQsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">虚拟数据集的前五行(作者图片)</p></figure><p id="bdfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环遍历数据帧的三种方法是:</p><ol class=""><li id="9139" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">使用<code class="fe mw mx my mz b">range(len(df))</code>进行迭代。</li><li id="fd13" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">使用<code class="fe mw mx my mz b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.iterrows.html" rel="noopener ugc nofollow" target="_blank">iterrows()</a></code>进行迭代。</li><li id="8ed9" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">使用<code class="fe mw mx my mz b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.itertuples.html" rel="noopener ugc nofollow" target="_blank">itertuples()</a></code>进行迭代。</li></ol><p id="2a3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在下面的代码块中实现了三个利用这三种方法的函数。该函数的目标是计算数据框架中所有雇员的平均工资。我们还在下面的同一个数据框架中找到了这些方法的运行时间。</p><h2 id="958a" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">方法1:使用<code class="fe mw mx my mz b">range(len(df))</code>迭代</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px nb l"/></div></figure><p id="5812" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">迭代超过400万条记录的平均运行时间是<code class="fe mw mx my mz b">46.1 ms</code>。</p><h2 id="3eb7" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">方法2:使用iterrows()迭代</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px nb l"/></div></figure><p id="8617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mw mx my mz b">iterrows()</code>方法在迭代过程中提供了实质性的改进，将运行时间从<code class="fe mw mx my mz b">46.1 ms</code>减少到<code class="fe mw mx my mz b">18.2 ms</code>的2.5倍<strong class="ky ir">。</strong></p><h2 id="4414" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">方法3:使用itertuples()进行迭代</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="px nb l"/></div></figure><p id="3e85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果证明<code class="fe mw mx my mz b">itertuples()</code>方法甚至比<code class="fe mw mx my mz b">iterrows()</code>更好，从<code class="fe mw mx my mz b">18.2 ms</code>到<code class="fe mw mx my mz b">773 µs</code>进一步减少运行时间超过<strong class="ky ir"> 23倍</strong>。</p><h2 id="7929" class="nr ma iq bd mb ns nt dn mf nu nv dp mj lf nw nx ml lj ny nz mn ln oa ob mp oc bi translated">关键要点/最终想法</h2><ol class=""><li id="42b1" class="nc nd iq ky b kz mr lc ms lf pl lj pm ln pn lr nh ni nj nk bi translated">首先，您应该避免在代码中引入for循环来迭代数据帧。如果可能的话，考虑一个矢量化的解决方案。</li><li id="c7a2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">如果矢量化是不可能的，那么利用Pandas中预先实现的方法进行迭代，比如<code class="fe mw mx my mz b">itertuples()</code>和<code class="fe mw mx my mz b">iterrows()</code>。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4376" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="99c8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在这篇文章中，我讨论了Pandas中五个令人难以置信的优化技术，你可以在你的下一个数据科学项目中直接利用它们。在我看来，我在这篇文章中讨论的领域是改善运行时间的微妙方法，在寻求优化时经常被忽略。尽管如此，我希望这篇文章能让你深刻理解这些熊猫的日常功能。</p><p id="0c7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢读这篇文章，我希望你也会喜欢下面的文章:</p><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/powerful-one-liners-in-pandas-every-data-scientist-should-know-737e721b81b6"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">每个数据科学家都应该知道的强大的一句话</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用熊猫可以在一行中完成的事情</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="py l or os ot op ou kp og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener follow" target="_blank" href="/20-of-pandas-functions-that-data-scientists-use-80-of-the-time-a4ff1b694707"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">数据科学家80%的时间使用熊猫20%的功能</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">将帕累托法则运用于熊猫图书馆</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="pz l or os ot op ou kp og"/></div></div></a></div><p id="401b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/6c3f1ecb22dd557a7eb437c7ea473be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*8FPnAvZr521V6iEBqh4TPA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者在<a class="ae kv" href="https://imgflip.com/" rel="noopener ugc nofollow" target="_blank">imgflip.com</a>创造的Doge meme。</p></figure></div></div>    
</body>
</html>