<html>
<head>
<title>Imputing Missing Data with Simple and Advanced Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用简单和先进的技术输入缺失数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/imputing-missing-data-with-simple-and-advanced-techniques-f5c7b157fb87#2022-05-12">https://towardsdatascience.com/imputing-missing-data-with-simple-and-advanced-techniques-f5c7b157fb87#2022-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2710" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">均值、众数、时间序列、KNN和MICE插补教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8de5b643ea670ebd6e6af811ee653d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hD9Wfz3fHuvjte0K"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alessionord?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿莱西奥·罗维西</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Missing_data" rel="noopener ugc nofollow" target="_blank">缺失数据</a>当数据集中没有存储感兴趣变量的数据时发生。根据其数量，丢失的数据可能会损害任何数据分析的结果或机器学习模型的稳健性。</p><p id="c2f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用Python处理缺失数据时，Pandas的<code class="fe lv lw lx ly b">dropna()</code>函数派上了用场。我们用它来删除包含空值的行和列。它还有几个参数，如<strong class="lb iu">轴</strong>定义是否删除行或列，<strong class="lb iu">如何</strong>确定是否在任一或所有行/列中出现缺失值，以及<strong class="lb iu">子集</strong>选择一组要应用drop函数的列或标签。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0d18" class="md me it ly b gy mf mg l mh mi">df.dropna(axis=0, how='any', subset=None, inplace=False)</span></pre><p id="0f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，还有其他<em class="mj">可能</em> <em class="mj">更好的</em>处理缺失数据的方法。在这篇文章中，我们将看到如何用简单和先进的技术来估算(替换)丢失的数据。我们将首先介绍简单的单变量技术，如均值和众数插补。然后，我们将看到时间序列数据的向前和向后填充，我们将探索用于填充缺失值的线性、多项式或二次插值。稍后，我们将探索先进的多变量技术，并学习如何使用KNN和小鼠的机器学习来估算缺失值。</p><p id="ed4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在阅读本文的同时，我鼓励您查看我的GitHub上的<a class="ae ky" href="https://github.com/Idilismiguzel/data_analysis/blob/main/missing_data/Missing_Value_Imputation.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>以获得完整的分析和代码。</p><p id="28e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抓紧，让我们开始吧！🦾</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="5600" class="md me it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">数据</h2><p id="ba41" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们将使用来自OpenMV.net<a class="ae ky" href="https://openmv.net/" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae ky" href="https://openmv.net/info/travel-times" rel="noopener ugc nofollow" target="_blank">旅行时间数据集</a>。使用下面的代码，我们将通过解析Date和StartTime列并将随机值转换为MaxSpeed列的10%上的缺失值来加载数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印数据的前5行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/691136bf410571bdf6bdb9ed604af903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jZpmVFL3d2NWogwqhOJsRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据的前五行</p></figure><h2 id="4bee" class="md me it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">检测缺失值</h2><p id="9d27" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">isna()</code>或<code class="fe lv lw lx ly b">isnull()</code>方法来检测数据中的缺失值。我们可以用<code class="fe lv lw lx ly b">sum()</code>得到每一列中缺失值的总数，或者用<code class="fe lv lw lx ly b">mean().</code>取平均值</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="0070" class="md me it ly b gy mf mg l mh mi">df.isnull().sum()</span></pre><blockquote class="nq nr ns"><p id="df37" class="kz la mj lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">day ofweek:0<br/>going to:0<br/>Distance:0<br/><strong class="lb iu">max speed:22</strong><br/>avg speed:0<br/>avg moving speed:0<br/>fuel economy:17<br/>total time:0<br/>moving time:0<br/>take 407 all:0<br/>评论:181</p></blockquote><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="127e" class="md me it ly b gy mf mg l mh mi">df.isnull().mean()*100</span></pre><blockquote class="nq nr ns"><p id="f08e" class="kz la mj lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">星期:0.00% <br/>去向:0.00% <br/>距离:0.00% <br/> <strong class="lb iu">最大速度:10.73% <br/> </strong>平均速度:0.00% <br/>平均移动速度:0.00% <br/>燃油经济性:8.29% <br/>总时间:0.00% <br/>移动时间:0.00% <br/>耗时40</p></blockquote><p id="278b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们用np.nan随机替换了MaxSpeed列中10%的值，所以它有大约10%的丢失值就不足为奇了。</p><p id="ad1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用<code class="fe lv lw lx ly b">missingno</code>包来生成数据缺失的可视化表示。如果您试图检测缺失值之间的关系，例如与其他列一起缺失或在特定周、月等期间缺失，这是一个非常有用的工具。</p><p id="2ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的矩阵视图中，我们可以用空行看到缺失值，用黑线看到未缺失值。正如所料，我们丢失的值随机出现在MaxSpeed列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/a0b17ff9e9e60997c7d73577be9ef13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6dHQH4tv_rvuPNGqrI3cg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缺少值，缺少编号</p></figure><h1 id="6efb" class="nx me it bd mr ny nz oa mu ob oc od mx jz oe ka na kc of kd nd kf og kg ng oh bi translated">1.基本插补技术</h1><h2 id="2ac4" class="md me it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">1.1.均值和众数插补</h2><p id="2f38" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以使用scikit-learn中的<code class="fe lv lw lx ly b">SimpleImputer</code>函数用一个填充值替换缺失值。<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">简单插补器</a>函数有一个名为<strong class="lb iu">策略</strong>的参数，它为我们提供了四种选择插补方法的可能性:</p><ul class=""><li id="7f72" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu on oo op oq bi translated"><code class="fe lv lw lx ly b">strategy='mean'</code>使用列的平均值替换缺失值。</li><li id="3642" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe lv lw lx ly b">strategy='median'</code>使用列的中间值替换缺失值。</li><li id="75ea" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe lv lw lx ly b">strategy='most_frequent'</code>使用列的最频繁(或模式)替换缺失值。</li><li id="df55" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu on oo op oq bi translated"><code class="fe lv lw lx ly b">strategy='constant'</code>使用定义的填充值替换缺失值。</li></ul><p id="0246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们将在MaxSpeed列上使用SimpleImputer transformer，它有10%的随机缺失值。我们首先用strategy=mean定义均值估算器，然后在列上应用fit_transform。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d834" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们绘制一个散点图，x轴是AvgSpeed，y轴是MaxSpeed。正如我们所知，AvgSpeed列没有缺失值，我们用列平均值替换了MaxSpeed列中缺失的值。在下图中，绿点是转换后的数据，蓝点是原始的非缺失数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/915852c9b94637fec55cae861aac5c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gV1VZ4Rm8QMnapwaUWqqPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在绿色中，查看MaxSpeed的平均值为~127的估算数据点。</p></figure><p id="5775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以对中间值、最频繁值或常量值重复同样的操作。🌀<br/>这里是用最频繁值(mode)进行输入的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/6934229711be2d2433b44da22b430992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nL0xa1o86bZrRSozHypCug.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在绿色，看到估算数据点的最小模式的最大速度，约124。</p></figure><blockquote class="nq nr ns"><p id="5a27" class="kz la mj lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">注:如果有一种以上的模式，则插补使用最小模式。</p></blockquote><p id="e244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，均值插补可能会使标准误差产生偏差，如果值不是随机缺失的，也可能会使该列的实际均值/众数产生偏差。根据缺失量的不同，这种方式的输入也会影响列之间的真实关系。如果该列有许多异常值，则中位数插补应优先于平均数插补。</p><h2 id="5714" class="md me it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">1.2.时间序列插补</h2><p id="9f0c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在加载数据集时，我们用日期和开始时间列的组合定义了索引，如果不清楚，请参见上面的<em class="mj">数据</em>部分。☝️</p><p id="ace6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">估算时间序列数据中缺失值的一种方法是用上一个或下一个观察值填充它们。Pandas有<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.fillna.html" rel="noopener ugc nofollow" target="_blank"> fillna() </a>函数，该函数有<strong class="lb iu">方法</strong>参数，我们可以选择<em class="mj"> "ffill" </em>填充下一个观察值或<em class="mj"> "bfill" </em>填充上一个观察值。</p><p id="c1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图按时间显示了MaxSpeed列的前100个数据点。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e527" class="md me it ly b gy mf mg l mh mi">df['MaxSpeed'][:100].plot(title="MaxSpeed", marker="o")</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/4edcf87266761ea72575e91e30906d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cc2sLe6Kr9034nYu3bCRlw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这里可以看到缺少的值</p></figure><p id="8391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想用下一个观察值填充缺失值，我们应该使用method="ffill "。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/71a4a59a814b39329e918d3abdf6856b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eql0kwPGsrfL9nR9gaSsQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用下一个观察值填充缺失值</p></figure><p id="417e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想用以前观察到的值来填充缺失的值，我们应该使用method="bfill "。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/f3383340e158002ee3328edc9c8bc2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ugeFH-c_gMY4CJf6Zi-xQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用先前观察值填充的缺失值</p></figure><p id="81ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了bfill和ffill，我们还可以使用Pandas的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html" rel="noopener ugc nofollow" target="_blank">interpolate()</a></code>函数，并选择<strong class="lb iu">方法</strong> =“线性”来填充缺失值，在前一个和下一个观察值之间按升序排列。重要的是要注意，这个函数通过忽略索引来威胁等距值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/47504809d20fe77ea8c3c3e5a0c8b145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bdj-gqFudufKt6gAexSZ1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用线性插值填充的缺失值</p></figure><p id="6a52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了method= <em class="mj"> linear </em>进行插值，我们还可以选择<em class="mj">多项式，样条，最近，</em>，<em class="mj">二次等</em>。如果你对插值技术感兴趣，可以看看这个<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.interpolate.html" rel="noopener ugc nofollow" target="_blank">熊猫文档</a>。📖</p><h1 id="5b9b" class="nx me it bd mr ny nz oa mu ob oc od mx jz oe ka na kc of kd nd kf og kg ng oh bi translated">2.先进的技术</h1><h2 id="f44a" class="md me it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">2.1.k近邻(KNN)插补</h2><p id="3874" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">估算缺失值的另一种方法是预测它们。最近邻插补被广泛应用，并被证明是缺失值插补的有效方法。</p><p id="e0a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用Scikit-learn中的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.KNNImputer.html" rel="noopener ugc nofollow" target="_blank">KNNImputer</a></code>，其中缺失值使用训练集中找到的<em class="mj"> K- </em>最近邻的平均值进行估算。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c7ee" class="md me it ly b gy mf mg l mh mi">from sklearn.impute import KNNImputer</span><span id="21a5" class="md me it ly b gy pb mg l mh mi">KNNImputer(<em class="mj">missing_values=np.nan</em>, <em class="mj">n_neighbors=5</em>, <em class="mj">weights='uniform'</em>, <em class="mj">metric='nan_euclidean'</em>)</span></pre><p id="efd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KNNImputer有几个参数，例如默认设置为np.nan的<strong class="lb iu"> missing_values </strong>，默认设置为5的用于插补的相邻样本的选定数量的<strong class="lb iu"> n_neighbors </strong>，默认设置为‘nan-euclidean’的用于搜索邻居的距离度量的<strong class="lb iu"> metric </strong>，但也可以使用用户定义的函数进行定义。</p><p id="1310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KNNImputer可以处理连续、离散和分类数据类型，但不能处理文本数据。因此，我使用选定的列子集过滤数据——Distance、MaxSpeed、AvgSpeed和AvgMoovingSpeed。此外，我使用了scikit-learn中的<code class="fe lv lw lx ly b">MinMaxScaler</code>,在0和1之间规范化这个数字数据。因为KNNImputer是基于距离的算法，所以缩放是流水线中的重要一步。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在定义了KNNImputer之后，我们进行fit_transform并保存新的(估算)数据。下面是估算数据与原始数据的散点图，绿色显示了MaxSpeed的估算值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d80c27a4875532a11230f999a854e1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ef01UunaLIvlLKHx463eKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在绿色中，请参见使用KNN估算器估算的数据点</p></figure><p id="0da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KNNImputer有几个优点，比如易于实现，能够处理数字和分类数据类型。然而，定义邻居的数量— <em class="mj"> k </em>可能很棘手，因为它引入了鲁棒性和速度之间的权衡。如果我们选择一个小的<em class="mj"> k </em>，那么我们有快速的计算，但是不太稳健的结果。相比之下，如果我们选择一个大的<em class="mj"> k </em>，那么我们有一个更健壮但是更慢的计算。</p><h2 id="33d5" class="md me it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">2.2.用链式方程进行多元插补——小鼠</h2><p id="d9eb" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">MICE算法可能是最常用的插补技术之一，也是一个常见的面试问题。😈</p><p id="8755" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MICE首先计算有缺失值的每一列的平均值，并将平均值用作占位符。然后，它运行一系列回归模型(链式方程)来依次估算每个缺失值。与任何回归模型一样，MICE使用特征矩阵和目标变量进行训练，在这种情况下，目标变量是缺少值的列。MICE预测并更新目标列上缺失的值。通过不断地用前一次迭代的预测来改变占位符变量，MICE反复多次重复这个过程。最后，得到一个稳健的估计。</p><p id="4172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了应用MICE算法，我们将使用scikit-learn中的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html#sklearn.impute.IterativeImputer" rel="noopener ugc nofollow" target="_blank">IterativeImputer</a></code>。这个估计器还在实验中，所以我们必须导入<code class="fe lv lw lx ly b">enable_iterative_imputer.</code></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1447" class="md me it ly b gy mf mg l mh mi">IterativeImputer(<em class="mj">estimator=None</em>, <em class="mj">missing_values=np.nan</em>, <em class="mj">sample_posterior=False</em>, <em class="mj">max_iter=10</em>, <em class="mj">tol=0.001</em>, <em class="mj">n_nearest_features=None</em>, <em class="mj">initial_strategy=’mean’</em>, <em class="mj">imputation_order=’ascending’</em>)</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">见下图，估算数据与原始数据的散点图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/b19e6ed2bc5e9769f1357cc9b1285d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-105m1Hsg8MPluanTu8Deg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿色表示使用鼠标插补的插补数据点</p></figure><h1 id="a662" class="nx me it bd mr ny nz oa mu ob oc od mx jz oe ka na kc of kd nd kf og kg ng oh bi translated">结论</h1><p id="cb68" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们探索了不同的方法来估算数据集中的缺失值。我们从使用无丢失包来检测丢失的数据开始。然后，我们使用简单的估算器计算缺失数据列的平均值和最频繁值。由于数据中存在时间元素，我们还讨论了使用时间序列填充缺失值的回填、前向填充和线性插值。最后，我们转向更先进的技术；k-最近邻插补(KNN)和使用机器学习填充缺失值的链式方程多元插补(MICE)。</p><p id="73ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读关于估算缺失值的文章，并发现这篇文章对你的工作有用！</p><p id="aa92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mj">如果你喜欢这篇文章，你可以在这里</em><strong class="lb iu"><em class="mj"/></strong><a class="ae ky" href="https://medium.com/@idilismiguzel" rel="noopener"><strong class="lb iu"><em class="mj">阅读我的其他文章</em></strong></a><strong class="lb iu"><em class="mj"/></strong><em class="mj">和</em> <a class="ae ky" href="http://medium.com/@idilismiguzel/follow" rel="noopener"> <strong class="lb iu"> <em class="mj">关注我的中</em></strong></a><strong class="lb iu"><em class="mj"/></strong>如果有任何问题或建议，请告诉我。✨</p><p id="5b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">喜欢这篇文章吗？ <a class="ae ky" href="https://idilismiguzel.medium.com/membership" rel="noopener"> <strong class="lb iu">成为会员求更！</strong> </a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="f936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考</p><ol class=""><li id="7a08" class="oi oj it lb b lc ld lf lg li ok lm ol lq om lu pe oo op oq bi translated">旅行时间数据集:learnche.org凯文·杜恩<a class="ae ky" href="http://learnche.org/" rel="noopener ugc nofollow" target="_blank"/></li><li id="11dc" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu pe oo op oq bi translated"><a class="ae ky" href="https://unsplash.com/@alessionord?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿莱西奥·罗维西</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的标题照片</li><li id="9a88" class="oi oj it lb b lc or lf os li ot lm ou lq ov lu pe oo op oq bi translated">所有其他图片均由作者提供</li></ol></div></div>    
</body>
</html>