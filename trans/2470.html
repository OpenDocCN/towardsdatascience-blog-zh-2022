<html>
<head>
<title>Binary Image Classification in PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch中的二值图像分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/binary-image-classification-in-pytorch-5adf64f8c781#2022-05-30">https://towardsdatascience.com/binary-image-classification-in-pytorch-5adf64f8c781#2022-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/140adb2e5d6fb5bb940f8ecff715959d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_NvFxBWRBGOlLn82"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Clément Hélardot </a>拍摄</p></figure><div class=""/><div class=""><h2 id="8f9e" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">采用迁移学习方法训练卷积神经网络</h2></div><p id="5cd8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我个人使用TensorFlow来接近深度学习，我立即发现它非常容易和直观。很多书也用这个框架作为参考，比如<a class="ae jd" href="https://www.amazon.it/Hands-Machine-Learning-Scikit-learn-Tensorflow/dp/1492032646/ref=asc_df_1492032646/?tag=googshopit-21&amp;linkCode=df0&amp;hvadid=386576436233&amp;hvpos=&amp;hvnetw=g&amp;hvrand=9196245492590438572&amp;hvpone=&amp;hvptwo=&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=1008736&amp;hvtargid=pla-523968811896&amp;psc=1&amp;tag=&amp;ref=&amp;adgrpid=78616235706&amp;hvpone=&amp;hvptwo=&amp;hvadid=386576436233&amp;hvpos=&amp;hvnetw=g&amp;hvrand=9196245492590438572&amp;hvqmt=&amp;hvdev=c&amp;hvdvcmdl=&amp;hvlocint=&amp;hvlocphy=1008736&amp;hvtargid=pla-523968811896" rel="noopener ugc nofollow" target="_blank"> <em class="lr">用Scikit-Learn、Keras、Tensorflow </em> </a>动手机器学习。然后我注意到PyTorch经常被用于学术界和工业界的研究。所以我开始使用PyTorch实现我已经在TensorFlow中开发的简单项目，以便对这两者有一个基本的了解。由于我相信最好的学习方法是向别人解释，所以我决定写这篇动手教程，用PyTorch开发一个用于二值图像分类的卷积神经网络。</p><h2 id="35c6" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">资料组</h2><p id="8da8" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们将使用<em class="lr">狗vs猫</em>数据集(有免费许可证)，你可以在以下链接找到:<a class="ae jd" href="https://www.kaggle.com/datasets/biaiscience/dogs-vs-cats" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://www.kaggle.com/datasets/biaiscience/dogs-vs-cats</em></a>。数据集是免费开放使用的。我将向您展示如何创建一个模型来解决这个二元分类任务，以及如何使用它对新图像进行推理。</p><p id="35c0" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了下载这个数据集，首先要做的是使用您的凭证访问<a class="ae jd" href="https://www.kaggle.com/" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>，然后下载<em class="lr"> kaggle.json </em>文件，您可以通过单击<em class="lr">创建新的API令牌</em>按钮获得该文件。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/9d8c02119f3998e5fe501f5b559ccd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhtu7C5E1RQ1oPthR2iZTg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="a024" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要编写允许我们上传个人Kaggle令牌和下载数据集的代码。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">从Kaggle下载数据</p></figure><p id="ee35" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们需要将下载的文件夹解压到一个新文件夹，我们将命名为<em class="lr">数据</em>。接下来，我们还将分别解压缩两个子文件夹<em class="lr">测试</em>和<em class="lr">训练</em>。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">解压缩数据</p></figure><h2 id="2934" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">构造并填充子文件夹</h2><p id="c9ec" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">为了便于管理数据集，我们创建了一个易于管理的文件夹结构。<br/>目标是有一个名为<em class="lr"> training </em>的文件夹，其中包含子文件夹<em class="lr"> dog </em>和<em class="lr"> cat </em>，它们显然包含各自宠物的所有图像。<br/>对<em class="lr">验证</em>文件夹应该做同样的事情。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">创建子文件夹结构</p></figure><p id="bf7c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们只需要重组数据并填充这些新创建的子文件夹。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">填充子文件夹</p></figure><p id="2a00" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们来绘制一些图像示例。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">绘图示例</p></figure><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/dde9d881e021d795d2c871c8ba8b0a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rGQZZHt4CEchxGxO1u6B8A.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><h2 id="3f78" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">创建数据加载器</h2><p id="435e" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">现在我们要做3件事:</p><ol class=""><li id="22a7" class="my mz jg kx b ky kz lb lc le na li nb lm nc lq nd ne nf ng bi translated">让我们使用<em class="lr"> compose </em>方法对数据进行预处理，这是一种简单的方法，可以对数据集应用多种预处理功能，比如标准化和数据扩充。</li><li id="0b61" class="my mz jg kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">让我们使用<em class="lr"> ImageFolder </em>创建一个pytorch数据集。如果子目录结构定义良好，PyTorch会自动推断出类(就像我们的例子一样)。</li><li id="df70" class="my mz jg kx b ky nh lb ni le nj li nk lm nl lq nd ne nf ng bi translated">使用<em class="lr">数据加载器</em>批量分割我们的数据。</li></ol><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">创建数据加载器</p></figure><h2 id="0e57" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">训练阶跃函数</h2><p id="f606" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">训练步骤总是由三个东西定义:<em class="lr">模型、优化器</em>和<em class="lr">损失函数</em>。因此，让我们编写一个函数，返回在输入这3个实体时给出的训练步骤函数。这样我们就不用一遍又一遍的重写同样的代码了！</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">训练阶跃函数</p></figure><h2 id="970e" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">建立模型</h2><p id="a79f" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在解决大多数Kaggle任务时，你不会从头开始编写一个网络，而是使用一个名为<em class="lr"> base_model </em>的预训练模型，并使其适应手头的任务。把<em class="lr"> base_model </em>想象成一个已经学会识别图像中重要特征的模型。我们要做的是通过增加一个由其他致密层组成的<em class="lr">头</em>来进行适配。在我们的例子中，最后的密集层将由单个神经元组成，该神经元将使用<em class="lr"> sigmoid </em>激活函数，以便我们将具有为0或1(猫或狗)的输出概率。</p><figure class="mr ms mt mu gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/cc7a614689286b9d44a570b299f41141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_59Qgk2QSxOYBO2yctbcBg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="3412" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们必须小心不要训练之前已经训练过的基础模型。</p><p id="17df" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们<strong class="kx jh">下载一个预训练模型(resnet)并冻结所有参数</strong>。然后我们将<strong class="kx jh">改变最后一个线性层</strong>以定制模型成为二进制分类器。<strong class="kx jh">记住型号和数据必须在同一个设备(GPU)上</strong>。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">冻结预训练模型的参数</p></figure><p id="b87e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在需要定义<em class="lr">损失</em>、<em class="lr">优化器</em>和<em class="lr">训练_步骤</em>。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">定义损失、优化程序和培训步骤。</p></figure><h2 id="0f83" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">训练模型</h2><p id="325d" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">让我们写一下我们的培训和评估阶段。我们还将实现<strong class="kx jh">提前停止</strong>并在每个时期保存最佳模型。</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">训练和模型评估</p></figure><p id="e656" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于我们从一个预先训练的模型开始，并且我们的二元分类任务非常简单，因此您应该很快就有一个能够非常准确地对数据集中的图像进行分类的模型。</p><h2 id="39fd" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">推理</h2><p id="9004" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">您现在可以使用该模型来预测新图像的标签！</p><figure class="mr ms mt mu gt is"><div class="bz fp l di"><div class="mv mw l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">对新图像的推断</p></figure><h2 id="a66f" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">结论</h2><p id="8960" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们已经成功地建立了一个图像分类器来识别图像中的猫和狗。我必须说，在本文 的<a class="ae jd" href="https://medium.com/towards-data-science/transfer-learning-data-augmentation-for-robust-image-classification-643ca88b3175" rel="noopener"> <em class="lr">中，我也用Tensorflow开发了相同的分类器，我发现tensorflow在这个简单的项目中使用起来更快。但是从我的角度来看，PyTorch的优点是对从数据预处理到模型训练的各个步骤的更细粒度的控制。让我知道你的想法！</em></a></p><h2 id="ee38" class="ls lt jg bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">结束了</h2><p id="2c7c" class="pw-post-body-paragraph kv kw jg kx b ky ml kh la lb mm kk ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><em class="lr">马赛洛·波利蒂</em></p><p id="9916" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" href="https://www.linkedin.com/in/marcello-politi/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>，<a class="ae jd" href="https://twitter.com/_March08_" rel="noopener ugc nofollow" target="_blank"> Twitter </a>，<a class="ae jd" href="https://march-08.github.io/digital-cv/" rel="noopener ugc nofollow" target="_blank"> CV </a></p></div></div>    
</body>
</html>