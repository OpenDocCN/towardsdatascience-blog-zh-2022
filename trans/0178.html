<html>
<head>
<title>How to Create a Monte Carlo Simulation using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用 Python 创建蒙特卡洛模拟</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-monte-carlo-simulation-using-python-c24634a0978a#2022-02-08">https://towardsdatascience.com/how-to-create-a-monte-carlo-simulation-using-python-c24634a0978a#2022-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="23fb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">演练一个示例，了解什么是蒙特卡罗模拟以及如何使用它来预测概率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c5f96126dc5aa28b4a249f3412c30a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wb9gsVLUtx029AwB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="0fb1" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是蒙特卡洛模拟？</h2><p id="57a8" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">蒙特卡罗模拟是一种计算算法，它估计由于涉及随机变量而导致的不可确定事件的发生概率。该算法依靠重复的随机抽样来确定概率。这意味着用随机输入模拟一个事件很多次，以获得你的估计。您也可以确定其他因素，我们将在示例中看到。蒙特卡罗模拟可以应用于广泛的领域，从经济、赌博、工程、能源到任何介于两者之间的领域。所以，无论你在哪个职业领域，这都是一件非常值得了解的事情。</p><p id="fd98" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当学习如何建立蒙特卡洛模拟时，最好从一个基本模型开始，以了解基本原理。最简单也是最常见的方法是简单的游戏，所以我们将在本文中使用一个骰子游戏。你可能听说过这样一句话，“赌场总是赢家”，所以在这个例子中，赌场(通常是赌场)将有优势，我们将展示这对玩家可能的收入意味着什么。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="7fbc" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">骰子游戏</h2><p id="393e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">我们的简单游戏包括两个六面骰子。为了赢，玩家需要在两个骰子上掷出相同的数字。六面骰子有六种可能的结果(1、2、3、4、5 和 6)。用两个骰子，现在有 36 种可能的结果(1 和 1，1 和 2，1 和 3，等等。，或 6×6 = 36 种可能性)。在这场游戏中，庄家有更多的机会获胜(30 个结果对玩家的 6 个结果)，这意味着庄家有相当的优势。</p><p id="fe92" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">假设我们的玩家开始时有 1000 美元的余额，并准备全部输掉，所以他们在每一次掷骰子时都下注 1 美元(意味着两个骰子都掷了)，并决定玩 1000 次。因为赌场如此慷慨，当玩家赢的时候，他们提供玩家赌注的 4 倍。例如，如果玩家赢了第一轮，他们的余额增加 4 美元，他们结束这一轮的余额为 1004 美元。如果他们奇迹般地连胜 1000 场，他们可以带着 5000 美元回家。如果他们每轮都输了，他们可能会一无所有地回家。风险回报比并不差…或者可能是这样。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="2a90" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">导入 Python 包</h2><p id="0436" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">让我们模拟我们的游戏，看看玩家是否做出了正确的选择。我们通过导入必要的 Python 包开始我们的代码:<em class="na">的<em class="na">py plot</em>Matplotlib</em>和<em class="na"> random </em>。我们将使用<em class="na"> Pyplot </em>来可视化我们的结果，并使用<em class="na"> random </em>来模拟普通的六面骰子滚动。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="cfe7" class="kz la it nc b gy ng nh l ni nj"># Importing Packages<br/>import matplotlib.pyplot as plt<br/>import random</span></pre><h2 id="10b3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">骰子滚动功能</h2><p id="5caa" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">接下来，我们可以定义一个函数，该函数将为两个骰子随机化一个从 1 到 6 的整数(模拟掷骰子)。该函数还将比较两个骰子，看它们是否相同。该函数将返回一个布尔变量<em class="na"> same_num </em>，用于存储卷是否相同。我们稍后将使用该值来确定代码中的操作。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="a4fa" class="kz la it nc b gy ng nh l ni nj"># Creating Roll Dice Function<br/>def roll_dice():<br/>    die_1 = random.randint(1, 6)<br/>    die_2 = random.randint(1, 6)<br/><br/>    # Determining if the dice are the same number<br/>    if die_1 == die_2:<br/>        same_num = True<br/>    else:<br/>        same_num = False<br/>    return same_num</span></pre><h2 id="b28b" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">输入和跟踪变量</h2><p id="77f9" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">每一次蒙特卡洛模拟都需要你知道你的输入是什么，你希望获得什么信息。当我们描述这个游戏的时候，我们已经定义了我们的输入是什么。我们说过每场游戏的掷骰数是 1，000，玩家每掷的下注金额是 1 美元。除了我们的输入变量，我们还需要定义我们想要模拟游戏的次数。我们可以使用<em class="na"> num_simulations </em>变量作为我们的蒙特卡罗模拟计数。这个数字越大，预测的概率就越接近真实值。</p><p id="7807" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们可以跟踪的变量数量通常与项目的复杂程度成比例，所以明确你想要的信息是很重要的。在本例中，我们将跟踪每场模拟(或游戏)的获胜概率(每场游戏的获胜数除以总掷骰数)和期末余额。这些被初始化为列表，并将在每场游戏结束时更新。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5643" class="kz la it nc b gy ng nh l ni nj"># Inputs<br/>num_simulations = 10000<br/>max_num_rolls = 1000<br/>bet = 1<br/><br/># Tracking<br/>win_probability = []<br/>end_balance = []</span></pre><h2 id="f277" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">设置图形</h2><p id="33e1" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">下一步是在运行模拟之前设置我们的图形。通过在模拟之前这样做，它允许我们在每次游戏后给我们的图形添加线条。然后，一旦我们运行了所有的模拟，我们就可以显示图表来显示我们的结果。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b531" class="kz la it nc b gy ng nh l ni nj"># Creating Figure for Simulation Balances<br/>fig = plt.figure()<br/>plt.title("Monte Carlo Dice Game [" + str(num_simulations) + "   <br/>          simulations]")<br/>plt.xlabel("Roll Number")<br/>plt.ylabel("Balance [$]")<br/>plt.xlim([0, max_num_rolls])</span></pre><h2 id="b4a3" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">蒙特 卡罗模拟</h2><p id="751e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">在下面的代码中，我们有一个外部的<em class="na"> for </em>循环，它遍历我们预定义数量的模拟(10，000 次模拟)和一个嵌套的<em class="na"> while </em>循环，它运行每个游戏(1，000 次掷骰)。在我们开始每个<em class="na"> while </em>循环之前，我们将玩家的余额初始化为$1，000(作为用于绘图目的的列表)以及掷骰子和赢数。</p><p id="3702" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们的<em class="na"> while </em>循环将模拟游戏进行 1000 次掷骰。在这个循环中，我们掷骰子并使用从<em class="na"> roll_dice() </em>返回的布尔变量来决定结果。如果骰子是相同的数字，我们将 4 倍赌注加到<em class="na">余额</em>列表中，并将一次胜利加到胜利计数中。如果骰子不同，我们从<em class="na">余额</em>列表中减去赌注。在每一次掷骰子结束时，我们会在我们的<em class="na"> num_rolls </em>列表中添加一个计数。</p><p id="3711" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">一旦掷骰数达到 1000，我们就可以计算出玩家的获胜概率，即获胜数除以掷骰总数。我们还可以在跟踪变量<em class="na"> end_balance </em>中存储已完成游戏的结束余额。最后，我们可以绘制<em class="na"> num_rolls </em>和<em class="na"> balance </em>变量，为我们之前定义的数字添加一条线。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f446" class="kz la it nc b gy ng nh l ni nj"># For loop to run for the number of simulations desired<br/>for i in range(num_simulations):<br/>    balance = [1000]<br/>    num_rolls = [0]<br/>    num_wins = 0</span><span id="3ca2" class="kz la it nc b gy nk nh l ni nj">    # Run until the player has rolled 1,000 times<br/>    while num_rolls[-1] &lt; max_num_rolls:<br/>        same = roll_dice()</span><span id="cd09" class="kz la it nc b gy nk nh l ni nj">        # Result if the dice are the same number<br/>        if same:<br/>            balance.append(balance[-1] + 4 * bet)<br/>            num_wins += 1<br/>        # Result if the dice are different numbers<br/>        else:<br/>            balance.append(balance[-1] - bet)<br/><br/>        num_rolls.append(num_rolls[-1] + 1)</span><span id="29a9" class="kz la it nc b gy nk nh l ni nj"># Store tracking variables and add line to figure<br/>    win_probability.append(num_wins/num_rolls[-1])<br/>    end_balance.append(balance[-1])<br/>    plt.plot(num_rolls, balance)</span></pre><h2 id="e4c6" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">获得结果</h2><p id="d57d" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">最后一步是显示来自跟踪变量的有意义的数据。我们可以显示我们在<em class="na"> for </em>循环中创建的图形(如下所示)。此外，我们可以通过平均我们的<em class="na"> win_probability </em>和<em class="na"> end_balance </em>列表来计算和显示(如下所示)我们的总体获胜概率和期末余额。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c5d9" class="kz la it nc b gy ng nh l ni nj"># Showing the plot after the simulations are finished<br/>plt.show()<br/><br/># Averaging win probability and end balance<br/>overall_win_probability = sum(win_probability)/len(win_probability)<br/>overall_end_balance = sum(end_balance)/len(end_balance)</span><span id="913d" class="kz la it nc b gy nk nh l ni nj"># Displaying the averages<br/>print("Average win probability after " + str(num_simulations) + "   <br/>       runs: " + str(overall_win_probability))<br/>print("Average ending balance after " + str(num_simulations) + " <br/>       runs: $" + str(overall_end_balance))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8f26340e44f19c3130da6d2e173d1b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*02uSFfK34Rc4ydQZB3BgNQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">骰子游戏模拟[由作者创建]</p></figure><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2947" class="kz la it nc b gy ng nh l ni nj">Average win probability after 10000 simulations: 0.1667325999999987<br/>Average ending balance after 10000 simulations: $833.663</span></pre><h2 id="9cee" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">分析结果</h2><p id="32e2" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">任何蒙特卡罗模拟(或任何这方面的分析)最重要的部分是从结果中得出结论。从我们的图中可以确定玩家很少在 1000 掷后盈利。事实上，我们 10，000 次模拟的平均期末余额为 833.66 美元(由于随机化，您的结果可能略有不同)。因此，即使玩家赢了，庄家“慷慨”地支付了 4 倍于我们赌注的钱，但庄家还是赢了。</p><p id="1364" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们还注意到我们获胜概率大约是 0.1667，或者大约是 1/6。让我们想想为什么会这样。回到前面的一段，我们注意到玩家有 6 种可能获胜的结果。我们还注意到有 36 种可能的掷骰子。使用这两个数字，我们预计玩家将在 36 次掷骰中赢得 6 次，或者 1/6 次，这与我们的蒙特卡洛预测相匹配。相当酷！</p><h2 id="2451" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="fb65" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">你可以用这个例子来发挥你的创造力，尝试不同的赌注，不同的掷骰子等等。如果你愿意，你也可以跟踪一些其他的变量。使用这个例子来熟悉蒙特卡洛模拟，并真正使它成为你自己的。更有趣的是，如果庄家支付 5 倍的赌注，玩家平均会与庄家持平。此外，如果他们支付的金额超过赌注的 5 倍，房子很可能最终会破产。如果你想看那些结果，请在评论中告诉我！这个简单的例子说明了为什么蒙特卡罗模拟和概率如此重要。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="467c" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">感谢您阅读文章！我希望这有助于你创建一个可靠的蒙特卡洛模拟！请关注我更多的 Python 相关文章，并查看我写的其他文章！</p></div></div>    
</body>
</html>