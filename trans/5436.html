<html>
<head>
<title>Python Documentation Testing with doctest: The Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 doctest 测试 Python 文档:简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-documentation-testing-with-doctest-the-easy-way-c024556313ca#2022-12-06">https://towardsdatascience.com/python-documentation-testing-with-doctest-the-easy-way-c024556313ca#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="44d9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="484d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">doctest 允许文档、单元和集成测试，以及测试驱动的开发</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/d364d807b3f2dafeab7f455b6b4b423c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dljPuq2NGKKcLvu9"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">doctest 允许保持最新的代码文档。照片由<a class="ae lh" href="https://unsplash.com/@esmiloenak?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊斯哈格·罗宾</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d4a7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码测试不一定很难。更重要的是，<a class="ae lh" href="https://medium.com/geekculture/make-yourself-enjoy-writing-unit-tests-e639711c10bd" rel="noopener">测试使编码变得更容易和更快——甚至，至少对一些开发人员来说，更令人愉快</a>。然而，为了让测试变得愉快，我们使用的测试框架需要对用户友好。</p><p id="aa1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python 提供了几个测试框架，目前最流行的三个是<code class="fe me mf mg mh b"><a class="ae lh" href="https://docs.pytest.org/en/7.2.x/contents.html" rel="noopener ugc nofollow" target="_blank">pytest</a></code>和内置的<code class="fe me mf mg mh b"><a class="ae lh" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">unittest</a></code>和<code class="fe me mf mg mh b"><a class="ae lh" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">doctest</a></code>。前两种侧重于单元测试。<code class="fe me mf mg mh b">doctest</code>是不同的，它的主要目的——但<em class="mi">肯定不是唯一的目的——是文档测试。</em></p><p id="4f82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">doctest</code>也是这篇文章的主旨。我将介绍这个特别有趣的工具，希望您能看到，尽管它很简单，但它非常有用。老实说，<code class="fe me mf mg mh b">doctest</code>是我最喜欢的 Python 包，正如我在这次<a class="ae lh" href="https://www.blog.pythonlibrary.org/2022/10/24/pydev-of-the-week-marcin-kozak/" rel="noopener ugc nofollow" target="_blank">“本周 PyDev”</a>采访中强调的。在上面，我写道，如果我们希望测试是愉快的，我们需要一个用户友好的工具。说<code class="fe me mf mg mh b"><a class="ae lh" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">doctest</a></code>用户友好是一种保守的说法——它是我见过的最简单、最友好的测试工具。</p><p id="2be1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">说到这里，我觉得很困惑，为什么我认识的大多数 python 爱好者很少使用或者根本不使用<code class="fe me mf mg mh b">doctest</code>。我希望这篇文章能让他们——还有你——相信将<code class="fe me mf mg mh b">doctest</code>引入日常编码程序是值得的。</p><p id="1da3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我提到的<code class="fe me mf mg mh b">doctest</code>很简单。的确，它是如此的简单，以至于看完这篇短文就足够你使用它了！</p><h1 id="c39c" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated"><code class="fe me mf mg mh b">doctest</code>是关于什么的？</h1><p id="b763" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated"><code class="fe me mf mg mh b">doctest</code>是一个标准库测试框架，所以它与您的 Python 安装一起提供。这意味着你不必安装它。虽然它不是为复杂的单元测试场景而设计的，但它使用简单，而且在大多数情况下功能强大。</p><p id="35d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">doctest</code>模块提供了<code class="fe me mf mg mh b">pytest</code>和<code class="fe me mf mg mh b">unittest</code>都没有的:<a class="ae lh" href="https://en.wikipedia.org/wiki/Documentation_testing" rel="noopener ugc nofollow" target="_blank"> <em class="mi">文档测试</em> </a>。简而言之，文档测试对于测试您的代码文档是否是最新的非常有用。这是相当多的功能，尤其是在大型项目中:只需一个命令，您就可以检查所有示例是否正确。因此，在每次新的提交、合并和发布之后，它取代了反复阅读文档中的代码示例。您还可以将<code class="fe me mf mg mh b">doctest</code> ing 添加到 CI/CD 管道中。</p><p id="b82d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">doctest</code>采用的方法使用了我们称之为回归测试的方法。原则上，您从示例中运行代码，保存输出，并且在将来您可以运行<code class="fe me mf mg mh b">doctest</code>来检查示例是否提供相同的输出——这意味着它们以它们应该的方式工作。如您所见，这将该工具的使用限制在不会随会话变化的对象上。因此，您不能使用这种方法来测试输出的随机元素。一个例子是对象的，它们在不同的会话中是不同的。这个限制并不是特定于<code class="fe me mf mg mh b">doctest</code>的，但是它在这个测试框架中似乎比在其他框架中更重要。幸运的是，<code class="fe me mf mg mh b">doctest</code>提供了处理这种限制的工具。</p><p id="6873" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与任何测试工具一样，您可以——也应该——在对代码进行任何更改之后运行<code class="fe me mf mg mh b">doctest</code>,以便检查这些更改是否没有影响输出。有时他们会，由于他们的性格(例如，你修复了一个 bug，现在功能工作正常了——但是不同了)；如果是这种情况，您应该更新相应的测试。如果更改不应该影响输出，但是它们影响了输出，正如失败的测试所表明的，代码有问题，因此是代码需要进一步的更改。</p><h1 id="a22b" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated"><strong class="ak">利用</strong> <code class="fe me mf mg mh b"><strong class="ak">doctest</strong></code> <strong class="ak">，结合实例</strong></h1><p id="20a4" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">要编写<code class="fe me mf mg mh b">doctest</code> s，您需要提供代码和预期的输出。在实践中，您以类似于在<a class="ae lh" href="https://docs.python.org/3/tutorial/interpreter.html" rel="noopener ugc nofollow" target="_blank">Python 解释器</a>中的代码及其输出的方式编写测试。</p><p id="ed20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我用一个简单的例子来描述一下。考虑下面的函数，它是<code class="fe me mf mg mh b">doctest</code>的一部分:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="90fc" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; def foo():<br/>...     return 42</span></pre><p id="f80d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(您可以导入该函数，但我们稍后将返回到这一点。)这是我在 Python 解释器中看到的情况:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi np"><img src="../Images/f7f660e153df96eb91c89a2a23305e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*COL_gFYNCMEPyCR9bs9hwQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Python 解释器中 foo()函数的定义。作者图片</p></figure><p id="2cab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们看到了一个微小的区别。当你在解释器中定义一个函数时，你需要按两次回车键，这就是为什么我们会在函数的末尾看到额外的省略号。<code class="fe me mf mg mh b">doctest</code>代码不需要这个额外的省略号行。更重要的是，在解释器中编码时，不必在每个省略号行之前(省略号之后)额外添加空格，而需要在<code class="fe me mf mg mh b">doctest</code>代码中做；否则，缩进看起来好像是由三个空格组成的，而不是四个。还有一个区别——实际上是一个很好的区别——在 Python 解释器中，您不会看到代码高亮显示。例如，当您编写文档测试时，您可能会在<a class="ae lh" href="https://www.markdownguide.org/" rel="noopener ugc nofollow" target="_blank"> Markdown </a>或<a class="ae lh" href="https://docutils.sourceforge.io/rst.html" rel="noopener ugc nofollow" target="_blank"> reStructuredText </a>文件中看到它。</p><p id="b58a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想你会同意这些不是很大的差异，而是好的差异。多亏了他们，<code class="fe me mf mg mh b">doctest</code>代码看起来很漂亮。</p><p id="af25" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，<code class="fe me mf mg mh b">&gt;&gt;&gt;</code>和<code class="fe me mf mg mh b">...</code>(Python 省略号)构成了测试的基本部分，因为<code class="fe me mf mg mh b">doctest</code>使用它们来识别新命令刚刚开始(<code class="fe me mf mg mh b">&gt;&gt;&gt;</code>)以及前一行的命令正在继续(<code class="fe me mf mg mh b">...</code>)。</p><p id="556d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面定义<code class="fe me mf mg mh b">foo()</code>函数的 cope 片段仍然不是有效的<code class="fe me mf mg mh b">doctest</code>，因为它只定义了函数。要编写一个测试，我们需要调用函数并包含它的预期输出:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="6519" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; foo()<br/>42</span></pre><p id="4853" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样！这是我们的第一个<code class="fe me mf mg mh b">doctest </code>——你已经了解了关于这个工具你需要知道的大部分内容！总之，此<code class="fe me mf mg mh b">doctest</code>将如下所示:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="9820" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; foo()<br/>42<br/>&gt;&gt;&gt; def foo():<br/>...     return 42</span></pre><p id="92dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以从 shell 运行测试。您也可以从 Python 解释器中完成，但是由于它需要与其中一个 shell 方法相同的代码，所以我不会重点介绍这一点；你也很少需要它。？？？<em class="mi">不清楚的句子！！！</em></p><p id="027b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设测试保存为<code class="fe me mf mg mh b">doctest_post_1.md</code>。要运行它，请打开 shell，导航到测试文件所在的文件夹，然后运行以下命令(它在 Windows 和 Linux 中都可以工作):</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="380a" class="nk mk it mh b be nl nm l nn no">$ python -m doctest doctest_post_1.md</span></pre><p id="e0cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果测试通过，你将什么也看不到。如果失败，您将在 shell 中看到这个。为了了解其工作原理，让我们将测试中的 42 改为 43:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="03ef" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; foo()<br/>43</span></pre><p id="de70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将是输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nq"><img src="../Images/a6f6537cfaa1f0eb7b4c847e080e7bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OU3EhokVX75cwY-s7MvMwA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在 shell 中运行的 doctest(失败)的输出。作者图片</p></figure><p id="3825" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以用另一种方法做这件事。考虑以下模块:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="2606" class="nk mk it mh b be nl nm l nn no"># mathmodule.py<br/>"""The simplest math module ever.<br/><br/>You can use two functions:<br/>&gt;&gt;&gt; add(2, 5.01)<br/>7.01<br/>&gt;&gt;&gt; multiply(2, 5.01)<br/>10.02<br/>"""<br/><br/><br/>def add(x, y):<br/>    """Add two values.<br/><br/>    &gt;&gt;&gt; add(1, 1)<br/>    2<br/>    &gt;&gt;&gt; add(-1.0001, 1.0001)<br/>    0.0<br/>    """<br/>    return x + y<br/><br/><br/>def multiply(x, y):<br/>    """Multiple two values.<br/><br/>    &gt;&gt;&gt; multiply(1, 1)<br/>    1<br/>    &gt;&gt;&gt; multiply(-1, 1)<br/>    -1<br/>    """<br/>    return x * y<br/><br/><br/>if __name__ == "__main__":<br/>    import doctest<br/><br/>    doctest.testmod()</span></pre><p id="0a9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用这个 name-main 块，您可以简化 shell 命令:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="e915" class="nk mk it mh b be nl nm l nn no">$ python doctest_post_1.md</span></pre><p id="ee89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这运行模块，运行它意味着运行它所有的<code class="fe me mf mg mh b">doctest</code>。</p><p id="42e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您想要查看详细的输出时，添加一个<code class="fe me mf mg mh b">-v</code>标志。下面，我使用了这个标志，它导致了下面的输出:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="da05" class="nk mk it mh b be nl nm l nn no">$ python doctest_post_1.md -v<br/>Trying:<br/>    add(2, 5.01)<br/>Expecting:<br/>    7.01<br/>ok<br/>Trying:<br/>    multiply(2, 5.01)<br/>Expecting:<br/>    10.02<br/>ok<br/>Trying:<br/>    add(1, 1)<br/>Expecting:<br/>    2<br/>ok<br/>Trying:<br/>    add(-1.0001, 1.0001)<br/>Expecting:<br/>    0.0<br/>ok<br/>Trying:<br/>    multiply(1, 1)<br/>Expecting:<br/>    1<br/>ok<br/>Trying:<br/>    multiply(-1, 1)<br/>Expecting:<br/>    -1<br/>ok<br/>3 items passed all tests:<br/>   2 tests in __main__<br/>   2 tests in __main__.add<br/>   2 tests in __main__.multiply<br/>6 tests in 3 items.<br/>6 passed and 0 failed.<br/>Test passed.</span></pre><p id="2b63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它相当杂乱，说实话，我几乎从不使用它。它的主要优势是我们在最后看到的，测试的总结。然而，在开发时，我不需要它，因为我通常运行测试来检查某个特定的功能是否通过测试。因此，这一点很重要，<code class="fe me mf mg mh b">doctest</code> s 应该相当快，因为你通常不会请求一个特定的测试，你只需从一个模块中运行所有的测试。</p><p id="16bb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面，我们展示了如何编写和运行<code class="fe me mf mg mh b">doctest</code>,所以是时候考虑实际问题了，也许还有更复杂的例子。<code class="fe me mf mg mh b">doctest</code>测试通常有两个位置:</p><ul class=""><li id="e8d1" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated">在函数/类/方法文档字符串中</li><li id="0428" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">在文档文件中</li></ul><p id="321b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为它们可能有显著的不同，所以让我们逐一讨论它们。</p><h2 id="f99b" class="of mk it bd ml og oh dn mp oi oj dp mt lr ok ol mv lv om on mx lz oo op mz iz bi translated"><code class="fe me mf mg mh b"><strong class="ak">doctest</strong></code> <strong class="ak">文档字符串中的 s </strong></h2><p id="52a2" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">考虑以下函数:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="02cd" class="nk mk it mh b be nl nm l nn no"># mean_module.py<br/>from typing import List, Union<br/><br/>def mean(x: List[Union[float, int]]) -&gt; float:<br/>    """Calculate the mean of a list of floats.<br/><br/>    &gt;&gt;&gt; x = [1.12, 1.44, 1.123, 6.56, 2.99]<br/>    &gt;&gt;&gt; round(mean(x), 2)<br/>    2.65<br/>    """<br/>    return sum(x) / len(x)</span></pre><p id="161c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是如何在 docstring 中编写<code class="fe me mf mg mh b">doctest</code>测试的方法。这里，我们在函数 docstring 中做了，但是您可以将它写在<em class="mi">任何</em> docstring 中，放在四个<code class="fe me mf mg mh b">doctest</code>位置:</p><ul class=""><li id="1dc6" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated">模块文档字符串</li><li id="4344" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">函数 docstring(就像上面的例子)</li><li id="0708" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">类文档字符串</li><li id="c1c1" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">方法文档字符串</li></ul><p id="3888" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用 docstrings，我认为是<code class="fe me mf mg mh b">doctest</code>最常见的用法。请记住，无论一个函数的 docstring 包含什么，它都会出现在它的帮助页面中，您可以通过调用<code class="fe me mf mg mh b">help()</code>函数在 Python 解释器中看到它。例如:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="585e" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; from mean_module import mean<br/>&gt;&gt;&gt; help(mean)</span></pre><p id="c553" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解释器将消失，取而代之的是您将看到下面的<code class="fe me mf mg mh b">mean()</code>功能的帮助页面:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/8a97df8365dd33aa3de6226161d10825.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*QBSe-_Gv_62RBByL7NGXQw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">mean()函数的帮助页面。作者图片</p></figure><p id="a763" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我在<code class="fe me mf mg mh b">doctest</code>测试中欣赏的另一件事:与 docstrings 结合，它们产生帮助页面，因此代码文档是干净的和最新的。有时函数或方法非常复杂，以至于很难看出应该如何使用它们。然后，通常，像添加到 docstring 中的一两个<code class="fe me mf mg mh b">doctest</code>测试这样小的东西会比类型提示和代码以及 docstring 的其余部分一起提供更多的信息。</p><p id="a79a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，请记住，不要让用文档测试淹没文档字符串。虽然在其中包含许多这样的测试可能很诱人，但是您不应该这样做。阅读这样的文档字符串是不愉快的。最好将关键的测试放在 docstring 中，将剩余的测试移到别处。您可以将它们移动到一个专用的<code class="fe me mf mg mh b">doctest</code>文件中，或者将它们翻译成<code class="fe me mf mg mh b">pytest</code>测试。两种解决方案我都用过。</p><h2 id="615a" class="of mk it bd ml og oh dn mp oi oj dp mt lr ok ol mv lv om on mx lz oo op mz iz bi translated"><code class="fe me mf mg mh b"><strong class="ak">doctest</strong></code>文档文件中的<strong class="ak">年代</strong></h2><p id="7dae" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">您可以在各种类型的文件中编写文档测试。我更喜欢降价。md)但是可以在 reStructuredText(。rst)甚至文本(。txt)文件。但是，不要试图在使用特定编码的文件中这样做，比如 e of。例如，<code class="fe me mf mg mh b">doctest</code>不能与。rtf 文件。</p><p id="1da6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面的代码块展示了一个带有 doctests 的 Markdown 文件的例子。为了节省空间，我将在这里只包括基本的测试，但它们足以显示如何创建这样的文件。</p><p id="7976" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">考虑<code class="fe me mf mg mh b">mathmodule</code>模块的以下自述文件(README.md ):</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="41fb" class="nk mk it mh b be nl nm l nn no"># Introduction<br/><br/>You will find here documentation of the mathmodule Python module. <br/><br/>It contains as many as two functions, `add()` and `multiply()`.<br/><br/>First, let's import the functions:<br/><br/>```python<br/>&gt;&gt;&gt; from mathmodule import add, multiply<br/><br/>```<br/><br/>## Using `add()`<br/><br/>You can use the `add()` function in the following way:<br/><br/>```python<br/>&gt;&gt;&gt; add(1, 1)<br/>2<br/>&gt;&gt;&gt; add(2, 5.01)<br/>7.01<br/><br/>```<br/><br/>## Using `multiply()<br/><br/>You can use the `multiply()` function in the following way:<br/><br/>```python<br/>&gt;&gt;&gt; multiply(1, 1)<br/>1<br/>&gt;&gt;&gt; multiply(-1, 1)<br/>-1<br/><br/>```</span></pre><p id="0cd2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，这里没有哲学:您在典型的代码块中添加了<code class="fe me mf mg mh b">doctest</code>。有两件事你应该记住:</p><ul class=""><li id="a506" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated">在完成代码块之前添加一个空行。否则，<code class="fe me mf mg mh b">doctest</code>会将<code class="fe me mf mg mh b">```</code>视为输出的一部分。</li><li id="d436" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">不要忘记导入您将在测试文件中使用的所有对象；这里，这些是<code class="fe me mf mg mh b">add()</code>和<code class="fe me mf mg mh b">multiply()</code>功能。这在你看来可能是一个基本的错误，甚至可能太基本了。即使这是最基本的，我也经常这样做；我甚至在这里，当写上述自述文件。</li></ul><p id="a28e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，我在代码块中包含了所有的测试，但是即使是在代码块之外编写的测试也会运行。然而，我认为这样做没有任何意义。</p><h1 id="f0c8" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated"><code class="fe me mf mg mh b">doctest</code>工具</h1><p id="3ffb" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">上面，我们已经学习了<code class="fe me mf mg mh b">doctest</code>的基本用法。然而，我们可以用它做更多的事情。通过使用所谓的指令，我们可以使用大多数附加的<code class="fe me mf mg mh b">doctest</code>功能。</p><p id="de17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">指令直接添加在被测试的代码之后，使用如下所示的特定语法。当需要指令的命令被分成几行时，您可以将指令添加到其中的任何一行中(我马上会给出一个例子)。指令改变<code class="fe me mf mg mh b">doctest</code>的行为；例如，测试可以忽略输出的一部分，规范化空白，捕捉异常，等等。</p><h2 id="fe8e" class="of mk it bd ml og oh dn mp oi oj dp mt lr ok ol mv lv om on mx lz oo op mz iz bi translated">省略</h2><p id="3436" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">也许最重要和最常用的指令是省略号:<code class="fe me mf mg mh b"># doctest: +ELLIPSIS</code>。下面，你可以看到上面的<code class="fe me mf mg mh b">multiply</code>函数的两个测试，一个没有，另一个有<code class="fe me mf mg mh b">ELLIPSIS</code>指令:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="772d" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; multiply(2.500056, 1/2.322)<br/>1.0766821705426355<br/>&gt;&gt;&gt; multiply(2.500056, 1/2.322) # doctest: +ELLIPSIS<br/>1.076...</span></pre><p id="4aed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，您需要在输出中的测试代码和省略号之后添加指令，输出中省略号所在的任何内容都将被忽略。这是另一个例子:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="a923" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; multiply<br/>&lt;function multiply at 0x7...&gt;</span></pre><p id="6ae3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，您可以使用结束的<code class="fe me mf mg mh b">&gt;</code>字符，但不是必须的。</p><h2 id="7e31" class="of mk it bd ml og oh dn mp oi oj dp mt lr ok ol mv lv om on mx lz oo op mz iz bi translated">输出中的长行</h2><p id="8fe8" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">长队可能是一种负担。我们有两种方法来处理输出中过长的行:(i) <code class="fe me mf mg mh b">\</code>和(ii)<em class="mi"/><code class="fe me mf mg mh b">NORMALIZE_WHITESPACE</code><em class="mi"/>指令。</p><p id="c469" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mi">方法(一):使用</em> <code class="fe me mf mg mh b"><em class="mi">\</em></code>。像在 Python 代码中一样，我们可以使用反斜杠(<code class="fe me mf mg mh b">\</code>)将输出分成几行，如下所示:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="c61f" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; s1 = "a"*20<br/>&gt;&gt;&gt; s2 = "b"*40<br/>&gt;&gt;&gt; add(s1, s2)<br/>'aaaaaaaaaaaaaaaaaaaa\<br/>bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'</span></pre><p id="73e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这场考验确实会通过。上面的输出格式非常难看，但是当我们需要在函数、类或方法 docstring 中拆分行时，情况会更糟:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="8fdb" class="nk mk it mh b be nl nm l nn no">def add(x, y):<br/>    """Add two values.<br/><br/>    &gt;&gt;&gt; add(1, 1)<br/>    2<br/>    &gt;&gt;&gt; add(-1.0001, 1.0001)<br/>    0.0<br/>    &gt;&gt;&gt; add(s1, s2)<br/>    'aaaaaaaaaaaaaaaaaaaa\<br/>bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'<br/>    """<br/>    return x + y</span></pre><p id="db15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，将这一行分成两部分需要我们将第二行移动到它的最开始；否则，<code class="fe me mf mg mh b">doctest</code>会看到以下输出:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="bc2a" class="nk mk it mh b be nl nm l nn no">'aaaaaaaaaaaaaaaaaaaa    bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'</span></pre><p id="378c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以测试会失败。</p><p id="c5db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意<em class="mi">这是处理行间字符串分割的唯一方法</em>。当您需要拆分长输出(例如，一个列表、一个元组等)时，下一个方法会更好。</p><p id="d3c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mi">方法(二)</em> <code class="fe me mf mg mh b">NORMALIZE_WHITESPACE</code> <em class="mi">指令</em>。这个方法不使用难看的反斜杠。相反，它使用了<code class="fe me mf mg mh b">NORMALIZE_WHITESPACE</code>指令:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="7199" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; multiply([1, 2], 10) #doctest: +NORMALIZE_WHITESPACE<br/>    [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,<br/>     1, 2, 1, 2, 1, 2, 1, 2, 1, 2]</span></pre><p id="1374" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果没有指令，该测试将无法通过:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="a270" class="nk mk it mh b be nl nm l nn no">Failed example:<br/>    multiply([1, 2], 10)<br/>Expected:<br/>    [1, 2, 1, 2, 1, 2, 1, 2, 1, 2,<br/>     1, 2, 1, 2, 1, 2, 1, 2, 1, 2]<br/>Got:<br/>    [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]</span></pre><p id="98df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是它通过了指令。只要有可能，我就用这个指令代替反斜杠，除了拆分长字符串。</p><h2 id="baaa" class="of mk it bd ml og oh dn mp oi oj dp mt lr ok ol mv lv om on mx lz oo op mz iz bi translated">例外</h2><p id="310e" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">上面，我们讨论了省略号指令。然而，省略号也有助于异常处理，也就是说，当我们想测试一个抛出错误的例子时:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="29f0" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; add(1, "bzik")<br/>Traceback (most recent call last):<br/>    ...<br/>TypeError: unsupported operand type(s) for +: 'int' and 'str'</span></pre><p id="7443" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出清楚地显示已经引发了一个异常，并且我们测试了它是否是预期的异常。</p><p id="7ffd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你能看出这个省略号的例子和前面的例子有什么不同吗？请注意，尽管我们在这里使用了省略号，但是在测试异常输出时，我们并不需要提供省略号指令。我想这是因为在测试中捕捉异常是如此频繁，以至于<code class="fe me mf mg mh b">doctest</code>创建者决定将省略号的这种用法构建到<code class="fe me mf mg mh b">doctest</code>语法中，而不需要添加省略号指令。</p><blockquote class="or"><p id="9c4d" class="os ot it bd ou ov ow ox oy oz pa md dk translated">当测试异常输出时，我们不必提供省略号指令。</p></blockquote><h2 id="15b9" class="of mk it bd ml og pb dn mp oi pc dp mt lr pd ol mv lv pe on mx lz pf op mz iz bi translated">排除故障</h2><p id="7b1c" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated"><code class="fe me mf mg mh b">doctest</code>为<a class="ae lh" href="https://docs.python.org/3/library/doctest.html#debugging" rel="noopener ugc nofollow" target="_blank">调试</a>提供了几种机制。既然我们在讨论基础，我将只介绍一种机制，这是最简单的，但至少对我来说，也是最直观和最有用的。说实话，自从我开始用<code class="fe me mf mg mh b">doctest</code>以来，我只用这种方法，满足我的需求绰绰有余。</p><p id="9d7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该方法使用内置的<code class="fe me mf mg mh b">pdb</code>模块和内置的<code class="fe me mf mg mh b">breakpoint()</code>函数。我们可以通过两种方式使用<code class="fe me mf mg mh b">doctest</code>进行调试:</p><ol class=""><li id="5b4d" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md pg nx ny nz bi translated">调试通过<code class="fe me mf mg mh b">doctest</code>测试的特定功能。</li><li id="3d08" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md pg nx ny nz bi translated">调试一个<code class="fe me mf mg mh b">doctest</code>会话。</li></ol><p id="7609" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mi">公元 1 年。调试通过</em> <code class="fe me mf mg mh b">doctest</code>测试的特定功能。在这种情况下，使用<code class="fe me mf mg mh b">breakpoint()</code>在函数中设置一个点，并运行 doctest。无非是使用<code class="fe me mf mg mh b">breakpoint()</code>进行标准调试，而是通过运行<code class="fe me mf mg mh b">doctest</code>来进行。</p><p id="0fe6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用<code class="fe me mf mg mh b">doctest</code>来调试下面的模块，它被命名为<code class="fe me mf mg mh b">play_debug.py</code>，只包含一个函数。</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="1835" class="nk mk it mh b be nl nm l nn no">def play_the_debug_game(x, y):<br/>    """Let's play and debug.<br/>    <br/>    &gt;&gt;&gt; play_the_debug_game(10, 200)<br/>    142<br/>    """<br/>    x *= 2<br/>    breakpoint()<br/>    x += 22<br/>    y *= 2<br/>    y -= 300<br/>    return x + y</span></pre><p id="2e64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面，您将看到 shell 截图，其中包含在模块上运行<code class="fe me mf mg mh b">doctest</code>后的调试会话。在输出中，我用省略号替换了路径。</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="eb7a" class="nk mk it mh b be nl nm l nn no">$ python -m doctest play_debug.py<br/>&gt; .../play_debug.py(9)play_the_debug_game()<br/>-&gt; x += 22<br/>(Pdb) l<br/>  4         &gt;&gt;&gt; play_the_debug_game(10, 200)<br/>  5         142<br/>  6         """<br/>  7         x *= 2<br/>  8         breakpoint()<br/>  9  -&gt;     x += 22<br/> 10         y *= 2<br/> 11         y -= 300<br/> 12         return x + y<br/>[EOF]<br/>(Pdb) x<br/>20<br/>(Pdb) n<br/>&gt; .../play_debug.py(10)play_the_debug_game()<br/>-&gt; y *= 2<br/>(Pdb) x<br/>42<br/>(Pdb) c</span></pre><p id="be1e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，这是<code class="fe me mf mg mh b">pdb</code>调试器的标准用法。这不是真正的<code class="fe me mf mg mh b">doctest</code>调试，而是通过<code class="fe me mf mg mh b">doctest</code>运行的代码的调试。我经常在代码开发过程中使用这种方法，尤其是当代码还没有包含在工作应用程序中的时候。</p><p id="4271" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="mi">公元 2 年。调试一个</em> <code class="fe me mf mg mh b">doctest</code> <em class="mi">会话</em>。与前一种方法不同，这种方法意味着调试实际的测试会话。你以类似的方式做它，但是这一次，你在一个测试中增加一个点，而不是在一个函数中。例如:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="88f5" class="nk mk it mh b be nl nm l nn no">def play_the_debug_game(x, y):<br/>    """Let's play and debug.<br/>    <br/>    &gt;&gt;&gt; game_1 = play_the_debug_game(10, 200)<br/>    &gt;&gt;&gt; game_2 = play_the_debug_game(1, 2)<br/>    &gt;&gt;&gt; breakpoint()<br/>    &gt;&gt;&gt; game_1, game_2<br/>    (142, -272)<br/>    """<br/>    x *= 2<br/>    x += 22<br/>    y *= 2<br/>    y -= 300<br/>    return x + y</span></pre><p id="7af3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在开始一个环节:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="f1cc" class="nk mk it mh b be nl nm l nn no">$ python -m doctest play_debug.py<br/>--Return--<br/>&gt; &lt;doctest play_debug.play_the_debug_game[2]&gt;(1)&lt;module&gt;()-&gt;None<br/>-&gt; breakpoint()<br/>(Pdb) game_1<br/>142<br/>(Pdb) game_2<br/>-272<br/>(Pdb) game_1 + game_2<br/>-130<br/>(Pdb) c</span></pre><p id="6d56" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种类型的调试在各种情况下都很有用，在这些情况下，您想要检查测试会话中正在发生什么；例如，当测试以一种意想不到的方式进行，所以你想检查发生了什么。</p><h1 id="a3c2" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">先进的例子</h1><p id="faf2" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">在前面的章节中，我展示了使用基本的<code class="fe me mf mg mh b">doctest</code>工具的简单例子。正如已经提到的，我很少使用更高级的工具。这是因为<code class="fe me mf mg mh b">doctest</code>是以一种方式设计的，它的基本工具确实能使一个人取得很多成就。也许这就是我如此喜欢这个测试框架的原因。</p><p id="0d8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个高级使用<code class="fe me mf mg mh b">doctest</code>的例子，我将使用两个文件——一个表示文档，另一个表示单元测试——来自我的一个 Python 包<code class="fe me mf mg mh b"><a class="ae lh" href="https://github.com/nyggus/perftester" rel="noopener ugc nofollow" target="_blank">perftester</a></code>。如果你想看更多的例子，你可以去包的<a class="ae lh" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>仓库。正如你在<a class="ae lh" href="https://github.com/nyggus/perftester/tree/main/tests" rel="noopener ugc nofollow" target="_blank">中看到的测试/文件夹的自述文件</a>，我把<code class="fe me mf mg mh b">perftester</code>当作一个实验:</p><blockquote class="ph pi pj"><p id="56a8" class="li lj mi lk b ll lm kd ln lo lp kg lq pk ls lt lu pl lw lx ly pm ma mb mc md im bi translated">在<code class="fe me mf mg mh b">perftester</code>中使用<code class="fe me mf mg mh b">doctest</code> ing 作为唯一的测试框架是一个实验。<code class="fe me mf mg mh b">perftester</code>中的测试非常丰富，收集在四个位置:<a class="ae lh" href="https://github.com/nyggus/perftester/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">主 README </a>，主 perftester 模块中的 docstrings，<a class="ae lh" href="https://github.com/nyggus/perftester/blob/main/docs" rel="noopener ugc nofollow" target="_blank">docs 文件夹</a>，以及<a class="ae lh" href="https://github.com/nyggus/perftester/blob/main/tests" rel="noopener ugc nofollow" target="_blank"> this 文件夹</a>。</p></blockquote><p id="c18e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，软件包的主自述文件充满了<code class="fe me mf mg mh b">doctest</code>——但这仅仅是开始。要了解更多信息，请访问<a class="ae lh" href="https://github.com/nyggus/perftester/tree/main/docs" rel="noopener ugc nofollow" target="_blank"> docs/ </a>文件夹，里面全是 Markdown 文件，每个都是一个<code class="fe me mf mg mh b">doctest</code> ing 文件。虽然这些是可测试的<em class="mi">文档文件</em>，但是<a class="ae lh" href="https://github.com/nyggus/perftester/tree/main/tests" rel="noopener ugc nofollow" target="_blank">测试/文件夹</a>中的文件构成了实际的测试文件。换句话说，我使用<code class="fe me mf mg mh b">doctest</code>作为唯一的测试框架，用于文档、单元和集成测试。在我看来，实验是成功的，最终的结论是，当你的项目中不需要复杂的单元和集成测试时，你可以使用<code class="fe me mf mg mh b">doctest</code>作为唯一的测试框架。</p><p id="d7db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我在这个项目中没有使用<code class="fe me mf mg mh b">pytest</code>并不意味着我决定完全停止使用<code class="fe me mf mg mh b">pytest</code>。我的常规方法是连接<code class="fe me mf mg mh b">doctest</code>和<code class="fe me mf mg mh b">pytest</code>。我使用<code class="fe me mf mg mh b">doctest</code>进行基于测试的开发，但是一旦一个函数、类或方法准备好了，我会将一些测试转移到<code class="fe me mf mg mh b">pytest</code>文件中，只保留一些测试作为<code class="fe me mf mg mh b">doctest</code> s。我通常用<code class="fe me mf mg mh b">doctest</code> s 编写 READMEs，如果我需要添加一个 doc 文件，我通常会用<code class="fe me mf mg mh b">doctest</code>测试将它变成一个 Markdown 文件。</p><p id="31bf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我给你看一下<code class="fe me mf mg mh b">perftester</code>的 docs 文件夹<code class="fe me mf mg mh b"><a class="ae lh" href="https://github.com/nyggus/perftester/blob/main/docs/most_basic_use_time.md" rel="noopener ugc nofollow" target="_blank">docs/most_basic_use_time.md</a></code>中的一个文档文件的片段(大约一半)。在下面的代码中，我换行以缩短它们。</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="3820" class="nk mk it mh b be nl nm l nn no"># Basic use of `perftester.time_test()`<br/><br/>```python<br/>&gt;&gt;&gt; import perftester as pt<br/>&gt;&gt;&gt; def preprocess(string):<br/>...    return string.lower().strip()<br/>&gt;&gt;&gt; test_string = "  Oh oh the young boy, this YELLOW one, wants to sing a song about the sun.\n"<br/>&gt;&gt;&gt; preprocess(test_string)[:19]<br/>'oh oh the young boy'<br/><br/>```<br/><br/>## First step - checking performance<br/><br/>We will first benchmark the function, to learn how it performs:<br/><br/>```python<br/>&gt;&gt;&gt; first_run = pt.time_benchmark(preprocess, string=test_string)<br/><br/>```<br/><br/>`first_run` gives the following results:<br/><br/>```python<br/># pt.pp(first_run)<br/>{'raw_times': [2.476e-07, 2.402e-07, 2.414e-07, 2.633e-07, 3.396e-07],<br/> 'raw_times_relative': [3.325, 3.226, 3.242, 3.536, 4.56],<br/> 'max': 3.396e-07,<br/> 'mean': 2.664e-07,<br/> 'min': 2.402e-07,<br/> 'min_relative': 3.226}<br/>```<br/><br/>Fine, no need to change the settings, as the raw times are rather short,<br/>and the relative time ranges from 3.3 to 4.6.<br/><br/><br/># Raw time testing<br/><br/>We can define a simple time-performance test, using raw values, as follows:<br/><br/>```python<br/>&gt;&gt;&gt; pt.time_test(preprocess, raw_limit=2e-06, string=test_string)<br/><br/>```<br/><br/>As is with the `assert` statement, no output means that the test has passed.<br/><br/>If you overdo with the limit so that the test fails, you will see the following:<br/><br/>```python<br/>&gt;&gt;&gt; pt.time_test(preprocess, raw_limit=2e-08, string=test_string) #doctest: +ELLIPSIS<br/>Traceback (most recent call last):<br/>    ...<br/>perftester.perftester.TimeTestError: Time test not passed for function preprocess:<br/>raw_limit = 2e-08<br/>minimum run time = ...<br/><br/>```<br/><br/># Relative time testing<br/><br/>Alternatively, we can use relative time testing, which will be more or<br/>less independent of a machine on which it's run:<br/><br/>```python<br/>&gt;&gt;&gt; pt.time_test(preprocess, relative_limit=10, string=test_string)<br/><br/>```<br/><br/>If you overdo with the limit so that the test fails, you will see the following:<br/><br/>```python<br/>&gt;&gt;&gt; pt.time_test(preprocess, relative_limit=1, string=test_string) #doctest: +ELLIPSIS<br/>Traceback (most recent call last):<br/>    ...<br/>perftester.perftester.TimeTestError: Time test not passed for function preprocess:<br/>relative_limit = 1<br/>minimum time ratio = ...<br/><br/>```</span></pre><p id="341a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意以下几点:</p><ul class=""><li id="59ac" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated">我使用的唯一指令是省略号指令。我不需要更高级的东西。</li><li id="c5a6" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">我想展示命令<code class="fe me mf mg mh b"># pt.pp(first_run)</code>的输出。因为它包含许多随机值(代表基准测试结果)，所以我没有让这个代码块进行<code class="fe me mf mg mh b">doctest</code>测试。我只是简单地陈述了结果。</li></ul><p id="0701" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面，我给出一个测试文件<code class="fe me mf mg mh b"><a class="ae lh" href="https://github.com/nyggus/perftester/blob/main/tests/doctest_config.md" rel="noopener ugc nofollow" target="_blank">tests/doctest_config.md</a></code>的一个部分(<em class="mi">默认值</em>)。与上面的 doc 文件不同，这个文件包括单元测试，而不是文档。因此，您不会在整个文件中看到太多文本——在这一部分也没有文本。这些是单元测试，仅此而已:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="975e" class="nk mk it mh b be nl nm l nn no">## Defaults<br/><br/>```python<br/>&gt;&gt;&gt; import perftester as pt<br/>&gt;&gt;&gt; pt.config.defaults<br/>{'time': {'number': 100000, 'repeat': 5}, 'memory': {'repeat': 1}}<br/><br/>&gt;&gt;&gt; original_defaults = pt.config.defaults<br/>&gt;&gt;&gt; pt.config.set_defaults("time", number=100)<br/>&gt;&gt;&gt; pt.config.defaults<br/>{'time': {'number': 100, 'repeat': 5}, 'memory': {'repeat': 1}}<br/><br/>&gt;&gt;&gt; pt.config.set_defaults("time", repeat=20)<br/>&gt;&gt;&gt; pt.config.defaults<br/>{'time': {'number': 100, 'repeat': 20}, 'memory': {'repeat': 1}}<br/>&gt;&gt;&gt; pt.config.set_defaults("time", repeat=2, number=7)<br/>&gt;&gt;&gt; pt.config.defaults<br/>{'time': {'number': 7, 'repeat': 2}, 'memory': {'repeat': 1}}<br/><br/>&gt;&gt;&gt; pt.config.set_defaults("memory", repeat=100)<br/>&gt;&gt;&gt; pt.config.defaults<br/>{'time': {'number': 7, 'repeat': 2}, 'memory': {'repeat': 100}}<br/><br/>&gt;&gt;&gt; pt.config.set_defaults("memory", number=100)<br/>Traceback (most recent call last):<br/>    ...<br/>perftester.perftester.IncorrectArgumentError: For memory tests, you can only set repeat, not number.<br/><br/>&gt;&gt;&gt; pt.config.set_defaults("memory", number=100, repeat=5)<br/>Traceback (most recent call last):<br/>    ...<br/>perftester.perftester.IncorrectArgumentError: For memory tests, you can only set repeat, not number.<br/><br/>&gt;&gt;&gt; pt.config.set_defaults("memory", repeat=5, number=100)<br/>Traceback (most recent call last):<br/>    ...<br/>perftester.perftester.IncorrectArgumentError: For memory tests, you can only set repeat, not number.<br/><br/>&gt;&gt;&gt; pt.config.defaults = original_defaults<br/><br/>```</span></pre><p id="c173" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，在这个片段中，除了输出之外，我使用的唯一其他工具是省略号，用于表示在一些命令后抛出的异常。</p><h1 id="27ce" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated"><strong class="ak">结论</strong></h1><p id="d27f" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">也许你认为我没有给你展示太多的<code class="fe me mf mg mh b">doctest</code> …你是对的。但是你所学到的将足以让你编写甚至相当高级的测试；在我看来，这就是你需要了解的关于<code class="fe me mf mg mh b">doctest</code> ing 的大部分内容。</p><p id="450b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这并不意味着我们<code class="fe me mf mg mh b">doctest</code>旅程的结束。我们将在下一篇文章中回到这个问题，因为<code class="fe me mf mg mh b">doctest</code> ing 提供了更高级的工具，也许您会想要使用。例如，我们将学习如何在测试驱动开发(TDD)中使用<code class="fe me mf mg mh b">doctest</code>；以及如何在 PoC 项目中有效地使用它。</p><h1 id="a5b2" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">脚注</h1><p id="ea0e" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">在<code class="fe me mf mg mh b">doctest</code>的情况下，对于初学者来说基本不代表。虽然我几乎每天都在使用这个包，但我很少使用比本文中介绍的工具更高级的工具。</p><h1 id="1495" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">资源</h1><div class="pn po gp gr pp pq"><a href="https://medium.com/geekculture/make-yourself-enjoy-writing-unit-tests-e639711c10bd" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">让自己享受编写单元测试的乐趣</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">大多数开发人员不喜欢编写测试。如果你是其中之一，尽你所能去改变它。</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">medium.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe lb pq"/></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://docs.python.org/3/library/doctest.html" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">doctest -测试交互式 Python 示例- Python 3.11.0 文档</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">源代码:Lib/doctest.py 通过验证所有交互的…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://docs.pytest.org/en/7.2.x/contents.html" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">完整的 pytest 文档</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">为功能测试请求一个唯一的临时目录</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">docs.pytest.org</p></div></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://docs.python.org/3/library/unittest.html" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">单元测试-单元测试框架- Python 3.11.0 文档</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">源代码:Lib/unittest/__init__。py(如果你已经熟悉了测试的基本概念，你可能想…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://docs.python.org/3/tutorial/interpreter.html" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">2.使用 Python 解释器- Python 3.11.0 文档</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">Python 解释器通常作为/usr/local/bin/python3.11 安装在可用的机器上…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">docs.python.org</p></div></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://docutils.sourceforge.io/rst.html" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">重组文本</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">reStructuredText 是一个易于阅读、所见即所得的纯文本标记语法和解析器系统。这是…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">docutils.sourceforge.io</p></div></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://www.markdownguide.org/" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">降价指南</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">解释如何使用 Markdown 的免费开源参考指南。</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">www.markdownguide.org</p></div></div><div class="pz l"><div class="qf l qb qc qd pz qe lb pq"/></div></div></a></div><div class="pn po gp gr pp pq"><a href="https://github.com/nyggus/perftester" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">GitHub - nyggus/perftester:一个轻量级 Python 包，用于 Python 的性能测试…</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">使用 pip 安装:perftester 仍在大量测试中。如果您发现任何不符合预期的情况，请…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">github.com</p></div></div><div class="pz l"><div class="qg l qb qc qd pz qe lb pq"/></div></div></a></div></div><div class="ab cl qh qi hx qj" role="separator"><span class="qk bw bk ql qm qn"/><span class="qk bw bk ql qm qn"/><span class="qk bw bk ql qm"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt pq"><a href="https://medium.com/@nyggus/membership" rel="noopener follow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd jd gy z fp pv fr fs pw fu fw jc bi translated">通过我的推荐链接加入媒体——玛茜·科萨克</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">阅读马尔钦·科萨克(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">medium.com</p></div></div><div class="pz l"><div class="qo l qb qc qd pz qe lb pq"/></div></div></a></div></div></div>    
</body>
</html>