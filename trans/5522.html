<html>
<head>
<title>4x Faster Pandas Operations with Minimal Code Change</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pandas 操作速度提高 4 倍，代码更改最少</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4x-faster-pandas-operations-with-minimal-code-change-bc7079792184#2022-12-13">https://towardsdatascience.com/4x-faster-pandas-operations-with-minimal-code-change-bc7079792184#2022-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e98e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">停止等待熊猫行动。将它们并行化。</h2></div><p id="58a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pandas 的一个主要限制是在处理大型数据集时速度会很慢，尤其是在运行复杂的操作时。这可能会让需要在工作中处理和分析大型数据集的数据科学家和分析师感到沮丧。</p><p id="e3ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以解决这个问题。一种方法是使用并行处理。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/2cf6d2516763a9ad76f78932fa62ce5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htN4-Ovy1z62JW9Uy1rxlQ.jpeg"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">一起运行多个熊猫操作！通过稳定扩散成像。</p></figure><h1 id="381e" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">输入 Pandarallel</h1><p id="b95d" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">Pandarallel 是一个开源 Python 库，支持使用多个 CPU 并行执行 Pandas 操作，从而显著提高了速度。</p><p id="e67d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它建立在流行的 Pandas 库之上，只需要很少的代码修改就可以使用。</p><blockquote class="mo mp mq"><p id="b2b8" class="kf kg mr kh b ki kj jr kk kl km ju kn ms kp kq kr mt kt ku kv mu kx ky kz la ij bi translated">声明:我不隶属于 pandarallel。</p></blockquote><h1 id="29f8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">利用 Pandarallel 实现显著的速度提升</h1><p id="3980" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">你可以亲眼看看熊猫与熊猫的速度相比有多快。在这里，pandarallel 将工作负载分布在 4 个内核上。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mz"><img src="../Images/7fd0ac2d05e7a4abc47257149b65740b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0BaaCutk-oowr3Ke"/></div></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi gj"><img src="../Images/bac386ca7d5778ff95ea6f2fd7b93143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h0bSlyT_tAzlRYvr"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">来源:<a class="ae na" href="https://nalepae.github.io/pandarallel/" rel="noopener ugc nofollow" target="_blank"> Pandarallel 的文档</a></p></figure><p id="7f8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更具体地说，从下面的图表中可以明显看出速度的提高。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nb"><img src="../Images/52fde44628c2add2b4e72a146e2e6cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*igAWI2vkZyf9vEYI"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">加速 4 倍。来源:<a class="ae na" href="https://nalepae.github.io/pandarallel/" rel="noopener ugc nofollow" target="_blank"> Pandarallel 的文档</a></p></figure><h1 id="611f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Pandarallel 入门</h1><p id="361c" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">要安装 Pandarallel，您可以使用 pip 软件包管理器:</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="65df" class="ng ls iq my b be nh ni l nj nk">pip install pandarallel</span></pre><p id="3b1a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以将包导入 Python 代码并初始化它。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="4582" class="ng ls iq my b be nh ni l nj nk">from pandarallel import pandarallel<br/><br/># Initialize pandarallel<br/>pandarallel.initialize()</span></pre><p id="caba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，您就可以使用下面提供的函数了。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nl"><img src="../Images/8bce29e60bbebe1b489226bbc3f73b22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JJUzQuJtfOKdAspu"/></div></div></figure><h1 id="ac6a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">如何使用 pandarallel 的代码示例</h1><p id="5f83" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">让我们首先创建一个模拟数据框架，其中包含从电子商务网站购买的商品。每行对应于在每个日期购买的一种产品。这些列是:</p><ul class=""><li id="4026" class="nm nn iq kh b ki kj kl km ko no ks np kw nq la nr ns nt nu bi translated"><code class="fe mv mw mx my b">date</code></li><li id="568a" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated"><code class="fe mv mw mx my b">product_id</code></li><li id="a89c" class="nm nn iq kh b ki nv kl nw ko nx ks ny kw nz la nr ns nt nu bi translated"><code class="fe mv mw mx my b">quantity</code></li></ul><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="d211" class="ng ls iq my b be nh ni l nj nk">import pandas as pd<br/>import numpy as np<br/><br/># Generate a dataframe.<br/>df = pd.DataFrame()<br/><br/># Generate a column of random dates from 2019-01-01 to 2019-12-31<br/>df['date'] = pd.date_range('2019-01-01', '2019-12-31', periods=10000)<br/><br/># Seed numpy random <br/>np.random.seed(0)<br/><br/># Generate a column of random product_id from 1 to 5<br/>df['product_id'] = np.random.randint(1, 5, 10000)<br/><br/># Generate a column of quantity bought from 1 to 100<br/>df['quantity'] = np.random.randint(1, 100, 10000)<br/></span></pre><p id="b480" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是前五行。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="26a7" class="ng ls iq my b be nh ni l oa nk">|    | date                | product_id | quantity |<br/>|---:|:--------------------|-----------:|---------:|<br/>|  0 | 2019-01-01 00:00:00 |          1 |       10 |<br/>|  1 | 2019-01-01 00:52:25 |          4 |       36 |<br/>|  2 | 2019-01-01 01:44:50 |          2 |       79 |<br/>|  3 | 2019-01-01 02:37:15 |          1 |       33 |<br/>|  4 | 2019-01-01 03:29:41 |          4 |       59 |</span></pre><p id="7702" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们使用<code class="fe mv mw mx my b">pandarallel</code>来加快我们的工作流程。为此，让我们初始化我们的 pandarallel。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="e5bb" class="ng ls iq my b be nh ni l nj nk">from pandarallel import pandarallel<br/><br/># Initialize pandarallel<br/>pandarallel.initialize()</span></pre><p id="2d95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，您有几个初始化 pandarallel 的选项。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="0126" class="ng ls iq my b be nh ni l nj nk"># Initialize pandarallel with a progress bar<br/>pandarallel.initialize(progress_bar = True)<br/><br/># Set the number of workers for parallelization. <br/># By default, this is the number of cores available.<br/>pandarallel.initialize(nb_workers = 4) <br/><br/># Initialize pandarallel with all logs printed.<br/># By default, this is 2 (display all logs), while 0 display n ologs.<br/>pandarallel.initialize(verbose = 2)</span></pre><h2 id="06e3" class="ob ls iq bd lt oc od dn lx oe of dp mb ko og oh md ks oi oj mf kw ok ol mh om bi translated">使用 parallel_apply 对列应用函数。</h2><p id="553d" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">让我们从<code class="fe mv mw mx my b">date</code>列中提取月份。例如，一月是 1，二月是 2。为此，我们可以使用<code class="fe mv mw mx my b">parallel_apply</code>函数。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="27b0" class="ng ls iq my b be nh ni l nj nk"># Group date by month using parallel_apply<br/>df['month'] = df['date'].parallel_apply(lambda x: x.month)</span></pre><pre class="on nc my nd bn ne nf bi"><span id="1fcf" class="ng ls iq my b be nh ni l oa nk"><br/>|    | date                | product_id | quantity | month |<br/>|---:|:--------------------|-----------:|---------:|------:|<br/>|  0 | 2019-01-01 00:00:00 |          1 |       10 |     1 |<br/>|  1 | 2019-01-01 00:52:25 |          4 |       36 |     1 |<br/>|  2 | 2019-01-01 01:44:50 |          2 |       79 |     1 |<br/>|  3 | 2019-01-01 02:37:15 |          1 |       33 |     1 |<br/>|  4 | 2019-01-01 03:29:41 |          4 |       59 |     1 |</span></pre><p id="2250" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在<code class="fe mv mw mx my b">parallel_apply</code>中使用一个<code class="fe mv mw mx my b">lambda</code>函数。让我们为每个<code class="fe mv mw mx my b">product_id</code>指定一个价格。然后，我们可以计算每笔交易的<code class="fe mv mw mx my b">revenue</code>。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="fe53" class="ng ls iq my b be nh ni l nj nk"># Assign a price to each product_id <br/>df['price'] = df['product_id'].parallel_apply(lambda x: 5.59 if x == 1 else 1.29 if x == 2 else 3.49 if x == 3 else 6.99)<br/><br/># Get the revenue<br/>df['revenue'] = df.parallel_apply(lambda x: x['quantity']* x['price'], axis=1)<br/></span></pre><pre class="on nc my nd bn ne nf bi"><span id="16b4" class="ng ls iq my b be nh ni l oa nk">|   | date                |product_id |quantity |month |price |revenue |<br/>|--:|:--------------------|----------:|--------:|-----:|-----:|-------:|<br/>| 0 | 2019-01-01 00:00:00 |         1 |      10 |    1 | 5.59 |  55.9  |<br/>| 1 | 2019-01-01 00:52:25 |         4 |      36 |    1 | 6.99 | 251.64 |<br/>| 2 | 2019-01-01 01:44:50 |         2 |      79 |    1 | 1.29 | 101.91 |<br/>| 3 | 2019-01-01 02:37:15 |         1 |      33 |    1 | 5.59 | 184.47 |<br/>| 4 | 2019-01-01 03:29:41 |         4 |      59 |    1 | 6.99 | 412.41 |</span></pre><h2 id="e2a4" class="ob ls iq bd lt oc od dn lx oe of dp mb ko og oh md ks oi oj mf kw ok ol mh om bi translated">使用 parallel_apply 对组应用函数。</h2><p id="7514" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">您也可以在应用<code class="fe mv mw mx my b">parallel_apply</code>之前按特定列分组。在下面的例子中，我们可以按特定的月份分组，并获得每个月的总收入。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="67ee" class="ng ls iq my b be nh ni l nj nk"># Get the sum of revenue for every month<br/>monthly_revenue_df = df.groupby('month').parallel_apply(np.sum)[['revenue']]</span></pre><p id="d716" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的是，我们也可以使用<code class="fe mv mw mx my b">parallel_apply </code>执行滚动求和。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="72de" class="ng ls iq my b be nh ni l nj nk"># Generate 3-month rolling revenue by month<br/>monthly_revenue_df['rolling_3_mth_rev'] = monthly_revenue_df['revenue'].rolling(3, min_periods=3).parallel_apply(np.sum)</span></pre><pre class="on nc my nd bn ne nf bi"><span id="0d8c" class="ng ls iq my b be nh ni l oa nk">|   month |   revenue |   rolling_3_mth_rev |<br/>|--------:|----------:|--------------------:|<br/>|       1 |    188268 |                 nan |<br/>|       2 |    164251 |                 nan |<br/>|       3 |    176198 |              528717 |<br/>|       4 |    178021 |              518470 |<br/>|       5 |    188940 |              543159 |</span></pre><h2 id="d413" class="ob ls iq bd lt oc od dn lx oe of dp mb ko og oh md ks oi oj mf kw ok ol mh om bi translated">使用 parallel_applymap 将函数应用于整个数据帧</h2><p id="2a30" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">如果有一个函数适用于整个数据帧，<code class="fe mv mw mx my b">applymap</code>是理想的函数。例如，要将<code class="fe mv mw mx my b">df</code>的所有元素转换成一个字符串，我们可以使用这个函数。</p><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="8da7" class="ng ls iq my b be nh ni l nj nk"># Convert every element of df to a string<br/>df.parallel_applymap(lambda x: str(x))</span></pre><h1 id="d8f8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">完整的代码</h1><pre class="lc ld le lf gt nc my nd bn ne nf bi"><span id="abcf" class="ng ls iq my b be nh ni l nj nk">import pandas as pd<br/>import numpy as np<br/>from pandarallel import pandarallel<br/><br/># Generate a dataframe.<br/>df = pd.DataFrame()<br/><br/># Generate a column of random dates from 2019-01-01 to 2019-12-31<br/>df['date'] = pd.date_range('2019-01-01', '2019-12-31', periods=10000)<br/><br/># Seed numpy random <br/>np.random.seed(0)<br/><br/># Generate a column of random product_id from 1 to 5<br/>df['product_id'] = np.random.randint(1, 5, 10000)<br/><br/># Generate a column of quantity bought from 1 to 100<br/>df['quantity'] = np.random.randint(1, 100, 10000)<br/><br/># Initialize pandarallel<br/>pandarallel.initialize()<br/><br/># Group date by month using parallel_apply<br/>df['month'] = df['date'].parallel_apply(lambda x: x.month)<br/><br/># Assign a price to each product_id <br/>df['price'] = df['product_id'].parallel_apply(lambda x: 5.59 if x == 1 else 1.29 if x == 2 else 3.49 if x == 3 else 6.99)<br/><br/># Get the revenue<br/>df['revenue'] = df.parallel_apply(lambda x: x['quantity']* x['price'], axis=1)<br/><br/># print(df.head().to_markdown())<br/><br/># Get the sum of revenue for every month<br/>monthly_revenue_df = df.groupby('month').parallel_apply(np.sum)[['revenue']]<br/><br/># Generate 3-month rolling revenue by month<br/>monthly_revenue_df['rolling_3_mth_rev'] = monthly_revenue_df['revenue'].rolling(3, min_periods=3).parallel_apply(np.sum)<br/><br/># print(monthly_revenue_df.head().to_markdown())</span></pre><h1 id="8f1d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">何时不使用 pandarallel</h1><p id="0125" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">当数据不适合存储时，我们不应该使用 Pandarallel。在这种情况下，使用<code class="fe mv mw mx my b">spark</code>或<code class="fe mv mw mx my b">pyspark</code>或<code class="fe mv mw mx my b">vaex</code>。</p><p id="d8b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阅读我关于使用<a class="ae na" href="https://medium.com/p/a272d3485b24" rel="noopener"> <strong class="kh ir"> Vaex 每秒处理 90 亿行</strong> </a>的文章。</p><p id="1e10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，pandarallel 有多种用例可以让数据科学家受益。停止等待您的 pandas 操作，将它们并行化。</p><h1 id="1f0b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">和我联系。</h1><p id="53b0" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我是 Travis Tang，技术领域的数据科学家。我在 Medium 和 LinkedIn 上定期分享数据分析和数据科学的技巧。与我联系，获取更多类似的提示。</p></div></div>    
</body>
</html>