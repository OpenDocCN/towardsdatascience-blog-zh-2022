<html>
<head>
<title>Learning Docker, the Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Docker，简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-docker-the-easy-way-52b7bdec5e86#2022-09-08">https://towardsdatascience.com/learning-docker-the-easy-way-52b7bdec5e86#2022-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ab5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个教程，涵盖了Docker的基础知识，并教你如何容器化你的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53282ab9dc950b046aec50c4b990deb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEU8wIKscK4IWt8A_Xf-hA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯利·西克玛在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="af07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker已经接管了软件行业，成为事实上的标准。我想我们大多数人都同意这一点。</p><p id="0e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker不仅让开发人员的生活变得更加轻松，也让运营人员和普通用户的生活变得更加轻松。几年前，安装一个软件可能会很麻烦，安装和设置数据库等东西需要几个小时。今天，它就像在Docker桌面上点击开始或使用Docker CLI运行一行命令一样简单。</p><p id="8fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于如何使用Docker和学习入门基础的教程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">教程的YouTube视频</p></figure><h2 id="ec65" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">什么是Docker</h2><p id="7297" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">Docker用于构建可发布的映像，这些映像可以在任何安装了docker的系统上发布和执行。这可以通过容器化软件来实现，容器化软件是一套拥有运行所需一切的软件。</p><p id="bc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何拥有这种容器化软件的人都可以运行它。想象一下，你在一台Ubuntu机器上安装PostgreSQL并配置它工作，这需要时间，但有了docker，你可以将安装和操作系统容器化，下次你需要它时，只需启动它。</p><p id="33a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker映像不是虚拟机，而是软件的自包含单元，该自包含单元包含它需要运行的一切。当我说一切时，我指的是一切，操作系统、依赖项、网络、配置。</p><p id="24d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在寻找关于它如何工作的更深入的解释，我推荐阅读官方的<a class="ae ky" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank"> docker docs </a>以了解细节。</p><blockquote class="mv mw mx"><p id="b120" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">需要我说docker在Go中编码吗？</p></blockquote><h2 id="d861" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">安装Docker</h2><p id="0778" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">通过访问他们的下载网站下载并安装docker引擎。Docker-desktop现在可用于所有平台，可以作为学习和维护Docker引擎的一个非常好的途径。</p><div class="nc nd gp gr ne nf"><a href="https://docs.docker.com/engine/install/" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">安装Docker引擎</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">Docker Desktop for Linux Docker Desktop帮助您在Mac和Windows上轻松构建、共享和运行容器，就像您做…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">docs.docker.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><p id="c108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用的是Linux，不要忘记运行</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="bafe" class="lx ly it nv b gy nz oa l ob oc">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<!-- --> </span></pre><p id="e0cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将下载docker加密密钥，并将其添加为可信来源。</p><p id="7885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用的是Linux，您还需要将您的用户添加到docker组中，这样您就可以在没有sudo的情况下运行docker。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="ca1c" class="lx ly it nv b gy nz oa l ob oc">sudo groupadd docker<br/>sudo usermod -aG docker $USER</span></pre><h2 id="832f" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">图像和容器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ed06d2ab8e2ae42753592a7eaf04ee62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMAWeRaA1P-raKPPk6ngdA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像充当一个模板，一旦运行就变成一个容器</p></figure><p id="0ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有docker用法都以<code class="fe oe of og nv b">Image</code>开头。您的映像是包含运行操作系统和其他依赖项所需的一切的盒子。把它想象成一个盒子，里面装满了启动这个盒子所需的所有文件。</p><blockquote class="mv mw mx"><p id="3c9d" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated"><em class="it">Docker容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切:代码、运行时、系统工具、系统库和设置。</em></p></blockquote><p id="ec5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在docker中，我们经常会谈到两种类型的<a class="ae ky" href="https://docs.docker.com/develop/develop-images/baseimages/" rel="noopener ugc nofollow" target="_blank">图像</a>。</p><ul class=""><li id="39cc" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><strong class="lb iu">基础图像</strong> —每个图像的开始，称为<code class="fe oe of og nv b">scratch</code>的图像，这是一个没有任何内容的图像，大小为0字节。</li><li id="795e" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">父映像</strong> —创建映像时，我们定义一个父映像作为起点，父映像中的所有内容都将出现在新映像中。</li></ul><p id="1cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像是用<code class="fe oe of og nv b">docker build</code>命令在docker中构建的。构建映像时，您需要指定一个<code class="fe oe of og nv b">tag</code>，它通常与版本、使用的系统架构或父映像相关。我们还需要给它一个名字，名字和标签，用<code class="fe oe of og nv b">:</code>分开。</p><p id="893c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个示例构建命令如下所示</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="0ac9" class="lx ly it nv b gy nz oa l ob oc">docker build -t myImage:1.0 .</span></pre><p id="8c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这个点不是一个错别字，构建图像时给出的最后一个参数是<a class="ae ky" href="https://docs.docker.com/engine/context/working-with-contexts/" rel="noopener ugc nofollow" target="_blank">上下文</a>。稍后将详细介绍上下文。</p><p id="d16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用Docker CLI工具查看您有哪些图像。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="3ce7" class="lx ly it nv b gy nz oa l ob oc">docker images</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/e6836e1c3b197c91cd4acf4829483480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWjW-fR0rpP19hVcbP6vJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker图像的输出</p></figure><p id="9358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，您将看到位于您机器上的所有当前图像。您将看到图像来自的<code class="fe oe of og nv b">repository</code>，而<code class="fe oe of og nv b">tag</code>是版本标签。<code class="fe oe of og nv b">Image id</code>是一个自动生成的ID，可以用来指代某个图像。它的创建日期和整个图像的总大小也会显示出来。</p><p id="8d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker使用该映像将其运行到一个<code class="fe oe of og nv b">container</code>中。每当我们使用<code class="fe oe of og nv b">docker run</code>启动一个容器时，它就会使用<code class="fe oe of og nv b">image</code>并将它转换成一个容器。容器是一个开始的图像。</p><p id="f632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把映像想象成蓝图，它有运行所需的软件，当你启动一个映像时，它会根据这个蓝图构建一个容器。</p><p id="1387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者如果你熟悉OOP，图像可以被认为是一个类，而容器是一个对象。</p><p id="f8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着您可以从同一个映像运行许多容器。理解从同一个映像运行的两个容器是完全独立的是很重要的。如果我们有一个称为基础的映像，并且我们从基础启动两个容器，我们在容器A中所做的更改不会反映在容器b中。在容器中所做的任何更改也不会反映在映像中。</p><p id="3a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe oe of og nv b">docker run</code>命令启动容器。Run获取图像并将其转换为容器。</p><p id="f606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，容器是图像的实例，但是容器中的任何更改都不会保存到图像中。</p><p id="55ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Docker的一个优点是，如果我们从一个干净的Ubuntu映像启动一个容器，并添加我们想要的软件和文件，我们可以使用<code class="fe oe of og nv b">docker commit</code>将该容器保存为映像。</p><p id="bdbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，我们有用于构建图像的<code class="fe oe of og nv b">docker build</code>，我们有从图像创建容器的<code class="fe oe of og nv b">docker run</code>，以及从容器创建图像的<code class="fe oe of og nv b">docker commit</code>。</p><p id="d89d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们能够创建高度定制的映像，满足成功运行软件的所有需求。</p><p id="dc18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DockerHub是一个图片存储库，任何组织或开发者都可以在这里发布他们的图片。Docker会自动使用dockerhub来查找任何你试图使用，但本地没有的图片。</p><h2 id="6eab" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">运行和管理容器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/cef09d00b82bc928bcf48adff35dc048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S3ZDI2FngKoVQMoU8UusYg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用docker CLI管理容器</p></figure><p id="e8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行一个容器来学习它。</p><p id="058b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe oe of og nv b">docker run</code>命令运行docker。如果您执行它，您会看到它打印出一个非常易于使用的语法。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="1538" class="lx ly it nv b gy nz oa l ob oc">docker run [OPTIONS] IMAGENAME:TAG [COMMAND] [ARGS]</span></pre><p id="45b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<code class="fe oe of og nv b">OPTIONS</code>是行为标志，改变如何运行容器。Imagename和Tag只是要使用的名称和标记。</p><p id="b925" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">COMMAND</code>是我们希望在容器启动后传递给它的任何命令，后面跟有任何<code class="fe oe of og nv b">ARGS</code>。</p><p id="2f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们运行一个Ubuntu容器，让它打印出当前工作目录中的所有文件。如果你没有安装Ubuntu容器也不用担心，当试图运行一个不存在的容器时，docker会自动查看DockerHub并为你下载。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="76d7" class="lx ly it nv b gy nz oa l ob oc">docker run ubuntu ls -al</span></pre><p id="db51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在命令中我没有指定使用什么标签，它会自动使用特殊标签<code class="fe oe of og nv b">latest</code>，这是最近上传的同名图片。</p><p id="0a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您运行这个命令两次，您会看到第一次它下载图像需要几秒钟，第二次它会立即运行。</p><p id="5d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经创建了两个容器来打印目录内容，我们可以使用<code class="fe oe of og nv b">ps</code>命令找到容器。我们将添加<code class="fe oe of og nv b">a</code>标志来列出所有容器，否则，只列出正在运行的容器。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="107a" class="lx ly it nv b gy nz oa l ob oc">docker container ps -a</span></pre><p id="5d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该看看那里的集装箱。你现在可以使用他们的ID删除他们。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="59d2" class="lx ly it nv b gy nz oa l ob oc">docker container rm $ID</span></pre><p id="8997" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用容器ID很麻烦，而且很长，我通常用<code class="fe oe of og nv b">--name</code>来运行我的容器，它允许你为你的容器创建一个自定义名称。该名称可用于在其他命令中引用docker，例如如果您想要删除它。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="4dd9" class="lx ly it nv b gy nz oa l ob oc">docker run --name test ubuntu ls<br/>docker container rm test</span></pre><p id="0fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理运行中的容器时，还有一些其他标志可以派上用场。</p><p id="24c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">--rm</code>将确保在流程结束后移除容器</p><p id="4bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">-it</code>用交互式外壳运行。</p><p id="97df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，如果你运行没有<code class="fe oe of og nv b">--rm</code>的<code class="fe oe of og nv b">docker run</code>，你不会删除容器，这将占用你的硬盘空间。</p><p id="a8aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试打开一个ubuntu shell，然后退出并重新列出你的容器，它应该已经被删除了。当调试为什么软件不能如预期的那样工作时，使用交互式shell是非常有用的。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="98d1" class="lx ly it nv b gy nz oa l ob oc">docker run --rm -it ubuntu</span></pre><p id="87d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们可以让docker容器运行很长时间，我们可以使用<code class="fe oe of og nv b">-d</code>标志让容器在一个分离的进程中运行。当你有一个运行你的软件的docker时，这是很常见的。</p><p id="cd29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以很容易地尝试所有这些，只需执行以下命令。在这个例子中，我们希望在bash中运行不止一个内部命令，所以我们没有简单地将sleep直接传递给docker，而是使用<code class="fe oe of og nv b">bash -c</code>插入多个命令来顺序运行。每个命令由<code class="fe oe of og nv b">;</code>分隔。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="9a26" class="lx ly it nv b gy nz oa l ob oc">docker run --name myUbuntuContainer -d ubuntu bash -c "sliep 5; echo 'Hello World'; sleep 60"</span></pre><p id="025d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你应该明白这个命令是做什么的了，但是为了好玩，它会从ubuntu映像创建一个名为<code class="fe oe of og nv b">myUbuntuContainer</code>的容器，在后台运行(分离<code class="fe oe of og nv b">-d</code>)，然后依次执行<code class="fe oe of og nv b">-c</code>中的命令。注意，我没有使用<code class="fe oe of og nv b">--rm</code>,所以这个容器不会在执行完成后自行移除。</p><p id="014b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行<code class="fe oe of og nv b">docker ps -a</code>列出所有现有的容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/fcadd4a0b76ae1caabdd7e8a7c82bc57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SxH21zyiAOqhtvyjgS6Kg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用ps显示正在运行的docker容器</p></figure><p id="e96d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出向您显示用于引用容器的容器ID，例如，如果您想要删除容器，但是您也可以使用名称。<code class="fe oe of og nv b">ps</code>还显示了哪些端口从容器暴露给主机，目前没有。</p><p id="ac02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想查看分离的容器中发生了什么，您可以通过运行。当您想要排除故障或了解容器不工作的原因时，这很有用。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="a5fd" class="lx ly it nv b gy nz oa l ob oc">docker logs $CONTAINERID/NAME</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/28bd8f17b17c4e983c530ffd8deb25a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*FG15D0WdAvogfDKAa7xyHw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker日志向我们显示了一个错误</p></figure><p id="34d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们记录了一个错误，在第一个<code class="fe oe of og nv b">sleep</code>命令中有一个打字错误。让我们移除这个容器，这样它就不会占用额外的空间，是的，留下一个容器会占用和图片一样多的空间。</p><p id="e506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe oe of og nv b">docker container rm</code>后跟容器ID或名称来删除容器。注意如果你的容器还在运行，你必须通过<code class="fe oe of og nv b">-f</code>标志来强制移除它。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="2373" class="lx ly it nv b gy nz oa l ob oc">docker container rm myUbuntuContainer</span></pre><p id="205a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行docker的一个重要方面是限制某个容器允许使用的资源数量，比如内存和CPU。您可以使用以下标志添加这些资源。</p><p id="6a6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">--memory</code> —使用它来设置允许的最大内存量，等等<code class="fe oe of og nv b">--memory=6m</code> (6兆字节是一个容器的最小值)</p><p id="bd47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">--cpus</code> —用于限制容器允许使用多少CPU资源等<code class="fe oe of og nv b">--cpus=1</code>。</p><p id="7957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe oe of og nv b">inspect</code>来验证容器的任何配置。尝试启动一个容器并设置内存限制，然后检查它</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="e47b" class="lx ly it nv b gy nz oa l ob oc">docker inspect ID/Name</span></pre><h2 id="2194" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">容器中的网络</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6941ab6d9e8f314d8c3913ae09d73562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T94FN2sRVsthMXo_nnjwbw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Docker中的联网和连接容器</p></figure><p id="480d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，您的容器在私有网络中运行。您可以让容器在同一个网络中运行，或者将它们隔离开来。</p><p id="2a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的事情之一是从容器中公开端口。</p><p id="4c70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以轻松地将<code class="fe oe of og nv b">publish</code>标志添加到<code class="fe oe of og nv b">docker run</code>命令中。简写标志为<code class="fe oe of og nv b">-p</code>，接受主机端口和容器端口以<code class="fe oe of og nv b">:</code>分隔链接。</p><p id="7aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在容器的端口<code class="fe oe of og nv b">8080</code>上托管了一个API，但是想要在运行端口<code class="fe oe of og nv b">8099</code>上的容器的主机上公开该API。</p><p id="1017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过运行以下命令来实现这一点</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="78d9" class="lx ly it nv b gy nz oa l ob oc">docker run -p 8099:8080 --name myUbuntuContainer -d ubuntu bash -c "sleep 5; echo 'Hello World'; sleep 60"</span></pre><p id="e2ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe oe of og nv b">docker container ps</code>或<code class="fe oe of og nv b">docker port $CONTAINERID</code>查看暴露的端口。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/5f1ca8e4db074c5afc7c5808f06d965a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fMTwC2Mc4OQYFTq6K1vIYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker port显示暴露的端口</p></figure><p id="6635" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意docker将默认为TCP，您可以通过在端口后添加<code class="fe oe of og nv b">/tcp</code>或<code class="fe oe of og nv b">/udp</code>来指定协议。</p><p id="f28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件很酷的事情是，你可以让docker动态地为你分配主机端口。如果您将主机部分排除在<code class="fe oe of og nv b">-p</code>标志之外，它将找到任何可用的端口并使用该端口。</p><p id="7268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试一下，只指定<code class="fe oe of og nv b">-p 8080</code>看看它为你选择了什么端口。</p><p id="1e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker还允许我们创建虚拟网络，以帮助我们拥有能够连接的容器。</p><p id="7a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe oe of og nv b">docker network ls</code>查看所有当前的虚拟网络。你会看到至少三个网络。</p><p id="9980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不想隔离，可以使用<code class="fe oe of og nv b">host</code>网络，它将运行与运行容器的主机相同的网络。如果您完全不想要网络，则使用<code class="fe oe of og nv b">none</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/7e8c3e4869625e09f6afa32eccc5dc81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*2dHVJaRqFF_RmfCb7ceKxw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认存在的Docker网络</p></figure><p id="a806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下命令创建新的虚拟网络</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="e118" class="lx ly it nv b gy nz oa l ob oc">docker network create skynet</span></pre><p id="904b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你创建了它，当运行容器时，我们可以使用<code class="fe oe of og nv b">--net</code>标志告诉容器在这个网络中运行。</p><p id="70e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试这一点，我们将打开两个容器，并将它们分配给<code class="fe oe of og nv b">skynet</code>，看看我们是否能相互ping通。然而，我们需要将<code class="fe oe of og nv b">ping</code>安装到ubuntu容器中，并且<strong class="lb iu">你不应该在容器</strong>中这样做。<br/>我们只是安装ping软件来展示网络。我们将在本文后面的构建容器时研究如何做到这一点。</p><blockquote class="pa"><p id="fadb" class="pb pc it bd pd pe pf pg ph pi pj lu dk translated">在构建映像时，始终安装依赖项</p></blockquote><p id="93e0" class="pw-post-body-paragraph kz la it lb b lc pk ju le lf pl jx lh li pm lk ll lm pn lo lp lq po ls lt lu im bi translated">让我们从启动第一个容器并准备它开始，我们将这个第一个容器命名为<code class="fe oe of og nv b">sky-client</code>。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="7d13" class="lx ly it nv b gy nz oa l ob oc">docker run --rm -it --net skynet --name sky-client ubuntu<br/>root@134f1245a32:/# apt-get update; apt-get install iputils-ping</span></pre><p id="6348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装ping后，尝试对<code class="fe oe of og nv b">sky-server</code>执行ping。您应该会看到一条错误消息，指出这在DNS中不存在。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/fb2fb31633c402c5b881bc73ab5f96b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*m5nWVhPkqmcllVV04HttdA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">找不到天空服务器</p></figure><p id="d6e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以解决这个问题，打开第二个终端，启动第二个名为<code class="fe oe of og nv b">sky-server</code>的容器。注意我们如何使用容器名在网络上定位它们。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="ab49" class="lx ly it nv b gy nz oa l ob oc">docker run --rm -it --net skynet --name sky-server ubuntu</span></pre><p id="2bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦sky-server开始运行，再次尝试从<code class="fe oe of og nv b">sky-client</code>ping它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/f799275fa5c290bb6a6a7d5ae5dc3f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9GPH9B0pGFhiJUiYuclEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用容器名称using同一网络上正在运行的容器</p></figure><p id="750f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们现在有两个容器运行在同一个虚拟网络上。需要记住的一点是，在同一个容器中可以有多个网络。</p><h2 id="023e" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">卷</h2><p id="16f5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">有时您希望在主机和容器之间共享数据。例如，当您有一个在容器中运行的数据库，并且希望该数据库在重新启动之间保持不变时，通常就是这种情况。</p><p id="feb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe oe of og nv b">-v</code>标志在容器和主机之间添加卷。同样，与网络端口一样，您可以指定主机上的路径，然后指定容器上的路径来装载。路径用<code class="fe oe of og nv b">:</code>划分，大部分时间用docker。</p><p id="6364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着打开一个容器，与主机共享一个文件夹。请记住始终使用主机上的完整路径。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="7e58" class="lx ly it nv b gy nz oa l ob oc">docker run --rm -ti -v /home/percy/sharedfolder:/shared --name sharing-is-caring ubuntu</span></pre><p id="9527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将在我的主机上的<code class="fe oe of og nv b">/home/percy/sharedfolder</code>处创建一个文件夹，该文件夹连接到容器上的<code class="fe oe of og nv b">/shared</code>文件夹。</p><p id="98f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尝试在该文件夹中创建一两个文件，看看能否在您的主机上查看它们。</p><p id="1a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以使用<code class="fe oe of og nv b">--volumes-from</code>标志在容器之间安装文件夹。如果您有需要跨多个容器共享的数据，这将非常有用。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="9153" class="lx ly it nv b gy nz oa l ob oc"># Start container with mount<br/>docker run --rm -ti --net skynet --name sky-client -v $PWD/data:/shared ubuntu<br/># Start the second container with same mounts<br/>docker run --rm -ti --net skynet --name sky-server --volumes-from sky-client ubuntu</span></pre><h2 id="253f" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">注册</h2><p id="e252" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">注册表用于管理和分发图像。有一个默认使用的官方docker注册表，但是你也可以设置你的公司注册表。</p><p id="581a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe oe of og nv b">docker search</code>在注册表中搜索图像。如果你对某个软件感兴趣，你可以随时搜索是否有它的图片。假设您想运行一个PostgreSQL容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/6b7ede811419e16cace4256e9feedf60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PmAKSQRzXGHfkomtGzTZRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker搜索显示许多图像</p></figure><p id="c6f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您会发现许多图像，因为任何人都可以在官方注册表上上传图像。在决定使用哪张图片时，你应该看看官方标签和星星的数量。</p><p id="1adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于任何人都可以创建并上传图像，因此在选择图像时可能会有风险。</p><p id="d6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要一个UI，你可以通过访问<a class="ae ky" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>来查看官方注册表。在Hub中，您通常可以找到关于如何使用该映像的自述文件。</p><p id="7335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将注册表视为代码存储库。</p><h2 id="f50f" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">构建定制的图像</h2><p id="02d4" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">自定义图片有两种方式，第一种是使用<code class="fe oe of og nv b">docker commit</code>，将容器保存为新图片。第二种方法是使用Dockerfiles，我们很快就会了解更多。</p><p id="813d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先看看如何使用Docker commit来轻松地保存一个包含从容器中进行的任何更改的图像。还记得之前我们在容器中下载Ping吗？这不能保存，也不是正确的方法，但是如果我们测试了它，并且知道这个容器是正确的，我们想把它保存为一个图像，我们可以提交这个容器。</p><p id="351c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打开一个新的Ubuntu容器，再次安装Iputils-ping。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="0631" class="lx ly it nv b gy nz oa l ob oc">docker run -it --name test ubuntu<br/>apt-get update -y; apt-get -y install iputils-ping</span></pre><p id="2090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，退出shell并打开主机上的终端。</p><p id="e0af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker commit接受几个选项，我喜欢添加<code class="fe oe of og nv b">--message</code>，这是一个更改的提交消息。我也喜欢添加<code class="fe oe of og nv b">--author</code>，这样其他开发人员就知道该联系谁了。</p><p id="00de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法是</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="7727" class="lx ly it nv b gy nz oa l ob oc">docker commit [OPTIONS] [ContainerName/ID] [repository/name:tag]</span></pre><p id="44d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，让我们提交包含我们需要的软件的容器。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="6d5e" class="lx ly it nv b gy nz oa l ob oc">docker commit --message "added iputils" --author programmingpercy test programmingpercy/ubuntu:1.0</span></pre><p id="0353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您应该能够从这个映像开始运行一个新的容器了。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="395c" class="lx ly it nv b gy nz oa l ob oc">docker run -it --name test2 programmingpercy/ubuntu:1.0</span></pre><p id="2617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经使用了预定义的图像，但还没有触及Docker最漂亮的部分。我们可以使用<code class="fe oe of og nv b">Dockerfiles</code>创建定制的图像。Dockerfile是一个包含脚本语言的文件，我们可以用它来创建和制作我们的图像。</p><p id="cd4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker文件应该被命名为<code class="fe oe of og nv b">dockerfile</code>，这允许docker在你执行目录中的docker时自动检测文件。</p><p id="7f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker文件非常容易阅读和理解，它们从上到下连续运行。有一点需要记住，docker文件中的每一行都是对<code class="fe oe of og nv b">docker run</code>和<code class="fe oe of og nv b">docker commit</code>的执行。这被称为<code class="fe oe of og nv b">layer</code>，有时你可以将动作组合成一行以节省空间。</p><p id="ead1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何创建一个包含预装FFmpeg的自定义ubuntu映像的例子如下所示。</p><blockquote class="mv mw mx"><p id="4f7d" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">FFMPEG是一个用于修改和处理视频和音频流的工具</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile —用于运行FFMPEG的定制he</p></figure><p id="3da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法非常简单，我们现在只讨论基本内容。</p><p id="7302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1行您可以看到<code class="fe oe of og nv b">FROM</code>，它表示我们的构建过程将从其开始的父节点<code class="fe oe of og nv b">image</code>。因此，在这种情况下，它将使用<code class="fe oe of og nv b">ubuntu</code>图像作为启动容器，将ubuntu作为一个容器运行，应用并提交更改。如果你想要一个特定的版本，你可以在分号后添加标签，所以如果你想要ubuntu 20.10等等，添加标签<code class="fe oe of og nv b">FROM ubuntu:20.10</code>。</p><p id="66df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一行使用<code class="fe oe of og nv b">RUN</code>命令，这将用当前层启动一个容器并执行该命令。所以在第3行，我们将启动一个基于<code class="fe oe of og nv b">ubuntu</code>的容器，并更新apt-get存储库。这将被提交到一个新的临时映像中。</p><p id="e6ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个新的临时图像将用于第4行，下载FFmpeg并将其添加到容器中，然后将容器保存为图像。</p><p id="2ba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你可能开始想知道为什么它重建图像的每一步作为一个层，这是超级有效的，没有什么可担心的。如果层在以后没有以任何方式被引用，它将在使用后被删除。主要的好处是docker将缓存这些层，并在构建中重用它们。所以，如果你修改了某个东西，你不必等待所有的东西都重新构建。</p><p id="24c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5行中，您可以看到docker的一个很酷的特性。<code class="fe oe of og nv b">CMD</code>允许我们在映像中指定容器运行时将执行的可执行文件。这允许我们说，当有人运行这个图像时，执行<code class="fe oe of og nv b">FFmpeg</code>。所以，我们刚才做的就是把FFmpeg打包成docker镜像，可以在任何支持docker、windows、mac等的电脑上运行。</p><p id="fefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在你尝试之前，我们需要建立图像。我们只在dockerfile文件中定义了如何构建它。</p><p id="b7d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了构建图像，我们使用<code class="fe oe of og nv b">docker build</code>命令。我们将传入一个标记标志<code class="fe oe of og nv b">-t</code>,为我们的图像指定一个名称。我们还会用一个<code class="fe oe of og nv b">.</code>来结束命令，这个点会让很多人感到困惑，所以试着跟着做。</p><p id="20fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker build命令的最后一个参数是构建上下文。它是docker在构建映像时应该使用的位置的路径。一个<code class="fe oe of og nv b">.</code>命令告诉docker使用当前目录，这是最常见的方法，但是理论上您可以通过指定路径在另一个位置构建这个映像。为什么，你可能会想，因为有时你想让本地文件从你的计算机出现在图像中，我们还没有谈到这一点，但你可以包括文件从主机到docker图像。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="f411" class="lx ly it nv b gy nz oa l ob oc">docker build -t demo/ffmpeg .</span></pre><p id="22de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行构建命令并等待它完成，这可能需要一些时间，这也是我选择FFmpeg的原因。不是让你厌烦，而是向你展示缓存机制。</p><p id="da44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构建期间，您将看到所有构建的层，并在最终图像完成之前移除这些层。第一次构建需要一些时间，但是我建议您在之后尝试运行相同的命令。您应该看到图层被缓存，构建时间是真实的，即时的。</p><p id="71f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在可以用<code class="fe oe of og nv b">docker run</code>命令运行你的令人惊叹的FFmpeg图像，在任何你想要的地方执行FFmpeg。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="df1d" class="lx ly it nv b gy nz oa l ob oc">docker run demo/ffmpeg</span></pre><p id="a971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker文件还有许多其他的docker语句。<br/>一个很常见的是<code class="fe oe of og nv b">ADD</code>语句。这允许您在主机(构建映像的主机)上指定要复制到映像中的文件夹或文件。</p><p id="6e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法非常简单，您指定主机上的路径，然后是映像上的路径。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="1d67" class="lx ly it nv b gy nz oa l ob oc">ÀDD mycomputer/myfile.txt /path/in/image</span></pre><p id="7cef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">ADD</code>也接受URL，所以你可以告诉docker从一个URL获取一个文件并把它放在图像中。</p><p id="bf27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个重要的声明是<code class="fe oe of og nv b">ENV</code>，它是环境变量的缩写</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="d44b" class="lx ly it nv b gy nz oa l ob oc">ENV DATABASE_USER = "my user"</span></pre><p id="ad4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们的图像中有一个小缺陷。我们使用了<code class="fe oe of og nv b">CMD</code>语句来触发FFmpeg，它可以工作，但是它不允许我们向FFmpeg中添加更多我们需要的参数。</p><p id="4df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候阐明<code class="fe oe of og nv b">CMD</code>语句和<code class="fe oe of og nv b">ENTRYPOINT</code>语句之间的区别了。</p><p id="66a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oe of og nv b">CMD</code>用于指定一个完整的命令在容器运行时使用。<code class="fe oe of og nv b">ENTRYPOINT</code>相反指定一个命令运行的开始。</p><p id="ef2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了允许用户使用我们的FFmpeg图像，但是修改FFmpeg参数，我们需要将<code class="fe oe of og nv b">CMD</code>改为<code class="fe oe of og nv b">ENTRYPOINT</code>。请尝试执行更改，然后重新运行容器。现在，您还可以在run命令中添加某些FFmpeg参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile —使用入口点允许FFmpeg的子参数</p></figure><p id="c1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重建图像现在应该允许用户添加输入文件等和更多的<code class="fe oe of og nv b">docker run demo/ffmpeg -inputfile</code>等。</p><p id="fc78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试添加文件，我们将使用前面提到的<code class="fe oe of og nv b">ADD</code>命令来获取演示视频。我们将从一个网址获取演示视频，所以我们可以尝试转换视频。我们将把文件存储在<code class="fe oe of og nv b">/videos</code>图像里面。</p><blockquote class="mv mw mx"><p id="299b" class="kz la my lb b lc ld ju le lf lg jx lh mz lj lk ll na ln lo lp nb lr ls lt lu im bi translated">我建议不要在图像中存储视频，这只是为了展示它是如何工作的。</p></blockquote><p id="fdae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的要点中，我还修改了所有的运行命令到一个层中，这是一个常用的技术，通过将相关的层分组到相同的层中来节省一些空间。<code class="fe oe of og nv b">&amp;&amp;</code>是bash for AND，<code class="fe oe of og nv b">\</code>只是一个不破坏命令的新行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile —我们将URL中的文件添加到/videos中</p></figure><p id="012b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将重建图像，然后执行FFmpeg来加速视频，然后输出到一个挂载的文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用mount运行容器，并在演示文件中使用FFmpeg。</p></figure><p id="74cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行该命令后，您应该能够在您的主机上查看视频的加速版本。</p><p id="f54e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里列出了Dockerfiles中最常用的命令。</p><ul class=""><li id="b1c8" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated"><strong class="lb iu">运行</strong> —用于在终端执行命令。对于Linux，它是Bash，对于windows，它是cmd。</li><li id="cd4f" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu"> ENV </strong> —用于在容器内部分配环境变量。</li><li id="872a" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">标签</strong> —用于向容器添加元数据。来自父图像的标签被继承。</li><li id="9336" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">复制</strong> —将文件从主机复制到容器。只能从主机复制文件。</li><li id="a687" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">添加</strong>——非常类似于COPY，它也将文件复制到我们的容器中。不同之处在于，ADD还可以通过URL使用远程文件。它还可以将本地焦油提取到容器中。</li><li id="a25d" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu"> ARG </strong> —可以由构建映像的人在构建时设置的变量。在构建过程中，可以在docker文件中使用ARGS，但是在构建映像之后，除非重新构建映像，否则不能使用或更改它们。</li><li id="fc8b" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">卷</strong> —在主机和容器之间添加一个挂载点。语法是卷路径。这通常在容器重启之间持久化数据时使用，例如数据库。实际数据存储在主机上，但在容器中使用。</li><li id="e29d" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu"> EXPOSE </strong> —告诉Docker引擎容器正在监听特定的端口和协议。格式是端口/协议(UDP/TCP)</li><li id="03b6" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu"> CMD </strong> —定义Docker容器在启动时应该运行的命令和参数。这通常指向带有一组缺省值的二进制文件。当允许用户更改命令时，应该使用CMD。</li><li id="eac5" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu">入口点</strong> —通常在容器应该作为可执行文件运行时使用。它的功能与CMD相同，但是如果使用ENTRYPOINT，用户不允许更改该命令。</li><li id="e1e3" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated"><strong class="lb iu"> WORKDIR </strong> —设置命令运行的路径。所以如果设置为/app，就像运行cd /app一样。</li></ul><h2 id="79f6" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">多阶段构建</h2><p id="a339" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在docker文件中，您可以做更多的事情。有一件事需要你自己去研究，那就是如何使用多重构建来大量减少docker图像的大小。使用多阶段构建，您可以将图像的大小减少90%以上。我见过大小在1GB左右的图像变成几MB。</p><p id="d426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多阶段允许我们使用映像来构建我们的软件，然后将它们作为最终产品移动到一个更加精简的映像中。</p><p id="7291" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常用它在Ubuntu映像上构建我的Go软件，然后将它转移到一个只包含我的单个二进制文件的暂存容器中。</p><p id="51f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在Dockerfile文件中添加多个<code class="fe oe of og nv b">FROM</code>语句，多阶段构建是可能的，我们可以使用<code class="fe oe of og nv b">AS</code>为每个<code class="fe oe of og nv b">FROM</code>指定一个特定的名称。这是很常见的看到建立阶段命名为<code class="fe oe of og nv b">builder</code>等。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="8769" class="lx ly it nv b gy nz oa l ob oc">FROM ubuntu AS builder</span></pre><p id="33a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过命名一个构建阶段，我们可以稍后使用带有<code class="fe oe of og nv b">--from</code>参数的<code class="fe oe of og nv b">COPY</code>来引用该构建阶段的文件系统。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dockerfile —我们本质上要做的是在一个成熟的操作系统中构建，然后将构建好的二进制文件转移到一个精简的操作系统中。</p></figure><p id="19ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了查看多阶段构建和正常构建之间的差异，我们将构建两个图像并进行比较。首先，我们需要构建一些东西，并更新dockerfile文件来构建二进制文件。</p><p id="4e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的Go程序，它只是打印一条消息，如果你没有安装Go，不要担心，我们将在Docker镜像中构建它，记得吗？</p><p id="cf47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将下面的要点复制到与dockerfile目录相同的名为<code class="fe oe of og nv b">main.go</code>的文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">main.go —打印消息的简单程序</p></figure><p id="bc2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们更新<code class="fe oe of og nv b">dockerfile</code>，首先将<code class="fe oe of og nv b">main.go</code>从主机复制到镜像中，然后构建二进制文件。</p><p id="6464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将把这个二进制文件复制到一个暂存映像中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ps lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dockerfile —在运行映像上构建二进制文件，然后进入临时映像</p></figure><p id="ff8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过执行常规的Build命令来构建映像。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="9a54" class="lx ly it nv b gy nz oa l ob oc">docker build -t multistaged .</span></pre><p id="9d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe oe of og nv b">docker images</code>查看最终图像，我的最后是1.95 MB大小，超级小。这是因为映像中唯一的东西是我们的二进制文件，没有其他东西会使映像膨胀。</p><p id="f11d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以尝试执行图像来验证它是否工作。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="4494" class="lx ly it nv b gy nz oa l ob oc">docker run multistaged</span></pre><p id="287e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么我们要经历这一切，而不是一个单一的构建，让我们来比较图像。</p><p id="f10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用docker build的<code class="fe oe of og nv b">--target</code>选项在某个构建步骤停止多阶段构建。这将允许我们运行第一个构建阶段并从中创建一个映像，我们传递我们的阶段的名称，<code class="fe oe of og nv b">builder</code>。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="6ad6" class="lx ly it nv b gy nz oa l ob oc">docker build --target builder -t singlestaged .</span></pre><p id="9491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，您可以运行<code class="fe oe of og nv b">docker images</code>来比较大小。</p><p id="0565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太棒了，对吧？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/32cfee99333caffce5d4b121efb9e768.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*urOY-fcpwLAj7-vk-3ie0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多阶段与单阶段构建</p></figure><h2 id="0b84" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">编排容器</h2><p id="4a28" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">现在很容易想象，当我们开始使用docker时，它进展很快，我们可以很容易地建立一个数据库、Redis等。如果您构建一个依赖于这些容器的系统，我们需要编排它们。</p><p id="3228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编排系统用于在容器出现故障时启动和重启容器，管理资源，并允许容器发现彼此。</p><p id="a028" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多编排服务，最容易上手的是<code class="fe oe of og nv b">docker-compose</code>，它通常用于帮助开发人员以一种非常简单的方式运行多个容器。Docker-compose 经常被用在开发阶段，使得在本地测试和运行一切变得容易。docker-compose不适合更广泛部署的原因是它仅限于在单台计算机上运行。</p><p id="7ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于生产环境，使用<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>更为常见。Kubernetes在本地硬件上使用，也很容易部署到使用托管服务的云提供商。</p><p id="b7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推荐学习Kubernetes，如果你想入门，我有一篇文章你可以看看。</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/@programmingpercy/learn-kubernetes-the-easy-way-d1cfa460c013" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">中等</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">编辑描述</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div></div></a></div><h2 id="8838" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">结论</h2><p id="1195" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在本教程中，您已经学习了图像和容器，这是Docker的两个关键组件。</p><p id="b126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经学习了如何创建图像，以及如何使用Dockerfiles编写图像规范。</p><p id="d865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经了解了如何在容器之间配置网络。</p><p id="bef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们学习了如何在主机和容器之间以及容器之间装载卷。</p><p id="55ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您已经掌握了足够的基础知识，能够独立使用Docker。</p><p id="1697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的项目中，我几乎总是保存一个打包软件的dockerfile文件。我还建议添加一个docker-compose文件，它将启动任何相关的所需服务。例如，如果您开发一个使用数据库的API，拥有一个启动API和数据库的compose是非常有用的。它帮助其他开发人员快速启动并运行，并减少安装数据库或保持开发实例运行的需要。</p><p id="c550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名开发人员，Docker确实改变了我的生活，让我的生活变得更加轻松。</p><p id="fd42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个教程，我很乐意听到你对这个教程的想法、反馈或意见。</p></div></div>    
</body>
</html>