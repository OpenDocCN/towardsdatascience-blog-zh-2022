<html>
<head>
<title>Tree Traversals and Anagrams In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的树遍历和变位词</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tree-traversals-and-anagrams-in-python-97047bcc6f8e#2022-11-08">https://towardsdatascience.com/tree-traversals-and-anagrams-in-python-97047bcc6f8e#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索散列表和递归算法的周末项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/09d9037910be62226c1495b2ce57c795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hm_0d6gw0zNL1yKKmP1zIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2386" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我知道这只是语言上的意外，但是你可以把“眼睛”中的字母重新排列成“他们看见”的事实感觉…很神奇。</p><p id="6285" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我从小就喜欢字谜游戏。所以，我想尝试用Python来构建一个变位词生成器。它变成了一个有趣的小周末项目，以Python字典和递归的形式使用哈希表。</p><p id="bc3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哈希表用于实现数据库索引和缓存之类的东西。它们通过将计算成本较低的键映射到一个值来实现数据的快速查找。但是，如果您没有接触过树和图之类的东西，您可能不会考虑将哈希表的值作为其他哈希表的值。</p><p id="89e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如您将看到的，用嵌套哈希表构建树结构有助于在大量数据中搜索模式，使之更易于管理。递归是一种工具，可以让你简洁明了地表达搜索逻辑。</p><p id="342e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你在这里看到的字谜生成算法是一种组合搜索算法。这类算法在机器人和人工智能中发挥着重要作用，其中可能状态的空间呈指数增长，甚至是阶乘增长。</p><p id="3b07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，在我们深入研究生成变位词之前，让我们先来看看一个更简单的问题:识别两个字符串何时是彼此的变位词。</p><h1 id="e08f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">如何检查两个字符串是否是字谜</h1><p id="ae94" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果<code class="fe mr ms mt mu b">string1</code>中的人物是<code class="fe mr ms mt mu b">string2</code>中人物的重排，<code class="fe mr ms mt mu b">string1</code>就是<code class="fe mr ms mt mu b">string2</code>的变位词。</p><p id="2ade" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，角色的顺序并不重要。重要的是<code class="fe mr ms mt mu b">string1</code>中每个角色的数量和<code class="fe mr ms mt mu b">string2</code>中每个角色的数量是一样的。如果每个字符在每个字符串中出现的次数相同，那么这两个字符串就是彼此的变位组合。</p><p id="445f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python的<code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noopener ugc nofollow" target="_blank">collections.Counter</a></code>——它是一种特殊类型的字典——可以这样计算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c94b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看到<code class="fe mr ms mt mu b">Counter</code>对象中的空字符串<code class="fe mr ms mt mu b">' '</code>了吗？这是个问题。“Theater”和“the tear”是变位词，尽管一个有空格，另一个没有。字谜不区分大小写。它们也可能有不同的标点符号，如“vitalise”和“IT'S ALIVE！”</p><p id="ca90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个健壮的解决方案需要考虑到所有这些，所以如果没有一些预处理的话<code class="fe mr ms mt mu b">collections.Counter</code>不会削减它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="accc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像大多数问题一样，有很多方法可以解决这个问题。</p><p id="6007" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我想要一个易于理解的解决方案，万一它不能处理所有应该处理的情况，也要易于修改。我使用了string <code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.python.org/3/library/stdtypes.html#str.translate" rel="noopener ugc nofollow" target="_blank">.translate()</a></code>方法，它根据翻译词典替换字符串中的每个字符。映射到<code class="fe mr ms mt mu b">None</code>的字符从字符串中删除。另外，我可以用<code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.python.org/3/library/stdtypes.html#str.maketrans" rel="noopener ugc nofollow" target="_blank">str.maketrans()</a></code>轻松创建翻译词典。</p><p id="f3bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这给了我在字符串被传递到<code class="fe mr ms mt mu b">Counter()</code>之前如何处理字符串的细粒度控制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="79f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe mr ms mt mu b">process()</code>功能中使用<code class="fe mr ms mt mu b"><a class="ae mv" href="https://docs.python.org/3/library/stdtypes.html#str.casefold" rel="noopener ugc nofollow" target="_blank">.casefold()</a></code>而不是<code class="fe mr ms mt mu b">.lower()</code>可能会更好。但总的来说，这是一个健壮的解决方案。这很好理解，前提是你了解<code class="fe mr ms mt mu b">Counter</code>、<code class="fe mr ms mt mu b">.translate()</code>、<code class="fe mr ms mt mu b">str.maketrans()</code>。如果需要，可以很容易地交换处理功能。</p><p id="27a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如何为特定的字符串寻找变位呢？</p><h1 id="1a7b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">如何生成字谜</h1><p id="f434" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这比检查两个字符串是否是彼此的变位词更难。</p><p id="a18a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单地生成一个字符串所有可能的重排是不够的。你必须在有意义的地方插入空格和标点符号。字符串中的结果单词必须是实际的词典单词。</p><p id="d9ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要一种方法来有效地生成使用字符串中的字母的单词。</p><h2 id="bdeb" class="my lv it bd lw mz na dn ma nb nc dp me lh nd ne mg ll nf ng mi lp nh ni mk nj bi translated">在纸上解决它</h2><p id="80db" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">抛开获取单词列表的问题，从简单的开始:</p><pre class="kj kk kl km gt nk mu nl nm aw nn bi"><span id="2d02" class="my lv it mu b gy no np l nq nr">eyes<br/>the<br/>they<br/>see<br/>sea</span></pre><p id="84cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">过程是这样的:</p><ol class=""><li id="f19b" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt nx ny nz oa bi translated">写下您想要生成变位词的短语，例如“眼睛”</li><li id="b431" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">从短语中选择一个字母(比如“t”)，然后浏览列表，寻找以该字母开头的单词(单词=“the”和“them”)。划掉短语中该字母的一个实例，并将该字母记为变位词的第一个字母(变位词=“t”)。</li><li id="09b0" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">从短语中挑选一个还没有被划掉的字母(比如“h”)，把上一步选择的单词过滤到第二个字母是你挑选的新字母的那些(words =“the”和“them”)。划掉短语中的字母，并将其添加到您的变位词中(anagram = "th ")。</li><li id="f68a" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">继续选择未使用的字母并过滤单词列表的过程。当你到达一个单词的末尾时，检查你目前生成的短语是否是原短语的变位词。如果是的话，你就完了。如果没有，从完整的单词列表开始，但是只使用没有被划掉的字母。</li><li id="1639" class="ns nt it la b lb ob le oc lh od ll oe lp of lt nx ny nz oa bi translated">用短语中不同的首字母重复整个过程。</li></ol><p id="ea6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你一步一步地按照上面的小单词列表中的算法，你会得到四个变位词:</p><ul class=""><li id="5e94" class="ns nt it la b lb lc le lf lh nu ll nv lp nw lt og ny nz oa bi translated">眼睛</li><li id="b312" class="ns nt it la b lb ob le oc lh od ll oe lp of lt og ny nz oa bi translated">眼睛看着</li><li id="d52b" class="ns nt it la b lb ob le oc lh od ll oe lp of lt og ny nz oa bi translated">他们看到了</li><li id="24d3" class="ns nt it la b lb ob le oc lh od ll oe lp of lt og ny nz oa bi translated">看到他们了吗</li></ul><p id="c6fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，“眼睛”是你开始用的短语。那很好。扔掉它。</p><p id="7f9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们可以直接跳到所有以字母T开头的单词，而不是扫描整个列表，这不是很好吗？还是跳到所有以th开头的单词？还是从。</p><p id="8976" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">听起来我们需要一个散列表！</p><p id="0699" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们<em class="oh">真正</em>想要的是哈希表的一个哈希表<em class="oh">。</em></p><p id="ad00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哈希表的哈希表是表示树的一种方式。而且，如果你停下来想一想，我描述的生成变位词的方法感觉很像深度优先搜索。对于如何实现算法，这是一个很大的线索。</p><p id="944f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python拥有我们需要的所有部分。</p><h2 id="53fd" class="my lv it bd lw mz na dn ma nb nc dp me lh nd ne mg ll nf ng mi lp nh ni mk nj bi translated">构建字典树</h2><p id="aaa9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们将要构建的树看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/dae424560d98dfc621a64ff1113e53f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RoLIf3X1ltn20_md.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供(使用<a class="ae mv" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank"> Excalidraw </a>制作)</p></figure><p id="05e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python字典是散列表，所以它们是我们的树的基础的自然选择。每个字典的键是包含单个字母的字符串，值是more dictionaries。我们需要知道什么时候是一个单词的末尾，所以我们会用字典<code class="fe mr ms mt mu b">{" ": {}}</code>来标记那些地方。</p><p id="dbd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">眼睛、The、them、see和sea这些词的字典树如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8eed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是你如何构建这样的字典呢？</p><p id="4f80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键的观察是，您可以递归地将单词添加到字典中。从一本空字典开始。对于每个单词，去掉第一个字母——称之为<code class="fe mr ms mt mu b">char</code>。如果<code class="fe mr ms mt mu b">char</code>是字典中的一个键，获取它的值。否则，用空字典设置字典中的键<code class="fe mr ms mt mu b">char</code>作为它的值。然后重复这个过程，使用映射到<code class="fe mr ms mt mu b">char</code>的字典和没有第一个字符的单词。</p><p id="08a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设<code class="fe mr ms mt mu b">word</code>没有空格，将字符串<code class="fe mr ms mt mu b">" "</code>加到末尾，这样我们就能得到正确的终端字典。</p><p id="685e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2a96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">递归很好，因为它可以简洁地描述一个重复的过程。但是，如果不通过手工推理步骤，就很难理解递归算法做了什么。带有一些好例子的文档可以帮助读者(包括你未来的自己！)理解一个递归函数。</p><p id="2e86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们有了一棵树，我们可以开始生成变位词了。</p><h2 id="a3bb" class="my lv it bd lw mz na dn ma nb nc dp me lh nd ne mg ll nf ng mi lp nh ni mk nj bi translated">遍历树来制作字谜</h2><p id="22b3" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">您可以将变位算法实现为遍历单词树中的节点。</p><p id="55a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们选择一个初始节点——短语中的一个字符，我们希望对其进行变位——并在数组中将该节点标记为已访问。然后移动到以该节点为根的树中的分支。重复此操作，直到访问完短语中的所有字符或到达一个单词的末尾。更多递归！</p><p id="f9a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它本质上是一种深度优先的搜索算法，除了可行走的节点受到树中节点和短语中尚未被访问的字符的限制。</p><p id="439e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是在以下Python代码中捕获的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6c85" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mr ms mt mu b">filter_()</code>函数应该返回一组可供遍历的节点。这对于寻找字谜有一些细微的差别。我们一会儿会谈到这个问题，暂时先不要定义过滤函数。</p><p id="a187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们仍然没有完成变位算法的实现。</p><p id="dd96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mr ms mt mu b">walks()</code>产生遍历所访问的节点元组——在这种情况下是短语中的字符——但是遍历一到达单词的末尾就结束了。</p><p id="6ee3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要产生多词变位词，你需要绕圈子，继续从树根开始遍历这棵树。我称之为“绕着树走”。你不停地走来走去，收集单词，直到走完为止。</p><p id="374c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="dec3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要实现<code class="fe mr ms mt mu b">done</code>和<code class="fe mr ms mt mu b">filter</code>函数来传递给<code class="fe mr ms mt mu b">walk_around()</code>，这两个函数都依赖于我们正在为其生成变位词的短语。</p><p id="c1fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当遍历中访问的字符串是短语的变位词时，遍历完成。我们已经知道怎么做了！我们可以使用<code class="fe mr ms mt mu b">are_anagrams()</code>功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1f3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要定义<code class="fe mr ms mt mu b">filter_()</code>。</p><p id="8c15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我说过这里有一些细微的差别。</p><p id="1e5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在行走的每一步，我们只需要移动到我们还没有访问过的短语中的一个字符。或者一个标点符号，因为我们想要包含像缩写这样的词。哦，我们也可以移动到一个<code class="fe mr ms mt mu b">" "</code>字符，因为这是我们如何知道我们在一个单词的末尾。</p><p id="685c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用<a class="ae mv" href="https://docs.python.org/3/library/stdtypes.html#set" rel="noopener ugc nofollow" target="_blank">集合</a>清晰地表达这些规则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e172" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mr ms mt mu b">Counter</code>便于计算短语中尚未访问过的字符。</p><p id="7505" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从另一个中减去一个<code class="fe mr ms mt mu b">Counter</code>会返回一个减去了计数的<code class="fe mr ms mt mu b">Counter</code>。计数为零的字符将被删除。例如，<code class="fe mr ms mt mu b">Counter("tea") - Counter("e")</code>返回<code class="fe mr ms mt mu b">Counter({'t': 1, 'a': 1})</code>。</p><p id="9ec8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经具备了编写变位词生成器的所有要素:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b707" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里使用<code class="fe mr ms mt mu b">functools.partial()</code>来“填充”<code class="fe mr ms mt mu b">done()</code>和<code class="fe mr ms mt mu b">filter_()</code>功能的<code class="fe mr ms mt mu b">phrase</code>参数。我们必须这样做，因为<code class="fe mr ms mt mu b">walk_around()</code>的<code class="fe mr ms mt mu b">done</code>和<code class="fe mr ms mt mu b">filter_</code>参数期望没有<code class="fe mr ms mt mu b">phrase</code>参数的函数。因为<code class="fe mr ms mt mu b">walk_around()</code>产生的遍历以空格结束，所以用<code class="fe mr ms mt mu b">.rstrip()</code>去除了变位词中的空格。</p><p id="1199" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们带着<code class="fe mr ms mt mu b">anagrams()</code>在一个小单词列表上兜一圈:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3d82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嘿，成功了！</p><h2 id="806d" class="my lv it bd lw mz na dn ma nb nc dp me lh nd ne mg ll nf ng mi lp nh ni mk nj bi translated">对大量单词进行测试</h2><p id="c2a9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果你的电脑有一个类似Unix的操作系统，你现在有一个很大的单词列表。</p><p id="996a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在大多数机器上，有一个位于<code class="fe mr ms mt mu b">/usr/share/dict/words</code>或<code class="fe mr ms mt mu b">/usr/dict/words</code>的<code class="fe mr ms mt mu b">words</code>文件。这是一个用换行符分隔的字典单词列表。如果你有一台Windows机器或者没有一个<code class="fe mr ms mt mu b">words</code>文件，你可以在GNU网站上找到一个用你的语言写的<a class="ae mv" href="http://ftp.gnu.org/gnu/aspell/dict/" rel="noopener ugc nofollow" target="_blank">文件。</a></p><p id="3fd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们试一试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="81e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以工作，但是<code class="fe mr ms mt mu b">words</code>文件包含单个字母和两个字母的单词，比如“te”这给我们的字谜增加了一堆噪音。我们应该清理一下。</p><p id="170c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们过滤掉一些我们知道我们不想要的单词:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c3c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这无疑给了我们更好的结果。对于一个更好的变位词生成器，你需要花一些时间来整理单词。并且<code class="fe mr ms mt mu b">words</code>文件不一定是最好的单词集，因为它不包含任何缩写。</p><p id="69ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以使用aspell的<a class="ae mv" href="http://app.aspell.net/create" rel="noopener ugc nofollow" target="_blank">皱眉工具</a>生成更有趣的单词列表。</p><h1 id="d2fd" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">那么这一切有什么意义呢？</h1><p id="5b43" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">首先，这是一个有趣的项目，涉及了一些我在日常生活中不会用到的概念。仅此一点就值得了。</p><p id="0660" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是解决方案本身总的来说还是很有趣的。它提出了一种用组合约束构造对象的方法。人们可以想象它的许多应用，从构建代码和遗传序列到寻找组合问题的极值解。</p><p id="aadd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个周末项目来说还不错！</p><pre class="kj kk kl km gt nk mu nl nm aw nn bi"><span id="a041" class="my lv it mu b gy no np l nq nr"><strong class="mu iu">Become a better coder in 5 minutes.</strong></span><span id="aee8" class="my lv it mu b gy oj np l nq nr">One email, every Saturday, with one actionable tip.<br/>Always less than 5 minutes of your time.</span><span id="3460" class="my lv it mu b gy oj np l nq nr"><a class="ae mv" href="https://davidamos.dev/curious-about-code-newsletter/" rel="noopener ugc nofollow" target="_blank">Subscribe here</a></span></pre></div></div>    
</body>
</html>