<html>
<head>
<title>Explaining SQL Joins the Right Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正确解释SQL连接</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/explain-sql-joins-the-right-way-f6ea784b568b#2022-08-17">https://towardsdatascience.com/explain-sql-joins-the-right-way-f6ea784b568b#2022-08-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/23884421093cfe59d8a4063c5e543dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Unm6qo_lCw5mtGG4yzeHvA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">(作者供图)</p></figure><p id="737e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文从需要向人们介绍数据库中连接概念的人的角度出发，例如<code class="fe ld le lf lg b">LEFT JOIN</code>。这可以是高级分析师角色、数据科学家或实际的教师和导师。这在实践层面上结合了数据和教育科学。</p><p id="352e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在讲授SQL中的连接时，您可能会使用或看到维恩图——只需<a class="ae lh" href="https://duckduckgo.com/?q=SQL+JOINS&amp;iax=images&amp;ia=images" rel="noopener ugc nofollow" target="_blank">图片搜索连接SQL </a>，它们就随处可见。但是维恩图是错误的<a class="ae lh" href="https://userpages.umbc.edu/~norcio/papers/1993/Staggers-MM-IJMMS.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="li">心智模型</em></a><em class="li"/>【1】！心理模型是一个有用的概念，它将学习描述为外部事件的内部建模——有点像机器学习，但结果集成在一个完整的模型网络中，帮助人类预测和生存其社会和物理环境[7]。</p><p id="e697" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用维恩来解释连接，大脑将它们建模为<em class="li">集合运算</em>(像<code class="fe ld le lf lg b">UNION</code>)，并将对它们的结果做出错误的预测。因此，结果不像预期的那样，导致沮丧和与<code class="fe ld le lf lg b">SELECT DISTINCT</code>的可疑的解决办法。</p><p id="f775" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我想展示一下</p><ul class=""><li id="8bc1" class="lj lk it kh b ki kj km kn kq ll ku lm ky ln lc lo lp lq lr bi translated">维恩图适用于集合运算，如并集等。—不适用于连接</li><li id="f94a" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">连接是组合运算，所以我们需要这样教它们。即<code class="fe ld le lf lg b">A CROSS JOIN B</code>是来自A的所有元素与来自B的所有元素的组合</li><li id="1c9b" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated">所有的连接都是某种(过滤的)交叉连接——所以我们可以从交叉连接开始介绍连接，并从那里继续深入。</li></ul><h1 id="8875" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">垂直运算:集合代数与并集</h1><p id="fa74" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">但是首先，为什么要比较Join和Union呢？因为维恩图是SQL中<code class="fe ld le lf lg b">UNION</code>等集合运算的<em class="li">正确心智模型</em>！它们甚至以相似的方式命名:</p><ul class=""><li id="a077" class="lj lk it kh b ki kj km kn kq ll ku lm ky ln lc lo lp lq lr bi translated"><code class="fe ld le lf lg b">A UNION DISTINCT B</code> = <em class="li"> A ⋃ B </em>:“碗运算符”将集合a和b组合成一个具有不同元素的集合(或“碗”)。</li></ul><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi na"><img src="../Images/d200a55046046b78c618f04e864b8c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*zqbs-cVdQmLtL0Lt98jsTA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">集合联合(图片由作者提供)</p></figure><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7a9a43233660a06af8cfa6997aea33ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*-miAVfoZC7f50oIyeK34bw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在表格中设置联合(作者图片)</p></figure><p id="40a2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">a⋂b:“cookie cutter”操作符只保留两个集合中的元素。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a73a216b421888d334e73cc4e97305a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*J-ga-Iit7bvXgtUytV38Yg.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">设置交叉点(图片由作者提供)</p></figure><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2d0bb4e697de3cb3f5dd061202e17b7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*_tsyyxwIQPyWtzG0Za5hag.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在表格中设置交叉点(图片由作者提供)</p></figure><p id="38fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe ld le lf lg b">A EXCEPT B</code> = <em class="li"> A \ B </em>:用“铲运算符”从A中减去所有B元素，得到一个精简的集合A(如果它们共享任何元素的话)。</p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/28739bc9fc1bc55ef66a6ac0078a07aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*Ma_SJmLy6k_e-e-vUC_Ksw.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">设置减法(图片由作者提供)</p></figure><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/04996b5ee84d3f25838d572325acabd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*GdEo7AFJmqiI7t_Y-BjmBA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">在表格中设置减法(图片由作者提供)</p></figure><p id="10ab" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">由于表不是真正的集合，我们也有像UNION ALL这样的构造，其中记录/元素允许出现不止一次。</p><p id="d236" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">SQL中的一个<em class="li">集合</em>是一个表，其中<em class="li">元素是行</em>，所以我们要把<em class="li">想成垂直</em>。</p><p id="3d9d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是<code class="fe ld le lf lg b">JOIN</code>被解释为<em class="li">好像列是元素</em>——因为我们<code class="fe ld le lf lg b">join</code>列。<code class="fe ld le lf lg b">Joins</code>是<strong class="kh iu"><em class="li"/></strong><em class="li"/>和<em class="li">给一个元素添加属性</em>。他们不会添加新元素，但是<em class="li">会将新属性</em>关联到现有的集合——这将创建一个全新的集合，其中包含从原始表中创建的新元素。</p><p id="6296" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还是那句话:不是加法，是联想。新元素是通过关联新属性(列)产生的，而不是通过添加另一个集合中的元素(行)产生的。</p><p id="42f4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这比集合运算更接近矩阵乘法。</p><p id="33e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">"<em class="li"> joins的<em class="li">心智模型</em>是集合运算"</em>，维恩图很容易将它们可视化:例如，如果任一表中的键不是惟一的，您可以使用<code class="fe ld le lf lg b">LEFT JOIN</code>创建新行。这是主键/外键思想中的标准情况:外键不应该是惟一的。</p><p id="cc91" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从右表<em class="li">的角度来看，在具有主键的<code class="fe ld le lf lg b">left join</code>中，元素<strong class="kh iu">的数量减少了左表中缺少主键的数量</strong>，因为我们只连接左表中存在的东西。所以右边的表丢失了元素。</em></p><figure class="nb nc nd ne gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/527c50d9605632714a2d111af3e0afa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*H-lrNY1GsRWhDjjuWnA1OA.png"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">当A左连接B时，A从关联中获得行，但是B丢失了不能关联的行(图片由作者提供)</p></figure><p id="6ef3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">但是从左边<em class="li">表</em>的角度来看，元素的数量<strong class="kh iu">增加了</strong>外键倍数的数量，因为我们必须连接右边表中的所有信息，而不仅仅是一个键的第一次出现。因此左边的表根据新组合的数量增加元素。</p><p id="f939" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">维恩图没有传达这些想法，这很糟糕，因为它非常重要——它改变了结果表的形状，从而改变了我们对它们进行的任何聚合。</p><p id="744c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您查看了一些初级同事的SQL，您可能会看到有人试图在奇怪的地方使用DISTINCT来修复连接问题，以消除最终输出表中不需要的重复项。但是这可能会改变含义，从而改变对聚合和分析的解释。对转换数据的错误解释会让公司损失惨重。</p><p id="f774" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">那么对于连接，什么是更好的心理模型呢？</p><h1 id="6cb6" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">备选方案:<em class="nl">带JOIN的组合学</em></h1><p id="49a1" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">从技术上讲，连接是创建新集合的元组操作(<a class="ae lh" href="https://en.wikipedia.org/wiki/Relational_algebra#Joins_and_join-like_operators" rel="noopener ugc nofollow" target="_blank">元组组合学</a> [2】)。维恩图给人的印象是集合大小保持不变，而实际上<code class="fe ld le lf lg b">joins</code>并没有给你对集合的控制，而是通过创建一个具有所需组合的新集合来控制记录的组合。</p><p id="a660" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要根据<em class="li">组合学</em>，<strong class="kh iu">而不是</strong>集合代数来思考。</p><h2 id="be85" class="nm ly it bd lz nn no dn md np nq dp mh kq nr ns ml ku nt nu mp ky nv nw mt nx bi translated">交叉连接</h2><p id="b5c4" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">在交叉连接中，我们将一个表中的每一行与另一个表中的每一行结合起来。这个概念非常容易理解，因为它将一切与一切结合起来——非常直观。结果表大小是各个表大小的乘积。</p><p id="69ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们在更高级的连接中使用这种直觉…</p><h2 id="3ffb" class="nm ly it bd lz nn no dn md np nq dp mh kq nr ns ml ku nt nu mp ky nv nw mt nx bi translated">条件连接</h2><p id="eff5" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">当使用一个需要匹配的键时，我们可以把那个<strong class="kh iu">键</strong>想象成<strong class="kh iu">定义了</strong>一个<strong class="kh iu">子域</strong> <em class="li">，我们在其中交叉连接</em>。</p><p id="a9a1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以一个简单的键为例:在表A和表B中找到带有某个值x_1 的键的每个实例——交叉连接它们！对键的下一个值<em class="li"> x_2 </em>重复，依此类推…</p><p id="aa74" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种连接只告诉我们如何处理<em class="li">不匹配</em>的元素:</p><ul class=""><li id="0a06" class="lj lk it kh b ki kj km kn kq ll ku lm ky ln lc lo lp lq lr bi translated"><code class="fe ld le lf lg b">INNER</code>:丢弃任何一方导致<code class="fe ld le lf lg b">NULL</code>的东西——但是在<code class="fe ld le lf lg b">ON</code>定义的子域内进行交叉连接。</li><li id="2f00" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><code class="fe ld le lf lg b">LEFT</code>:只在左侧表格中找到的子域内进行交叉连接。</li><li id="407a" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><code class="fe ld le lf lg b">RIGHT</code>:仅在右侧表格中找到的子域内进行交叉连接。</li><li id="c613" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc lo lp lq lr bi translated"><code class="fe ld le lf lg b">FULL OUTER</code>:在任一表格中找到的子域内进行交叉连接。有点像<code class="fe ld le lf lg b">INNER</code>，但保留<code class="fe ld le lf lg b">NULLs</code>。</li></ul><h2 id="e52e" class="nm ly it bd lz nn no dn md np nq dp mh kq nr ns ml ku nt nu mp ky nv nw mt nx bi translated">例子</h2><p id="7fb7" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">让我们看一些代码。用匹配和非匹配键建立一些简单的表，并用子域中新的<em class="li">交叉连接思想解释它。</em></p><p id="7d32" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你现在可以使用<a class="ae lh" href="https://db-fiddle.com" rel="noopener ugc nofollow" target="_blank">db-fiddle.com</a>或者类似的东西来尝试(复制/粘贴)。</p><pre class="nb nc nd ne gt ny lg nz oa aw ob bi"><span id="7ac0" class="nm ly it lg b gy oc od l oe of">/* Schema SQL, */<br/>/* prepare tables and add some data */<br/>CREATE TABLE A (<br/>  id INT,<br/>  val VARCHAR<br/>);<br/>CREATE TABLE B (<br/>  id INT,<br/>  val VARCHAR<br/>);<br/>INSERT INTO A (id, val) VALUES (1, 'xxx');<br/>INSERT INTO A (id, val) VALUES (2, 'def');<br/>INSERT INTO A (id, val) VALUES (4, 'ghi');</span><span id="dba4" class="nm ly it lg b gy og od l oe of">INSERT INTO B (id, val) VALUES (1, 'xxx');<br/>INSERT INTO B (id, val) VALUES (1, 'zzz');<br/>INSERT INTO B (id, val) VALUES (2, 'aaa');<br/>INSERT INTO B (id, val) VALUES (3, 'bbb');</span></pre><p id="e74f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在是一些简短的查询:</p><pre class="nb nc nd ne gt ny lg nz oa aw ob bi"><span id="8f30" class="nm ly it lg b gy oc od l oe of">SELECT * FROM A; /* Query 1: table A */<br/>SELECT * FROM B; /* Query 2: table B */</span><span id="feb8" class="nm ly it lg b gy og od l oe of">/* Query #3: cross join without subdomains */<br/>SELECT * FROM A <strong class="lg iu">CROSS JOIN</strong> B;</span><span id="8e72" class="nm ly it lg b gy og od l oe of">/* Query #4: A left join B <br/> * = cross join within subdomain id found in A:<br/> * There's no id 3 because it doesn't exist in A! <br/> * <br/> * We have two id=1 because they're both in B <br/> * and two id=2 because they're both in A.<br/> * Sub-domain cross-join in action!<br/> */<br/>SELECT * FROM A <strong class="lg iu">LEFT JOIN</strong> B ON A.id=B.id;</span><span id="3211" class="nm ly it lg b gy og od l oe of">/* Query #5: cross join within subdomain id found in B: no id 4! */<br/>SELECT * FROM A <strong class="lg iu">RIGHT JOIN</strong> B ON A.id=B.id;</span><span id="ffde" class="nm ly it lg b gy og od l oe of">/* Query #6: cross join within subdomain id found in A or B: all ids! */<br/>SELECT * FROM A <strong class="lg iu">FULL OUTER JOIN</strong> B ON A.id=B.id;</span><span id="de7e" class="nm ly it lg b gy og od l oe of">/* Query #7: cross join within subdomain id found in A or B: <br/> * All ids that have a matching partner in the other table! <br/> * So don't keep NULL rows!<br/> */<br/>SELECT * FROM A <strong class="lg iu">INNER JOIN</strong> B ON A.id=B.id;</span></pre><p id="d690" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">特别是<code class="fe ld le lf lg b">inner join</code>表明我们正在进行子域交叉连接。将其与<code class="fe ld le lf lg b">INTERSECT</code>进行比较，后者是一个真实的设置操作:</p><pre class="nb nc nd ne gt ny lg nz oa aw ob bi"><span id="549d" class="nm ly it lg b gy oc od l oe of">SELECT * FROM A <strong class="lg iu">INTERSECT</strong> SELECT * FROM B;</span></pre><p id="48d8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们只得到在两个集合/表格中匹配的一个集合元素，而由于组合学的原因，<code class="fe ld le lf lg b">inner join</code>返回doubles。</p><h2 id="7773" class="nm ly it bd lz nn no dn md np nq dp mh kq nr ns ml ku nt nu mp ky nv nw mt nx bi translated">关键场景</h2><p id="a14f" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">在理想的主键/外键场景中，我们是安全的:我们只向表中加入唯一的信息，并且大小不会改变。但是这个用例是有欺骗性的——它只显示了查询引擎实际在做什么的边缘情况。如果查询引擎是围绕这个用例构建的，那么当右边的键不是惟一的或者左边没有主键时，左连接应该会给我们一个警告。但是他们通常不关心——而且CTE和子查询没有任何主键，也不可能实现。</p><p id="c606" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果您从集合的角度考虑，并期望A中的行数+B中的一定数量的行(匹配id ),但是您的连接组合学突然创建了一个奇怪的意外行数和id重复数，您无法解释，这很快就会令人沮丧。</p><h1 id="2055" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="568d" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">我们需要教授正确的心智模型，这样让人们从电子表格世界进入数据库世界(变得越来越有用)就更容易了。</p><p id="b6cd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当解释连接时，用组合学的术语来说，避免维恩图，不惜一切代价使用代数术语。按以下顺序引入联接:</p><ol class=""><li id="2bc5" class="lj lk it kh b ki kj km kn kq ll ku lm ky ln lc oh lp lq lr bi translated">交叉连接，因为我们还没有键，而且“把所有的东西和所有的东西结合起来”是很容易理解的。</li><li id="8eeb" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc oh lp lq lr bi translated">内部连接，因为它类似于交叉连接，但是通过我们连接的键引入了子域。不匹配的案例会被直接删除。</li><li id="29a5" class="lj lk it kh b ki ls km lt kq lu ku lv ky lw lc oh lp lq lr bi translated">左/右/外连接，因为它增加了对不匹配情况的控制，我们希望保留前面介绍的概念。</li></ol><p id="c20d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">总的来说:为了避免指令错误，确保你用类似于<a class="ae lh" href="https://blog.cathy-moore.com/2013/05/is-training-really-the-answer-ask-the-flowchart/" rel="noopener ugc nofollow" target="_blank">动作映射</a> [3]的东西开始课程规划。对于评估，使用<a class="ae lh" href="https://mi.mcmaster.ca/learning-portfolio/" rel="noopener ugc nofollow" target="_blank">学习文件夹</a>，或者——如果你被迫给人打分——使用并分享事先制定的带有<a class="ae lh" href="https://www.johnbiggs.com.au/academic/constructive-alignment/" rel="noopener ugc nofollow" target="_blank">建设性一致性</a>的标准【4】。对于更复杂的课程，使用<a class="ae lh" href="https://www.4cid.org/publications/" rel="noopener ugc nofollow" target="_blank"> 4CID </a> [5]。为了发展实际的学习经验，使用来自<a class="ae lh" href="https://hbr.org/2007/07/the-making-of-an-expert" rel="noopener ugc nofollow" target="_blank">爱立信</a>【6】和<a class="ae lh" href="https://www.google.com/books/edition/_/zpp9zQEACAAJ?hl=en" rel="noopener ugc nofollow" target="_blank">德阿纳</a>【7】的见解。</p><h1 id="4d29" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">参考</h1><p id="f529" class="pw-post-body-paragraph kf kg it kh b ki mv kk kl km mw ko kp kq mx ks kt ku my kw kx ky mz la lb lc im bi translated">[1] N. Staggers，A. F. Norcio，心智模型:人机交互研究的概念(1993)，Int。人机研究</p><p id="156c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[2]连接和类连接运算符。维基百科(2022)。URL:<a class="ae lh" href="https://en.wikipedia.org/wiki/Relational_algebra#Joins_and_join-like_operators" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Relational _ algebra # Joins _ and _ join-like _ operators</a></p><p id="f530" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[3] C .摩尔，训练真的是答案吗？问流程图。(2013)，网址:<a class="ae lh" href="https://blog.cathy-moore.com/2013/05/is-training-really-the-answer-ask-the-flowchart/" rel="noopener ugc nofollow" target="_blank">https://blog . cathy-Moore . com/2013/05/is-training-true-the-answer-ask-the-flow trade/</a></p><p id="9b8f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[4] J. Biggs，Constructive Alignment(无日期)，网址:<a class="ae lh" href="https://www.johnbiggs.com.au/academic/constructive-alignment/" rel="noopener ugc nofollow" target="_blank">https://www . John Biggs . com . au/academic/Constructive-Alignment/</a></p><p id="75a1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[5] J.J.G .范·梅林波尔，《四要素教学设计模式:其主要设计原则概述》(2019年)网址:<a class="ae lh" href="https://www.4cid.org/publications/" rel="noopener ugc nofollow" target="_blank">https://www.4cid.org/publications/</a></p><p id="a683" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[6] K. A .埃里克森、M. J .普列图拉和E. T .科克里，《专家的形成》。(2007年)网址:<a class="ae lh" href="https://hbr.org/2007/07/the-making-of-an-expert" rel="noopener ugc nofollow" target="_blank">https://hbr.org/2007/07/the-making-of-an-expert</a></p><p id="16e8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">[7]s·德阿纳《我们如何学习》。教育和大脑的新科学。(2021)爱尔兰:企鹅图书有限公司</p></div></div>    
</body>
</html>