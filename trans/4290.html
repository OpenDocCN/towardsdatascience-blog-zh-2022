<html>
<head>
<title>Commonly Asked Interview Question: Where vs Having vs Qualify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的面试问题:vs在哪里有资格</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/commonly-asked-interview-question-where-vs-having-vs-qualify-1445a1d15902#2022-09-22">https://towardsdatascience.com/commonly-asked-interview-question-where-vs-having-vs-qualify-1445a1d15902#2022-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9888" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基础知识回归| SQL初学者基础知识</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8062f9010cae8faa59690bd2c5e8f8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKGxXTF3pa_NMKR4hNoAvQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片，创建于<a class="ae kv" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> canva </a></p></figure><p id="09d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是否曾经被分配了一个分析新数据集的任务，但你不知道从哪里开始？当我第一次作为商业智能顾问开始处理数据时，我也遇到过同样的情况。开始处理包含数百万条您不熟悉的记录的数据有时会让人不知所措。</p><p id="a2c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，从较小的数据块开始并向前推进始终是一种最佳实践(是的！数据分析101)。首先选择一个子集，如部门、产品或位置，然后转移到更大的数据子集。</p><p id="924d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相信我，知道如何有效地检索企业数据是一项需要磨练的关键技能，因为它会进一步放大数据的价值；不仅仅是日常的商业任务，从面试的角度来看也是如此，因为这是我到目前为止遇到的最常见的面试问题。</p><p id="2bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是大多数SQL风格中最常用的数据过滤子句的快速指南。<em class="ls">其中</em>、<em class="ls">有</em>和<em class="ls">有</em>均用于基于条件表达式过滤查询结果集，但用例不同。</p><p id="d185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在用<a class="ae kv" href="https://www.mysqltutorial.org/mysql-sample-database.aspx" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">classic models</strong></a>MySQL样本数据库进行演示；它保存汽车零售商的业务数据。下面是ER图，以便快速理解，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/c8eecf27187711291ef0341d63121b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WokfDeDulO1ZT5YvSO28Gw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="9203" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">其中</em> </strong></p><ul class=""><li id="0700" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><em class="ls">其中</em>是根据条件表达式过滤出结果集的最常用子句。</li><li id="ec80" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated">通过子句可以使用/不使用<em class="ls">组。一起使用时，<em class="ls"> GROUP BY </em>子句总是跟在<em class="ls"> WHERE </em>子句后面。</em></li></ul><p id="b02b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是来自<em class="ls">产品</em>表的样本数据，</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="c9bb" class="mn mo iq mj b gy mp mq l mr ms">SELECT * FROM CLASSICMODELS.PRODUCTS LIMIT 10;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/23188c9fd4aa1a795c7c21d2c53b73ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8RU6xXMIUEHAmN4zrI9zQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b46e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比方说，我们想要按每条产品线分组的<em class="ls">产品线</em> <em class="ls">老爷车、老爷车</em>和<em class="ls">摩托车、</em>的当前总库存数量信息。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="22e4" class="mn mo iq mj b gy mp mq l mr ms">#where clause example</span><span id="4ec5" class="mn mo iq mj b gy mu mq l mr ms">SELECT<br/>    PRODUCTLINE,<br/>    SUM(QUANTITYINSTOCK) AS TOTAL_QUANTITY<br/>FROM <br/>    CLASSICMODELS.PRODUCTS<br/>WHERE PRODUCTLINE IN ('Classic Cars', 'Vintage Cars', 'Motorcycles')<br/>GROUP BY PRODUCTLINE;</span></pre><p id="dc75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的查询将返回以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/2749e1c3113bdce285f2bbf3071676ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*1Y_SVk__hTdy_kziMFisBw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b83c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">拥有</em> </strong></p><ul class=""><li id="0fad" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><em class="ls"> HAVING </em>类似于<em class="ls"> WHERE </em>子句，不同之处在于它用于使用任何集合函数的过滤条件，并涉及作为过滤条件/表达式的<em class="ls"> GROUP BY </em>子句。</li><li id="f796" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><em class="ls"> GROUP BY </em>先于<em class="ls"> HAVING </em>子句。(具有子句的<em class="ls">总是用在由</em>子句分组的<em class="ls">之后)</em></li><li id="76c1" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated">当在查询中使用HAVING子句时，只有满足条件表达式的组才会出现在输出中。</li></ul><p id="7f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续上一个示例，我们进一步希望将结果集过滤到总量超过100000的<em class="ls">产品系列</em>,</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="3d32" class="mn mo iq mj b gy mp mq l mr ms">#having clause example</span><span id="c2b3" class="mn mo iq mj b gy mu mq l mr ms">SELECT<br/>    PRODUCTLINE,<br/>    SUM(QUANTITYINSTOCK) AS TOTAL_QUANTITY<br/>FROM <br/>    CLASSICMODELS.PRODUCTS<br/>WHERE PRODUCTLINE IN ('Classic Cars', 'Vintage Cars', 'Motorcycles')<br/>GROUP BY PRODUCTLINE<br/>HAVING TOTAL_QUANTITY &gt; 100000;</span></pre><p id="efc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该查询将返回以下输出，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/32e78f80416c8b3ba39f7d9e9ec86aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*GdlYtsQ80WFBPZAeHTfeNQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="a400" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> WHERE </em>和<em class="ls">有</em>子句的一些关键区别，</p><ul class=""><li id="7dff" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated">语法方面的<em class="ls">，其中</em>子句在<em class="ls"> GROUP BY </em>子句之前，这意味着它将在执行聚合计算之前基于条件表达式过滤行。<br/>而在语法上，具有子句的<em class="ls">位于<em class="ls"> GROUP BY </em>子句之后，因此它将在执行聚合计算后过滤行。从性能优化的角度来看，具有</em>子句的<em class="ls">比<em class="ls">慢，在<em class="ls">中，应尽可能避免</em>。</em></em></li><li id="3126" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated">当两者一起使用时，<em class="ls"> WHERE </em>子句将首先过滤单个行，然后将这些行分组，执行聚合计算，最后将使用<em class="ls"> HAVING </em>子句过滤组。</li><li id="5563" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><em class="ls">其中</em>子句可用于所有DML命令，而具有的<em class="ls">只能用于SELECT语句。</em></li></ul><p id="07df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">晋级</em> </strong></p><ul class=""><li id="6bd4" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><em class="ls">限定</em>用于过滤表达式根据用户指定的条件使用任何分析/窗口函数的情况。</li></ul><p id="96bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续<em class="ls">产品线</em>的例子，之前我们查询了产品线<em class="ls">老爷车、老爷车</em>和<em class="ls">摩托车的当前库存产品总量。</em>现在，我们来看看产品线中库存数量最高的前3种产品。由于MySQL不支持<em class="ls"> QUALIFY </em>子句，请尝试在其他支持的SQL环境中运行下面的查询。</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="6df6" class="mn mo iq mj b gy mp mq l mr ms">#qualify clause example<br/>SELECT <br/>    PRODUCTLINE,<br/>    PRODUCTNAME,<br/>    QUANTITYINSTOCK,<br/>    ROW_NUMBER() OVER (PARTITION BY PRODUCTLINE ORDER BY   QUANTITYINSTOCK DESC) AS ROW_NUM<br/>FROM <br/>    CLASSICMODELS.PRODUCTS<br/>WHERE PRODUCTLINE IN ('Classic Cars', 'Vintage Cars', 'Motorcycles') <br/>QUALIFY ROW_NUM &lt;= 3;</span></pre><p id="2b0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的查询将返回，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/9b0e436a13e2cf5176554b9b60c21802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bRZ20xW7xlYRrsnQ_iqGmA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b9d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用嵌套查询可以得到相同的结果，</p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="f818" class="mn mo iq mj b gy mp mq l mr ms">#qualify clause work-around using nested query<br/>SELECT <br/>    PRODUCTLINE,<br/>    PRODUCTNAME,<br/>    QUANTITYINSTOCK,<br/>    ROW_NUM<br/>FROM <br/>   (<br/>    SELECT<br/>        PRODUCTLINE,<br/>        PRODUCTNAME,<br/>        QUANTITYINSTOCK,<br/>        ROW_NUMBER() OVER (PARTITION BY PRODUCTLINE ORDER BY QUANTITYINSTOCK DESC) AS ROW_NUM<br/>    FROM <br/>       CLASSICMODELS.PRODUCTS<br/>    WHERE PRODUCTLINE IN ('Classic Cars','Vintage Cars','Motorcycles')<br/>   )SUBQ<br/>WHERE SUBQ.ROW_NUM &lt;= 3;</span></pre><p id="42d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还是我个人的最爱；使用<a class="ae kv" href="https://dev.mysql.com/doc/refman/8.0/en/with.html" rel="noopener ugc nofollow" target="_blank"><em class="ls">【CTE(常用表表达式)</em></a><em class="ls"/></p><pre class="kg kh ki kj gt mi mj mk ml aw mm bi"><span id="4ecc" class="mn mo iq mj b gy mp mq l mr ms">#qualify clause work-around using cte<br/>WITH STOCK_RANKING<br/>AS<br/> (<br/>  SELECT<br/>      PRODUCTLINE,<br/>      PRODUCTNAME,<br/>      QUANTITYINSTOCK,<br/>      ROW_NUMBER() OVER (PARTITION BY PRODUCTLINE ORDER BY QUANTITYINSTOCK DESC) AS ROW_NUM<br/> FROM <br/>      CLASSICMODELS.PRODUCTS<br/> WHERE PRODUCTLINE IN ('Classic Cars','Vintage Cars','Motorcycles')<br/> )<br/>   <br/>SELECT <br/>   PRODUCTLINE,<br/>   PRODUCTNAME,<br/>   QUANTITYINSTOCK,<br/>   ROW_NUM<br/>FROM <br/>   STOCK_RANKING<br/>WHERE ROW_NUM &lt;= 3;</span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="297b" class="nf mo iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">结论</h1><p id="f684" class="pw-post-body-paragraph kw kx iq ky b kz nw jr lb lc nx ju le lf ny lh li lj nz ll lm ln oa lp lq lr ij bi translated">出于上述原因，我个人尽量避免使用带有子句的<em class="ls">。我通常会创建一个临时的或中间的表，在那里获取数据的子集，然后在另一个查询中使用；为了<em class="ls">的可读性</em>和<em class="ls">的复用性</em>。总而言之，如果它是针对您的业务案例的性能优化解决方案，了解这些条款并使用它总是值得的。</em></p><p id="1d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一些有用的资源，</p><ul class=""><li id="5c37" class="lu lv iq ky b kz la lc ld lf lw lj lx ln ly lr lz ma mb mc bi translated"><a class="ae kv" href="https://www.mysqltutorial.org/mysql-where/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">其中</em> </a>从句</li><li id="3742" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><a class="ae kv" href="https://www.mysqltutorial.org/mysql-having.aspx" rel="noopener ugc nofollow" target="_blank"> <em class="ls">拥有</em> </a>条款</li><li id="bb09" class="lu lv iq ky b kz md lc me lf mf lj mg ln mh lr lz ma mb mc bi translated"><a class="ae kv" href="https://docs.teradata.com/r/2_MC9vCtAJRlKle2Rpb0mA/1z5LI8ycTW55f53vLJ0WjQ" rel="noopener ugc nofollow" target="_blank"> <em class="ls">限定</em> </a>子句</li></ul><p id="0249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快乐学习！</p></div></div>    
</body>
</html>