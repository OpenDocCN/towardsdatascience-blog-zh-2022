<html>
<head>
<title>Build a Blog Website Using Django Rest Framework — Users App (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Django Rest 框架——用户应用程序构建一个博客网站(第 2 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-part-2-be9bc353abf3#2022-12-15">https://towardsdatascience.com/build-a-blog-website-using-django-rest-framework-part-2-be9bc353abf3#2022-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bda" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在第二部分中，我们将处理构建用户相关的模型和视图，并将测试用户相关的 API。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac5a2aa7ea62a64be976393a9bd67efb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j3PaHQamOhNdiZC6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/fr/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d73d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大家好，我希望你们都过得很好，并且喜欢这个 DRF 文章系列的第一部分。在本系列的第一部分中，我们处理了设置这个项目的基础，并且您已经对我们将要构建的项目有了一个大致的了解。</p><p id="580e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有读第一部分，我建议你先去读一读，然后再回到这一部分。以下是该系列的第一部分:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/build-a-blog-website-using-django-rest-framework-overview-part-1-1f847d53753f"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用 Django Rest 框架构建博客网站——概述(第 1 部分)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">让我们使用 Django Rest 框架构建一个简单的博客网站，了解 DRF 和 REST APIs 如何工作，以及我们如何添加…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="50be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个系列的第二部分，我们将处理完整的<code class="fe mn mo mp mq b">users</code>应用程序，然后，在第三部分，我们将完成<code class="fe mn mo mp mq b">posts</code>应用程序来完成这个网站的后端。</p><blockquote class="mr ms mt"><p id="c30e" class="kz la mu lb b lc ld ju le lf lg jx lh mv lj lk ll mw ln lo lp mx lr ls lt lu im bi translated"><strong class="lb iu">更新:</strong>当我第一次写这篇文章的时候，我并没有在第二部分中包含一个合适的认证系统。仅支持注册用户和查看所有用户，但如果我们想与前端连接，这是不够的。由于我们想为我们的后端应用程序建立一个工作前端，我们想提供一个登录功能，因为我们不能使用可浏览的 API 登录按钮登录时，我们使用前端。</p><p id="c4ed" class="kz la mu lb b lc ld ju le lf lg jx lh mv lj lk ll mw ln lo lp mx lr ls lt lu im bi translated">因此，我在本文的一个单独的部分中添加了应用程序所需的完整身份验证，显示了为了使它工作，我们需要做的所有必要的更改。所以，我没有在中间做改动，因为我觉得最好在一个单独的部分做，因为我们只会添加一些东西来增加所需的功能。</p></blockquote><p id="5d6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将看到如何在构建 API 的同时测试它们，并且我们将使用 Django Rest 框架提供的可浏览 API 接口来完成这项工作。</p><p id="2bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个超级用户来访问 Django 应用程序的管理面板。为此，我们将在终端中使用以下命令:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="b726" class="nc nd it mq b be ne nf l ng nh">python manage.py createsuperuser</span></pre><p id="19ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它会询问您的用户名、电子邮件和密码。在您输入所有这些细节之后，它将使用这些凭证创建一个超级用户。您可以使用这些详细信息登录到应用程序，以便能够完全访问网站上的所有功能，还可以访问管理面板。</p><p id="3c76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，现在让我们进入<code class="fe mn mo mp mq b">users</code>应用程序。我们可以看到这个文件夹里面已经创建了很多文件，比如<code class="fe mn mo mp mq b">models.py</code>、<code class="fe mn mo mp mq b">views.py</code>、<code class="fe mn mo mp mq b">admin.py</code>等。</p><p id="c01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，由于我们将使用默认的 Django 用户模型，而不是创建任何定制的用户模型或用户配置文件，因此我们不会在<code class="fe mn mo mp mq b"> models.py</code>文件中写任何东西。</p><p id="e7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将首先编写序列化程序。创建一个名为<code class="fe mn mo mp mq b">serializers.py</code>的新文件。我们将在这里序列化我们默认的 Django 用户模型。</p><h2 id="510b" class="ni nd it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated"><strong class="ak">什么是序列化，我们为什么需要它？</strong></h2><p id="22a4" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">序列化是将复杂对象转换为易于存储或传输的数据格式的过程。在 Django Rest 框架的上下文中，序列化用于将 Django 模型中的数据转换成可以通过互联网发送并被其他应用程序使用的格式。</p><p id="b198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是为什么序列化在 Django Rest 框架中必不可少的一些具体原因:</p><ol class=""><li id="f54a" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">它允许您将 Django 模型和查询集转换成 JSON 或 XML 之类的格式，这些格式很容易被前端的其他应用程序或 JavaScript 框架使用。</li><li id="82b7" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">它允许您精确地控制 API 公开什么数据以及如何格式化数据。这对于安全性以及确保 API 的一致性和易用性非常重要。</li><li id="a898" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">它允许您轻松地将复杂的数据结构转换成易于存储或传输的格式。这在处理大型数据集或处理不同对象之间有大量关系的数据时特别有用。</li></ol><p id="0c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，序列化是 Django Rest 框架的一个关键特性，它使您能够快速构建各种应用程序和框架都可以使用的 API。</p><h2 id="9603" class="ni nd it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated"><strong class="ak">serializer . py</strong></h2><p id="9aa2" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">因此，在<code class="fe mn mo mp mq b">serializers.py</code>文件中，我们将序列化默认的 Django 用户模型。因此，我们将为我们的用户模型使用三个字段— <code class="fe mn mo mp mq b">username</code>、<code class="fe mn mo mp mq b">email</code>和<code class="fe mn mo mp mq b">password</code>。</p><p id="9b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们先看看代码，然后我们就能理解代码的所有部分。</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="0cef" class="nc nd it mq b be ne nf l ng nh">from rest_framework import serializers<br/>from django.contrib.auth.models import User<br/><br/>class UserSerializer(serializers.ModelSerializer):<br/>    password = serializers.CharField(min_length = 8, write_only = True)<br/><br/>    class Meta:<br/>        model = User<br/>        fields = ('username', 'email', 'password')</span></pre><p id="5877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在上面的代码块中看到的，首先，我们将从<code class="fe mn mo mp mq b">rest_framework</code>导入<code class="fe mn mo mp mq b">serializers</code>，并且我们还从 Django 认证模型导入默认的<code class="fe mn mo mp mq b">User</code>模型。</p><p id="3557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，代码定义了一个<code class="fe mn mo mp mq b">UserSerializer</code>类，用于将<code class="fe mn mo mp mq b">User</code>模型的实例转换成一种易于序列化的格式，比如 JSON 或 XML。<code class="fe mn mo mp mq b">UserSerializer</code>类继承自<code class="fe mn mo mp mq b">ModelSerializer</code>类，后者提供了很多将 Django 模型自动转换成可序列化格式的功能。</p><p id="6109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">UserSerializer</code>类定义了一个<code class="fe mn mo mp mq b">password</code>字段，它是一个最小长度为 8 个字符的<code class="fe mn mo mp mq b">CharField</code>。<code class="fe mn mo mp mq b">write_only</code>参数被设置为<code class="fe mn mo mp mq b">True</code>，这意味着密码字段仅在将数据写入序列化程序时使用，但不会包含在序列化输出中，因为我们不希望密码被泄露。</p><p id="c32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">UserSerializer</code>类中的<code class="fe mn mo mp mq b">Meta</code>类指定了序列化器应该用于的<code class="fe mn mo mp mq b">model</code>(在本例中是<code class="fe mn mo mp mq b">User</code>型号)，以及应该包含在序列化输出中的<code class="fe mn mo mp mq b">fields</code>列表。在这种情况下，<code class="fe mn mo mp mq b">username</code>、<code class="fe mn mo mp mq b">email</code>和<code class="fe mn mo mp mq b">password</code>字段将包含在序列化输出中。</p><p id="c319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将移动到<code class="fe mn mo mp mq b">views.py</code>文件，在这里我们将使用序列化数据并编写我们的<code class="fe mn mo mp mq b">users</code>应用程序的主要逻辑。这是决定我们的应用程序如何处理不同请求的文件。</p><h2 id="c340" class="ni nd it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated"><strong class="ak"> views.py </strong></h2><p id="3b58" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">在<code class="fe mn mo mp mq b">views.py</code>文件中，我们将编写与用户相关的<code class="fe mn mo mp mq b">get</code>和<code class="fe mn mo mp mq b">post</code>请求——检索所有用户的列表并注册一个新用户。让我们先看看代码，然后我们将详细讨论代码是如何实现的。</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="59a2" class="nc nd it mq b be ne nf l ng nh">from rest_framework.views import APIView<br/>from rest_framework.response import Response<br/>from django.contrib.auth.models import User<br/>from .serializers import UserSerializer<br/><br/>class UsersAPIView(APIView):<br/>    def get(self, request):<br/>        users = User.objects.all()<br/>        serializer = UserSerializer(users, many = True)<br/>        return Response(serializer.data)<br/>    <br/>    def post(self, request):<br/>        serializer = UserSerializer(data = request.data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return Response(serializer.data, status = 201)<br/>        return Response(serializer.errors, status = 400)</span></pre><p id="eb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，首先，我们导入所需的依赖项，并引入我们将在视图中使用的<code class="fe mn mo mp mq b">User</code>模型和<code class="fe mn mo mp mq b">UserSerializer</code>。</p><p id="83eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，代码定义了一个<code class="fe mn mo mp mq b">UsersAPIView</code>类，它处理对 Django Rest 框架 API 的 HTTP 请求。<code class="fe mn mo mp mq b">UsersAPIView</code>类继承了<code class="fe mn mo mp mq b">APIView</code>类，后者为处理 HTTP 请求和返回响应提供了许多有用的功能。</p><p id="b52d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">UsersAPIView</code>类定义了两个方法:<code class="fe mn mo mp mq b">get</code>和<code class="fe mn mo mp mq b">post</code>。当 API 接收到 GET 请求时，调用<code class="fe mn mo mp mq b">get</code>方法。它从数据库中检索所有的<code class="fe mn mo mp mq b">User</code>对象，使用一个<code class="fe mn mo mp mq b">UserSerializer</code>将数据转换成可序列化的格式，并向客户端返回一个包含序列化数据的响应。</p><p id="8b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，正如我们所见，当调用<code class="fe mn mo mp mq b">get</code>方法时，<code class="fe mn mo mp mq b">many</code>参数被设置为<code class="fe mn mo mp mq b">UserSerializer</code>中的<code class="fe mn mo mp mq b">True</code>，这表明序列化程序应该会处理多个<code class="fe mn mo mp mq b">User</code>对象。这很重要，因为它允许<code class="fe mn mo mp mq b">UserSerializer</code>正确处理数据并返回包含所有<code class="fe mn mo mp mq b">User</code>对象的响应。</p><p id="b3d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe mn mo mp mq b">many</code>没有设置为<code class="fe mn mo mp mq b">True</code>，那么<code class="fe mn mo mp mq b">UserSerializer</code>一次只会处理一个<code class="fe mn mo mp mq b">User</code>对象，而<code class="fe mn mo mp mq b">get</code>方法的响应只会包含一个<code class="fe mn mo mp mq b">User</code>对象，而不是数据库中的所有<code class="fe mn mo mp mq b">User</code>对象。</p><p id="9d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当 API 接收到 POST 请求时，调用<code class="fe mn mo mp mq b">post</code>方法。它使用<code class="fe mn mo mp mq b">UserSerializer</code>将请求的数据转换成一个<code class="fe mn mo mp mq b">User</code>对象，验证数据，如果数据有效，将对象保存到数据库，并向客户机返回一个带有序列化数据的响应。如果数据无效，它将向客户端返回一个错误响应。</p><p id="7ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们必须为我们刚刚创建的视图定义<code class="fe mn mo mp mq b">urls</code>，这将允许我们使用可浏览的 API 接口来测试我们的 API。</p><h2 id="cb50" class="ni nd it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated"><strong class="ak"> urls.py </strong></h2><p id="0301" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">我们将不得不修改两个<code class="fe mn mo mp mq b">urls.py</code>文件，一个在<code class="fe mn mo mp mq b">users</code>应用中，另一个在<code class="fe mn mo mp mq b">blog</code>应用中。在<code class="fe mn mo mp mq b">users</code>应用程序中，我们将创建<code class="fe mn mo mp mq b">urls.py</code>文件，并且我们将为刚刚创建的视图创建一个 URL。</p><p id="6af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，<code class="fe mn mo mp mq b">users</code> app 里面的<code class="fe mn mo mp mq b">urls.py</code>文件的内容是:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="ac89" class="nc nd it mq b be ne nf l ng nh">from django.urls import path, include<br/>from .views import UsersAPIView<br/><br/>urlpatterns = [<br/>    path('', UsersAPIView.as_view()),<br/>]</span></pre><p id="12d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码定义了 Django 应用程序的 URL 模式列表。在 Django 中，URL 模式是一个特定的字符串，它指定了特定资源在 web 上的位置。<code class="fe mn mo mp mq b">urlpatterns</code>列表定义了一组可以与输入 URL 匹配的模式，并指定应该调用哪个视图函数来处理每个模式。</p><p id="2374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，<code class="fe mn mo mp mq b">urlpatterns</code>列表定义了一个匹配空字符串的 URL 模式(即应用程序的根 URL)。这个模式被映射到<code class="fe mn mo mp mq b">UsersAPIView</code>视图，这意味着对应用程序根 URL 的任何请求都将由<code class="fe mn mo mp mq b">UsersAPIView</code>视图处理。</p><p id="51f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mn mo mp mq b">as_view()</code>方法调用<code class="fe mn mo mp mq b">UsersAPIView</code>视图，该方法创建视图的一个实例并返回一个函数，可以调用该函数来处理传入的请求。这个函数然后被传递给<code class="fe mn mo mp mq b">path()</code>函数，后者创建一个 URL 模式，可以与传入的 URL 进行匹配。</p><p id="fade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在<code class="fe mn mo mp mq b">blog</code>应用程序的<code class="fe mn mo mp mq b">urls.py</code>文件中，这是我们 Django 应用程序的根应用程序，我们将添加以下代码:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="7280" class="nc nd it mq b be ne nf l ng nh">....<br/>from users import urls as users_urls<br/><br/>urlpatterns = [<br/>    ....<br/>    path("api/users/", include(users_urls)),<br/>]</span></pre><p id="0cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">....</code>只是用于表示的目的，因为我们还有几行代码，就像我们在上一部分添加的那样。</p><p id="a14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">path()</code>函数有两个参数:一个字符串指定匹配的模式，另一个是视图函数或其他 URL 模式，应该调用它来处理匹配模式的请求。在这段代码中，<code class="fe mn mo mp mq b">include()</code>函数作为第二个参数传递，这意味着<code class="fe mn mo mp mq b">path()</code>函数将包含在<code class="fe mn mo mp mq b">users_urls</code>变量中定义的 URL 模式。</p><p id="e5e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许我们将我们的 URL 模式组织到多个文件中，使我们的代码更干净，更容易维护。因此，正如我们所见，我们已经在<code class="fe mn mo mp mq b">users</code>应用程序中的<code class="fe mn mo mp mq b">urls.py</code>文件中定义了我们的<code class="fe mn mo mp mq b">user_urls</code>，我们将在这里使用它。</p><p id="cf93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，包含<code class="fe mn mo mp mq b">users</code>部分的<code class="fe mn mo mp mq b">blogs</code> app 的完整<code class="fe mn mo mp mq b">urls.py</code>文件为:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="7534" class="nc nd it mq b be ne nf l ng nh">from django.contrib import admin<br/>from django.urls import path, include<br/>from users import urls as users_urls<br/><br/>urlpatterns = [<br/>    path("admin/", admin.site.urls),<br/>    path("api-auth/", include("rest_framework.urls", namespace="rest_framework")),<br/>    path("api/users/", include(users_urls)),<br/>]</span></pre><h2 id="5f52" class="ni nd it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">测试 API</h2><p id="f3b3" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">现在，让我们通过运行服务器来测试我们刚刚创建的与用户相关的 API。因此，我们将使用下面的命令来启动我们的应用程序。</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="b315" class="nc nd it mq b be ne nf l ng nh">python manage.py runserver</span></pre><p id="a0ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将执行一些系统检查并启动服务器。它将显示运行您的应用程序的 URL。转到那个 URL，因为我们想要测试用户 API，所以我们将转到<code class="fe mn mo mp mq b"><a class="ae ky" href="http://127.0.0.1:8000/api/users/" rel="noopener ugc nofollow" target="_blank">/api/users/</a></code>部分。</p><p id="79bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到这个 URL，我们会看到它显示了我们的应用程序中的用户列表和添加新用户的 POST 选项。另外，在右上方，我们可以看到一个登录选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/8748d20a0f90cac949150ac2d9632c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTOtIQMf50N726YiwVwlrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DRF 可浏览 API —用户 API —(图片由作者提供)</p></figure><p id="e24c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，如果我们点击<strong class="lb iu">登录</strong>按钮，我们会看到如下页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/d922cd754c6603dce243d2511189e629.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*I2C_0wzPBEsQzKMFqaP-kQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">DRF 登录界面—(图片由作者提供)</p></figure><p id="09d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们可以使用之前创建的凭证登录到应用程序。</p><p id="e4c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们再次被带到 DRF 页面。现在，我们可以尝试使用 POST 按钮向应用程序添加一个新用户。为此，我们将以 JSON 格式提供新的用户数据，如下所示:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="054f" class="nc nd it mq b be ne nf l ng nh">{<br/>   "username": "Satyam",<br/>   "email": "satyam@gmail.com",<br/>   "password": "testing@123"<br/>}</span></pre><p id="41a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在提供的<code class="fe mn mo mp mq b">Content</code>部分添加上面的 JSON，然后我们将单击 POST 按钮向我们的应用程序添加一个新用户。然后，它将刷新页面并显示添加的新用户。</p><p id="4e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们再次单击 GET 按钮，我们可以看到用户列表，它现在包含两个条目，第一个是我们之前创建的超级用户，第二个是我们刚才创建的用户。</p><p id="05a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是我们的应用程序在这个阶段的用户列表:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="89f0" class="nc nd it mq b be ne nf l ng nh">[<br/>    {<br/>        "username": "Shubham",<br/>        "email": "shubhamstudent5@gmail.com"<br/>    },<br/>    {<br/>        "username": "Satyam",<br/>        "email": "satyam@gmail.com"<br/>    }<br/>]</span></pre><p id="63e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以访问管理面板来查看在我们的应用程序中注册的用户，并编辑他们的详细信息。</p><h2 id="c46f" class="ni nd it bd nj nk nl dn nm nn no dp np li nq nr ns lm nt nu nv lq nw nx ny nz bi translated">添加完整的身份验证部分</h2><p id="b980" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">首先，我们将导入几个库，我们将要求它们包含一个合适的认证系统，该系统将使用<strong class="lb iu"> JWT </strong> (JSON Web 令牌)工作。</p><p id="09c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将从导入这些库开始:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="16f2" class="nc nd it mq b be ne nf l ng nh">pipenv install django-cors-headers<br/>pipenv install djangorestframework-simplejwt</span></pre><p id="715d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们进入应用程序的<code class="fe mn mo mp mq b">blogs</code>应用程序中的<code class="fe mn mo mp mq b">settings.py</code>文件。</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="6ff1" class="nc nd it mq b be ne nf l ng nh"># add this import<br/>from datetime import timedelta<br/><br/># at last add these two in the INSTALLED_APPS section<br/>INSTALLED_APPS = [<br/>    ...,<br/>    "rest_framework_simplejwt.token_blacklist",<br/>    "corsheaders",<br/>]<br/><br/># add the cors middleware<br/>MIDDLEWARE = [<br/>    ...,<br/>    "corsheaders.middleware.CorsMiddleware",<br/>]<br/><br/># update this part to add the default authentication class to be used<br/>REST_FRAMEWORK = {<br/>    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.PageNumberPagination",<br/>    "PAGE_SIZE": 10,<br/>    "DEFAULT_AUTHENTICATION_CLASSES": (<br/>        "rest_framework_simplejwt.authentication.JWTAuthentication",<br/>    ),<br/>}<br/><br/># add this<br/>SIMPLE_JWT = {<br/>    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),<br/>    'REFRESH_TOKEN_LIFETIME': timedelta(days=50),<br/>    'ROTATE_REFRESH_TOKENS': True,<br/>    'BLACKLIST_AFTER_ROTATION': True,<br/>    'UPDATE_LAST_LOGIN': False,<br/><br/>    'ALGORITHM': 'HS256',<br/><br/>    'VERIFYING_KEY': None,<br/>    'AUDIENCE': None,<br/>    'ISSUER': None,<br/>    'JWK_URL': None,<br/>    'LEEWAY': 0,<br/><br/>    'AUTH_HEADER_TYPES': ('Bearer',),<br/>    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',<br/>    'USER_ID_FIELD': 'id',<br/>    'USER_ID_CLAIM': 'user_id',<br/>    'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',<br/><br/>    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),<br/>    'TOKEN_TYPE_CLAIM': 'token_type',<br/>    'TOKEN_USER_CLASS': 'rest_framework_simplejwt.models.TokenUser',<br/><br/>    'JTI_CLAIM': 'jti',<br/><br/>    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',<br/>    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),<br/>    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),<br/>}<br/><br/># add this line<br/>CORS_ALLOW_ALL_ORIGINS = True</span></pre><p id="2592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…表示在我们刚刚添加的代码之上还有更多代码。所以，我们只是在我们的<code class="fe mn mo mp mq b">settings.py</code>文件中添加了一些东西。</p><p id="c39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">rest_framework_simplejwt.token_blacklist</code>提供了一种简单的方法，使用<code class="fe mn mo mp mq b">SimpleJWT</code>库将 Django 项目中的 JSON Web 令牌(jwt)列入黑名单。<code class="fe mn mo mp mq b">SimpleJWT</code>库是 Django REST 框架的一个 JSON Web 令牌认证库。</p><p id="c192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户注销应用程序时，通常会使他们的 JWT 失效，这样就不能再用它来验证将来的请求。这可以通过将 JWT 添加到令牌黑名单来实现。任何随后的要求，提出了黑名单 JWT 将被拒绝。</p><p id="6304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将 CORS 头文件添加到 Django 项目中很容易。它允许您指定允许哪些源向您的服务器发出请求，以及在这些请求中允许哪些 HTTP 方法和头。</p><p id="a4a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">JWTAuthentication</code>类是<code class="fe mn mo mp mq b">SimpleJWT</code>库的一部分，后者是 Django REST 框架的 JSON Web Token (JWT)认证库。它允许您使用 jwt 验证 API 请求。</p><p id="43b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">SIMPLE_JWT</code>设置是用于配置<code class="fe mn mo mp mq b">SimpleJWT</code>库的字典，该库是 Django REST 框架的 JSON Web Token (JWT)认证库。它允许我们使用 jwt 认证 API 请求。</p><p id="83ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是对<code class="fe mn mo mp mq b">SIMPLE_JWT</code>字典中每个键的简要解释:</p><ul class=""><li id="e865" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ov ol om on bi translated"><code class="fe mn mo mp mq b">ACCESS_TOKEN_LIFETIME</code>:访问令牌的生命周期，这些令牌是用于认证 API 请求的 jwt。这被指定为一个<code class="fe mn mo mp mq b">timedelta</code>对象。</li><li id="3d5d" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">REFRESH_TOKEN_LIFETIME</code>:刷新令牌的生命周期，是用来获取新的访问令牌的 jwt。这被指定为一个<code class="fe mn mo mp mq b">timedelta</code>对象。</li><li id="5c2b" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">ROTATE_REFRESH_TOKENS</code>:一个布尔值，指示当刷新令牌用于获取新的访问令牌时，它们是否应该被循环(无效并替换为新的令牌)。</li><li id="bd7c" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">BLACKLIST_AFTER_ROTATION</code>:布尔值，表示是否应将循环刷新令牌添加到令牌黑名单。</li><li id="e2bc" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">UPDATE_LAST_LOGIN</code>:boolean，表示当使用刷新令牌获取新的访问令牌时，是否应该更新用户的<code class="fe mn mo mp mq b">last_login</code>字段。</li><li id="e896" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">ALGORITHM</code>:应该用于签署 jwt 的算法。这必须是有效的 JWT 签名算法。</li><li id="2243" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">VERIFYING_KEY</code>:应该用来验证 jwt 签名的密钥。</li><li id="94e2" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">AUDIENCE</code>:jwt 应该面向的受众。</li><li id="d51e" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">ISSUER</code>:jwt 应该发行的发行方。</li><li id="cc8a" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">JWK_URL</code>:JSON Web Key Set(JWKS)的 URL，可用于验证 jwt 的签名。</li><li id="b507" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">LEEWAY</code>:验证 jwt 到期时间时应该允许的余量。</li><li id="7e53" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">AUTH_HEADER_TYPES</code>:一组字符串，指定<code class="fe mn mo mp mq b">JWTAuthentication</code>类应该接受的<code class="fe mn mo mp mq b">Authorization</code>头的类型。</li><li id="f253" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">AUTH_HEADER_NAME</code>:应该由<code class="fe mn mo mp mq b">JWTAuthentication</code>类使用的<code class="fe mn mo mp mq b">Authorization</code>头的名称。</li><li id="04da" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">USER_ID_FIELD</code>:用户模型上用于获取用户 ID 的字段名称。</li><li id="c3f1" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">USER_ID_CLAIM</code>:应该用于获取用户 ID 的 JWT 有效负载中声明的名称。</li><li id="8796" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">USER_AUTHENTICATION_RULE</code>:根据用户 ID，使用函数名对用户进行认证。</li><li id="40af" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">AUTH_TOKEN_CLASSES</code>:字符串元组，指定应该用来创建 jwt 的类。</li><li id="76ac" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">TOKEN_TYPE_CLAIM</code>:JWT 有效载荷中声明的名称，该名称应该用于指定 JWT 的类型。</li><li id="e1f1" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">TOKEN_USER_CLASS</code>:类名应该用来表示与 JWT 关联的用户。</li><li id="79fc" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">JTI_CLAIM</code>:应该用于存储 JWT ID 的 JWT 有效载荷中声明的名称。</li><li id="d2bf" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">SLIDING_TOKEN_REFRESH_EXP_CLAIM</code>:JWT 有效负载中声明的名称，该名称应该用于存储滑动令牌的刷新到期时间。</li><li id="90b9" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">SLIDING_TOKEN_LIFETIME</code>:滑动令牌的生命周期，它是具有动态过期时间的 jwt，每次使用令牌对请求进行身份验证时都会更新。这被指定为一个<code class="fe mn mo mp mq b">timedelta</code>对象。</li><li id="728b" class="of og it lb b lc oo lf op li oq lm or lq os lu ov ol om on bi translated"><code class="fe mn mo mp mq b">SLIDING_TOKEN_REFRESH_LIFETIME</code>:滑动令牌刷新令牌的生存期，用于获取新的滑动令牌。这被指定为一个<code class="fe mn mo mp mq b">timedelta</code>对象。</li></ul><p id="d98b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将转到<code class="fe mn mo mp mq b">users</code>应用程序，为使用 JWT 令牌的登录支持添加必要的内容。</p><p id="13f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们将首先更新我们的<code class="fe mn mo mp mq b">serializers.py</code>文件。下面是相同的更新代码。</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="5881" class="nc nd it mq b be ne nf l ng nh">from rest_framework import serializers<br/>from django.contrib.auth.models import User<br/>from rest_framework_simplejwt.serializers import TokenObtainPairSerializer<br/><br/>class UserSerializer(serializers.ModelSerializer):<br/>    password = serializers.CharField(min_length = 8, write_only = True)<br/><br/>    class Meta:<br/>        model = User<br/>        fields = ('username', 'email', 'password')<br/><br/>class MyTokenObtainPairSerializer(TokenObtainPairSerializer):<br/>    @classmethod<br/>    def get_token(cls, user):<br/>        token = super().get_token(user)<br/>        token['username'] = user.username<br/>        token['email'] = user.email<br/>        return token</span></pre><p id="09fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，我们的<code class="fe mn mo mp mq b">UserSerializer</code>保持不变。我们只添加了<code class="fe mn mo mp mq b">MyTokenObtainPairSerializer</code>类。</p><p id="b285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">MyTokenObtainPairSerializer</code>类是来自<code class="fe mn mo mp mq b">SimpleJWT</code>库的<code class="fe mn mo mp mq b">TokenObtainPairSerializer</code>的子类，该库是 DRF 的 JWT 认证库。它用于序列化和反序列化令牌，这些令牌用于使用 jwt 对 API 请求进行身份验证。</p><p id="8fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">MyTokenObtainPairSerializer</code>类覆盖了基类<code class="fe mn mo mp mq b">TokenObtainPairSerializer</code>的<code class="fe mn mo mp mq b">get_token</code>方法。<code class="fe mn mo mp mq b">get_token</code>方法负责生成 JWT，当客户端验证一个请求时返回给客户端。</p><p id="316a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在被覆盖的<code class="fe mn mo mp mq b">get_token</code>方法中，<code class="fe mn mo mp mq b">super().get_token(user)</code>调用将调用基类<code class="fe mn mo mp mq b">TokenObtainPairSerializer</code>的<code class="fe mn mo mp mq b">get_token</code>方法，并返回它生成的 JWT。然后通过将<code class="fe mn mo mp mq b">user</code>对象的<code class="fe mn mo mp mq b">username</code>和<code class="fe mn mo mp mq b">email</code>字段添加到 JWT 有效载荷来修改 JWT。然后返回修改后的 JWT。</p><p id="f38c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们移动到<code class="fe mn mo mp mq b">views.py</code>文件，在这里我们将为令牌部分添加几行。</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="c980" class="nc nd it mq b be ne nf l ng nh">from rest_framework.views import APIView<br/>from rest_framework.response import Response<br/>from django.contrib.auth.models import User<br/>from .serializers import UserSerializer<br/>from rest_framework_simplejwt.views import TokenObtainPairView<br/>from .serializers import MyTokenObtainPairSerializer<br/><br/>class UsersAPIView(APIView):<br/>    def get(self, request):<br/>        users = User.objects.all()<br/>        serializer = UserSerializer(users, many = True)<br/>        return Response(serializer.data)<br/>    <br/>    def post(self, request):<br/>        serializer = UserSerializer(data = request.data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return Response(serializer.data, status = 201)<br/>        return Response(serializer.errors, status = 400)<br/><br/><br/>class MyTokenObtainPairView(TokenObtainPairView):<br/>    serializer_class = MyTokenObtainPairSerializer</span></pre><p id="3851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，我们只添加了一个使用<code class="fe mn mo mp mq b">MyTokenObtainPairSerializer</code>类的新类<code class="fe mn mo mp mq b">MyTokenObtainPairView</code>。</p><p id="bc14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们移动到<code class="fe mn mo mp mq b">urls.py</code>文件，并为登录和令牌刷新添加新的访问端点。修改后的<code class="fe mn mo mp mq b">urls.py</code>文件如下:</p><pre class="kj kk kl km gt my mq mz bn na nb bi"><span id="1333" class="nc nd it mq b be ne nf l ng nh">from django.urls import path, include<br/>from .views import UsersAPIView, MyTokenObtainPairView<br/>from rest_framework_simplejwt.views import TokenRefreshView<br/><br/>urlpatterns = [<br/>    path('', UsersAPIView.as_view()),<br/>    path('login/', MyTokenObtainPairView.as_view()),<br/>    path('token/refresh/', TokenRefreshView.as_view()),<br/>]</span></pre><p id="95b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我们所见，我们添加了两个不同的<code class="fe mn mo mp mq b">urlpatterns</code>，分别用于登录和刷新令牌。</p><p id="c643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp mq b">TokenRefreshView</code>视图允许我们通过向视图发送带有刷新令牌的请求来刷新 JSON Web 令牌(JWT)。</p><p id="a84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JWT 刷新流程的工作方式如下:</p><ol class=""><li id="05a1" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">客户端向服务器认证，并接收访问令牌和刷新令牌。</li><li id="1851" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">客户端使用访问令牌向受保护的资源发出请求。</li><li id="987c" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">如果访问令牌已过期，服务器会响应 401 未授权错误。</li><li id="dc55" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">然后，客户机用刷新令牌向<code class="fe mn mo mp mq b">TokenRefreshView</code>视图发出请求。</li><li id="a1f5" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">如果刷新令牌有效，视图向客户端发布新的访问令牌和刷新令牌。</li></ol><p id="751a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用可浏览的 API 接口或 API 测试应用程序(如 Postman)来测试这种身份验证。我推荐 Postman，因为它的功能更加丰富，并且允许您轻松地提供访问令牌来请求访问任何受保护的视图。</p></div><div class="ab cl ow ox hx oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="im in io ip iq"><p id="3622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，这就是这部分的全部内容。在下一部分，我们将处理这个应用程序的<code class="fe mn mo mp mq b">posts</code>应用程序，并将完成这个系列的后端部分。</p><p id="6b07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章，并学到一些新的和令人兴奋的东西。我将很快写下一部分，一旦它们出版，我会在这里把它们连接起来。</p><p id="4591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该系列文章的下一部分可以在下面找到:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/build-a-blog-website-using-django-rest-framework-posts-app-part-3-7334f75983fc"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用 Django Rest 框架——Posts 应用程序构建一个博客网站(第 3 部分)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在第三部分，我们处理应用程序的整个 posts 应用程序，从而完成应用程序的后端。</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="pd l mj mk ml mh mm ks ly"/></div></div></a></div><p id="a3a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读完这篇文章后，我推荐阅读以下系列文章:</p><div class="lv lw gp gr lx ly"><a href="https://javascript.plainenglish.io/build-an-e-commerce-website-with-mern-stack-part-1-setting-up-the-project-eecd710e2696" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">让我们建立一个 MERN 堆栈电子商务网络应用程序</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">第 1 部分:设置项目</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mh l"><div class="pe l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/build-a-social-media-website-using-django-setup-the-project-part-1-6e1932c9f221"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">使用 Django 构建一个社交媒体网站——设置项目(第 1 部分)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在第一部分中，我们通过设置密码来集中设置我们的项目和安装所需的组件…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="pf l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>