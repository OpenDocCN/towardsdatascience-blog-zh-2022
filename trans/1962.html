<html>
<head>
<title>The Big O Notation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O符号</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/big-o-notation-32fb458e5260#2022-05-04">https://towardsdatascience.com/big-o-notation-32fb458e5260#2022-05-04</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a77a" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用Big-O符号计算算法的时间和空间复杂度</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/035e882d5f550da880d9fbfa3c24c576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuLqAuXiut4x_IAO8tckeg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">约翰尼斯·格罗尔在<a class="ae kz" href="https://unsplash.com/s/photos/algorithm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="7003" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">当开发算法时，我们通常关注它的有效性——换句话说，它是否能做它应该做的工作。然而，时间和空间复杂度是必须评估的两个非常重要的因素，以确保该算法可以在实践中实现和使用。</p><p id="3c42" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">即使一个算法在理论上是可行的，但是如果运行它所花费的时间使它变得无用，会发生什么呢？或者它需要的空间大到电脑可能内存不足怎么办？</p><p id="acec" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将在渐近算法分析的背景下讨论时间和空间复杂性。我们将探索大O符号，这是用来描述算法效率的最常用的度量。</p><p id="6c80" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，我们还将讨论大O，大Theta和大Omega符号之间的区别。最后，我们还将通过几个实际操作的例子来演示如何在实践中计算时间和空间复杂度。</p><p id="71d9" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">请注意，这些示例将使用Python——即使您不了解Python，我也很确定它会比您想象的更容易理解。为了帮助没有Python背景的人，我保证会添加尽可能多的评论:)</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="51d4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">渐近时间复杂性</h2><p id="d281" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在数学分析中，<strong class="ly iv">渐近分析</strong>是一种用来描述当输入接近某个其他值时，函数所逼近的值(即极限)的方法。作为一个例子，让我们考虑我们想要研究一个函数<strong class="ly iv"> <em class="nb"> f(n) </em> </strong>在数n变得非常大时的行为。</p><p id="c03b" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如果<strong class="ly iv"><em class="nb">f(n)=n⁴+4n+10</em></strong>并且数字<em class="nb"> n </em>非常大，那么术语<strong class="ly iv"> <em class="nb"> 4n </em> </strong>与术语<strong class="ly iv"><em class="nb"/></strong>相比将无足轻重，而<strong class="ly iv"> <em class="nb"> n </em> </strong>对常数<strong class="ly iv"> 10 </strong>没有影响。因此，当<em class="nb"> n </em>趋于无穷大时，函数<strong class="ly iv"> <em class="nb"> f(n) </em> </strong>被称为<strong class="ly iv">渐近等价于<em class="nb"> n⁴ </em> </strong>。</p><p id="ae1e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在在算法的上下文中，执行<strong class="ly iv">渐近分析</strong>，以便<strong class="ly iv">根据输入大小</strong>描述或评估算法的性能。换句话说，当输入大小也增加时，我们使用渐近分析来确定时间和空间的增加。</p><p id="9784" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">作为一个例子，让我们考虑你想要传送一个数据文件给一个朋友，他住在离你当前位置3小时路程的城市。现在让我们假设实际上有两种方式发送它；第一种是电子转账，第二种是旅行3个小时，用u盘(物理)交给她。如果您决定以电子方式发送文件，传输时间将受到文件大小的影响。文件越大，传输给朋友所需的时间就越长。另一方面，如果您决定前往您朋友的位置并将其移交，传输时间将为3小时，与文件的大小无关，因此文件大小不会影响传输时间。</p><p id="94d2" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">下图说明了这种行为— <em class="nb"> O(s) </em>对应于以电子方式传输文件的时间复杂度。随着文件大小<strong class="ly iv"> <em class="nb"> s </em> </strong>的增加，完成传输所需的时间也增加(在这个例子中，这种增加是线性的)。另一方面，<em class="nb"> O(1) </em>对应于物理传送文件的情况下的时间复杂度，因此时间复杂度是恒定的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/c098c1162a366bac423b0f3313a20b85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*UzD8LlwcWr2ELOEPrf_XvA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">时间(和空间)复杂性的渐近分析—来源:作者(<a class="ae kz" href="https://gist.github.com/gmyrianthous/27106b51253ccea7985215a7a9252793" rel="noopener ugc nofollow" target="_blank">源代码复制它</a>)</p></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="2d11" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">大O vs大Theta vs大Omega</h2><p id="969a" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">大O符号用于描述算法复杂度的一个<strong class="ly iv">上限</strong>。假设我们有一个N个整数的列表(或数组)。如果我们想打印出列表中的每个元素，时间复杂度是O(N)。虽然从理论上讲，这个用例的时间复杂度也可以描述为O(N)或O(N)或任何其他大于O(N)的值，因为这些是上限。</p><p id="e34e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这可能有点令人困惑，所以让我们考虑一个现实生活中的例子。我们来做一个假设，没有一辆车可以超过400 km/h的速度，如果我们有一辆车的最大速度是X，那么我们当然可以说X ≤ 400。虽然从理论上讲，我们也可以说X≤1000或X≤10000。从技术上讲，这是正确的，因为我们使用上限，即使进一步扩展上限并不十分有用。</p><p id="b176" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">然而，除了大O之外，还有两种替代符号，即大ω(<em class="nb">ω</em>)和大θ(<em class="nb">θ</em>)。</p><p id="a5ef" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">大ω</strong>用来形容<strong class="ly iv">下界</strong>。回到我们打印所有列表元素的例子，下限将是<em class="nb">ω(N)</em>，因为我们知道它不会比这个更快。同样，我们也可以说下限是<em class="nb">ω(1)</em>或<em class="nb">ω(logN)</em>，因为打印一个包含N个元素的列表不会比这些下限更快。</p><p id="1918" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">大θ</strong>用于描述<strong class="ly iv">紧界</strong>。这意味着如果一个算法同时是<em class="nb"> O(N) </em>和<em class="nb">ω(N)</em>，那么这个算法可以描述为<em class="nb">θ(N)</em>。我们可以说打印一个有N个元素的数组是<em class="nb">θ(N)</em>。</p><p id="9069" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">一般来说，我们通常使用大O符号来描述算法的时间和空间复杂性，同时总是试图定义尽可能紧密的运行时，给定特定算法和/或用例的细节。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="a5fa" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最佳情况对最差情况对预期情况</h2><p id="bb08" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">各种算法都包含某种形式的随机性，这可能会影响算法的性能。也有一些算法在排序的数组上运行得更快，但是当数组的元素没有排序时运行得更慢。</p><p id="af9e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">因此，<strong class="ly iv">实际上有三种不同的方式来描述算法的运行时间</strong>；最好的情况，预期的情况和最坏的情况。当我们评估算法的性能时，应该计算<strong class="ly iv">最坏情况的复杂度</strong>。</p><p id="d4f7" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">请注意，这些概念不应与我们之前讨论的大θ和大ω相混淆。下限和上限与最佳、最差和预期情况无关。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="0c15" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">空间复杂性</h2><p id="f1ba" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">除了时间复杂度之外，另一个需要评估的重要方面是空间复杂度，即算法执行所需的内存量。随着计算机能力的不断发展，空间复杂性通常会被程序员忽略。然而，考虑到正在处理的数据也在不断发展，以消耗尽可能少的内存的方式设计和实现算法是非常重要的。</p><p id="c36c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">进入空间复杂度的实际计算，如果我们要创建一个N个整数的一维数组，那么就需要<em class="nb"> O(n) </em>空间。同样，一个大小为<em class="nb"> n </em> x <em class="nb"> n </em>的二维数组需要O(n)个空间。这里还必须提到，除了数据结构中元素占用的空间之外，在递归调用中分配给堆栈的空间也应该考虑在内。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="a96a" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用大O符号计算空间复杂度</h2><p id="57b8" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">作为一个例子，让我们考虑下面的递归函数，它用于计算0和<code class="fe nd ne nf ng b">n</code>之间的数字之和:</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="3750" class="la lb iu ng b gz nl nm l nn no">def sum_func(n: int):<br/>    """ <br/>    Recursive method that returns the sum <br/>    of the numbers between 0 and input n<br/>    """<br/>    if n &gt; 0:<br/>        return sum_func(n - 1) + n</span><span id="fce7" class="la lb iu ng b gz np nm l nn no">    return 0</span></pre><p id="7ab3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">尽管函数的输入只是一个整数，但每次递归调用都会在调用堆栈中增加一个级别。举个例子，</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="4894" class="la lb iu ng b gz nl nm l nn no">sum_func(5)<br/>    adds call sum_func(4) to stack<br/>        adds call sum_func(3) to stack<br/>            adds call sum_func(2) to stack<br/>                adds call sum_func(1) to stack<br/>                    adds call  sum_func(0) to stack</span></pre><p id="7b04" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">实际上，添加到调用堆栈中的每个调用都会消耗实际内存，因此在计算空间复杂度时，应该始终将它们考虑在内。因此，函数<code class="fe nd ne nf ng b">sum_func</code>将需要O(n)时间和O(n)空间。</p><p id="43f6" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">拥有<em class="nb"> n个</em>调用，并不一定意味着一个算法需要<em class="nb"> O(n) </em>空间。现在让我们修改一下我们之前使用的递归方法，这样0和输入数<code class="fe nd ne nf ng b">n</code>之间的和的计算是以迭代的方式进行的。</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="5d02" class="la lb iu ng b gz nl nm l nn no">def sum_func(n: int):<br/>    """ <br/>    Iterative method that returns the sum <br/>    of the numbers between 0 and input n<br/>    """<br/>    sum = 0<br/>    for i in range(n+1):<br/>        sum = sum_nums(sum, i)<br/>    return sum<br/></span><span id="8090" class="la lb iu ng b gz np nm l nn no">def sum_nums(a: int, b:int):<br/>    """<br/>    Returns the sum of two numbers<br/>    """<br/>    return a + b</span></pre><p id="2ef7" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">上述函数将花费O(n)时间和O(1)空间。换句话说，执行功能<code class="fe nd ne nf ng b">sum_func</code>所需的内存是恒定的。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="cc76" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用大O符号计算时间复杂度</h2><p id="7d97" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">现在回到时间复杂性，重要的是要强调大O符号与所讨论算法的实际执行时间并不对应的事实。例如，O(n)的算法实际上可能比O(1)的算法更快。因此，我们可以说<strong class="ly iv">大O用于描述相对于输入大小</strong>的增长率。</p><p id="1011" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这就是我们在计算时间复杂度时，并不真正关注常数的主要原因。在最开始，我们讨论了数学背景下的渐近分析。</p><blockquote class="nq nr ns"><p id="eef1" class="lw lx nb ly b lz mp jv mb mc mq jy me nt mr mg mh nu ms mj mk nv mt mm mn mo in bi translated">如果<strong class="ly iv"> <em class="iu"> f (n) = n⁴ + 4n + 10 </em> </strong>并且数字<em class="iu"> n </em>非常大，那么术语<strong class="ly iv"> <em class="iu"> 4n </em> </strong>与术语<strong class="ly iv"><em class="iu"/></strong>相比将无足轻重，而<strong class="ly iv"> <em class="iu"> n </em> </strong>对常数<strong class="ly iv"> 10 </strong>没有影响。因此，当<em class="iu"> n </em>趋于无穷大时，函数<strong class="ly iv"> <em class="iu"> f(n) </em> </strong>被称为<strong class="ly iv">渐近等价于<em class="iu"> n⁴ </em> </strong>。</p></blockquote><p id="a2a3" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">类似地，在算法渐近分析<strong class="ly iv">中，我们丢弃任何常量值以及无关紧要的项</strong>。</p><p id="5ab7" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">作为一个例子，让我们考虑一个算法的两个版本，它从一个输入列表中计算最小和最大数字。注意，可能有更好的方法来执行相同的操作，但是这个例子的目的是演示一些与Big-O符号相关的概念。</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="2293" class="la lb iu ng b gz nl nm l nn no">def get_min_max(lst):<br/>    """<br/>    Returns the minimum and maximum <br/>    numbers from the input list as a <br/>    tuple in the form (min, max)<br/>    """<br/>    _min = lst[0]<br/>    _max = lst[0]</span><span id="2743" class="la lb iu ng b gz np nm l nn no">    for n in lst[1:]:<br/>        if n &gt; _max:<br/>            _max = n<br/>        if n &lt; _min:<br/>            _min = n</span><span id="81e4" class="la lb iu ng b gz np nm l nn no">    return _min, _max</span></pre><p id="c836" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">因为我们有一个遍历输入列表元素的for循环，所以上面函数的时间复杂度可以用<em class="nb"> O(n) </em>来描述。</p><p id="ad0f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在让我们修改这个方法，使最小和最大数量的计算发生在单独的循环中。</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="8646" class="la lb iu ng b gz nl nm l nn no">def get_min_max(lst):<br/>    """<br/>    Returns the minimum and maximum <br/>    numbers from the input list as a <br/>    tuple in the form (min, max)<br/>    """<br/>    _min = lst[0]<br/>    _max = lst[0]</span><span id="de05" class="la lb iu ng b gz np nm l nn no">    for n in lst[1:]:<br/>        if n &gt; _max:<br/>            _max = n</span><span id="6741" class="la lb iu ng b gz np nm l nn no">    for n in lst[1:]:<br/>        if n &lt; _min:<br/>            _min = n</span><span id="2056" class="la lb iu ng b gz np nm l nn no">    return _min, _max</span></pre><p id="60fa" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在我们有两个独立的(虽然不是嵌套的！)for循环，每个循环的执行时间为O(n)。有人可能会争辩说，这被翻译成O(n + n)，因此O(2n)。回想一下，当用Big-O符号描述时间复杂性时，我们必须消除任何常量和/或无关紧要的项。因此，我们的示例算法的第二个版本的复杂度仍然是O(n ),因为我们只对增长率感兴趣。</p><p id="07af" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">让我们考虑另一个例子，其中一个函数接受一个输入列表，并打印出原始元素和平方元素(我再次警告您，有更好的方法来实现这一点，所以请不要太关注逻辑)。</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="370d" class="la lb iu ng b gz nl nm l nn no">def print_squares(lst):<br/>    for a in lst: <br/>        print(a)</span><span id="0153" class="la lb iu ng b gz np nm l nn no">    for a in lst:<br/>        for b in lst:<br/>            print(a * b)</span></pre><p id="c6a7" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">所以我们有一个for循环，它简单地遍历输入列表的元素，并打印出每一个元素，然后我们有两个嵌套循环。</p><p id="c13d" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">前一个表达式需要O(n)时间，后一个表达式由于两个嵌套循环需要O(n)时间。同样，有人会认为时间复杂度是O(n + n ),但鉴于我们只对增长率感兴趣，我们必须去掉任何无关紧要的项，因此我们最终的时间复杂度是O(n)。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="f485" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">增长率</h2><p id="219a" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">下面列出了大多数时候用来描述算法的时间和空间复杂性的标准增长率。</p><ul class=""><li id="13fb" class="nw nx iu ly b lz mp mc mq lj ny ln nz lr oa mo ob oc od oe bi translated">对数:<em class="nb"> O(log n) </em></li><li id="807d" class="nw nx iu ly b lz of mc og lj oh ln oi lr oj mo ob oc od oe bi translated">线性:<em class="nb"> O(n) </em></li><li id="d69d" class="nw nx iu ly b lz of mc og lj oh ln oi lr oj mo ob oc od oe bi translated">线性算法:<em class="nb"> O(n log n) </em></li><li id="2b07" class="nw nx iu ly b lz of mc og lj oh ln oi lr oj mo ob oc od oe bi translated">二次:<em class="nb"> O(n ) </em></li><li id="f06d" class="nw nx iu ly b lz of mc og lj oh ln oi lr oj mo ob oc od oe bi translated">指数:<em class="nb"> O(c^n) </em>其中<em class="nb"> c </em>是固定值，而<em class="nb"> c &gt; 1 </em></li><li id="3bf1" class="nw nx iu ly b lz of mc og lj oh ln oi lr oj mo ob oc od oe bi translated">阶乘:<em class="nb"> O(n！)</em></li></ul></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了在开发算法时评估时间和空间复杂度的重要性。这可以通过渐近分析来实现，这可以帮助我们使用大O符号来描述性能。</p><p id="253a" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">此外，我们讨论了带有大ω和大θ的大O符号之间的区别，以及在描述算法复杂性时最好、最坏和预期情况的含义。为了演示如何计算时间和空间复杂度，我们还使用了一些示例算法。最后，我们快速浏览了一下最常用的增长率，当涉及到算法的计算空间和时间复杂度时，这些增长率通常涵盖了大多数情况。</p><p id="c519" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">算法中的渐近分析是一个基本且非常重要的话题，每个写代码的人都必须知道。通过理解某些决策如何影响时间和空间复杂性，您最终可以提高代码的质量和性能。此外，如果你想搞定你的下一次面试，那么这是一个你必须仔细修改的话题。有可能你会被要求开发一个算法，而时间和空间复杂度是你在开发时需要考虑的概念。即使您无法实现给定问题的最佳解决方案，您至少应该知道您的解决方案如何执行，以及如何修改它以达到最佳的复杂性时间。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="ok ol gq gs om on"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="oo ab fp"><div class="op ab oq cl cj or"><h2 class="bd iv gz z fq os fs ft ot fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="ou l"><h3 class="bd b gz z fq os fs ft ot fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ov l"><p class="bd b dl z fq os fs ft ot fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kt on"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">相关文章你可能也喜欢</strong></p><div class="ok ol gq gs om on"><a rel="noopener follow" target="_blank" href="/python-linked-lists-c3622205da81"><div class="oo ab fp"><div class="op ab oq cl cj or"><h2 class="bd iv gz z fq os fs ft ot fv fx it bi translated">如何在Python中实现链表</h2><div class="ou l"><h3 class="bd b gz z fq os fs ft ot fv fx dk translated">探索如何使用Python从头开始编写链表和节点对象</h3></div><div class="ov l"><p class="bd b dl z fq os fs ft ot fv fx dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb kt on"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu on"><a rel="noopener follow" target="_blank" href="/multithreading-multiprocessing-python-180d0975ab29"><div class="oo ab fp"><div class="op ab oq cl cj or"><h2 class="bd iv gz z fq os fs ft ot fv fx it bi translated">Python中的多线程和多处理</h2><div class="ou l"><h3 class="bd b gz z fq os fs ft ot fv fx dk translated">深入探讨Python中的多线程和多处理，以及它们与并发性和</h3></div><div class="ov l"><p class="bd b dl z fq os fs ft ot fv fx dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb kt on"/></div></div></a></div></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu on"><a rel="noopener follow" target="_blank" href="/augmented-assignments-python-caa4990811a0"><div class="oo ab fp"><div class="op ab oq cl cj or"><h2 class="bd iv gz z fq os fs ft ot fv fx it bi translated">Python中的扩充赋值</h2><div class="ou l"><h3 class="bd b gz z fq os fs ft ot fv fx dk translated">了解增强赋值表达式在Python中的工作方式，以及为什么在使用它们时要小心…</h3></div><div class="ov l"><p class="bd b dl z fq os fs ft ot fv fx dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="pe l oy oz pa ow pb kt on"/></div></div></a></div></div></div>    
</body>
</html>