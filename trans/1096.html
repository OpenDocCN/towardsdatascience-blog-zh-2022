<html>
<head>
<title>4 Important SQL Concepts for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者的 4 个重要 SQL 概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-important-sql-concepts-for-beginners-51d69f195843#2022-03-21">https://towardsdatascience.com/4-important-sql-concepts-for-beginners-51d69f195843#2022-03-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c65c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们为初学者学习一些重要的 SQL 概念来增强您的查询能力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc66624d98815acf1edcd965d43023e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KjYPZAqEswZpfE1L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由 unsplash.com<a class="ae ky" href="https://unsplash.com/@chrisliverani" rel="noopener ugc nofollow" target="_blank">@克里斯利维拉尼</a>拍摄</p></figure><p id="6d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">QL 是目前最灵活的编程语言之一。随着 1974 年第一次实现，SQL 是一种查询语言，使开发人员能够顺利地处理存储在关系表中的数据。</p><p id="85de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在一个组织中工作，你很有可能会在你公司的报告中发现一些 SQL 代码。为什么？因为应用程序开发人员、数据科学家、数据分析师或云工程师等各种各样的角色都使用 SQL。</p><p id="bc42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL 也非常灵活——您可以将其与 Python、R、Java 和大多数编程语言集成。大多数情况下，如果您的应用程序有一个数据库层，您可能会使用某种类型的 SQL 实现(如 PostGres、MySQL 或 SQLite)与之通信。</p><p id="2956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，<strong class="lb iu">我们将为 SQL 初学者检查 4 个重要概念，它们将帮助你进一步练习和提高这门语言。</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="9323" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">示例数据</h1><p id="d000" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">对于我们的沙盒示例，我们将使用一个名为<code class="fe ni nj nk nl b">companies</code>的表，其中包含不同行业的几个组织的信息。</p><p id="11e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从头开始创建它，以便您也可以在一些 SQL 实现上复制这些示例(我将使用 MySQL，所以请注意，如果您选择其他实现，一些查询子句可能会有不同的语法)。</p><p id="3fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行这段代码，确保创建了一个<code class="fe ni nj nk nl b">sandbox</code>数据库——如果没有，只需执行<code class="fe ni nj nk nl b">CREATE DATABASE SANDBOX;</code></p><p id="cc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码创建了我们的<code class="fe ni nj nk nl b">companies</code>表结构，并将一些数据插入其中:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="ee90" class="nq mm it nl b gy nr ns l nt nu">create table sandbox.companies (<br/> company_name varchar(30),<br/>    industry varchar(30),<br/>    ticker varchar(5),<br/>    market_cap bigint,<br/>    num_employees int<br/>    );</span><span id="4a0f" class="nq mm it nl b gy nv ns l nt nu">insert into sandbox.companies (<br/> company_name, industry, ticker, market_cap, num_employees<br/>    ) values ("Apple","Technology","AAPL", 2621000000, 154000),<br/>    ("L'oreal", "Consumer Goods", "LRLCY", 214272000, 85087),<br/>             ("Intel", "Semiconductors", "INTC", 196323000, 110600),<br/>             ("Novo Nordisk", "Pharmaceutical", "NVO",246022000,45000),<br/>             ("Bayer", "Pharmaceutical", "BAYRY",56833000,99637),<br/>             ("Abbvie", "Pharmaceutical", "ABBV",280506000,50000),<br/>             ("Facebook", "Technology", "FB",552707000,71970),<br/>             ("Johnson &amp; Johnson", "Pharmaceutical", "JNJ",464855000,130000);</span></pre><p id="2a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我们数据的表格形式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/4701e6d15534851be169f5f369157117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*SgiFdcUmyXhqLPh2VyUtQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">公司表-按作者分类的图片</p></figure><p id="1eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将在整个帖子中使用的表格。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d7cc" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">分组数据</h1><p id="7613" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在构建数据管道时，分组和聚合数据是最酷的技能之一。分组数据使您能够完全转换表结构，并基于几个列在原始数据上构建几个聚合。</p><p id="02fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些虚构用例的示例:</p><ul class=""><li id="1431" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">对股票行情自动收录器的每日股票价格进行分组，以了解特定一天的平均价格；</li><li id="004b" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">对商店数据进行分组，以获得每个商店和每个月的总销售额；</li></ul><p id="acc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于用例，对数据进行分组主要有两个目的:</p><ul class=""><li id="2ac0" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><strong class="lb iu">构建数据管道，并为特定需求创建具有聚合数据的定制 ETL</strong>—例如，为仪表板或机器学习算法准备数据。</li><li id="e7d4" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">对数据进行快速统计。</strong></li></ul><p id="4e3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，数据分组是使用<code class="fe ni nj nk nl b">GROUP BY </code> SQL 子句完成的。将<code class="fe ni nj nk nl b">GROUP BY</code>子句与聚合函数结合起来是一个非常强大的 SQL 特性——例如，如果我们想在<code class="fe ni nj nk nl b">companies</code>表中检查每个行业的平均雇员人数，我们只需:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="58ac" class="nq mm it nl b gy nr ns l nt nu">select industry, avg(num_employees) as avg_n_employees<br/>from sandbox.companies<br/>group by industry;</span></pre><p id="57fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意这段代码有多简单——几乎就像我们在交谈一样！</p><blockquote class="ol om on"><p id="cd3a" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">我想从“公司”表中选择行业和雇员人数的平均值，并按行业对数据进行分组。</p></blockquote><p id="89d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生一个结果，其中我们有两列——<code class="fe ni nj nk nl b">industry</code>和<code class="fe ni nj nk nl b">avg_n_employees</code>。SQL 如何计算这个<code class="fe ni nj nk nl b">avg_n_employees</code>？让我给你解释一下原因。</p><p id="f79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的原始表中有 4 家制药公司:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/98baed792d96d1a31da38c26de1be888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*UEgSjjK1HQyCPOpP51NRtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">过滤查询-按作者分类的图像</p></figure><p id="a724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该行业的平均雇员人数将为:<code class="fe ni nj nk nl b">(45000+99637+50000+130000)/4</code>，大约为 81.159 人。这个数字代表<strong class="lb iu"> <em class="oo">“制药行业公司的平均员工人数”。</em>T19】</strong></p><p id="276e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切正确，我们的<code class="fe ni nj nk nl b">GROUP BY</code>输出必须包含制药行业行的相同数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/ea223913143fdd94dee5b045acf958fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*ErrIStImU7lE9ausNBoRnQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">按公司列出的平均员工人数-按作者列出的图片</p></figure><p id="e0ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，没错！对于其他行业，SQL 自动计算相同的公式— <strong class="lb iu">由于半导体和消费品在我们的</strong> <code class="fe ni nj nk nl b"><strong class="lb iu">companies</strong></code> <strong class="lb iu">表中只有公司，所以这些行业的员工人数值与</strong> <code class="fe ni nj nk nl b"><strong class="lb iu">n=1</strong></code> <strong class="lb iu">中的公司相同。</strong></p><p id="8938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷！我们还可以用<code class="fe ni nj nk nl b">GROUP BY</code>做什么花样？另一个想法是计算每个行业的公司数量——使用<code class="fe ni nj nk nl b">count()</code>函数:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="e669" class="nq mm it nl b gy nr ns l nt nu">select industry, count(company_name) as nb_companies<br/>from sandbox.companies<br/>group by industry;</span></pre><p id="19d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/7b7986df753c3626666272ee54ebe9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*7Uy1h3VtIazAkKqS8uNx9w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个行业的计数-按作者分类的图片</p></figure><p id="027f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 SQL 中，<code class="fe ni nj nk nl b">GROUP BY</code>子句通常位于<code class="fe ni nj nk nl b">FROM</code>之后(如果您没有任何<em class="oo">连接</em>或<em class="oo">过滤器</em>)。如果<em class="oo">连接</em>或<em class="oo">过滤器</em>存在，这些子句将为我们查询的后续部分推送<code class="fe ni nj nk nl b">GROUP BY</code>子句。只要记住他们总是需要跟在<code class="fe ni nj nk nl b">FROM</code>从句后面！</p><p id="0c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的<a class="ae ky" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"> SQL 课程的第一部分了解更多关于<code class="fe ni nj nk nl b">GROUP BY</code>子句的知识。</a></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6b05" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">连接</h1><p id="11a7" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">SQL 中另一个非常重要的概念是表连接。连接主要是为了将多个表合并成一个表。它们是 SQL 中需要掌握的关键方面之一，连接的效率(当与索引结合时)是开发人员可能更喜欢使用该语言来构建数据管道的主要原因之一。</p><p id="f78c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">所以..依赖于连接的最常见的 SQL 用法是什么？</strong></p><p id="852a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个主要的例子是:</p><ul class=""><li id="cd69" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">在关系数据模型中连接数据；</li><li id="82e3" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">为数据集市构建新的组合表；</li></ul><p id="2e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接有多种形式。在这一部分，我将解释一些最常见的。</p><p id="cded" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的沙盒示例，我们需要一个额外的表与我们的<code class="fe ni nj nk nl b">companies </code>表交叉。让我们创建一个包含每个行业市场规模的新表:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="8c76" class="nq mm it nl b gy nr ns l nt nu"># Create industries data<br/>create table sandbox.industries (<br/>    industry varchar(30),<br/>    market_size bigint<br/>    );<br/> <br/># Insert some industries data<br/>insert into sandbox.industries (<br/> industry, market_size<br/>    ) values ("Technology",5200000000),<br/>    ("Consumer Goods", 2000000000),<br/>             ("Semiconductors", 6000000000),<br/>             ("Banking",7500000000);</span></pre><p id="f895" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe ni nj nk nl b">industries</code>表如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/459fd3dfcc5b4774b4cff3a9be254b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*MCzYu7kQdN_XksYkxwQklg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">行业表-按作者分类的图片</p></figure><p id="daee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意该表的两点:</p><ul class=""><li id="195d" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><strong class="lb iu">这里有一个行业(银行业)不在公司表上；</strong></li><li id="8670" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><strong class="lb iu">有一个行业在公司表中，但不在</strong> <code class="fe ni nj nk nl b"><strong class="lb iu">industries</strong></code> <strong class="lb iu">(制药)中。</strong></li></ul><p id="d2df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于现实生活中的数据，数据库中缺少一些信息是很常见的情况。这个小细节对于理解我们将要做的不同连接是很重要的。</p><p id="616e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们执行一个<em class="oo">内部连接</em>——假设我想将<code class="fe ni nj nk nl b">market_size</code>列添加到<code class="fe ni nj nk nl b">companies</code>表中——例如，对于特定行业中的每家公司，我希望有一个包含市场规模信息的列。我可以用一个连接来做到这一点！</p><p id="928e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们学习一下<code class="fe ni nj nk nl b">INNER JOIN</code>的语法:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="e931" class="nq mm it nl b gy nr ns l nt nu">select left.*, right.market_size<br/>from sandbox.companies as left<br/>inner join sandbox.industries as right<br/>on left.industry = right.industry;</span></pre><p id="22a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于连接，关键是定义将被用作表之间的连接器<em class="oo">T21 的列。在我们的例子中，我们使用<code class="fe ni nj nk nl b">industry</code>列，因为这是我们在<em class="oo">左</em>和<em class="oo">右</em>表上都有的列。关于该查询的一些重要细节:</em></p><ul class=""><li id="b1ef" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">我们使用别名来引用表格。左边是公司表，右边是行业表。</li><li id="04da" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">子句中的<em class="oo">声明了将用于连接两个表的列——通常称为<em class="oo">连接键</em>。</em></li><li id="1312" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><em class="oo">左。* </em>意味着我们要从<em class="oo">公司</em>表中选择所有列。</li></ul><p id="1f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ni nj nk nl b">INNER</code>关键字只返回在连接的两个表中都存在<em class="oo">键</em>的行。例如，由于制药公司不在行业表中，这些公司将从结果中排除:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/10bc53423571a451bb186b82ec54d111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z9XnU9wmkKM2W3wbKgHcAg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内部连接结果-按作者排序的图像</p></figure><p id="6f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，您可能希望覆盖这一点，例如，当行业数据不可用时，将 market_size 设为<code class="fe ni nj nk nl b">NULL</code>—这可以通过<code class="fe ni nj nk nl b">LEFT JOIN</code>来实现，这意味着您希望将表中的每一行都放在左侧<em class="oo">和右侧</em>上，而不管它是否出现在右侧<em class="oo">和</em>上:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="ec4d" class="nq mm it nl b gy nr ns l nt nu"># Left join example<br/>select left.*, right.market_size<br/>from sandbox.companies as left<br/>left join sandbox.industries as right<br/>on left.industry = right.industry;</span></pre><p id="b370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法和<code class="fe ni nj nk nl b">INNER JOIN</code>超级相似——真的很酷。唯一的区别是我们现在用<code class="fe ni nj nk nl b">LEFT JOIN</code>作为连接从句。上述查询的结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/5f80605702407f7e2263cb8c135a19eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSmPN2da-OvN7JpQRAHTZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">左连接结果-按作者排序的图像</p></figure><p id="7250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式，你不会丢失公司的数据，即使你没有更多关于这个行业的信息。</p><p id="59c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用<code class="fe ni nj nk nl b">RIGHT JOIN</code>进行相反的操作:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="6dd0" class="nq mm it nl b gy nr ns l nt nu"># Right join example<br/>select left.*, right.market_size<br/>from sandbox.companies as left<br/>right join sandbox.industries as right<br/>on left.industry = right.industry;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/ff5afe7453227f88979d36907221a9be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8yhVnd6J4qRUtvsPD3kSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">右连接结果-按作者排序的图像</p></figure><p id="9003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，现在我们有了银行业的市场规模，所有其他行都显示为<code class="fe ni nj nk nl b">NULL</code>。奇怪的是，我们没有“银行”行的<code class="fe ni nj nk nl b">industry</code>—<strong class="lb iu">为什么？</strong>因为在查询中我们从表<code class="fe ni nj nk nl b">left</code>(我们的公司表)中选择了行业。</p><p id="e2e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，连接是非常酷的概念，它使我们能够连接不同的表。我们没有涉及的其他连接是<code class="fe ni nj nk nl b">OUTER</code>或<code class="fe ni nj nk nl b">FULL</code>，但是您可以在掌握<code class="fe ni nj nk nl b">INNER</code>、<code class="fe ni nj nk nl b">RIGHT</code>和<code class="fe ni nj nk nl b">LEFT</code>之后学习它们。</p><p id="d8bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的<a class="ae ky" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"> SQL 课程的第三部分了解更多关于<code class="fe ni nj nk nl b">JOIN</code>子句的知识。</a></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="fc0f" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">子查询</h1><p id="79d9" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">子查询是另一个 SQL 特性，它将使您的查询非常灵活。</p><p id="f632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用子查询，您可以嵌套<em class="oo">查询</em>，并直接使用<em class="oo">查询结果</em>作为其他查询的输入。这听起来令人困惑，但实际上很简单！</p><p id="3e3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们创建一个表，只过滤我们的<code class="fe ni nj nk nl b">companies</code>表中的制药公司:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="22d3" class="nq mm it nl b gy nr ns l nt nu">select * <br/>from sandbox.companies<br/>where industry = 'Pharmaceutical';</span></pre><p id="e6b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该查询将产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ff3ee79c8a819b67098cdaf22bb27a26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*T-wZVI5TakXSpEIYrr9Tfw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子查询结果-按作者排序的图像</p></figure><p id="e691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">如果我们现在想从这个查询结果中获取最大数量的</strong> <code class="fe ni nj nk nl b"><strong class="lb iu">num_employees</strong></code> <strong class="lb iu">怎么办？</strong>当然，我们可以在<code class="fe ni nj nk nl b">where</code>上的查询中直接使用计算列，但是我们也可以使用子查询，例如:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="1005" class="nq mm it nl b gy nr ns l nt nu"># Subqueries Example<br/>select max(subtable.num_employees) as max_n_employees <br/>from (<br/> select * <br/> from sandbox.companies<br/> where industry = 'Pharmaceutical'<br/>    ) as subtable;</span></pre><p id="31da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以把子查询想象成在<code class="fe ni nj nk nl b">FROM</code>子句中替换一个物理表——SQL 的灵活性使我们能够直接在同一个<code class="fe ni nj nk nl b">from</code>子句中使用任何查询结果。这有几个优点:</p><ul class=""><li id="5988" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">当我们想要进行两个连续的 group by 操作时，这一点尤其重要；</li><li id="4baf" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">当您想要构建数据管道而不实际创建表时，这很有用。</li></ul><p id="0ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在我的<a class="ae ky" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"> SQL 课程的第五部分了解更多关于子查询的知识。</a></p><h1 id="e2fe" class="ml mm it bd mn mo pa mq mr ms pb mu mv jz pc ka mx kc pd kd mz kf pe kg nb nc bi translated">其中=/=拥有</h1><p id="5d82" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">初学者在开始用 SQL 编码时面临的一个常见问题是理解<code class="fe ni nj nk nl b">WHERE</code>和<code class="fe ni nj nk nl b">HAVING</code>子句之间的区别。</p><p id="407c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要区别在于<code class="fe ni nj nk nl b">WHERE</code>在任何<code class="fe ni nj nk nl b">GROUP BY</code>应用之前应用，而<code class="fe ni nj nk nl b">HAVING</code>在分组之后应用。让我们检查以下两个查询:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="a624" class="nq mm it nl b gy nr ns l nt nu"># Query with WHERE<br/>select industry, avg(market_cap) as market_cap<br/>from sandbox.companies<br/>where market_cap &lt; 1000000000<br/>group by industry;</span><span id="e5a6" class="nq mm it nl b gy nv ns l nt nu"># Query with HAVING<br/>select industry, avg(market_cap) as market_cap<br/>from sandbox.companies<br/>group by industry<br/>having market_cap &lt; 1000000000;</span></pre><p id="35c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会有两种不同的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/c94ccb567ea70048396ab7bcaf55bee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*yudonvVQm8YLeZ8okkuAjw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 Where 的查询结果-按作者排序的图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/15d6f78d073acccca6f47603a14e6bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*WF1EsKOtR1qCWSka1Qy5cQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者使用 Having-Image 查询的结果</p></figure><p id="51d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<em class="oo">行业</em>技术的变化。这是为什么呢？第一个查询翻译成下面的句子:</p><blockquote class="ol om on"><p id="1e08" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">“我想按行业选择平均市值，但排除市值超过 1 万亿的公司”</p></blockquote><p id="b57d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为<code class="fe ni nj nk nl b">WHERE</code>总是在分组前应用。在这种情况下，<code class="fe ni nj nk nl b">Apple</code>在计算之前被移除了<strong class="lb iu">——因此唯一进入平均值计算的公司是<code class="fe ni nj nk nl b">Facebook</code>，因为它是唯一与 where 子句中的筛选器匹配的技术公司。</strong></p><p id="aa97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，对于第二个查询，我们执行以下操作:</p><blockquote class="ol om on"><p id="90a9" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">“我想按行业选择平均市值，但排除平均市值超过 1 万亿的行业”</p></blockquote><p id="c6dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到区别了吗？这是因为<code class="fe ni nj nk nl b">HAVING</code>子句在分组完成后起作用。在这种情况下，<code class="fe ni nj nk nl b">Apple</code>进入计算，使科技行业的平均价值超过 1 万亿市值。由于平均值超过 1 万亿，我们从结果中过滤掉了它，我们不再有关于<code class="fe ni nj nk nl b">HAVING</code>条款的技术争论。</p><p id="8aa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我的<a class="ae ky" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"> SQL 课程的第一部分了解更多关于<code class="fe ni nj nk nl b">WHERE</code>和<code class="fe ni nj nk nl b">HAVING</code>子句的知识。</a></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="c90a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完事了。感谢你花时间阅读这篇文章。当涉及到操作数据时，SQL 具有很少语言能够比拟的灵活性。它非常容易掌握，可能是不同数据领域角色(分析师、科学家、工程师等)使用最广泛的语言。).</p><p id="24c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们探索了一些很酷的 SQL 概念，它们将帮助初学者提高查询的灵活性——还知道其他类似的概念吗？写在下面的评论里吧！</p><p id="359c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="oo">我在</em></strong><a class="ae ky" href="https://www.udemy.com/course/sql-for-absolute-beginners/?referralCode=23E560A160F7202E026F" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="oo">Udemy</em></strong></a><strong class="lb iu"><em class="oo">上开设了一门关于从零开始学习 SQL 的课程，我在其中深入探讨了这些概念以及更多内容——这门课程适合绝对的初学者，我希望您能在我身边！</em> </strong></p></div></div>    
</body>
</html>