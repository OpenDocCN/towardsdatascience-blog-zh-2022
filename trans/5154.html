<html>
<head>
<title>Refactoring: Make this code readable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构:使代码可读</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/refactoring-make-this-code-readable-59b998015218#2022-11-17">https://towardsdatascience.com/refactoring-make-this-code-readable-59b998015218#2022-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq jr js"><p id="e82b" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">"编程时，永远遵循露营规则:永远让代码库比你发现它时更健康."马丁·福勒[2]。</p></blockquote><p id="689b" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">本文是为开发人员、技术领导者或好奇的人编写的，他们希望了解如何在给定的代码库上节省时间，如何使开发过程更快，如何让开发人员感觉更好，并使他们能够维护一个健康和敏捷的代码库。重构是软件工程中的嵌入活动，需要技能和经验。我写了这篇文章，作为我自己经验的一个简短总结，并得到了《重构》[2]和《干净手艺》[1]这两本书的支持。</p><p id="1548" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">我已经解释了为什么重构是绝对必要的，并且应该是所有开发活动的一部分，并且列出了它提供的许多好处。然后我解释了重构时要达到的目标，最后解释了重构常见模式的内容和方法。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/6c646dd7d71c582822722d7f1047d526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7iVn8B0ImtuwJ0zH"/></div></div><p class="lh li gj gh gi lj lk bd b be z dk translated">照片由来自 Unsplash 的<a class="ae ll" href="https://unsplash.com/@andersjilden" rel="noopener ugc nofollow" target="_blank"> andersjilden </a>拍摄</p></figure><h1 id="c573" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重构实现一个好的设计</h1><p id="82ac" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">重构旨在改进代码设计。一个好的设计避免管理僵化、不灵活和脆弱的代码库。当代码基础是如此的不可行，以至于测试和重构都是缓慢的和避免的。这是垂死的软件。开发人员总是需要在代码中实现新的特性。变更的成本不应该超过变更的预期范围。</p><p id="25db" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">好的设计遵循四条规则[1]:</p><ol class=""><li id="ac84" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr mu mv mw mx bi translated">没有回归，测试通过</li><li id="8b45" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr mu mv mw mx bi translated">揭示意图(代码表现力)</li><li id="ee04" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr mu mv mw mx bi translated">无重复</li><li id="1f56" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr mu mv mw mx bi translated">小(尽可能少的类，尽可能少的方法)。</li></ol><h2 id="1cc7" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">测试:</h2><p id="b7aa" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">好的设计有好的测试覆盖率。代码设计和代码覆盖率有什么关系？原因是可测试代码是解耦代码。被测试的代码必须被设计成可测试的。在 TDD 框架中，编写代码先于编写测试。</p><p id="fab3" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">良好的测试覆盖率也有助于随着时间的推移改进设计。</p><h2 id="938a" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">揭示意图:</h2><p id="2613" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">代码应该是不言自明的。每一个表达代码“做什么”的注释都应该用一个更有表现力的代码来代替。我们只对代码的“为什么”进行评论。变量、函数和类型的名称都有很深的描述性。考虑像写故事一样写代码。首先，角色应该在故事开始前被描述。然后，故事应该让读者明白，直接与已经定义好的人物联系起来，最后，故事应该逻辑清晰。如果一个变量或一个方法的名字不清楚，阅读时就要浪费时间。</p><p id="dace" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">作者在故事中唯一没有的是他为什么选择这样写故事。这是我们接受使用注释的地方。</p><p id="345f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">测试给出了代码的上下文及其背后的意图。这就是为什么总的来说，代码和测试是系统的每个元素是什么，系统做什么，以及如何使用系统的表达。</p><h2 id="3f98" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">小:</h2><p id="91f7" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">YAGNI 框架:“如果你不需要它怎么办”</p><p id="0ed5" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">好的代码也能解放你的时间。如果代码的含义模糊不清，所有未来的代码用户都会问你问题，会误解你函数的含义，浪费他们和你的时间去理解函数。为你未来的自己和其他人节省时间，让他们第一次就写对。</p><p id="bf80" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">此外，如果您不在，团队应该仍然能够重用您的工作并推进项目。</p><p id="0de8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">记住这一点，现在我们可以开始重构了。</p><h1 id="0279" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">我真的需要重构吗？</h1><p id="ae3a" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">在开始重构之前，你需要一个重构的目标作为关注的方向。</p><h2 id="f84c" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">为什么我们应该重构？</h2><ul class=""><li id="a310" class="mp mq it jw b jx mk kb ml ks np kt nq ku nr kr ns mv mw mx bi translated">一些项目需要实验性的代码，实现起来又快又脏。在证明代码可以工作之后，需要对代码进行结构化，以便将来可以维护和扩展。</li><li id="d96b" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">需求已经改变，或者我们对问题的理解已经发展，现有的代码设计不再满足我们的需求。重构改进了软件开发过程中任何阶段的代码设计。</li><li id="df30" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">重构提高了代码的可读性。写代码的时候，有两个步骤:让代码工作，然后让代码可读。同时制作这两个需要很多经验和技巧。对我来说，我确信这将是两个不同的阶段。在使代码在功能上起作用之后(代码符合验收标准并显示出预期的行为)，我需要确保代码的未来读者不会花费我已经花费在理解代码行为上的时间。<strong class="jw iu">计算机能理解肮脏的代码，但人类不能。</strong></li><li id="8af2" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">重构有助于发现 bug。当代码存在并工作时，我们大多数人不会花时间去深入阅读它。重构是一个再次仔细阅读代码并记住代码编写时所做的假设的机会。</li><li id="081d" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">重构允许简单地进行分析，以便在以后找到性能瓶颈。重构允许将来对功能进行优化，比如它们可以很好地解决当前的需求。如果代码结构良好且清晰，就更容易找到代码的瓶颈并进行优化。</li><li id="aa67" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">重构的代码允许更快的迭代。当代码库很清晰，组件也很好理解时，添加新特性就很容易了。如果代码库不受控制地成长为一个分支和线条的怪物，开发速度就会受到损害。开发者需要花时间<em class="jv">记住</em>代码每次是如何工作的。除了干净的代码和良好的文档，重构是关于理解代码并将这些知识放回代码中。</li><li id="4477" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">重构的代码可以节省时间和代码行。添加功能并不意味着添加代码，而是改变现有的代码以包含这种新的行为。当你做一些类似于现有代码的事情时，这一点尤其明显。团队中的每个开发人员都应该推动更多的重构，而不是太少。它使代码库更健康，开发更快。重构并没有减慢这个过程，而是总体上加快了这个过程。这为公司带来了无可争议的经济收益，这是所有领导者都应该追求的。关于节省时间，重构可能是一个兔子洞，所以这项活动需要时间限制和范围。</li><li id="0976" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">重构的代码允许更好的模块化(只需要理解程序的一小部分就可以修改程序的能力)。为了获得这种模块化，我需要确保相关的软件元素被分组在一起，并且它们之间的链接易于找到和理解。</li></ul><blockquote class="jq jr js"><p id="f5a3" class="jt ju jv jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr im bi translated">减少模块之间相互了解的需要有助于减少我在改变一些东西时需要向我的大脑输入的信息——我的大脑没有以前那么大了(尽管这并没有说它的容器有多大)。[2]</p></blockquote><h2 id="d162" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">什么时候应该重构？</h2><p id="d5e5" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">实际上一直都是。</p><ul class=""><li id="b1cd" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">开始编码前</li><li id="1f88" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">在编码期间</li><li id="6f36" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">在编码之后</li></ul><p id="3298" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">重构的最佳时间是在我向代码库添加新特性之前[2]。这给了我时间来看看我们是否能改进代码结构。如果函数中的参数是硬编码的，我宁愿将参数作为实参，而不是复制/粘贴带有不同硬编码参数的函数。开始编码前的重构应该是自然而然的。因为我们需要阅读代码库，以便在开始工作之前理解它的功能。当阅读代码时，如果我看到一些小的和最小的改进来帮助下一个读者(分解功能，添加文档等)，我应该在开始工作之前实现它们。一旦代码被清理，我们就可以更清楚地看透它。重构不仅是为了帮助未来的用户，也是为了帮助现在的用户。</p><p id="935c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">编码过程中的重构也是非常自然的。当我们让特性工作时，我们需要让它反复可读。</p><p id="9a7d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">最后，在推送一个新的拉请求之前，我们应该确保我们的代码被清理和格式化。虽然目前在现代代码编辑器(如 VSCode)中格式化是自动的，但变量命名仍然取决于开发人员。变量名应该易于理解，代码对用户来说应该像一个童话故事。每一个变量的引入，故事的逻辑性，几乎不会让读者感到惊讶。</p><p id="3eab" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">尤其是现在，在同一个代码库中有大量质量不一的代码，重构有助于一起改进代码库。</p><h2 id="260b" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">什么时候不应该重构:</h2><ul class=""><li id="edad" class="mp mq it jw b jx mk kb ml ks np kt nq ku nr kr ns mv mw mx bi translated">大多数时候，在预见未来需求时，没有必要为了一般化而重构(记住 YAGNI 的概念:“你不会需要它”)。</li></ul><p id="ecab" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">重构隐含地要求你比在你之前写代码的人更好地了解你需要解决的当前问题。</p><h1 id="d7e7" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重构伴随着测试</h1><p id="d964" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">测试也有很多目的。它通过确保类的行为符合预期来防止错误，并帮助读者理解代码应该做什么和不应该做什么(不要忘记测试您的异常和边缘情况)。最后，测试对于健康的重构过程是必要的。当重构时，我们寻求在保持相同行为的同时改变代码结构。一个测试应该遵循三个阶段:<em class="jv">设置、练习、验证</em> [2]。</p><p id="7739" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">在重构之前，我们需要确保测试存在并且测试通过。测试应该运行得很快，不到一分钟。然后你可以做著名的循环重复:</p><ul class=""><li id="a0c6" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">重构</li><li id="eed0" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">运行测试</li><li id="fae4" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">提交更改</li></ul><p id="61ad" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">几乎同样频繁地进行更改，否则，一旦一个测试被破坏，就很难知道哪个更改修改了代码的行为。</p><p id="a94f" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">所以这个重构循环“重构、测试、提交”应该在非常小的代码块上完成。我们都会犯错误，我们可能会犯错误。如果在修改了 500 行代码后测试失败，我们希望能轻松地发现错误，我将很难找到错误在哪里。</p><p id="187e" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">我喜欢布雷特·斯拉特金提出重构的先决条件:</p><ul class=""><li id="2241" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">快速测试</li><li id="f29f" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">源代码控制</li><li id="d271" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">愿意犯错误</li></ul><h1 id="cfaf" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重构</h1><p id="9224" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">我们已经看到重构有许多潜在的原因。然而，程序员有更多的事情要做，不能把自己投入到不必要的活动中。然后，我们需要对重构的正确信号非常敏感。在这一节中，我将描述我最喜欢的重构信号。我需要重构并做出一些改变的信号。变化总是遵循三个主要阶段:</p><ul class=""><li id="ee8c" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">试着理解发生了什么</li><li id="21bb" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">将洞察力移回到代码中</li><li id="d175" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr ns mv mw mx bi translated">继续理解，在一个有益的正向循环中添加边界。</li></ul><p id="c044" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">现在让我们深入研究一下。</p><h2 id="6668" class="nd ln it bd lo ne nf dn ls ng nh dp lw ks ni nj ma kt nk nl me ku nm nn mi no bi translated">重构范围:何时开始，何时停止</h2><ul class=""><li id="c093" class="mp mq it jw b jx mk kb ml ks np kt nq ku nr kr ns mv mw mx bi translated">不明代码</li></ul><p id="eb55" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">当你不得不阅读代码，但代码的故事不清楚。没有的函数、模块和变量不是好名字，不能清楚地表达它们应该做什么。</p><ul class=""><li id="feb2" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">重复代码</li></ul><p id="af65" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">当代码在不同的部分被重用时，我们从中提取一个函数，并调用这个函数。</p><ul class=""><li id="c8f5" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">长函数</li></ul><p id="412c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">将长函数分解成更小的函数。您可以使用空格、注释段落或循环来轻松分解它。</p><ul class=""><li id="6b82" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">大班</li></ul><p id="62b6" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">当一个类变得太大时，可以尝试提取另一个类。取那些放在一起的变量，它们共享后缀或前缀。这个提取的类与最初的大类的关系可以是继承或组合。试着消除潜在的冗余。</p><ul class=""><li id="cc42" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">长参数列表</li></ul><p id="6cfd" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">通过使用类或 dataclasses 对象作为参数可以避免这种情况。然后我们用一个查询替换这个参数。例如，如果多个函数同时使用变量“开始日期”和“结束日期”作为参数。您可以使用变量“日期范围”来代替。将数据分组到新的结构中使得参数之间的关系更加明确。</p><ul class=""><li id="4b9a" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">发散性变化和散弹枪手术[2]</li></ul><p id="06d2" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">Martin Fowler 在他的书《重构》中称之为“不同的变化”,当一个模块经常因为不同的原因以不同的方式改变时，就会发生这种变化。大多数时候，代码中容易改变的部分应该被分离出来，这样我们就可以避免为了接口而改变一个模块。它可以将数据加载到一个模块中，并在另一个模块中处理数据。</p><p id="065c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">“猎枪手术”是相反的模式，当一个变化需要在许多不同的类中进行许多小的编辑。在这种情况下，将小的编辑统一到一个函数中，或者找到一个通用的模式来提取和调用，对于减少编辑时间非常有用。</p><ul class=""><li id="8068" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">内置类型的过度使用</li></ul><p id="8598" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">对于具体用法，使用封装了特定领域(温度、坐标系、货币)逻辑的对象比原语类型更清晰。</p><ul class=""><li id="c83d" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">一长串“如果”语句</li></ul><p id="0088" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">一长串的条件可能会被多态性所取代。条件可以封装在具有共享方法的不同类中(例如，从抽象类继承)。我们可以调用来自共享相同父类的一族类的实例(然后是抽象方法)，而不是调用一系列 if。</p><ul class=""><li id="f69d" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">将循环改为管道</li></ul><p id="0e1a" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">这是我收到的最违背直觉的重构建议之一。将循环重构为连续的管道阶段。具有多重职责的循环可能会令人困惑。可以使用内置的“过滤器”、“映射”、“简化”(参见<a class="ae ll" href="https://book.pythontips.com/en/latest/map_filter.html" rel="noopener ugc nofollow" target="_blank">链接</a>中的示例)或行列表理解来重构它们。这允许将一个循环分解成多个循环(如果有必要，可以在弄清楚代码后进行性能优化)，这些循环可读性更强，调试更容易。</p><ul class=""><li id="02dc" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">消除不必要的复杂性</li></ul><p id="faeb" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">它可以合并两个变得常见的类。经常会发生这样的情况，抽象类不再是必需的(只有一个子类)。删除当前不需要的过于通用的类。您还可以从代码库中删除未使用的(死的)代码。</p><ul class=""><li id="9793" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">分担责任</li></ul><p id="9e6c" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">一个功能应该承载一个责任。当代码试图做两个(或者更多！)不同的东西，要尝试拆分成不同的功能。越容易将功能分成两个连续的阶段。然后，我们可以专注于单独理解每个功能，而不必同时理解周围的其他功能。</p><p id="a7d1" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">对于变量也是如此，如果您使用相同的变量来保存不同的值，那么最好使用两个不同的变量。它经常与占位符变量一起出现，如<code class="fe nt nu nv nw b">tmp</code>、<code class="fe nt nu nv nw b">var</code>、<code class="fe nt nu nv nw b">res</code>等。</p><pre class="kw kx ky kz gt nx nw ny nz aw oa bi"><span id="cb74" class="nd ln it nw b gy ob oc l od oe"># Before<br/>def transform_img(img, angle=90):<br/>    img = rgb_to_binary(img)<br/>    img = rotate_img(img, angle)<br/>    return img</span><span id="7fa2" class="nd ln it nw b gy of oc l od oe"># After<br/>def transform_img(img, angle=90):<br/>    binary_img = rgb_to_binary(img)<br/>    rotated_binary_img = rotate_img(binary_img, angle)<br/>    return rotated_binary_img</span></pre><ul class=""><li id="a53f" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">包装</li></ul><p id="f435" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">封装意味着模块需要了解系统的其他部分。</p><pre class="kw kx ky kz gt nx nw ny nz aw oa bi"><span id="163f" class="nd ln it nw b gy ob oc l od oe">intersection_coordinates = road_edge.geo.coordinates</span></pre><p id="1cee" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">可以替换为</p><pre class="kw kx ky kz gt nx nw ny nz aw oa bi"><span id="9f9d" class="nd ln it nw b gy ob oc l od oe">intersection_coordinates = road_edge.coordinates</span><span id="0276" class="nd ln it nw b gy of oc l od oe">class RoadEdge:<br/>    @property<br/>    def coordinates(self):<br/>        return self.geo.coordinates</span></pre><p id="cff8" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">这将有助于将来对类<code class="fe nt nu nv nw b">RoadEdge</code>的任何修改，并减少所有代码的编辑次数。客户端代码不需要知道类的 geo 属性来调用坐标。</p><p id="2bb7" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">我们还使用封装将可变记录转换成对象:</p><pre class="kw kx ky kz gt nx nw ny nz aw oa bi"><span id="a00d" class="nd ln it nw b gy ob oc l od oe"># Before<br/>image_sample = {"image": image_array, "dataset": "SatelliteDataset_01", "resolution": 0.5}</span><span id="37d0" class="nd ln it nw b gy of oc l od oe"># After<br/>@dataclass<br/>def ImageSample:<br/>    image_array: np.ndarray<br/>    dataset: str<br/>    resolution: float<br/>image_sample = ImageSample(image_array, "SatelliteDataset_01", 0.5)</span></pre><ul class=""><li id="bd03" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">移动方法</li></ul><p id="c413" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">当一个函数从另一个上下文中引用的元素多于它当前所在的上下文时，这是将这个函数移到另一个上下文的标志。</p><p id="d516" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">这也可能跨类继承发生。如果子类从其父类继承了一个他们不需要的方法，这意味着这些方法可以向下移动到唯一使用这个方法的兄弟类。</p><p id="0b0d" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">您还可以移动语句，例如相互关联的事物，使其一起出现。如果几行代码引用相同的元素，它们应该一个接一个地出现在代码中，而不是与访问其他数据结构的代码行混杂在一起。滑动语句的一个常见情况是变量声明和变量的使用应该总是尽可能接近。</p><ul class=""><li id="a76c" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">使用多态性</li></ul><p id="6070" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">如果一族类使用相同的接口，它们可以互相替换。</p><ul class=""><li id="e3f5" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr ns mv mw mx bi translated">提取代码</li></ul><p id="10b0" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">从代码块中提取一部分外部代码并重命名。它可以是:</p><ol class=""><li id="0675" class="mp mq it jw b jx jy kb kc ks mr kt ms ku mt kr mu mv mw mx bi translated">提取变量</li><li id="a48d" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr mu mv mw mx bi translated">提取函数</li><li id="746f" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr mu mv mw mx bi translated">使用函数中的变量</li><li id="3341" class="mp mq it jw b jx my kb mz ks na kt nb ku nc kr mu mv mw mx bi translated">从代码中提取一个类</li></ol><p id="46c9" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">提取函数提高了可读性，类使测试变得容易，因为我们可以通过测试产生它们的函数来测试中间结果。</p><p id="6132" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">从代码块中提取函数可能是主观的。我应该将代码提取到多个连续的函数中，还是让逻辑在 50 行连续的代码中流动？有些人说函数应该适合计算机屏幕，有些人说应该只提取重用的函数，否则就让代码内联。当代码变得不清楚它在做什么时，提取函数也是有意义的。一个函数是代码故事中的一章，故事应该清晰易读。变量也是一样，我们可以把复杂的计算分解成中间变量。最后，由你来决定什么是最清楚的。</p><h1 id="dd70" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">参考资料:</h1><p id="1692" class="pw-post-body-paragraph jt ju it jw b jx mk jz ka kb ml kd ke ks mm kh ki kt mn kl km ku mo kp kq kr im bi translated">[1]干净的手工艺，塞西尔马丁。</p><p id="7253" class="pw-post-body-paragraph jt ju it jw b jx jy jz ka kb kc kd ke ks kg kh ki kt kk kl km ku ko kp kq kr im bi translated">[2]《重构》，马丁·福勒，肯特·贝克。</p></div></div>    
</body>
</html>