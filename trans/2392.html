<html>
<head>
<title>Getting Started with BigQuery SQL User Defined Functions (SQL UDFs)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery SQL用户定义函数(SQL UDFs)入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-bigquery-sql-user-defined-functions-sql-udfs-a99c79689d4b#2022-05-25">https://towardsdatascience.com/getting-started-with-bigquery-sql-user-defined-functions-sql-udfs-a99c79689d4b#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7627" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个强大的基本构建块，支持核心BigQuery平台功能的自定义扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8235e41ce8196c005e855f3b0513ca0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t2LGkc9cN8HwNRNs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迷茫？不要害怕。照片由<a class="ae ky" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> charlesdeluvio </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="0a92" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机</h1><p id="73d2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">可扩展性是BigQuery的关键特性之一——伴随着超级大国般的新功能的不断发展——这使得它成为一个强大的平台，可以处理任何类型的数据工作，无论大小。</p><p id="be39" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，任何平台的功能集都可能是压倒性的，甚至很难弄清楚从哪里开始。这一系列的目的是揭开一些基本BigQuery特性的神秘面纱，并让您以更快的速度朝着您的特定目标前进。</p><h1 id="46a9" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">情况</h1><p id="dba7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">BigQuery中有几个不同种类的“函数”,所以如果没有通过全面的(但有时是压倒性的)官方文档弄清楚每个函数的细微差别，请原谅。</p><p id="79c5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，<code class="fe ms mt mu mv b">User-Defined Functions (UDFs)</code>是被称为<code class="fe ms mt mu mv b">Routines</code>的大查询资源类型家族的一部分，该家族还包括<code class="fe ms mt mu mv b">Stored Procedures</code>、(也就是通常所说的脚本)、<code class="fe ms mt mu mv b">Remote Functions</code>和<code class="fe ms mt mu mv b">Table Functions</code>。</p><p id="805d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每一种都有不同的种类，每一种都有自己的特质。下面这篇文章是对开发<code class="fe ms mt mu mv b">Routines</code>的一个温和的介绍:</p><div class="mw mx gp gr my mz"><a rel="noopener follow" target="_blank" href="/getting-started-with-bigquery-scripting-45bdd968010c"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd iu gy z fp ne fr fs nf fu fw is bi translated">BigQuery脚本入门</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">揭开BigQuery功能强大但可能难以理解的一面，只需简单的一步…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn ks mz"/></div></div></a></div><p id="f6f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了简单起见，让我们从最简单的开始:SQL用户定义函数。</p><h1 id="41e4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">解决办法</h1><p id="7ec0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在深入函数构造和语法的细节之前，一个有用的起点是展示如何实际使用它。从SQL UDF获得结果的语法非常简单且一致:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="38a4" class="ns la it mv b gy nt nu l nv nw">SELECT project_id.dataset_id.function_name([OPTIONAL PARAMETERS])</span></pre><p id="97e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果这个函数没有参数，那么你仍然需要包括括号，因此:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="3ad2" class="ns la it mv b gy nt nu l nv nw">SELECT project_id.dataset_id.function_name()</span></pre><p id="05ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以将它用作普通查询的一部分(在这种情况下，该函数将为查询响应的每一行返回一个值)，或者用作工作流的一部分，其中只需要一个响应，并且您希望将一些计算复杂性封装在一个易于使用的函数中。</p><p id="294c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本例中，我们将构建一个SQL UDF，使表引用(通常缩写为refs)的工作变得非常简单，这对开发BigQuery自动化脚本和其他函数很有帮助。将使用以下语法调用该函数:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="5883" class="ns la it mv b gy nt nu l nv nw">SELECT flowfunctions.ref.build('project_id', 'dataset_id', 'table_name')</span><span id="8f87" class="ns la it mv b gy nx nu l nv nw"><strong class="mv iu">RETURNS:</strong><br/>'project_id.dataset_id.table_name'</span></pre><p id="b526" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们按照地理位置(美国:<code class="fe ms mt mu mv b">flowfunctions</code>)将所有<code class="fe ms mt mu mv b">Routines</code>分组到单个项目中，并按照功能类型分组到数据集中。</p><p id="4064" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">UDF最简单的开发工作流程实际上是<em class="ny">而不是</em>从开发实际功能开始，它是编写底层查询。通过在开始时声明您将用作参数的变量，将查询转换成函数就变成了微不足道的最后一步。</p><p id="a549" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这种情况下，我期望三个输入参数，<code class="fe ms mt mu mv b">project_id</code>、<code class="fe ms mt mu mv b">dataset_id</code>和<code class="fe ms mt mu mv b">table_name</code>，都是<code class="fe ms mt mu mv b">STRINGs</code>。我像在BigQuery脚本中一样声明它们，在这种情况下，使用<code class="fe ms mt mu mv b">DECLARE</code>关键字在声明点设置它们的值:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="1980" class="ns la it mv b gy nt nu l nv nw">DECLARE project_id STRING DEFAULT 'my-project';<br/>DECLARE dataset_id STRING DEFAULT 'my_dataset';<br/>DECLARE table_name STRING DEFAULT 'my_view';</span></pre><p id="df14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我现在甚至可以运行这个脚本，它会成功运行——但是实际上什么也不会发生，因为我没有选择任何东西。如果我想检查这些值，我可以执行以下查询:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="5804" class="ns la it mv b gy nt nu l nv nw">SELECT project_id, dataset_id, table_name</span></pre><p id="9056" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，这很无聊，让我们把他们建成一个参考！这并不难——然而，即使对于这个简单的例子，也有几种不同的方法可以实现这一点，或者使用<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions#concat" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu"> CONCAT </strong> </a>函数:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="938c" class="ns la it mv b gy nt nu l nv nw">SELECT CONCAT(project_id, ".", dataset_id, '.', table_name) AS ref</span></pre><p id="d9f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">或者使用<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/operators#concatenation_operator" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">串联运算符</strong> </a>:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="78c9" class="ns la it mv b gy nt nu l nv nw">SELECT project_id||"."||dataset_id||'.'||table_name AS ref;</span></pre><p id="3dce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这两个例子都很可读，但是因为第二个例子有点短，我们就用它吧。执行这个(连同变量声明)，我们将得到我们想要的结果:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="595c" class="ns la it mv b gy nt nu l nv nw"><strong class="mv iu">RETURNS:</strong><br/>my-project.my_dataset.my_view</span></pre><p id="dea4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">太好了！现在把它放到一个函数中，这样我们可以重用和简化我们未来的代码。<code class="fe ms mt mu mv b">User-Defined Functions</code>的官方文档是<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions" rel="noopener ugc nofollow" target="_blank">这里是</a>，然而我们只需要一个非常简单的语法来实现我们的简单函数:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="8731" class="ns la it mv b gy nt nu l nv nw">CREATE OR REPLACE FUNCTION flowfunctions.ref.build (<br/>project_id STRING, <br/>dataset_id STRING, <br/>table_name STRING<br/>) AS ((<br/>SELECT project_id||"."||dataset_id||'.'||table_name AS ref<br/>))</span></pre><p id="1229" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">没有必要将参数定义放在不同的行上，但是如果有很多这样的定义，会有助于提高可读性。其他需要注意的事项有:</p><ul class=""><li id="686f" class="nz oa it lt b lu mn lx mo ma ob me oc mi od mm oe of og oh bi translated">您不能在查询末尾使用分号，否则会出错</li><li id="4a82" class="nz oa it lt b lu oi lx oj ma ok me ol mi om mm oe of og oh bi translated">您需要双括号，否则您会得到以下错误消息:</li></ul><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="0292" class="ns la it mv b gy nt nu l nv nw"><em class="ny">The body of each CREATE FUNCTION statement is an expression, not a query; to use a query as an expression, the query must be wrapped with additional parentheses to make it a scalar subquery expression at [y:x]</em></span></pre><p id="dff7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这听起来很奇怪，但却是<em class="ny">非常重要的</em>！您可以更改函数体以删除<code class="fe ms mt mu mv b">SELECT</code>和<code class="fe ms mt mu mv b">AS ref</code>来消除错误，但是将SQL查询放在双括号中(使其成为“标量子查询表达式”)现在使您能够编写任意复杂的SQL查询，并将它们封装到可重用的函数中。这意味着您可以以连续的方式编写美观、可读的查询(即使用通用的表表达式，而不求助于无法理解的嵌套子查询)。这是一件非常好的事情。</p><p id="6154" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">限制是您需要从查询中返回一个(且只有一个)“对象”，然而实际上您可以简单地将多列构建到<code class="fe ms mt mu mv b">STRUCTs</code>中，将多行构建到<code class="fe ms mt mu mv b">ARRAYs</code>中，这应该可以解决任何用例。</p><p id="458b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，那时你必须<code class="fe ms mt mu mv b">UNNEST</code>他们才能使用他们，但那肯定是另一天的主题。</p><h1 id="0024" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">执行</h1><p id="f160" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要执行此功能，只需在控制台中执行以下查询:</p><pre class="kj kk kl km gt no mv np nq aw nr bi"><span id="7761" class="ns la it mv b gy nt nu l nv nw">SELECT flowfunctions.ref.build('project_id', 'dataset_id', 'table_name')</span></pre><p id="4103" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">拥有<code class="fe ms mt mu mv b">BigQuery Data Viewer</code>和<code class="fe ms mt mu mv b">BigQuery Metadata Viewer</code>权限的<code class="fe ms mt mu mv b">allAuthenticatedUsers</code>也可以使用包含该函数的数据集，因此只需几次点击，就可以对全世界开放。相当神奇！</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="e11c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果您觉得这(以及其他相关材料)有用和/或有趣，请跟我来！</p><p id="7fce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你还不是会员，那么<a class="ae ky" href="https://jim-barlow.medium.com/membership" rel="noopener">加入Medium </a>吧，每月只需5美元，就能从这个活跃、充满活力和激情的数据人社区中获得无限的故事。也有很多其他人，但是如果你对数据感兴趣，那么这里就是你要去的地方…</p></div></div>    
</body>
</html>