<html>
<head>
<title>Performing Data Validation at Scale with Soda Core</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Soda Core进行大规模数据验证</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performing-data-validation-at-scale-with-soda-core-825267bb4714#2022-05-26">https://towardsdatascience.com/performing-data-validation-at-scale-with-soda-core-825267bb4714#2022-05-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="eb36" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">深入了解数据验证的过去和现在，以及如何利用当今的工具来确保大规模数据质量</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/133f743c6760d28368e94692e04666e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufTdZSSYUJNZvqJK"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@killerfvith?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alex wong </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cb60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着人们对现代数据堆栈(MDS)及其不断增长的数据技术和SaaS产品生态系统的兴趣不断增加，数据团队正在大力押注于它，以打开创新和能力的新大门。但更重要的是，MDS生态系统有望为不久前做出的昂贵决策提供高效的替代方案。</p><p id="ac48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">毕竟，当我们将今天的数据堆栈与“<em class="lw">第一波</em>”BI平台或“<em class="lw">第二波</em>”Hadoop环境进行比较时，很明显，今天我们可以用更少的资源获得更多(特性、功能和价值创造)，无论是在工程工作、时间还是基础架构成本方面。这是一个非常合适的时间来增强我们的数据平台，或者更好的是，更新和微调他们现有的组件。</p><p id="61b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将详细介绍如何利用这一波新的数据工具，在数据验证领域用更少的资源做更多的事情。</p><h1 id="4506" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">等等，我们对数据验证有明确的定义吗？</h1><p id="a429" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">数据验证的广义理论定义是静态的:它是一组允许我们确保我们的数据可信并符合预定义的数据质量标准的过程——通常使用<a class="ae kz" href="https://www.collibra.com/us/en/blog/the-6-dimensions-of-data-quality" rel="noopener ugc nofollow" target="_blank"> 6个关键维度</a>(准确性、完整性、一致性、及时性、有效性和唯一性)。另一方面，像数据工程中的大多数其他领域一样，我们应用理论定义的技术方法正在快速发展，并朝着不同的方向发展——这使得概念本身相当不稳定。尽管如此，最终目标仍然是一样的:<strong class="lc iv"> <em class="lw">确保我们可以信任我们正在消费的数据</em> </strong>。</p><p id="8b62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们已经——在某种程度上——明确了定义，让我们看看几年前我们是如何处理(有时避免)数据验证的。</p><h1 id="1e1c" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">数据验证的黑暗过去</h1><p id="9ea4" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">多年来(想想2010年到2016年)，数据工程师在没有软件工程最佳实践的情况下构建管道——目标是尽可能快地交付尽可能多的数据，然后决定我们想要用这些数据做什么。这在当时没有造成任何直接的问题，因为“<em class="lw">大数据</em>”仍然是大多数公司决策的次要因素，因此完全跳过数据验证是可以容忍的。</p><p id="c125" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在那些年，想要确保数据质量的数据工程团队的选择非常有限:</p><ul class=""><li id="821f" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv mz na nb nc bi translated">如果使用分布式计算引擎(通常在像HDFS这样的分布式文件系统之上)处理数据，那么团队将需要编写专门的任务/作业来清理数据并运行数据质量检查。(例如，如果团队维护进行处理的Spark作业，数据验证也将通过专用作业或作为处理作业的一个步骤使用Spark进行。)</li><li id="b830" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv mz na nb nc bi translated">另一方面，如果数据存在于分布式数据仓库中(比如Apache Hive)，那么团队将需要编写和维护多个SQL查询，这些查询在不同的输入表上运行，以执行必要的检查。</li></ul><p id="9fb6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这两种情况下，难以扩展的强力方法是唯一可用的选择。不同的公司致力于构建内部框架和抽象来简化流程，但在数据社区中没有“啊哈”的时刻——数据验证需要大量的工作，因为每个人都是从头开始，所以大多数公司只是把它推到一边。</p><p id="151d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是现在，事情发生了变化:数据在任何地方都是一等公民，指标被广泛的用户/团队使用。现在，我们经常发现自己试图理解为什么两个仪表板为同一指标提供不同的值，或者一个管道中的故障会如何影响我们的最终用户。现在，我们正在偿还建设数据管道的逾期债务，却没有考虑数据质量——那么，我们如何用开源的"<em class="lw">第三波</em>"工具来解决数据质量问题呢？我们如何利用这些工具来自动化现有流程，并降低大规模实现数据验证组件的成本(无论是在工程工作、时间还是预算方面)？</p><h1 id="1fb7" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">数据验证的现状</h1><p id="900f" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">让我们首先从谈论数据验证在过去几年中取得的巨大进步开始我们的回答。无论是通过像Great Expectations和Soda Core(以前的SodaSQL)这样的开源项目，还是像MonteCarlo和Sifflet这样专注于更大空间的数据可观察性的SaaS平台，数据验证都有了很大的发展。</p><p id="b949" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们今天谈论数据验证时，我们谈论的只是包含数据可观察性和数据操作的更广泛且快速成熟的空间中的一个组件，这个空间使我们更容易找到信心说<em class="lw">“是的，数据没问题”</em>。因此，即使我们专注于开源数据验证工具，我们正在构建的设计也可以扩展到一个详尽的数据可观察性层——但这超出了本文的范围。</p><p id="a393" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，在范围内的是2022年开源数据质量的状态——所以让我们来看一下土地的布局。</p><h2 id="d285" class="ni ly iu bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn nt bi translated">巨大的期望</h2><p id="8414" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated"><a class="ae kz" href="https://github.com/great-expectations/great_expectations" rel="noopener ugc nofollow" target="_blank"> Great Expectations </a>可以说是定义了对数据验证工具期望的当前标准的工具:您定义您的检查(或期望)以及您希望如何/何时运行它们，然后您的数据验证组件会处理剩下的事情。相当整洁。</p><p id="c5bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在过去的四年中，该工具在各个方面都得到了扩展:越来越长的集成列表、数据分析功能和内置的数据文档。最重要的是，巨大的期望是一个Python库，而你的期望只是Python函数。</p><p id="1c24" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是还有什么比维护Python函数更简单的呢？YAML和SQL。</p><h2 id="9f2a" class="ni ly iu bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn nt bi translated">苏打核心(以前为SodaSQL)</h2><p id="3f7f" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated"><a class="ae kz" href="https://github.com/sodadata/soda-core" rel="noopener ugc nofollow" target="_blank"> Soda Core </a>是另一个开源工具，它提供了确保数据验证的必要功能。尽管该工具本身也是用Python编写的(类似于Great Expectations)，但它以不同的方式处理数据验证:作为一名开发人员，您只需要提供一组YAML配置文件，告诉Soda如何连接到您的数据仓库，以及您希望在不同的表上运行哪些检查。</p><p id="bc97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当管理拥有不同所有者和维护者的数百个表时，这种方法非常方便。最初，Soda要求每个表有一个YAML文件，但是现在随着<a class="ae kz" href="https://docs.soda.io/soda-cl/soda-cl-overview.html" rel="noopener ugc nofollow" target="_blank"> SodaCL </a>的发布，你可以在YAML配置中利用<a class="ae kz" href="https://docs.soda.io/soda-cl/for-each.html" rel="noopener ugc nofollow" target="_blank">循环</a>和定制Soda语法来优化你如何定义度量/检查。</p><p id="e85b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Soda主要优先考虑CLI交互来运行检查(使用广泛的命令和选项)，但它也提供了丰富的Python库，这为自定义使用和直接在Python应用程序中利用其检查的输出打开了大门。</p><h1 id="7b56" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">具体示例:使用Soda Core确保大规模数据质量</h1><p id="f4ed" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">为了展示现在设置可伸缩数据验证组件的简单性，让我们来看看将Soda Core添加到现有数据平台的不同步骤。</p><p id="d303" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可能会在各种用例中遇到这种情况，例如需要提高数据质量和增强对数据的信任，或者数据协调项目(确保您从新源使用的数据与您从您想要废弃的旧源使用的数据相匹配)。在这种情况下，添加数据验证组件已经被简化为只提供三个问题的答案。</p><h2 id="957a" class="ni ly iu bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn nt bi translated">步骤1:我们在验证什么？</h2><p id="ccd1" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">首先，我们需要从定义我们实际想要测试/验证的资产开始，以及我们想要在这些资产上运行的检查。Soda使得这个过程非常高效，因为我们不需要编写许多冗余的SQL查询，我们只需要挑选我们想要利用的指标(从<a class="ae kz" href="https://docs.soda.io/soda/metrics.html" rel="noopener ugc nofollow" target="_blank">一长串预定义指标</a>中)和我们想要执行的检查。</p><p id="9c2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后，我们需要通过YAML向苏打水传达我们的选择。我们可以使用循环、列表，甚至自定义的基于SQL的指标/检查，确保我们可以在定义检查时实现所有可能的场景，而没有任何冗余。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">样品苏打核心检查YAML文件。</p></figure><p id="0a1f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Soda进行了大量优化，以最小化添加和维护数据检查所需的成本和工作，在上面的示例中，我们只触及了可用功能的表面(其他值得注意的功能包括内置的<a class="ae kz" href="https://docs.soda.io/soda-cl/freshness.html" rel="noopener ugc nofollow" target="_blank">新鲜度检查</a>和<a class="ae kz" href="https://docs.soda.io/soda-cl/optional-config.html" rel="noopener ugc nofollow" target="_blank">检查配置</a>)。</p><p id="237e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用这种方法，我们可以通过源代码控制来管理我们的数据验证检查(确保版本控制和集中化)。此外，YAML的使用意味着无论与数据交互的用户背景如何(无论他们是数据科学家、数据工程师、ML工程师，甚至是项目经理)，他们不仅能够理解给定表的现有检查，还能够提出修改建议。不管是好是坏，YAML设法将自己定位为技术世界的通用配置语言，所以我们不妨充分利用它。</p><p id="5adb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然我们已经定义了想要运行的检查，那么让我们来讨论一下应该在哪里运行它们。</p><h2 id="0505" class="ni ly iu bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn nt bi translated">步骤2:我们在哪里验证？</h2><p id="3c85" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">考虑到我们正在谈论一个现代数据平台，假设我们正在应用ELT设计并在基于云的分布式数据仓库上运行我们的转换。</p><p id="133e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Soda提供了到所有“主流”数据仓库的连接器，并对其查询进行了内置优化(如利用缓存)，以确保在数据仓库上运行的数据验证查询的最佳性能和最低成本。记住这一点，我们只需要提供一个描述连接和我们想要使用的数据仓库的<code class="fe nw nx ny nz b">configuration.yml</code>文件——然后Soda将抽象其余的。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nu nv l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Postgres仓库的示例配置。</p></figure><p id="6098" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样值得注意的是，有可能将Soda用于基于Spark的架构，这要感谢功能丰富的Soda Spark扩展<a class="ae kz" href="https://docs.soda.io/soda-spark/install-and-use.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="68c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">既然Soda可以连接到我们的数据仓库并在其上运行查询，那么让我们决定我们实际上想要如何以及何时运行这些查询。</p><h2 id="3c8b" class="ni ly iu bd lz nj nk dn md nl nm dp mh lj nn no mj ln np nq ml lr nr ns mn nt bi translated">步骤3:我们如何(以及何时)进行验证？</h2><p id="9d29" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">既然我们有一个现有的数据平台，我们可以假设我们也有一个<em class="lw">编排器</em>，它触发我们管道内的不同任务，并确保调度和——不出所料——编排(例子包括Airflow和Dagster)。理想情况下，我们希望在我们的<a class="ae kz" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/dags.html#:~:text=A%20DAG%20(Directed%20Acyclic%20Graph,say%20how%20they%20should%20run." rel="noopener ugc nofollow" target="_blank">Dag</a>内尽快执行数据验证—因此，让我们看看如何通过我们的orchestrator实现这一点。</p><p id="4caf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Soda提供与开箱即用的<a class="ae kz" href="https://docs.soda.io/soda-sql/orchestrate_scans.html#apache-airflow-using-pythonvirtualenvoperator" rel="noopener ugc nofollow" target="_blank">气流</a>和<a class="ae kz" href="https://docs.soda.io/soda-sql/orchestrate_scans.html#prefect-using-a-custom-task" rel="noopener ugc nofollow" target="_blank">完美</a>的集成，建议将Soda检查作为我们Dag内的专门任务来运行。如果我们以Airflow为例，这可以通过不同的方式完成，比如利用<a class="ae kz" href="https://docs.soda.io/soda-sql/orchestrate_scans.html#apache-airflow-using-pythonvirtualenvoperator" rel="noopener ugc nofollow" target="_blank">python virtualenv操作符</a>，甚至直接通过<a class="ae kz" href="https://docs.soda.io/soda-sql/orchestrate_scans.html#apache-airflow-using-bashoperator" rel="noopener ugc nofollow" target="_blank"> Airflow的Bash操作符</a>运行<code class="fe nw nx ny nz b">soda scan</code> CLI命令。</p><p id="b3ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，即使我们使用不与Soda集成的orchestrator(不允许我们运行Python包)，理想的模式可能如下:</p><ol class=""><li id="a222" class="mu mv iu lc b ld le lg lh lj mw ln mx lr my lv oa na nb nc bi translated">从外部源或通过EL组件(例如Airbyte)接收原始数据。这些数据将被接收到我们的原始层(无论是在数据仓库还是在湖边小屋)，接收的完成将反过来触发验证任务。</li><li id="f4ec" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv oa na nb nc bi translated">在我们的orchestrator中使用专门的数据验证任务/步骤，触发执行环境来运行Soda Core。像AWS上的Lambda函数这样的无服务器服务(或其他云提供商上的替代服务)非常适合这种情况，因为它消除了在orchestrator本身中直接运行Soda的需要。无服务器功能将通过HTTP请求触发，然后任务的结果将依赖于无服务器功能的响应来确定执行是成功还是失败(这甚至可以仅仅依赖于无服务器功能的响应代码)。</li><li id="e3d4" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv oa na nb nc bi translated">将数据验证任务生成的指标推送到我们的数据仓库，以便进一步监控或在其上构建专用仪表板。为了检索指标，我们可以使用<code class="fe nw nx ny nz b">scan_result</code>对象，它是<a class="ae kz" href="https://docs.soda.io/soda/scan.html#programmatically-use-scan-output" rel="noopener ugc nofollow" target="_blank"> Soda扫描输出</a>的一部分。</li><li id="96f7" class="mu mv iu lc b ld nd lg ne lj nf ln ng lr nh lv oa na nb nc bi translated">依靠Soda检查的输出来确定如何继续执行我们的DAG。这完全依赖于特定的用例来确定当检查失败时应该发生什么动作。(例如根据检查类型和问题的严重性发出警告或错误，发送警报等。)如果没有阻塞故障，那么我们将转移到管道的数据转换部分，因为我们知道可以信任数据。</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/13733e7dc1dac4df7dc97cea6a2b5893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHRDddE_9t0ra76HlRJhjg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Soda核心任务的数据管道示例。(图片由作者提供)</p></figure><p id="43e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过这种设计，我们利用了Soda是一个轻量级包的事实，并在一个专用的无服务器环境中运行它，这将潜在问题的风险降至最低。</p><h1 id="d511" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">总结事情</h1><p id="1d37" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">在整篇文章中，我们看到了数据验证在过去几年中是如何发展的，以及今天实现一个专用的数据质量组件仅仅包括通过YAML配置回答三个问题。</p><p id="27c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这种进步极大地降低了确保大规模数据质量的成本，无论是增强现有的数据管道和提高对数据的信任，还是实现像数据协调场景中那样的特定用例。</p><p id="ea97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在数据堆栈的其他部分也可以看到类似的模式，不久前的资源密集型问题变成了可以用最少的资源实现的抽象特性。这让我们回到了文章的第一点:<strong class="lc iv"> <em class="lw">在期望MDS引入新功能或用例之前，为什么不利用其生态系统来改进我们数据堆栈中的现有组件呢？</em> </strong></p></div></div>    
</body>
</html>