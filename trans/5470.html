<html>
<head>
<title>A Callable Float? Fun and Creativity in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可赎回的浮动？Python 中的乐趣和创造力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-callable-float-fun-and-creativity-in-python-7a311ccd742d#2022-12-08">https://towardsdatascience.com/a-callable-float-fun-and-creativity-in-python-7a311ccd742d#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ffa2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="2974" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为了学习创造性，我们将在 Python 中实现可调用的浮点数</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/57d02707f34c3b0005bcef97fccab41d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FABmGpocbD9wHbbz"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@kai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kai Gradert </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1066" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Python 的内置数据类型中，我们有许多表示数字的类型，最重要的是<code class="fe me mf mg mh b">int</code>和<code class="fe me mf mg mh b">float</code>。如同 Python 中的一切，它们的实例是对象；而作为对象，它们有自己的属性和方法。例如，这就是<code class="fe me mf mg mh b">float</code>型报价的实例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mi"><img src="../Images/f5f57bdeafc545d5b063c7da79713f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwVJIJ3UzAZqpaXeNh2XLw.png"/></div></div></figure><p id="86bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，<code class="fe me mf mg mh b">float</code>数字提供了许多不同的使用方法。他们没有提供一个<code class="fe me mf mg mh b">.__call__()</code>方法，这意味着你不能调用他们。</p><p id="2bfa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你有没有想过为什么我们不能像调用函数一样调用浮点数？看:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="44de" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; i = 10.0012<br/>&gt;&gt;&gt; i()<br/>Traceback (most recent call last):<br/>    ...<br/>TypeError: 'float' object is not callable</span></pre><p id="75f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它不起作用。为什么它不起作用？！</p><p id="2587" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">老实说……我从来没有考虑过为什么 floats 是不可调用的——但是这对我来说非常有意义。他们为什么要这么做？为什么你觉得他们有什么特别的原因吗？我不知道。</p><p id="0bd7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但这并不意味着我们不会实现这样的功能——我们肯定会实现。我们为什么要这么做？原因有三:学习 Python，有创意，学习有创意。</p><p id="e7c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">学习创新是学习编程语言的一个重要方面。有一天，在一个 Python 项目中，你会发现自己处于一个困难的境地，标准的解决方案不起作用；你必须<em class="mt">思考</em>和<em class="mt">有创造性</em>。你的创造力可能会帮助你找出一个创新的、非典型的解决方案，一个能帮助你解决这个奇怪的或者非典型的问题的方案。</p><p id="fa08" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在本文中，我们将实现一个可调用的浮点类型；这绝对不是一个典型的场景。我们将逐步进行，我将详细解释每一步。继续读下去的时候，要尽量有创造性。也许这样会帮助你想出自己的想法来改进解决方案。如果有，就去实现它们，并请在评论中分享。</p><h1 id="e74c" class="mu mo it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">履行</h1><p id="f615" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">我们将从实现下面的简单方法开始:如果用户调用一个 float，它返回四舍五入到三个十进制数字的数字。现在，让我们简化一下——我将硬编码舍入到三个十进制数字；我们以后会改变这一点。</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="bd70" class="mn mo it mh b be mp mq l mr ms"># callable_float.py<br/>class Float(float):<br/>    def __call__(self):<br/>        return round(self, 3)</span></pre><p id="b3e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是我们所需要的！正如您在下面看到的，在正常的用例中，<code class="fe me mf mg mh b">Float</code>的一个实例的行为就像一个常规的<code class="fe me mf mg mh b">float</code>对象:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="42f8" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; from callable_float import Float<br/>&gt;&gt;&gt; i = Float(10.0012)<br/>&gt;&gt;&gt; i * 2<br/>20.0024<br/>&gt;&gt;&gt; i - 1<br/>9.0012<br/>&gt;&gt;&gt; round(2 * (i + 1) / 7, 5)<br/>3.14320</span></pre><p id="cdd5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，与<code class="fe me mf mg mh b">float</code>不同的是，<code class="fe me mf mg mh b">Float</code>是可调用的:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="427c" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; i()<br/>10.001</span></pre><p id="b6a6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Voilà —可调用的浮点数。</p><p id="907c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，不需要硬编码要在舍入中使用的小数位数。我们可以让用户决定使用多少个十进制数字。为此，只需向<code class="fe me mf mg mh b">.__call__()</code>方法添加一个<code class="fe me mf mg mh b">digits</code>参数:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="5c1e" class="mn mo it mh b be mp mq l mr ms"># callable_float.py<br/>class Float(float):<br/>    def __call__(self, digits=3):<br/>        return round(self, digits)</span></pre><pre class="nq mj mh mk bn ml mm bi"><span id="e716" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; i(1)<br/>10.0<br/>&gt;&gt;&gt; i(3)<br/>10.001<br/>&gt;&gt;&gt; i(10)<br/>10.0012</span></pre><p id="9609" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">完美！请注意，这正是我们将相应的<code class="fe me mf mg mh b">float</code>数字四舍五入后得到的结果:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="26cb" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; j = float(i)<br/>&gt;&gt;&gt; i(1) == round(j, 1)<br/>True<br/>&gt;&gt;&gt; i(3) == round(j, 3)<br/>True<br/>&gt;&gt;&gt; i(10) == round(j, 10)<br/>True</span></pre><p id="7026" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可能想返回一个<code class="fe me mf mg mh b">Float</code>对象，而不是一个<code class="fe me mf mg mh b">float</code>:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="8a1b" class="mn mo it mh b be mp mq l mr ms"># callable_float.py<br/>class Float(float):<br/>    def __call__(self, digits=3):<br/>        return Float(round(self, digits))</span></pre><p id="4890" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，<code class="fe me mf mg mh b">Float</code>数字在被调用时唯一能做的就是四舍五入。无聊！让它能够做<em class="mt">任何事情</em>。</p><p id="5a78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这样一个通用的概念，我们需要使<code class="fe me mf mg mh b">.__call__()</code>方法成为一个高阶方法，这意味着它接受一个函数(实际上是一个可调用的函数)作为参数。下面的类实现了这个功能:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="b294" class="mn mo it mh b be mp mq l mr ms"># callable_float.py<br/>from typing import Callable<br/><br/>class Float(float):<br/>    def __call__(self, func: Callable):<br/>        return func(self)</span></pre><p id="2b5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，这一次，我们没有将返回值的类型更改为<code class="fe me mf mg mh b">Float</code>，因为用户可能希望使用返回另一种类型的对象的<code class="fe me mf mg mh b">func()</code>函数。</p><p id="4c77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个版本的<code class="fe me mf mg mh b">Float</code>是这样工作的:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="c866" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; from callable_float import Float<br/>&gt;&gt;&gt; i = Float(12.105)<br/>&gt;&gt;&gt; 2*i<br/>24.21<br/>&gt;&gt;&gt; i(round)<br/>12<br/>&gt;&gt;&gt; i(lambda x: 200)<br/>200<br/>&gt;&gt;&gt; i(lambda x: x + 1)<br/>13.105<br/>&gt;&gt;&gt; def square_root_of(x):<br/>...     return x**.5<br/>&gt;&gt;&gt; i(square_root_of)<br/>3.479224051422961<br/>&gt;&gt;&gt; i(lambda x: round(square_root_of(x), 5))<br/>3.47922<br/>&gt;&gt;&gt; i = Float(12345.12345)<br/>&gt;&gt;&gt; i(lambda x: Float(str(i)[::-1]))<br/>54321.54321</span></pre><p id="61e4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它像预期的那样工作，但是它有一个明显的缺点:您不能对<code class="fe me mf mg mh b">func()</code>函数使用额外的参数。由于有了<code class="fe me mf mg mh b">*args</code>和<code class="fe me mf mg mh b">**kwargs</code>参数，我们可以很容易地实现这个功能，使用户能够提供<em class="mt">任何</em>参数:</p><pre class="ks kt ku kv gt mj mh mk bn ml mm bi"><span id="a41e" class="mn mo it mh b be mp mq l mr ms"># callable_float.py<br/>from typing import Callable<br/><br/>class Float(float):<br/>    def __call__(self, func: Callable, *args, **kwargs):<br/>        return func(self, *args, **kwargs)</span></pre><pre class="nq mj mh mk bn ml mm bi"><span id="d933" class="mn mo it mh b be mp mq l mr ms">&gt;&gt;&gt; i(lambda x, digits: round(x**.5, digits), 5)<br/>111.10861<br/>&gt;&gt;&gt; def rounded_square_root_of(x, digits=3):<br/>...     return round(x**.5, digits)<br/>&gt;&gt;&gt; i(rounded_square_root_of)<br/>111.109<br/>&gt;&gt;&gt; i(rounded_square_root_of, 5)<br/>111.10861<br/>&gt;&gt;&gt; j = float(i)<br/>&gt;&gt;&gt; i(rounded_square_root_of, 5) == rounded_square_root_of(j, 5)<br/>True</span></pre><p id="b46e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有工作都很好。请考虑以下注意事项:</p><ul class=""><li id="fb16" class="nr ns it lk b ll lm lo lp lr nt lv nu lz nv md nw nx ny nz bi translated">用户提供一个应用于类实例的函数。它可以不带参数，也可以带任意数量的参数，包括位置参数(<code class="fe me mf mg mh b">*args</code>)和关键字参数(<code class="fe me mf mg mh b">**kwargs</code>)。然后将<code class="fe me mf mg mh b">Float</code>的值作为函数调用，将函数<code class="fe me mf mg mh b">func()</code>作为该函数的参数调用，这与将该值作为其参数调用该函数是一样的……如果这不疯狂，那么什么才是疯狂呢？！</li><li id="1e88" class="nr ns it lk b ll oa lo ob lr oc lv od lz oe md nw nx ny nz bi translated">这次<code class="fe me mf mg mh b">Float.__call__()</code>的返回值可以是任意类型，并且和<code class="fe me mf mg mh b">func()</code>函数的返回值是同一个类型。</li></ul><h1 id="82bc" class="mu mo it bd mv mw mx my mz na nb nc nd ki ne kj nf kl ng km nh ko ni kp nj nk bi translated">结论</h1><p id="d82d" class="pw-post-body-paragraph li lj it lk b ll nl kd ln lo nm kg lq lr nn lt lu lv no lx ly lz np mb mc md im bi translated">我们已经实现了一个类<code class="fe me mf mg mh b">Float</code>，它可以像函数一样调用浮点数。用一个函数作为参数调用一个<code class="fe me mf mg mh b">Float</code>类的实例意味着用<code class="fe me mf mg mh b">Float</code>实例作为参数调用这个函数。您可以使用任何附加参数，包括位置参数和关键字参数。</p><p id="12d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们做这些并不是为了实际使用可调用的<code class="fe me mf mg mh b">Float</code>类。我从未实现或使用过任何类似的东西，我也不<em class="mt">也不</em>期望如此。但对我来说，这很有趣，非常有趣——也是使用 Python 的创造性的一课。我希望你也喜欢这篇文章。我认为做这些疯狂的事情有很大的价值:它帮助你学习 Python，并且帮助你学习这种语言的复杂性，这是你用其他方法学不到的。</p><p id="ad21" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">Float</code>类并不重要。重要的是，当你不得不处理非典型情况时，这种头脑风暴可以帮助你在未来的项目中激发创造力。实践这样的实现可以帮助您在 Python 项目中找到并实现非典型解决方案。</p><p id="f567" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读。如果你喜欢这篇文章，你也可以喜欢我写的其他文章；你会在这里看到他们<a class="ae lh" href="https://medium.com/@nyggus" rel="noopener"/>。如果你想加入 Medium，请使用我下面的推荐链接:</p><div class="of og gp gr oh oi"><a href="https://medium.com/@nyggus/membership" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jd gy z fp on fr fs oo fu fw jc bi translated">加入我的介绍链接媒体-马尔钦科萨克</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">阅读马尔钦·科萨克(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow lb oi"/></div></div></a></div></div></div>    
</body>
</html>