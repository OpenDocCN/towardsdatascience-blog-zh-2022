<html>
<head>
<title>CI/CD for TFX Pipelines with Vertex and AI Platform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带顶点和人工智能平台的TFX管道CI/CD</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ci-cd-for-tfx-pipelines-with-vertex-and-ai-platform-c562452fba1#2022-10-18">https://towardsdatascience.com/ci-cd-for-tfx-pipelines-with-vertex-and-ai-platform-c562452fba1#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="60d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用顶点管道部署TFX管道，在人工智能平台上服务您的模型，监控您的请求，并构建CI/CD管道来扩展您的系统</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/619a87444b21d26764ce85588f72e92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4_-bDcr7_nlltAiyq8rwQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">里卡多·戈麦斯·安吉尔在<a class="ae kv" href="https://unsplash.com/s/photos/pipe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="b016" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 1。简介</strong></h1><p id="0ac8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">本文是两部分的第二部分，第一部分可在<a class="ae kv" href="https://arturlunardi.medium.com/sentiment-analysis-with-tfx-pipelines-local-deploy-e9daa4cbde2a" rel="noopener">TFX管道情绪分析—本地部署</a>获得。在第一部分中，我们讨论了如何在本地开发管道，此外还展示了构建情感分析模型的过程。</p><p id="28e2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">在这一部分中，我们将介绍如何在云环境中运行我们的管道，如何开发CI/CD管道，以及如何监控我们模型的服务请求。</strong></p><p id="4b8a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">完成本文后，您将能够:</p><ul class=""><li id="0ab4" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">创建情感分析模型</li><li id="bdee" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">创建一个与<a class="ae kv" href="https://cloud.google.com/vertex-ai" rel="noopener ugc nofollow" target="_blank">顶点AI </a>集成的TFX管道</li><li id="0225" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">通过REST API在云环境中服务您的模型</li><li id="75b3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">分析您的管道元数据</li><li id="0fc2" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">创建CI/CD管道</li><li id="07c6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">使用<a class="ae kv" href="https://cloud.google.com/bigquery/docs" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>分析推论</li></ul><p id="3ada" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">整个应用程序的代码可以在这个GitHub存储库中找到<a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="2d58" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 2。顶点AI + TFX管线</strong></h1><p id="d667" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在第一部分，我们解释了什么是TFX管道，它的组成部分是什么，以及我们的模型是如何工作的。现在，<strong class="lq ir">让我们来关注如何在云环境中使用这个管道，以及如何构建CI/CD管道来扩展我们的系统。</strong></p><p id="f777" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当部署一个模型时，我们需要考虑如何让最终用户可以使用它。最常用的方法之一是通过REST API中的请求。</p><p id="9c2a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本教程中，我们将使用<a class="ae kv" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a> (GCP)的服务部署我们的管道，一般来说，我们将使用两个主要服务:</p><h2 id="dc80" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 2.1顶点AI </strong></h2><p id="1055" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Vertex AI是谷歌新的AI平台，联合所有谷歌云服务构建ML。我们将使用<a class="ae kv" href="https://cloud.google.com/vertex-ai/docs/pipelines" rel="noopener ugc nofollow" target="_blank">顶点管道</a>到<strong class="lq ir">来运行我们的训练管道</strong>，主要有两个原因:</p><ul class=""><li id="8246" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir">比</strong> <a class="ae kv" href="https://cloud.google.com/ai-platform/pipelines/docs" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> AI平台管道</strong> </a> <strong class="lq ir">便宜——在我们这里。</strong>顶点管道具有每次运行的固定执行率，也与通过计算引擎训练模型的成本相关联。无需激活和管理集群，使基础架构更精简、更便宜。</li><li id="7855" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">与人工智能平台中使用的<a class="ae kv" href="https://cloud.google.com/google/kubernetes" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a>(GKE)<strong class="lq ir">不同，我们不需要管理服务器和集群的基础设施/健康状况</strong>，因为Vertex是一个自我管理的平台。</li></ul><h2 id="6881" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 2.2人工智能平台</strong></h2><p id="db91" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">虽然我们的管道使用顶点管道运行，但我们的模型将在AI平台上训练和服务，主要原因有一个:</p><p id="1918" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">到目前为止，无法通过顶点AI中的函数</strong> <a class="ae kv" href="https://cloud.google.com/ vertex-ai/docs/reference/rest/v1/projects.locations.endpoints/predict" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">预测</strong> </a> <strong class="lq ir">来通知</strong><a class="ae kv" href="https://www.tensorflow.org/guide/saved_model" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">saved model</strong></a><strong class="lq ir">tensor flow的订阅。</strong></p><p id="e8e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我们的管道的工作原理如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/040e4a26b9a8476e2e4b5d9221ded0db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USX7Ezhrm6q7NFESofazQw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nq">图一。</strong> TFX管道上的云。这张图片是从谷歌创作和分享的<a class="ae kv" href="https://developers.google.com/readme/policies" rel="noopener ugc nofollow" target="_blank">作品中复制的，并根据</a><a class="ae kv" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">知识共享4.0归属许可</a>中描述的条款使用。来源:<a class="ae kv" href="https://www.tensorflow.org/tfx/guide" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/tfx/guide</a></p></figure><h1 id="9f59" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 3。云上TFX管道</strong></h1><p id="6a64" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，让我们了解如何将我们的管道迁移到云环境。</p><h2 id="496a" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 3.1配置项目</strong></h2><blockquote class="nr"><p id="48a9" class="ns nt iq bd nu nv nw nx ny nz oa mj dk translated">重要:这个项目将有成本。谷歌云的新用户可能有资格获得免费试用。</p></blockquote><p id="3bb7" class="pw-post-body-paragraph lo lp iq lq b lr ob jr lt lu oc ju lw lx od lz ma mb oe md me mf of mh mi mj ij bi translated">首先，您需要在<a class="ae kv" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Cloud Console </a>中创建一个项目，并启用以下API:</p><ul class=""><li id="d70e" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">顶点人工智能</li><li id="78ef" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">人工智能平台训练和预测</li><li id="d283" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">云存储</li><li id="1854" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">集装箱登记处</li><li id="89b2" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">BigQuery</li><li id="5bfb" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">云构建</li><li id="9e95" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">笔记本API</li></ul><h2 id="511e" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 3.2管道设置</strong></h2><p id="5c3c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在让我们打开<em class="og"> configs.py </em>文件并分析一些变量:</p><ul class=""><li id="a2e3" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir"><em class="og">【GCP _人工智能_平台_训练_ARGS </em> </strong> —传递给人工智能平台训练我们模型的参数。</li><li id="28a2" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"><em class="og">【GCP _ AI _平台_服务_ ARGS</em></strong>——传递给AI平台服务我们模型的参数。</li></ul><p id="436a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">添加这些参数是为了在<em class="og"> kubeflow_v2_runner </em>中创建管道。py文件</p><p id="3a8d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，让我们来看看相对于路径的变量。请注意，在代码中，所有变量都指向<a class="ae kv" href="https://cloud.google.com/storage/docs" rel="noopener ugc nofollow" target="_blank"> Google云存储</a>中的存储桶，这是因为当我们要构建CI/CD管道时，这些文件将在云环境中找到并可用。</p><ul class=""><li id="ead6" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><strong class="lq ir"><em class="og">TRANSFORM _ MODULE _ FILE</em></strong>—包含变换组件的变换的文件。</li><li id="ce40" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"><em class="og">TRAIN _ MODULE _ FILE</em></strong>—包含训练器组件说明的文件。</li><li id="ddb4" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"><em class="og">TUNER _ MODULE _ PATH</em></strong>—包含一个<em class="og">best _ hyperparameters . txt</em>文件的目录，该文件包含模型的超参数。</li><li id="4d47" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"> <em class="og">数据路径</em> </strong> —包含我们数据的目录。</li><li id="0f2d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir"><em class="og">LABEL _ ENCODER _ FILE</em></strong>—包含我们的LabelEncoder来转换我们的目标变量的文件。</li></ul><h2 id="8b8a" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 3.3为云构建创建Docker映像</strong></h2><p id="04de" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们需要创建一个Docker映像，供<a class="ae kv" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank">云构建</a>使用。我们创建此映像是因为默认Python映像提供的Python版本是3.9，但最新的TFX版本仅支持Python 3.8或更低版本。</p><p id="60ff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我们必须访问Vertex AI -&gt; Workbench并创建一个笔记本来定义我们的图像。这个步骤也可以在本地完成<a class="ae kv" href="https://cloud.google.com/container-registry/docs/quickstart" rel="noopener ugc nofollow" target="_blank">或者在云壳</a>中完成。</p><p id="ccfc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">打开终端并克隆repo:</p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="0f3a" class="nd kx iq oi b gy om on l oo op">git clone <a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx" rel="noopener ugc nofollow" target="_blank">https://github.com/arturlunardi/sentiment-analysis-tfx</a></span></pre><p id="6fe6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在存储库内部，打开<em class="og">create _ first _ container . ipynb</em>记事本，运行代码行在指定的路径中创建容器。</p><p id="442f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">运行后，您可以在<a class="ae kv" href="https://cloud.google.com/container-registry" rel="noopener ugc nofollow" target="_blank">容器注册表</a>中检查图像。</p><h2 id="25ac" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 3.4创建存储桶</strong></h2><p id="ab8f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了让我们能够将文件从我们的存储库复制到Google云存储的<a class="ae kv" href="https://cloud.google.com/storage/docs/creating-buckets" rel="noopener ugc nofollow" target="_blank">桶</a>中，我们需要创建文件夹来复制它们。</p><p id="864e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">访问项目中的云存储，并使用以下目录结构创建一个存储桶:</p><pre class="kg kh ki kj gt oh oi oj ok aw ol bi"><span id="5b2c" class="nd kx iq oi b gy om on l oo op">└───{{ GOOGLE_CLOUD_PROJECT }} + '-vertex-default'<br/>    └───{{ PIPELINE_NAME }}<br/>        ├───best_hyperparameters<br/>        ├───data<br/>        └───modules</span></pre><h2 id="fd81" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 3.5创建服务账户</strong></h2><p id="515d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了让GitHub Actions能够在Cloud Build中执行任务，我们需要创建一个用于身份验证的服务帐户。</p><p id="2b68" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">创建服务帐户并添加以下权限:</p><ul class=""><li id="dc66" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">AI平台管理员</li><li id="15a9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">顶点人工智能服务代理</li><li id="7e0e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">服务代理顶点人工智能自定义代码</li><li id="beef" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">云构建服务帐户</li><li id="de64" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">电视观众</li></ul><p id="2a7f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后在keys -&gt; Add Key -&gt; JSON中创建一个Key。</p><p id="91d5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后一步是必要的。由于我们要通过Vertex AI服务从Google云存储中读取文件，所以我们需要给Vertex AI服务帐户授予读取权限。</p><p id="e650" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后进入IAM和admin -&gt;勾选右侧包含Google提供的角色授予-&gt;找到名为:AI平台自定义代码服务代理-&gt;添加查看者角色的账户。</p><h2 id="bd9e" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 3.6在Git Repo中设置秘密</strong></h2><p id="dc4c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们的CI/CD管道将使用一些秘密的变量，所以我们需要添加它们。</p><p id="e5f0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">转到您的存储库-&gt;设置-&gt;机密-&gt;操作，并创建以下机密:</p><ul class=""><li id="02e0" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">GCP项目标识:你的项目标识</li><li id="aca3" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><strong class="lq ir">GCP _凭证</strong>:复制并粘贴上面创建的服务帐户的JSON密钥的全部内容</li></ul><h1 id="e801" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 4。CI/CD管道</strong></h1><blockquote class="oq or os"><p id="ba8c" class="lo lp og lq b lr mk jr lt lu ml ju lw ot mm lz ma ou mn md me ov mo mh mi mj ij bi translated">根据Park，c；在软件工程中，持续集成(CI)和持续交付(CD)是两个非常重要的概念。CI是集成变更(新特性、批准的代码提交等。)进入你的系统。CD是您可靠地、持续地部署这些变更的时候。CI和CD既可以单独执行，也可以耦合执行。</p></blockquote><p id="1b2d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了使我们的系统可伸缩，我们需要使用CI/CD实践。这将<strong class="lq ir">允许我们更快、更可靠地应用实验、集成和部署。</strong>让我们分析几个场景:</p><ul class=""><li id="60c5" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">有了新数据，我如何定期重新培训我的模型？</li><li id="50b5" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">添加新功能时，我如何确保我的系统不会崩溃？</li><li id="e8e6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">在部署我的模型之后，我如何通过API测试预测服务以确保输入和预测被正确解释？</li></ul><p id="c08b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在生产中实现ML不仅仅意味着通过API提供模型，还意味着实现一个可扩展的、适应变化的管道，允许快速实验并提供准确的结果。如果你想了解更多关于CI/CD管道及其重要性的知识，我推荐这篇谷歌文章，<a class="ae kv" href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning" rel="noopener ugc nofollow" target="_blank"> MLOps:机器学习中的连续交付和自动化管道</a>。</p><p id="eec9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个项目中，我们的CI/CD渠道将按如下方式工作:</p><ol class=""><li id="ed16" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj ow mv mw mx bi translated">我们创建了一个<a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx" rel="noopener ugc nofollow" target="_blank"> Github库</a>，包含了将在Vertex AI上运行的TFX管道的所有代码。</li><li id="0c6e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">我们在GitHub Actions上设置了一个流程，它将触发对主分支的每次推送，并将检查我们的存储库的特定目录中的更改。</li><li id="7ba6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">如果有变化，对每种类型的变化采取特定的行动。</li></ol><p id="6de8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">YAML文件后面的<a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx/blob/master/.github/workflows/ci.yaml" rel="noopener ugc nofollow" target="_blank">定义了一个GitHub动作，由对主分支的推送激活。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="ffd5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们理解重要的一点:GitHub Actions的<em class="og"> dorny/paths-filter </em>允许我们检测使用<em class="og"> push </em>时某些路径是否发生了变化。</p><p id="ff0e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这种情况下，我们看到两条路径:<em class="og"> tfx-pipeline </em>和<em class="og">模块</em>:</p><ul class=""><li id="3499" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">如果<em class="og"> tfx-pipeline </em>路径有变化，使用<em class="og">Build/full-pipeline-deployment . YAML</em>文件中提供的设置，通过<em class="og"> —替换</em>使用环境变量，启动云构建过程。</li><li id="f102" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">如果<em class="og">模块</em>路径有变化，而<em class="og"> tfx_pipeline </em>没有变化(为了避免重复运行)，则使用<em class="og">Build/partial-pipeline-deployment . YAML</em>文件中提供的设置启动云构建过程，通过<em class="og"> —替换</em>使用环境变量。</li></ul><p id="8275" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在让我们仔细分析这两个文件。</p><h2 id="5ad6" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 4.1 </strong> <a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx/blob/master/build/full-pipeline-deployment.yaml" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">全管道部署. yaml </strong> </a></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/f4729f70a23465f93428cff2849d6042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XyBLPwn7G5coS1OWlJcCbg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nq">图二。</strong>整个CI/CD管道。本图片转载自Park，c .创作并分享的作品<a class="ae kv" href="https://github.com/deep-diver/Model-Training-as-a-CI-CD-System" rel="noopener ugc nofollow" target="_blank">；并根据</a><a class="ae kv" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"> Apache 2.0许可证</a>中描述的条款使用。来源:<a class="ae kv" href="https://cloud.google.com/blog/topics/developers-practitioners/model-training-cicd-system-part-i" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/blog/topics/developers-从业者/模型-培训-cicd-system-part-i </a></p></figure><p id="3901" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果在包含与<strong class="lq ir">管道设置</strong>相关的文件的目录中有变化，流程将启动云构建过程，该过程将克隆整个储存库，仅将变化的模块复制到Google云存储桶中的模块目录，基于代码变化构建新的Docker映像，将新映像上传到Google容器注册表，并在Vertex AI中提交TFX管道。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="4c01" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一次阅读可能很难，但如果我们一步一步地阅读，我们就会明白发生了什么:</p><ol class=""><li id="87b8" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj ow mv mw mx bi translated">我们克隆整个存储库</li><li id="5e67" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">我们将这个存储库中的一些文件复制到指定的桶中</li><li id="f14c" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">我们编译管道来检查是否一切正常</li><li id="f399" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">我们用<em class="og"> tfx管道创建</em>创建管道</li><li id="4e44" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">我们用<em class="og"> tfx run create </em>创建顶点AI中的游程</li></ol><p id="7a4a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该文件中有三个要点:</p><ul class=""><li id="8000" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><em class="og"> tfx pipeline create </em>中的<em class="og"> — build-image </em>标志用于创建我们环境的新Docker映像</li><li id="7347" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">云构建使用的Docker镜像是<em class="og">gcr.io/$_PROJECT/cb-tfx:latest</em>，也就是我们在步骤3.3中创建的镜像</li><li id="e729" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">我们将<em class="og"> tfx运行创建</em>引擎设置为<em class="og">顶点</em>，因为我们正在向顶点AI提交管道。</li></ul><h2 id="9980" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 4.2 </strong> <a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx/blob/master/build/partial-pipeline-deployment.yaml" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">局部-管道-部署. yaml </strong> </a></h2><p id="ac10" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果目录中包含<strong class="lq ir">模型代码、预处理器代码、训练数据、超参数或标签编码器</strong>的变更</p><ol class=""><li id="b5bf" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj ow mv mw mx bi translated">该流程将启动一个云构建过程，该过程将克隆整个存储库</li><li id="4c29" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">仅将更改的模块复制到Google云存储桶中的模块目录</li><li id="3e89" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj ow mv mw mx bi translated">在Vertex AI中提交TFX管道，无需建立新的Docker映像</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/8a83090a7ee7c6d4ebd9454c7f01eb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fY_jLaXlPxZhk2NRfeOKaA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nq">图3。</strong>部分CI/CD管道。本图片转载自Park，c .创作并分享的作品<a class="ae kv" href="https://github.com/deep-diver/Model-Training-as-a-CI-CD-System" rel="noopener ugc nofollow" target="_blank">；并根据</a><a class="ae kv" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"> Apache 2.0许可证</a>中描述的条款使用。来源:<a class="ae kv" href="https://cloud.google.com/blog/topics/developers-practitioners/model-training-cicd-system-part-i" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/blog/topics/developers-从业者/模型-培训-cicd-system-part-i </a></p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="9d10" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该文件实际上与<em class="og">full-pipeline-deployment . YAML</em>相同，不同之处在于:</p><ul class=""><li id="7bd3" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><em class="og"> tfx管道创建</em>中的<em class="og"> —构建映像</em>标志已被移除，因为我们不需要创建新的Docker映像</li><li id="1dca" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">因为没有改变管道设置，我们不需要编译它，移除<em class="og"> tfx管道编译</em></li></ul><h1 id="d95d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak"> 5。监控</strong></h1><p id="8aa5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当将一个模型部署到产品中时，<strong class="lq ir">我们需要不断地监控它。</strong>我们的模型已经在某个数据集上进行了训练，因此为了保持性能，它将暴露的数据必须具有相同的分布。</p><p id="ce42" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于模型不是在静态环境中运行的，<strong class="lq ir">由于训练数据和预测数据之间的偏差，它们的性能可能会随着时间而降低。</strong>偏差的一些例子可能是:</p><ul class=""><li id="204a" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">新词汇(新语言)的引入</li><li id="2a6b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">测量单位的变化(米到公里)</li><li id="0258" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">消费者行为因某些外部事件而改变(疫情)</li></ul><p id="2818" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于模型没有受到这些变化的影响，因此性能可能会受到影响。所以我们需要监控:</p><ul class=""><li id="764d" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">数据如何随时间变化</li><li id="5bf6" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">当需要重新训练模型以捕捉新模式时</li><li id="b21f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">正在摄取的数据是否与我的模型所接触到的数据相同</li></ul><p id="f573" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个例子中，我们将记录模型中所有的<a class="ae kv" href="https://cloud.google.com/ai-platform/prediction/docs/online-predict#requesting_logs_for_online_prediction_requests" rel="noopener ugc nofollow" target="_blank">请求/响应日志</a>。我们的模型将在AI平台上可用，<strong class="lq ir">记录将以raw格式(JSON)保存在一个</strong><a class="ae kv" href="https://cloud.google.com/bigquery/docs" rel="noopener ugc nofollow" target="_blank"><strong class="lq ir">big query</strong></a><strong class="lq ir">表</strong>中。</p><p id="f0c5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下图显示了我们将要创建的架构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/740f100bee479daad3ecf1b330e04870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cd5CkBAJDvrrWLudvXo0NA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nq">图4。</strong>监控架构。这张图片是从谷歌创作和<a class="ae kv" href="https://developers.google.com/readme/policies" rel="noopener ugc nofollow" target="_blank">分享的作品中复制的，并根据</a><a class="ae kv" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">知识共享4.0归属许可</a>中描述的条款使用。来源:<a class="ae kv" href="https://cloud.google.com/architecture/ml-modeling-monitoring-analyzing-ai-platform-prediction-in-big-query" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/architecture/ml-建模-监控-分析-ai-平台-预测-大查询</a></p></figure><h2 id="88ab" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 5.1 </strong>为BigQuery启用请求-响应日志记录</h2><p id="2af9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">默认情况下，AI平台预测服务不提供关于请求的日志信息，因为日志会产生成本。模型可以接收非常多的请求，导致相当大的成本，所以我们需要显式地启用注册。代码在<a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx/blob/master/activate_logging_requests.ipynb" rel="noopener ugc nofollow" target="_blank">activate _ logging _ requests . ipynb文件</a>中。</p><p id="b9f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在启用日志之前，我们需要创建一个<a class="ae kv" href="https://cloud.google.com/bigquery/docs/tables" rel="noopener ugc nofollow" target="_blank"> BigQuery表</a>来保存日志。</p><p id="8469" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">每个表都需要在一个<a class="ae kv" href="https://cloud.google.com/bigquery/docs/datasets-intro" rel="noopener ugc nofollow" target="_blank"> BigQuery数据集</a>中，所以我们定义数据集和表名并创建数据集。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="8e25" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们定义表所期望的数据模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="ac53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们创建表格。<em class="og">注意，我们没有为表格设置任何到期时间，如果您想了解更多信息，请前往</em> <a class="ae kv" href="https://cloud.google.com/bigquery/docs/tables" rel="noopener ugc nofollow" target="_blank"> <em class="og">文档</em> </a> <em class="og">。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="4c1d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们可以为我们的模型启用日志记录了。重要的一点是我们需要定义我们想要激活记录的模型的版本。对于模型的每个版本，我们需要显式地启用日志记录。</p><p id="05ff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们在模型中搜索最新版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="398e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们启用日志记录。<em class="og"> samplingPercentage </em>参数定义了我们想要记录的请求的百分比，在我们的例子中，我们设置1.0，也就是说，我们记录100%的记录。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="97a1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们的表中会有我们模型的所有版本的原始记录。</p><h2 id="b03d" class="nd kx iq bd ky ne nf dn lc ng nh dp lg lx ni nj li mb nk nl lk mf nm nn lm no bi translated"><strong class="ak"> 5.2可视化我们的数据</strong></h2><p id="0034" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如我们在下面看到的，我们的数据是以JSON格式记录的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/3e0228098e17d307b748b2a38e63fb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zTFYQp8B3126Y2JGpHLfsA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nq">图五。</strong> Raw格式数据(JSON)(图片由作者提供)。</p></figure><p id="1e57" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了改进我们的视图，我们可以为我们的数据创建一个特定的视图。让我们来理解BigQuery表模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="dd99" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在下表中，我们分别显示了存储在BigQuery表的<em class="og"> raw_data </em>和<em class="og"> raw_prediction </em>列中的数据示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="3229" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，在文件<a class="ae kv" href="https://github.com/arturlunardi/sentiment-analysis-tfx/blob/master/create_view.py" rel="noopener ugc nofollow" target="_blank"> create_view.py </a>中我们定义了视图的创建。首先，我们创建一些辅助函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="0be4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">之后，我们定义将创建视图的函数，接收所有参数。让我们把它分成四个部分:</p><p id="597e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">1.我们定义特征和目标变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="a590" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">2.我们定义两个变量<em class="og"> json_features_extraction </em>和<em class="og">JSON _ prediction _ extraction</em>。这些变量包含可以在SQL语句中输入的格式的属性和预测值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="236f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">3.我们创建了<em class="og"> sql_script </em>变量，它包含了<em class="og"> CREATE或REPLACE VIEW </em>语句。该语句包含几个标记，这些标记在字符串中使用@作为前缀进行标记。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="4c31" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">4.最后，我们用前面定义的变量替换SQL语句中的标记，并创建视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="34b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们可以访问BigQuery控制台并访问我们的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="88d9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">输出和这个差不多。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/0dfb56122401b508c83250c621b333a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taCRJjEbeIN0LSdwa-8L9A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd nq">图6。</strong>个性化BigQuery视图(图片由作者提供)。</p></figure><p id="afc6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们也可以使用<a class="ae kv" href="https://cloud.google.com/looker" rel="noopener ugc nofollow" target="_blank"> Google Looker </a>来创建交互式仪表盘和我们数据的可视化。</p><p id="b5af" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要清理该项目中使用的所有Google Cloud资源，您可以<a class="ae kv" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#shutting_down_projects" rel="noopener ugc nofollow" target="_blank">删除您在教程中使用的Google Cloud项目</a>。</p><h1 id="a9a7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6。结论</h1><p id="4611" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在云环境中开发管道可以让我们的系统变得可伸缩，并且不容易出错。部署模型只是整个过程的一部分，为了保持我们预测的性能，我们需要不断地监控推论并分析哪些数据被发送到我们的模型。</p><p id="c5d9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">CI/CD管道为我们的系统提供了响应能力，允许更快的测试周期、模型部署中更高的可靠性、改进的代码质量和更短的反馈循环。</p><h1 id="891a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">7。参考文献</h1><p id="0a95" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">[1] <a class="ae kv" href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> MLOps:机器学习中的连续交付和自动化管道</strong></a>(2020年1月07日)，谷歌。</p><p id="7316" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[2]帕克，c；保罗，S. <a class="ae kv" href="https://cloud.google.com/blog/topics/developers-practitioners/model-training-cicd-system-part-i" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">模型训练作为一个CI/CD系统:第一部分</strong></a>(2021年10月6日)，谷歌。</p><p id="8308" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[3] <a class="ae kv" href="https://cloud.google.com/architecture/ml-modeling-monitoring-logging-serving-requests-using-ai-platform-prediction" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> ML模型监控:利用AI平台预测记录服务请求</strong></a>(2021年3月12日)，Google。</p><p id="9fb8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[4] <a class="ae kv" href="https://cloud.google.com/architecture/ml-modeling-monitoring-analyzing-ai-platform-prediction-in-big-query" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">分析AI平台预测日志在big query</strong></a>(2021年3月12日)，Google。</p><p id="6875" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[5]迪凡特，A. L. <a class="ae kv" rel="noopener" target="_blank" href="/how-i-deployed-my-first-machine-learning-model-1147c04c449b"> <strong class="lq ir">我如何部署我的第一个机器学习模型</strong></a>(2021年12月15日)，中。</p><p id="5722" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">[6] <a class="ae kv" href="https://www.tensorflow.org/tfx/tutorials/tfx/cloud-ai-platform-pipelines" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">云AI平台管道上的TFX</strong></a>(2021年11月05日)，TensorFlow。</p><p id="fbfd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://www.tensorflow.org/tfx/tutorials/tfx/gcp/vertex_pipelines_simple" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">【简单TFX】管道为顶点管道</strong></a><strong class="lq ir"/>(2021年12月08日)，TensorFlow。</p></div></div>    
</body>
</html>