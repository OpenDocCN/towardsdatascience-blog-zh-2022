<html>
<head>
<title>How to Handle an Autoregressive Model over Multiple Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理多个时间序列的自回归模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-handle-autoregressive-model-over-multiple-time-series-4604fdd96e2b#2022-11-29">https://towardsdatascience.com/how-to-handle-autoregressive-model-over-multiple-time-series-4604fdd96e2b#2022-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9fce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用工厂模式设计代码，避免数据泄露</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b83cd8925c4463aacc8c776a612f5fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F29CFmYH83ax1Y9DP8wgdw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道有时会变得复杂。波兰 2022。(作者供图)。</p></figure><h1 id="d024" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">介绍</h1><p id="2fe1" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">当涉及到<strong class="ls iu">数据准备</strong>时，自回归模型是“更难”实现的模型之一。由于模型预计会产生每日或每小时的预测，数据集本身预计会随着每个新的观察结果而增长和扩展，这需要模型进行定期的再训练。因此，处理数据成为一个高度动态的过程，必须格外小心，以确保在任何给定的时间点都不会出现<em class="mm">数据泄漏</em>。</p><p id="5ac7" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">令人惊讶的是，但不幸的是，大多数关于自回归的教程更多地强调模型和算法，而不是太关注数据准备方面的事情。由于他们的目标是解释自回归概念(他们做得很好，例如:<a class="ae ms" href="https://machinelearningmastery.com/autoregression-models-time%20series-forecasting-python/" rel="noopener ugc nofollow" target="_blank">机器学习大师</a>或<a class="ae ms" rel="noopener" target="_blank" href="/time series-from-scratch-autoregression-theory-and-implementation-f8c614f738f2">第 1 篇</a>，<a class="ae ms" rel="noopener" target="_blank" href="/deep-autoregressive-models-41b21c8a140c">第 2 篇</a>来自《走向数据科学》)，数据准备的处理仅限于单变量或多变量时间序列。<a class="ae ms" href="https://www.tensorflow.org/tutorials/structured_data/time_series" rel="noopener ugc nofollow" target="_blank">Tensorflow.org</a>提供了更广泛的解释，尽管他们的方法不容易扩展到<strong class="ls iu"> <em class="mm">多个多变量</em> </strong>时间序列的情况。</p><p id="8f0e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">在本文中，我将向您展示如何利用<a class="ae ms" href="https://realpython.com/factory-method-python/" rel="noopener ugc nofollow" target="_blank">工厂模式</a>来封装不同抽象层次的逻辑，而又不丧失代码的灵活性。为了演示，我将使用与 Tensorflow 教程中使用的相同的数据集(<a class="ae ms" href="https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip" rel="noopener ugc nofollow" target="_blank"> Jena Climate Dataset </a>)由<a class="ae ms" href="https://www.bgc-jena.mpg.de/wetter/" rel="noopener ugc nofollow" target="_blank"> Max Planck Institute </a>提供。然而，为了使事情变得复杂一点，我将创建一些带有随机扰动的数据副本，以模拟我们的模型的任务是预测几个地理位置的天气的情况。此外，包含随机间隔“来来去去”的观察值的时间序列数据集并不少见。为了从数据集中获得尽可能多的训练示例，我还将考虑这一事实。</p><h1 id="9e57" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">让数据更真实一点…</h1><p id="03ff" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">为简单起见，我将跳过处理特征生成的部分，集中在<code class="fe mt mu mv mw b">T (degC)</code>栏。假设我们的模型的任务是在给定<code class="fe mt mu mv mw b">first</code>、<code class="fe mt mu mv mw b">last</code>、<code class="fe mt mu mv mw b">min</code>和<code class="fe mt mu mv mw b">max</code>温度的情况下预测几个城市的<code class="fe mt mu mv mw b">mean</code>温度。当然，您可以将相同的推理扩展到数据集中的所有列，或者选择不同的目标(例如，从过去的平均温度预测平均温度)。一切都取决于你。然而，我在这里关注的是<strong class="ls iu">从多个多维系列</strong>中构建训练示例，特别注意<strong class="ls iu">避免数据泄露</strong>和“类似生产”的性质，新的观察结果每天都会出现。</p><h1 id="a69f" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">获取数据</h1><p id="03e4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们从获取数据并按每天的时间间隔重新采样开始。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="5b54" class="nb kz it mw b be nc nd l ne nf">import numpy as np<br/>import pandas as pd<br/>import tensorflow as tf<br/><br/><br/>zip_path = tf.keras.utils.get_file(<br/>    origin="https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip",<br/>    fname="jena_climate_2009_2016.csv.zip",<br/>    extract=True,<br/>)<br/>csv_path, _ = os.path.splitext(zip_path)<br/><br/>df = pd.read_csv(csv_path) \<br/>    .assign(date=lambda x: pd.to_datetime(x["Date Time"])) \<br/>    .set_index("date") \<br/>    .get(["T (degC)"]) \<br/>    .resample("D") \<br/>    .aggregate(["first", "last", "min", "max", "mean"])<br/><br/>df.columns = [c[1] for c in df.columns]</span></pre><p id="86dc" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">创建了<code class="fe mt mu mv mw b">[first, last, min, max]</code>列之后，让我们使用烛台来显示数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/f77bbaa69cf15dee1a64b330f78e9560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YCc1uw5b8-C3lan-.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。蜡烛代表温度的每日变化。蓝线描绘了平均温度，这是我们的目标。(图片由作者提供)。</p></figure><h1 id="67dd" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">嘲笑这个案子</h1><p id="354e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，是时候模拟一个更现实的场景了，在这个场景中，数据可用性并不理想。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="528e" class="nb kz it mw b be nc nd l ne nf">np.random.seed(42)<br/><br/>CITIES = [<br/>    "London", "Oslo", "Warsaw", "Copenhagen", "Amsterdam", "Dublin",<br/>    "Brussels", "Stockholm", "Prague", "Paris", "Rome", "Budapest",<br/>    "Lisbon", "Vienna", "Madrid", "Riga", "Berlin", "Belgrade", "Sofia",<br/>]<br/><br/>series = {}<br/>for city in CITIES:<br/>    X = df.copy()<br/>    X += 0.75 * X.std() * np.random.randn()<br/><br/>    bounds = np.random.randint(0, len(X), size=2)<br/>    bounds = sorted(bounds)<br/>    slc = slice(*bounds)<br/>    X = X.iloc[slc]<br/><br/>    series[city] = X</span></pre><p id="8fcf" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">经过这…修改后，我们的数据如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/e317fe43d8f5e2393fc11559c8235c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/0*wsNClcpG5ILSFO4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。热图显示目标值，即平均温度。(图片由作者提供)。</p></figure><p id="ae3e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这不就是数据在现实中的表现吗？如您所见，根据城市的不同，我们的可用性也有所不同。尤其是在伦敦，我们对序列长度的选择可能是有限的。</p><h1 id="63e5" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">生成样本</h1><p id="2bab" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在自回归中，一种常见的方法是使用滚动窗口，该窗口将沿时间维度滑动，并将其分为<em class="mm">历史</em>和<em class="mm">未来</em>子序列。随着窗口向前移动(这里，步长为一天)，每次获得一个新的<code class="fe mt mu mv mw b">(X, y)</code>对。然后将这些对输入模型进行训练。</p><p id="43fc" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">定义窗口时，需要考虑两个因素。首先，窗口的<em class="mm">历史</em>部分决不能进入不应该观察数据的时间区域。否则，数据泄漏是超过保证！反之，窗口的<em class="mm">未来</em>部分可以进入其中。但是，对于训练、验证和测试子集，我们应该确保数据存在，以便可以将预测值与真实值进行比较。在推断过程中，它是不同的。从技术上讲，今天不可能观察明天的数字。但是当太阳再次升起的时候，我们可以比较这些预测。</p><p id="1dba" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">其次，时间“地平线”将不断向前移动。对于模型的训练来说，这意味着我们的历史数据集在增长，时间范围也应该推至未来。</p><p id="7d4c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">正如你所看到的，整个形势相当活跃。除非设计合理，否则代码会很快失去透明性并导致错误。</p><h1 id="1396" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">解决办法</h1><p id="86c7" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">解决问题的关键是把责任分配给不同的阶层。例如，将系列分成训练和测试部分不应该是滚动窗口逻辑的一部分。类似地，一旦窗口滚动，它应该只生成数据样本，而不需要关心日期。</p><p id="88fd" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">想一想，可以辨析一下下面的责任链。</p><ol class=""><li id="167a" class="ni nj it ls b lt mn lw mo lz nk md nl mh nm ml nn no np nq bi translated">首先，有一些存储参数的<em class="mm">配置</em>文件是有用的。通常，我会有两个独立的文件，比如<code class="fe mt mu mv mw b">development.ini</code>和<code class="fe mt mu mv mw b">production.ini</code>以及一个<code class="fe mt mu mv mw b">get_config</code>函数。</li><li id="422a" class="ni nj it ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">一旦加载了常量，让我们使用一个<code class="fe mt mu mv mw b">TimeSplitter</code>类来计算时间间隔并给出边界日期。这些日期将定义培训、测试和验证部分的开始和结束。</li><li id="a8f6" class="ni nj it ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">日期实际上告诉了滚动窗口应该在哪里运行。然而，如前所述，我们不希望他们管理时间。滚动窗口只会生成样本，这就是<em class="mm">工厂模式</em>的用武之地。让我们用一个<code class="fe mt mu mv mw b">WindowFactory</code>类来消费边界并创建<code class="fe mt mu mv mw b">Window</code>对象。</li><li id="d715" class="ni nj it ls b lt nr lw ns lz nt md nu mh nv ml nn no np nq bi translated">最后，根据需要，我们可以构造不同种类的<code class="fe mt mu mv mw b">Window</code>(例如，有或没有步长、平均窗口等。).尽管如此，一旦工厂类将日期转换成索引，每个<code class="fe mt mu mv mw b">Window</code>将只被给予一个时间序列块来翻转并生成<code class="fe mt mu mv mw b">(X, y)</code>对。</li></ol><h1 id="fc26" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">常数</h1><p id="1cff" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">开始之前，让我们就几个参数达成一致。</p><h2 id="f6c2" class="nw kz it bd la nx ny dn le nz oa dp li lz ob oc lk md od oe lm mh of og lo oh bi translated">development.ini</h2><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="901d" class="nb kz it mw b be nc nd l ne nf">[constants]<br/>horizon = 2022-02-28<br/>test_split_days = 30<br/>val_split_days = 90<br/>history_days = 21<br/>future_days = 7</span></pre><p id="1060" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">为了澄清约定:<code class="fe mt mu mv mw b">horizon</code>定义了数据集的最终“盲化”。它应该是“今天”，除此之外还不存在任何观察。在生产中，该参数预计每天更新。然后，分别在区间[-inf，h-91]、[h-90，h-31]和[h-30，h]上定义训练集、验证集和测试集。最后，在这个场景中，<code class="fe mt mu mv mw b">Window</code>需要支持在已知过去 21 天的情况下，对未来 7 天进行预测的模型。</p><p id="d4d9" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">我将离开实施<code class="fe mt mu mv mw b">get_config</code>...一旦我们读取了数据，下一步就是:</p><h1 id="f875" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">时间分离器</h1><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="138d" class="nb kz it mw b be nc nd l ne nf">from typing import Optional, Text, Tuple, TypeVar<br/><br/>import pandas as pd<br/><br/>TS = TypeVar("TS")<br/><br/><br/>class TimeSplitter:<br/>    def __init__(<br/>        self,<br/>        horizon: Text,<br/>        val_split_days: int,<br/>        test_split_days: int,<br/>        history_days: int,<br/>        future_days: int,<br/>    ) -&gt; TS:<br/>        self.horizon = pd.Timestamp(horizon)<br/>        self.val_split_days = pd.Timedelta(val_split_days, unit="days")<br/>        self.test_split_days = pd.Timedelta(test_split_days, unit="days")<br/>        self.history_days = pd.Timedelta(history_days, unit="days")<br/>        self.future_days = pd.Timedelta(future_days, unit="days")<br/><br/>        # here you can put additional assertion logic such as non-negative days, etc.<br/><br/>    @property<br/>    def _test_upto(self) -&gt; pd.Timestamp:<br/>        return self.horizon<br/><br/>    @property<br/>    def _test_from(self) -&gt; pd.Timestamp:<br/>        return self.horizon - self.test_split_days - self.history_days<br/><br/>    @property<br/>    def _validation_upto(self) -&gt; pd.Timestamp:<br/>        return self.horizon - self.test_split_days - pd.Timedelta(1, unit="days")<br/><br/>    @property<br/>    def _validation_from(self) -&gt; pd.Timestamp:<br/>        return self.horizon - self.val_split_days - self.history_days<br/><br/>    @property<br/>    def _train_upto(self) -&gt; pd.Timestamp:<br/>        return self.horizon - self.val_split_days - pd.Timedelta(1, unit="days")<br/><br/>    @property<br/>    def _train_from(self) -&gt; None:<br/>        return None  # defined only for consistency<br/><br/>    def get_boundaries(self, subset: Optional[Text] = "training") -&gt; Tuple[pd.Timestamp]:<br/>        if subset == "training":<br/>            return self._train_from, self.train_upto<br/>        elif subset == "validation":<br/>            return self._validation_from, self._validation_upto<br/>        elif subset == "test":<br/>            return self._test_from, self._test_upto<br/>        else:<br/>            raise NotImplementedError(f"Requested subset '{subset}' is not supported.")</span></pre><p id="92e6" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如前所述，<code class="fe mt mu mv mw b">TimeSplitter</code>的唯一目标是找出界限。通过额外的逻辑，我们可以针对导致病态结果的情况引入断言、警告或错误。此外，我们可以用一个<code class="fe mt mu mv mw b">Enum</code>类替换<code class="fe mt mu mv mw b">if-else</code>语句，将选择限制在几个预定义的选项中。这可能会超出本文的范围，所以让我们继续实现工厂类。</p><h1 id="6e61" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">窗户工厂</h1><p id="a43e" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">现在，该上工厂课了。一旦计算出日期时间界限，我们希望该类使用这些信息来修剪序列并生成窗口。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="8e75" class="nb kz it mw b be nc nd l ne nf">class WindowFactory:<br/>    def __init__(<br/>        self,<br/>        history_days: int,<br/>        future_days: int,<br/>        first_allowed_date: Optional[pd.Timestamp] = None,<br/>        last_allowed_date: Optional[pd.Timestamp] = None,<br/>    ) -&gt; WF:<br/>        self.hdays = history_days<br/>        self.fdays = future_days<br/>        self.lower_date = first_allowed_date<br/>        self.upper_date = last_allowed_date<br/><br/>    def __repr__(self) -&gt; Text:<br/>        lower = self.lower_date or "-inf"<br/>        upper = self.upper_date or "+inf"<br/>        interval = f"['{lower}':'{upper}']"<br/>        shape = f"({self.hdays}, {self.fdays})"<br/>        name = self.__class__.__name__<br/><br/>        return f"{name}(interval={interval}, shape={shape})"<br/><br/>    def create(self, df: pd.DataFrame) -&gt; Optional[W]:<br/>        t0 = self.lower_date if self.lower_date is pd.NaT else None<br/>        t1 = self.upper_date if self.upper_date is pd.NaT else None<br/>        slc = slice(t0, t1)<br/>        chunk = df.loc[slc]<br/><br/>        if (width := self.hdays + self.fdays) &gt; len(chunk):<br/>            print(f"Not possible to spawn a window of width={width}.")<br/>            return None<br/><br/>        return Window(<br/>            chunk,<br/>            history_days=self.hdays,<br/>            future_days=self.fdays,<br/>        )</span></pre><p id="8243" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">有几种方法可以实现该类。核心功能由<code class="fe mt mu mv mw b">.create</code>方法提供。它期望一个时间序列作为一个<code class="fe mt mu mv mw b">pd.DataFrame</code>，它的目标是正确地分割输入数据。这里，我们利用了数据帧中的索引是<code class="fe mt mu mv mw b">pd.DateTimeIndex</code>对象的事实。然而，如果我们使用 plain numpy，想法将是相同的。</p><p id="e005" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">如果需要，该方法还可以扩展到支持不同种类的窗口。在我们的版本中，我们只使用一种类型的<code class="fe mt mu mv mw b">Window</code>，所以不需要其他输入参数。</p><p id="2622" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">最后，我们引入<code class="fe mt mu mv mw b">__repr__</code>方法来显示工厂在时间间隔和窗口形状方面的“能力”。纯粹是为了调试和可读性。</p><h1 id="e3de" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">窗户</h1><p id="ccbb" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">那么如何定义<code class="fe mt mu mv mw b">Window</code>？毕竟，日期时间和索引管理已经完成，我们需要的只是一个产生样本的对象。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="68aa" class="nb kz it mw b be nc nd l ne nf">W = TypeVar("W")<br/><br/><br/>class Window:<br/>    def __init__(<br/>        self,<br/>        chunk: pd.DataFrame,<br/>        history_days: int,<br/>        future_days: int,<br/>    ) -&gt; W:<br/>        self.X = chunk.to_numpy()<br/>        self.hdays = history_days<br/>        self.fdays = future_days<br/><br/>    @property<br/>    def width(self) -&gt; int:<br/>        return self.hdays + self.fdays<br/><br/>    def __len__(self) -&gt; int:<br/>        return len(self.X) - self.width + 1<br/><br/>    def __repr__(self) -&gt; Text:<br/>        name = self.__class__.__name__<br/>        iters = f"iters: {len(iters)}"<br/><br/>        return f"{name}[{iters}]({self.hdays, self.fdays})"<br/><br/>    def get_generator(self) -&gt; Generator[np.ndarray, None, None]:<br/>        for idx in range(len(self)):<br/>            slc = slice(idx, idx + self.width)<br/><br/>            yield self.X[slc]</span></pre><p id="5c59" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><code class="fe mt mu mv mw b">.get_generator</code>方法是不言自明的。它通过以一天为步长在时间维度上滚动来给出时间序列的片段。这里，<code class="fe mt mu mv mw b">__len__</code>方法用于表示<code class="fe mt mu mv mw b">Window</code>将产生的样本数。例如，如果序列包含 5 条记录，窗口的宽度是 2，它应该滚动 4 次(因此最后是<code class="fe mt mu mv mw b">+ 1</code>)。</p><p id="5b49" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">但是等等！</p><p id="f4fc" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">生成器不会产生<code class="fe mt mu mv mw b">(X, y)</code>对，对吗？正确。</p><p id="dc54" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">不过，形成对子很容易。稍加修改，我们可以重新定义生成器方法:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="f71b" class="nb kz it mw b be nc nd l ne nf">def get_sample_pairs(self) -&gt; Generator[np.ndarray, None, None]:<br/>    for idx in range(len(self)):<br/>        slc_X = slice(idx, idx + self.hdays)<br/>        slc_y = slice(idx + self.hdays, idx + self.width)<br/><br/>        yield (self.X[slc_X, :4], self.X[slc_y, -1])</span></pre><h1 id="ab64" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">tf.data 版本</h1><p id="262c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">但是，如果您选择使用 Keras，您可能会发现用包含对的<code class="fe mt mu mv mw b">tf.data.Dataset</code>对象替换生成器并将其传递到模型中是很有用的。为了实现这一点，让我们通过再添加一个方法来使<code class="fe mt mu mv mw b">Window</code>对象可调用。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="f8dd" class="nb kz it mw b be nc nd l ne nf">    def __call__(self) -&gt; tf.data.Dataset:<br/>        generator = lambda: self.get_generator()<br/>        signature = tf.TensorSpec(<br/>            shape=(self.width, 5),<br/>            dtype=tf.float32,<br/>            name=self.__class__.__name__,<br/>        )<br/>        ds = tf.data.Dataset.from_generator(<br/>            generator,<br/>            output_signature=signature,<br/>        )<br/>        ds = ds.map(lambda tensor: [<br/>            tensor[:self.hdays, :4],<br/>            tensor[self.hdays:self.width, -1:],<br/>        ])<br/><br/>        return ds</span></pre><p id="5c68" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">使用这种方法的缺点是，我们创建了一个惰性加载机制，只是为了急切地消耗数据。另一方面，使用<code class="fe mt mu mv mw b">tf.data</code>为我们提供了很多有用的函数(如<code class="fe mt mu mv mw b">prefetch</code>、<code class="fe mt mu mv mw b">shuffle</code>、<code class="fe mt mu mv mw b">batch</code>或<code class="fe mt mu mv mw b">concatenate</code>)，使得数据在后期的处理更加容易。</p><h1 id="ffc1" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">整个流程</h1><p id="4739" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">让我们重新审视我们的解决方案，并借助实现的逻辑创建完整的训练、测试和验证数据集。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="3ce3" class="nb kz it mw b be nc nd l ne nf"># from config...<br/>horizon = "2014-01-01"<br/>test_split_days = 30<br/>val_split_days = 90<br/>history_days = 21<br/>future_days = 7<br/><br/><br/>def get_window_factory(splitter, name):<br/>    bounds = splitter.get_boundaries(name)<br/><br/>    return WindowFactory(<br/>        history_days=history_days,<br/>        future_days=future_days,<br/>        first_allowed_observation_date=bounds[0],<br/>        last_allowed_observation_date=bounds[1],<br/>    )<br/><br/><br/>def get_dataset(factory, series):<br/>    windows = {}<br/>    for city, X in series.items():<br/>        window = factory.create(X)<br/>        if window is None:<br/>            print("City skipped:", city)<br/>            continue<br/>    <br/>        windows[city] = window<br/>   <br/>    _, window = windows.popitem()<br/>    ds = window()<br/>    for window in windows.values():<br/>        _ds = window()<br/>        ds = ds.concatenate(_ds)<br/>    <br/>    return ds<br/><br/><br/>if __name__ == "__main__":<br/>    splitter = TimeSplitter(<br/>        horizon=horizon,<br/>        test_split_days=test_split_days,<br/>        val_split_days=val_split_days,<br/>        history_days=21,<br/>        future_days=7,<br/>    )<br/><br/>    training_factory = get_window_factory(splitter, "training")<br/>    validation_factory = get_window_factory(splitter, "validation")<br/>    test_factory = get_window_factory(splitter, "test")<br/>    <br/>    ds_train = get_dataset(training_factory, series)<br/>    df_val = get_dataset(validation_factory, series)<br/>    df_test = get_dataset(test_factory, series)</span></pre><h1 id="851b" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="df0a" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这就是了！一旦我们加载了常量并使用<code class="fe mt mu mv mw b">TimeSplitter</code>分割了日期，我们就分别为每个数据集创建了三个工厂。然后使用<code class="fe mt mu mv mw b">tf.data.Datasets</code>对象生成并收集样本。然而，我们选择参数化代码，过程保持不变，尽管如果数据集太窄(或<code class="fe mt mu mv mw b">Window</code>的宽度太大)，我们可能最终只有几个样本。</p><p id="f81c" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">为了验证这种方法，您可以断言样本总数。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="8d64" class="nb kz it mw b be nc nd l ne nf">count_1 = len([x for x in ds.as_numpy_iterator()])<br/>count_2 = sum([len(w) for w in windows.values()])<br/><br/>assert count_1 == count_2</span></pre><p id="922e" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">这段代码当然可以改进。然而，正如您所看到的，这种方法使用起来很简单，代码应该很容易维护。它也适用于任何一般的多变量 T2 时间序列。这完全取决于你如何想象<code class="fe mt mu mv mw b">(X, y)</code>-对的样子(例如标量，向量，张量，...)?尽管如此，通过应用这个简单的模式，您几乎可以将数据准备代码从实际模型中完全分离出来，允许您快速迭代您的想法，而不用担心数据泄漏会在您的结果中出现。</p><p id="927f" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated">*本文使用了马克斯·普朗克研究所在<a class="ae ms" href="https://www.bgc-jena.mpg.de/wetter/weather_data.html" rel="noopener ugc nofollow" target="_blank"> Creative Common License 下的数据集。</a></p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="aaa9" class="pw-post-body-paragraph lq lr it ls b lt mn ju lv lw mo jx ly lz mp mb mc md mq mf mg mh mr mj mk ml im bi translated"><em class="mm">原载于</em><a class="ae ms" href="https://zerowithdot.com/multi-time-series-data-generator/" rel="noopener ugc nofollow" target="_blank"><em class="mm"/></a><em class="mm">。</em></p></div></div>    
</body>
</html>