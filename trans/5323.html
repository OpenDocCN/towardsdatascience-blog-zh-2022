<html>
<head>
<title>Pandas Multi-Index Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫多指数解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pandas-multi-index-explained-6f11d880c0e5#2022-11-29">https://towardsdatascience.com/pandas-multi-index-explained-6f11d880c0e5#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a18" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">分级索引</h2></div><p id="16a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在前几章中，我们看到了如何使用索引。我们要么使用<code class="fe lb lc ld le b">DataFrame</code>中提供的默认索引，要么将一列转换成索引。</p><div class="lf lg gp gr lh li"><a href="https://battox.medium.com/a-thorough-intro-to-pandas-for-data-analysis-ii-d09cbbf67cd" rel="noopener follow" target="_blank"><div class="lj ab fo"><div class="lk ab ll cl cj lm"><h2 class="bd ir gy z fp ln fr fs lo fu fw ip bi translated">熊猫数据分析完全介绍 2</h2><div class="lp l"><h3 class="bd b gy z fp ln fr fs lo fu fw dk translated">检查、过滤和编辑</h3></div><div class="lq l"><p class="bd b dl z fp ln fr fs lo fu fw dk translated">battox.medium.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw lx li"/></div></div></a></div><p id="597a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们将看到 Pandas 提供的更多可能性，以通过索引探索一个<code class="fe lb lc ld le b">DataFrame</code>，以及我们如何能够拥有多个索引。</p><p id="5ee6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，我们将使用一个数据集，该数据集包含基于马克斯·普朗克进化人类学研究所的世界语言结构图集的 CSV 文件中的世界人类语言信息。</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="86e9" class="mg mh iq le b be mi mj l mk ml">import pandas as pd<br/><br/># We import a CSV dataset.<br/>df = pd.read_csv('human_natural_languages.csv')<br/><br/># And we are going to convert the column "genus" into index.<br/>df.set_index('genus', inplace=True)</span></pre><p id="0fe9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"/><code class="fe lb lc ld le b"><strong class="kh ir">inplace</strong></code><strong class="kh ir">论证</strong></p><p id="b022" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用来修改一个<code class="fe lb lc ld le b">DataFrame</code>的许多方法会产生一个新的<code class="fe lb lc ld le b">DataFrame</code>，并保持原来的完整。用参数<code class="fe lb lc ld le b">inplace=True</code>我们修改原来的<code class="fe lb lc ld le b">DataFrame</code>。</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="cb4c" class="mg mh iq le b be mi mj l mk ml">df.set_index(column, inplace=True)</span></pre><p id="2fc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<code class="fe lb lc ld le b">DataFrame</code>有了新的索引。如果不使用<code class="fe lb lc ld le b">inplace=True</code>，我们也可以做得差不多:</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="6980" class="mg mh iq le b be mi mj l mk ml">df = df.set_index(column)</span></pre><p id="c8e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们在上一章中所做的将列转换成索引。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="79cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用“genus”作为索引快速浏览一下<code class="fe lb lc ld le b">DataFrame</code>，我们会注意到<strong class="kh ir">设置索引保留了行的原始顺序</strong>(在这种情况下是列“Name”的字母顺序)。请记住，当我们将一个列转换为索引时，即使它看起来像一个列，它的行为却并不如此。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/68d2dde143abf27fedda33f61c6bd369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-TBxGXa54ssYremRMLBIw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="78da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过使用<code class="fe lb lc ld le b">loc</code>来选择索引的一个类别。如果我们选择的标签出现不止一次，我们将看到几行。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/c409a64bc8e0bef296a4799e904721d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScnnnakEf3w9qK-uU-ODQA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="259d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者几类。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nf"><img src="../Images/d7b8963c0c42c92888d67c8f8b95d636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ODXyG5CjBFye9u5MXyt6Bw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="9ed6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在表格的开始将会有一种爱尔兰语，到最后，将会有日耳曼语。</p><p id="af31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们需要将索引变回列时，我们将使用<code class="fe lb lc ld le b">DataFrame.reset_index()</code>。索引一直存在:当它不是数据集的一列或我们定义的另一个索引时，默认情况下将生成一个索引(标签与位置匹配)。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/9458a2aae8475de401fb0813dff5bdfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlGAKMXbfIwqBKWNaRgTBw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="fe93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意“genus”也是一个列(在第一个位置)。<br/> <br/>如果我们没有兴趣将索引(属)保存为一列，我们可能会将<code class="fe lb lc ld le b">drop=True</code>参数添加到<code class="fe lb lc ld le b">reset_index()</code>中，它可能会被丢弃。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nh"><img src="../Images/01e4f0b17a42d7eefaed7ff52309015a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ne8DH7HG2SV7l3_-IgfwLw.jpeg"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">由<a class="ae ni" href="https://deepai.org/" rel="noopener ugc nofollow" target="_blank"> DeepAI </a> text2img 模型生成的熊猫套娃。</p></figure><h1 id="4597" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">多指数</h1><p id="2853" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">Pandas 的优点在于它能够将多列或者多行转换成索引。那叫<strong class="kh ir">多指标</strong>。多索引将包含许多索引级别，因此，将建立索引级别的层次结构。</p><p id="a9de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管能够将多列的内容转换成索引，但我们不能认为现在一行有几个索引，这一点很重要。<strong class="kh ir">多指标</strong>还是一个。有层次。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/e66c4af4694e5a6372062cc3f37c2806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cVO4D3gNgxttwOyTdwUJxg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="9d25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下,“家庭”是指数化的第 0 级，并且优先于指数化的第 1 级“元音目录”。我们现在可以通过名称或级别编号来引用级别。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi of"><img src="../Images/baccf32d58b33c85a8fc489731cf7ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Am5xhwVY30fuEcLwjzuCQ.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="cc9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">FrozenList</code>有点像普通的<code class="fe lb lc ld le b">list</code>，现在不用担心。</p><p id="94df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引可以有名称，也可以没有名称。大多数情况下，并不是这样:例如，我们到目前为止使用的自动生成的整数索引是在没有名称的情况下创建的。提升为索引的列将列的名称转换为索引的名称，因此索引有了名称，可以修改或删除该名称。</p><h1 id="3ed1" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">元组</h1><p id="c1e8" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">在全面了解多索引之前，我们需要介绍 Python 的另一个本机对象<code class="fe lb lc ld le b">tuple</code>。</p><p id="c325" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe lb lc ld le b">tuple</code>和一个<code class="fe lb lc ld le b">list</code>的区别在于列表是可变的，而元组不是；换句话说，我们可以在创建了一个<code class="fe lb lc ld le b">list</code>之后添加或删除元素，但是我们不能对一个<code class="fe lb lc ld le b">tuple</code>做这样的事情。一旦创建，如果我们想要不同的东西，我们需要创建另一个<code class="fe lb lc ld le b">tuple</code>。<br/> <br/>我们创建它们的方式类似于创建<code class="fe lb lc ld le b">list</code>的方式，但我们将使用圆括号(圆括号)代替方括号。</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="0862" class="mg mh iq le b be mi mj l mk ml">name_of_tuple = (element_a, element_b)</span></pre><p id="e727" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">DataFrame</code>的每一行现在用一个<code class="fe lb lc ld le b">tuple</code>索引。在前面的例子中，当我们使用“单一”索引时，行是由字符串标签索引的。将<code class="fe lb lc ld le b">tuple</code>视为多索引行或列的标签。<br/> <br/>在多指标中，<code class="fe lb lc ld le b">tuple</code>的元素和指标级别一样多。例如，如果多索引有三个级别，这样的元组将被成形为<code class="fe lb lc ld le b">(level_0, level_1, level_2)</code>。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/d2ba54396654e0cb081eaebc9850e776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXxOcUMS20d9ZSgLHsmiqw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="18b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要检索一个级别的值，Pandas 会帮你搞定<code class="fe lb lc ld le b">MultiIndex.get_level_values()</code>。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mt"><img src="../Images/e27bb4c49fe6450e2cd0e0cc5cf96e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tJuMbkmrOOnJ0yKn_ChSFA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="867a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们试一试。我们从 0 级“家族”中选择印欧语，从 1 级“元音库存”中选择元音库存为 5 或 6 的语言。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/42451bbbbec92db855e1d52641c29893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPvAZhwKu27lTNnE7iVoWw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="92ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们假设这一次我们不想要印欧语系的语言，而是阿拉瓦坎语和乌拉尔语系的语言。我们没有使用单个标签(将其解释为单个<code class="fe lb lc ld le b">tuple</code>)，而是传递一个<code class="fe lb lc ld le b">list</code>标签(实际上是一个<code class="fe lb lc ld le b">tuple</code>列表)。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/47ceb5a9119dd7719d7640801f29736b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QBvPwkYvGeGvE2cyXVJ1DA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="631c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们刚才所做的另一种方式。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi nf"><img src="../Images/4dcac1465260a077e21f70d39de867d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x9DcRa_aLCV1l4Ju84gQRw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="c689" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有一个小挑战:让我们假设我们想要从级别 0 的所有行中的<strong class="kh ir">中找到级别 1 的结果(例如，小元音库存)(我们实际上忽略了级别 0)。当然，我们可以将 0 级变回列，但是不行，我们不想修改多索引。所以，也许，我们会尝试检索 0 级的所有标签和 1 级的一个标签。我们可以尝试通过使用数据集的全范围<code class="fe lb lc ld le b">slice</code> ( <code class="fe lb lc ld le b">first_row:last_row</code>)或仅使用冒号<code class="fe lb lc ld le b">:</code>来做到这一点。</strong></p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="740e" class="mg mh iq le b be mi mj l mk ml">row_labels = (:, '1 Small (2-4)')</span></pre><p id="a6b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不。这个语法不正确。<code class="fe lb lc ld le b">slice</code>仅在索引器<code class="fe lb lc ld le b">[]</code>(方括号)内工作，不与任何其他对象(本例中为<code class="fe lb lc ld le b">tuple</code>)一起工作。<br/> <br/>为此，熊猫提供了一种叫做<code class="fe lb lc ld le b">IndexSlice</code>的特殊型号来代替<code class="fe lb lc ld le b">tuple</code> s。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/a1fce5c66da4b0da80b623c846fe378f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llhBnBtl_KVlXRhvmPhH4w.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="ee36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些人喜欢将<code class="fe lb lc ld le b">IndexSlice</code>分配给一个较短的标识符，因为他们知道会多次使用它。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/70f134b5446a083a44f1fea28f785d06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGcVJae3Sc6w0Bt4mG4bJg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><h1 id="005a" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">横截面</h1><p id="c2cb" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">使用<code class="fe lb lc ld le b">DataFrame.xs()</code>方法是绕过层级的一种简便方法。它的缺点是只为选择而不为分配而工作<strong class="kh ir">。当我们需要改变帧值时，我们必须照常使用<code class="fe lb lc ld le b">loc</code> / <code class="fe lb lc ld le b">iloc</code>。</strong></p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ng"><img src="../Images/63a8960794973c0234ba73a152613859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUsyWulY9PEYks5l8HBwXg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><h1 id="1949" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">部分选择</h1><p id="bfd2" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">分层索引的一个重要特性是，您可以通过<em class="og">部分</em>标签选择数据，识别数据中的子组。<br/> <br/>如果我们只对多索引的更高级别感兴趣，而不是通过<code class="fe lb lc ld le b">pd.IndexSlice['Indo-European', :]</code>来选择行，比如我们将一个级别为 0 的标签和所有级别为 1 的标签作为目标，我们可以简单地使用<code class="fe lb lc ld le b">'Indo-European'</code>。<br/> <br/> <strong class="kh ir">非常重要</strong>:部分选择<em class="og">会在结果中删除层次索引的</em>级。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi of"><img src="../Images/1cdeb316333e12b55b7d497185a14e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tsa9j6uIb1KoHxB3106_eA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><h1 id="7373" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">整理</h1><p id="8ae1" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">这个<code class="fe lb lc ld le b">DataFrame</code>仍然是按照“名称”栏的字母顺序组织的。为了对值进行不同的排序，我们使用了<code class="fe lb lc ld le b">DataFrame.sort_values()</code>，它能够使用一个或多个列和/或索引的内容对行进行排序。<br/> <br/>我们将按照“家族”(索引级别 0)对<code class="fe lb lc ld le b">DataFrame</code>进行排序，按字母升序排列。如果“family”是一个简单的列，而不是一个索引级别，那么方法是相同的。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oh"><img src="../Images/41e5dbb308cf97e381409c69dff1555f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3PcdsvZyy0a36TTZhs5DSw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="e49e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在<code class="fe lb lc ld le b">DataFrame</code>从亚非语系的语言开始，显示的第一种语言是库洛语😃。<br/> <br/>如前所述，我们也可以通过非索引列对<code class="fe lb lc ld le b">DataFrame</code>进行排序，例如，通过语法案例的数量。此外，我们将通过添加<code class="fe lb lc ld le b">ascending=False</code>按降序排列。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oh"><img src="../Images/c3ce1909ea01731ada7d070dba39c7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NnQztvAkUHObyiksuSBSQ.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="6180" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，为了通过索引对值进行排序，我们需要通过它的名称来引用它，正如我们之前所说的，有时索引没有名称。我们可能还想使用索引的位置/级别，而不是名称。然后就是方法<code class="fe lb lc ld le b">DataFrame.sort_index()</code>派上用场的时候了(自然，它对列不起作用)。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oh"><img src="../Images/ac43389920022ac83649bde609b68976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPMvpeH1LZbO_-QXpEutPg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="c020" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">sort_index()</code>的另一个有趣的用例是当我们想要按所有级别排序时(不需要指定名称和层次)。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi oh"><img src="../Images/c200f7f5ca7b388773ec0a9b41b72598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIczmUegFmzxAaUMrbaxwg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="a5b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它首先使用级别 0 对行进行排序，然后使用级别 1。存在重复的 0 级值，这些行很难排序。第二层消除了歧义。</p><h1 id="a581" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">重新命名</h1><p id="e300" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">我们可以更改(行)索引标签或列标签的名称。为此，我们将使用<code class="fe lb lc ld le b">DataFrame.rename()</code>方法。<br/> <br/>当我们想要改变一些列的名称时，我们传递一个带有旧名称到新名称映射的<code class="fe lb lc ld le b">dict</code>。因为<code class="fe lb lc ld le b">rename()</code>对两个轴都有效，所以指定我们要瞄准哪一个是很重要的，我们用<code class="fe lb lc ld le b">index</code>(对于行)和<code class="fe lb lc ld le b">columns</code>参数(非此即彼)这样做，就像这样</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="80a3" class="mg mh iq le b be mi mj l mk ml">df.rename( columns={old_name: new_name, ...} )</span></pre><p id="7d26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一种指定轴的方法，不仅在<code class="fe lb lc ld le b">rename()</code>中使用，在许多其他方法中也使用。它在一个方向或另一个方向上起作用，值得了解:论点<code class="fe lb lc ld le b">axis</code>。它对行使用值<code class="fe lb lc ld le b">0</code>(默认情况下)，对列使用值<code class="fe lb lc ld le b">1</code>。为了通过使用<code class="fe lb lc ld le b">axis</code>获得前一个例子的结果，我们应该这样写:</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="2749" class="mg mh iq le b be mi mj l mk ml">df.rename( {old_name: new_name, ...}, axis=1 )</span></pre><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/77ab4d90487b76fb2e0f6ea6d9eb84da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-vjW6pLFWpGT1wRjshBew.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="d892" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要更改(行)索引中的名称，我们使用<code class="fe lb lc ld le b">rename(index={...})</code>。从旧到新的映射适用于所有级别，无论是多少级别或哪个级别。如果有必要将更改限制在某些级别(在我们想要更改的标签出现在几个级别的情况下)，我们可以使用参数<code class="fe lb lc ld le b">levels</code>。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/81fc7ae68fac81568b298160702a63f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sl3IuH_5FdLoGuj04cGKHQ.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><p id="d92b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">额外奖金</strong></p><p id="6a25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们被告知，一些讲 Kullo 语的人不太喜欢这个名字，他们更喜欢把他们的语言称为 Dawro。我们想重命名数据集中出现的 Kullo，但是方法<code class="fe lb lc ld le b">rename()</code>不行，因为“语言”不是索引而是列。<br/> <br/>无论我们想做什么，熊猫总有办法做到:<code class="fe lb lc ld le b">DataFrame.replace()</code>行为超过框架值。</p><figure class="ly lz ma mb gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi ne"><img src="../Images/f71d6fa2a4d41550012081f4f9f2a0ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edko8socy6lnJwWGCJYAQg.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">图片作者。</p></figure><h1 id="701d" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">结论</h1><p id="5efe" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">当使用多索引时，<code class="fe lb lc ld le b">DataFrame</code>的每一行和/或每一列都用代表索引级别的<code class="fe lb lc ld le b">tuple</code>进行索引，而不是像简单索引那样用字符串进行索引。</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="ff35" class="mg mh iq le b be mi mj l mk ml"># Let us suppose that we are dealing with a 3-level multi-index at the rows.<br/>rows = [('big', 'square', 'blue'), ('small', 'square', 'green')]<br/><br/># Retrieve rows with big blue and small green squares multi-index<br/># and all columns.<br/>df.loc[rows, :]</span></pre><p id="40bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们需要使用<code class="fe lb lc ld le b">slice</code>来表示所有的等级值(或它们的范围)时，我们使用<code class="fe lb lc ld le b">IndexSlice</code>来代替。</p><pre class="ly lz ma mb gt mc le md bn me mf bi"><span id="332c" class="mg mh iq le b be mi mj l mk ml"><br/># Now imagine that we are interested in all the figures<br/># that are blue or green.<br/>idx = pd.IndexSlice[:, :, ('blue', 'green')]<br/><br/># Retrieve intended rows and all columns.<br/>df.loc[idx, :]</span></pre><h1 id="c784" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">我喜欢的熊猫文章</h1><ul class=""><li id="2aeb" class="oi oj iq kh b ki oa kl ob ko ok ks ol kw om la on oo op oq bi translated">看看杰西卡·斯特林汉姆写的这个很酷的多索引备忘单。</li></ul><h1 id="c354" class="nj mh iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">方法列表</h1><p id="d789" class="pw-post-body-paragraph kf kg iq kh b ki oa jr kk kl ob ju kn ko oc kq kr ks od ku kv kw oe ky kz la ij bi translated">在本教程中看到的方法的简短列表。</p><ul class=""><li id="15b1" class="oi oj iq kh b ki kj kl km ko or ks os kw ot la on oo op oq bi translated"><code class="fe lb lc ld le b">set_index()</code></li><li id="5ec9" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">reset_index()</code></li><li id="8544" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">Index.get_level_values()</code></li><li id="3fad" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">xs()</code> —横截面。</li><li id="0f69" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">sort_values()</code></li><li id="d678" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">sort_index()</code></li><li id="0405" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">rename()</code> —更改索引标签。</li><li id="32d3" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">replace()</code> —改变数值。</li></ul><p id="843a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和一些方便的看不见的方法。</p><ul class=""><li id="9354" class="oi oj iq kh b ki kj kl km ko or ks os kw ot la on oo op oq bi translated"><code class="fe lb lc ld le b">rename_axis()</code> —更改一个<code class="fe lb lc ld le b">Index</code>或<code class="fe lb lc ld le b">MultiIndex</code>的名称。</li><li id="2610" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">swaplevel()</code> —切换两个<code class="fe lb lc ld le b">MultiIndex</code>级别的顺序。</li><li id="deba" class="oi oj iq kh b ki ou kl ov ko ow ks ox kw oy la on oo op oq bi translated"><code class="fe lb lc ld le b">Index.set_names()</code> —与<code class="fe lb lc ld le b">rename_axis()</code>相似，但直接在<code class="fe lb lc ld le b">Index</code>上。</li></ul></div></div>    
</body>
</html>