<html>
<head>
<title>2 Rules To Follow When Using GROUP BY in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在SQL中使用GROUP BY时要遵循的2条规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/2-rules-groupby-sql-6ff20b22fd2c#2022-09-27">https://towardsdatascience.com/2-rules-groupby-sql-6ff20b22fd2c#2022-09-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="162c" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">了解GROUP BY子句中要包含哪些列，以及如何在WHERE子句中包含聚合</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c8c6b9961d9d6b5988fa306c6bdb55ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJsCWwXCQ_OrFV7ZCdtIeA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae kz" href="https://unsplash.com/s/photos/group?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="156b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SQL中的<code class="fe lw lx ly lz b">GROUP BY</code>子句允许用户应用函数，并通过将具有相同值的记录分组在一起来对数据执行聚合，如结果查询中所指定的。</p><p id="b4da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SQL新手在使用<code class="fe lw lx ly lz b">GROUP BY</code>子句和聚合函数时，通常很难找到正确的查询语法。</p><p id="5aea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将介绍两个基本原则，这两个原则最终可以帮助您解决SQL中聚合和GROUP BY子句的任何困惑。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="614e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，让我们创建一个示例表，我们将在这个简短的教程中引用它，以便用实际的例子来演示一些概念。</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="43d1" class="ml mm iu lz b gz mn mo l mp mq">&gt; SELECT * FROM orders;</span><span id="87af" class="ml mm iu lz b gz mr mo l mp mq">+----+-------------+---------+-----------+----------+<br/>| id | customer_id |  amount | order_date| store_id |<br/>+----+-------------+---------+-----------+----------+<br/>|  1 |          20 |   10.99 | 2022-02-02|        1 |<br/>|  2 |         138 |   21.85 | 2022-09-10|        1 |<br/>|  3 |          31 |    9.99 | 2021-12-28|        2 |<br/>|  4 |          20 |   12.99 | 2022-04-29|        2 |<br/>|  5 |          89 |    5.00 | 2022-03-03|        3 |<br/>|  6 |          31 |    4.99 | 2022-11-09|        1 |<br/>|  7 |          20 |   15.00 | 2022-09-10|        3 |<br/>|  8 |          15 |  120.00 | 2022-06-07|        2 |<br/>|  9 |          15 |   32.00 | 2022-04-01|        2 |<br/>+----+-------------+---------+-----------+----------+</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="e5b5" class="ml mm iu bd ms mt mu dn mv mw mx dp my lj mz na nb ln nc nd ne lr nf ng nh ni bi translated">SQL中的GROUP BY子句</h2><p id="e72b" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">现在,<code class="fe lw lx ly lz b">GROUP BY</code>子句通常应用于分类列。尽管可以对具有连续值的列上的记录进行分组，但这样做通常没有太大意义。</p><p id="3ff6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当调用<code class="fe lw lx ly lz b">GROUP BY</code>子句时，查询将根据<code class="fe lw lx ly lz b">GROUP BY</code>子句中指定的列的值将记录分组，然后将聚合函数应用于各个组，以计算所需的结果，并最终返回结果，在这些结果中，我们将看到<code class="fe lw lx ly lz b">GROUP BY</code>子句中指定的每组列的一个值。</p><p id="f9f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一些最常见的聚合函数包括<code class="fe lw lx ly lz b">SUM</code>、<code class="fe lw lx ly lz b">AVG</code>、<code class="fe lw lx ly lz b">COUNT</code>、<code class="fe lw lx ly lz b">MAX</code>和<code class="fe lw lx ly lz b">MIN</code>。</p><p id="c96a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在使用我们的示例表，假设我们希望看到每个客户的最大订单量，最后根据最大订单量对结果进行降序排序。下面的查询可以解决这个问题:</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="8ab0" class="ml mm iu lz b gz mn mo l mp mq">SELECT<br/>    customer_id,<br/>    MAX(amount) as max_order_amount<br/>FROM<br/>    orders<br/>GROUP BY<br/>    customer_id<br/>ORDER BY <br/>    max_order_amount DESC<br/>;</span></pre><p id="f465" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果会是</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="1d4b" class="ml mm iu lz b gz mn mo l mp mq">+-------------+------------------+<br/>| customer_id | max_order_amount |<br/>+-------------+------------------+<br/>|          15 |              120 |<br/>|         138 |            21.85 |<br/>|          20 |               15 |<br/>|          31 |             9.99 |<br/>|          89 |                5 |<br/>+------------+-------------------+</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="beb6" class="ml mm iu bd ms mt mu dn mv mw mx dp my lj mz na nb ln nc nd ne lr nf ng nh ni bi translated">GROUP BY子句中要包含哪些列</h2><p id="a092" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">现在，当我们需要在我们的<code class="fe lw lx ly lz b">SELECT</code>子句中包含更多列时，事情可能会变得有点复杂。继续我们之前编写的查询，现在让我们假设我们想要查看每个商店的每个客户的最小和最大订单。</p><p id="9d48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们尝试运行以下查询:</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="6372" class="ml mm iu lz b gz mn mo l mp mq">SELECT<br/>    customer_id,<br/>    store_id,<br/>    MIN(amount) as min_order_amount,<br/>    MAX(amount) as max_order_amount<br/>FROM<br/>    orders<br/>GROUP BY<br/>    customer_id<br/>ORDER BY <br/>    max_order_amount DESC<br/>;</span></pre><p id="8fc5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，我们有一个语法错误，应该类似于下面报告的错误:</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="c84a" class="ml mm iu lz b gz mn mo l mp mq">ERROR:  column "orders.store_id" must appear in the GROUP BY clause or be used in an aggregate function LINE 3:     store_id,             ^ SQL state: 42803 Character: 29</span></pre><p id="9abf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是因为我们违反了涉及<code class="fe lw lx ly lz b">GROUP BY</code>子句的SQL查询的一个基本原则。在<code class="fe lw lx ly lz b">SELECT</code>语句中指定的列，要么必须应用聚合函数，要么必须包含在<code class="fe lw lx ly lz b">GROUP BY</code>子句中。</p><p id="2299" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">回到我们的例子，这个错误是因为我们没有将<code class="fe lw lx ly lz b">staff_id</code>和<code class="fe lw lx ly lz b">customer_id</code>一起包含在<code class="fe lw lx ly lz b">GROUP BY</code>子句中。另一方面，<code class="fe lw lx ly lz b">amount</code>不应该包含在<code class="fe lw lx ly lz b">GROUP BY</code>子句中，因为它应用了聚合函数(<code class="fe lw lx ly lz b">MIN</code>和<code class="fe lw lx ly lz b">MAX</code>)。</p><blockquote class="no"><p id="bdc0" class="np nq iu bd nr ns nt nu nv nw nx lv dk translated"><code class="fe lw lx ly lz b">SELECT</code>语句中的列必须应用聚合函数，或者包含在<code class="fe lw lx ly lz b">GROUP BY</code>子句中</p></blockquote><p id="ef5b" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated">因此，为了修复我们的查询，我们需要做的就是在<code class="fe lw lx ly lz b">GROUP BY</code>子句中包含<code class="fe lw lx ly lz b">store_id</code>(假设我们想要观察的是每个客户和商店的最大和最小订单金额)。</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="7811" class="ml mm iu lz b gz mn mo l mp mq">SELECT<br/>    customer_id,<br/>    store_id,<br/>    MIN(amount) as min_order_amount,<br/>    MAX(amount) as max_order_amount<br/>FROM<br/>    orders<br/>GROUP BY<br/>    customer_id,<br/> store_id<br/>ORDER BY <br/>    max_order_amount DESC<br/>;</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="7f1a" class="ml mm iu bd ms mt mu dn mv mw mx dp my lj mz na nb ln nc nd ne lr nf ng nh ni bi translated">WHERE语句中的聚合以及如何使用HAVING</h2><p id="6079" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">回到我们的第一个例子，让我们假设我们想计算每位消费超过5.00英镑的顾客的最大订单金额。</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="c355" class="ml mm iu lz b gz mn mo l mp mq">SELECT<br/>    customer_id,<br/>    MAX(amount) as max_order_amount<br/>FROM<br/>    orders<br/>WHERE <br/>    MAX(amount) &gt; 5<br/>GROUP BY<br/>    customer_id<br/>ORDER BY <br/>    max_order_amount DESC<br/>;</span></pre><p id="cac3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们尝试运行上面的查询，将会出现以下错误:</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="3be7" class="ml mm iu lz b gz mn mo l mp mq">ERROR:  aggregate functions are not allowed in WHERE</span></pre><p id="8a09" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上述查询的问题是，我们试图在一个<code class="fe lw lx ly lz b">WHERE</code>子句中包含一个聚合函数(即<code class="fe lw lx ly lz b">MAX</code>)。SQL的语法明确规定<code class="fe lw lx ly lz b">WHERE</code>语句不能引用<code class="fe lw lx ly lz b">SELECT</code>子句中指定的聚合。</p><p id="cfe9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是解决方法是什么呢？</p><blockquote class="no"><p id="d1e8" class="np nq iu bd nr ns nt nu nv nw nx lv dk translated">WHERE语句不能引用SELECT子句中指定的聚合</p></blockquote><p id="3acf" class="pw-post-body-paragraph la lb iu lc b ld ny jv lf lg nz jy li lj oa ll lm ln ob lp lq lr oc lt lu lv in bi translated">我们可以使用<code class="fe lw lx ly lz b">HAVING</code>子句，而不是在<code class="fe lw lx ly lz b">WHERE</code>子句中指定聚合列的条件，该子句允许我们使用<code class="fe lw lx ly lz b">GROUP BY</code>子句，然后对聚合结果进行筛选。</p><p id="33b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们应该将<code class="fe lw lx ly lz b">WHERE</code>替换为<code class="fe lw lx ly lz b">HAVING</code>子句，如下所示:</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="ef97" class="ml mm iu lz b gz mn mo l mp mq">SELECT<br/>    customer_id,<br/>    MAX(amount) as max_order_amount<br/>FROM<br/>    orders<br/>GROUP BY<br/>    customer_id<br/>HAVING<br/> MAX(amount) &gt; 5<br/>ORDER BY <br/>    max_order_amount DESC<br/>;</span></pre><p id="1f9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">生成的记录集应该如下所示:</p><pre class="kk kl km kn gu mh lz mi mj aw mk bi"><span id="d407" class="ml mm iu lz b gz mn mo l mp mq">+-------------+------------------+<br/>| customer_id | max_order_amount |<br/>+-------------+------------------+<br/>|          15 |              120 |<br/>|         138 |            21.85 |<br/>|          20 |               15 |<br/>|          31 |             9.99 |<br/>+------------+-------------------+</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h2 id="62d7" class="ml mm iu bd ms mt mu dn mv mw mx dp my lj mz na nb ln nc nd ne lr nf ng nh ni bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph la lb iu lc b ld nj jv lf lg nk jy li lj nl ll lm ln nm lp lq lr nn lt lu lv in bi translated">作为一名SQL初学者，使用GROUP BY子句有时会非常令人沮丧。在今天的简短教程中，我们讨论了在SQL查询中使用聚合时需要牢记的两个最基本的原则。</p><p id="a6b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">概括地说，重要的是要确保在<code class="fe lw lx ly lz b">SELECT</code>子句中指定的所有列都将应用聚合函数(例如<code class="fe lw lx ly lz b">SUM</code>、<code class="fe lw lx ly lz b">AVG</code>等)。)或在<code class="fe lw lx ly lz b">GROUP BY</code>条款中指定。</p><p id="938a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，您需要记住聚合(在<code class="fe lw lx ly lz b">SELECT</code>子句中指定)不能在<code class="fe lw lx ly lz b">WHERE</code>子句中引用。如果您希望这样做，您需要在<code class="fe lw lx ly lz b">HAVING</code>条款中指定您的条件。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a> <strong class="lc iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="od oe gq gs of og"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kt og"/></div></div></a></div></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">相关文章您可能也喜欢</strong></p><div class="od oe gq gs of og"><a rel="noopener follow" target="_blank" href="/ddl-dml-e802a25076c6"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">DDL和DML是什么？</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">理解SQL中DDL和DML的区别</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ov l or os ot op ou kt og"/></div></div></a></div></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu og"><a rel="noopener follow" target="_blank" href="/standard-vs-legacy-sql-bigquery-6d01fa3046a9"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">BigQuery中的标准SQL与传统SQL</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">理解标准SQL和遗留SQL在Google Cloud BigQuery环境中的区别</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ow l or os ot op ou kt og"/></div></div></a></div></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu og"><a rel="noopener follow" target="_blank" href="/sql-select-distinct-277c61012800"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">DISTINCT不是SQL函数</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">在SQL中使用DISTINCT关键字时，括号的使用如何会导致混淆</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ox l or os ot op ou kt og"/></div></div></a></div></div></div>    
</body>
</html>