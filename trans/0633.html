<html>
<head>
<title>Memoize and Cache in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia 中的内存和缓存</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/memoize-and-cache-in-julia-48aa98f6549#2022-02-25">https://towardsdatascience.com/memoize-and-cache-in-julia-48aa98f6549#2022-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e0cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用动态编程让你的函数更快</h2></div><p id="e020" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">表情化是编程中的一个简单技巧，通过记住一些间歇的结果来减少计算量。在这里，我将向你展示如何用最简单的方法在 Julia 中做到这一点。</p><blockquote class="ln lo lp"><p id="0162" class="ki kj lq kk b kl km ju kn ko kp jx kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated">🙏非常感谢在这里查看回购<a class="ae ly" href="https://github.com/JuliaCollections/Memoize.jl" rel="noopener ugc nofollow" target="_blank">的人们。</a></p></blockquote><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/032514fe6799bf37418572028161647d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nGc_6Vs0gAEs4BKQUtmKlQ.jpeg"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">照片由<a class="ae ly" href="https://unsplash.com/@thefredyjacob?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fredy Jacob </a>在<a class="ae ly" href="https://unsplash.com/s/photos/memory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="9f34" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">天真些</h1><p id="c0ef" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">我们将从一个简单的斐波那契函数开始，看看对于较大的数字它会变得多慢。斐波纳契数列由以下简单规则定义:</p><blockquote class="nm"><p id="061d" class="nn no it bd np nq nr ns nt nu nv ld dk translated">F(1) = 1，F(2) = 1，F(n) = n — 2 + n — 1</p></blockquote><p id="56b2" class="pw-post-body-paragraph ki kj it kk b kl nw ju kn ko nx jx kq kr ny kt ku kv nz kx ky kz oa lb lc ld im bi translated">其中<code class="fe lu lv lw lx b">n</code>为正整数。</p><p id="7960" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用 Julia 来编码:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3de5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个<strong class="kk iu">递归函数</strong>，它调用它自己，这本身并不是一个罪过，但是对于这个特殊的函数来说，代价非常高。如果你想了解为什么这很贵以及记忆化是如何工作的，看看这个由<strong class="kk iu"> freeCodeCamp </strong>制作的精彩视频:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="od oc l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">由<a class="ae ly" href="https://www.freecodecamp.org" rel="noopener ugc nofollow" target="_blank">freecodecamp.org</a>进行动态编程</p></figure><p id="7654" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">😉我喜欢 Julia 的一点是<strong class="kk iu">你可以简洁地定义简单的函数。上面和这个小俏皮话一样:</strong></p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1323" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过使用方便的<code class="fe lu lv lw lx b">@show</code>宏来检查上面的内容是否有效:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="74b5" class="oi mq it lx b gy oj ok l ol om">julia&gt; for i in 1:10<br/>           <a class="ae ly" href="http://twitter.com/show" rel="noopener ugc nofollow" target="_blank">@show</a> i, fibonacci(i)<br/>       end<br/>(i, fibonacci(i)) = (1, 1)<br/>(i, fibonacci(i)) = (2, 1)<br/>(i, fibonacci(i)) = (3, 2)<br/>(i, fibonacci(i)) = (4, 3)<br/>(i, fibonacci(i)) = (5, 5)<br/>(i, fibonacci(i)) = (6, 8)<br/>(i, fibonacci(i)) = (7, 13)<br/>(i, fibonacci(i)) = (8, 21)<br/>(i, fibonacci(i)) = (9, 34)<br/>(i, fibonacci(i)) = (10, 55)</span></pre><p id="6106" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过使用<code class="fe lu lv lw lx b">BenchmarkTools</code>包来检查上述操作有多快:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="1287" class="oi mq it lx b gy oj ok l ol om">julia&gt; <a class="ae ly" href="http://twitter.com/btime" rel="noopener ugc nofollow" target="_blank">@btime</a> fibonacci(30)<br/>  2.280 ms (0 allocations: 0 bytes)<br/>832040</span></pre></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><blockquote class="ln lo lp"><p id="ba06" class="ki kj lq kk b kl km ju kn ko kp jx kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated">想看看朱莉娅的其他作品吗？别害羞，跟我来😅</p></blockquote><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/build-your-first-neural-network-with-flux-jl-in-julia-10ebdfcf2fa3"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">在 Julia 中用 Flux.jl 构建你的第一个神经网络</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">没有任何外部数据的初学者教程</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl mj ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://blog.devgenius.io/make-a-command-line-game-with-julia-a408057adcfe" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">和 Julia 一起做一个命令行游戏</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">没有图形用户界面的 2048 游戏</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">blog.devgenius.io</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl mj ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/jupyter-notebooks-can-be-a-pain-but-i-️-pluto-f47913c5c16d"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">朱庇特笔记本可能是一种痛苦，但我❤️布鲁托</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">朱莉娅的 Pluto.jl 将使教育变得更好</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl mj ox"/></div></div></a></div></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="ee7c" class="mp mq it bd mr ms po mu mv mw pp my mz jz pq ka nb kc pr kd nd kf ps kg nf ng bi translated">保持天真</h1><p id="3054" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">我们现在拥有的代码可以工作，但是它非常慢，尤其是对于较大的数字。所以本着保持天真的精神，让我们试着实现我们自己的这个函数的记忆版本。</p><p id="4bae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记忆只不过是使用字典(或类似的缓存)来存储结果，而不是重新计算<code class="fe lu lv lw lx b">F(3)</code>无数次，而是从字典中查找。这是如何工作的:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3ed1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些步骤是:</p><ol class=""><li id="07c3" class="pt pu it kk b kl km ko kp kr pv kv pw kz px ld py pz qa qb bi translated">检查我们的内存中是否已经有了<code class="fe lu lv lw lx b">n</code>的结果，如果有，快乐的日子。</li><li id="91ad" class="pt pu it kk b kl qc ko qd kr qe kv qf kz qg ld py pz qa qb bi translated">如果没有，计算它并立即存储在内存中。</li><li id="e269" class="pt pu it kk b kl qc ko qd kr qe kv qf kz qg ld py pz qa qb bi translated">返回计算结果。</li></ol><p id="558f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果更好:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="e98a" class="oi mq it lx b gy oj ok l ol om">julia&gt; <a class="ae ly" href="http://twitter.com/btime" rel="noopener ugc nofollow" target="_blank">@btime</a> fibonacci_memory(30)<br/>  1.630 μs (7 allocations: 1.97 KiB)<br/>832040</span></pre><p id="8bc9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是 0.00163 ms vs 之前的 2.28ms。那就是<strong class="kk iu"> 1400x 加速</strong>！😜</p><h1 id="12fb" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">不要多此一举</h1><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi qh"><img src="../Images/d83f9b20d51fcfefd4d4f7f6b5657b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UcL79dZ9TQ95XhVBMLAsyw.jpeg"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">乔纳森·肯珀在<a class="ae ly" href="https://unsplash.com/s/photos/stone-wheel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="aaee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管编写这个版本并不太复杂，但是有更好的方法。也就是说，<code class="fe lu lv lw lx b">Memoize.jl</code>包确实如其名所言。使用起来超级简单。用<code class="fe lu lv lw lx b">Pkg.add("Memoize")</code>或<code class="fe lu lv lw lx b">] add Memoize</code>以通常的方式安装它，然后你就可以用一个很棒的小<strong class="kk iu">宏来帮你记忆你的功能</strong>:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8a23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这和我们在第一部分中的函数是一样的，除了它现在被包装在<code class="fe lu lv lw lx b">@memoize</code>宏中。这是多么容易。</p><p id="cc28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看它有多快:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="7ea3" class="oi mq it lx b gy oj ok l ol om">julia&gt; <a class="ae ly" href="http://twitter.com/btime" rel="noopener ugc nofollow" target="_blank">@btime</a> fibonacci_easy(30)<br/>  58.189 ns (0 allocations: 0 bytes)<br/>83204</span></pre><p id="eb40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">等一下！这比以前快了 30 倍。这怎么可能呢？🧐</p><p id="ee17" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，这个记忆函数存储了所有以前的结果，所以现在它根本不做任何计算。从字面上看，这就是从字典中查找结果。您可以使用包装中的<code class="fe lu lv lw lx b">memoize_cache</code>功能查看字典:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="7dc1" class="oi mq it lx b gy oj ok l ol om">julia&gt; memoize_cache(fibonacci_easy)<br/>IdDict{Any, Any} with 30 entries:<br/>  (7,)  =&gt; 13<br/>  (29,) =&gt; 514229<br/>  (25,) =&gt; 75025<br/>  (21,) =&gt; 10946<br/>  (15,) =&gt; 610<br/>  (4,)  =&gt; 3<br/>  (13,) =&gt; 233<br/>  (26,) =&gt; 121393<br/>  (18,) =&gt; 2584<br/>  (10,) =&gt; 55<br/>  (2,)  =&gt; 1<br/>  (27,) =&gt; 196418<br/>  (20,) =&gt; 6765<br/>  (16,) =&gt; 987<br/>  (5,)  =&gt; 5<br/>  (8,)  =&gt; 21<br/>  (28,) =&gt; 317811<br/>  (24,) =&gt; 46368<br/>  (12,) =&gt; 144<br/>  ⋮     =&gt;</span></pre><p id="0583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如你所见，它包含 30 个条目，所以它已经学习了前 30 个斐波那契数列。</p><p id="a4f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您的函数需要大量不同的输入，并且您担心内存可能是一个问题，您可能想要将缓存切换到<strong class="kk iu">最近最少使用的(LRU)缓存</strong>。Memoize.jl 库的<a class="ae ly" href="https://github.com/JuliaCollections/Memoize.jl" rel="noopener ugc nofollow" target="_blank">主自述文件中有一个这样的例子。</a></p><h1 id="9f95" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">为了完全不同的东西… 🥁</h1><p id="4395" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">为了更好地衡量，这里有一个斐波那契生成器，没有任何记忆，也没有递归:</p><figure class="ma mb mc md gt me"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="9920" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是一些证据，证明这也能实现所有其他功能:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="1a2d" class="oi mq it lx b gy oj ok l ol om">julia&gt; for i in 1:10<br/>           <a class="ae ly" href="http://twitter.com/show" rel="noopener ugc nofollow" target="_blank">@show</a> i, fibonacci(i), fib(i)<br/>       end<br/>(i, fibonacci(i), fib(i)) = (1, 1, 1)<br/>(i, fibonacci(i), fib(i)) = (2, 1, 1)<br/>(i, fibonacci(i), fib(i)) = (3, 2, 2)<br/>(i, fibonacci(i), fib(i)) = (4, 3, 3)<br/>(i, fibonacci(i), fib(i)) = (5, 5, 5)<br/>(i, fibonacci(i), fib(i)) = (6, 8, 8)<br/>(i, fibonacci(i), fib(i)) = (7, 13, 13)<br/>(i, fibonacci(i), fib(i)) = (8, 21, 21)<br/>(i, fibonacci(i), fib(i)) = (9, 34, 34)<br/>(i, fibonacci(i), fib(i)) = (10, 55, 55)</span></pre><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi qi"><img src="../Images/e628b3ceeb2667c1d3fa09e6fc928071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FT5LOj7e969JuaTaeyuDgg.jpeg"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">夏洛特·科内比尔在<a class="ae ly" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2175" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦，天啊，太快了:</p><pre class="ma mb mc md gt oe lx of og aw oh bi"><span id="7163" class="oi mq it lx b gy oj ok l ol om">julia&gt; <a class="ae ly" href="http://twitter.com/btime" rel="noopener ugc nofollow" target="_blank">@btime</a> fib(30)<br/>  2.000 ns (0 allocations: 0 bytes)<br/>832040</span></pre><p id="896f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比在内存中查找结果快 30 倍。哦，茱莉亚，你是头野兽！😆</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="8d04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想要更多的斐波纳契还是渴望更多的茱莉亚？看看这些:</p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/fibonacci-series-with-user-defined-functions-in-bigquery-f72e3e360ce6"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">BigQuery 中的斐波那契数列</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">在 BigQuery 中使用用户定义的 JavaScript 函数来计算 Fibonacci</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="qj l pi pj pk pg pl mj ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/vectorize-everything-with-julia-ad04a1696944"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">向量化朱莉娅的一切</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">告别 for loops，广播所有的东西</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="qk l pi pj pk pg pl mj ox"/></div></div></a></div></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><h1 id="285a" class="mp mq it bd mr ms po mu mv mw pp my mz jz pq ka nb kc pr kd nd kf ps kg nf ng bi translated">摘要</h1><p id="4c0b" class="pw-post-body-paragraph ki kj it kk b kl nh ju kn ko ni jx kq kr nj kt ku kv nk kx ky kz nl lb lc ld im bi translated">如果您有一个函数可以从记住自己计算的中间结果中受益，那么使用同一个包中的<code class="fe lu lv lw lx b">@memoize</code>函数。它会让你的功能运行得更快，而且超级容易使用。</p><p id="c7e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想要一种有意义的、易于使用的、快速的编程语言——即使是 for 循环——就用 Julia 吧！</p><blockquote class="ln lo lp"><p id="6260" class="ki kj lq kk b kl km ju kn ko kp jx kq lr ks kt ku ls kw kx ky lt la lb lc ld im bi translated"><em class="it">这里用到的所有代码都可以在 GitHub 上【https://github.com/niczky12/medium】<a class="ae ly" href="https://github.com/niczky12/medium/blob/master/julia/memoize.jl" rel="noopener ugc nofollow" target="_blank"><em class="it"/></a>下找到</em></p></blockquote><blockquote class="nm"><p id="e3c6" class="nn no it bd np nq ql qm qn qo qp ld dk translated">要获得所有媒体文章的完整访问权限，包括我的文章，请考虑在此订阅<a class="ae ly" href="https://niczky12.medium.com/membership" rel="noopener"/>。</p></blockquote></div></div>    
</body>
</html>