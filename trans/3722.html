<html>
<head>
<title>Process On-Demand Data without Idle Databricks Clusters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无需闲置数据块集群即可按需处理数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/process-on-demand-data-without-idle-databricks-clusters-cbf0bd99d8d6#2022-08-18">https://towardsdatascience.com/process-on-demand-data-without-idle-databricks-clusters-cbf0bd99d8d6#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9dc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在您的工作流程之前添加云功能，实现经济高效的解决方案</h2></div><p id="dde3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Databricks是一种平台即服务产品，允许数据工程师执行数据的接收、探索和转换。最近，他们在多任务工作流平台中加入了创建数据管道的功能。此外，它们还提供了一种可配置和可扩展的数据接收功能，称为自动加载器。有了它，您可以按需和按计划接收数据。但是，如果您希望在数据到达时立即接收数据，则必须在等待文件到达时激活作业。这与工作流功能不兼容，并且会让您的计算集群无限期开启。情况就是这样，我以前工作的一家公司在一个项目上花费了数千美元，让空闲集群监听数据。</p><p id="41c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是你一定要这样做吗？使用云功能作为您的数据传感器，您可以经济高效地触发您的Databricks管道。您将只使用您的集群进行实际处理。祝您身体健康</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/c30f4a22a6f1146278c3b82e3075ddbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Aw8HQZAex5Cf0xLj"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">现在，云就是一切。在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lr" href="https://unsplash.com/@z734923105?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jerry Zhang </a>的照片。</p></figure><h1 id="212a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">0.预赛</h1><p id="6562" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">你可以在这里找到我的伙伴库<a class="ae lr" href="https://github.com/hector6298/azFunctionsDatabricks/tree/master" rel="noopener ugc nofollow" target="_blank"/>。微软Azure将是这个特定练习的云提供商，但是概念可以被翻译到其他提供商。数据集将是“<em class="mp">纽约黄色出租车出行数据”</em>，并且可以在这里找到<a class="ae lr" href="https://www.kaggle.com/datasets/microize/newyork-yellow-taxi-trip-data-2020-2019" rel="noopener ugc nofollow" target="_blank">。但是，数据集有许多分区。下载一个CSV文件，并使用该数据的子集创建一个新文件，以便在测试步骤中将其上传到Azure容器时最大限度地减少等待。</a></p><h1 id="3be3" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.文件暂存区</h1><p id="4b75" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">您将需要一个存储服务，您的数据将在这里着陆，并在稍后由数据块提取以供消费。这种服务可以是亚马逊S3、Azure Blob存储容器等。该条目将使用Azure服务和VS代码。</p><p id="fd53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Azure插件中，有一个标签页叫做<strong class="kh ir"> <em class="mp">【资源】</em> </strong>。点击<strong class="kh ir"><em class="mp">“+”</em></strong>按钮，选择<strong class="kh ir"> <em class="mp">【创建存储账户】:</em> </strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mq"><img src="../Images/f109f19468c8f5e5c13622b5adbe1a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Fm3DQTCaOzmcYw0kyFmpw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">创建存储帐户。截图由作者拍摄。</p></figure><p id="7f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给它一个独特的名字，一个蔚蓝色的区域。然后，检查终端区域中的Azure活动日志，直到创建了资源。在左窗格中查找资源，右键单击并创建一个新容器:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mr"><img src="../Images/310307ef9b4fb0b059156ee4df35bd87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoI8nwx__oGgoeNi4wOExg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">创建blob容器。截图由作者拍摄。</p></figure><p id="1c9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建容器后，您需要将它挂载到Databricks文件系统上。为此，请在您的Databricks工作区内运行以下代码单元:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">正在安装blob容器。作者创建的片段。</p></figure><h1 id="bf7c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.数据库和表格</h1><p id="7a09" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在，根据您的数据模型创建适当的表。在这个简单的示例中，使用了一个表:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">创建数据库表。作者创建的片段。</p></figure><p id="9dab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该表将接收来自中转区文件的出租车行程数据。</p><h1 id="3b5e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.自动装载机查询</h1><p id="115b" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这是工作量的核心！但是首先，让我们使用<code class="fe mu mv mw mx b">dbutils</code>在数据块中定义所需的参数:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">Dbutils小部件。作者创建的片段。</p></figure><p id="9aa0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Autoloader查询将定义从登台区到表的ETL。让我们回顾一下代码:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">自动加载器查询。我创建的片段:)</p></figure><ul class=""><li id="bd14" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">cloudFiles</code>:向结构化流查询指示您要使用自动加载器。</li><li id="ca8f" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">cloudFiles.format</code>:传入数据的格式。在这种情况下，CSV。</li><li id="1c2c" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">cloudFiles.schemaHints</code>:默认情况下，所有发现的字段都将被视为字符串。您可以在这里指定特定字段的数据类型。</li><li id="20bb" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">load()</code>:指定将要加载的数据的位置。在这种情况下，是已装载容器的位置。</li><li id="7555" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">select()</code>:选择所有列的子集。</li><li id="233c" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">trigger(availableNow=True)</code>:非常重要。它向查询指定您想要处理所有尚未使用且现在可用的数据。否则，默认情况下，该查询将每半秒运行一次。</li><li id="27d8" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">table()</code>:将数据存储在指定的表格中。</li></ul><h1 id="e601" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.数据砖块的工作</h1><p id="79b6" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">既然已经定义了查询，那么就要创建实际的数据管道了。重新定义的Databricks工作流的优点在于，您可以定义一组任务和依赖关系。以前在这个平台上做不到的事情。对于这个简单的例子，将定义一个单一的任务。你可以在这里阅读如何创建更复杂的工作流程<a class="ae lr" href="https://docs.databricks.com/workflows/jobs/jobs-quickstart.html" rel="noopener ugc nofollow" target="_blank">。此外，请查看我的关于Databricks中管道编排的文章</a><a class="ae lr" href="https://hectormrejia.medium.com/use-these-methods-to-orchestrate-your-pipelines-2b8b614285ba" rel="noopener">。</a></p><p id="bbb3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<strong class="kh ir"><em class="mp">【Path】</em></strong>里面，寻找自动加载器脚本所在的笔记本位置。此外，发出屏幕截图中描述的必需参数:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/f16a02b06a6d27252a1194cfdea495d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*brKAxnGGV5-QYykbaJh6hQ.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">创建数据块作业。自己的作者身份截图。</p></figure><p id="df0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几点需要注意:</p><ul class=""><li id="d5f4" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">dbfs:/mnt/test</code>是挂载的Azure存储容器的目录，如之前在挂载代码片段中定义的。</li><li id="ec87" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">default</code>是默认创建的数据库的名称。</li><li id="b22f" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><strong class="kh ir"><em class="mp">check point _ directory</em></strong>设置为<code class="fe mu mv mw mx b">/tmp/</code>，该目录在每次集群重启时都会被清除。<strong class="kh ir">千万不要</strong>在真实场景中将其设置为检查点目录，这只是为了练习。</li></ul><h1 id="1267" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.功能应用程序</h1><p id="1073" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这是实现预期的按需行为的关键组件。一旦数据到达临时区域，该功能将被触发，然后，它将使用Databricks作业API运行Databricks工作流。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nn"><img src="../Images/caec9346008b88a14cd7da883ce0de14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zKGe6M8LTlpCyN9dwlJ-ng.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">按需处理。我使用Azure图标创建的图片:)</p></figure><p id="7542" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在VS代码中创建一个函数，寻找Azure插件。在工作区选项卡上选择<strong class="kh ir"><em class="mp">“+”</em></strong>，点击<strong class="kh ir"> <em class="mp">【创建功能】</em> </strong>:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d42544785ef93ef6f99475dbcc38fb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*NmkVakY-bNo58aC65mBjcg.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">创建本地函数。截图由作者拍摄。</p></figure><p id="14cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，一件很棒的事情是，我们可以为函数触发器提供多种选择。这意味着我们的<strong class="kh ir"> Databricks工作流可以通过这些方法中的任何一种来激活</strong>。在本练习中，请遵循以下步骤:</p><ul class=""><li id="3c3a" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated">点击<strong class="kh ir"> <em class="mp">【天蓝色斑点存储】</em> </strong>触发。</li><li id="bb84" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">给这个函数一个唯一的名字，然后按回车键。</li><li id="d156" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">点击<strong class="kh ir"> <em class="mp">“创建新的本地应用设置”。</em> </strong></li></ul><p id="9c78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您的VS代码文件夹中应该填充了来自所创建函数的文件。当项目在编辑器中可用时，在<code class="fe mu mv mw mx b">local.settings.json</code>中定义所需的环境变量:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">函数的必需变量。作者创建的片段。</p></figure><ul class=""><li id="a72f" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">&lt;your-storage-account-name&gt;_STORAGE</code>:将保存来自你的Azure存储帐户的连接字符串。若要获取该值，请转到Azure门户并选择您的存储帐户。点击左窗格中的<strong class="kh ir"> <em class="mp">【访问键】</em> </strong>，复制连接字符串。</li><li id="5f59" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">DB_JOB_ID</code>:您的数据块作业的id。创建工单后，复制与之关联的id并粘贴到此处。</li><li id="2786" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">DATABRICKS_HOST</code>:是您的Databricks工作区的URL。应该类似于<em class="mp">“https://ADB-xxxxxxxxx . xx . azuredatabricks . net/”</em></li><li id="8eef" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">DATABRICKS_TOKEN</code>:您需要创建一个Databricks个人访问令牌，并在此处插入值。这将允许该函数与您的数据块工作空间进行交互。</li><li id="1b7b" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">忽略其他参数。</li></ul><p id="6345" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置好参数后，我们将在<code class="fe mu mv mw mx b">__init__.py</code>脚本中实现函数的行为:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">Azure函数行为。我和❤一起创作的片段</p></figure><p id="e5a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该脚本需要注意的事项:</p><ul class=""><li id="a1f6" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated">Databricks CLI是为shell设计的工具。然而，这个脚本利用了它是用python编写的这一事实，我们可以将这些对象用于这个函数的逻辑。在<code class="fe mu mv mw mx b">requirements.txt</code>文件中包含<code class="fe mu mv mw mx b">databricks-cli</code>。</li><li id="26c5" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">EnvironmentVariableConfigProvider</code>是Databricks CLI中的一个类，它使用<code class="fe mu mv mw mx b">DATABRICKS_HOST</code>和<code class="fe mu mv mw mx b">DATABRICKS_TOKEN</code>环境变量来初始化环境。</li><li id="d834" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated"><code class="fe mu mv mw mx b">JobsService</code>也是Datbaricks CLI中的一个类，允许您创建、运行、列出和删除作业。这是一个非常强大的工具。</li><li id="0b48" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">代码的控制流旨在避免多个函数执行触发同一作业的多个并发运行。一次只能运行一次。</li></ul><p id="2f07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码完成后，我们必须创建实际的云资源，并上传我们刚刚实现的配置。为此，在Azure插件下，在<strong class="kh ir"> <em class="mp">【资源】</em> </strong>窗格中点击<strong class="kh ir"> <em class="mp">【在Azure中创建功能应用】</em> </strong>:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi np"><img src="../Images/94168ac6a3204cb12ae20b0dddc5f2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*TBmM1UhWCnSPWJVOND3TiQ.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">在云上创建功能。自己署名截图。</p></figure><p id="0875" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外:</p><ul class=""><li id="a14b" class="my mz iq kh b ki kj kl km ko na ks nb kw nc la nd ne nf ng bi translated">给这个函数一个唯一的名字，然后按回车键。</li><li id="1161" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">点击最新的python运行时堆栈。</li><li id="f6ff" class="my mz iq kh b ki nh kl ni ko nj ks nk kw nl la nd ne nf ng bi translated">对于本例，选择“美国东部”作为地区。在更现实的情况下，您应该选择最适合您业务案例的地区。</li></ul><p id="f091" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建函数时。右键点击后者，选择<strong class="kh ir"> <em class="mp">“部署到功能App”</em></strong>:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/084e35d264a7147fa856a73325f357fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*sGlLd2M9ALcP72fU_ruklg.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">将代码部署到云功能。截图是我拍的。</p></figure><p id="8a2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将把代码上传到云资源。要完成，在您的功能内的<strong class="kh ir"> <em class="mp">【应用设置】</em> </strong>子菜单下点击右键，选择<strong class="kh ir"> <em class="mp">【上传本地设置】</em> </strong>:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5d7bb54dfef1c43c0cb0b3222f49c109.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*tkvsDTVL89vvhzhpJdes1Q.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">上传变量到云函数。截图由作者拍摄。</p></figure><p id="178a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会将<code class="fe mu mv mw mx b">local.settings.json</code>内容设置为我们函数app的环境变量。就是这样！Databricks工作区应该能够对存储容器中的文件上传做出反应，并运行适当的工作流。</p><h1 id="7d5c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.测试项目</h1><p id="b6da" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">现在基础设施已经准备好了，是时候删除样本数据集了。初始黄行数据太重，无法快速上传。此外，选取一小部分记录样本，并将其上传到存储容器:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ns"><img src="../Images/bb9acb0b897da6a6a5ba27942b2e297c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtj18AJCvwGS12TTbQLNCw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">将文件上传到存储容器。截图是我拍的:)</p></figure><p id="8b8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦文件被加载，该函数将被触发，然后，它将向Databricks作业发出运行信号。这是Azure函数生成的日志示例:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nt"><img src="../Images/a218a40c4fab602c0917ad2317a18d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWXXfNYUTeo-CkYaz29crA.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">Azure函数运行日志。截图由作者拍摄。</p></figure><p id="1409" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果您在几分钟后转到Databricks，作业将会完成:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nu"><img src="../Images/cb9285ba13e36db094656cd2128ebe6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOsFSDawBmQEXWE6HQ3Wcw.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">数据块作业运行。自己的作者身份截图。</p></figure><p id="d302" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">表格中应填入黄色的行程数据记录:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi nv"><img src="../Images/0dd69a3939f5daeb0d9b0e2aa609e56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipURL91XXuwhjTHYFRH73w.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">查询表中加载的数据。截图是我拍的。</p></figure><p id="dea3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它像魔法一样有效！</p><h1 id="5913" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">其他注意事项</h1><p id="3f83" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这个项目的实现是在Visual Studio代码和Databricks工作空间中完成的。然而，如果你需要你的基础设施是CI-CD或IaC友好的，你总是可以使用Azure资源管理器模板和Azure CLI来创建环境。只需提取本文的核心概念，并根据您的用例进行调整。</p><p id="47c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，相应地测试和调整函数和数据块作业的行为。这种逻辑没有经过在很短的时间间隔内加载大量文件的实战测试。但是，它应该提供一个起点，以便您可以按需接收数据，而不需要无限期活动的群集消耗资源和资金，同时只侦听数据。</p><p id="c229" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，作业被设置为在冷启动设置中创建集群。这将增加几分钟的执行时间。如果您需要作业尽可能快地运行，请考虑创建计算池，以便群集可以使用预热的实例。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="0603" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你喜欢这个内容，请鼓掌并订阅，并在我的<a class="ae lr" href="https://www.linkedin.com/in/hectorandresmv/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。干杯！👾</p><div class="od oe gp gr of og"><a href="https://github.com/hector6298" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">赫克托6298</h2><div class="on l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ll og"/></div></div></a></div></div></div>    
</body>
</html>