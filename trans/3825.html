<html>
<head>
<title>How to Speed up Data Processing with Numpy Vectorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Numpy矢量化加速数据处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca#2022-08-25">https://towardsdatascience.com/how-to-speedup-data-processing-with-numpy-vectorization-12acac71cfca#2022-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="904e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据准备</h2><div class=""/><div class=""><h2 id="0c1b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">比标准函数快8000倍</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/23dac43a96b5fed6dd5a39ca747b1182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-G9wxh7WNBClcTn0YTsvw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@loic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Djim Loic </a>在<a class="ae lh" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="02b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">在处理较小的数据集时，很容易认为普通的Python方法足以快速处理数据。然而，随着产生的数据量的增加，以及通常可用于分析的数据量的增加，尽可能快地优化代码变得比以往更加重要。</strong></p><p id="a3d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">因此，我们将探讨如何使用矢量化和numpy库来帮助您加速数字数据处理。</strong></p><h1 id="cd5b" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">python为什么慢？</h1><p id="c7ae" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Python是众所周知的用于数据处理和探索的优秀语言。主要的吸引力在于它是一种高级语言，因此理解和学习起来简单直观，编写和迭代也很快。如果您的重点是数据分析/处理，而不是编写堆积如山的代码，您会想要的所有功能。</p><p id="9cb6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这种易用性也有不好的一面。与c等低级语言相比，它处理计算的速度要慢得多。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/f25012897c65bdd59247886572c54168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGW9i2lnTIWACM0gepJnYA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Wolfgang Hasselmann 在<a class="ae lh" href="https://unsplash.com/s/photos/snail?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="03fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，由于python是数据分析和数据科学社区(以及许多其他社区)选择的语言之一，因此有大量的库和工具可用来缓解python在处理大量数据时固有的“缓慢”。</p><h1 id="22e3" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">到底什么是矢量化？</h1><p id="c434" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">当谈到用numpy加速计算时，您会经常看到“矢量化”这个术语。Numpy甚至有一个叫做“矢量化”的方法，我们将在后面看到。</p><p id="e109" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一般的谷歌搜索会产生大量关于矢量化实际是什么的混乱和矛盾的信息，或者只是泛泛而谈，不能告诉你太多:</p><blockquote class="nc nd ne"><p id="3a18" class="li lj nf lk b ll lm kd ln lo lp kg lq ng ls lt lu nh lw lx ly ni ma mb mc md im bi translated">NumPy上的<strong class="lk jd">矢量化运算</strong>的概念允许在NumPy数组对象和数据序列上使用更优化的预编译函数和数学运算。与简单的非矢量化操作相比，输出和操作将会加快。<br/><br/>-<a class="ae lh" href="https://www.geeksforgeeks.org/vectorized-operations-in-numpy/" rel="noopener ugc nofollow" target="_blank">GeekForGeeks.org</a>-搜索时的第一个谷歌结果——什么是numpy矢量化？</p></blockquote><p id="699f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它只是没有说更多:<em class="nf">由于优化</em>它会变得更快。</p><h2 id="ce9d" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">什么优化？</h2><p id="53b4" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">问题是numpy是一个非常强大的优化工具。当实现类似矢量化的东西时，numpy中的实现除了简单的传统矢量化之外，还包括许多经过深思熟虑的优化。我认为这是很多困惑的来源，分解正在发生的事情(至少在某种程度上)将有助于让事情变得更清楚。</p><h1 id="c419" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">在numpy中分解矢量化</h1><p id="d883" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">接下来的部分将分解numpy库中使用的一般“向量化”保护伞下通常包含的内容。</p><p id="28cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">了解它们各自的功能，以及它们如何提高numpy“向量化”操作的速度，应该有助于解决任何困惑。</p><h2 id="931a" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">实际矢量化</h2><p id="3476" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">矢量化是一个在numpy之外使用的术语，用最基本的术语来说就是计算的并行化。</p><p id="7251" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有一个1D数组(或称为<strong class="lk jd">向量</strong>):</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="c9d6" class="nj mf it nv b gy nz oa l ob oc">[1, 2, 3, 4]</span></pre><p id="39ca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…将向量中的每个元素乘以标量值2，最终得到:</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="59c9" class="nj mf it nv b gy nz oa l ob oc">[2, 4, 6, 8]</span></pre><p id="3228" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在普通python中，这将使用类似for循环的东西一个元素一个元素地完成，因此一个接一个地进行四次计算。如果每次计算需要1秒钟，那么完成计算并发布结果需要4秒钟。</p><p id="1cf7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，numpy实际上将两个向量相乘<code class="fe od oe of nv b">[2,2,2,2]</code>和<code class="fe od oe of nv b">[2,4,6,8]</code> (numpy使用一种叫做broadcasting的东西将标量值2“拉伸”成一个向量，请参阅下一节了解更多信息)。四个独立计算中的每一个都是同时并行完成的。所以从时间上来说，计算是1秒完成的(每次计算需要1秒，但都是同时完成的)。</p><p id="a70e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅仅通过计算的“矢量化”(或者，如果你喜欢，一种并行处理的形式)，速度就提高了四倍。请记住，我给出的例子非常简单，但它确实有助于说明基本情况。</p><p id="029e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以看到，如果您正在处理包含数千个(如果不是数百万个)元素的数据集，这相当于一个非常大的差异。</p><p id="7d0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，并行化不是无限的，在某种程度上依赖于硬件。Numpy不能同时并行处理1亿次计算，但它可以显著减少串行计算量，尤其是在处理大量数据时。</p><p id="929c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想要更详细的解释，那么我推荐<a class="ae lh" href="https://stackoverflow.com/questions/35091979/why-is-vectorization-faster-in-general-than-loops" rel="noopener ugc nofollow" target="_blank">这篇</a> stackoverflow帖子，它在更详细的解释方面做得很好。如果你想要更多的细节，那么<a class="ae lh" rel="noopener" target="_blank" href="/decoding-the-performance-secret-of-worlds-most-popular-data-science-library-numpy-7a7da54b7d72">的这篇</a>文章和<a class="ae lh" href="https://pythonspeed.com/articles/vectorization-python/" rel="noopener ugc nofollow" target="_blank">的这篇</a>文章都很棒。</p><h2 id="fddc" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">广播</h2><p id="fa9d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">广播是numpy的一个特性，它允许在不同大小的数组之间执行数学运算。实际上，我们在上一节中已经这样做了。</p><p id="d717" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">标量值2被“拉伸”成一个充满2的数组。这就是广播，也是numpy <strong class="lk jd">为更高效的计算准备</strong>数据的方式之一。然而，说“它只是创建了一个2的数组”是一种过于简单化的说法，但是不值得在这里详细讨论。</p><p id="17ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Numpy自己的文档实际上非常清楚:</p><blockquote class="nc nd ne"><p id="0944" class="li lj nf lk b ll lm kd ln lo lp kg lq ng ls lt lu nh lw lx ly ni ma mb mc md im bi translated">术语广播描述了NumPy在算术运算中如何处理不同形状的数组。在某些约束条件下，较小的阵列在较大的阵列中“广播”,以便它们具有兼容的形状。广播提供了一种向量化数组操作的方法，因此循环在C而不是Python中发生。<br/><br/>-<a class="ae lh" href="https://numpy.org/doc/stable/user/basics.broadcasting.html" rel="noopener ugc nofollow" target="_blank">numpy.org</a></p></blockquote><h2 id="276d" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">更快的语言</h2><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/c1da97b1919e18bbc323af96e2b73b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xAWaOsb3uLTijgTJTNxmA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@vargasuillian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尤利安·巴尔加斯</a>在<a class="ae lh" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1ce6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如前面引用的numpy自己的文档中所详述的，numpy使用预编译和优化的C函数来执行计算。</p><p id="d687" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于C是一种低级语言，因此有更多的空间来优化计算。这不是你需要考虑的事情，因为numpy库已经为你做了，但是你会从中受益。</p><h2 id="41e7" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">同类数据类型</h2><p id="8c3c" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在python中，你可以灵活地混合使用不同的数据类型(字符串、整型、浮点型等)来指定列表。).在numpy中处理数据时，数据是同构的(即都是同一类型)。这有助于加快计算速度，因为数据类型不需要像在python列表中那样即时计算出来。</p><p id="a6e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这当然也可以看作是一种限制，因为它使得处理混合数据类型更加困难。</p><h2 id="55ee" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">把所有的放在一起</h2><p id="614e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如前所述，当谈到numpy中的矢量化时，将上述所有内容(以及更多内容)组合在一起是很常见的。然而，由于矢量化也在其他上下文中用于描述更具体的操作，这可能会非常混乱。</p><p id="b046" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望大家对我们正在处理的事情有一点点的了解，现在我们可以开始实际的工作了。</p><p id="abb3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">numpy的矢量化实现真的有多大作用？</p><h1 id="0de3" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">实际例子</h1><p id="91b8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">为了演示numpy中矢量化的有效性，我们将使用<a class="ae lh" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>库比较几种不同的常用方法来应用数学函数和逻辑。</p><blockquote class="nc nd ne"><p id="fa57" class="li lj nf lk b ll lm kd ln lo lp kg lq ng ls lt lu nh lw lx ly ni ma mb mc md im bi translated"><strong class="lk jd"> pandas </strong>是一个快速、强大、灵活且易于使用的开源数据分析和操作工具，构建在<a class="ae lh" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>编程语言之上。</p><p id="5552" class="li lj nf lk b ll lm kd ln lo lp kg lq ng ls lt lu nh lw lx ly ni ma mb mc md im bi translated">-<a class="ae lh" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">pydata.org</a></p></blockquote><p id="224c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Pandas在处理表格数据时被广泛使用，它也是建立在numpy之上的，所以我认为它是展示矢量化有效性的一个很好的媒介。</p><p id="6d52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">随后的所有计算都可以在colab笔记本上找到</strong></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/numpy_vectorize.ipynb"><div class="gh gi oh"><img src="../Images/e3c494d78254a53189d50acf0675d635.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*0cSi95lq5JxmVAlk4PCpug.jpeg"/></div></a></figure><h2 id="8a9c" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">数据</h2><p id="938f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">数据将是一个有两列的简单数据帧。这两列都将由取自正态分布的100万行随机数组成。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="3545" class="nj mf it nv b gy nz oa l ob oc">df = pd.DataFrame({‘series1’:np.random.randn(1000000), ‘series2’:np.random.randn(1000000)})</span></pre><p id="9670" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这导致:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/55b309259b8f50b655c99dc113e2a00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*Mmx5c98VrFZqwvfa_wSPjA.png"/></div></figure><h2 id="b212" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">操控</h2><p id="db72" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">然后，上面的数据帧将由两个不同的函数操作，以创建第三列<strong class="lk jd">‘series 3’</strong>。这是熊猫非常常见的操作，例如，在为机器或深度学习创建新功能时:</p><p id="a223" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">功能1 —简单求和</strong></p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="1e4f" class="nj mf it nv b gy nz oa l ob oc">def sum_nums(a, b):<br/>    return a + b</span></pre><p id="ef2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">功能2 —逻辑和算术</strong></p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="8774" class="nj mf it nv b gy nz oa l ob oc">def categorise(a, b):<br/>    if a &lt; 0:<br/>        return a * 2 + b<br/>    elif b &lt; 0:<br/>        return a + 2 * b<br/>    else:<br/>        return None</span></pre><p id="f1a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将使用不同的方法(有些是矢量化的，有些不是)应用上述每个函数，以查看哪种方法在一百万行上执行计算最快。</p><h2 id="894a" class="nj mf it bd mg nk nl dn mk nm nn dp mo lr no np mq lv nq nr ms lz ns nt mu iz bi translated">方法和结果</h2><p id="5ee6" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">下面的处理方法按速度顺序排列。最慢的先来。</p><p id="24c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每种方法都使用<a class="ae lh" href="https://docs.python.org/3/library/timeit.html#module-timeit" rel="noopener ugc nofollow" target="_blank"> timeit库</a>运行了多次，并且使用了上一节中提到的两个函数。对于较慢的方法是一次，对于较快的方法是1000次。这确保了计算不会运行太长时间，并且我们得到足够的迭代来平均每次迭代的运行时间。</p><p id="1a11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nf">熊猫敷法</em> </strong></p><p id="0c29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">熊猫敷法非常简单直观。然而，这也是在大型数据集上应用计算的最慢方式之一。</p><p id="8eb4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有优化计算。它基本上是执行一个简单的for循环。除非功能要求排除了所有其他方法，否则应该避免使用这种方法。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="e892" class="nj mf it nv b gy nz oa l ob oc"># Function 1<br/>series3 = df.apply(lambda df: sum_nums(df['series1'],df['series2']),axis=1)</span><span id="28a0" class="nj mf it nv b gy oj oa l ob oc"># Function 2<br/>series3 = df.apply(lambda df: categorise(df['series1'],df['series2']),axis=1)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/9d9451bd709b40fd8ce7289217f6c755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*MMh_XnkgaGte1xPR9Su2FA.png"/></div></figure><p id="1502" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"><em class="nf"/></strong></p><p id="bb6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在一些简单的实现中，Itertuples甚至比apply方法更慢，但是在这种情况下，它与列表理解一起使用，因此在速度上比apply方法提高了近20倍。</p><p id="db8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Itertuples消除了处理pandas系列的开销，而是使用命名元组进行迭代。如前所述，这个特定的实现还受益于list comprehension提供的加速，因为它消除了追加到列表的开销。</p><p id="5a29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nf">注意:还有一个名为iterrows的函数，但是它总是比较慢，因此为了简洁起见而被忽略。</em></p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="84f4" class="nj mf it nv b gy nz oa l ob oc"># Function 1<br/>series3 = [sum_nums(a, b) for a, b in df.itertuples(index=False)]</span><span id="a63b" class="nj mf it nv b gy oj oa l ob oc"># Function 2<br/>series3 = [categorise(a, b) for a, b in df.itertuples(index=False)]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7559ec7b21ede550b24992a44f0628e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*4fiang03QCCErHSCrCvKeA.png"/></div></figure><p id="846f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nf">列表理解</em> </strong></p><p id="f877" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">前面的itertuples示例也使用了列表理解，但是这个使用“zip”而不是itertuples的特殊解决方案似乎快了两倍。</p><p id="6dcb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">其主要原因是itertuples方法引入的额外开销。Itertuples实际上在内部使用zip，因此任何到达应用zip的地方的额外代码都只是不必要的开销。</p><p id="bd38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中可以找到对此的一个很好的调查。顺便说一下，这也解释了为什么iterrows比itertuples慢。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="2b25" class="nj mf it nv b gy nz oa l ob oc"># Function 1<br/>series3 = [sum_nums(a, b) for a, b in zip(df['series1'],df['series2'])]</span><span id="6370" class="nj mf it nv b gy oj oa l ob oc"># Function 2<br/>series3 = [categorise(a, b) for a, b in zip(df['series1'],df['series2'])]</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/a469ba66abca2d46654dd2fa9f3fc0b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*Lt-N-a6wLtkc07l05hajVg.png"/></div></figure><p id="0ff7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nf"> Numpy矢量化方法</em> </strong></p><p id="9cc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这有点奇怪。该方法本身被称为“矢量化”，但事实是，它远没有我们将在下面的方法中看到的全面优化的矢量化快。甚至numpy自己的文档也指出:</p><blockquote class="nc nd ne"><p id="9486" class="li lj nf lk b ll lm kd ln lo lp kg lq ng ls lt lu nh lw lx ly ni ma mb mc md im bi translated"><a class="ae lh" href="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank">矢量化</a>功能主要是为了方便，而不是为了提高性能。该实现本质上是一个for循环。</p><p id="8743" class="li lj nf lk b ll lm kd ln lo lp kg lq ng ls lt lu nh lw lx ly ni ma mb mc md im bi translated">- <a class="ae lh" href="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank"> numpy .或</a> g</p></blockquote><p id="cf40" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，用于实现该功能的语法确实非常简单明了。最重要的是，该方法实际上在加速计算方面做得很好，比我们迄今为止尝试过的任何方法都好。</p><p id="095e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它也比后面的方法更灵活，因此在许多情况下更容易实现，不会有任何混乱。因此，Numpy矢量化是一种很好的方法，强烈推荐使用。</p><p id="fe5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">值得记住的是，虽然这种方法很快，但它甚至无法达到我们将要看到的完全优化的方法所能达到的效果，因此它不应该只是所有情况下的首选方法。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="1d6f" class="nj mf it nv b gy nz oa l ob oc"># Function 1<br/>series3 = np.vectorize(sum_nums)(df['series1'],df['series2'])</span><span id="4b9b" class="nj mf it nv b gy oj oa l ob oc"># Function 2<br/>series3 = np.vectorize(categorise)(df['series1'],df['series2'])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/1335f3e32bd3cdbdf0520e793c5a16a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*2kHP_9ybDgoM4Ac-OYx4Cw.png"/></div></figure><p id="665c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nf">熊猫矢量化</em> </strong></p><p id="a783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们全面了解优化的矢量化。</p><p id="a4ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与以前的任何方法相比，速度上的差别是天壤之别，也是本文前面讨论的所有优化协同工作的一个主要例子。</p><p id="b4f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">pandas的实现仍然是numpy的实现，但是语法非常非常简单。如果你能以这种方式表达你想要的计算，你就不能在速度方面做得更好，而不提出一个明显更复杂的实现。</p><p id="8a5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">大约比apply方法快7000倍，比numpy矢量化方法快130倍！</p><p id="187c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">缺点是，这种简单的语法不允许处理复杂的逻辑语句。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="4964" class="nj mf it nv b gy nz oa l ob oc"># Function 1<br/>series3 = df['series1'] + df['series2']</span><span id="ea0f" class="nj mf it nv b gy oj oa l ob oc"># Function 2<br/># N/A as a simple operation is not possible due to the included logic in the function.</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi om"><img src="../Images/7ff2dd5e729f06e40658d6b333b9b1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*Q0blY0fCYceASJRGeAnyyQ.png"/></div></figure><p id="bc2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">T5】Numpy矢量化T7】</strong></p><p id="4450" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终的实现是我们能够实现的最接近原始numpy的实现，同时仍然有来自pandas数据帧的输入。</p><p id="c1c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管如此，通过在计算中去掉任何pandas开销，与pandas实现相比，处理时间减少了15%。</p><p id="2d21" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这比apply方法快8000倍。</p><pre class="ks kt ku kv gt nu nv nw nx aw ny bi"><span id="0cb3" class="nj mf it nv b gy nz oa l ob oc"># Function 1<br/>series3 = np.add(df['series1'].to_numpy(),df['series2'].to_numpy())</span><span id="c52f" class="nj mf it nv b gy oj oa l ob oc"># Function 2<br/># N/A as a simple operation is not possible due to the included logic in the function.</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/fd4b55a7dfbdfb3727b01f38fcb3d9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*dwXEzTxTfR1-J96WahjJ4A.png"/></div></figure><h1 id="5b88" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="8403" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我希望这篇文章有助于澄清一些特别是与矢量化相关的术语，从而让您更好地理解哪种方法最适合您的特定情况。</p><p id="0dd6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据经验，如果您正在处理大型数值数据集，pandas和numpy中的矢量化方法是您的好朋友:</p><ol class=""><li id="7230" class="oo op it lk b ll lm lo lp lr oq lv or lz os md ot ou ov ow bi translated">如果计算允许，尝试使用numpy内置的数学函数</li><li id="c3e2" class="oo op it lk b ll ox lo oy lr oz lv pa lz pb md ot ou ov ow bi translated">熊猫的数学运算也是不错的选择</li><li id="1259" class="oo op it lk b ll ox lo oy lr oz lv pa lz pb md ot ou ov ow bi translated">如果你需要更复杂的逻辑，使用numpy的vectorize⁴方法</li><li id="9229" class="oo op it lk b ll ox lo oy lr oz lv pa lz pb md ot ou ov ow bi translated">如果以上所有方法都失败了，那么就需要决定你到底需要什么功能，并选择一个合适的较慢的方法(列表理解、互耦、应用)</li></ol><p id="9449" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你发现自己处在一个既需要速度又需要灵活性的情况下，那么你就处在一个特殊的位置。您可能需要开始考虑实现您自己的并行化，或者编写您自己的定制数字functions⁵.所有这些都是可能的。</p></div><div class="ab cl pc pd hx pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="im in io ip iq"><p id="a1f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你觉得这篇文章有趣或有用，记得关注我，或者<a class="ae lh" href="https://medium.com/@maclayton/subscribe" rel="noopener">注册我的简讯</a>获取更多类似的内容。</p><p id="8be7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你还没有，你也可以考虑<a class="ae lh" href="https://medium.com/@maclayton/membership" rel="noopener">订阅媒体</a>。你的会员费不仅直接支持我，也支持你所阅读的其他作家。你还可以完全不受限制地访问媒体上的每个故事。</p><p id="3b03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用我的推荐链接注册会给我一点回扣，对你的会员资格没有影响，所以如果你选择这样做，谢谢你。</p><div class="pj pk gp gr pl pm"><a href="https://medium.com/@maclayton/membership" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">加入我的介绍链接媒体-迈克克莱顿</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">阅读迈克·克莱顿(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa lb pm"/></div></div></a></div><h1 id="89ed" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">参考</h1><p id="b472" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">1 https://pandas.pydata.org/docs/reference/api/pandas.<a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.itertuples.html" rel="noopener ugc nofollow" target="_blank">DataFrame.itertuples.html</a></p><p id="3980" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2 <a class="ae lh" href="https://stackoverflow.com/users/2867928/mazdak" rel="noopener ugc nofollow" target="_blank"> Mazdak </a>，<a class="ae lh" href="https://stackoverflow.com/questions/30245397/why-is-a-list-comprehension-so-much-faster-than-appending-to-a-list" rel="noopener ugc nofollow" target="_blank">为什么列表理解比追加列表快那么多？</a> (2015)，<a class="ae lh" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank">stackoverflow.com</a></p><p id="fbac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3<a class="ae lh" href="https://numpy.org/doc/stable/reference/routines.math.html" rel="noopener ugc nofollow" target="_blank">https://numpy.org/doc/stable/reference/routines.math.html</a></p><p id="36a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4<a class="ae lh" href="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank">https://numpy . org/doc/stable/reference/generated/numpy . vectorize . html</a></p><p id="0fee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">5<a class="ae lh" href="https://numpy.org/doc/stable/user/c-info.ufunc-tutorial.html" rel="noopener ugc nofollow" target="_blank">https://numpy . org/doc/stable/user/c-info . uf unc-tutorial . html</a></p></div></div>    
</body>
</html>