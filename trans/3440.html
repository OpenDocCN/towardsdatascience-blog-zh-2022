<html>
<head>
<title>Responsible Concurrent Data Retrieval</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">负责任的并行数据检索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/responsible-concurrent-data-retrieval-80bf7911ca06#2022-07-29">https://towardsdatascience.com/responsible-concurrent-data-retrieval-80bf7911ca06#2022-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="345d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以PubChem化学安全数据为例，探讨如何降低数据检索率的策略</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de0d445d388cfe8f89684d6b95d9e06b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRqgDySi6RM0K9AHVQCt0g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者在希腊克里特岛南部某地拍摄的照片</p></figure><p id="53f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">目录</strong></p><p id="ba79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="#0f58" rel="noopener ugc nofollow">设置场景</a> <br/> <a class="ae lr" href="#0119" rel="noopener ugc nofollow">同步数据检索</a> <br/> <a class="ae lr" href="#423d" rel="noopener ugc nofollow">异步数据检索</a> <br/> ∘ <a class="ae lr" href="#c8d7" rel="noopener ugc nofollow">概念化速率节流</a> <br/> ∘ <a class="ae lr" href="#1c38" rel="noopener ugc nofollow">并发和速率节流检索使用异步</a> <br/> ∘ <a class="ae lr" href="#e6ba" rel="noopener ugc nofollow">结果概述</a> <br/> <a class="ae lr" href="#692b" rel="noopener ugc nofollow">结论</a></p><h1 id="0f58" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">设置场景</h1><p id="ee60" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">一般来说，在外部资源从容不迫地做出响应时，通过巧妙切换上下文，可以使用单核来协调I/O绑定的进程。尽管如此，仍有几种方法可以使用，它们在两个主要方面有所不同:</p><ul class=""><li id="fec9" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">他们是使用<a class="ae lr" href="https://en.wikipedia.org/wiki/Preemption_%28computing%29#Preemptive_multitasking" rel="noopener ugc nofollow" target="_blank">抢占式</a>还是<a class="ae lr" href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="noopener ugc nofollow" target="_blank">协作式</a>(也称为非抢占式)多任务处理，这与谁控制上下文切换有关</li><li id="b90e" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">如何调节数据检索以满足数据提供者的需求</li></ul><p id="b16f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我看来，后者是最重要的。当与数据提供者交互时，我们需要确保数据检索率不超过我们所使用的服务指定的限制。数据分析师有责任采取负责任的行动，而不仅仅是从数据接收者的角度着眼于优化流程。</p><p id="687c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文以化学品安全为主题。它使用基于<a class="ae lr" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> asyncio </a>的多任务协作，从<a class="ae lr" href="https://pubchem.ncbi.nlm.nih.gov/" rel="noopener ugc nofollow" target="_blank">public chem</a>收集欧盟使用的所有工业化学品的化学安全数据。在欧盟，每年生产或进口1吨或以上的物质需要根据REACH法规的要求进行注册。注册物质的列表可以方便地从<a class="ae lr" href="https://echa.europa.eu/universe-of-registered-substances" rel="noopener ugc nofollow" target="_blank">这里</a>下载，格式良好的excel文件如下所示(图1)。即使将来该列表不可用，任何物质标识符列表都可以用作输入。或者，可以从附带的<a class="ae lr" href="https://github.com/karpanGit/myBlogs/tree/master/ResponsibleConcurrentDataRetrieval" rel="noopener ugc nofollow" target="_blank">资源库</a>中获得本文撰写时使用的列表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/fe43195db6d5523e3423b3301ac00fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flBdsZvU4Z0shUV3Vo4wXg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:欧盟生产或进口的物质，标明了其数字标识符(化学文摘社编号和欧洲委员会编号)</p></figure><p id="0eae" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">物质清单可以用熊猫阅读，代码如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cde8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里没什么特别的。如果过滤不清楚，目的是保留具有<a class="ae lr" href="https://en.wikipedia.org/wiki/CAS_Registry_Number" rel="noopener ugc nofollow" target="_blank">化学文摘社编号</a>的物质，这是一个可以很容易地用于从PubChem检索数据的标识符。如PubChem PUG REST <a class="ae lr" href="https://pubchemdocs.ncbi.nlm.nih.gov/pug-rest" rel="noopener ugc nofollow" target="_blank">文档</a>和<a class="ae lr" href="https://pubchemdocs.ncbi.nlm.nih.gov/pug-rest-tutorial" rel="noopener ugc nofollow" target="_blank">教程</a>中所述，也可以使用其他标识符。</p><p id="66ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文的用例包括两个步骤。第一步是使用CAS号获取相应的PubChem化合物ID (CID)。例如，甲醛的化学文摘社编号为50–00–0，可通过POST <a class="ae lr" href="https://pubchemdocs.ncbi.nlm.nih.gov/pug-rest-tutorial" rel="noopener ugc nofollow" target="_blank">请求</a>获得相应的CID</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="6641" class="nl lt iq nh b gy nm nn l no np">https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/cids/JSON</span></pre><p id="0350" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">带标题</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f0b7" class="nl lt iq nh b gy nm nn l no np">Content-Type: application/x-www-form-urlencoded</span></pre><p id="4298" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和身体</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="69e8" class="nl lt iq nh b gy nm nn l no np">name=50-00-0</span></pre><p id="e29f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在编写时，这给出了CID 712。CAS号可能对应于由实现处理的多个CID。这一步也可以通过使用更简单的GET请求来完成，但是我们更喜欢PubChem提供的POST功能，因为它不会受到可以在URL中传递的字符的限制(例如，当从物质名称获取CID时)。当起点是CAS号时，这不太重要，但我选择了更通用的实现。</p><p id="2959" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二步是获得特定化合物的索引，即列出存在的信息，但没有全部数据内容；实质上是该记录的目录。在甲醛的情况下，这可以使用GET <a class="ae lr" href="https://pubchemdocs.ncbi.nlm.nih.gov/pug-view#_full_record" rel="noopener ugc nofollow" target="_blank">请求</a>来获得</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="cbf9" class="nl lt iq nh b gy nm nn l no np">https://pubchem.ncbi.nlm.nih.gov/rest/pug_view/index/compound/712/JSON</span></pre><p id="fabf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该用例基本上允许分析工业化学品PubChem中可用的信息类型。PubChem是一个庞大的存储库，提供全面的化学信息和流畅的编程访问，专为数据密集型研究而构建。本文仅使用所提供的部分功能来解释Python中的并发性，可以进一步扩展该功能以从PubChem获得更多数据，例如生物测定数据。尽管如此，所展示的用例足够复杂，足以代表这种集成可能带来的挑战。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="0119" class="ls lt iq bd lu lv nx lx ly lz ny mb mc jw nz jx me jz oa ka mg kc ob kd mi mj bi translated"><strong class="ak">同步数据检索</strong></h1><p id="71e5" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在考虑并发性之前，使用基于优秀的<a class="ae lr" href="https://pypi.org/project/requests/" rel="noopener ugc nofollow" target="_blank">请求</a>包的同步(阻塞)方法来测试数据检索方法是有用的。</p><p id="54e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与从CAS号中检索CID相关的第一步由函数<code class="fe oc od oe nh b">retrieve_CID</code>执行，而与检索特定CID的PUG视图索引相关的第二步由函数<code class="fe oc od oe nh b">retrieve_pugview</code>执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b55e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该方法使用化学文摘社编号作为起点。然而，该实现也允许使用EC号或物质名称作为起点，以防读者发现这很有用。由于这个原因，需要URL和字节编码，这里没有详细解释，但是希望从代码中可以看得很清楚。类似地，我没有提供对<code class="fe oc od oe nh b">import logger</code>导入和日志方法的解释，因为这对本文并不重要。关于日志的复习，请参考这个优秀的<a class="ae lr" href="https://realpython.com/python-logging/" rel="noopener ugc nofollow" target="_blank">资源</a>。通过重试失败的尝试和创建一个请求会话，可以进一步优化同步方法，但是在同步函数中没有讨论这一点，因为本文的重点是异步实现。完整的代码可以在附带的GitHub <a class="ae lr" href="https://github.com/karpanGit/myBlogs/tree/master/ResponsibleConcurrentDataRetrieval" rel="noopener ugc nofollow" target="_blank">库</a>中看到。</p><p id="a903" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">回到甲醛的例子，我们可以用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1484" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它返回的JSON输出与我们在浏览器中使用甲醛CID看到的相同</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/63fb406db445b408e5da3bee148319c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPp-o_ymRs8WIcVzTqvsNA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:甲醛的帕格观察指数(CID=712)</p></figure><p id="a626" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">响应中一个特别有趣的部分是嵌套的TOCHeading值，当涉及到欧盟的工业化学品时，可以递归解析这些值来查看PubChem包含多少数据。我们将在文章的结尾回到这个问题。</p><p id="e455" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种同步方法可能是以编程方式从PubChem获取数据的最简单方式，可能已经对一些读者有用了。然而，本文的目的是超越同步方法，展示如何针对相当大数量的CAS号并发执行两个REST请求(但是不要大到考虑PubChem提供的ftp数据检索选项)。并发性并不是最容易涉及的话题。因此，在并行工作之前，实现同步方法总是明智的。这确保了正确使用REST API，并设置了基线来检查并发方法的任何性能增益。根据记录，从化学文摘社编号开始检索甲醛指数大约需要1.3秒。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="423d" class="ls lt iq bd lu lv nx lx ly lz ny mb mc jw nz jx me jz oa ka mg kc ob kd mi mj bi translated">异步数据检索</h1><h2 id="c8d7" class="nl lt iq bd lu og oh dn ly oi oj dp mc le ok ol me li om on mg lm oo op mi oq bi translated"><strong class="ak">概念化的速率调节</strong></h2><p id="1896" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用API检索数据时，最重要的一个方面是遵守数据提供者的条款和条件，这些条款和条件可能会对检索到的数据施加限制。在我们的例子中，不存在这样的复杂性，因为数据不会用于任何特定的应用程序，因为目的是演示检索数据的过程，而不是构建面向用户的应用程序或以不同的方式利用数据。除了数据使用之外，负责任地检索数据也很重要，这样我们就不会给数据提供商的服务器带来过度的压力。本节尝试如何在我们的用例中实现速率调节。</p><p id="49ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PubChem规定了<a class="ae lr" href="https://pubchemdocs.ncbi.nlm.nih.gov/programmatic-access#_RequestVolumeLimitations" rel="noopener ugc nofollow" target="_blank">请求量限制</a>，要求对程序性web请求进行节流，以便:</p><ul class=""><li id="270d" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">每秒不超过5个请求</li><li id="b8e7" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">每分钟不超过400个请求</li><li id="e9f4" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">每分钟运行时间不超过300秒</li></ul><p id="b9d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二个要求似乎是多余的，如果我们在一整分钟内每秒提交5个请求，那么一分钟内提交的请求数将是300，即少于400。哪个条件可能是限制条件取决于典型请求的响应时间，而响应时间又可能取决于所请求的数据量、服务的总负载以及与PubChem的负载平衡器相关的细微差别。总而言之，这意味着我们不能假设相同的请求如果在不同的时间执行将花费相同的时间。该方法应该是通用的和灵活的，以考虑到这种波动。</p><p id="3cda" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编排数据检索的起点是我们每秒可以提交多达五个请求。如果我们假设我们正在运行五个独立的并发流，那么所有的需求都可以得到满足，如果每个请求的响应时间被测量为:</p><ul class=""><li id="d07e" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">花费<em class="or">t</em>T8】1秒的响应之后是1- <em class="or"> t </em>秒的空闲时间</li><li id="6b4e" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">花费<em class="or"> t </em> ≥ 1秒的响应可以立即跟随另一个请求</li></ul><p id="c67c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面模拟了响应时间分布不同的四种不同情况(<a class="ae lr" href="https://github.com/karpanGit/myBlogs/tree/master/ResponsibleConcurrentDataRetrieval" rel="noopener ugc nofollow" target="_blank">库</a>包含<code class="fe oc od oe nh b">utilities.py</code>中的函数<code class="fe oc od oe nh b">visualise_task_orchstrationin</code>)。我们假设有五个并发流，每个并发流发出十个请求。在图2中，响应时间相当短，服从正态分布，平均值为0.2秒，标准差为0.05秒。我们可以看到，速率限制条件是每秒的请求数。五个并发流每秒提交5个请求，但是响应时间(PubChem服务器上的负载)只有墙时间的20%，而80%是空闲时间。这意味着我们每分钟只使用60秒的运行时间，但不幸的是，我们无法在不违反请求量限制的情况下进一步延长运行时间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/7978140b1017f58b5fbfe436ff436521.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-R2hJsZpx8XkwTpTbhC-mA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:从平均值为0.2秒、标准偏差为0.05秒的正态分布中得出的响应时间；响应时间用一条从请求开始处开始的水平线(空心圆圈)表示，并带有注释</p></figure><p id="4428" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图3模拟了稍长的响应时间，从平均值为0.5秒、标准偏差为0.12秒的正态分布中提取。同样，速率限制条件是每秒的请求数。现在运行时间大约是每分钟5x0.5x60 = 150秒。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/76dd05e04b2e264e7859b96068865b66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqcIRAyJSz97qwILSeiB2A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3:从平均值为0.5秒、标准偏差为0.12秒的正态分布中得出的响应时间</p></figure><p id="a857" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图4模拟了更长的响应时间，平均值为1秒，标准偏差为0.25秒。我们可以看到，五个并发流每秒提交的请求总数略少于5个，运行时间略少于每分钟300秒。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/3a753ae283ff28efa68a1c7cdf99f351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkE4C2o9U8O987Ip7YUFRw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:从平均值为1.0秒、标准偏差为0.25秒的正态分布中得出的响应时间</p></figure><p id="164a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，图5模拟了最长的响应时间，平均值为1.5秒，标准偏差为0.38秒。很少有请求会有空闲时间。限速条件是运行时间接近每分钟300秒。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/347a52699aee70f45b0a95a06242d8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FvPQB1Eus51AtD9AASg0bA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图5:从平均值为1.5秒、标准偏差为0.38秒的正态分布中得出的响应时间</p></figure><p id="0d21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在实践中，由于<a class="ae lr" href="https://docs.aiohttp.org/en/stable/tracing_reference.html#aiohttp-client-tracing-reference" rel="noopener ugc nofollow" target="_blank">请求生命周期</a>的复杂性和准确测量响应时间的挑战，我们将把空闲时间增加0.1秒，以留出一些误差。</p><p id="3fe2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上述方法可以进一步改进，特别是如果响应时间波动，例如通过遵循具有更快和更慢响应的二项式分布。在这种情况下，更快的响应后面会有更少的空闲时间，因为更慢的响应确保我们不会那么容易达到每秒五个请求的限制。然而，这种方法开发起来更复杂，如果不加监督地运行，可能会有危险，因为除非我们能够在理论上保证请求量限制不会被超过，否则我们可能会无意中给PubChem施加压力，最终导致IP被阻塞。</p><p id="7b1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们注意到PubChem还提供了动态节流功能。伴随所有PUG-REST web请求的HTTP响应头包含关于用户有多接近极限的信息。PubChem可以根据总体需求动态调整这些限制，因此可以实时使用这些限制来确保并发率得到相应的动态调整。这种反馈循环机制超出了本文的范围，本文将涉及相当多的内容。在本文中，动态节流仅用于双重检查数据检索率是否保持在可接受的范围内。</p><p id="0c3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下一节中，我们将使用五个独立且并行的流来实施数据检索方法，以数千种物质的化学文摘社编号为起点来检索其CID。这些cid将是唯一的，然后用于检索它们相应的PUG视图索引。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h2 id="1c38" class="nl lt iq bd lu og oh dn ly oi oj dp mc le ok ol me li om on mg lm oo op mi oq bi translated">使用asyncio的并行和速率受限检索</h2><p id="5f0c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">异步方法在很大程度上基于同步方法，但在本次会议中列出了一些调整。</p><p id="fb27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最关键的调整是用<a class="ae lr" href="https://aiohttp.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> aiohttp </a>模块替换阻塞请求模块，这是一个以异步方式发出http请求的库。请求本身是使用单个aiohttp会话发出的，以利用会话内部连接池的重用。</p><p id="bed5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这种情况很少发生，但实现会重新提交可能暂时失败的请求，例如，由于网络问题或PubChem的服务器繁忙。查看日志，这种情况只发生几十次，没有一个请求需要提交两次以上。</p><p id="b9a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">速率调节是通过一个异步<a class="ae lr" href="https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore" rel="noopener ugc nofollow" target="_blank">信号量</a>来实现的</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="31f0" class="nl lt iq nh b gy nm nn l no np">sem = asyncio.Semaphore(limit)</span></pre><p id="c274" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用<code class="fe oc od oe nh b">limit=5</code>。信号量管理一个内部计数器，该计数器在每次<code class="fe oc od oe nh b">sem.aquire()</code>调用时递减(一旦我们使用信号量进入上下文管理器),在每次<code class="fe oc od oe nh b">sem.release()</code>调用时递增(一旦我们使用信号量退出上下文管理器)。计数器永远不能低于零；当<code class="fe oc od oe nh b">sem.aquire()</code>发现它是零时，它会阻塞，直到某个任务调用<code class="fe oc od oe nh b">sem.release()</code>唤醒另一个等待获取信号量的任务。这实质上实现了前面概念上的五个并发且独立的流。</p><p id="d9e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">短请求之后是一个<code class="fe oc od oe nh b">asyncio.sleep(idle_time)</code>调用，其中空闲时间取决于请求持续时间，假设请求持续时间反映了PubChem计算时间。幸运的是，aiohttp支持<a class="ae lr" href="https://docs.aiohttp.org/en/stable/client_advanced.html#aiohttp-client-tracing" rel="noopener ugc nofollow" target="_blank">客户端跟踪</a>，它通过将监听器协程附加到由<code class="fe oc od oe nh b">TraceConfig</code>实例提供的信号上来工作:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="a8ce" class="nl lt iq nh b gy nm nn l no np">async def on_request_start(session, trace_config_ctx, params):<br/>    trace_config_ctx.start = asyncio.get_event_loop().time()<br/><br/>async def on_request_end(session, trace_config_ctx, params):<br/>    elapsed_time = asyncio.get_event_loop().time() - trace_config_ctx.start<br/>    if trace_config_ctx.trace_request_ctx['request duration'] is not None:<br/>        raise Exception('should not happen')<br/>    trace_config_ctx.trace_request_ctx['request duration'] = elapsed_time<br/><br/>trace_config = aiohttp.TraceConfig()<br/>trace_config.on_request_start.append(on_request_start)<br/>trace_config.on_request_end.append(on_request_end)</span></pre><p id="ba90" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该实例用作<code class="fe oc od oe nh b">ClientSession</code>构造函数的参数，其结果是客户端触发了<code class="fe oc od oe nh b">TraceConfig</code>支持的不同信号。这些信号将第一个参数<code class="fe oc od oe nh b">ClientSession</code>和第二个参数<code class="fe oc od oe nh b"><a class="ae lr" href="https://docs.python.org/3/library/types.html" rel="noopener ugc nofollow" target="_blank">SimpleNamespace</a></code>称为<code class="fe oc od oe nh b">trace_config_ctx</code>，它们可用于共享属于同一请求和同一<code class="fe oc od oe nh b">TraceConfig</code>类的不同信号的状态。这使得能够测量从请求开始到结束所用的时间。<code class="fe oc od oe nh b">trace_config_ctx</code>参数在请求流开始时初始化。更复杂的是，我们需要将信息从侦听器传递回实现请求的协程，以便可以设置空闲时间。代码使用了在请求执行开始时给出的<code class="fe oc od oe nh b">trace_request_ctx</code>参数，它被所有HTTP动词接受，并将作为关键字参数传递给实例化<code class="fe oc od oe nh b">trace_config_ctx</code>的默认工厂。我们不使用这个功能向监听器传递数据，而是获取请求持续时间，因为一旦请求返回，键值对<code class="fe oc od oe nh b">trace_request_ctx = {'request duration': None}</code>的值将被设置。</p><p id="e02c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">诚然，这一节介绍了许多概念。在附带的<a class="ae lr" href="https://github.com/karpanGit/myBlogs/tree/master/ResponsibleConcurrentDataRetrieval" rel="noopener ugc nofollow" target="_blank">库</a>中查看整个实现可能更容易。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="e6ba" class="nl lt iq bd lu og oh dn ly oi oj dp mc le ok ol me li om on mg lm oo op mi oq bi translated">结果概述</h2><p id="99c7" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">具有化学文摘社编号的物质数量为17，829，相当于17，700个独特的化学文摘社编号。使用协程<code class="fe oc od oe nh b">retrieve_CID</code>我们获得了15 361个唯一的CID号码，其中12 873个CAS号码只有一个CID号码。4 117化学文摘社编号在PubChem数据库中找不到，710化学文摘社编号有两个或两个以上的CID编号。后者表明了工业化学品的物质鉴定挑战和PubChem中潜在的重复记录。总而言之，整个数据检索花费了2.04小时，即使数据检索需要定期重复，这也绝不是令人望而却步的。在处理日志时，我们可以看到两种请求类型的平均响应时间都不到0.2秒，响应时间的分布非常窄，如下所示。尽管如此，还是有一些例外。使用<a class="ae lr" href="https://seaborn.pydata.org/generated/seaborn.boxplot.html" rel="noopener ugc nofollow" target="_blank"> seaborn </a>生成箱线图的代码也可以在补充<a class="ae lr" href="https://github.com/karpanGit/myBlogs/tree/master/ResponsibleConcurrentDataRetrieval" rel="noopener ugc nofollow" target="_blank">库</a>中找到。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/5aa573aa06a54944f35662bc70954315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDPPPVbYTPXciy5XaRaRDw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图6:响应时间</p></figure><p id="d255" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">检查日志，有大约30个警告与超过PubChem的请求量限制有关，响应代码为503，消息为“请求太多或服务器太忙”，与大约33k的请求相比，这是相当小的。这是一个相当小的数字，最终重试后数据检索成功。限制导致这种情况的原因可能不值得研究，因为很难准确解释PubChem对计算时间的定义以及我们的客户端跟踪方法测量的响应时间。PubChem允许一些回旋余地，我们显然在负责任地使用这些余地。</p><p id="337b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe oc od oe nh b">utilities.py </code>中的递归函数<code class="fe oc od oe nh b">utilities/parse_TOCHeadings</code>，我们看到PubChem包含6 248个CID编号的生物测定数据，即几乎一半的检索CID编号。此类数据可用于危险评估，同时PubChem还包含大量使用和暴露信息，对风险评估很有价值。<a class="ae lr" href="https://github.com/karpanGit/myBlogs/tree/master/ResponsibleConcurrentDataRetrieval" rel="noopener ugc nofollow" target="_blank">库</a>包含该<a class="ae lr" href="https://github.com/karpanGit/myBlogs/blob/master/ResponsibleConcurrentDataRetrieval/output/data_availability.xlsx" rel="noopener ugc nofollow" target="_blank">文件</a>中所有TOC标题的完整数据可用性。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><h1 id="692b" class="ls lt iq bd lu lv nx lx ly lz ny mb mc jw nz jx me jz oa ka mg kc ob kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="348a" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">还有其他方法来实现速率限制并发数据检索，例如通过将asyncio与一个<a class="ae lr" href="https://docs.python.org/3/library/asyncio-queue.html" rel="noopener ugc nofollow" target="_blank">队列</a>相结合。也允许限制同时连接的数量，但我决定采用信号量方法，因为这是一个更通用的节流解决方案，只依赖于asyncio本身。数据检索不是唯一可以异步执行的部分。例如，检索到的数据可以异步存储在PostgreSQL <a class="ae lr" href="https://github.com/aio-libs/aiopg" rel="noopener ugc nofollow" target="_blank">数据库</a>或<a class="ae lr" href="https://github.com/Tinche/aiofiles" rel="noopener ugc nofollow" target="_blank">文件系统</a>中。asyncio库和框架的列表在不断地<a class="ae lr" href="https://github.com/timofurrer/awesome-asyncio#alternatives-to-asyncio" rel="noopener ugc nofollow" target="_blank">增长</a>，现在有许多优秀的资源可用(例如，请阅读这篇优秀的<a class="ae lr" href="https://realpython.com/async-io-python/" rel="noopener ugc nofollow" target="_blank">文章</a>并浏览最后的资源链接)。事实上，甚至还有asyncio的替代品，比如<a class="ae lr" href="https://github.com/dabeaz/curio" rel="noopener ugc nofollow" target="_blank"> curio </a>和<a class="ae lr" href="https://github.com/python-trio/trio" rel="noopener ugc nofollow" target="_blank"> trio </a>。我对这些替代品的成熟程度了解不多。我承认asyncio发展很快，理解何时使用诸如futures、tasks和coroutines之类的东西并不容易，但同时它包含在标准库中，并且它现在有足够的发展势头。并发不是一个简单的话题，想象力是没有限制的。例如，在不同的<a class="ae lr" href="http://use a single core and hence speed-up is achieved by cleverly switching context whilst the external resource is taking its time to respond." rel="noopener ugc nofollow" target="_blank">内核</a>中运行多个asyncio循环可能会同时融化您的笔记本电脑和大脑(双关语)。玩笑归玩笑，我觉得asyncio对于数据分析师和数据科学家通常遇到的大多数io绑定流程来说已经足够了。</p><p id="1d7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了完整起见，IO绑定的进程也可以使用<a class="ae lr" href="https://realpython.com/python-concurrency/#threading-version" rel="noopener ugc nofollow" target="_blank">多线程</a>来编排。我个人的观点是，asyncio是比多线程更好的选择，因为切换上下文是显式的，不需要担心线程安全，这并不意味着asyncio没有自己的挑战。</p><p id="3968" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现是本文使用的高级asyncio功能，如<code class="fe oc od oe nh b">asyncio.gather()</code>。更明确地与循环和任务进行交互可以导致进一步的优化，从而使数据检索更加接近PubChem的请求量约束的限制。这是否值得追求是个人喜好的问题，因为性能的提高可能是微不足道的。此外，实现将不可避免地变得更加复杂，asyncio不仅复杂，而且在不断发展。维护代码需要相当多的脑力来阅读和试验新的特性，这可能会超过好处，除非你在理论上倾向于并享受挑战多于你需要的结果。人们有不同的观点和世界观，如果你准备好迎接挑战，请给我留言，指出你的方法。我将非常乐意阅读更多关于它的内容！</p><p id="bfe8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">免责声明</strong></p><p id="c497" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从欧洲化学品管理局获得的物质清单受此处和<a class="ae lr" href="https://echa.europa.eu/universe-of-registered-substances" rel="noopener ugc nofollow" target="_blank">免责声明</a>中解释的<a class="ae lr" href="https://echa.europa.eu/legal-notice" rel="noopener ugc nofollow" target="_blank">法律条款和条件的约束。PubChem数据使用政策和免责声明可在</a><a class="ae lr" href="https://www.ncbi.nlm.nih.gov/home/about/policies/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在使用本文中讨论的任何公开数据之前，请查阅这些页面。</p></div></div>    
</body>
</html>