<html>
<head>
<title>Data Scientists Need to Know Just One Statistical Test</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家只需要知道一个统计测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-scientists-need-to-know-just-one-statistical-test-3115b2ff26fd#2022-06-30">https://towardsdatascience.com/data-scientists-need-to-know-just-one-statistical-test-3115b2ff26fd#2022-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">读完这篇文章后，你将能够检验任何可能的统计假设。用独特的算法。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81d6980c06d160e2c9357ea66118cf87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqycnGXFLuvypvOQ-vfw4Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">[图片由作者提供]</p></figure><p id="5119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di">截止到今天的</span>，维基百科总共统计了<a class="ae md" href="https://en.wikipedia.org/wiki/Category:Statistical_tests" rel="noopener ugc nofollow" target="_blank"> 104次统计测试</a>。因此，数据科学家可能会感到不知所措，并问自己:</p><blockquote class="me"><p id="ab2c" class="mf mg it bd mh mi mj mk ml mm mn lt dk translated">“我应该知道他们所有人吗？我如何知道何时使用其中一个？”</p></blockquote><p id="5249" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我在这里向你保证:作为一名数据专业人员，你只需要知道一个测试。不是因为1个测试重要，其他103个可以忽略不计。而是因为:</p><blockquote class="me"><p id="daf3" class="mf mg it bd mh mi mj mk ml mm mn lt dk translated">所有的统计测试实际上都是同一个测试！</p></blockquote><p id="d351" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">一旦你真正掌握了这个测试是如何工作的，你将能够测试你需要的任何假设。</p><p id="605f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想要证据吗？在本文中，我们将解决4个不同的统计问题。我们会用相同的算法来解决它们。</p><ol class=""><li id="2686" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">你已经掷出了10次骰子。你得到了[1，1，1，1，2，2，2，3，3]。模具装好了吗？</li><li id="e0b0" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">你的朋友声称一些拼字游戏的瓦片从袋子里掉了出来，巧合的是，这些字母组成了一个真正的单词:“F-E-A-R”。你怀疑你的朋友只是想取笑你。你的朋友在撒谎吗？</li><li id="d320" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">在一项客户满意度调查中，100名客户对产品A的平均评分为3.00，对产品b的平均评分为2.63，这种差异显著吗？</li><li id="1816" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">你训练了一个二元分类模型。在您的测试集(由100个观察值组成)上，它在ROC曲线下的面积为70%。模型是否明显优于随机？</li></ol><p id="36dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在深入研究这些问题的答案之前，让我们试着了解一下统计测试的本质。</p><h1 id="9904" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">任何统计检验的深刻含义是什么？</h1><p id="4db8" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">我试着用统计学中最不原始的例子来回答这个问题:骰子的投掷。</p><p id="6a33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，你投了六次骰子，你得到了[2，2，2，2，4]。有点可疑，不是吗？你不会期望6次中有5次得到相同的数字。至少，如果死亡是公平的，你不会期望它发生<em class="oe">。</em></p><p id="d1f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这正是统计测试的要点。</p><p id="1446" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你有一个假设，叫做“零假设”，你想测试它。因此，你问自己:</p><blockquote class="me"><p id="cf86" class="mf mg it bd mh mi mj mk ml mm mn lt dk translated">“如果假设是真的，我得到的结果和我实际得到的结果一样可疑的几率有多大？”</p></blockquote><p id="7732" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在骰子的例子中，问题变成了:“如果骰子是公平的，我多久会得到一个像[2，2，2，2，4]这样意想不到的序列？”既然你问的是“多长时间一次”，那么答案必然是一个介于0和1之间的数字，其中0表示从不，1表示总是。</p><blockquote class="me"><p id="c364" class="mf mg it bd mh mi mj mk ml mm mn lt dk translated"><strong class="ak">在统计学中，这种“多频繁”被称为“p值”。</strong></p></blockquote><p id="b86a" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">在这一点上，推理的路线是相当琐碎的:<strong class="la iu">如果p值非常低，那么这意味着你最初的假设很可能是错误的。</strong></p><p id="0ffa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意,“出乎意料”的概念与您正在测试的特定假设密切相关。例如，如果你认为骰子是公平的，那么结果[2，2，2，2，4]就很奇怪。然而，如果你认为骰子在75%的情况下都是装载到数字“2”中，这就不足为奇了。</p><h1 id="fb2d" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">统计测试的要素</h1><p id="4a1e" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">阅读前一段，你可能已经猜到我们需要两种成分:</p><ol class=""><li id="58b9" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">可能结果的分布，取决于零假设。</li><li id="c637" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">衡量任何结果的“不可预测性”。</li></ol><p id="5834" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于第一个因素，得到结果的全部分布并不总是简单的。通常，<strong class="la iu">随机模拟大量结果</strong>更方便(也更容易):这是真实分布的一个很好的近似值。</p><p id="0938" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于第二个要素，我们需要定义<strong class="la iu">一个将每个可能的结果映射成一个数字</strong>的函数。这个数字必须表示结果有多出乎意料，假设零假设为真:结果越出乎意料，这个分数就越高。</p><p id="0719" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们有了这两个要素，工作基本上就完成了。实际上，计算分布中每个结果的未预期分数和观察结果的未预期分数就足够了。</p><p id="d1ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">p值是随机得分高于观察得分的百分比。</strong></p><p id="a720" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样。这就是每一个统计测试的工作原理。</p><p id="ddef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们刚刚描述的流程的图示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d72ee1c52610b93520346a8cafd16c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pnx8rZ1Vy6rM7b7IhwQJWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何计算公平骰子的零假设下outcome [2，2，2，2，2，4]的p值？[图片由作者提供]</p></figure><h1 id="55c4" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">独特的统计测试</h1><p id="7479" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">但是我们如何在Python中实现呢？算法如下:</p><ol class=""><li id="358f" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">定义一个函数<code class="fe og oh oi oj b">draw_random_outcome</code>。这个函数应该返回随机试验的结果，假设零假设为真。它可以是一个数字、一个数组、一个数组列表、一个图像，实际上可以是任何东西:这取决于具体的情况。</li><li id="4dbe" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">定义一个函数<code class="fe og oh oi oj b">unexp_score</code>(代表“意外得分”)。该函数应该将实验结果作为输入，并返回一个数字。这个数字必须是结果出乎意料程度的分数，假设它是在零假设下产生的。分数可能是正数，负数，整数，或者浮点数，都没关系。它必须具有的唯一属性如下:<strong class="la iu">结果越不可能，这个分数就必须越高</strong>。</li><li id="ac33" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">多次(例如10，000次)运行函数<code class="fe og oh oi oj b">draw_random_outcome</code>(在第1点定义)，对于每个随机结果，计算其<code class="fe og oh oi oj b">unexp_score</code>(在第2点定义)。将所有的分数存储在一个名为<code class="fe og oh oi oj b">random_unexp_scores</code>的数组中。</li><li id="80c9" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">计算观察结果的<code class="fe og oh oi oj b">unexp_score</code>，称之为<code class="fe og oh oi oj b">observed_unexp_score</code>。</li><li id="2796" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">计算有多少随机结果比观察到的结果更出乎意料。也就是说，数一数<code class="fe og oh oi oj b">random_unexp_scores</code>有多少个元素比<code class="fe og oh oi oj b">observed_unexp_score</code>高。这是p值。</li></ol><p id="c63d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">根据具体情况，前两步是唯一需要一点创造力的步骤</strong>，而第3、4和5步则完全是机械的。</p><p id="a16e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，为了更具体，让我们看一下例子。</p><h1 id="9d4d" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">例1。滚动骰子</h1><p id="d7c8" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">我们已经发射了10次骰子，并获得了这样的结果:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="3d64" class="oo ni it oj b gy op oq l or os">observed_outcome = np.array([1,1,1,1,1,2,2,2,3,3])</span></pre><p id="e422" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无效假设是骰子是公平的。在这个假设下，很容易提取随机结果:用Numpy的<code class="fe og oh oi oj b">random.choice</code>就够了。这是我们算法的第一步:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="1c7f" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 1<br/></strong>def draw_random_outcome():</span><span id="5f5b" class="oo ni it oj b gy ot oq l or os">  return np.random.choice([1,2,3,4,5,6], size=10)</span></pre><p id="82e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二步是定义一个名为<code class="fe og oh oi oj b">unexp_score</code>的函数，该函数应该为每个可能的结果分配一个不可预测的分数。</p><p id="5298" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果骰子是公平的，我们期望每张脸平均出现六分之一的时间。所以我们要检查每张脸的观察频率和1/6的距离。然后，为了获得单个分数，我们应该取平均值。这样，距离六分之一的平均距离越高，结果就越出人意料。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="7590" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 2<br/></strong>def <!-- -->unexp_score<!-- -->(outcome):</span><span id="451a" class="oo ni it oj b gy ot oq l or os">  outcome_distribution = np.array([np.mean(outcome == face) for face in [1,2,3,4,5,6]])</span><span id="4ed9" class="oo ni it oj b gy ot oq l or os">  return np.mean(np.abs(outcome_distribution - 1/6))</span></pre><p id="9064" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至此，困难的部分已经完成:正如我之前所说，算法的步骤3、4和5完全是机械的。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="f600" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 3<br/></strong>n_iter = 10000</span><span id="417f" class="oo ni it oj b gy ot oq l or os">random_unexp_scores = np.empty(n_iter)</span><span id="0362" class="oo ni it oj b gy ot oq l or os">for i in range(n_iter):<br/>  random_unexp_scores[i] = unexp_score(draw_random_outcome())</span><span id="8c03" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 4<br/></strong>observed_unexp_score = unexp_score(observed_outcome)</span><span id="362f" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 5<br/></strong>pvalue = np.sum(random_unexp_scores &gt;= observed_unexp_score) / n_iter</span></pre><p id="3319" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">得到的p值为1.66%，这意味着在零假设下，只有1.66%的结果像[1，1，1，1，1，2，2，2，3，3]一样出乎意料。</p><p id="a5ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于好奇，这是一个直方图，显示了意外得分的分布以及观察得分的确切位置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/3663989c5ad99baeb484dd5cee00be04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7LRHNOVL1Z8OAwIim2eiA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">掷出10次骰子的意外得分。无效假设:骰子是公平的。观察结果:[1，1，1，1，2，2，3，3]。[图片由作者提供]</p></figure><h1 id="249e" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">例2。拼字迷</h1><p id="b0f8" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">你的朋友声称一些拼字游戏的瓦片从袋子里掉了出来，巧合的是，这些字母组成了一个真正的单词:“F-E-A-R”。你怀疑你的朋友在戏弄你。如何统计检查你的朋友是否在说谎？</p><p id="68c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，观察到的结果是一系列字母，因此是一个字符串:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="7199" class="oo ni it oj b gy op oq l or os">observed_outcome = 'FEAR'</span></pre><p id="4f53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设袋子里有26个字母。无效假设是随机数量的字母(在1到26之间)以随机的顺序从袋子里掉出来。因此，我们将不得不使用Numpy的<code class="fe og oh oi oj b">random</code>来表示字母的数量和字母的选择:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="c146" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 1<br/></strong>def draw_random_outcome():</span><span id="985e" class="oo ni it oj b gy ot oq l or os">  size=np.random.randint(low=1, high=27)</span><span id="a92a" class="oo ni it oj b gy ot oq l or os">  return ''.join(np.random.choice(list(string.ascii_uppercase), size=size, replace=False))</span></pre><p id="3341" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，如何评价这个场景中的意外？</p><p id="53ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一般来说，我们有理由认为从袋子里掉出来的字母越多，就越不可能找到一个真正的单词。</p><p id="31d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以使用这个规则:如果字符串是一个现有的单词，那么它的得分将是该单词的长度。如果字符串不是一个真实的单词，那么它的分数将是单词长度的减。</p><p id="62a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以这是算法的第二步(注意:你必须<code class="fe og oh oi oj b">pip install english-words</code>让下面的代码工作)。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="8fa1" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 2<br/></strong>from english_words import english_words_set</span><span id="0565" class="oo ni it oj b gy ot oq l or os">english_words_set = [w.upper() for w in english_words_set]</span><span id="b8e0" class="oo ni it oj b gy ot oq l or os">def unexp_score(outcome):</span><span id="5619" class="oo ni it oj b gy ot oq l or os">  is_in_dictionary = outcome in english_words_set</span><span id="c654" class="oo ni it oj b gy ot oq l or os">  return (1 if is_in_dictionary else -1) * len(outcome)</span></pre><p id="7d65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">步骤3、4、5总是相同的，因此我们将从上一个示例中复制并粘贴它们:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="8cd4" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 3<br/></strong>n_iter = 10000</span><span id="bdd6" class="oo ni it oj b gy ot oq l or os">random_unexp_scores = np.empty(n_iter)</span><span id="bcf8" class="oo ni it oj b gy ot oq l or os">for i in range(n_iter):<br/>  random_unexp_scores[i] = unexp_score(draw_random_outcome())</span><span id="0499" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 4<br/></strong>observed_unexp_score = unexp_score(observed_outcome)</span><span id="dfb9" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 5<br/></strong>pvalue = np.sum(random_unexp_scores &gt;= observed_unexp_score) / n_iterThis is the result:</span></pre><p id="f409" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/e870b78750b3fab27459ed67cefe4f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1SpF1Zi-EvujFZXZej4fg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">字母表中随机字符串的意外分数。零假设:随机选择一些字母，字母的顺序也是随机的。观察结果:“恐惧”。[图片由作者提供]</p></figure><p id="a507" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，p值为0.0，因为没有随机得分高于观察得分。所以，根据这个统计测试，你的朋友在撒谎！</p><h1 id="12ee" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">例3。两个平均值之间的差异</h1><p id="7fab" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">您要求100名客户对您的两种产品进行评级:产品A和产品b。您获得了以下评级:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="dd54" class="oo ni it oj b gy op oq l or os">product_a = np.repeat([1,2,3,4,5], 20)</span><span id="d0ee" class="oo ni it oj b gy ot oq l or os">product_b = np.array([1]*27+[2]*25+[3]*19+[4]*16+[5]*13)</span><span id="d449" class="oo ni it oj b gy ot oq l or os">observed_outcome = np.mean(product_a) - np.mean(product_b)</span></pre><p id="862b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果计算为产品A的平均评分(3.0)和产品B的平均评分(2.63)之间的差异，在本例中为0.37。</p><p id="fc80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为您想要测试平均评分之间的差异是否显著，所以零假设是产品A和产品b之间没有差异。如果这是真的，我们可以在两个产品之间调换评分。</p><p id="8c2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，函数<code class="fe og oh oi oj b">unexp_score</code>将获取所有200个评分，对它们进行洗牌，随机分配100个给A，剩余的100个给b。然后，它将计算两个平均值之间的差异。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="6e3c" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 1<br/></strong>def draw_random_outcome():</span><span id="ebd8" class="oo ni it oj b gy ot oq l or os">  pr_a, pr_b = np.random.permutation(np.hstack([product_a, product_b])).reshape(2,-1)</span><span id="5691" class="oo ni it oj b gy ot oq l or os">  return np.mean(pr_a) - np.mean(pr_b)</span></pre><p id="c0a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据两种产品之间没有差异的假设，均值之间观察到的差异应该很小。因此，离零越远的结果值就越出人意料。所以我们可以把结果的绝对值作为意外得分:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="b261" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 2<br/></strong>def unexp_score(outcome):</span><span id="e765" class="oo ni it oj b gy ot oq l or os">  return np.abs(outcome)</span></pre><p id="bac6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">步骤3、4、5总是相同的，因此我们将从上一个示例中复制并粘贴它们:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="9d61" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 3<br/></strong>n_iter = 10000</span><span id="f5f9" class="oo ni it oj b gy ot oq l or os">random_unexp_scores = np.empty(n_iter)</span><span id="65cb" class="oo ni it oj b gy ot oq l or os">for i in range(n_iter):<br/>  random_unexp_scores[i] = unexp_score(draw_random_outcome())</span><span id="1859" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 4<br/></strong>observed_unexp_score = unexp_score(observed_outcome)</span><span id="2934" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 5<br/></strong>pvalue = np.sum(random_unexp_scores &gt;= observed_unexp_score)/ n_iter</span></pre><p id="b517" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/1550eaa3ef39cc901644cdb945847179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n0zLfPro2BYdku9z3LqNqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">均值间差异的意外得分。零假设:均值之间没有差异。观察结果:0.37。[图片由作者提供]</p></figure><p id="6424" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种情况下的p值为6.82%。因此，在传统的统计测试中，如果您将阈值设置为1%或5%，您应该会得出平均评级之间没有显著差异的结论。</p><h1 id="2b3d" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated"><strong class="ak">例4。ROC曲线下面积</strong></h1><p id="b13a" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">假设你训练了一个预测模型，它在测试数据集上ROC下有70%的面积。好消息，对吧？但是测试集仅由100个观察值组成。那么你怎么证明这个结果是否显著呢？</p><p id="b2b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象这些是你的初始元素:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="9ebd" class="oo ni it oj b gy op oq l or os">y_test = np.random.choice([0,1], size=100, p=[.9,.1])</span><span id="29c0" class="oo ni it oj b gy ot oq l or os">proba_test = np.random.uniform(low=0, high=1, size=100)</span><span id="1199" class="oo ni it oj b gy ot oq l or os">observed_outcome = .7</span></pre><p id="5a74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无效假设是你的模型与随机模型没有什么不同，所以如果你只是打乱你的预测并计算<code class="fe og oh oi oj b">roc_auc_score</code>，你会得到一个在无效假设下产生的结果:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="1d38" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 1<br/></strong>def draw_random_outcome():</span><span id="9f7a" class="oo ni it oj b gy ot oq l or os">  return roc_auc_score(y_test, np.random.permutation(proba_test))</span></pre><p id="9786" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个结果有多出乎意料？由于我们正在处理ROC曲线下的区域，其中50%表示随机分类器，因此当它进一步远离50%时，结果更加出乎意料，因此我们的函数<code class="fe og oh oi oj b">unexp_score</code>可以是<code class="fe og oh oi oj b">roc_auc_score</code>和50%之间的绝对差值:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="60ab" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 2<br/></strong>def unexp_score(outcome):<br/>  return np.abs(outcome - .5)</span></pre><p id="2b35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">步骤3、4、5总是相同的，因此我们将从上一个示例中复制并粘贴它们:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="d0e6" class="oo ni it oj b gy op oq l or os"><strong class="oj iu"># step 3<br/></strong>n_iter = 10000</span><span id="8ed4" class="oo ni it oj b gy ot oq l or os">random_unexp_scores = np.empty(n_iter)</span><span id="1762" class="oo ni it oj b gy ot oq l or os">for i in range(n_iter):<br/>  random_unexp_scores[i] = unexp_score(draw_random_outcome())</span><span id="7799" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 4<br/></strong>observed_unexp_score = unexp_score(observed_outcome)</span><span id="1e38" class="oo ni it oj b gy ot oq l or os"><strong class="oj iu"># step 5<br/></strong>pvalue = np.sum(random_unexp_scores &gt;= observed_unexp_score) / n_iter</span></pre><p id="37e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/534effdb9a4958e716f8f7e21b0e55b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnnKS9IVV3Epnc5c6xTHBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ROC曲线下面积的意外分数。零假设:预测模型与随机模型没有区别。观察结果:70%。[图片由作者提供]</p></figure><p id="3080" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">p值为2.25%，因此观察到的结果并不像我们最初认为的那样“令人惊讶”。如果你设置阈值为1%，遵循统计测试的经典规则，你不能拒绝你的模型不比随机模型好的假设。</p><h1 id="45bb" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">那么，为什么所有这些统计测试？</h1><p id="3ff2" class="pw-post-body-paragraph ky kz it la b lb nz ju ld le oa jx lg lh ob lj lk ll oc ln lo lp od lr ls lt im bi translated">如果你已经走到这一步，你可能会想:如果这么容易，为什么还存在这么多的测试？答案大多是“历史”。</p><p id="ffa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">曾几何时，计算比现在昂贵得多，因此“统计测试”基本上是高效计算p值的捷径。由于我们所看到的算法的第一步和第二步有如此多的选择可能性，测试激增。</p><p id="7379" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想深化这个话题，可以读一下艾伦·唐尼的经典之作<a class="ae md" href="http://allendowney.blogspot.com/2011/05/there-is-only-one-test.html" rel="noopener ugc nofollow" target="_blank">《只有一个测试》</a>，正是它启发了本文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/17c74346e31fb4d7f0c892ab7e00a5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TXOR-eCNEIAdbX5j.png"/></div></div></figure><p id="782a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oe">感谢您的阅读！我希望你喜欢这篇文章。如果你愿意，</em> <a class="ae md" href="https://www.linkedin.com/in/samuelemazzanti/" rel="noopener ugc nofollow" target="_blank"> <em class="oe">在Linkedin上加我</em> </a> <em class="oe">！</em></p></div></div>    
</body>
</html>