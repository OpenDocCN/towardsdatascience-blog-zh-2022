<html>
<head>
<title>How-To: 4 Essential Parts of Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">how-To:Python中多重处理的4个基本部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multiprocessing-in-python-9d498b1029ca#2022-09-22">https://towardsdatascience.com/multiprocessing-in-python-9d498b1029ca#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="058e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">像专家一样编码！</h2><div class=""/><div class=""><h2 id="153d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">有效的Python</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/37b7018822a16e81869ffe187de23975.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_h9IyXdJhDjbWCmW9dvC0Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图一。</strong>进程、锁、队列和池对于理解多处理Python包至关重要。写完博客后，理解以上内容将使编码人员能够在他们的源代码中利用并行处理，并理解在其他代码中的用法。</p></figure><p id="6d84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">经过多次请求、一些计划，并有时间交付一个实用的摘要之后，我很高兴地分享一个指南，它将允许您开始在Python代码中使用并行处理！</p><h1 id="987d" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="ef81" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi nb translated"><span class="l nc nd ne bm nf ng nh ni nj di"> P </span>并行处理可以加速你的代码，并处理每个数据集样本要执行的许多任务。遵循这种范式，Python中的多处理允许您同时运行多个进程。我们讨论Python中多处理包的四个重要组件:进程、锁、队列和池(图1)。</p><h1 id="9e7f" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">目录</h1><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="7a50" class="np mf it nl b gy nq nr l ns nt">· <a class="ae nu" href="#43d9" rel="noopener ugc nofollow">Introduction</a><br/>· <a class="ae nu" href="#0df6" rel="noopener ugc nofollow">What is multiprocessing, and why use it?</a><br/>· <a class="ae nu" href="#2a93" rel="noopener ugc nofollow">Multiprocessing in Python</a><br/>· <a class="ae nu" href="#cd53" rel="noopener ugc nofollow">Using the multiprocessing library — Process, Lock, Queue, Pool</a><br/>  ∘ <a class="ae nu" href="#f318" rel="noopener ugc nofollow">1. Process</a><br/>  ∘ <a class="ae nu" href="#0385" rel="noopener ugc nofollow">2. Lock</a><br/>  ∘ <a class="ae nu" href="#30eb" rel="noopener ugc nofollow">3. Queue</a><br/>  ∘ <a class="ae nu" href="#943e" rel="noopener ugc nofollow">4. Pool</a><br/>· <a class="ae nu" href="#8d4e" rel="noopener ugc nofollow">Tips on how to get started with multiprocessing</a><br/>· <a class="ae nu" href="#bf67" rel="noopener ugc nofollow">Tips on Best Practices for Using Multiprocessing</a><br/>· <a class="ae nu" href="#9794" rel="noopener ugc nofollow">Conclusion</a><br/>· <a class="ae nu" href="#4705" rel="noopener ugc nofollow">Supplemental Material</a></span></pre><h1 id="43d9" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">介绍</h1><p id="4625" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi nb translated"><span class="l nc nd ne bm nf ng nh ni nj di"> D </span>数据科学家经常被赋予使用各种转换技术处理一组数据点的任务。换句话说，给定一个数据集，我们的目标是通过过滤、转换、清理、缩放等对数据进行预处理。此外，为了突出和理解，或者为了分析和可视化结果，必须经常对得到的数据进行后处理。因此，相同的工作必须对<em class="nv"> N </em>个数据样本执行<em class="nv"> N </em>次——正如有经验的数据科学家所争论的那样，建模前后的步骤会成为额外的瓶颈。想了解如何利用CPU的全部功能来减少时间开销吗？如果我说使用多处理Python包很容易呢？</p><p id="cd35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们学习如何通过几行额外的代码来加快Python的运行时间！但是首先，让我们并行运行这组进程！入门所需的所有知识涵盖了多处理包的四个组件——进程、锁、队列和池(图1)。</p><p id="625b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们从定义多处理开始，同时强调它的用例。接下来，我们讨论Python编程特有的多重处理。然后，通过定义、示例代码和视觉效果描述并举例说明入门所需的四个组件；下面是采用最佳实践的技巧。最后，在总结时，我们回顾了那些希望将学习提高到下一个水平的人的补充资源。完整的代码在Github上。</p><h1 id="0df6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">什么是多重处理，为什么要使用它？</h1><p id="5395" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">多重处理指的是同时运行多个进程，这对加速代码和处理大型数据集和任务非常有用。例如，并行运行一个操作可以将一个作业分成几个可以同时处理的较小部分。典型的单处理器执行，时间成本为<em class="nv">N×M</em>，其中<em class="nv"> M </em>为单个进程的时间(即时间单位)，下至(<em class="nv"> N / C </em> ) <em class="nv"> x M </em>，其中<em class="nv"> C </em>为CPU核心数。考虑到<em class="nv"> N </em>在现代大数据范式中可能会变得非常大，我们可以缩短时间。当您的计算机有多个内核或处理器时，这尤其有用。此外，多处理可以将I/O密集型任务分散到不同的进程中，从而提高这些任务的性能(图2)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/df18befda7f1249831dfd77e1bfb2ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDoGZTklg0ZC02kjQfnuRQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图二。</strong>对加工类型的描述。作业期间访问的资源(蓝色文本框)访问内存资源(绿色)以在CPU核心线程(红色)上处理作业。如前所述，本质上可并行化的CPU密集型任务可以在多个处理器上运行(右图)，这是本博客的主题。多线程值得一个单独的博客——期待后续的主题。有关内存和资源的资源，请参见末尾的补充资料。作者创作了这幅插图。</p></figure><p id="9739" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然多重处理非常有用，但是注意到一些与使用它相关的潜在危险是很重要的。例如，如果两个进程试图同时访问同一资源，这可能会导致数据损坏或不一致。因此，锁对于保护进程间的共享资源至关重要。与此同时，一个有效的程序员将了解硬件的能力，因此，充分利用它的潜力(图3)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/28826d7c71055f1462bbc48ba4512430.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/1*NxUdE-Ok0nip_nQ-Na1ikg.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图3。</strong>GIF展示了单核处理(上图)和多核处理(即多处理，下图)之间的区别。该图描绘了具有四个核心的同一个CPU，四个核心被四个任务(即T1、T2、…、T4)所包围。请注意单核是如何连续处理任务的，必须完成第一个任务，然后是下一个任务，依此类推。另一方面，多重处理利用所有四个核心来处理程序(也称为作业、任务等)。)并行。作者创作了动画。</p></figure><p id="dd92" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于那些视觉学习最好的人，让我们用另一种方式来比较单处理和多处理:作为处理器和作业的函数(图4)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ny"><img src="../Images/da4d4296fc10d35d32e2ffcf8bf4cd8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZD-p1hy_pqWOdGvwPVjUpQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图4。</strong>应该清楚的是，比较单处理和多处理范例，M个作业(例如，本例中为4个)或者一个接一个地串行执行(top ),或者作为独立的进程同时执行。哪个看起来更有效率？作者创作的人物。</p></figure><h1 id="2a93" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">Python中的多重处理</h1><p id="fd58" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">多重处理利用多个CPU内核来加速计算负载。Python采用了一个<a class="ae nu" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>(即GIL)，这是一种通过为<a class="ae nu" href="https://realpython.com/python-memory-management/" rel="noopener ugc nofollow" target="_blank">内存管理</a>实现的引用计数方案来避免内存泄漏和不必要的竞争情况的范例。像大多数实现策略一样，GIL有其优点和缺点，让我们考虑一个主要缺陷:它限制了Python字节码在同一个内核的单个线程上运行。除此之外，GIL是未来博客的主题。现在，我们知道在核心Python中，并行编程是被有意禁用的。</p><p id="a63b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python提供了几个工具，通过同名的包来实现多处理，包括进程、锁、队列和池。我们将讨论每个组件，并举例说明接下来如何使用它们。首先，让我们导入包并确定系统中可用的内核数量(图5)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nz"><img src="../Images/8d26ad8e364778e4b6f4477f5cb9d81a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1zSGfrKj0CQGp7tFJExgQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图5。</strong>导入并调用' cpu_count()'来了解当前cpu上有多少核心。作者创作了这幅插图。</p></figure><h1 id="cd53" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">使用多处理库—进程、锁、队列和池</h1><p id="945a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Python的多重处理的四个基本组件都有特定的用途。下面是每一个的简要概述。</p><h2 id="f318" class="np mf it bd mg oa ob dn mk oc od dp mo lr oe of mq lv og oh ms lz oi oj mu iz bi translated">1.过程</h2><p id="df5d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这是Python中的基本执行单元。每个进程都有自己的Python解释器副本和内存空间，允许多个作业同时执行而不会发生冲突。</p><p id="e423" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nv">流程</em>类的处理如下:(1)通过forked复制当前流程；(2)创建新的进程标识符；(3)任务作为独立的子进程运行。</p><p id="044c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">具体来说，如下例所示，<em class="nv">进程</em>通过两个函数<code class="fe ok ol om nl b">start()</code>和<code class="fe ok ol om nl b">join()</code>进行管理。</p><p id="9eb5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">举例和动手学习。</strong></p><p id="b0d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们首先定义一个为<code class="fe ok ol om nl b">sleep_sec</code>休眠的函数，默认值设置为半秒。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="ce4a" class="np mf it nl b gy nq nr l ns nt">import time<br/> <br/>def sleep(sleep_sec=0.5):<br/>    print(f'Sleeping for {sleep_sec} seconds')<br/>    time.sleep(sleep_sec)<br/>    print('Finished sleeping')</span></pre><p id="091c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，让我们使用多重处理包创建多个进程。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="fbed" class="np mf it nl b gy nq nr l ns nt">import multiprocessing<br/>p1 = multiprocessing.Process(target=task)<br/>p2 = multiprocessing.Process(target=task)</span></pre><p id="7088" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ok ol om nl b">Process()</code>的<code class="fe ok ol om nl b">target</code>参数指定了流程运行的目标函数。但是这些进程在启动之前不会立即运行。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="ca1c" class="np mf it nl b gy nq nr l ns nt">p1.start()<br/>p2.start()</span></pre><p id="d802" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将所有这些放在一起，我们有以下内容:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="872e" class="np mf it nl b gy nq nr l ns nt">import multiprocessing<br/>import time<br/> <br/>def sleep(sleep_sec=0.5):<br/>    print(f'Sleeping for {sleep_sec} seconds')<br/>    time.sleep(sleep_sec)<br/>    print('Finished sleeping')<br/> <br/>if __name__ == "__main__":<br/>    start_time = time.perf_counter()<br/> <br/>    # Creates two processes<br/>    p1 = multiprocessing.Process(target=sleep)<br/>    p2 = multiprocessing.Process(target=sleep)<br/> <br/>    # Starts both processes<br/>    p1.start()<br/>    p2.start()<br/> <br/>    finish_time = time.perf_counter()<br/> <br/>    print(f"Program finished in {(finish_time - start_time):.3f} seconds")</span></pre><p id="b29c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">打印报表将被设置为如下引号:</p><blockquote class="on oo op"><p id="fdb7" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated"><em class="it">程序0.013秒结束<br/>休眠0.5秒<br/>休眠0.5秒<br/>休眠结束<br/>休眠结束</em></p></blockquote><p id="8f4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，虽然执行了两次对<code class="fe ok ol om nl b">sleep</code>的调用，但是人们会认为程序至少需要1秒钟(即，睡眠两次，每次半秒钟)。此外，程序末尾的print语句出现在之前通过函数调用执行的语句之前。这是为什么呢？答案很简单。如上所述，<code class="fe ok ol om nl b">start()</code>和<code class="fe ok ol om nl b">join()</code>是<code class="fe ok ol om nl b">Process()</code>类一起使用的方法。在我们做<code class="fe ok ol om nl b">start()</code>的地方，我们从来不<code class="fe ok ol om nl b">join()</code>。让我们使用原理图来检查程序流程(图6)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/445a99e96a5d3268dd0818c391b93b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdzMM5i0nZuN77aqCZO4bQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图6。</strong>当没有调用‘join()’时，程序将执行与其他进程并行的主进程。因此，需要将打印的时间打印在作者创建的主示意图的末尾。</p></figure><p id="b305" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在解决这个问题之前，让我们强调一下关于Python中多重处理的一个重要注意事项。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="0f0e" class="np mf it nl b gy nq nr l ns nt">ℹ️ The main program (i.e.,<!-- -->if <em class="nv">__name__ == "__main__"</em>) must encapsulate our execution; else, the <!-- -->multiprocessing<!-- --> module complains. This safety construct guarantees Python finishes analyzing the program before the sub-process is created.</span></pre><p id="ad8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，回到我们的程序，它似乎没有按顺序运行，事实并非如此，但它没有被设置为等待。我们需要在两个进程上调用<code class="fe ok ol om nl b">join()</code>函数，让它们在打印时间之前运行。这是因为有三个过程正在进行:<code class="fe ok ol om nl b">p1</code>、<code class="fe ok ol om nl b">p2</code>和主过程。主进程是跟踪和打印执行时间的进程。我们应该使<code class="fe ok ol om nl b">finish_time</code>线的运行不早于<code class="fe ok ol om nl b">p1</code>和<code class="fe ok ol om nl b">p2</code>工序的完成。我们需要在<code class="fe ok ol om nl b">start()</code>函数调用后立即添加这段代码:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="2c66" class="np mf it nl b gy nq nr l ns nt">p1.join()<br/>p2.join()</span></pre><p id="5fb5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe ok ol om nl b">join()</code>方法强制其他进程等待，直到调用它的进程完成。以下是添加了join语句的输出:</p><blockquote class="on oo op"><p id="abe1" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated"><em class="it">休眠0.5秒<br/>休眠0.5秒<br/>休眠完毕<br/>休眠完毕<br/>程序在0.568213340181392秒内完成</em></p></blockquote><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/b58c2eef6a8c2ba8889a03f0b7640142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ip1BQ9EXK8FH_jLmuGgl6g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">图7。</strong>现在，程序将等待并行作业完成，因为每个流程实例都调用了“join()”。作者创建的示意图。</p></figure><p id="4f4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看更新后的程序流(图7)。</p><p id="d032" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过类似的推理，我们可以运行更多的进程。下面是从上面修改的具有10个进程的完整代码:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="435e" class="np mf it nl b gy nq nr l ns nt">import multiprocessing<br/>import time<br/><br/><br/>def sleep(sleep_sec=0.5):<br/>    print(f'Sleeping for {sleep_sec} seconds')<br/>    time.sleep(sleep_sec)<br/>    print('Finished sleeping')<br/><br/><br/>if __name__ == "__main__":<br/>    start_time = time.perf_counter()<br/>    processes = []<br/><br/>    # Creates 10 processes then starts them<br/>    for i in range(10):<br/>        p = multiprocessing.Process(target=sleep, args=(1.0,))<br/>        p.start()<br/>        processes.append(p)<br/><br/>    # Joins all the processes<br/>    for p in processes:<br/>        p.join()<br/><br/>    finish_time = time.perf_counter()<br/><br/>    print(f"Program finished in {finish_time - start_time):.3f} seconds")</span></pre><blockquote class="on oo op"><p id="ae71" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡1.0秒<br/>睡完<br/>睡完<br/>睡完<br/>睡完<br/>睡完<br/></p><p id="fac8" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">进程结束，退出代码为0</p></blockquote><p id="a3a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们运行上面的代码片段，它调用了<code class="fe ok ol om nl b">sleep(1.0)</code>十次:如果没有多核处理，我们预计代码至少需要十秒钟。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="122e" class="np mf it nl b gy nq nr l ns nt">ℹ️ Referring to the complete code above: notice that input arguments can be passed via keyword <em class="nv">args</em>, which expects a tuple. Also, notice that we loop and store each process in a list, which is better practice for there could be variable processes, opposed to hard-coding <em class="nv">p1, p2, ..., p10</em>.</span></pre><h2 id="0385" class="np mf it bd mg oa ob dn mk oc od dp mo lr oe of mq lv og oh ms lz oi oj mu iz bi translated">2.锁</h2><p id="7d69" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如上所述，进程是程序的运行实例，封装了每个Python程序(即，每个都是Python解释器的新实例)。<code class="fe ok ol om nl b">MainProcess</code>是当<code class="fe ok ol om nl b">python &lt;file&gt;.py</code>作为脚本运行时的流程名称——这是我们前面通过schematics看到的一个方面。此外，我们了解到子进程可以通过一个<code class="fe ok ol om nl b">Process</code>实例派生出来并同时运行。通常，这些并发程序在进程间共享数据或资源。互斥锁保护共享资源并防止竞争情况。</p><blockquote class="on oo op"><p id="1e40" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">最常用的确保互斥的机制是互斥锁或互斥体，或简单的锁。互斥体是一种特殊类型的对象，在底层硬件中有支持。基本思想是每个关键部分都有锁保护。</p></blockquote><p id="ee57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">——第53页，<a class="ae nu" href="https://amzn.to/3LRljie" rel="noopener ugc nofollow" target="_blank">并行编程介绍</a>，2020。</p><p id="fc0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nv">锁</em>用于保护进程间的共享资源。它们允许多个作业无冲突地访问一个资源。此外，<em class="nv">锁</em>对于确保作业之间的数据一致至关重要。</p><p id="9ad8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nv">锁</em>允许代码断言，在锁被释放之前，没有其他进程可以执行类似的代码。因此，类<em class="nv">锁</em>的目的是双重的:(1)通过<code class="fe ok ol om nl b">acquire()</code>函数来声明锁；(2)通过<code class="fe ok ol om nl b">release()</code>功能解除锁定。</p><p id="0875" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们吸取上面<code class="fe ok ol om nl b">Process</code>的教训。下面是要运行的完整代码:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="874b" class="np mf it nl b gy nq nr l ns nt"># example of a mutual exclusion (mutex) lock for processes<br/>import time<br/>from random import random<br/>from multiprocessing import Process<br/>from multiprocessing import Lock<br/><br/><br/># work function<br/>def sleep(lock, identifier, value):<br/>    # acquire the lock<br/>    with lock:<br/>        print(f'&gt;process {identifier} got the lock, sleeping for {value:.3f}')<br/>        time.sleep(value)<br/><br/><br/># entry point<br/>if __name__ == '__main__':<br/>    # create the shared lock<br/>    lock = Lock()<br/>    # create a number of processes with different sleep times<br/>    processes = [Process(target=sleep, args=(lock, i, random())) for i in range(10)]<br/>    # start the processes<br/>    for process in processes:<br/>        process.start()<br/>    # wait for all processes to finish<br/>    for process in processes:<br/>        process.join()</span></pre><p id="388f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出如下。</p><blockquote class="on oo op"><p id="9a80" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">&gt;进程0获得锁，休眠0.297 <br/> &gt;进程1获得锁，休眠0.908 <br/> &gt;进程2获得锁，休眠0.223 <br/> &gt;进程3获得锁，休眠0.016 <br/> &gt;进程4获得锁，休眠0.323 <br/> &gt;进程5获得锁，休眠0.796 <br/> &gt;进程6获得锁，休眠0。</p><p id="315f" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">进程结束，退出代码为0</p></blockquote><p id="449f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们再次运行相同的代码会怎么样:</p><blockquote class="on oo op"><p id="3c8b" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">&gt;进程0得到锁，休眠0.223 <br/> &gt;进程1得到锁，休眠0.175 <br/> &gt;进程2得到锁，休眠0.148 <br/> &gt;进程3得到锁，休眠0.773 <br/> &gt;进程4得到锁，休眠0.180 <br/> &gt;进程5得到锁，休眠0.294 <br/> &gt;进程7得到锁</p><p id="40cd" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">进程结束，退出代码为0</p></blockquote><p id="e476" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意第二次运行时<em class="nv"> ID5 </em>在<em class="nv"> ID7 </em>之前，返回到<em class="nv"> ID6 </em>。这怎么可能？</p><p id="5e46" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以开发一个例子，通过将上面的示例代码分成几部分来演示如何使用互斥锁。</p><p id="6d4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们可以定义一个目标任务函数，它将一个锁作为参数，并使用锁来保护一个关键部分。</p><p id="80ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">关键部分包括报告消息和几分之一秒的阻塞。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="9892" class="np mf it nl b gy nq nr l ns nt"># work function<br/>def sleep(lock, identifier, value):<br/>    # acquire the lock<br/>    with lock:<br/>        print(f'&gt;process {identifier} got the lock, sleeping for {value:.3f}')<br/>        time.sleep(value)</span></pre><p id="4b3f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们可以创建一个<code class="fe ok ol om nl b">Lock </code>实例供流程共享。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="4037" class="np mf it nl b gy nq nr l ns nt">...<br/># create the shared lock<br/>lock = Lock()</span></pre><p id="e83f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们可以创建许多流程来执行我们的<strong class="lk jd"> task() </strong>函数，并竞争执行关键部分。</p><p id="723d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个进程将接收共享锁、一个0到9之间的整数ID和一个0到1之间的随机睡眠时间(秒)作为输入。</p><p id="d66c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如上一节对完整代码所做的那样，我们可以通过列表理解来实现这一点，创建一个由十个已配置的<code class="fe ok ol om nl b">Process</code>实例组成的列表。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="07d6" class="np mf it nl b gy nq nr l ns nt">...<br/># create a number of processes with different sleep times<br/>processes = [Process(target=task, args=(lock, i, random())) for i in range(10)]</span></pre><p id="767b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们可以开始所有的过程。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="0175" class="np mf it nl b gy nq nr l ns nt">...<br/># start the processes<br/>for process in processes:<br/>    process.start()</span></pre><p id="ed98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们可以等待所有新的子进程终止。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="acdc" class="np mf it nl b gy nq nr l ns nt">...<br/># wait for all processes to finish<br/>for process in processes:<br/>    process.join()</span></pre><p id="63bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面列出了使用锁的完整示例。</p><p id="8877" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">代码从十个被配置为执行我们的自定义函数的进程开始。</p><p id="3746" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后启动子进程，主进程阻塞，直到所有子进程完成。</p><p id="58f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个子进程试图获取<code class="fe ok ol om nl b">sleep()</code>函数中的<em class="nv">锁</em>。一次只有一个方法可以获取<em class="nv">锁</em>，一旦它们这样做了，它们就报告一条消息，包括它们的id和它们将休眠多长时间。然后，在释放锁之前，该进程会阻塞几分之一秒。</p><h2 id="30eb" class="np mf it bd mg oa ob dn mk oc od dp mo lr oe of mq lv og oh ms lz oi oj mu iz bi translated">3.长队</h2><p id="36c5" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">允许进程相互通信。例如，数据可以放在一个队列中，当它可用时由另一个处理器处理，这允许我们将一个任务分解成可以同时处理的更小的部分。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="90e8" class="np mf it nl b gy nq nr l ns nt">from multiprocessing import Queue<br/><br/>colors = ['red', 'green', 'blue', 'black']<br/>cnt = 1<br/># instantiating a queue object<br/>queue = Queue()<br/>print('pushing items to queue:')<br/>for color in colors:<br/>    print('item no: ', cnt, ' ', color)<br/>    queue.put(color)<br/>    cnt += 1<br/><br/>print('\npopping items from queue:')<br/>cnt = 0<br/>while not queue.empty():<br/>    print('item no: ', cnt, ' ', queue.get())<br/>    cnt += 1</span></pre><blockquote class="on oo op"><p id="36a4" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">将物品推入队列:<br/>1号物品红色<br/>2号物品绿色<br/>3号物品蓝色<br/>4号物品黑色</p><p id="a789" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">从队列中弹出项目:<br/>项目编号:0红色<br/>项目编号:1绿色<br/>项目编号:2蓝色<br/>项目编号:3黑色</p></blockquote><h2 id="943e" class="np mf it bd mg oa ob dn mk oc od dp mo lr oe of mq lv og oh ms lz oi oj mu iz bi translated">4.泳池</h2><p id="2f4b" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">池是用于并行执行任务的进程的集合。池有助于将一个巨大的任务分成多个处理器可以处理的小部分。</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="e61f" class="np mf it nl b gy nq nr l ns nt">from multiprocessing import Pool<br/><br/>import time<br/><br/>work = (["A", 5], ["B", 2], ["C", 1], ["D", 3])<br/><br/><br/>def work_log(work_data):<br/>    print(" Process %s waiting %s seconds" % (work_data[0], work_data[1]))<br/>    time.sleep(int(work_data[1]))<br/>    print(" Process %s Finished." % work_data[0])<br/><br/><br/>def pool_handler():<br/>    p = Pool(4)<br/>    p.map(work_log, work)<br/><br/><br/>if __name__ == '__main__':<br/>    pool_handler()</span></pre><p id="9c2b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><blockquote class="on oo op"><p id="832b" class="li lj nv lk b ll lm kd ln lo lp kg lq oq ls lt lu or lw lx ly os ma mb mc md im bi translated">流程A等待5秒<br/>流程B等待2秒<br/>流程C等待1秒<br/>流程D等待3秒<br/>流程C完成。<br/>流程B完成。<br/>流程D完成。<br/>流程一结束。</p></blockquote><p id="f30b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，我们现在可以设置并行执行的工作线程数量:</p><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="aaac" class="np mf it nl b gy nq nr l ns nt">def pool_handler():<br/>    p = Pool(4)<br/>    p.map(work_log, work)</span></pre><p id="5287" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将<code class="fe ok ol om nl b">Pool</code>设置为具有<code class="fe ok ol om nl b">nworkers=4</code>，并且列表具有4个元素，这意味着同时执行每个组件。因此，请注意，打印语句显示每次修整的顺序与设置为<code class="fe ok ol om nl b">sleep</code>的秒数相同。</p><h1 id="8d4e" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">关于如何开始多重处理的提示</h1><p id="313d" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如果您是Python多重处理的新手，这里有一些技巧可以帮助您入门:</p><ol class=""><li id="566e" class="ov ow it lk b ll lm lo lp lr ox lv oy lz oz md pa pb pc pd bi translated">熟悉Python流程管理的基础知识。<em class="nv">流程</em>模块的文档可以帮助您理解如何启动和控制流程。</li><li id="183c" class="ov ow it lk b ll pe lo pf lr pg lv ph lz pi md pa pb pc pd bi translated">确保你知道锁的基本知识。<em class="nv">锁</em>模块提供了保护进程间共享资源所需的所有工具。</li><li id="ea66" class="ov ow it lk b ll pe lo pf lr pg lv ph lz pi md pa pb pc pd bi translated">使用队列在进程间通信使得在作业间来回传递数据变得容易。</li><li id="637b" class="ov ow it lk b ll pe lo pf lr pg lv ph lz pi md pa pb pc pd bi translated">实验！学习如何使用多重处理的最好方法是尝试不同的技术，看看什么最适合您的需要。</li></ol><h1 id="bf67" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">使用多重处理的最佳实践技巧</h1><p id="0846" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">当在项目中使用多重处理时，请记住一些最佳实践。以下是一些帮助您充分利用多重处理的技巧:</p><p id="e93b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">1.使用CPU密集型任务:并非所有作业都适合并行运行。然而，CPU密集型作业非常适合多处理，因为它们可以分成更小的部分并同时运行。</p><p id="725a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">2.限制共享资源的使用:如前所述，两个进程试图访问同一个资源会导致数据损坏或不一致。限制进程间共享资源的使用以避免任何潜在的冲突是很重要的。</p><p id="72ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">3.小心使用锁:锁对于保护进程间的共享资源至关重要，但是小心使用它们也很重要。如果您需要更加小心的话，您可以很容易地创建死锁或其他同步问题。</p><p id="cafa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">4.使用队列进行通信:队列允许进程相互通信，这对于需要在多个任务之间进行协调的任务很有帮助。</p><p id="1bbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">5.彻底测试您的代码:在将它部署到生产环境之前进行测试总是一个好主意。多重处理会引入新的和不可预见的问题，所以在它们给应用程序带来问题之前捕捉任何潜在的问题是非常重要的。</p><h1 id="9794" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="ca51" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Python中的多重处理是加速代码的强大工具。<strong class="lk jd">通过在多个处理器之间分配任务，您通常可以比在单个处理器上运行相同的任务更快地获得结果。</strong>在本文中，我们看了四个重要的Python多处理组件。我们还讨论了有效使用多处理的一些最佳实践。</p><p id="f56f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将来，我们将探索Python中多处理的用例，例如消息传递和共享内存概念。因此，我们将返回到<code class="fe ok ol om nl b">Queue</code>并引入其他数据结构，使其能够相对快速地实现。</p><p id="5c60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请对未来的博客提出建议，无论是多重处理还是另一个主题。</p><h1 id="4705" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">补充材料</h1><p id="ef1e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在过去的关于智能指针的三部分系列文章中介绍了内存管理:</p><div class="pj pk gp gr pl pm"><a href="https://betterprogramming.pub/smart-pointers-in-cpp-708486276526" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">理解C++中的智能指针</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">更聪明地工作，而不是更努力</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">better编程. pub</p></div></div><div class="pv l"><div class="pw l px py pz pv qa lb pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://betterprogramming.pub/understanding-smart-pointers-in-cpp-6c3854593503" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">现代C++:智能指针的近距离观察</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">《理解智能指针》续集betterprogramming.pub</h3></div></div><div class="pv l"><div class="qb l px py pz pv qa lb pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://betterprogramming.pub/understanding-smart-pointer-iii-909512a5eb05" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">通过直观的视觉效果解释C++智能指针</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">我的C++指针系列的第3部分</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">better编程. pub</p></div></div><div class="pv l"><div class="qc l px py pz pv qa lb pm"/></div></div></a></div><h1 id="7f49" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">接触</h1><pre class="ks kt ku kv gt nk nl nm nn aw no bi"><span id="1afa" class="np mf it nl b gy nq nr l ns nt"><strong class="nl jd">Want to Connect? </strong>Follow Dr. Robinson on <a class="ae nu" href="https://www.linkedin.com/in/jrobby/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>, <a class="ae nu" href="https://twitter.com/jrobvision" rel="noopener ugc nofollow" target="_blank">Twitter</a>, <a class="ae nu" href="https://www.facebook.com/joe.robinson.39750" rel="noopener ugc nofollow" target="_blank">Facebook</a>, and <a class="ae nu" href="https://www.instagram.com/doctor__jjj/" rel="noopener ugc nofollow" target="_blank">Instagram</a>. Visit my homepage for papers, blogs, email signups, and more!</span></pre><div class="pj pk gp gr pl pm"><a href="https://www.jrobs-vision.com/" rel="noopener  ugc nofollow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">人工智能研究工程师和企业家|约瑟夫·p·罗宾逊</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">研究员和企业家问候！作为一名研究人员，罗宾逊博士提出并采用先进的人工智能来理解…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">www.jrobs-vision.com。</p></div></div><div class="pv l"><div class="qd l px py pz pv qa lb pm"/></div></div></a></div></div></div>    
</body>
</html>