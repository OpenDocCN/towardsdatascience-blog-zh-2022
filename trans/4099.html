<html>
<head>
<title>How to Create a Grid Layout in Streamlit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Streamlit中创建网格布局</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-create-a-grid-layout-in-streamlit-7aff16b94508#2022-09-12">https://towardsdatascience.com/how-to-create-a-grid-layout-in-streamlit-7aff16b94508#2022-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3b60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们介绍了一种在Streamlit中使用世界人口数据演示应用程序以编程方式创建网格布局的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/4bf3c9f4dc57af8c85e49a1add0c47e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*lnyyEPgHqZaYEU6M.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><em class="ku"> Piet Mondrian，公共领域，通过维基共享媒体</em></p></figure><p id="ea1c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Streamlit的优秀人员为我们提供了许多显示数据和图表的方法，也为设计数据科学应用程序提供了几种方法。</p><p id="5e16" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是没有原生网格布局。</p><p id="4f2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">幸运的是，这很容易解决，我们将看到如何使用标准的Streamlit布局函数构建网格，然后创建一个简单的函数来创建任意维度的网格。</p><p id="08da" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">网格让我们以行和列的形式整齐一致地布置文本、数据和图表。例如，我用2022年联合国<em class="lr">世界人口展望</em>报告中的数据创建了一个Streamlit应用程序。其中，这份报告着眼于未来几十年世界人口将如何增长。这款应用基于《我们的世界》杂志的一篇文章(见注1)，外观如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/970b524e0333261161101fc981531ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*R6-M8yqoF1K5siZ-.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="4522" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以在这里运行<a class="ae lt" href="https://alanjones2-alan-jones-article-code-stgridappgridapp-s6w2lw.streamlit.app/" rel="noopener ugc nofollow" target="_blank">的应用</a>。</p><h1 id="a659" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">构建网格布局</h1><p id="ef1e" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">稍后我们将查看该应用程序，但首先，我们将了解如何在Streamlit中构建网格布局。</p><p id="f777" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当然，Streamlit有内置的标准列。但是排呢？</p><p id="7dc6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实际上，是的，那些也是。如果我们将一堆Streamlit容器一个接一个地堆叠起来，我们就有了行。如果我们把这些容器分成相同数量的列，我们就有了一个网格。</p><p id="b1d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">看一下这段代码:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="18e0" class="mw lv it ms b gy mx my l mz na"><em class="lr"># a 2x2 grid the long way</em></span><span id="bca9" class="mw lv it ms b gy nb my l mz na">with st.container():<br/>    col1, col2 = st.columns(2)<br/>    with col1:<br/>        st.write('Caption for first chart')<br/>    with col2:<br/>        st.line_chart((0,1), height=100)</span><span id="8ad0" class="mw lv it ms b gy nb my l mz na">with st.container():<br/>    col1, col2 = st.columns(2)<br/>    with col1:<br/>        st.write('Caption for second chart')<br/>    with col2:<br/>        st.line_chart((1,0), height=100)</span></pre><p id="09ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">清单1 </em></p><p id="4d94" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它通过堆叠两个容器并将每个容器分成两列来创建一个2 x 2的网格。每一行在右栏中有一个图表，在左栏中有一个标题。代码很容易理解并且运行良好。结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nc"><img src="../Images/09ecff104c33bf517809a2a9ea07a0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WMM8l1PoFsqo6Ncf.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="d84e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于这个简单的应用程序来说，这样做很好，但是如果我们要创建一个10 x 10的网格，代码可能会非常麻烦。</p><p id="5760" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建一个可以作为二维数组访问的网格不是更容易吗？因此，我们可以编写类似下面这样的代码，而不是我们上面看到的显式代码:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="ebb0" class="mw lv it ms b gy mx my l mz na">mygrid[0][0].write('Caption for first chart')<br/>mygrid[0][1].line_chart((1,0), height=100)<br/>mygrid[1][0].write('Caption for second chart')<br/>mygrid[1][1].line_chart((0,1), height=100)</span></pre><p id="d6b6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">清单2 </em></p><p id="5189" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我想你可能会同意，这是一种更简洁的方式来实现同样的事情，对于一个更大的网格将更容易管理。</p><p id="1e44" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，下一步可能是这样的:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="4aee" class="mw lv it ms b gy mx my l mz na"><em class="lr"># 2x2 grid using an array</em></span><span id="795d" class="mw lv it ms b gy nb my l mz na">mygrid = [[],[]]</span><span id="74ae" class="mw lv it ms b gy nb my l mz na">with st.container():<br/>    mygrid[0] = st.columns(2)<br/>with st.container():<br/>    mygrid[1] = st.columns(2)</span></pre><p id="3ccd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">清单3 </em></p><p id="e065" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里我们创建一个空的二维数组，然后在每个数组中，我们使用一个容器，并为每个数组元素分配两列。这给了我们一个二维数组，这使我们能够完全按照清单2 中的方式编写代码。</p><p id="cb6c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，虽然这样做很好，但是将其扩展到更大的网格会导致更麻烦的代码。</p><h1 id="8336" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">通用解决方案</h1><p id="6651" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">那么，我们写一个函数来创建一个任意维度的二维数组怎么样，2 x 2，3 x 2，10 x 10——随便什么。</p><p id="1ca1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="2637" class="mw lv it ms b gy mx my l mz na"><em class="lr"># make any grid with a function</em></span><span id="8487" class="mw lv it ms b gy nb my l mz na">def make_grid(cols,rows):<br/>    grid = [0]*cols<br/>    for i in range(cols):<br/>        with st.container():<br/>            grid[i] = st.columns(rows)<br/>    return grid</span></pre><p id="d0ee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">清单4 </em></p><p id="6602" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">清单4 中的函数将行数和列数作为参数。接下来，它创建一个一维数组，该数组是列的大小。(列表用零初始化——一个将被覆盖的任意值。)</p><p id="55bd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，对于该数组的每个元素，我们创建一个Streamlit容器，并在该容器中创建所需数量的行(一个行列表)并将其分配给一维数组的每个元素，从而创建一个由函数返回的行和列组成的二维数组。</p><p id="9e01" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们现在可以编写如下所示的代码:</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="ac1a" class="mw lv it ms b gy mx my l mz na">mygrid = make_grid(5,5)</span><span id="057d" class="mw lv it ms b gy nb my l mz na">mygrid[0][0].write('00')<br/>mygrid[1][1].write('11')<br/>mygrid[2][2].write('22')<br/>mygrid[3][3].write('33')<br/>mygrid[4][4].write('44')</span></pre><p id="90f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">清单5 </em></p><p id="dec4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">会产生这样的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi nh"><img src="../Images/b8a1b34441b751fb98d368adc9af65a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MWLLpI8gXTnUUgKD.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="b345" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当然，我们可以对这些网格元素使用任何适当的Streamlit函数，因此在清单5 中的代码之后执行它</p><pre class="kj kk kl km gt mr ms mt mu aw mv bi"><span id="89ae" class="mw lv it ms b gy mx my l mz na">mygrid[2][2].line_chart((0,1), height=100)</span></pre><p id="f9bf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">清单6 </em></p><p id="4b50" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">会给你这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nd ne di nf bf ng"><div class="gh gi ni"><img src="../Images/daa7b02ce944f1f64f054c9ff4ef8e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6eLXiV9Ml3xgJov5.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="9f4e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这里我们有一个创建任意大小和形状的网格布局的通用方法。让我们看看我是如何在世界人口应用程序中实际使用它的。</p><h1 id="19ec" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">示例应用程序</h1><p id="931b" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">该应用程序显示了联合国《2022年世界人口展望》中的三个关键发现。它在数据中使用了我们世界中的两个数据文件，文本基于相同的来源(参见注释1)。</p><p id="49d9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个调查结果有三行，每行包含三列:第一列是标题，第二列是简要描述，最后一列是图表。使用上述函数构建网格，使用_ py plot _ from<em class="lr">matplotlib</em>从数据文件构建图表。使用<code class="fe nj nk nl ms b">st.write()</code>或<code class="fe nj nk nl ms b">st.markdown()</code>在适当的栏中显示文本。如果你遵循了上面的代码，你会发现代码很容易理解(代码的<em class="lr">要点</em>包含在最后)。</p><p id="89eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">关于这个应用程序需要注意的一点是，它对各列的权重不同，因此标题列比其他两列窄一点。我们通过向<code class="fe nj nk nl ms b">make_grid()</code>传递一个元组作为它的<code class="fe nj nk nl ms b">cols</code>值来做到这一点。这被传递给产生我们想要的效果的<code class="fe nj nk nl ms b">st.columns()</code>函数。</p><p id="bd3f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第一个发现是，世界人口增长率现在低于1%，不到20世纪60年代的一半。</p><p id="d93a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这一结果反映在第二个发现中，即尽管世界人口继续增长，但将在2086年达到104亿的峰值。</p><p id="890e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第三个发现是，虽然中国长期以来一直是地球上人口最多的国家——目前有14亿人——但自20世纪70年代和80年代以来，其增长率一直在下降。因此，印度的人口很可能在2023年超过中国，因为尽管其人口增长也在下降，但速度比中国慢。</p><h1 id="012a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="57d4" class="pw-post-body-paragraph kv kw it kx b ky mm ju la lb mn jx ld le mo lg lh li mp lk ll lm mq lo lp lq im bi translated">也许Streamlit将来会增加网格布局。但在此之前，我希望你会发现这是有用的。</p><p id="54e4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你可以在我的<a class="ae lt" href="https://alanjones2.github.io" rel="noopener ugc nofollow" target="_blank"> Github网页</a>上找到这里使用的所有代码和应用程序的完整列表，在文章的最后还有应用程序代码的要点。</p><p id="8850" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢阅读。</p><h1 id="145e" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">笔记</h1><ol class=""><li id="12cf" class="nm nn it kx b ky mm lb mn le no li np lm nq lq nr ns nt nu bi translated">数据和编辑文本由<a class="ae lt" href="https://ourworldindata.org/world-population-update-2022" rel="noopener ugc nofollow" target="_blank">提供，数据中的我们的世界</a>，根据知识共享署名4.0国际(<a class="ae lt" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank"> CC BY 4 </a>)转载</li></ol><h1 id="d524" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">示例应用程序清单</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div></div>    
</body>
</html>