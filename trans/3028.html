<html>
<head>
<title>Understand Context Managers in Python and Learn to Use Them in Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Python中的上下文管理器，并学习在单元测试中使用它们</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-context-managers-in-python-and-learn-to-use-them-in-unit-tests-66cff907ce8e#2022-07-03">https://towardsdatascience.com/understand-context-managers-in-python-and-learn-to-use-them-in-unit-tests-66cff907ce8e#2022-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f682" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用上下文管理器使你的代码更加健壮，更加Pythonic化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5a84e2361c2420b4c7d5ff0022e380ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RRAlqmRvPgAczttw.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/photos/poster-wall-mockup-interior-frame-2899095/" rel="noopener ugc nofollow" target="_blank"> BUMIPUTRA </a>在Pixabay拍摄</p></figure><p id="e016" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经使用了关键字<code class="fe lv lw lx ly b">with</code>和函数<code class="fe lv lw lx ly b">open</code>来创建一个上下文，它将在我们读/写完之后关闭文件。然而，Python中的上下文管理器并不局限于管理外部资源，如文件描述符、数据库连接、线程锁等，它们可以用于提供所有类型的上下文，这些上下文需要在执行主代码块之前和之后进行一些设置和拆卸操作。在本帖中，我们将通过简单的代码片段解释所有的技术机制，来揭开Python中的上下文管理器的神秘面纱。我们还将介绍如何在大量使用上下文管理器的Python单元测试中使用模拟/补丁。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="c2ab" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">将上下文管理器与try/finally语句进行比较</h2><p id="d314" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当用于管理外部资源时，<code class="fe lv lw lx ly b">with</code>上下文管理器可以被看作是<code class="fe lv lw lx ly b">try/finally</code>语句的语法糖。无论主代码成功与否，两者都将在最后关闭外部资源。以下使用<code class="fe lv lw lx ly b">with</code>上下文管理器和<code class="fe lv lw lx ly b">try/finally</code>语句的代码片段是等效的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，有了上下文管理器，代码可以更加简洁。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="3947" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">创建自定义上下文管理器</h2><p id="59d7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在让我们创建一个定制的上下文管理器，以便理解场景背后的技术机制。</p><p id="39fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创建上下文管理器，我们可以创建一个实现<code class="fe lv lw lx ly b">__enter__()</code>和<code class="fe lv lw lx ly b">__exit__()</code>魔法方法的类。<code class="fe lv lw lx ly b">__enter__()</code>包括上下文的设置代码，将在创建上下文时执行。它可以返回一个值，该值将被赋给<code class="fe lv lw lx ly b">with … as &lt;var&gt;</code>语句中的变量。另一方面，<code class="fe lv lw lx ly b">__exit__()</code>包括当上下文退出时将被执行的拆卸代码，不管主代码块是否引发异常。如果主代码块中出现异常，异常类型、异常值和回溯将分别传递给<code class="fe lv lw lx ly b">exc_type</code>、<code class="fe lv lw lx ly b">exc_value</code>和<code class="fe lv lw lx ly b">exc_tb</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，定制上下文管理器应该以与内置<code class="fe lv lw lx ly b">open</code>函数相同的方式工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="122d" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">使用生成器函数创建自定义上下文管理器</h2><p id="e79c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">上面我们使用经典的基于类的协议创建了一个定制的上下文管理器，它实现了<code class="fe lv lw lx ly b">__enter__()</code>和<code class="fe lv lw lx ly b">__exit__()</code>方法。类似于<a class="ae ky" rel="noopener" target="_blank" href="/demystify-iterators-and-generators-in-python-f21878c9897">迭代器</a>，我们可以使用生成器函数以更简洁的方式创建一个上下文管理器。为此，我们只需要用<code class="fe lv lw lx ly b">contextlib</code>库中的<code class="fe lv lw lx ly b"><a class="ae ky" href="http://twitter.com/contextmanager" rel="noopener ugc nofollow" target="_blank">contextmanager</a></code> <a class="ae ky" href="https://lynn-kwong.medium.com/understand-and-master-the-decorator-in-python-481aa444933f" rel="noopener">装饰器</a>来装饰生成器函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将生成器函数用作上下文管理器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e0ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">yield</code>语句前后的代码分别对应于<code class="fe lv lw lx ly b">__enter__()</code>和<code class="fe lv lw lx ly b">__exit__()</code>方法。产生的值(如果有的话)被绑定到<code class="fe lv lw lx ly b">with … as &lt;var&gt;</code>语句中的变量。注意，如果什么都没有产生，那么<code class="fe lv lw lx ly b">yield</code>语句也应该存在，否则它就不是一个生成器函数。这种情况很快就会有一个例子。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="2f9a" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">用上下文管理器模拟一个函数</h2><p id="a408" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有了上下文管理器，我们可以在上下文中改变函数的行为，并在它退出上下文时重置它。这实际上是单元测试中修补工作的机制。让我们用上下文管理器模拟一下<code class="fe lv lw lx ly b">datetime.now()</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="6f21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主题演讲:</p><ul class=""><li id="38d5" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">我们必须将<code class="fe lv lw lx ly b">datetime.now</code>函数对象赋给一个新变量，否则，它不能被赋一个新值来改变它在上下文管理器中的行为。稍后你会看到我们可以使用<code class="fe lv lw lx ly b">unittest.mock</code>中特殊的<strong class="lb iu"> <em class="np">补丁</em> </strong>函数非常方便地模仿任何函数/方法，而不需要创建新的中间变量。</li><li id="fd4c" class="ng nh it lb b lc nq lf nr li ns lm nt lq nu lu nl nm nn no bi translated">这里创建了一个基于生成器的上下文管理器，您也可以创建一个基于类的上下文管理器，这应该非常简单。只需将<code class="fe lv lw lx ly b">yield</code>语句前后的代码分别复制到<code class="fe lv lw lx ly b">__enter__()</code>和<code class="fe lv lw lx ly b">__exit__()</code>方法中。</li><li id="b90b" class="ng nh it lb b lc nq lf nr li ns lm nt lq nu lu nl nm nn no bi translated">在生成器函数中，我们必须使用<code class="fe lv lw lx ly b">global</code>关键字来声明<code class="fe lv lw lx ly b">now</code>是一个全局变量，否则就无法在那里访问。它被保存到一个新变量<code class="fe lv lw lx ly b">saved_now</code>中，以便以后可以重置。</li><li id="ca97" class="ng nh it lb b lc nq lf nr li ns lm nt lq nu lu nl nm nn no bi translated">然后给<code class="fe lv lw lx ly b">now</code>变量分配一个新的lambda函数，该函数总是返回同一个<code class="fe lv lw lx ly b">datetime</code>对象。这样，<code class="fe lv lw lx ly b">now()</code>函数的行为在上下文中被改变。</li><li id="5e33" class="ng nh it lb b lc nq lf nr li ns lm nt lq nu lu nl nm nn no bi translated">在这个上下文管理器中，什么都没有产生，但是我们仍然需要显式地产生，以使它成为一个有效的生成器函数。</li><li id="ccc1" class="ng nh it lb b lc nq lf nr li ns lm nt lq nu lu nl nm nn no bi translated">我们已经知道，<code class="fe lv lw lx ly b">yield</code>语句后的代码是拆机部分。我们应该把<code class="fe lv lw lx ly b">now()</code>重置回原来的<code class="fe lv lw lx ly b">datetime.now()</code>。</li></ul><p id="072b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用这个上下文管理器来检查上下文内外的<code class="fe lv lw lx ly b">now()</code>函数的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="00f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到,<code class="fe lv lw lx ly b">now()</code>函数的行为在上下文中被模仿，当它退出上下文时又被重置回正常状态。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="747a" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">在单元测试中模拟datetime.now()</h2><p id="4bb5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">大部分功能都可以直接嘲讽。但是，我们不能直接嘲讽<code class="fe lv lw lx ly b">datetime.now()</code>，否则，我们会看到下面的<code class="fe lv lw lx ly b">TypeError</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="5743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要模拟<code class="fe lv lw lx ly b">datetime</code>模块。请务必小心下面的代码，这里很容易出错:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="332f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主题演讲:</p><ul class=""><li id="ba09" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">您需要安装<code class="fe lv lw lx ly b">pytest</code>模块来运行单元测试:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="6f28" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">由于<code class="fe lv lw lx ly b">datetime.now()</code>函数不能直接打补丁，我们需要打<code class="fe lv lw lx ly b">datetime</code>模块的补丁。注意，我们需要修补当前测试文件中导入的<code class="fe lv lw lx ly b">datetime</code>模块，而不是内置<code class="fe lv lw lx ly b">datetime</code>库中的模块。如果将<code class="fe lv lw lx ly b">test_mock_now.datetime</code>改为<code class="fe lv lw lx ly b">datetime.datetime</code>，测试将失败。这是因为，随着这个改变，被嘲笑的是<code class="fe lv lw lx ly b">datetime.datetime</code>，而不是当前测试文件中导入的<code class="fe lv lw lx ly b">datetime</code>模块。因此，第10行和第11行的断言会失败。一定要自己尝试一下，这样你才能更好地理解它。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="2712" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">单元测试中的Mock requests.get()</h2><p id="54ef" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">实际上，在Python单元测试中，模仿非常简单。只是来自<code class="fe lv lw lx ly b">datetime</code>库的<code class="fe lv lw lx ly b">datetime.now()</code>函数有点特殊。让我们修补单元测试中更常用的<code class="fe lv lw lx ly b">requests.get()</code>函数，以模拟一些HTTP请求的响应:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4cb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次<code class="fe lv lw lx ly b">requests.get()</code>函数可以直接打补丁，代码也简单很多。</p><p id="9f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟在单元测试中非常重要，它可以让你的测试代码独立于外部资源工作，让你专注于代码的逻辑和健壮性。几乎所有东西都可以在单元测试中被嘲笑。我们刚刚在本帖中介绍了函数的模拟。更多的例子将会在一篇更专门的单元测试文章中介绍。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="82e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们介绍了上下文管理器的基础知识以及用Python实现它们的不同方法。上下文管理器可以用基于类或基于生成器的协议来实现，后者更简洁。上下文管理器可以使您的代码更加健壮，因为资源肯定是关闭的。此外，上下文管理器可以用来改变上下文中某些函数的行为，这使得它们在单元测试中被广泛使用，因为它们可以让您的测试代码独立于外部资源工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="2166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="15eb" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/demystify-iterators-and-generators-in-python-f21878c9897">解开Python中迭代器和生成器的神秘面纱</a></li></ul></div></div>    
</body>
</html>