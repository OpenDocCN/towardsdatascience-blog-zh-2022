<html>
<head>
<title>How to Make Your Pandas Code Run Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让你的熊猫代码运行得更快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/two-pandas-tricks-i-wish-id-known-earlier-60af0a049735#2022-04-03">https://towardsdatascience.com/two-pandas-tricks-i-wish-id-known-earlier-60af0a049735#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3ce8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">两只熊猫的把戏我希望我能早点知道</h2></div><p id="05e6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们大多数数据科学家，在工作的某个时候都会用到熊猫图书馆。这篇文章将介绍两个技巧，让你的熊猫代码运行得更快。第一个是删除None值，第二个是从某一列中提取一组值。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/ad71066ebd692c3a4382fde1b53e7254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DVtD_JUgvYR2jOmq5R33g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae lr" href="https://unsplash.com/@stonewyq" rel="noopener ugc nofollow" target="_blank">斯通王</a>在<a class="ae lr" href="https://unsplash.com/s/photos/pandas" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。文本由作者添加。</p></figure><h1 id="4860" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">删除无值</strong></h1><p id="afe4" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">像生活中的大多数事情一样，我们的数据并不完美。通常，在进行某些计算之前，我们没有想要删除的值。无论是简单的平均值、直方图还是更复杂的计算，我们都希望没有这些。我们如何用熊猫来做呢？小菜一碟！我们可以简单地使用pd.dropna()方法。假设我们的数据帧名为df，我们希望删除“日期”列中的所有None值:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="df7e" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd</span><span id="5b3a" class="mu lt iq mq b gy mz mw l mx my">#load dataframe<br/>df = pd.read_pickle("my_dataframe.pkl")<br/>#remove rows with None in column "date"<br/>df.dropna(subset=['date'])</span></pre><p id="9ca5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将这种方法称为“dropna”。很长一段时间，这是我的首选方法...直到我遇到了这样一段代码:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="606a" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd</span><span id="19d0" class="mu lt iq mq b gy mz mw l mx my">#load dataframe<br/>df = pd.read_pickle("my_dataframe.pkl")<br/>#remove rows with None in column "date"<br/>df = df[df["date"].notna()]</span></pre><p id="64ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的第一反应是:“为什么不干脆用dropna()？”嗯，我查了一下，答案很简单。它可能并不漂亮，但它要快得多！<br/>我们来看下面的对比:</p><div class="lc ld le lf gt ab cb"><figure class="na lg nb nc nd ne nf paragraph-image"><img src="../Images/8dc9f105fc8ccf5cdbeb500bbd173165.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*lVNvWvAbmTjMvuoO0iI4rA.png"/></figure><figure class="na lg nb nc nd ne nf paragraph-image"><img src="../Images/fda0b3b99dc5afc26a840b4df1b5ddb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*RVxDiD8kgu4FCp1qyOU0HQ.png"/><p class="ln lo gj gh gi lp lq bd b be z dk ng di nh ni translated">notna和dropna方法的比较。作者创作的图表。</p></figure></div><p id="884d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在10到10⁷.之间的各种数据帧大小上测试了这两种方法左侧显示了作为数据帧长度函数的移除None值的时间。因为它随着行数的增加而显著增加，所以可以更清楚地看到这两种方法之间的时间比——因此是右图。它显示<notna time=""> / <dropna time=""/></notna></p><p id="ceb9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论很明确:nonta每次都赢。</strong></p><p id="b678" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">有什么隐情？</strong></p><p id="efb7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有。没有内存消耗费用。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/828c4a5f7448972249ded76f0f4cae5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Bl7wj4zcKK_CnMXj0AESlw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">notna和dropna RAM消耗的比较。作者创作的图表。</p></figure><h1 id="04e1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">从列中提取集合</strong></h1><p id="5d45" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有时我们需要从某一列中获取一组项目。我将比较Pandas的方法drop_duplicates和Numpy的方法unique。对于这一部分，我们将首先删除“日期”列中的None值。下面是这两种方法的代码:</p><p id="00db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">熊猫的掉落_复制品:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="e62c" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd</span><span id="0513" class="mu lt iq mq b gy mz mw l mx my">#load dataframe<br/>df = pd.read_pickle("my_dataframe.pkl")<br/>#extract "date" column and remove None values<br/>date = df[df["date"].notna()]</span><span id="472b" class="mu lt iq mq b gy mz mw l mx my">#get a set of column "date" values<br/>date_set = date.drop_duplicates(subset=['date'])['date'].values<br/></span></pre><p id="a391" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Numpy的独特之处:</p><pre class="lc ld le lf gt mp mq mr ms aw mt bi"><span id="fa5c" class="mu lt iq mq b gy mv mw l mx my">import pandas as pd<br/>import numpy as np</span><span id="e6b3" class="mu lt iq mq b gy mz mw l mx my">#load dataframe<br/>df = pd.read_pickle("my_dataframe.pkl")<br/>#extract "date" column and remove None values<br/>date = df[df["date"].notna()]['date'].values</span><span id="71ca" class="mu lt iq mq b gy mz mw l mx my">#get a set of column "date" values<br/>date_set = np.unique(date)</span></pre><p id="9bc0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我做了一个快速的比较，并再次想到我们有一个赢家——Numpy的独特。然而，在仔细测试了各种数据帧大小后，我意识到实际情况要复杂得多。</p><div class="lc ld le lf gt ab cb"><figure class="na lg nb nc nd ne nf paragraph-image"><img src="../Images/46770ece274546742ae87ffc104c95fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*o6fJe-IUSrS3n7yu1aYUFQ.png"/></figure><figure class="na lg nb nc nd ne nf paragraph-image"><img src="../Images/810696f1b072b4fdd92386c5997a5a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*0vAYua5xFH29V2XbP6uGrA.png"/><p class="ln lo gj gh gi lp lq bd b be z dk ng di nh ni translated">unique和drop_duplicates方法之间的比较。作者创作的图表。</p></figure></div><p id="c970" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于短数据帧，unique比drop_duplicates快。随着数据帧变得越来越大，drop_duplicates占了上风，其中相等点位于10⁶行附近的某处(其中时间比正好是1)。我试着看看列数的影响，得到了同样的结果。同样，对于所有大小，这两种方法的内存消耗是相似的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d1c64db4f6a5621d4157626ff7f4ebae.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*DZ00dIViR_pN1rbrRqBjvA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">unique和drop_duplicates RAM消耗的比较。作者创作的图表。</p></figure><h1 id="b996" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">结论</strong></h1><p id="a4c8" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当我们想要执行操作时，我们每个人都有自己的go-to方法。通常还有另一个实现值得一试，它可能会节省您的时间和资源。<br/> *使用notna删除None值。<br/> *对于提取集合，这取决于您的典型数据帧长度:在10⁵行下使用unique。在10⁶上空使用drop_duplicates。</p><p id="765b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于其他操作，检查替代方案，并让我知道你发现了什么！</p></div></div>    
</body>
</html>