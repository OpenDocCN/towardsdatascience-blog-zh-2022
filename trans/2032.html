<html>
<head>
<title>Predict Your Model’s Performance (Without Waiting for the Control Group)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测你的模型的性能(不需要等待控制组)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/predict-your-models-performance-without-waiting-for-the-control-group-3f5c9363a7da#2022-05-09">https://towardsdatascience.com/predict-your-models-performance-without-waiting-for-the-control-group-3f5c9363a7da#2022-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b734" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">NannyML的一种新算法允许在基础事实可用之前估计ML模型的性能。这是它的工作原理。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/315ede0544217b9bfc0e34822dfc03cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmBMifJ3Utm4qhQPfXGJpw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">[图片由作者提供]</p></figure><p id="73fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi lr translated">现在，你的预测模型已经建立并开始运行了。您已经开发、测试并最终部署了它。在向利益相关者展示时，您提到该模型在回溯测试数据上实现了75%的精确度和25%的召回率。他们会问:“<strong class="kx ir">但是在目前活跃的客户中表现如何呢？</strong>”。重点是:</p><blockquote class="ma"><p id="f254" class="mb mc iq bd md me mf mg mh mi mj lq dk translated"><strong class="ak">没人对你的模型在旧数据上的表现感兴趣。唯一重要的是该模型将如何处理新数据</strong>。</p></blockquote><p id="a217" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">但是，为了知道这一点，你必须等待观察目标变量，这可能需要很长时间。我们可以称之为“<strong class="kx ir">延迟表现的诅咒</strong>”:你需要现在就做出决定，但是你只能在未来获得完整的信息。</p><p id="5e7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我以为这个问题无解，直到最近看了NannyML (一个专注于部署后数据科学的开源库)的<a class="ae mp" href="https://docs.nannyml.com/latest/deep_dive/performance_estimation.html" rel="noopener ugc nofollow" target="_blank">这篇文章。他们提出了一种叫做“<strong class="kx ir">基于信心的性能评估</strong>”(CBPE)的算法。该方法允许<strong class="kx ir">通过使用预测概率作为唯一的输入(即，当基础事实不可用时)</strong>可靠地估计模型的性能。</a></p><p id="95b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我认为他们的想法非常聪明，所以在这篇文章中，我将描述他们的算法是如何工作的。</p><h1 id="7305" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">预测性能的需要</h1><p id="9259" class="pw-post-body-paragraph kv kw iq kx b ky ni jr la lb nj ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">假设你的公司要求你预测下个月内每个客户的流失概率。因此，你开发了一个机器学习管道，在对保留数据进行验证后，你就可以部署它了。</p><p id="87e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">管道的输出是这样一个表:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/437d551384f1bac20d01cb5041841fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2rYYgl04VlwmwQVQOLrIbA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ML管道的输出。[图片由作者提供]</p></figure><p id="cf49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常，您会将一小组(随机选择的)客户分开。我们的想法是让这个群体保持完整，这样一个月后你就会知道如果你对你的客户群什么都不做会发生什么。如同在临床试验中一样，这个组被称为“<strong class="kx ir">对照组</strong>”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/d67a0120c57f9479059d34762d21009a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFlbV9qCWYWcRBp5NmGtJA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">随机选择一个对照组。[图片由作者提供]</p></figure><p id="2dd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一个月后，你终于知道对照组的哪些客户翻炒了。因此，您可以计算控制组中模型的任何性能指标:ROC曲线下面积、平均精度、F1分数等等。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/11c61867b6591cd8241269cff1b026e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JJnlE4lBIVQvp2mpghcm_w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">延迟(观察到的)模型性能。[图片由作者提供]</p></figure><p id="212b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，你必须等待一个月。</p><p id="07cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，NannyML提出的算法允许你<strong class="kx ir">立即获得模型性能的可靠估计，而不必等待控制组</strong>。此外，这些预期指标是基于整个客户群(而不仅仅是控制组)计算的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/90ca660611054f3bfd81549af5181729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1aE5MJFpoL_KhZE4S93fA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">NannyML的算法允许在服务时获得预期的模型性能。[图片由作者提供]</p></figure><p id="0336" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有很多好处:</p><ul class=""><li id="7ca9" class="np nq iq kx b ky kz lb lc le nr li ns lm nt lq nu nv nw nx bi translated">立即做出更好的决策，允许进行<strong class="kx ir">假设分析</strong>(例如:如果我将概率阈值设置为50%，预期的精确度/召回率是多少？如果我把门槛设成80%呢？).</li><li id="4705" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">对你的模型有一个<strong class="kx ir">早期危险信号</strong>，这样你就可以在为时已晚之前修复它。例如，如果你的信用评分模型正在系统地失败，你甚至不需要等一年(并损失数百万)才意识到这一点。</li><li id="2a55" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">对你的模型在当前数据上的表现有一个现实的结果，因为<strong class="kx ir">有时等待控制组是不可行的</strong>，例如在长期预测中(例如房屋抵押贷款违约)或当获得标签很昂贵时。</li></ul><p id="528f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，一种方法并不排斥另一种:你可以估算出预期的模型性能，然后等待一个月，观察实际性能，最后进行比较。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/6dd241ff776da0804d0ed74d011ee139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d9SndvJG5E_LYUR2KVKxfA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预期模型性能与观察到的模型性能。[图片由作者提供]</p></figure><p id="7fb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们知道了为什么这是有用的，让我们试着理解算法背后的魔力。</p><h1 id="fedb" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">警告，小心处理！</h1><p id="5291" class="pw-post-body-paragraph kv kw iq kx b ky ni jr la lb nj ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">为了使算法产生可靠的结果，必须满足两个先决条件:</p><ul class=""><li id="c39b" class="np nq iq kx b ky kz lb lc le nr li ns lm nt lq nu nv nw nx bi translated"><strong class="kx ir">模型产生的概率必须正确校准。</strong></li><li id="ccac" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated"><strong class="kx ir">不能有概念漂移</strong>(但是，数据漂移不是问题)。</li></ul><p id="af0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">概率校准是一个直观的概念:如果你有一群预测概率为20%的人，那么其中大约20%实际上应该是正面的。这里就不赘述了，但是有校准你模型的技巧“<em class="od">事后”</em>。如果想了解更多，可以看我的文章<a class="ae mp" rel="noopener" target="_blank" href="/pythons-predict-proba-doesn-t-actually-predict-probabilities-and-how-to-fix-it-f582c21d63fc">《Python的predict_proba其实并不预测概率》</a>。</p><p id="b70e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于概念漂移，它是指你的特征和目标变量之间的关系随着时间的推移而变化。这是机器学习中可能发生的最可怕的事情之一。如果发生这种情况，你当然不能指望可靠地预测你的模型的性能。</p><p id="4916" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">说到这里，我们继续有趣的部分。</p><h1 id="3d13" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">从概率到混淆矩阵</h1><p id="feca" class="pw-post-body-paragraph kv kw iq kx b ky ni jr la lb nj ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">为了确定想法，让我们以5个人为例，他们有不同的预测概率:10%、25%、40%、70%和85%。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/e7ae1cc808fc04a9091f600a8f1544e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nx7Dk7tjDMly_g_Uaf3IaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">5个人的预测概率。[图片由作者提供]</p></figure><p id="ccbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，通常情况下，概率并不像现在这样被使用。事实上，最终，我们感兴趣的是找出哪些人会是积极的，哪些人会是消极的。要做到这一点，我们需要设置一个阈值:高于该阈值的观察结果将被归类为积极的，低于该阈值的将被归类为消极的。</p><p id="4097" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果我们将阈值设置为50%，前3个人将被分类为阴性(标签0)，而后2个人将被分类为阳性(标签1)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/8beb88a8c7318d1bcc99c922ddf92fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXcRF8A7RgkwUvTC3x61oA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从预测概率到预测标签，基于阈值。[图片由作者提供]</p></figure><p id="49ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们考虑最后一个人，他的预测概率是85%。由于该点高于阈值，该个体被分类为阳性。然而，由于我们的概率是经过校准的，我们可以合理地预期:</p><ul class=""><li id="8379" class="np nq iq kx b ky kz lb lc le nr li ns lm nt lq nu nv nw nx bi translated">85%的情况下，这个人实际上会变成阳性(<strong class="kx ir">“真阳性”</strong>)；</li><li id="6acd" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">15%的情况下，这个人会变成阴性(<strong class="kx ir">【假阳性】</strong>)。</li></ul><p id="00d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们看看第一个个体。其预测概率为10%，因此被归类为负面。根据同样的推理:</p><ul class=""><li id="9db0" class="np nq iq kx b ky kz lb lc le nr li ns lm nt lq nu nv nw nx bi translated">90%的时候，这个人实际上会变成阴性(<strong class="kx ir">“真阴性”</strong>)；</li><li id="569b" class="np nq iq kx b ky ny lb nz le oa li ob lm oc lq nu nv nw nx bi translated">10%的情况下，这个人会变成阳性(<strong class="kx ir">“假阴性”</strong>)。</li></ul><p id="af51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很容易从几何上形象化所有观测值的这些量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/11f963b8109a2c8d338c44e2cb3614c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kC_uGzGDVzwAnwx3-PR9mw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基于预测概率和阈值来估计混淆矩阵。[图片由作者提供]</p></figure><p id="91ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个彩色部分代表个体成为真/假阳性或真/假阴性的<strong class="kx ir">概率。</strong></p><p id="278d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，<strong class="kx ir">如果我们对每种颜色的所有片段的长度求和，我们就分别获得了真阳性、假阳性、假阴性和真阴性的预期数量</strong>。</p><p id="3f41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">同样，从图中可以清楚地看到<code class="fe og oh oi oj b">TP + FP + FN + TN = n</code>，其中<code class="fe og oh oi oj b">n</code>是个体的数量。注意，这个性质是“常规”混淆矩阵所共有的。</p><p id="55d0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一的区别是，在我们的例子中，TP、FP、FN和TN的值不是整数值。这是有意义的，因为它们是期望值。事实上，在这个例子中，我们得到的是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/80313d9122be4a06e7320ad6c5de6389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*Z5KKik4821ctjoqOe2VMYQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预期混淆矩阵。[图片由作者提供]</p></figure><p id="5ebd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，为了获得这个预期混淆矩阵，我们只需要知道(校准的)预测概率和阈值。到目前为止，我们看到的所有Python代码的对应代码是:</p><pre class="kg kh ki kj gt ol oj om on aw oo bi"><span id="7070" class="op mr iq oj b gy oq or l os ot">pred = proba &gt;= thres<br/>    <br/>tp = np.sum((pred == 1) * proba)<br/>fp = np.sum((pred == 1) * (1 - proba))<br/>fn = np.sum((pred == 0) * proba)<br/>tn = np.sum((pred == 0) * (1 - proba))</span></pre><p id="df93" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们知道了预期混淆矩阵，我们就可以计算许多性能指标，比如精确度、召回率、F1分数、平均精确度、ROC曲线下的面积等等。</p><h1 id="bd77" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">得到预期的ROC曲线</h1><p id="e041" class="pw-post-body-paragraph kv kw iq kx b ky ni jr la lb nj ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">例如，让我们关注ROC曲线下的区域。ROC曲线的两个成分是真阳性率和假阳性率。从图形上看，TPR和FPR是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/215bb21aafe7504b02c7e48f02852914.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YsRa-_2VoqdFRkfECz3olw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">真阳性率和假阳性率的图形解释。[图片由作者提供]</p></figure><p id="baee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，阈值的选择是任意的。因此，为了获得模型性能的全局概念，ROC曲线被定义为所有可能阈值的所有TPR/FPR的集合。在这种情况下，有5个不同的值，有6个可能的阈值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/19974b5ff3e9b90326051b2747b64d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1otPQI52-b_gUiJ21VJPIg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">不同阈值的假阳性率和真阳性率。[图片由作者提供]</p></figure><p id="0ffc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在这一点上，我们有6对假阳性/真阳性率:每个阈值一对。然后通过绘制所有对来获得ROC曲线，假阳性率在<em class="od"> x轴</em>上，真阳性率在<em class="od"> y轴</em>上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/8642b369b2a685264a042eb39995e4f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_BaCaL20y2dWnFBEDucFA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从6对FPR/TPR获得的ROC曲线。[图片由作者提供]</p></figure><p id="04fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，<code class="fe og oh oi oj b">roc_auc_score</code>就是这条曲线下的面积，这很容易计算:Scikit-learn还提供了一个函数，可以直接计算任何曲线下的面积。在我们的例子中，<em class="od"> x- </em>坐标由假阳性率给出，<em class="od"> y- </em>坐标由真阳性率给出，因此:</p><pre class="kg kh ki kj gt ol oj om on aw oo bi"><span id="280e" class="op mr iq oj b gy oq or l os ot">from sklearn.metrics import auc</span><span id="f521" class="op mr iq oj b gy ov or l os ot">fpr = [0.0, 0.06, 0.17, 0.39, 0.67, 1.0]<br/>tpr = [0.0, 0.37, 0.67, 0.85, 0.96, 1.0]</span><span id="599a" class="op mr iq oj b gy ov or l os ot">roc_auc = auc(x=fpr, y=tpr)</span></pre><p id="f53f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是0.81。这意味着我们可以对该数据集上模型的ROC下面积做的最佳估计是81%。</p><p id="afec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样。我们只是根据预测的概率计算了ROC曲线下的预期面积，而不知道事实真相！</p><h1 id="1d29" class="mq mr iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">总结</h1><p id="b8b7" class="pw-post-body-paragraph kv kw iq kx b ky ni jr la lb nj ju ld le nk lg lh li nl lk ll lm nm lo lp lq ij bi translated">在本文中，我们已经看到了<strong class="kx ir">当基础事实不可用</strong>时，如何可靠地预测机器学习模型的预期性能(例如ROC下的面积)。</p><p id="a69c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种算法被称为“<strong class="kx ir">基于信心的性能评估</strong>”(CBPE)，由NannyML (一个专注于部署后数据科学的开源库)在本文<a class="ae mp" href="https://docs.nannyml.com/latest/deep_dive/performance_estimation.html" rel="noopener ugc nofollow" target="_blank">中首次提出。他们刚刚开始开源，你可以在他们的Github页面上看看他们的代码和文档:</a><a class="ae mp" href="https://github.com/NannyML/nannyml" rel="noopener ugc nofollow" target="_blank">https://github.com/NannyML/nannyml</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/56186a9e504b40e91e7ed00c97f59a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3THXdGNEJdypBZhq.png"/></div></div></figure><p id="a4aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="od">感谢您的阅读！我希望你喜欢这篇文章。如果你愿意，</em> <a class="ae mp" href="https://www.linkedin.com/in/samuelemazzanti/" rel="noopener ugc nofollow" target="_blank"> <em class="od">在Linkedin上加我</em> </a> <em class="od">！</em></p></div></div>    
</body>
</html>