<html>
<head>
<title>Running Serverless Applications in the Cloud — A Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在云中运行无服务器应用程序—教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/running-serverless-applications-in-the-cloud-a-tutorial-2b5b38457d8d#2022-08-26">https://towardsdatascience.com/running-serverless-applications-in-the-cloud-a-tutorial-2b5b38457d8d#2022-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e50" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么没有服务器？又是怎么做到的？AWS ECS的实际应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6546c736f203cbb8f80b1ba61e0e4a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xAqLUiJauTosYjMy.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="55b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们将在AWS上设计和部署一个FastAPI应用程序。</p><p id="9424" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将使用无服务器计算服务和托管数据库服务来设计应用程序。这种微服务架构有助于构建一个解耦系统，从而提高健壮性。接下来，我们使用AWS CDK将我们的整个基础设施捆绑成代码。这样做的好处很多。简而言之，它使部署和基础设施更新更加容易。它允许在VCS(版本控制系统)如git中提交定义基础设施的整个代码。</p><p id="bd3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是什么是无服务器，我们为什么需要它？</p><h1 id="a4a6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">无服务器简介</h1><p id="858d" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">AWS提供了几个无服务器计算选项。有了无服务器计算，我们无需担心服务器的管理和配置。安装补丁、更新和安全修复等维护任务完全消失了。这释放了时间和资源。我们也不需要担心容量供应，因为如果负载增加，AWS会自动扩展实例。无服务器计算选项提供随用随付的定价模式。这意味着我们只为我们实际使用的计算时间付费。根据用例，这可以降低运行我们软件的相关成本。</p><h2 id="6841" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">EC2上的Docker和对ECS的需求</h2><p id="8d99" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在介绍这个架构之前，我们先看看如何使用简单的虚拟服务器(AWS EC2)在AWS中运行一个容器化的应用程序。</p><p id="0523" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">涉及的步骤有:</p><ol class=""><li id="0133" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt ni nj nk nl bi translated">构建Docker映像</li><li id="ed62" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">部署EC2实例</li><li id="f5f4" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">管理Docker应用程序和EC2实例</li><li id="b1d2" class="nd ne it la b lb nm le nn lh no ll np lp nq lt ni nj nk nl bi translated">为EC2实例付款</li></ol><p id="f586" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这似乎很简单。但是也有一些不利的方面。</p><p id="035d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要管理我们的EC2实例。所以随着时间的推移安装更新和补丁。其次，我们需要管理Docker应用程序。万一容器停止工作，或者FastAPI版本需要更新，我们需要手动更新容器。这可能会很麻烦，因为正在运行的容器需要停止。</p><p id="d144" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一点是规模。生产系统是由数百个容器组成的大规模系统。使用上述方法同时运行几个容器是不可行的。我们需要分别管理每个容器。例如，确保容器平稳运行(健康检查)，并且它们可以安全地相互通信。或者在不危及整个应用程序的情况下更新容器使用的图像。如果用户需求增加，我们如何处理增加容器数量的用例？类似地，对于如此多的容器，负载平衡变得至关重要，因为我们不想让选定的几个容器不堪重负，而让其他容器闲置。</p><p id="8676" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">AWS ECS可以帮助我们解决所有这些问题，甚至更多。</p><h2 id="1066" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">AWS ECS</h2><p id="e5d5" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><em class="nr">为了简单起见，我们只考虑Fargate上的AWS ECS，不考虑EC2。</em></p><p id="12eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">弹性集装箱服务。这是一个容器编排服务，允许我们运行和管理容器化的Docker应用程序。对于可能有数百个容器的大型工作流，管理它们既具有挑战性又非常耗时。这里有一张解释ECS的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/e7c480bc6e4bde9c107eefde71eb99d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQgloku7u24b3GnKFeZofw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Fargate、服务和任务说明AWS ECS。图片作者。</p></figure><p id="2027" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ECS由以下组件组成:</p><ul class=""><li id="6c53" class="nd ne it la b lb lc le lf lh nf ll ng lp nh lt nt nj nk nl bi translated">集群——这只是一个被称为容量提供者的Fargate实例的逻辑分组。任务在运行前被放入集群。</li><li id="bf1a" class="nd ne it la b lb nm le nn lh no ll np lp nq lt nt nj nk nl bi translated">AWS Fargate — Fargate与ECS集成，并“在幕后”提供无服务器计算服务。Fargate本质上运行我们的Docker容器，而我们不必担心管理服务器。</li><li id="4141" class="nd ne it la b lb nm le nn lh no ll np lp nq lt nt nj nk nl bi translated">服务—服务允许您指定希望运行多少任务，是否希望启用负载平衡等。一个集群中可以有多个服务。例如，您可以让一个服务处理所有生产流量(生产环境)，另一个服务处理测试/开发流量(测试环境)。上图中，您可以看到集群中运行着两个服务— <em class="nr">服务1 </em>和<em class="nr">服务2 </em>。任务在服务内部运行。</li><li id="7949" class="nd ne it la b lb nm le nn lh no ll np lp nq lt nt nj nk nl bi translated">任务定义——这是一个用JSON编写的模板文件。它就像一个蓝图，指定运行什么容器、内存和CPU规格、应该打开什么端口以及其他配置，如使用什么Docker映像。本质上，它定义了要运行的实际代码。</li><li id="e8ef" class="nd ne it la b lb nm le nn lh no ll np lp nq lt nt nj nk nl bi translated">任务—这是任务定义的实例。它可以是挂起、运行或停止。正在运行的任务意味着任务定义中指定的所有容器都正在运行，即您的应用程序正在运行。<br/>还可以运行几个任务来处理应用程序的大负载。在上图中，有两个<em class="nr">任务A </em>的实例在<em class="nr">服务1中运行。</em></li></ul><h1 id="9ae7" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">架构图</h1><p id="7d52" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">架构图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/7a8bae71513450c9a3f4599b358bd933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mlih-Jy2QvnVNtjxFElIqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AWS架构图。图片作者。</p></figure><p id="311e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们使用虚拟私有云(VPC)。这是我们专用的ip地址集合，与我们的AWS帐户相关联。一个因特网网关被连接到VPC，以便于与因特网的连接。</p><p id="dd19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">FastAPI应用程序将在公共子网内的ECS上运行。PostgreSQL数据库将在私有子网内的RDS(关系数据库服务)上运行。RDS只是AWS提供的一项托管数据库服务，意味着AWS为我们管理数据库。</p><p id="f4f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用户请求被路由到ECS，因为它位于公共子网内。在本教程中，这是通过简单的HTTP，端口80完成的。对于所有实际使用案例，这应该在HTTPS端口443上完成。RDS禁止任何公共访问。这是因为它存储了敏感的用户数据。但是，由于ECS和RDS在同一个VPC中，所以ECS可以与RDS通信来存储和检索数据。这是通过默认的PostgreSQL端口TCP: 5432完成的。</p><h1 id="e3c7" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">密码</h1><p id="06bb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu"> <em class="nr">完整的回购代码是</em> </strong> <a class="ae nv" href="https://github.com/CrimsonScythe/ecs-intro" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu"> <em class="nr">这里的</em> </strong> </a> <strong class="la iu"> <em class="nr">。</em> </strong></p><p id="87bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nr">这篇文章假设你的系统已经安装了AWS CLI和CDK。</em> <br/> <em class="nr">如果没有请查看此</em> <a class="ae nv" href="https://haseebkamal.com/deploying-a-static-site-with-aws-cdk/" rel="noopener ugc nofollow" target="_blank"> <em class="nr">帖子</em> </a> <em class="nr">获取教程。</em></p><p id="1173" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，现在我们终于可以进入正题，写一些实际的代码了👩🏾‍💻</p><p id="1094" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一站，CDK！</p><h2 id="33bc" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">CDK初始化</h2><p id="a883" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">创建一个名为<code class="fe nw nx ny nz b">ecs</code> <br/>的新项目目录，运行以下命令为CDK创建一些样板代码:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="7489" class="mr lv it nz b gy oe of l og oh">cdk init sample-app --language python</span></pre><p id="98cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果在Python中创建venv时出现错误，可以执行以下命令为Python创建一个新的虚拟环境:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="7309" class="mr lv it nz b gy oe of l og oh">py -m venv .venv</span></pre><p id="2290" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后使用以下命令激活它:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="4419" class="mr lv it nz b gy oe of l og oh">.\.venv\Scripts\activate</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/b228c114a31a5bfe575650d677847d33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*rxKahe6ydHfPe8gaSPtiRg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建和激活Python虚拟环境</p></figure><p id="8d4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">启用虚拟环境后，我们可以通过以下方式安装Python依赖项:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="35dd" class="mr lv it nz b gy oe of l og oh">pip3 install -r requirements.txt</span></pre><p id="54da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编辑<code class="fe nw nx ny nz b">app.py</code>并确保提供了地区和帐户。它应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="ccc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，打开<code class="fe nw nx ny nz b">ecs_stack.py</code>。这是我们定义要创建的架构和资源的地方。<br/>粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0efa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从定义一个<code class="fe nw nx ny nz b">vpc</code>开始。您可以将此视为与您的帐户相关联并可供使用的ip地址的集合。</p><p id="9b44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们定义两个安全组，一个用于数据库，另一个用于fargate。安全组的作用类似于有状态的防火墙，默认情况下，它们允许所有传出的网络流量并阻止所有传入的流量。我们明确允许通过TCP从fargate连接到我们的数据库服务器。</p><p id="e51d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们创造秘密。这些可以是任何东西，包括API密钥、数据库凭证或其他需要存储和访问的敏感数据。通过AWS secrets manager，可以轻松地存储、检索和循环使用，以获得最大的安全性。在这里，我们为数据库实例创建凭证。我们提供用户名为<code class="fe nw nx ny nz b">postgres</code>，让cdk自动为我们生成一个密码。这里的好处是我们不会暴露代码中的秘密，因为我们可以简单地传递<code class="fe nw nx ny nz b">templatedSecret</code>变量来引用敏感的密码。</p><p id="d1cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建一个新的数据库实例，将<code class="fe nw nx ny nz b">templatedSecret</code>作为凭证传入，并将之前创建的安全组传入。</p><p id="5db1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们创建一个新的fargate服务。默认情况下会创建一个应用程序负载平衡器，但其详细信息不在讨论范围之内。这里最重要的事情是我们提供了一个到docker映像的路径。我们将用户名和密码作为<code class="fe nw nx ny nz b">task_image_options</code> <code class="fe nw nx ny nz b">secrets</code>传递，并将数据库实例的端点作为<code class="fe nw nx ny nz b">environment</code>变量传递。这允许docker容器能够连接到数据库。注意我们没有以明文形式传递任何东西！甚至数据库实例端点也是在运行时自动生成的，所以我们事先并不知道，但我们只是用<code class="fe nw nx ny nz b">rdsInstance.db_instance_endpoint_address</code>将它传递给fargate。</p><p id="3b17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们添加了对<code class="fe nw nx ny nz b">rdsInstance</code>的依赖。这确保了数据库在fargate服务之前创建。否则，我们的FastAPI应用程序将无法连接。</p><p id="99b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了！大部分工作已经完成。<br/>接下来，我们需要为ECS创建一个FastAPI应用程序和一个docker文件。</p><h2 id="5d84" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">REST API与FastAPI</h2><p id="2b11" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">确保虚拟环境已激活，并逐一安装以下软件包:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="44f5" class="mr lv it nz b gy oe of l og oh">pip3 install psycopg2 <br/>pip3 install fastapi <br/>pip3 install uvicorn[standard] <br/>pip3 install sqlalchemy</span></pre><p id="869a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，在根目录下创建一个<code class="fe nw nx ny nz b">main.py</code>文件。<br/>为<code class="fe nw nx ny nz b">main.py</code>粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5dc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个简单的REST API，有两个端点。我们可以存储一个<code class="fe nw nx ny nz b">book</code>或者基于<code class="fe nw nx ny nz b">book_name</code>检索一个<code class="fe nw nx ny nz b">book</code>。在第30行，我们为插入和检索数据库记录所需的<code class="fe nw nx ny nz b">book</code>创建了一个数据库模型。</p><p id="6095" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意如何简单地引用<code class="fe nw nx ny nz b">username</code>、<code class="fe nw nx ny nz b">password</code>和<code class="fe nw nx ny nz b">endpoint</code>作为环境变量。这是可行的，因为我们在前面的CDK代码中明确地将它们作为秘密和环境变量传递。</p><p id="e4e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还需要为FastAPI创建一个Pydantic数据模型。这具有在向端点发出请求时提供输入数据的自动验证的优点。例如，当POST请求存储一本新书时，pydantic会自动验证是否提供了正确的<code class="fe nw nx ny nz b">book</code>字段。继续在名为<code class="fe nw nx ny nz b">schemas.py</code>的新文件中创建一个Pydantic模型。<br/>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="5b31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在开始有趣的部分！</p><h2 id="0bc2" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">Dockerfile文件</h2><p id="201e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">而在根目录下运行<code class="fe nw nx ny nz b">pip freeze &gt; requirements.txt</code>得到一个<code class="fe nw nx ny nz b">requirements.txt</code>。这是建立我们码头工人形象的需要:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f0def6b3859a5319548f2f9790446aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vq8-BAJXk5XtLdn_BN7uPQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pip冻结要求</p></figure><p id="c47d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在根目录下创建一个新的<code class="fe nw nx ny nz b">Dockerfile</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="d7c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们简单地提取Python:3.9的官方Docker映像，设置一个命名的工作目录，我们将在后面引用它。然后我们在<code class="fe nw nx ny nz b">requirements.txt</code>上运行一个pip安装，最后将所有代码从我们的主机复制到Docker容器中。容器运行时执行最后的<code class="fe nw nx ny nz b">CMD</code>命令。<br/>在这种情况下，它启动了我们的FastAPI应用程序。</p><p id="325d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您现在应该有一个如下所示的目录结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/89d9c740813c99f9febd572679691e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*HYCEANq4pkeCTyPF7P9lXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目目录结构</p></figure><p id="3b54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了😇为自己出色的工作给自己一点鼓励！<br/>现在最激动人心的时刻到来了！</p><h2 id="4ae8" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">部署🚀</h2><p id="46a0" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated"><strong class="la iu"> <em class="nr">注意:</em> </strong> <strong class="la iu"> <em class="nr">运行下面的命令将向您的AWS帐户支付费用。</em>T19】</strong></p><p id="84ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喝杯咖啡，然后跑步:</p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="6e6c" class="mr lv it nz b gy oe of l og oh">cdk deploy</span></pre><p id="7cf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将启动资源的创建并部署应用程序。</p><p id="c896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nr">请耐心等待。这一步可能需要几分钟。</em> </strong> <br/> <strong class="la iu"> <em class="nr">如果几分钟后控制台上看不到任何输出，点击</em> </strong> <code class="fe nw nx ny nz b">CTRL+C</code> <strong class="la iu"> <em class="nr">，然后点击</em> </strong> <code class="fe nw nx ny nz b">cdk destroy</code>。在这种情况下，您可以直接联系我/在下面评论，以获得故障排除帮助。 </p><h2 id="e0e2" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">瞧吧🎆</h2><p id="e992" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们需要获得<code class="fe nw nx ny nz b">ECS</code>任务的ip地址来与服务器交互。<br/>因为我们启动的fargate任务包含一个负载平衡器，所以我们使用负载平衡器的名称<code class="fe nw nx ny nz b">DNS</code>。这是AWS自动生成的。继续在AWS控制台上搜索<code class="fe nw nx ny nz b">EC2</code>。在左侧导航窗格中，找到并选择<code class="fe nw nx ny nz b">load balancers</code>。打开的页面应该会列出一个负载平衡器。从描述中复制<code class="fe nw nx ny nz b">DNS name</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/aa26227c262f19eb916a36a3c5b150d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-8M0MZ39bIefCUA5iN6Fdg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从负载平衡器获取DNS名称</p></figure><p id="b27b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">粘贴复制的URL并在浏览器上点击enter。您应该看到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/3e65b8f8af6b0815540ce0e57a5081d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijaf3I4hrtY9m51JER3OUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">到达端点以测试应用程序</p></figure><p id="e22f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以使用Postman或类似的命令，通过POST和GET调用API端点。</p><p id="e18e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nr">记得销毁堆栈，防止跑费。<br/>从终端执行以下命令，销毁所有创建的资源:</em> </strong></p><pre class="kj kk kl km gt oa nz ob oc aw od bi"><span id="70e9" class="mr lv it nz b gy oe of l og oh">cdk destroy</span></pre><p id="f77f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nr">请耐心等待，这可能需要几分钟。<br/>您也可以通过在AWS控制台中搜索</em> </strong> <code class="fe nw nx ny nz b"><strong class="la iu"><em class="nr">Cloudformation</em></strong></code> <strong class="la iu"> <em class="nr">来手动删除堆栈。</em>T51】</strong></p><p id="7cc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">销毁堆栈后，您可能需要检查任何RDS快照。在控制台中搜索RDS，并在左侧导航窗格中找到<code class="fe nw nx ny nz b">Snapshots</code>。如果您看到列出了任何快照，请将其全部删除。</p><h1 id="530b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="d5c7" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">在本文中，我们研究了如何在AWS ECS和RDS上部署FastAPI应用程序。</p><p id="a868" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们剖析并描述了ECS(一种无服务器计算服务)的时间和资源优势。我们还使用了RDS——一种托管数据库服务，AWS负责为我们管理服务器。同样，像ECS一样，我们获得了不需要管理服务器的好处。</p><p id="eaa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现自动化部署，我们使用了AWS IaC(基础设施即代码)产品CDK。通过CDK，我们可以将我们的架构定义为代码，轻松地将其提交给版本控制，并在未来进行更改等等。这也使得将来更改和更新基础设施变得更加容易。</p><p id="c4f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望你喜欢这篇相当长的帖子。</p><p id="cacd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nr">如果你喜欢这部作品，可以考虑关注并订阅</em> </strong> <a class="ae nv" href="https://medium.com/subscribe/@haseebkamal98" rel="noopener"> <strong class="la iu"> <em class="nr">这里</em> </strong> </a> <strong class="la iu"> <em class="nr">。</em> </strong></p></div><div class="ab cl op oq hx or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="im in io ip iq"><p id="a69b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nr">原载于2022年8月26日</em><a class="ae nv" href="https://haseebkamal.com/running-serverless-applications-in-the-cloud/" rel="noopener ugc nofollow" target="_blank"><em class="nr">https://haseebkamal.com</em></a><em class="nr">。</em></p></div></div>    
</body>
</html>