<html>
<head>
<title>How to Make the Most of Your Python Debugger in VSCode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 VSCode 中充分利用 Python 调试器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-most-of-your-python-debugger-in-vscode-9e05dfce533f#2022-02-14">https://towardsdatascience.com/how-to-make-most-of-your-python-debugger-in-vscode-9e05dfce533f#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1457" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 调试</h2><div class=""/><div class=""><h2 id="d03c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在处理大型项目时，观察变量、使用条件断点、调用堆栈、异常断点等</h2></div><p id="045f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">快速脉冲检查—还在使用</em> <code class="fe lo lp lq lr b"><em class="ln">print()</em></code> <em class="ln">语句调试您的代码吗？嘿，承认你知道也没什么丢人的。如果有效，就有效(特别是对于较小的脚本)！</em></p><p id="ed8c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">话虽如此，但在处理较大的项目时，这不是一个可持续的解决方案——涉及大量第三方包、实用程序文件夹、目录、子目录——很容易失去对代码流的跟踪。</p><p id="a846" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是学习 VS 代码必须为调试代码提供的所有细节背后的主要动机。在这里与你分享相同的！</p><h1 id="ebdd" class="ls lt it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated">VSCode 调试器的基础</h1><p id="deec" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">为了简洁起见，我将保持事情简单，并讨论足够的细节，让你开始。要了解更多信息，请随时查看他们的官方文档。</p><h2 id="c292" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">虚拟项目</h2><p id="923a" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">我们将进行一个虚拟项目。目前，它包含一个<code class="fe lo lp lq lr b">hello.py</code>脚本和一个包含 5 个音频文件的小型虚拟<code class="fe lo lp lq lr b">audio_data </code>数据集。你可以在 Github 的这里找到<a class="ae mp" href="https://github.com/V-Sher/medium_debugger" rel="noopener ugc nofollow" target="_blank">。</a></p><div class="nb nc gp gr nd ne"><a href="https://github.com/V-Sher/medium_debugger" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">GitHub - V-Sher/medium_debugger:如何充分利用 VSCode 调试器</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">github.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns nt ne"/></div></div></a></div><p id="989e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">作为健全性检查，运行脚本以查看终端中的输出。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi nu"><img src="../Images/949d998f48be91bab758b99e5fdab7d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP7ZTUsnhnBLwCZy3JHmpA.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">hello.py</p></figure><h2 id="c28c" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">启动配置</h2><p id="1549" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">让我们继续创建一个<code class="fe lo lp lq lr b">launch.json</code>文件。详细步骤请参考此处的文档<a class="ae mp" href="https://code.visualstudio.com/docs/editor/debugging#_launch-configurations" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi oj"><img src="../Images/db21e5b1f468f9d4d15a7bde6da9a4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOms0PN7vgSLr_d6JCUzjw.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">启动配置</p></figure><p id="85ed" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这将在您的项目中创建一个新的<code class="fe lo lp lq lr b">.vscode</code>文件夹，并将包含<code class="fe lo lp lq lr b">launch.json</code>文件，登记所有的调试设置细节。现在，我们将使用默认值。</p><h2 id="73f1" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">让我们开始调试</h2><p id="0484" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">要检查特定行的代码状态，我们必须向它添加一个断点。这些通常会在编辑器页边空白处显示为红色实心圆圈。例如，我在<code class="fe lo lp lq lr b">for</code>循环中添加了一个断点(见下图)。</p><blockquote class="ok ol om"><p id="a485" class="kr ks ln kt b ku kv kd kw kx ky kg kz on lb lc ld oo lf lg lh op lj lk ll lm im bi translated">在脚本的第 X 行添加一个断点将会执行所有代码，直到第 X 行，代码执行将会在第 X 行停止，以便您检查代码的状态。换句话说，直到您点击<a class="ae mp" href="https://code.visualstudio.com/docs/editor/debugging#_debug-actions" rel="noopener ugc nofollow" target="_blank">调试工具栏</a>中的继续(或任何其他)按钮，X 行的代码才会被执行。</p></blockquote><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi oq"><img src="../Images/c36af25a4ccf7db16574773e4996d58c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8EJ4oOpQailu3O12uMLJA.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">在 hello.py 中的 for 循环处添加断点</p></figure><p id="ca68" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们可以通过点击绿色的 play 按钮开始调试脚本了(上图中的<code class="fe lo lp lq lr b">Python:Current File</code>)。这将弹出一个浮动的<a class="ae mp" href="https://code.visualstudio.com/docs/editor/debugging#_debug-actions" rel="noopener ugc nofollow" target="_blank">调试工具栏</a>(见下图)。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi or"><img src="../Images/573fae98a005298da230c8f0d2fde176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VssHkI5gt56uOt5Io037ug.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">浮动调试工具栏</p></figure><p id="c97e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln"> Pro 提示:在开始调试之前，确保在编辑器中打开了正确的文件，因为默认情况下，调试器将开始调试当前活动的文件。</em></p><p id="7277" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">开始调试过程后，您将看到以下内容:</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi os"><img src="../Images/6efbd6e2c2cb964565c64faa83fabb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4W0EtLf4CYiBoP7ut_J3Q.png"/></div></div></figure><p id="2532" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的几件事:</p><ul class=""><li id="40e7" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">在左边,<code class="fe lo lp lq lr b">Variables</code>选项卡填充了一些局部和全局变量。</li><li id="1e6a" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">在右边，脚本中添加第一个断点的那一行用黄色突出显示。</li><li id="8352" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">调试器<strong class="kt jd">尚未</strong>处理添加断点的那一行。(到目前为止的一切都已经处理完毕，这就是为什么你会看到<code class="fe lo lp lq lr b">os</code>模块是<code class="fe lo lp lq lr b">Variables</code>选项卡的一部分。)</li></ul><p id="0f2b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从现在开始，作为调试工具栏的一部分，您有几个调试选项:</p><ul class=""><li id="f4e2" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated"><strong class="kt jd">继续</strong>按钮将调试器从当前断点(或红色填充圆)带到下一个红色填充圆(因为在我们的例子中有一个<code class="fe lo lp lq lr b">for</code>循环，下一个断点将再次在<code class="fe lo lp lq lr b">for</code>循环)。</li><li id="abf0" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated"><strong class="kt jd"> Step Over </strong>按钮将调试器从代码的当前行带到下一行(在我们的例子中，是<code class="fe lo lp lq lr b">print</code>语句)。</li><li id="1de5" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated"><strong class="kt jd">单步执行</strong>按钮将带您进入当前断点中定义的任何功能(在我们的例子中是<code class="fe lo lp lq lr b">enumerate()</code>和<code class="fe lo lp lq lr b">listdir()</code>)。</li><li id="bf98" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated"><strong class="kt jd">重启</strong>和<strong class="kt jd">停止</strong>按钮非常直观。</li></ul><h2 id="1687" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated"><strong class="ak">继续按钮</strong></h2><p id="3dec" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">点击调试工具栏中的<strong class="kt jd">继续</strong>按钮将执行所有操作，直到下一个断点。由于我们在 for 循环中，下一个断点实际上将与当前断点相同。</p><p id="1c7f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们尝试这样做，看看我们会得到什么！</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ph"><img src="../Images/b03125c4d17c379a79626482ce937bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bvp3lNn_DnWtFaXNvOx6w.png"/></div></div></figure><p id="7988" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">注意:如果我们在 for 循环的</em> <code class="fe lo lp lq lr b"><em class="ln">print</em></code> <em class="ln">语句中添加了一个断点，调试器接下来将会在这里停止。)</em></p><p id="83d7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的几件事:</p><ul class=""><li id="f6c6" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">在左边，<code class="fe lo lp lq lr b">local</code>变量已经被更新，现在我们可以在<code class="fe lo lp lq lr b"><em class="ln">for</em></code> <em class="ln">循环中看到当前迭代的<code class="fe lo lp lq lr b">i</code>和<code class="fe lo lp lq lr b">file</code>的值。你甚至可以将鼠标悬停在脚本中的这些变量上来查看它们的值。</em></li><li id="3776" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">调试器现在突出显示脚本中的下一个断点<em class="ln">(与上面讨论的<code class="fe lo lp lq lr b">for</code>循环相同)。</em></li><li id="b1a8" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">在终端中，我们可以从<code class="fe lo lp lq lr b">print</code>语句中看到<em class="ln">部分</em>结果(来自迭代<code class="fe lo lp lq lr b">i=0</code>)。</li></ul><p id="7fd7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，我们可以继续点击<strong class="kt jd">继续</strong>选项，我们将看到<code class="fe lo lp lq lr b">local</code>变量<code class="fe lo lp lq lr b">i</code>和<code class="fe lo lp lq lr b">file</code>更新为各自的值，以及相关的<code class="fe lo lp lq lr b">print</code>语句。但是，如果<code class="fe lo lp lq lr b">for</code>循环本身相当复杂，我们想要深入研究并调试它，该怎么办呢？</p><p id="f91e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了进行试验，我们必须暂时停止调试器(使用 debug 工具栏中的 stop 按钮)，并对脚本本身进行一些更改。我们现在将使用<code class="fe lo lp lq lr b">os.path.abspath()</code>打印绝对路径，而不是打印文件名，我已经将它打包到一个名为<code class="fe lo lp lq lr b">get_abspath()</code>的(无用)函数中。此外，还将从文件名中提取发言者 id。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pi"><img src="../Images/dbcd7c46712c76651094a2bbed8eab41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UaJRMDOI3DDAEGI-JeS2hA.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">hello.py</p></figure><p id="649b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如前所述:</p><ul class=""><li id="e00b" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">我们在<code class="fe lo lp lq lr b">for</code>循环处设置断点。</li><li id="0dda" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">启动调试器，点击继续按钮<strong class="kt jd">一次</strong>以查看本地和全局变量更新到<code class="fe lo lp lq lr b">0</code>和<code class="fe lo lp lq lr b">PA_T_0000001.flac</code>以及终端中的单个<code class="fe lo lp lq lr b">print</code>语句。</li></ul><p id="064e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，假设我们想要检查<code class="fe lo lp lq lr b">for</code>循环内部发生了什么。一种方法是设置另一个断点，或者我们可以(而不是点击<strong class="kt jd">继续</strong>按钮)选择调试工具栏中的<strong class="kt jd">跳过</strong>按钮。</p><h2 id="4bc7" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">跳过按钮</h2><p id="ef5b" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">顾名思义，调试器已经单步执行到断点后的下一行(用黄色突出显示)。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pj"><img src="../Images/f0ee5eacaa61ccdf8cad3c6db8debdb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEEqzp2lPQiNpO0T3g-zvw.png"/></div></div></figure><p id="78c0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的几件事:</p><ul class=""><li id="454c" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">终端中不会有任何<code class="fe lo lp lq lr b">print</code>语句。<em class="ln">为什么？</em>因为该行代码还没有被调试器处理！您必须点击<strong class="kt jd">继续</strong>(或<strong class="kt jd">前进</strong> <strong class="kt jd">越过</strong>)按钮才能看到输出。</li><li id="9496" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">为了检查这个迭代的<code class="fe lo lp lq lr b">speaker_id</code>的值，我们可以再次点击<strong class="kt jd">跳过</strong>按钮，你会看到一个名为<code class="fe lo lp lq lr b">speaker_id</code>的新的局部变量被创建(调试器会跳到下一行并高亮显示它——见下图)。</li></ul><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pk"><img src="../Images/2499af198d1df55abe08441df97a9e07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bdrAzsJ95IQDqhOt0DaDw.png"/></div></div></figure><ul class=""><li id="5c02" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">我们仍然无法检查由<code class="fe lo lp lq lr b">get_abspath()</code>方法返回的内容。<em class="ln">解决方案</em>:设置断点！<br/> <em class="ln">注意:不要在</em> <code class="fe lo lp lq lr b"><em class="ln">def get_abspath()</em></code> <em class="ln">行设置断点，而是在函数定义内设置断点(见下图)。</em></li></ul><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pi"><img src="../Images/e9b2e038e81719411575f1976f00327d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iNJZJUQqkQl_7l6EGX8CA.png"/></div></div></figure><p id="74b1" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦设置了断点，您可以再次单击<strong class="kt jd">跳过</strong>按钮，调试器现在将停留在函数内的<code class="fe lo lp lq lr b">return</code>语句处(见下图)。我们可以看到<strong class="kt jd">局部</strong>变量现在已经更新为<em class="ln">，只有</em>反映了函数接收到的<code class="fe lo lp lq lr b">filename</code>参数。先前的变量如<code class="fe lo lp lq lr b">i</code>、<code class="fe lo lp lq lr b">file</code>和<code class="fe lo lp lq lr b">speaker_id</code>现在已经成为<strong class="kt jd">全局</strong>变量的一部分。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pl"><img src="../Images/7ea48f0c54e3b071a8ce08d95ac37e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTHPWYTINjJuKR7cY_1zUQ.png"/></div></div></figure><p id="c0f5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是检查函数定义是否接收正确参数的好方法。然而，我们仍然不知道<code class="fe lo lp lq lr b">get_abspath()</code>将返回的实际值。</p><p id="2762" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这是以前的我在代码中使用<code class="fe lo lp lq lr b">print</code>语句的地方！</p><p id="04b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">相反，我们可以利用调试器中的<strong class="kt jd">观察</strong>功能。输入要观察/获取其值的表达式，然后按 Enter 键(见下图)。瞧，你可以看到表达式的实际值！</p><blockquote class="ok ol om"><p id="5a3d" class="kr ks ln kt b ku kv kd kw kx ky kg kz on lb lc ld oo lf lg lh op lj lk ll lm im bi translated">Watch 功能通常用于观察变量值在整个代码中如何变化，因此得名 watch。例如，您可以使用它来跟踪<code class="fe lo lp lq lr b">64x64x3</code>输入图像如何通过卷积(和其他层)以在典型的卷积神经网络(CNN)中给出单个输出。</p></blockquote><div class="nv nw nx ny gt ab cb"><figure class="pm nz pn po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/6f627bc72fd6851d2a0e63a74bba27ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*jGvbeb060WZLMuUbVzZZ2Q.png"/></div></figure><figure class="pm nz ps po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/669039c8446cb6b04b8547d592a35b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*kVGXJ1vBurwHcW9riFKd0g.png"/></div></figure></div><p id="e72a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">从现在开始，您可以使用 Continue 和 Step Over 按钮以及 Watch 功能来完成代码导航/调试。</p><p id="e666" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦完成，就该对代码做更多的修改了。我们将重组代码并将<code class="fe lo lp lq lr b">get_abspath()</code>从<code class="fe lo lp lq lr b">hello.py</code>移到新的<code class="fe lo lp lq lr b">abs.py </code>脚本中，该脚本将驻留在新创建的<code class="fe lo lp lq lr b">utils</code>文件夹中。断点仍将保留在函数内的<code class="fe lo lp lq lr b">return</code>语句处。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pt"><img src="../Images/82129fa2196d422a154b3964a8799d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXJ97SVuJ4mD8RE-Nt239Q.png"/></div></div></figure><p id="b935" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">快速更新代码以在<code class="fe lo lp lq lr b">hello.py</code>内导入方法(如果您对来回导入模块感到紧张，请随意查看<a class="ae mp" rel="noopener" target="_blank" href="/understanding-python-imports-init-py-and-pythonpath-once-and-for-all-4c5249ab6355">我的 python 导入文章</a>)。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pi"><img src="../Images/50b2783da2066deedfb9e48f2cd63383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrYE1IcfCKJ0GJWWtv7Bcg.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">hello.py</p></figure><p id="c291" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在尝试以通常的方式调试<code class="fe lo lp lq lr b">hello.py</code>脚本，即使第二个断点(在<code class="fe lo lp lq lr b">abs.py</code>内)不在当前活动的脚本中(即<code class="fe lo lp lq lr b">hello.py</code>，调试器仍将工作。</p><h2 id="b3d7" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">步入/退出按钮</h2><p id="498a" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">一旦进入<code class="fe lo lp lq lr b">abs.py</code>的断点，出于好奇，你也会对检查标准库函数<code class="fe lo lp lq lr b">os.path.abspath()</code>的内部工作感兴趣。这意味着你必须<em class="ln">进入</em>这个功能，我们可以使用调试工具栏中的<strong class="kt jd">进入</strong>按钮。</p><p id="6605" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">理想情况下，这应该将调试器引入到<code class="fe lo lp lq lr b">os</code>模块内的函数定义中。然而，你会看到它不会发生？<br/> <em class="ln">为什么？</em> —默认情况下，调试仅限于用户编写的代码！</p><p id="ffb7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了能够调试非用户编写的代码，在<code class="fe lo lp lq lr b">launch.json</code>中描述的配置内将<code class="fe lo lp lq lr b">justMyCode</code>设置为<code class="fe lo lp lq lr b">False</code>。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pu"><img src="../Images/aa0f2ebeab6182950885bbff6f887940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DYDCmzASJGaJi9RDW3RJw.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">启动. json</p></figure><p id="3e42" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在尝试重启调试器，当调试器到达<code class="fe lo lp lq lr b">return</code>断点时，使用<strong class="kt jd">进入</strong>按钮来探索<code class="fe lo lp lq lr b">abspath()</code>。一旦进入，您可以随时使用<strong class="kt jd">步出</strong>按钮——比方说，您认为您不想进一步探索了——调试器将返回到您进入之前的位置，在我们的例子中是<code class="fe lo lp lq lr b">abs.py</code>中的<code class="fe lo lp lq lr b">return</code>语句。</p><h2 id="4f33" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">条件断点</h2><p id="0651" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">假设您已经通过查看最初的几个<code class="fe lo lp lq lr b">for</code>循环迭代理解了调试器是如何工作的。显然，等待它完成所有迭代没有多大意义。相反，我们可以让它在不碰到断点的情况下运行，比如说，直到它到达最后一次迭代。</p><p id="95b9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这就是条件断点发挥作用的地方！让我们看看如何做到这一点。(为了简单起见，我们将禁用<code class="fe lo lp lq lr b">abs.py</code>中的断点。)</p><ul class=""><li id="99d8" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">右键单击<code class="fe lo lp lq lr b">for</code>循环中的断点，选择编辑断点。</li><li id="e5d4" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">从下拉菜单中选择<strong class="kt jd">表达式</strong>并设置为<code class="fe lo lp lq lr b">i == len(os.listdir(“audio_data”)) — 1</code>。</li><li id="c8e2" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">按回车键。</li></ul><div class="nv nw nx ny gt ab cb"><figure class="pm nz pv po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/543124f58ac0b3e7ecb9ffb8ae95dbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*DkLWGjrcSqobOQlkLHo0Jw.png"/></div></figure><figure class="pm nz pw po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/d9f72ee73249315913e9680e6e336056.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*vlnDdB5BxFm4dOEfQr2WGw.png"/></div></figure></div><p id="92e3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，当您重新启动调试器时，它将自动跳过前四次迭代，并在<code class="fe lo lp lq lr b">i=4</code>处触发断点，如下图所示。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi px"><img src="../Images/6d2fbc6a498834ae1a3a385a51ee6fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OYpf1EzMlhHRwKKAWN7wVQ.png"/></div></div></figure><p id="2feb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln"> Pro 提示 1:您还可以根据命中次数指定要触发的断点。</em></p><blockquote class="ok ol om"><p id="9412" class="kr ks ln kt b ku kv kd kw kx ky kg kz on lb lc ld oo lf lg lh op lj lk ll lm im bi translated">命中次数是指调试器命中特定断点的次数。</p></blockquote><p id="a2c9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">例如，您可能想只为最后几个文件触发断点(可能是因为您想详细检查它们)。您可以从下拉菜单中选择</em> <strong class="kt jd"> <em class="ln">点击次数</em> </strong> <em class="ln">(而不是</em> <strong class="kt jd"> <em class="ln">表达式</em> </strong> <em class="ln">)并将其设置为</em> <code class="fe lo lp lq lr b"><em class="ln">&gt;3</em></code> <em class="ln">。这意味着断点仅在前三次出现后触发，因此我们在终端中看到三个打印语句，分别对应于</em> <code class="fe lo lp lq lr b"><em class="ln">i=0</em></code> <em class="ln">、</em> <code class="fe lo lp lq lr b"><em class="ln">i=1</em></code> <em class="ln">和</em> <code class="fe lo lp lq lr b"><em class="ln">i=2</em></code> <em class="ln">。</em></p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi py"><img src="../Images/f3eb8a19cb46005e4539d79a4422cc67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tr5kOkDK5pO8iJNamArYaw.png"/></div></div></figure><p id="83fb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">专家提示 2:我们甚至可以在每次遇到断点时记录一条消息(到调试控制台)。为此，从下拉菜单中选择 <strong class="kt jd"> <em class="ln">日志消息</em> </strong> <em class="ln">(而不是</em> <strong class="kt jd"> <em class="ln">表达式</em> </strong> <em class="ln">)并将其设置为要在花括号内评估的一些纯文本和/或表达式。举个简单的例子，我们将通过设置日志消息为</em> <code class="fe lo lp lq lr b"><em class="ln">Updated i. i = {i}</em></code> <em class="ln">来记录断点被命中时</em> <code class="fe lo lp lq lr b"><em class="ln">i</em></code> <em class="ln">的更新值。</em></p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi pz"><img src="../Images/1f7b0bc03ff12ba9be8e6c27b175d303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NL91UavTyjR4enABaja9A.png"/></div></div></figure><h2 id="29de" class="mq lt it bd lu mr ms dn ly mt mu dp mc la mv mw me le mx my mg li mz na mi iz bi translated">调用栈</h2><p id="f964" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">通常，在处理大型项目时，很容易忘记代码流。由于有很多断点，您可能会奇怪自己是如何出现在这个文件中的，更重要的是，<em class="ln">您是从哪里</em>出现在这里的！</p><blockquote class="ok ol om"><p id="1cf1" class="kr ks ln kt b ku kv kd kw kx ky kg kz on lb lc ld oo lf lg lh op lj lk ll lm im bi translated">由于堆栈遵循<strong class="kt jd">先进后出</strong>的顺序，VSCode 的调用堆栈非常适合在调试期间跟踪断点。</p></blockquote><p id="05fd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">使用显示调用层次结构的调用堆栈窗口，VSCode 调试器可以在这方面提供一些帮助。</p><p id="b140" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了展示该实用程序，我们将通过在<code class="fe lo lp lq lr b">utils</code>目录中引入<code class="fe lo lp lq lr b">upper.py</code>来使当前项目稍微大一点。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/8dd0660c89352de9fcd0799f6a91b42f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*NBptUHYVbOJg3VUt_ZSLHw.png"/></div><p class="of og gj gh gi oh oi bd b be z dk translated">upper.py</p></figure><p id="695d" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们快速更新<code class="fe lo lp lq lr b">abs.py</code>以使用<code class="fe lo lp lq lr b">to_upper()</code>功能:</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi qb"><img src="../Images/4ab08df9f0010609ba00304acb06e428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-uMaEP3YoF7rjQn4K6S6Q.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">abs.py</p></figure><p id="c3ca" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">总而言之，我们将在项目中设置四个断点(见下图):</p><ul class=""><li id="c7ce" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">在<code class="fe lo lp lq lr b">hello.py</code>的第四行</li><li id="c635" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">在<code class="fe lo lp lq lr b">abs.py</code>的第 5 行和第 6 行</li><li id="ccc7" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">在<code class="fe lo lp lq lr b">upper.py</code>的第 2 行</li></ul><div class="nv nw nx ny gt ab cb"><figure class="pm nz qc po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/08efe9273acbe776febacc43ab1509e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*pNza2BPgNhat_DfKwAqmzA.png"/></div></figure><figure class="pm nz qd po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/8360611c675c0a9a0813fdb998a7d4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*RMmd_70td-X5dR_nanWq8g.png"/></div></figure><figure class="pm nz qe po pp pq pr paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><img src="../Images/acce25c13ee467660343286572af5d4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*vpgmxlBoQ3CxkyiN2kZAbg.png"/></div><p class="of og gj gh gi oh oi bd b be z dk qf di qg qh translated">展示 VSCode 中调用堆栈功能的示例</p></figure></div><p id="ee85" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管这看起来像是一个微不足道的例子，但我们可以通过以下方式来了解呼叫层次结构:</p><ul class=""><li id="89ba" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">启动调试器(确保活动屏幕包含<code class="fe lo lp lq lr b">hello.py</code>)并点击<strong class="kt jd">继续</strong>按钮，直到到达<code class="fe lo lp lq lr b">upper.py</code>中的断点。</li><li id="caf7" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">看一下<strong class="kt jd">调用堆栈</strong>窗口(见下图):</li></ul><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi qi"><img src="../Images/313322a62c2153bd6a6f9a9fe2304bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QM3Y_56j6jHxxvXmmPHdxA.png"/></div></div></figure><p id="4fc7" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">需要注意的几件事:</p><ul class=""><li id="9c4e" class="ot ou it kt b ku kv kx ky la ov le ow li ox lm oy oz pa pb bi translated">在调用栈的最顶端是模块(即<code class="fe lo lp lq lr b">to_upper()</code>)和文件名(<code class="fe lo lp lq lr b">upper.py</code>)以及包含当前断点的行号(在我们的例子中是第 2 行)。</li><li id="a285" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">第二个位置是调用当前断点的文件/行号(在我们的例子中是<code class="fe lo lp lq lr b">abs.py</code>，第 5 行)。</li><li id="92f0" class="ot ou it kt b ku pc kx pd la pe le pf li pg lm oy oz pa pb bi translated">第三个位置是初始模块(<code class="fe lo lp lq lr b">hello.py</code>在第 6 行)，它调用了<code class="fe lo lp lq lr b">abs.py</code>中的<code class="fe lo lp lq lr b">get_abspath()</code>，后者调用了当前模块(<code class="fe lo lp lq lr b">upper.py)</code>中的<code class="fe lo lp lq lr b">to_upper()</code>)。</li></ul><p id="7e5e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">希望这是有意义的，不会成为那种<em class="ln">我知道你知道我知道你知道…</em>东西！</p><h1 id="43f1" class="ls lt it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated">额外收获:异常断点</h1><p id="2751" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">良好的编程实践使用 try-catch 块强制使用错误处理。因此，调试器可能会跳过它们，代码不会中断。但是，如果您想在抛出和/或引发异常时显式停止调试器，该怎么办呢？</p><blockquote class="ok ol om"><p id="b9a2" class="kr ks ln kt b ku kv kd kw kx ky kg kz on lb lc ld oo lf lg lh op lj lk ll lm im bi translated">调试期间的异常断点有助于突出显示任何可能因为在 catch 块中被捕获而未被注意到的错误。</p></blockquote><p id="412f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">为了演示这一点，让我们最后一次修改代码，并加入一些 try-except 块。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi qj"><img src="../Images/3de5a967eb092d6232e9fa9d01524db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILe8Sp-WBZNoJrIRTnDssQ.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">hello.py</p></figure><p id="4ef8" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果您运行这个独立的脚本(没有调试器)，它将运行得很好，没有任何错误！即使在没有找到<code class="fe lo lp lq lr b">x</code>时遇到问题，也会因为 except 块中的<code class="fe lo lp lq lr b">pass</code>而被静默处理。</p><p id="1dce" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">话虽如此，在这种情况下破解 VSCode 似乎还是有用的。为此，请转到断点窗口，确保勾选了<strong class="kt jd">引发的异常</strong>旁边的复选框(默认情况下会触发未捕获的异常)。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi qk"><img src="../Images/94daf6c31cb471f11096a1038934d60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Tb-bJYXSMoDsUlD84Kgqw.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">断点异常</p></figure><p id="844f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">现在，当您尝试在调试模式下运行<code class="fe lo lp lq lr b">hello.py</code>时，代码将在 try 块处中断。</p><figure class="nv nw nx ny gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ql"><img src="../Images/31b7ab8b81fbde19d11617f82af23858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rS3R-xSAWilzO86d60CO3w.png"/></div></div><p class="of og gj gh gi oh oi bd b be z dk translated">断点异常</p></figure><h1 id="50c2" class="ls lt it bd lu lv lw lx ly lz ma mb mc ki md kj me kl mf km mg ko mh kp mi mj bi translated">结论</h1><p id="dbc4" class="pw-post-body-paragraph kr ks it kt b ku mk kd kw kx ml kg kz la mm lc ld le mn lg lh li mo lk ll lm im bi translated">调试是我根据帕累托 80:20 法则学到的技能之一。学习它的各个方面可能需要一段时间，但是一旦掌握了，它就可以应用到你将要从事的所有项目中。需要注意的一点是，在调试器运行时，我们可以设置/编辑任意多的断点，但是，我们不能改变代码本身。我们必须首先停止调试器，进行更改，然后再次启动调试器。</p><p id="b3ba" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一如既往，如果有更简单的方法来做/解释本文中提到的一些事情，一定要让我知道。一般来说，避免不请自来的破坏性/垃圾/敌意评论！</p><p id="d709" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">直到下一次✨</p></div><div class="ab cl qm qn hx qo" role="separator"><span class="qp bw bk qq qr qs"/><span class="qp bw bk qq qr qs"/><span class="qp bw bk qq qr"/></div><div class="im in io ip iq"><p id="e3c3" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我喜欢写循序渐进的初学者指南、操作指南、面试问题、ML/AI 中使用的解码术语等。如果你想完全访问我的所有文章(以及其他媒体上的文章)，那么你可以注册使用 <a class="ae mp" href="https://varshitasher.medium.com/membership" rel="noopener"> <strong class="kt jd"> <em class="ln">我的链接</em></strong></a><strong class="kt jd"><em class="ln"/></strong><em class="ln">这里</em> <strong class="kt jd"> <em class="ln">。</em>T24】</strong></p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/fine-tuning-hubert-for-emotion-recognition-in-custom-audio-data-using-huggingface-c2d516b41cd8"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">使用 Huggingface 微调 HuBERT 用于定制音频数据中的情感识别</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">构建自定义数据加载器、实验日志、改进指标的技巧和 GitHub repo，如果您想了解…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qt l np nq nr nn ns nt ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/time-series-modeling-using-scikit-pandas-and-numpy-682e3b8db8d1"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">使用 Scikit、Pandas 和 Numpy 进行时间序列建模</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">直观地利用季节性来提高模型准确性。</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qu l np nq nr nn ns nt ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/end-to-end-deep-learning-project-part-1-930af1e1e191"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">端到端深度学习项目:第 1 部分</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">用 Keras 实现迁移学习的高效网络图像分类模型</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qv l np nq nr nn ns nt ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/step-by-step-guide-to-explaining-your-ml-project-during-a-data-science-interview-81dfaaa408bf"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jd gy z fp nj fr fs nk fu fw jc bi translated">在数据科学面试中解释你的 ML 项目的逐步指南。</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在结尾有一个额外的样本脚本，让你谨慎地展示你的技术技能！</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="qw l np nq nr nn ns nt ne"/></div></div></a></div></div></div>    
</body>
</html>