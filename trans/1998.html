<html>
<head>
<title>Battle of the Data Containers — Which Python Typed Structure is the Best?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据容器之战——哪种Python类型的结构是最好的？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/battle-of-the-data-containers-which-python-typed-structure-is-the-best-6d28fde824e#2022-05-06">https://towardsdatascience.com/battle-of-the-data-containers-which-python-typed-structure-is-the-best-6d28fde824e#2022-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ab4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Class，dataclass，attrs，pydantic还是NamedTuple，哪个容器最适合你的项目？让我们找出答案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/559f51838b20df280999ebb53a548c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiiM7eKKOB7tjiqU4K7y5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="13ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们开始了一个全新的项目，积极性很高。在基本规划完成后，我们开始对我们的应用程序进行初始分类，我们即将构建将通过我们的应用程序管道流动的数据模型。<br/> <br/>突然我们碰了壁，我们必须在项目的早期做出妥协的选择，<strong class="la iu">我们应该选择什么样的数据容器，静态输入信息？</strong></p><p id="82a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">十年前，选择会更简单。那时候没有打字模块。数据容器是非常基本的。十年过去了，情况有了很大的不同，Python作为一种语言已经有了巨大的发展，它的社区也是如此。<strong class="la iu">大多数ide都支持静态类型，这使得类型提示成为大型项目的必备条件和所有代码的最佳实践。</strong></p><p id="6773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以回到我们的问题，我们应该选择哪个容器？有许多选择，事实上是伟大的选择。没有明确的目标，但是在这个故事中，我们将测试和比较一些最流行的容器。在故事的结尾，选择应该更简单，你应该能够根据我们项目的需求来选择。</p><h2 id="4e07" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">目录</h2><ul class=""><li id="1a3e" class="mn mo it la b lb mp le mq lh mr ll ms lp mt lt mu mv mw mx bi translated">关于__slots__的快速注释</li><li id="87df" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">编写测试代码</li><li id="0fbd" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">普通班</li><li id="55de" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">数据类</li><li id="46d6" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">属性</li><li id="2d05" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">Pydantic</li><li id="07c7" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">命名元组</li><li id="92fa" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">控制，字典</li><li id="b7d5" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">试验结果</li><li id="4bb3" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">结论</li></ul><h2 id="69cb" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">关于__slots__的快速注释</h2><p id="0681" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">插槽是一种让类更有效的内存和更快的方法。通过使用槽，我们显式地定义(硬编码)了类的属性。</p><p id="20d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">标准Python类在__dict__ dunder方法中存储属性(在幕后)，顾名思义，这是一个字典。这允许我们在运行时设置新的属性。如果我们不想在运行时设置新的属性，这不是很有效。</p><p id="b7b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个选择是使用__slots__ dunder方法，它覆盖__dict__。在标准类中，我们必须对属性进行硬编码，但是有一些数据容器提供了像布尔标志这样简单的插槽功能(将在接下来的部分中显示)。</p><h2 id="0ebf" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">编写测试代码</h2><p id="bb81" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">时间是关键，性能是大多数应用程序的关键。</p><p id="36e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在我们开始测试之前，我们创建了一个小的<em class="ng"> Timer </em>类来测量纳秒级的时间。该类使用来自<em class="ng">时间</em>标准模块的“perf_counter_ns”方法，这是测量两个事件之间时间的最精确方法(来自<em class="ng">时间</em>模块)。</p><p id="e46a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<em class="ng">定时器</em>非常简单，它公开了一个“start()”方法和一个“stop()”方法，以及一个“time”属性来检索定时器的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7d44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有将被测试的容器都应该实现这个简单的协议(接口):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9ffe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将执行的测试包括:</p><ul class=""><li id="2367" class="mn mo it la b lb lc le lf lh nj ll nk lp nl lt mu mv mw mx bi translated">创建对象所花费的时间，“时间_人员_创建”</li><li id="5c69" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">从类“time_person_get”中获取属性所花费的时间</li><li id="63c8" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">在类“time_person_set”中设置属性所花费的时间(注意，这只适用于可变对象)</li><li id="a737" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">对象使用的内存(以字节为单位)(为此我们使用Pympler，一个简洁的内存分析第三方库)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4cea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码将我们的四个测试封装到一个函数(“test_person_container”)中，该函数运行测试的<em class="ng"> n_trials </em>并报告每个测试的平均值。该函数有一个布尔标志参数<em class="ng"> test_set </em>，其中<em class="ng">T5表示是否测试set属性(对于不可变对象，应该设置为<em class="ng"> False </em>)。</em></p><p id="fedd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试结果在一个<em class="ng">PersonTestResult</em>object<em class="ng"/>中返回(注意，尽管这是一个dataclass，但它不是测试的一部分)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="00a4" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">普通班</h2><p id="d73f" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们的第一个容器是普通的旧类。我们用__dict__方法(<em class="ng"> PersonClass </em>)测试标准类，用slots(<em class="ng">person class slots)</em>测试另一个类。</p><p id="f8df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就可读性而言，注意单词“name”和“age”在每个类定义中出现的次数。这是使用常规类的一个巨大缺点。</p><p id="5a70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个缺点是当我们打印一个类的实例时会发生什么，对于一个普通的类，会打印一个内存地址。这对于数据容器来说不是很方便。要解决这个问题，我们必须用我们想要打印的信息编写一个__repr__ dunder方法。这将进一步增加单词“姓名”和“年龄”被书写的次数。</p><p id="c629" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对数据使用通用类还有许多其他注意事项。</p><p id="ac07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以总的来说，将常规类用作包含输入信息的数据容器并不是最好的主意，但仍然是可行的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="f786" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">数据类</h2><p id="95d0" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在Python 3.7中引入了dataclasses，它们解决了上一节中讨论的许多问题。我只想说，<strong class="la iu">数据类很棒</strong>。我一直在使用它们，只是喜欢使用它们。然而，这不会使测试有偏差。</p><p id="b3b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据类(直到Python 3.10)的一个主要问题是没有简单的方法来使用槽。但是如果你使用的是Python 3.10+你是golden，你可以使用slots布尔标志作为参数。使用数据类是如此简单，这不是很好吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="ddb2" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">属性</h2><p id="713f" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">很棒的第三方库。事实上，数据类是基于属性功能的。因此，它是一个非常成熟和健壮的库。</p><p id="298c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就我个人而言，我不经常使用attrs，但它的功能非常棒。如果你希望你的项目有一些功能，attrs可能会满足你。</p><p id="da91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在我看来，与dataclasses相比，语法并不简单或优雅，但这只是我的看法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="83de" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">Pydantic</h2><p id="6cde" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">又一个很棒的第三方库。然而，与测试中的其他容器相比，pydantic可能属于不同的类别。Pydantic的主要目的是解析和使用ORM，也就是说，它更适合对数据进行净化/验证，而不仅仅是一个容器。</p><p id="507a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我喜欢pydantic，也有很多功能。但是，在使用pydantic之前，您必须确保实际上您需要整理数据，因为这会影响性能，您将在下面几节中看到这一点。</p><p id="9887" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一下，还有止痛药。BaseModel 是pydantic的旗舰产品，但也有一个pydantic数据类，隐藏在库中。我们也会测试它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="8bf3" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">命名元组</h2><p id="61db" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我可能应该更多地使用NamedTuple。这是一个非常简单的类型化元组实现。因此，也许我应该使用NamedTuple，而不是将函数返回的多个值包装在dataclass中(如果这是一个借口，我喜欢decorators)。</p><p id="9b47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">抛开所有的乐趣不谈，当你需要一个不可变的容器时，NamedTuple是一个很好的选择，它继承了Tuple。因此，这是一种在代码中清楚表明某些东西不应该被弄乱的干净方式。</p><p id="9944" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果您确定想要一个不可变的对象，那么就选择NamedTuple。如果你想改变一些东西，你必须创建另一个实例，这将导致性能下降。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="338f" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">控制，字典</h2><p id="090a" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了能够比较容器，我们还将测试普通字典，即它将是我们的控制。十年前，dict将是我们的通用数据容器。</p><p id="ffe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将为<em class="ng"> dict </em>编写一个单独的测试，因为dict没有实现我们为一般测试定义的接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="9715" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">试验结果</h2><p id="fd3c" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">下图显示了创建时间、获取属性时间、设置属性时间(如果适用)和内存使用的结果。</p><p id="b8cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">似乎pydantic在创建时间和设置属性时间上是一个异常值。正如我们前面提到的，pydantic的主要功能是净化/验证，在解析时非常有用。然而，这需要付出性能成本。所以我不会将pydantic作为通用数据容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/2ce258bc7d310399721f9e76c18d2f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WiSPDZEWq9gH9_UxUjHYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。所有容器的结果。越低越好。</p></figure><p id="9790" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的图中，我们给出了相同的结果，但没有pydantic的测试，图的比例现在更适合于比较其他容器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/640c175993af2eb91a5350184f19ac62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PC9k1-cSJW4Qhf5pb3Qawg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。不包括pydantic的容器结果。越低越好。</p></figure><p id="92f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所预料的，使用插槽时，无论是在使用插槽的常规类、使用插槽的数据类还是使用插槽的属性中，性能都会有所提高。</p><p id="815a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下图总结了结果。为了避免比例问题，省略了Pydantic。需要注意的是，带槽的数据类和带槽的属性几乎完全重叠，所以出于可视化的目的，带槽的属性没有显示出来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/cb4afbcebbcffdd194fee703ca143416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTQo22np0BrxyVveC1Pgzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。气泡图摘要。带插槽的属性被省略，因为它与带插槽的数据类几乎完全重叠。x越低越好，y越低越好，气泡越小越好。</p></figure><h2 id="a1f5" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="94ba" class="pw-post-body-paragraph ky kz it la b lb mp ju ld le mq jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">从人数上来看，有空位的班级是明显的赢家。然而，正如我们之前讨论的，使用常规类作为数据容器并不方便。如果我们包含了attrs或dataclass的方法，那么我们的常规类将不会是轻量级和高性能的。</p><p id="a7cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我们继续宣布并列第一，带槽的属性和带槽的数据类是赢家。</p><p id="b5ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后的裁决是:</p><ul class=""><li id="86be" class="mn mo it la b lb lc le lf lh nj ll nk lp nl lt mu mv mw mx bi translated">如果您使用Python 3.10+并且不希望任何第三方依赖，请使用dataclasses(可能的话使用插槽)。</li><li id="c184" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">如果你想要功能上的灵活性和健壮性，不管是Python版本还是第三方依赖，都可以使用attrs。</li><li id="7929" class="mn mo it la b lb my le mz lh na ll nb lp nc lt mu mv mw mx bi translated">如果你低于Python 3.10，不想依赖第三方，想要简单和不可变的东西，那么NamedTuple适合你。</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="8d8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。如果我错过了什么，请让我知道。如果你想知道更多这样的故事，请关注我。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/subscribe/@diego-barba" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ks oa"/></div></div></a></div><p id="0a4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我的推荐链接成为媒体会员，可以无限制地访问我的故事和许多其他内容。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd iu gy z fp of fr fs og fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="op l ol om on oj oo ks oa"/></div></div></a></div></div></div>    
</body>
</html>