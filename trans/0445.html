<html>
<head>
<title>7 Useful Examples of Python’s itertools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 的 itertools 的 7 个有用例子</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/7-useful-examples-of-pythons-itertools-e561dc9f15ca#2022-02-17">https://towardsdatascience.com/7-useful-examples-of-pythons-itertools-e561dc9f15ca#2022-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过灵活的实用函数和范例节省时间和代码</h2></div><p id="2c6b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python <code class="fe le lf lg lh b">itertools</code>库为处理可重复项提供了非常有用的实用函数。通过熟练掌握<code class="fe le lf lg lh b">itertools</code>函数，您可以以新的方式组合它们，并使用它们作为构建模块，用很少几行代码解决复杂的问题。在本文中，你将看到 7 个应用<code class="fe le lf lg lh b">itertools</code>函数的实例。</p><p id="93a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想继续下去，确保导入<code class="fe le lf lg lh b">itertools</code>以及<code class="fe le lf lg lh b">matplotlib</code>、<code class="fe le lf lg lh b">seaborn</code>和<code class="fe le lf lg lh b">numpy </code>用于涉及可视化的例子。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="f394" class="lq lr it lh b gy ls lt l lu lv">import itertools<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>import numpy as np</span></pre><h2 id="fd0e" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">1.用 cycle()制作重复序列</h2><p id="7419" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">函数将无限重复你给它的任何 iterable。通过使用<code class="fe le lf lg lh b">islice()</code>函数，您可以获得任意长度的序列，其中包含您选择的重复子序列。您可以使用它来快速生成一些周期性数据。下面的代码创建了一个 20 项的列表，包含重复序列 0，2，1，3，…</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7deb" class="lq lr it lh b gy ls lt l lu lv">data = list(itertools.islice(itertools.cycle([0, 2, 1, 3]), 0, 20))<br/>sns.lineplot(x=range(len(data)), y=data)</span></pre><figure class="li lj lk ll gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/74eebc7886eeea479b8ebe24b049e5c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UJZAidRxORGqm5XkW-6PkA.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">作者图片</p></figure><p id="8f99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了<code class="fe le lf lg lh b">cycle()</code>，你可能还会发现<code class="fe le lf lg lh b">count()</code>很有用，它只是在一个无限迭代器中从一个给定的数字向上计数。</p><h2 id="3785" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">2.用组合()获得集合的所有可能组合</h2><p id="c544" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">假设你和你的朋友想要制定一个烹饪计划，每周两个人为整个团队做饭。有多少独特的厨师组合？这是数学组合的经典案例，用<code class="fe le lf lg lh b">combinations()</code>就能轻松得到答案。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5105" class="lq lr it lh b gy ls lt l lu lv">names = ["Alice", "Bob", "Charlie", "Dora", "Evgenia", "Farhat"]<br/>print(list(itertools.combinations(names, 2)))</span><span id="d8b1" class="lq lr it lh b gy ne lt l lu lv"># [('Alice', 'Bob'),<br/>#  ('Alice', 'Charlie'),<br/>#  ('Alice', 'Dora'),<br/>#  ('Alice', 'Evgenia'),<br/>#  ('Alice', 'Farhat'),<br/>#  ('Bob', 'Charlie'),<br/>#  ('Bob', 'Dora'),<br/>#  ('Bob', 'Evgenia'),<br/>#  ('Bob', 'Farhat'),<br/>#  ('Charlie', 'Dora'),<br/>#  ('Charlie', 'Evgenia'),<br/>#  ('Charlie', 'Farhat'),<br/>#  ('Dora', 'Evgenia'),<br/>#  ('Dora', 'Farhat'),<br/>#  ('Evgenia', 'Farhat')]</span></pre><p id="215f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组合还会告诉你一组 N 个人互相握手所需的独特握手的数量，或者 N 个变量的协方差值的数量。</p><h2 id="902f" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">3.用产品()替换嵌套循环</h2><p id="b3ba" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">在一副扑克牌中，你有 13 种面值和 4 种花色，总共 52 张牌。大家可以看到，牌的总数是 13 和 4 的乘积，所有牌的集合是面值的集合和花色的集合的<a class="ae nf" href="https://en.wikipedia.org/wiki/Cartesian_product" rel="noopener ugc nofollow" target="_blank">笛卡尔积</a>。您可以使用<code class="fe le lf lg lh b">product()</code>功能快速获得所有扑克牌的列表，而无需诉诸循环。我经常发现使用<code class="fe le lf lg lh b">product()</code>比创建难以阅读的嵌套循环要优雅得多。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ecd1" class="lq lr it lh b gy ls lt l lu lv">values = ["Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"]<br/>suits = ["Hearts", "Diamonds", "Clubs", "Spades"]<br/>print(list(itertools.product(values, suits)))</span></pre><p id="ff4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个例子是数据集。假设您有几种语言的数据集，对于每种语言，您都有一个测试、训练和验证集。您可以使用<code class="fe le lf lg lh b">product()</code>，而不是使用嵌套循环来表示尽可能多的文件名。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ea24" class="lq lr it lh b gy ls lt l lu lv">datasets = ["english", "spanish", "arabic", "chinese", "japanese"]<br/>splits = ["train", "test", "validation"]</span><span id="c9cb" class="lq lr it lh b gy ne lt l lu lv">for dataset, split in itertools.product(datasets, splits):<br/>    print(f"{dataset}_{split}.txt")</span><span id="e159" class="lq lr it lh b gy ne lt l lu lv"># english_train.txt<br/># english_test.txt<br/># english_validation.txt<br/># spanish_train.txt<br/># ...</span></pre><h2 id="d2a1" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">4.使用带有 compress()的布尔索引从列表中选择数据</h2><p id="cc8d" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">如果您使用过像<code class="fe le lf lg lh b">pandas</code>这样的数据科学库，您可能习惯于使用布尔索引来索引一个系列或数据帧。换句话说，您可以获取一系列布尔值，如<code class="fe le lf lg lh b">[True, False, False, True, ...]</code>，并选择系列或数据帧中的行，这样结果就只包括相应布尔值为<code class="fe le lf lg lh b">True</code>的行。那么，你知道你实际上也可以用 Python 列表和 iterables 做到这一点吗？假设您只想要字母表中每三个字母的列表。您可以使用<code class="fe le lf lg lh b">compress()</code>函数，它接受一个 iterable 和一个 iterable 的真/假(或 1/0)值，并执行布尔索引。下面的代码以两种不同的方式实现这一点，每一种都使用不同的先前见过的<code class="fe le lf lg lh b">itertools</code>函数作为助手。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="e5b1" class="lq lr it lh b gy ls lt l lu lv">import string</span><span id="5d71" class="lq lr it lh b gy ne lt l lu lv">print(list(itertools.compress(string.ascii_lowercase, itertools.cycle([1, 0, 0]))))<br/># ['a', 'd', 'g', 'j', 'm', 'p', 's', 'v', 'y']</span><span id="1bc5" class="lq lr it lh b gy ne lt l lu lv">print(list(itertools.compress(string.ascii_lowercase, map(lambda x: x % 3 == 0, itertools.count()))))<br/># ['a', 'd', 'g', 'j', 'm', 'p', 's', 'v', 'y']</span></pre><h2 id="fc64" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">5.用 accumulate()计算累积和与积</h2><p id="433b" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">这里有一个有趣的问题:给定一个长度为 N 的列表，您的任务是创建一个函数，该函数采用两个索引 I 和 j(使得 i &lt; j ),并计算位于索引 I 和索引 j 之间的子列表中的项目的总和。您可以对列表进行什么样的预计算以使这些查询尽可能快？</p><p id="e772" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">accumulate()</code>函数从开始到结束计算列表中项目的累积和(默认情况下)。下面的代码生成一个随机的整数数组，用<code class="fe le lf lg lh b">accumulate()</code>在一行中预先计算一个累积和列表，并使用这个预先计算的数组返回子列表问题的常数时间解决方案。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4406" class="lq lr it lh b gy ls lt l lu lv">original_list = np.random.randint(0, 100, (100,))<br/>cumulative_list = list(itertools.accumulate(original_list))</span><span id="6fc6" class="lq lr it lh b gy ne lt l lu lv">def query(i, j):<br/>    return cumulative_list[j] - cumulative_list[i]</span></pre><p id="7caa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以提供另一个函数作为<code class="fe le lf lg lh b">accumulate()</code>的参数来改变行为，这样您就可以很容易地计算累积积或一些其他函数。</p><h2 id="0121" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">6.用 Repeat()无限重复一个值</h2><p id="f66c" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">假设您想要创建一个以人名作为关键字的字典，除了您想要每个人在创建字典时最初都有一个特定的默认值。您可以遍历名称列表，并将默认值与每个名称相关联。一种更优雅的方式是使用<code class="fe le lf lg lh b">dict()</code>构造函数、<code class="fe le lf lg lh b">zip()</code>函数和<code class="fe le lf lg lh b">itertools.repeat()</code>。<code class="fe le lf lg lh b">repeat()</code>函数将简单地在一个无限迭代器中重复相同的值，这意味着当你将它与一个有限列表压缩在一起时，将会生成精确的重复次数。<code class="fe le lf lg lh b">dict()</code>构造函数可以接受(键，值)元组的 iterable，初始化一个字典，每个键映射到每个值。我们可以不使用循环就完成我们想要的。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="9161" class="lq lr it lh b gy ls lt l lu lv">names = ["Alice", "Bob", "Charlie", "Dora", "Evgenia", "Farhat"]<br/>names_dict = dict(zip(names, itertools.repeat("Default")))</span><span id="f8cc" class="lq lr it lh b gy ne lt l lu lv"># {'Alice': 'Default',<br/>#  'Bob': 'Default',<br/>#  'Charlie': 'Default',<br/>#  'Dora': 'Default',<br/>#  'Evgenia': 'Default',<br/>#  'Farhat': 'Default'}</span></pre><h2 id="64a0" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">7.用 starmap()在元组列表中映射函数</h2><p id="b22f" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><code class="fe le lf lg lh b">starmap()</code>函数类似于 Python 的内置<code class="fe le lf lg lh b">map()</code>函数，它将函数应用于 iterable。不同之处在于，starmap()将一个双参数函数应用于元组的 iterable，例如<code class="fe le lf lg lh b">starmap(lambda x, y: x ** y, [(2, 3), (3, 2), (1, 5)])</code>将返回序列<code class="fe le lf lg lh b">[8, 9, 1]</code>的迭代器，即<code class="fe le lf lg lh b">[2**3, 3**2, 1**5]</code>。这种方法的一个潜在应用是计算列表中成对项目之间的差异。下面的代码使用<code class="fe le lf lg lh b">zip()</code>和列表切片从<code class="fe le lf lg lh b">temps</code>列表中创建一个成对条目的 iterable，然后应用减法函数。这就产生了一个每日温度变化的列表，我们可以将其绘制成柱状图。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4045" class="lq lr it lh b gy ls lt l lu lv">temps = [70, 69, 69, 58, 55, 68, 81, 90, 89, 88, 75, 76, 74]<br/>diffs = list(itertools.starmap(np.subtract, zip(temps[1:], temps[:-1])))<br/>data = {"x": list(range(len(diffs))), "y": diffs}<br/>sns.barplot(data=data, x="x", y="y")</span></pre><figure class="li lj lk ll gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ng"><img src="../Images/8a5eee26187efbd389f3384c8dcb5699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Xx2c7dknG7eIooQo3DJiw.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">作者图片</p></figure><p id="7cdf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用同样的想法来创建一个函数导数的数值近似值。如果我们在 x 的一个小变化上有一个值序列(在这种情况下，正弦函数每 0.1 个单位计算一次)，我们将值的成对差除以 x 的变化，我们会得到一条看起来完全像余弦函数的曲线，它实际上是 sin(x)的导数。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="91f0" class="lq lr it lh b gy ls lt l lu lv">x = np.linspace(0, 10, 100)<br/>y = np.sin(x)              <br/>diffs = list(itertools.starmap(lambda x, y: (x-y)/0.1, zip(y[1:], y[:-1]))) # this list is one shorter than the original list<br/>sns.lineplot(x=x, y=y)<br/>sns.lineplot(x=x[:-1], y=diffs)</span></pre><figure class="li lj lk ll gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/868358eca4309b547365b47944746943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16m4wZvi4SesKroECPyT5w.png"/></div></div><p class="na nb gj gh gi nc nd bd b be z dk translated">蓝色曲线是根据原始列表绘制的，包含均匀分布的 x 值和相应的 sin(x)值。橙色曲线来自于使用 starmap()对列表中的值进行成对差分。图片作者。</p></figure><p id="f1ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这是一个有些做作的例子，但希望您能看到这在各种情况下是如何有用的。您不局限于使用简单的函数，如减法和取幂，而是可以提供您自己的自定义函数作为<code class="fe le lf lg lh b">starmap()</code>的第一个参数。</p><h2 id="f405" class="lq lr it bd lw lx ly dn lz ma mb dp mc kr md me mf kv mg mh mi kz mj mk ml mm bi translated">结论</h2><p id="d6cf" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">我希望你喜欢这些例子。这些功能你有什么喜欢的用法吗？关于<code class="fe le lf lg lh b">itertools</code>的伟大之处在于，一旦你习惯了它们，你就有无穷无尽的方法来混合和搭配它们。拥有这些方便的子例程在处理较难的问题时会有很大帮助，并最终使我的代码更加优雅和健壮。查看<code class="fe le lf lg lh b">itertools</code> <a class="ae nf" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank">文档</a>中更多的函数和例子！</p></div></div>    
</body>
</html>