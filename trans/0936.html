<html>
<head>
<title>OOP in Python - Understanding a Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的 OOP 理解一个类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/oop-in-python-understanding-a-class-bcc088e595c6#2022-03-12">https://towardsdatascience.com/oop-in-python-understanding-a-class-bcc088e595c6#2022-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/005da2cb84554046cf70bd92214d40b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rRYxcbRNQSciBEN3"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@javchz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈维·加西亚·查维斯</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="53cf" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">理解 Python 类的基本组件</h2></div><h1 id="82dc" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">背景</h1><p id="d9d0" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这是关于 Python 中面向对象编程(OOP)的博客文章系列的第二部分。</p><p id="c5a6" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在我的上一篇文章中，我提到了什么是 OOP，以及为什么你可能想学习 OOP，即使你可能看不到它的明显用途。万一你没看过，好奇的话，可以看看:<a class="ae jd" rel="noopener" target="_blank" href="/object-oriented-programming-in-python-what-and-why-d966e9e0fd03">Python 中的面向对象编程——什么和为什么？。</a></p><p id="d19d" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在这篇文章中，我们将开始深入一些 OOP 概念的内部，并尝试加深我们对它们的理解。</p><h1 id="348d" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">一个类的构造块</h1><p id="7e5d" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">为了保持连续性，也为了有一个具体的例子，我将从我在上一篇文章中创建的名为<code class="fe mp mq mr ms b">NumList</code>的<em class="mo">类</em>开始。我们将剖析<code class="fe mp mq mr ms b">NumList</code>来看看它的元素。然后我们会再回来对一个<em class="mo">类</em>的元素进行更一般的讨论。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="03df" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">首先，让我们注意以下事项:</p><ul class=""><li id="e127" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">定义一个类以关键字:<code class="fe mp mq mr ms b">class</code>开始，然后跟一个类的名字，以一个类似于函数的冒号<code class="fe mp mq mr ms b">(:)</code>结束。</li><li id="88eb" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated">一个类通常配备有这三个组件:<br/>–一个<strong class="lp jh">名称</strong>:在我们的例子中，<code class="fe mp mq mr ms b">NumList</code>用来标识这个类。<br/>–<strong class="lp jh">属性</strong>:关于类的一组特性。在<code class="fe mp mq mr ms b">NumList</code>中，<code class="fe mp mq mr ms b">__list</code>是一个属性。一个类也可能没有属性。<br/>–<strong class="lp jh">方法</strong>:类执行某些任务的能力。在<code class="fe mp mq mr ms b">NumList</code>、<code class="fe mp mq mr ms b">add_value()</code>、<code class="fe mp mq mr ms b">remove_value</code>和<code class="fe mp mq mr ms b">get_list()</code>中是方法。与属性类似，类也可以不包含方法。</li></ul><blockquote class="nn"><p id="e31d" class="no np jg bd nq nr ns nt nu nv nw mi dk translated"><em class="nx">一个简单的 Python 类配备了三样东西:名称、属性和方法</em></p></blockquote><h1 id="6207" class="kv kw jg bd kx ky kz la lb lc ld le lf km ny kn lh kp nz kq lj ks oa kt ll lm bi translated">进入一个班级的内部</h1><h2 id="92cd" class="ob kw jg bd kx oc od dn lb oe of dp lf lw og oh lh ma oi oj lj me ok ol ll om bi translated">Python 构造函数</h2><p id="3146" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在让我们来谈谈<code class="fe mp mq mr ms b">NumList</code>中定义<code class="fe mp mq mr ms b">__init__()</code>的第一块代码。我们将讨论这个方法是什么，解释使用的符号和关键字。</p><ul class=""><li id="9a8c" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">这是一个特殊的方法，叫做<em class="mo">构造器</em>。<br/>–每次从类中创建对象时，构造函数都会自动运行。它加载了一个类的所有必要元素，使它变得可用。<br/>–在<code class="fe mp mq mr ms b">NumList</code>的情况下，一创建<code class="fe mp mq mr ms b">NumList</code>类的对象，空列表<code class="fe mp mq mr ms b">__list</code>就被构造函数初始化。<br/>–构造函数只在类中使用。<br/>–构造函数必须至少有一个参数。在<code class="fe mp mq mr ms b">NumList</code>中，<code class="fe mp mq mr ms b">__init__()</code>有一个参数- <code class="fe mp mq mr ms b">self</code>。</li><li id="934f" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated"><code class="fe mp mq mr ms b">self</code>:该参数用作自参考。<br/>–使用该参数使属于该类的变量可用。<br/>–它可以被称为任何其他名称，但称为<code class="fe mp mq mr ms b">self</code>只是一种习惯。</li><li id="db86" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated">虚线符号:我们创建了空列表<code class="fe mp mq mr ms b">self.__list</code>。<br/>–该约定用于访问或创建对象的属性:<code class="fe mp mq mr ms b">&lt;ClassName&gt;&lt;dot(.)&gt;&lt;property name&gt;</code>。<br/>–在<code class="fe mp mq mr ms b">NumList</code>中，我们使用<code class="fe mp mq mr ms b">self.__list = []</code>创建了一个名为<code class="fe mp mq mr ms b">__list</code>的属性，属于<code class="fe mp mq mr ms b">NumList</code>，用<code class="fe mp mq mr ms b">self</code>表示，并作为一个空列表初始化。</li><li id="8d11" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated"><code class="fe mp mq mr ms b">__</code>:以两个下划线开头的组件名称使组件成为私有的。<br/>–表示组件只能在类内访问。是<a class="ae jd" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming" rel="noopener ugc nofollow" target="_blank"> <em class="mo">封装</em> </a>的一个实现。<br/>–试图访问私有组件将导致错误。<br/>–试试:<code class="fe mp mq mr ms b">list01 = NumList()</code>然后<code class="fe mp mq mr ms b">len(list01.__list)</code>。这将导致一个<code class="fe mp mq mr ms b">AttributeError</code>。</li></ul><h2 id="3d68" class="ob kw jg bd kx oc od dn lb oe of dp lf lw og oh lh ma oi oj lj me ok ol ll om bi translated">方法</h2><h2 id="60b3" class="ob kw jg bd kx oc od dn lb oe of dp lf lw og oh lh ma oi oj lj me ok ol ll om bi translated"><code class="fe mp mq mr ms b">add_value()</code>和<code class="fe mp mq mr ms b">remove_value()</code></h2><p id="79c1" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">接下来的三个代码块实现了三个方法或函数。</p><p id="59d3" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">前两个方法基本上是我们创建的两个函数的再现，用于在类上下文中演示过程化编程，因此在关键字和符号方面有以下变化:</p><ul class=""><li id="cdae" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">使用<code class="fe mp mq mr ms b">self</code>作为参数:对于任何方法，<code class="fe mp mq mr ms b">self</code>都是一个强制参数，如前所述，</li></ul><blockquote class="on oo op"><p id="1b03" class="ln lo mo lp b lq mj kh ls lt mk kk lv oq ml ly lz or mm mc md os mn mg mh mi ij bi translated"><code class="fe mp mq mr ms b">self</code> <em class="jg">使得所有来自类的属性和方法，在我们的例子中</em> <code class="fe mp mq mr ms b"><em class="jg">NumList</em></code> <em class="jg">，可用到方法。</em></p></blockquote><ul class=""><li id="3b91" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">方法中的参数:根据需要，方法可以有多个参数，作为类上下文之外的常规 Python 函数。例如，<code class="fe mp mq mr ms b">add_value()</code>方法除了强制参数<code class="fe mp mq mr ms b">self</code>外，还有一个名为<code class="fe mp mq mr ms b">val</code>的参数。</li><li id="4c5a" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated">点符号:根据前面讨论的约定，<code class="fe mp mq mr ms b">self</code>指的是类本身。<br/>–如此，<code class="fe mp mq mr ms b">self.__list</code>进入空单。为了使用一种方法，我们再次使用点符号。<br/>–为了构造方法:<code class="fe mp mq mr ms b">add_value()</code>，我们使用了<code class="fe mp mq mr ms b">List</code>类中的<code class="fe mp mq mr ms b">append()</code>方法。因为我们的<code class="fe mp mq mr ms b">__list</code>本身是一个列表，所以它继承了<code class="fe mp mq mr ms b">append()</code>方法。所以要使用这个方法我们用:<code class="fe mp mq mr ms b">self.__list.append()</code>。</li></ul><h2 id="a522" class="ob kw jg bd kx oc od dn lb oe of dp lf lw og oh lh ma oi oj lj me ok ol ll om bi translated"><code class="fe mp mq mr ms b">get_list()</code></h2><p id="5971" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">因为我们将<code class="fe mp mq mr ms b">__list</code>初始化为<code class="fe mp mq mr ms b">NumList</code>中的隐藏组件，所以直接访问列表是不可能的。所以我们需要一个方法或函数来访问它。</p><blockquote class="on oo op"><p id="a73f" class="ln lo mo lp b lq mj kh ls lt mk kk lv oq ml ly lz or mm mc md os mn mg mh mi ij bi translated"><code class="fe mp mq mr ms b"><em class="jg">get_list()</em></code> <em class="jg">为我们提供了进入</em> <code class="fe mp mq mr ms b"><em class="jg">__list</em></code> <em class="jg">的隐藏参数。</em></p></blockquote><h1 id="e138" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">超越单一的阶级</h1><h2 id="2ee5" class="ob kw jg bd kx oc od dn lb oe of dp lf lw og oh lh ma oi oj lj me ok ol ll om bi translated">亚纲</h2><p id="4df9" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在让我们假设在将我们的产品<code class="fe mp mq mr ms b">NumList</code>交付给我们的客户后，我们从推荐中获得了一个新客户。该客户想要相同的列表和功能，但还需要:</p><ul class=""><li id="a394" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">获取列表中数字总和的能力</li></ul><p id="bfed" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">那么，我们该怎么做呢？</p><p id="d444" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一个显而易见的方法是复制<code class="fe mp mq mr ms b">NumList</code>的代码，并为其添加另一个方法，姑且称之为<code class="fe mp mq mr ms b">get_total()</code>。但是，如果我们不断获得新的客户或订单，并有不同的附加功能需求，该怎么办呢？很快，这种复制和修改的过程将不再是一个有效的解决方案。</p><p id="f4cd" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">OOP 有一个有效解决这个问题的方法:创建<em class="mo">子类</em>。创建子类有两个明显的优点:</p><ul class=""><li id="8e1f" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated"><strong class="lp jh">代码的重用</strong>:一个<em class="mo">子类</em>继承了超类的所有方法，因此我们不必重新创建这些方法。</li><li id="1982" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated"><strong class="lp jh">定制</strong>:一个<em class="mo">子类</em>可以包含新的方法和属性。这使得定制解决方案变得容易，同时保持超类的基础不变。</li></ul><h2 id="1716" class="ob kw jg bd kx oc od dn lb oe of dp lf lw og oh lh ma oi oj lj me ok ol ll om bi translated">例子</h2><p id="e153" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">现在让我们创建一个名为<code class="fe mp mq mr ms b">NumListExt01</code>的子类来扩展<code class="fe mp mq mr ms b">NumList</code>类的功能。</p><figure class="mt mu mv mw gt is"><div class="bz fp l di"><div class="mx my l"/></div></figure><pre class="mt mu mv mw gt ot ms ou ov aw ow bi"><span id="090e" class="ob kw jg ms b gy ox oy l oz pa">Initial list of values of cust02: []<br/>Updated list after adding values to it: [2, 20, 44, 12]<br/>Updated list after removing value 12 is:  [2, 20, 44]<br/>Sum of all the elements of the current list is: 66</span></pre><p id="0587" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">注意<code class="fe mp mq mr ms b">NumList</code>是如何被子类利用和定制而不影响超类的:</p><blockquote class="on oo op"><p id="53c3" class="ln lo mo lp b lq mj kh ls lt mk kk lv oq ml ly lz or mm mc md os mn mg mh mi ij bi translated"><em class="jg"> ♻️的子类</em> <code class="fe mp mq mr ms b"><em class="jg">NumListExt01</em></code> <em class="jg">继承了超类</em><code class="fe mp mq mr ms b"><em class="jg">NumList</em></code><em class="jg"><em class="jg"/><code class="fe mp mq mr ms b"><em class="jg">remove_value()</em></code><em class="jg"/><code class="fe mp mq mr ms b"><em class="jg">get_list()</em></code><em class="jg">的方法。</em></em></p><p id="a5bb" class="ln lo mo lp b lq mj kh ls lt mk kk lv oq ml ly lz or mm mc md os mn mg mh mi ij bi translated"><em class="jg"> ➕子类</em> <code class="fe mp mq mr ms b"><em class="jg">NumListExt01</em></code> <em class="jg">有一个额外的方法</em> <code class="fe mp mq mr ms b"><em class="jg">get_total()</em></code> <em class="jg">，它只存在于这个类中，因此只对我们的新客户可用。</em></p></blockquote><h1 id="e023" class="kv kw jg bd kx ky kz la lb lc ld le lf km lg kn lh kp li kq lj ks lk kt ll lm bi translated">下一步是什么？</h1><p id="a98d" class="pw-post-body-paragraph ln lo jg lp b lq lr kh ls lt lu kk lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在这篇文章中，我们看到</p><ul class=""><li id="76b9" class="mz na jg lp b lq mj lt mk lw nb ma nc me nd mi ne nf ng nh bi translated">我们如何构造一个 Python 类</li><li id="7c3e" class="mz na jg lp b lq ni lt nj lw nk ma nl me nm mi ne nf ng nh bi translated">我们如何通过添加<em class="mo">子类</em>来扩展现有的<em class="mo">类</em>。</li></ul><p id="ece1" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下一篇文章中，我们将讨论更多关于<em class="mo">子类</em>的内容，深入<em class="mo">子类</em>的内部，并结合实例讨论 Python 中的<em class="mo">继承</em>。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="7c92" class="pw-post-body-paragraph ln lo jg lp b lq mj kh ls lt mk kk lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp jh">更新</strong>:查看下一篇文章<a class="ae jd" rel="noopener" target="_blank" href="/object-oriented-programming-in-python-inheritance-and-subclass-9c62ad027278">Python 中的面向对象编程——继承和子类</a>。</p></div></div>    
</body>
</html>