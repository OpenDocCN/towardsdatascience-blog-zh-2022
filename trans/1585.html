<html>
<head>
<title>If you are using Python and Google Cloud Platform, this will Simplify Life for you (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果您正在使用Python和Google云平台，这将简化您的生活(第1部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/if-you-are-using-python-and-google-cloud-platform-this-will-simplify-life-for-you-6be4f777fa3a#2022-04-16">https://towardsdatascience.com/if-you-are-using-python-and-google-cloud-platform-this-will-simplify-life-for-you-6be4f777fa3a#2022-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3bc0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Artifact Registry管理您的私有包，并将它们导入您的云功能和云运行服务</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5ac76fa9568bd1a55562349a99acf7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*whqkFfKt-QUHwT_o"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Max van den Oetelaar 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在专业环境中使用python，我可以告诉您，您已经在寻找一种在私有存储库中部署Python包的方法。好吧，让我来介绍一下<a class="ae kv" href="https://cloud.google.com/artifact-registry" rel="noopener ugc nofollow" target="_blank">工件注册</a>，这是<a class="ae kv" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>的工件管理服务，可能正是你所需要的。</p><h2 id="259a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">工件注册解决的3个问题</strong></h2><p id="2784" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设您有一个python类(例如一个日志记录类),它被一个<a class="ae kv" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云函数</a>和一个<a class="ae kv" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云运行</a>服务使用。</p><p id="31fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">实施DRY原则</strong>:如果没有管理python包的解决方案，您最终将部署python类和云函数。同样，您需要部署与云运行服务打包在一起的python类，复制相同的代码片段。工件注册库使您能够通过将python类部署到一个库中，并从云功能和云运行服务中提取该库中的内容，来执行非常重要的DRY(不要重复自己)原则。当您需要修改或修复python类中的任何bug时，这为您提供了一个单一的地方。</p><p id="2463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">部署安全版本</strong> : <strong class="ky ir"> </strong>每次对python类进行更改，都存在破坏云功能和/或云运行服务的风险。我们称之为<strong class="ky ir">回归</strong>。虽然有可能用非回归测试来降低破坏东西的风险，但是这些测试通常是不够的。此外，您会希望用python类的工作版本来精确定位每个版本。精彩！Python工件注册库允许您这样做。</p><p id="14f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">管理对包的访问</strong> : <strong class="ky ir"> </strong>如果你不在乎隐私，也就是说，如果你不介意你的python包被世界上任何人看到和使用，我鼓励你把它们放在<a class="ae kv" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank">公共python库</a>。但是如果您需要控制谁查看您的包，正如在专业环境中经常出现的情况，工件注册库是一个很好的工具，因为它使您能够只与选定的人共享您的库。</p><p id="4a78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说够了！让我们构建一个python工件注册表存储库，在里面部署一些东西，并尝试从云函数中提取存储库。</p><p id="9891" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要的是将私有python包安装到Cloud Composer DAG中，请勾选<a class="ae kv" rel="noopener" target="_blank" href="/if-you-are-using-python-and-google-cloud-platform-this-will-simplify-life-for-you-part-2-bef56354fd4c">这个</a>。</p><h2 id="d1d8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">为您的包创建一个存储库</h2><p id="d246" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设您可以访问<a class="ae kv" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank"> GCP项目</a>和<a class="ae kv" href="https://cloud.google.com/shell" rel="noopener ugc nofollow" target="_blank">云外壳</a>，为python包创建一个存储库是很简单的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><ul class=""><li id="3271" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><em class="nb">&lt;your _ repository _ name&gt;是您要给python库</em>起的名字</li><li id="d2af" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr mx my mz na bi translated"><em class="nb"> &lt;您的存储库位置&gt;是存储库的位置。类似于“美国-中部1”或“欧洲-西部1”的内容</em></li><li id="4ad7" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr mx my mz na bi translated"><em class="nb">&lt;your _ repository _ description&gt;是描述存储库用途或效用的文本</em></li></ul><h2 id="555b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">部署简单的包</h2><p id="26c6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们的存储库已经创建好了，让我们在其中部署一个玩具python包。我们将使用一个包含计算两点间<a class="ae kv" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank">哈弗线距离</a>的函数的库。图书馆可以在这里找到<a class="ae kv" href="https://gitlab.com/marcdjoh/sample-python-package" rel="noopener ugc nofollow" target="_blank">。这是您将库部署到先前创建的工件注册库的方式:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="83b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在克隆了样例包存储库之后，我们构建了一个轮子，并使用python库<strong class="ky ir"><em class="nb">‘twine’</em></strong>将轮子上传到工件注册库。</p><p id="c786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们是如何使用<strong class="ky ir"><em class="nb">【g cloud auth】</em></strong>对gcp账户进行认证的。该过程还在本地保存认证凭证，然后由<strong class="ky ir"><em class="nb">【twine】</em></strong>在上传到工件注册表时使用。</p><h2 id="3ffa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">部署一个从私有Python包中提取的简单云函数</h2><p id="4fe8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在让我们使用我们的库来计算一个<a class="ae kv" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云函数</a>中的哈弗线距离。首先，克隆包含该函数的存储库。其次，激活需要的API。第三，使用<strong class="ky ir"><em class="nb">【g cloud】</em></strong>命令部署云功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d9e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然这是一个安全漏洞，但为了简单起见，我们使用标志<em class="nb"> - allow-unauthenticated </em>来简化函数调用。在真实的场景中，您会希望限制对您的函数的访问，以便只有具有适当权限的客户端才有机会调用它。</p><p id="a19f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是测试的时候了。我们将调用这个函数，看看它是否能像预期的那样工作。</p><p id="b467" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，cloud函数从工件注册中心导入示例包(我们之前部署的包),并使用它来计算两点之间的哈弗线距离。它还将结果记录到<a class="ae kv" href="https://cloud.google.com/logging" rel="noopener ugc nofollow" target="_blank">云日志</a>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fe30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好，那么(1，2)和(3，4)之间的哈弗线距离是多少。为了找到答案，我们调用了云函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="969c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成功执行curl命令后，通过查看函数日志，您应该能够看到哈弗线距离。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/d2ac06110458ca6d303ac17226b515d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXQjQzoYTEIKt_BwPorOug.png"/></div></div></figure><h2 id="a105" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">这里发生了一件神奇的事情</h2><p id="51ba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">至此，我们已经成功地将一个python包部署到工件注册中心，并且我们能够使用一个<em class="nb"> requirements.txt </em>文件从云函数中提取这个包。requirements.txt包含两件事:</p><ol class=""><li id="dc1d" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr ni my mz na bi translated">python工件注册库的URL:<a class="ae kv" href="https://europe-west1-python.pkg.dev/artifact-registry-fct/python-repository/simple/" rel="noopener ugc nofollow" target="_blank"><em class="nb">https://</em></a><em class="nb">&lt;your _ repository _ location&gt;</em><a class="ae kv" href="https://europe-west1-python.pkg.dev/artifact-registry-fct/python-repository/simple/" rel="noopener ugc nofollow" target="_blank"><em class="nb">-python . pkg . dev/&lt;your _ GCP _ project&gt;/</em></a><em class="nb">&lt;your _ repository _ name&gt;</em><a class="ae kv" href="https://europe-west1-python.pkg.dev/artifact-registry-fct/python-repository/simple/" rel="noopener ugc nofollow" target="_blank"><em class="nb">/simple</em></a><em class="nb">/</em></li><li id="e6ad" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr ni my mz na bi translated">python包的名称及其版本:<em class="nb"> mypythonlib==0.2.0 </em></li></ol><p id="dbda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们使用<strong class="ky ir"><em class="nb">【g Cloud】</em></strong>命令部署该功能时，会触发<a class="ae kv" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank">云构建</a>服务，并且<strong class="ky ir">会向工件注册表</strong>进行认证以提取包。它使用我们启用云构建API时自动创建的服务帐户来实现这一点。</p><p id="c090" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，云构建服务帐户—<em class="nb">&lt;project_number939016278554@cloudbuild.gserviceaccount.com&gt;</em>拥有从同一个项目中的任何工件注册库提取所需的权限。然而，如果注册中心位于不同的项目中(例如，在一个共享项目中，这是一种常见的设计),如果我们不明确地给予云构建服务帐户在持有注册中心的项目中的<strong class="ky ir"> <em class="nb">工件注册中心阅读器</em> </strong>角色，云功能将不能从注册中心中拉出。</p><h2 id="00ff" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结束注释</h2><p id="b715" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用托管在云运行服务的工件注册表中的私有python包的工作方式非常相似。只需在requirements.txt文件中为<em class="nb"> extra-index-url </em>选项设置正确的值，如果需要的话，给云构建服务帐户工件注册表阅读器角色，就可以了。</p><p id="6e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢你的时间。请在这里找到示例python包<a class="ae kv" href="https://gitlab.com/marcdjoh/sample-python-package" rel="noopener ugc nofollow" target="_blank">的代码，在这里</a>找到google cloud函数<a class="ae kv" href="https://gitlab.com/marcdjoh/cloud-functions-pull-from-artifact-registry" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="ea58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直到下一次写作，拜拜。</p></div></div>    
</body>
</html>