<html>
<head>
<title>One Fill Value Is Not Enough: Preserving Columnar Types When Reindexing DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个填充值是不够的:重新索引数据帧时保留列类型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/one-fill-value-is-not-enough-preserving-columnar-types-when-reindexing-dataframes-3bb3f0572651#2022-07-20">https://towardsdatascience.com/one-fill-value-is-not-enough-preserving-columnar-types-when-reindexing-dataframes-3bb3f0572651#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/359d47a9996add47fce92e6bd1d7210e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXYKXVtuQuDP_c1akUB7Sw.jpeg"/></div></div></figure><p id="a4b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当处理数据帧时，重新索引是很常见的。当数据帧被重新索引时，旧的索引(及其相关值)与新的索引相一致，可能重新排序、收缩或扩展行或列。当重新索引扩展数据帧时，需要新的值来填充新创建的行或列:这些是“填充值”</p><p id="ec76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当使用Pandas重新索引时，通过<code class="fe kw kx ky kz b">fill_value</code>参数，只允许一个值。如果<code class="fe kw kx ky kz b">fill_value</code>的类型与一个或多个列的类型不兼容，则该列将被重新转换为不同的、可能不需要的类型。</p><p id="d66e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，给定一个具有三列类型object、integer和Boolean的DataFrame，缺省情况下，重新索引索引会用NaN填充新行，NaN是一种float类型，它强制将integer列转换为float，将Boolean列转换为object。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="30dd" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; df = pd.DataFrame.from_records((('a', 1, True), ('b', 2, False)), columns=tuple('xyz'))<br/>&gt;&gt;&gt; df<br/>   x  y      z<br/>0  a  1   True<br/>1  b  2  False</span><span id="3cdb" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; df.dtypes.tolist()<br/>[dtype('O'), dtype('int64'), dtype('bool')]</span><span id="99b2" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; df.reindex((1, 0, 2))<br/>     x    y      z<br/>1    b  2.0  False<br/>0    a  1.0   True<br/>2  NaN  NaN    NaN</span><span id="2ff4" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; df.reindex((1, 0, 2)).dtypes.tolist()<br/>[dtype('O'), dtype('float64'), dtype('O')]</span></pre><p id="0858" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">柱状退化通常是有害的。预先存在的柱状类型可能适合数据；仅仅因为重新索引而不必要地更改该类型通常是意想不到的。从一种C级NumPy类型转换到另一种类型，比如从int转换到float，可能是可以忍受的。但是当从C级NumPy类型转换到Python对象数组(object dtypes)时，性能会下降。和熊猫重配的时候，这个问题是没有办法避免的。</p><p id="1b52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StaticFrame 是一个不可变的数据框架库，为这类问题提供了解决方案。在StaticFrame中，替代填充值表示可用于在重新索引、移位和许多其他需要<code class="fe kw kx ky kz b">fill_value</code>参数的操作中保留列类型。对于异构类型列数据的操作，一个填充值是远远不够的。</p><p id="d6ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StaticFrame支持将<code class="fe kw kx ky kz b">fill_value</code>作为单个元素、一个行长度的值列表、一个列标签映射或者一个<code class="fe kw kx ky kz b">FillValueAuto</code>，一个定义类型到值映射的新对象。</p><p id="4ed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有示例都使用Pandas 1.4.3和StaticFrame 0.9.6。导入使用以下惯例:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4ffa" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; import static_frame as sf</span></pre><p id="7381" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过用一个填充值NaN重新索引同一个数据帧，在StaticFrame中重现熊猫的行为。这导致了和熊猫一样的柱状类型。注意，默认情况下，StaticFrame显示每一列的dtype，这使得列类型的退化变得非常明显。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="d4a8" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f = sf.Frame.from_records((('a', 1, True), ('b', 2, False)), columns=tuple('xyz'))<br/>&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x     y       z      &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>0       a     1       True<br/>1       b     2       False<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;int64&gt; &lt;bool&gt;</span><span id="0c3c" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; f.reindex((1, 0, 2), fill_value=np.nan)<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x        y         z        &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>1       b        2.0       False<br/>0       a        1.0       True<br/>2       nan      nan       nan<br/>&lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt;</span></pre><p id="ed7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">避免重新索引时类型退化的一种方法是为每列提供一个填充值。使用StaticFrame，可以为填充值提供一个列表，为每列提供一个值:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="5091" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f.reindex((1, 0, 2), fill_value=['', 0, False])<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x     y       z      &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>1       b     2       False<br/>0       a     1       True<br/>2             0       False<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;int64&gt; &lt;bool&gt;</span></pre><p id="e113" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，可以使用字典来提供列标签到填充值的映射。如果未提供标签，将提供默认值(NaN)。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="3fa9" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f.reindex((1, 0, 2), fill_value={'z':False, 'x':''})<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x     y         z      &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>1       b     2.0       False<br/>0       a     1.0       True<br/>2             nan       False<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;float64&gt; &lt;bool&gt;</span></pre><p id="3ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前面的例子都要求每列有一个显式值，以提供最大的特异性。在许多情况下(尤其是对于较大的数据帧)，需要一种更通用的方式来指定填充值。</p><p id="dde8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种选择是基于特定的NumPy数据类型映射填充值。这种方法被拒绝，因为NumPy dtype定义了一个以字节为单位的变量“itemsize ”,导致了大量可能的NumPy dtype。更有可能的是，相同的填充值将用于独立于itemsize的dtypes族；例如，所有大小的整数(int8、int16、int32和int64)。</p><p id="82be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了识别与大小无关的类型族，我们可以使用dtype“kind”。NumPy dtypes有一个独立于dtype itemsize的“kind”属性:例如，int8、int16、int32和int64 dtypes都被标记为kind“I”。如下所示，有11种数据类型，每种都有一个字符标签:</p><ul class=""><li id="bd1c" class="lq lr iq ka b kb kc kf kg kj ls kn lt kr lu kv lv lw lx ly bi translated">布尔</li><li id="ca0e" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">i: int</li><li id="e1b8" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">u: uint</li><li id="70a5" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">外宾:浮动</li><li id="34d7" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">丙:复杂</li><li id="e852" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">男:时差</li><li id="71ac" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">m:日期时间</li><li id="092b" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">o:反对</li><li id="57db" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">s:字节</li><li id="eba9" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">U: str</li><li id="b252" class="lq lr iq ka b kb lz kf ma kj mb kn mc kr md kv lv lw lx ly bi translated">v:无效</li></ul><p id="ef66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为每种数据类型指定一个填充值提供了一种方便的方法来避免列类型强制，同时不需要为每列指定一个繁琐的规范。为此，StaticFrame引入了一个新对象:<code class="fe kw kx ky kz b">FileValueAuto</code>。</p><p id="edd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用类<code class="fe kw kx ky kz b">FillValueAuto</code>作为填充值为所有dtype类型提供了无类型强制的缺省值。如果需要不同的映射，可以创建一个<code class="fe kw kx ky kz b">FillValueAuto</code>实例，为每种数据类型指定一个填充值。</p><p id="49d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到前面的重新索引示例，我们看到了使用<code class="fe kw kx ky kz b">FillValueAuto</code>类的便利，并且所有列类型都被保留:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="a55e" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x     y       z      &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>0       a     1       True<br/>1       b     2       False<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;int64&gt; &lt;bool&gt;</span><span id="1e71" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; f.reindex((1, 0, 2), fill_value=sf.FillValueAuto)<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x     y       z      &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>1       b     2       False<br/>0       a     1       True<br/>2             0       False<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;int64&gt; &lt;bool&gt;</span></pre><p id="c863" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们需要偏离提供的<code class="fe kw kx ky kz b">FillValueAuto</code>缺省值，可以创建一个实例，指定每种数据类型的填充值。初始化器的关键字参数是单字符数据类型种类标签。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="a069" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f.reindex((1, 0, 2), fill_value=sf.FillValueAuto(U='x', i=-1, b=None))<br/>&lt;Frame&gt;<br/>&lt;Index&gt; x     y       z        &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>1       b     2       False<br/>0       a     1       True<br/>2       x     -1      None<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;int64&gt; &lt;object&gt;</span></pre><p id="2160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在StaticFrame中，几乎在任何需要填充值的地方，都接受相同数量的填充值类型。例如，在移位数据中，必须提供填充值；但是当移动异构类型的整个数据帧时，一个填充值是不够的。如下所示，默认的<code class="fe kw kx ky kz b">fill_value</code>，NaN，强制所有列类型要么是object要么是float。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="7b56" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f = sf.Frame.from_records((('a', 1, True, 'p', 23.2), ('b', 2, False, 'q', 85.1), ('c', 3, True, 'r', 1.23)), columns=tuple('abcde'))</span><span id="8b32" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; f.shift(2)<br/>&lt;Frame&gt;<br/>&lt;Index&gt; a        b         c        d        e         &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>0       nan      nan       nan      nan      nan<br/>1       nan      nan       nan      nan      nan<br/>2       a        1.0       True     p        23.2<br/>&lt;int64&gt; &lt;object&gt; &lt;float64&gt; &lt;object&gt; &lt;object&gt; &lt;float64&gt;</span></pre><p id="4ab6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和以前一样，使用一个<code class="fe kw kx ky kz b">FillValueAuto</code>实例允许一个通用的填充值规范，它完全避免了列类型的退化。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="da7c" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f.shift(2, fill_value=sf.FillValueAuto(U='', b=False, f=0, i=0))<br/>&lt;Frame&gt;<br/>&lt;Index&gt; a     b       c      d     e         &lt;&lt;U1&gt;<br/>&lt;Index&gt;<br/>0             0       False        0.0<br/>1             0       False        0.0<br/>2       a     1       True   p     23.2<br/>&lt;int64&gt; &lt;&lt;U1&gt; &lt;int64&gt; &lt;bool&gt; &lt;&lt;U1&gt; &lt;float64&gt;</span></pre><p id="9573" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在二元运算符的许多应用中也需要填充值。一般来说，对带标签的数据进行二元运算会强制操作数重新索引到联合索引，这可能会引入缺失值。如果缺少的值仅为NaN，则可能会重新转换生成的列类型。</p><p id="fe6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，给定两个数据帧，每个数据帧都有一个float和一个integer列，二元运算将为重新索引的值引入NaN，将integer列强制转换为float。这可以通过使用<code class="fe kw kx ky kz b">FillValueAuto</code>在StaticFrame中避免。</p><p id="22c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于二元操作符不接受参数，StaticFrame提供了<code class="fe kw kx ky kz b">via_fill_value</code>接口，允许在二元操作中需要重新索引时指定要使用的填充值。这类似于熊猫<code class="fe kw kx ky kz b">DataFrame.multiply()</code>和相关方法提供的功能。有了StaticFrame的<code class="fe kw kx ky kz b">via_fill_value</code>，我们可以继续使用任意二元运算符的表达式。</p><p id="937e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当将两个数据帧相乘时，每个数据帧都有一列浮点数和一列整数，由于重新索引而引入的nan会将所有值强制转换为浮点数。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="45ad" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f1 = sf.Frame.from_records(((10.2, 20), (2.4, 4)), index=('a', 'b'))<br/>&gt;&gt;&gt; f2 = sf.Frame.from_records(((3.4, 1), (8.2, 0)), index=('b', 'c'))</span><span id="bf48" class="li lj iq kz b gy lo ll l lm ln">&gt;&gt;&gt; f1 * f2<br/>&lt;Frame&gt;<br/>&lt;Index&gt; 0         1         &lt;int64&gt;<br/>&lt;Index&gt;<br/>a       nan       nan<br/>b       8.16      4.0<br/>c       nan       nan<br/>&lt;&lt;U1&gt;   &lt;float64&gt; &lt;float64&gt;</span></pre><p id="73c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用<code class="fe kw kx ky kz b">via_fill_value</code>和<code class="fe kw kx ky kz b">FillValueAuto</code>，我们可以保留列类型，即使需要重新索引，并且继续在表达式中使用二元运算符。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4fb8" class="li lj iq kz b gy lk ll l lm ln">&gt;&gt;&gt; f1.via_fill_value(sf.FillValueAuto) * f2<br/>&lt;Frame&gt;<br/>&lt;Index&gt; 0         1       &lt;int64&gt;<br/>&lt;Index&gt;<br/>a       nan       0<br/>b       8.16      4<br/>c       nan       0<br/>&lt;&lt;U1&gt;   &lt;float64&gt; &lt;int64&gt;</span></pre><p id="c35a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面使用的只有几列的例子并没有完全展示出<code class="fe kw kx ky kz b">FillValueAuto</code>的威力:当处理成百上千列的异构类型数据帧时，规范的通用性提供了一个简洁而强大的工具。</p><p id="a605" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由重新索引或其他转换导致的无意类型强制的成本可能会导致错误或性能下降。StaticFrame灵活的填充值类型，以及新的<code class="fe kw kx ky kz b">FillValueAuto</code>，为这些实际问题提供了解决方案。</p></div></div>    
</body>
</html>