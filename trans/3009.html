<html>
<head>
<title>5 Most Useful SQL Best Practices You Should Follow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该遵循的5个最有用的SQL最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-most-useful-sql-best-practices-you-should-follow-ef753a50ad26#2022-07-01">https://towardsdatascience.com/5-most-useful-sql-best-practices-you-should-follow-ef753a50ad26#2022-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="55f0" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><div class=""><h2 id="4e2e" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">避免经常犯的错误以改进您的代码</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c2118e28d24614c66c01231666ef5c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-fVilJ9ZFBZZOh4HaMgnA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@alexlionco?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历克斯·莱昂</a>在<a class="ae lh" href="https://unsplash.com/collections/3381514/it%27s-about-time?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c48c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">SQL——所有数据专业人员最重要的技能之一！</strong>🏆</p><p id="4cf1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">考虑到SQL中庞大的命令集，有多种方法可以获得所需的结果数据集。然而，重要的是要知道并实现有效的、计算成本低的方法来实现你的目标。</p><p id="7e79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我在这里列出了作为数据专业人员应该知道的编写SQL查询的5个最佳实践。</p><p id="d52a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我把这篇文章写得很短，这样你就可以很快地完成它，并掌握节省时间、编写SQL查询的正确方法。🏆</p><p id="dea5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用此索引快速导航到您最喜欢的部分。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="ed23" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">· </strong><a class="ae lh" href="#7ac8" rel="noopener ugc nofollow"><strong class="mf jd">Prefer using specific column names in SELECT</strong></a><strong class="mf jd"><br/>· </strong><a class="ae lh" href="#8bcf" rel="noopener ugc nofollow"><strong class="mf jd">Use WHERE and HAVING wisely</strong></a><strong class="mf jd"><br/>· </strong><a class="ae lh" href="#1db3" rel="noopener ugc nofollow"><strong class="mf jd">Prioritize using SQL JOINs over WHERE </strong></a><strong class="mf jd"><br/>· </strong><a class="ae lh" href="#669f" rel="noopener ugc nofollow"><strong class="mf jd">Select unique records without using DISTINCT</strong></a><strong class="mf jd"><br/>· </strong><a class="ae lh" href="#bc5d" rel="noopener ugc nofollow"><strong class="mf jd">Use LIKE for filtering the dataset Rows</strong></a></span></pre><blockquote class="mp mq mr"><p id="a7c4" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated">📍注意:我使用的是SQLite DB浏览器&amp;自己创建的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank"> Dummy_Sales_Data </a>使用<a class="ae lh" rel="noopener" target="_blank" href="/faker-an-amazing-and-insanely-useful-python-library-b313a60bdabf"> <strong class="lk jd"> Faker </strong> </a>创建的，你可以在我的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Github </strong> </a> repo下免费获得<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/LICENSE.md" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> MIT许可</strong> </a> <strong class="lk jd">！</strong></p></blockquote><p id="67b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，我们开始吧…🚀</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="7ac8" class="nd mk it bd ne nf ng nh ni nj nk nl nm ki nn kj no kl np km nq ko nr kp ns nt bi translated">首选在SELECT中使用特定的列名</h1><p id="6f01" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">从数据库的特定表中检索所有数据的最常见和最简单的方法是<code class="fe nz oa ob mf b">SELECT *</code>。但是，当您试图从一个拥有数十亿行、占用100s GBs数据的数据集中提取数据时，这将是最昂贵的方法。</p><p id="0f08" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在现实世界中，数据集中的所有列很少对特定任务有用。因此，在SELECT语句中传递所需的列名更有意义。</p><p id="a5fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，当您需要虚拟销售数据集中的订单ID、数量和状态列时，<code class="fe nz oa ob mf b">SELECT * FROM Dummy_Sales_Data_v1</code>将生成包含数据集所有行和列的输出。</p><p id="e377" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，你只需要三列，这意味着其他由<code class="fe nz oa ob mf b">SELECT *</code>提取的信息对你的任务没有用。</p><p id="960e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，当你使用正确的方法时，</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="9796" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">SELECT OrderID,<br/>       Quantity,<br/>       Status</strong><br/>FROM Dummy_Sales_Data_v1</span></pre><p id="8b67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将仅获得任务所需的信息，如下所示</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6497c879820be0d2e19e0fbcefca9650.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*_qKH-U6Pg43Nxs-UgQy1Ag.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按作者选择SQL | Image中的列名</p></figure><p id="3a07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我看来，以下是您不应该使用SELECT *的5个原因</p><p id="cb6a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸<strong class="lk jd">SQL联接的复杂性:</strong> <br/>当JOIN语句中的两个表具有相同的列名时，在联接中使用SELECT *可能会在列名之间引入歧义。</p><p id="6388" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸<strong class="lk jd">失去透明性:</strong> <br/> SELECT *无法让您的SQL查询读者知道您要从哪些列获取数据。</p><p id="fb16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸<strong class="lk jd">增加的网络流量:</strong> <br/> SELECT *返回的数据量肯定会超过您的任务需求，而且这不是免费的。您的数据库和网络正在遭受损失，因为它们正在处理所有的数据。</p><p id="e843" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸<strong class="lk jd">内存消耗增加:</strong> <br/>由于处理超过所需的数据会不必要地增加内存消耗。当您在单个计算集群上与一组专业人员一起工作时，这可能会特别成问题。</p><p id="6bc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸<strong class="lk jd">数据复制不正确:</strong> <br/>将数据从一个表复制到另一个表的常用方法之一是在INSERT语句中使用SELECT。当使用SELECT *而不是特定列时，如果两个表中的列顺序不同，可能会将不正确的数据复制到新表中。</p><p id="5f42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终，<strong class="lk jd"> <em class="ms">选择*是不好的做法，必须避免</em> </strong>。相反，使用特定的列名来编写一个易于阅读、易于调试、节省时间和内存的查询。💯</p><p id="e16f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，我们讨论一下为什么理解WHERE和HAVING子句的区别很重要。</p><h1 id="8bcf" class="nd mk it bd ne nf od nh ni nj oe nl nm ki of kj no kl og km nq ko oh kp ns nt bi translated">明智地使用和拥有</h1><p id="1790" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">这两个子句在SQL中用于逻辑过滤数据。然而，他们在工作中有一点小小的不同。</p><p id="bc99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nz oa ob mf b"><strong class="lk jd">WHERE</strong></code>子句用于根据其中提到的条件选择记录，而<code class="fe nz oa ob mf b"><strong class="lk jd">HAVING</strong></code>子句用于根据一列或多列的聚合从组中选择记录。这就是为什么<code class="fe nz oa ob mf b">HAVING</code>出现在<code class="fe nz oa ob mf b">GROUP BY</code>子句之后，它本质上是对行进行分组。</p><p id="4047" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，与<code class="fe nz oa ob mf b">WHERE</code>子句不同，您可以在<code class="fe nz oa ob mf b">HAVING</code>子句中使用任何聚合函数，比如sum、min、max。</p><p id="a239" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，有时编码人员会像下面这样互换使用它们，</p><p id="5f53" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">❌坏方法——使用<code class="fe nz oa ob mf b">HAVING</code>过滤使用非聚集列的记录</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="8aa3" class="mj mk it mf b gy ml mm l mn mo">SELECT OrderID,<br/>       Quantity,<br/>       Status<br/>FROM Dummy_Sales_Data_v1<br/>GROUP BY OrderID, Quantity, Status<br/><strong class="mf jd">HAVING Quantity = 100</strong><br/>AND Status LIKE 'Shipped'<br/>AND Shipping_Cost &gt; 30</span></pre><p id="d9fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">✅最佳方式——使用<code class="fe nz oa ob mf b">WHERE</code>过滤使用非聚集列的记录</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="8abd" class="mj mk it mf b gy ml mm l mn mo">SELECT OrderID,<br/>       Quantity,<br/>       Status<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mf jd">WHERE Quantity = 100</strong><br/>AND Status LIKE 'Shipped'<br/>AND Shipping_Cost &gt; 30</span></pre><p id="7bb4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上述两个查询返回如下相同输出:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/e04eb2bbfc2460d63167c5797cdef363.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*flP9sOcRZ97KiAaQxeWs8w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">WHERE和HAVING | Image by Author的输出相同</p></figure><p id="ffe1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，人们应该始终考虑SQL操作的执行顺序。</p><p id="e79e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如前面提到的<a class="ae lh" href="https://www.sisense.com/blog/sql-query-order-of-operations/" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Sisense </strong> </a>，<br/> <strong class="lk jd"> <em class="ms">在哪里被执行</em> </strong> <strong class="lk jd"> <em class="ms">在分组前被</em> </strong>查询。这意味着，<code class="fe nz oa ob mf b">WHERE</code>在对行进行分组或聚合列计算之前选择行。</p><p id="1bd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">并且，<strong class="lk jd"> <em class="ms"> HAVING是在GROUP BY </em> </strong>子句之后执行的，意思是在对分组后的行执行了聚集函数之后选择行。</p><p id="23f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是为什么<em class="ms">是前置过滤器</em>而<em class="ms">是后置过滤器</em>的原因。<br/>所以，<code class="fe nz oa ob mf b"><strong class="lk jd">WHERE</strong></code> <strong class="lk jd">会更快。</strong></p><p id="86d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你的任务可以通过<code class="fe nz oa ob mf b">WHERE</code>从句完成，那么我会建议不要用<code class="fe nz oa ob mf b">HAVING</code>代替<code class="fe nz oa ob mf b">WHERE</code>。</p><p id="fe9d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您想要基于一些列聚合来选择行时,<code class="fe nz oa ob mf b">HAVING</code>绝对是最佳解决方案。</p><p id="01ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，另一个常犯的错误是使用WHERE连接两个表，这在SQL中不是好的做法。下面我们来详细讨论一下。</p><h1 id="1db3" class="nd mk it bd ne nf od nh ni nj oe nl nm ki of kj no kl og km nq ko oh kp ns nt bi translated">优先使用SQL连接</h1><p id="9eeb" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">在SQL中，<code class="fe nz oa ob mf b">JOIN</code>子句用于根据多个表之间的相关列组合这些表中的行，而<code class="fe nz oa ob mf b">WHERE</code>子句用于根据其中提到的条件选择行。</p><p id="e23f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，有时data professional使用<code class="fe nz oa ob mf b">WHERE</code>子句从两个表中选择行，此时某个列及其值同时出现在两个表中。</p><p id="5774" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看一个简单的例子。</p><p id="8f98" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我们创建两个<a class="ae lh" rel="noopener" target="_blank" href="/5-advanced-sql-concepts-you-should-know-in-2022-b50efe6c99"><strong class="lk jd">cte或公共表表达式</strong> </a>订单和价格。然后我们可以看到如何从两个表中选择行。(<em class="ms">当您已经有两个表</em>时，绝对不需要这一步)</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="152c" class="mj mk it mf b gy ml mm l mn mo">WITH orders AS<br/>(<br/>SELECT OrderID,<br/>       Product_Category,<br/>       Quantity<br/>FROM Dummy_Sales_Data_v1<br/>WHERE Quantity = 100<br/>AND Status LIKE 'Shipped'<br/>AND Product_Category LIKE 'Healthcare'<br/>),</span><span id="3b28" class="mj mk it mf b gy oj mm l mn mo">prices AS<br/>(<br/>SELECT OrderID,<br/>       UnitPrice,<br/>       Shipping_Cost,<br/>       Shipping_Address<br/>FROM Dummy_Sales_Data_v1<br/>WHERE Quantity = 100<br/>AND Product_Category LIKE 'Healthcare'<br/>)</span></pre><p id="e225" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们从订单ID匹配的两个表中选择所有的行和列—订单ID、产品类别、数量、单价。</p><p id="e526" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">❌不好的做法你应该避免</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="3e97" class="mj mk it mf b gy ml mm l mn mo">SELECT orders.OrderID,<br/>       orders.Product_Category,<br/>       orders.Quantity,<br/>       prices.UnitPrice<br/>FROM orders, prices<br/><strong class="mf jd">WHERE orders.OrderID = prices.OrderID</strong></span></pre><p id="afd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，<code class="fe nz oa ob mf b">WHERE</code>子句自动充当<code class="fe nz oa ob mf b">INNER JOIN</code>，这意味着您正在执行join而没有显式地提及JOIN子句。所以，这里的<code class="fe nz oa ob mf b"><strong class="lk jd">WHERE</strong></code> <strong class="lk jd"> </strong>就变成了<strong class="lk jd"> </strong>的隐式连接。</p><p id="6b75" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这导致可读性和理解性差。</p><p id="fe84" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，显式连接才是正确的方式，比如显式地提到连接的类型，比如— <code class="fe nz oa ob mf b">LEFT JOIN</code>、<code class="fe nz oa ob mf b">RIGHT JOIN</code>、<code class="fe nz oa ob mf b">INNER JOIN </code>。这样，您的查询可读性更好，也更容易理解。💯</p><p id="87e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它还为您提供了更多的灵活性来选择您想要执行的连接操作的类型——左连接或右连接——而<code class="fe nz oa ob mf b">WHERE</code>子句不需要。</p><p id="bd02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">✅是你应该遵循的好习惯。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="6400" class="mj mk it mf b gy ml mm l mn mo">SELECT orders.OrderID,<br/>       orders.Product_Category,<br/>       orders.Quantity,<br/>       prices.UnitPrice<br/>FROM orders<br/><strong class="mf jd">INNER JOIN prices<br/>ON orders.OrderID = prices.OrderID</strong></span></pre><p id="c99d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个查询都检索相同结果集，如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/261bf60133d51f15968ab57021910d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*JzVNXK4BxLbGZ4P-4wpJcA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SQL联接-隐式和显式|作者图片</p></figure><p id="c059" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，您可以将两个表组合在一个公共列上，并将所有条件选择的行放在<code class="fe nz oa ob mf b">JOIN</code>子句之后的<code class="fe nz oa ob mf b">WHERE</code>子句上。</p><p id="5ac4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据我的经验，使用<code class="fe nz oa ob mf b">JOIN</code>而不是<code class="fe nz oa ob mf b">WHERE</code>子句的主要优点是—</p><p id="6aa4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸SQL联接使您能够控制扫描和联接表的顺序</p><p id="5a57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸使用显式连接编写的查询易于阅读、理解和修改，因为<code class="fe nz oa ob mf b">JOIN</code>标准与<code class="fe nz oa ob mf b">WHERE</code>子句保持分离。</p><p id="62d9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🔸在编写查询时，在FROM子句中提到表名后，您很容易忘记<code class="fe nz oa ob mf b">WHERE</code>子句，而在JOIN criteria中却不是这样。当你想合并两个表格时，你肯定会在<code class="fe nz oa ob mf b">FROM</code>后使用<code class="fe nz oa ob mf b">JOIN</code>。</p><p id="40da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，显式总是比隐式好，因为它更容易理解和维护。💯</p><p id="523c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，让我们讨论DISTINCT从表中选择唯一记录的最佳替代方法。</p><h1 id="669f" class="nd mk it bd ne nf od nh ni nj oe nl nm ki of kj no kl og km nq ko oh kp ns nt bi translated">选择不使用DISTINCT的唯一记录</h1><p id="cfc7" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">每当您需要从数据库中提取唯一的记录时，一个简单的答案就是使用<code class="fe nz oa ob mf b"><strong class="lk jd">DISTINCT</strong></code>！！</p><p id="fbfa" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，<code class="fe nz oa ob mf b">DISTINCT</code>可能很昂贵，因为它不会告诉您所使用的连接和过滤器是正确的还是不正确的，而这实际上是重复的原因。</p><p id="84da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只要您想从单个列中选择唯一的值，<code class="fe nz oa ob mf b">DISTINCT</code>就能很好地工作。但是，当你想选择唯一的行(多列的组合)时，<code class="fe nz oa ob mf b"><strong class="lk jd">GROUP BY</strong></code>是最好的选择。💯</p><p id="b58e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，从我们的数据集中选择销售经理、送货地址和运费的唯一行。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="547e" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd"><em class="ms">-- </em></strong><em class="ms">Using</em><strong class="mf jd"><em class="ms"> DISTINCT</em></strong></span><span id="d27d" class="mj mk it mf b gy oj mm l mn mo">SELECT <strong class="mf jd">DISTINCT</strong> Sales_Manager,<br/>                Shipping_Address,<br/>                Shipping_Cost<br/>FROM Dummy_Sales_Data_v1<br/>WHERE Status LIKE 'Shipped'<br/>AND Product_Category LIKE 'Healthcare'</span><span id="343a" class="mj mk it mf b gy oj mm l mn mo"><br/><strong class="mf jd"><em class="ms">-- </em></strong><em class="ms">Using</em><strong class="mf jd"><em class="ms"> GROUP BY</em></strong></span><span id="8255" class="mj mk it mf b gy oj mm l mn mo">SELECT Sales_Manager,<br/>       Shipping_Address,<br/>       Shipping_Cost<br/>FROM Dummy_Sales_Data_v1<br/>WHERE Status LIKE 'Shipped'<br/>AND Product_Category LIKE 'Healthcare'<br/><strong class="mf jd">GROUP BY</strong> Sales_Manager, <br/>         Shipping_Address, <br/>         Shipping_Cost</span></pre><p id="1969" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个查询返回完全相同的行</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/8f946de760a02d137208ccf4eddd3cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*XhbLTRyu5OyIJuhEgcnQ5g.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用DISTINCT和GROUP BY | Image by Author选择唯一记录</p></figure><p id="6783" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于在这个查询中没有提到任何复杂的join语句，并且数据集与商业数据集相比也很小，所以两个查询具有相同的性能。</p><p id="41f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，几乎90%的时候，我发现<code class="fe nz oa ob mf b">GROUP BY</code>更方便，因为我总是想使用集合函数做一些其他的计算，这可以使用<code class="fe nz oa ob mf b">GROUP BY</code>来完成。</p><p id="b43b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了GROUP BY之外，还有3种最好的方法可以在不使用DISTINCT的情况下获得唯一的记录。</p><blockquote class="om"><p id="4210" class="on oo it bd op oq or os ot ou ov md dk translated">UNION()、INTERSECT() &amp; ROW_NUMBER()</p></blockquote><p id="0f98" class="pw-post-body-paragraph li lj it lk b ll ow kd ln lo ox kg lq lr oy lt lu lv oz lx ly lz pa mb mc md im bi translated">在我的上一篇文章中，了解更多关于在SQL中寻找唯一记录的3种终极方法。</p><div class="pb pc gp gr pd pe"><a rel="noopener follow" target="_blank" href="/3-ultimate-ways-to-find-unique-records-in-sql-6ddf8ae567b0"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd jd gy z fp pj fr fs pk fu fw jc bi translated">在SQL中查找唯一记录的3种终极方法</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">停止使用DISTINCT！开始使用这些快速的替代方法来避免混淆！</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">towardsdatascience.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps lb pe"/></div></div></a></div><p id="ca17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，让我们讨论如何使用SQL的内置特性(如索引)来提高查询性能。</p><h1 id="bc5d" class="nd mk it bd ne nf od nh ni nj oe nl nm ki of kj no kl og km nq ko oh kp ns nt bi translated">使用LIKE筛选数据集行</h1><p id="c457" class="pw-post-body-paragraph li lj it lk b ll nu kd ln lo nv kg lq lr nw lt lu lv nx lx ly lz ny mb mc md im bi translated">过滤行最常见的方法是使用数学表达式，如<code class="fe nz oa ob mf b"><strong class="lk jd">=</strong></code>、<code class="fe nz oa ob mf b"><strong class="lk jd">&gt;</strong></code>等等。然而，它们会生成布尔值——真或假<em class="ms">——并且只选择那些表达式为<code class="fe nz oa ob mf b">TRUE</code>的行。</em></p><p id="0194" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个过程很慢，因为它不使用SQL索引，而SQL索引是一种与表相关联的磁盘结构，可以加快从表中检索行的速度。</p><p id="7cc1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据<a class="ae lh" href="https://docs.microsoft.com/en-us/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver16" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">微软</strong> </a>，</p><blockquote class="mp mq mr"><p id="e84d" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated">索引包含从表或视图中的一列或多列构建的键。这些键存储在一个结构(B树)中，该结构使SQL Server能够快速有效地找到与键值关联的一行或多行。</p></blockquote><p id="bb26" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些表达式的快速替代方法是使用像<code class="fe nz oa ob mf b"><strong class="lk jd">LIKE</strong></code>这样的操作符。</p><p id="cb87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，当你需要对数值或聚合值使用过滤器时，这并不是一个好的选择。</p><p id="ece6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，对于文本值，您总是可以使用LIKE运算符。💯</p><p id="235a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，让我们检索数据集的所有行，其中产品类别为“医疗保健”，状态为“已发货”</p><p id="f0b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">❌的不良做法是，</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="e9a8" class="mj mk it mf b gy ml mm l mn mo">SELECT OrderID, <br/>        Product_Category,<br/>        Status<br/>FROM Dummy_Sales_Data_v1<br/>WHERE Product_Category <strong class="mf jd">=</strong> 'Healthcare'<br/>AND Status <strong class="mf jd">=</strong> 'Shipped'</span></pre><p id="7c67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">✅的良好做法是，</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="fda6" class="mj mk it mf b gy ml mm l mn mo">SELECT OrderID, <br/>        Product_Category,<br/>        Status<br/>FROM Dummy_Sales_Data_v1<br/>WHERE Product_Category <strong class="mf jd">LIKE</strong> 'Healthcare'<br/>AND Status <strong class="mf jd">LIKE</strong> 'Shipped'</span></pre><p id="77d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，即使您不知道要比较的确切文本值，也可以在LIKE运算符中使用通配符。</p><p id="4b18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我推荐阅读2022年 你应该知道的<a class="ae lh" rel="noopener" target="_blank" href="/5-practical-sql-queries-you-should-know-in-2022-11b428560a30#4750"> <strong class="lk jd"> 5个实用SQL查询，深入了解如何使用LIKE运算符。</strong></a></p><p id="cf1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅此而已！</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="5153" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你很快完成这篇文章，并发现它对提高SQL技能很有用。</p><p id="4f33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">过去3年来，我一直在使用SQL，并通过经验找到了这些最佳实践。此外，这些实践在数据科学工作面试中也会得到间接测试。采用它们肯定会为您的SQL技能增加更多价值。</p><blockquote class="om"><p id="ebf9" class="on oo it bd op oq or os ot ou ov md dk translated">对阅读媒体上的无限故事感兴趣？？</p></blockquote><p id="f501" class="pw-post-body-paragraph li lj it lk b ll ow kd ln lo ox kg lq lr oy lt lu lv oz lx ly lz pa mb mc md im bi translated">💡考虑<a class="ae lh" href="https://medium.com/@17.rsuraj/membership" rel="noopener"> <strong class="lk jd">成为媒体会员</strong> </a>到<strong class="lk jd">访问媒体上无限的</strong>故事和每日有趣的媒体文摘。我会得到你的费用的一小部分，没有额外的费用给你。</p><p id="47c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">💡请务必<a class="ae lh" href="https://medium.com/subscribe/@17.rsuraj" rel="noopener"> <strong class="lk jd">注册我的电子邮件列表</strong> </a> <strong class="lk jd">和800+其他</strong>千万不要错过另一篇关于数据科学指南、技巧和提示、SQL和Python的文章。</p><p id="7a36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">感谢您的阅读！</strong></p></div></div>    
</body>
</html>