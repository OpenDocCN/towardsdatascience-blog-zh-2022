<html>
<head>
<title>A highly anticipated Time Series Cross-validator is finally here</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">备受期待的时间序列交叉验证器终于来了</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-highly-anticipated-time-series-cross-validator-is-finally-here-7dc99f672736#2022-11-01">https://towardsdatascience.com/a-highly-anticipated-time-series-cross-validator-is-finally-here-7dc99f672736#2022-11-01</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="4e99" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">不均匀分布的时间序列数据不再是交叉验证的问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/3b3e93d0190d7cd9abd9f530a8802789.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XN9WIpMRKLJ8IBBF"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kz" href="https://unsplash.com/@max_thehuman?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max bhme</a>拍摄的照片</p></figure><p id="d51c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">交叉验证是训练机器学习模型的数据科学家经常使用的方法。探究使用交叉验证的原因超出了本文的范围，但是可以找到许多关于它的好文章，例如<a class="ae kz" rel="noopener" target="_blank" href="/cross-validation-430d9a5fee22">这篇文章</a>。</p><p id="6bf0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是用<code class="fe lw lx ly lz b">kfold=4</code>进行简单交叉验证划分的图示。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/3dfc0b77aaea74767f5054787585f96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*Q3wtbXaIAqDII4--cXokRg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[作者插图]</p></figure><p id="88c4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在时间序列问题中，我们不能使用这种标准的交叉验证划分。在大多数时间序列问题中，您希望训练数据在测试数据之前，否则，您将使用未来数据来预测过去。因此，为每次迭代划分训练和测试折叠的常用技术如下:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/2693334d02a81aa9997343b6250d3255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*OmXXg140ZEHqOy1ApbyqpQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[作者插图]</p></figure><p id="993a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Scikit-learn的<code class="fe lw lx ly lz b">TimeSeriesSplit</code>正在拆分数据，如上图所示。</p><p id="bb1d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可能已经注意到，现在数据被分成了五份，而不是四份，尽管<em class="mb"> kfold </em>仍然是四份。这是因为我们不能使用第一个折叠作为测试折叠，因为在它之前没有火车折叠。然而，这里出现了更多。训练数据的大小随着每次迭代而增加。这并不总是理想的，因为在时间序列问题中，您可能希望您的模型只学习根据最近的数据进行预测。因此，我们也可以选择创建这样的折叠:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/e30e20230a970d1728c0e6097605f5f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*hwhJ6ljMQUAJa0FVmPbj5w.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[作者插图]</p></figure><p id="d04c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这接近于sktime的T2所做的。</p><p id="482c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">到目前为止还不错，但是如果你的数据集不包含均匀分布的数据呢？</p><p id="5269" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Scikit-learn的<code class="fe lw lx ly lz b">TimeSeriesSplit </code>和sktime的<code class="fe lw lx ly lz b">SlidingWindowSplitter </code>都没有对此进行调整。你可能会像这样结束分裂:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/ff024206b104274a7af19bec2a787662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*6D6aitWm3rs3Y1Pb1PScpA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[作者插图]</p></figure><p id="7985" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">到目前为止，您必须编写自己的交叉验证器来解决时间序列问题中数据分布不均匀的问题，这不是一件小事。随着<a class="ae kz" href="https://scikit-lego.netlify.app/" rel="noopener ugc nofollow" target="_blank"> Scikit-lego </a>发布<code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>，我们终于可以利用开源代码来实现这一点了！</p><p id="d941" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们通过一个例子来说明时间序列数据分布不均匀的问题以及<code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>如何缓解这个问题:</p><h1 id="32a5" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">狼的崛起</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mu"><img src="../Images/a5744ae2daa7aded1530775e17d0a959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*umBrw18k5E4s3JTv"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@rayhennessy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷·轩尼诗</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="c09b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">狼在欧洲又开始抬头了。它正从东欧稳步蔓延到整个欧洲大陆。让我们考虑下面的假设情况:</p><p id="64ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">1980年，一个组织开始联系公园管理员，打电话问他们那天是否在公园里看到了狼。他们记录每年公布的数据。随着技术的进步，该组织开始使用更现代的技术来联系更多的公园管理员，从短信到2010年以来完全开发的应用程序。因此，他们收集的数据量会随着时间的推移而增加。此外，随着狼在欧洲的扩张，看到狼的机会也在增加。</p><p id="cd91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这为我们提供了以下<a class="ae kz" href="https://github.com/sTomerG/GroupTimeSeriesSplit/blob/main/wolf_train.csv" rel="noopener ugc nofollow" target="_blank">数据集</a>:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj mv"><img src="../Images/33105bbeab071fc8c2209f5e2afed2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdMH_5Mw8nGmL5GzIgLvfA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[作者提供的图表]</p></figure><p id="cf91" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个数据集跨越了40年。从1980年到2019年。假设我们想使用kfold与<code class="fe lw lx ly lz b">k=4</code>交叉验证来训练一个模型，该模型可以预测公园管理员是否会在特定的一天看到狼。现在，我们不能简单地把40年分成8年的5倍，因为那会导致这些倍:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/ff024206b104274a7af19bec2a787662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*6D6aitWm3rs3Y1Pb1PScpA.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">当每列火车或测试装置有8年时折叠。[作者插图]</p></figure><p id="2237" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除此之外，每个折叠都有非常不同的大小，我们总是有一个比训练集大得多的测试集，这对于训练和测试模型来说几乎从来都不是首选的。计算如何在每个折叠中划分年份以获得尽可能相等大小的折叠可能需要我们检查所有选项(所谓的<em class="mb">蛮力</em>方法)。对于40年和5个折叠(当<code class="fe lw lx ly lz b">kfold=4</code>时是必要的)已经有658.008种不同的可能性来在折叠上划分年份，同时保持时间顺序。不同组合的金额可以用<em class="mb"> n计算！/(n-r)！(r)！</em>其中<em class="mb"> n </em> =组数量(在本例中为唯一年份数量)，而<em class="mb"> r </em> =折叠数量。</p><p id="c9d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://scikit-lego.netlify.app/index.html" rel="noopener ugc nofollow" target="_blank">Scikit-Lego’s</a>s<code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>正在使用一个智能版本的<em class="mb">蛮力，</em>它可以避免检查所有可能的选项。在这种特殊情况下，<code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>没有检查658.008个组合，而是只检查20.349个组合(减少了近97%！)同时仍然得出与检查所有658.008个组合时相同的最佳答案。</p><p id="3b6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面你可以看到如何用Scikit-learn的<code class="fe lw lx ly lz b">GridSearchCV</code>使用<code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>进行网格搜索:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="mw mx l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[作者要点]</p></figure><p id="5944" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>对褶皱的划分如下:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj my"><img src="../Images/922785d4dedf3c267a8282008188e2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpvPaO19tsI_NS_Oln2lIQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">[图片由作者提供]</p></figure><p id="b8c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">图形看起来是这样的:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ma"><img src="../Images/66ec2a30ce39d063151c00b5fa0ece00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*e9c3TdaVNxI8l5zx47X8tw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用sklego的GroupTimeSeriesSplit后折叠。[作者插图]</p></figure><p id="f5c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数据现在几乎是均匀分布的，或者说，实际上是尽可能均匀分布的，限制条件是在训练集和测试集中没有相同的年份。因此，我们现在终于可以在组大小不均匀的时间序列问题中使用滑动窗口了。</p><h1 id="902d" class="mc md iu bd me mf mg mh mi mj mk ml mm ka mn kb mo kd mp ke mq kg mr kh ms mt bi translated">结论</h1><p id="36de" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Scitkit-learn和sktime有很好的交叉验证器来解决时间序列问题。然而，当每单位时间的观察数量波动很大时，你可能会以非常不平衡的训练和测试折叠结束。随着scikit-lego发布<code class="fe lw lx ly lz b">GroupTimeSeriesSplit</code>，我们现在有了一个针对这些情况的开箱即用的交叉验证器。</p><p id="946c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文使用的数据和代码可以在<a class="ae kz" href="https://github.com/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="1d40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">点击这里查看我关于数据科学、机器学习和Python <a class="ae kz" href="https://medium.com/@tomergabay" rel="noopener">的其他文章，或者关注我以获得更多关于这些主题的文章！</a></p></div></div>    
</body>
</html>