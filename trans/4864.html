<html>
<head>
<title>Using Function Wrappers for Data Imputation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用函数包装器进行数据插补</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-function-wrappers-for-data-imputation-in-python-c115751669bd#2022-10-28">https://towardsdatascience.com/using-function-wrappers-for-data-imputation-in-python-c115751669bd#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ed8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python Decorators的自定义数据插补方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49422addcc4248d100298be9c123a7cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsM8y3-y4A-I7F9SHN_X5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由乔治·多尔吉克在<a class="ae ky" href="https://www.pexels.com/photo/red-white-and-brown-gift-boxes-1303081/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="c4ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，函数包装器(也称为装饰器)用于修改或扩展现有函数的行为。他们有各种各样的应用程序，包括调试、运行时监控、web开发中的用户登录访问、插件等等。虽然通常应用于软件工程的环境中，但是函数包装器也可以用于数据科学和机器学习任务。例如，在开发数据处理管道和机器学习模型时，可以使用运行时监控和使用函数包装进行调试。</p><p id="5bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数包装器在数据科学和机器学习领域的一个有趣应用是用于数据插补。数据插补是推断和替换数据中缺失值的任务。数据插补可以帮助减少偏差，提高数据分析的效率，甚至提高机器学习模型的性能。</p><p id="63f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种众所周知的技术用于输入数据集中的缺失值。最简单的方法是用零替换所有缺失的值。这是有限的，因为这种插补值可能无法准确反映现实，也不一定能减少偏差和提高数据分析的效率。在某些情况下，它实际上可能会引入大量的偏差，尤其是当一列中的大部分值缺失时。另一种方法是用平均值替换缺失的数值。虽然这比用零进行估算要好，但它仍然会导致偏差，尤其是当一列中有很大一部分数据丢失时。</p><p id="3132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种方法是建立一个机器学习模型，根据数据中其他列的值来预测缺失值。这种方法非常理想，因为即使在特定列中有很大一部分数据缺失的情况下，基于其他列的推断也应该有助于减少偏差。这种方法可以通过在类别级别应用机器学习模型来进一步改进。理论上，这可以用来相对较好地估算一整列缺失值。此外，类别和模型的粒度越细，这种方法应该工作得越好。</p><p id="802c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于前两种方法，我们可以简单地使用pandas fillna()方法用零、平均值和众数来填充缺失值。对于输入带有预测的缺失值，我们可以使用<a class="ae ky" href="https://scikit-learn.org/stable/index.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>包中的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html#sklearn.impute.IterativeImputer" rel="noopener ugc nofollow" target="_blank">迭代输入</a>模块。在这里，我们将看看如何使用函数包装器来设计每种方法的数据插补方法。</p><p id="4554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们将使用葡萄酒杂志数据集，可以在这里找到。在知识共享许可(CC0:公共领域)下，这些数据可以公开自由使用、修改和共享。</p><p id="f2e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的分析，我将在<a class="ae ky" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> Deepnote </a>中编写代码，这是一个协作数据科学笔记本，使运行可重复的实验变得非常容易。</p><h2 id="c7b7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">用零输入缺失值</h2><p id="d3c2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，让我们导航到Deepnote并创建一个新项目(如果您还没有帐户，可以免费注册)。</p><p id="cb43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为“数据_估算”的项目，并在这个项目中创建一个名为“估算”的笔记本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/b3f734fe60fe1c29f2f752902b763871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1dJ8VumpwAYjkbBKdqvcg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="f78e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们导入将要使用的包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mu mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="8a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们定义我们的函数，我们将使用零来估算缺失值。我们称之为简单插补。它将采用一个名为input_function的参数作为自变量。我们还将把输入函数传递给functools包装器中的wraps方法，我们将把它放在实际插补函数之前，称为simple _ attribute _ wrapper:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="dcce" class="lv lw it mx b gy nb nc l nd ne">def simple_imputation(input_function):<br/>    @functools.wraps(input_function)<br/>    def simple_imputation_wrapper(*args, **kwargs):</span></pre><p id="cc08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在simple _ attraction wrapper的范围内，我们指定了在输入函数返回的数据帧中输入缺失值的逻辑。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="23bd" class="lv lw it mx b gy nb nc l nd ne">def simple_imputation_wrapper(*args, **kwargs):<br/>    return_value = input_function(*args, **kwargs)<br/>    print(" — — — — — — — Before Imputation — — — — — — — ")<br/>    print(return_value.isnull().sum(axis = 0)).  return_value.fillna(0, inplace = True)<br/>    print(" — — — — — — — After Imputation — — — — — — — ")   <br/>    print(return_value.isnull().sum(axis = 0))<br/>    return return_value</span></pre><p id="0216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的插补函数(simple _ attachment _ wrapper)是在我们的simple _ attachment函数的范围内定义的。完整的功能如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="ab4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个函数，该函数读入我们的Wines数据集并返回包含我们的数据的dataframe:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="2e7b" class="lv lw it mx b gy nb nc l nd ne">def read_data():<br/>    df = pd.read_csv(“wines_data.csv”, sep = “;”)<br/>    return df</span></pre><p id="a2cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们调用read_data函数，它将具有简单插补方法的附加行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><h2 id="2d3a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">使用均值和模式输入缺失值</h2><p id="2efc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来，我们将定义一种数据插补方法，用平均值替换缺失的数值，用模式替换缺失的分类值。</p><p id="3a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将称我们的新函数为均值模式_插补。它还会将input_function作为参数。我们还将把输入函数传递给functools包装器中的wraps方法，我们将把它放在我们实际的均值/模式插补函数之前，称为mean mode _ attribute _ wrapper:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4b69" class="lv lw it mx b gy nb nc l nd ne">def meanmode_imputation(input_function):<br/>    @functools.wraps(input_function)<br/>    def meanmode_imputation_wrapper(*args, **kwargs):</span></pre><p id="74d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在meanmode _插补包装器的范围内，我们指定了在由输入函数返回的数据帧中输入缺失值的逻辑。这里，我们将迭代列类型，如果列类型为“浮点型”，则估算平均值，如果列类型为“类别”，则估算模式:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6bba" class="lv lw it mx b gy nb nc l nd ne">def meanmode_imputation_wrapper(*args, **kwargs):<br/>    return_value = input_function(*args, **kwargs)<br/>    print("— — — — — — — Before Mean/Mode Imputation — — — — — — — ")<br/>    print(return_value.isnull().sum(axis = 0))<br/>    for col in list(return_value.columns):<br/>        if return_value[col].dtype == float:       <br/>            return_value[col].fillna(return_value[col].mean(), inplace = True).       <br/>        elif return_value[col].dtype.name == 'category':<br/>           return_value[col].fillna(return_value[col].mode()[0], inplace = True)</span><span id="0c0b" class="lv lw it mx b gy nh nc l nd ne">    print(" — — — — — — — After Mean/Mode Imputation — — — — — — — ")<br/>    print(return_value.isnull().sum(axis = 0))<br/>    return return_value</span></pre><p id="bab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的功能如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="6c2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要修改read_data函数，使其接受列名字典，并将分类列和数字列类型分别指定为category和float。我们通过迭代列名并使用我们的列和数据类型字典为每个列转换列类型来实现这一点:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="5329" class="lv lw it mx b gy nb nc l nd ne">for col in list(df.columns):<br/>        df[col] = df[col].astype(data_type_dict[col])</span></pre><p id="a5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的功能如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="4637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要定义我们的数据类型映射字典:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="d7e9" class="lv lw it mx b gy nb nc l nd ne">data_type_dict = {'country':'category', 'designation':'category','points':'float', 'price':'float', 'province':'category', 'region_1':'category','region_2':'category', 'variety':'category', 'winery':'category', 'last_year_points':'float'}</span></pre><p id="cbd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将字典传递给read data方法:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="07c2" class="lv lw it mx b gy nb nc l nd ne">df = read_data(data_type_dict)</span></pre><p id="2a58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><h2 id="b823" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">用迭代输入器输入缺失值</h2><p id="661c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于我们的最终函数包装器，我们将使用Scikit-learn插补模块中的迭代插补器。iterative input使用一个估计器，通过使用所有其他列中的值来迭代地估算一列中的缺失值。默认估计量是贝叶斯岭回归估计量，但这是一个可以修改的参数值。让我们从导入IterativeImputer开始:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f9fc" class="lv lw it mx b gy nb nc l nd ne">from sklearn.impute import IterativeImputer</span></pre><p id="c804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，类似于前面的函数包装器，我们定义一个称为迭代_插补的函数，它采用一个输入函数，在插补包装器之前调用wraps方法，并将插补包装器定义为迭代_插补_包装器。我们还存储输入函数的返回值，并打印插补前缺失值的数量:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="c18d" class="lv lw it mx b gy nb nc l nd ne">def iterative_imputation(input_function):<br/>    @functools.wraps(input_function)<br/>    def iterative_imputation_wrapper(*args, **kwargs):                           <br/>        return_value = input_function(*args, **kwargs)<br/>        print("--------------Before Bayesian Ridge Regression Imputation--------------")<br/>        print(return_value.isnull().sum(axis = 0))</span></pre><p id="7f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在迭代插补包装范围内，我们定义包含分类列和数字列的数据帧:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="a7eb" class="lv lw it mx b gy nb nc l nd ne">return_num = return_value[['price', 'points', 'last_year_points']]<br/>return_cat = return_value.drop(columns=['price', 'points', 'last_year_points'])</span></pre><p id="c48b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以定义我们的插补模型。我们用10次迭代和一个随机状态集来定义我们的模型对象。我们还将使用默认估计量，即贝叶斯回归估计量:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="663a" class="lv lw it mx b gy nb nc l nd ne">imp_bayesian = IterativeImputer(max_iter=10, random_state=0)</span></pre><p id="abc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以拟合我们的模型并估算缺失的数值:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="fe33" class="lv lw it mx b gy nb nc l nd ne">imp_bayesian.fit(np.array(return_num))return_num = pd.DataFrame(np.round(imp_bayesian.transform(np.array(return_num))), columns = ['price', 'points', 'last_year_points'])</span></pre><p id="b69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将继续用模式输入分类变量。值得注意的是，分类值也可以用分类模型估算(我将把这个任务留到以后的文章中):</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="48e1" class="lv lw it mx b gy nb nc l nd ne">for col in list(return_cat.columns):<br/>    return_cat[col].fillna(return_cat[col].mode()[0], inplace = True)<br/>return_value = pd.concat([return_cat, return_num], axis=1)</span></pre><p id="2a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的功能如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="3532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以将迭代插补装饰器放在read_data方法之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="78dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像以前一样调用我们的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mv l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的嵌入</p></figure><p id="6b39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">改进这种插补方法的另一种方法是在类别一级建立插补模型。例如，为每个国家建立一个估算器来估算缺失的数值。我鼓励你试验一下代码，看看你是否能做出这样的修改。在以后的文章中，我将介绍如何建立这些类别级插补模型，并探索其他插补方法。</p><p id="0461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/deepnote/blob/main/imputer.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到</p><h2 id="f8b9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="0aaf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">有各种各样的技术可用于数据插补。我们介绍的最简单的方法是用零替换缺失值。这种方法并不理想，因为它会导致很大的偏差，尤其是在有大量缺失值的情况下。更好的方法是用平均值估算缺失的数值，用模式估算缺失的类别值。虽然这是对用零输入缺失值的改进，但它可以使用机器学习模型来进一步改进。此外，在类别一级建立插补模型可以提供进一步的改进。</p></div></div>    
</body>
</html>