<html>
<head>
<title>From Jupyter to Kubernetes: Refactoring and Deploying Notebooks Using Open-Source Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Jupyter到Kubernetes:使用开源工具重构和部署笔记本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-jupyter-to-kubernetes-refactoring-and-deploying-notebooks-using-open-source-tools-19f99585e923#2022-06-23">https://towardsdatascience.com/from-jupyter-to-kubernetes-refactoring-and-deploying-notebooks-using-open-source-tools-19f99585e923#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="fe9f" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">数据科学软件工程</h2><div class=""/><div class=""><h2 id="b34f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">从凌乱的笔记本到在Kubernetes上运行的流水线的一步一步的指南</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/39da7f5d3a833acd2286d95206ae6462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D4k68s7aQyu6lpNr"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@mjessier?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Myriam Jessier </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f7e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">笔记本电脑非常适合快速迭代和原型制作，但很快就会变得凌乱不堪。在笔记本上工作之后，我的代码变得难以管理并且不适合部署。在生产中，代码组织对于可维护性至关重要(改进和调试有组织的代码比一个又长又乱的笔记本要容易得多)。</p><p id="c242" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这篇文章中，我将描述如何<strong class="lh ja">使用我们的开源工具来覆盖数据科学项目的整个生命周期</strong>:从一个凌乱的笔记本开始，直到代码在生产中运行。我们开始吧！</p><p id="dda2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">第一步，用自动化工具清理我们的笔记本；然后，我们将使用<code class="fe mb mc md me b">soorgeon</code>自动将我们的单片笔记本重构为模块化管道；之后，我们将测试我们的管道是否运行；最后，我们将把管道部署到Kubernetes。这个工作流的主要好处是所有步骤都是完全自动化的，所以我们可以返回Jupyter，迭代(或修复bug)，并毫不费力地再次部署。</p><h1 id="08b8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">清理笔记本</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mx"><img src="../Images/30e9014faea5defa91450c6db4bb085e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5-NAz3skVjKRWibihiqjqA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="4edd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">笔记本的交互性使得尝试新想法变得简单，但也产生了杂乱的代码。在探索数据的时候，我们经常在不考虑可读性的情况下匆忙编写代码。幸运的是，有像<a class="ae le" href="https://github.com/PyCQA/isort" rel="noopener ugc nofollow" target="_blank"> isort </a>和<a class="ae le" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank"> black </a>这样的工具可以让我们轻松地重新格式化代码以提高可读性。不幸的是，这些工具只能处理<code class="fe mb mc md me b">.py</code>文件；然而，<code class="fe mb mc md me b">soorgeon</code>使我们能够在笔记本文件上运行它们(<code class="fe mb mc md me b">.ipynb</code>):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b484" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="na">注意:如果你需要一个示例笔记本来尝试这些命令，这里有一个:</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="70e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">查看本节开头的图片:我在左边的笔记本上引入了一些额外的空白。然而，在应用了<code class="fe mb mc md me b">soorgeon clean</code>(右图)之后，我们看到多余的空白消失了。所以现在我们可以专注于编写代码并应用<code class="fe mb mc md me b">soorgeon clean</code>来轻松使用自动格式化！</p><h1 id="2b51" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">重构笔记本</h1><p id="6e75" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">在单个笔记本上创建分析是很方便的:我们可以在各个部分之间移动，并且很容易地编辑它们；然而，这有很多缺点:很难协作和测试。在多个文件中组织我们的分析将允许我们定义清晰的边界，因此多个管道可以在项目中工作，而不会相互妨碍。</p><p id="6189" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从单个笔记本到模块化流水线的过程既耗时又容易出错；幸运的是，<code class="fe mb mc md me b">soorgeon</code>可以为我们做这些繁重的工作:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8263" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">重构后，我们会看到一堆新文件:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ng"><img src="../Images/0c4751097beb5d99e3d1c2b5776519b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEllld7miWi1VPPnYA03cA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="27b8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Ploomber自动将我们的笔记本变成一个模块化的项目！它生成一个带有基本指令的<code class="fe mb mc md me b">README.md</code>和一个<code class="fe mb mc md me b">requirements.txt</code>(从<code class="fe mb mc md me b">import</code>语句中提取包名)。此外，它创建了一个包含几个<code class="fe mb mc md me b">.ipynb</code>文件的<code class="fe mb mc md me b">tasks/</code>目录；这些文件来自原始的笔记本部分，由降价标题分开。计算出哪些部分依赖于哪些部分。</p><p id="bdb0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您喜欢导出<code class="fe mb mc md me b">.py</code>文件；您可以通过<code class="fe mb mc md me b">--file-format</code>选项:</p><pre class="kp kq kr ks gt nh me ni nj aw nk bi"><span id="ac13" class="nl mg iq me b gy nm nn l no np">soorgeon refactor nb.ipynb --file-format py</span></pre><p id="44fe" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这次<code class="fe mb mc md me b">tasks/</code>目录会有<code class="fe mb mc md me b">.py</code>文件:</p><pre class="kp kq kr ks gt nh me ni nj aw nk bi"><span id="b67c" class="nl mg iq me b gy nm nn l no np">  ├── README.md <br/>  ├── nb.ipynb<br/>  ├── pipeline.yaml<br/>  ├── requirements.txt<br/>  └── tasks<br/>      ├── clean.py<br/>      ├── linear-regression.py<br/>      ├── load.py<br/>      ├── random-forest-regressor.py<br/>      └── train-test-split.py</span></pre><p id="c257" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe mb mc md me b">soorgeon</code>使用降价标题确定要生成多少输出任务。在我们的例子中，有五个人。然后，<code class="fe mb mc md me b">soorgeon</code>分析代码以解析各部分之间的依赖关系，并添加必要的代码以将输出传递给每个任务。</p><p id="bdfc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">例如，我们的“训练测试分割”部分创建了一个变量<code class="fe mb mc md me b">X</code>、<code class="fe mb mc md me b">y</code>、<code class="fe mb mc md me b">X_train</code>、<code class="fe mb mc md me b">X_test</code>、<code class="fe mb mc md me b">y_train</code>和<code class="fe mb mc md me b">y_test</code>；最后四个变量由“线性回归”部分使用:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7db7221e70dd788a0129d6d84e2a0c82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*1nAAd9crpGSfp8Hth5M4RA.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="92c6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过确定输入和输出变量，<code class="fe mb mc md me b">soorgeon</code>确定“线性回归”部分依赖于“训练测试分割”部分。此外,“随机森林回归”部分也依赖于“训练测试分割”,因为它也使用“训练测试分割”部分生成的变量。根据这些信息，<code class="fe mb mc md me b">soorgeon</code>构建了依赖图。</p><h1 id="bed8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">测试我们的管道</h1><p id="b110" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">现在是时候确保我们的模块化管道正确运行了。为此，我们将使用工具箱中的第二个包:<code class="fe mb mc md me b">ploomber</code>。Ploomber允许我们在本地开发和执行我们的管道。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="adfc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是输出:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e0a4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe mb mc md me b">ploomber</code>提供大量工具来管理我们的渠道；例如，我们可以生成一个图:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/6b5fab3669561a9f3734a392fa2584e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ad1cpwxaFcRIcXWTQ0OUQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">图片作者。</p></figure><p id="ab72" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们可以看到依赖图；有三个串行任务:<code class="fe mb mc md me b">load</code>、<code class="fe mb mc md me b">clean</code>和<code class="fe mb mc md me b">train-test-split</code>。在它们之后，我们看到两个独立的任务:<code class="fe mb mc md me b">linear-regression</code>和<code class="fe mb mc md me b">random-forest-regressor</code>。将我们的工作模块化的好处是我们团队的成员可以独立工作，我们可以<a class="ae le" href="https://docs.ploomber.io/en/latest/user-guide/testing.html" rel="noopener ugc nofollow" target="_blank">隔离测试任务</a>，并行<a class="ae le" href="https://docs.ploomber.io/en/latest/api/_modules/executors/ploomber.executors.Parallel.html" rel="noopener ugc nofollow" target="_blank">运行独立任务</a>。有了<code class="fe mb mc md me b">ploomber</code>,我们可以继续用Jupyter开发管道，直到我们准备好部署！</p><h1 id="5dc5" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">部署</h1><p id="c0c4" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">为了简单起见，您可以使用<a class="ae le" href="https://ploomber.io/blog/cron/" rel="noopener ugc nofollow" target="_blank"> cron </a>部署Ploomber管道，并按计划运行<code class="fe mb mc md me b">ploomber build</code>。但是，在某些情况下，您可能希望利用现有的基础设施。我们掩护你！使用<code class="fe mb mc md me b">soopervisor</code>，您可以将您的管道导出到<a class="ae le" href="https://soopervisor.readthedocs.io/en/latest/tutorials/airflow.html" rel="noopener ugc nofollow" target="_blank">气流</a>、<a class="ae le" href="https://soopervisor.readthedocs.io/en/latest/tutorials/aws-batch.html" rel="noopener ugc nofollow" target="_blank"> AWS批次</a>、<a class="ae le" href="https://soopervisor.readthedocs.io/en/latest/tutorials/kubernetes.html" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>、<a class="ae le" href="https://soopervisor.readthedocs.io/en/latest/tutorials/slurm.html" rel="noopener ugc nofollow" target="_blank"> SLURM </a>或<a class="ae le" href="https://soopervisor.readthedocs.io/en/latest/tutorials/kubeflow.html" rel="noopener ugc nofollow" target="_blank"> Kubeflow </a>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="2dcf" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe mb mc md me b">soopervisor add</code>向我们的项目添加一些文件，比如一个预配置的<code class="fe mb mc md me b">Dockerfile</code>(如果我们愿意，我们可以修改它)。另一方面，<code class="fe mb mc md me b">soopervisor export</code>将我们现有的管道导出到Argo工作流，这样我们就可以在Kubernetes上运行它。</p><p id="886a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过更改<code class="fe mb mc md me b">soopervisor add</code>命令中的<code class="fe mb mc md me b">--backend</code>参数，您可以切换到其他支持的平台。或者，你可以注册<a class="ae le" href="https://docs.ploomber.io/en/latest/cloud/cloud-execution.html" rel="noopener ugc nofollow" target="_blank">免费云服务</a>，它允许你用一个命令在云中运行你的笔记本。</p><h1 id="8004" class="mf mg iq bd mh mi mj mk ml mm mn mo mp kf mq kg mr ki ms kj mt kl mu km mv mw bi translated">结束语</h1><p id="9a7a" class="pw-post-body-paragraph lf lg iq lh b li nb ka lk ll nc kd ln lo nd lq lr ls ne lu lv lw nf ly lz ma ij bi translated">笔记本清理和重构既耗时又容易出错，我们正在开发工具来使这一过程变得轻而易举。在这篇博文中，我们从拥有一个单片笔记本到拥有一个在生产中运行的模块化流水线——所有这些都是使用开源工具以自动化的方式实现的。所以请让我们知道你想看什么功能。<a class="ae le" href="https://ploomber.io/community" rel="noopener ugc nofollow" target="_blank">加入我们的社区</a>，分享你的想法！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><blockquote class="nz oa ob"><p id="919e" class="lf lg na lh b li lj ka lk ll lm kd ln oc lp lq lr od lt lu lv oe lx ly lz ma ij bi translated">嗨！我叫爱德华多，我喜欢写关于数据科学的所有东西。如果您想了解我的最新内容。在<a class="ae le" href="https://medium.com/@edublancas" rel="noopener"> Medium </a>或<a class="ae le" href="https://twitter.com/edublancas" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。感谢阅读！</p></blockquote><p id="a33e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><em class="na">最初发布于</em><a class="ae le" href="https://ploomber.io/blog/notebook-to-kubernetes/" rel="noopener ugc nofollow" target="_blank"><em class="na">ploomber . io</em></a><em class="na">。</em></p></div></div>    
</body>
</html>