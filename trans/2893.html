<html>
<head>
<title>A Small Taste of Classical AI: Solving Search Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">经典人工智能的一点味道:解决搜索问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-small-taste-of-classical-ai-solving-search-problems-aab1a1984a24#2022-06-23">https://towardsdatascience.com/a-small-taste-of-classical-ai-solving-search-problems-aab1a1984a24#2022-06-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="f7f1" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">学习如何以系统和通用的方式解决搜索问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/3bf51bf5e5ef23ed83d6d258358e8fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1b1VWe9eAlhlaGRk"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅姆</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="665a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在广阔的人工智能领域，有一个令人兴奋的分支<strong class="lc iv">状态空间搜索问题</strong>，里面充满了你最喜欢的谜题:</p><ul class=""><li id="8cc7" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Sudoku" rel="noopener ugc nofollow" target="_blank">数独</a>，</li><li id="e16a" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Sliding_puzzle" rel="noopener ugc nofollow" target="_blank">滑动拼图</a>，又称8字拼图、15字拼图、…、</li><li id="b241" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">河内的<a class="ae kz" href="https://en.wikipedia.org/wiki/Tower_of_Hanoi" rel="noopener ugc nofollow" target="_blank">塔</a>(递归讲座倒叙，有人吗？),</li><li id="cdbe" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">后面我们作为例子的<a class="ae kz" href="https://en.wikipedia.org/wiki/Pancake_sorting" rel="noopener ugc nofollow" target="_blank">煎饼排序问题</a>，</li><li id="6861" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> n </em>蚁后问题</a></li><li id="3192" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">还有很多。</li></ul><p id="23e9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">也许你不得不编写算法来解决这类或那类搜索问题。对于这些问题中的每一个，你都有一个独特的算法，这是非常乏味的。</p><p id="a11d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我想向你展示</p><ol class=""><li id="53f9" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv ml mc md me bi translated">这些(以及其他)问题是如何联系在一起的</li><li id="7b91" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated">如何编写一个元算法来解决所有这些问题。</li></ol><blockquote class="mm mn mo"><p id="fe3a" class="la lb mk lc b ld le jv lf lg lh jy li mp lk ll lm mq lo lp lq mr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="iu">剧透:找到</em> </strong> <a class="ae kz" href="https://github.com/Garve/search_problems/blob/main/search_problems.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv"> <em class="iu">上的代码我的Github </em> </strong> </a> <strong class="lc iv"> <em class="iu">。</em> </strong></p></blockquote><h1 id="f966" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated"><strong class="ak">状态空间搜索问题</strong></h1><p id="9ec4" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">上述问题——从现在起我也称之为<strong class="lc iv">游戏</strong>——不像国际象棋、围棋或任何高级电脑游戏那样复杂。尽管如此，研究它们还是很有趣的，并且解决其中的一些问题可能已经是<a class="ae kz" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"> NP-hard </a>了，也就是说，通常可能不存在多项式时间算法来解决它们。</p><p id="15b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">我来速写一下我们现在要解决哪种游戏。</strong></p><p id="a2e4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">游戏有几个<strong class="lc iv">游戏状态，</strong>其中一个是<strong class="lc iv">初始状态</strong>，我们会在开始问题时找到。<strong class="lc iv"> </strong>一个游戏状态就是所有关于游戏状态的<em class="mk">必要</em>信息。在数独游戏中，这可能是包含所有数字的字段。例如，它可以方便地表示为一个9×9的矩阵，用数字填充，用0表示空字段。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj np"><img src="../Images/7ace0940b52c067b11aacb29479704dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*T2UwmSLFjqbOqiw8tE2qZg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://commons.wikimedia.org/wiki/File:Sudoku_Puzzle_by_L2G-20050714_standardized_layout.svg" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="e9de" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以采取<strong class="lc iv">动作</strong>将一个游戏状态改变为另一个游戏状态。在数独游戏中，你只能填写数字。你必须指定一个空的单元格和一个数字，然后将数字写入指定的单元格，改变游戏状态。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj np"><img src="../Images/1a1a4477959b2703501668526f46f12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*bzfCczpPoAuEup6tKY-REw.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由作者编辑。数字4被写入一个单元格。</p></figure><p id="7ddf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有一个我们试图达到的<strong class="lc iv">目标状态</strong>，它让我们<strong class="lc iv">赢得游戏</strong>。在数独游戏中，每一行、每一列和每一个方块都必须恰好显示一次所有的数字1-9。</p><h1 id="d067" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">解决搜索问题</h1><p id="8f11" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">好吧，如果你已经看了上面的一些问题和困惑，你可能已经注意到它们看起来都很不同。我们如何将它们结合成一个单一的框架？好吧，以下是唯一的秘密:</p><blockquote class="nq"><p id="7307" class="nr ns iu bd nt nu nv nw nx ny nz lv dk translated">解决搜索问题归结为<strong class="ak">图遍历</strong>。</p></blockquote><p id="6236" class="pw-post-body-paragraph la lb iu lc b ld oa jv lf lg ob jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">那是什么意思？我希望你听说过像<a class="ae kz" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>和<a class="ae kz" href="https://en.wikipedia.org/wiki/Breadth-first_search" rel="noopener ugc nofollow" target="_blank">广度优先搜索(BFS) </a>这样的算法。这些算法允许你系统地遍历一个图，就像我们想要系统地解决这些难题一样。如果你是新手，请继续读下去，因为现在你将了解它们。让我们以煎饼排序问题为例，因为它没有数独复杂，而且你可以看到游戏状态和动作的不同设置。</p><h2 id="0920" class="of mt iu bd mu og oh dn my oi oj dp nc lj ok ol ne ln om on ng lr oo op ni oq bi translated">煎饼分类🥞</h2><p id="b0f0" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">这个问题可以这样描述:</p><blockquote class="nq"><p id="62bd" class="nr ns iu bd nt nu nv nw nx ny nz lv dk translated">你有一堆杂乱的大小不一的煎饼。你想用抹刀翻动一堆煎饼的一部分，将这一堆(最小的放在上面，最大的放在下面)分类。</p></blockquote><p id="67e2" class="pw-post-body-paragraph la lb iu lc b ld oa jv lf lg ob jy li lj oc ll lm ln od lp lq lr oe lt lu lv in bi translated">请看下图，这是一个可能的操作示例:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj os"><img src="../Images/6190fd534a4796ff2751518d2aa4e45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*ldkmGdY6PGvcpbteTVxt7Q.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://commons.wikimedia.org/wiki/File:Pancake_sort_operation.png" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p></figure><p id="960f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们根据煎饼的大小给它们编号，1是最小的，6是最大的。上图中，我们处于<strong class="lc iv">游戏状态(2，1，4，6，3，5) </strong>，从上到下。使用<strong class="lc iv">动作“在位置3翻转”</strong>，我们可以将旧的游戏状态转换为新的游戏状态(<strong class="lc iv"> 4，1，2 </strong>，6，3，5)，即前3个煎饼的顺序颠倒。</p><h2 id="948e" class="of mt iu bd mu og oh dn my oi oj dp nc lj ok ol ne ln om on ng lr oo op ni oq bi translated">4个煎饼的系统解决方案</h2><p id="a949" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">假设我们从初始博弈状态(4，2，1，3)开始。还是那句话，4是最大的煎饼，1是最小的。我从上到下记录游戏状态。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ot"><img src="../Images/b17f385b9f51ee1e88d349ed01d327ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:288/format:webp/1*FHx59BlV1CGhAwuCqTFN-g.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。状态为(4，2，1，3)。</p></figure><p id="b1f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在取这个状态，并列举所有可能的下一个状态。我们称这一步<strong class="lc iv">为扩展</strong>当前状态。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ou"><img src="../Images/4a70912ae67bb7e18d9fd2142db964cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kY4lahJL_gVIo6DTOglr5A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。4个煎饼总是有4种可能的动作。</p></figure><p id="9401" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="mk">注意，我们可以放弃“翻转1”动作，因为它只是空转，即它会再次导致相同的状态。</em></p><p id="32e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你现在可能知道该怎么做了。我们不断扩展四个新节点，直到找到我们的目标状态:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ov"><img src="../Images/080f78642d4decb28d7de68c5033ae54.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*6Yhoj7Dl1wnzExWINeE2BQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。目标，而不是Spotify的标志。</p></figure><p id="4dcd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，它可能看起来像这样，省略了许多状态:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/0a93618452d7d5a83f0c66c673051a9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GbWAzoQX-s5z4mcnsvbesg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。找到了。</p></figure><p id="c78a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很好，对吧？而且最好的一点是，这个方法不需要任何关于煎饼问题的特别之处。它需要<strong class="lc iv">状态和</strong>动作，就是这样。我们也可以把9×9的数独字段放在节点、棋盘(针对<em class="mk"> n </em>皇后问题)或者任何我们想要的地方。重要的事情如下:</p><ol class=""><li id="aad7" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv ml mc md me bi translated">我们需要一种方法来<strong class="lc iv">识别目标状态</strong>。</li><li id="2382" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated">给定一个状态，我们需要一种方法来<strong class="lc iv">枚举下一个状态</strong>。</li></ol><p id="8abf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在将形式化这个算法。</p><h1 id="c833" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">Python中的一般实现</h1><p id="fcf8" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">首先，让我们定义一个<code class="fe ox oy oz pa b">SearchProblem</code>基类来商定搜索问题应该具有的接口。这个类仍然会有缺失的功能，它仅仅是一个模板。我们将从中派生出具体的类，然后实现缺失的功能。我们开始吧:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="e64a" class="pf mt iu pa b be pg ph l pi pj">class SearchProblem:<br/>    def __init__(self, state):<br/>        self.state = state<br/>        <br/>    def is_solution(self):<br/>        # Implement me!<br/>        pass<br/>    <br/>    def get_next_states(self):<br/>        # Implement me!<br/>        pass<br/>    <br/>    def __hash__(self):<br/>        # Implement me!<br/>        pass<br/>    <br/>    def __repr__(self):<br/>        return str(self.state)<br/>    <br/>    def __eq__(self, other):<br/>        return self.state == other.state</span></pre><p id="b0ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ox oy oz pa b">__hash__</code>、<code class="fe ox oy oz pa b">__eq__</code>和<code class="fe ox oy oz pa b">__repr__</code>(还有<code class="fe ox oy oz pa b">__init__</code>)是所谓的<strong class="lc iv">魔法函数</strong>或<strong class="lc iv">邓德方法</strong>的例子。实现<code class="fe ox oy oz pa b">__hash__</code>允许我们在这个类的对象上使用Python <code class="fe ox oy oz pa b">hash</code>函数。作为一个例子，键入<code class="fe ox oy oz pa b">hash((1, 2, 3))</code>，它给出了元组<code class="fe ox oy oz pa b">(1, 2, 3)</code>的哈希值。</p><blockquote class="mm mn mo"><p id="2fb0" class="la lb mk lc b ld le jv lf lg lh jy li mp lk ll lm mq lo lp lq mr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="iu">哈希函数:</em> </strong> <em class="iu">直观上，哈希函数应该是将对象映射到整数。虽然这是一个确定性的过程(即相同的输入导致相同的输出)，但当我们向一个散列函数提供许多不同的对象时，散列值的最终分布应该看起来是</em> <strong class="lc iv"> <em class="iu">均匀分布</em> </strong> <em class="iu">。</em></p></blockquote><p id="d0a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们为什么需要这个？我们需要这两种方法，因为我们的问题求解算法必须将搜索问题对象作为关键字放入字典才能有效工作，并且<strong class="lc iv">关键字</strong> <strong class="lc iv">必须是可散列的</strong>，即<code class="fe ox oy oz pa b">hash(our_object)</code>不应抛出错误。</p><p id="72a8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实现<code class="fe ox oy oz pa b">__eq__</code>让我们比较两个不同的对象，即它们是否相等。通常，我们只是检查状态是否相等，因此我已经给出了一个具体的实现。</p><p id="a3da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实现<code class="fe ox oy oz pa b">__repr__</code>只是在打印时给出了该类对象的一个很好的表示。通常，只打印州名就可以了。</p></div><div class="ab cl pk pl hy pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="in io ip iq ir"><p id="4789" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">太好了，所以一个一般的搜索问题可以被初始化，并分配一个(开始)状态。我们还可以通过检查两个问题的状态是否相等来检查它们是否相同，并且可以很好地打印出来。但最重要的细节仍有待充实，并在很大程度上取决于问题。</p><h2 id="af88" class="of mt iu bd mu og oh dn my oi oj dp nc lj ok ol ne ln om on ng lr oo op ni oq bi translated">回到煎饼上</h2><p id="a1a8" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">让我们再次回到煎饼排序问题，给出<code class="fe ox oy oz pa b">is_solution</code>、<code class="fe ox oy oz pa b">get_next_states</code>和<code class="fe ox oy oz pa b">__hash__</code>的具体实现。</p><blockquote class="mm mn mo"><p id="c913" class="la lb mk lc b ld le jv lf lg lh jy li mp lk ll lm mq lo lp lq mr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="iu">我们的约定:</em> </strong> <em class="iu">状态会是由整数1到</em> n <em class="iu">组成的列表。整数代表煎饼大小。列表中的第一个元素是最上面的煎饼。一个例子可以是[4，2，1，3]。</em></p></blockquote><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="4361" class="pf mt iu pa b be pg ph l pi pj">class PancakeSortingProblem(SearchProblem):<br/>    def is_solution(self):<br/>        for i in range(len(self.state)-1):<br/>            if self.state[i] &gt; self.state[i+1]:<br/>                return False<br/>        return True<br/>    <br/>    def get_next_states(self):<br/>        for i in range(2, len(self.state)+1):<br/>            upper = self.state[:i]<br/>            lower = self.state[i:]<br/>            next_state = upper[::-1] + lower<br/>            yield PancakeSortingProblem(next_state)<br/>    <br/>    def __hash__(self):<br/>        n = max(self.state) + 1<br/>        return sum([x*n**i for i, x in enumerate(self.state)])</span></pre><p id="af0d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我认为<code class="fe ox oy oz pa b">is_solution</code>和<code class="fe ox oy oz pa b">get_next_states</code>的实现应该不会太复杂而难以理解。<code class="fe ox oy oz pa b">is_solution</code>实际上只是检查一个数组是否排序。<code class="fe ox oy oz pa b">get_next_states</code>获取一个状态(列表)并通过翻转每个可行位置的pancake堆栈的上半部分来返回以下所有状态。让我们试试这个:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="6949" class="pf mt iu pa b be pg ph l pi pj">p = PancakeSortingProblem([4, 2, 1, 3]) # start state = [4, 2, 1, 3]<br/><br/>for next_state in p.get_next_states():<br/>    print(next_state)</span></pre><pre class="pr pb pa pc bn pd pe bi"><span id="d360" class="pf mt iu pa b be pg ph l pi pj"># Output (thanks to the __repr__ method!):<br/># [2, 4, 1, 3]<br/># [1, 2, 4, 3]<br/># [3, 1, 2, 4]</span></pre><blockquote class="mm mn mo"><p id="8371" class="la lb mk lc b ld le jv lf lg lh jy li mp lk ll lm mq lo lp lq mr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="iu">注:</em> </strong> <em class="iu">我跳过了四个下一状态中的一个，因为“在位置1翻转”动作基本上是一个“什么都不做”的动作。它只是增加了复杂性，因此我们放弃了它。</em></p></blockquote><p id="71cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们解决房间里的大象:<strong class="lc iv">那个杂碎</strong>。我在那里做什么？目标是将一个状态转换成一个整数，即<em class="mk">哈希值</em>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ps"><img src="../Images/4fe8eecea4cf7e3f83abb96806fa2719.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*DFYncMRkgEi6cJQWo6qOVg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。</p></figure><p id="808f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我如何到达那里？通过计算</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pt"><img src="../Images/176863204354d67418f18f092ac9ed32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i-Ier0SjF7RB_GG6ygZbgw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片由作者提供。</p></figure><p id="ba70" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我就实现了这么多。基本上，我将状态[4，2，1，3]视为五进制(类似二进制，只是基数为5而不是2)数3124 (4213反转)，并将其转换回十进制。这使得两个不同的状态具有两个不同的散列值(<strong class="lc iv"> <em class="mk">技术细节:</em> </strong> <em class="mk">)，只要结果小于2⁶ </em>，这对于性能来说很好。我们就到此为止吧。</p><p id="9183" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你也可以自己编另一个hash函数，只要试着创建一个在大多数时候给不同hash值分配不同状态的东西<strong class="lc iv">，不使用随机性</strong>。做这样的事情在技术上是可能的:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="6d3d" class="pf mt iu pa b be pg ph l pi pj">def __hash__(self):<br/>    return 1</span></pre><p id="c959" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是这会导致算法速度变慢，所以要避免这样做。太好了，我们有一个工作问题类，所以我们现在可以处理解决方案了！</p><h2 id="726c" class="of mt iu bd mu og oh dn my oi oj dp nc lj ok ol ne ln om on ng lr oo op ni oq bi translated">定义搜索问题解决程序类</h2><p id="bb7c" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">让我们用文字来描述这个算法。</p><ol class=""><li id="4b0a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv ml mc md me bi translated">我们获取起始状态(以问题对象的形式)并将其放入一个名为<code class="fe ox oy oz pa b">frontier</code>的列表中。</li><li id="d276" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated">我们<strong class="lc iv">弹出</strong>一个状态(即将其从列表中移除)并且<strong class="lc iv">检查</strong>是否是目标。如果没有，我们就<strong class="lc iv">扩大</strong>它。</li><li id="83cd" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated">我们将所有尚未看到的下一个状态<strong class="lc iv"/>添加到<code class="fe ox oy oz pa b">frontier</code>中。这可以防止我们绕圈子。</li><li id="5f1f" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated">然后重复第2步和第3步，直到找到目标，即弹出、检查、扩展、弹出、检查、扩展……</li></ol><p id="226d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">基本上，我们用我们遇到的所有状态填充一个列表(最初用起始状态填充)。这是要探索的状态列表。每当这个列表为空时，就没有什么可探索的了。如果到那时我们还没有找到目标，那就没有解决方案。</p><p id="5037" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我们最多将每个可能的状态插入列表一次，所以算法将终止。</p></div><div class="ab cl pk pl hy pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="in io ip iq ir"><p id="ec59" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在代码中，它可能是这样的:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="84eb" class="pf mt iu pa b be pg ph l pi pj">class SearchProblemSolverDFS:<br/>    def solve(self, start_problem):<br/>        frontier = [start_problem]<br/>        self.backlinks = {start_problem: None}<br/>        self.solution = None<br/><br/>        while frontier and self.solution is None:<br/>            current_state = frontier.pop()<br/><br/>            if current_state.is_solution():<br/>                self.solution = current_state<br/><br/>            for next_state in current_state.get_next_states():<br/>                if next_state not in self.backlinks:<br/>                    self.backlinks[next_state] = current_state<br/>                    frontier.append(next_state)<br/><br/>    def print_solution(self):<br/>        current_state = self.solution<br/>        result = []<br/>        while current_state is not None:<br/>            result.append(current_state)<br/>            current_state = self.backlinks[current_state]<br/>        <br/>        return result[::-1]</span></pre><p id="4cce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">关于代码的一些注释:</strong></p><p id="953a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe ox oy oz pa b">solve</code>方法中，我还引入了<code class="fe ox oy oz pa b">backlinks</code>字典。这有两个不同的目的:</p><ol class=""><li id="b227" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv ml mc md me bi translated">记录访问过的州，正如你在<code class="fe ox oy oz pa b">if next_state not in self.backlinks</code>一行中看到的。</li><li id="3988" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated">记录如何到达每个状态，即存储前置任务。起始状态没有前身，因此我将其初始化为<code class="fe ox oy oz pa b">{start_problem: None}</code>。</li></ol><p id="0ff2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我还创建了一个<code class="fe ox oy oz pa b">print_solution</code>方法，输出如何从开始状态到达目标状态。</p><p id="969f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">酷，让我们试试吧！</p><h2 id="cdce" class="of mt iu bd mu og oh dn my oi oj dp nc lj ok ol ne ln om on ng lr oo op ni oq bi translated"><strong class="ak">运行代码</strong></h2><p id="e110" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">我们已经做了这么多工作，但是看看现在应用一切是多么容易:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="d061" class="pf mt iu pa b be pg ph l pi pj">four_pancakes = PancakeSortingProblem([4, 2, 1, 3])<br/>solver = SearchProblemSolverDFS()<br/><br/>solver.solve(four_pancakes)<br/>solver.print_solution()<br/><br/># Output:<br/># [[4, 2, 1, 3], [3, 1, 2, 4], [2, 1, 3, 4], [1, 2, 3, 4]]</span></pre><p id="7631" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这对应于我们在上图中看到的解决方案。不错！尝试用更多的煎饼，如</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="591d" class="pf mt iu pa b be pg ph l pi pj">PancakeSortingProblem([4, 2, 1, 3, 5, 7, 6, 8])</span></pre><p id="9a62" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">解决方法是loooooooooooong，我马上会告诉你为什么。</p><h1 id="ac8d" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">一些评论</h1><p id="80f0" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">我们实现<code class="fe ox oy oz pa b">SearchProblemSolver</code>的方式是通过深度优先搜索(DFS)。它之所以有这个名字，是因为它倾向于深度，而不是试图找到最短的解决方案。它之所以如此，是因为我们使用了一个<strong class="lc iv">堆栈</strong>数据结构来实现<code class="fe ox oy oz pa b">frontier</code>。我们总是<strong class="lc iv">在列表的末尾插入新的状态，并从那里弹出元素(后进先出或LIFO原则)</strong>。这就是为什么新的州会立即被探索。想象一下<code class="fe ox oy oz pa b">frontier</code>是一个待办事项列表，新的事情有更高的优先级——你写在列表上的最后一件事会被首先处理。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pu"><img src="../Images/095566bdf72a8f86daf8e4516937ec57.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/1*5LfQZB_te39u7i-ASqra5g.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">DFS待办事项列表。图片由作者提供。</p></figure><p id="032b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">直到状态<em class="mk">下一个(a) </em>和<em class="mk">下一个(b) </em>被探测到需要很长时间，尽管它们在从开始状态开始的<strong class="lc iv">单个动作</strong>内是可到达的。</p></div><div class="ab cl pk pl hy pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="in io ip iq ir"><p id="66d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以不同地实现frontier，例如作为一个<a class="ae kz" href="https://en.wikipedia.org/wiki/Queue_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">队列</strong> </a>。使用这种数据结构，我们可以<strong class="lc iv">在列表的末尾插入新的状态(和以前一样)，但是从列表的开始弹出元素(先进先出或FIFO原则)</strong>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pu"><img src="../Images/8862ca3ad99439134c68757a91f40259.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/1*IPD208UIDxvSiunT7tg75Q.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">BFS待办事项列表。图片由作者提供。</p></figure><p id="a693" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一种低效而廉价的方法是用<code class="fe ox oy oz pa b">frontier.pop(0)</code>代替<code class="fe ox oy oz pa b">frontier.pop()</code>。不过这是一个比较慢的操作(<em class="mk"> O </em> ( <em class="mk"> n </em>)如果列表中有<em class="mk"> n </em>个元素的话)，用指定的数据结构实现队列比较好(<em class="mk"> O </em> (1)那么)。参考资料，<a class="ae kz" href="https://wiki.python.org/moin/TimeComplexity" rel="noopener ugc nofollow" target="_blank">见此处</a>。</p><p id="91ff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一种方法是使用<a class="ae kz" href="https://docs.python.org/3/library/collections.html#collections.deque" rel="noopener ugc nofollow" target="_blank">队列</a>:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="e086" class="pf mt iu pa b be pg ph l pi pj">from collections import deque</span></pre><pre class="pr pb pa pc bn pd pe bi"><span id="d4e3" class="pf mt iu pa b be pg ph l pi pj">class SearchProblemSolverBFS:       <br/>    def solve(self, start_problem):<br/>        frontier = deque([start_problem])<br/>        ...<br/>        <br/>        while frontier and self.solution is None:<br/>            current_state = frontier.popleft()<br/>            <br/>            ...<br/>                <br/>    ...</span></pre><p id="f5c0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个简单的变化创造了广度优先搜索(BFS)，它专注于最短的解决方案。让我们试一试:</p><pre class="kk kl km kn gu pb pa pc bn pd pe bi"><span id="c9ff" class="pf mt iu pa b be pg ph l pi pj">eight_pancakes = PancakeSortingProblem([4, 2, 1, 3, 5, 7, 6, 8])<br/>solver = SearchProblemSolverBFS()<br/>solver.solve(eight_pancakes)<br/>solver.print_solution()<br/><br/># Output:<br/># [[4, 2, 1, 3, 5, 7, 6, 8],<br/># [3, 1, 2, 4, 5, 7, 6, 8],<br/># [2, 1, 3, 4, 5, 7, 6, 8],<br/># [1, 2, 3, 4, 5, 7, 6, 8],<br/># [6, 7, 5, 4, 3, 2, 1, 8],<br/># [7, 6, 5, 4, 3, 2, 1, 8],<br/># [1, 2, 3, 4, 5, 6, 7, 8]]</span></pre><p id="f250" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">又好又短！然而，BFS的缺点是它使用更多的内存，这可能是相当令人失望的。还有一个BFS和DFS的混合体叫做<a class="ae kz" href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search" rel="noopener ugc nofollow" target="_blank">迭代深化深度优先搜索</a>。这在不浪费太多内存的情况下找到了最短的解决方案，但是它使用了更多的运行时间。</p><h1 id="3a8a" class="ms mt iu bd mu mv mw mx my mz na nb nc ka nd kb ne kd nf ke ng kg nh kh ni nj bi translated">结论</h1><p id="b1e0" class="pw-post-body-paragraph la lb iu lc b ld nk jv lf lg nl jy li lj nm ll lm ln nn lp lq lr no lt lu lv in bi translated">在本文中，我们看到了如何使用图搜索系统地解决搜索问题，如数独、滑动拼图或煎饼排序问题。</p><p id="5177" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们编写的求解器是通用的，我们只需创建一个问题类，在其中定义问题如何工作，即</p><ul class=""><li id="586a" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv mb mc md me bi translated">目标是什么样的</li><li id="1a9d" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv mb mc md me bi translated">以及我们可以从任何给定的州到达哪些州。</li></ul><p id="e027" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不过，我们没有谈到的一件有趣的事情是，有些行动可能比其他行动成本更高。我们还不能最优地解决这些问题，因为我们的BFS求解器只最小化了步骤的<strong class="lc iv">绝对数量</strong>，这意味着我们使用了一个隐含的恒定成本，例如1。</p><p id="d2c5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在煎饼的情况下，不均匀成本可能意味着在位置<em class="mk"> k </em>翻转煎饼堆的成本可能是<em class="mk"> k，</em>直觉是，我们一次翻转的煎饼越多，翻转就越困难。我们可能需要一个解决方案来最小化这些成本的总和。在这种情况下，也有获得最优解的方法，我们可以在另一篇文章中朝这个方向看一看。目前的关键词:<strong class="lc iv">统一成本搜索</strong>(又名<strong class="lc iv"> Dijkstra </strong>)和<strong class="lc iv"> A* </strong>。</p><p id="7494" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您现在可以创建更多的问题类并解决它们，而无需更改我们的问题解决程序类。下一个简单的问题可能是<a class="ae kz" href="https://en.wikipedia.org/wiki/Pancake_sorting#The_burnt_pancake_problem" rel="noopener ugc nofollow" target="_blank">烤焦的煎饼问题</a>(因为为什么不呢🔥🥞).这里，煎饼有烧焦的一面和没烧焦的一面。它们不仅要整齐，而且所有煎饼烧焦的一面都要在底部。您可以将状态表达为[[4，0]，[2，0]，[1，1]，[3，1]]，这意味着我们又有了煎饼[4，2，1，3]，但是煎饼1和3烧焦的一面在上面。为此，您只需稍微修改pancake类代码。</p><p id="750f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">祝解谜愉快！</p></div><div class="ab cl pk pl hy pm" role="separator"><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp pq"/><span class="pn bw bk po pp"/></div><div class="in io ip iq ir"><p id="8a13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="ef79" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">作为最后一点，如果你</strong></p><ol class=""><li id="af43" class="lw lx iu lc b ld le lg lh lj ly ln lz lr ma lv ml mc md me bi translated"><strong class="lc iv">想支持我多写点机器学习和</strong></li><li id="9de1" class="lw lx iu lc b ld mf lg mg lj mh ln mi lr mj lv ml mc md me bi translated"><strong class="lc iv">无论如何，计划获得一个中等订阅，</strong></li></ol><p id="06d3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">为什么不做</strong> <a class="ae kz" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="lc iv">通过这个环节</strong> </a> <strong class="lc iv">？这将对我帮助很大！😊</strong></p><p id="c4ef" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="mk">说白了，给你的价格不变，但是大约一半的订阅费直接归我。</em></p><p id="f37d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="nq"><p id="f52f" class="nr ns iu bd nt nu nv nw nx ny nz lv dk translated"><em class="or">有问题就在</em> <a class="ae kz" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"> <em class="or"> LinkedIn </em> </a> <em class="or">上写我！</em></p></blockquote></div></div>    
</body>
</html>