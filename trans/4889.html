<html>
<head>
<title>Dynamic Programming: The Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态编程:框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamic-programming-the-framework-7af71604cd78#2022-10-31">https://towardsdatascience.com/dynamic-programming-the-framework-7af71604cd78#2022-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a83a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你在编码面试中需要知道的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/711cbaec16c601de20442d3c2fc6171e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L1XZlBpf4qnKejGcgAzHog.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。图标取自Freepick</p></figure><p id="8d46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码面试中最具挑战性的话题之一是动态编程。特别是在用动态规划将问题识别、处理和发展为优化任务的过程中。</p><p id="728d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇博客中，我们将看到识别什么时候可以用动态编程解决问题的关键，以及如何一步一步地提出解决方案。你准备好了吗？让我们去吧！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="13d9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">如何识别一个问题可以用动态规划来解决？</h1><p id="2461" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">动态规划范例指的是一个优化过程，其目的是有效地探索所有可能的解决方案，直到找到最佳结构。</p><p id="5418" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，动态规划问题在其方法中需要计算"<em class="my">某事</em>"的最大值或最小值，做"<em class="my">某事</em>"的不同可能性，状态<code class="fe mz na nb nc b">k</code>中进程的结果值，等等。</p><p id="a006" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比如斐波那契数列的<code class="fe mz na nb nc b">nth</code>数是多少？寻找斐波纳契数列的<code class="fe mz na nb nc b">nth</code>数变成了一个动态规划问题，因为本质上，第n个数是由数字<code class="fe mz na nb nc b">n-1</code>和<code class="fe mz na nb nc b">n-2</code>决定的，而这两个数字又分别由<code class="fe mz na nb nc b">n-2</code>和<code class="fe mz na nb nc b">n-3</code>以及<code class="fe mz na nb nc b">n-3</code>和<code class="fe mz na nb nc b">n-4</code>决定。换句话说，为了找到状态<code class="fe mz na nb nc b">k</code>的解，我们需要知道其解递归相关的前<code class="fe mz na nb nc b">k-1</code>状态的解。</p><p id="0a2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在图2中，我们可以看到斐波纳契数列对循环关系的依赖性的图形表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/ddfe8711df6d03b7f14dcb8606506fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N-CoykgX-IP8iFS8er1mUA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。斐波那契数列|作者图片示例</p></figure><p id="31a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得一提的是，基于<strong class="la iu"> <em class="my">动态编程</em> </strong>的解决方案的方法可能与基于<strong class="la iu"> <em class="my">分治技术</em> </strong>的解决方案相混淆。区别在于，与动态编程解决方案相比，基于分而治之的解决方案不代表递归依赖关系。</p><p id="f60f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，确定您的代码访问问题是否可以用动态编程解决的关键是:</p><ul class=""><li id="07ab" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt nj nk nl nm bi translated">确定问题是否可以<strong class="la iu">分解为子问题</strong>(思考基本情况是什么在这一点上将是关键)。</li><li id="808a" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated">识别每个子问题之间是否有任何<strong class="la iu">循环依赖关系</strong>(例如，子问题的解决方案是否影响后续子问题的解决方案)。</li><li id="d9eb" class="ne nf it la b lb nn le no lh np ll nq lp nr lt nj nk nl nm bi translated"><strong class="la iu">依靠关键词</strong>:寻找<em class="my">“某事”的最大值或最小值、</em>寻找在一定限制下做<em class="my">“某事”</em>的<code class="fe mz na nb nc b">n</code>种可能性等。</li></ul><p id="3d3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦你确定手头的问题可以用动态规划来解决，你现在就需要一个策略来制定和开发解决方案。在下一部分，我们将看到提议和开发您的解决方案的三个基本组件。</p><p id="67ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们去吧！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="a659" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">框架</h1><p id="135f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">开发基于动态编程的解决方案的基本组件包括:</p><ol class=""><li id="a5fd" class="ne nf it la b lb lc le lf lh ng ll nh lp ni lt ns nk nl nm bi translated">对每种状态之间的递归关系进行建模的函数或数据结构。</li><li id="9b99" class="ne nf it la b lb nn le no lh np ll nq lp nr lt ns nk nl nm bi translated">记忆和制表。</li><li id="59e4" class="ne nf it la b lb nn le no lh np ll nq lp nr lt ns nk nl nm bi translated">基本案例</li></ol><p id="dda9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们详细看一下每个元素。</p><h2 id="34ca" class="nt mc it bd md nu nv dn mh nw nx dp ml lh ny nz mn ll oa ob mp lp oc od mr oe bi translated">1.函数或数据结构</h2><p id="dff4" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">对所有状态的探索需要一种数据结构，这种数据结构允许跟踪每个状态的解决方案。通常，使用用于迭代扫描的数组(基于自下而上的方法)或用于递归扫描的函数(基于自上而下的方法)。</p><p id="69de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码片段1展示了迭代关系函数和递归关系函数之间的比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段1。Fibonacci序列中第n个元素的自底向上和自顶向下方法的比较。</p></figure><h2 id="f92f" class="nt mc it bd md nu nv dn mh nw nx dp ml lh ny nz mn ll oa ob mp lp oc od mr oe bi translated">1.a .基于自上而下和自下而上的方法</h2><p id="6b6c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe mz na nb nc b">top-down</code>方法意味着从后向前处理问题的递归函数。另一方面，<code class="fe mz na nb nc b">bottom-up</code>方法使用一个数据结构(通常是一个数组)迭代地进行状态依赖建模。</p><p id="47a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mz na nb nc b">top-down</code>方法从状态<code class="fe mz na nb nc b">n</code>开始，直到到达基本情况，而<code class="fe mz na nb nc b">bottom-up</code>方法从基本情况开始，直到到达情况<code class="fe mz na nb nc b">n</code>。</p><h2 id="f9f9" class="nt mc it bd md nu nv dn mh nw nx dp ml lh ny nz mn ll oa ob mp lp oc od mr oe bi translated">2.记忆和制表</h2><p id="69cf" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">记忆和列表是指使用数据结构来跟踪和追踪每个状态的解决方案。</p><p id="c679" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记忆化通常与<code class="fe mz na nb nc b">top-down</code>方法一起使用，其中最常用的数据结构是散列表。制表通常与数据结构是数组的<code class="fe mz na nb nc b">bottom-up</code>方法一起使用。两种策略都允许跟踪每个状态的子问题的解决方案。</p><h2 id="ddfb" class="nt mc it bd md nu nv dn mh nw nx dp ml lh ny nz mn ll oa ob mp lp oc od mr oe bi translated">3.基础案例</h2><p id="0aad" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">基本情况决定了过程的开始(对于<code class="fe mz na nb nc b">bottom-up</code>方法)或结束(对于<code class="fe mz na nb nc b">top-down</code>方法)。</p><p id="beec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，基本情况是不需要应用动态编程就可以定义的情况，换句话说，它是我们开始的情况或我们最终将达到的情况。</p><p id="c45c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Fibonacci数列的<code class="fe mz na nb nc b">top-down</code>和<code class="fe mz na nb nc b">bottom-up</code>方法的基本情况在代码片段2中指出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段2。斐波纳契数列中第n个元素的自下而上和自上而下方法的基本情况。</p></figure><p id="02c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经知道了如何确定一个问题是否可以用动态编程来解决，以及构建一个解决方案的基本组件是什么，那么让我们继续看一个例子，在这个例子中我们将应用到目前为止所学的内容。</p><p id="c7e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们去吧！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="fc30" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">示例:查找第n个斐波那契数列</h1><p id="b5e7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在我们开始解决方案之前，让我们一步一步来。首先，我们需要确定这个问题是否可以用动态编程来解决，所以让我们分析一下斐波那契数列是如何表现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/181be24872c0e3eff59862a041e3aff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbss1A7DYJMykeVP_jeXKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。斐波纳契数列计算的可视化描述。|作者图片</p></figure><p id="8656" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如图3所示，对于每个数字<code class="fe mz na nb nc b">i</code>，需要预先知道数字<code class="fe mz na nb nc b">i-1</code>和<code class="fe mz na nb nc b">i-2</code>的值，也就是说，问题可以分解为子问题，这些子问题在各自的解决方案中具有依赖关系。因此，我们可以说这个挑战可以作为一个动态规划问题来处理。</p><p id="0cdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们应用上一节中看到的框架。第一部分指的是检测将保持每个状态的解的函数或数据结构，其中该函数可以处理<code class="fe mz na nb nc b">bottom-up</code>和<code class="fe mz na nb nc b">top-down</code>方法。</p><p id="e88c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于解释的目的，让我们解决这两种方法。对于<code class="fe mz na nb nc b">bottom-up</code>方法，我们需要一个迭代函数，对于<code class="fe mz na nb nc b">top-down</code>方法，我们需要一个递归函数。</p><p id="a813" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码片段X中，展示了这两种方法的原型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段3。斐波纳契数列第n项的自下而上和自上而下原型。</p></figure><p id="9014" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们需要考虑<strong class="la iu">记忆</strong>或<strong class="la iu">制表</strong>。在这种情况下，出于解释的目的，我们将解决这两个问题。对于<code class="fe mz na nb nc b">bottom-up</code>方法，我们将使用<strong class="la iu">列表</strong>，即包含每个状态的解决方案的数组，对于<code class="fe mz na nb nc b">top-down</code>方法，我们将使用<strong class="la iu">记忆化</strong>，即包含每个状态的解决方案的散列表。</p><p id="96c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在代码片段4中，我们可以看到每种方法的列表和记忆的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段4。展示列表和记忆。</p></figure><p id="83ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们需要解决<strong class="la iu">基础案例</strong>。<code class="fe mz na nb nc b">bottom-up</code>方法以基础案例为起点，直到到达状态<code class="fe mz na nb nc b">k</code>，<code class="fe mz na nb nc b">top-down</code>方法从案例<code class="fe mz na nb nc b">k</code>开始，直到找到基础案例为止。</p><p id="7ada" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码片段5分别显示了<code class="fe mz na nb nc b">bottom-up</code>和<code class="fe mz na nb nc b">top-down</code>方法的基本情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段5。用自下而上和自上而下的方法完整实现斐波那契数列中的第n项。</p></figure><p id="36cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已。寻找斐波纳契数列中的<code class="fe mz na nb nc b">nth</code>数的问题已经用基于动态编程范例的解决方案开发出来了。</p><h1 id="5a32" class="mb mc it bd md me oi mg mh mi oj mk ml jz ok ka mn kc ol kd mp kf om kg mr ms bi translated">结论</h1><p id="15a2" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在这篇博客中，我们看到了如何确定一个问题是否可以用动态编程来解决，如果可以的话，提出和开发一个解决方案需要考虑哪些因素。最后，我们展示了一个示例，展示了如何构建一个基于动态编程的解决方案来解决寻找斐波那契数列的第n个数的问题。</p></div></div>    
</body>
</html>