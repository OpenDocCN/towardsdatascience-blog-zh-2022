<html>
<head>
<title>Random Sampling with SciPy and NumPy: Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SciPy和NumPy进行随机抽样:第一部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/random-sampling-using-scipy-and-numpy-part-i-f3ce8c78812e#2022-04-14">https://towardsdatascience.com/random-sampling-using-scipy-and-numpy-part-i-f3ce8c78812e#2022-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/08c4a7efaed06bcd1a42a2a74b87d3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjYutcq8mNYiu84t7J8N7g.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">由<a class="ae jd" href="https://unsplash.com/s/photos/statistics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jd" href="https://unsplash.com/@edge2edgemedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Edge2Edge媒体</a>拍摄</p></figure><div class=""/><div class=""><h2 id="0a3a" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">介绍采样、编写我们自己的程序、速度测试</h2></div><p id="eb59" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">能够从你选择的分布中随机抽取样本是非常有用的。它是任何一种随机过程模拟的基础，无论是粒子扩散、股票价格运动，还是模拟任何显示某种时间随机性的现象。</p><p id="5a2e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，获得准确高效的采样过程非常重要。一旦我们接触到像正态分布这样到处都在使用的分布，这种重要性只会增加。</p><p id="d8d5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是对SciPy和NumPy如何为我们打包以使大规模采样非常快速和易于使用的“深入探究”。任何有一点使用SciPy历史的人都会告诉你原因如下:</p><ul class=""><li id="b5b5" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">它是由一些非常聪明的人写的</li><li id="5386" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">这是非常优化的代码</li><li id="70b3" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">它使用C语言编写的底层数值例程</li></ul><p id="9666" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这都是真的。这里的目的是更深入地了解这是如何发生的，以及为什么聪明人可以用一些聪明的算法让事情变得更快。</p><h2 id="8421" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">我为什么要关心“引擎盖下”发生了什么？</h2><p id="67f0" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">因为SciPy只能让我们到此为止，尽管<a class="ae jd" href="https://docs.scipy.org/doc/scipy/reference/stats.html" rel="noopener ugc nofollow" target="_blank">它提供的发行范围相当令人难以置信</a>。当我们想从“自定义分布”中取样时，问题就出现了。如果不是从给定的参数化正态或指数分布中采样，而是从我们自己的分布中开始采样，会怎么样？也许是因为这种分布更好地代表了我们试图拟合的数据，我们希望利用蒙特卡罗过程进行一些测试？</p><p id="ff46" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这些情况下，正如我们将在下面看到的，理解它的工作原理是有好处的，因为:</p><ul class=""><li id="ca7d" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">编写自己天真的采样机制可能会慢得令人难以置信</li><li id="158f" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">理解它的工作原理可以让我们在SciPy框架中编写自己的定制发行版</li></ul><h2 id="23fd" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">采样是如何工作的？</h2><p id="d396" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">换句话说:给定一个密度函数(pdf)，我如何使用它来绘制随机样本，如果我绘制它们，它们将形成与pdf相同形状的直方图？为了给这个陈述增加一点视觉效果，让我们用一个正态分布的例子。使用SciPy，让我们绘制pdf，然后生成一系列随机样本，然后再深入了解:</p><ul class=""><li id="7b67" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">它是如何产生这些样本的</li><li id="a3c1" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">它怎么做得这么快</li></ul><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt is gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/e383a8d5ced5f9963ec743d68f4af695.png" data-original-src="https://miro.medium.com/v2/format:webp/1*KSgUJJ3SbNyKNc3soNT7eA.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="2062" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，蓝色线显示我们绘制的pdf，橙色直方图显示我们从同一分布中提取的<code class="fe nl nm nn no b">1,000,000</code>样本的直方图。<strong class="kx jh">这是采样——给定一条指定的蓝线(无论它可能采取什么形状)，我们如何定义一个过程(最好是快速准确的)，可以生成形成与蓝线一致的直方图的数字。</strong></p><p id="73b7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要回答最初的问题<em class="nd">我们如何</em>做到这一点，答案是:视情况而定。有许多方法可以做到这一点，每种方法都有优点和缺点。我们会发现其中一些方法比其他方法快得多。首先，我们将关注一种特定的方法，这种方法是通用的，我们将使用它作为比较SciPy速度的基线。如果我们没有可以与之比较的东西，我们就不能称之为SciPy fast。</p><h2 id="a54a" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">逆变换采样(ITS)</h2><p id="dd4d" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">这里有一些想法，在编写一些基本代码来说明和形成我们的速度基准之前，我们将尝试将其浓缩成几个简短的段落。首先，我们将解决以下问题— <strong class="kx jh">生成随机数需要某种随机数生成器</strong>。</p><p id="c80f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不管我们想从哪个分布中得到它们，我们都需要某种潜在的随机过程。在计算机的情况下，这个过程不可能是真正随机的，因为它需要能够被编程到机器中，但是它们可以是“伪”随机的。</p><p id="5172" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">换句话说，如果我们不知道生成这些数字的基本过程，那么它们对我们来说可能是随机的，即使它们对生成过程来说不是随机的。借用纳西姆·塔勒布的话，圣诞节那天对火鸡随机的东西对农民来说并不随机——这完全取决于你的信息集。这种过程被称为伪随机数发生器(PRNG ),有许多竞争对手提供。</p><p id="a0fa" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们想当然地认为，我们有这样一个PRNG，它产生这些随机数，这些随机数来自均匀分布。如果你对这些数字究竟是如何产生的感到好奇，那么我已经在这里写了一个解释器<a class="ae jd" rel="noopener" target="_blank" href="/where-does-python-get-its-random-numbers-from-81dece23b712"/>，但是对于这篇文章来说，说这样一个过程存在就足够了。</p><div class="ip iq gp gr ir np"><a rel="noopener follow" target="_blank" href="/where-does-python-get-its-random-numbers-from-81dece23b712"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jh gy z fp nu fr fs nv fu fw jf bi translated">python的随机数是从哪里来的？</h2><div class="nw l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ix np"/></div></div></a></div><p id="94c7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们有了这些均匀分布的数字，我们就需要一种方法来<em class="nd">将</em>转换成符合我们指定的pdf的数字(上面的蓝线)。为此，我们可以利用<a class="ae jd" href="https://en.wikipedia.org/wiki/Probability_integral_transform" rel="noopener ugc nofollow" target="_blank">以下定理</a>。事实证明，如果我们:</p><ul class=""><li id="86c1" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">从连续的概率分布中抽取一批数字</li><li id="ab78" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">获取所有这些样本的cdf值</li></ul><p id="a56d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">…这些cdf值的分布将是均匀分布的。</strong>这里有一个很棒的gif <a class="ae jd" href="https://gfycat.com/unfitflatflounder" rel="noopener ugc nofollow" target="_blank">图</a>展示了标准正态分布的过程。但是对我们来说更有用的是反过来——或者说<em class="nd">反</em>。如果我们从一堆均匀分布的随机数开始(我们的PRNG会给我们)，那么我们可以在“逆”cdf上发射它们，并获得一堆遵循我们想要的分布的数。这就是逆变换采样。</p><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="ni nj l"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">来自<a class="ae jd" href="https://gfycat.com/unfitflatflounder" rel="noopener ugc nofollow" target="_blank">https://gfycat.com/unfitflatflounder</a>的GIF</p></figure><h2 id="0d5f" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">我们能把这个编码吗？</h2><p id="5983" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">绝对的。写下来并创建我们自己的正态分布随机抽样器有两个目的:</p><ul class=""><li id="eac2" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">提供一个模拟上述理论解释的代码</li><li id="6c51" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">为SciPy实现创建一个纯python比较来检查速度</li></ul><p id="42a2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先让我们定义我们的pdf。我们不会给SciPy太多的优势，所以为了保持合理的速度，我们将:</p><ul class=""><li id="0931" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">利用NumPy进行矢量化计算</li><li id="7073" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">将<code class="fe nl nm nn no b">sqrt(2 * pi)</code>编码为浮点数，以保存乘法和sqrt操作</li></ul><pre class="ne nf ng nh gt od no oe of aw og bi"><span id="36eb" class="mf mg jg no b gy oh oi l oj ok"># define std normal pdf<br/>def norm_p(x):<br/>    return np.exp(-0.5 * x**2) / 2.5066282746310002</span></pre><p id="6ec8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们需要创建cdf，这样我们就可以反转它。为此，我们将:</p><ul class=""><li id="e13e" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">定义一个数值范围，并计算每个数值的pdf</li><li id="4891" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">归一化pdf值，这样我们就有了一个密度函数，即pdf下的面积为<code class="fe nl nm nn no b">1</code></li><li id="3d9b" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用“累积分布函数”中的“累积”来创建cdf:我们只需对这些pdf值应用累积和来创建我们的cdf</li></ul><p id="03a7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的代码实现了这一点，为了更好地衡量，我们将绘制创建的pdf和cdf以供检查。</p><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt is gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/4608843559ab6d466608871fc9fa31d7.png" data-original-src="https://miro.medium.com/v2/format:webp/1*hcxdwkZtlYiNdVje-IZFLQ.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="0af7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以看起来在意料之中。现在我们需要获取生成的CDF——此时它只是一组x值的累积概率值，并将其转换为一个函数。特别是我们想把它变成反函数。幸运的是，我们可以依靠SciPy并使用插值函数<code class="fe nl nm nn no b">interp1d</code>:</p><pre class="ne nf ng nh gt od no oe of aw og bi"><span id="2e78" class="mf mg jg no b gy oh oi l oj ok"># generate the inverse cdf<br/>func_ppf = interp1d(my_cdf, xs, fill_value='extrapolate')</span></pre><p id="b652" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们称之为“PPF”——百分点函数，因为这与SciPy术语一致，但这正是我们想要实现的——反向cdf函数。现在我们有了这个函数，我们可以用它来:</p><ul class=""><li id="4149" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">首先:向它发射均匀分布的随机数，从标准正态分布中产生样本</li><li id="c0e1" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">第二:比较它与内置的SciPy采样相比有多快</li></ul><h2 id="e559" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">分配检查</h2><p id="44f3" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">首先，让我们仔细检查一下，以确保我们是根据正确的分布来生成数字的——换句话说，我没有将一个错误集中到上面几行代码中。如前所述，现在我们有了反向cdf，我们只需要向它发射随机均匀分布的数。我们如何获得那些均匀分布的随机数？</p><p id="2a77" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们利用NumPy中的随机数生成器:</p><figure class="ne nf ng nh gt is"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="ne nf ng nh gt is gh gi paragraph-image"><div class="ab gu cl nk"><img src="../Images/2168e00c6ed7634022da45ba4ee2b1fb.png" data-original-src="https://miro.medium.com/v2/format:webp/1*EaaooGhrpE5IMu1hUX_0xg.png"/></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">作者图片</p></figure><p id="366e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们可以确信我们创建的函数确实从标准正态分布中抽取了随机样本——我们的橙色直方图与SciPy生成的代表pdf的蓝色线条对齐。</p><h2 id="b248" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">速度</h2><p id="be38" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">现在进入主要问题——我们生成的函数与SciPy相比如何？</p><pre class="ne nf ng nh gt od no oe of aw og bi"><span id="61a5" class="mf mg jg no b gy oh oi l oj ok">%timeit func_ppf(np.random.uniform(size=n))</span><span id="6331" class="mf mg jg no b gy ol oi l oj ok">2.32 s ± 264 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span><span id="4ab2" class="mf mg jg no b gy ol oi l oj ok">%timeit snorm.rvs(size=n)</span><span id="cef2" class="mf mg jg no b gy ol oi l oj ok">56.3 ms ± 1.08 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="ab6d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，即使我们尽了最大努力来创建一个正态分布采样器的有效实现，我们仍然比做同样事情的SciPy慢。这就引出了下一个问题:为什么？</p><h2 id="578a" class="mf mg jg bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">概述</h2><p id="8744" class="pw-post-body-paragraph kv kw jg kx b ky my kh la lb mz kk ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">在深入研究SciPy和NumPy代码库以弄清楚为什么我们在速度方面仍然落后之前，让我们简单回顾一下我们已经建立的东西:</p><ul class=""><li id="577a" class="lr ls jg kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">抽样是抽取随机数的过程，这些随机数作为一个集合遵守给定的pdf</li><li id="72c5" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">有许多方法可以实现这种采样，其中一种方法称为逆变换采样</li><li id="f8be" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">它依赖于在插入均匀分布的随机数之前对给定分布的cdf求逆</li><li id="c67a" class="lr ls jg kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">即使有相当有效的自我实现，我们也比SciPy慢大约<code class="fe nl nm nn no b">40x</code></li></ul><p id="b207" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">记住这一点，<a class="ae jd" rel="noopener" target="_blank" href="/random-sampling-with-scipy-and-numpy-part-ii-234c2385828a">让我们继续第二部分</a>，开始挖掘SciPy和NumPy代码库。</p><div class="ip iq gp gr ir np"><a rel="noopener follow" target="_blank" href="/random-sampling-with-scipy-and-numpy-part-ii-234c2385828a"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd jh gy z fp nu fr fs nv fu fw jf bi translated">用SciPy和NumPy随机抽样第二部分</h2><div class="nw l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="nx l"><div class="om l nz oa ob nx oc ix np"/></div></div></a></div></div></div>    
</body>
</html>