<html>
<head>
<title>Graph Sampling Strategies for Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">聚类的图抽样策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-sampling-strategies-for-clustering-42a05a61a5d3#2022-04-13">https://towardsdatascience.com/graph-sampling-strategies-for-clustering-42a05a61a5d3#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f10" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在采样图上生成高模块性聚类</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6fbe4cc3ce629f941c7083ee8ae5a328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VXLyGJYKgM5xhJ4V"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">纳斯蒂亚·杜尔希尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b5be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">图表是需要分析的复杂结构，如果它们变得太大，处理起来会很有挑战性。在过去的几年中，对巨大图表的分析一直是一个热门的研究领域，产生了像<a class="ae kv" href="https://ogb.stanford.edu/" rel="noopener ugc nofollow" target="_blank"> OGB </a>和<a class="ae kv" href="https://ogb.stanford.edu/docs/lsc/" rel="noopener ugc nofollow" target="_blank"> OGB-LSC </a>这样的倡议。</p><p id="7538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试处理这些大型图表的一种方法是，以保持原始结构在样本上的方式对它们进行采样，然后在采样的图表上进行分析。</p><p id="6efb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，图形不容易取样。当您删除节点或边时，如何处理您将拥有的信息丢失？为了开始研究这个主题，今天我们将回顾并实现论文<a class="ae kv" href="https://www.semanticscholar.org/paper/Clustering%2C-Prominence-and-Social-Network-Analysis-Hegde-Magdon-Ismail/cf65c5e1fa99947c9402cd4ed43c9485fcd1b197" rel="noopener ugc nofollow" target="_blank">不完全网络上的聚类、显著性和社会网络分析</a> [1]，该论文提出了两种图的边采样算法。</p><p id="63a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将从理解论文的观点、局限性和作者提出的结果开始。然后，我们将实现它，尝试解决它的一个限制，看看这个方法是否真的有效。</p><p id="aab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用于分析的笔记本可在<a class="ae kv" href="https://www.kaggle.com/tiagotoledojr/incomplete-networks-analysis" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>和我的<a class="ae kv" href="https://github.com/TNanukem/paper_implementations/blob/main/Incomplete%20Networks%20Analysis.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。</p><h2 id="21b4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">初步考虑</h2><p id="b34a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我们来介绍一下论文的基本假设。通过对采样图应用聚类方法来测试采样方法，以查看在原始图上得到的聚类是否类似于或优于在完整图上应用相同算法。</p><p id="3799" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，他们使用了一种叫做SpeakEasy的算法。因为我找不到这个算法的Python实现，所以我使用了NetworkX上的<a class="ae kv" href="https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.community.modularity_max.greedy_modularity_communities.html" rel="noopener ugc nofollow" target="_blank">贪婪模块化最大化</a>算法。</p><p id="dba0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们还分析了几个指标。对于这个分析，我只考虑了模块化，这是本文中考虑的许多因素之一。</p><p id="a1a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该论文指出，这种方法仅用于无向图。对于使用邻接矩阵对称性的第一种算法来说尤其如此。然而，在这个分析中，我考虑了一个旨在观察这些方法如何成立的网络。</p><p id="c614" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，需要记住的一件重要事情是，这些方法依赖于邻接矩阵的创建，对于具有数十亿个节点的图来说，表示邻接矩阵以生成样本是不可行的。作者指出，其他表示是可能的，但没有进一步深入细节。</p><p id="df2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了分析结果，我考虑了4个网络，它们都可以在斯坦福大学的快照上免费获得。在这篇文章中，我将向你展示其中两个的结果:<a class="ae kv" href="http://snap.stanford.edu/data/ego-Facebook.html" rel="noopener ugc nofollow" target="_blank">自我-脸书网络</a> [2]，一个由来自脸书的朋友列表组成的无向网络，和<a class="ae kv" href="http://snap.stanford.edu/data/p2p-Gnutella08.html" rel="noopener ugc nofollow" target="_blank"> p2p-Gnutella08 </a>网络[3]，一个由点对点文件共享网络组成的有向图。</p><p id="1768" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每种算法和样本大小都应用了几次，以说明结果的随机性。</p><h2 id="67ea" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">采样策略1</h2><p id="a8b2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">第一种策略使用邻接矩阵上的采样，然后使用线性回归来尝试估计被采样掉的丢失链接。使用来自该回归的预测，创建新的邻接矩阵，并对其应用该算法。</p><p id="e36f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">算法如下:</p><ul class=""><li id="3e30" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">是图G的邻接矩阵</li><li id="7761" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">从邻接矩阵中随机抽取K列，并将它们的索引保存在变量K中</li><li id="da30" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">样本X -&gt; X = A(:，K)</li><li id="1baa" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">创建一个目标Y，用A -&gt; Y(K，:= X(N-K，:)的对称性质部分填充。T</li><li id="4236" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">使用X -&gt; Y_hat = X(X- Y)的Moore-Pensore伪逆进行线性回归</li><li id="2eb0" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">用采样的列生成新的邻接矩阵:A_hat(:，K) = X</li><li id="1c2e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">添加重建的列:A_hat(:，N-K) = Y_hat</li></ul><p id="ba45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这里直接使用了矩阵的对称属性来定义y。让我们看看这个实现在Python中是什么样子的:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="dd4d" class="ls lt iq nf b gy nj nk l nl nm">def algorithm_1(A, sample_size, n, N):</span><span id="da18" class="ls lt iq nf b gy nn nk l nl nm">    k = sample_size<br/>    K = randsample(N, k)</span><span id="491b" class="ls lt iq nf b gy nn nk l nl nm">    X = A[:, K]<br/>    <br/>    set_ = list(set(N) - set(K))<br/>    <br/>    Y = np.zeros((n, n-k))</span><span id="62cc" class="ls lt iq nf b gy nn nk l nl nm">    Y[K, :] = X[set_, :].T<br/>    Y_hat = np.dot(X, np.dot(np.linalg.pinv(X), Y))<br/>    A_hat = np.zeros((n,n))</span><span id="e16c" class="ls lt iq nf b gy nn nk l nl nm">    A_hat[:, K] = X<br/>    A_hat[:, list(set(N) - set(K))] = Y_hat</span><span id="0665" class="ls lt iq nf b gy nn nk l nl nm">    G_algo1 = nx.from_numpy_matrix(A_hat)<br/>    return G_algo1</span></pre><p id="4617" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中randsample方法实现为:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2a9f" class="ls lt iq nf b gy nj nk l nl nm">def randsample(N, k):<br/>    K = np.random.choice(N, size=k, replace=False)<br/>    if type(K[0]) == str:<br/>        K = [int(i) for i in K]</span><span id="ffe2" class="ls lt iq nf b gy nn nk l nl nm">    return K</span></pre><p id="db12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，这是论文中提出的算法的直接实现。注意，在纸上，矩阵Y_hat的维数是错误的，它应该是(n，n)否则矩阵运算将没有意义。</p><p id="282d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现了这个方法之后，我注意到线性回归并没有生成比原始图更小的图，而是生成了更多的边。我们将在分析中看到，这使得聚类算法在采样图上比在原始图上花费更长的时间。</p><p id="0d6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于脸书网络，就执行时间而言，正如我所说的，采样图更糟:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/1f3a2a46a0d1b51f90651c57d8151d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ay-yq2VxG5RY6FHayTZbPw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">脸书网络中算法1的运行时间。由作者开发。</p></figure><p id="fd6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们谈到模块性时，在大约40%的样本大小之后，采样图能够超过原始图上的模块性，但是以更大的运行时间为代价。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/3a9564754e836c519794c32f64b49684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jusd_7EoheQ4QU01JRK8bQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">算法1采样的脸书网络上的聚类的模块性。由作者开发。</p></figure><p id="75d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，重要的是要注意，对于这里没有展示的一个网络，也是无向的，这种采样方法不能超越模块性，并且花费的时间也更长。更多详情请参考笔记本。</p><p id="8716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，对于p2p-Gnutella网络，在经过的时间上发生了相同的现象，但是这一次，模块性甚至没有接近最初的模块性，如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/54d0b52f155c9ec17ef6dbeaba29d4e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4WHrgWtC0TPt7oFKPzinQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">p2p-gnu网络中算法1的运行时间。由作者开发。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/dc681002537c75142ce043e9d7c7934f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iu-HlQRMegzDUXgK8LjNsw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">算法1采样的脸书网络上的聚类的模块性。由作者开发。</p></figure><h2 id="f4ae" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">采样策略2</h2><p id="e82c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">第二种采样策略包括对原始邻接矩阵进行多次采样，然后汇总结果以生成要考虑的新图。</p><p id="6f9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法具有改变边的权重的效果，使其补偿从网络中移除的边。算法如下:</p><ul class=""><li id="82ef" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">是图G的邻接矩阵</li><li id="2fa2" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">从邻接矩阵中随机抽取K列，并将它们的索引保存在变量K中</li><li id="5fd5" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">从A -&gt; X1(:，K) = A(:，K)中得到K列</li><li id="adbc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">应用对称属性-&gt; X1(K，)= A(K，:)。T</li><li id="524a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">通过由节点数量的平方根的倒数构成的矩阵a P中的缩放因子来缩放X-&gt; X1 = diag(P1)* X1</li><li id="4c61" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">生成一组新的列，删除先前采样的列，并将其保存到X2</li><li id="9aa4" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">生成新的邻接矩阵作为对样本的思考-&gt; A_hat = alpha * X1 + (1-alpha)*X2</li></ul><p id="7b75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Python实现它，就变成了:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="528e" class="ls lt iq nf b gy nj nk l nl nm">def algorithm_2(A, sample_size, n, N, symmetric=True):<br/>    <br/>    def construct_X(N, k):<br/>        K = randsample(N, k)</span><span id="97e7" class="ls lt iq nf b gy nn nk l nl nm">        X1 = np.zeros((n, n))<br/>        X1[:, K] = A[:, K]</span><span id="85b5" class="ls lt iq nf b gy nn nk l nl nm">        if symmetric:<br/>            X1[K, :] = A[:, K].T</span><span id="68d6" class="ls lt iq nf b gy nn nk l nl nm">        P1 = np.full((n,n), np.sqrt(1 / n))<br/>        X1 = np.diag(P1) * X1<br/>    <br/>        return X1, K<br/>    <br/>    k = int(np.floor(sample_size / 2))</span><span id="39a4" class="ls lt iq nf b gy nn nk l nl nm">    alpha = 0.5<br/>    X1, K1 = construct_X(N, k)<br/>    X2, K2 = construct_X(list(set(N) - set(K1)), k)</span><span id="5e98" class="ls lt iq nf b gy nn nk l nl nm">    A_algo2 = alpha * X1 + (1 - alpha) * X2<br/>    G_algo2 = nx.from_numpy_matrix(A_algo2)<br/>    <br/>    return G_algo2</span></pre><p id="edb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我必须在这里提请你注意，我做了一个在论文中提出的简化版本。本文利用线性代数中的一些特定的采样机制生成第二矩阵。为了简单起见，我又做了一次随机抽样。这可能会影响该方法的性能。</p><p id="1c63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，看看结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/cc73d3efadf69220d7820a078b06c9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ideLNjfpQIxbvrPzb8ZBQA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">脸书网络中算法2的运行时间。由作者开发。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/7485c266227039ed1e66c7b75ebe62ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J4TYjrPk-eIB_nFuY7vM4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">算法2采样的脸书网络上聚类的模块性。由作者开发。</p></figure><p id="2298" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们可以看到的，对于脸书网络，该算法能够生成更快的聚类，甚至能够超过全网络上的原始模块性，这是一个非常好的结果，因为该方法简单。</p><p id="a651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，对于p2p-gnu网络，我们不能说同样的话:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/35be08f36cfd2eba98cf3b07991d2d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bE29l1cdn3xT0K99WaF7IA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">p2p-gnu网络中算法2的运行时间。由作者开发。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/5982a60f64e7066f5f2fcbc44ec60e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkD1vtuepmWpqwwq6VooKg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">算法2采样的p2p-gnu网络聚类的模块性。由作者开发。</p></figure><p id="b402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，聚类运行得更快，但是，即使使用更高的采样方法，采样图也无法实现完整图的模块性度量。</p><p id="cc45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面链接的笔记本上，Ca-Gr网络取得了很好的模块化效果。这表明放松该算法的对称条件会严重损害其性能。</p><h2 id="d911" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="21ba" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在本文中，我们探讨了两种用于聚类目的的图形采样机制。我们试图验证这些方法的对称性假设是否真的有必要，并试图重现这篇论文的观点。</p><p id="1b05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次注意，在开发过程中对算法做了一些简化。</p><p id="fb7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这能对您作为数据科学家的旅程有所帮助。</p><p id="7cab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] Hegde，k .，Magdon-Ismail，m .，Szymanski，B.K .，&amp; Kuzmin，K. (2016)。不完全网络上的聚类、突出和社会网络分析。<em class="nv">复杂网络</em>。</p><p id="a7b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]麦考利和莱斯科维奇。<a class="ae kv" href="http://i.stanford.edu/~julian/pdfs/nips2012.pdf" rel="noopener ugc nofollow" target="_blank">学习在自我网络中发现社交圈</a>。NIPS，2012。</p><p id="8479" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3] M. Ripeanu和I. Foster和A. Iamnitchi。<a class="ae kv" href="http://snap.stanford.edu/data/p2p-Gnutella08.html" rel="noopener ugc nofollow" target="_blank">绘制Gnutella网络:大规模对等系统的特性和系统设计的含义。</a> IEEE互联网计算杂志，2002年。</p></div></div>    
</body>
</html>