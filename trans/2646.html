<html>
<head>
<title>Finding the Best Classification Threshold for Imbalanced Classifications with the Interactive Confusion Matrix and Line Charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用交互式混淆矩阵和折线图寻找不平衡分类的最佳分类阈值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-the-best-classification-threshold-for-imbalanced-classifications-with-interactive-plots-7d65828dda38#2022-06-08">https://towardsdatascience.com/finding-the-best-classification-threshold-for-imbalanced-classifications-with-interactive-plots-7d65828dda38#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1c28" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用binclass-tools amazing Python包将您对二进制分类问题的分析提升到一个新的水平</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/084294be2a1337283f11f8612fd9857f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huI5ZSphdpmD5UN9p64usw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5e1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即将训练分类模型的数据科学家经常发现自己在分析产生的<em class="lu">混淆矩阵</em>以查看模型的性能是否令人满意。让我们仔细看看这是怎么回事。</p><h2 id="7eae" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">引入混淆矩阵</h2><p id="2905" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">术语“混淆”是指一个观察值可能被模型正确或错误地预测，然后在分类中被混淆。如果我们考虑一个二元分类模型(其可能的结果只有两个，例如，<em class="lu">真</em>或<em class="lu">假</em>)，该模型的混淆矩阵是一个矩阵，该矩阵组织了为测试数据集的目标变量(作为模型的输入给出)获得的与该变量在数据集中呈现的真值相关的预测输出。通过这种方式，可以识别正确预测的数量和错误预测的数量(<em class="lu">假阳性</em>和<em class="lu">假阴性</em>)。将问题中感兴趣的类别定义为<em class="lu">正</em>(例如，交易是欺诈性的，因此<em class="lu">真</em>是正类别)，<strong class="la iu">假正</strong>是那些预测为真(预测的正类别)，但实际上不是(假预测)的观察；<strong class="la iu">假阴性</strong>则是那些观测值被预测为假(负类预测)，而实际上不是(假预测)。理解了这些定义，你就可以自己推导出<em class="lu">真阳性</em>和<em class="lu">真阴性</em>的含义。</p><p id="0a9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模型结果的这种排列允许理解模型的性能是否如预期的那样。通常，二元模型的混淆矩阵如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/82f356ee4d0613c13e6a99c877e2ad19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*mz3kTkn6DgQFZv4hYQAMlw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1-二元分类的混淆矩阵示例(作者图片)</p></figure><p id="c153" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦确定了混淆矩阵的4个象限的值，就有可能确定测量模型性能的定量和定性指标，如参考文献所示(见参考文献1)。1).</p><p id="7605" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍看起来，混淆矩阵的四个象限的值对于被分析的模型是不变的。然而，在幕后，这些值是基于一个非常具体的假设计算出来的。</p><h2 id="e15f" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">注意分类阈值</h2><p id="69c9" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">二元分类模型主要为目标变量中的每个类返回相似概率得分，该得分提供了一种度量方法，用于衡量针对该观察值获得的预测为正类的可能性。如果您使用Python来训练分类模型，我们讨论的分数通常是通过Scikit-learn <code class="fe mu mv mw mx b">predict_proba</code>函数获得的。该分数具有以下属性:</p><ul class=""><li id="647a" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">它是一个介于0和1之间的实数</li><li id="bb1f" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">将把一个观察关联到正面类的分值和把同一观察关联到负面类的分值相加，我们得到1</li></ul><p id="9b4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何学过一点数学的人都会认识到，这些属性与概率度量的定义是相同的。然而，我们的分数并不是一个真正的概率度量，即使通过应用一种称为<a class="ae nm" href="https://kiwidamien.github.io/are-you-sure-thats-a-probability.html" rel="noopener ugc nofollow" target="_blank"> <em class="lu">模型校准</em> </a>的变换，有可能使我们的分数近似于一个概率度量。也就是说，我们之前讨论的关于混淆矩阵值的假设如下:</p><blockquote class="nn"><p id="0abb" class="no np it bd nq nr ns nt nu nv nw lt dk translated">通常，考虑到如果得分大于或等于0.5，则预测是正类，如果得分小于0.5，则预测是负类，来计算与二元分类模型相关联的混淆矩阵所示的TP、TN、FP、FN的值</p></blockquote><p id="0ead" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">前一语句的0.5值被称为<strong class="la iu">分类阈值</strong>，可以在0和1之间变化。为了理解阈值的用途，假设您已经训练了一个二进制分类模型来检测房屋火灾中的烟雾。您的模型将在安装于厨房的真实烟雾探测器中实现。现在假设测试产品的实验室将探测器安装在烤肉的炉子附近。如果传感器阈值设置得较低，在烤肉时，探测器很可能会报告火灾(<em class="lu">假阳性</em>)。为了使探测器更可靠，实验室技术人员应该在几次实验后将阈值增加到被认为适合识别真实火灾的值。</p><p id="7167" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">改变阈值，我们去修改预测的类。例如，使用阈值0.5(得分0.54大于阈值0.5，因此观察结果为真)分类为<em class="lu">真</em>的观察结果，如果阈值变为0.6(得分0.54小于阈值0.6，因此为假)，则变为<em class="lu">假</em>。因此，通过改变阈值，我们前面提到的所有定量和定性指标(例如，<em class="lu">精度</em>和<em class="lu">召回</em>)也会发生变化。所以，很明显:</p><blockquote class="nn"><p id="3044" class="no np it bd nq nr ns nt nu nv nw lt dk translated">分类器性能随着阈值的变化而变化</p></blockquote><p id="de24" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">因此，您应该很好地理解，使用默认值为0.5的阈值的分类器可能会导致低质量的结果，尤其是在处理<em class="lu">不平衡数据集</em>时，因为不平衡数据的概率分布往往偏向多数类。</p><p id="7bb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一点上，一旦模型已经被训练，问题是:“好的，现在我应该为我的模型使用什么阈值？”。通常适用于任何复杂决策情况的坏消息是:</p><blockquote class="nn"><p id="b42c" class="no np it bd nq nr ns nt nu nv nw lt dk translated">不存在适用于所有情况的最佳阈值。这取决于要满足的业务需求。</p></blockquote><p id="e41e" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在我们详细讨论阈值调整的不同情况之前，让我们快速提醒一下最常用于<em class="lu">不平衡分类</em>的指标，它们是更复杂的训练和测量模型。</p><h1 id="bc18" class="oc lw it bd lx od oe of ma og oh oi md jz oj ka mg kc ok kd mj kf ol kg mm om bi translated">不平衡分类的评价指标</h1><p id="9984" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">让我们回想一下下面一些对初学者有用的基本概念，以便能够测量不平衡二进制分类的性能。当所分析的情况不同时，同样的概念将有助于解释最佳阈值。</p><h2 id="4a6f" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">精确度-召回率的权衡</h2><p id="0cda" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">假设您需要训练一个二进制分类模型来检测欺诈性信用卡交易。这是一个典型的<em class="lu">不平衡问题</em>，对于这个问题，感兴趣类别(欺诈交易=正类别)中的标签数量远远小于负类别中的标签数量。在这种情况下，为了评估分类器，经常考虑的度量是<em class="lu">精度</em>和<em class="lu">召回</em>(在平衡问题的情况下，经常考虑<em class="lu">灵敏度</em>和<em class="lu">特异性</em>)。</p><p id="2e97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，需要提出的问题是:“将健康交易归类为欺诈更严重，还是将欺诈交易归类为健康更严重？”。如果对一个健康的事务强制进行检查，那么您的成本就是检查所需的时间。另一方面，如果欺诈性交易被错误分类为健康的，欺诈的成本显然高于前一种情况。</p><p id="0387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">被错误分类为健康(负面类别)的欺诈交易(正面类别)属于<em class="lu">假阴性</em> (FN)集合。当FNs减少时，一个增加的指标(保持TPs数量不变)就是<em class="lu">回忆</em>。事实上，看看回忆的定义，我们有:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/7c02610b8acd349791cf96b510568573.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*pdRiye49mMvpMmu5T7VUdg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2 —回忆的定义(作者提供的图片)</p></figure><p id="ea09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的公式可以明显看出，如果我们想通过使fn的数量趋向于0来最小化fn的数量，那么召回的值将趋向于TP/TP = 1。</p><p id="e751" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，首先要做的是将阈值移动到使回忆最大化的值1。不幸的是，人们会发现，要使回忆趋于1，必须将阈值移动到非常接近0。但这将意味着把几乎所有的交易都归类为欺诈！实际上，召回公式中不存在的假阳性(FPs)的数量不成比例地增长，并且分类器在所有被预测为欺诈的观察结果中辨别实际上是欺诈的观察结果的能力被取消。换句话说，名为Precision的指标值急剧下降到零，这可以从下面定义它的公式中看出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/b2416982bd0b65bd96f512b2ec1bc8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*Qf6Lwg-x0pjrkKFzivXWhQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3——精度的定义(图片由作者提供)</p></figure><p id="769e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上式可以看出，如果FPs趋向于比TP大得多的数N，精度就会趋向于TP/N~0</p><p id="f4ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你所了解的是著名的<em class="lu">精确-召回权衡</em>，它包括以下内容:</p><blockquote class="nn"><p id="d03b" class="no np it bd nq nr ns nt nu nv nw lt dk translated">不可能同时拥有高精度和高召回率，除非你处理的是一个完美的模型(FP = FN = 0)。对于不太完美的模型，如果提高精度，就会降低召回率，反之亦然。</p></blockquote><p id="8520" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">下面显示了一个示例模型的精度-召回曲线，展示了上述权衡:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/f7fe67266f76bacf88610f2f0f68abc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*BgiFREbjm34TypABBzahAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4——精确召回曲线(图片由作者提供)</p></figure><p id="8206" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了兼顾精确度和召回率，我们可以考虑由两者的调和平均值给出的度量，也称为<em class="lu">F1-得分</em>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/32a522300d3a281de795c672e76c0c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*O2IFIxHw_alr6_EOJLWrrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5—F1的定义(图片由作者提供)</p></figure><p id="b6df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您希望对其中一个定义指标给予更多权重，您可以通过引入“不平衡”β系数来推广该公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d73ec2cac718013821e3554be7ecde53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*vY5FyR6IXjUu6NSbXFzaWg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6-F-beta的定义(作者提供的图片)</p></figure><p id="bd75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果您认为召回率是精确度的两倍，那么您可以将β设置为2。反过来，如果你相信精度比召回率重要2，那么β就会。</p><p id="dc53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到我们的欺诈交易问题，已经确定召回比精确度重要得多，您可以考虑β &gt; 1并优化阈值，以便F分数取最大值。</p><h2 id="593d" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">从精确度、召回率和F值到马修斯相关系数</h2><p id="9e65" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">有一个重要的事实需要考虑。精度和召回率(以及F值，F值是两者的函数)将正面类视为感兴趣的类，回答以下问题:</p><blockquote class="nn"><p id="b8c3" class="no np it bd nq nr ns nt nu nv nw lt dk translated">"在所有肯定预测的例子(FP + TP)中，有多少肯定检测(TP)是正确的？"(精度)</p><p id="8ae8" class="no np it bd nq nr ns nt nu nv nw lt dk translated">“在所有实际的正面例子(FN + TP)中，我们能够识别多少正面例子(TP)？”(回忆)</p></blockquote><p id="6399" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">如果你仔细看上面的定义，<strong class="la iu">真否定</strong> (TN)从来不会出现。如果感兴趣的类(较罕见的类)被标记为正的(大多数情况下都是这样)，这就不是问题。例如，在这种情况下，F1分数仍然是不平衡分类的有效指标。事实上，如果模型没有正确地预测负类，则不正确的预测将馈入FPs。因此，精度的值将减少，因为它被定义为TP/(FP+TP)，因此F1-score的值也将减少。总之，在这种情况下，较少的负类正确预测了较低的F1分数。</p><p id="5170" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有时可能发生的情况是，感兴趣的类没有被标记为正面的，而是被标记为负面的。在这种情况下，F1值会误导对问题的正确分析。有关更多详细信息，请查看参考资料(参考。7).</p><p id="0882" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，需要引入一种新的度量，该度量也将TNs考虑在内，并且不管正类分配如何都是稳定的。</p><p id="0cf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那些研究过一些统计学的人肯定遇到过<em class="lu">克拉默相关系数</em> ( <em class="lu">克拉默相关系数V </em>)，它测量两个分类变量之间的关联强度。1975年，Brian W. Matthews引入了一个相关系数，它是应用于2x2混淆矩阵的cramér V的一个特例。我们正在讨论的<strong class="la iu">马修斯相关系数</strong> (MCC)定义如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/fd086e8904d5c9a0a6d9feaa2b656367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83YBNrk43rlOLtT3_M0Swg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7 —马修斯相关系数的定义(图片由作者提供)</p></figure><p id="4a6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与通常的相关系数一样，MCC也取[-1，1]范围内的值。在分类的情况下，值-1表示模型预测正类和负类的方式与它们在目标变量中呈现的实际值完全相反。如果MCC取值为0，则模型随机预测正类和负类。在值为1的情况下，模型是完美的。此外，如果正类被重命名为负类，MCC是不变的，反之亦然。MCC的主要特点如下:</p><blockquote class="nn"><p id="cff6" class="no np it bd nq nr ns nt nu nv nw lt dk translated">只有当模型能够正确预测大多数正面观察值和大多数负面观察值时，MCC才是唯一得分高的指标。</p></blockquote><p id="b199" class="pw-post-body-paragraph ky kz it la b lb nx ju ld le ny jx lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">在快速回顾了不平衡分类问题(处理起来最复杂)中最常用的指标之后，我们可以回到文章的主题，即如何在这些情况下设置阈值。</p><h1 id="3ff5" class="oc lw it bd lx od oe of ma og oh oi md jz oj ka mg kc ok kd mj kf ol kg mm om bi translated">为您的模型选择正确的阈值</h1><p id="adc7" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">确定阈值的“最佳值”意味着找到使特定目标函数最大化或最小化的值，该值衡量模型的良好性，并适合要解决的业务问题。归根结底，这是一个优化问题。</p><p id="f427" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，有两种优化阈值的方法:</p><ul class=""><li id="6401" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">基于特定<em class="lu">指标的优化</em></li><li id="54ca" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">基于<em class="lu">成本</em>的优化</li></ul><p id="17b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一种情况下，选择感兴趣的<strong class="la iu">度量</strong>(例如，F2分数，或MCC)并识别所选度量指示模型的最大性能的阈值(意味着必须根据其性质最大化或最小化度量)。</p><p id="e7d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，在第二种情况下，使用所谓的<strong class="la iu">成本矩阵</strong>，由此成本可以与混淆矩阵的每个类别相关联。这样，通过最小化与每个类别相关联的成本的总和来给出最佳阈值。</p><p id="a2a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦确定了感兴趣的目标函数，不管它是度量还是成本，也不管它是需要最大化还是最小化，都有可能通过操作所谓的<strong class="la iu">阈值移动</strong>来找到最佳阈值:</p><ol class=""><li id="c402" class="my mz it la b lb lc le lf lh na ll nb lp nc lt ot ne nf ng bi translated">将阈值从0变化到1，步长例如为0.01，记录每个阈值的目标函数值。</li><li id="f94b" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated">选择使函数最大化(或最小化)的阈值。</li></ol><p id="801a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，以这种方式识别的值将严格依赖于训练数据集，并且它可能不是阈值的最佳值的良好估计。</p><p id="57f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最近开发了一种通用方法，该方法总是基于从训练数据集获得的目标函数值，称为<strong class="la iu"> GHOST </strong> ( <strong class="la iu"> G </strong>一般化T<strong class="la iu">H</strong>resh<strong class="la iu">O</strong>LD<strong class="la iu">S</strong>HIF<strong class="la iu">T</strong>ing过程)。总之，它使用通过分层随机抽样提取的训练数据集的N个子集，以便它们保持类别分布。然后，对于每个子集，它应用由每个阈值给出的目标函数。这样，对于每个阈值，将有由N个子集给出的目标函数的N个值。此时，它会计算上述值的每个阈值的中值，因此您只能获得一个与阈值相关的“稳定”值。您可以在参考资料中找到更多详细信息(参考。8).</p><h1 id="efbc" class="oc lw it bd lx od oe of ma og oh oi md jz oj ka mg kc ok kd mj kf ol kg mm om bi translated">使用binclass-tools Python包控制一切</h1><p id="c644" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">现在，深入分析的所有方面的总体情况都更清楚了，您很好地理解了主要困难之一是随着阈值的变化，要有手头上最重要的指标的视图。只有这样，您才能够根据所选择的业务标准，快速了解模型的性能何时接近期望的性能。</p><p id="3186" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正是这种需求促使我开发了一个新的Python包，其中包含一些用于这种类型分析的有用工具。我们正在谈论令人惊奇的<strong class="la iu"> binclass-tools </strong>软件包:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/851dd9a965c4069eb2aed452e36de8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-knxbcsXHLCym7fLGsWGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8—bin class-tools包的徽标(图片由作者提供)</p></figure><p id="a6e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看这个包提供的一些最重要的工具。</p><h2 id="8eb3" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">交互混淆矩阵</h2><p id="0797" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">软件包中最有趣的工具之一是<strong class="la iu">交互式混淆矩阵</strong>，这是一个交互式图表，允许您查看二进制分类的最重要指标如何随着阈值的变化而变化，包括与矩阵中的类别相关联的任何金额和成本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/8f76b4905c8d3d20f76fd3a2d824854e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jatqd97CEO9VDv24KvK_VQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9 —交互式混淆矩阵的实例</p></figure><p id="ca95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从<em class="lu">图9 </em>中可以看出，阈值与范围从0到1的滑块相关联，具有用户选择的步长(在本例中为0.02)。随着滑块的移动，一些显示的测量和指标会相应地改变。</p><p id="28a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">剧情分为两部分:</p><ul class=""><li id="4497" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">底部是<strong class="la iu">混淆矩阵</strong>，它突出显示了属于TP、TN、FP、FN类别的观察数量以及与单个观察相关的数量或成本的可能度量。这是因为通过对从训练数据集的一列中获取的单个观察值进行求和来查看与每个类别相关联的总量如何变化可能会很有趣。类似地，通过对每个观察的平均成本或每个观察的成本列表中的值求和，来查看与每个类别相关联的总成本如何变化可能是有趣的。这些值显然会随着阈值的变化而变化，每个值旁边都显示了它在总数中所占的百分比值</li><li id="5922" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">最上面是三张桌子。左边的第一个包含所有依赖于阈值的度量，因此将随着载玻片的移动而变化(例如，准确度、F1分数等。).另一方面，中间的表包含所有那些随着阈值变化而不变的指标(例如ROC AUC或PR AUC)。只有在调用生成图的函数时指定了右边的第三个也是最后一个表，并且该表包含相对于左边的列中显示的指标而言最佳的所有阈值时，该表才会出现。目前可以优化的指标有Cohen's kappa、Matthews相关系数、ROC曲线、F1-得分、F2-得分、f 0.5-得分和成本。在1.1.0版之前，最佳阈值的计算是通过GHOST完成的(如前一节所述)。从版本1.1.0开始，图中显示的最佳阈值只是与给定数据集的已实施指标的最佳值相关联的阈值(即:最大化F分数、MCC和Kappa以及最小化成本的阈值)。实现GHOST方法的函数在包中仍然可用，并可用于获得通常优化给定指标的阈值(最佳实践:使用训练集进行优化，并对新数据使用这些阈值)。</li></ul><p id="a186" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用交互混淆矩阵分析二元分类器的预测的便利性是毋庸置疑的。同样，显示阈值变化时金额或成本趋势的图表也是有用的。</p><h2 id="737e" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">交互式混乱折线图</h2><p id="430c" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">从通过交互式混淆矩阵完成的分析中，分析师可能不仅对看到一个值感兴趣，而且对可视化与混淆矩阵的每个类别相关联的可能数量或成本的趋势感兴趣，因为阈值改变。这就是为什么<em class="lu"> binclass-tools </em>包也允许你绘制<strong class="la iu">交互混淆线图</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/00bafbda1198c3602310da433403f136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CIlLGL1g3t-kLwttnP80Gg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10 —交互式混淆折线图的实例</p></figure><p id="6cfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以从<em class="lu">图10 </em>中观察到，除了代表所选阈值下的金额/成本的4个图中的每一个图都有一个点之外，还有黑色的“菱形”表示金额和成本曲线互换的第一个阈值。曲线交换点也可以多于一个。</p><p id="f030" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果分析师希望关注混淆矩阵中任何类别组合的总金额或成本值，还有另一个非常有用的图。</p><h2 id="61ef" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">交互式金额-成本折线图</h2><p id="398e" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">假设您想帮助一家公司的团队使用欺诈检测分类器分析可能的欺诈。假设分类器将欺诈类检测为阳性，分析师可能会提出以下观点:</p><ul class=""><li id="3370" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">如果模型检测到TPs，则交易金额从可能的欺诈中“节省”出来，因此可以认为是公司的收益。</li><li id="bb04" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">所有被分类为良好但实际上是欺诈的观察结果(因此FNs)实际上都是与相关交易总额相等的损失。因此，它们是成本。</li><li id="1bed" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">此外，团队必须对模型预测为欺诈但实际上不是欺诈的所有交易(FPs)进行检查，这也是成本，尽管在数量上小于与欺诈相关的成本。在这些情况下，通常考虑每次检查的固定成本。</li></ul><p id="a52e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果现在分析师想要比较他认为的收益(TPs数量)的表现和他认为的损失(FNs数量+每FP的固定成本)的表现，他可以通过<strong class="la iu">交互式数量-成本折线图</strong>来完成:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/a0754dfe0a853e0eef1352fb7469fd6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dh_SX0I9nD-Qxez_iZ-Eyw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11 —交互式金额-成本折线图示例</p></figure><p id="d74b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样在该图中，黑色“菱形”表示发生数量和成本曲线交换的第一个阈值。</p><p id="37d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一点上，基于分类器的损益分析的需求可以很容易地使用上述图来满足。</p><h1 id="e776" class="oc lw it bd lx od oe of ma og oh oi md jz oj ka mg kc ok kd mj kf ol kg mm om bi translated">酷！但是我在哪里可以找到这个伟大的包呢？</h1><p id="81e6" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">一段时间以来，我一直在考虑将函数放在一个库中，以便对二进制分类器提供的结果进行交互式分析。由于我没有时间，Python(或R)中的实现总是阻塞步骤。自从我得到一位同事的承诺，帮助我开发上述功能后，实现这个项目的可能性变得更加现实。这就是为什么所有这些想法的实现都要归功于Greta Villa的Python专业知识。</p><p id="354a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，我决定在GitHub上以<strong class="la iu">开源</strong>的形式提供这个项目，原因有两个:</p><ul class=""><li id="c9fc" class="my mz it la b lb lc le lf lh na ll nb lp nc lt nd ne nf ng bi translated">我想与整个数据科学家社区分享一个工具，它可以使二元分类器的分析更加容易。</li><li id="13ec" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt nd ne nf ng bi translated">我依靠社区可能的帮助来建议新的特性，改进现有的代码，或者帮助我们开发软件包的未来版本。</li></ul><p id="9025" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu"> binclass-tools </em>包在PyPI 上发布<a class="ae nm" href="https://pypi.org/project/binclass-tools/" rel="noopener ugc nofollow" target="_blank">，所以您只需要下面一行代码就可以将它安装到您的Python环境中:</a></p><pre class="kj kk kl km gt oz mx pa pb aw pc bi"><span id="addf" class="lv lw it mx b gy pd pe l pf pg">pip install binclass-tools</span></pre><p id="09da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关如何使用软件包中包含的功能的更多详细信息，请参考GitHub页面:</p><div class="ph pi gp gr pj pk"><a href="https://github.com/lucazav/binclass-tools" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">GitHub-Luca zav/bin class-工具</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">一组Python包装器和交互式绘图，有助于分析二进制分类问题。的…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">github.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><p id="dd5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还添加了交互式ROC和精确回忆图，您可以在本文中读到:</p><div class="ph pi gp gr pj pk"><a rel="noopener follow" target="_blank" href="/roc-and-pr-curves-probabilities-distribution-and-density-plots-now-in-binclass-tools-python-9351681a3803"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">走向数据科学</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">binclass-tools Python包中的ROC和PR曲线、概率分布和密度图</h3></div></div><div class="pt l"><div class="pz l pv pw px pt py ks pk"/></div></div></a></div><p id="6e9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还将添加包装器，以简化未来版本中校准模型的操作。</p><p id="8bf3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎对该包的任何反馈！</p><h1 id="4ed8" class="oc lw it bd lx od oe of ma og oh oi md jz oj ka mg kc ok kd mj kf ol kg mm om bi translated">参考</h1><ol class=""><li id="ff32" class="my mz it la b lb mo le mp lh qa ll qb lp qc lt ot ne nf ng bi translated"><a class="ae nm" href="https://algolytics.com/how-to-determine-the-quality-and-correctness-of-classification-models-part-2-quantitative-quality-indicators/" rel="noopener ugc nofollow" target="_blank">如何确定分类模型的质量和正确性？第2部分—定量质量指标</a></li><li id="c884" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" href="https://medium.com/analytics-vidhya/what-is-balance-and-imbalance-dataset-89e8d7f46bc5" rel="noopener">什么是平衡和不平衡数据集？</a></li><li id="4da7" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" href="https://machinelearningmastery.com/tour-of-evaluation-metrics-for-imbalanced-classification/" rel="noopener ugc nofollow" target="_blank">不平衡分类评价指标巡礼</a></li><li id="8775" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" href="https://medium.com/analytics-vidhya/precision-recall-tradeoff-for-real-world-use-cases-c6de4fabbcd0" rel="noopener">真实世界用例中的精度-召回权衡</a></li><li id="fea4" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" href="https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-019-6413-7" rel="noopener ugc nofollow" target="_blank">马修斯相关系数(MCC)在二分类评估中相对于F1分数和准确度的优势</a></li><li id="6f3d" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9440903" rel="noopener ugc nofollow" target="_blank">在二进制分类评估中，马修斯相关系数(MCC)比科恩的Kappa和Brier <br/>分数</a>更具信息量</li><li id="9732" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" rel="noopener" target="_blank" href="/matthews-correlation-coefficient-when-to-use-it-and-when-to-avoid-it-310b3c923f7e">马修斯相关系数:何时使用，何时避免</a></li><li id="c628" class="my mz it la b lb nh le ni lh nj ll nk lp nl lt ot ne nf ng bi translated"><a class="ae nm" href="https://pubs.acs.org/doi/10.1021/acs.jcim.1c00160" rel="noopener ugc nofollow" target="_blank"> GHOST:调整决策阈值处理机器学习中的不平衡数据</a></li></ol></div></div>    
</body>
</html>