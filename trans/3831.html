<html>
<head>
<title>Understanding Bitmask for the Coding Interview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解编码面试的位掩码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-bitmask-for-the-coding-interview-b1643f4b0e24#2022-08-25">https://towardsdatascience.com/understanding-bitmask-for-the-coding-interview-b1643f4b0e24#2022-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e6dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个挑战性话题的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c47a7797271828cb58e3f945d9d802b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NR1ZPrlz8OqEJqjVicNsJQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·辛恩在<a class="ae ky" href="https://unsplash.com/s/photos/binary?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码面试一定要知道位操作和位掩码吗？</p><p id="8ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个主题被认为是高级材料，在编码面试中“隐含地”不是必需的。然而，如果面试官愿意，他完全有权利给你这些问题。</p><p id="f3c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是您应该知道的处理位掩码问题的所有标准技术和模式的简要概述。</p><p id="bfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">目录</strong></p><p id="c844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="#5f19" rel="noopener ugc nofollow">位操作的基本</a> <br/> ∘ <a class="ae ky" href="#a76d" rel="noopener ugc nofollow">位操作的常见操作</a> <br/> ∘ <a class="ae ky" href="#93c0" rel="noopener ugc nofollow">位掩码的重要操作</a> <br/> <a class="ae ky" href="#aae9" rel="noopener ugc nofollow">位操作模式</a> <br/> ∘ <a class="ae ky" href="#b95f" rel="noopener ugc nofollow">统计一个数的二进制表示中的1位数</a> <br/> ∘ <a class="ae ky" href="#01cf" rel="noopener ugc nofollow">检查一个正数是否是二的幂</a> <br/> ∘ <a class="ae ky" href="#2800" rel="noopener ugc nofollow">高效计算Pow(x，n)、 其中x &gt; 0，n &gt; 0 </a> <br/> <a class="ae ky" href="#5e7e" rel="noopener ugc nofollow">位掩码模式</a> <br/> ∘ <a class="ae ky" href="#bc45" rel="noopener ugc nofollow">通用模式:</a> <br/> ∘ <a class="ae ky" href="#e493" rel="noopener ugc nofollow">给定一个唯一元素数组，找出所有可能的子集</a> <br/> ∘ <a class="ae ky" href="#cb35" rel="noopener ugc nofollow">统计所有可能的大小为k的子集，其总和为给定的目标</a> <br/> <a class="ae ky" href="#ced9" rel="noopener ugc nofollow">结论</a></p><blockquote class="lv lw lx"><p id="0089" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">所有代码和方程都是作者写的。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="5f19" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">基本的</h1><p id="3f0e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">位掩码是使用数字的二进制表示来解决困难问题的思想。这种表示对于每个数字都是唯一的。</p><p id="dba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">例</em>:数字11的位数是“1011”，因为以2为基数:</p><p id="ab3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">11 = 8+2+1 =<strong class="lb iu">1</strong>* 2+<strong class="lb iu">0</strong>* 2+<strong class="lb iu">1</strong>* 2+<strong class="lb iu">1</strong>*2⁰=“1011”</p><p id="98a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理位掩码时:<strong class="lb iu">实际数字是多少并不重要。</strong>我们要关心的只是它的二进制形式和下面的运算:</p><h2 id="a76d" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">位操作的常见操作</h2><ul class=""><li id="bbc1" class="ns nt it lb b lc nb lf nc li nu lm nv lq nw lu nx ny nz oa bi translated">左移:要将<code class="fe ob oc od oe b">x</code>向左移动n个空格，我们使用<code class="fe ob oc od oe b">x &lt;&lt; n</code>。例如，二进制形式的<code class="fe ob oc od oe b">"1011" &lt;&lt; 3 = "1011000"</code>或<code class="fe ob oc od oe b">11 &lt;&lt; 3 = 88</code>。</li><li id="e447" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">右移:同样，我们使用<code class="fe ob oc od oe b">x &gt;&gt; n</code>。例如，<code class="fe ob oc od oe b">"10101" &gt;&gt; 3= "101"</code>(注意1位消失)。</li><li id="add8" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">清除最低设置位:<code class="fe ob oc od oe b">x &amp; (x — 1)</code>(如<code class="fe ob oc od oe b">"10100" -&gt; "10000"</code>)</li><li id="73ca" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">AND: <code class="fe ob oc od oe b">a &amp; b = 1</code>如果<code class="fe ob oc od oe b">a = 1</code>和<code class="fe ob oc od oe b">b = 1</code>，否则为0</li><li id="a1e6" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">或者:<code class="fe ob oc od oe b">a | b = 1</code>如果<code class="fe ob oc od oe b">a = 1</code>或者<code class="fe ob oc od oe b">b = 1</code>，否则为0</li><li id="6090" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">XOR: <code class="fe ob oc od oe b">a ^ b = 1</code>如果<code class="fe ob oc od oe b">a</code>或<code class="fe ob oc od oe b">b</code>中恰好有一个为1，否则为0</li><li id="1a8f" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">对于大于1的数字，我们对每个比特位置迭代地应用这些运算。例如<code class="fe ob oc od oe b">"10111" AND "1100" = "00100" = "100"</code></li></ul><h2 id="93c0" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated"><strong class="ak">位掩码的重要操作</strong></h2><ul class=""><li id="6e62" class="ns nt it lb b lc nb lf nc li nu lm nv lq nw lu nx ny nz oa bi translated">将i^th位设为1: <code class="fe ob oc od oe b">mask = mask | (1 &lt;&lt; i)</code>或<code class="fe ob oc od oe b">mask |= (1 &lt;&lt; i)</code></li><li id="c90d" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">翻转i^th位:<code class="fe ob oc od oe b">mask = mask ^ (1 &lt;&lt; i)</code>或<code class="fe ob oc od oe b">mask ^= (1 &lt;&lt; i)</code></li></ul><p id="0723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数时候，你会操作一个叫做<code class="fe ob oc od oe b">mask</code>的数字。这个掩码将用于跟踪列表中“已用”或“未用”的元素。</p><p id="1190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">举例:</em>给定一个由3个元素组成的集合<code class="fe ob oc od oe b">A = {1,2,3}</code>，我们如何有效地表示这个集合的所有子集？</p><p id="6cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">答:</em>使用从0到7的数字及其对应的位掩码，其中每个1位位置向一个选定的元素发送信号:</p><pre class="kj kk kl km gt ok oe ol om aw on bi"><span id="263d" class="ng mk it oe b gy oo op l oq or">0 = "000" = {} = the empty set<br/>1 = "00<strong class="oe iu">1</strong>" = {1}<br/>2 = "0<strong class="oe iu">1</strong>0" = {2}<br/>3 = "0<strong class="oe iu">11</strong>" = {1, 2}<br/>4 = "<strong class="oe iu">1</strong>00" = {3}<br/>5 = "<strong class="oe iu">1</strong>0<strong class="oe iu">1</strong>" = {1, 3}<br/>6 = "<strong class="oe iu">11</strong>0" = {2, 3}<br/>7 = "<strong class="oe iu">111</strong>" = {1, 2, 3}</span></pre><p id="8353" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，给定一组<code class="fe ob oc od oe b">n</code>元素，<strong class="lb iu">我们总是可以用从0到</strong> <code class="fe ob oc od oe b"><strong class="lb iu">2^n — 1</strong></code> <strong class="lb iu">的数字来表示这个集合的所有子集。</strong></p><p id="4893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是bitmask的基本思想。我们将操作一个代表给定列表的当前子集的<code class="fe ob oc od oe b">mask</code>。</p><h1 id="aae9" class="mj mk it bd ml mm os mo mp mq ot ms mt jz ou ka mv kc ov kd mx kf ow kg mz na bi translated">位操作模式</h1><h2 id="b95f" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">计算一个数的二进制表示中的1位数</h2><p id="4071" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们可以一直向右移动这个数，直到它变成零。在每一步，我们检查0^th位是否为1，并将其加到总计数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="8bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以进一步优化这个解决方案:我们可以删除最低设置位并相应地移位，而不是每次移位1位:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h2 id="01cf" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">检查正数是否是2的幂</h2><p id="11c8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果n是2的幂，那么对于某个正整数k，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/d5c058b357e40ae870449f69c5bb91aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*CHrzTglRSq9oLIY8DaL9KQ.png"/></div></figure><p id="ed46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，n的二进制表示形式为<code class="fe ob oc od oe b">"100...0"</code>。那么我们可以通过移除n的最低位集合来容易地验证这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h2 id="2800" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">有效地计算幂(x，n)，其中x &gt; 0，n &gt; 0</h2><p id="1f35" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">以11为例，考虑n的二进制表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/eff9fa90f94a352e5d9724e7dfff4d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*6CBFiuyuQ19SDxI2RdnQDg.png"/></div></figure><p id="faaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，11的二进制表示中的每个位置对应于x，x，x⁴，…</p><p id="a579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，代替循环和乘以n次来计算答案，我们可以通过仅存储2的幂的幂来优化计算:x、x、x⁴、x⁸,…，并且乘以适当的值来获得我们的最终答案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h1 id="5e7e" class="mj mk it bd ml mm os mo mp mq ot ms mt jz ou ka mv kc ov kd mx kf ow kg mz na bi translated">位掩码模式</h1><p id="357d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">回想一下，掩码代表一个子集。</p><p id="5d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我有一个写着<code class="fe ob oc od oe b">"00110011"</code>的面具</p><blockquote class="lv lw lx"><p id="8da7" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">这个十进制数是多少？</p></blockquote><p id="4ab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不知道，也不在乎。</p><p id="01a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需要知道这个掩码代表一个集合的状态。这个特殊的掩码意味着我们正在处理一个包含索引为0、1、4和5的元素的子集(从右到左)。</p><h2 id="bc45" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">一般模式:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="d776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码在做什么？</p><p id="da4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们遍历集合中的所有索引。如果我们在索引<code class="fe ob oc od oe b">i</code>处遇到一个“未使用”的元素，那么相应的掩码元素将是<code class="fe ob oc od oe b">"0"</code>。因此索引<code class="fe ob oc od oe b">i</code>处的<code class="fe ob oc od oe b">not mask</code>为<code class="fe ob oc od oe b">"1"</code>，因此<code class="fe ob oc od oe b">not mask &amp; (1 &lt;&lt; i)</code>将返回True。然后，我们可以将这个元素添加到我们的子集中，并接下来处理它。</p><h2 id="e493" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">给定一个<strong class="ak">唯一</strong>元素的数组，找到<em class="pb">所有可能的子集</em></h2><p id="0ba5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">回想一下上一节:给定一个大小为<code class="fe ob oc od oe b">n</code>的集合，我们可以使用从0到<code class="fe ob oc od oe b">2^n-1</code>的数字来表示所有的子集。</p><p id="1930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个数字，我们通过查看其二进制表示来构建相应的子集，并找到所有<code class="fe ob oc od oe b">"1"</code>的位置。然后，我们可以将子集添加到最终结果中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="7de3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例输出:</p><pre class="kj kk kl km gt ok oe ol om aw on bi"><span id="5fc0" class="ng mk it oe b gy oo op l oq or">&gt;&gt;&gt; A = [1,3,5,7]<br/>&gt;&gt;&gt; subset(A)<br/>[[], [1], [3], [1, 3], [5], [1, 5], [3, 5], [1, 3, 5], [7], [1, 7], [3, 7], [1, 3, 7], [5, 7], [1, 5, 7], [3, 5, 7], [1, 3, 5, 7]]</span></pre><h2 id="cb35" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">对给定目标的所有可能的大小为k的子集进行计数</h2><p id="914c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这个问题是Leetcode上的<a class="ae ky" href="https://leetcode.com/problems/combination-sum-iii/" rel="noopener ugc nofollow" target="_blank">组合和III </a>。我们希望找到所有大小为<code class="fe ob oc od oe b">k</code>的子集，其总和为<code class="fe ob oc od oe b">n</code>，因此:</p><ul class=""><li id="c792" class="ns nt it lb b lc ld lf lg li pc lm pd lq pe lu nx ny nz oa bi translated">仅使用数字<code class="fe ob oc od oe b">1</code>至<code class="fe ob oc od oe b">9</code>。</li><li id="b1b4" class="ns nt it lb b lc of lf og li oh lm oi lq oj lu nx ny nz oa bi translated">每个号码最多使用<strong class="lb iu">一次</strong>。</li></ul><p id="668f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题可以通过回溯来解决，但是我想在这里提出一个位掩码解决方案。一旦您熟悉了位操作，您可能会发现使用位掩码更容易求解和/或编写解决方案。</p><p id="e1e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">我们的起始掩码是0，代表空集</strong>(99%的情况下都是这样)。在每一步，我们选择打开位置1到9的任何位(从右到左，起始位置索引为0)。</p><p id="e6f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe ob oc od oe b">"1010101010"</code>在位置1、3、5、7和9有<code class="fe ob oc od oe b">"1"</code>。这个掩码表示集合{1，3，5，7，9}，总和等于25。</p><p id="a7a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用位掩码和DP来解决这个问题。一旦我们得到了所有有效掩码的集合，我们就可以解码每个掩码并得到最终的数字集合。</p><p id="57ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个解决方案，它利用了本帖中讨论的三种不同的位操作技术:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h1 id="ced9" class="mj mk it bd ml mm os mo mp mq ot ms mt jz ou ka mv kc ov kd mx kf ow kg mz na bi translated">结论</h1><p id="64df" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">位掩码不一定要吓人。</p><p id="b607" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始<a class="ae ky" href="https://medium.com/p/5c77f27d5224" rel="noopener">准备</a>编码面试时，我发现位掩码是最具挑战性的话题。一开始，我会完全跳过这些问题。然而，随着我解决越来越多的问题，我最终发现它并不像我想象的那么可怕。</p><p id="0d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的一些朋友在面试中确实被问到了关于位屏蔽的问题(在一些大型科技公司)。难度类似于“位掩码模式”一节中的两个问题。这些问题旨在通过回溯来解决。但是，用位掩码求解是给面试官留下深刻印象的好方法！</p><p id="da2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(很有可能，他们对此也不太适应。)</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="c77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你愿意支持Thu，你可以考虑注册成为一名中等会员。每月支付5美元，你就可以无限制地阅读媒体上的故事。如果你使用他的推荐链接，Thu也会得到一小笔佣金。</p><div class="pf pg gp gr ph pi"><a href="https://medium.com/@tdinh15/membership" rel="noopener follow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">通过我的推荐链接加入媒体- Thu Dinh</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">阅读Thu Dinh的每一个故事(以及媒体上成千上万的其他作家)。你的会员费直接支持周四…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">medium.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div></div></div>    
</body>
</html>