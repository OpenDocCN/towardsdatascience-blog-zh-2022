<html>
<head>
<title>SQL Anti-Patterns for BigQuery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery 的 SQL 反模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-anti-patterns-dacb61f8a3f#2022-11-22">https://towardsdatascience.com/bigquery-anti-patterns-dacb61f8a3f#2022-11-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="acb2" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在 Google Cloud BigQuery 上运行 SQL 的最佳实践和需要避免的事情</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/af7bf0ca5e407698e0b8ac3bee3b2c30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgxr4imVnxueXa4vXNurIw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@carterjack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰克·卡特</a>在<a class="ae kz" href="https://unsplash.com/s/photos/idea?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="216b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> BigQuery </strong>是<strong class="lc iv">谷歌云平台上的托管<strong class="lc iv">数据仓库</strong>服务，</strong>像大多数服务和技术一样，它有一套使用时需要牢记的原则。</p><p id="2f2a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几节中，我们将概述一组<strong class="lc iv">最佳实践</strong>，以避免通常会对 BigQuery 性能产生负面影响的常见反模式。应用最佳实践很重要，主要有两个原因——它们将帮助您<strong class="lc iv">编写更高效的查询</strong>,同时，如果应用正确，将<strong class="lc iv">降低您的成本</strong>。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="bc93" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">避免选择*</h2><p id="d694" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">从结果集中选择所有字段是一种非常常见的反模式，应该尽可能避免。<code class="fe nb nc nd ne b">SELECT *</code>将导致对表中的每一列进行完全扫描，这意味着这将是一个执行开销很大的操作。</p><blockquote class="nf"><p id="369d" class="ng nh iu bd ni nj nk nl nm nn no lv dk translated">仅查询您需要的列</p></blockquote><p id="1e88" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">还要记住<code class="fe nb nc nd ne b">LIMIT</code>不会减少读取的字节量，因此，您仍然需要为每一列的完全扫描付费。因此，请确保只查询您实际需要的列。如果您仍然需要运行<code class="fe nb nc nd ne b">SELECT *</code>,那么考虑对您的表进行分区，这样您将能够查询驻留在一个或一些分区中的数据。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="2f2e" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">避免自连接</h2><p id="700c" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在表上执行自连接是另一件应该避免的事情。自然有人会问两个独立表的连接和自连接有什么区别。</p><p id="904c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">答案是否定的——这几乎是一回事，但这里的要点是，无论何时您要执行自连接，都有可能使用窗口函数来实现相同的结果，这是一种更优雅的方式。</p><blockquote class="nf"><p id="fe8f" class="ng nh iu bd ni nj nk nl nm nn no lv dk translated">避免自连接，而使用窗口函数</p></blockquote><p id="f146" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">自联接可能会增加输出行数，这意味着它会降低查询性能，还会导致处理的字节数增加，从而增加运行此类查询的成本。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="7b03" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">处理数据偏斜</h2><p id="ae8a" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">数据偏斜是当您的数据被划分为大小不均匀的分区时出现的现象。在后台，BigQuery 会将这些分区发送到插槽中，这些插槽是用于以分布式方式执行 SQL 查询的虚拟 CPU。</p><p id="a102" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，分区不能跨不同的插槽共享。如果您创建了不平衡的分区，这意味着一些插槽最终会比其他插槽有更多的工作负载，而在某些极端情况下，过大的分区甚至会使插槽崩溃。</p><p id="e6e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当您基于包含比其他值更频繁出现的值的键/列对表进行分区时，您很可能会得到大小不等的分区。在这种情况下，尽早应用过滤器将有助于缩小这种不平衡。</p><blockquote class="nf"><p id="7ca3" class="ng nh iu bd ni nj nk nl nm nn no lv dk translated">如果你的数据有偏差，尽早应用<strong class="ak">过滤</strong></p></blockquote><p id="1ca8" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">此外，您可能还需要重新考虑分区键。例如，您可能希望避免使用具有许多<code class="fe nb nc nd ne b">NULL</code>值的键对表进行分区，因为这将为此类行创建一个巨大的分区。一个常用的分区键是一个日期字段，它可以确保数据在不同分区上的均匀分布(假设每天/每月/每年的数据量大致相同)。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="fc7b" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">交叉连接</h2><p id="e4f4" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">交叉连接用于生成两个表之间的笛卡尔积，即包含相关表记录之间所有可能组合的结果。更简单地说，第一个表中的每一行都将被连接到第二个表中的每一行，这意味着在最坏的情况下，我们将得到由 M×N 行组成的结果，其中 M 和 N 分别是表的大小。</p><blockquote class="nf"><p id="36b7" class="ng nh iu bd ni nj nk nl nm nn no lv dk translated">避免执行会导致输出多于输入的连接</p></blockquote><p id="6892" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">因此，这意味着交叉连接通常会返回比输入更多的输出行，这是我们通常想要避免的。作为一名总顾问，在这种情况下，您应该考虑两种可能的解决方法:</p><ol class=""><li id="027a" class="nu nv iu lc b ld le lg lh lj nw ln nx lr ny lv nz oa ob oc bi translated">评估窗口函数(比交叉连接更有效)是否能帮助您获得想要的结果</li><li id="2fc1" class="nu nv iu lc b ld od lg oe lj of ln og lr oh lv nz oa ob oc bi translated">在加入之前，使用<code class="fe nb nc nd ne b">GROUP BY</code>执行预聚合</li></ol></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="4a47" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">比起分片，更喜欢表分区</h2><p id="40df" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">表分片是一种将数据存储到多个不同表中的方法，使用一个命名前缀，比如<code class="fe nb nc nd ne b">[PREFIX]_YYYYMMDD</code>。许多用户会认为上述技术与分区相同，但实际上并非如此。</p><p id="c75e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">表分片要求 BigQuery 维护每个表的元数据和模式，此外，无论何时执行操作，平台都必须验证所有单个表的权限，这会对性能产生重大影响。</p><blockquote class="nf"><p id="17fb" class="ng nh iu bd ni nj nk nl nm nn no lv dk translated">表分区比表分片更有效</p></blockquote><p id="1df2" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">一般来说，表分区的性能更好，因此您应该首选它们而不是分片表。此外，在过滤和降低成本方面，分区表更容易处理。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="4237" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">不要将 BigQuery 视为 OLTP 系统</h2><p id="7af5" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">像大多数数据仓库解决方案一样，BigQuery 也是一个 OLAP(在线分析处理)系统。这意味着在使用表扫描处理海量数据时，它的设计是高效的。因此，BigQuery 上的<a class="ae kz" rel="noopener" target="_blank" href="/ddl-dml-e802a25076c6"> DML 语句</a>不应该用于执行<strong class="lc iv">批量</strong> <strong class="lc iv">更新</strong>。</p><blockquote class="nf"><p id="92c0" class="ng nh iu bd ni nj nk nl nm nn no lv dk translated">BigQuery 是一个 OLAP 系统，需要如此对待</p></blockquote><p id="e988" class="pw-post-body-paragraph la lb iu lc b ld np jv lf lg nq jy li lj nr ll lm ln ns lp lq lr nt lt lu lv in bi translated">使用 DML 语句执行模块化更改意味着您试图将 BigQuery 视为 OLTP(在线事务处理)系统。如果是这样的话，你应该重新考虑你的设计，甚至是你正在使用的工具。有可能 OLTP 系统(比如 Google 云平台上的 CloudSQL)更合适。或者，如果您的设计涉及常规模块化插件，您可以考虑其他技术，如流技术。</p><p id="66c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">关于 OLAP 和 OLTP 系统之间的主要区别的更多细节，您可以阅读我最近的一篇文章。</p><div class="oi oj gq gs ok ol"><a rel="noopener follow" target="_blank" href="/oltp-vs-olap-9ac334baa370"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd iv gz z fq oq fs ft or fv fx it bi translated">OLTP 与 OLAP:他们的区别是什么</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">在数据处理系统的上下文中理解 OLTP 和 OLAP 之间的区别</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kt ol"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="78f3" class="md me iu bd mf mg mh dn mi mj mk dp ml lj mm mn mo ln mp mq mr lr ms mt mu mv bi translated">最后的想法</h2><p id="b95c" class="pw-post-body-paragraph la lb iu lc b ld mw jv lf lg mx jy li lj my ll lm ln mz lp lq lr na lt lu lv in bi translated">在 BigQuery 中应用最佳实践并避免常见的反模式非常重要，因为这些原则将帮助您提高系统的性能并降低成本。</p><p id="f311" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">总结一下，</p><ul class=""><li id="8b34" class="nu nv iu lc b ld le lg lh lj nw ln nx lr ny lv pa oa ob oc bi translated">避免使用<code class="fe nb nc nd ne b">SELECT *</code>，取而代之的是，确保你只查询你需要的字段</li><li id="5695" class="nu nv iu lc b ld od lg oe lj of ln og lr oh lv pa oa ob oc bi translated">尽可能选择窗口函数而不是自连接(例如，如果您需要计算的是行相关的)</li><li id="b876" class="nu nv iu lc b ld od lg oe lj of ln og lr oh lv pa oa ob oc bi translated">明智地选择分区键，以避免数据偏斜。如果不可能，请确保尽早应用过滤器</li><li id="2a80" class="nu nv iu lc b ld od lg oe lj of ln og lr oh lv pa oa ob oc bi translated">避免产生输出多于输入的连接</li><li id="21fc" class="nu nv iu lc b ld od lg oe lj of ln og lr oh lv pa oa ob oc bi translated">比起表分片，我更喜欢表分区，因为前者效率更高，成本更低</li><li id="eb40" class="nu nv iu lc b ld od lg oe lj of ln og lr oh lv pa oa ob oc bi translated">避免模块化的 DML 语句——big query 是一个 OLAP 系统，需要这样对待</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a> <strong class="lc iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="oi oj gq gs ok ol"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd iv gz z fq oq fs ft or fv fx it bi translated">通过我的推荐链接加入 Medium-Giorgos Myrianthous</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz kt ol"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">相关文章您可能也喜欢</strong></p><div class="oi oj gq gs ok ol"><a rel="noopener follow" target="_blank" href="/visual-sql-joins-4e3899d9d46c"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd iv gz z fq oq fs ft or fv fx it bi translated">SQL 连接的直观解释</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">用维恩图和实际例子理解 SQL 连接</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pc l ow ox oy ou oz kt ol"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ol"><a rel="noopener follow" target="_blank" href="/2-rules-groupby-sql-6ff20b22fd2c"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd iv gz z fq oq fs ft or fv fx it bi translated">在 SQL 中使用 GROUP BY 时要遵循的 2 条规则</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">了解 GROUP BY 子句中要包含哪些列，以及如何在 WHERE 子句中包含聚合</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz kt ol"/></div></div></a></div></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ol"><a rel="noopener follow" target="_blank" href="/sql-select-distinct-277c61012800"><div class="om ab fp"><div class="on ab oo cl cj op"><h2 class="bd iv gz z fq oq fs ft or fv fx it bi translated">DISTINCT 不是 SQL 函数</h2><div class="os l"><h3 class="bd b gz z fq oq fs ft or fv fx dk translated">在 SQL 中使用 DISTINCT 关键字时，括号的使用如何会导致混淆</h3></div><div class="ot l"><p class="bd b dl z fq oq fs ft or fv fx dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pe l ow ox oy ou oz kt ol"/></div></div></a></div></div></div>    
</body>
</html>