<html>
<head>
<title>Building Generator Pipelines in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建生成器管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-generator-pipelines-in-python-8931535792ff#2022-10-19">https://towardsdatascience.com/building-generator-pipelines-in-python-8931535792ff#2022-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="efa6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本文提出了一种构建生成器管道的优雅方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e8a24124735751ac9a77ddaf1b4e4fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R1aKD55IvgJbohBh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">发电机管道:解决问题的捷径。马修·布罗德尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="325d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在软件中，<a class="ae ky" href="https://en.wikipedia.org/wiki/Pipeline_(software)" rel="noopener ugc nofollow" target="_blank">管道</a>意味着对可迭代的每个元素按顺序执行多个操作(例如，调用一个又一个函数),每个元素的输出都是下一个元素的输入。</p><p id="f5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，可以用各种方式构建管道，有些方式比其他方式简单。在本文中，我们将讨论一种优雅的方式:生成器管道。</p><p id="073d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我举一个简单的例子。对于我们来说，使用由简单操作组成的管道会更容易，这样我们就不必关注每个操作在做什么。例如，对于整数范围内的每个数字，您希望应用以下计算:</p><ul class=""><li id="c3c9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">求平方根</li><li id="35d8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数字翻倍，加12</li><li id="a1b3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">求数字的平方</li><li id="7481" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">加上圆周率的平方根</li><li id="2493" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">添加75</li><li id="49a9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">返回舍入到两位小数后的结果</li></ul><p id="431a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，没有人会这样做，但是想象一下，每一步都在iterable的特定元素上执行操作。例如，iterable可以包含许多文件，您希望读取它们，对它们进行预处理，对每个文本应用NLP模型，分析结果，然后返回它们。或者，您有许多包含定量数据的文件，您希望读取每个文件，检查并预处理数据，使用ML模型，然后以某种有组织的方式返回结果。这两个示例可以像上面的示例一样组织在一个管道中，因为每个示例都有一个iterable，其中包含一系列操作要依次应用到的项目，一个项目的输出是下一个项目的输入。</p><h1 id="bdf3" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">常见的方法</h1><p id="fe0d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">可能最自然的方法是获取iterable的每个元素，并逐步应用这些计算。所以，当你有两个函数要应用于<code class="fe ng nh ni nj b">x</code>时，比如说，<code class="fe ng nh ni nj b">f1()</code>然后是<code class="fe ng nh ni nj b">f2()</code>，你可以通过<code class="fe ng nh ni nj b">f2(f1(x))</code>来完成。就这么简单——但是当应用更多的函数并且它们接受更多的参数时，产生的代表<code class="fe ng nh ni nj b">f2(f1(x))</code>的代码就变成了一个难以理解的怪物。你会在下面看到。</p><p id="f1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个对数字执行操作的管道。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="06e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nm">注</em> </strong> <em class="nm">:下面这段是描述代码中类型提示的题外话。不感兴趣可以跳过。</em></p><p id="95d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你在上面的代码中看到的，我决定使用类型别名。在许多情况下，我认为这种方法比使用原始类型提示更具可读性(<a class="ae ky" href="https://betterprogramming.pub/pythons-type-hinting-friend-foe-or-just-a-headache-73c7849039c7" rel="noopener ugc nofollow" target="_blank">科萨克2022 </a>)。因此，我创建了类型别名<code class="fe ng nh ni nj b">XType</code>来表示<code class="fe ng nh ni nj b">x</code>的类型。另一个类型别名，<code class="fe ng nh ni nj b">PipeItems</code>，代表一个iterable，其中包含了我们将要创建的管道中将要处理的项目；这样就带了<code class="fe ng nh ni nj b">XType</code>的对象。在我们的例子中，这些是数字，但一般来说，这可以是任何对象。函数<code class="fe ng nh ni nj b">power()</code>和<code class="fe ng nh ni nj b">add()</code>也将<code class="fe ng nh ni nj b">XType</code>的值作为输入，但是这不是必须的；这取决于创建管道的操作。代表特定操作的函数应该接受前一个操作返回的类型的对象。</p><p id="1d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的第一种方法是简单地一个接一个地应用所有的函数(因此函数名为<code class="fe ng nh ni nj b">get_pipeline_all_calc</code>)，可能是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么？！</p><p id="1781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你怎么能读懂这样的代码，更不用说理解它了？我尝试了十几个版本，只是为了找出哪一个是最好的，但是……没有一个是最好的。因此，因为我需要使行更短，我选择了这一个，尽管它肯定是<em class="nm">不</em>可读的。但是，他们都不是。</p><p id="8e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面，您会发现在使用标志<code class="fe ng nh ni nj b">-l 79</code>之后<code class="fe ng nh ni nj b"><a class="ae ky" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">black</a></code>对这段代码做了什么，标志<code class="fe ng nh ni nj b">-l 79</code>将最大行长度保持在79:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="68be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不认为这有多大帮助…你自己决定这段代码对你来说是否是可理解的。</p><p id="0865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的代码不仅难以阅读和理解，而且难以编写和重写。你自己试试。例如，回到管道的描述并自己实现它。或者在上面的函数中增加一个新的步骤；比如说，在加圆周率的平方根之前，把这个数提高到3的次方。这样做只是为了看看使用这种方法有多难。</p><p id="19eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的版本工作正常，无论它看起来多么疯狂和不可理解。Python 的<a class="ae ky" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅说“简单比复杂好”，所以应该有更好的方法。</a></p><p id="4354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有就是:<em class="nm">发电机管线</em>。</p><h1 id="3983" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">发电机管道</h1><p id="a820" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>函数返回一个生成器，所以我们可以称之为生成器管道。因为它返回了一个<code class="fe ng nh ni nj b">generator</code>对象，我们必须评估它的项目。这是生成器管道的一个伟大之处:在被创建之后，管道(正式地说，它是一个<code class="fe ng nh ni nj b">generator</code>对象)可以被延迟评估，也就是按需评估。可以一次完成，可以分步完成，也可以在想要或者需要的时候对后续项目进行评估。</p><p id="ac8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，许多人不同意这是一个发电机管道；更确切地说，它是压入生成器的计算。<em class="nm">真正的生成器管道在管道的每一步都使用一个生成器</em>。</p><p id="9add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，要构建一个生成器管道，您需要使每一步都成为基于前一步的生成器的生成器。第一步将iterable与原始项一起使用。</p><p id="a555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实际上比听起来简单。下面的函数显示了实现这一点的一种方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您当然可以使用不同的命名，这可以稍微提高可读性。例如，不使用<code class="fe ng nh ni nj b">step_i</code>的名称，其中<code class="fe ng nh ni nj b">i</code>代表步骤的ID，实际上您可以使用一个有意义的名称。例如，<code class="fe ng nh ni nj b">step_1</code>可以是<code class="fe ng nh ni nj b">root_squared</code>，<code class="fe ng nh ni nj b">step_2</code>可以变成<code class="fe ng nh ni nj b">doubled</code>，<code class="fe ng nh ni nj b">step_3</code>可以是<code class="fe ng nh ni nj b">added_12</code>。虽然在这里这样的命名并不真正有用，但在许多情况下会有用。您也可以在每个步骤中使用<code class="fe ng nh ni nj b">map()</code>(稍后我们将返回到<code class="fe ng nh ni nj b">map()</code>)。</p><p id="9a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，生成器管道版本<code class="fe ng nh ni nj b">get_pipeline_original()</code>可读性更好，也更容易更新(例如，添加一个新操作)。我看到了链中的每一步，所以很容易添加新的一步，不像在<code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>中。</p><p id="5bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，代码并不完美。我们能进一步改进它吗？</p><h1 id="06c2" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">我们能把发电机管道做得更好吗？</h1><p id="18a1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated"><code class="fe ng nh ni nj b">get_pipeline_original()</code>函数展示了创建生成器管道的典型方法。我不认为它经常被使用，尽管它有可读性。虽然可读，但它不是完全可读的。例如，我不喜欢视觉混乱，这主要是由在每一步中创建生成器表达式的<code class="fe ng nh ni nj b">for</code>循环造成的。也许最重要的是，为了理解这样的管道，您需要同时考虑两件事:操作和生成器表达式。在它们之间，前者构成了本质，后者构成了方法论的具体内容。</p><p id="2b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我上面写的，我们可以使用<code class="fe ng nh ni nj b">map()</code>函数来代替。但不幸的是，这没有多大帮助:我们必须理解所有的地图。</p><p id="2448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，正是管道作业构成了其本质。我们应该关注它们，因为如果我们想要了解管道，我们需要了解其每个步骤的以下方面:</p><ul class=""><li id="2e72" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">对操作的输入</li><li id="b6a1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">手术的作用</li><li id="a60a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">操作的输出</li></ul><p id="c27e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到上面的代码。我们看到了这些方面，但是当试图理解代码时，我们的大部分注意力都放在了理解生成器表达式上。</p><p id="a279" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使代码更具可读性，我们可以尝试减少没有描述其本质的代码量。问自己以下问题:<em class="nm">每个操作都需要专用的生成器表达式吗？</em></p><p id="79bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案是，<em class="nm">当然不是</em>。既然没有，我们可以试着简化代码，例如，去掉所有的生成器表达式，只留下一个。考虑以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="613e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，<code class="fe ng nh ni nj b">calculate()</code>包含单个元素的操作管道，而<code class="fe ng nh ni nj b">get_pipeline_proposed()</code>为<code class="fe ng nh ni nj b">items</code> iterable的每个元素创建一个管道生成器——也就是一个生成器管道。之前在<code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>中，所有的操作都在一行中调用，这里没有；它们以流水线的形式出现，每一行代表一个操作。我们很容易看到，除了第一个操作之外，每个操作都将前一个操作的输出作为输入。</p><p id="3457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到这句话:<em class="nm">真正的生成器管道在管道的每一步都使用一个生成器</em>。对于这种方法，我们不能这么说，因为<code class="fe ng nh ni nj b">calculate()</code>函数由一个管道组成，然后这个管道在生成器中循环。抛开命名的理论考虑，我认为我们仍然可以称这种方法为生成器管道:这是一种使用生成器评估的管道。</p><p id="52d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，<code class="fe ng nh ni nj b">get_pipeline_proposed()</code>和<code class="fe ng nh ni nj b">calculate()</code>函数比我们上面考虑过的任何其他版本都更具可读性，包括<code class="fe ng nh ni nj b">get_pipeline_original()</code>。前者比后者需要更少的字符和更短的行——因此，它不会受到视觉混乱的影响。</p><p id="011d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我们可以在<code class="fe ng nh ni nj b">calculate()</code>中使用不同的命名。你觉得下面的版本怎么样？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我觉得是喜好问题。在这个例子中，我会选择带有<code class="fe ng nh ni nj b">x</code>的版本，因为它表明我们从每一步得到的仍然是同一个变量，只是经过了处理。但是当每个步骤执行不同的操作时，例如，读取文件、处理文本、运行NLP模型，那么这样的命名可以增加可读性。</p><p id="9694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，使用管道操作符将函数链接起来会产生更可读的代码。我将在另一篇文章中讨论这个问题，因为它值得单独关注。</p><h1 id="5e3c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">带地图的发电机管道()</h1><p id="a693" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">不能用<code class="fe ng nh ni nj b"><a class="ae ky" rel="noopener" target="_blank" href="/does-python-still-need-the-map-function-96787ea1fb05">map()</a></code>创建一个生成器管道吗？难道<code class="fe ng nh ni nj b">map()</code>不是被创造出来的吗？</p><p id="65d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的确，我们可以。为此，我们将使用上面定义的<code class="fe ng nh ni nj b">calculate()</code>函数，管道创建函数如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9ec0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！这是生成器管道的另一个版本，用<code class="fe ng nh ni nj b">map()</code>函数构建。</p><h1 id="bf42" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">标杆管理</h1><p id="4de5" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">代码可读性是一回事；性能是另一个。传统的生成器管道创建的生成器数量与管道中的步骤数量一样多。虽然创建一个生成器在性能方面很便宜，但这仍然意味着要创建和使用几个生成器，而不是一个。当然，提议的版本(使用生成器表达式或<code class="fe ng nh ni nj b">map()</code>)尽管没有使用那么多的生成器，但使用了相同数量的对象，所以它们的评估与生成器的评估一样昂贵吗？</p><p id="2e55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于基准测试，我将使用<code class="fe ng nh ni nj b"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>模块。如果你想了解更多关于这个模块的内容，你可以阅读我的文章<a class="ae ky" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">，从<em class="nm">走向数据科学</em> </a>，在这篇文章中，我解释了这个包的一些有趣的复杂性。</p><p id="7cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将运行基准测试，以比较以下四种方法的性能:</p><ul class=""><li id="75d5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>:第一个版本，一个接一个地进行所有的计算；</li><li id="1fd4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">get_pipeline_original()</code>:传统的生成器管道，其中每个计算都是使用专用的生成器来完成的；</li><li id="a106" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">get_pipeline_proposed()</code>:提出的发电机管道，是对第一个版本的修改；；和</li><li id="124f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b">get_pipeline_proposed_map()</code>:提议的生成器管道，使用<code class="fe ng nh ni nj b">map()</code>创建。</li></ul><p id="cfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试代码太长且重复，无法在此展示，因此您可以在本GitHub gist 中找到它<a class="ae ky" href="https://gist.github.com/nyggus/6312fda2702f137899a5f23a7d746963" rel="noopener ugc nofollow" target="_blank">。你会在这里找到结果。</a></p><p id="8b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是从基准测试中得出的结论:</p><ul class=""><li id="5cf7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">四个中最快的是<code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>，即创建一个能同时调用所有函数的生成器。这并不奇怪，因为这个版本创建生成器、调用函数和创建对象的开销最低。</li><li id="41de" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最慢的是传统的生成器流水线<code class="fe ng nh ni nj b">get_pipeline_original()</code>，它使用的生成器和操作一样多。这也不足为奇，因为这个版本的开销很大，需要创建与管道中的操作一样多的生成器。</li><li id="ff59" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用生成器表达式<code class="fe ng nh ni nj b">get_pipeline_proposed()</code>的建议解决方案位于中间。</li><li id="099d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用<code class="fe ng nh ni nj b">map()</code>、<code class="fe ng nh ni nj b">get_pipeline_proposed_map()</code>的建议解决方案比<code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>慢，但比<code class="fe ng nh ni nj b">get_pipeline_proposed()</code>快。</li><li id="d2f9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">上述结果适用于iterable的所有长度，即<code class="fe ng nh ni nj b">[100, 1_000, 10_000, 100_000, 1_000_000]</code>。正如本例所示，可以预料iterable元素的执行时间实际上是相同的。</li></ul><p id="e40d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，请注意，我们分析的是由非常快速的操作组成的流水线。如果其中一个或多个需要很长时间来执行，基准测试将显示这两个方法之间几乎没有区别，因为在<code class="fe ng nh ni nj b">calculate()</code>中创建生成器或创建几个对象的开销可以忽略不计。</p><p id="e6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想检查这一点，将上面定义的<code class="fe ng nh ni nj b">double()</code>功能更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并使用<code class="fe ng nh ni nj b">number=1</code>。你将看不出这四种方法之间有什么有意义的区别。这是因为这一次，与操作的执行时间相比，在<code class="fe ng nh ni nj b">calculate()</code>中创建生成器和附加对象的开销可以忽略不计。</p><p id="e384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，请记住，只有当管道本身非常快时，考虑性能才有意义。但是这个实验的主要目的是表明所提出的发电机管道结构并不比其他方法慢很多。事实证明这是真的。因此，使用这种方法时，您不必担心性能。此外，如果性能很重要，所提出的解决方案甚至会比传统的发电机管道更快——虽然只是一点点，但仍然如此。</p><h1 id="5ca4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="bef4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">传统的生成器管道由与管道中的操作一样多的生成器组成。生成器管道代码比一次调用所有函数的生成器更容易理解。这就是为什么在两种选择中，生成器管道是首选。</p><p id="af91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在快速操作的情况下，这种方法比在一个生成器中一次一个地调用所有操作要慢。有趣的是，<code class="fe ng nh ni nj b">map()</code>版本比这更快。然而，对于更长的操作，这种差异变得可以忽略不计，对于所有版本，您将得到几乎相同的结果。</p><p id="4c89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我已经展示了使用一个生成器的生成器管道确实比其他版本更易读。特别是，这一呼吁:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比下面的生成器管道可读性差:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法都导致了完全相同的<code class="fe ng nh ni nj b">generator</code>、<code class="fe ng nh ni nj b">results</code>。但是它们是不同的，在这种情况下，简洁不会带来可读性。</p><p id="eaa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成器管道的确可读性更好，但这并不意味着它的可读性不能再提高了。每个操作(步骤)本身就是一个生成器，这有助于我们理解每个步骤中发生了什么。</p><p id="b252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不喜欢这段代码的重复和不必要的视觉混乱。这背后的主要原因是生成器表达式中的<code class="fe ng nh ni nj b">for</code>循环。乍一看，它们可能很重要，尽管事实是它们并不重要。</p><p id="2e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一点:那些创建过几个生成器管道的人知道，创建它们有时会很棘手；不一定很难编码，但有时很棘手。第一种方法——在一个长链中一个接一个地调用函数——可能是一个更大的挑战，尤其是当您需要在中间添加一个新的操作时。</p><p id="9abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是我写这篇文章的原因。我建议采用一种介于两者之间的方法，将前一种方法的简洁性与后一种方法的可读性结合起来。通过这样做，这种方法避免了不必要的代码片段，这些片段在每一步中都重复出现，尽管它们不做任何必要的事情。在这样的渠道中，我们有几个基本项目:</p><ul class=""><li id="3487" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">生成器:事实是我们只有一个iterable，所以我们应该只有一个生成器；在提议的生成器管道结构中，<code class="fe ng nh ni nj b">step1</code>创建了这个生成器；</li><li id="8b03" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="nm">操作</em>:在上面的例子中，它们由函数表示，每个函数执行一个操作；在我们这里是<code class="fe ng nh ni nj b">function1</code>、<code class="fe ng nh ni nj b">function2</code>、<code class="fe ng nh ni nj b">function3 </code>、<code class="fe ng nh ni nj b">function4</code>；</li><li id="c4f1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><em class="nm">结果生成器对象</em>:这是你需要得到结果时所求值的对象，但是注意它是在第一步开始的，最后一步仍然使用它。</li></ul><p id="4089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用本文中提出的生成器管道结构，我们将得到一个新类型的生成器管道，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a8b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在上面提到过编写<code class="fe ng nh ni nj b">get_pipeline_all_calc()</code>和<code class="fe ng nh ni nj b">get_p[ipeline_original)</code>可能会很棘手。这种结构<em class="nm">并不棘手</em>。很<em class="nm">直白</em>。很清楚。虽然仍然比第一种方法长，但它不会像原始管道那样添加不必要的代码。与其他两个版本相比，我肯定更喜欢这个版本，尽管我确实理解并接受这也是一个偏好问题。</p><p id="5358" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在性能方面，新的生成器管道介于两者之间，其中<code class="fe ng nh ni nj b">map()</code>版本比生成器表达式版本性能更好。但是我们必须记住，通常情况下，这并不重要，如果一个管道需要一些计算时间，那么创建多个生成器(就像在原始生成器管道中所做的那样)的开销是可以忽略的。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="5dd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这篇文章没有提供任何新奇的东西。我们很多人都用过类似的管道，只是不叫它们“发电机管道”；或者不打电话给他们。</p><p id="8706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于传统的生成器管道通常被认为是创建内存高效管道的好方法(例如，<a class="ae ky" href="https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e" rel="noopener">兰登2012 </a>、<a class="ae ky" href="https://brett.is/writing/about/generator-pipelines-in-python/" rel="noopener ugc nofollow" target="_blank">乌赞2020 </a>和<a class="ae ky" href="https://betterprogramming.pub/3-data-processing-pipelines-you-can-build-with-python-generators-dc0d2019b177" rel="noopener ugc nofollow" target="_blank">卡尔曼2021 </a>)，本文建议以一种新的方式创建生成器管道，将所有操作包装在一个函数中，并使用该函数创建一个生成器。</p><p id="5560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法更简单、更高效、可读性更强。总之是比较好。</p><h1 id="0ccc" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">资源</h1><ul class=""><li id="c276" class="lv lw it lb b lc nb lf nc li nu lm nv lq nw lu ma mb mc md bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Pipeline_(software)" rel="noopener ugc nofollow" target="_blank">维基百科。管道(软件)。</a></li><li id="ef86" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">科萨克米(2022)。Python的类型暗示:朋友，敌人，还是只是头痛？<em class="nm">更好的编程</em>。</li><li id="65b5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b"><a class="ae ky" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">black</a></code> <a class="ae ky" href="https://github.com/psf/black" rel="noopener ugc nofollow" target="_blank">:不妥协的代码格式化程序。GitHub仓库。</a></li><li id="1063" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Python之禅:<a class="ae ky" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">https://peps.python.org/pep-0020/</a></li><li id="5171" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">科萨克米(2022)。用 <code class="fe ng nh ni nj b"><a class="ae ky" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">timeit</a></code> <a class="ae ky" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">对标Python代码。<em class="nm">走向数据科学</em>。</a></li><li id="7ac6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ng nh ni nj b"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit </a></code> <a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> —测量小代码片段的执行时间。文档。</a></li><li id="491a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">科萨克米(2022)。Python还需要map()函数吗？<em class="nm">走向数据科学</em>。</li><li id="da93" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://gist.github.com/nyggus/6312fda2702f137899a5f23a7d746963" rel="noopener ugc nofollow" target="_blank"> Git要点与基准代码。</a></li><li id="1505" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://gist.github.com/nyggus/d3e225bf4cab72f1ae66fe2e4881bae0" rel="noopener ugc nofollow" target="_blank">基准测试结果。</a></li><li id="4510" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/analytics-vidhya/building-a-data-pipeline-with-python-generators-a80a4d19019e" rel="noopener">乌赞一世(2020)。用Python生成器构建数据管道。</a></li><li id="b40d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://brett.is/writing/about/generator-pipelines-in-python/" rel="noopener ugc nofollow" target="_blank">兰登b。Python中的生成器管道。</a></li><li id="44b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Kalkman P. (2021)。您可以使用Python生成器构建3个数据处理管道。</li></ul></div></div>    
</body>
</html>