<html>
<head>
<title>R Shiny Gadgets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">r闪亮的小玩意</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/r-shiny-gadgets-f9094ce21a47#2022-04-03">https://towardsdatascience.com/r-shiny-gadgets-f9094ce21a47#2022-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b574" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何帮助您的RStudio使用交互式应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4cbe5253de2bbaa7773e17190918c329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y7lHl-th-bQbMuM0f7zuTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8310" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://shiny.rstudio.com/" rel="noopener ugc nofollow" target="_blank"> Shiny </a>是一个非常著名且广泛使用的R包，它让你可以用R开发交互式web应用，而不需要HTML、CSS或JavaScript编码。我最近自己发现，Shiny有一个鲜为人知的功能，即所谓的闪亮小工具。这些小工具基本上是迷你应用程序，你可以直接从RStudio运行，例如在你的查看器面板中。</p><p id="ea14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，小玩意似乎在很大程度上被遗忘了。它们是在5年多前问世的，正如我们所知，这在数据科学领域是一个很大的进步。有一些2016年和2017年的教程，几个关于堆栈溢出的问题，就这些。</p><p id="3757" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反正我开始在日常工作中使用一个闪亮的小玩意，我觉得值得分享。在这篇文章中，我们将学习什么是闪亮的小工具，然后仔细看看我创造的一个。如果你只是需要代码，你可以在<a class="ae lu" href="https://github.com/MatePocs/rshiny_apps/blob/main/gadgets/my_plot_gadget.R" rel="noopener ugc nofollow" target="_blank">我的GitHub </a>上找到。我假设读者通常熟悉闪亮的应用程序，如果你不熟悉，有大量的好教程，我不久前也写了一个一般的<a class="ae lu" rel="noopener" target="_blank" href="/how-to-build-a-data-analysis-app-in-r-shiny-143bee9338f7">闪亮教程</a>。</p><h1 id="f2c4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是闪亮的小玩意？</h1><p id="99a5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">闪亮的小工具是包装在一个函数中的迷你闪亮应用程序，可能有返回值。一旦gadget功能在您的环境中，您就可以像运行任何其他功能一样运行它。应用程序会弹出，你与它交互，当你关闭它时，你会得到返回值，你可以在你常规的R工作中使用。</p><p id="435b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">小工具的构建与常规应用非常相似:它们有主要的<code class="fe ms mt mu mv b">ui</code>和<code class="fe ms mt mu mv b">server</code>功能，并使用相同的反应逻辑在前端和后端之间进行通信。</p><h2 id="b39a" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">闪亮应用和小工具的区别</h2><ul class=""><li id="0461" class="ni nj it la b lb mn le mo lh nk ll nl lp nm lt nn no np nq bi translated">从技术上讲，小工具是一种特殊的应用程序；每个小工具都是应用，但不是每个应用都是小工具。也就是说，本文中的“应用”仅指非小工具应用。</li><li id="02d8" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">小工具是编程过程的一部分，由R用户运行。另一方面，应用程序的主要目的是将结果或想法传达给更广泛的受众，他们不需要任何编程经验来与应用程序交互。</li><li id="1ae0" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">gadget在本地R会话中运行，从函数调用，而应用程序部署在web服务器上或嵌入R Markdown文档中。</li></ul><h2 id="9df9" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">小玩意的潜在用途</h2><p id="bd7a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你可能会说，这很好，但是实际上在哪里可以使用这样的工具呢？毕竟，如果我们内联运行它，使用代码肯定会更快？一般来说，我会说是的，在绝大多数情况下，使用代码比在UI中点击更快，这可能是这个工具没有更受欢迎的主要原因之一。</p><blockquote class="nw"><p id="fde6" class="nx ny it bd nz oa ob oc od oe of lt dk translated">然而，有一个我认为小工具真正闪耀的利基领域(双关语):利用图来过滤你的数据。</p></blockquote><p id="c032" class="pw-post-body-paragraph ky kz it la b lb og ju ld le oh jx lg lh oi lj lk ll oj ln lo lp ok lr ls lt im bi translated">我不认为这是巧合，<a class="ae lu" href="https://shiny.rstudio.com/articles/gadgets.html" rel="noopener ugc nofollow" target="_blank">小工具教程网站</a>上的主要例子展示了这样一个应用程序。</p><p id="77df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了完整起见，我还发现了其他一些可能有效的潜在用途:一个用于可视化的交互式颜色选择器，一个密码处理器(你输入你的密码，这样你就不必在代码中硬编码/从文件中导入)，以及一个正则表达式测试器。也有一堆其他小工具的想法被抛出，如交互式模型生成器，但我个人并不认为这是一个非常有吸引力的解决方案。</p><h1 id="075b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我的小工具</h1><p id="b54f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">现在让我们来看看我创建的小工具，实际上我发现它很有用。我的起点是<a class="ae lu" href="https://shiny.rstudio.com/articles/gadgets.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，它显示了一个小工具，让你从一个矩形的图表中选择点，并返回你选择的点的列表。我采纳了这个想法，并根据需要添加了一些额外的功能。</p><h2 id="e676" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">描述</h2><p id="9ed1" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">小工具功能:</p><ul class=""><li id="43cf" class="ni nj it la b lb lc le lf lh ol ll om lp on lt nn no np nq bi translated">将一个<code class="fe ms mt mu mv b">data.frame</code>作为输入</li><li id="08dc" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">创建散点图</li><li id="4ebf" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">用户可以选择X和Y变量，图形会动态更新</li><li id="fb73" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">当用户选择绘图中的一个区域时(用闪亮的术语来说:刷它)，区域中的点根据当前从下拉列表中选择的内容改变颜色，并且可以多次重复这个选择</li><li id="488c" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">一旦用户关闭应用程序，返回值是一个带有颜色代码的向量</li></ul><h2 id="f4a7" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">我认为这个小工具有用的地方</h2><ul class=""><li id="0074" class="ni nj it la b lb mn le mo lh nk ll nl lp nm lt nn no np nq bi translated">标记异常值</li><li id="24e1" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">将数据分成最多三组</li><li id="263e" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">检查数据点如何随着图上X和Y变量的变化而移动</li></ul><h2 id="d39c" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">限制</h2><ul class=""><li id="8e1c" class="ni nj it la b lb mn le mo lh nk ll nl lp nm lt nn no np nq bi translated">这个小工具只适用于足够小的数据，可以在散点图上可视化，最多几百行</li></ul><h1 id="7b84" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">代码</h1><p id="3e4d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我的<a class="ae lu" href="https://github.com/MatePocs/rshiny_apps/blob/main/gadgets/my_plot_gadget.R" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上也有这个小工具，下面是全部内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><h1 id="175f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何运行小工具</h1><p id="4144" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">要在RStudio中运行小工具:</p><ul class=""><li id="08eb" class="ni nj it la b lb lc le lf lh ol ll om lp on lt nn no np nq bi translated">在您的环境中导入函数</li><li id="5721" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">像这样运行函数:<br/> <code class="fe ms mt mu mv b">results &lt;- my_plot_gadget(iris, “Petal.Length”, “Sepal.Width”)</code></li><li id="6b9f" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">在查看器面板中与应用程序互动</li><li id="88f2" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">点击完成按钮</li><li id="b19d" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated"><code class="fe ms mt mu mv b">results</code>矢量将包含你分配给不同点的颜色</li></ul><h1 id="7eda" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">守则的注释</h1><p id="f6c3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">以下是我在使用这个小工具时发现的一些有趣的事情。</p><h2 id="4621" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">miniUI</h2><p id="dda6" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">正如你可能注意到的，我们装载了<code class="fe ms mt mu mv b">miniUI</code>包，还有<code class="fe ms mt mu mv b">shiny</code>。这个包帮助你创建一个在小屏幕空间工作的用户界面，例如，在RStudio的查看器面板中。详见<a class="ae lu" href="https://shiny.rstudio.com/articles/gadget-ui.html" rel="noopener ugc nofollow" target="_blank"> UI设计指南</a>。</p><p id="28fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有趣的是，你可以在常规应用中使用<code class="fe ms mt mu mv b">miniUI</code>元素，在小工具中使用常规闪亮的UI元素(如<code class="fe ms mt mu mv b">fluidPage</code>、<code class="fe ms mt mu mv b">sidebarLayout</code>等)。请注意，从查看器面板运行小工具并不是唯一的选择，您还可以做一个弹出窗口，在这里使用常规UI元素是完全可行的。</p><h2 id="0e04" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">菲尔罗和菲尔科尔</h2><p id="4ee4" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">除了使用像<code class="fe ms mt mu mv b">miniContentPanel</code>这样的<code class="fe ms mt mu mv b">miniUI</code>元素，设计指南还推荐使用大而闪亮的封装中的两个函数:<code class="fe ms mt mu mv b"><a class="ae lu" href="https://shiny.rstudio.com/reference/shiny/0.14/fillRow.html" rel="noopener ugc nofollow" target="_blank">fillRow</a></code>和<code class="fe ms mt mu mv b"><a class="ae lu" href="https://shiny.rstudio.com/reference/shiny/0.14/fillRow.html" rel="noopener ugc nofollow" target="_blank">fillCol</a></code>。做了相当多的实验才把这些做对。</p><p id="4881" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码:</p><pre class="kj kk kl km gt oq mv or os aw ot bi"><span id="9aaa" class="mw lw it mv b gy ou ov l ow ox">fillRow(flex = c(NA, 1),…</span></pre><p id="085a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">意味着第一列将使用它所需要的空间，第二列将获得行中剩余的可用空间。但是，我还必须单独将第一列的宽度定义为150像素。您可能会认为，如果您手动定义宽度，您可以省略flex部分，但这不起作用。</p><p id="44dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更奇怪的是，我发现为了让右边的按钮对齐，我不得不插入以下内容:</p><pre class="kj kk kl km gt oq mv or os aw ot bi"><span id="5aa3" class="mw lw it mv b gy ou ov l ow ox">fillCol(flex = c(NA, NA, NA),…</span></pre><p id="5af0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以有3个元素，它们都应该使用尽可能多的空间。这不是默认设置，如果省略flex部分，按钮将分布在整个列中。</p><p id="d1d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也有一些违反直觉的缺省值(至少对我来说是违反直觉的)，比如必须为绘图定义高度= 100%。</p><h2 id="08d3" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">stopApp</h2><p id="3440" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这个函数停止应用程序的运行，它的参数定义了整个gadget函数的返回值。在RStudio中包含关闭小工具并返回到日常工作的路线非常重要。</p><p id="ad0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从技术上来说，你也可以把这个放在一个普通的闪亮的应用程序中。然而，我们倾向于将闪亮的应用程序视为网页，我们不期望它们有一个关闭一切的按钮。<code class="fe ms mt mu mv b"><a class="ae lu" href="https://rdrr.io/cran/miniUI/man/miniTitleBar.html" rel="noopener ugc nofollow" target="_blank">gadgetTitleBar</a></code>函数为你创建了两个默认按钮，<code class="fe ms mt mu mv b">cancel</code>和<code class="fe ms mt mu mv b">done</code>，在<code class="fe ms mt mu mv b">observeEvent</code>中编辑它们的行为很重要。如果你不把这个位放在代码里:</p><pre class="kj kk kl km gt oq mv or os aw ot bi"><span id="cbee" class="mw lw it mv b gy ou ov l ow ox">observeEvent(input$cancel, {<br/>  stopApp(NULL)<br/>})</span></pre><p id="4413" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次你点击<code class="fe ms mt mu mv b">cancel</code>，你都会得到一个错误信息，这很快就变得很烦人。</p><h2 id="b324" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">电抗值与电抗</h2><p id="f333" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当我第一次使用Shiny时，我犯了一个错误，认为<code class="fe ms mt mu mv b"><a class="ae lu" href="https://shiny.rstudio.com/reference/shiny/0.11/reactiveValues.html" rel="noopener ugc nofollow" target="_blank">reactiveValues</a></code>只是一个<code class="fe ms mt mu mv b">reactive</code>对象的列表，使用<code class="fe ms mt mu mv b">reactiveValues</code>来跟踪一个对象是没有意义的。事实并非如此！</p><p id="7aa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关键的区别在于您可以从多个来源改变<code class="fe ms mt mu mv b">reactiveValues</code>中的对象。如果您有一个反应性元素，其行为就像一个跟踪某个状态的变量，那么使用<code class="fe ms mt mu mv b">reactiveValues</code>可能是有意义的。更多详情参见本<a class="ae lu" href="https://stackoverflow.com/questions/39436713/r-shiny-reactivevalues-vs-reactive" rel="noopener ugc nofollow" target="_blank">论坛交流</a>和本<a class="ae lu" href="https://shiny.rstudio.com/articles/reactivity-overview.html" rel="noopener ugc nofollow" target="_blank">关于反应性的文档</a>。</p><p id="5773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我的小工具中，我定义了一个跟踪颜色状态的向量，它被初始化为:</p><pre class="kj kk kl km gt oq mv or os aw ot bi"><span id="8332" class="mw lw it mv b gy ou ov l ow ox">results &lt;- reactiveValues(<br/>  colourcodes = rep(“none”, nrow(data))<br/>)</span></pre><p id="0c39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">稍后，当<code class="fe ms mt mu mv b">main_plot_brush</code>事件发生时(因此用户改变了绘图上的矩形选择)，它会相应地更新。我可以简单地在一个<code class="fe ms mt mu mv b">observeEvent</code>中给<code class="fe ms mt mu mv b">results$colourcodes</code>赋值。如果我定义了一个<code class="fe ms mt mu mv b">reactive</code>对象并试图在其他地方更新它，同样的情况不会发生:</p><pre class="kj kk kl km gt oq mv or os aw ot bi"><span id="15ef" class="mw lw it mv b gy ou ov l ow ox">results_colourcodes &lt;- reactive(rep(“none”, nrow(data)))</span></pre><p id="971b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">自然，使用一个常规的、非反应性的变量也不行，因为这样它就不能在<code class="fe ms mt mu mv b">observeEvent</code>中更新。</p><h2 id="87a5" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">清理刷子</h2><p id="5c06" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">一个有趣的用户体验决定。我最初把<code class="fe ms mt mu mv b">resetBrush</code>函数放在<code class="fe ms mt mu mv b">observeEvent</code>中，它监视画笔的更新。当画笔事件发生时，我更新了<code class="fe ms mt mu mv b">results$colourcodes</code>状态向量，然后清除了画笔。然而，因为这都是在一个<code class="fe ms mt mu mv b">observeEvent</code>中完成的，所以绘图更新直到完成后才开始，这导致了用户体验的轻微偏离:用户选择了矩形，它立即消失，然后在一个小但明显的延迟之后，绘图中的点得到了它们的颜色。</p><p id="ee61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我最终创建了一个独立的<code class="fe ms mt mu mv b">observeEvent</code>来监控<code class="fe ms mt mu mv b">main_plot</code>的更新。这让流动感觉更加自然。</p><h2 id="4799" class="mw lw it bd lx mx my dn mb mz na dp mf lh nb nc mh ll nd ne mj lp nf ng ml nh bi translated">最后一个值</h2><p id="ef6e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果您忘记将函数结果分配给一个对象，您的结果将简单地打印在控制台上，就像其他函数一样。请记住，您可以使用<code class="fe ms mt mu mv b">.Last.Value</code>来访问您在R中运行的最后一行的结果，并将其保存在一个对象中。在使用小工具的时候，我确实经历了很多。</p><div class="oy oz gp gr pa pb"><a href="https://matepocs.medium.com/membership" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">加入我的推荐链接-伴侣概念</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">matepocs.medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ks pb"/></div></div></a></div><h1 id="a1e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">来源</h1><div class="oy oz gp gr pa pb"><a href="https://shiny.rstudio.com/articles/gadgets.html" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">闪亮的小玩意</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">Shiny最初被认为是一种交互交流想法和结果的媒介。作为一个闪亮的作者…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">shiny.rstudio.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp ks pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://www.rstudio.com/resources/webinars/introducing-shiny-gadgets-interactive-tools/" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">介绍闪亮的小工具:交互式工具</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">一个闪亮的小工具是一个交互工具，可以增强你的R编程体验。</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">www.rstudio.com</p></div></div><div class="pk l"><div class="pr l pm pn po pk pp ks pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://shiny.rstudio.com/articles/selecting-rows-of-data.html" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">选择数据行</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">鼠标交互的一个常见用途是从输入数据框中选择数据行。虽然你可以写代码…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">shiny.rstudio.com</p></div></div></div></a></div></div></div>    
</body>
</html>