<html>
<head>
<title>Don’t Take Shortcuts When Handling Missing Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理缺失值时不要走捷径</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-take-shortcuts-when-handling-missing-values-afb9312e73c3#2022-11-08">https://towardsdatascience.com/dont-take-shortcuts-when-handling-missing-values-afb9312e73c3#2022-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6234" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何确保缺失数据得到正确处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a91af2c1bfe59bd304300e2b2c090ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PAvTWugFCkDnP62bjhOUfQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安H的照片:<a class="ae ky" href="https://www.pexels.com/photo/pink-jigsaw-puzzle-piece-3482441/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/pink-jigsaw-puzzle-piece-3482441/</a></p></figure><p id="d051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多数据集中，缺失值是一个两难问题，但是许多用户渴望分配更少的时间来处理它们，以便他们可以将更多的精力放在建模上。</p><p id="7a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写这篇文章之前，我最近遇到了许多将丢失数据视为事后想法的投资组合项目。人们对最佳算法和超参数进行了大量的考虑，但很少对选择的插补方法进行论证。</p><p id="171b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我明白，建立模型很有趣，但机器学习项目的成功取决于在任何建模之前如何处理数据。</p><p id="144a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们深入探讨了许多人在处理缺失数据时往往会跳过的重要步骤，并展示了用户如何在自己的项目中实现这一点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="00fa" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">最重要的一步</h2><p id="cfa8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">那么，您必须执行什么步骤来确保正确处理丢失的数据呢？</p><p id="705c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答案很简单:探索性数据分析(EDA)！</p><p id="0577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在处理数据集中缺失的数据时，用户经常会忽略EDA。相反，他们选择依靠他们最熟悉/最舒适的方法。</p><p id="a641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，不考虑“为什么”而盲目地执行技术是一个灾难。</p><p id="31e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，丢失数据的性质因情况而异。在处理缺失值时，适用于一个使用数据集中的方法可能不适用于另一个使用数据集中。</p><p id="735b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跳过EDA的用户更有可能使用基于错误假设的技术，这将影响数据质量。较差的数据质量自然会对后续建模阶段建立的任何机器学习模型产生负面影响(垃圾进，垃圾出)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="0524" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">使用EDA处理缺失数据</h2><p id="2389" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">EDA是掌握数据集的关键特征及其缺失值的有效方法。通过掌握关于缺失数据的更多信息，您将能够就如何处理这些缺失值做出更明智的决策。</p><p id="1071" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个问题是:当用户用EDA检查他们的数据时，到底应该寻找什么？</p><p id="a77a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，处理缺失数据的用户应回答以下问题:</p><ul class=""><li id="6698" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">哪些要素包含缺失值？</li><li id="2dc7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">每个特征的记录中缺失数据的比例是多少？</li><li id="c0d7" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">缺失数据是随机缺失(MAR)还是非随机缺失(MNAR)？</li><li id="699b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">具有缺失值的要素是否与其他要素相关？</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="f3a4" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">处理缺失数据的方法</h2><p id="2da5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了有效地解决缺少值的困境，用户将受益于对他们可用的各种技术的熟悉。了解几种方法及其优缺点将增加选择最佳方法的机会。</p><p id="0ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们简要概述一些处理缺失数据的基本和高级方法，并考虑它们的优点和局限性。</p><p id="e82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们将使用下面的模拟数据集演示如何在Python中使用这些方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/ce72adf02d5b2040e1b78c648d70a2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*NLG-fSGc-nFFBZCKaXISeg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="dcdc" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">基本方法</h2><ol class=""><li id="3efd" class="na nb it lb b lc mv lf mw li nr lm ns lq nt lu nu ng nh ni bi translated"><strong class="lb iu">省略有缺失数据的记录</strong></li></ol><p id="bc31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有缺少值的数据点吗？</p><p id="1331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需从数据集中删除它们！问题解决了！</p><p id="3edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的优点是它是处理缺失值的最简单的方法。就代码而言，您可以使用Pandas库用一行程序执行这个操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/7abc13859495132d6b1ea536da4e127e.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*alXwQB6lYXdIrW0TZDZjXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="b557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这种方法会产生一个小得多的数据集，从而为模型提供较少的训练信息。此外，如果缺失值不是随机缺失(MNAR)，这意味着移除这些数据点将不可避免地导致模型中的偏差。</p><p id="6fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很少是处理缺失数据的首选方法。对于考虑这种方法的人来说，至少要确保有足够的数据，并且缺失值是随机缺失的。</p><p id="5116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。省略丢失数据的特征</strong></p><p id="164f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种选择是只移除特征而不是数据点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5b4c7771aa4b534fd51a0b3c315bfade.png" data-original-src="https://miro.medium.com/v2/resize:fit:184/format:webp/1*qiEV48IkoBPjsHpeTqxRPg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="3d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这需要移除数据，因此用户在考虑此方法之前，应首先验证要素中缺失数据的数量。</p><p id="44f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果某个要素缺少太多数据，它很可能不会对模型有所贡献。对于这种情况，最好不要考虑这个特性。</p><p id="2082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。用统计数据输入缺失数据</strong></p><p id="472f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户可以依靠简单的插补方法，用导出值替换缺失数据，而不是删除缺失值的记录或特征。对于数字要素，缺失数据可以用分布中值的平均值或中值来替换。对于分类特征，缺失数据可以由模式替换。</p><p id="8678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中的插补可以用Scikit Learn包的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.SimpleImputer.html" rel="noopener ugc nofollow" target="_blank">simple imputr</a>类来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/467b74281854a087ea988cabe79cb38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*J5OiYOW9-XioNBxFukKQrg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="bff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然简单的插补听起来像是一种完美的方法，但它忽略了感兴趣的特征与任何其他特征之间可能存在的相关性，而其他特征可能不适合感兴趣的数据。因此，用基本方法替换缺失值可能会产生不能充分代表数据点的值分布。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3c22" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">处理缺失数据的高级方法</h2><p id="4fed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">到目前为止，我们已经探索了一些解决缺失值的简单方法。然而，这些方法基于可能不适用于现实生活场景的假设。</p><p id="3b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于较简单的方法无法解决的情况，值得考虑在输入缺失数据时考虑多个变量的更高级的方法。</p><ol class=""><li id="045f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nu ng nh ni bi translated"><strong class="lb iu">用K-最近邻进行输入</strong></li></ol><p id="b6f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能熟悉K-最近邻算法在分类中的应用，但是您知道吗，您还可以利用K-最近邻算法来估算缺失值？</p><p id="8d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该过程需要在特征空间中绘制特征，以找到具有缺失值的记录的“最近邻”。然后，最近邻值的平均值用于估算缺失值。</p><p id="ebd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用Scikit-learn模块的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.KNNImputer.html" rel="noopener ugc nofollow" target="_blank"> KNNImputer </a>类来执行这项技术。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/b52dde94ba50059d2e632b9603c1c155.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*UyU3_wKwMVjOI-yB0S0E9A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="896f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">KNN算法的主要缺点是计算量大，容易出现异常值。</p><p id="b6c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。用链式方程进行多元插补(小鼠)</strong></p><p id="df60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MICE是一种独特的插补方法，没有得到足够的重视。可以说它值得单独写一篇文章。</p><p id="f726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，该方法需要为每个缺失值创建多个插补，而不是只有一个。该算法解决了统计不确定性，并使用户能够估算不同类型数据的值。</p><p id="a0d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解这个算法的来龙去脉，我找到了一篇很好的论文，在这里详细介绍了它。</p><p id="9da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以使用Scikit Learn包的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html" rel="noopener ugc nofollow" target="_blank">iterative imputr</a>类在Python中实现MICE算法。注意这个类还是实验性的，所以你还需要导入<code class="fe nz oa ob oc b">enable_iterative_imputer</code>来使用它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/5438ddf20aa3fd9a8ac714bfa4d752cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*TCAopfc-GHDGowLOb3V6Tw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="e791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MICE算法是健壮的，但是它是在假设数据中的缺失值是随机缺失(MAR)的情况下运行的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="2940" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">寻找最佳方法</h2><p id="f3b3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因为没有一种放之四海而皆准的方法可以用来处理缺失值，所以理想的方法取决于所讨论的数据。</p><p id="7f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，任何关于丢失数据处理的决定都应始终基于明智的决定，这就是为什么在处理丢失数据之前进行EDA如此重要的原因。</p><p id="e6e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过识别感兴趣的数据集的特征，您可以识别最合适的方法，或者至少可以不考虑某些方法。</p><p id="bf6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些示例，说明您可以从EDA中检测到什么，以及如何根据您的发现处理丢失的数据:</p><ol class=""><li id="5cba" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nu ng nh ni bi translated">如果数据集的要素有超过80%的记录缺失数据，最好是将该要素完全移除。</li><li id="e95f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nu ng nh ni bi translated">如果具有缺失值的要素与其他缺失值密切相关，则值得考虑使用高级插补技术，该技术使用来自其他要素的信息来推导值以替换缺失数据。</li><li id="b6a4" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nu ng nh ni bi translated">如果某个特性的值不是随机丢失的(MNAR ),请不要考虑像鼠标这样的方法。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="16a7" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">关键要点</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a876959ca6db076eda2b6420e4b5c5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xhK_70_KwG_ehzaD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>拍摄</p></figure><p id="3dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的主要观点应该是始终分配时间来执行EDA，以便更好地理解您的数据。您的EDA结果将让您深入了解与给定用例最兼容的技术。</p><p id="7240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，值得用处理缺失数据的多种方法的知识来武装自己，以确保EDA的发现将引导您选择最佳方法。</p><p id="a66e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您可以直接进入建模阶段时，花费额外的时间查看您的数据可能看起来很麻烦(我明白，EDA可能很无聊)，但是当最终的模型表现令人满意时，花费额外的时间来确定要使用的最佳技术将会得到回报。</p><p id="e821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我祝你在数据科学的努力中好运！</p></div></div>    
</body>
</html>