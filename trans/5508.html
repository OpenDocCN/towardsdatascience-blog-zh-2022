<html>
<head>
<title>Python Tracebacks — Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 回溯-解释</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-tracebacks-explained-538caaac434#2022-12-12">https://towardsdatascience.com/python-tracebacks-explained-538caaac434#2022-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7435" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调试的好帮手</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9d767a41c84a2cedd6870e7a29998404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-bWqZTYz9WNYCXTMz1K-g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·尼加德在<a class="ae ky" href="https://unsplash.com/s/photos/trace?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们很少能在第一次尝试时运行一个没有任何错误的脚本，这在编写代码时是绝对正常的。重要且有时具有挑战性的部分是修复这些错误。</p><p id="2cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复错误并使脚本按预期工作的过程可能需要多次迭代，这取决于程序员的经验和我们对错误的了解。编程语言给了我们一些提示，告诉我们是什么导致了错误，这基本上就是 Python 回溯所做的事情。</p><p id="b73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 中的回溯可以看作是一份报告，帮助我们理解和修复代码中的问题。在本文中，我们将学习什么是 Python 中的回溯，如何阅读回溯消息以便能够更有效地使用它们，以及不同的错误类型。</p><h1 id="ce4c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Python 中的回溯是什么？</h1><p id="86b5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 中的程序在遇到错误时会停止执行，错误的形式可能是语法错误或异常。当解释器检测到无效的语法时，就会出现语法错误，这相对来说比较容易解决。</p><p id="6f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法错误的一个例子是不匹配的括号。另一方面，当语法正确但程序导致错误时，会引发异常。</p><p id="9bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回溯是帮助我们理解异常原因的报告。它包含代码中的函数调用以及它们的行号，这样我们就不会对导致代码失败的问题一无所知。</p><p id="056d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的例子。</p><p id="308b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段创建了一个函数，该函数将两个数字相加，并将总和乘以第一个数字。然后，它调用带有参数 5 和 4 的函数。但是，4 是作为字符串传递的，所以它实际上不是一个数字。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="246e" class="mx lw it mt b be my mz l na nb">def add_and_multiply(x, y):<br/>    return (x + y) * x<br/><br/>add_and_multiply(5, "4")</span></pre><p id="7c3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行此代码时，Python 会引发以下异常:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/1dfb4251effcfaecafa867da09a4bdf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RIG1XI55A1UERRNtSyyA_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="4de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行显示了错误类型以及简短的解释。这种情况下的错误是由整数和字符串之间不受支持的操作数导致的类型错误。加号运算符不能用于将字符串与整数相加，因此代码会导致异常。</p><p id="9aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行上面的行根据函数名和行号告诉我们异常发生的位置。我们这里的例子非常简单，但是当处理非常长的脚本或具有多个脚本的程序时，关于函数名和行号的信息对于诊断和修复问题非常有帮助。</p><p id="2d65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回溯还显示了模块和文件名，这在处理从其他文件或脚本导入模块的脚本时非常有用。根据您的工作环境(如终端或 REPL)，文件名和模块名的显示方式会略有不同。</p><p id="b55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当我将上面的代码片段保存为“sample_script.py”并尝试在终端中运行它时，我得到以下回溯:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="128f" class="mx lw it mt b be my mz l na nb">Traceback (most recent call last):<br/>  File "/Users/sonery/sample_script.py", line 6, in &lt;module&gt;<br/>    add_and_multiply(5, "6")<br/>  File "/Users/sonery/sample_script.py", line 2, in add_and_multiply<br/>    print((x + y) * x)<br/>TypeError: unsupported operand type(s) for +: 'int' and 'str'</span></pre><p id="7278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何情况下，我们都可以从回溯消息中获得有用的线索。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="1748" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">常见追溯类型</h1><p id="3920" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">创建高效程序并在生产中维护它们的大量时间都花在了调试错误上。因此，利用 Python 回溯至关重要。</p><p id="77ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，可能需要花费数小时来查找和修复问题，如果程序已经部署到生产环境中，这可能会产生严重的后果。​</p><p id="4b92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回溯消息最重要的部分是错误类型，因为它提示我们是哪种错误导致脚本停止执行。</p><p id="7b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回顾一下回溯消息中一些常见的错误类型。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="ed0b" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">类型错误</h2><p id="1453" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当对象的数据类型与定义的操作不兼容时，会发生类型错误。我们在开始时做的添加整数和字符串的例子就是这种错误的一个例子。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="51ce" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">属性错误</h2><p id="0c7c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在 Python 中，一切都是一个具有整数、字符串、列表、元组、字典等类型的对象。使用类来定义类型，类也具有用于与类的对象交互的属性。</p><p id="dbdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类可以有数据属性和过程属性(即方法):</p><ul class=""><li id="a34c" class="ob oc it lb b lc ld lf lg li od lm oe lq of lu og oh oi oj bi translated">数据属性:创建一个类的实例需要什么</li><li id="03f6" class="ob oc it lb b lc ok lf ol li om lm on lq oo lu og oh oi oj bi translated">方法(即过程属性):我们如何与类的实例交互。</li></ul><p id="1f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个 list 类型的对象。我们可以使用 append 方法向列表中添加新项。如果对象没有我们试图使用的属性，就会引发一个属性错误异常。</p><p id="d4aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="f04a" class="mx lw it mt b be my mz l na nb">mylist = [1, 2, 3, 4, 5]<br/><br/>mylist.add(10)<br/><br/># output<br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;ipython-input-25-4ad0ec665b52&gt;", line 3, in &lt;module&gt;<br/>    mylist.add(10)<br/>AttributeError: 'list' object has no attribute 'add'</span></pre><p id="192a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于 list 类没有名为“add”的属性，我们得到一个显示属性错误的回溯。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="c534" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">ImportError 和 ModuleNotFoundError</h2><p id="01c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 有大量的第三方库(即模块)，这使得用几行代码完成大量任务成为可能。</p><p id="669d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用这样的库，以及内置的 Python 库(例如操作系统、请求)，我们需要导入它们。如果在导入它们时出现问题，则会引发导入错误或模块未找到错误异常。</p><p id="bd8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在下面的代码片段中，我们试图从 Scikit-learn 导入逻辑回归类。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="2a89" class="mx lw it mt b be my mz l na nb">from sklearn import LogisticRegression<br/><br/># output<br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;ipython-input-22-b74afc1ba453&gt;", line 1, in &lt;module&gt;<br/>    from sklearn import LogisticRegression<br/>ImportError: cannot import name 'LogisticRegression' from 'sklearn' (/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sklearn/__init__.py)</span></pre><p id="31a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于线性模型模块中提供了逻辑回归类，因此引发了导入错误异常。正确的导入方法如下。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="3064" class="mx lw it mt b be my mz l na nb">from sklearn.linear_model import LogisticRegression</span></pre><p id="d284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果模块在工作环境中不可用，则会引发模块未找到错误异常。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="1311" class="mx lw it mt b be my mz l na nb">import openpyxl<br/><br/># output<br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;ipython-input-23-f5ea1cbb6934&gt;", line 1, in &lt;module&gt;<br/>    import openpyxl<br/>  File "/Applications/PyCharm CE.app/Contents/plugins/python-ce/helpers/pydev/_pydev_bundle/pydev_import_hook.py", line 21, in do_import<br/>    module = self._system_import(name, *args, **kwargs)<br/>ModuleNotFoundError: No module named 'openpyxl'</span></pre></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="be76" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">索引错误</h2><p id="8dea" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一些数据结构有一个索引，可以用来访问它们的项目，如列表、元组和数据帧。我们可以通过使用序列下标来访问一个特定的项目。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="de38" class="mx lw it mt b be my mz l na nb">names = ["John", "Jane", "Max", "Emily"]<br/><br/># Get the third item<br/>names[2]<br/><br/># output<br/>"Max"</span></pre><p id="dccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果下标超出范围，将引发索引错误异常。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="9b28" class="mx lw it mt b be my mz l na nb">names = ["John", "Jane", "Max", "Emily"]<br/><br/># Get the sixth item<br/>names[5]<br/><br/># output<br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;ipython-input-30-3033b2837dcd&gt;", line 3, in &lt;module&gt;<br/>    names[5]<br/>IndexError: list index out of range</span></pre><p id="05e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于列表包含 4 项，当我们试图访问不存在的第 6 项时，会引发一个异常。</p><p id="b97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用熊猫数据框架做另一个例子。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="8a80" class="mx lw it mt b be my mz l na nb">import pandas as pd<br/>import numpy as np<br/><br/>df = pd.DataFrame(np.random.randint(10, size=(5, 2)), columns=["A", "B"])<br/><br/>df<br/><br/># output<br/>   A  B<br/>0  1  6<br/>1  6  3<br/>2  8  8<br/>3  3  5<br/>4  5  6</span></pre><p id="c0cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量 df 是一个具有 5 行 2 列的数据帧。以下代码行试图获取第一行第三列中的值。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="75ee" class="mx lw it mt b be my mz l na nb">df.iloc[0, 3]<br/><br/># output<br/><br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;file&gt;", line 1, in &lt;module&gt;<br/>    df.iloc[0, 3]<br/>  File "&lt;file&gt;", line 960, in __getitem__<br/>    return self.obj._get_value(*key, takeable=self._takeable)<br/>  File "&lt;file&gt;", line 3612, in _get_value<br/>    series = self._ixs(col, axis=1)<br/>  File "&lt;file&gt;", line 3439, in _ixs<br/>    label = self.columns[i]<br/>  File "&lt;file&gt;", line 5039, in __getitem__<br/>    return getitem(key)<br/>IndexError: index 3 is out of bounds for axis 0 with size 2</span></pre><p id="7a04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在回溯的最后一行看到的，这是一个不言自明的错误消息。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="dcf8" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">名称错误</h2><p id="6f48" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们引用代码中未定义的变量时，会引发名称错误异常。</p><p id="f697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子:</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="e10e" class="mx lw it mt b be my mz l na nb">members = ["John", "Jane", "Max", "Emily"]<br/><br/>member[0]<br/><br/># output<br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;ipython-input-35-9fcefb83a26f&gt;", line 3, in &lt;module&gt;<br/>    name[5]<br/>NameError: name 'member' is not defined</span></pre><p id="c0a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量的名称是 members，所以当我们试图使用 member 而不是 members 时，我们会得到一个错误。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h2 id="139e" class="np lw it bd lx nq nr dn mb ns nt dp mf li nu nv mh lm nw nx mj lq ny nz ml oa bi translated">值错误</h2><p id="f2b2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我们试图给一个变量赋一个不合适的值时，就会出现值错误异常。回想一下我们的 5 行 2 列的数据帧。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="4560" class="mx lw it mt b be my mz l na nb">import pandas as pd<br/>import numpy as np<br/><br/>df = pd.DataFrame(np.random.randint(10, size=(5, 2)), columns=["A", "B"])<br/><br/>df<br/><br/># output<br/>   A  B<br/>0  1  6<br/>1  6  3<br/>2  8  8<br/>3  3  5<br/>4  5  6</span></pre><p id="7a36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想向这个数据帧添加一个新列。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="6795" class="mx lw it mt b be my mz l na nb">df["C"] = [1, 2, 3, 4]<br/><br/># output<br/>Traceback (most recent call last):<br/>  File "&lt;file&gt;", line 3378, in run_code<br/>    exec(code_obj, self.user_global_ns, self.user_ns)<br/>  File "&lt;file&gt;", line 1, in &lt;module&gt;<br/>    df["C"] = [1, 2, 3, 4]<br/>  File "&lt;file&gt;", line 3655, in __setitem__<br/>    self._set_item(key, value)<br/>  File "&lt;file&gt;", line 3832, in _set_item<br/>    value = self._sanitize_column(value)<br/>  File "&lt;file&gt;", line 4535, in _sanitize_column<br/>    com.require_length_match(value, self.index)<br/>  File "&lt;file&gt;", line 557, in require_length_match<br/>    raise ValueError(<br/>ValueError: Length of values (4) does not match length of index (5)</span></pre><p id="aa7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如错误消息中所述，数据帧有 5 行，因此每列有 5 个值。当我们试图创建一个包含 4 个条目的新列时，我们得到一个值错误。</p></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><h1 id="4253" class="lv lw it bd lx ly nk ma mb mc nl me mf jz nm ka mh kc nn kd mj kf no kg ml mm bi translated">结论</h1><p id="dc4e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">错误消息在调试代码或使代码第一次正确执行时非常有用。幸运的是，Python 回溯有清晰的解释性错误消息。</p><p id="6e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们学习了什么是回溯，如何阅读它，以及一些常见的回溯类型。</p><p id="3ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="op">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="op">媒介会员</em> </a> <em class="op">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅</em><a class="ae ky" href="https://sonery.medium.com/subscribe" rel="noopener"><em class="op"/></a><em class="op">如果你想在我发表新文章时收到电子邮件。</em></p><p id="4049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>