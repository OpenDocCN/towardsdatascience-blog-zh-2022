<html>
<head>
<title>Dockerizing Flask ML Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对接烧瓶ML应用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dockerizing-flask-ml-applications-3577b216dac0#2022-07-19">https://towardsdatascience.com/dockerizing-flask-ml-applications-3577b216dac0#2022-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b81e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Flask部署ML模型和将您的工作容器化的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/11d87e0264d339ee7268a3197ea1fe46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LpVjxPm4Ez2s-4IM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://unsplash.com/@jonassmith" rel="noopener ugc nofollow" target="_blank">乔纳斯·史密斯</a>的<a class="ae ky" href="https://unsplash.com/photos/aL6tG-j-E4Y" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="3094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署ML模型是ML生命周期中必不可少的一步，这一步经常被数据科学家所忽视。没有模型部署/托管，在现实世界的应用中就没有机器学习模型的使用。有很多种方法来保存你的ML模型，其中最简单也是最有效的是<a class="ae ky" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>。</p><p id="7886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flask是一个用Python实现的微型网络框架。使用Flask，我们将通过一个例子演示如何在本地为ML模型提供推理服务。如果你对Flask完全陌生，我建议你看一下这个<a class="ae ky" href="https://www.digitalocean.com/community/tutorials/how-to-make-a-web-application-using-flask-in-python-3" rel="noopener ugc nofollow" target="_blank">指南</a>，它会让你快速上手。</p><p id="ece4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">烧瓶只是我们要解决的首要问题的第一步。是的，我们可以找到一种方法来使用Flask托管我们的模型，但是我们如何在生产环境中维护这个环境呢？我们如何在实时应用程序中跟踪我们可能必须对软件进行的任何更改？</p><p id="b240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过Docker容器，我们提供了一个轻量级的包装器，可以非常容易地复制您的环境和依赖关系。例如，如果我们有一个软件更新需要安装在我们的应用程序中，Docker使实现和跟踪这个更新变得很简单。通过利用诸如<a class="ae ky" href="https://docs.docker.com/registry/" rel="noopener ugc nofollow" target="_blank"> Docker Registry </a>之类的服务，您还可以跟踪不同的映像版本以进行部署。使用Docker容器来保存我们的环境和我们所做的任何更改，软件生命周期变得更加简单和高效。关于Docker的完整分类，请查看下面的<a class="ae ky" href="https://medium.com/swlh/what-exactly-is-docker-1dd62e1fde38" rel="noopener">资源</a>。</p><p id="0f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过一个我们训练过的ML模型来看一下这两个步骤。</p><p id="928a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:本文将假设您对Python、Docker、Flask和使用CLI有基本的了解。我们也将使用一些基本的HTML/CSS，但是你可以原样复制模板。这篇文章也将使用一个ML模型来服务，但我们不会涵盖模型构建背后的任何理论，关于模型的具体信息，请参考这篇<a class="ae ky" href="https://medium.com/analytics-vidhya/basic-ml-models-pros-cons-code-demos-66412eb98b6f" rel="noopener">文章</a>。</p><h2 id="c51e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资料组</h2><p id="eaa5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于我们的例子，我们将使用来自Kaggle的<a class="ae ky" href="https://www.kaggle.com/datasets/harinir/petrol-consumption" rel="noopener ugc nofollow" target="_blank">汽油消耗回归数据集</a>。原始数据源在这里被许可<a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="b2f1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">模型结构</h2><p id="feb6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">对于本文，我们不会在模型构建或从数据科学性能角度选择最准确的模型上花费太多时间。对于我们的回归问题，我将通过Sklearn框架利用一个<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" rel="noopener ugc nofollow" target="_blank"> RandomForest回归</a>模型。一般来说，当我需要快速访问工作的ML模型示例时，我会尝试维护一个<a class="ae ky" href="https://github.com/RamVegiraju/ML-ToolBox" rel="noopener ugc nofollow" target="_blank">模型工具箱</a>，它会给我样板代码来加速这个过程。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">准备数据</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">训练随机森林模型</p></figure><p id="84eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<a class="ae ky" href="https://joblib.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Joblib </a>模块对模型进行序列化，为了验证它是否有效，我将快速预测一个样本数据点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本推断</p></figure><p id="988b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保保留生成的“model.pkl”文件(也可以创建model.joblib)。这是我们将在Flask服务器上加载用于推理的模型工件。</p><h2 id="df2c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">在Flask上托管模型</h2><p id="0592" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们的Flask应用程序有两个部分。首先，我们想使用一些基本的HTML/CSS为我们的前端构建一个模板。在这个模板中，我们所做的只是创建一个简单的表单，它将接受四个输入:汽油税、平均收入、铺设的公路和人口驾驶执照百分比。这是我们的模型在后端期望的四个参数，我们将通过这个表单捕获它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">形式</p></figure><p id="43ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们可以配置Flask应用程序来处理这些表单输入。让我们看看必要的导入并加载模型，这就是我们的model.pkl文件派上用场的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">负载模型</p></figure><p id="219b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在配置处理表单之前，让我们用Flask web服务器测试一个GET请求。我们渲染自己创建的index.html页面(请原谅我糟糕的HTML/CSS技能)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烧瓶应用程序设置</p></figure><p id="42c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在Flask应用程序文件所在的目录中运行以下命令，则可以启动Flask服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">启动服务器</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/933961e7266a1d62600cab46a45cbf59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l9WGODw4EOH5wDthVOYfkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表单模板(作者截图)</p></figure><p id="8e50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以处理表单的输入，并将它们提供给我们的模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">流程表单输入</p></figure><p id="d864" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在HTML方面，我们希望反映模型返回的输出变量“res ”,所以我们在index.html代码中添加了这一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反映结果</p></figure><p id="a036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在用一些虚拟值填写表单，我们应该能够在页面上看到推理输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/a85de97e1683271c684113b448793b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_OkrhYXvDyHQ4j0wk9qx0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提交表单(作者截图)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/3666b8b37542ff22e7a0f4b28b1e1932.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*hteCQgnvvbW925lsbA6_fQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推理显示(作者截图)</p></figure><p id="d87a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们有一个工作的Flask应用程序，现在让我们看看如何正确地将它容器化。</p><h2 id="97d4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">将烧瓶应用程序归档</h2><p id="9fb8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在开始之前，确保<a class="ae ky" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker已安装</a>并正常运行。</p><p id="66e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要知道两个主要的Docker实体:<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/image/" rel="noopener ugc nofollow" target="_blank"> Docker图像</a>和<a class="ae ky" href="https://www.docker.com/resources/what-container/" rel="noopener ugc nofollow" target="_blank"> Docker容器</a>。Docker映像包含我们的源代码、依赖项和环境。Docker容器是Docker图像的一个实例。使用Docker图像作为模板，我们可以运行启动应用程序的容器。要进一步了解不同之处，请参考这篇<a class="ae ky" href="https://phoenixnap.com/kb/docker-image-vs-container" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><p id="d4a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了建立我们的Docker映像，我们需要提供一个Docker文件，其中包含基本的设置说明。有了Dockerfiles，我们可以使用<a class="ae ky" href="https://docs.docker.com/docker-hub/official_images/" rel="noopener ugc nofollow" target="_blank">基础映像</a>，这些映像已经预装了依赖项和代码。我们将从<a class="ae ky" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank">基础Python映像</a>开始。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基础图像</p></figure><p id="5fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用<a class="ae ky" href="https://www.educative.io/answers/what-is-the-workdir-command-in-docker" rel="noopener ugc nofollow" target="_blank"> WORKDIR </a>命令来设置容器内的工作目录。利用容器中的根目录不一定是最佳实践，因为它可能导致类似的文件名和类似的小问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作目录</p></figure><p id="0108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了设置我们的环境，我们需要提供安装所需的依赖项，我们可以通过requirements.txt文件来完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">申请要求</p></figure><p id="13be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以首先复制这个需求文件，然后将它安装在我们的容器环境中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安装要求</p></figure><p id="1faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以将剩余的文件复制到工作目录中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将剩余文件复制到工作目录</p></figure><p id="09c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，利用<a class="ae ky" href="https://phoenixnap.com/kb/docker-cmd-vs-entrypoint#:~:text=CMD%20is%20an%20instruction%20that,container%20with%20a%20specific%20executable." rel="noopener ugc nofollow" target="_blank"> CMD </a>我们可以在启动容器时提供一个默认命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在容器中启动Flask Web服务器</p></figure><p id="7c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了Docker文件，我们可以通过在Docker文件所在的路径中运行以下命令来<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">构建</a>我们的Docker映像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建Docker映像</p></figure><p id="6799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个标记为“ramveg/ml-app”的Docker图像，您可以随意重命名它。默认情况下，这也是“最新”的版本，如果你想改变，你可以做“ramveg/ml-app:dev”或类似的事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建图像</p></figure><p id="8fb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过运行下面的<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/images/" rel="noopener ugc nofollow" target="_blank">命令</a>来看到这个图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/717dc599f7a457823654beffa9b4d220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NcqFp49Xudmcnnw5oOUedA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">码头图片(作者截图)</p></figure><p id="b090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您也可以使用以下命令检查容器的内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">检查码头集装箱</p></figure><p id="a843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该会在您的容器中启动一个shell，在这里您可以运行普通的linux命令来了解您的目录结构。这里我们看到了所有我们复制过来的文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/5170e2894828be82afb727d3c7ee394f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qmVSLTT5L1xn6C_e13VSRg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">容器结构(作者截图)</p></figure><p id="5cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以<a class="ae ky" href="https://docs.docker.com/engine/reference/commandline/run/" rel="noopener ugc nofollow" target="_blank">启动</a>容器，这里的关键部分是我们需要指定端口5000，因为这是Flask运行的默认端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在容器上启动Flask服务器</p></figure><p id="a01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们转到“localhost:5000”，我们应该会看到与本地相同的Flask应用程序。只是为了验证我们也可以再次进行推理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/83989c673cd8466284e15494f5607ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh3Yp5d1_Pt2IVRk6tYrCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Flask服务器(作者截图)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/45ba819b361f9d15dab8b614891b3f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:388/format:webp/1*U1Ov3tnLiy0VT_kk-o0ZSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推论(作者截图)</p></figure><h2 id="152a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">其他资源和结论</h2><div class="nc nd gp gr ne nf"><a href="https://github.com/RamVegiraju/ML-FlaskApp-Docker" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">GitHub-RamVegiraju/ML-FlaskApp-Docker:托管ML模型的Dockerize Flask应用程序</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">托管您的ML模型的Dockerize Flask应用程序。为RamVegiraju/ML-FlaskApp-Docker开发做出贡献，创建…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><p id="c585" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过上面的链接访问示例的完整代码。我希望通过这篇文章，您对在生产类型环境中部署模型有了更深的理解。关于了解ML模型托管的更多内容，请查看我的<a class="ae ky" rel="noopener" target="_blank" href="/mlflow-model-serving-bcd936d59052"> MLFlow </a>和<a class="ae ky" href="https://ram-vegiraju.medium.com/list/amazon-sagemaker-f1b06f720fba" rel="noopener"> SageMaker </a>系列。如果你有兴趣学习更多关于容器的知识，Stephen Grider在Udemy上有一个很棒的课程，可以帮助你从头开始。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="cf9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ob">如果你喜欢这篇文章，请在</em> <a class="ae ky" href="https://www.linkedin.com/in/ram-vegiraju-81272b162/" rel="noopener ugc nofollow" target="_blank"> <em class="ob"> LinkedIn </em> </a> <em class="ob">上与我联系，并订阅我的媒体</em> <a class="ae ky" href="https://ram-vegiraju.medium.com/subscribe" rel="noopener"> <em class="ob">简讯</em> </a> <em class="ob">。如果你是新手，使用我的</em> <a class="ae ky" href="https://ram-vegiraju.medium.com/membership" rel="noopener"> <em class="ob">会员推荐</em> </a> <em class="ob">报名。</em></p></div></div>    
</body>
</html>