<html>
<head>
<title>K-Fold Cross Validation: Are You Doing It Right?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k 倍交叉验证:你做得对吗？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/k-fold-cross-validation-are-you-doing-it-right-e98cdf3e6690#2022-11-28">https://towardsdatascience.com/k-fold-cross-validation-are-you-doing-it-right-e98cdf3e6690#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c2b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">讨论在数据集上执行 k-fold 交叉验证的适当(和不适当)方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b35dd402ee61ca8196fcf538851bda8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rhG1icQl1jokCHZBsF1JPQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Markus Spiske 拍摄的照片:<a class="ae ky" href="https://www.pexels.com/photo/one-black-chess-piece-separated-from-red-pawn-chess-pieces-1679618/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/one-black-chess-pieces-separated-from-red-pawn-chess-pieces-1679618/</a></p></figure><p id="af6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">k-fold 交叉验证是机器学习应用中一种流行的统计方法。它减轻了过度拟合，并使模型能够更好地利用训练数据进行概括。</p><p id="4e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在实践中，与典型的训练-测试分割相比，该技术可能更难执行。如果使用不当，k 重交叉验证会导致数据泄漏。</p><p id="08c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们回顾了 Python 中 k-fold 交叉验证的不当实现可能导致数据泄漏的方式，以及用户可以做些什么来避免这种结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8d9c" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">k 倍交叉验证审查</h2><p id="818f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">k 倍交叉验证是一种需要将训练数据分成 k 个子集的技术。模型被训练和评估 k 次，每个子集被用作评估模型的验证集一次。</p><p id="530e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果训练数据集被分成 3 部分:</p><ul class=""><li id="af72" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">模型 1 将用折叠 1 和 2 训练，并用折叠 3 评估</li><li id="856b" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">模型 2 将用折叠 1 和 3 训练，并用折叠 2 评估</li><li id="c162" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">模型 3 将用折叠 2 和 3 训练，并用折叠 1 评估</li></ul><p id="b975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使这种采样策略成功工作，模型应该只使用它们应该能够访问的数据进行训练。</p><p id="f854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，用作验证集的折叠不应影响用作训练集的折叠。不遵守这一原则的数据集将容易出现数据泄漏。</p><p id="698a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据泄漏是当用训练数据之外的信息(即，验证和测试数据)训练模型时发生的现象。应该避免数据泄漏，因为它会产生误导性的评估指标，从而导致无法在生产中使用的模型。</p><p id="7f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些不熟悉这个概念的人，可以看看下面的文章:</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/an-introduction-to-data-leakage-f1c58f7c1d64"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">数据泄漏介绍</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">对数据的粗心处理会破坏你的机器学习模型</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><p id="8f72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在执行 k 重交叉验证时，很容易导致数据泄漏，下面将对此进行解释。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7ab8" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">K-fold 交叉验证(错误的方式)</h2><p id="0e0d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">k 倍交叉验证仅在模型仅使用它们应该能够访问的数据进行训练时有效。如果数据在采样前处理不当，则可能违反该规则。</p><p id="c81e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了证明这一点，我们可以使用一个玩具数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ecd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们首先将训练数据标准化，然后将其分成 3 份。很简单，对吧？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e4a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，仅仅这几行代码，我们就犯了一个明显的错误。</p><p id="35e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像标准化这样的转换在确定如何改变每个值时使用整个数据分布。在训练数据被分成 k 个折叠之前执行这样的技术<em class="oi">将意味着训练集将受到验证集的影响，从而导致数据泄露。</em></p><p id="97d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更糟糕的是，代码仍然会成功运行，不会引发任何错误，因此如果用户不注意，他们将会忘记这个问题。</p><p id="4f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当执行包含交叉验证分割策略的超参数调整方法时，例如网格搜索或随机搜索，也会犯类似的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，这里的数据在被分成 k 倍用于超参数调整之前被标准化<em class="oi">，因此训练集被来自验证集的数据无意中转换。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b6db" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">解决方案</h2><p id="0ff1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在进行 k-fold 交叉验证时，有一种避免数据泄漏的简单解决方案，即在将训练数据拆分成 k-fold 的之后进行这样的转换<em class="oi">。</em></p><p id="6480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户可以通过利用 Scikit-Learn 模块的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank">管道</a>轻松实现这一点。</p><p id="6088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通俗地说，管道可以创建将工作流的每一步链接在一起的对象。不熟悉 Scikit-Learn 管道的人可以在此了解更多信息:</p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/why-you-should-use-scikit-learn-pipelines-8754b4d1e375"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">为什么您应该使用 Scikit-Learn 管道</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">这个工具把你的代码带到了一个新的高度</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="oj l oc od oe oa of ks nr"/></div></div></a></div><p id="262a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是这个工具的主要支持者，只要有机会，我就会反复使用它。用户可以将所有的转换器和估算器输入到一个管道对象中，然后对该对象执行 k-fold 交叉验证。</p><p id="d00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将通过确保所有变换将仅在单个折叠上执行而不是在整个训练数据上执行来防止数据泄漏。让我们利用管道来修复之前交叉验证尝试中出现的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="a825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当执行网格搜索时，可以实现相同的方法来避免数据泄漏。不要给<code class="fe ok ol om on b">estimator</code>超参数分配机器学习算法，而是分配管道对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="ad23" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">关键要点</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/ab48d05407767a6615cc7fc3b4b05ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KNnT9A8L93UkGubj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行 k-fold 交叉验证的用户需要警惕数据泄漏，如果无意中使用验证数据来转换训练数据，就会发生数据泄漏。</p><p id="9743" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果用户无情地利用受数据分布影响的变换，如特征缩放和维度缩减，则可能会出现数据泄漏。</p><p id="f691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题可以通过在交叉验证分割之后而不是之前应用转换<em class="oi">来防止。实现这一点最简单的方法是使用 Scikit-Learn 包的管道。</em></p><p id="ac04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我祝你在数据科学的努力中好运！</p></div></div>    
</body>
</html>