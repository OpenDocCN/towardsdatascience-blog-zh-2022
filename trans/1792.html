<html>
<head>
<title>Polymorphism: Understand the Concept Behind Creating Custom Classes like Custom Transformers in Scikit-Learn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多态性:理解在Scikit-Learn中创建自定义类(如自定义转换器)背后的概念</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/polymorphism-understand-the-concept-behind-creating-custom-classes-like-custom-transformers-in-eb9d8b4f5e30#2022-04-26">https://towardsdatascience.com/polymorphism-understand-the-concept-behind-creating-custom-classes-like-custom-transformers-in-eb9d8b4f5e30#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">曾经想知道为什么一些Python类从无到有的地方调用方法吗？还是实现一些方法只是为了过关？</h2></div><p id="1fb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你曾经遇到过Scikit-Learn定制转换器，你很可能对上面的现象很熟悉。如果是这样的话，这篇文章是给你的。我们将深入研究支持这种行为的叫做<em class="lb">多态性</em>的概念，并且我们将构建一些定制类来获得一些实践经验和更深入的理解。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/05f516a5a8425504d34d8e8b8f1b9579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0eLlQG3D_vXxRENF"/></div></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">照片由<a class="ae ls" href="https://unsplash.com/@mcarsience_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Meagan car science</a>在<a class="ae ls" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="438d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scikit-learn transformers是为生产中的数据准备建立管道的一套很棒的工具。虽然内置的转换器列表非常详尽，但是构建您的定制转换器是自动化定制特性转换和实验的一个很好的方式。如果您曾经使用过scikit-learn transformer，您很可能会遇到以下常用模式:</p><pre class="ld le lf lg gt lt lu lv lw aw lx bi"><span id="079e" class="ly lz iq lu b gy ma mb l mc md"># defining a custom transformer<br/>    class CustomTransformer(BaseEstimator, TransformerMixin):<br/>        def fit(self, X, y=None):<br/>            return self  <br/>        def transform(self, X):<br/>            ...... </span><span id="0c73" class="ly lz iq lu b gy me mb l mc md"># calling fit_transform() <br/>  customTransformer = CustomTransformer()<br/>  data = customTransformer.fit_transform(data)</span></pre><p id="a263" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果你来自非编程背景，那么<code class="fe mf mg mh lu b">fit_transform()</code>方法没有在<code class="fe mf mg mh lu b">CustomTransformer</code>类中定义，却可以从该类中调用，这似乎有点令人困惑。此外，如果您已经知道该方法来自上面的某个类，但是想到它如何能够使用没有在它所属的同一个类中定义的方法，您可能会感到困惑。例如，在官方GitHub库<a class="ae ls" href="https://github.com/scikit-learn/scikit-learn/blob/801cca8e73215d4946f05379319d97156be659d6/sklearn/base.py#L531" rel="noopener ugc nofollow" target="_blank">这里</a>中检查<code class="fe mf mg mh lu b">TransformerMixin</code>类的脚本，你不会在<code class="fe mf mg mh lu b">TransformerMixin</code>类中找到任何为<code class="fe mf mg mh lu b">fit()</code>或<code class="fe mf mg mh lu b">transform()</code>定义的方法。</p><p id="0489" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将尝试理解这些概念:多态和鸭类型，这些概念支持这些行为。我们还会做一些动手练习来加深理解。</p><h1 id="1258" class="mi lz iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">什么是多态性？</h1><p id="63a5" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">一般来说，<em class="lb">多态性</em>意味着一个对象采取不同形式的能力。一个具体的例子是，不同类的对象包含相同的方法，但表现出不同的行为。</p><p id="04b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在Python中，我们可以运行类似于<code class="fe mf mg mh lu b">1+2</code>或<code class="fe mf mg mh lu b">'a' + 'b'</code>的操作，并分别得到<code class="fe mf mg mh lu b">3</code>和<code class="fe mf mg mh lu b">ab</code>的结果。Python在幕后调用了一个已经在string和integer类中实现的名为<code class="fe mf mg mh lu b">__add__()</code>的<em class="lb">魔法方法</em>。关于Python如何将这些核心语法转换成特殊方法的详细信息，请查看我上一篇关于Python核心语法的文章。</p><div class="ne nf gp gr ng nh"><a href="https://betterprogramming.pub/python-core-syntax-and-the-magic-behind-them-3c912985b87c" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">Python核心语法及其背后的魔力！</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">您是否曾想过如何在Python中运行像将两个数字或字符串相加(+)这样的操作，并且还能得到…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">better编程. pub</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv lm nh"/></div></div></a></div><p id="f83f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个神奇的方法——<code class="fe mf mg mh lu b">__add__()</code>是多态性的一个例子——它是同一个方法，但是根据调用它的类对象，它调整它的行为，从累加数字到连接字符串。</p><blockquote class="nw nx ny"><p id="4929" class="kf kg lb kh b ki kj jr kk kl km ju kn nz kp kq kr oa kt ku kv ob kx ky kz la ij bi translated"><em class="iq">在Python类上下文中，我们可以通过两种方式实现多态性:继承和Duck类型化。</em></p></blockquote><h1 id="d0f3" class="mi lz iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">遗传多态性</h1><p id="15fc" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated"><em class="lb">继承</em>在面向对象的编程环境中，意味着我们从另一个类继承或接收类属性。我们继承的类叫做<em class="lb">超类</em>，我们继承的属性叫做<em class="lb">子类</em>。因为这篇文章的重点不是继承，我们将跳到一个例子中，希望这个概念在我们进行的过程中有意义。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="4c18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果他们不知道或者你需要快速复习，请随意阅读我以前关于理解继承和子类的文章。</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/object-oriented-programming-in-python-inheritance-and-subclass-9c62ad027278"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">Python中的面向对象编程——继承和子类</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">理解继承的基本概念，并通过创建子类来应用它们。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="oj l ns nt nu nq nv lm nh"/></div></div></a></div></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="6808" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的例子，我们将创建一个名为<code class="fe mf mg mh lu b">InheritList</code>的超类和三个子类:<code class="fe mf mg mh lu b">DefaultList</code>、<code class="fe mf mg mh lu b">EvenList</code>和<code class="fe mf mg mh lu b">OddList</code>来运行继承和多态的例子。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ok ol l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">示例超类01</p></figure><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ok ol l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">示例子类</p></figure><h2 id="5930" class="ly lz iq bd mj om on dn mn oo op dp mr ko oq or mt ks os ot mv kw ou ov mx ow bi translated">遗产</h2><p id="5d8e" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在上面的代码块中，注意我们没有在<code class="fe mf mg mh lu b">DefaultList</code>类中实现任何方法。请注意，在下面的代码块中，我们还可以从该类创建的实例中调用方法(例如<code class="fe mf mg mh lu b">add_value()</code>、<code class="fe mf mg mh lu b">get_list()</code>)。因为<code class="fe mf mg mh lu b">DefaultList</code>子类从它的超类- <code class="fe mf mg mh lu b">InheritList</code>继承了这些方法。这是继承在起作用。nums = [1，2，3，4，5]</p><pre class="ld le lf lg gt lt lu lv lw aw lx bi"><span id="aa53" class="ly lz iq lu b gy ma mb l mc md">defaultNumList = DefaultList()</span><span id="11aa" class="ly lz iq lu b gy me mb l mc md">[defaultNumList.add_value(i) for i in nums]</span><span id="7f68" class="ly lz iq lu b gy me mb l mc md">print(f"List with all added values: {defaultNumList.get_list()}")​</span><span id="3745" class="ly lz iq lu b gy me mb l mc md"># removes the last item from the list</span><span id="022d" class="ly lz iq lu b gy me mb l mc md">defaultNumList.remove_value()</span><span id="7736" class="ly lz iq lu b gy me mb l mc md">print(f"List after removing the last item: {defaultNumList.get_list()}")</span><span id="5fa5" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;List with all added values: [1, 2, 3, 4, 5]<br/>&gt;&gt;List after removing the last item: [1, 2, 3, 4]</span></pre><p id="985e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子展示了基本的继承——我们从超类中获得所有的属性，并按原样使用它们。但是我们可以改变或更新子类中继承的方法，就像我们在其他两个子类中所做的一样— <code class="fe mf mg mh lu b">EvenList</code>和<code class="fe mf mg mh lu b">OddList</code>。</p><h2 id="26ba" class="ly lz iq bd mj om on dn mn oo op dp mr ko oq or mt ks os ot mv kw ou ov mx ow bi translated">方法覆盖</h2><p id="ce57" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在<code class="fe mf mg mh lu b">EvenList</code>和<code class="fe mf mg mh lu b">OddList</code>类中，我们修改了<code class="fe mf mg mh lu b">remove_value()</code>方法，这样<code class="fe mf mg mh lu b">EvenList</code>类将从构建的列表中移除所有奇数值，而<code class="fe mf mg mh lu b">OddList</code>将移除所有偶数值。通过这样做，我们将引入多态性——其中<code class="fe mf mg mh lu b">remove_value()</code>在两种情况下会有不同的表现。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ok ol l"/></div><p class="lo lp gj gh gi lq lr bd b be z dk translated">演示:方法重写</p></figure><pre class="ld le lf lg gt lt lu lv lw aw lx bi"><span id="ecf8" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;evenNumList with all the values: [1, 2, 3, 4, 5]<br/>&gt;&gt;evenNumList after applying remove_value(): [2, 4]<br/><br/>&gt;&gt;oddNumList with all the values: [1, 2, 3, 4, 5]<br/>&gt;&gt;oddNumList after applying remove_value(): [1, 3, 5]</span></pre><h1 id="50ed" class="mi lz iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">鸭分型多态性</h1><p id="db53" class="pw-post-body-paragraph kf kg iq kh b ki mz jr kk kl na ju kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">在详细介绍Duck类型之前，让我们先谈谈在超类<code class="fe mf mg mh lu b">InheritList</code>中实现的另一个方法<code class="fe mf mg mh lu b">do_all()</code>。它接受一个值作为输入，将其添加到列表中，从列表中删除不需要的值，并返回最终的列表。要完成所有这些任务，需要依靠其他内部方法:<code class="fe mf mg mh lu b">add_value()</code>、<code class="fe mf mg mh lu b">remove_value()</code>和<code class="fe mf mg mh lu b">get_list()</code>。看看下面的演示。</p><pre class="ld le lf lg gt lt lu lv lw aw lx bi"><span id="5035" class="ly lz iq lu b gy ma mb l mc md">print(f"evenNumList after calling do_call(58): {evenNumList.do_all(58)}")</span><span id="aafc" class="ly lz iq lu b gy me mb l mc md">print(f"oddNumList after calling do_call(58): {oddNumList.do_all(55)}")</span><span id="25f5" class="ly lz iq lu b gy me mb l mc md">&gt;&gt;evenNumList after calling do_call(58): [2, 4, 58, 58]<br/>&gt;&gt;oddNumList after calling do_call(58): [1, 3, 5, 55, 55]</span></pre><p id="a7cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是Python允许我们更灵活地实现这一点。例如，我们可以从超类中完全移除<code class="fe mf mg mh lu b">remove_value()</code>方法，创建一个单独的只有<code class="fe mf mg mh lu b">combine_all()</code>方法的类，并且仍然能够毫无问题地使用它。全拜鸭子打字所赐！</p><p id="6d3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上，我们不关心依赖属性是否来自同一个类。只要依赖属性可用，我们就很好。这基本上反映了代表鸭子类型的广泛使用的引用:</p><blockquote class="ox"><p id="c97d" class="oy oz iq bd pa pb pc pd pe pf pg la dk translated">“如果它像鸭子一样走路，像鸭子一样游泳，像鸭子一样嘎嘎叫，那么它很可能就是一只鸭子。”</p></blockquote><p id="5e97" class="pw-post-body-paragraph kf kg iq kh b ki ph jr kk kl pi ju kn ko pj kq kr ks pk ku kv kw pl ky kz la ij bi translated">为了演示，让我们创建一个名为<code class="fe mf mg mh lu b">ComboFunc</code>的新类，它只有一个方法<code class="fe mf mg mh lu b">combine_all()</code>，这个方法将执行与<code class="fe mf mg mh lu b">do_all()</code>方法相同的功能。同样，让我们创建一个新的子类，它将拥有一个先前创建的子类— <code class="fe mf mg mh lu b">EvenList</code>和这个新类作为超类。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="8985" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们没有在这两个类中定义任何依赖方法(<code class="fe mf mg mh lu b">add_value()</code>、<code class="fe mf mg mh lu b">remove_value()</code>和<code class="fe mf mg mh lu b">get_list()</code>)。然而，我们将能够成功地从<code class="fe mf mg mh lu b">GenDuckList</code>类的实例中调用<code class="fe mf mg mh lu b">combine_all()</code>方法。因为依赖方法将从<code class="fe mf mg mh lu b">EvenList</code>类继承而来，而<code class="fe mf mg mh lu b">combine_all()</code>方法并不关心它们来自哪里，只要它们存在。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ok ol l"/></div></figure><pre class="ld le lf lg gt lt lu lv lw aw lx bi"><span id="6476" class="ly lz iq lu b gy ma mb l mc md">&gt;&gt;Initial list: [1, 2, 3, 4, 5]<br/>&gt;&gt;Final list: [2, 4, 40]</span></pre><p id="e724" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们也可以通过其他方式完成上述任务，</p><ol class=""><li id="8eac" class="pm pn iq kh b ki kj kl km ko po ks pp kw pq la pr ps pt pu bi translated">如果我们需要定制的东西，我们也可以完全避免从<code class="fe mf mg mh lu b">EvenList</code>类继承任何东西，并在类内部实现依赖方法。或者，</li><li id="d3ed" class="pm pn iq kh b ki pv kl pw ko px ks py kw pz la pr ps pt pu bi translated">我们可以把它作为一个超类，但覆盖任何特定的依赖方法，使它更加定制化。总的来说，多态性让我们变得更加灵活，可以轻松地重用已经实现的方法。或者，</li><li id="2622" class="pm pn iq kh b ki pv kl pw ko px ks py kw pz la pr ps pt pu bi translated">我们可以从超类中移除<code class="fe mf mg mh lu b">remove_value()</code>并在我们的<code class="fe mf mg mh lu b">GenDuckList</code>类中实现它，但仍然能够执行相同的任务。</li></ol><p id="e1b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，为了完成这个循环，当我们使用<code class="fe mf mg mh lu b">BaseEstimator</code>和<code class="fe mf mg mh lu b">TransformerMixin</code>类作为超类在scikit-learn中构建自定义转换器时，我们基本上应用<em class="lb"> duck typing </em>来实现<em class="lb">多态</em>。与之相关的是，您可以将<code class="fe mf mg mh lu b">GenDuckList</code>视为一个虚拟的定制transformer类，<code class="fe mf mg mh lu b">ComboFunc</code>视为一个虚拟的<code class="fe mf mg mh lu b">TransformerMixin</code>类，<code class="fe mf mg mh lu b">EvenList</code>视为一个虚拟的<code class="fe mf mg mh lu b">BaseEstimator</code>类。上面的duck类型化示例和开始的transformer示例之间的实现级别差异是，我们从一个超类继承了<code class="fe mf mg mh lu b">remove_value()</code>方法，而在custom transformer中，我们在custom类中定义它——上面提到的第三种替代方式。</p></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><p id="2533" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您阅读这篇文章。希望它能帮助您理解Python类上下文中多态性的概念。如果你喜欢这篇文章，请考虑关注我的个人资料，以获得关于我未来文章的通知。</p><div class="ne nf gp gr ng nh"><a href="https://levelup.gitconnected.com/use-modules-to-better-organize-your-python-code-75690ba6b6e" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">使用模块更好地组织您的Python代码</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">了解Python模块以及如何使用它们来更好地组织您不断增长的代码库。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nq l"><div class="qa l ns nt nu nq nv lm nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://levelup.gitconnected.com/use-modules-to-better-organize-your-python-code-75690ba6b6e" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">使用模块更好地组织您的Python代码</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">了解Python模块以及如何使用它们来更好地组织您不断增长的代码库。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nq l"><div class="qa l ns nt nu nq nv lm nh"/></div></div></a></div></div></div>    
</body>
</html>