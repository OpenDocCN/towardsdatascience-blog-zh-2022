<html>
<head>
<title>How to Plot a Route on a Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在地图上绘制路线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-plot-a-route-on-a-map-fb900a7f6605#2022-09-08">https://towardsdatascience.com/how-to-plot-a-route-on-a-map-fb900a7f6605#2022-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/711c011e4260c17a9140d15f86d44b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNbCllyMLyiVyGfY-HXHjw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">巴黎城市漫步。图片作者。</p></figure><div class=""/><div class=""><h2 id="c30c" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated"><strong class="ak">python中带有代码示例的教程。</strong></h2></div><p id="9e08" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于某些项目来说，在地图上绘制路线可能会很有用。在这里你可以找到你需要的所有信息:包、API和代码示例。最终，您可以创建漂亮的交互式地图。</p><h1 id="5ec8" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">安装和准备工作</h1><p id="aaad" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">我们将使用<a class="ae mn" href="https://geopy.readthedocs.io/en/stable/#" rel="noopener ugc nofollow" target="_blank"> geopy </a>和<a class="ae mn" href="https://python-visualization.github.io/folium/" rel="noopener ugc nofollow" target="_blank">folio</a>，这两个包都是为使用python处理地理空间数据而设计的。首先，使用conda或pip安装软件包:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3def" class="mx lr jf mt b gy my mz l na nb"># conda<br/>conda install -c conda-forge folium<br/>conda install -c conda-forge geopy</span><span id="524a" class="mx lr jf mt b gy nc mz l na nb"># pip<br/>pip install folium<br/>pip install geopy</span></pre><p id="3d9b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">除了这些包之外，您还需要能够调用一个API来给出多行线段的路径坐标。做这件事的API是<a class="ae mn" href="https://rapidapi.com/geoapify-gmbh-geoapify/api/route-and-directions/" rel="noopener ugc nofollow" target="_blank">路线和方向API </a>。您可以在RapidAPI上创建一个帐户，并订阅路线和方向API。RapidAPI免费计划包括每月30 000次免费通话，这是一个不错的开始。还有其他(更商业化的)选项可用，如<a class="ae mn" href="https://developers.arcgis.com/" rel="noopener ugc nofollow" target="_blank"> ArcGIS </a>或<a class="ae mn" href="https://developers.google.com/maps/documentation/directions" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>方向，所以选择适合你的情况。</p><h1 id="557c" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">检索两点之间的路线数据</h1><p id="394c" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">本节末尾的代码使用了我前面提到的<a class="ae mn" href="https://rapidapi.com/geoapify-gmbh-geoapify/api/route-and-directions/" rel="noopener ugc nofollow" target="_blank">路线和方向API </a>。获得两点之间的方向真的很容易:您需要指定两点的纬度和经度。如果您的数据集包含没有经纬度值的地址，不要担心，转换它们很容易。这个过程称为<em class="nd">地理编码</em>。使用geopy，其工作方式如下:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f567" class="mx lr jf mt b gy my mz l na nb">from geopy.geocoders import Nominatim</span><span id="f67d" class="mx lr jf mt b gy nc mz l na nb">def get_lat_long_from_address(address):<br/>   locator = Nominatim(user_agent='myGeocoder')<br/>   location = locator.geocode(address)<br/>   return location.latitude, location.longitude</span><span id="bd41" class="mx lr jf mt b gy nc mz l na nb"># example<br/>address = 'Zeeweg 94, 2051 EC Overveen'<br/>get_lat_long_from_address(address)<br/>&gt;&gt;&gt; (52.4013046, 4.5425025)</span></pre><p id="bf1c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在路线和方向API中，您还可以指定想要使用的交通方式:驾车、卡车、自行车、步行或公交。</p><p id="d4b3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">要调用API，您需要一个API键。订阅后，您可以在这里找到它:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/161aa7ed80f51fa252e6cdadb7b83dc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Ft9Jly6Akals8xAHjWfwg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">快速API键，见黄色箭头。图片作者。</p></figure><p id="644e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">调用API获取从第一个地址到第二个地址的方向:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5abc" class="mx lr jf mt b gy my mz l na nb">import requests</span><span id="ac67" class="mx lr jf mt b gy nc mz l na nb">def get_directions_response(lat1, long1, lat2, long2, mode='drive'):<br/>   url = "https://route-and-directions.p.rapidapi.com/v1/routing"<br/>   key = "<strong class="mt jg">YOUR-API-KEY</strong>"<br/>   host = "route-and-directions.p.rapidapi.com"<br/>   headers = {"X-RapidAPI-Key": key, "X-RapidAPI-Host": host}<br/>   querystring = {"waypoints":f"{str(lat1)},{str(long1)}|{str(lat2)},{str(long2)}","mode":mode}<br/>   response = requests.request("GET", url, headers=headers, params=querystring)<br/>   return response</span><span id="1d82" class="mx lr jf mt b gy nc mz l na nb">response = get_directions_response(52.4013, 4.5425, 52.402, 4.5426)</span></pre><p id="8785" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe nf ng nh mt b">response</code>变量是这样的(点击放大):</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/9ee20f76445ab2afca9cb0e8a4bbafc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMtX9FJyC-lFKcbHOjL4Mw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">API的回应，点击放大。图片作者。</p></figure><p id="afa5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">对于我们的路线绘图，我们需要<em class="nd">几何图形</em>:它包含了我们必须在其间画线的所有坐标，这将在地图上创建路线。</p><p id="1a38" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">请注意，响应还包含驾驶员指示，如:<em class="nd">‘进入环形交叉路口，从第二个出口进入zee weg/N200。’很酷，不是吗？您可以将它们用于导航目的。</em></p><p id="ca70" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们可以用数据来可视化路线了！</p><h1 id="bef7" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">使用leav创建路线图</h1><p id="8b83" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">下面的函数使用两点之间的路径创建地图。输入是我们从对路线和方向API的API调用中收到的响应。我们从响应中提取坐标。然后我们添加标记(起点和终点)并用<code class="fe nf ng nh mt b">PolyLine</code>画线。该脚本的一个重要部分创建了最佳缩放，这确保了您的路线将始终在地图的中心。为此，我们使用最小和最大纬度和经度值以及<code class="fe nf ng nh mt b">fit_bounds</code>。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4da4" class="mx lr jf mt b gy my mz l na nb">import folium</span><span id="6c39" class="mx lr jf mt b gy nc mz l na nb">def create_map(response):<br/>   # use the response<br/>   mls = response.json()['features'][0]['geometry']['coordinates']<br/>   points = [(i[1], i[0]) for i in mls[0]]</span><span id="4010" class="mx lr jf mt b gy nc mz l na nb">   m = folium.Map()</span><span id="3617" class="mx lr jf mt b gy nc mz l na nb">   # add marker for the start and ending points<br/>   for point in [points[0], points[-1]]:<br/>      folium.Marker(point).add_to(m)</span><span id="57c1" class="mx lr jf mt b gy nc mz l na nb">   # add the lines<br/>   folium.PolyLine(points, weight=5, opacity=1).add_to(m)</span><span id="43ae" class="mx lr jf mt b gy nc mz l na nb">   # create optimal zoom<br/>   df = pd.DataFrame(mls[0]).rename(columns={0:'Lon', 1:'Lat'})[['Lat', 'Lon']]<br/>   sw = df[['Lat', 'Lon']].min().values.tolist()<br/>   ne = df[['Lat', 'Lon']].max().values.tolist()<br/>   m.fit_bounds([sw, ne])<br/>   return m</span><span id="9897" class="mx lr jf mt b gy nc mz l na nb">m = create_map(response)</span></pre><p id="1e67" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果你在笔记本上工作，你可以打电话给<code class="fe nf ng nh mt b">m</code>，你会看到:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nj"><img src="../Images/a9d60d7339cf7cfbd8f29259509cc188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRSahSJ9nMenOyOoXVbqBg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">第一条路线绘制在一张漂亮的交互式图表上！图片作者。</p></figure><p id="90f3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">漂亮！另一种方法是将图像保存为html格式，并在浏览器中打开:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a9d6" class="mx lr jf mt b gy my mz l na nb">m.save(<!-- -->'./route_map.html')</span></pre><h1 id="0de5" class="lq lr jf bd ls lt lu lv lw lx ly lz ma kl mb km mc ko md kp me kr mf ks mg mh bi translated">添加地址</h1><p id="f2a7" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">功能的改进可以是添加更多的地址。让我们沿着巴黎的亮点创建一个城市漫步。</p><p id="0b99" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先我们指定我们的地址:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b495" class="mx lr jf mt b gy my mz l na nb"># touristic route through Paris (Eiffel Tower, Arc de Triomphe, ...)<br/>address1 = '5 Avenue Anatole France, 75007 Paris, France'<br/>address2 = 'Place Charles de Gaulle, 75008 Paris, France'<br/>address3 = '60 Avenue des Champs-Élysées, 75008 Paris, France'<br/>address4 = "Place de l'Opéra, 75009 Paris, France"        <br/>address5 = 'Rue de Rivoli, 75001 Paris, France'<br/>address6 = '10 Bd du Palais, 75001 Paris, France'<br/>address7 = '3 Rue Guynemer, 75006 Paris, France'<br/>address8 = '33 Avenue du Maine, 75015 Paris, France' </span><span id="5f26" class="mx lr jf mt b gy nc mz l na nb">addresses = [address1, address2, address3, address4, address5, address6, address7, address8]</span></pre><p id="79b4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们需要坐标，而不是地址，所以我们使用之前创建的<code class="fe nf ng nh mt b">get_lat_long_from_address</code>函数创建一个包含纬度和经度的列表:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="200a" class="mx lr jf mt b gy my mz l na nb">lat_lons = [get_lat_long_from_address(addr) for addr in addresses]</span></pre><p id="64a9" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然后，我们用<code class="fe nf ng nh mt b">get_directions_response</code>函数调用API来获取点之间的方向:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="52be" class="mx lr jf mt b gy my mz l na nb">responses = []</span><span id="19bb" class="mx lr jf mt b gy nc mz l na nb">for n in range(len(lat_lons)-1):<br/>   lat1, lon1, lat2, lon2 = lat_lons[n][0], lat_lons[n][1], lat_lons[n+1][0], lat_lons[n+1][1]<br/>   response = get_directions_response(lat1, lon1, lat2, lon2, mode='walk')<br/>   responses.append(response)</span></pre><p id="fa67" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在我们更改<code class="fe nf ng nh mt b">create_map</code>函数来处理多个响应:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4fbb" class="mx lr jf mt b gy my mz l na nb">def create_map(responses, lat_lons):<br/>   m = folium.Map()<br/>   df = pd.DataFrame()</span><span id="7aa7" class="mx lr jf mt b gy nc mz l na nb">   # add markers for the places we visit<br/>   for point in lat_lons:<br/>      folium.Marker(point).add_to(m)</span><span id="0264" class="mx lr jf mt b gy nc mz l na nb">   # loop over the responses and plot the lines of the route<br/>   for response in responses:<br/>      mls = response.json()['features'][0]['geometry']['coordinates']<br/>      points = [(i[1], i[0]) for i in mls[0]]<br/>      <br/>      # add the lines<br/>      folium.PolyLine(points, weight=5, opacity=1).add_to(m)</span><span id="b3da" class="mx lr jf mt b gy nc mz l na nb">      temp = pd.DataFrame(mls[0]).rename(columns={0:'Lon', 1:'Lat'})[['Lat', 'Lon']]<br/>      df = pd.concat([df, temp])</span><span id="b2e6" class="mx lr jf mt b gy nc mz l na nb">   # create optimal zoom<br/>   sw = df[['Lat', 'Lon']].min().values.tolist()<br/>   sw = [sw[0]-0.0005, sw[1]-0.0005]<br/>   ne = df[['Lat', 'Lon']].max().values.tolist()<br/>   ne = [ne[0]+0.0005, ne[1]+0.0005]<br/>   m.fit_bounds([sw, ne])<br/>   return m</span><span id="6af7" class="mx lr jf mt b gy nc mz l na nb">m = create_map(responses, lat_lons)</span></pre><p id="fb16" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe nf ng nh mt b">m</code>看起来是这样的:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nk"><img src="../Images/83541feaf9e6248f72bbc2b9f2703676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYrUKKLlYumL2O5ZMuBOqA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">游览巴黎。点击放大。图片作者。</p></figure><p id="ea26" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里一个有趣的附加功能是通过优化计算所有地址之间的最短或最快路线。以下文章中的更多信息(示例2):</p><div class="ip iq gp gr ir nl"><a rel="noopener follow" target="_blank" href="/how-to-handle-optimization-problems-daf97b3c248c"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd jg gy z fp nq fr fs nr fu fw je bi translated">如何处理优化问题？</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">带有解决方案和代码的简单示例。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">towardsdatascience.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ix nl"/></div></div></a></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h1 id="2c0d" class="lq lr jf bd ls lt oh lv lw lx oi lz ma kl oj km mc ko ok kp me kr ol ks mg mh bi translated">结论</h1><p id="65b0" class="pw-post-body-paragraph ku kv jf kw b kx mi kg kz la mj kj lc ld mk lf lg lh ml lj lk ll mm ln lo lp ij bi translated">在这篇文章中，您学习了使用follow、geopy和route and directions API在交互式地图上创建路线。你可以以多种不同的方式使用地图，比如在flask应用程序中使用<a class="ae mn" href="http://python-visualization.github.io/folium/flask.html" rel="noopener ugc nofollow" target="_blank">或者与plotly结合使用</a><a class="ae mn" rel="noopener" target="_blank" href="/how-to-embed-interactive-plotly-visualizations-in-folium-map-pop-ups-c69c818a8cd9">来进行很酷的交互</a>。您也可以决定将地图保存为代码为<code class="fe nf ng nh mt b">m.save('./route_map.html')</code>的html文件。这使得嵌入文件成为可能:<code class="fe nf ng nh mt b">&lt;iframe src="route_map.html" height=”500" width="500"&gt;&lt;/iframe&gt;</code></p><p id="372f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">感谢阅读！</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="4255" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><em class="nd">别忘了</em> <a class="ae mn" href="https://hennie-de-harder.medium.com/subscribe" rel="noopener"> <em class="nd">订阅</em> </a> <em class="nd">如果你想在我发表新文章时收到电子邮件。</em></p></div></div>    
</body>
</html>