<html>
<head>
<title>Simulation with SimPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SimPy模拟</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/simulation-with-simpy-287cbdf5d78e#2022-06-21">https://towardsdatascience.com/simulation-with-simpy-287cbdf5d78e#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2378" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">第7部分:非终止模拟</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f381bd353cb0938d9ece02baca3ab56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hJ5FXCjcV6KdxWrl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jcgellidon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JC Gellidon </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="de9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列的第四篇文章中，我们区分了关于输出数据分析的两种类型的模拟:[1]终止模拟；[2]非终止模拟。</p><p id="04f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">终止模拟</strong>是指运行一段时间，直到某个<strong class="lb iu">预定义事件</strong>标志着运行结束。该事件被称为“终端事件”，它必须在运行前指定，其发生时间可能是一个随机变量。模型的初始条件必须在运行前完全建立，因为我们关心的是被研究系统的<strong class="lb iu">短期动态行为</strong>。</p><p id="4d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<strong class="lb iu">非终止模拟</strong>是一种我们关心被研究系统的<strong class="lb iu">稳态性能的模拟。</strong>模型运行了很长一段时间:没有预定义的终端事件来指定每次运行的长度。当然，我们必须在某个时间点停止运行。建立停止点有不同的技术，我们将在本文中讨论其中的一种。</p><p id="a1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非终止模拟与终止模拟有几个概念上的不同:</p><p id="b137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)模型的<strong class="lb iu">初始条件不需要完全建立</strong>，因为它们的影响随着运行的长度而显著降低。</p><p id="3f9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)最初，有一个<strong class="lb iu">瞬态</strong>，在此状态下，性能指标在稳定之前会大幅波动。通常的程序是从瞬态中移除数据，以便它们不会对系统的稳态性能产生任何影响。</p><p id="40a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)不可避免地，在非常长的运行中，出现<strong class="lb iu">自相关</strong>现象，因此在计算模型的稳态参数时出现<strong class="lb iu">偏差</strong>。</p><p id="76f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经开发了几种方法和程序来确保非终止模拟的输出数据真正代表所研究系统的真实稳态行为。也许最著名的是分批平均法。</p><h1 id="a8f8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">批量方法指</strong></h1><p id="8d76" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们记住(<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8e7187c6eb82"> article 4 </a>)在终止模拟中，我们执行<em class="ms"> n </em>个独立复制。每次运行的独立性通过在每次运行中使用不同的随机数流来实现。每次复制都以相同的初始条件开始。最后，我们计算每个性能指标的点估计和置信区间。</p><p id="25a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，我们在一个非终止的模拟中进行一个单独的长期运行。</p><p id="010a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非终止模拟的批量平均方法<strong class="lb iu">由以下步骤组成:</strong></p><p id="eb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)做一次非常非常长的跑步。通过消除初始瞬态的所有数据来消除瞬态效应。这被称为<strong class="lb iu">预热阶段</strong>。它的长度通常是通过初步的试运行来确定的。</p><p id="a19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)剩余长度(有效行程)被分成等长的<em class="ms"> n </em>个区间，称为<strong class="lb iu">批次</strong>。</p><p id="0e99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3) <strong class="lb iu">每批被认为是一个独立的复制</strong>。因此，我们可以通过将每批视为一个独立的复制来计算样本均值、样本方差和置信区间及其相应的置信水平(平均性能指标)。</p><p id="3626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的程序，尽管有不同的方法涉及<strong class="lb iu"/><strong class="lb iu">批次数量和每批的长度。</strong>一些作者认为至少应该有20至30个批次，而其他作者认为由于自相关问题，不应超过20个批次。一般认为，批次应等于或长于预热时间，以确保在一定程度上接近独立重复的条件。</p><h1 id="6a97" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">用SimPy模拟急诊室</strong></h1><p id="b08d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">急诊室是医院或医疗机构中的一个部门，当病人病危或受伤并需要尽快治疗时，他们会去那里。</p><p id="d09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">急诊室的操作方面通常被分析为<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-322606d4ba0c"> <strong class="lb iu">排队系统</strong> ( </a>等候线系统)，其中患者随机到达，并排队等候(或不排队)，直到他们被初步筛选以确定他们的严重程度。这些患者中有一定比例的人需要住院治疗，另一个比例的人需要门诊治疗，其余的人不需要额外治疗，并在确认他们的病情不需要任何治疗后离开系统。</p><p id="cc6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<strong class="lb iu"> SimPy </strong>来模拟在一个虚构的急诊室中对人员分配的可能修改，该急诊室包括一个入院区，以及分配给以下三个区域的医生:医院护理；门诊护理；不在乎。</p><p id="53a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们导入了SimPy，Pandas作为<em class="ms"> pd，</em> Numpy作为<em class="ms"> np </em>，以及<em class="ms"> scipy.stats </em>模块，该模块包含了再现服从均匀分布和<strong class="lb iu">截尾正态分布</strong>的随机数序列的方法。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="5fca" class="my lw it mu b gy mz na l nb nc">@author: darwt<br/>"""</span><span id="5e5b" class="my lw it mu b gy nd na l nb nc">## Emergency Room Simulation Model<br/>## Non Terminating Simulation<br/>## Batch Means Technique</span><span id="523d" class="my lw it mu b gy nd na l nb nc"># Import Modules</span><span id="c963" class="my lw it mu b gy nd na l nb nc">import pandas as pd<br/>import numpy  as np<br/>from numpy.random import RandomState</span><span id="ab86" class="my lw it mu b gy nd na l nb nc">import simpy</span><span id="3a6a" class="my lw it mu b gy nd na l nb nc">from scipy import stats<br/>from scipy.stats import uniform<br/>from scipy.stats import truncnorm</span></pre><p id="1abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们包含了一个初始化模块来指示代表患者到达率的泊松分布的参数值。我们还显示了住院服务台的数量和医院护理、门诊护理和非护理级别的医生数量。我们认为住院、住院和流动区域的住院时间遵循正态分布，其平均值和标准偏差值在模块中显示。不关心水平遵循均匀分布，因此我们指出了它的最小值和最大值。我们还初始化了模拟运行的长度，以及用于存储中间结果的列表。第3条中所示的类似逻辑用于将患者分为三个护理级别。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="47c3" class="my lw it mu b gy mz na l nb nc"># initialization module<br/># Unit of time = hours</span><span id="54fb" class="my lw it mu b gy nd na l nb nc">PATIENT_ARRIVAL_RATE  = 1.2</span><span id="abc0" class="my lw it mu b gy nd na l nb nc">NUMBER_ADMISSIONS_DESKS = 2</span><span id="3e9b" class="my lw it mu b gy nd na l nb nc">ADMISSION_MEAN = 0.3<br/>ADMISSION_STD  = 0.15</span><span id="a4c7" class="my lw it mu b gy nd na l nb nc">HOSPITAL_MEAN = 25<br/>HOSPITAL_STD  = 1.5</span><span id="05c8" class="my lw it mu b gy nd na l nb nc">AMBULATORY_MEAN = 6<br/>AMBULATORY_STD  = 1</span><span id="dba2" class="my lw it mu b gy nd na l nb nc">NO_CARE_INF = 0.5<br/>NO_CARE_SUP = 1.0</span><span id="f67f" class="my lw it mu b gy nd na l nb nc">NUMBER_DOCS_HOSPITAL= 1<br/>NUMBER_DOCS_AMBULAT = 5<br/>NUMBER_DOCS_NO_CARE = 1</span><span id="d363" class="my lw it mu b gy nd na l nb nc"># discrete probabilities for three care levels<br/>prob1, prob2, prob3 = 0.3, 0.6, 0.1</span><span id="cdd4" class="my lw it mu b gy nd na l nb nc">prob1 = round(prob1, 2)<br/>prob2 = round(prob1 + prob2,2)<br/>prob3 = round(prob2 + prob3,2)<br/>list_of_probs = [prob1, prob2, prob3]</span><span id="ff5e" class="my lw it mu b gy nd na l nb nc">patient_arrival, arrival = [], []<br/>patient_admission, patient_hospital_care = [], []<br/>patient_ambulatory_care, patient_no_care = [], []<br/>time_in_admission,       delay_in_admission = [], []<br/>time_in_hospital_care,   delay_in_hospital_care   = [], []<br/>time_in_ambulatory_care, delay_in_ambulatory_care = [], []<br/>time_in_no_care,         delay_in_no_care         = [], []</span><span id="ddbe" class="my lw it mu b gy nd na l nb nc">SIM_TIME = 3000</span></pre><p id="949a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8d744c82dc80">生成器功能</a>和<em class="ms">生成患者来模拟患者的到达。</em>我们计算住院和三级护理的住院时间。<em class="ms"> yield env.timeout() </em>是一种离散事件，在经过一定的模拟时间后触发。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="043a" class="my lw it mu b gy mz na l nb nc">def generate_patient(env, patient_arrival_rate,inital_delay = 0,                 <br/>              stoptime = simpy.core.Infinity,prng = RandomState(0)):</span><span id="efbc" class="my lw it mu b gy nd na l nb nc">    number_of_patients = 0<br/>    yield env.timeout(inital_delay)     # Initial delay </span><span id="0d41" class="my lw it mu b gy nd na l nb nc">    while (env.now &lt;stoptime):  <br/>       inter_arrival_time=prng.exponential(1.0/patient_arrival_rate)</span><span id="682c" class="my lw it mu b gy nd na l nb nc">       left, right = 0, np.inf <br/>       loc1, scale1  = ADMISSION_MEAN, ADMISSION_STD<br/>       loc2, scale2  = HOSPITAL_MEAN,  HOSPITAL_STD<br/>       loc3, scale3  = AMBULATORY_MEAN,AMBULATORY_STD</span><span id="fcfd" class="my lw it mu b gy nd na l nb nc">       a1 = (left -  loc1)/scale1<br/>       b1 = (right - loc1)/scale1<br/>       a2 = (left -  loc2)/scale2<br/>       b2 = (right - loc2)/scale2<br/>       a3 = (left -  loc3)/scale3<br/>       b3 = (right - loc3)/scale3   </span><span id="2ce3" class="my lw it mu b gy nd na l nb nc">       los_admis = truncnorm.rvs(a1,b1,loc1, scale1 ,size=1)<br/>       los_hosp  = truncnorm.rvs(a2,b2,loc2, scale2 ,size=1)<br/>       los_ambu  = truncnorm.rvs(a3,b3,loc3, scale3 ,size=1)<br/>       los_exit  = uniform.rvs(loc = NO_CARE_INF, <br/>                               scale = NO_CARE_SUP + 1,size=1)</span><span id="e4ac" class="my lw it mu b gy nd na l nb nc">       number_of_patients += 1<br/>       pat_str = patient_stream(env, 'Patient number: {}'.format(number_of_patients),<br/>              los_admis, los_hosp,los_ambu, los_exit)</span><span id="d60e" class="my lw it mu b gy nd na l nb nc">       env.process(pat_str)<br/>       yield env.timeout(inter_arrival_time)</span></pre><p id="2e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Simpy在仿真建模中使用<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-b04c2ddf1900"> <strong class="lb iu">流程交互方法</strong> </a>。<em class="ms"> patient_stream </em>生成器函数描述了单个患者在整个系统中的流动，代码模拟了这些患者在急诊室模型中的路线中的体验。方法<em class="ms"> request() </em>生成一个事件，该事件在资源再次可用时被触发(<em class="ms"> yield req </em>)。进程<em class="ms">请求</em>那些资源成为用户，并且一旦完成就必须<em class="ms">释放</em>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="09cf" class="my lw it mu b gy mz na l nb nc">def patient_stream(env, patient_number, los_admis, <br/>                   los_hosp, los_ambu, los_exit):</span><span id="952e" class="my lw it mu b gy nd na l nb nc">    #  Admission<br/>    print("%3s is arriving for admission at %.2f" %(patient_number, env.now))<br/>    patient_arrival.append(patient_number)<br/>    arrival_time = env.now<br/>    arrival.append(arrival_time)</span><span id="d32f" class="my lw it mu b gy nd na l nb nc">    adm_request_desk = admission_desks.request()<br/>    yield adm_request_desk<br/>    print("%3s admitted to admission at %.2f" %(patient_number, env.now))<br/>    time_in_admission.append(env.now)</span><span id="e3f8" class="my lw it mu b gy nd na l nb nc">    if (env.now &gt; arrival_time):<br/>        delay_in_admission.append(env.now - arrival_time)<br/>        patient_admission.append(patient_number)<br/>        print("%3s has to wait %.2f' for admission" %(patient_number, env.now - arrival_time))</span><span id="0661" class="my lw it mu b gy nd na l nb nc">    yield env.timeout(los_admis)<br/>    print('%3s stays at admission %.2f' % (patient_number,los_admis))</span><span id="6ca0" class="my lw it mu b gy nd na l nb nc">    admission_desks.release(adm_request_desk)</span><span id="ff53" class="my lw it mu b gy nd na l nb nc">    # uniform distribution for level assigments<br/>    r_v = uniform.rvs(size=1)<br/>    if r_v &lt; prob1:<br/>       stream = 1<br/>    elif r_v &lt; prob2:<br/>       stream = 2<br/>    else:<br/>       stream = 3</span><span id="336a" class="my lw it mu b gy nd na l nb nc">   if stream == 1:<br/>       #  Hospital Care<br/>       print('%3s is arriving for hospital care at %.2f' % (patient_number,env.now))</span><span id="c36f" class="my lw it mu b gy nd na l nb nc">       arrival_time = env.now<br/>       time_in_hospital_care.append(arrival_time)</span><span id="6eac" class="my lw it mu b gy nd na l nb nc">       hospital_care_request = hospital_care.request()<br/>       yield hospital_care_request<br/>       print('%3s is admitted to hospital care at %.2f' % (patient_number,env.now))</span><span id="fce9" class="my lw it mu b gy nd na l nb nc">       if (env.now &gt; arrival_time):<br/>          delay_in_hospital_care.append(env.now - arrival_time)<br/>          patient_hospital_care.append(patient_number)<br/>          print('%3s has to wait for hospital care for %.2f'<br/>                 %(patient_number, env.now - arrival_time)) <br/> <br/>       yield env.timeout(los_hosp)<br/>       print('%3s stays at hospital care at %.2f' % (patient_number,los_hosp))</span><span id="3374" class="my lw it mu b gy nd na l nb nc">       hospital_care.release(hospital_care_request)</span><span id="73ac" class="my lw it mu b gy nd na l nb nc">   elif stream == 2:<br/>       #  ambulatory care<br/>       print('%3s is arriving for ambultory care at %.2f' % (patient_number,env.now))</span><span id="b12a" class="my lw it mu b gy nd na l nb nc">       arrival_time = env.now<br/>       time_in_ambulatory_care.append(arrival_time)</span><span id="5f8d" class="my lw it mu b gy nd na l nb nc">       ambulatory_care_request = ambulatory_care.request()<br/>       yield ambulatory_care_request<br/>       print('%3s is admitted to ambulatory care at %.2f' % (patient_number,env.now))</span><span id="6219" class="my lw it mu b gy nd na l nb nc">       if (env.now &gt; arrival_time):<br/>          delay_in_ambulatory_care.append(env.now - arrival_time)<br/>          patient_ambulatory_care.append(patient_number)<br/>          print('%3s has to wait for ambulatory care for %.2f' %<br/>                 (patient_number, env.now - arrival_time))</span><span id="b01b" class="my lw it mu b gy nd na l nb nc">       yield env.timeout(los_ambu)<br/>       print('%3s stays at ambulatory care at %.2f' % (patient_number,los_ambu))</span><span id="bf4c" class="my lw it mu b gy nd na l nb nc">       ambulatory_care.release(ambulatory_care_request)</span><span id="f2ab" class="my lw it mu b gy nd na l nb nc">elif stream == 3:<br/>       #  no care<br/>       print('%3s is arriving for no care at %.2f' % (patient_number,env.now))</span><span id="f21b" class="my lw it mu b gy nd na l nb nc">       arrival_time = env.now<br/>       time_in_no_care.append(arrival_time)</span><span id="4018" class="my lw it mu b gy nd na l nb nc">       no_care_request = no_care_level.request()<br/>       yield no_care_request<br/>       print('%3s is admitted to no care at %.2f' % (patient_number,env.now))</span><span id="da44" class="my lw it mu b gy nd na l nb nc">       if (env.now &gt; arrival_time):<br/>          delay_in_no_care.append(env.now - arrival_time)<br/>          patient_no_care.append(patient_number)<br/>          print('%3s has to wait for no care for %.2f' % <br/>                (patient_number, env.now - arrival_time))</span><span id="8920" class="my lw it mu b gy nd na l nb nc">       yield env.timeout(los_exit)<br/>       print('%3s stays at no care at %.2f' % (patient_number,los_exit))</span><span id="d3de" class="my lw it mu b gy nd na l nb nc">       no_care_level.release(no_care_request)</span></pre><p id="fd36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写了函数<em class="ms"> calc_batches() </em>，用于计算门诊护理级别的平均排队延迟的置信区间(置信水平为0.90)。我们在每批中使用了12批相同数量的记录。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0d02" class="my lw it mu b gy mz na l nb nc">def calc_batches():<br/>    ## delay in ambulatory care</span><span id="8f84" class="my lw it mu b gy nd na l nb nc">    global inf, sup, delay_in_ambulatory_care<br/>    number_batchs = 13        ## selected by the analyst<br/>    number_recs    = len(delay_in_ambulatory_care)<br/>    recs_per_batch = int(number_recs/number_batchs)</span><span id="942c" class="my lw it mu b gy nd na l nb nc">    # to guarantee equal number of records in each batch<br/>    matrix_dim = number_batchs*recs_per_batch<br/>    rows_to_eliminate = number_recs - matrix_dim   <br/>    delay _in_ambulatory_care = <br/>                    delay_in_ambulatory_care[rows_to_eliminate:]</span><span id="66eb" class="my lw it mu b gy nd na l nb nc">    # eliminating transient effects (warm-up period)<br/>    delay_in_ambulatory_care =  <br/>                    delay_in_ambulatory_care[recs_per_batch:]</span><span id="b331" class="my lw it mu b gy nd na l nb nc">    matrix = []<br/>    while delay_in_ambulatory_care != []:<br/>         matrix.append(delay_in_ambulatory_care[:recs_per_batch])<br/>         delay_in_ambulatory_care = <br/>                   delay_in_ambulatory_care[recs_per_batch:] <br/>   <br/>    number_batchs = number_batchs – 1 ## the warm-up batch<br/>                                         <br/>    dof  = number_batchs - 1<br/>    confidence = 0.90                   ## selected by the analyst<br/>    t_crit = np.abs(stats.t.ppf((1-confidence)/2,dof))<br/>    batch_means = np.mean(matrix, axis = 1)<br/>    batch_std   = np.std(matrix,  axis = 1)<br/>    average_batch_means  = np.mean(batch_means,axis = 0)<br/>    standard_batch_means = np.std(batch_means, axis = 0)</span><span id="9603" class="my lw it mu b gy nd na l nb nc">    inf = average_batch_means <br/>          -standard_batch_means*t_crit/np.sqrt(number_batchs)</span><span id="8fc4" class="my lw it mu b gy nd na l nb nc">    sup = average_batch_means <br/>          +standard_batch_means*t_crit/np.sqrt(number_batchs)</span><span id="7a37" class="my lw it mu b gy nd na l nb nc">    inf = round(float(inf),2)<br/>    sup = round(float(sup),2)</span><span id="8cb5" class="my lw it mu b gy nd na l nb nc">    print('')<br/>    print('Simulation of an Emergency Room')<br/>    print('')<br/>    print('%3s patients arrived at the emergency room' % (len(patient_arrival)))<br/>    print('%3s patients derived to ambulatory care' % (number_recs))<br/>    print('%3s batches of %3s records were used for calculations' %      (number_batchs,  recs_per_batch))<br/>    print ('')<br/>    print('The average delay in ambulatory care belongs to the interval %3s %3s' % (inf, sup))</span></pre><p id="4e35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟算法的核心代码如下。它包含了一个<em class="ms"> Environment() </em>的实例，因为所有SimPy进程都存在于一个环境中[2]。我们排队系统的服务器(<strong class="lb iu">资源</strong>)是接诊台的数量，以及医院护理、门诊护理和非护理级别的医生数量。我们使用<em class="ms"> 1234 </em>作为泊松、均匀和截尾正态分布的随机数序列的种子值。变量<em class="ms">stop _ arrives</em>在验证步骤中使用，必须在生产运行时分配给<em class="ms"> SIM_TIME </em>。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="1fb3" class="my lw it mu b gy mz na l nb nc">env = simpy.Environment()<br/>admission_desks = simpy.Resource(env,<br/>                                 capacity = NUMBER_ADMISSIONS_DESKS)<br/>hospital_care   = simpy.Resource(env, <br/>                                 capacity = NUMBER_DOCS_HOSPITAL)<br/>ambulatory_care = simpy.Resource(env, <br/>                                 capacity = NUMBER_DOCS_AMBULAT)<br/>no_care_level   = simpy.Resource(env, <br/>                                 capacity = NUMBER_DOCS_NO_CARE)</span><span id="5494" class="my lw it mu b gy nd na l nb nc">prng = RandomState(1234)<br/>stop_arrivals = 2000</span><span id="ce5a" class="my lw it mu b gy nd na l nb nc">env.process(generate_patient(env,PATIENT_ARRIVAL_RATE,0,<br/>            stop_arrivals, prng ))</span><span id="d727" class="my lw it mu b gy nd na l nb nc">env.run(until = SIM_TIME)<br/>calc_batches()</span></pre><p id="831e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">分析</strong></p><p id="2e8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们模拟了一个急诊室，包括一个有两个入院台的入院区、一个医院护理级别的医生、五个门诊护理级别的医生和一个非护理级别的医生。根据泊松分布，病人以每小时1.2个病人的速度到达急诊室。根据正态分布，患者随机停留在入院区、医院护理级别和门诊护理级别。历史数据表明，30%的到达患者留在医院护理，60%需要流动护理，只有10%离开房间时仅进行了根据均匀分布的额外筛查。</p><p id="4fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">医疗机构的管理人员希望分析人员分配的可能修改，因为他们收到了来自众多患者的大量投诉，这些投诉与排队时间过长有关，尤其是在门诊护理级别。</p><p id="ac93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们决定进行模拟研究，以了解最终变化的影响，而不必在实际系统中进行。</p><p id="40c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我们进行了一次长度为8760 (24小时* 365天/小时)的运行。在剔除第一批(预热期)后，我们用12个等长批次的批次均值法计算了我们的性能指标(稳态参数)。</p><p id="494d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图1总结了输出数据:在10514个模拟患者后，我们以大约90%的置信度声称，门诊护理水平的平均延迟包含在置信区间[4.36，6.06]小时内。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/aa606664abdbdf500263e783353a90f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*js89S6JcBuHf9qtDzoQ2Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1由作者制作</p></figure><p id="70df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接下来的文章中，我们将继续分析当前配置的替代方案，以使急诊室的运作更好地响应患者的需求。</p><h1 id="596c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">参考文献</strong></h1><p id="5dba" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu">【1】</strong><a class="ae ky" href="https://simpy.readthedocs.io/en/latest/api_reference/simpy.resources.html#simpy.resources.resource.Resource.release" rel="noopener ugc nofollow" target="_blank">https://simpy . readthedocs . io/en/latest/API _ reference/simpy . resources . html # simpy . resources . resource . resource . release</a></p><p id="6a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">【2】</strong><a class="ae ky" href="https://simpy.readthedocs.io/en/latest/api_reference/simpy.html#environments" rel="noopener ugc nofollow" target="_blank">https://simpy . readthedocs . io/en/latest/API _ reference/simpy . html # environments</a></p></div></div>    
</body>
</html>