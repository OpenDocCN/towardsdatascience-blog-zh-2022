<html>
<head>
<title>AWS Step Functions Activities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS步骤功能活动</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/aws-step-functions-activities-f9408a66756a#2022-02-04">https://towardsdatascience.com/aws-step-functions-activities-f9408a66756a#2022-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="47fd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将分离的工人集成到状态机工作流中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f5c2516aee130173d48b3e577e46ed2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pD9iXaFb6y7OII1N8hFPEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:作者提供的图表</p></figure><p id="ae41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://aws.amazon.com/step-functions/" rel="noopener ugc nofollow" target="_blank"> AWS Step Functions </a>于2016年推出，提供状态机来协调AWS服务之间的请求。Step函数支持与<a class="ae lu" href="https://aws.amazon.com/lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda函数</a>、<a class="ae lu" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> SQS队列</a>、<a class="ae lu" href="https://aws.amazon.com/dynamodb" rel="noopener ugc nofollow" target="_blank"> DynamoDB表</a>和<a class="ae lu" href="https://aws.amazon.com/blogs/aws/now-aws-step-functions-supports-200-aws-services-to-enable-easier-workflow-automation/" rel="noopener ugc nofollow" target="_blank">更多服务</a>的集成，可以自动化复杂的流程并管理每秒数千个执行启动—适应无服务器架构并利用其扩展能力。</p><p id="7c34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些情况下，我们希望对工作流中的步骤进行分级限制:手动检查数据质量，或者限制Lambda函数并发性以适应外部API限制。这给原本同步的流添加了一个异步元素。之前我们探索了<a class="ae lu" href="https://medium.com/avmconsulting-blog/callbacks-with-aws-step-functions-a3dde1bc7203?sk=c2b9d966fa32533ea4b3a02da2b5655b" rel="noopener">步骤函数回调</a>来处理这样的场景:生成任务令牌，将它们推给异步工作器进行处理，并暂停我们的执行，直到工作器返回结果。</p><p id="2cae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常这就足够了，但是假设我们有一个回调不支持的工作线程，或者网络中的另一个工作线程不可访问Step函数，使我们无法推送任务令牌。在这些情况下，我们如何整合员工？</p><p id="b86a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-activities.html" rel="noopener ugc nofollow" target="_blank">活动</a>—<a class="ae lu" href="https://aws.amazon.com/blogs/aws/new-aws-step-functions-build-distributed-applications-using-visual-workflows/" rel="noopener ugc nofollow" target="_blank">Step Functions</a>推出的首批功能之一—是解决这些问题的一个选项。大体上类似于回调，活动依赖于工人和令牌来协调异步任务。基本的区别在于步骤函数和工作器之间的关系:回调是基于推送的，活动工作器轮询任务。</p><h1 id="9aeb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">一项活动是如何运作的？</h1><p id="438a" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">一项活动有两个关键部分。首先我们有工人。这可以是一个Lambda函数，一个<a class="ae lu" href="https://aws.amazon.com/ec2/" rel="noopener ugc nofollow" target="_blank"> EC2实例</a>，或者任何有效的运行代码的东西。工人使用活动的唯一的<a class="ae lu" href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html" rel="noopener ugc nofollow" target="_blank"> Amazon资源号</a> (ARN)来轮询任务的步骤函数。</p><p id="b772" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当检索到一个挂起的任务时，worker将获得一个惟一的任务令牌以及要处理的输入数据。worker应用它的魔力，确定请求是成功还是失败，并将结果报告给Step函数。如果请求需要一段时间来处理，那么工作者也可以发送一个心跳来确认请求仍在进行中。</p><p id="26e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在步骤函数工作流中，我们获取活动的ARN，并将其嵌入到新的活动调用状态中。该状态启动工作者轮询的新活动任务。当步骤函数执行到达调用状态时，工作流暂停，直到活动确认来自工作器的响应，或者活动超时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb022135da3aaddbd699e01575fd90b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOq1y0mTPGMPz-HkcBckNw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:作者提供的图表</p></figure><h1 id="3c9b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们如何建立一个活动？</h1><p id="4b77" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">让我们使用最新版本的<a class="ae lu" href="https://docs.aws.amazon.com/cdk/latest/guide/home.html" rel="noopener ugc nofollow" target="_blank">AWS Cloud Development Kit</a>(CDK)for TypeScript来提供一个Step Functions活动—在撰写本文时版本为2.10.0。在本例中，我们将提供一个Lambda函数作为我们的活动工作器，并将它集成到一个只有三种状态的Step Functions工作流中:开始、活动任务和结束。</p><p id="978d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们使用CDK的<code class="fe ms mt mu mv b">Activity</code>结构提供一个活动。活动的名称是可选的。我们将它合并到一个<code class="fe ms mt mu mv b">StepFunctionsInvokeActivity</code>状态中，这将为我们的工人创建活动任务。最后，但同样重要的是，我们定义一个<code class="fe ms mt mu mv b">StateMachine</code>来完成我们的步骤函数配置，将调用状态传递到定义中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6fc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以把注意力转向工人了。到目前为止，我们已经创建了一个活动，但是还没有工人处理它的任务。为这个例子选择一个节点Lambda函数，让我们提供一个<code class="fe ms mt mu mv b">NodejsFunction</code>，将活动ARN作为环境变量传递，以便在函数代码中引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c5a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe ms mt mu mv b">src/activityWorker.ts</code>中定义Lambda类型脚本代码，我们使用AWS SDK <code class="fe ms mt mu mv b">getActivityTask</code>方法读取<code class="fe ms mt mu mv b">ACTIVITY_ARN</code>环境变量和未决任务的长轮询。请注意，轮询可能会运行一分钟，而Lambda函数默认为三秒钟的超时，因此请确保将Lambda超时增加到一分钟以上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="054f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果发现一个挂起的任务，我们就要处理输入数据和任务令牌。使用一个基本的随机生成器来决定这个任务应该成功还是失败，我们可以根据结果将输出和任务令牌一起提供给SDK的<code class="fe ms mt mu mv b">sendTaskSuccess</code>或<code class="fe ms mt mu mv b">sendTaskFailure</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7b7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就结束了工人逻辑！现在是最后的润色。让我们返回到CDK，授予我们的Lambda函数<a class="ae lu" href="https://aws.amazon.com/iam" rel="noopener ugc nofollow" target="_blank">身份和访问管理</a> (IAM)权限，以轮询并向Step Functions活动报告任务结果，并在Lambda函数上安排一个五分钟的调用速率以保持其热度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="d61c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从AWS控制台手动调用Step函数，我们观察到pending activity任务，它显示为蓝色，表示它正在进行中，直到我们的Cron调度调用Lambda worker。根据调用和处理时间的不同，这将持续7分钟。当工人获取任务并报告成功或失败时，我们的步骤函数在控制台上共享这个结果。在失败的情况下，我们会看到一个异常选项卡，显示来自工作线程的调用状态的错误细节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/f3cbf8a6965a2a651a5a0b8a22c47f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rKPExLGPYgog9ORqPyBPxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:作者截图</p></figure><h1 id="4ee2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">活动存在哪些限制？</h1><p id="f945" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">活动工作者在高吞吐量下努力轮询未决任务。如果预计流量很大，请考虑对SQS队列使用回调，并将工作线程配置为轮询队列，而不是任务的活动。</p><h1 id="cbca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5595" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">活动与回调有很大的相似之处，它提供了一种在Step函数中编排异步任务的替代方法。需要一点额外的工作来适应任务令牌的长时间轮询，活动不太可能是大多数异步用例的首选。</p><p id="3d2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，当分离的工作者是必要的，或者回调不支持与工作者的集成时，活动仍然是一个有价值的选择。请记住高吞吐量的局限性，使用回调和SQS队列的替代方法可能更健壮。</p><p id="b3f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本活动演练的完整代码库可从GitHub 获得<a class="ae lu" href="https://github.com/rrhodes/aws-step-functions-activity" rel="noopener ugc nofollow" target="_blank">。如果你以前有使用阶跃函数活动的经验，或者更一般的阶跃函数，请告诉我。</a></p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="db9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">博客于2022年2月5日发布，分享了关于活动工作者轮询和高吞吐量的限制，并推荐了使用回调和SQS队列的解决方法。感谢<a class="ng nh ep" href="https://medium.com/u/8055367b4f0e?source=post_page-----f9408a66756a--------------------------------" rel="noopener" target="_blank">艾达·王</a>分享这些。</p></div></div>    
</body>
</html>