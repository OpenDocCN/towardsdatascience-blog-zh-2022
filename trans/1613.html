<html>
<head>
<title>Building an Open Source ML Pipeline: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建开源ML管道:第2部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-open-source-ml-pipeline-part-2-29a8dcbc7620#2022-04-18">https://towardsdatascience.com/building-an-open-source-ml-pipeline-part-2-29a8dcbc7620#2022-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="33b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Argo事件和Argo工作流进行事件驱动的数据处理。</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="3235" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="ko ir"> 1。设置Argo事件</strong></p><p id="34c4" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了建立事件驱动的工作流，我们需要向我们的工具包添加另一个工具，即<a class="ae li" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> Argo Events </a>。设置Argo事件可能有点棘手，但是我在Github <a class="ae li" href="https://github.com/lambertsbennett/mlops-odyssey" rel="noopener ugc nofollow" target="_blank">这里</a>提供了必要的YAML文件。我们将从他们的例子中的一个例子开始，只是为了确保一切都正确安装。因此，一旦您克隆了存储库，就可以随意查看这些清单的内容。就修改而言，您需要用自己的凭据替换' minio-secret.yaml '中的base64编码凭据，以便事件源能够工作。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="0d1e" class="ls lt iq lo b gy lu lv l lw lx">kubectl apply -f argo-events.yaml -n argo</span><span id="56ea" class="ls lt iq lo b gy ly lv l lw lx">kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/eventbus/native.yaml</span><span id="4bc5" class="ls lt iq lo b gy ly lv l lw lx">kubectl apply -f minio-secret.yaml -n argo</span><span id="8d06" class="ls lt iq lo b gy ly lv l lw lx">kubectl apply -f minio-event-source-example.yaml -n argo</span><span id="ba16" class="ls lt iq lo b gy ly lv l lw lx">kubectl apply -f minio-sensor-example.yaml -n argo</span></pre><p id="1310" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可能已经注意到，在Argo工作流中，侧边栏中有一个与事件相关的标签。如果您现在导航到那里，您应该会得到一个关于服务帐户无法列出该类别中的资源的错误。这是因为默认的Argo工作流角色不考虑Argo事件。要修复此运行，请执行以下操作:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="71ec" class="ls lt iq lo b gy lu lv l lw lx">kubectl apply -f argo-role.yaml -n argo</span></pre><p id="1f06" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在，当您导航到events选项卡时，您应该会看到与此类似的内容。这是我们的示例事件源-&gt;传感器-&gt;触发器设置。当我们将一个文件放入“openaq”桶时，它会触发一个whalesay工作流，打印上传文件的文件名。</p><figure class="lj lk ll lm gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lz"><img src="../Images/c46e23b0ceb8e9889824300cb35369c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7ApkOSe0HH21IzjueMk1g.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">Argo用户界面中概述了我们的示例事件源。图片作者。</p></figure><p id="84d0" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这是一个很大的YAML，所以让我们后退一步，谈谈Argo事件如何工作，每个文件在做什么。Argo events的工作原理是将'<a class="ae li" href="https://argoproj.github.io/argo-events/concepts/event_source/" rel="noopener ugc nofollow" target="_blank">事件源</a>与包含'<a class="ae li" href="https://argoproj.github.io/argo-events/concepts/trigger/" rel="noopener ugc nofollow" target="_blank">触发器</a>'的'<a class="ae li" href="https://argoproj.github.io/argo-events/concepts/sensor/" rel="noopener ugc nofollow" target="_blank">传感器</a>连接起来。事件源使用来自外部源的事件。在我们的例子中，当一个文件被放入“openaq”桶时，我们的事件源正在消耗由Minio生成的通知。传感器侦听特定的事件源，并定义当事件发生时应该发生什么(这是触发器，在我们的情况下，我们部署Argo工作流)。Argo Events确实是一个很酷的框架，我们在这里使用Minio作为事件源，但它也可以很容易地成为Kafka主题或Redis pubsub事件。</p><figure class="lj lk ll lm gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ml"><img src="../Images/017d2d9ca6b1fce5d316c83be9bda6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*db2vr9fWaWykY7cMWD_gLQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图片来自<a class="ae li" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank">https://argoproj.github.io/argo-events/</a>。</p></figure><p id="694f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们需要用触发器模板定义事件源和传感器。为了测试，我使用了来自<a class="ae li" href="https://github.com/argoproj/argo-events/tree/master/examples" rel="noopener ugc nofollow" target="_blank"> Argo Events Github页面</a>的示例事件源和传感器文件。起初有一些问题，但是我打开了一个Github问题，几天之内就解决了。团队的响应时间令人印象深刻！现在，如果您向前移植并访问Minio bucket，您就可以上传一个文件，您应该会看到示例事件在运行。</p><p id="3408" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">我们将回到Argo事件并定义我们的预处理模板，但是首先我们需要为数据验证生成一个期望套件。为此我们将寄予厚望。我以前写过一篇关于在Argo工作流中使用Great Expectations的文章，很多内容都是从<a class="ae li" rel="noopener" target="_blank" href="/data-validation-with-great-expectations-and-argo-workflows-b8e3e2da2fcc">那里</a>摘录的。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><p id="7178" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="ko ir"> 2。在Argo工作流中生成期望套件</strong></p><p id="e9f9" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了生成我们的期望套件，我们需要从OpenAQ API中提取代表性数据。为了做到这一点，我们将尽可能早地获取API允许的数据，然后生成我们的期望套件。原则上，这些数据应该与我们用来训练模型的数据相同，所以我会将这些数据保存到我们的Minio“数据湖”中，以备将来使用。我们可以利用Hera为此生成一个工作流，这让生活变得更加美好。我们也可以利用第1部分中的提取和转换函数，只需稍加修改。<em class="mm">这里未来要做的是参数化提取函数，这样我们就不需要硬编码API调用的开始和结束日期。</em>我们需要为数据验证工作再创建两个Minio桶，因为我们不想在上传远大前程文件时触发Argo事件管道。我创建了一个名为“验证”的桶和一个名为“训练”的桶。我们将在“验证”中存储我们的远大前程套件，在“训练”中存储原始数据。总之，从OpenAQ数据中生成期望值的代码如下所示:</p><figure class="lj lk ll lm gt ma"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="277c" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这里，我们利用Argo Workflow的能力，通过定义任务在各行中的顺序来运行并行任务:</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="009d" class="ls lt iq lo b gy lu lv l lw lx">extract_task &gt;&gt; ge_task<br/>extract_task &gt;&gt; store_task</span></pre><p id="bcc7" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在运行代码之前，确保您正在本地主机:2746上端口转发Argo服务器，在本地主机:9000上端口转发Minio。提交后，您应该能够在Argo用户界面中看到成功的管道运行:</p><figure class="lj lk ll lm gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi mp"><img src="../Images/7254e1e05a8b56ef81e6676576d2748a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAryhAWPUPnp4Dgf0o7sKg.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated">图片作者。</p></figure><p id="099f" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated"><strong class="ko ir"> 3。设置我们的事件驱动管道。</strong></p><p id="72cc" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在这个管道的最后一次迭代中，我们希望能够基于模型度量触发模型重新训练。为此，我认为最灵活的选择是创建一个webhook事件源。这意味着我们可以使用http请求触发argo工作流。简而言之，我们的工作流程如下所示:</p><ul class=""><li id="cd18" class="mq mr iq ko b kp kq ks kt kv ms kz mt ld mu lh mv mw mx my bi translated">在http触发时，检索历史OpenAQ数据。</li><li id="e735" class="mq mr iq ko b kp mz ks na kv nb kz nc ld nd lh mv mw mx my bi translated">将数据转换成表格格式。</li><li id="d986" class="mq mr iq ko b kp mz ks na kv nb kz nc ld nd lh mv mw mx my bi translated">为检索到的数据生成一个期望套件。</li><li id="3e51" class="mq mr iq ko b kp mz ks na kv nb kz nc ld nd lh mv mw mx my bi translated">将原始数据存储在我们的“train”Minio桶中。</li></ul><p id="e5a9" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">从那里，我们可以设置一个Minio事件源，它将触发一个模型训练管道。这一点我们将在下一篇文章中介绍！</p><p id="0b66" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">为了避免在YAML编写我们的管道，我们将使用Argo工作流CRD，工作流模板。我们可以在Python中使用<a class="ae li" href="https://github.com/argoproj-labs/hera-workflows" rel="noopener ugc nofollow" target="_blank"> Hera </a>定义工作流模板，然后在Argo事件定义中引用工作流模板。</p><p id="75b8" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">在Hera中，从工作流切换到工作流模板非常容易。为了完整起见，下面是完整的代码，但我将重点介绍具体的更改。</p><figure class="lj lk ll lm gt ma"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="aea8" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">更改发生在导入和第180–181行。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="26a5" class="ls lt iq lo b gy lu lv l lw lx">ws = WorkflowTemplateService(host="https://localhost:2746", verify_ssl=False, token=TOKEN)</span><span id="5c2a" class="ls lt iq lo b gy ly lv l lw lx">w = WorkflowTemplate("generate-expectations", ws, namespace="argo")</span></pre><p id="6919" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在剩下的就是定义我们的webhook，每当它接收到post请求时就提交这个工作流模板。</p><p id="ad22" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">首先让我们定义我们的webhook事件源。</p><figure class="lj lk ll lm gt ma"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="21d0" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">这里我们创建一个名为retrain的webhook，它在端点/retrain和端口12000上公开。接下来，让我们创建我们的传感器:</p><figure class="lj lk ll lm gt ma"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cc5e" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">您可以在这里看到，我们利用了之前通过使用“templateRef”字段创建的工作流模板。如果我们kubectl应用这两个文件，那么我们应该有一个准备就绪的eventsource + sensor对。</p><p id="1f03" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">接下来测试设置端口-转发eventsource pod。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="3240" class="ls lt iq lo b gy lu lv l lw lx">kubectl -n argo port-forward webhook-eventsource-{randomstring} 12000:12000</span></pre><p id="3817" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">然后，我们可以通过向/retrain端点处的pod发送post请求来简单地测试它。我学到的一件有趣的事情是，为了正确触发工作流，我必须包含虚拟数据，即使它没有参数。</p><pre class="lj lk ll lm gt ln lo lp lq aw lr bi"><span id="ee79" class="ls lt iq lo b gy lu lv l lw lx">curl -d '{"dummy":"dummy"}' -H "Content-Type: application/json" -X POST http://localhost:12000/retrain</span></pre><p id="98cf" class="pw-post-body-paragraph km kn iq ko b kp kq jr kr ks kt ju ku kv kw kx ky kz la lb lc ld le lf lg lh ij bi translated">现在我们有了一个设置，可以用事件驱动的方式启动我们的管道。我们将继续以同样的方式建立我们的渠道。在下一篇文章中，我们将重点关注模型训练过程，以及我们如何将Argo工作流与MLflow结合起来进行模型训练、实验跟踪和模型存储。</p></div></div>    
</body>
</html>