<html>
<head>
<title>The Unreasonable Effectiveness Of Comprehensions In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中理解的不合理有效性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-unreasonable-effectiveness-of-comprehensions-in-python-2a0dcc585153#2022-03-28">https://towardsdatascience.com/the-unreasonable-effectiveness-of-comprehensions-in-python-2a0dcc585153#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b986" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python 中有哪些理解，为什么它们如此有用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7922ddac80042178efad24a653954f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ke9HBeGU5PVcJ19fo8iyQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae ky" href="https://pixabay.com/images/id-1338543/" rel="noopener ugc nofollow" target="_blank"> altoff </a>提供)</p></figure><h1 id="dbc4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="d1e9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi mn translated">在语法方面，ython 是一种众所周知的妙招百出的语言。其中一个例子是 decorators，它完全改变了 Python 在不同实例中的行为方式。另一个很好的例子是理解，由于它们非常有用和多才多艺，它已经被带到了各种其他语言中。如果你不知道如何使用理解来表示 Python 中的不同类型，那么你就真的错过了 Python 编程语言的一个巨大特性。</p><p id="ba46" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">此外，理解尤其热衷于数据科学。当然，总会有一些软件工程场景，在这些场景中，理解变得唾手可得，并且使用了列表，但是在数据科学领域，更常见的是在整个数据范围内应用操作。我们可以认为理解很像正常的断言。如果我们将一个值设置为正常意义上的某个值，那么数据不会发生任何变化，但是如果我们添加了一个操作，那么在我们创建它之前，我们会使数据等于其他值。理解也有类似的应用，它们可以在断言之前改变或生成数据。这是数据结构所特有的。不用说，因为我们经常在 Julia 中处理列表或熊猫系列，所以对于 Python 中的数据科学和软件工程来说，理解是一个非常强大的工具。</p><blockquote class="nb"><p id="fd3c" class="nc nd it bd ne nf ng nh ni nj nk mm dk translated"><a class="ae ky" href="https://github.com/emmettgb/Emmetts-DS-NoteBooks/blob/master/Python3/Python%20Comprehensions.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a></p></blockquote></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="1f8d" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">不同类型的理解</h1><p id="f04a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在 Python 中有许多不同类型的理解。尽管本文的主要焦点是列表理解，考虑到它们在数据科学和其他领域的应用，也可以理解 Python 中的字典、集合甚至生成器。在许多情况下也非常有用，并为处理数据结构的传统方法提供了显著的性能优势。</p><h2 id="6156" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">列出理解</h2><p id="be4d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先要谈的理解仍然是列表的理解。Python 中的列表理解在大多数情况下本质上是一个迭代循环。然而，这些循环的一个优点是，它们通常比 Python 中的标准迭代循环要快得多。考虑下面的例子，其中理解可以非常有效地使用，但不是。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="def2" class="nx la it ok b gy oo op l oq or">def define_list(x : int):<br/>    lst = []<br/>    for i in range(1, 50):<br/>        lst.append(x * i)<br/>    return(lst)</span></pre><p id="b32b" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">在这种情况下，仅仅因为我们没有使用理解，就需要做更多的工作。首先，如果我们希望我们的最终值对函数是公共的，那么我们必须在 for 循环开始之前定义它。这是因为每个迭代循环都在函数内部建立了一个新的私有作用域，这也是我们一旦退出 for 循环就不能访问" I "的原因。除了使用 append()方法而不是仅仅使用列表理解来降低算法速度之外，我们还浪费了各种各样的代码行。我们可以将整个函数缩减为一行，在这里使用简单的列表理解来排除 return 和 definition 语句。我们通过使用标准的数组分隔符、[和]，并在其中加入某种公式化的或迭代的逻辑，来进行列表理解。在前面的例子中，它们是这样的:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="9b7b" class="nx la it ok b gy oo op l oq or">def def_list2(x: int):<br/>    return([x * i for i in range(1, 50)])</span></pre><p id="2c5e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">不用说，这要简洁得多。即使这样，代码也获得了性能增强，所以没有什么好的理由不使用理解。理解也提供了一个回报，意味着我们可以设置一些与它相等的东西，这个值将成为我们写理解所要创建的列表。</p><h2 id="95cd" class="nx la it bd lb ny nz dn lf oa ob dp lj ma oc od ll me oe of ln mi og oh lp oi bi translated">字典理解</h2><p id="e98b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然我肯定在列表中使用理解最多，但它们也适用于其他类型。其中之一是字典类型。这种理解语法与 list 示例中的方式大致相同。通常，这些都是用迭代循环规范来完成的，然而这次当然是用键和花括号来完成的。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="ff4c" class="nx la it ok b gy oo op l oq or">input = [5, 10, 15, 20]<br/>{x:x ** 3 for x in input if x % 2 != 0}</span></pre><h1 id="612e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据科学中的理解应用</h1><p id="1d8c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当涉及到通用软件工程时，这种不合理的有效性很容易理解为什么这种有效性会延伸到数据科学领域。经常使用理解的一个很好的例子是条件掩蔽技术。条件屏蔽允许我们创建一个位数组，然后用它从给定的数据帧、列表或你所拥有的东西中过滤出值。它首先创建掩码，然后用位数组索引数据帧。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="f723" class="nx la it ok b gy oo op l oq or">import pandas as pd<br/>df = pd.DataFrame({"A" : [5, 10, 15, 20], "B" : [5, 10, 15, 20]})</span><span id="fc84" class="nx la it ok b gy os op l oq or">mask = df["A"] &gt; 5<br/>mask</span><span id="00dc" class="nx la it ok b gy os op l oq or">newdf = df[mask]</span></pre><p id="c716" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">做数据科学的时候，这其实是相当常见的操作。一个很好的例子是，如果我们想进行测试。测试时，我们需要根据某个字段来分离数据。例如，假设我们有以下数据:</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="6dbd" class="nx la it ok b gy oo op l oq or">df = pd.DataFrame({"height (cm)" : [182, 125, 102, 190, 140, 150], "sex" : ['m', 'f', 'f', 'm', 'f', 'm']})</span></pre><p id="2cd5" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">我们想进行一项学生 t 检验，以确定一个人的性别对其身高的影响是否有统计学意义。我们可以用一种理解来区分男性和女性，并将他们与人口进行比较。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="c909" class="nx la it ok b gy oo op l oq or">from scipy.stats import ttest_ind</span><span id="703b" class="nx la it ok b gy os op l oq or">male_mask = df["sex"] == 'm'<br/>female_mask = df["sex"] == 'f'</span><span id="14e9" class="nx la it ok b gy os op l oq or">male_df = df[male_mask]<br/>female_df = df[female_mask]</span><span id="2dd9" class="nx la it ok b gy os op l oq or">ttest_ind(df["height (cm)"], female_df["height (cm)"])<br/>Ttest_indResult(statistic=1.2115133507714908, pvalue=0.26500459971996915)</span></pre><p id="e77a" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">理解的另一个重要应用是特征工程。通常在数据科学中，特性并不完全是我们想要的样子。有时，我们希望预测数据中没有的东西，但可以使用数据来创建。对于这一点，理解非常适合，因为它们提供了足够的回报，并且可以非常容易地从其他列表中构建，例如数据帧中的其他特性。我们将通过在我们的其他数据帧上设计一个新的特性来尝试这一点。虽然这个特性没有用，但它很好地展示了如何将同样的技术应用到更有用的实例中。</p><pre class="kj kk kl km gt oj ok ol om aw on bi"><span id="c7dd" class="nx la it ok b gy oo op l oq or">df["height (in)"] = [x * 0.393701 for x in df["height (cm)"]]</span></pre><p id="5203" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">这将为我们的 dataframe 添加一个新的高度列(英寸)。不用说，与其他设计特征的技术相比，这种技术非常有效。理解在数据科学世界中扮演着大胆而重要的角色。</p></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="73fc" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">结论</h1><p id="e34e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">所以…理解是很棒的。它们不仅使您的代码更加简洁，而且还提高了 Python 代码的性能。当然，考虑到我们是在用 Python 做数据科学，可以节省的每一点性能都应该被节省下来。也就是说，这些理解也被引入到其他语言中，如 Julia，它们的实现在某种程度上已经成为科学计算高级语言中的主要内容，很容易理解为什么会这样。</p><p id="c54e" class="pw-post-body-paragraph lr ls it lt b lu mw ju lw lx mx jx lz ma my mc md me mz mg mh mi na mk ml mm im bi translated">虽然理解在一般的软件工程应用中肯定有恰当的应用，但我相信这些理解真正开始发光是在数据科学中。感谢您阅读我的文章，我希望这些理解对您今后的 Python 代码有重大的改进！</p></div></div>    
</body>
</html>