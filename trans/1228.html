<html>
<head>
<title>Automated Data Cleaning with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 自动清理数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automated-data-cleaning-with-python-94d44d854423#2022-03-29">https://towardsdatascience.com/automated-data-cleaning-with-python-94d44d854423#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c285" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何自动化数据准备并为您的下一个数据科学项目节省时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b24cac538256e32ca7dd18b3ce37230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fToKmWr1-pQy3btyw7cSkw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://unsplash.com/photos/lFv0V3_2H6s" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>。</p></figure><p id="0fab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，数据清理和预处理是数据科学项目的主要组成部分。而且，你可能会同意我的观点，这不是项目中最令人兴奋的部分。</p><blockquote class="lv"><p id="d1cc" class="lw lx it bd ly lz ma mb mc md me lu dk translated">那么，(让我们扪心自问):我们能自动化这个过程吗？</p></blockquote><p id="5fdd" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">嗯，自动化数据清理说起来容易做起来难，因为所需的步骤高度依赖于数据的<strong class="lb iu">形状</strong>和特定领域的<strong class="lb iu">用例</strong>。尽管如此，还是有办法以一种标准化的方式使<strong class="lb iu">自动化</strong>至少是<strong class="lb iu"> </strong>相当大的一部分<strong class="lb iu">。</strong></p><p id="d265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何在<strong class="lb iu"> Python 3.8 </strong>中构建自己的<strong class="lb iu">自动化数据清理管道</strong>。</p><p id="3d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mk">查看</em><a class="ae ky" href="https://github.com/elisemercury/AutoClean" rel="noopener ugc nofollow" target="_blank"><em class="mk">Github</em></a><em class="mk">上的 AutoClean 项目。</em></p><h1 id="b5dc" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">1 | <strong class="ak">我们想自动化什么？</strong></h1><p id="81cf" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在深入这个项目之前，我们应该问自己的第一个也是最重要的问题是:数据清理过程的哪些步骤<strong class="lb iu">可以</strong>实现<strong class="lb iu">标准化</strong>和<strong class="lb iu">自动化</strong>？</p><p id="cb8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有可能自动化或标准化的步骤是在几乎每个数据科学项目的每个清理过程中反复执行的步骤。而且，由于我们想要建立一个“一刀切”的管道，我们想要确保我们的处理步骤是相当通用的，可以适应各种类型的数据集。</p><p id="ca65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在大多数项目中经常被问到的一些常见问题包括:</p><ul class=""><li id="b82d" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">我的数据是什么格式的？CSV，JSON，text？还是另一种格式？我该如何处理这种格式？</li><li id="8078" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我们的数据特征有哪些<strong class="lb iu">数据类型</strong>？我们的数据集包含分类和/或数字数据吗？我们如何处理每一个问题？我们想要对我们的数据进行<strong class="lb iu">一次性编码</strong>，和/或执行数据<strong class="lb iu">类型转换</strong>？</li><li id="01cf" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我们的数据是否包含<strong class="lb iu">缺失值</strong>？如果是，我们如何处理它们？我们要执行一些<strong class="lb iu">插补技术</strong>吗？或者我们能安全地<strong class="lb iu">删除</strong>有缺失值的观测值吗？</li><li id="1705" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">我们的数据是否包含<strong class="lb iu">异常值</strong>？如果是，我们是应用<strong class="lb iu">正则化技术</strong>，还是让它们保持原样？……等等，我们甚至认为什么是“异常值”？</li></ul><p id="5b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论我们的项目将针对什么用例，这些都是很可能需要解决的问题，因此可以成为<strong class="lb iu">自动化</strong>的一个伟大主题。</p><p id="9d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些问题的答案以及它们的实现将在接下来的几章中讨论和展示。</p><h1 id="5615" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">2 |管道的构建模块</h1><p id="060c" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">首先，让我们从导入我们将使用的库开始。这些将主要是 Python <strong class="lb iu"> Pandas、Sklearn </strong>和<strong class="lb iu"> Numpy </strong>库，因为它们在处理数据时非常有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="7080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将定义我们的脚本将接受一个<strong class="lb iu"> Pandas dataframe 作为输入</strong>，这意味着我们至少需要将数据转换成 Pandas dataframe 格式，然后才能被我们的管道处理。</p><p id="2aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看我们的管道的构建模块。以下章节将经历以下处理步骤:</p><p id="b8ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">【区块 1】</strong>缺失值<br/> <strong class="lb iu">【区块 2】</strong>异常值<br/> <strong class="lb iu">【区块 3】</strong>分类编码<br/> <strong class="lb iu">【区块 4】</strong>提取日期时间特征<br/> <strong class="lb iu">【区块 5】</strong>打磨步骤</p><h2 id="29cf" class="ny mm it bd mn nz oa dn mr ob oc dp mv li od oe mx lm of og mz lq oh oi nb oj bi translated">[块 1 ]缺少值</h2><p id="f7e5" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">一个项目从一个包含缺失值的数据集开始是相当常见的，并且有各种方法来处理它们。我们可以简单地删除含有缺失值的观测值，或者我们可以使用插补技术。在各种回归或分类模型的帮助下预测数据中的缺失值也是常见的做法。</p><blockquote class="ok ol om"><p id="5f50" class="kz la mk lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><em class="it">💡</em>插补技术用某些值(如平均值)或与特征空间中其他样本值类似的值(例如 K-NN)来替换缺失数据。</p></blockquote><p id="63b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何处理缺失值的选择主要取决于:</p><ul class=""><li id="955c" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">数据类型(数值或分类)和</li><li id="6c17" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">相对于样本总数，我们有多少缺失值(从 100k 中删除 1 个观察值与从 100 个中删除 1 个观察值的影响不同)</li></ul><p id="cf2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的管道将遵循策略<strong class="lb iu">插补&gt;删除</strong>，并将支持以下技术:线性和逻辑回归预测、K-NN 插补、均值、中值和众数以及删除。</p><p id="8c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在我们可以开始为我们的第一个构建块编写函数了。我们将首先创建一个单独的类来处理缺失值。下面的函数<em class="mk"> handle </em>将以不同的方式处理<strong class="lb iu">数值型</strong>和<strong class="lb iu">分类型</strong>缺失值:一些插补技术可能只适用于数值型数据，而一些则只适用于分类型数据。让我们来看看处理数字特征的第一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击查看完整源代码<a class="ae ky" href="https://github.com/elisemercury/AutoClean/blob/main/AutoClean/Modules.py" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="3815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数检查为数字和分类特征选择了哪种处理方法。默认设置为“<em class="mk">自动”</em>，这意味着:</p><ul class=""><li id="eb96" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated"><strong class="lb iu">数值</strong>缺失值将首先通过<strong class="lb iu">线性回归</strong>预测进行插补，剩余值将通过 K-NN 进行插补</li><li id="a96e" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><strong class="lb iu">分类</strong>缺失值将首先使用<strong class="lb iu">逻辑回归</strong>通过预测进行估算，剩余值将使用 K-NN 进行估算</li></ul><p id="1cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于分类特征，与上述相同的原则适用，除了我们将仅支持使用逻辑回归、K-NN 和模式插补的插补。当使用 K-NN 时，我们将首先将我们的分类特征标记编码为整数，使用这些标记来预测我们缺少的值，最后将标记映射回它们的原始值。</p><p id="cc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据所选择的处理方法，<em class="mk"> handle </em>函数从其类中调用所需的函数，然后在各种 Sklearn 包的帮助下操作数据:<em class="mk">_ imput</em>函数将负责 K-NN、均值、中值和众数插补，<em class="mk">_ Lin _ regression _ imput</em>和<em class="mk">log _ regression _ imput</em>将通过预测执行插补，我假设<em class="mk"> _delete </em>的角色是自我插补</p><p id="418c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最终的<em class="mk"> MissingValues </em>类结构将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击查看完整源代码<a class="ae ky" href="https://github.com/elisemercury/AutoClean/blob/main/AutoClean/Modules.py" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="31a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mk">我不会更详细地介绍该类其余函数中的代码，但是我邀请您查看</em> <a class="ae ky" href="https://github.com/elisemercury/AutoClean/blob/main/AutoClean/Modules.py" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> AutoClean 资源库</em> </a> <em class="mk">中的完整源代码。</em></p><p id="c119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成所有需要的步骤后，我们的函数输出处理过的输入数据。</p><p id="0f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷，我们通过了管道的第一个模块🎉。现在让我们考虑一下如何处理数据中的异常值。</p><h2 id="208c" class="ny mm it bd mn nz oa dn mr ob oc dp mv li od oe mx lm of og mz lq oh oi nb oj bi translated">[区块 2 ]异常值</h2><p id="03b2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们的第二个模块将关注数据中异常值的处理。首先我们需要问自己:什么时候我们认为一个值是异常值？对于我们的管道，我们将使用一个普遍应用的规则，即如果<strong class="lb iu">在以下</strong>范围之外，则数据点可被视为异常值:</p><p id="c4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mk">【Q1—1.5 * IQR；Q3 + 1.5 * IQR] </em></p><p id="537c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…其中 Q1 和 Q3 是第一和第三四分位数，IQR 是四分位数之间的范围。下面你可以看到一个很好的箱线图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/90cf4480915afb93f34b180bba4411a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNrZ14cuVtV_l4cW4EfAqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="5c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经定义了什么是异常值，我们现在必须决定如何处理这些异常值。同样，有各种策略可以做到这一点，对于我们的用例，我们将重点关注以下两种:winsorization 和 deletion。</p><blockquote class="ok ol om"><p id="d964" class="kz la mk lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><em class="it">💡</em> Winsorization 在统计学中用于限制数据中的极端值，并通过用数据的特定百分位数替换异常值来减少异常值的影响。</p></blockquote><p id="7d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用 winsorization 时，我们将再次使用上面定义的范围来替换异常值:</p><ul class=""><li id="901b" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">值&gt;上限将由<strong class="lb iu">上限范围值</strong>代替，并且</li><li id="a9f3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">数值&lt; lower bound will be replaced by the <strong class="lb iu">量程下限值</strong>。</li></ul><p id="aa9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<em class="mk">异常值</em>类的最终结构将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击查看完整源代码<a class="ae ky" href="https://github.com/elisemercury/AutoClean/blob/main/AutoClean/Modules.py" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="e54f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们到达了第二块的末尾——现在让我们看看如何对分类数据进行编码。</p><h2 id="3172" class="ny mm it bd mn nz oa dn mr ob oc dp mv li od oe mx lm of og mz lq oh oi nb oj bi translated">[块 3 ]分类编码</h2><p id="ec6a" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">为了能够用分类数据进行计算，在大多数情况下，我们需要我们的数据是数字类型，即数字或整数。因此，常见的技术包括<strong class="lb iu">一键编码</strong>数据，或<strong class="lb iu">标签编码</strong>数据。</p><blockquote class="ok ol om"><p id="a7d6" class="kz la mk lb b lc ld ju le lf lg jx lh on lj lk ll oo ln lo lp op lr ls lt lu im bi translated"><em class="it">💡</em>数据的一键编码将特征的每个唯一值表示为二进制向量，而标签编码为每个值分配一个唯一的整数。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/cdbd891504a5697ef03d1e5f46212036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*FuIxxb4SodCkY2aWzBofGw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="ba89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种方法都有不同的利弊，比如独热编码产生了许多额外的特性。此外，如果我们标记 encode，这些标记可能会被某些算法解释为数学相关:1 个苹果+ 1 个橘子= 1 个香蕉，这显然是对这种类型的分类数据的错误解释。</p><p id="655a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的管道，我们将设置默认策略<em class="mk">‘auto’</em>来根据以下规则执行编码:</p><ul class=""><li id="7379" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">如果特征包含&lt; 10 unique values, it will be <strong class="lb iu">单热编码</strong></li><li id="bd34" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">如果特征包含&lt; 20 unique values, it will be <strong class="lb iu">标签编码的</strong></li><li id="a8eb" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">如果特征包含&gt; 20 个唯一值，它将<strong class="lb iu">而不是</strong>被编码</li></ul><p id="d0cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是处理编码过程的一种非常原始和快速的方式，可能会很方便，但也可能导致编码不完全适合我们的数据。即使自动化很棒，我们仍然希望确保我们也可以<strong class="lb iu">手动定义</strong>哪些特性应该被编码，以及如何编码。这是在<em class="mk"> EncodeCateg </em>类的<em class="mk">句柄</em>函数中实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击查看完整源代码<a class="ae ky" href="https://github.com/elisemercury/AutoClean/blob/main/AutoClean/Modules.py" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="43ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mk">句柄</em>函数将一个<strong class="lb iu">列表</strong>作为输入，而我们想要手动编码的特性可以由列名或索引定义，如下所示:</p><pre class="kj kk kl km gt os ot ou ov aw ow bi"><span id="86bc" class="ny mm it ot b gy ox oy l oz pa">encode_categ = [‘onehot’, [‘column_name’, 2]]</span></pre><p id="dab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经定义了如何处理异常值，我们可以继续我们的第四个块，它将涵盖<strong class="lb iu"> datetime </strong>特性的提取。</p><h2 id="16b1" class="ny mm it bd mn nz oa dn mr ob oc dp mv li od oe mx lm of og mz lq oh oi nb oj bi translated">[块 4 ]提取<em class="pb">日期时间</em>特征</h2><p id="98d6" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">如果我们的数据集包含一个具有<strong class="lb iu"> datetime </strong>值的特征，比如时间戳或日期，我们很可能希望提取这些值，以便在以后处理或可视化时更容易处理它们。</p><p id="b9d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以以自动化的方式来做这件事:我们将让我们的管道搜索这些特性，并检查其中的一个是否可以转换成<strong class="lb iu">日期时间</strong>类型。如果是，那么我们可以有把握地假设这个特性保存了<strong class="lb iu"> datetime </strong>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">点击查看完整源代码<a class="ae ky" href="https://github.com/elisemercury/AutoClean/blob/main/AutoClean/Modules.py" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="c58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以定义提取<strong class="lb iu">日期时间</strong>特征的粒度，而默认设置为<em class="mk">s’</em>秒。提取后，该函数检查日期和时间的条目是否有效，意思是:如果提取的列<em class="mk">、</em>、<em class="mk">、【月】、<em class="mk">、【年】、</em>、<strong class="lb iu">、</strong>都包含 0，那么这三个都将被删除。对于<em class="mk">【小时】</em><em class="mk">【分钟】</em><em class="mk">【秒】</em>也是如此。</em></p><p id="533d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了日期时间的提取，我们可以进入管道的最后一个构建模块，它将包含一些最终的调整来完善我们的输出数据帧。</p><h2 id="8c1e" class="ny mm it bd mn nz oa dn mr ob oc dp mv li od oe mx lm of og mz lq oh oi nb oj bi translated">[区块 5 ]数据框抛光</h2><p id="3321" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">现在我们已经处理了我们的数据集，我们仍然需要做一些调整，使我们的数据框架“看起来不错”。我这么说是什么意思？</p><p id="6ea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，由于应用了插补技术或其他处理步骤，一些原本属于类型<strong class="lb iu">整数</strong>的特征可能已经被转换为<strong class="lb iu">浮点数</strong>。在输出我们最终的数据帧之前，我们将<strong class="lb iu">把这些值转换回</strong> <strong class="lb iu">整数</strong>。</p><p id="8b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，我们希望将数据集中的所有<strong class="lb iu"> float </strong>要素的<strong class="lb iu">舍入到与原始输入数据集中的<strong class="lb iu">相同的小数位数</strong>。这一方面是为了避免浮点小数中不必要的尾随 0，另一方面是为了确保不要将我们的值四舍五入超过我们的原始值。</strong></p><p id="beb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mk">同样，我不会更详细地讨论这些想法背后的代码，但我邀请您查看</em> <a class="ae ky" href="https://github.com/elisemercury/AutoClean" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> AutoClean 资源库</em> </a> <em class="mk">中的完整源代码。</em></p><h1 id="44fa" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">3 |将所有内容放在一起</h1><p id="0991" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">首先，祝贺你坚持到现在！🎉</p><p id="0c1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经到了想要将所有构建模块放在一起的阶段，这样我们就可以实际开始使用我们的管道了。你可以在我的<strong class="lb iu"> GitHub 库</strong>中找到完整的<strong class="lb iu">自动清理</strong>代码，而不是在这里发布完整的代码:</p><div class="pc pd gp gr pe pf"><a href="https://github.com/elisemercury/AutoClean" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">GitHub - elisemercury/AutoClean:用于 Python 中自动数据清理的包。</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">AutoClean 为您的下一个 Python 数据科学项目自动进行预处理和清理。</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div><p id="e307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我们来看一个 AutoClean 如何处理样本数据集的可视化示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/dcd2cfa3a0d67b739831bf417bb76343.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*TdLEaURmZoah2W-bVLbqJg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本数据集。图片作者。</p></figure><p id="c90e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我生成了一个随机数据集，正如您所看到的，当涉及到不同的数据类型时，我使它变化很大，并且我在数据集中添加了一些随机的 NaN 值。</p><p id="c437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以运行自动清理脚本，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="e6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">产生的清理后的输出数据帧如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/214d26fdbef7877722dac9d7e12488de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3tMTIM8UXxJ64lQuKY9cw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">已处理的样本数据集。图片作者。</p></figure><p id="8c72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，您将看到 AutoClean 对我们的数据所做的可视化更改。估算的缺失值用<strong class="lb iu">黄色</strong>标记，异常值用<strong class="lb iu">绿色</strong>标记，提取的日期时间值用<strong class="lb iu">蓝色</strong>标记，分类编码用<strong class="lb iu">橙色</strong>标记。</p></div><div class="ab cl pw px hx py" role="separator"><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb"/></div><div class="im in io ip iq"><p id="524d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对您有所帮助，并且 AutoClean 将帮助您节省一些宝贵的时间。🚀</p><p id="275e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有任何问题或反馈，请随时发表评论。也欢迎在 GitHub 上投稿！</p></div><div class="ab cl pw px hx py" role="separator"><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb qc"/><span class="pz bw bk qa qb"/></div><div class="im in io ip iq"><h1 id="39d5" class="ml mm it bd mn mo qd mq mr ms qe mu mv jz qf ka mx kc qg kd mz kf qh kg nb nc bi translated">参考资料:</h1><p id="2dc8" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">[1] N. Tamboli，<a class="ae ky" href="https://www.analyticsvidhya.com/blog/2021/10/handling-missing-value/" rel="noopener ugc nofollow" target="_blank">所有你需要知道的关于不同类型的缺失数据值以及如何处理它</a> (2021)</p><p id="b0ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] C .泰勒，<a class="ae ky" href="https://www.thoughtco.com/what-is-the-interquartile-range-rule-3126244" rel="noopener ugc nofollow" target="_blank">什么是四分位间距规则？</a> (2018)</p><p id="df6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3] J. Brownlee，<a class="ae ky" href="https://machinelearningmastery.com/one-hot-encoding-for-categorical-data/" rel="noopener ugc nofollow" target="_blank"/>(2020)分类数据的顺序和一键编码</p></div></div>    
</body>
</html>