<html>
<head>
<title>Unit Testing with Mocking in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟后模拟单元测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/unit-testing-with-mocking-in-10-minutes-e28feb7e530#2022-06-06">https://towardsdatascience.com/unit-testing-with-mocking-in-10-minutes-e28feb7e530#2022-06-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="112b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用内置的unittest Python包有效地测试您的代码库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/45bea9b668ce85988ad077c1c23536f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WaNM5lS3GbgHLxz_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@alexkondratiev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚历克斯·康德拉蒂耶夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="e013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，单元测试通过测试预期的输出、错误或数据类型，甚至测试函数是否被调用(以及调用了多少次)，来测试单个单元或代码库的一小部分，以确保组件按预期工作。</p><p id="058c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将比较可用的不同单元测试方法、单元测试最佳实践、如何编写和运行单元测试，最后用内置断言、测试的条件跳过和模拟来增强您的单元测试。</p><p id="f10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">更新</em> </strong> <em class="lv">:本文是系列文章的一部分。查看其他“10分钟内”话题</em> <a class="ae ky" href="https://medium.com/@kayjanwong/list/in-10-minutes-eeaa9aa67055" rel="noopener"> <em class="lv">此处</em> </a> <em class="lv">！</em></p><h1 id="43fa" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">目录</h1><ol class=""><li id="d348" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#1b08" rel="noopener">单元测试生态系统</a></li><li id="db87" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#6ce7" rel="noopener">单元测试最佳实践</a></li><li id="4cc7" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#dc86" rel="noopener">单元测试的结构</a></li><li id="073c" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#cc2e" rel="noopener">运行单元测试</a></li><li id="de06" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#f11a" rel="noopener">高级:内置断言</a></li><li id="7194" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#157f" rel="noopener">高级:跳过单元测试</a></li><li id="e5ee" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/p/e28feb7e530/#292d" rel="noopener">高级:单元测试中的模拟</a></li></ol></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="1b08" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">单元测试生态系统</h1><p id="fc47" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">有几个python包可以执行单元测试和其他形式的测试，</p><ul class=""><li id="9c54" class="mo mp it lb b lc ld lf lg li nt lm nu lq nv lu nw mw mx my bi translated">测试代码覆盖率，以衡量单元测试的有效性</li><li id="345f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">doctest</strong></code>:在函数本身的docstring中测试函数的实现，但是测试用例的类型可以是有限的。在我的关于代码文档的文章<a class="ae ky" href="https://kayjanwong.medium.com/advanced-code-documentation-with-coverage-and-unit-tests-part-3-3f7b698497fb" rel="noopener">中阅读更多信息</a></li><li id="0d4c" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">mypy</strong></code>:测试函数的返回类型</li><li id="c8ea" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">pytest</strong></code>:在一个单独的文件中测试函数的实现，写在一个函数中(函数式编程)。这个python包需要安装pip</li><li id="d57b" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">unittest</strong></code>:在一个单独的文件中测试函数的实现，写在一个类中(面向对象编程)。这是一个内置的python包，不需要安装</li></ul><p id="45b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写单元测试的两个最常见的包是<code class="fe nx ny nz oa b">pytest</code>和<code class="fe nx ny nz oa b">unittest</code>。个人认为用<code class="fe nx ny nz oa b">unittest</code>写的代码比<code class="fe nx ny nz oa b">pytest</code>可读性强。然而，<code class="fe nx ny nz oa b">pytest</code>确实有它的优点，因为它需要更少的代码，因为测试是在函数而不是类中编写的。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="6ce7" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">单元测试最佳实践</h1><p id="6bc2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">无论您决定使用哪一个单元测试python包，都会强制执行一些我称之为最佳实践的约定。我将根据以下类别将它们分为强制的和推荐的最佳实践，</p><h2 id="df21" class="ob lx it bd ly oc od dn mc oe of dp mg li og oh mi lm oi oj mk lq ok ol mm om bi translated">文件夹结构(强制性最佳实践)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/e8c85871f229322c56af2b4acbd80622.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*O7cSijlyXCWRX3Z7f1CQig.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:单元测试文件夹结构——作者图片</p></figure><p id="b9c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试文件应该保存在一个<code class="fe nx ny nz oa b">tests</code>目录中，与包目录或源代码处于相同的嵌套层次，并且该目录必须是可导入的。可导入的目录(也称为python模块)非常简单，只需向文件夹中添加一个空的<code class="fe nx ny nz oa b">__init__.py</code>文件，以表明该目录是可导入的。</p><p id="5723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nx ny nz oa b">tests</code>目录中，文件夹结构应该遵循源代码或包目录的结构。</p><h2 id="f70b" class="ob lx it bd ly oc od dn mc oe of dp mg li og oh mi lm oi oj mk lq ok ol mm om bi translated">命名约定(强制性最佳实践)</h2><p id="aec8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">文件名、类名和类方法都有命名约定，</p><ul class=""><li id="1842" class="mo mp it lb b lc ld lf lg li nt lm nu lq nv lu nw mw mx my bi translated">文件名跟在snake_case后面，以<code class="fe nx ny nz oa b">test_</code>开头，并且应该跟在它正在测试的文件的名称后面(即<code class="fe nx ny nz oa b">test_module_one.py</code>是文件<code class="fe nx ny nz oa b">module_one.py</code>的单元测试文件)</li><li id="05f9" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">类名遵循PascalCase并以<code class="fe nx ny nz oa b">Test</code>(即<code class="fe nx ny nz oa b">TestFunction</code>)开头</li><li id="0856" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">类方法名跟在snake_case后面，以<code class="fe nx ny nz oa b">test_</code>(即<code class="fe nx ny nz oa b">test_scenario_one</code>)开头。</li></ul><h2 id="e4b4" class="ob lx it bd ly oc od dn mc oe of dp mg li og oh mi lm oi oj mk lq ok ol mm om bi translated">测试案例(推荐的最佳实践)</h2><p id="636e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">单元测试是基于断言的，例如断言结果等于或不等于预定义的预期输出。为了彻底测试断言，一个经过良好测试的函数应该测试</p><ul class=""><li id="efb8" class="mo mp it lb b lc ld lf lg li nt lm nu lq nv lu nw mw mx my bi translated">糟糕的论点；导致函数引发异常的参数</li><li id="c9d0" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">特殊论据；边界值，或者可以使用特殊逻辑的地方</li><li id="a75d" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">正常的争论；测试通常的情况</li><li id="080f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">测试返回值/数据类型/异常</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="dc86" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">单元测试的结构</h1><p id="4750" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">了解了最佳实践之后，让我们来看看单元测试的框架！下面是一个最简单的单元测试的例子，只有4行代码。</p><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="3db1" class="os lx it oa b be ot ou l ov ow">import unittest<br/><br/><br/>class TestFunction(unittest.TestCase):<br/>    def test_function_with_scenario_one(self):<br/>        print("Testing function with scenario one")<br/>        # assert something here<br/><br/>if __name__ == "__main__":<br/>    unittest.main()</span></pre><p id="94aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试是在继承自<code class="fe nx ny nz oa b">unittest.TestCase</code>的类中编写的；并且每个单元测试都被实现为一个类方法。当运行单元测试时(下一节将详细介绍)，它会查找所有以<code class="fe nx ny nz oa b">test</code>开头的类方法名，并按顺序运行它们。在上面的例子中，运行测试的顺序是<code class="fe nx ny nz oa b">start &gt; test_function_with_scenario_one &gt; end</code>。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="56d9" class="os lx it oa b be ot ou l ov ow">import unittest<br/><br/><br/>class TestFunction(unittest.TestCase):<br/><br/>    def setUp(self):<br/>        print("Set up...")<br/>        self.value = 1<br/><br/>    def tearDown(self):<br/>        print("Tear down...")<br/>        self.value = None<br/><br/>    def test_function_with_scenario_one(self):<br/>        print("Testing function with scenario one")<br/><br/>    def test_function_with_scenario_two(self):<br/>        print("Testing function with scenario two")</span></pre><p id="49d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，可能有一些设置应该在每个单元测试之前运行，例如，当每个单元测试都在相同的数据集或变量上执行操作时，您希望在设置每个单元测试时保持数据集或变量的一致性或减少重复。</p><p id="b4f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用在每个单元测试之前和之后运行的<code class="fe nx ny nz oa b">setUp</code>和<code class="fe nx ny nz oa b">tearDown</code>夹具。这导致执行命令<code class="fe nx ny nz oa b">start &gt; <strong class="lb iu">setUp </strong>&gt; test<strong class="lb iu"> </strong>&gt; <strong class="lb iu">tearDown</strong> &gt; <strong class="lb iu">setUp </strong>&gt; test &gt; <strong class="lb iu">tearDown </strong>&gt; end</code>。当设置单元测试时，变量可以作为类属性存储，并传递给单元测试(第8行)，这些类属性可以在拆卸期间重置为<code class="fe nx ny nz oa b">None</code>(第12行)。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="a3a4" class="os lx it oa b be ot ou l ov ow">import unittest<br/><br/>class TestFunction(unittest.TestCase):<br/><br/>    @classmethod<br/>    def setUpClass(cls):<br/>        print("Set up class...")<br/>        cls.value = 1<br/><br/>    @classmethod<br/>    def tearDownClass(cls):<br/>        print("Tear down class...")<br/>        cls.value = None<br/><br/>    def test_function_with_scenario_one(self):<br/>        print("Testing function with scenario one")<br/><br/>    def test_function_with_scenario_two(self):<br/>        print("Testing function with scenario two")</span></pre><p id="f18e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果设置代码在计算上很昂贵或者很耗时，比如连接到数据库，那么您可以实现<code class="fe nx ny nz oa b">setUpClass</code>和<code class="fe nx ny nz oa b">tearDownClass</code>fixture，它们在进入和退出类时运行一次。这导致了执行顺序<code class="fe nx ny nz oa b">start &gt; <strong class="lb iu">setUpClass </strong>&gt; test &gt; test &gt; <strong class="lb iu">tearDownClass </strong>&gt; end</code>。</p><p id="6074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面的设置和拆除实现相比，这是一个不太理想的实现，因为适当的单元测试应该独立地运行每个测试。当实现多个单元测试时，测试可能会修改类属性，只需一次设置和拆卸。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="cc2e" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">运行单元测试</h1><p id="227a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">建议在命令行终端上运行单元测试以彻底测试它，因为在控制台上运行它可能会由于<a class="ae ky" href="https://en.wikipedia.org/wiki/Variable_shadowing" rel="noopener ugc nofollow" target="_blank">变量遮蔽</a>而不完全可靠。</p><p id="e2a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在官方的<code class="fe nx ny nz oa b">unittest</code>文档中，它声明转到<code class="fe nx ny nz oa b">tests</code>目录，并根据您是分别在目录、文件、类还是类方法上运行单元测试来运行下面几行，</p><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="8be2" class="os lx it oa b be ot ou l ov ow">$ python -m unittest .<br/>$ python -m unittest test_file test_file2<br/>$ python -m unittest test_file.TestClass<br/>$ python -m unittest test_file.TestClass.test_method</span></pre><p id="04df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我发现转到<code class="fe nx ny nz oa b">tests</code>目录会弄乱我在单元测试中的导入语句，因为基目录现在是<code class="fe nx ny nz oa b">tests</code>，我不能正确地从我的包目录或源代码中导入函数。我的首选方法是转到基本项目目录并运行下面一行代码，</p><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="c8dc" class="os lx it oa b be ot ou l ov ow">$ python -m unittest discover tests/</span></pre><p id="00c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多定制可以附加到命令中，例如</p><ul class=""><li id="f616" class="mo mp it lb b lc ld lf lg li nt lm nu lq nv lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">-f</code> : fail fast，遇到第一个测试失败就停止所有单元测试</li><li id="de7a" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">-p "test_*.py"</code>:指定文件名模式，有选择地运行测试</li><li id="ed4b" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">-s start-dir</code>:指定运行测试的开始目录</li><li id="2770" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">-v</code>:添加详细度；显示控制台日志的更多信息</li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="f11a" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">高级:内置断言</h1><p id="428a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">如前所述，有许多场景需要测试(坏的、特殊的或好的输入参数),并且可以测试结果的预期输出、错误或数据类型。这些断言可以用<code class="fe nx ny nz oa b">assert</code>语句来完成，但是<code class="fe nx ny nz oa b">unittest</code>中有内置的比较器可以利用。以下是一些比较常见的比较器，完整列表可在<a class="ae ky" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="bd4a" class="ob lx it bd ly oc od dn mc oe of dp mg li og oh mi lm oi oj mk lq ok ol mm om bi translated">断言预期输出</h2><ul class=""><li id="6ed0" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu nw mw mx my bi translated">条件:<code class="fe nx ny nz oa b">self.assertTrue(condition)</code>或<code class="fe nx ny nz oa b">self.assertFalse(condition)</code></li><li id="f7f3" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">相等:<code class="fe nx ny nz oa b">self.assertEqual(a, b)</code>或<code class="fe nx ny nz oa b">self.assertNotEqual(a, b)</code></li><li id="e32f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">成员:<code class="fe nx ny nz oa b">self.assertIn(a, b)</code>或<code class="fe nx ny nz oa b">self.assertNotIn(a, b)</code></li></ul><h2 id="4f31" class="ob lx it bd ly oc od dn mc oe of dp mg li og oh mi lm oi oj mk lq ok ol mm om bi translated">断言预期误差</h2><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="c9d4" class="os lx it oa b be ot ou l ov ow">import unittest<br/><br/><br/>class TestFunction(unittest.TestCase):<br/><br/>    def test_function_raise_error(self):<br/>        self.assertRaises(ValueError, int, "a")<br/><br/>    def test_function_raise_error_with(self):<br/>        with self.assertRaises(ValueError):<br/>            int("a")</span></pre><ul class=""><li id="1f10" class="mo mp it lb b lc ld lf lg li nt lm nu lq nv lu nw mw mx my bi translated">错误:<code class="fe nx ny nz oa b">self.assertRaises(ExceptionName, function, arguments)</code>或使用如上所示的上下文管理器(第10行)</li><li id="49d7" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">警告:<code class="fe nx ny nz oa b">self.assertWarns(WarningName, function, arguments)</code></li></ul><h2 id="c6f1" class="ob lx it bd ly oc od dn mc oe of dp mg li og oh mi lm oi oj mk lq ok ol mm om bi translated">断言预期的数据类型</h2><ul class=""><li id="aaed" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu nw mw mx my bi translated">数据类型:<code class="fe nx ny nz oa b">self.assertIsInstance(a, dtype)</code>或<code class="fe nx ny nz oa b">self.assertNotIsInstance(a, dtype)</code></li><li id="a85f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">无类型:<code class="fe nx ny nz oa b">self.assertIsNone(x)</code>或<code class="fe nx ny nz oa b">self.assertIsNotNone(x)</code></li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="157f" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">高级:跳过单元测试</h1><p id="611f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">除了利用内置的比较器方法，我们还可以使用内置的装饰器来实现单元测试的条件跳过。这意味着如果不满足某个条件，可以跳过单元测试。例如，由于向后兼容性问题而跳过对旧Python版本或包版本的测试，或者由于平台不兼容而跳过对某些系统的测试。</p><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="d4ca" class="os lx it oa b be ot ou l ov ow">import sys<br/>import unittest<br/><br/><br/>class TestFunction(unittest.TestCase):<br/><br/>    @unittest.skip("Skip unit test")<br/>    def test_skipped(self):<br/>        self.fail("This should be skipped")<br/><br/>    @unittest.skipIf(sys.version_info.major &lt; 2, "Skip due to Python version")<br/>    def test_python_version(self):<br/>        print("Test is ran")<br/><br/>    @unittest.skipUnless(sys.platform.startswith("win"), "Skip unless it is Windows")<br/>    def test_python_version(self):<br/>        print("Test is ran")</span></pre><p id="1be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当运行单元测试时，它会在最后的语句中显示跳过的测试数量，比如<code class="fe nx ny nz oa b">OK (skipped=1)</code>，这样你就不必担心单元测试在你不知情的情况下被编写和跳过了！</p><h1 id="292d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">高级:单元测试中的模拟</h1><p id="bdef" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">单元测试中使用模仿来替换类方法或函数的返回值。这可能看起来违反直觉，因为单元测试应该测试类方法或函数，但是我们正在替换所有那些处理和设置预定义的输出。</p><p id="62ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟对于替换不应该在测试环境中运行的操作很有用，例如，当测试环境没有相同的数据访问时，替换连接到数据库并加载数据的操作。因此，取消处理并用预定义的数据替换输出不仅消除了可能的数据库连接错误，还增加了可预测性，因为对预定义数据进行的单元测试可以确保与您的预期输出完全匹配。</p><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="ef70" class="os lx it oa b be ot ou l ov ow">import unittest<br/>from unittest.mock import Mock<br/><br/><br/>class SampleClass:<br/>    def __init__(self):<br/>        self.value = 1<br/><br/>    def sample_method(self):<br/>        """Function that returns value 1"""<br/>        return self.value<br/><br/><br/>class TestSampleClass(unittest.TestCase):<br/><br/>    def test_mock_class(self):<br/>        class_object = SampleClass()<br/>        class_object.sample_method = Mock(return_value=2)<br/>        self.assertEqual(class_object.sample_method(), 2), "Mocking does not work"<br/><br/>    def test_mock_function(self):<br/>        sample_function = Mock(return_value=2)<br/>        self.assertEqual(sample_function(), 2), "Mocking does not work"</span></pre><p id="9837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，mocking是用<code class="fe nx ny nz oa b">return_value</code>参数实现的，用来替换类方法和函数的预期输出。我们可以看到这个类方法最初返回值<code class="fe nx ny nz oa b">1</code>，但是我用<code class="fe nx ny nz oa b">2</code>代替了返回值，并且使用了前一节提到的内置断言<code class="fe nx ny nz oa b">self.assertEqual()</code>。</p><p id="219c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，将返回值限制为一个固定的预定义输出可能会有很大的局限性。每次调用类方法或函数时，可以使用<code class="fe nx ny nz oa b">side_effect</code>参数将返回值设置为不同的输出，并传入不同的预期输出列表。<code class="fe nx ny nz oa b">side_effect</code>参数接受函数、可重复项或异常，示例如下:</p><pre class="kj kk kl km gt oo oa op bn oq or bi"><span id="328b" class="os lx it oa b be ot ou l ov ow">import unittest<br/>from unittest.mock import Mock<br/><br/><br/>class TestSampleClass(unittest.TestCase):<br/><br/>    def test_side_effect_function(self):<br/>        sample_function = Mock(side_effect=lambda x: x + 1)<br/>        self.assertEqual(class_object.sample_method(1), 2)<br/><br/>    def test_side_effect_iterable(self):<br/>        sample_function = Mock(side_effect=[1, 2, 3])<br/>        self.assertEqual(sample_function(), 1)<br/>        self.assertEqual(sample_function(), 2)<br/>        self.assertEqual(sample_function(), 3)<br/><br/>    def test_side_effect_exception(self):<br/>        sample_function = Mock(side_effect=ValueError())<br/>        with self.assertRaises(ValueError):<br/>            sample_function()</span></pre><p id="3005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz oa b">unittest.mock</code>模块中可用的项目更多，比如<code class="fe nx ny nz oa b">MagicMock</code>类似于<code class="fe nx ny nz oa b">Mock</code>但可以改变魔术方法，还有<code class="fe nx ny nz oa b">patch</code>代替整个函数而不是代替不那么直接的返回值。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="66aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您已经了解了更多关于不同类型的测试、如何编写和运行单元测试、有用的提示以及单元测试的高级实现。在生产中编写代码时，单元测试很重要；标记出代码中的意外错误，或者防止代码增强破坏代码的其他部分。</p><p id="bafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为<a class="ae ky" href="https://en.wikipedia.org/wiki/CI/CD" rel="noopener ugc nofollow" target="_blank">持续集成持续交付(CICD) </a>的一部分，单元测试应该在任何代码被推送之前以自动化的方式运行。在<a class="ae ky" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发(TDD) </a>的情况下，一些工作流可以在编写源代码之前优先编写单元测试，以考虑代码应该如何工作。</p><p id="9c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢您的阅读！如果你喜欢这篇文章，请随意分享。</strong></p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="f39a" class="lw lx it bd ly lz nl mb mc md nm mf mg jz nn ka mi kc no kd mk kf np kg mm mn bi translated">相关链接</h1><ul class=""><li id="2ecd" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">coverage.py</code>文档:<a class="ae ky" href="https://coverage.readthedocs.io/en/6.4.1/" rel="noopener ugc nofollow" target="_blank">https://coverage . readthedocs . io</a></li><li id="7e89" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">doctest</code>文件:<a class="ae ky" href="https://docs.python.org/3/library/doctest.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org</a></li><li id="3b12" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">https://mypy.readthedocs.io/en/stable/<a class="ae ky" href="https://mypy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">T2</a></li><li id="eaf9" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated"><code class="fe nx ny nz oa b">pytest</code>文件:<a class="ae ky" href="https://docs.pytest.org/en/6.2.x/contents.html" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org</a></li><li id="49e8" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu nw mw mx my bi translated">https://docs.python.org<a class="ae ky" href="https://docs.python.org" rel="noopener ugc nofollow" target="_blank">T4</a></li></ul></div></div>    
</body>
</html>