<html>
<head>
<title>Bootstrapping Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引导基础</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bootstrapping-basics-254db6635a76#2022-03-02">https://towardsdatascience.com/bootstrapping-basics-254db6635a76#2022-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="affa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">非参数重采样，已解释</h2></div><h2 id="2af7" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">r库要求</h2><ul class=""><li id="cb94" class="le lf it lg b lh li lj lk kr ll kv lm kz ln lo lp lq lr ls bi translated">并行:用于并行计算</li><li id="1e5f" class="le lf it lg b lh lt lj lu kr lv kv lw kz lx lo lp lq lr ls bi translated">ggplot2:用于数据可视化</li></ul><h1 id="4c59" class="ly kj it bd kk lz ma mb kn mc md me kq jz mf ka ku kc mg kd ky kf mh kg lc mi bi translated">一.导言</h1><p id="37c4" class="pw-post-body-paragraph mj mk it lg b lh li ju ml lj lk jx mm kr mn mo mp kv mq mr ms kz mt mu mv lo im bi translated">当估计感兴趣的统计量时，我们不仅对该统计量的点值感兴趣。我们还想量化我们估计的不确定性。对于感兴趣的标准量，如平均值或标准差，我们有采样分布的分析结果，或者可以很容易地使用大样本近似。很多时候，我们感兴趣的是那些我们不知道抽样分布的量，而且即使有可能，推导抽样分布也很困难。在这些情况下，bootstrap是量化不确定性的一个有价值的工具。</p><p id="2b85" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">在进行bootstrapping时，我们将样本视为总体。我们用替换样本重复重新采样与原始样本<em class="nb">相同数量的观察值，并计算这些样本的感兴趣的统计量。我们用替换重新取样，因为在没有替换的情况下取样时，样本是不独立的。它们也将与我们的原始样本完全匹配，这将不是很有帮助。这为我们提供了一个模拟的采样分布，我们可以用它进行分析。</em></p><h1 id="977c" class="ly kj it bd kk lz ma mb kn mc md me kq jz mf ka ku kc mg kd ky kf mh kg lc mi bi translated">二。履行</h1><p id="1102" class="pw-post-body-paragraph mj mk it lg b lh li ju ml lj lk jx mm kr mn mo mp kv mq mr ms kz mt mu mv lo im bi translated">虽然有像<a class="ae nc" href="https://cran.r-project.org/web/packages/bootstrap/bootstrap.pdf" rel="noopener ugc nofollow" target="_blank"> bootstrap </a>这样的库为我们做引导，但我发现编写轻量级函数是一个很好的学习方法，即使我在实践中使用维护良好的库。为了演示自举，我编写了两个助手函数来支持我的主自举函数，该函数利用并行化来加速计算。</p><p id="c495" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">处理每个引导样本不依赖于其他样本，因为这些样本彼此独立。这使得自举很容易并行化，这就是<strong class="lg iu"> bootstrap_parallel </strong>所做的。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="67e5" class="ki kj it ni b gy nm nn l no np">one_bootstrap &lt;- function(my_vec, my_func){<br/> ###<br/> # This function retrieves one bootstrapped sample and returns the   <br/> # statistic of interest.<br/> #<br/> # Args<br/> # ----<br/> # my_vec : numeric vector<br/> #   A vector of numbers of which to compute the statistic of <br/> #   interest.<br/> # my_func : function<br/> #   Function which computes the statistic of interest.<br/> #<br/> # Returns<br/> # -------<br/> # double<br/> #   The statistic of interest computed on the bootstrapped sample.<br/> ###<br/> bootstrapped_sample &lt;- sample(my_vec, size=length(my_vec), <br/>                               replace=TRUE)<br/> return(my_func(bootstrapped_sample))<br/>}</span><span id="ec6e" class="ki kj it ni b gy nq nn l no np">bootstrap_replicate_par &lt;- function(B, my_vec, my_func){<br/>  ###<br/>  # This function is a helper function for the parallized <br/>  # bootstrapping function. It takes in a vector whose length <br/>  # determines the number of bootstrap samples to take, a data <br/>  # vector, and a function. It utilized optimized looping.<br/>  #<br/>  # Args<br/>  # ----<br/>  # B : vector<br/>  #   A vector whose length determines of bootstrapped samples to <br/>  #   return.<br/>  # my_vec : numeric vector<br/>  #   A vector of numbers of which to compute the statistic of <br/>  #   interest.<br/>  # my_func : function<br/>  #   Function which computes the statistic of interest.<br/>  #<br/>  # Returns<br/>  # -------<br/>  # estimates : vector<br/>  #   A vector of the estimates.<br/>  ###<br/>  estimates &lt;- replicate(length(B), one_bootstrap(my_vec, my_func))<br/>  return(estimates)<br/>}</span><span id="d531" class="ki kj it ni b gy nq nn l no np">bootstrap_parallel &lt;- function(my_vec, my_func, B){<br/>  ###<br/>  # This function takes in a data vector, function, and the number <br/>  # of bootstrap iterations and returns a list holding the mean and <br/>  # standard deviation of the bootstrap estimates, as well as the <br/>  # vector of the bootstrap estimates. It utilizes parallel <br/>  # computing.<br/>  #<br/>  # Args<br/>  # ----<br/>  # my_vec : numeric vector<br/>  #   A vector of numbers of which to compute the statistic of <br/>  #   interest.<br/>  # my_func : function<br/>  #   Function which computes the statistic of interest.<br/>  # B : int<br/>  #   The number of bootstrapped samples to return.<br/>  #<br/>  # Returns<br/>  # -------<br/>  # output : list<br/>  #   A list of the mean, and standard deviation of the estimates <br/>  #   and a vector of the estimates.<br/>  ###<br/>  <br/>  # Count the cores and make a cluster from leaving one core free.<br/>  cores &lt;- detectCores()  <br/>  cluster &lt;- makeCluster(cores - 1)</span><span id="c9d8" class="ki kj it ni b gy nq nn l no np">  # Create a vector that will be split up and determine the number <br/>  # of bootstrap samples to get on each core.<br/>  boot_vec &lt;- 1:B<br/>  <br/>  # Export variables and functions to the cluster.<br/>  clusterExport(<br/>    cluster, <br/>    list("boot_vec", "one_bootstrap", "bootstrap_replicate_par", <br/>         "my_vec", "my_func"),<br/>    envir=environment()<br/>    )  </span><span id="021e" class="ki kj it ni b gy nq nn l no np">  estimates &lt;- parSapply(<br/>    cluster,<br/>    boot_vec,<br/>    FUN=bootstrap_replicate_par,<br/>    my_vec=my_vec,<br/>    my_func=my_func<br/>    )</span><span id="0d69" class="ki kj it ni b gy nq nn l no np">  stopCluster(cluster)</span><span id="9226" class="ki kj it ni b gy nq nn l no np">  output &lt;- list(<br/>    'mean' = mean(estimates),<br/>    'se' = sd(estimates),<br/>    'estimates' = estimates<br/>    )</span><span id="cba9" class="ki kj it ni b gy nq nn l no np">  return(output)<br/>}</span></pre><p id="b719" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">定义好这些函数后，我们就可以开始应用这些函数了。</p><h1 id="912e" class="ly kj it bd kk lz ma mb kn mc md me kq jz mf ka ku kc mg kd ky kf mh kg lc mi bi translated">三。具有左尾期望值的示例</h1><p id="f76f" class="pw-post-body-paragraph mj mk it lg b lh li ju ml lj lk jx mm kr mn mo mp kv mq mr ms kz mt mu mv lo im bi translated">作为演示，我们将通过bootstrap估计的统计数据是分布左尾的期望值。为了便于参考，我将它称为<strong class="lg iu"> ELT(α) </strong>，用于表示<strong class="lg iu"> α </strong>处的预期左尾。这种统计有助于估计的一个例子是<a class="ae nc" href="https://www.investopedia.com/terms/c/conditional_value_at_risk.asp" rel="noopener ugc nofollow" target="_blank">条件风险值</a>。</p><p id="16d3" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">假设我们关注的是一个随机变量，<strong class="lg iu"> X </strong>，其分布为某种连续分布。设<strong class="lg iu"> f(x) </strong>为<strong class="lg iu"> X </strong>的概率密度函数<strong class="lg iu"> q(α) </strong>为<strong class="lg iu"> X </strong>在100* <strong class="lg iu"> α </strong>百分位的分位数函数。那么我们感兴趣的数量如下所示。</p><figure class="nd ne nf ng gt ns gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/09c5db59c6e88c0b1904f9ce2a201203.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*GZH4mvW8e1G9S_616QMGsA.png"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">连续分布左尾的期望值</p></figure><p id="aa27" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">在现实世界的应用中，我们不知道<strong class="lg iu"> X </strong>的真实底层分布。我们可以找到一个合适的分布，尽管它可能很难或不可能进行解析积分。幸运的是，我们有像bootstrap这样的数字工具来帮助我们。</p><p id="39da" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">在这个演示中，我抽取了1000个<strong class="lg iu"> X </strong>的样本，其中<strong class="lg iu">X∾T(ν)</strong>和<strong class="lg iu"> ν </strong>为10.5。我制作了下面样本的直方图，并覆盖了真实密度函数，以衡量样本与基础数据的吻合程度。</p><figure class="nd ne nf ng gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi nz"><img src="../Images/7eb39ac929f59a54369b9edc13c3bc4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*hXJeJ05s9VQ8wARHMF92pw.png"/></div></div></figure><p id="0ce2" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">样本相当好地符合真实分布，所以让我们计算<strong class="lg iu"> ELT(α) </strong>。</p><p id="084e" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">我使用非参数方法，使用样本分位数来估计<strong class="lg iu"> ELT(α) </strong>。<strong class="lg iu"> ELT(α) </strong>的非参数估计如下式所示。</p><figure class="nd ne nf ng gt ns gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/aedbf51bbf1dea88edabb4f0489251c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*QDKxROidqgyfreWJW_gTfw.png"/></div><p class="nv nw gj gh gi nx ny bd b be z dk translated">左尾期望值的非参数样本估计</p></figure><p id="bddb" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">其中<strong class="lg iu"> Xi </strong>是随机变量的实现，<strong class="lg iu">qˇ(α)</strong>是<strong class="lg iu"> α </strong>处的样本分位数，<strong class="lg iu"> I </strong>是一个指示函数，如果为真则为1，如果为假则为0。</p><p id="78a2" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">在继续之前，让我们看看我们对<strong class="lg iu"> ELT(α) </strong>的样本估计，其中<strong class="lg iu"> α </strong>为0.1。是-2.063。</p><p id="b99b" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">让我们最后使用自举。我将用10，000次引导迭代来估计ELT(α)。</p><pre class="nd ne nf ng gt nh ni nj nk aw nl bi"><span id="7af2" class="ki kj it ni b gy nm nn l no np">et_est &lt;- bootstrap_parallel(rand_sample, expected_tail, B=10000)</span></pre><p id="c1de" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">下面的直方图显示了<strong class="lg iu"> ELT(α) </strong>的自举估计的分布。</p><figure class="nd ne nf ng gt ns gh gi paragraph-image"><div class="gh gi of"><img src="../Images/f2f198464a661ba7c5417fdf3d3dc467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*8xG3OLXcMYjkNPgwxAnp8w.png"/></div></figure><p id="891a" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">我们的平均估计值是-2.063，与样本估计值几乎完全相同(我四舍五入到小数点后3位)。它的标准误差为0.085。自举95% CI为-2.232至-1.906。我们可以95%确信<strong class="lg iu"> ELT(0.1) </strong>在-2.232到-1.906之间。</p><p id="7b55" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">我们已经成功地使用自举来估计一个量，并量化我们对该估计的不确定性！</p><p id="c274" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">我希望这已经阐明了什么是自举以及如何应用它。感谢阅读！</p><p id="9cf5" class="pw-post-body-paragraph mj mk it lg b lh mw ju ml lj mx jx mm kr my mo mp kv mz mr ms kz na mu mv lo im bi translated">注:所有图片均由作者(我)生成</p></div></div>    
</body>
</html>