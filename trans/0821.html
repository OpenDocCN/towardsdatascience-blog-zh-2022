<html>
<head>
<title>How to Make a Treemap in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用 Python 制作树形图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/make-a-treemap-in-python-426cee6ee9b8#2022-03-07">https://towardsdatascience.com/make-a-treemap-in-python-426cee6ee9b8#2022-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b40e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Plotly 制作一个带有滑块的树形图来调整深度</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bd3ba771ef4812670c95d0c3e55d711b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4J4h7Jm-yPojPTUY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完整的最终树形图—滚动到底部进行交互式可视化(图片由作者提供)</p></figure><p id="27e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">简介</strong></p><p id="e389" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">树形图是一种用于显示分层数据的可视化方式。传统的树形图由嵌套的矩形组成，然而，也有由嵌套的圆形组成的圆形树形图。总的来说，任何适合嵌套的形状都可以使用。树形图最适合用来显示与其父节点大小成比例的节点。</p><p id="7016" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">数据集</strong></p><p id="e44d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正在使用的数据集是 flare.json，它包含有关 flare 类的分层数据。该数据包含每个节点的名称、子节点以及每个节点的值，这些值将用作树图中节点的大小。</p><p id="a3d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里下载:<a class="ae lr" href="https://github.com/kruthik109/Data-Visualization/blob/main/Advanced-Visualizations/flare.json" rel="noopener ugc nofollow" target="_blank">https://github . com/kruthik 109/Data-Visualization/blob/main/Advanced-Visualizations/flare . JSON</a>(博斯托克，2021)</p><p id="73f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">系统要求</strong></p><p id="d1d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文中的 treemap 将使用 Python 中的 Plotly 库构建，因为它易于使用，并且能够添加交互式功能，如控制深度的滑块和工具提示。需要的库是 json、anytree、ipywidgetsm、plotly 和 pandas 库。我使用 Google Colab 来实现我的可视化，因为它简化了库导入过程。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="7fb7" class="lx ly iq lt b gy lz ma l mb mc">import json<br/>!pip install anytree<br/>from anytree import PostOrderIter<br/>from anytree.importer import DictImporter<br/>import ipywidgets as widgets<br/>import plotly.graph_objs as go<br/>import pandas as pd</span></pre><p id="67f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一步:导入数据</strong></p><p id="b411" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据被格式化为 JSON 文件。为了便于使用，用 JSON 库导入文件。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="79f7" class="lx ly iq lt b gy lz ma l mb mc">with open(‘flare.json’) as f:<br/>   js_data = json.loads(f.read())</span></pre><p id="76ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JSON 格式很难处理，所以使用 anytree 库中的 DictImporter 来简化这个过程。该库通过直接访问子节点、父节点和遍历命令，以与树相同的方式转换要访问的数据。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b655" class="lx ly iq lt b gy lz ma l mb mc">#imports dictionary in a tree form<br/>importer = DictImporter()<br/>root = importer.import_(js_data)</span></pre><p id="1ed2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤 2:计算所有节点的大小</strong></p><p id="a5fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 flare 数据中，只有叶节点附有值。要获得每个节点的大小，请将每个对应叶节点的值相加。下面的递归算法使用 DFS 的一种改变形式，它从叶节点开始，递归地将子节点值添加到父节点。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="aef1" class="lx ly iq lt b gy lz ma l mb mc">def format(node):<br/>   for i in node.children:</span><span id="e8d0" class="lx ly iq lt b gy md ma l mb mc">      #check if node as attribute value<br/>      if hasattr(i, ‘value’) == False:<br/>          format(i)</span><span id="1b22" class="lx ly iq lt b gy md ma l mb mc">      #check if node parent as attribute value<br/>      if hasattr(i.parent, ‘value’):<br/>         i.parent.value += i.value</span><span id="1230" class="lx ly iq lt b gy md ma l mb mc">      #if node parent doesn’t have a value set to same val as child<br/>      elif hasattr(i.parent, ‘value’)== False:<br/>         i.parent.value = i.value</span><span id="abc7" class="lx ly iq lt b gy md ma l mb mc">      #insert step 3 code here</span><span id="c2cf" class="lx ly iq lt b gy md ma l mb mc">format(root)</span></pre><p id="a9f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第三步:树形图的格式参数</strong></p><p id="8188" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了在 Plotly 中制作树形图，所使用的参数必须是列表或数据帧格式。在下面的代码中，创建了三个列表，一个用于大小、名称、父节点和级别，这将在步骤 5 中进一步讨论。这段代码将被插入到格式函数的末尾</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2d62" class="lx ly iq lt b gy lz ma l mb mc">size = []<br/>name = []<br/>parent = []<br/>level = []</span><span id="9c73" class="lx ly iq lt b gy md ma l mb mc">#append parent to parent list<br/>parent.append(i.parent.name)<br/>#append node name to name list<br/>name.append(i.name)<br/>#append node size to size list<br/>size.append(c)<br/>#get the level of each node by taking the length of its ancestors<br/>#used for step 5<br/>level.append(len(i.ancestors))</span></pre><p id="81cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在 format 函数中，根节点的数据不会被追加到列表中，因为它不是子节点，所以我们在 format 函数之外添加这些值。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="12fb" class="lx ly iq lt b gy lz ma l mb mc">#append attributes for root<br/>level.append(0)<br/>name.append(root.name)<br/>parent.append(“”)<br/>size.append(root.value)</span></pre><p id="1007" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第四步:创建树形图</strong></p><p id="9e11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用上面的列表，创建树形图。Plotly 中的 treemap 函数有两个必需的参数，即标签和双亲。标签列表对应于为每个节点显示的文本。父列表用于确定当前节点将嵌套在哪个节点中。值列表是可选的，用于为每个节点指定大小。尺寸列表包含每个节点的尺寸，如果没有给出，尺寸将由 Plotly 自动确定。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="b00e" class="lx ly iq lt b gy lz ma l mb mc">#create plotly figure<br/>fig = plotly.graph_objs.Figure()<br/>fig.add_trace(plotly.graph_objs.Treemap(<br/>   labels = name,<br/>   parents = parent,<br/>   values = size<br/>))</span><span id="7d8b" class="lx ly iq lt b gy md ma l mb mc">#show figure<br/>fig.show()</span></pre><p id="ce42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第五步:添加滑块(可选)</strong></p><p id="02c0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Plotly 中的树形图有许多级别，根据数据的深度和复杂性，树形图可能会变得难以解释。这个问题的解决方案是添加一个滑块，这将允许用户控制可视化中显示的深度以提高可读性。上面创建的代码，加上一些额外的东西，可以很容易地修改成包含一个滑块。</p><p id="aa52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤 5a:创建深度参数</strong></p><p id="5bfa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，如第四步所示，确定每个节点深度的 level 参数将用于控制滑块改变时显示哪些节点。anytree 库提供的 node.ancestor 功能简化了这个过程。如果使用 Python 中的传统节点类，可以进行遍历来计算每个节点的祖先的数量。</p><p id="0e4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤 5b:用参数</strong>创建数据帧</p><p id="47c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二步是创建一个数据框，将第三步中创建的列表作为列。这是下一步创建新的树形图所需要的。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8b6c" class="lx ly iq lt b gy lz ma l mb mc">#create DataFrame<br/>df = pd.DataFrame()<br/>df[‘parent’] = parent<br/>df[‘name’] = name<br/>df[‘value’]= size<br/>df[‘level’] = level</span></pre><p id="018d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤 5c:用滑块值创建树形图的函数</strong></p><p id="b2bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用第四步中创建的 DataFrame，创建一个函数来创建树形图和滑块。除了使用数据框中的列而不是列表之外，树状图的制作方式与第四步中的类似。使用一个简单的 DataFrame filter 命令将滑块合并到树形图中。第一个文件服务器正在检查该级别中的哪些节点小于当前滑块值。第二个过滤器是相应列的名称。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="cddf" class="lx ly iq lt b gy lz ma l mb mc">#create figure and slider<br/>def update(sliderVal):<br/>   fig = plotly.graph_objs.Figure()<br/>   fig.add_trace(plotly.graph_objs.Treemap(<br/>      labels = df[df[‘level’]&lt;sliderVal][‘name’],<br/>      values = df[df[‘level’]&lt;sliderVal][‘value’],<br/>      parents = df[df[‘level’]&lt;sliderVal][‘parent’]</span><span id="cd46" class="lx ly iq lt b gy md ma l mb mc">))</span></pre><p id="8081" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将根部颜色更新为浅灰色，以提高清晰度，因为原始颜色是白色。然后调整节点大小，使其与带有 branchvalues 的父节点成比例。更改布局以适应所需的空间。我把高度和宽度调整为 900 乘 900。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="3a48" class="lx ly iq lt b gy lz ma l mb mc">fig.update_traces(root_color=”#f1f1f1", branchvalues =’total’, width = 900, height = 900)</span></pre><p id="a970" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显示调整后的图。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="de2f" class="lx ly iq lt b gy lz ma l mb mc">fig.show()</span></pre><p id="3dd7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">步骤 5d:创建 Widget 并连接更新功能</strong></p><p id="6a54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将微件连接到更新功能，并将滑块的范围从最小深度设置为最大深度。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6d28" class="lx ly iq lt b gy lz ma l mb mc">widgets.interact(update, sliderVal = (0, 5))</span></pre><p id="cf39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">最终输出</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="me mf l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者可视化</p></figure><p id="c572" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将鼠标悬停在上面可视化效果中的节点上，以查看它们的值。单击一个节点以放大并查看其子节点的更详细视图。使用滑块控制要在可视化中显示的节点深度。目前，滑块处于最大值，因此向下滑动将减少细节。</p><p id="d0df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">结论</strong></p><p id="5fb4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用 Plotly 制作的树形图可以清晰地显示分层数据。查看者能够看到节点与其父节点成比例的大小，这对于比较非常有用。树形图只是可用于分层数据的一种可视化形式。请继续关注我的下一篇文章，我将讨论更多类型的分层数据可视化。</p><p id="2662" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整代码可以在这里找到:<a class="ae lr" href="https://github.com/kruthik109/Data-Visualization/blob/main/Advanced-Visualizations/enclosure_diagram.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/kruthik 109/Data-Visualization/blob/main/Advanced-Visualizations/enclosure _ diagram . ipynb</a></p><p id="112d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">引文</strong></p><p id="a7af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">博斯托克，M. (2021，10 月 27 日)。具有 Flare 类层次结构的 JSON 文件。<a class="ae lr" href="https://gist.github.com/mbostock/1044242#file-readme-flare-imports-json." rel="noopener ugc nofollow" target="_blank">https://gist . github . com/MBO stock/1044242 # file-readme-flare-imports-JSON。许可证:gpl-3.0</a></p></div></div>    
</body>
</html>