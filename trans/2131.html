<html>
<head>
<title>Introduction to Simulation with SimPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SimPy仿真简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-simulation-with-simpy-e27cd7b1ff47#2022-05-12">https://towardsdatascience.com/introduction-to-simulation-with-simpy-e27cd7b1ff47#2022-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8200" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">第5部分:模拟实验的顺序抽样程序</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/905734aea9b30f648f2689756a254abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DZQDRrgy54WkPsMc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@clayton_cardinalli?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克莱顿·卡迪纳利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c06e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是一系列文章中的第五篇，介绍使用<strong class="lb iu"> SimPy </strong>框架的<strong class="lb iu">离散事件模拟</strong>技术的概念和方法。</p><p id="075b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8e7187c6eb82">第4篇</a>中，我们根据指定每次运行长度的预定义事件的发生来区分终止和非终止模拟。此外，在同一篇文章中，我们开始分析模拟研究的输出数据。</p><p id="10cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟技术通常用于评估物理上不存在的系统的性能，或者当希望知道存在的系统中的变化的影响但不需要在现实中执行它们时。</p><p id="08db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，建立被研究系统的数学和/或逻辑<strong class="lb iu">模型</strong>并<strong class="lb iu">进行实验</strong>，直到对系统行为有足够的了解来解决之前建立的业务问题。</p><p id="ad07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些实验被设计为<strong class="lb iu">统计实验</strong>。通常总结模拟实验输出数据的方式是用<a class="ae ky" href="https://en.wikipedia.org/wiki/Confidence_interval" rel="noopener ugc nofollow" target="_blank">置信区间(<strong class="lb iu"> CIs </strong> ) </a>。在<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8e7187c6eb82">第4篇</a>中，我们开发了<strong class="lb iu"> </strong>用于终止模拟的输出数据分析，使用名为<strong class="lb iu">固定样本量程序</strong>的程序计算置信区间。这种方法避免了输出数据的一些统计问题，但是分析员不能控制置信区间的宽度。</p><p id="95ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，有一个名为<strong class="lb iu">顺序采样</strong>的程序，它允许分析师<strong class="lb iu">获得一个具有预定精度水平的置信区间。</strong></p><p id="23d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第五篇文章中，我们将使用与第四篇文章相同的示例来开发顺序过程，比较结果并指出两个过程的优缺点。</p><h1 id="72de" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">绝对精度与相对精度</strong></h1><p id="d21b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在许多模拟研究中，常见的操作模式包括对模型进行编码，并进行任意长度的<strong class="lb iu">单次模拟运行</strong>。从该运行中获得的性能度量被视为所研究模型的相应真实估计。</p><p id="7721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一过程是不正确的，因为我们使用从特定概率分布中得出的随机样本(特定的种子值)来浏览我们的模拟模型。我们获得了我们的绩效评估，但是<strong class="lb iu">它们可能有很大的差异</strong>。</p><p id="d077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了减少与单次运行相关的方差，相同的模型被运行多次，并且连续的结果被平均以获得点估计量，<strong class="lb iu"><em class="ms">【Xk】</em></strong>。然后，根据图1所示的公式构建该点周围的<strong class="lb iu">置信区间</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/91898d4c85926af42d312ddd203dfa09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*jthBkij_ze_-Umv5ejsXew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:置信区间。</p></figure><p id="7a3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="ms"> k </em>为运行次数，<em class="ms"> tη，k1</em>为自由度为<em class="ms">k1</em>的t分布的<em class="ms"> (1 + η)/2 </em>分位数，<em class="ms"> S </em> ₖ <em class="ms"> </em>为样本方差。</p><p id="c37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">性能指标估计的<strong class="lb iu">精度</strong>习惯上是指置信区间的半宽度。它由图2所示的等式描述:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/9156b4a802cc38e35967b5f709f37f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*DdVSh4N4wBMSLkOcuWmgtw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:置信区间的半宽度。</p></figure><p id="97f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ms"> Xk </em> </strong> <em class="ms"> </em>的精度可能是<strong class="lb iu">绝对或相对</strong>。</p><p id="2c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对X的估计是这样的<em class="ms">│</em><strong class="lb iu"><em class="ms">Xk</em></strong><em class="ms">——│=图</em>，<strong class="lb iu"> <em class="ms"> Xk </em> </strong>有一个<strong class="lb iu">绝对误差<em class="ms">图</em>(绝对精度)。</strong></p><p id="6a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对X的估计是这样的:Xk<em class="ms">│</em><strong class="lb iu"><em class="ms">Xk</em></strong><em class="ms">——│/││=γ</em>，<strong class="lb iu"> <em class="ms"> Xk </em> </strong>有一个γ的<strong class="lb iu">相对误差</strong>(相对精度)。</p><p id="0b9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中<em class="ms"> </em>为总体均值【1】。</p><p id="10b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8e7187c6eb82">第4篇</a>中，我们指出固定样本程序有一个严重的缺点，因为分析员无法控制IC的宽度；所以他无法控制估算的精度。因此，如果模拟运行产生的置信区间的半宽度必须强制满足分析师的精度要求，我们必须使用<strong class="lb iu">顺序程序</strong>。</p><h1 id="bef0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">顺序程序</strong></h1><p id="488e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">该程序假设X1，X2，…..Xk是来自模拟的一系列<em class="ms"> k </em>独立且同分布(<strong class="lb iu"> IID </strong>)的样本(性能测量)。该程序的目的是获得<em class="ms">T5的估计值和置信水平为100(1 — <em class="ms"> η </em>)的置信区间，绝对精度为<em class="ms"/>。</em></p><p id="4c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绝对精度的程序如下:</p><p id="4208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.为置信度选择一个值<em class="ms"> η </em>(习惯上为90%或95%)。</p><p id="6f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.选择一个值<em class="ms">和</em>作为特定性能测量和特定研究的精度要求。</p><p id="2478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.进行k₀模拟的初始复制，并设置k = k₀.</p><p id="99a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.根据图2所示的公式计算点估计值和置信区间的半宽度。</p><p id="80f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.如果HWn，k &gt; <em class="ms">，</em>用k+1替换k，再运行一次模拟，然后返回步骤4。</p><p id="ff5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.当HWn，k &lt;=<em class="ms">时，</em>停止，<em class="ms"> </em>使用<strong class="lb iu"> <em class="ms"> Xk </em> </strong>作为点估计量，根据图1计算最终置信区间。</p><p id="320f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，对于相对精度和实际相对误差<em class="ms"> γ </em>，我们必须在步骤5和6中计算“调整后的”相对误差[1]:</p><p id="2e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> HWn，k &lt; = <em class="ms"> γ' </em>，其中<em class="ms"> γ'= γ/(1+ γ) </em> </strong> [1]。</p><h1 id="c44d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">用SimPy进行模拟</strong></h1><p id="8b26" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-8e7187c6eb82">第4篇</a>中，我们用SimPy模拟了一个专门生产艺术品的工作车间。工件到达车间的速度服从泊松分布，平均速度为每10小时1个工件。该车间有两个工作站，每台机器一名操作员，所有工作都需要在这两种类型的机器上进行处理。假设每个工作站的加工时间分别为7和5的指数分布。这家商店按照先进先出(FIFO)的原则安排工作。</p><p id="7981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第4篇文章中，我们使用固定样本程序计算了一些性能指标的置信区间。在本文中，我们将使用上述顺序程序计算<strong class="lb iu">一个具有绝对精度的特定性能指标</strong>。</p><p id="47da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下:</p><p id="d6d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先我们导入了以下库:Pandas、Numpy、SimPy、SciPy和Matplotlib。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6925" class="na lw it mw b gy nb nc l nd ne">import pandas as pd<br/>import numpy  as np<br/>from numpy.random import RandomState</span><span id="4b49" class="na lw it mw b gy nf nc l nd ne">import simpy<br/>from scipy import stats<br/>import matplotlib.pyplot as plt</span></pre><p id="508d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包括一个初始化模块来指示任务到达率、表征处理时间的指数分布的参数以及工作站的数量。数据帧<em class="ms"> df </em>将用于存储中间结果。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="9114" class="na lw it mw b gy nb nc l nd ne"># initialization module<br/># Unit of time = hours</span><span id="77d4" class="na lw it mw b gy nf nc l nd ne">JOBS_ARRIVAL_RATE  = 1/10</span><span id="8546" class="na lw it mw b gy nf nc l nd ne">WORK_STATION1_MEAN = 7<br/>WORK_STATION2_MEAN = 5</span><span id="8f6f" class="na lw it mw b gy nf nc l nd ne">NUMBER_WORK_STATION1 = 1<br/>NUMBER_WORK_STATION2 = 1</span><span id="f403" class="na lw it mw b gy nf nc l nd ne">column_labels = ["Delay WK1","Delay WK2","Util. WK1",<br/>                 "Util. WK2", "Avg Length WK1"]</span><span id="2c1b" class="na lw it mw b gy nf nc l nd ne">df = pd.DataFrame(columns=column_labels)</span></pre><p id="ca9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作业的到达和处理用两个<a class="ae ky" href="https://docs.python.org/3/reference/expressions.html#yieldexpr" rel="noopener ugc nofollow" target="_blank">生成器函数</a> : 1) <em class="ms"> generate_jobs建模；</em> 2) <em class="ms">流程_岗位。</em>我们在打印语句中放了一些##字符，因为我们只将它们用于<a class="ae ky" href="https://en.wikipedia.org/wiki/Verification_and_validation_of_computer_simulation_models" rel="noopener ugc nofollow" target="_blank">验证目的</a>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0cb8" class="na lw it mw b gy nb nc l nd ne">def generate_jobs(env, arrival_stream, arrival_rate, <br/>                  inital_delay = 0,<br/>                  stoptime = simpy.core.Infinity, <br/>                  prng = RandomState(0)):</span><span id="4b8e" class="na lw it mw b gy nf nc l nd ne">    number_of_job = 0<br/>    yield env.timeout(inital_delay)     #Yield the initial delay</span><span id="2051" class="na lw it mw b gy nf nc l nd ne">    while (env.now &lt;stoptime):<br/>        inter_arrival_time = prng.exponential(1.0 / arrival_rate)<br/>        los_station1 = prng.exponential(WORK_STATION1_MEAN)<br/>        los_station2 = prng.exponential(WORK_STATION2_MEAN)</span><span id="ae43" class="na lw it mw b gy nf nc l nd ne">        number_of_job += 1<br/>        jobpr = process_jobs(env, <br/>           'Job number: {}'.format(number_of_job), number_of_job,<br/>            los_st1 = los_station1, los_st2 = los_station2)</span><span id="1665" class="na lw it mw b gy nf nc l nd ne">        env.process(jobpr)<br/>        yield env.timeout(inter_arrival_time)</span><span id="7e56" class="na lw it mw b gy nf nc l nd ne">#.................................................................<br/>def process_jobs(env, number_of_job, job_number, los_st1, los_st2):</span><span id="4a16" class="na lw it mw b gy nf nc l nd ne">    # First Workstation<br/>    ##print("{} is scheduled for workstation 1 <br/>            at hour {:.4f}".format(number_of_job, env.now))</span><span id="d42b" class="na lw it mw b gy nf nc l nd ne">    workstation1_schedule_list.append(job_number)<br/>    time_workstation1_schedule_list.append(env.now)</span><span id="900e" class="na lw it mw b gy nf nc l nd ne">    jobwk1_request = work_station1.request()<br/>    workstation1_length_list.append(len(work_station1.queue))<br/>    workstation1_timeth_list.append(env.now)</span><span id="3d90" class="na lw it mw b gy nf nc l nd ne">    yield jobwk1_request<br/>    ##print("{} enters to workstation 1 <br/>            at hour  {:.4f}".format(job_number, env.now))</span><span id="c1ec" class="na lw it mw b gy nf nc l nd ne">    workstation1_operation_list.append(job_number)<br/>    time_workstation1_operation_list.append(env.now)<br/>    workstation1_length_list.append(len(work_station1.queue))<br/>    workstation1_timeth_list.append(env.now)</span><span id="f03b" class="na lw it mw b gy nf nc l nd ne">    ##if (env.now &gt; jobwk1_request_time):<br/>        ##print("{} has to wait {:.4f} hours".format(job_number, <br/>                env.now - jobwk1_request_time))</span><span id="b9b6" class="na lw it mw b gy nf nc l nd ne">    yield env.timeout(los_st1)<br/>    work_station1.release(jobwk1_request)<br/>    workstation1_release_list.append(job_number)<br/>    time_workstation1_release_list.append(env.now)</span><span id="46db" class="na lw it mw b gy nf nc l nd ne"># Second Workstation<br/>    ##print("{} is scheduled for workstation 2 at hour <br/>            {:.4f}".format(job_number, env.now))</span><span id="c122" class="na lw it mw b gy nf nc l nd ne">    workstation2_schedule_list.append(job_number)<br/>    time_workstation2_schedule_list.append(env.now)</span><span id="fb0e" class="na lw it mw b gy nf nc l nd ne">    jobwk2_request = work_station2.request()<br/>    yield jobwk2_request</span><span id="9c0f" class="na lw it mw b gy nf nc l nd ne">    ##print("{} enters to workstation 2 at hour  <br/>            {:.4f}".format(job_number, env.now))</span><span id="1199" class="na lw it mw b gy nf nc l nd ne">    workstation2_operation_list.append(job_number)<br/>    time_workstation2_operation_list.append(env.now)</span><span id="969f" class="na lw it mw b gy nf nc l nd ne">    ##if (env.now &gt; jobwk2_request_time):<br/>      ##print("{} has to wait {:.4f} hours".format(job_number, <br/>              env.now-jobwk2_request_time))</span><span id="e115" class="na lw it mw b gy nf nc l nd ne">    yield env.timeout(los_st2)<br/>    work_station2.release(jobwk2_request)<br/>    workstation2_release_list.append(job_number)<br/>    time_workstation2_release_list.append(env.now)</span></pre><p id="420b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<em class="ms"> calc_measures() </em>允许我们计算性能的模型度量:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="886e" class="na lw it mw b gy nb nc l nd ne">def calc_measures():</span><span id="a578" class="na lw it mw b gy nf nc l nd ne">   # Construct dataframes prior to calculations</span><span id="26f2" class="na lw it mw b gy nf nc l nd ne">   df_wk1_schdl['Job Number']   = workstation1_schedule_list<br/>   df_wk1_schdl['Job Time Sc1'] = time_workstation1_schedule_list<br/>   df_wk2_schdl['Job Number']   = workstation2_schedule_list<br/>   df_wk2_schdl['Job Time Sc2'] = time_workstation2_schedule_list</span><span id="a3ca" class="na lw it mw b gy nf nc l nd ne">   df_wk1_opert['Job Number']   = workstation1_operation_list<br/>   df_wk1_opert['Job Time Op1'] = time_workstation1_operation_list <br/>   df_wk2_opert['Job Number']   = workstation2_operation_list<br/>   df_wk2_opert['Job Time Op2'] = time_workstation2_operation_list</span><span id="4564" class="na lw it mw b gy nf nc l nd ne">   df_wk1_reles['Job Number']   = workstation1_release_list<br/>   df_wk1_reles['Job Time Rl1'] = time_workstation1_release_list<br/>   df_wk2_reles['Job Number']   = workstation2_release_list<br/>   df_wk2_reles['Job Time Rl2'] = time_workstation2_release_list</span><span id="dbb9" class="na lw it mw b gy nf nc l nd ne">   df_merge = pd.merge(df_wk1_schdl, df_wk1_opert, on='Job Number', how='left')<br/>   df_merge = pd.merge(df_merge,     df_wk1_reles, on='Job Number', how='left')<br/>   df_merge = pd.merge(df_merge,     df_wk2_schdl, on='Job Number', how='left')<br/>   df_merge = pd.merge(df_merge,     df_wk2_opert, on='Job Number', how='left')<br/>   df_merge = pd.merge(df_merge,     df_wk2_reles, on='Job Number', how='left')</span><span id="ac77" class="na lw it mw b gy nf nc l nd ne">#.......................................<br/># Computing measures of performance<br/># Average Delay in Queues</span><span id="eef7" class="na lw it mw b gy nf nc l nd ne">   df_merge['Delay Wk1'] = df_merge['Job Time Op1'] - df_merge['Job Time Sc1']<br/>   df_merge['Delay Wk2'] = df_merge['Job Time Op2'] - df_merge['Job Time Sc2']<br/>    mean_delay_wk1 = df_merge['Delay Wk1'].mean()<br/>    mean_delay_wk2 = df_merge['Delay Wk2'].mean()</span><span id="4174" class="na lw it mw b gy nf nc l nd ne">    print('  ')<br/>    print('Measures of Performance for Run: %1d' %(run+1) )<br/>    print(' ')<br/>    print('The average delay in queue for workstation 1 is %.2f hours'  % (mean_delay_wk1))</span><span id="ea4c" class="na lw it mw b gy nf nc l nd ne">    print('The average delay in queue for workstation 2 is %.2f hours'  % (mean_delay_wk2))</span><span id="4701" class="na lw it mw b gy nf nc l nd ne">#............................................<br/># Utilization of the Servers<br/>    for i in range(0, len(df_merge)-1):</span><span id="e559" class="na lw it mw b gy nf nc l nd ne">         workstation1_utilization_list.append(df_merge['Job Time Op1'][i+1] - df_merge['Job Time Rl1'][i])<br/>         workstation2_utilization_list.append(df_merge['Job Time Op2'][i+1] - df_merge['Job Time Rl2'][i])</span><span id="5af5" class="na lw it mw b gy nf nc l nd ne">    wk2_sum_idle = np.nansum(workstation2_utilization_list)<br/>    utilization_wk1 = round((1 - wk1_sum_idle / stop_arrivals) * 100, 2)<br/>    utilization_wk2 = round((1 - wk2_sum_idle / stop_arrivals) * 100, 2)</span><span id="abed" class="na lw it mw b gy nf nc l nd ne">    print(' ')<br/>    print('The utilization of the workstation 1 is %.2f%%'  % (utilization_wk1))<br/>    print('The utilization of the workstation 2 is %.2f%%'  % (utilization_wk2))<br/>#...............................................<br/># Time weighted average of the queue length</span><span id="0d75" class="na lw it mw b gy nf nc l nd ne">    df_l1 = pd.DataFrame(workstation1_length_list, <br/>                         columns = ['len'])<br/>    df_t1 = pd.DataFrame(workstation1_timeth_list,<br/>                         columns = ['time'])<br/>    df_qlength1 = pd.concat([df_l1, df_t1], axis = 1)</span><span id="36ed" class="na lw it mw b gy nf nc l nd ne"># use the next row to figure out how long the queue was at that length<br/>    df_qlength1['delta_time'] = df_qlength1['time'].shift(-1) - df_qlength1['time']</span><span id="e74e" class="na lw it mw b gy nf nc l nd ne"># drop the last row because it would have an infinite time span<br/>    df_qlength1 = df_qlength1[0:-1]<br/>    len_avg_wk1 = np.average(df_qlength1['len'],<br/>                             weights = df_qlength1['delta_time'])</span><span id="30e0" class="na lw it mw b gy nf nc l nd ne">    print(' ')<br/>    print('The time weighted length of the workstation 1 is %.2f'  % (len_avg_wk1))<br/>#.....................................................<br/># list and dataframe for final output</span><span id="fc74" class="na lw it mw b gy nf nc l nd ne">    listoflists = []<br/>    listoflists.append(round(mean_delay_wk1,2))<br/>    listoflists.append(round(mean_delay_wk2,2))<br/>    listoflists.append(utilization_wk1)<br/>    listoflists.append(utilization_wk2)<br/>    listoflists.append(round(len_avg_wk1,2))</span><span id="46da" class="na lw it mw b gy nf nc l nd ne">    df.loc[len(df)] = listoflists</span></pre><p id="1c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，描述用于计算置信区间的函数(<em class="ms"> calc_ICs() </em>)。当所选性能测量的置信区间的半宽度小于先前定义的绝对精度时，我们将布尔变量(<em class="ms"> l_end </em>)设置为<em class="ms"> True </em>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5d62" class="na lw it mw b gy nb nc l nd ne">def calc_ICs():</span><span id="3433" class="na lw it mw b gy nf nc l nd ne">    ## confidence intervals<br/>    ## define 3 global variables<br/>    global df_output, hwic, l_end</span><span id="29a3" class="na lw it mw b gy nf nc l nd ne">    mean = round(df.mean(),2)<br/>    sigma= round(df.std(ddof=1),2)<br/>    dof  = len(df) -1</span><span id="a570" class="na lw it mw b gy nf nc l nd ne">    t_crit = np.abs(stats.t.ppf((1-confidence)/2,dof))<br/>    inf, sup = (mean-sigma*t_crit/np.sqrt(len(df)),    <br/>                mean+sigma*t_crit/np.sqrt(len(df)))</span><span id="aab6" class="na lw it mw b gy nf nc l nd ne">    inf = round(inf,2)<br/>    sup = round(sup,2)<br/>    hwic= (sup-inf)/2</span><span id="4699" class="na lw it mw b gy nf nc l nd ne">    if hwic[0] &lt;= abs_err_delay_wk1:<br/>        l_end = True</span><span id="4172" class="na lw it mw b gy nf nc l nd ne">    print('')<br/>    print(round(hwic[0],2),abs_err_delay_wk1, l_end )  <br/>    df_output = pd.concat([mean, sigma, inf, sup], axis=1)<br/>    print(df_output)</span></pre><p id="327d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写了函数<em class="ms"> print_output() </em>来显示最近20次独立运行的性能度量，并打印输出数据表，显示每个性能度量的样本均值、样本标准差以及CIs的<strong class="lb iu">下限和上限</strong>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8de9" class="na lw it mw b gy nb nc l nd ne">def print_output(): </span><span id="7663" class="na lw it mw b gy nf nc l nd ne">    # Table showing measures of performance <br/>      for the last 20 independent runs</span><span id="232a" class="na lw it mw b gy nf nc l nd ne">     df_last_20 = df.tail(20)<br/>     row_labels = ['Run' + str(i+1) for i in range(run+1-20, run+1)]</span><span id="19ac" class="na lw it mw b gy nf nc l nd ne">     fig, ax = plt.subplots(1,1)<br/>     ax.axis('tight')<br/>     ax.axis('off')</span><span id="fde3" class="na lw it mw b gy nf nc l nd ne">     runs_table = ax.table(cellText = df_last_20.values,<br/>                  colLabels = df.columns, rowLabels = row_labels,   <br/>                  rowColours =["skyblue"]*(20),<br/>                  colColours =["cyan"]*5,<br/>                  cellLoc='center', loc="center")</span><span id="c0bd" class="na lw it mw b gy nf nc l nd ne">     ax.set_title("Measures of Performance", <br/>                   fontsize=18, y= 1.2 , pad = 4)</span><span id="a392" class="na lw it mw b gy nf nc l nd ne">     runs_table.auto_set_font_size(False)<br/>     runs_table.set_fontsize(8)<br/>     plt.savefig(your_path +'twoWKs_perf_measures.png',<br/>                 bbox_inches='tight', dpi=150)<br/>     plt.show()<br/>#.....................................................</span><span id="5f65" class="na lw it mw b gy nf nc l nd ne">    ## Output Data Table<br/>    col_labels = ["Mean", "Std. Dev.", "Lower bound", "Upper Bound"]</span><span id="9d18" class="na lw it mw b gy nf nc l nd ne">    row_labels = ["Delay WK1 (h)","Delay WK2 (h)",<br/>                  "Util. WK1 (%)","Util. WK2 (%)","Avg Length WK1"]</span><span id="58a7" class="na lw it mw b gy nf nc l nd ne">    fig, ax = plt.subplots(1,1)<br/>    ax.axis('tight')<br/>    ax.axis('off')</span><span id="3efd" class="na lw it mw b gy nf nc l nd ne">    output_table = ax.table(cellText = df_output.values,<br/>                   colLabels = col_labels, rowLabels = row_labels,<br/>                   rowColours =["skyblue"]*5,<br/>                   colColours =["cyan"]*4,<br/>                   cellLoc='center', loc="center")</span><span id="cc50" class="na lw it mw b gy nf nc l nd ne">    ax.set_title("Output data for %i independent runs" %(run+1),<br/>                 fontsize=18,y= 0.8, pad = 4)</span><span id="9882" class="na lw it mw b gy nf nc l nd ne">    output_table.auto_set_font_size(False)<br/>    output_table.set_fontsize(8)<br/>    plt.savefig(your_path +'twoWKs_output_perf_measures.png',<br/>                bbox_inches='tight', dpi=150)<br/>    plt.show()</span></pre><p id="d5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">置信度为90%、绝对精度为1.0、<em class="ms">k</em><em class="ms"/>= 10(<em class="ms">if run&gt;= 10:</em>)的仿真算法的核心是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="a1a0" class="na lw it mw b gy nb nc l nd ne">confidence = 0.90<br/>abs_err_delay_wk1 = 1.00<br/>l_end = False</span><span id="8a47" class="na lw it mw b gy nf nc l nd ne">init_numb_of_runs = 500<br/>numb_of_runs = init_numb_of_runs</span><span id="895c" class="na lw it mw b gy nf nc l nd ne">seed_value = 2345<br/>prbnumgen  = RandomState(seed_value)<br/>hours_run_sim = 30 * 24<br/>stop_arrivals = 720           ## for the verification step</span><span id="5de3" class="na lw it mw b gy nf nc l nd ne">for run in range(numb_of_runs):</span><span id="b819" class="na lw it mw b gy nf nc l nd ne">   workstation1_schedule_list, workstation2_schedule_list = [],[]<br/>   workstation1_operation_list,workstation2_operation_list= [],[]<br/>   workstation1_release_list,  workstation2_release_list  = [],[]</span><span id="bcca" class="na lw it mw b gy nf nc l nd ne">   time_workstation1_schedule_list, time_workstation2_schedule_list  = [],[]<br/>   time_workstation1_operation_list,time_workstation2_operation_list = [],[]<br/>   time_workstation1_release_list,  time_workstation2_release_list   = [],[]</span><span id="7bec" class="na lw it mw b gy nf nc l nd ne">   workstation1_length_list, workstation1_utilization_list = [],[]<br/>   workstation1_timeth_list, workstation2_utilization_list = [],[]</span><span id="6f14" class="na lw it mw b gy nf nc l nd ne">   mean_delay_wk1,  mean_delay_wk2  = [],[]<br/>   utilization_wk1, utilization_wk2 = [],[]<br/>   len_avg_wk1,     len_avg_wk2     = [],[]<br/>   listoflists = []</span><span id="92c0" class="na lw it mw b gy nf nc l nd ne">   df_wk1_schdl = pd.DataFrame(columns = ['Job Number', 'Job Time Sc1'])<br/>   df_wk2_schdl = pd.DataFrame(columns = ['Job Number', 'Job Time Sc2'])<br/>   df_wk1_opert = pd.DataFrame(columns = ['Job Number', 'Job Time Op1'])<br/>   df_wk2_opert = pd.DataFrame(columns = ['Job Number', 'Job Time Op2'])<br/>   df_wk1_reles = pd.DataFrame(columns = ['Job Number', 'Job Time Rl1'])<br/>   df_wk2_reles = pd.DataFrame(columns = ['Job Number', 'Job Time Rl2'])</span><span id="d976" class="na lw it mw b gy nf nc l nd ne">   # Set up the simulation environment<br/>   env = simpy.Environment()</span><span id="9f2a" class="na lw it mw b gy nf nc l nd ne">   work_station1 = simpy.Resource(env, NUMBER_WORK_STATION1)<br/>   work_station2 = simpy.Resource(env, NUMBER_WORK_STATION2)</span><span id="15d0" class="na lw it mw b gy nf nc l nd ne">   env.process(generate_jobs(env, "Type1", JOBS_ARRIVAL_RATE, 0, <br/>               stop_arrivals, prbnumgen))</span><span id="f60d" class="na lw it mw b gy nf nc l nd ne">   env.run(until = hours_run_sim)<br/>   calc_measures()</span><span id="ee11" class="na lw it mw b gy nf nc l nd ne">   if run &gt;= 10:<br/>      calc_ICs()</span><span id="a29d" class="na lw it mw b gy nf nc l nd ne">      if l_end == True:<br/>         print_output() <br/>         break</span></pre><h1 id="df68" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">分析</strong></h1><p id="5fd9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在第4篇文章中，我们使用固定样本量的方法计算了一些性能指标的置信区间。我们在每次运行中使用不同的随机数流进行了<strong class="lb iu"> 10次独立复制</strong>。表1显示了工作站1中的延迟、工作站2中的延迟、工作站1 &amp; 2忙碌的时间百分比以及队列1的时间加权平均长度的平均值、标准偏差以及CIs的下限和上限。分析师认为一些置信区间太大，对商业目的没有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/32605cf1f7aad4c349677af294d9256b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*wQdFuiknd22Wdf_3WjLM7g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表1，作者用Matplotlib做的。</p></figure><p id="2a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于分析师无法控制CIs的精度，他决定使用前面代码中指示的顺序程序。他为工作站1 的延迟设定了90%的置信度和1.0的<strong class="lb iu">绝对精度。他选择30*24 = 720小时的模拟时间作为终止模拟的终止事件，两个工作站都空闲作为初始条件。for循环</strong>外的种子值<em class="ms">2345</em>2345<strong class="lb iu">(<em class="ms">for run in range(number _ of _ runs):</em>)用于完成跨运行的统计独立性。</strong></p><p id="862b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表2显示了研究中最后20次独立运行的性能测量值。我们需要208次运行来获得期望的绝对精度。表2中显示的估计值的较大方差清楚地表明<strong class="lb iu">模拟输出数据</strong>的随机性质以及计算每个性能测量的ci的需要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/d3897d24eb3a437c67020a536ea521c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*rO9s1nNYBTdtowBKfulIAw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表2，作者用Matplotlib做的。</p></figure><p id="34b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表3总结了模拟研究的输出数据。它显示了208次独立运行后我们的性能测量的平均值、标准偏差和置信区间的下限和上限。<strong class="lb iu">我们以大约90%的把握宣称，1号工作站的延迟包含在区间【12.53，14.53】小时</strong>内。工作站1中延迟的置信区间宽度等于2，因此IC的半宽度满足分析师的精度要求。对于该性能测量，从固定样本程序获得的值可以观察到非常重要的差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/2a3d1f570da02cdd30bb16bf3e5b9eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*blKRYYVLRxsPkouq-LVNWA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表3，作者用Matplotlib做的。</p></figure><p id="d2e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">置信区间被定义为包含具有指定概率的真值的区域。我们必须为我们想要构建的每个配置项定义置信度。还有一个与CIs相关的重要量:<strong class="lb iu">覆盖概率</strong>。置信水平是程序的<strong class="lb iu"> <em class="ms">名义覆盖概率</em> </strong>。<em class="ms">覆盖概率</em>是区间包含真均值的实际概率。如果在推导置信区间中使用的所有假设都满足，则标称覆盖概率将等于覆盖概率。但是，如果不满足某些假设，实际覆盖概率可能小于或大于名义覆盖概率[2]。</p><p id="54b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管顺序程序显著减小了IC的半宽度，但在覆盖方面并不总是表现良好。覆盖范围可能会有所不同，因为在模拟实验期间不满足CI的假设，或者输出数据的分布与程序假设的分布不同。此外，<strong class="lb iu">覆盖率对选择</strong>非常敏感。在任何情况下，<strong class="lb iu">我们必须意识到使用顺序程序可能会导致严重的承保范围损失。</strong></p><p id="aad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的文章中，我们将继续分析模拟研究中存在的这些和其他重要的统计问题。</p><p id="2111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[1]: Law，A.M. &amp; Kelton，W.D. (2000)模拟建模与分析。波士顿麦格劳希尔公司。</p><p id="4e18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]:<a class="ae ky" href="https://en.wikipedia.org/wiki/Coverage_probability" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Coverage_probability</a></p></div></div>    
</body>
</html>