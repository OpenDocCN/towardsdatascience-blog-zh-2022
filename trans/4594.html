<html>
<head>
<title>Traveling salesman problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">旅行推销员问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/traveling-salesman-problem-92e21d488a6a#2022-10-12">https://towardsdatascience.com/traveling-salesman-problem-92e21d488a6a#2022-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5eba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用遗传算法寻找最短路径</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ba1d7010056de3393223855164e835b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fCu0t32JUPjXTomQk058LA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如何找到不同地方之间的最短路线？(图片由作者提供)</p></figure><p id="7e24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所谓的旅行推销员问题是一个众所周知的挑战。任务是在多个目的地之间寻找最短的整体路线:女售货员连续访问几家商店，并在终点以整体最短的距离返回起点。我们打算用Python实现一个遗传算法来解决这个问题。</p><p id="e4ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">背景:</strong></p><p id="1b3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，从前，莫斯科一家金色汉堡连锁店的销售人员。销售人员必须走遍A、B、C和d四家商店。因为时间就是金钱，所以很自然地，您希望找到最短的旅行路线。</p><p id="56e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要所有四家商店之间的距离:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/2591013d093ba28a27e1cbf1a04b4a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*REt8T1i8Es_CzoIKBvrSWA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">四家商店之间的车程，以米为单位。也考虑相反的方向(蓝色阴影)。</p></figure><p id="3fc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我们所看到的，所有商店之间的距离——在两个方向上——都是已知的。我们正在考虑两个方向，因为开车的距离可能略有不同。让我们看看商店A和商店B之间的距离，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/07098dde09a0b5773ddd9b36757b56fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HV-F3jhx_geYNl46IgGBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用谷歌地图的汽车距离。我们的数据基于OpenStreetMap，这就是为什么数字可能不同(图片由作者提供)</p></figure><p id="150e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将所有商店组合在一条总的最短路线中称为非确定性多项式问题。这意味着找到的最短距离最多可以在多项式时间内得到验证。通俗地说，要找到确定性很高的最优路线可能需要很长时间。因为我们没有这个时间(即使我们有，我们也不能证明我们是否真的找到了最短的总距离)，我们将通过一种叫做遗传算法的特殊方法来接近最佳可能的解决方案。</p><p id="8bef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">解:</strong> <br/>遗传算法反复修改一个群体的染色体(个体解)。染色体包含一个可能的存储序列，例如从存储D到B，从B到A，从A到C，最后再从C回到D:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/9c653bdd5c9b3d97155a56391f41a3a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*_0HNZJUnxnblHQZHxoPdIQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">存储在数组中(图片由作者提供)</p></figure><p id="5195" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个可能是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/e73285190a32dafaf28059c7142d0280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*L58KnV-DK4siR-XAfO-20w.png"/></div></figure><p id="0b05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三个，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/409d02943e8a4c9ed723fcbd7fb0b296.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*7IGsbPLfBz_tBStm1Yep-Q.png"/></div></figure><p id="4518" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">..诸如此类。</p><p id="a66a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">染色体背后的想法是基于模拟生物进化的自然选择过程。因为它只是模仿，但肯定甚至不接近自然的镜子，我更喜欢称遗传方法为“高级盲猜”和染色体为“潜在的解决方案”。遗传方法的有趣之处在于，在每一步，遗传算法从当前群体中随机选择个体，并使用它们作为父母为下一代产生孩子。因此，通过使用遗传算法，从可能的随机生成解的初始群体中选择特别有前景的路线(商店的顺序)。经过一定数量的循环(突变)，种群“进化”到一个最优解。</p><p id="a0a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">遗传算法的实现包括类潜在解决方案，它将染色体表示为一种可能的单路解决方案。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="ccdd" class="me mf it ma b gy mg mh l mi mj">class PotentialSolution:<br/>    def randomInstance(cls):<br/>        return PotentialSolution()<br/>    def fitness(self):<br/>        return 1<br/>    def mutate(self):<br/>        return self<br/>    def crossover(self, other):<br/>        return [self, other]</span></pre><p id="bd02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">randomInstance()为第一代创建一个具有随机位置的实例。它也能够突变，即改变一条随机选择的路线，并与另一条染色体进行交叉，以与其随机交换位置。</p><p id="bdd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于距离将被最小化，因此适应度函数计算相应总距离的倒数。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="e6af" class="me mf it ma b gy mg mh l mi mj">def fitness(self):<br/>    return 1 / self.getDistance()</span></pre><p id="3d87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在突变过程中，两个位置随机互换，</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="8809" class="me mf it ma b gy mg mh l mi mj">def mutate(self):<br/>    return self</span></pre><p id="a5c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并且在交叉中，存储区将其位置与该存储区在另一个染色体中的位置交换。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="6e62" class="me mf it ma b gy mg mh l mi mj">def crossover(self, other):<br/>    return [self, other]</span></pre><p id="50e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">class方法randomInstance()首先创建一个位置列表的副本，因为否则相同的列表将一直被传递。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="23a7" class="me mf it ma b gy mg mh l mi mj">def randomInstance(cls):<br/>    return PotentialSolution()</span></pre><p id="4769" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用random shuffle()函数将副本随机化，并用于创建一个新实例，然后返回该实例。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="169e" class="me mf it ma b gy mg mh l mi mj">def randomCoordinates(cls):<br/>    PlacesCopy = cls.locations[:]<br/>    shuffle(PlacesCopy)<br/>    return distanceShuffling(PlacesCopy)</span></pre><p id="e355" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在mutate()和crossover()中，randint()函数用于生成两个指定数字之间的随机整数。方法cross()在子代之间交换信息之前，使用copy.deepcopy()获得父代染色体的完整拷贝。这是因为在当前的生殖循环中，父母可能会被重新选择。</p><p id="bddb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主程序创建由20条随机染色体组成的初始第一个群体。计算每条染色体所有距离的总和。一旦其适应度超过指定的阈值(一个非常小的数字)，生成序列就会提前结束，并返回最优解。否则，经过预定的世代数后会找到最好的一个。算法将在达到最大20代后停止。Crossover _ chance是一个介于0和1之间的概率值，表示平均发生交叉的频率，而不是直接接管父代。“突变_机会”指定新一代染色体的平均突变频率。该值也介于0和1之间。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="394f" class="me mf it ma b gy mg mh l mi mj">if __name__ == '__main__': <br/>    population = []<br/>    for i in range(0, 20):<br/>        population.append(distanceShuffling.randomCoordinates())<br/>    advancedGuessing = AdvancedGuess(population, 0.0000001, 20, 0.7, 0.5)<br/>    optimal = advancedGuessing.find()<br/>    print("Shortest distance found:", optimal)</span></pre><p id="272a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">主要过程发生在find()方法中。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="2d75" class="me mf it ma b gy mg mh l mi mj">def find(self):<br/>    optimal = deepcopy(<br/>        max(self.population, key = lambda potentialSolution: potentialSolution.fitness())<br/>    )<br/>    for i in range(0, self.max_generations):<br/>        if optimal.fitness() &gt;= self.expected:<br/>            return optimal<br/>        self.propagate()<br/>        current_best = deepcopy(<br/>            max(self.population, key = lambda potentialSolution: potentialSolution.fitness())<br/>        )<br/>        if current_best.fitness() &gt; optimal.fitness():<br/>            optimal = current_best<br/>        print(i, optimal)<br/>    return optimal</span></pre><p id="c579" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最多max_generations代开始循环之前，这首先确定初始代的最适合的染色体。如果先前的最佳值已经达到预期的阈值，则立即返回。总体最适染色体和每轮最适染色体都被复制。</p><p id="4443" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在标准情况下，下一代的生殖周期接下来发生。propagate()方法对此负责。之后，确定新一代的最佳个体，与先前的最佳值进行比较，如果出现进一步的改进，则接管该最佳个体。如果运行了所选的最大代数，但没有产生最佳结果，则最终返回目前为止找到的最佳结果。propagate()复制方法也是循环的，为下一代选择或创建个体，直到有足够多的个体。为此，在每次循环中首先选择两个人。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="6f25" class="me mf it ma b gy mg mh l mi mj">def propagate(self):<br/>    newPopulation = []<br/>    while len(newPopulation) &lt; len(self.population):<br/>        parents = self.chooseParents()<br/>        if random() &lt; self.crossover_chance:<br/>            [child1, child2] = parents[0].crossover(parents[1])<br/>            newPopulation.append(child1)<br/>            newPopulation.append(child2)<br/>        else:<br/>            newPopulation.append(parents[0])<br/>            newPopulation.append(parents[1])<br/>    if len(newPopulation) &gt; len(self.population):<br/>        newPopulation.pop()<br/>    for potentialSolution in newPopulation:<br/>        if random() &lt; self.mutation_chance:<br/>            potentialSolution.mutate()<br/>    self.population = newPopulation</span></pre><p id="a1d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与交叉概率相比较的随机值接下来决定是将来自上一代的原始个体延续下来，还是将由它们的父母产生新一代。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="62ad" class="me mf it ma b gy mg mh l mi mj">while len(newPopulation) &lt; len(self.population):<br/>    parents = self.chooseParents()<br/>    if random() &lt; self.crossover_chance:<br/>        [child1, child2] = parents[0].crossover(parents[1])<br/>        newPopulation.append(child1)<br/>        newPopulation.append(child2)<br/>    else:<br/>        newPopulation.append(parents[0])<br/>        newPopulation.append(parents[1])</span></pre><p id="005f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在新一代最终取代老一代之前，所有新个体的另一个循环决定了它们是否应该变异。这也是通过将随机值与期望概率进行比较来完成的。</p><pre class="kj kk kl km gt lz ma mb mc aw md bi"><span id="5b44" class="me mf it ma b gy mg mh l mi mj">def mutate(self):<br/>    rand_index_1 = randint(0, len(self.places) - 1)<br/>    rand_index_2 = randint(0, len(self.places) - 1)<br/>    if rand_index_1 != rand_index_2:<br/>        self.places[rand_index_1], self.places[rand_index_2] = (<br/>            self.places[rand_index_2], self.places[rand_index_1]<br/>        )</span></pre><p id="1c4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只要我们运行所有的代码，我们就能在几秒钟内得到解决方案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a26b61501024bb181a135a137a2c153d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1142/format:webp/1*PSLkzUX5jXA9jOwOcQlBRg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可能的最短总距离之一(图片由作者提供)</p></figure><p id="6724" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，这些遗传算法是高度随机的。继续尝试连续几次代码，更改参数并观察结果如何变化。你可以在这里找到完整的代码和数据。</p><p id="9345" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">小短途:</strong></p><p id="2393" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们在玩的时候，我想提一下迭戈·维森特解决旅行推销员问题的迷人方法:</p><div class="mm mn gp gr mo mp"><a href="https://github.com/diego-vicente/som-tsp" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">GitHub - diego-vicente/som-tsp:使用自组织地图解决旅行推销员问题</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">该存储库包含一个自组织映射的实现，可用于为…寻找次优解决方案</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ks mp"/></div></div></a></div><p id="bfce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Diego应用了一种改进的自组织映射(SOM)技术。出于好奇，现在让我们将现有的四家McD-Moscow商店再扩展9个坐标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/456ef9f04a107c1450e9ed47603506c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*7uEruBu9EVZULB5Aq3JJgw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">tsp格式的13家商店的坐标(图片由作者提供)</p></figure><p id="9c78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">..并将迭戈的知识库应用于此:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ba1d7010056de3393223855164e835b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*fCu0t32JUPjXTomQk058LA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们没看到本文开头的gif吗？你说的完全正确，我就是百听不厌！</p></figure><p id="c355" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果迭戈的方法不酷，那什么才酷呢？</p><p id="869e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">总结:</strong></p><p id="d865" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">恭喜你，你已经应用遗传算法找到了一条最佳路线。</p><p id="17ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这一点上，让我们也简单地记住，生活中有比Python编程更重要的事情。因此，这听起来也许很幽默，但却很真诚的愿望是，希望不久就会有和平，这样我们就可以在世界各地一起吃自由薯条了！</p><p id="81b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此之前，非常感谢您的阅读！希望这篇文章对你有帮助。请随时在<a class="ae ml" href="https://de.linkedin.com/in/jesko-rehberg-40653883" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae ml" href="https://twitter.com/DAR_Analytics" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或<a class="ae ml" href="https://jesko-rehberg.medium.com/virtual-reality-vr-for-education-a532aa5b6272" rel="noopener">工作室</a>与我联系。</p><div class="mm mn gp gr mo mp"><a href="https://jesko-rehberg.medium.com/membership" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd iu gy z fp mu fr fs mv fu fw is bi translated">通过我的推荐链接加入Medium-Jesko Rehberg</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">阅读杰斯科·雷伯格(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">jesko-rehberg.medium.com</p></div></div><div class="my l"><div class="ne l na nb nc my nd ks mp"/></div></div></a></div></div></div>    
</body>
</html>