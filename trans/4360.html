<html>
<head>
<title>How to Prepare Scikit-Learn Models for Production</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为生产准备Scikit-Learn模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-prepare-scikit-learn-models-for-production-4aeb83161bc2#2022-09-27">https://towardsdatascience.com/how-to-prepare-scikit-learn-models-for-production-4aeb83161bc2#2022-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27f8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用FastAPI和Docker服务scikit-learn模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/86d7292230e252d570a00b0a89860af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5LZouy9fw5SqgknWhKLeg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/photos/ready-prepared-preparation-2379042/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><h1 id="6b96" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="b1ce" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">数据科学家花费大量精力收集业务需求，执行探索性数据分析、数据预处理、功能工程、超参数调整和模型评估，结果却让他们的模型停留在本地笔记本电脑环境中。为了释放训练模型的全部价值，模型必须对下游应用程序可用。在本文中，我们将介绍使用Docker和FastAPI向下游应用程序提供scikit-learn机器学习模型的步骤。本质上，我们将训练一个模型，将模型包装成API，并将应用程序容器化。</p><p id="75d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">Docker是什么？</strong></p><blockquote class="ms mt mu"><p id="fcfe" class="lr ls mv lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated">Docker是一个开发、发布和运行应用程序的开放平台。它提供了在松散隔离的环境(称为容器)中打包和运行应用程序的能力。容器是轻量级的，包含运行应用程序所需的一切，因此您不需要依赖主机上当前安装的内容[1]。</p></blockquote><p id="0730" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">什么是FastAPI？</strong></p><blockquote class="ms mt mu"><p id="dadc" class="lr ls mv lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated"><em class="it"> FastAPI是一个现代、快速(高性能)的web框架，用于基于标准Python类型提示使用Python 3.7+构建APIs。</em></p></blockquote><p id="7132" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本文中的内容按以下顺序涵盖:</p><ol class=""><li id="dabe" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">设置</li><li id="6e86" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">数据</li><li id="7f62" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">项目目录</li><li id="7240" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">火车模型</li><li id="e265" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">使用FastAPI创建API</li><li id="73a1" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">本地测试API</li><li id="a98b" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">创建docker图像</li><li id="c07f" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">docker容器中的测试API</li></ol><h1 id="6ba2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">设置</h1><p id="1d72" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是用于演练的设置。</p><ol class=""><li id="46d6" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">Visual Studio代码</li><li id="aaeb" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">Docker桌面</li><li id="3e12" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">包装</li></ol><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c005" class="ns la it no b gy nt nu l nv nw">fastapi&gt;=0.68.0,&lt;0.69.0<br/>pydantic&gt;=1.8.0,&lt;2.0.0<br/>uvicorn&gt;=0.15.0,&lt;0.16.0<br/>numpy==1.23.3<br/>scikit-learn==0.23.2<br/>joblib==1.1.0<br/>pandas==1.4.4</span></pre><h1 id="986c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据</h1><p id="d3dc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这个例子中，我们将使用心脏病数据集[3]。任务是在给定患者的各种属性的情况下，预测患者是否患有心脏病。<code class="fe nx ny nz no b">condition</code>是目标变量，其中<code class="fe nx ny nz no b">1</code>表示存在心脏病，<code class="fe nx ny nz no b">0</code>表示不存在心脏病。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/4c4c1c2bce2d42661ba6b92b21c6bda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O65LlEYLArDBW-3X"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="6ca5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">项目目录</h1><p id="c2a9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">项目目录结构如下:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="9f07" class="ns la it no b gy nt nu l nv nw">G:.<br/>│   requirements.txt<br/>│   Dockerfile<br/>│   app.py<br/>|<br/>├───data<br/>│       heart-disease.csv<br/>│<br/>└───model<br/>    │   train.py<br/>    │   heart-disease-v1.joblib</span></pre><ul class=""><li id="2f10" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">[app.py](&lt;http://app.py&gt;)</code>:包含API逻辑</li><li id="f976" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">/data</code>:训练数据(<code class="fe nx ny nz no b">heart-disease.csv</code>)保存在该目录下</li><li id="98ee" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">/model</code>:训练好的模型和训练脚本保存在这个目录下</li><li id="67f9" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">[train.py](&lt;http://train.py&gt;)</code> : scikit-learn模型在这个脚本中被训练</li><li id="60c4" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">Dockerfile</code>:容器化API的Dockerfile</li><li id="b5ee" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">requirements.txt</code>:包含python包的需求</li></ul><h1 id="33a3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">火车模型</h1><p id="c94e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">文件名:<code class="fe nx ny nz no b">train.py</code></p><p id="75dd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了演示FasAPI和Docker，我们保持培训简单，不包括任何预处理或功能工程。从<code class="fe nx ny nz no b">/data</code>目录中读取数据，用10棵树训练一个随机森林分类器。然后，训练好的模型被保存为<code class="fe nx ny nz no b">/model</code>目录中的<code class="fe nx ny nz no b">.joblib</code>文件。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="3dc8" class="ns la it no b gy nt nu l nv nw">#train.py</span><span id="5960" class="ns la it no b gy oc nu l nv nw">from os import PathLike<br/>from sklearn.ensemble import RandomForestClassifier<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import classification_report<br/>from joblib import dump<br/>import pandas as pd<br/>import pathlib</span><span id="a38b" class="ns la it no b gy oc nu l nv nw">df = pd.read_csv(pathlib.Path('data/heart-disease.csv'))<br/>y = df.pop('condition')<br/>X = df</span><span id="4f13" class="ns la it no b gy oc nu l nv nw">X_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.2)</span><span id="0115" class="ns la it no b gy oc nu l nv nw">print ('Training model.. ')<br/>clf = RandomForestClassifier(n_estimators = 10,<br/>                             max_depth=2,<br/>                             random_state=0)<br/>clf.fit(X_train, y_train)</span><span id="c743" class="ns la it no b gy oc nu l nv nw">print ('Saving model..')<br/>dump(clf, pathlib.Path('model/heart-disease-v1.joblib'))</span></pre><h1 id="eeb5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建API</h1><p id="ea2e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">文件名:<code class="fe nx ny nz no b">app.py</code></p><p id="526b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是大部分活动发生的地方。</p><p id="fb68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">导入库</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="76a5" class="ns la it no b gy nt nu l nv nw">from fastapi import FastAPI<br/>from pydantic import BaseModel<br/>import numpy as np<br/>from joblib import load<br/>import pathlib</span></pre><p id="df78" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">创建一个FastAPI实例</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="bfea" class="ns la it no b gy nt nu l nv nw">app = FastAPI(title = 'Heart Disease Prediction')</span></pre><p id="95dc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">加载训练好的模型</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f5e5" class="ns la it no b gy nt nu l nv nw">model = load(pathlib.Path('model/heart-disease-v1.joblib'))</span></pre><p id="60a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">定义请求模型</strong></p><p id="c024" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们定义API所需的输入数据。格式由字段名、数据类型和可选默认值组成。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="db6d" class="ns la it no b gy nt nu l nv nw">class InputData(BaseModel):<br/>    age:int=64<br/>    sex:int=1 <br/>    cp:int=3<br/>    trestbps:int=120<br/>    chol:int=267<br/>    fbs:int=0<br/>    restecg:int=0<br/>    thalach:int=99<br/>    exang:int=1<br/>    oldpeak:float=1.8<br/>    slope:int=1<br/>    ca:int=2<br/>    thal:int=2</span></pre><p id="d0ca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">定义响应模型</strong></p><p id="074d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以用类似的方式定义响应数据。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f9db" class="ns la it no b gy nt nu l nv nw">class OutputData(BaseModel):<br/>    score:float=0.80318881046519</span></pre><p id="5623" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">定义发布请求</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f4a5" class="ns la it no b gy nt nu l nv nw">@app.post('/score', response_model = OutputData)<br/>def score(data:InputData):<br/>    model_input = np.array([v for k,v in data.dict().items()]).reshape(1,-1)<br/>    result = model.predict_proba(model_input)[:,-1]<br/>    <br/>    return {'score':result}</span></pre><p id="52d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的代码片段里有很多事情在进行，我们来分解一下。</p><p id="aeb6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们先来看看<code class="fe nx ny nz no b">@app.post('/score', response_model = OutputData)</code>。</p><ul class=""><li id="10f3" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">/score</code>是路线名称。它是URL的最后一部分，例如“<a class="ae ky" href="http://my-url.com/score%E2%80%9D" rel="noopener ugc nofollow" target="_blank">http://my-url.com/score"</a>”。</li><li id="5320" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">@app.post</code>表示<code class="fe nx ny nz no b">/score</code>路由接受post请求。</li><li id="0ca5" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">@app.post('/score')</code>告诉FastAPI下面的函数(即<code class="fe nx ny nz no b">def score</code>)负责处理去往<code class="fe nx ny nz no b">/score</code>路线的请求。</li><li id="b52f" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated"><code class="fe nx ny nz no b">response_model</code>表示API将返回给调用者的格式数据。</li></ul><p id="7c43" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在<code class="fe nx ny nz no b">@app.post</code>下面我们有<code class="fe nx ny nz no b">score</code>功能。</p><ul class=""><li id="630f" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ob nf ng nh bi translated">score函数需要一个<code class="fe nx ny nz no b">data</code>参数，它采用我们之前定义的<code class="fe nx ny nz no b">InputData</code>的格式。</li><li id="2ea3" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated">score函数然后解析<code class="fe nx ny nz no b">data</code>并将其转换成一个numpy数组</li><li id="c739" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ob nf ng nh bi translated">该数组被传递给<code class="fe nx ny nz no b">.predict_proba</code>方法，该方法返回一个介于0-1之间的分数。</li></ul><p id="9055" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">运行实时服务器</strong></p><p id="0f4f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过以下方式在本地启动API。在终端中，在项目根目录下运行:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="eef3" class="ns la it no b gy nt nu l nv nw">uvicorn app:app --reload</span></pre><p id="7bd5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">成功部署的输出如下所示:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="cb82" class="ns la it no b gy nt nu l nv nw">INFO:     Will watch for changes in these directories: ['path/to/project']<br/>INFO:     Uvicorn running on &lt;http://127.0.0.1:8000&gt; (Press CTRL+C to quit)<br/>INFO:     Started reloader process [24040] using StatReload<br/>INFO:     Started server process [26612]<br/>INFO:     Waiting for application startup.<br/>INFO:     Application startup complete.</span></pre><p id="d83e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上述代码块中的第二行显示了应用程序被提供的URL。</p><p id="3d82" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">自动化API文档</strong></p><p id="48a8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">基于API定义，FastAPI在Swagger和Redoc UI中自动生成文档。使用<code class="fe nx ny nz no b"><a class="ae ky" href="http://127.0.0.1:8000/docs." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/docs</a></code> <a class="ae ky" href="http://127.0.0.1:8000/docs." rel="noopener ugc nofollow" target="_blank">访问Swagger API文档。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/d9285f39608498769c35f2b03ec8f349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QYqMoC30_x04NVcB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="293d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">而Redoc API文档使用<code class="fe nx ny nz no b"><a class="ae ky" href="http://127.0.0.1:8000/redoc." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/redoc</a></code> <a class="ae ky" href="http://127.0.0.1:8000/redoc." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/0d5eed53b9d2f57e02891094d596752e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U7E3aBYyQjrUaljH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="607b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">本地测试API</h1><p id="dd21" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">此时，可以通过swagger UI、终端或使用python来测试API。</p><p id="5878" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">霸气UI </strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/e7ab026f43bf7f1759e16255b1f30f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HOWvVmEbsJEpuRYh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d708" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">端子</strong></p><p id="3eda" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用<code class="fe nx ny nz no b">curl</code>通过终端调用API。<code class="fe nx ny nz no b">score</code>函数所需的<code class="fe nx ny nz no b">data</code>参数通过<code class="fe nx ny nz no b">curl</code>中的<code class="fe nx ny nz no b">-d</code>参数传递。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="949d" class="ns la it no b gy nt nu l nv nw">curl -X 'POST' \\<br/>  '&lt;http://127.0.0.1:8000/score&gt;' \\<br/>  -H 'accept: application/json' \\<br/>  -H 'Content-Type: application/json' \\<br/>  -d '{<br/>  "age": 64,<br/>  "sex": 1,<br/>  "cp": 3,<br/>  "trestbps": 120,<br/>  "chol": 267,<br/>  "fbs": 0,<br/>  "restecg": 0,<br/>  "thalach": 99,<br/>  "exang": 1,<br/>  "oldpeak": 1.8,<br/>  "slope": 1,<br/>  "ca": 2,<br/>  "thal": 2<br/>}'</span></pre><p id="6462" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> Python </strong></p><p id="a336" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">可以使用python的<code class="fe nx ny nz no b">requests</code>包调用API。<code class="fe nx ny nz no b">score</code>函数所需的<code class="fe nx ny nz no b">data</code>参数通过<code class="fe nx ny nz no b">request.post</code>中的<code class="fe nx ny nz no b">json</code>参数传递。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="e2ec" class="ns la it no b gy nt nu l nv nw">import requests</span><span id="784a" class="ns la it no b gy oc nu l nv nw">body = {<br/>    "age": 64,<br/>    "sex": 1,<br/>    "cp": 3,<br/>    "trestbps": 120,<br/>    "chol": 267,<br/>    "fbs": 0,<br/>    "restecg": 0,<br/>    "thalach": 99,<br/>    "exang": 1,<br/>    "oldpeak": 1.8,<br/>    "slope": 1,<br/>    "ca": 2,<br/>    "thal": 2<br/>    }</span><span id="23f9" class="ns la it no b gy oc nu l nv nw">response = requests.post(url = '&lt;http://127.0.0.1:8000/score&gt;',<br/>              json = body)</span><span id="84fa" class="ns la it no b gy oc nu l nv nw">print (response.json())<br/># output: {'score': 0.866490130600765}</span></pre><h1 id="9791" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">创建Docker图像</h1><p id="7c11" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">太好了！API在本地工作。通常，我们可能需要在云环境中部署API，如AWS、Azure或GCP。实现这一点的方法之一是将您的应用程序容器化。</p><p id="ac6f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">定义python需求</strong></p><p id="ebe6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们在<code class="fe nx ny nz no b">requirements.txt</code>中定义要求</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="de6e" class="ns la it no b gy nt nu l nv nw"># requirements.txt<br/>fastapi&gt;=0.68.0,&lt;0.69.0<br/>pydantic&gt;=1.8.0,&lt;2.0.0<br/>uvicorn&gt;=0.15.0,&lt;0.16.0<br/>numpy==1.23.3<br/>scikit-learn==0.23.2<br/>joblib==1.1.0</span></pre><p id="cb2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">定义Dockerfile </strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="4197" class="ns la it no b gy nt nu l nv nw">#Dockerfile<br/>FROM python:3.8</span><span id="6794" class="ns la it no b gy oc nu l nv nw">WORKDIR /app</span><span id="ee1a" class="ns la it no b gy oc nu l nv nw">COPY ./requirements.txt ./requirements.txt</span><span id="ad34" class="ns la it no b gy oc nu l nv nw">RUN pip install --no-cache-dir --upgrade -r ./requirements.txt</span><span id="77a5" class="ns la it no b gy oc nu l nv nw">COPY ./app.py .<br/>COPY ./model ./model</span><span id="436b" class="ns la it no b gy oc nu l nv nw">CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "80"]</span></pre><p id="2853" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">does文件执行以下操作:</p><ol class=""><li id="e5c9" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">从Docker hub获取python 3.8图像</li><li id="72cb" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">创建一个名为<code class="fe nx ny nz no b">/app</code>的工作目录</li><li id="4fe6" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">将<code class="fe nx ny nz no b">requirements.txt</code>复制到工作目录</li><li id="d5a2" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">安装<code class="fe nx ny nz no b">requirements.txt</code>中定义的软件包</li><li id="445b" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">将代码和模型复制到工作目录中</li><li id="f684" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nx ny nz no b">CMD</code>当容器启动时，在端口80上启动服务器</li></ol><p id="a558" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">构建Docker映像</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8b90" class="ns la it no b gy nt nu l nv nw"># at the project root folder<br/>docker build -t fastapiml .</span></pre><h1 id="d0fb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">在Docker容器中测试</h1><p id="7316" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">启动码头集装箱</strong></p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="643a" class="ns la it no b gy nt nu l nv nw">docker run -d --name heart-disease-serving -p 80:80 fastapiml</span></pre><p id="080e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正在运行的容器将显示在Docker桌面中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0018122b25a0ae8557b70d0879c68adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IohBlbvKAoWDsO0q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d7b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">自动化API文档</strong></p><p id="eaae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与之前类似，我们可以使用以下方式访问API文档:</p><ol class=""><li id="19b4" class="mz na it lt b lu mn lx mo ma nb me nc mi nd mm ne nf ng nh bi translated">招摇:<code class="fe nx ny nz no b"><a class="ae ky" href="http://127.0.0.1/docs" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/docs</a></code></li><li id="fefa" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated">Redoc: <code class="fe nx ny nz no b"><a class="ae ky" href="http://127.0.0.1/redoc" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1/redoc</a></code></li></ol><p id="fdf4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">docker容器中运行的API可以像以前一样以类似的方式进行测试。要么在终端使用Swagger UI、<code class="fe nx ny nz no b">curl</code>命令，要么使用python的<code class="fe nx ny nz no b">requests</code>包。</p><h1 id="5db8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="78a7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们讨论了让下游应用程序可以访问机器学习模型的重要性。我们可以通过使用FastAPI的API来服务这些模型，从而释放机器学习模型的价值。使用FastAPI的一个优点是它在Swagger中的自动文档，这也允许进行快速测试。我们还演示了如何将FastAPI应用程序容器化，从而更容易部署到云中。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="d9ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://medium.com/@edwin.tan/membership" rel="noopener">加入灵媒</a>阅读更多这样的故事！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="498f" class="kz la it bd lb lc oo le lf lg op li lj jz oq ka ll kc or kd ln kf os kg lp lq bi translated">参考</h1><p id="b71f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] <a class="ae ky" href="https://docs.docker.com/get-started/overview/" rel="noopener ugc nofollow" target="_blank"> Docker概述| Docker文档</a></p><p id="bbff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[2]<a class="ae ky" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank">FastAPI(tiangolo.com)</a></p><p id="689e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">[3]来自<a class="ae ky" href="https://archive-beta.ics.uci.edu/ml/datasets/heart+disease" rel="noopener ugc nofollow" target="_blank"> UCI机器学习库</a>的心脏病数据集。由4.0在CC下授权。</p></div></div>    
</body>
</html>