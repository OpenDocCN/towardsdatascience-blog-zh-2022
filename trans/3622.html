<html>
<head>
<title>How to Create File System Triggers in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中创建文件系统触发器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-file-change-trigger-6f8a6c94c13e#2022-08-11">https://towardsdatascience.com/python-file-change-trigger-6f8a6c94c13e#2022-08-11</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="0554" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何以编程方式轻松监控文件的创建、修改和删除</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/31d4f277b78c73c9906aabe8ec8c1b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Erqxm1Ssv0cK7mjkI2hqIQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/photo/multi-colored-folders-piled-up-159519/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="56b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设您使用一个客户端系统，该系统将文件上传到FTP文件夹。一旦文件出现在文件夹中，我们就必须对其进行处理，并将其推送到数据库中。</p><p id="b90e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">实时仪表板正在访问数据库。因此，我们必须毫不拖延地更新数据库。</p><p id="f177" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以运行定期任务并检查文件夹内容。但是让我们假设你更新数据库越快，对用户越好。使用周期性任务时，小延迟的成本很高。随着任务运行得越来越频繁，周期越来越短可能需要更多的资源。</p><p id="97db" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要构建一个文件系统触发器来完成这项任务。</p><h1 id="e913" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">监控文件夹中的新文件创建。</h1><p id="0618" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">我们可以使用Python脚本主动监听文件夹中的文件系统事件。</p><p id="62c7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以从安装一个名为Watchdog的Python包开始。它可以通过PyPI存储库获得。</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="fa85" class="my lx iu mu b gz mz na l nb nc">pip install watchdog</span><span id="0d9c" class="my lx iu mu b gz nd na l nb nc"># If you're using Poetry instead of Virtualenv<br/>poetry add watchdog.</span></pre><p id="5544" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个例子。以下Python脚本将监视当前目录中的文件更改。它会记录所有发生的变化。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Watchdog在Python中监控文件更改的示例。</p></figure><p id="c88a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上述代码的重要部分是FileProcessor类。但是在进入之前，我们应该创建一个observer对象来附加一个事件处理程序。</p><p id="7513" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以使用schedule方法将事件处理程序附加到观察者。在上面的例子中，我们已经附加了它来监视当前目录及其所有下游目录中的事件。</p><p id="e972" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您运行这段代码并在当前目录中创建新文件，我们可以看到Python脚本在终端上打印事件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ng"><img src="../Images/80e0edb777a6a18aea7292a5819143b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*93PXeM_LlpGiAuE_n-C2Sw.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python脚本监听当前文件夹的变化-作者截屏。</p></figure><p id="6841" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在observer对象的<code class="fe nh ni nj mu b">schedule</code>方法中使用了当前文件夹。您也可以使用您选择的任何路径。您也可以选择从命令行参数获取它。</p><p id="63f9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是对将我们的脚本转换成CLI 的代码的修改。现在，您可以使用命令行参数将路径传递给monitor。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="b1ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您可以在终端中运行脚本，如下所示</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="6926" class="my lx iu mu b gz mz na l nb nc">python &lt;YourScript&gt;.py /somewhare/in/your/computer</span></pre><p id="6edc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我之前的文章中，你可以了解更多关于使用Python创建命令行界面的内容。</p><div class="nk nl gq gs nm nn"><a rel="noopener follow" target="_blank" href="/a-simplified-guide-to-create-clis-for-your-data-science-project-bf9bcaa26e1"><div class="no ab fp"><div class="np ab nq cl cj nr"><h2 class="bd iv gz z fq ns fs ft nt fv fx it bi translated">为您的数据科学项目创建CLI的简化指南</h2><div class="nu l"><h3 class="bd b gz z fq ns fs ft nt fv fx dk translated">CLI是一种与机器学习模型交互的强大而直接的方式</h3></div><div class="nv l"><p class="bd b dl z fq ns fs ft nt fv fx dk translated">towardsdatascience.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kt nn"/></div></div></a></div><h1 id="0709" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">处理程序类中的文件更改</h1><p id="981d" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">在我们的例子中，我们通过子类化“FileSystemEventHandler”类创建了一个事件处理程序。所有的事件处理程序都应该这样。</p><p id="9176" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">父类有几个文件系统事件方法的占位符。我们使用了“on_create”方法来处理所有新文件的创建。同样，您也可以使用on_deleted、on_modified、on_moved和on_any_event方法来处理其他类型的事件。</p><p id="252a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们更新on_create来处理文件并将值插入数据库。如果与您的用例无关，请随意跳过这一部分。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="cd08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您曾经使用过Sqlalchemy和Pandas，这段代码可能看起来非常熟悉。值得注意的是我们如何获得新创建文件的路径。</p><p id="b34a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">“FileSystemEventHandler”类中的每个事件触发器都引用其事件参数中的路径。我们可以用代码中所示的<code class="fe nh ni nj mu b">src-path</code>标签来访问它。</p><p id="a31d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您运行代码并让Python脚本监听更改，它也会立即将这些更改推送到数据库。</p><h1 id="ccda" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">在后台提供您的应用程序。</h1><p id="2512" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">到目前为止，您已经注意到我们的应用程序运行在一个活动的终端上。但在生产中这样做并不明智。终端会话的任何内容都会影响应用程序。</p><p id="87bb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在后台运行此类服务的最佳方式是通过系统服务。Windows用户可以使用工具<a class="ae kz" href="https://nssm.cc/" rel="noopener ugc nofollow" target="_blank"> NSSM </a>(非吸吮服务管理器。)如果您浏览一下他们的文档，这将非常简单。</p><p id="6b89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是在这篇文章中，我将讲述Linux使用<a class="ae kz" href="https://www.digitalocean.com/community/tutorials/how-to-use-systemctl-to-manage-systemd-services-and-units" rel="noopener ugc nofollow" target="_blank"> systemctl </a>的方式。</p><p id="3cea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过在“/etc/systemd/system”文件夹中创建包含以下内容的文件来创建新的系统服务。你可以给它起任何扩展名为'的名字。'服务'</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="150c" class="my lx iu mu b gz mz na l nb nc">[Unit]<br/>Description="Process Data"</span><span id="1645" class="my lx iu mu b gz nd na l nb nc">[Service]<br/>Restart=always<br/>WorkingDirectory=&lt;PATH_TO_PROJECT_DIRECTORY&gt;<br/>ExecStart=&lt;PATH_TO_PYTHON_EXECUTABLE&gt; &lt;YOUR_SCRIPT&gt;.py</span><span id="9f5c" class="my lx iu mu b gz nd na l nb nc">[Install]<br/>WantedBy=multi-user target</span></pre><p id="22b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">完成后，您可以在终端上运行以下命令来激活服务。</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="da5a" class="my lx iu mu b gz mz na l nb nc"># To make your new service available to systemctl utility.<br/>$ systemctl daemon-reload<br/></span><span id="3e3d" class="my lx iu mu b gz nd na l nb nc"># To start the service <br/>$ systemctl start &lt;YOUR_SERVICE_FILE_NAME&gt;.service</span></pre><p id="5657" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将启动该过程。现在，随着新文件在我们的FTP目的地上被创建，该服务将处理它们并将其上传到数据库。我们的实时数据库将毫无延迟地获得新数据。</p><p id="8a89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用以下命令检查您的服务是否正常运行。</p><pre class="kk kl km kn gu mt mu mv mw aw mx bi"><span id="8e09" class="my lx iu mu b gz mz na l nb nc">systemctl status &lt;YOUR_SERVICE_FILE_NAME&gt;.service</span></pre><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/a3dbdcc1e5bb9f3d6a72c63da07679d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-D32Wt3E75PPTkYm4I9rZw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Systemctl运行Python脚本——截图由<a class="ae kz" href="https://thuwarakesh.medium.com" rel="noopener">作者提供。</a></p></figure><h1 id="5fc6" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">最后的想法</h1><p id="206f" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">随着世界向更健壮的系统间集成发展，处理文件系统变化现在已经很少见了。但是这并不意味着文件系统触发器没有用处。</p><p id="fb0e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在许多情况下，我们需要监控新文件的创建或修改。以日志流处理为例。您可以使用这里描述的技术来处理新的日志行，并将其推送到数据仓库。</p><p id="9328" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我已经用了很长时间了。我也不认为有必要降低它。</p></div><div class="ab cl od oe hy of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="in io ip iq ir"><blockquote class="ok ol om"><p id="8a44" class="la lb on lc b ld le jv lf lg lh jy li oo lk ll lm op lo lp lq oq ls lt lu lv in bi translated">感谢阅读，朋友！在<a class="ae kz" href="https://www.linkedin.com/in/thuwarakesh/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong></a><a class="ae kz" href="https://twitter.com/Thuwarakesh" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">Twitter</strong></a><a class="ae kz" href="https://thuwarakesh.medium.com/" rel="noopener"><strong class="lc iv">Medium</strong></a>上跟我打招呼。</p><p id="e0ad" class="la lb on lc b ld le jv lf lg lh jy li oo lk ll lm op lo lp lq oq ls lt lu lv in bi translated">还不是中等会员？请使用此链接<a class="ae kz" href="https://thuwarakesh.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a>因为，在没有额外费用的情况下，我赚取了一点佣金。</p></blockquote></div></div>    
</body>
</html>