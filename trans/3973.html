<html>
<head>
<title>Counting Distinct Events in Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计数流中的不同事件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/counting-distinct-events-in-streams-c80ea7d48a46#2022-09-02">https://towardsdatascience.com/counting-distinct-events-in-streams-c80ea7d48a46#2022-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9cd5" class="pw-subtitle-paragraph jr is it bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">分布式环境中的大数据统计</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/cec2022713638123e192067d7f44cbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dfu2uOUeBcq5SqSj"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">阿克顿·克劳福德在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1d46" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">想象一个无限的输入符号流。我们想知道到目前为止在任何时间点收到的不同值的数量。</p><p id="c08d" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个问题有许多用途。其中之一是跟踪某个时间段内，比如说上个月，某个访问量很大的网站的不同访问者的数量。</p><p id="f01b" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">解决这个问题最简单的方法是维护到目前为止看到的所有(不同的)值的集合。当有许多不同的值时，这会消耗大量内存。</p><p id="f34a" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们的记忆能力有限，我们能做什么？或者，如果我们处于分布式设置中，需要以分布式方式合并数据结构的许多实例，这涉及到四处传送数据结构？</p><p id="813f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">寻求精确的计数变得不可行。然而，我们仍然可以在不牺牲速度的情况下获得一个近似的计数，并获得很大的压缩。</p><p id="d6df" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">幸运的是，在许多用例中，一个(足够好的)近似计数就足够了。例如，一个网站在一个月内收到的不同访问者的数量的近似计数可能足够好，只要该近似足够好。</p><p id="2939" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从这一点开始，我们将这个问题称为<em class="lw">基数估计</em>。</p><p id="7c0d" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我们想给读者一个如何思考和处理这类问题的具体感受。为了这个目的，这个问题的简化版本将会更有效。接下来，我们将回到最初的问题，因为它有更广泛的用途。</p><p id="c56e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">计数事件</strong></p><p id="956f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们只想计算到目前为止到达流中的符号的数量。不明显的。如果实际计数为<em class="lw"> n </em>，我们可以在log n位数量级的数据结构中捕获它。嗯，这看起来已经很节省内存了，不是吗？假设我们想要做得更好。如果没有别的原因，这将迫使我们思考一个更困难问题的可行解决方案——带有<em class="lw">独特的</em>约束。</p><p id="92b3" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我们将放弃得到确切答案的目标。也就是说，我们会对一个大概的答案感到满意。只要近似“足够好”</p><p id="b571" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，让我们从这里开始。对于预先设定的固定概率<em class="lw"> p </em>，当事件到来时，以概率<em class="lw"> p，</em>让我们的计数器加1。(概率为1- <em class="lw"> p </em>，我们忽略这个事件。)在任何时候，我们对计数的估计都将是计数器的值乘以1/ <em class="lw"> p </em>。</p><p id="3159" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与当<em class="lw"> p </em>等于1时相比，通过选择<em class="lw"> p </em>足够小，我们可以在计数器中使用更少的内存。例如，假设实际数量约为43亿。这将需要32位来精确存储。通过选择<em class="lw">p</em>为1/2 ⁶，我们期望以16位通过。当然，最终的计数只是一个近似值。</p><p id="a0a8" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">更重要的是，如果我们在精确计数小得多的情况下使用相同的<em class="lw"> p </em>，我们的近似值可能会相差很远。我们估计的计数总是以1/ <em class="lw"> p </em>为单位，即0，1/ <em class="lw"> p </em>，2/ <em class="lw"> p </em>，…。对于p = 1/2 ⁶，这将是0，2⁶，2*2 ⁶，…</p><p id="65e0" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设实际数是1000。最接近1000的估计数0和2 ⁶都相差甚远。</p><p id="df64" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们可以用大的<em class="lw"> p </em>来表示低的实际计数，用小的<em class="lw"> p </em>来表示高的计数，那就太好了。莫里斯柜台体现了这种思想。</p><p id="1aa6" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设近似计数器的当前值是<em class="lw"> X </em>。假设看到了下一个事件。准确的计数器会在<em class="lw"> X </em>上加1。莫里斯计数器以1/2^ <em class="lw"> X </em>的概率给<em class="lw"> X </em>加1。</p><p id="e79f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这样做的效果是，流中较早发生的事件比流中较晚发生的事件更有可能被计数。这很直观。</p><p id="b5f1" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这么想吧。想象一下50个事件的切片。假设这些是流中的前50个事件。我们希望使用一个非常大的p值，这样，如果流在那里结束，我们的估计计数就足够好了。例如，如果<em class="lw"> p </em>为0，那么我们的估计计数将为0，而实际计数为50。</p><p id="6c1f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">另一方面，如果这50个事件发生在已经看过一百万个事件之后，我们可以使用更低的<em class="lw"> p </em>，实际上甚至是0。一百万是“一百万加50”的一个很好的近似值。</p><p id="5c55" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">计数<em class="lw">不同的</em>事件</strong></p><p id="6cd5" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们回到激发这篇文章的问题:估计在一个流中遇到的<em class="lw">不同</em>项的数量。</p><p id="791e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面我们来说明一下这个问题。假设我们生成<em class="lw"> n </em>个数字1/ <em class="lw"> n </em>，2/ <em class="lw"> n </em>，…，3/ <em class="lw"> n </em>。请注意，它们平均分布在0和1之间。接下来，我们将它们复制任意多次。最后，我们任意排列这个集合。我们能从最终数据推断出<em class="lw"> n </em>吗？</p><p id="6527" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里有一个<em class="lw"> n </em> = 4的例子。</p><pre class="kk kl km kn gt lx ly lz ma aw mb bi"><span id="d8b3" class="mc md it ly b gy me mf l mg mh">0.25 0.5 0.75 1               // <strong class="ly iu">4 numbers uniformly spread in (0,1]</strong><br/>0.25 0.25 0.25 0.5 0.5 0.75 1 1 // <strong class="ly iu">Some replicates added</strong><br/>0.5 0.25 0.25 0.25 1 0.75 0.5 1 // <strong class="ly iu">Permuted</strong></span></pre><p id="2458" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们的第一个想法是，我们找到这些数字的最小值，并输出一除以这个最小值作为我们的估计。在我们的例子中，最小值是0.25，1/0.25是4，这确实是不同项目的数量。</p><p id="eea5" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个想法的吸引力在于流中的最小值可以以流的方式更新。速度非常快，而且内存容量不变。</p><p id="ae93" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有意思。在我们的例子中，数字平均分布在0和1之间。我们如何解除这一限制？这将我们引向…</p><p id="d73d" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">使用最小散列的概率计数</strong></p><p id="a215" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们先适当散列。不管使用什么情况，一个有效的散列函数都将数据<em class="lw">均匀地</em>映射到固定数量<em class="lw"> m </em>个桶上。这正是我们想要的。除了0，1，…，<em class="lw"> m </em> -1到(0，1)的重新缩放只涉及除以<em class="lw"> m </em>和加1。</p><p id="3fce" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当然，你可以说我们已经把问题从原来的问题转移到寻找一个均匀分布数据的散列函数。幸运的是，在过去的几十年里，已经有了很多关于哈希函数对哪种类型的数据做这种事情的研究和经验。</p><p id="bfa8" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">使用这种方法的基数估计如下。我们选择一个散列函数，我们认为它将在0和1之间平均分布这些值。在做这个选择时，我们可能需要了解到达数据流的数据的性质。</p><p id="467d" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">(还要注意，我们不允许对数据进行多次传递，例如第一次学习哈希函数，下一次使用它。也就是说，我们想要一个纯粹的流式解决方案。)</p><p id="c1f7" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，当数据以流的形式到达时，我们保持我们看到的散列值的最小值。一除以这个最小值就是我们对原始集合的基数的估计。</p><p id="f637" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> Min+Invert放大哈希函数中的噪声</strong></p><p id="0409" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">合理的预期是，我们选择的哈希函数对于我们正在建模的数据来说并不完美。特别是，数据集中的最小哈希值可能与它应有的值相差甚远。例如，如果它是应有数量的一半，估计的数量将是应有数量的两倍。</p><p id="3e95" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">取最小值会放大哈希函数中的噪声。直觉类似于为什么iid随机变量的最小值具有比它们的和更高的方差的直觉。非正式地说，当取总和时，变量的可变性倾向于抵消，而当取最小值时则不会。</p><p id="b53f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">反转噪声最小值会进一步放大噪声。</p><p id="1678" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以让我们寻求一种噪音更小的方法。</p><p id="8e8e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">最大前导位哈希概率计数</strong></p><p id="059f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">和前面的方法一样，首先，我们散列。这一次，我们将哈希值视为一个二进制数(固定位数)。接下来，我们计算<em class="lw"> k </em>，这个哈希值中0值位的最长前缀的长度。因此，<em class="lw"> k </em>对于<strong class="lc iu"> 0 </strong> 110将是1，对于<strong class="lc iu"> 00 </strong> 10将是2。最后，我们跟踪<em class="lw"> k </em> _max，这是流中计算的哈希值在所有这些<em class="lw"> k </em>中的最大值。我们返回2^( <em class="lw"> k </em> _max)作为流中不同事件的估计数量。</p><p id="e8db" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">直觉是什么？想象一下，我们的散列函数将任何固定事件<em class="lw"> x </em>映射到从散列函数的范围中随机均匀选择的一个数。(注意，相同的<em class="lw"> x </em>应该总是映射到相同的哈希值。)</p><p id="b07b" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于任何固定的<em class="lw"> x </em>，其哈希值以<em class="lw"> k </em>连续0开始的概率为1/(2^ <em class="lw"> k </em>。这是因为在<em class="lw"> k </em>位上有2^ <em class="lw"> k </em>个二进制数，其中正好有一个是“全0”。</p><p id="1bb3" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，如果我们在流中遇到2^<em class="lw">k</em>不同的事件，我们会期望它们的哈希值之一以<em class="lw">k</em>连续的0开始。将这个推理反过来，如果<em class="lw"> k </em> _max是找到的任何散列值开始的0值比特的最大数量，则2^( <em class="lw"> k </em> _max)是从其导出这样一组散列值的流中的不同事件的数量的合理估计。</p><p id="5070" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这种方法非常节省内存。假设散列函数的范围是一个<em class="lw"> m </em>位数。也就是说，散列函数在其范围内有<em class="lw"> n </em> =2^ <em class="lw"> m </em>个不同的值。在处理流的时候，我们只需要跟踪和更新<em class="lw"> k </em> _max。<em class="lw"> k </em> _max的值可以存储在log <em class="lw"> m </em>位的二进制数中。用<em class="lw"> n </em>表示——我们可以区分的不同事件的最大值——这只是log(log <em class="lw"> n </em>))位。</p><p id="c965" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与前面的方法一样，这种方法也放大了哈希函数的噪声，尽管可能没有那么大。说实际产生的<em class="lw"> k </em> _max才是真正的一加二。从前者得到的估计计数将是从真实的<em class="lw"> k </em> _max得到的4倍。</p><p id="9ea6" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">通过使用多个哈希函数来改进估计</strong></p><p id="6fe9" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以使用多个独立的散列函数，并取它们产生的估计值的平均值。得到的估计值通常具有较低的方差，因此会更准确。这适用于我们到目前为止看到的两种方法。</p><p id="3cfc" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们使用的散列函数越多，我们的估计就越准确。也就是说，我们将需要为我们看到的任何一个事件<em class="lw"> x </em>计算许多<em class="lw"> </em>哈希值。当我们使用的散列函数的数量达到1000个时，这可能会变得非常耗时。</p><p id="14eb" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个叫做<em class="lw">随机平均</em>的巧妙程序使用一个散列函数来模拟多个散列函数的效果。假设我们的哈希函数将一个x映射到一个<em class="lw"> m </em>位的随机二进制数。我们将把由第一个<em class="lw"> q </em>位形成的二进制数解释为散列函数标识符，将由剩余的<em class="lw"> m个</em> - <em class="lw"> q </em>位形成的二进制数解释为所识别的散列函数的值。</p><p id="d633" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，对于事件的任何一次发生，该方法在<em class="lw"> m </em> - <em class="lw"> q </em>位上只给出一个散列函数的值。尽管如此，我们得到了方差减少的好处，因为现在就好像我们已经从2^ <em class="lw"> q </em>选择中为这个实例随机选择了散列函数。</p><p id="111a" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们确实需要跟踪和更新2^的值，因为我们现在已经有了那么多的散列函数。在估算的时候，我们将需要使用所有这些2^值。</p><p id="9793" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">最大前导位哈希的估计计数</strong></p><p id="53e9" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是:</p><p id="585e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">常数*<em class="lw">p</em>*2^(mean(<em class="lw">r</em>1、…、<em class="lw"> Rp </em>)、<em class="lw"> p </em> = 2^ <em class="lw"> q </em></p><p id="8ad7" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里<em class="lw"> R </em> 1、…、<em class="lw"> Rp </em>是<em class="lw"> p </em>哈希函数传递的最大前导0位数，mean( <em class="lw"> R </em> 1、…、<em class="lw"> Rp </em>)是它们的算术平均值。前两个因素，常数和<em class="lw"> p </em>，修正了单独使用2^(mean( <em class="lw"> R </em> 1、…、<em class="lw">RP</em>)<strong class="lc iu"/>会引入的偏差。这些因素我们就不多说了。如果仅使用一个散列函数，则<em class="lw"> R </em> 1，…，<em class="lw"> Rp </em>的平均值将是R1。使用多个哈希函数时，单个值会被平均值替换。正是这一点减少了方差。</p><p id="101a" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">用调和平均值代替算术平均值</strong></p><p id="8c2d" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">根据[2]，在[4]中观察到，R1到Rp的最大值不成比例地对平均值中的噪声产生影响(<em class="lw"> R </em> 1，…，<em class="lw"> Rp </em>)。这可能是如下的直觉。</p><p id="5a21" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设流中有<em class="lw"> N </em>个事件。每个哈希函数<em class="lw"> i </em>看到其中的<em class="lw"> N </em> / <em class="lw"> p </em>。因此，对于比1大得多的<em class="lw"> p </em>，与当<em class="lw"> p </em>为1时相比，从更小的样本<em class="lw"> N </em> / <em class="lw"> p </em>中估计<em class="lw"> R </em> i。这导致了估计的误差。因为在估算R时我们使用了最大值运算，所以更是如此。最后，取2^(mean( <em class="lw"> R </em> 1，…，<em class="lw"> Rp </em>))进一步放大噪声。</p><p id="761c" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当然，使用一个远大于1的<em class="lw"> p </em>仍然比使用<em class="lw"> p </em> = 1要好。问题是，我们是否可以通过用其他东西替换<em class="lw"> R </em> 1、…、<em class="lw"> Rp </em>的算术平均值来进一步提高估计值？</p><p id="b2f0" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">事实证明，是的。从取算术平均值切换到<em class="lw">谐波</em>平均值。众所周知，算术平均值受到异常值的过度影响(在我们的例子中，Ri过大)。相比之下，调和平均值更倾向于较小的Ri，因此对右尾异常值更稳健。</p><p id="ca36" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个增强序列的最终数据结构被称为<em class="lw">超对数对数</em> (HLL)。</p><p id="49b1" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">可制造性</strong></p><p id="2b4f" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在假设事件以两个流的形式到达，由两个不同的服务器独立处理，这两个服务器可能相距很远。你在想象一个分布式的环境。(实际上可能有数千个服务器，而不仅仅是两个。)</p><p id="1b1e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们希望每个服务器都能处理它的数据流。然而，我们还希望跨两个流的事件计数不同。为了做到这一点，我们需要我们的数据结构是可合并的。</p><p id="7d67" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">向数据结构中添加可合并性支持可以加速其在分布式设置中的使用。我们可以高效简洁地独立处理大量的流，然后在需要连接流中的点时合并数据结构。</p><p id="1cc1" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">好了，数据结构应该支持合并操作，从两个实例构建数据结构的新实例。这个新实例是两者的“联合”。如果您将两个流合并，并直接从它构建一个实例，那么您将会得到它。这可以描述如下。</p><p id="54f1" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">构建(s1) +构建(s2) =构建(s1+s2)</p><p id="1d7e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">其中左手边的+表示<em class="lw">数据结构</em>合并操作，右手边的+表示<em class="lw">流</em>合并操作。</p><p id="b5cf" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">只要两个实例使用相同的“优步”散列函数、相同的<em class="lw"> q </em>和相同的<em class="lw"> n </em>，HLL就是可合并的。对于每个<em class="lw"> i </em>，合并实例的Ri就是输入实例的<em class="lw"> R </em> i的最大值。</p><p id="2270" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">只要实例使用相同的散列函数，最小散列数据结构也是可合并的。</p><p id="88b0" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">总结</strong></p><p id="c230" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这篇文章研究了计算到达一个潜在无限流中的不同事件的数量的问题。这个问题有很多用途，例如，计算网站的不同访问者的数量。</p><p id="bf29" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">将问题简化为获得计数的估计值，而不一定是其精确值，这为概率数据结构打开了大门，当数据到达时，概率数据结构可以有效而简洁地捕获有关数据的某些信息。估计需求数量所需的信息，即何时需要。这种数据结构还支持可合并性，这允许它们在任意复杂的分布式设置中使用。也就是说，可能在地理上分散的大量流中的每一个可以在本地被处理，并且数据结构根据需要被合并以估计计数，就好像它来自单个合并的流一样。</p><p id="52cb" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">延伸阅读</strong></p><ol class=""><li id="c8c9" class="mi mj it lc b ld le lg lh lj mk ln ml lr mm lv mn mo mp mq bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Count-distinct_problem" rel="noopener ugc nofollow" target="_blank">计数问题——维基百科</a></li><li id="1099" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><a class="ae kz" href="https://engineering.fb.com/2018/12/13/data-infrastructure/hyperloglog/" rel="noopener ugc nofollow" target="_blank"> HyperLogLog in Presto:更快的基数估计Meta工程</a></li><li id="987d" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><a class="ae kz" href="https://courses.engr.illinois.edu/cs498abd/fa2020/slides/04-lec.pdf" rel="noopener ugc nofollow" target="_blank">概率计数和莫里斯计数器</a></li><li id="0d19" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><a class="ae kz" href="https://hal.inria.fr/inria-00076244/file/RR-0313.pdf" rel="noopener ugc nofollow" target="_blank">数据库应用的概率计数算法</a></li><li id="c3cb" class="mi mj it lc b ld mr lg ms lj mt ln mu lr mv lv mn mo mp mq bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/HyperLogLog" rel="noopener ugc nofollow" target="_blank">超级日志—维基百科</a></li></ol></div></div>    
</body>
</html>