<html>
<head>
<title>Generating a Synthetic Dataset for Machine Learning and Software Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为机器学习和软件测试生成合成数据集</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generating-a-synthetic-dataset-for-machine-learning-and-software-testing-7bebaed69386#2022-05-20">https://towardsdatascience.com/generating-a-synthetic-dataset-for-machine-learning-and-software-testing-7bebaed69386#2022-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python生成统计上相似的虚拟数据集，用于代码开发和测试健壮性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a81b03d2d703dbed8fadd8b340bfe77b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RAVOZbjWRxUvRYE3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hjkp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亨利·佩克斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="088b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">据此</h1><p id="d61f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为测试生成真实的数据集是一个突出的问题。这在两个领域之一经常遇到:机器学习或软件工程。</p><h2 id="6bef" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">创建更可靠的模型</h2><p id="00d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在机器学习中，过拟合往往是一个非常突出的问题。如果一个模型过拟合一个小的/有限的/不平衡的数据集，那么它对未知数据产生准确预测的可靠性就会大大降低。对此的一个解决方案是使用合成数据集来扩展“训练”数据集，合成数据集是自动生成的数据集，具有与原始数据集相同的形式、大小和分布。</p><h2 id="634f" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">看不见或不可用的数据</h2><p id="3174" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">类似地，如果我们正在编写一个应用程序来读取、查询或可视化数据(这还不可用)，我们可能希望通过使用一个伪真实的虚拟数据集来测试它的健壮性。通过这样做，我们能够在数据的最新迭代被处理之前就开始开发全新的应用程序。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="4c42" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">数据预测</h1><p id="921a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然生成数据的方法很多，例如缩放、变换、标准化、添加噪声、混洗等。我们感兴趣的是保持形式，同时产生一个新的扰动样本集。为了做到这一点，我们依赖于copulas——与传统的相关性计算相比，copulas允许我们更好地捕捉诸如非线性尾部相关性等细微差别。</p><h2 id="9bfc" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">什么是系词？</h2><p id="cca1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">联合分布解释了我们的<code class="fe nl nm nn no b">n</code>随机变量(向量)是如何相互关联的。它由两件事组成:</p><ul class=""><li id="7018" class="np nq it lt b lu nr lx ns ma nt me nu mi nv mm nw nx ny nz bi translated">边际:对边际行为的描述(每个分布的边缘是什么)</li><li id="f94a" class="np nq it lt b lu oa lx ob ma oc me od mi oe mm nw nx ny nz bi translated">每个变量的边际(尾部)概率分布均匀的多元累积分布函数，赢得区间<code class="fe nl nm nn no b">[0,1]</code>。这是系词。</li></ul><p id="2ceb" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">copula描述了数据集中所有随机变量或组件之间的相关性结构。</p><h1 id="5d9c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">将它们全部编码成Python</h1><h2 id="f56f" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">装置</h2><p id="ae69" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了生成我们的合成数据集，我们使用了<a class="ae ky" href="https://dmey.github.io/synthia/index.html" rel="noopener ugc nofollow" target="_blank"> Synthia </a>包。这可以与以下设备一起安装:</p><pre class="kj kk kl km gt oi no oj ok aw ol bi"><span id="6c25" class="mn la it no b gy om on l oo op">pip install synthia</span></pre><h2 id="b9fc" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">加载和清理数据</h2><p id="2d1d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们首先加载数据，并提取数值列的子集，用于数据生成器。在这里，我还将任何<code class="fe nl nm nn no b">nan (<em class="oq">not a number)</em></code>项替换为零——这是因为我希望应用高斯连接函数，对于该函数，线性代数(sqrtm)计算需要对矩阵求逆。</p><p id="4109" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated"><em class="oq">如果使用独立系词(参见“代码”部分的片段),则不需要这一步。</em></p><pre class="kj kk kl km gt oi no oj ok aw ol bi"><span id="5ab5" class="mn la it no b gy om on l oo op"><em class="oq"># Load the original data    </em><br/>data  = pd.read_csv(filename, index_col=0)    </span><span id="c9ef" class="mn la it no b gy or on l oo op"><em class="oq"># Get file datatypes    </em><br/>dtypes = data.dtypes    </span><span id="71d4" class="mn la it no b gy or on l oo op"><em class="oq"># Get the names of the columns with numeric types   </em> <br/>numeric = data.columns[dtypes.apply(pd.api.types.is_numeric_dtype)]    </span><span id="ad2f" class="mn la it no b gy or on l oo op"><em class="oq"># Extract numeric subset    </em><br/>subset = data.loc[:,numeric].replace(np.nan, 0)</span></pre><h2 id="e436" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">构建数据生成器</h2><p id="65e0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用Synthia包，我们创建了一个copula数据生成器。利用这一点，我们拟合高斯连接函数，并使用以下代码将数据参数化为分位数:</p><pre class="kj kk kl km gt oi no oj ok aw ol bi"><span id="d03f" class="mn la it no b gy om on l oo op"><em class="oq"># Create Generator  </em>  <br/>generator = syn.CopulaDataGenerator()     </span><span id="aa4a" class="mn la it no b gy or on l oo op"><em class="oq"># Define Coupla and Parameterizer </em>   <br/>parameterizer = syn.QuantileParameterizer(n_quantiles=100)       </span><span id="fcda" class="mn la it no b gy or on l oo op">generator.fit(subset, copula=syn.GaussianCopula(), parameterize_by=parameterizer)   </span></pre><h2 id="379b" class="mn la it bd lb mo mp dn lf mq mr dp lj ma ms mt ll me mu mv ln mi mw mx lp my bi translated">创建新数据集</h2><p id="ab91" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了一个生成器，我们可以用它来创建一个与原始数据集大小相同的样本数据集。在ML任务的情况下，我们可能希望将样本量增加到一个任意大的数字。</p><pre class="kj kk kl km gt oi no oj ok aw ol bi"><span id="e58d" class="mn la it no b gy om on l oo op">samples = generator.generate(n_samples=len(subset), uniformization_ratio=0, stretch_factor=1)    </span><span id="b2aa" class="mn la it no b gy or on l oo op">synthetic = pd.DataFrame(samples, columns = subset.columns, index = subset.index)     </span></pre><p id="8609" class="pw-post-body-paragraph lr ls it lt b lu nr ju lw lx ns jx lz ma of mc md me og mg mh mi oh mk ml mm im bi translated">最后，我们可以复制原始数据帧，并用新生成的值替换这些值:</p><pre class="kj kk kl km gt oi no oj ok aw ol bi"><span id="28da" class="mn la it no b gy om on l oo op">update = data.loc[:]<br/>update.loc[:,numeric]= synthetic.loc[:,numeric]    <br/>update = update.astype(dtypes)     </span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="c5f1" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">结论</h1><p id="4bf4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在能够使用pandas和Syntia包创建人工数据集，并在旧数据集的位置注入它们。这有许多应用，并不局限于取代测试的机密信息，在数据集可用之前进行软件开发，或扩展训练数据集作为提高人工智能性能的手段。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="2463" class="kz la it bd lb lc ng le lf lg nh li lj jz ni ka ll kc nj kd ln kf nk kg lp lq bi translated">密码</h1><p id="d94c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个项目中使用的脚本附后。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><h1 id="9333" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">资源</h1><p id="e170" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">关于系词的更多信息可以在<a class="ae ky" href="https://medium.com/kxytechnologies/a-primer-on-copulas-from-a-machine-learning-perspective-b9ea11c8681b" rel="noopener">这里</a>和<a class="ae ky" href="https://www.youtube.com/watch?v=WFEzkoK7tsE" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>