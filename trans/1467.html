<html>
<head>
<title>Building an Open Source ML Pipeline: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建开源ML管道:第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-open-source-ml-pipeline-part-1-5b52d06351d1#2022-04-11">https://towardsdatascience.com/building-an-open-source-ml-pipeline-part-1-5b52d06351d1#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">开始使用我们的管道——数据采集和存储。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/96fd36dd1dff90aa8c3d40f37e2c8001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2bWZmQWzI6v2k5mX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亨特·哈里特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="f2c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。简介</strong></p><p id="1f2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一系列的文章中，我感兴趣的是尝试将一个考虑到现代MLOps实践的基本ML管道放在一起。自然地，在这些项目的开始，我们列出了一个需求列表，那么我们希望我们的管道做什么呢？</p><ul class=""><li id="1b41" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">自动检索用于模型训练和推理的数据。</li><li id="42c9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在模型推断之前验证数据。</li><li id="060e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">为我们的模型自动搜索超参数。</li><li id="96d0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">自动化模型存储和指标跟踪。</li><li id="cf33" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">持续交付训练好的模型。</li><li id="a439" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">模型监控。</li><li id="ef55" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">自动化模型再训练。</li></ul><p id="b263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用哪些工具来完成这些事情？我不敢说这是做事的最佳方式，但我认为这是一个不错的开始。我们将使用<a class="ae kv" href="https://argoproj.github.io/argo-workflows/" rel="noopener ugc nofollow" target="_blank"> Argo工作流</a>作为我们系统的主干。有了Argo，我们可以定义操作的有向无环图(DAGS ),这将有助于我们建立数据管道。为了存储我们的数据，我们将使用<a class="ae kv" href="https://min.io/" rel="noopener ugc nofollow" target="_blank"> Minio </a>。为了验证数据，我们将使用<a class="ae kv" href="https://greatexpectations.io/" rel="noopener ugc nofollow" target="_blank"> Great Expectations </a>，一个用于数据验证的python工具。我以前写过一篇关于结合Argo和远大前程的文章，你可以在这里找到<a class="ae kv" rel="noopener" target="_blank" href="/data-validation-with-great-expectations-and-argo-workflows-b8e3e2da2fcc"/>。对于超参数优化，我们将利用Argo的能力来运行并行管道步骤和动态扇出/入。对于模型存储和指标跟踪，我们将利用<a class="ae kv" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLflow </a>。作为一个特色商店，我们将使用<a class="ae kv" href="https://feast.dev/" rel="noopener ugc nofollow" target="_blank">盛宴</a>。对于模型监控和连续交付，我们将使用<a class="ae kv" href="https://github.com/SeldonIO/seldon-core" rel="noopener ugc nofollow" target="_blank"> Seldon Core </a>最后，为了自动化模型重新训练和处理其他基于事件的依赖关系，我们将使用<a class="ae kv" href="https://argoproj.github.io/argo-events/" rel="noopener ugc nofollow" target="_blank"> Argo Events </a>。一切都将部署在minikube集群上。我会尽我所能地讲述整个过程，并对工具的选择保持透明。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="7091" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。入门</strong></p><p id="3e4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们管道的一个构件是Minio对象存储。为什么是米尼奥？Minio是免费的，非常容易使用。同样，你也没有理由不能用你的应用程序的任何云对象存储来代替Minio。</p><p id="0408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我假设一开始就安装了<a class="ae kv" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> minikube </a>、<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>、<a class="ae kv" href="https://github.com/argoproj/argo-workflows/releases/tag/v3.3.1" rel="noopener ugc nofollow" target="_blank"> argo命令行工具</a>和<a class="ae kv" href="https://helm.sh/docs/intro/install/" rel="noopener ugc nofollow" target="_blank"> helm </a>。这给了我们一个起点，来生成我们将需要的所有kubernetes资源，以形成一个有效的ML管道。</p><p id="5c2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始我们的minikube集群:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="327d" class="ms mt iq mo b gy mu mv l mw mx">minikube start --cpus 4</span></pre><p id="cb7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的实例有4个可用的CPU和大约8 Gb的内存。</p><p id="1d2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们使用Bitnami helm图表部署Minio:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="cfe5" class="ms mt iq mo b gy mu mv l mw mx">kubectl create ns mlops<br/>helm repo add bitnami <a class="ae kv" href="https://charts.bitnami.com/bitnami" rel="noopener ugc nofollow" target="_blank">https://charts.bitnami.com/bitnami</a><br/>helm repo update<br/>helm install minio bitnami/minio --namespace mlops</span></pre><p id="5b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照shell中显示的说明获取您的凭据，并将它们存储在某个地方！</p><p id="a02e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们设置Argo工作流。我们可以使用他们的快速启动安装来实现。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="ade2" class="ms mt iq mo b gy mu mv l mw mx">kubectl create ns argo <br/>kubectl apply -n argo -f https://raw.githubusercontent.com/argoproj/argo-workflows/master/manifests/quick-start-postgres.yaml</span></pre><p id="24b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们应该有一个Argo工作流的工作安装。</p><p id="d284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按如下方式获取您的登录令牌(我们稍后会用到):</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="e72c" class="ms mt iq mo b gy mu mv l mw mx">SECRET=$(kubectl -n argo get sa argo -o=jsonpath='{.secrets[0].name}')<br/>ARGO_TOKEN="Bearer $(kubectl -n argo get secret $SECRET -o=jsonpath='{.data.token}' | base64 --decode)"</span><span id="fdb4" class="ms mt iq mo b gy my mv l mw mx">echo $ARGO_TOKEN</span></pre></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="6789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。提取、转换、加载</strong></p><p id="9a34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，我们已经准备好了核心工具，可以在非常基本的ETL管道上工作了。我们将从<a class="ae kv" href="https://openaq.org/#/" rel="noopener ugc nofollow" target="_blank"> OpenAQ </a> API获取数据。对于个人项目来说，OpenAQ是一个很好的资源，API可以提供世界各地城市的空气质量数据。</p><p id="e129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把我们的数据检索管道组织成三个部分。</p><ol class=""><li id="747a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr mz ly lz ma bi translated">从OpenAQ API获取JSON格式的数据。</li><li id="69b2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mz ly lz ma bi translated">将数据转换为Pandas Dataframe并估算缺失值。</li><li id="914d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr mz ly lz ma bi translated">将Pandas Dataframe保存为拼花文件并加载到Minio bucket。</li></ol><p id="26c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面列出了这些步骤的脚本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="855a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，我对OpenAQ进行API调用，以获取奥地利维也纳市的空气质量数据。该调用针对前一天到当天的所有数据。计划是制作一个Cron工作流，在晚上执行我们的ETL管道。对于转换，我们将JSON响应转换为Pandas数据帧，并删除所有包含NaN值的行。最后，在加载部分，我们将数据作为一个parquet文件上传到我们的Minio实例。现在是有趣的部分！设置我们的Argo工作流CronJob。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="c966" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。阿尔戈</strong></p><p id="efbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置<a class="ae kv" href="https://argoproj.github.io/argo-workflows/cron-workflows/" rel="noopener ugc nofollow" target="_blank"> Cron工作流</a>对我来说是新的，所以我很想听到任何反馈。该工作流应该在每天凌晨1点运行。有趣的是，当我提交它时，我收到一条消息说它将在凌晨3点运行，因为我的本地时间与UTC有偏差。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用Argo命令行工具提交此工作流:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="0f36" class="ms mt iq mo b gy mu mv l mw mx">argo -n argo cron create ETL.yaml</span></pre><p id="859d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在进入Argo UI，我们可以提交Cron作业来测试它。希望你也看到绿色支票！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/358de6d236400c258d655bf6fc4b7048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kL-8VcPik8PbaTcVzOADYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><p id="6db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且应该已经在我们的Minio对象存储中创建了一个文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/6f4aa8eb102e58f278804194b7db7f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dKN74dapiUWlAEmjynvMzg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片作者。</p></figure><p id="0f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这是ML流水线的第一步。获取数据，对其进行简单的转换，并存储起来以备将来使用。在下一篇文章中，我想设置Argo事件来触发基于这个Minio桶中出现的新文件的工作流！敬请关注。</p><p id="0d55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ne">在这里</em>  <em class="ne">找到系列</em> <a class="ae kv" rel="noopener" target="_blank" href="/building-an-open-source-ml-pipeline-part-2-29a8dcbc7620"> <em class="ne">的第二部。</em></a></p></div></div>    
</body>
</html>