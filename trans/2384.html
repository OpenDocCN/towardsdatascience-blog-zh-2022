<html>
<head>
<title>Similarity Search with IVFPQ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用IVFPQ进行相似性搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/similarity-search-with-ivfpq-9c6348fd4db3#2022-05-25">https://towardsdatascience.com/similarity-search-with-ivfpq-9c6348fd4db3#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="363b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何实现倒排文件索引(IVF)和乘积量化(PQ ),以实现快速有效的近似最近邻搜索</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd3f000b48a8bba6801dcd744e7ee2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW-Au0Aicq3ZHt_dXc_jbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Voronoi细胞。除非另有说明，所有图片均为作者所有</p></figure><p id="e946" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上一篇关于<a class="ae lu" rel="noopener" target="_blank" href="/product-quantization-for-similarity-search-2f1f67c5fddd"> <strong class="la iu">相似性搜索的产品量化</strong> </a>的文章中，我们解释了什么是产品量化，并详细介绍了产品量化如何用于相似性搜索。</p><p id="d705" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乘积量化将数据库中的每个向量转换为短码(PQ码)，这种表示形式对于近似最近邻搜索来说非常节省内存。</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/product-quantization-for-similarity-search-2f1f67c5fddd"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">用于相似性搜索的产品量化</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">如何在内存中压缩和适应一个庞大的向量集，以便用非对称距离计算进行相似性搜索…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="85a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如文章中提到的，产品量化是高度可扩展的，但是单独实现产品量化对于大规模搜索来说并不是最有效的方法。</p><p id="12bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本帖中，我们将研究和学习如何将产品量化与倒排文件索引相结合，以形成一种高效快速且记忆灵敏的搜索方法。</p><blockquote class="mn mo mp"><p id="f1a1" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated">在研究论文中，IVFPQ通常也称为IVFADC。</p></blockquote></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e6ac" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">倒排文件索引</h1><p id="8ba5" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">一个<a class="ae lu" href="https://en.wikipedia.org/wiki/Inverted_index" rel="noopener ugc nofollow" target="_blank">倒排文件</a>是一个索引结构，用于将<em class="mq">内容</em>映射到它们的<em class="mq">位置</em>。</p><p id="3ddd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会问，<em class="mq">内容</em>和<em class="mq">位置</em>是什么，倒排文件索引如何应用于带有产品量化的相似性搜索？</p><p id="f99b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的上下文中，<em class="mq">内容</em>指的是数据库向量，<em class="mq">位置</em>指的是这些向量所在的分区。</p><p id="57ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，你没听错，我们需要对数据库向量进行分区。对数据库向量进行分区的原因是为了只对特定分区的向量而不是所有向量进行搜索。</p><h2 id="0b27" class="ny nc it bd nd nz oa dn nh ob oc dp nl lh od oe nn ll of og np lp oh oi nr oj bi translated">粗略量化器</h2><p id="78e3" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">首先，数据库向量被分成<code class="fe ok ol om on b">k'</code>个分区。分割是通过<a class="ae lu" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank"> k均值聚类</a>完成的，产生了我们所说的粗量化器。</p><p id="5f2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，构建了一个倒排文件索引，它将用于将向量列表(即倒排列表)映射到相应的分区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f7ddbc07368f8e543a950111d680b293.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*BtuQKl80aU1b8WSZxMKh9Q.png"/></div></figure><p id="068d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个分区由一个<em class="mq">分区质心</em>来表示和定义，每个向量只能属于一个分区。这种结构有时被称为<a class="ae lu" href="https://en.wikipedia.org/wiki/Voronoi_diagram" rel="noopener ugc nofollow" target="_blank"> Voronoi </a>单元，因此基于分区的搜索策略也被称为<em class="mq">单元探测</em>方法<em class="mq">。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/d6cd9b1302caaa9cea647f3e0eda6056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*bInx8pS8USZK4_mNCf59Bg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Voronoi单元的例子</p></figure><h1 id="de78" class="nb nc it bd nd ne oq ng nh ni or nk nl jz os ka nn kc ot kd np kf ou kg nr ns bi translated">剩余向量的乘积量化</h1><p id="8267" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">接下来，对于训练和编码，我们采用与<a class="ae lu" rel="noopener" target="_blank" href="/product-quantization-for-similarity-search-2f1f67c5fddd"> <strong class="la iu">相似性搜索的产品量化</strong> </a>中描述的相同的过程，除了这次训练和编码是在剩余向量而不是原始向量上完成的。</p><h2 id="d5b1" class="ny nc it bd nd nz oa dn nh ob oc dp nl lh od oe nn ll of og np lp oh oi nr oj bi translated">什么是剩余向量</h2><p id="d34b" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">剩余向量只不过是向量从其<em class="mq">分区质心</em>的偏移，即原始向量与其关联的<em class="mq">分区质心</em>之间的差。</p><p id="6a14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了计算残差，我们只需从原始向量中减去质心。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/237d2cce4d18278a6c512e9049bbe1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*o6tLFAPCY5kZWIGOLOn8gw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计算残差，向量从其<em class="ow">分区质心</em>的偏移量</p></figure><h2 id="0ac8" class="ny nc it bd nd nz oa dn nh ob oc dp nl lh od oe nn ll of og np lp oh oi nr oj bi translated">为什么是剩余向量</h2><p id="cdab" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">为什么我们要使用残差向量，还要经历额外的计算残差的步骤？</p><p id="5250" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码残差向量背后的直觉是提高准确性，因为编码残差比编码原始向量更精确。</p><p id="33e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了理解这意味着什么，我们用一组三维向量来说明。注意，在现实生活中，对这种低维向量应用乘积量化是不实际的。三维向量在此仅用于在计算残差之前和之后解释和可视化它们。</p><p id="ca7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，向量可以清楚地分成两个分区，分区质心<em class="mq">用红圈表示。还有一个用橙色十字符号表示的查询向量。如下图所示，这个查询向量非常接近<code class="fe ok ol om on b">Partition B</code>。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/20368faba18dff03a4bc4e922a0259c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*dYa4Ltel6uvSOn2emvUlqg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第一个图-具有两个分区的原始向量</p></figure><p id="f80e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算完剩余向量后，让我们看看它们在下图中的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/e190f1d3894be22a8f4f66fc7edbf19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*IpQ2CU7pLZsyJ5GHbd6-7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">第二幅图——剩余向量</p></figure><h2 id="b49d" class="ny nc it bd nd nz oa dn nh ob oc dp nl lh od oe nn ll of og np lp oh oi nr oj bi translated"><strong class="ak">第一次观察</strong></h2><p id="9bde" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">通过获取残差，来自两个分区的数据点实际上已经重新定位到以原点为中心的相同空间，并且彼此重叠。这与第一个图非常不同，在第一个图中，可以看到两个分区彼此隔离。</p><blockquote class="oz"><p id="a217" class="pa pb it bd pc pd pe pf pg ph pi lt dk translated">取残差类似于将质心移动到原点，这样所有的数据点现在都聚焦在原点上。</p></blockquote><h2 id="870c" class="ny nc it bd nd nz pj dn nh ob pk dp nl lh pl oe nn ll pm og np lp pn oi nr oj bi translated"><strong class="ak">第二次观察</strong></h2><p id="4067" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">让我们注意第一个图中的查询向量和第二个图中的查询向量的残差。</p><p id="b678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二个图中，<code class="fe ok ol om on b">Query Residual A</code>是查询向量从分区A的质心的偏移，而<code class="fe ok ol om on b">Query Residual B</code>是查询向量从分区b的质心的偏移。</p><blockquote class="oz"><p id="d03c" class="pa pb it bd pc pd pe pf pg ph pi lt dk translated">在残差计算之前和之后，查询记录到相应分区和数据点的距离保持不变。</p></blockquote><p id="0574" class="pw-post-body-paragraph ky kz it la b lb po ju ld le pp jx lg lh pq lj lk ll pr ln lo lp ps lr ls lt im bi translated">从所有这些观察中我们能得出什么结论？</p><p id="ca67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令人惊讶的是，通过获取残差，我们设法减少了来自所有分区的数据点的分布，并将它们压缩到相同的区域，同时保持了到查询记录的相同距离。</p><p id="86c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于数据集中的方差较低，当使用乘积量化进行近似最近邻搜索时，这将转化为较小的误差，并最终导致更好的搜索质量。</p><p id="95e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，在理解了剩余向量以及为什么使用它们之后，让我们回到<a class="ae lu" rel="noopener" target="_blank" href="/product-quantization-for-similarity-search-2f1f67c5fddd">乘积量化过程</a>。</p><p id="9db7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">概括地说，从乘积量化训练中学习码本，并且从编码过程中生成PQ码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/6dc2c10d84cc6dfd01eda8ebe2c1fb5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*7UyGJJUczxctJ7jPoVyptA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品量化培训和编码流程</p></figure><p id="3063" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着倒排文件索引的出现，PQ代码现在作为倒排列表条目的一部分被包括在内。如下所示，倒排表的条目将由向量标识符(向量Id)和编码残差(PQ码)组成。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/b8d9f616fb49d70aa0c0467c22187d45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*Z4X6nergVs5Svg2fqwQFug.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由向量Id和PQ代码组成的反向列表条目</p></figure><p id="30e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，这些条目被添加到标记为相关分区的相应倒排表中。</p><h1 id="173f" class="nb nc it bd nd ne oq ng nh ni or nk nl jz os ka nn kc ot kd np kf ou kg nr ns bi translated">使用IVFPQ搜索</h1><p id="dc1c" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">粗略量化器保存关于分区列表和<em class="mq">分区质心</em>的信息。给定一个查询向量<code class="fe ok ol om on b">q</code>，使用粗量化器来寻找最接近<code class="fe ok ol om on b">q</code>的<em class="mq">分区质心</em>。</p><p id="7d91" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在获得离<code class="fe ok ol om on b">q</code>最近的<em class="mq">分区质心</em>后，计算查询向量的残差。</p><p id="6f1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似于在<a class="ae lu" rel="noopener" target="_blank" href="/product-quantization-for-similarity-search-2f1f67c5fddd"> <strong class="la iu">相似性搜索的乘积量化</strong> </a>中描述的搜索过程，我们使用码本和查询向量的残差来预先计算部分<a class="ae lu" href="https://en.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance" rel="noopener ugc nofollow" target="_blank">平方欧几里德距离</a>。</p><p id="45ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些部分平方欧几里德距离被记录在具有<code class="fe ok ol om on b">k</code>行和<code class="fe ok ol om on b">M</code>列的距离表中，其中<code class="fe ok ol om on b">M</code>表示向量段的数量，而<code class="fe ok ol om on b">k</code>表示在训练期间被选择来执行k均值聚类的值。</p><p id="a902" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，有了倒排文件索引，我们可以选择性地查找部分距离并进行求和，只针对倒排列表中那些被标记为分区质心<em class="mq"> </em>最接近<code class="fe ok ol om on b">q</code>的分区的条目。</p><blockquote class="oz"><p id="3f05" class="pa pb it bd pc pd pe pf pg ph pi lt dk translated">倒排文件索引是非穷举搜索方法的关键组件。</p></blockquote><blockquote class="mn mo mp"><p id="2b9d" class="ky kz mq la b lb po ju ld le pp jx lg mr pq lj lk ms pr ln lo mt ps lr ls lt im bi translated">为了找到并返回<code class="fe ok ol om on b"><em class="it">K</em></code>最近的邻居，一种有效的方法是使用固定容量的<a class="ae lu" href="https://en.wikipedia.org/wiki/Max-heap" rel="noopener ugc nofollow" target="_blank"> Max-Heap </a>。这是一个基于树的结构，其中根节点总是包含最大值，每个节点的值都等于或小于父节点的值。</p><p id="48d0" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated">在每次距离计算之后，只有当向量标识符的距离小于最大堆中的最大距离时，向量标识符才被添加到最大堆结构中。</p></blockquote><h1 id="7efe" class="nb nc it bd nd ne oq ng nh ni or nk nl jz os ka nn kc ot kd np kf ou kg nr ns bi translated">改善搜索结果</h1><p id="16e6" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">早些时候，对于倒排文件索引，我们讨论了编码残差而不是原始向量来改善搜索结果。</p><p id="4e35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果只从一个分区进行搜索，我们可能会遇到比没有倒排文件索引的基本乘积量化更差的结果。</p><p id="bc66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然搜索速度快得令人难以置信，只需探测一个分区，但结果会受到影响，因为搜索范围现在确实局限于很小的记录子集。</p><p id="92d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据作者的<a class="ae lu" href="https://ieeexplore.ieee.org/document/5432202" rel="noopener ugc nofollow" target="_blank"> <strong class="la iu">为最近邻搜索</strong></a>【1】、</p><blockquote class="oz"><p id="1180" class="pa pb it bd pc pd pe pf pg ph pi lt dk translated">查询向量及其最近的邻居通常不被量化到相同的分区质心，而是被量化到附近的分区质心</p></blockquote><p id="60b6" class="pw-post-body-paragraph ky kz it la b lb po ju ld le pp jx lg lh pq lj lk ll pr ln lo lp ps lr ls lt im bi translated">如下例所示，尽管查询向量最接近顶部分区的质心，但附近分区中还有其他向量也是查询向量的潜在最近邻居。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/f78e4c203de472057b77b7a1a92d2de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*LNC39yBtm0WsIY-RKKGyWQ.png"/></div></figure><p id="3926" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果搜索仅限于查询向量最接近分区质心的分区，那么我们可能会错过位于附近分区的许多潜在的最近邻居。</p><p id="a968" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当查询向量非常靠近单元或分区的边界时，这种影响会更加明显。</p><blockquote class="oz"><p id="f650" class="pa pb it bd pc pd pe pf pg ph pi lt dk translated">为了避免错过那些潜在的最近邻居，可以在更多分区上执行向量搜索。</p></blockquote><p id="e6b4" class="pw-post-body-paragraph ky kz it la b lb po ju ld le pp jx lg lh pq lj lk ll pr ln lo lp ps lr ls lt im bi translated">特别地，我们将在<code class="fe ok ol om on b">W</code>分区上执行搜索，其中来自这些<code class="fe ok ol om on b">W</code>分区的质心最接近查询向量。<code class="fe ok ol om on b">W</code>通常是一个可配置的参数。</p><p id="7ab2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拥有<code class="fe ok ol om on b">w &gt; 1</code>有什么寓意？</p><p id="254e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，随着更多分区的加入，我们将需要使用每个<em class="mq">分区质心</em>分别计算查询向量的残差。并且对于查询向量的每个残差，需要计算单独的距离表。</p><p id="c05e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终，在<code class="fe ok ol om on b">W</code>分区上执行搜索的意图将导致计算<code class="fe ok ol om on b">W</code>剩余查询向量和<code class="fe ok ol om on b">W</code>距离表。</p><p id="3e4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管构建倒排文件索引会带来开销，但对于大型数据集，拥有更多分区并从更多分区进行搜索通常会提高效率。这是一条可行之路，并且在现实中被证明非常有效。</p><p id="e333" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，对于小数据集，如果分区的数量太大，粗量化器的复杂性可能成为瓶颈。</p><h1 id="c8d8" class="nb nc it bd nd ne oq ng nh ni or nk nl jz os ka nn kc ot kd np kf ou kg nr ns bi translated">摘要</h1><p id="93fd" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">下图总结了使用反向文件索引和产品量化(IVFPQ)进行相似性搜索的过程和步骤。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/85489bcfab72c8bbc097e30a4c7fce9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*NCraGdCIeGBt0GZmqZOkQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">具有倒排文件索引和产品量化的相似性搜索(IVFPQ)</p></figure><p id="e37f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<strong class="la iu">倒排文件索引(IVF) </strong>，可以在相关分区上执行相似性搜索，将搜索范围限制在高度相关的一个小子集中。</p><p id="6658" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，<strong class="la iu">乘积量化(PQ) </strong>能够用极其节省存储空间的压缩表示对矢量进行编码。</p><blockquote class="oz"><p id="a986" class="pa pb it bd pc pd pe pf pg ph pi lt dk translated">利用乘积量化(PQ)实现倒排文件索引(IVF)提出了一种新方法(IVFPQ ),该方法对于大规模相似性搜索非常有效。</p></blockquote><p id="4e66" class="pw-post-body-paragraph ky kz it la b lb po ju ld le pp jx lg lh pq lj lk ll pr ln lo lp ps lr ls lt im bi translated">将两者结合在一起，我们可以从两个世界中获益。结果呢？对于大规模近似最近邻搜索，搜索时间快，精度好。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi px"><img src="../Images/96fc8c20dc0682322ec3dc06e72c9771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kYvPP5cXW9gOJUKl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">詹姆斯·巴尔茨在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="mn mo mp"><p id="6fc3" class="ky kz mq la b lb lc ju ld le lf jx lg mr li lj lk ms lm ln lo mt lq lr ls lt im bi translated">处理十亿级向量数据集？点击下面的链接，了解<strong class="la iu"> HNSW </strong>以及它如何与<strong class="la iu"> IVFPQ </strong>一起使用，以形成十亿级相似性搜索的最佳索引方法。</p></blockquote><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/ivfpq-hnsw-for-billion-scale-similarity-search-89ff2f89d90e"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">IVFPQ + HNSW用于十亿级相似性搜索</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">十亿级矢量数据集的最佳索引方法</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="py l mj mk ml mh mm ks ly"/></div></div></a></div></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="db24" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><p id="3c44" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">[1] H. Jégou，M. Douze，C. Schmid，<a class="ae lu" href="https://ieeexplore.ieee.org/document/5432202" rel="noopener ugc nofollow" target="_blank">最近邻搜索的乘积量化</a> (2010)</p><p id="7413" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[2] C. McCormick，<a class="ae lu" href="http://mccormickml.com/2017/10/22/product-quantizer-tutorial-part-2/" rel="noopener ugc nofollow" target="_blank">用于k-NN教程的产品量化器第2部分</a> (2017)</p><p id="3565" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3] J. Briggs，<a class="ae lu" href="https://www.pinecone.io/learn/product-quantization/" rel="noopener ugc nofollow" target="_blank">产品量化:将高维向量压缩97% </a></p><pre class="kj kk kl km gt pz on qa qb aw qc bi"><span id="e7bd" class="ny nc it on b gy qd qe l qf qg"><strong class="on iu"><em class="mq">Before You Go...</em></strong></span><span id="f547" class="ny nc it on b gy qh qe l qf qg"><em class="mq">Thank you for reading this post, and I hope you’ve enjoyed learning about similarity search with IVFPQ.</em></span><span id="0d7f" class="ny nc it on b gy qh qe l qf qg"><em class="mq">If you like my post, don’t forget to hit </em><a class="ae lu" href="https://peggy1502.medium.com/" rel="noopener"><strong class="on iu"><em class="mq">Follow</em></strong></a><em class="mq"> and </em><a class="ae lu" href="https://peggy1502.medium.com/subscribe" rel="noopener"><strong class="on iu"><em class="mq">Subscribe</em></strong></a><em class="mq"> to get notified via email when I publish.</em></span><span id="62f9" class="ny nc it on b gy qh qe l qf qg"><em class="mq">Optionally, you may also </em><a class="ae lu" href="https://peggy1502.medium.com/membership" rel="noopener"><em class="mq">sign up</em></a><em class="mq"> for a Medium membership to get full access to every story on Medium.</em></span><span id="5096" class="ny nc it on b gy qh qe l qf qg">📑 <em class="mq">Visit this </em><a class="ae lu" href="https://github.com/peggy1502/Data-Science-Articles/blob/main/README.md" rel="noopener ugc nofollow" target="_blank"><em class="mq">GitHub repo</em></a><em class="mq"> for all codes and notebooks that I shared in my posts.</em></span><span id="00b0" class="ny nc it on b gy qh qe l qf qg">© 2022 All rights reserved.</span></pre><p id="53ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有兴趣阅读我的其他数据科学文章吗？查看以下内容:</p><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/transformers-can-you-rate-the-complexity-of-reading-passages-17c76da3403"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">变形金刚，你能评价阅读段落的复杂程度吗？</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">用PyTorch微调RoBERTa以预测文本摘录的阅读难易程度</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="qi l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/advanced-techniques-for-fine-tuning-transformers-82e4e61e16e"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">微调变压器的先进技术</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">学习这些先进的技术，看看它们如何帮助改善结果</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="qj l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a href="https://pub.towardsai.net/building-a-product-recommendation-engine-with-aws-sagemaker-321a0e7c7f7b" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">用AWS SageMaker构建产品推荐引擎</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">了解如何使用Amazon SageMaker因式分解机构建和训练个性化推荐引擎</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">pub.towardsai.net</p></div></div><div class="mh l"><div class="qk l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener follow" target="_blank" href="/aws-certified-machine-learning-specialty-97eacbd1a0fe"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">AWS认证机器学习—专业</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">关于如何准备和通过考试的提示和建议</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">towardsdatascience.com</p></div></div><div class="mh l"><div class="ql l mj mk ml mh mm ks ly"/></div></div></a></div><div class="lv lw gp gr lx"><div role="button" tabindex="0" class="ab bv gv cb fp qm qn bn qo ks ex"><div class="qp l"><div class="ab q"><div class="l di"><img alt="Peggy Chang" class="l de bw qq qr fe" src="../Images/9e4c26496eb3cca6b350330838259487.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*4RiPT4MGaV1PUkLGaNirFQ.png"/><div class="fb bw l qq qr fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://peggy1502.medium.com/?source=post_page-----9c6348fd4db3--------------------------------" rel="noopener follow" target="_top">张佩琦</a></p></div></div><div class="qu qv gw l"><h2 class="bd iu vw vx fp vy fr fs me fu fw is bi translated">掌握动态编程系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi vz au wa wb wc sn wd an eh ei we wf wg el em eo de bk ep" href="https://peggy1502.medium.com/list/series-on-mastering-dynamic-programming-ce9124edda06?source=post_page-----9c6348fd4db3--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="wh l fo"><span class="bd b dl z dk">2 stories</span></div></div></div><div class="rh dh ri fp ab rj fo di"><div class="di qz bv ra rb"><div class="dh l"><img alt="Article cover for “Mastering Dynamic Programming — Understanding the fundamentals and knowing when and how to apply this optimization technique”. Author: Peggy Chang" class="dh" src="../Images/4189e936345f7dd6622ff2fc4cc61733.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*c0gU2CkZ880j1_pfnGS1fw.png"/></div></div><div class="di qz bv rc rd re"><div class="dh l"><img alt="Article cover for “Mastering Dynamic Programming II — Manual tabulation and workout is a great way to start grokking, analyzing, and spotting patterns, as well as strengthening our understanding and intuitions”. Author: Peggy Chang" class="dh" src="../Images/2cfd9c02af79a8bee7a11d30e4d2abb9.png" width="194" height="194" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*2hR-6vz3mdHIh8hS0GXanA.png"/></div></div><div class="di bv rf rg re"><div class="dh l"><div class="rk rl rm l qc"/></div></div></div></div></div></div></div>    
</body>
</html>