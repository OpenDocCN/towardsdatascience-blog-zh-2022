<html>
<head>
<title>Powerful SQL queries that you might not know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能不知道的强大的SQL查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/powerful-sql-queries-that-you-might-not-know-c9953ea4bf20#2022-09-03">https://towardsdatascience.com/powerful-sql-queries-that-you-might-not-know-c9953ea4bf20#2022-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fb5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一些可以将您的SQL带到另一个层次的查询和技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cd0e03ac3ea6d3d5b7addbe5d9c18dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mYc9Tdv_Vu_GFiO-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">博伊图梅洛·菲特拉</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="fe33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我大学毕业时，我对SQL非常有信心。会有多难呢？只是选择、连接和分组。窗口函数一开始有点难以理解，但我认为这是它所能达到的最大挑战。我不知道有一个残酷的世界在等着我。SQL的世界是巨大的，如果你没有在实践中使用它来解决现实世界的问题，你就不能100%理解其中的一些条款和概念。</p><p id="dc8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成为一名分析工程师意味着SQL现在已经成为我的日常语言(也许比英语用得更多？！).下面我分享一些SQL查询和技术，这些是我在解决了一些实际问题后学到的，我觉得它们是对你的SQL库的很好的补充。</p><p id="3ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意，我主要研究雪花方言。查询也可以存在于不同的方言中，但是具有不同的语法，或者在某些方言中根本不被支持。务必事先检查文档。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bc5b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">晋级</strong></h1><p id="e8ad" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">假设您有一个客户下订单的表。每个客户可能有多个订单。现在您想从每个客户那里获得最新的订单。</p><p id="58c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">| date | customer _ id | order _ id | price |<br/>|--|-|-|<br/>| 2022-01-01 | 001 | 123 | 100 |<br/>| 2022-01-02 | 002 | 432 | 250 |<br/>| 2022-01-03 | 002 | 212 | 350 |<br/>| 2022-01-04</p><p id="5b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的窗口函数和CTE可以做到这一点:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9d0a" class="nf me it nb b gy ng nh l ni nj">with order_order as<br/>(<br/>select<br/>    date,<br/>    customer_id,<br/>    order_id,<br/>    price,<br/>    row_number() over (partition by customer_id order by date desc)    <br/>    as order_of_orders<br/>from customer_order_table <br/>)<br/>select<br/>     *<br/>from order_order<br/>where order_of_orders = 1<br/>;<br/></span><span id="9207" class="nf me it nb b gy nk nh l ni nj">Results:<br/>| date       | customer_id | order_id | price |<br/>|------------|-------------|----------|-------|<br/>| 2022-01-03 | 002         | 212      | 350   |<br/>| 2022-01-06 | 005         | 982      | 300   |<br/>| 2022-01-07 | 001         | 109      | 120   |</span></pre><p id="ac3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这样做很好，但这不是编写这个查询的最佳方式。这就是<code class="fe nl nm nn nb b">qualify</code>派上用场的地方。</p><blockquote class="no np nq"><p id="231a" class="kz la lv lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><strong class="lb iu"> QUALIFY </strong>子句过滤窗口函数的结果。限定具有窗口功能的does，就像具有的<strong class="lb iu">对由</strong>分组的<strong class="lb iu">所做的那样。因此，在执行顺序中，QUALIFY是在窗口函数之后计算的。<br/>来源:<a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/constructs/qualify.html" rel="noopener ugc nofollow" target="_blank">雪花文档</a></strong></p></blockquote><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8189" class="nf me it nb b gy ng nh l ni nj">select<br/>    date,<br/>    customer_id,<br/>    order_id,<br/>    price<br/>from customer_order_table<br/>qualify row_number() over (partition by customer_id order by date desc) = 1<br/>;</span><span id="2d7a" class="nf me it nb b gy nk nh l ni nj">Results:<br/>| date       | customer_id | order_id | price |<br/>|------------|-------------|----------|-------|<br/>| 2022-01-03 | 002         | 212      | 350   |<br/>| 2022-01-06 | 005         | 982      | 300   |<br/>| 2022-01-07 | 001         | 109      | 120   |</span></pre><p id="04ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回答像获取每个类别的最大XXX值这样的问题时，QUALIFY特别有用。</p><h1 id="be68" class="md me it bd mf mg nu mi mj mk nv mm mn jz nw ka mp kc nx kd mr kf ny kg mt mu bi translated"><strong class="ak">阵列</strong></h1><p id="772e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当您希望将多个值作为一个数组放入一个单元格中时，Array非常有用。我发现最有用的数组函数是<code class="fe nl nm nn nb b">array_agg</code>、<code class="fe nl nm nn nb b">array_size</code>和<code class="fe nl nm nn nb b">array_contains</code>。</p><p id="5abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们有一个order_item表，它列出了每个订单项目的品牌、类别和销售价格。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f913" class="nf me it nb b gy ng nh l ni nj">| brand  | order_item_number | category   | sales |<br/>| ------ | ------------------| ---------- | ----- |<br/>| Levi's |  A123879320931    | jeans      | 30    |<br/>| Uniqlo |  A123879320932    | t-shirts   | 120   |<br/>| Uniqlo |  A123879320933    | shirts     | 150   |<br/>| COS    |  A123879320934    | trousers   | 347   |<br/>| Levi's |  A123879320935    | jacket     | 672   |<br/>| Arket  |  A123879320936    | jacket     | 40    |<br/>| Uniqlo |  A123879320937    | vest       | 65    |<br/>| COS    |  A123879320938    | shirts     | 78    |<br/>| COS    |  A123879320939    | vest       | 100   |</span></pre><h2 id="f020" class="nf me it bd mf nz oa dn mj ob oc dp mn li od oe mp lm of og mr lq oh oi mt oj bi translated">数组_聚集</h2><p id="0640" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe nl nm nn nb b">ARRAY_AGG</code> <a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/array_agg.html" rel="noopener ugc nofollow" target="_blank">返回输入值并将它们旋转到一个数组中。</a>例如，今天你想知道每个品牌在网站上都有哪些品类。你可以做一个简单的<code class="fe nl nm nn nb b">group by</code>作为</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3b98" class="nf me it nb b gy ng nh l ni nj">select<br/>    brand,<br/>    category<br/>from order_item<br/>group by brand, category<br/>order by brand, category<br/>;</span><span id="1312" class="nf me it nb b gy nk nh l ni nj">Results:</span><span id="f48c" class="nf me it nb b gy nk nh l ni nj">| brand  | category   | <br/>| ------ | ---------- | <br/>| Arket  | jacket     |<br/>| COS    | shirts     |<br/>| COS    | trousers   | <br/>| COS    | vest       |<br/>| Levi's | jacket     |<br/>| Levi's | jeans      |<br/>| Uniqlo | shirts     |<br/>| Uniqlo | t-shirts   | <br/>| Uniqlo | vest    <!-- -->   |</span></pre><p id="eb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的问题是，如果每个品牌有很多类别，行数将变得非常多，以至于很难检查每个品牌。而且也不容易看到一个品牌的所有品类。这两个问题都可以通过使用<code class="fe nl nm nn nb b">array_agg</code>并在函数中指定distinct来解决:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7ef7" class="nf me it nb b gy ng nh l ni nj">select<br/>   brand,<br/>   array_agg(distinct category) as all_categories<br/>from order_item<br/>group by brand<br/>order by brand<br/>;</span><span id="58f3" class="nf me it nb b gy nk nh l ni nj">Results:</span><span id="6a99" class="nf me it nb b gy nk nh l ni nj">| brand  | all_categories               | <br/>| ------ | ---------------------------- | <br/>| Arket  | ['jacket']                   |<br/>| COS    | ['shirts','trousers','vest'] |<br/>| Levi's | ['jacket','jeans']           |<br/>| Uniqlo | ['shirts','t-shirts','vest'] |</span></pre><p id="fb09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将这些值转换成一个数组，现在检查每一项就容易多了。它还为使用其他数组函数来回答带有简单子句的更复杂的问题提供了机会。</p><h2 id="4584" class="nf me it bd mf nz oa dn mj ob oc dp mn li od oe mp lm of og mr lq oh oi mt oj bi translated">数组大小</h2><p id="e8b1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe nl nm nn nb b">array_size</code>函数将一个数组或变量作为输入，并返回数组/变量中的项数(<a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/array_size.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。通过使用它，我们可以很容易地回答诸如“<em class="lv">每个品牌有多少个类别”这样的问题。</em></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="19d6" class="nf me it nb b gy ng nh l ni nj">select<br/>   brand,<br/>   array_agg(distinct category) as all_categories,<br/>   array_size(all_categories) as no_of_cat<br/>from order_item<br/>group by brand<br/>order by brand<br/>;</span><span id="8cd2" class="nf me it nb b gy nk nh l ni nj">Results:</span><span id="7f4c" class="nf me it nb b gy nk nh l ni nj">| brand  | all_categories               | no_of_cat |<br/>| ------ | ---------------------------  | --------- |<br/>| Arket  | ['jacket']                   | 1         |<br/>| COS    | ['shirts','trousers','vest'] | 3         |<br/>| Levi's | ['jacket','jeans']           | 2         |<br/>| Uniqlo | ['shirts','t-shirts','vest'] | 3         |</span></pre><h2 id="eada" class="nf me it bd mf nz oa dn mj ob oc dp mn li od oe mp lm of og mr lq oh oi mt oj bi translated">数组包含</h2><p id="060c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><code class="fe nl nm nn nb b">ARRAY_CONTAINS</code>检查一个<strong class="lb iu"> <em class="lv">变量</em> </strong>是否包含在一个数组中，并返回一个布尔值。请注意，您需要首先将您想要检查的项目转换为变量(<a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/functions/array_contains.html" rel="noopener ugc nofollow" target="_blank">文档</a>)。语法:<code class="fe nl nm nn nb b"><em class="lv">array_contains(variant, array)</em></code> <em class="lv"> <br/>问:什么品牌有外套？</em></p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fab4" class="nf me it nb b gy ng nh l ni nj">select<br/>   brand,<br/>   array_agg(distinct category) as all_categories,<br/>   array_size(all_categories) as no_of_cat,<br/>   array_contains('jacket'::variant,all_categories) as has_jacket<br/>from order_item<br/>group by brand<br/>order by brand<br/>;</span><span id="094d" class="nf me it nb b gy nk nh l ni nj">Results:</span><span id="2026" class="nf me it nb b gy nk nh l ni nj">| brand  | all_categories               | no_of_cat | has_jacket |<br/>| ------ | ---------------------------  | --------- | ---------- |<br/>| Arket  | ['jacket']                   | 1         | true       |<br/>| COS    | ['shirts','trousers','vest'] | 3         | false      |<br/>| Levi's | ['jacket','jeans']           | 2         | true       |<br/>| Uniqlo | ['shirts','t-shirts','vest'] | 3         | false      |</span></pre><h1 id="ece2" class="md me it bd mf mg nu mi mj mk nv mm mn jz nw ka mp kc nx kd mr kf ny kg mt mu bi translated"><strong class="ak">其中1=1 </strong></h1><p id="453c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从技术上讲，这不是一个查询，而更像是一个约定或技巧。如果您没有深入研究SQL，这可能不太直观。我花了一段时间才真正理解为什么工程师总是加一个<code class="fe nl nm nn nb b">1=1</code>或者<code class="fe nl nm nn nb b">true</code>作为第一个where子句。</p><p id="f939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一组where子句，您希望在不同的条件下应用它们。诸如</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2fe0" class="nf me it nb b gy ng nh l ni nj">select<br/>     *<br/>from XXX_table<br/>where <br/>  (if condition A) clause 1 <br/>  (if condition B) and clause 2 <br/>  (if condition C) and clause 3<br/>;</span></pre><p id="fb29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，如果不满足条件A，子句1将为空，查询中的where子句将变为<code class="fe nl nm nn nb b">where <em class="lv">and</em> clause 2 and clause 3</code>，这将导致语法错误。为了防止错误发生，通常在开头添加一个<code class="fe nl nm nn nb b">1=1</code>，因此它变成了</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e2d7" class="nf me it nb b gy ng nh l ni nj">select<br/>     *<br/>from XXX_table<br/>where 1=1<br/>    (if condition A) and clause 1 <br/>    (if condition B) and clause 2 <br/>    (if condition C) and clause 3<br/>;</span></pre><p id="12dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nl nm nn nb b">1=1</code>总是为真，即使所有的条件都不满足，查询仍然会工作。</p><p id="08aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个原因是让开发查询更加顺畅。在开发SQL查询时，我们经常需要更改where子句来测试不同的场景。在普通的where子句中，如</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e6db" class="nf me it nb b gy ng nh l ni nj">where <br/>    clause 1 <br/>    and clause 2 <br/>    and clause 3</span></pre><p id="f633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们要对第1条进行注释，那么我们也需要删除第2条中的“and”。通过在开头使用<code class="fe nl nm nn nb b">1=1</code>或<code class="fe nl nm nn nb b">true</code>，所有的子句都将有一个‘and’，所以当注释掉任何where子句时，我们不需要担心其他事情。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6cd8" class="nf me it nb b gy ng nh l ni nj">where 1=1<br/>   -- and clause 1<br/>   and clause 2<br/>   and clause 3</span></pre><p id="7903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它更美观，因为您可以将所有where子句排成一行。好吧，我承认这有点强迫症，但是一直在你的where子句开头加<code class="fe nl nm nn nb b">1=1</code>或者<code class="fe nl nm nn nb b">true</code>是个好习惯。</p><h1 id="6385" class="md me it bd mf mg nu mi mj mk nv mm mn jz nw ka mp kc nx kd mr kf ny kg mt mu bi translated"><strong class="ak">自然加入</strong></h1><p id="afee" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">自然联接假定不同表中同名的列是联接键。因此，您不需要指定连接键，只需<code class="fe nl nm nn nb b">select * from table_a natural join table_b</code>。与其他联接不同，如果没有在select中指定列，自然联接将只包括一次公共列，即联接键。如果未指定，自然联接将作为内部联接执行，但是，它也可以与外部联接组合。你不能使用<code class="fe nl nm nn nb b">natural join table_b <strong class="lb iu">on</strong> ...</code>，因为当你使用自然连接时，连接键已经被隐含了。<br/> <em class="lv">来源:</em> <a class="ae ky" href="https://docs.snowflake.com/en/sql-reference/constructs/join.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">雪花加入</em> </a></p><p id="4bc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f1c7" class="nf me it nb b gy ng nh l ni nj">table_a:</span><span id="cc1e" class="nf me it nb b gy nk nh l ni nj">| id | name  |<br/>|----|-------|<br/>| 1  | Jenny |<br/>| 2  | Jeff  |<br/>| 3  | Brian |</span><span id="c5d3" class="nf me it nb b gy nk nh l ni nj">table_b:</span><span id="8b65" class="nf me it nb b gy nk nh l ni nj">| id | age |<br/>|----|-----|<br/>| 1  | 30  |<br/>| 2  | 21  |<br/>| 4  | 50  |</span><span id="5e75" class="nf me it nb b gy nk nh l ni nj"><br/>select<br/>    *<br/>from table_a<br/>natural join table_b<br/>;</span><span id="82f6" class="nf me it nb b gy nk nh l ni nj">Results:<br/>| id | name  | age |<br/>|----|-------|-----|<br/>| 1  | Jenny | 30  |<br/>| 2  | Jeff  | 21  |</span><span id="a98b" class="nf me it nb b gy nk nh l ni nj"><br/>select<br/>    *<br/>from table_a<br/>natural outer join table_b<br/>;</span><span id="fd73" class="nf me it nb b gy nk nh l ni nj">Results:<br/>| id | name  | age  |<br/>|----|-------|------|<br/>| 1  | Jenny | 30   |<br/>| 2  | Jeff  | 21   |<br/>| 3  | Brian | null |<br/>| 4  | null  | 50   |</span></pre><p id="bab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以下情况下，您应该考虑使用自然联接:</p><ol class=""><li id="67a5" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">多个表中有许多同名的公共列，它们都被用作连接键。</li><li id="ef12" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">您不希望为了避免多次输出相同的列而在select中键入所有的公共列。</li></ol><h1 id="d435" class="md me it bd mf mg nu mi mj mk nv mm mn jz nw ka mp kc nx kd mr kf ny kg mt mu bi translated">总流量</h1><p id="e07b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">计算运行总数是你可以从涉众那里得到的一个非常普遍的需求。当我第一次接近这个问题时，我花了很多时间思考如何使用窗口函数和LAG/LEAD来完成工作。直到我了解到一个简单的加窗函数就能解决问题。让我们再次以此表为例:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="aeae" class="nf me it nb b gy ng nh l ni nj">| name  | date       | sales |<br/>| ----- | -----------| ----- |<br/>| James | 2021-01-01 | 30    |<br/>| Nina  | 2021-01-02 | 120   |<br/>| Mike  | 2021-01-02 | 150   |<br/>| James | 2021-01-03 | 347   |<br/>| James | 2021-01-05 | 672   |<br/>| Mike  | 2021-01-03 | 40    |<br/>| Nina  | 2021-01-05 | 65    |<br/>| Mike  | 2021-01-08 | 78    |<br/>| Mike  | 2021-01-09 | 100   |</span></pre><p id="25a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要计算每个人的运行总数，按日期排序，只需将这个要求放在<code class="fe nl nm nn nb b">over</code>子句中，并使用<code class="fe nl nm nn nb b">sum()</code>作为聚合函数。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="376c" class="nf me it nb b gy ng nh l ni nj">select<br/>    name,<br/>    date,<br/>    sales,<br/>    sum(sales) over (partition by name order by date) as running_sum<br/>from TABLE_NAME<br/>;</span><span id="8d33" class="nf me it nb b gy nk nh l ni nj">Results:</span><span id="6940" class="nf me it nb b gy nk nh l ni nj">| name  | date       | sales | running_sum |<br/>| ----- | -----------| ----- | ----------- |<br/>| James | 2021-01-01 | 30    |30           |<br/>| James | 2021-01-03 | 347   |377          |<br/>| James | 2021-01-05 | 672   |1,049        |<br/>| Mike  | 2021-01-02 | 150   |150          |<br/>| Mike  | 2021-01-03 | 40    |190          |<br/>| Mike  | 2021-01-08 | 78    |268          |<br/>| Mike  | 2021-01-09 | 100   |368          |<br/>| Nina  | 2021-01-02 | 120   |120          |<br/>| Nina  | 2021-01-05 | 54    |274          |</span></pre><p id="0ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以使用相同的逻辑来计算移动平均值。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="92b2" class="nf me it nb b gy ng nh l ni nj">select<br/>    name,<br/>    date,<br/>    sales,<br/>    sum(sales) over (partition by name order by date) as running_sum,<br/>    avg(sales) over (partition by name order by date) as running_avg<br/>from TABLE_NAME<br/>;</span><span id="7241" class="nf me it nb b gy nk nh l ni nj">Results:</span><span id="142c" class="nf me it nb b gy nk nh l ni nj">| name  | date       | sales | running_sum | running_avg |<br/>| ----- | -----------| ----- | ----------- | ----------- |<br/>| James | 2021-01-01 | 30    |30           | 30          |<br/>| James | 2021-01-03 | 347   |377          | 188         |<br/>| James | 2021-01-05 | 672   |1,049        | 350         |<br/>| Mike  | 2021-01-02 | 150   |150          | 150         |<br/>| Mike  | 2021-01-03 | 40    |190          | 95          |<br/>| Mike  | 2021-01-08 | 78    |268          | 89          |<br/>| Mike  | 2021-01-09 | 100   |368          | 92          |<br/>| Nina  | 2021-01-02 | 120   |120          | 120         |<br/>| Nina  | 2021-01-05 | 54    |274          | 137         |</span></pre><h1 id="c940" class="md me it bd mf mg nu mi mj mk nv mm mn jz nw ka mp kc nx kd mr kf ny kg mt mu bi translated">预付款:移动平均线</h1><p id="d510" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">获得最近n天的平均值，即移动平均线，是人们喜欢问的另一个流行问题。通过查看过去n天的平均值，而不是只查看每天的数字，我们可以更好地了解趋势，减少偏差。这是防止异常值影响结果的好方法。例如，如果在几天的低病例数后，新冠肺炎病例数有一天出现高峰，仅从高峰来看，情况可能很糟糕。但看看最近的7天平均线，峰值会被平均掉，数字会更好地反映当前的情况。</p><p id="c40a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL中的移动平均并不难。一开始这可能有点令人生畏，但是一旦你理解了它背后的概念，它就是一个非常强大的工具。我们使用<code class="fe nl nm nn nb b">rows between n preceding and n following</code>来指定我们想要用来计算平均值的窗口。您也可以使用<code class="fe nl nm nn nb b">CURRENT ROW</code>来确定当前行，使用<code class="fe nl nm nn nb b">UNBOUNDED</code>来不设置边界。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/cbdcaa7041f604b52c9828aca890f6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dzo9Nj9k8sA_yloC.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://learnsql.com/blog/sql-window-functions-cheat-sheet/" rel="noopener ugc nofollow" target="_blank"> SQL窗口函数备忘单</a></p></figure><p id="75ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用这个表来看看一些实际的代码示例。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="07a2" class="nf me it nb b gy ng nh l ni nj">table_daily_sales:</span><span id="0b1c" class="nf me it nb b gy nk nh l ni nj">| date       | sales |<br/>|------------|-------|<br/>| 2022-01-01 | 100   |<br/>| 2022-01-02 | 300   |<br/>| 2022-01-03 | 210   |<br/>| 2022-01-04 | 250   |<br/>| 2022-01-05 | 400   |<br/>| 2022-01-06 | 1200  |<br/>| 2022-01-07 | 220   |</span></pre><p id="cdd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想计算过去3天(包括今天)的移动平均值，我们希望在窗口中显示今天(当前行)、昨天和前天。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f346" class="nf me it nb b gy ng nh l ni nj">select<br/>   date,<br/>   sales,<br/>   avg(sales) over (order by date <br/>       rows between 2 preceding and current row) as moving_avg<br/>from table_daily_sales<br/>;</span><span id="fccd" class="nf me it nb b gy nk nh l ni nj">Results:<br/>| date       | sales | moving_avg |<br/>|------------|-------|------------|<br/>| 2022-01-01 | 100   | 100        | =(100)/1<br/>| 2022-01-02 | 300   | 200        | =(100+300)/2<br/>| 2022-01-03 | 210   | 203        | =(100+300+210)/3<br/>| 2022-01-04 | 250   | 253        | =(250+210+300)/3<br/>| 2022-01-05 | 400   | 286        | =(400+250+210)/3<br/>| 2022-01-06 | 1200  | 616        | =(1200+400+250)/3<br/>| 2022-01-07 | 220   | 606        | =(220+1200+400)/3</span></pre><p id="166e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，前几行会相应地改变分母，因为之前没有足够的日期。也许你认为今天还没有结束，所以我们应该只包括从4天前到昨天。这很简单，只需根据您想要的逻辑更改您的窗口:</p><p id="559d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn nb b">order by date rows between 3 preceding and current row -1</code></p><p id="2284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nl nm nn nb b">UNBOUNDED</code>允许您不设置边界:</p><p id="ecaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn nb b">order by date rows between UNBOUNDED preceding and current row</code>将给出从表格的最早日期直到当前行。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="14d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SQL还有很多东西要学，就像我说的世界是巨大的。你觉得哪个最有用？你有什么“隐藏的宝石”SQL查询想分享吗？评论一下，让我知道！</p></div></div>    
</body>
</html>