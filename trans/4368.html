<html>
<head>
<title>5 Minute Guide to Cross Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉验证的5分钟指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-minute-guide-to-cross-validation-be3c5b0ae693#2022-09-27">https://towardsdatascience.com/5-minute-guide-to-cross-validation-be3c5b0ae693#2022-09-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="42b2" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">有哪些策略？你应该如何以及何时使用它们？</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c2d1eb76694991c99850e73e149f9fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AlF164RaV1-q7XzTcaycQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">保留交叉验证。作者图片</p></figure><p id="ecfa" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">机器学习模型的目标是从具体的例子中学习<strong class="lb iv"> </strong>的一般模式。在现实生活中，所有数据都包含一定程度的随机变化和噪声。为了学习数据集中的一般潜在模式并对新数据进行良好预测，重要的是机器学习模型能够区分信号和噪声。</p><blockquote class="lv"><p id="20a9" class="lw lx iu bd ly lz ma mb mc md me lu dk translated">机器学习模型的目标是从<strong class="ak">具体的</strong>例子中学习<strong class="ak">一般的</strong>模式。</p></blockquote><p id="a5c9" class="pw-post-body-paragraph kz la iu lb b lc mf jv le lf mg jy lh li mh lk ll lm mi lo lp lq mj ls lt lu in bi translated">当机器学习模型学习了太多的噪声，并且无法对以前看不见的例子进行归纳和做出良好的预测时，这被称为过度拟合。如果出现过度拟合，则很有可能存在一个模型，该模型在训练时表现出高度的准确性，但在部署到现实世界中时表现很差。</p><p id="cee2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">检查并防止过度拟合是开发机器学习模型的关键步骤。发现过度拟合的一般技术称为交叉验证。交叉验证包括保留训练数据的样本，稍后您可以在这些样本上测试您的模型，以检查它是否能够很好地概括。</p><p id="5b95" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">有几种技术可以执行交叉验证，在这篇文章的剩余部分，我将给出一个最常用方法的初学者指南。这将包括代码示例、每种技术的优缺点以及何时使用每种方法的正确时间的总结。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="7bff" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">坚持方法</h1><p id="8e5b" class="pw-post-body-paragraph kz la iu lb b lc nj jv le lf nk jy lh li nl lk ll lm nm lo lp lq nn ls lt lu in bi translated">最简单的交叉验证技术被称为保留法。这种技术包括将数据分成三部分。训练集和测试集用于迭代地执行模型选择和超参数调整。例如，在训练样本上训练特定算法，然后用测试集评估性能。</p><p id="4278" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">一旦选择了最佳算法和参数，验证集将用作优化模型性能的最终评估。这里的假设是，如果模型在测试集上过度拟合，这将在最终验证集的较低分数中显示出来。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c2d1eb76694991c99850e73e149f9fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AlF164RaV1-q7XzTcaycQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">维持交叉验证。作者图片</p></figure><p id="3ae2" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面的代码使用了Scikit-learn <code class="fe no np nq nr b">train_test_split</code>函数两次。首先将整个数据集分为训练集和测试集，然后再次将训练集分为训练集和验证集。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><p id="bba7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">优点</strong></p><p id="d001" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">保持交叉验证的计算开销很小，因此即使在非常大的数据集上也可以快速返回结果。</p><p id="14fe" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">缺点</strong></p><p id="a2cd" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">与接下来讨论的技术相比，它的鲁棒性要差得多。</p><p id="0aac" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">拒绝验证尤其不适合非常小的数据集，因为一般来说，将数据集分成三部分会留下太少的样本来训练。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="10f1" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">k倍</h1><p id="8102" class="pw-post-body-paragraph kz la iu lb b lc nj jv le lf nk jy lh li nl lk ll lm nm lo lp lq nn ls lt lu in bi translated">K-fold交叉验证是一种更稳健的模型评估方法。利用这种技术，可用的训练数据被随机打乱并分成选定数量的样本(k)。k的值可以是任何合理的数，通常选择10。单个观测值只包含在一个折叠中，因此折叠之间没有重叠。</p><p id="25d6" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">k-fold算法迭代地使用每个折叠作为测试集，同时使用剩余的数据进行训练。然后评估每个k样本的模型性能。通常，在对所有折叠进行训练和评估后，计算模型得分的平均值。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nu"><img src="../Images/2b7929256031587f227a566ad60b2a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBI8XByVXQm6mxT5rr41jw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">k倍交叉验证。作者图片</p></figure><p id="752e" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面显示的代码使用Scit-kit Learn <code class="fe no np nq nr b">KFold</code>函数将训练数据分成10份。然后在每个折叠上迭代训练随机森林分类器，最后使用Yellowbrick库来显示模型分数的视觉摘要。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nv"><img src="../Images/10729fc0e39f6463b9c0788ed91a52fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDexN55aHnhNfntdNB-P8g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">分数K倍交叉验证。作者图片</p></figure><p id="8169" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">优点</strong></p><p id="bddb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">比维持交叉验证健壮得多。</p><p id="7b75" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">可用于小型数据集。</p><p id="7084" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">缺点</strong></p><p id="1c57" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">计算开销很大。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="6669" class="mr ms iu bd mt mu mv mw mx my mz na nb ka nc kb nd kd ne ke nf kg ng kh nh ni bi translated">留一个出来</h1><p id="e211" class="pw-post-body-paragraph kz la iu lb b lc nj jv le lf nk jy lh li nl lk ll lm nm lo lp lq nn ls lt lu in bi translated">留一法是另一种交叉验证技术。该方法首先从单个观察值创建一个测试集，其余的观察值形成训练集。使用该训练集拟合模型，并在单次观察的基础上评估其性能。对整个数据集中的每个观测重复这个过程。类似于k-fold，然后计算评估度量的平均值。</p><p id="75a0" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">下面的代码使用Scikit-Learn的<code class="fe no np nq nr b">LeaveOneOut</code>方法分割数据集，并n次拟合一个随机森林分类器。然后打印平均分数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ns nt l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nw"><img src="../Images/5150b3c33599ce589c05b4eb8b7cce9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*4_4HoAy-L2RGY1jXT23g8Q.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">平均准确度分数。作者图片</p></figure><p id="26ed" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">优点</strong></p><p id="fc0b" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">特别适合非常小的数据集。</p><p id="8288" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">缺点</strong></p><p id="9db7" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">计算开销很大。通常，这种技术不适合大型数据集。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><p id="0bb5" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在本文中，我讨论了最流行的交叉验证策略。这里描述的所有技术都用于评估模型的性能，特别强调检查过度拟合。</p><p id="aeeb" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">所涉及的方法各有利弊，这意味着它们更适合某些任务、数据集和问题陈述。前一段时间，我发现了一个关于栈交换的极好的总结，它给出了使用每种技术的正确情况的建议。我在下面总结了这一点，但这要归功于用户等密度振荡——本文底部的完整引用。</p><p id="953c" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">保留交叉验证:</strong>如果您的数据集大于1，000，000个示例，则应使用保留交叉验证，除非您拥有强大的计算能力，在这种情况下，可以使用k = 5的k-fold。对于20到100个示例之间的较小数据集，可以使用较大的k。</p><p id="c9ee" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv"> K-fold交叉验证:</strong>如果您的数据集在100到1，000，000个示例之间，请使用k = 5。如果计算能力有限，并且您的数据集为&gt; 10，000行，则应考虑保留交叉验证。</p><p id="2b82" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated"><strong class="lb iv">留一交叉验证:</strong>用于非常小的数据集，通常少于20个例子。</p><p id="8cb4" class="pw-post-body-paragraph kz la iu lb b lc ld jv le lf lg jy lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">感谢阅读！</p><h2 id="a2d7" class="nx ms iu bd mt ny nz dn mx oa ob dp nb li oc od nd lm oe of nf lq og oh nh oi bi translated">承认</h2><p id="a737" class="pw-post-body-paragraph kz la iu lb b lc nj jv le lf nk jy lh li nl lk ll lm nm lo lp lq nn ls lt lu in bi translated"><em class="oj">等密度振荡(https://stats . stack exchange . com/users/25029/Isopycnal-Oscillation)，保留验证与交叉验证，URL(版本:2021–09–07):</em><a class="ae ok" href="https://stats.stackexchange.com/q/307849" rel="noopener ugc nofollow" target="_blank"><em class="oj">https://stats.stackexchange.com/q/307849</em></a></p></div></div>    
</body>
</html>