<html>
<head>
<title>Simple Parquet Tutorial and Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单拼花教程和最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easy-parquet-tutorial-best-practices-237955e46cb7#2022-12-16">https://towardsdatascience.com/easy-parquet-tutorial-best-practices-237955e46cb7#2022-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">开始学习拼花地板的实践教程</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/4bf9590f3b69c1d2e1288f3caf44494d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vgxI8urMr_dIBmlN"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@jeriden94?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰瑞登·维勒加斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ca3d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="lw"> Parquet </em> file 是一个文件存储系统，它改变了任何与几个数据用户之间的日常数据操作有关的人的生活，例如<em class="lw">数据工程师</em>、<em class="lw">数据科学家</em>、<em class="lw">分析工程师</em>以及其他技术角色。</p><p id="1fef" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> </strong> <em class="lw">拼花</em>的原理在于其<strong class="lc iu">面向列的</strong>存储，以及数据沿着<em class="lw">列</em>比沿着行更加<em class="lw">同质</em>的事实，提供了数据的优化压缩，从而导致<strong class="lc iu">更小的存储大小</strong>和<strong class="lc iu">增加的处理速度</strong>。</p><p id="171c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本教程中，我们将概述一些最佳实践，让你开始学习镶木地板。</p><h1 id="d4a7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">加载数据</strong></h1><p id="1a93" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">首先，我们将使用一个公开的信用卡应用数据集。数据集可在 Kaggle 上获得:<a class="ae kz" href="https://www.kaggle.com/datasets/rikdifos/credit-card-approval-prediction" rel="noopener ugc nofollow" target="_blank">信用卡审批预测| Kaggle </a>。</p><p id="cf55" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">获取这些数据最简单的方法是在您的环境中安装<strong class="lc iu"> </strong> Kaggle API，提取数据并将归档文件解压到您的工作文件夹中:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="b78c" class="mz ly it mv b be na nb l nc nd">pip install kaggle<br/>kaggle datasets download -d rikdifos/credit-card-approval-prediction<br/>unzip credit-card-approval-prediction.zip</span></pre><p id="f790" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">让我们加载教程所需的包。6.0.0 以上的<strong class="lc iu"> pyarrow </strong>任何版本都可以。</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="c5a9" class="mz ly it mv b be na nb l nc nd">import pandas as pd<br/>import numpy as np<br/>import pyarrow as pa</span></pre><p id="a572" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在 zip 存档中，您将拥有<em class="lw"> credit_record.csv </em>(关于客户每月信用状况的数据集)和<em class="lw"> application_record.csv </em>(关于客户的信息)。为了简单起见，我们只对 zip 存档中的<em class="lw">应用程序记录. csv </em>文件感兴趣。</p><p id="bad9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了让事情变得有趣，我们将复制数据 10 次并重置 id，使数据帧大约有<strong class="lc iu">400 万</strong>行和<strong class="lc iu"> 18 </strong>列。</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="08ba" class="mz ly it mv b be na nb l nc nd">applications = pd.read_csv('application_record.csv')<br/>applications = pd.concat(10*[applications]).reset_index().drop(columns=['ID','index']).reset_index().rename(columns={'index':'ID'})</span></pre><p id="fc02" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是数据帧前 5 行的概述(面向列):</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="82bf" class="mz ly it mv b be na nb l nc nd">applications.head(5).T</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ne"><img src="../Images/a233a36dde4d7a31e0e880c3a4fd6a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8j5LxoLsSu03vHCN2IiGA.png"/></div></div></figure><p id="471a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们注意到名为<em class="lw"> FLAG_X </em>的变量不共享相同的输出类型，将它们规范化为布尔值应该是一个合理的选择。</p><p id="5ecd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，让我们构建一些简单的功能，即家庭收入和申请人年龄的月度版本:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="0bcb" class="mz ly it mv b be na nb l nc nd">applications['MONTH_INCOME_TOTAL'] = applications['AMT_INCOME_TOTAL']/12<br/>applications['AGE'] = - np.floor(applications['DAYS_BIRTH']/365)</span></pre><p id="95b9" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，我们希望与其他数据用户共享这些数据。为此，我们将以 CSV 和 parquet 格式将数据保存到其他用户可以访问的一些路径中。但在此之前，我们先来看看模式的概念。</p><h1 id="56ef" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated"><strong class="ak">模式</strong></h1><p id="ef67" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">对于 parquet 文件，一个非常有价值的实践是定义数据集的<strong class="lc iu">模式</strong>。原因是，这将显著提高您正在共享的数据的一致性和健壮性，在用户之间传输数据时，列上不会出现任何<em class="lw">类型的</em>模糊性。</p><p id="4c22" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要获得 pandas DataFrame 的<strong class="lc iu">模式</strong>，只需使用<em class="lw"> pyarrow 的<em class="lw"> from_pandas </em>。模式</em>。在内部，该函数将 DataFrame 列的类型与<em class="lw"> pyarrow </em>能够理解的类型进行匹配，以用于<em class="lw"> Parquet </em>文件。</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="a1d4" class="mz ly it mv b be na nb l nc nd">my_schema = pa.Schema.from_pandas(applications)<br/>my_schema</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/cce1d3c331e63f1ef12c6ea36e9226c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*UMs3BvVrWFDSD5-YSlgOyg.png"/></div></figure><p id="9b0a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从上面的<strong class="lc iu">模式</strong>中，我们注意到我们最好做两个操作:</p><p id="bcea" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">flags 变量实际上是<strong class="lc iu">布尔值</strong> (1/0)，这样存储它们除了避免任何<em class="lw">类型</em>模糊性之外，还会节省我们的存储空间。<br/> - <strong class="lc iu">出生天数</strong>与<strong class="lc iu">年龄</strong>重复，可以删除。</p><p id="26ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> Schema </strong>可以轻松完成这两种操作(类型转换和变量过滤)。该方法集用于用第二个参数更新第<em class="lw">个</em> <strong class="lc iu"> </strong>列，该参数应该是一个<strong class="lc iu"> pyarrow.field </strong>对象。</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="b014" class="mz ly it mv b be na nb l nc nd">my_schema = my_schema.set(12, pa.field('FLAG_MOBIL', 'bool'))<br/>my_schema = my_schema.set(13, pa.field('FLAG_WORK_PHONE', 'bool'))<br/>my_schema = my_schema.set(14, pa.field('FLAG_PHONE', 'bool'))<br/>my_schema = my_schema.set(15, pa.field('FLAG_EMAIL', 'bool'))<br/>my_schema = my_schema.remove(10)</span></pre><p id="1059" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在让我们比较一下保存<em class="lw">拼花</em>和<em class="lw"> CSV </em>文件的执行时间:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="1b8c" class="mz ly it mv b be na nb l nc nd">%%time<br/>applications.to_parquet('applications_processed.parquet', schema = my_schema)</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b3df3bd5b65a24cb8e4697376560f29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*b05TTi0C0ndL8C517qaSjA.png"/></div></figure><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="4efb" class="mz ly it mv b be na nb l nc nd">%%time<br/>applications.to_csv('applications_processed.csv')</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/93b6ef115843e27ca415e8385c477221.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*ZqGdQ4Nyk9UCQ0R-FGjG2g.png"/></div></figure><p id="ceb1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以<em class="lw"> CSV </em>格式存储不允许任何<em class="lw">类型</em>声明，与<em class="lw">拼花</em>模式不同，并且在执行时间上有显著差异，以<em class="lw">拼花</em>格式存储比以<em class="lw"> CSV </em>格式存储快 5-6 倍。</p><p id="228a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您刚刚见证了由<em class="lw">拼花</em>文件提供的处理速度。</p><p id="ee31" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了减少存储大小，在本例中,<em class="lw">拼花</em>文件的存储差几乎是<strong class="lc iu"> 20 </strong>乘以<em class="lw">便宜</em>(CSV 为 636MB，拼花为 39MB)。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/b5167ef416d716e3924f2d455dd2896b.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*DPHVA2g1solxzorb9oibYg.png"/></div></figure><p id="dcc3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">总的来说，处理速度和存储减少是<em class="lw"> Parquet </em>文件的主要优势，但不是唯一的优势。</p><h1 id="6e02" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">创建分区</h1><p id="a74c" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">另外，关于<em class="lw"> Parquet </em>非常有趣的一点是，您可以通过<strong class="lc iu">分区</strong>来分割数据，这意味着将与<em class="lw">分区名称</em>上的相同值相关的信息组合在一起。</p><p id="abc8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以将数据分区视为将图书馆中相同类型的书籍排列在一起。就像整理书籍一样，它有许多优点:</p><ul class=""><li id="cabc" class="nj nk it lc b ld le lg lh lj nl ln nm lr nn lv no np nq nr bi translated">数据的<strong class="lc iu">用户</strong>可以访问指定的一组数据，显著提高了<em class="lw">加载速度</em>，降低了<em class="lw"> RAM 消耗</em></li><li id="5131" class="nj nk it lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">数据的<strong class="lc iu">生产者</strong>可以<em class="lw">并行化</em>处理，允许<em class="lw">数据大小</em>的可伸缩性和<em class="lw">运行时间</em>的可伸缩性减少</li></ul><p id="00bd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面我将向您展示如何产生<em class="lw"> Parquet </em>分区数据。</p><p id="d187" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从列<em class="lw"> NAME_INCOME_TYPE，</em>中，我们观察到只有 5 个不同的值涉及客户的职业活动类别。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ec047ac965688973b9fd52c1589c6236.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*PpqCoF72iE8wCWZNLtLBZQ.png"/></div></figure><p id="bd97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在假设，我们作为数据的<em class="lw">制作者</em>，想要保存到<em class="lw">拼花</em>文件，但是在这个列上分区，因为数据的<em class="lw">用户</em>有兴趣分别查看那些专业活动:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="5801" class="mz ly it mv b be na nb l nc nd">applications.to_parquet('APPLICATIONS_PROCESSED', schema = my_schema, partition_cols=['NAME_INCOME_TYPE'])</span></pre><p id="a0f5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">注意，当我们保存到具有一个或多个<strong class="lc iu">分区</strong>列的<em class="lw"> Parquet </em>时，我们必须提供一个<strong class="lc iu">文件夹路径</strong>而不是一个<em class="lw"> Parquet </em>文件路径，因为方法<em class="lw"> to_parquet </em>将创建关于<em class="lw"> partition_cols </em>所需的所有子文件夹和<em class="lw"> Parquet </em>文件。</p><p id="69f3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">生成的<em class="lw"> APPLICATIONS_PROCESSED </em>文件夹现在根据信用申请人的<em class="lw"> NAME_INCOME_TYPE </em>为每个信用申请人类别包含一个文件夹。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ny"><img src="../Images/7750b9d14d547faffca5e07822da7407.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*jJpvcV1OwAGjL57EcFB9SA.png"/></div></div></figure><p id="85d6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，对特定专业类别进行分析或决策选择感兴趣的最终用户，如<em class="lw">【国家公务员】</em>可以以很快的速度加载数据，并且只针对这群信贷申请人。</p><h1 id="59db" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">读取分区</h1><p id="e305" class="pw-post-body-paragraph la lb it lc b ld mp ju lf lg mq jx li lj mr ll lm ln ms lp lq lr mt lt lu lv im bi translated">我们将数据创建为分区的<em class="lw"> Parquet </em>文件。</p><p id="cc3e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是<em class="lw">用户</em>如何访问它们呢？这是我们从数据的<em class="lw">用户</em>的角度将要看到的。</p><p id="6966" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有几种方法可以读取<em class="lw">拼花</em>文件。</p><p id="1cb5" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果它是由<em class="lw">生成器</em>生成的，没有<em class="lw">分区</em>列，并且假设我们，作为一个用户，对是“<em class="lw">工薪阶层”</em>的候选人感兴趣，我们必须写:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="28a2" class="mz ly it mv b be na nb l nc nd">%%time<br/>test = pd.read_parquet('applications_processed.parquet')<br/>test[test.NAME_INCOME_TYPE=='Working']</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/debfd82b402e766ed5b77e2e5a8da332.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*05LVorjys-8F70zeVDtuYQ.png"/></div></figure><p id="af9d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个操作花了将近 5 秒，仍然比在<em class="lw"> CSV </em>中读取要好，但不是最佳的，因为<em class="lw">用户</em>正在加载所有数据并在那之后过滤它们。这意味着我们在浪费宝贵的<em class="lw">内存</em>和计算<em class="lw">时间</em>。</p><p id="6f0d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们刚刚看到了分区的存在，一个熟练的数据工程师生成了由<em class="lw"> NAME_INCOME_TYPE </em>分区的数据，这样我们就可以通过简单地加载感兴趣的分区来加快读取时间并减少 RAM 消耗。</p><p id="f7e2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有两种方法可以在相似的执行时间内完成:</p><ul class=""><li id="c7a3" class="nj nk it lc b ld le lg lh lj nl ln nm lr nn lv no np nq nr bi translated">我们可以直接将<em class="lw"> NAME_INCOME_TYPE </em>的分区路径读作“<em class="lw">Working”</em></li><li id="3434" class="nj nk it lc b ld ns lg nt lj nu ln nv lr nw lv no np nq nr bi translated">或者我们可以使用 filters list 参数以同样的方式到达分区。过滤器选项会查看文件夹中的所有分区，并选择符合您条件的分区，这里是<em class="lw">NAME _ INCOME _ TYPE</em><em class="lw">=</em><em class="lw">‘正在工作’，而不是直接进入路径。</em></li></ul><p id="f2b3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面列出了两种可能性:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="48e7" class="mz ly it mv b be na nb l nc nd">%%time<br/>pd.read_parquet('APPLICATIONS_PROCESSED/NAME_INCOME_TYPE=Working/')<br/># OR (the run-time below corresponds to either one of way of reading)<br/>pd.read_parquet('APPLICATIONS_PROCESSED', filters=[('NAME_INCOME_TYPE', '=', 'Working')])</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/4188d793dbc627c434edbe725a081623.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*e8CD5BXsx_ZmGtEC42jSZg.png"/></div></figure><p id="a224" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你看到<em class="lw">速度</em>增加了吗？速度快了 3 倍，而且你不必加载全部数据，节省了你机器上的大量内存。</p><p id="0abe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这两种读取分区数据的方法有一个区别，但在我们的例子中几乎察觉不到:使用过滤器读取数据取决于内部分区的数量。实际上，这里我们在<em class="lw"> NAME_INCOME_TYPE，</em>上只有 5 个分区，所以读取数据的路径和过滤器方法之间的<em class="lw">运行时</em>是相同的。然而，如果我们有 1000 个分区，运行时的差异将会很大，因为<em class="lw"> Apache Parquet </em>必须发现所有的分区，并返回与您的过滤器匹配的分区。</p><p id="7973" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，我强调这样一个事实，用过滤器读取在灵活性和容量方面要强大得多，如果运行时的<em class="lw">权衡</em>可以接受的话，我强烈建议您尝试一下。</p><p id="622e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一个简单的例子是，如果您想专门读取两个或更多的分区(但不是所有的分区)，那么您无法使用路径读取有效地做到这一点，但是使用过滤器，您可以做到。</p><p id="fc97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">例如，如果我们不仅对标准的<em class="lw">【工作】</em>申请人感兴趣，而且对<em class="lw">【国家公务员】</em>申请人也感兴趣:</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="e02c" class="mz ly it mv b be na nb l nc nd">filters = [('NAME_INCOME_TYPE', 'in', ['Working', 'State servant'])]<br/>pd.read_parquet('APPLICATIONS_PROCESSED', filters=filters)</span></pre><p id="0351" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您也可以通过给出文件夹路径<em class="lw"> : </em>来加载整个数据，即使它是在<em class="lw"> NAME_INCOME_TYPE </em>上分区的</p><pre class="kk kl km kn gt mu mv mw bn mx my bi"><span id="62c8" class="mz ly it mv b be na nb l nc nd">pd.read_parquet('APPLICATIONS_PROCESSED')</span></pre><p id="214e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">请注意，在生成的数据帧上，列<em class="lw"> NAME_INCOME_TYPE </em>是存在的，而如果您正在读取<em class="lw"> NAME_INCOME_TYPE </em>的分区，则它是隐藏的。</p><p id="09ba" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这是正常的行为:通过简单地读取分区，分区数据上的<em class="lw">Apache</em><em class="lw">Parquet</em>假设您已经知道这个列是针对这个特定的已过滤分区值而存在的(因为您告诉他根据<em class="lw"> NAME_INCOME_TYPE </em>进行过滤)，所以它不会在输出数据帧中重复该列，因为它只是一个具有唯一值的<em class="lw"> NAME_INCOME_TYPE </em>的列。</p><p id="c601" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">总之，我们概述了使用<em class="lw"> Parquet </em>的最佳实践，包括定义一个模式和划分数据。我们还强调了使用<em class="lw">拼花</em>文件在<em class="lw">处理速度</em>和<em class="lw">存储效率</em>方面的优势(在<em class="lw">硬盘</em>和<em class="lw"> RAM </em>上)。此外，我们还考虑了数据用户的观点以及使用<em class="lw"> Parquet </em>文件的相关性和简单性。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="f0b4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">用我的其他文章继续学习拼花地板:</p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/parquet-best-practices-discover-your-data-without-loading-them-f854c57a45b6"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">拼花地板最佳实践:发现您的数据而不加载它们</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">元数据、行组统计信息、分区发现和重新分区</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kt ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a href="https://pub.towardsai.net/parquet-best-practices-the-art-of-filtering-d729357e441d" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">拼花地板最佳实践:过滤的艺术</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">了解如何过滤拼花文件</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">pub.towardsai.net</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kt ol"/></div></div></a></div><p id="28ab" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><em class="lw">无需额外费用，您可以通过我的推荐链接订阅 Medium。</em></p><div class="oi oj gp gr ok ol"><a href="https://medium.com/@arli94/membership" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">通过我的推荐链接加入 Medium—Arli</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">阅读 Arli 和媒体上成千上万的其他作家的每一个故事。你的会员费直接支持 Arli 和…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="pb l ow ox oy ou oz kt ol"/></div></div></a></div><p id="1f10" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">或者你可以在收件箱里收到我所有的帖子。<strong class="lc iu"><em class="lw"/></strong><a class="ae kz" href="https://arli94.medium.com/subscribe" rel="noopener"><strong class="lc iu"><em class="lw">做到这里</em> </strong> <em class="lw">！</em>T29】</a></p></div></div>    
</body>
</html>