<html>
<head>
<title>NumPy ufuncs — The Magic Behind Vectorized Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NumPy ufuncs——矢量化函数背后的魔力</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-ufuncs-the-magic-behind-vectorized-functions-8cc3ba56aa2c#2022-07-06">https://towardsdatascience.com/numpy-ufuncs-the-magic-behind-vectorized-functions-8cc3ba56aa2c#2022-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5206" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解NumPy通用函数(ufuncs)以及如何创建它们。编写自己的矢量化函数。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/681fb455f4702942bf3af26e8be953b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-ZXa1EyX3P2KGgMD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰瑞米·贝赞格在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过NumPy神奇表演的由来？NumPy在引擎盖下为数据科学家的许多日常驱动程序提供性能，例如熊猫。当然，考虑用C和Fortran编写的优化数组是正确的。至少说对了一半。另一半不是数组，而是NumPy的函数本身。NumPy通用函数(以下简称ufuncs)是数组(ndarray)之外的另一个构件。</p><p id="6852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想写一些圆滑的和高性能的数字代码时，没有别的办法；我们用NumPy。一旦我们开始使用NumPy数组，就可以直观地使用NumPy的内置函数来操纵和操作它们。如果我们在数组上使用Python的普通函数，性能会很快消失。</p><p id="d8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个故事中，我们将讨论一些关于ufunc的见解，更重要的是，学习关于自定义uf unc创建的基础知识。能够实现我们自己的ufuncs将使NumPy项目更上一层楼。</p><p id="5381" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常我们会花很多时间在NumPy的文档中寻找实现我们需要的功能的方法；有时候，我们找到了，有时候，我们没有。在后一种情况下，我们可能会最终实现一些hack或退回到普通Python，并牺牲性能。编写自定义函数可以极大地简化我们的生活。</p><p id="ed9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">故事结构:</p><ul class=""><li id="ee4c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">什么是ufuncs？</li><li id="aab1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一元和二元函数</li><li id="b214" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">NumPy ufunc创建</li><li id="4ae7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Numba ufunc创建:矢量化装饰器</li><li id="63d4" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">ufunc创建:NumPy vs. Numba</li><li id="e861" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">ufunc.reduce</li><li id="4038" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">ufunc.accumulate</li><li id="455e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">最终意见</li></ul><h2 id="8095" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">什么是ufuncs？</h2><p id="8386" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">NumPy ufuncs对数组(ndarray)进行元素操作。其中一些支持更复杂的功能，如阵列广播。虽然NumPy的内置uf unc是矢量化的(C或Fortran中的矢量化计算)，但并非所有uf unc都是相同意义上的矢量化，我们将在下面的部分中看到这一点。</p><p id="7b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有ufuncs都采用相同的可选关键字参数，并公开相同的属性和方法；你可以在这里查看它们。</p><p id="0936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy中的大部分函数都是ufuncs然而，有些不是，而是ufunc的方法。ufunc的方法是普通的Python函数，但仍然是从ufunc派生的。那是他们获得魔力的地方。比如np.sum就是一个正则函数，来自于<code class="fe nh ni nj nk b">np.add</code>，一个ufunc。</p><p id="3bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这些方法并不适用于所有的ufuncs。有两种主要的形式，二元和一元。方法只适用于二进制函数。</p><h2 id="5a9e" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">一元和二元函数</h2><p id="8185" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在数学中，最常见的运算是二进制。和(a + b)和乘积(a * b)是一些最简单和最著名的例子。这些操作中的一些是通勤的；其他人没有。然而，有一些转换是在单个元素上操作的。事实上，我们可以争论这些变换是否可以通过使用二元运算导出，也许是无限和——例如，指数函数。</p><p id="fd36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二元运算在数学中处于中心地位的原因之一是，所有具有两个以上操作数的运算都可以转换为一系列二元运算。</p><p id="001f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy在其函数中继承了这一行为。有两种类型的ufuncs:</p><ul class=""><li id="3440" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一元ufuncs:取一个数组(ndarray)作为参数</li><li id="305b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">二进制ufuncs:将两个数组(ndarray)作为参数</li></ul><p id="952d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="08e2" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class>，1</class></p><p id="b99d" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class>，2</class></p></blockquote><p id="5075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中nin属性是输入的数量。</p><h2 id="d718" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">NumPy ufunc创建</h2><p id="0318" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">创建自定义ufuncs非常容易。NumPy有一个实用程序<code class="fe nh ni nj nk b">np.frompyfunc</code>，它接受一个普通的Python函数、输入参数的数量和输出参数的数量，并返回一个ufunc。例如，我们可以创建一元ufunc:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="e5ad" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class>，<class/></class></p><p id="cdde" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">3, 3</p></blockquote><p id="5ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以创建一个二进制ufunc:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="6891" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class>，<class/></class></p><p id="12a7" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">2, 2</p></blockquote><h2 id="6abb" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">Numba ufunc创建:矢量化装饰器</h2><p id="f287" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">Numba还有一个创建ufunc的方法。<code class="fe nh ni nj nk b">vectorize</code>装饰工。然而，这个装饰器不仅仅是创建一个ufunc它还针对性能进行了优化。根据Numba的文档，它可以编译Python函数，其速度与用C编写的ufuncs相当(NumPy内置)。</p><p id="420c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多方法可以使用装饰器；最直接的方法是在装饰器中使用所有默认值(即没有参数):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="7d5e" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class/></p><p id="2d58" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">2</p><p id="ca52" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[2. 2.]</p></blockquote><p id="af8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们没有为编译指定输入和输出数据类型，因此是惰性模式。</p><p id="7bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以显式传递数据类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="4103" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class/></p><p id="de7f" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">2</p><p id="c38b" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[2. 2.]</p></blockquote><p id="54cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们说有一个输入(括号外的类型)和两个输出(括号内的元组)。如果两个输入都是<code class="fe nh ni nj nk b">int64</code>，返回类型也将是<code class="fe nh ni nj nk b">int64</code>。如果两个输入都是<code class="fe nh ni nj nk b">float32</code>，则输出是<code class="fe nh ni nj nk b">float32</code>，以此类推。指定数据类型可以优化编译。</p><p id="7feb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们还可以更改其他装饰器的默认参数来优化计算性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="fbfa" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class/></p><p id="a371" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">2</p><p id="fcdd" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[2. 2.]</p></blockquote><h2 id="995a" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">ufunc创建:NumPy vs. Numba</h2><p id="7635" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本节中，我们将比较添加两个2D NumPy数组(ndarray)的几种方法的计算时间。我们将使用以下ufuncs:</p><ul class=""><li id="127a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">NumPy内置add ( <code class="fe nh ni nj nk b">np.add</code>)</li><li id="1a58" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">np_my_sum</code>、用np.frompyfunc创建的ufunc</li><li id="31e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">numba_lazy_sum</code>、用下Numba的矢量化装饰器创建的ufunc，带有默认参数，没有数据类型信息</li><li id="8c87" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nh ni nj nk b">numba_dtype_sum</code>，使用矢量化装饰器创建的ufunc，说明用于编译的数据类型转换</li><li id="61d7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">numba_ <code class="fe nh ni nj nk b">dtype_opt_sum</code>，使用矢量化装饰器创建的ufunc，说明编译的数据类型转换以及优化性能的参数</li></ul><p id="1de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对谈话进行编码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="64e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/95ca965a36f2708467714c17ca47ff34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-tu_FPfmMeR9F1Vauf5Lw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加法运算的计算时间(越少越好)。对于NumPy内置，NumPy ufunc(frompypfunc)和几个Numba ufuncs(矢量化装饰器)[作者图片]</p></figure><p id="583d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，用NumPy <code class="fe nh ni nj nk b">frompyfunc</code>创建的ufunc完全是另一个联盟；计算时间比其他函数大几个数量级。然而，如果我们忽略它，我们可以看到Numba的ufuncs性能与NumPy的内置<code class="fe nh ni nj nk b">add</code>功能相当，并且它们之间是相似的。</p><p id="e287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想创造高性能的ufuncs，Numba是必由之路。除非性能很关键，否则<code class="fe nh ni nj nk b">vectorize</code>装饰器可以在没有参数的情况下使用。</p><p id="77cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NumPy的优势之一是它的性能，为Python带来了速度。让我们面对它；速度不是Python的优势之一。因此，有必要区分C或Fortran矢量化计算与纯Python矢量化。速度不会一样。</p><h2 id="e46e" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">ufunc.reduce</h2><p id="6375" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">NumPy中有些函数不是ufuncs大多数人都接受axis关键字。这些函数非常棒，因为它们允许我们指定是将函数操作应用于整个数组，还是只应用于轴的子集，例如<code class="fe nh ni nj nk b">np.sum</code>。</p><p id="788d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个2D阵列，并且不指定轴(或者同时指定两个轴)。在这种情况下，函数返回一个标量和整个数组的和，但是如果我们指定轴零(1)，函数将返回列(行)和的向量。</p><p id="141c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以检查<code class="fe nh ni nj nk b">np.sum</code>是一个普通的Python函数，而不是ufunc:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="9776" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated"><class/></p></blockquote><p id="3c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们可以使用函数和axis参数做的事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="589b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印总和:</p><blockquote class="nn no np"><p id="8deb" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">36</p><p id="594a" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">36</p><p id="ba1a" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]</p><p id="f1b1" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 12 21]</p></blockquote><p id="8781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在引擎盖下，<code class="fe nh ni nj nk b">np.sum</code>本质上是<code class="fe nh ni nj nk b"> np.add</code>功能的还原方法的应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="a0aa" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">36</p><p id="026d" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">36</p><p id="7dda" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]</p><p id="d405" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 12 21]</p></blockquote><p id="5870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果我们可以从add ufunc中恢复NumPy sum函数，那么Numba的add ufunc呢？当然，我们也可以使用reduce。让我们用<code class="fe nh ni nj nk b">vectorized</code>装饰器来定义函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="a850" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">36</p><p id="54e8" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">36</p><p id="6a60" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]</p><p id="8908" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 12 21]</p></blockquote><p id="18fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们是金色的。</p><p id="4d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">讨论NumPy的apply _沿_轴函数是至关重要的。它可以简化Python的常规函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="94f2" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]</p><p id="4b69" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 12 21]</p></blockquote><p id="e61c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这样做并不会利用NumPy的性能。这比使用编译的ufunc要慢得多。所以要小心。</p><h2 id="40f5" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">ufunc.accumulate</h2><p id="2e34" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">另一个有用方法是积累。对于sum，它类似于函数(普通Python) np.cumsum所做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="56f7" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[[ 0 1 2]</p><p id="d2ff" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 5 7]</p><p id="8dd2" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]]</p><p id="e51d" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[[ 0 1 3]</p><p id="3866" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 7 12]</p><p id="0676" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 6 13 21]]</p></blockquote><p id="b255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在add ufunc中使用accumulate方法，得到相同的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="ed8c" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[[ 0 1 2]</p><p id="36d1" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 5 7]</p><p id="8fe2" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]]</p><p id="3bd2" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[[ 0 1 3]</p><p id="089a" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 7 12]</p><p id="412b" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 6 13 21]]</p></blockquote><p id="881a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在Numba的ufunc中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><blockquote class="nn no np"><p id="9f60" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[[ 0 1 2]</p><p id="f125" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 5 7]</p><p id="b047" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 9 12 15]]</p><p id="660b" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[[ 0 1 3]</p><p id="b69a" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 3 7 12]</p><p id="393a" class="kz la nq lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi">[ 6 13 21]]</p></blockquote><h2 id="8d76" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">最终意见</h2><p id="e018" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">正如我们在这个故事中所看到的，强调并非所有的人生来平等是至关重要的。在ndarrays上应用自定义函数时，即使使用frompyfunc或apply_along_axis等NumPy工具，找出代码中的性能瓶颈也是至关重要的。</p><p id="7333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以下次在数组上使用函数时，问问自己它是否为矢量化运算进行了适当的优化。</p><p id="6f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于ufunc的创建，Numba的实用程序在性能方面是一个不错的选择。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="3707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个故事对你有用。 <a class="ae ky" href="https://medium.com/subscribe/@diego-barba" rel="noopener"> <em class="nq">订阅</em> </a> <em class="nq">到我的邮件列表如果你想知道更多这样的故事。</em></p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="87ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nq">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</em></p><div class="oc od gp gr oe of"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">阅读迭戈·巴尔巴(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>