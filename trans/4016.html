<html>
<head>
<title>SQL Aggregate Functions Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SQL聚合函数面试问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sql-aggregate-functions-interview-questions-46a631114843#2022-09-07">https://towardsdatascience.com/sql-aggregate-functions-interview-questions-46a631114843#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="37ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为了下一次数据科学面试，让我们更深入地了解一下必须知道的SQL聚合概念。</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/feee05a394cee62d48498067c2c2535b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r-0AoHbxtUX8s3fPao0l7Q.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图片</p></figure><p id="8122" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">今天，我们每秒钟生成数百万、数十亿行数据。然而，我们通常需要一个单一的指标来标记变更并做出业务决策。例如，上一季度的总销售额、平均流失率、广告投放次数等。聚合函数有助于生成这些指标。聚合函数根据一组输入值计算单个结果。所有聚合函数都是确定性的，每次使用相同的输入值集调用它们时，它们都输出相同的值。我们有一篇文章——《SQL聚合的终极指南<a class="ae kw" href="https://www.stratascratch.com/blog/the-ultimate-guide-to-sql-aggregate-functions/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"><em class="lt"/></a>——来获得这些函数的介绍性概述。在本文中，我们将更深入地研究SQL聚合函数的使用。我们将在这里讨论的各种场景是:</p><ul class=""><li id="d7f9" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">整个表上的聚合</li><li id="8757" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">按组群汇总</li><li id="5577" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">窗口函数中的聚合</li></ul><p id="2d11" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意:除了COUNT(*)，所有聚合函数都会忽略空值，除非另有说明。让我们开始吧。</p><h1 id="175c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">整个表上的聚合</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/a930b6e787e3cbfe3a430d1f93ada38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EYYCnu0sDvdRNU9C"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="8326" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最简单的用例是从一个数据集中找到总的聚合指标。让我们用Postmates数据科学家访谈问题中的一个例子来尝试一下。</p><h2 id="10ed" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题#1:客户平均订单</h2><p id="d61f" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated"><em class="lt">查找平均订单金额和下订单的客户数量。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nr"><img src="../Images/1840a1c3946c9b48f4f5a48b435098b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*23-WyfM8buxhv9LU"/></div></div></figure><p id="7585" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此问题使用具有以下字段的postmates_order表。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b02ae4fb8af9e5004f5a018052f27e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*RfGSa-EB_pdRa_QcMmhIuQ.png"/></div></figure><p id="f36e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据以下列方式显示。</p><p id="217e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong> postmates_orders</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nt"><img src="../Images/301cd307905990cbae26618f80accf9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFJoJhfizDZDAmQNBp_pIw.png"/></div></div></figure><h2 id="958d" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="6e04" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">这个问题很简单。但是有一点小小的变化，我们稍后会讲到。找到平均订单量相当容易。我们只需要使用AVG()函数。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="5b36" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    AVG(amount) AS avg_order_amount <br/>FROM postmates_orders<br/>;</span></pre><p id="b2b2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是，要找到客户的数量，我们需要稍微小心一点。我们不能简单地采用COUNT(*)或COUNT(customer_id ),因为存在重复交易的客户。我们需要使用DISTINCT关键字来确保我们只计算唯一的。使用下面的查询可以解决这个问题。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="b725" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    COUNT(DISTINCT customer_id) AS num_customers<br/>    , AVG(amount) AS avg_order_amount <br/>FROM postmates_orders<br/>;</span></pre><h2 id="276c" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题2:出售披萨的Yelp商家数量</h2><p id="95f4" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated"><em class="lt">查找出售披萨的Yelp商家的数量。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi od"><img src="../Images/c3bb514438fff49ad3d819101aa3e19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ums1nu_GbZgIn8m7"/></div></div></figure><p id="0570" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该问题使用包含以下字段的yelp_business数据集。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oe"><img src="../Images/d5916db2caf79fdd642ad483ce829708.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*5d_we3UdWIKy25EnYr1j1w.png"/></div></div></figure><p id="5e8a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据是这样的。</p><p id="033f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表格:</strong> yelp_business</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi of"><img src="../Images/4b41c00c7fab73cfecb92283e4dd40c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMIqUde6L_5klIayXqIlxw.png"/></div></div></figure><h2 id="3d8a" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="dc24" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">这是一个非常简单的问题。在解决问题时，我们需要考虑两个部分。</p><ul class=""><li id="23f3" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">识别销售比萨饼的企业</li><li id="a3fa" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">细数相关商家。</li></ul><p id="fc04" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了识别销售比萨饼的企业，我们使用categories字段并搜索文本是否包含短语“比萨饼”。为了使搜索不区分大小写，我们使用ILIKE操作符。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="ecd0" class="na mj iq nv b gy nz oa l ob oc">SELECT business_id, categories<br/>FROM yelp_business<br/>WHERE categories ILIKE '%pizza%'<br/>;</span></pre><p id="579f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">或者，我们也可以将文本转换成大写或小写，并使用LIKE操作符，它在所有SQL风格中都可用。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="7a2c" class="na mj iq nv b gy nz oa l ob oc">SELECT business_id, categories<br/>FROM yelp_business<br/>WHERE LOWER(categories) LIKE '%pizza%'<br/>;</span></pre><p id="8692" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">输出如下所示</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi og"><img src="../Images/1c24159d74ccf9bdfab1da6457d93124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n2DKThZ-cznLOivm"/></div></div></figure><p id="9a51" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们简单地计算唯一的business_id。同样，我们使用DISTINCT关键字来忽略重复项。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="bd1c" class="na mj iq nv b gy nz oa l ob oc">SELECT COUNT(DISTINCT business_id)<br/>FROM yelp_business<br/>WHERE LOWER(categories) LIKE '%pizza%'<br/>;</span></pre><h1 id="b1ce" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">按组群汇总</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/98ca69490a01dea3ef6525e32e71f8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QN9HOtTdgLcZpDHm"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="1f2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">聚合的另一个常见用例是按不同的分组进行汇总——相同的产品类别、交易月份、现场访问周等。这些基于群组的分析有助于我们识别子层中的趋势，而这些子层在总体总量中可能是不可见的。我们可以通过使用GROUP BY子句来实现这一点。让我们从ESPN数据科学采访中的一个简单问题开始。</p><h2 id="fa6e" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题3:找出第一次参加奥运会的年份</h2><p id="621a" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated"><em class="lt">根据各国首次参加奥运会的年份对其进行排序。该国可在国家奥林匹克委员会(NOC)领域。按升序报告年份和NOC。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oh"><img src="../Images/c55cb85e975967c8ab208f173601446b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cOQK6u30XY5FhwLo"/></div></div></figure><p id="c349" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该问题使用包含以下字段的olympics_athletes_events数据集。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/cee7dcb5b0b000a17772e7c43a7fc716.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*NBP2OOuVog4lZCeJJAA5eg.png"/></div></figure><p id="255e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据以下列方式显示。</p><p id="e503" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>奥运会_运动员_赛事</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oj"><img src="../Images/cd1eb4a68ddc885eb174872d023ac5f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a9Wrb-rq0m9pJpxG9pBamA.png"/></div></div></figure><h2 id="1b53" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="c188" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">这是一个相对容易的问题。为了解决这个问题，我们按以下方式进行。</p><ul class=""><li id="3765" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">找出某个国家参加奥运会的最早年份。</li><li id="8fbf" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">以所需的方式对结果进行排序。</li></ul><p id="c43b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与前一个问题不同，我们需要按国家进行汇总。为此，我们使用GROUP BY子句。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="2a28" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>noc, MIN(year) <br/>FROM olympics_athletes_events<br/>GROUP BY 1<br/>;</span></pre><p id="498d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ok"><img src="../Images/9cace31ef89952ed0f0cb3e50e808007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tl-GnSyDjOjc8dCH"/></div></div></figure><p id="3105" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们通过根据需要对输出进行排序来完成这个问题。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="8cb7" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>noc, MIN(year) <br/>FROM olympics_athletes_events<br/>GROUP BY 1<br/>ORDER BY 2,1<br/>;</span></pre><h2 id="38ed" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题4:每年最高的薪水</h2><p id="5664" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated"><em class="lt">报告2011年至2014年每一年每位员工的最高薪酬。以每名员工一行的形式输出上述各年相应的最高薪酬。按照员工姓名的字母顺序对记录进行排序。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ol"><img src="../Images/997a62f4104f2b2b865ff473a0a8c0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OGcG7uQyIcZ7Gmc5"/></div></div></figure><p id="2156" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该问题使用包含以下字段的sf _ public _ salaries表。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi om"><img src="../Images/b03ef52594c047450eaea2515ed0e05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*jIuu43oK9jiDNzYl9IkaMA.png"/></div></div></figure><p id="5d5a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据以下列方式显示。</p><p id="d97f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>SF _ public _ salary</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi on"><img src="../Images/e2f10a6af2345512433c8d3083e6d1eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uX0VrhZzJ63ca2R8Nt5sNw.png"/></div></div></figure><h2 id="7128" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="1ea2" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">我们可以用以下方式解决这个SQL聚合函数面试问题。</p><ul class=""><li id="fddf" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">首先旋转每个员工每年的工资。</li><li id="f065" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">汇总每个员工每年的数据，并以所需的方式输出。</li></ul><p id="c5e5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据集中感兴趣的列是employeename、totalpay和year。数据是长格式的。我们需要将其转换成宽格式。为此，我们使用CASE WHEN运算符。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="2943" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>    employeename<br/>    , CASE WHEN year = 2011 THEN totalpay ELSE 0 END AS pay_2011<br/>    , CASE WHEN year = 2012 THEN totalpay ELSE 0 END AS pay_2012<br/>    , CASE WHEN year = 2013 THEN totalpay ELSE 0 END AS pay_2013<br/>    , CASE WHEN year = 2014 THEN totalpay ELSE 0 END AS pay_2014<br/>FROM<br/>sf_public_salaries<br/>;</span></pre><p id="aca4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oo"><img src="../Images/0e3cb9513920cb2ad432af4b968a0d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T61ZS9i3RdQaazU-"/></div></div></figure><p id="0021" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们已经成功地从长格式数据集转向宽格式数据集。现在，我们只需找到根据雇员姓名聚合的每一列的最高工资，并按字母顺序对结果进行排序。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="7d2a" class="na mj iq nv b gy nz oa l ob oc">WITH yearly_pays as (<br/>SELECT <br/>    employeename<br/>    , CASE WHEN year = 2011 THEN totalpay ELSE 0 END AS pay_2011<br/>    , CASE WHEN year = 2012 THEN totalpay ELSE 0 END AS pay_2012<br/>    , CASE WHEN year = 2013 THEN totalpay ELSE 0 END AS pay_2013<br/>    , CASE WHEN year = 2014 THEN totalpay ELSE 0 END AS pay_2014<br/>FROM<br/>sf_public_salaries<br/>)<br/>SELECT <br/>    employeename<br/>    , MAX(pay_2011) AS pay_2011<br/>    , MAX(pay_2012) AS pay_2012<br/>    , MAX(pay_2013) AS pay_2013<br/>    , MAX(pay_2014) AS pay_2014<br/>FROM yearly_pays<br/>GROUP BY 1<br/>ORDER BY 1<br/>;</span></pre><p id="f70c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">或者，我们可以在MAX()函数中使用CASE WHEN操作符，而不必创建一个CTE。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="5aa7" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>    employeename<br/>    , MAX(CASE WHEN year = 2011 THEN totalpay ELSE 0 END) AS pay_2011<br/>    , MAX(CASE WHEN year = 2012 THEN totalpay ELSE 0 END) AS pay_2012<br/>    , MAX(CASE WHEN year = 2013 THEN totalpay ELSE 0 END) AS pay_2013<br/>    , MAX(CASE WHEN year = 2014 THEN totalpay ELSE 0 END) AS pay_2014<br/>FROM<br/>sf_public_salaries<br/>GROUP BY 1<br/>ORDER BY 1<br/>;</span></pre><h2 id="7ab6" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题5:有风险的项目</h2><p id="79f3" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">确定可能会超出预算的项目。为了计算项目的成本，我们需要在项目持续期间按比例分配给项目的所有员工的成本。员工成本按年定义。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi op"><img src="../Images/c22fac16b98f5f7b82a249cc402e2322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*irdzBVwBe8R5dZ5I"/></div></div></figure><p id="79fd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该问题使用了三个表:linkedin_projects、linkedin_emp_projects、linkedin_employees</p><p id="cfd3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">linkedin_projects表包含以下字段。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f9261d99700266a31f3115e44879d9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*OgKch_VT10rVxIFdBS1ATg.png"/></div></figure><p id="f52d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表格:</strong>领英_项目</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi on"><img src="../Images/9c7f9f55452469572c841a0eb1c86787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TrSWw2QZL5GAARx1Ir4quA.png"/></div></div></figure><p id="b77f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数据集linkedin_emp_projects包含以下字段。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi or"><img src="../Images/d1b4e80b45b1c73815b5ffb9a5f2949c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*BZZ5GgyTe8A838HcmKTiQA.png"/></div></figure><p id="73ae" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表格:</strong>领英_员工_项目</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi os"><img src="../Images/48a6a26a57aee854d944d5e9906b12e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ri9OF7zOzGSvcwWFCdgchA.png"/></div></div></figure><p id="d7b9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">包含以下字段的数据集linkedin_employees</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/c9b4b1916c394fcc194c5e2ab7b09670.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*LRSdVtMcqfceN57PrHB7Yg.png"/></div></figure><p id="d7ef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>LinkedIn _员工</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ou"><img src="../Images/f5d0063a7b6b39e5df2dd7410687df0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SaNPjybdg2NuQyRjTHOyVQ.png"/></div></div></figure><h2 id="02ca" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="b7b9" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">与前一个问题相比，这是一个更长的问题。让我们把我们的解决方案分成更小的部分。我们的计划是</p><ul class=""><li id="8e8f" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">首先，找出每个员工的每日成本</li><li id="fca1" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">然后在项目级别合计每日成本</li><li id="6256" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">通过将项目的每日总成本乘以项目的持续时间来计算项目的预计成本</li><li id="758d" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">输出相关结果。</li></ul><p id="ac40" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从找出每天的花费开始。由于员工的工资是一整年的，所以我们通过将工资除以365来计算每天的成本。注意，由于salary字段是一个整数，我们需要将分子或分母转换为浮点，以避免整数除法<a class="ae kw" href="https://www.postgresql.org/docs/8.0/functions-math.html#:~:text=division%20(integer%20division%20truncates%20results" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="850f" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>*, salary * 1.0 / 365 AS daily_cost<br/>FROM linkedin_employees <br/>;</span></pre><p id="ab3c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们也可以通过除以365.0来完成同样的操作</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="714e" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>*, salary / 365.0 AS daily_cost<br/>FROM linkedin_employees<br/>;</span></pre><p id="82a6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ov"><img src="../Images/9795342fb86f65257338df1e25b40eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FjCkz4yeiIq5han4"/></div></div></figure><p id="1eee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，我们通过合计与项目相关的所有员工的员工成本来计算每个项目的每日成本。为此，我们将linkedin_emp_projects表与linkedin_employees表合并。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="92d0" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>    lep.project_id<br/>    , SUM(le.salary / 365.0) AS daily_cost<br/>FROM <br/>linkedin_emp_projects AS lep<br/>LEFT JOIN linkedin_employees AS le<br/>    ON lep.emp_id = le.id<br/>GROUP BY 1    <br/>;</span></pre><p id="9fef" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ow"><img src="../Images/78b20514d5f190bc5035ab6df2d66679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hPmxgXqpsNIj9D7O"/></div></div></figure><p id="ea1d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们将上述输出与linkedin_projects合并，以获得项目细节。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="2161" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>    lp.title<br/>    , lp.budget<br/>    , lp.start_date<br/>    , lp.end_date<br/>    , SUM(le.salary / 365.0) AS daily_cost<br/>FROM <br/>linkedin_projects AS lp<br/>LEFT JOIN linkedin_emp_projects AS lep<br/>    ON lp.id = lep.project_id<br/>LEFT JOIN linkedin_employees AS le<br/>    ON lep.emp_id = le.id<br/>GROUP BY 1,2,3,4    <br/>;</span></pre><p id="18ea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ox"><img src="../Images/c7d332589025da5aec8c243ff610e3f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gfuodsYn1L6pW43K"/></div></div></figure><p id="fee9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们在一个表中有了所有的数据。现在，我们可以根据start_date和end_date之间的天数计算预计成本，并将其乘以每日成本。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="6bd9" class="na mj iq nv b gy nz oa l ob oc">WITH merged AS (<br/>SELECT <br/>    lp.title<br/>    , lp.budget<br/>    , lp.start_date<br/>    , lp.end_date<br/>    , SUM(le.salary / 365.0) AS daily_cost<br/>FROM <br/>linkedin_projects AS lp<br/>LEFT JOIN linkedin_emp_projects AS lep<br/>    ON lp.id = lep.project_id<br/>LEFT JOIN linkedin_employees AS le<br/>    ON lep.emp_id = le.id<br/>GROUP BY 1,2,3,4<br/>)<br/>SELECT <br/>    title<br/>    , budget<br/>    , (end_date - start_date)::INT * daily_cost AS projected_cost<br/>FROM merged<br/>;</span></pre><p id="9dc8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oy"><img src="../Images/aad3c210ae40663bd897def98ffe2912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yotH8genFqa3zrod"/></div></div></figure><p id="5da0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们最后向上取整projected_cost，并且只输出那些projected_cost大于预算的项目。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="e64c" class="na mj iq nv b gy nz oa l ob oc">WITH merged AS (<br/>SELECT <br/>    lp.title<br/>    , lp.budget<br/>    , lp.start_date<br/>    , lp.end_date<br/>    , SUM(le.salary / 365.0) AS daily_cost<br/>FROM <br/>linkedin_projects AS lp<br/>LEFT JOIN linkedin_emp_projects AS lep<br/>    ON lp.id = lep.project_id<br/>LEFT JOIN linkedin_employees AS le<br/>    ON lep.emp_id = le.id<br/>GROUP BY 1,2,3,4<br/>)<br/>SELECT <br/>    title<br/>    , budget<br/>    , CEIL((end_date - start_date)::INT * daily_cost) AS projected_cost<br/>FROM merged<br/>WHERE (end_date - start_date)::INT * daily_cost &gt; budget<br/>;</span></pre><p id="3848" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以参考我们的文章<a class="ae kw" href="https://www.stratascratch.com/blog/different-types-of-sql-joins-that-you-must-know/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank"> " <em class="lt">不同类型的SQL连接</em> " </a>来更详细地理解连接的概念。</p><h1 id="5380" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">窗口函数中的聚合</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/da1774370d144b5a24489c0959cc1e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p2it3NvNAgKH-uvC"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图像</p></figure><p id="9afa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">窗口函数的知识和应用是区分顶级SQL分析师和优秀分析师的关键。如果使用得当，窗口函数可以节省大量时间，因为它们有助于节省用于聚集然后合并回原始数据集的中间查询。在数据分析师和数据科学家的时代，这是一个非常常见的用例。我们从亚马逊数据科学采访中的一个简单问题开始。</p><h2 id="22cf" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题6:最新登录日期</h2><p id="bfb7" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated"><em class="lt">查找每个视频游戏玩家登录的最新日期。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oz"><img src="../Images/897d72fb64ad1160b2f20d64d7d6c75c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BL5_lds6oRb5fCmF"/></div></div></figure><p id="7729" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该问题使用包含以下字段的players_logins表</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/3cc8214fe93fcaf757f4484e2ac649b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*pz4Mnopr5fxw-ef4-OoCMQ.png"/></div></figure><p id="65a8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>玩家_登录</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/04fe15ae9fa5c1fe2a6ddbebb83a4c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*qx3mVkx1zawbCePevCj-2Q.png"/></div></figure><h2 id="f815" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="d158" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">通过在GROUP BY子句中使用MAX()可以非常容易地解决这个问题。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="6a87" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    player_id<br/>    , MAX(login_date) AS latest_login<br/>FROM players_logins<br/>GROUP BY 1<br/>;</span></pre><p id="9633" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是让我们用稍微不同的方法来解决这个问题。这将帮助我们理解窗口函数中的聚合是如何工作的。我们需要找到最近的登录日期，按照player_id进行划分。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="7f65" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    player_id<br/>    , login_date<br/>    , MAX(login_date) OVER (PARTITION BY player_id) AS latest_login<br/>FROM players_logins<br/>;</span></pre><p id="2a2f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pc"><img src="../Images/da5418a9eb5955400e16d7e66337fb1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bFcsUzIPQmmda78M"/></div></div></figure><p id="41ff" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们有每个玩家的最新登录信息，我们可以通过使用DISTINCT子句来删除重复项，从而获得最终输出。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="559f" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    DISTINCT<br/>    player_id<br/>    , MAX(login_date) OVER (PARTITION BY player_id) AS latest_login<br/>FROM players_logins<br/>;</span></pre><p id="b94a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与之前的GROUP BY相比，使用window函数的优势在于，我们在一次查询调用中添加了一个字段，其中包含每个玩家的最新登录日期。我们不必单独汇总指标，并将其合并回原始数据集。这有助于我们将总指标与单个值进行比较。在下一个问题中会非常有用的东西。这是来自网飞数据科学的采访。</p><h2 id="36e1" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题7:电影分级的不同</h2><p id="fc62" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated"><em class="lt">对于每位演员，报告所有电影的平均终身评分与她参演的倒数第二部电影的评分之间的差异。只考虑角色类型为‘普通演技’的电影。id字段是根据电影发行的时间顺序创建的顺序ID。排除没有评级的角色。</em></p><p id="3b9c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="lt">输出演员姓名，终身评分，倒数第二部电影的评分，以及两个评分的绝对差值。</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pd"><img src="../Images/aa02b4656d6929cbacad5e47f1f0f3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ycU5Ed7HEcYKoBl"/></div></div></figure><p id="5d02" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个问题使用了两个表格——被提名人电影记录和被提名人信息。表nominee_filmography具有以下字段。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/4532dc271498ccf27eb6edb683df28b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*1ZkPaJXhUdyGzUEFCQtqdA.png"/></div></figure><p id="0f48" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>提名人_从影记录</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pe"><img src="../Images/52ae76c43e539af528928380a37759bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ccRyfOWfQzXdzjnH64Ilog.png"/></div></div></figure><p id="2741" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">表nominee_information包含以下字段。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/2e96eec2a09f5c4cc7defb2f439dda82.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*PNv0TZs50GdOPo-PdZIYFQ.png"/></div></figure><p id="15cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表格:</strong>被提名人_信息</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pg"><img src="../Images/496eaafcf54f49c8c7576c35293909e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3aSlTBPCpNZhNeqswD-rg.png"/></div></div></figure><h2 id="653d" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="c62d" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">如果仔细阅读这个SQL聚合函数面试问题，我们不需要第二个表。我们需要的所有数据都在第一个表格中(提名人_电影记录)。我们可以用下面的方法解决这个问题</p><ul class=""><li id="5bbd" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">找出一个演员演过的所有电影的平均评分。</li><li id="610d" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">查找每位演员的倒数第二部电影的评分</li><li id="cef0" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">报告两者之间的差异，并输出相关字段。</li></ul><p id="a04f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要排除那些没有提供分级的电影，只包括那些角色类型为“正常表演”的电影。我们从找到平均评级开始。我们不使用GROUP BY子句，而是使用一个窗口函数，因为在第二步中我们也将使用一个窗口函数。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="f55d" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    name<br/>    , id<br/>    , rating<br/>    , AVG(rating) OVER (PARTITION BY name) AS avg_rating<br/>FROM nominee_filmography<br/>WHERE role_type = 'Normal Acting'<br/>AND rating IS NOT NULL<br/>;</span></pre><p id="06d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ph"><img src="../Images/8092a3614230aa7b00cfa2080e65e16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y1fl5pXQQCv_VjGx"/></div></div></figure><p id="e187" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们添加另一个窗口函数来根据id字段计算电影的排名。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="f3b5" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    name<br/>    , id<br/>    , rating<br/>    , AVG(rating) OVER (PARTITION BY name) AS avg_rating<br/>    , RANK() OVER (PARTITION BY name ORDER BY id DESC) AS movie_order<br/>FROM nominee_filmography<br/>WHERE role_type = 'Normal Acting'<br/>AND rating IS NOT NULL<br/>;</span></pre><p id="093b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下输出。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ow"><img src="../Images/8cf836fffa5fa0672cbc9d5493395865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fj0ciDIV2leJ62Ig"/></div></div></figure><p id="a5ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们现在有了演员出演的每部电影的总体电影评级和排名(根据上映日期)。现在我们简单的找到排名2的电影(倒数第二部电影)，找到与平均评分的绝对差值。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="7d5d" class="na mj iq nv b gy nz oa l ob oc">SELECT <br/>    name<br/>    , avg_rating<br/>    , rating<br/>    , ABS(avg_rating - rating) AS difference<br/>FROM (<br/>    SELECT<br/>        name<br/>        , id<br/>        , rating<br/>        , AVG(rating) OVER (PARTITION BY name) AS avg_rating<br/>        , RANK() OVER (PARTITION BY name ORDER BY id DESC) AS movie_order<br/>    FROM nominee_filmography<br/>    WHERE role_type = 'Normal Acting'<br/>    AND rating IS NOT NULL<br/>    ) AS ranked<br/>WHERE movie_order = 2<br/>;</span></pre><p id="561c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可以在这里阅读我们关于窗口功能的全面指南。</p><h1 id="33d1" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">额外文本聚合</h1><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/fd2c025f6f1c4a18e8a7178dd4f35ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F_OpmynEP0FSw9-j"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">作者在<a class="ae kw" href="https://canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>上创建的图片</p></figure><p id="956d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们通过将聚合函数应用于文本操作来结束我们对聚合的研究。随着非结构化数据变得越来越普遍，在SQL中熟练使用文本操作函数非常重要。我们有一篇文章专门讨论<a class="ae kw" href="https://www.stratascratch.com/blog/string-and-array-functions-in-sql-for-data-science/?utm_source=blog&amp;utm_medium=click&amp;utm_campaign=medium" rel="noopener ugc nofollow" target="_blank">文本操作，如果你想了解更多关于文本特定函数的信息。出于这个练习的目的，我们将使用一个在亚马逊数据科学采访中出现的问题，这个问题相当难。但是让我们试着用稍微不同的方式来解决这个问题。</a></p><h2 id="a07c" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">问题8:连胜记录最长的球员</h2><p id="f320" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">给定乒乓球运动员的比赛日期和比赛结果，找出最长的连胜记录。连胜是指一个球员连续赢得比赛的次数。输出具有最长连胜的玩家的ID和连胜的长度。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pi"><img src="../Images/6326e9e20a570bd08d0bb850f048a25c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uo-y4lPOshuqZdzk"/></div></div></figure><p id="7e1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">该问题使用包含以下字段的players_results表</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/5fd216dfc6eeabd5d303c15c592c735f.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*xes1moTIeziJFvH5P6_BGg.png"/></div></figure><p id="1b0b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><strong class="kz ir">表:</strong>选手_成绩</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pk"><img src="../Images/ef37e1f36284d6a84c6c7b899e2b78b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZlcjRfu7xsG_IcHZFCUdQ.png"/></div></div></figure><h2 id="3dcc" class="na mj iq bd mk nb nc dn mo nd ne dp ms lg nf ng mu lk nh ni mw lo nj nk my nl bi translated">解决办法</h2><p id="2899" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">要解决这个SQL聚合函数面试问题，我们需要了解条纹是如何定义的，以及我们如何识别它们。让我们假设一个玩家赢和输的序列。</p><p id="7be4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">W，W，L，L，W，L，W，L，W，W，L，L，W，W，L，W，L，W，W，W，L，L，W</p><p id="2d16" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们忽略损失，序列会变成类似这样。</p><p id="b8ed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">W，W，_，_，W，_，W，W，_，_，W，W，_，W，_，W，_，W，W，_，_，W</p><p id="d75d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">牛排的开始和结束可以简单地通过空间的存在来识别。所以在上面的例子中，条纹是2，1，3，2，1，2，1。然后，我们可以将这些条纹中最长的条纹作为玩家的最佳条纹(在我们的示例中为三个)。</p><p id="b1ee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要以上述方式在SQL中实现这一点，我们需要执行以下操作。</p><ul class=""><li id="6993" class="lu lv iq kz b la lb ld le lg lw lk lx lo ly ls lz ma mb mc bi translated">按照match_date的顺序连接所有结果</li><li id="861c" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">通过移除中间损失，将结果字符串分割成单独的条纹。</li><li id="6226" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">找出条纹的长度</li><li id="fca6" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">在玩家级别聚集，保持每个玩家最长的连胜记录</li><li id="d0c4" class="lu lv iq kz b la md ld me lg mf lk mg lo mh ls lz ma mb mc bi translated">输出最长的连胜记录以及拥有最长连胜记录的玩家。</li></ul><p id="b76d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们首先按照球员的时间顺序连接每场比赛的结果。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="2719" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    player_id<br/>    , string_agg(match_result, '' ORDER BY match_date) as result_string<br/>FROM players_results<br/>GROUP BY 1<br/>;</span></pre><p id="1ed6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到以下结果</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pl"><img src="../Images/6a4209abb9d57e3d9468d8e49da5fac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zwsBjCfXs_LEv5yt"/></div></div></figure><p id="f6c3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后我们继续分割琴弦。为此，我们使用string_to_array函数，并通过使用“L”作为分隔符将结果字符串转换为数组。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="e1f1" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    player_id<br/>    , string_to_array(string_agg(match_result, '' ORDER BY match_date), 'L') as win_streak<br/>FROM players_results<br/>GROUP BY 1</span></pre><p id="a2f6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们得到一系列条纹。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pm"><img src="../Images/7f3a6840f0ba21fc1e15cb28daf813ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SntiD3RbFdf3nbsw"/></div></div></figure><p id="4da6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们需要做的就是用空白来识别条纹的起点和终点。现在，我们继续将阵列分割成单独的条纹。为此，我们使用UNNEST()函数。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="f4f9" class="na mj iq nv b gy nz oa l ob oc">SELECT<br/>    player_id<br/>    , unnest(string_to_array(string_agg(match_result, '' ORDER BY match_date), 'L')) as win_streak<br/>FROM players_results<br/>GROUP BY 1<br/>;</span></pre><p id="3b62" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们现在有如下的单独条纹。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pn"><img src="../Images/f54db8147673717d32641b92d418e4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*chhyNbFPjqZN85Mk"/></div></div></figure><p id="4b80" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在问题已经简化为寻找最长‘连胜’的长度。这可以通过使用LENGTH()函数来完成。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="a92a" class="na mj iq nv b gy nz oa l ob oc">WITH res_str AS (<br/>    SELECT<br/>        player_id<br/>        , unnest(string_to_array(string_agg(match_result, '' ORDER BY match_date), 'L')) as win_streak<br/>    FROM players_results<br/>    GROUP BY 1<br/>)<br/>SELECT <br/>    player_id<br/>    , win_streak<br/>    , length(win_streak)<br/>FROM res_str<br/>;</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi po"><img src="../Images/dc7b1534d487826d8ba29dc3198a3bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2qgcziglDIlW8R9i"/></div></div></figure><p id="7a2d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们使用GROUP BY子句在玩家级别进行聚合。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="9aff" class="na mj iq nv b gy nz oa l ob oc">WITH res_str AS (<br/>    SELECT<br/>        player_id<br/>        , unnest(string_to_array(string_agg(match_result, '' ORDER BY match_date), 'L')) as win_streak<br/>    FROM players_results<br/>    GROUP BY 1<br/>)<br/>SELECT <br/>    player_id<br/>    , MAX(length(win_streak)) as max_streak<br/>FROM res_str<br/>GROUP BY 1<br/>;</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/9e63785875154fa657d1328ea4a51640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/0*_PNrK2x2uYzweYBR"/></div></figure><p id="1381" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后像前面一样使用窗口函数来找到具有最长连胜的玩家。</p><pre class="kh ki kj kk gt nu nv nw nx aw ny bi"><span id="6dd6" class="na mj iq nv b gy nz oa l ob oc">WITH res_str AS (<br/>    SELECT<br/>        player_id<br/>        , unnest(string_to_array(string_agg(match_result, '' ORDER BY match_date), 'L')) as win_streak<br/>    FROM players_results<br/>    GROUP BY 1<br/>), ranked_streaks AS (<br/>    SELECT <br/>        player_id<br/>        , MAX(length(win_streak)) as max_streak<br/>        , RANK() OVER (ORDER BY MAX(length(win_streak)) DESC) as rnk<br/>    FROM res_str<br/>    GROUP BY 1<br/>)<br/>SELECT<br/>    player_id<br/>    , max_streak<br/>FROM ranked_streaks<br/>WHERE rnk = 1<br/>;</span></pre><h1 id="479f" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">结论</h1><p id="af4a" class="pw-post-body-paragraph kx ky iq kz b la nm jr lc ld nn ju lf lg no li lj lk np lm ln lo nq lq lr ls ij bi translated">在本文中，我们研究了SQL中聚合的各种应用。我们从聚合整个数据集开始，然后使用GROUP BY子句将聚合应用到子组，最后在窗口函数中完成聚合。我们还看了一个文本聚合的例子。随着数据量每天成倍增长，数据分析师和数据科学家掌握聚合函数至关重要。就像生活中的其他技能一样，掌握这些技能需要练习、耐心和坚持。</p></div></div>    
</body>
</html>