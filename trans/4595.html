<html>
<head>
<title>Algorithms Explained #5: Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释#5:动态编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-explained-5-dynamic-programming-e5472a4ce464#2022-10-12">https://towardsdatascience.com/algorithms-explained-5-dynamic-programming-e5472a4ce464#2022-10-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f03a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python中离散背包和最长公共子序列问题的示例解决方案解释动态编程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b1a96a2d28faced06d726c643f84e7a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViwROS0UxzniD5BO7ET8sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/mohamed_hassan-5229782/" rel="noopener ugc nofollow" target="_blank">穆罕默德·哈桑</a>来自<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="4cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态规划对于解决具有重叠子问题和最优子结构的问题是有用的。在上一篇关于贪婪算法的文章中，我们谈到了贪婪的选择或者在每个决策点选择最佳的下一个选择有时会产生局部最优的选择。在这些情况下，我们可以使用动态规划来克服这个问题，更有效地解决这些优化问题。</p><p id="d046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态规划对于表现出以下两个特征的问题是有效的:</p><ol class=""><li id="c011" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="me">最优子结构:</em>组合子问题的最优解，产生全局最优解。</li><li id="51bc" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">重叠问题</em>:多次求解同一个子问题可以找到最优解。</li></ol><p id="f92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，动态规划是一种适用于问题的优化方法，通过将其分解为更小的子问题，找到这些子问题的最优解，并将最优解组合以产生全局最优解，可以最优地解决这些问题。为了提高算法的效率，通常使用<strong class="lb iu">记忆</strong>来重用和跟踪已经在一些数据结构中评估过的先前项目。</p><p id="9adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用动态规划解决问题的步骤包括:I)定义子问题，ii)寻找递归，iii)求解基本案例。在接下来的几节中，我们将介绍一些可以用动态编程解决的例子。</p><p id="b312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将介绍两个优化问题，以及如何使用Python中的动态编程来解决它们。</p><h2 id="f393" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">离散背包问题</h2><p id="1ab2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">在上一篇关于贪婪算法的文章中，我们使用贪婪算法实现了分数背包问题的解决方案。然而，对于离散背包问题，贪婪算法并不总是导致使用贪婪算法的全局最优解，因为项目是不可分的。相反，我们将探索如何使用动态规划来解决离散背包问题。</p><p id="ffca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提醒一下，背包问题的前提是一个窃贼正在抢劫一家有n件物品的商店，每件物品的价值是美元，重量是磅。窃贼想最大化被盗物品的价值，但他/她的背包只能装最大重量的物品，他/她应该带什么物品？</p><p id="8638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把这个问题分解成:</p><ol class=""><li id="8970" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="me">子问题:</em>构造一个矩阵M来跟踪结果，并通过用重量限制为j的物品<em class="me"> i[0…i] </em>填充背包来定义M[i，j]为最大值</li><li id="9aac" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">递归:</em>递归可以分为以下两种情况之一:I)如果第I个项目的权重<em class="me"> w[i] </em>在第j个单元格小于或等于我们背包的剩余容量，那么我们可以选择添加第I个项目；ii)如果在第j个单元格中<em class="me"> w[i] </em>的重量超过了背包的剩余容量，那么我们不添加它，重量保持不变。</li><li id="81b7" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">基本情况:</em>初始化<em class="me"> M[i，0] </em>和<em class="me"> M[0，j] </em>为0，因为背包将从权重0开始。</li></ol><p id="a11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">离散背包问题的动态规划解的时间复杂度是O(nW)，其中<em class="me"> n </em>是物品的数量，而<em class="me"> W </em>是背包的容量或重量限制。这是因为我们首先遍历物品的数量，然后遍历背包中允许的总重量，以找到这个问题的最优解。以下是离散背包问题的动态编程解决方案的Python实现:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="38d6" class="mk ml it nj b gy nn no l np nq">def fill_knapsack_discrete(W, values, weights):<br/>   """Function to find maximum value to fill knapsack <br/>      whereby items are not divisible.<br/> <br/>   Parameters:<br/>      W (int): maximum weight of knapsack.<br/>      values (list): list of item values.<br/>      weights (list): list of item weights.<br/> <br/>   Returns: <br/>   int: value of filled knapsack.<br/>   """<br/>   # Initialize matrix<br/>   num_items = len(values)<br/>   M = [[None] * (W + 1) for i in range(num_items + 1)]</span><span id="bf37" class="mk ml it nj b gy nr no l np nq">  for i in range(num_items + 1):<br/>     for j in range(W + 1):<br/>        # Base case<br/>        if i == 0 or j == 0:<br/>           M[i][j] = 0<br/>        # Recurrence if weight of item is less than or <br/>        # equal to the remaining capacity of knapsack<br/>        elif weights[i - 1] &lt;= j:<br/>           M[i][j] = max(<br/>              values[i - 1] + M[i - 1][j - weights[i - 1]], <br/>              M[i - 1][j]<br/>           )<br/>        # Recurrence if weight of item is more than <br/>        # remaining capacity of knapsack<br/>        else:<br/>           M[i][j] = M[i - 1][j]</span><span id="7233" class="mk ml it nj b gy nr no l np nq">   return M[num_items][W]</span></pre><h2 id="5f71" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">最长公共子序列(LCS)问题</h2><p id="9418" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">这个问题如下:给定两个字符串<em class="me"> a </em>和<em class="me"> b </em>，求两个字符串中存在的最长公共子序列(LCS)的长度。请注意，子序列是以相同的相对顺序出现的序列，但它可能不连续。</p><p id="1c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以将问题分解为:</p><ol class=""><li id="ed4c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><em class="me">子问题:</em>构造一个矩阵L来跟踪结果，并将<em class="me"> L[i，j] </em>定义为<em class="me"> a[0…i] </em>和<em class="me"> b[0…j]的最长公共子序列的长度。</em></li><li id="7f95" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">递归:</em>我们可以把递归分成以下两种情况之一:I)如果<em class="me"> a[i] </em>等于<em class="me"> b[j] </em>，那么它们都对LCS有贡献，我们可以把结果加1，所以<em class="me"> L[i，j] = L[i-1，j-1]+1；</em> ii)如果<em class="me"> a[i] </em>不等于<em class="me"> b[j] </em>，那么没有匹配，可以丢弃一个所以<em class="me"> L[i，j] = max(L[i-1，j]，L[i，j-1])。</em></li><li id="3a88" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><em class="me">基本情况:</em>初始化<em class="me"> L[i，0] </em>和<em class="me"> L[0 j] </em>为0。</li></ol><p id="909b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的动态编程解决方案的时间复杂度是O(nm)，因为我们首先遍历长度为<em class="me"> n </em>的第一个字符串<em class="me"> a </em>，然后遍历长度为<em class="me"> m </em>的第二个字符串<em class="me"> b </em>。下面是Python中的实现:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0f31" class="mk ml it nj b gy nn no l np nq">def find_lcs(a, b):<br/>   # Find length of strings<br/>   len_a = len(a)<br/>   len_b = len(b)</span><span id="268e" class="mk ml it nj b gy nr no l np nq">   # Initialize matrix<br/>   L = [[None] * (len_b + 1) for i in range(len_a + 1)]</span><span id="d305" class="mk ml it nj b gy nr no l np nq">   # Loop through strings and record the length of LCS at<br/>   # each a[0...i] and b[0...j]<br/>   for i in range(len_a + 1):<br/>      for j in range(len_b + 1):<br/>         # Base case<br/>         if i == 0 or j == 0:<br/>            L[i][j] = 0<br/>         # Recurrence if characters match<br/>         elif a[i - 1] == b[j - 1]:<br/>            L[i][j] = L[i - 1][j - 1] + 1<br/>         # Recurrence if characters do not match<br/>         else:<br/>            L[i][j] = max(L[i - 1][j], L[i][j - 1])</span><span id="f27b" class="mk ml it nj b gy nr no l np nq">   return L[len_a][len_b]</span></pre><h2 id="3308" class="mk ml it bd mm mn mo dn mp mq mr dp ms li mt mu mv lm mw mx my lq mz na nb nc bi translated">结论</h2><p id="645e" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">动态规划是解决最优化问题的一个非常有用的工具。实现动态规划算法的步骤包括将问题分解成子问题，识别其重现和基本情况以及如何解决它们。</p><p id="2e75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多请看本算法讲解系列:<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>(本期文章)<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>。</p></div></div>    
</body>
</html>