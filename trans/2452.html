<html>
<head>
<title>A Primer On PySpark Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PySpark窗口函数入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-dive-into-pyspark-window-functions-a090aee4ff23#2022-05-27">https://towardsdatascience.com/a-dive-into-pyspark-window-functions-a090aee4ff23#2022-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a920" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">许多有待发现的能力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5d4ade92771dd440c9371fc333a2483d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6bqfunoPxgd5D9s4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">皮特·赖特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3577" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在早先的<a class="ae kv" href="https://medium.com/p/a60bcb28cc3b" rel="noopener">文章</a>中，我提供了PySpark窗口函数的快速介绍。这篇早期文章的目的是说明与不太熟悉窗口函数的数据分析师通常使用的复杂变通方法相比，使用窗口函数的好处。本文的目的是更深入一点，说明PySpark窗口函数提供的各种可能性。同样，我们在整个示例中使用合成数据集。这使得喜欢边阅读边练习的感兴趣的读者可以很容易地进行实验。本文中包含的代码是使用Spark 3.2.1测试的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="e921" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">导入并启动数据集</strong></p><p id="efde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从必要的进口开始</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4897" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们创建一个包含三家虚构公司销售额的合成数据集。为了方便起见，数据集是使用pandas、numpy和scipy创建的，这些工具通常可供所有使用Python的数据从业者使用。考虑到更大的尺寸，起始数据帧可以专门在PySpark中构建。然而，本文的目的是说明窗口函数的可能性，而不是将计算扩大到熊猫友好的大小之外。</p><p id="e5df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">起始数据框包含三家公司在大约2.5年期间的每日销售数据。生成宽格式数据帧的代码是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="948c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据框可通过以下方式显示</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6d26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">产生了</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/319fcef6c09551208876a14345f7cc79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*9Izc7qz8qO54OP24OEEn6g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:开始数据集</p></figure><p id="3773" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何构建起始数据帧的细节并不重要。对于感兴趣的读者，我们创建了两个短列表，分别是x点和y点，第二个列表被随机排列，以产生三家公司的不同曲线。我们在x点之间使用了scipy中实现的样条插值，并使用numpy添加了一些噪声。为了再现性，我们通过指定种子构建了一个随机数生成器。其中一列是有意为日期类型的，因为时间序列是窗口函数显示的数据类型。剩下的唯一一件事就是使用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="00c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方便的是，PySpark数据帧具有所需的模式，无需显式指定模式。</p><p id="670b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的四个部分是聚合、排序和分析PySpark窗口函数的例子。有了这个，我们就可以出发了！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="34f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">聚合窗口函数</strong></p><p id="1e0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">集合窗口函数通常处理整个窗口。如果目的是处理整个窗口，则不需要在窗口内排序，这是最典型的用例。例如，让我们计算公司1每季度销售额最大的日期</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="f169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确认一切正常，我们绘制了结果图</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="76b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">产生了</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/887278cb021422fb178c5ecfab4438a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Id_sFULWuc_dXcRMqVqCKQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图2:公司1的季度最高销售额</p></figure><p id="3483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">红点表示最大销售额，垂直虚线表示季度界限。我们可以看到，window函数正确地计算出了公司1在每个季度销售额最高的日期。通过设置轴限制，图表已被放大，这样我们可以更容易地检查结果。在Spark和pandas数据框之间来回切换在实践中通常不会发生，但是在本教程中，如果所使用的数据框完全在pandas的能力范围内，那么这对于绘制需求是很方便的。</p><p id="e20e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个烦恼是，上面的计算只涉及公司1。还有两家公司，实际上我们可能有更多公司的更多列。我们可以创建一个循环，或者(更好地)我们可以用长格式而不是宽格式创建起始数据帧。解除Spark数据帧的透视也是可能的，尽管这需要更多的努力</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="cf34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其工作方式是创建一个包含结构数组的列(PySpark中的“dictionary”包含公司名称和销售额)，分解数组以创建多行，然后从结构中提取我们需要的列。这有点复杂，但是对于本文的目的来说，细节并不重要。重要的是数据框现在有一行是每个公司和日期的销售数据。</p><p id="c805" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，可以一次计算出所有公司每季度最高销售额的日期</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="3642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公司1的结果与之前相同。</p><p id="3d49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用的聚合函数有min、max、count、sum等。原则上，我们可以使用一些记录而不是整个窗口，如下所示。这在聚合窗口函数中并不常见，除非我们需要运行求和。例如，如果我们想计算每个公司和季度到给定日期的最大销售额，我们可以使用</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="2e2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，每当遇到更高的销售额时，就会出现新的一行，直到我们到达下一个季度，然后我们再次开始。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="9861" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">排名窗口功能</strong></p><p id="5bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">排序窗口函数很容易概念化。如果不对窗口中的行进行排序，排序函数就没有意义，所以我们需要引入更多的语法。我们将使用一个较小的数据集，特别是在删除一些列后，公司1每个季度销售额最高的数据集(名为res_company1)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a91d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们希望对每年的季度进行排名，我们可以使用以下内容</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="967b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认的排序是升序，所以并不严格要求显式地指定它，但是它使代码更清晰。函数<code class="fe mc md me mf b">F.rank()</code>不接受任何参数，并在出现平局时产生非连续整数。如果不希望这样，可以使用<code class="fe mc md me mf b">F.dense_rank()</code>。还有更多排名功能，如<a class="ae kv" href="https://spark.apache.org/docs/latest/api/python/reference/pyspark.sql.html" rel="noopener ugc nofollow" target="_blank">文档</a>中描述的<code class="fe mc md me mf b">F.percent_rank()</code>、<code class="fe mc md me mf b">F.ntile()</code>、<code class="fe mc md me mf b">F.row_number()</code>等。还有一个<a class="ae kv" href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.sql.functions.cume_dist.html" rel="noopener ugc nofollow" target="_blank">函数</a> <code class="fe mc md me mf b">F.cume_dist()</code>与<code class="fe mc md me mf b">F.percent_rank()</code>相关，它返回累积密度函数而不是百分比排名，因此严格来说它不是排名函数，而是统计函数，但这主要是语义上的，除非你是面向统计的。如果您有兴趣，可以用一个小的数据框进行实验，并比较这两个函数。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="4d4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">分析窗口功能</strong></p><p id="48dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一组窗口函数允许查看感兴趣的记录。典型地，这种函数与时间序列一起使用，例如，将记录与最近的记录进行比较。</p><p id="d82c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为第一个例子，我们将计算公司1的销售额与前一个日期相比增长最多的日期。用例并不表示需要在变量上创建窗口，因此整个数据框将是唯一的窗口。这是通过不带任何参数调用<code class="fe mc md me mf b">Window.partitionBy()</code>函数来实现的。尽管如此，我们还是要避免这种情况，因为它会将所有数据移动到同一个分区，从性能的角度来看这是不明智的(尽管我们在本教程中的数据帧太小了，不值得担心)。相反，我们将按年进行分区，这仅意味着第n+1年1月1日的记录不能与第n年12月31日的记录进行比较，因为窗口中没有以前的记录。对于我们的例子来说，这不是一个大问题</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子的有趣之处在于，我们在另一个窗口函数中使用了一个窗口函数的结果。你想知道为什么我们创造了另一个窗口吗？我们不能用之前的吗？答案是否定的，原因是排序意味着我们不会使用整个窗口，而只会使用给定记录之前的部分窗口。这是违反直觉的，因为排序通常不会影响计算的范围，但在这种情况下它会影响！我们稍后将回到这一点。</p><p id="8439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与排序窗口函数相比，<code class="fe mc md me mf b">F.lag()</code>函数可以在与排序列不同的列上操作。对于<code class="fe mc md me mf b">F.lead()</code>函数来说也是如此，它向前看而不是向后看。两个函数都使用参数<code class="fe mc md me mf b">n</code>来控制我们向前或向后移动多少记录，使用参数<code class="fe mc md me mf b">default</code>来替换接近窗口边界时的空值。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="cbb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">从窗户到窗框</strong></p><p id="f017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文章开头的图像显示了一个由几个窗口框架组成的窗口。选择该图像与PySpark窗口函数进行类比。我们不需要在计算中使用整个窗口，实际上我们可能只需要使用它的一部分。在本文前面计算每个公司和每个季度的最大销售额时，我们第一次看到了这一点。在PySpark窗口语言中，我们在运行最大值示例中使用的窗口框架是增长的。它从窗口开始(<code class="fe mc md me mf b">unboundedPreceding</code>)开始，覆盖订单变量的整个范围，直到当前记录(<code class="fe mc md me mf b">currentRow</code>)。现在，我们将概括窗口框架的概念，以涵盖所有窗口框架的大小和类型。</p><p id="68e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想使用10天或3天的静态窗口和年度窗口来计算公司1每年的运行平均销售额，会怎么样？为了实现这一点，我们将依赖于Unix纪元时间，因为该时间用可在范围中使用的数值表示(pandas在日期范围方面提供了更多功能，但不适合大数据分析；我们不能拥有一切！).Unix纪元时间以秒表示，因此我们的3天窗口对应于24*3600*3 = 259 200秒的范围，而10天窗口对应于864 000秒的范围。为了便于比较，我们还将计算每年销售的移动平均值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e7aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们把结果想象成</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e9c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们获得</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/080c26a2812ba3ce751186c65cef3f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Ul4AMZBOy9q-D1rHo94czA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图3: 3天、10天和运行平均值</p></figure><p id="31e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你对如何在像<a class="ae kv" href="https://www.worldometers.info/coronavirus/" rel="noopener ugc nofollow" target="_blank">这种</a>带有新冠肺炎更新的页面中计算运行平均值感到好奇，现在你知道了！除了<code class="fe mc md me mf b">.rangeBetween()</code>之外，我们也可以使用<code class="fe mc md me mf b">.rowsBetween()</code>，但是我们把它作为一个练习。</p><p id="6e62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最终想法</strong></p><p id="5b2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PySpark中的窗口函数可以成为数据分析和特征工程不可或缺的工具。有一个学习曲线，但是一旦掌握了窗口函数，就可以避免难以维护且效率可能较低的变通代码技巧。当你处理一个新问题时，你可以首先考虑目的是汇总、排序还是向前/向后看。其次，你可以考虑你的窗口是否应该全部被使用(无界的)或者你只需要它的一个框架(有界的)，在这种情况下，排序几乎肯定也是需要的。回答完这些问题后，使用这篇文章和PySpark <a class="ae kv" href="https://spark.apache.org/docs/latest/api/python/" rel="noopener ugc nofollow" target="_blank">文档</a>应该可以让你开始了！</p></div></div>    
</body>
</html>