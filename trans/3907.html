<html>
<head>
<title>How GANs learn creativity — Understanding the optimization function of Generative Adversarial Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GANs如何学习创造力——理解生成性对抗网络的优化功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-gans-learn-creativity-478fc1e4cc79#2022-08-30">https://towardsdatascience.com/how-gans-learn-creativity-478fc1e4cc79#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a2fe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释流行的GAN min-max游戏和模型的总损失</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c8df40d292d57eaf81b77953c0c1a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_JhCYa8MbIXio67C5-tpw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Joshua Woroniecki 在<a class="ae kv" href="https://unsplash.com/s/photos/creativity?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4664" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> G </span> <strong class="ky ir">生成对抗网络</strong> (GANs)最近在人工智能领域变得非常流行，尤其是在计算机视觉领域。随着Ian J. Goodfellow等人[1]的科学文章“生成对抗网络”的介绍，一种用于开发生成模型的强大的新策略出现了，并且自那时起，许多研究和研究项目随之出现，开发了我们现在看到的新应用，例如最新的<strong class="ky ir">DALL-E 2</strong>【2】<strong class="ky ir"/>或<strong class="ky ir">GLIDE</strong>【3】(<em class="mb">这两种应用都是使用扩散模型开发的，这是生成模型的较新范式。然而，GAN今天仍然是一种广泛使用的模型，能够解决多种问题</em></p><p id="2d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但由于一切总是从头开始，在本文中，我将展示大家听说过的<strong class="ky ir">的<strong class="ky ir">原始GAN优化函数</strong>的含义和推理，以及它与模型的总损失函数</strong>的差异(您必须知道，根据模型的目的，后来还创建了许多其他变体)</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="6e37" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">目录</h1><ol class=""><li id="b76b" class="nb nc iq ky b kz nd lc ne lf nf lj ng ln nh lr ni nj nk nl bi translated"><a class="ae kv" href="#5b04" rel="noopener ugc nofollow"> <strong class="ky ir">甘简介</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#4fea" rel="noopener ugc nofollow"><strong class="ky ir">甘训练</strong> </a></li><li id="2cdd" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="#5ca5" rel="noopener ugc nofollow"> <strong class="ky ir">【最小-最大博弈】优化功能</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#7d6d" rel="noopener ugc nofollow"><strong class="ky ir">鉴别器损耗功能</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#6bb7" rel="noopener ugc nofollow"><strong class="ky ir">优化功能</strong></a><strong class="ky ir"><br/></strong><a class="ae kv" href="#ef58" rel="noopener ugc nofollow"><strong class="ky ir">发电机损耗功能</strong></a></li><li id="3f3d" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="#7284" rel="noopener ugc nofollow"> <strong class="ky ir">总损耗功能</strong> </a></li><li id="726f" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="#c007" rel="noopener ugc nofollow"> <strong class="ky ir">结论</strong> </a></li><li id="776d" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="#e3d1" rel="noopener ugc nofollow"> <strong class="ky ir">参考文献</strong> </a></li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="5b04" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">1.甘斯简介</h1><p id="9fa5" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">生成对抗网络是一类<strong class="ky ir">深度学习框架，被设计为生成模型</strong>，目的是生成新的复杂数据(输出)，如在之前<strong class="ky ir">从未存在过的图像或音频。</strong></p><p id="50fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了训练GAN，我们只需要一组我们想要复制或模仿的数据(图像、音频……)，网络将找出创建新数据的方法，这些数据看起来像我们数据集的例子。</p><blockquote class="nu"><p id="2e6f" class="nv nw iq bd nx ny nz oa ob oc od lr dk translated">换句话说，我们给模型一些例子作为输入来“获得灵感”,并给它产生新输出的完全自由</p></blockquote><p id="7b6f" class="pw-post-body-paragraph kw kx iq ky b kz oe jr lb lc of ju le lf og lh li lj oh ll lm ln oi lp lq lr ij bi translated">这种训练过程称为<strong class="ky ir">无监督学习</strong>，在这种过程中，我们只向网络提供<strong class="ky ir"> X </strong>输入，而不附带任何标签(或期望的输出)。</p><p id="c6de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GAN架构由<strong class="ky ir">两个相互竞争</strong>的网络组成(因此得名“敌对网络”)。通常我们将这些网络称为<strong class="ky ir">发生器</strong><strong class="ky ir">【G】</strong>和<strong class="ky ir">鉴别器(D) </strong>。生成器的任务是学习从<strong class="ky ir">随机噪声</strong>开始生成数据的函数，而鉴别器要决定生成的数据是否“真实”(这里“真实”是指数据属于我们数据集的例子)，这样我们就可以衡量模型的性能，调整参数。两个网络同时被训练和学习。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/2bfc033d66775c2a4f643e946ae99bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1A35o75mj9JAiHdI6gZeFw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为了说明生成器-鉴别器游戏，我们可以把伪造者想象成试图愚弄侦探或鉴别器的<strong class="bd ok">生成器</strong>(右图由<a class="ae kv" href="https://unsplash.com/@the_ahnafpiash?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ahnaf Piash </a>在<a class="ae kv" href="https://unsplash.com/s/photos/hacker?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><h2 id="4fea" class="ol mk iq bd ml om on dn mp oo op dp mt lf oq or mv lj os ot mx ln ou ov mz ow bi translated">甘培训</h2><p id="7d1b" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">GANs训练有许多不同的变化和修改。然而，如果我们遵循原始论文[1]，普通GAN训练循环如下:</p><p id="66a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为</strong>训练迭代次数<strong class="ky ir">做</strong>:</p><ol class=""><li id="e582" class="nb nc iq ky b kz la lc ld lf ox lj oy ln oz lr ni nj nk nl bi translated">从样本分布(即随机噪声<strong class="ky ir"> <em class="mb"> z </em> </strong>)中生成<em class="mb"> m </em>个样本(图像、音频……)，我们将其表示为:<strong class="ky ir"> <em class="mb"> G(z) </em> </strong></li><li id="01e7" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">从训练数据集中取<em class="mb"> m </em>个例子:<strong class="ky ir"> <em class="mb"> x </em> </strong></li><li id="5291" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">将所有示例(生成的和训练的数据集)混合，并将其馈送给鉴别器<strong class="ky ir"> <em class="mb"> D </em> </strong> <em class="mb">。</em>D的输出将在0和1之间，意味着0这个例子是假的，1这个例子是真的</li><li id="3bd2" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">测量鉴频器损耗函数并调整参数</li><li id="8a89" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">生成新的m实例<strong class="ky ir"> G'(z) </strong></li><li id="32bf" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">将<strong class="ky ir"> G'(z) </strong>送入鉴别器。测量发电机损耗函数并调整参数。</li></ol><p id="11f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结束</strong></p><blockquote class="pa pb pc"><p id="4362" class="kw kx mb ky b kz la jr lb lc ld ju le pd lg lh li pe lk ll lm pf lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>。最近的GAN训练方法测量发生器损耗，并在第4步中连同鉴别器一起调整其参数，跳过第5步和第6步，从而节省时间和计算机资源。</p></blockquote><h1 id="5ca5" class="mj mk iq bd ml mm pg mo mp mq ph ms mt jw pi jx mv jz pj ka mx kc pk kd mz na bi translated">2.最优化和损失函数(最小-最大游戏)</h1><p id="1c7f" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">如果您阅读GAN的原始论文，您将获得以下函数，该函数为模型定义了<strong class="ky ir">优化函数</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/bda84490b06165c4993c43c8845c9174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-8SSKzW5VsTuFEitLQJxg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">GAN优化功能。截图自原论文《生成性对抗性网络》[1]</p></figure><blockquote class="pa pb pc"><p id="0c83" class="kw kx mb ky b kz la jr lb lc ld ju le pd lg lh li pe lk ll lm pf lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>。上面的公式是<strong class="ky ir">优化函数</strong>，即两个网络(生成器和鉴别器)都试图优化的表达式。在这种情况下，G希望最小化它，而D的目标是最大化它。但是，<strong class="ky ir">这不是模型的总损失函数</strong>，它告诉我们它的性能。</p></blockquote><p id="ac17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解mix-max游戏，我们必须考虑用什么来衡量我们模型的性能，这样网络就可以优化它。由于GAN架构由两个同时训练的网络构成，我们必须计算两个指标:<strong class="ky ir">发电机损耗</strong>和<strong class="ky ir">鉴别器损耗</strong>。</p><h2 id="7d6d" class="ol mk iq bd ml om on dn mp oo op dp mt lf oq or mv lj os ot mx ln ou ov mz ow bi translated">鉴别器损失函数</h2><p id="4cb8" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">根据论文[1]中描述的训练循环，鉴别器从数据集接收一批<em class="mb"> m </em>个示例，从生成器接收其他<em class="mb"> m </em>个示例，并且<strong class="ky ir">输出一个数字∈ [0，1] </strong>，这是输入数据属于数据集分布的概率(即数据为“真实”的概率)。</p><p id="6ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将示例输入鉴别器之前，我们已经知道哪些示例是真实的，哪些是生成的(来自数据集的示例<strong class="ky ir"> <em class="mb"> x </em> </strong>是真实的，生成器的输出<strong class="ky ir"> <em class="mb"> G(z) </em> </strong>是生成的)，因此我们可以给它们分配一个标签:y = 0(生成的)，y = 1(真实的)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/760a671082e849a002d92745bb857fae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rcLSUzkaPaVncPRYSV2Rdg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">图1 </strong>。GAN模型的工作流程。注意:k是指鉴别器的输入，它可以是生成的图像或数据集的一个例子。作者图片</p></figure><p id="0ccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以使用<strong class="ky ir">二进制交叉熵</strong>损失函数将鉴别器训练成普通的二进制分类器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/10b6a5db96be2d3f71c99ea0e4fc171f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/0*y5sYfx8OAUl89nve.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">n = 2m时鉴别器(D)的二元交叉熵公式</strong>。yi表示标签，k表示输入(生成的和真实的输入)</p></figure><p id="a02c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，由于这是一个二进制分类器，求和交替出现:<br/> -当输入为实数时，标签<strong class="ky ir"> y = 1 </strong> →求和<strong class="ky ir"> ∑ = log(D(k)) <br/> </strong> -当输入生成时，标签<strong class="ky ir"> y = 0 </strong> →求和<strong class="ky ir"> ∑ = log(1-D(k)) </strong></p><p id="cb42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以用更简单的形式重写表达式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/bd9926327bb8a489c1ca0b9507ca5dc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdP7bJ4QA_kdehaBJa5TEg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">现在<strong class="bd ok"> xi是来自数据集</strong>的真实例子，而<strong class="bd ok"> G(z)是由生成器(G)生成的输出</strong>。因此，我们不是给函数一个单一的输入，而是同时引入两个:D(Xi)和G(z)。此外，n = m</p></figure><h2 id="6bb7" class="ol mk iq bd ml om on dn mp oo op dp mt lf oq or mv lj os ot mx ln ou ov mz ow bi translated">优化功能</h2><p id="48c3" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">我们知道，鉴频器想要最小化它的损耗，因此，它想要最小化上面的公式(<em class="mb"> argmin Dloss </em>)。然而，我们可以通过去掉负号来修改公式。现在，我们必须最大化它，而不是最小化表达式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/9cab1f6ffcbeb239e744cca8cdc4c529.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/0*bDzDDorOqmhsvF8s.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">以前，要获得Dloss = 0，我们必须将其最小化。但是现在我们改变了表达式符号，我们必须最大化它以获得- Dloss = 0</p></figure><p id="5781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以操作这些条款:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/a37de7345cd123081cde99b96ab9c47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/0*P0VNdvjg4PYQyplu.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">- Dloss的最终表达式。Ex~p(x)表示期望值</p></figure><p id="c057" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并重写表达式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/43d411736a9fedbfa690a0b683f509ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9rLq6i9noqQxjd-H.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">鉴别器优化功能</strong></p></figure><p id="253a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，生成器的目标是伪造鉴别器。然后，发生器必须执行与鉴别器相反的操作，并且<strong class="ky ir">找到V(G，D) </strong>的最小值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/b66a450e3e69a8d7d09b6d53db465213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LJyyVfbqzO6ex527.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">发电机优化功能</strong></p></figure><p id="3678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以将两个表达式(鉴别器和生成器优化函数)相加，并获得最后一个表达式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/33a98682cc65a7beb60f33434681ce03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NCuoJw18OJOPXsjDO4gagg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">最小最大游戏</strong></p></figure><p id="2d18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(<em class="mb"> Tadaa！</em>)我们终于得到了优化函数。然而，正如我之前说过的，这不是总损失函数，它告诉我们模型的整体性能。但在此之前，我们需要首先计算发电机损耗:</p><h2 id="ef58" class="ol mk iq bd ml om on dn mp oo op dp mt lf oq or mv lj os ot mx ln ou ov mz ow bi translated">发电机损耗函数</h2><p id="3425" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">再回头看优化函数，我们看到生成器只参与表达式<em class="mb">E(log(1-D(G(z)))】</em>的第二项，而第一项保持不变。因此，试图最小化的发电机损耗函数为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/cfd49940d09eb591b625779b05f3105b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b8Z65bBnf6Zi16Vghjzg9A.png"/></div></div></figure><p id="a873" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们还没有完成。正如原论文<strong class="ky ir"> <em class="mb">中所解释的，“在学习的早期，当G很差的时候，D可以以很高的置信度拒绝样本，因为它们与训练数据明显不同。”</em> </strong> <em class="mb"> </em>即<em class="mb"> </em>在训练的初期，鉴别器很容易区分真实图像和生成的图像，因为生成器还没有学会。这种情况下，log(1D(G(z))会饱和，因为D(G(z))∞0</p><p id="228c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免这种情况，研究人员提出如下:<strong class="ky ir"> <em class="mb">“与其训练G使log(1d(G(z))最小化，我们可以训练G使log D(G(z))最大化”</em> </strong> <em class="mb">。<br/> </em>这就等于说，不是训练生成器最小化图像是假的概率，而是要最大化图像是真的概率。</p><p id="7b52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从本质上讲，两种<em class="mb"> </em>优化方法是相同的，正如我们在图表中看到的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/603754943621c925ddc875bc7c11183a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XadTxETa2uoJ9Luio_5FPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在[0，1]范围内最小化log(1-x)与最大化log(x)是一样的。作者图片</p></figure><p id="d4a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，出于我们的目的，我们将使用的发电机损耗函数为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/459aafe8f95c2cb8b955609357fffcf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKZIG40BAszqMBa-MkSqPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">非饱和发电机损耗功能</strong>。重要的是要记住，现在<strong class="bd ok"> G想要最大化这个函数</strong></p></figure><blockquote class="pa pb pc"><p id="ed31" class="kw kx mb ky b kz la jr lb lc ld ju le pd lg lh li pe lk ll lm pf lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>。实际中，在对发电机损耗函数进行编码时，<strong class="ky ir">通常使用上述公式的负形式</strong>，这样，目标不是使函数最大化，而是使其最小化。从而便于用诸如Tensorflow之类的库来调整参数。这对于理解下一节的<strong class="ky ir">总损耗函数</strong>也很重要。</p></blockquote><h1 id="7284" class="mj mk iq bd ml mm pg mo mp mq ph ms mt jw pi jx mv jz pj ka mx kc pk kd mz na bi translated">3.总损失函数</h1><p id="99c0" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">文中给出了各部件(发生器和鉴别器)的损耗公式，以及模型的优化功能。但是，<strong class="ky ir">我们如何衡量</strong>型号的整体性能呢？</p><p id="eef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只看优化函数并不是一个好的衡量标准，因为正如我们已经看到的，优化函数是鉴频器损耗函数的修改，因此它并不反映发电机的性能(尽管发电机损耗函数是从它派生出来的，但我们只是在该函数中考虑了鉴频器的性能)</p><p id="6d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，可以考虑增加两个损失函数(鉴别器和发生器),虽然这是一个很好的直觉，但我们需要考虑一些细微差别:</p><p id="8ef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。两个损失函数都必须以最小化或最大化为目标</strong>。</p><p id="c6d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，相加将反映比应该的误差更高或更低的误差。<br/>举个例子，让我们来看看想要通过D最大化的优化函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/95609a2af06bb6ac11be84b163342a32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/0*npHpOtyH4hnGCrWG.png"/></div></div></figure><p id="2fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和旨在通过G最小化的第一发电机损耗函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/371ec816f1518a38e0a6419ecdcebda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*V5__Fxw-Z0UwkBtb.png"/></div></figure><p id="a5c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当D做得很差(低误差)而G做得很好(低误差)时，整体性能将产生低误差，这意味着两个网络(G和D)都做得很好，尽管我们知道其中一个不是。<br/>此外，如果一个损失的目标是最小化，另一个是最大化，我们就不知道高误差是好是坏。</p><blockquote class="pa pb pc"><p id="80ac" class="kw kx mb ky b kz la jr lb lc ld ju le pd lg lh li pe lk ll lm pf lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>。如果我们使用以最大化为目标的损失函数，称之为“误差”可能听起来违反直觉，因为“误差”越高，性能越好。然而，我们也可以使用对数标度来转换它，例如log(1+“误差”)</p></blockquote><p id="7ff6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。为了建立总损失函数，单个损失必须在相同的数值范围内</strong></p><p id="f753" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们以我们讨论的第一个鉴别器损耗(二元交叉熵)为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi px"><img src="../Images/808faf9a5d3e9d3e98badae49447f32a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*dfc6s8TrtfCbD_Cd.png"/></div></figure><p id="07c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以及在最后一点中使用的先前的发电机损耗函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/371ec816f1518a38e0a6419ecdcebda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*V5__Fxw-Z0UwkBtb.png"/></div></figure><p id="7307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在两个函数都满足目标最小化的条件。然而，鉴频器损耗在[0，+∞]范围内，而发电机损耗输出值在(-∞，0)范围内。将这两个函数相加等同于减去发生器损耗，因此我们说总损耗是没有发生器影响的鉴频器损耗(即E(log(D(xi))，其中E表示期望值)，这是不正确的。</p><p id="98a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，我们还有另一个加法组合。<strong class="ky ir">如果我们加上第一个鉴频器损耗和修正发电机损耗的负形式会怎么样？</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/87e637d230a42fc1ab279f70183e94b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*heCs1yY3vyQE0j00Kyfxvw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd ok">GAN模型的总损失函数</strong>。这个函数告诉我们模型的整体性能</p></figure><p id="1a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(<em class="mb">万岁！</em>)这是GAN总损耗函数。然而，万一你不相信我，让我们检查它是否满足性质。</p><p id="ce75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">✅ 1.我们知道，Dloss旨在最小化，负形式的修正发电机损耗也旨在最小化。</p><p id="a5fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">✅ 2.Dloss输出范围[0，+∞)内的值，结果是负的修正发电机损耗也将值映射到相同的范围内。</p><p id="ac0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们增加了相同类别的误差，并因此计算了我们模型的总损失函数。</p><h1 id="c007" class="mj mk iq bd ml mm pg mo mp mq ph ms mt jw pi jx mv jz pj ka mx kc pk kd mz na bi translated">4.结论</h1><p id="bd76" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">总结本文的主要要点:</p><ol class=""><li id="f57e" class="nb nc iq ky b kz la lc ld lf ox lj oy ln oz lr ni nj nk nl bi translated">甘优化函数(也叫极小极大博弈)和模型的总损失是不同的概念:<br/> <strong class="ky ir">极小极大优化≠总损失</strong></li><li id="d2d8" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">优化函数的来源来自于<strong class="ky ir">二进制交叉熵</strong>(其反过来是鉴别器损耗)，并且还从其导出发电机损耗函数。</li><li id="d384" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">发电机损耗函数在实践中被修改，使得对数不饱和。并且这种修改对于计算模型的总损失函数也是有用的。</li><li id="440f" class="nb nc iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><strong class="ky ir">总损失函数= Dloss +光泽度</strong>。然而，并不是所有的公式都可以使用，我们需要考虑两个关键点:<br/> -两个单独的损失函数都必须以最小化或最大化为目标。<br/> -各项损失必须在相同的数值范围内</li></ol><p id="6766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章，它对你有所帮助。请不吝赐教。欢迎任何反馈或更正</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="e3d1" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">5.参考</h1><p id="7945" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated"><strong class="ky ir"/><a class="ae kv" href="https://arxiv.org/abs/1406.2661" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mb">生成性对抗性网络</em> </strong> </a>。伊恩·古德菲勒等人，2014年</p><p id="b548" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">【2】</strong><a class="ae kv" href="https://cdn.openai.com/papers/dall-e-2.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mb">层次文本——有条件的图像生成带剪辑潜影</em> (DALL-E 2纸)</strong> </a>。OpenAI 2022</p><p id="0535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">【3】</strong><a class="ae kv" href="https://arxiv.org/pdf/2112.10741.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">GLIDE:利用文本引导的扩散模型实现真实感图像生成和编辑</strong> </a>。</p></div></div>    
</body>
</html>