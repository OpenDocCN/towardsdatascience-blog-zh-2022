<html>
<head>
<title>How to Structure Your dbt Projects and Data Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建您的dbt项目和数据模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dbt-models-structure-c31c8977b5fc#2022-11-09">https://towardsdatascience.com/dbt-models-structure-c31c8977b5fc#2022-11-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="df5f" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">对dbt数据模型实施有意义的结构</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/658d061a20cad10b300c36e04e6b5865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhAwZR9hPYSKZrxLHNmRAQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">阿兰·范在<a class="ae kz" href="https://unsplash.com/s/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="76b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数据模型是表示应用程序域中特定对象的抽象结构。这种模型可以是特定组织的用户、产品和订单。在现代组织中，应该制定数据驱动的决策，因此能够高效和有效地管理数据模型非常重要。</p><p id="2178" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着公司收集和处理的数据量不断增长，需要维护数百甚至数千个数据模型。这意味着，考虑到一些模型可能是其他数据模型的上游或下游依赖关系，也需要管理它们的相互依赖关系。</p><p id="8410" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在蓬勃发展的数据行业中，大量的工具可供数据专业人员和团队使用。数据构建工具(dbt)是由Fishtown Analytics开发的开源工具，无疑是最强大的工具之一，我强烈推荐给每个团队，如果他们对现代组织中可扩展的有效数据管理感兴趣的话。<strong class="lc iv"> dbt可以帮助数据团队创建数据集和模型，作为分析、报告、机器学习建模和一般数据工作流的一部分</strong>。</p><blockquote class="lw"><p id="c09a" class="lx ly iu bd lz ma mb mc md me mf lv dk translated">dbt是一个开发框架，它将模块化SQL与软件工程最佳实践结合起来，使数据转换变得可靠、快速和有趣。- dbt <a class="ae kz" href="https://www.getdbt.com/analytics-engineering/transformation/" rel="noopener ugc nofollow" target="_blank">文档</a></p></blockquote><p id="8726" class="pw-post-body-paragraph la lb iu lc b ld mg jv lf lg mh jy li lj mi ll lm ln mj lp lq lr mk lt lu lv in bi translated">除了在工作中使用正确的工具，同样重要的是确保你也以正确的方式使用它们。在我最近的一篇文章中，我们讨论了关于<a class="ae kz" rel="noopener" target="_blank" href="/install-dbt-1bd6a4259a14">如何安装dbt命令行接口以及您需要访问</a>的特定数据平台所需的适配器。</p><p id="60ee" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在今天的文章中，我们将讨论如何在dbt项目中正确构建数据模型。数据通常是组织中混乱的资产，因此尽可能加强结构总是很重要的。在接下来的几节中，我们将讨论三种类型的数据模型——在dbt的上下文中——以及如何以一种有意义且可伸缩的方式构建它们，这将允许数据团队的团队成员保持一致。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h2 id="9f08" class="ms mt iu bd mu mv mw dn mx my mz dp na lj nb nc nd ln ne nf ng lr nh ni nj nk bi translated">分期、中间和集市模型</h2><p id="79ca" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">数据模型各不相同——我的意思是，一些数据模型可能对应于一些特定的数据源，另一些可能将多个数据源甚至其他数据模型组合在一起，等等。因此，创建数据模型的<strong class="lc iv">层非常重要。</strong>拟分层由三类模型组成，即<strong class="lc iv">分期</strong>模型、<strong class="lc iv">中间</strong>模型和<strong class="lc iv">集市</strong>模型。</p><p id="2231" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">阶段模型</strong>，是您的dbt项目中所有数据模型的构建块。分期模型应该包括<strong class="lc iv">基本计算</strong>(如字节到千兆字节)<strong class="lc iv">重命名</strong>、<strong class="lc iv">类型转换</strong>和<strong class="lc iv">分类</strong>(使用<code class="fe nq nr ns nt b">CASE WHEN</code>语句)。然而，您应该<strong class="lc iv">避免在分段模型上执行任何连接和聚合</strong>。作为一般的经验法则，你应该在你的数据源和阶段模型之间有1-1的映射。因为阶段模型不应该代表最终的工件，所以建议<strong class="lc iv">将它们具体化为视图</strong>。</p><p id="7bb1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">中间模型</strong>，被认为是将阶段模型甚至其他中间模型集合在一起，它们往往比阶段模型更复杂一些。换句话说，这些模型代表了更有意义的构建模块，将来自多个模型的信息集合在一起。但是请注意，它们不应该向最终用户公开(即由BI工具使用，如Tableau、PowerBI或Looker)。同样重要的是要提到，作为一个经验法则，如果一个中间模型在几个地方被引用，那么你可能不得不考虑构建一个宏，或者重新考虑你设计模型的方式。</p><p id="5e8d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">集市模型</strong>，是商业定义的实体，应该由终端用户和商业智能工具消费。每个集市模型都代表一个细粒度的实体——支付、客户、用户、订单只是我们作为集市所代表的一些例子。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h2 id="060e" class="ms mt iu bd mu mv mw dn mx my mz dp na lj nb nc nd ln ne nf ng lr nh ni nj nk bi translated">构建您的dbt模型</h2><p id="fdd2" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">既然我们已经对数据构建环境中的三种主要模型类型有了坚实的理解，那么让我们开始讨论如何以一种有意义的方式构建这些模型，以帮助数据团队以一种简单直观的方式维护和扩展它们。</p><p id="f9a3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在您的dbt项目中，您需要有一个名为<code class="fe nq nr ns nt b">models</code>的父目录，由三个目录组成，每个目录代表我们前面讨论的一个模型类型:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="df32" class="ms mt iu nt b gz ny nz l oa ob">models<br/>|---intermediate<br/>|---marts<br/>|---staging</span></pre><p id="b895" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们从<strong class="lc iv">分期模型</strong>开始。</p><ul class=""><li id="83af" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">对于每个不同的源，您需要在<code class="fe nq nr ns nt b">staging</code>目录下创建一个子目录</li><li id="1e71" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">每一个模型，都必须遵循<code class="fe nq nr ns nt b">stg_[source]__[entity]s.sql</code>符号</li><li id="0e4e" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">模型目录下的一个<code class="fe nq nr ns nt b">base</code>子目录，以防您需要将登台模型连接在一起</li></ul><p id="ac57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">举个例子，假设我们有三个独立的来源——一个是脸书广告(营销活动),另一个来自Stripe(支付),第三个包含我们的在线商店的商业实体。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="430e" class="ms mt iu nt b gz ny nz l oa ob">models/staging<br/>|---facebook_ads<br/>|   |---_facebook_ads__models.yml<br/>|   |---_facebook_ads__sources.yml<br/>|   |---_facebook_ads__events.yml<br/>|---my_shop<br/>|   |---_my_shop__models.yml<br/>|   |---_my_shop__sources.yml<br/>|   |---base<br/>|   |  |---base_my_shop__deleted_products.sql<br/>|   |  |---base_my_shop__deleted_users.sql<br/>|   |  |---base_my_shop__products.sql<br/>|   |  |---base_my_shop__users.sql<br/>|   |---stg_my_shop__orders.sql<br/>|   |---stg_my_shop__products.sql<br/>|   |---stg_my_shop__users.sql<br/>|---stripe<br/>    |---_stripe_models.yml<br/>    |---_stripe_models.yml<br/>    |---stg_stripe__payments.yml</span></pre><p id="62d0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意我们是如何为每个不同的源创建一个单独的子目录的，每个子目录都由两个yml文件组成——一个用于定义模型，另一个用于源——以及您为每个源拥有的尽可能多的登台模型。</p><p id="5e42" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们继续讨论<strong class="lc iv">中级车型</strong>。</p><ul class=""><li id="dae0" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">对于每个不同的业务组，我们创建一个子目录——非常类似于我们前面介绍的分级结构</li><li id="f22f" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">每一款中级车型，都必须遵循<code class="fe nq nr ns nt b">int_[entity]s_[verb]s.sql</code>的命名惯例。请注意，使用动词作为命名的一部分将有助于您构建名称，这有助于读者和维护人员清楚地了解特定模型应该做什么。这样的动词有<code class="fe nq nr ns nt b">joined</code>、<code class="fe nq nr ns nt b">aggregated</code>、<code class="fe nq nr ns nt b">summed</code>等。</li></ul><p id="81a0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，假设我们有两个业务组，即<code class="fe nq nr ns nt b">finance</code>和<code class="fe nq nr ns nt b">marketing</code>:</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="8154" class="ms mt iu nt b gz ny nz l oa ob">models/intermediate<br/>|---finance<br/>|   |---_int_finance__models.yml<br/>|   |---int_payments_pivoted_to_orders.sql<br/>|---marketing<br/>|   |---_int_marketing__models.yml<br/>|   |---int_events_aggregated_per_user_platform.sql</span></pre><p id="4731" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，让我们看看如何构建我们的最终构件，即对应于业务定义的实体的<strong class="lc iv">集市模型</strong>。</p><ul class=""><li id="9759" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">为每个部门、业务单位或实体创建一个子目录</li><li id="6f03" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">每个mart模型都应该简单地以它所代表的实体命名。例如<code class="fe nq nr ns nt b">orders</code>、<code class="fe nq nr ns nt b">users</code>或<code class="fe nq nr ns nt b">payments</code></li><li id="62a9" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">避免跨多个不同业务单元的重复实体(这通常是一种反模式)。</li></ul><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="bdcb" class="ms mt iu nt b gz ny nz l oa ob">models/marts<br/>|---finance<br/>|   |---_finance__models.yml<br/>|   |---orders.sql<br/>|   |---payments.sql<br/>|   |---payroll.sql<br/>|   |---revenue.sql<br/>|---marketing<br/>|   |---_marketing__models.yml<br/>|   |---campaigns.sql<br/>|   |---users.sql</span></pre></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h2 id="32fa" class="ms mt iu bd mu mv mw dn mx my mz dp na lj nb nc nd ln ne nf ng lr nh ni nj nk bi translated">命名约定:概述</h2><p id="cd00" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">这是一篇相当长的文章，包含了太多的信息——尤其是如果您是dbt新手的话——所以让我回顾一下关于命名约定的一些要点。</p><ul class=""><li id="368e" class="oc od iu lc b ld le lg lh lj oe ln of lr og lv oh oi oj ok bi translated">在<code class="fe nq nr ns nt b">models</code>目录下，为每个数据模型类型创建三个子目录</li><li id="6f62" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">分级模型需要遵循<code class="fe nq nr ns nt b">stg_[source]__[entity]s.sql</code>命名约定</li><li id="4b9c" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">中间型号需要遵循<code class="fe nq nr ns nt b">int_[entity]s_[verb]s.sql</code>惯例</li><li id="7729" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">集市模型需要以它们所代表的实体命名</li><li id="afec" class="oc od iu lc b ld ol lg om lj on ln oo lr op lv oh oi oj ok bi translated">暂存模型目录下的一个<code class="fe nq nr ns nt b">base</code>子目录，以防您需要将暂存模型连接在一起</li></ul><p id="0f81" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我们在前面几节中经历的示例的最终结构。</p><pre class="kk kl km kn gu nu nt nv nw aw nx bi"><span id="feac" class="ms mt iu nt b gz ny nz l oa ob">models<br/>|---intermediate<br/>   |---finance<br/>   |   |---_int_finance__models.yml<br/>   |   |---int_payments_pivoted_to_orders.sql<br/>   |---marketing<br/>   |   |---_int_marketing__models.yml<br/>   |   |---int_events_aggregated_per_user_platform.sql<br/>|---marts<br/>    |---finance<br/>    |   |---_finance__models.yml<br/>    |   |---orders.sql<br/>    |   |---payments.sql<br/>    |   |---payroll.sql<br/>    |   |---revenue.sql<br/>    |---marketing<br/>    |   |---_marketing__models.yml<br/>    |   |---campaigns.sql<br/>    |   |---users.sql<br/>|---staging<br/>   |---facebook_ads<br/>   |   |---_facebook_ads__models.yml<br/>   |   |---_facebook_ads__sources.yml<br/>   |   |---_facebook_ads__events.yml<br/>   |---my_shop<br/>   |   |---_my_shop__models.yml<br/>   |   |---_my_shop__sources.yml<br/>   |   |---base<br/>   |   |  |---base_my_shop__deleted_products.sql<br/>   |   |  |---base_my_shop__deleted_users.sql<br/>   |   |  |---base_my_shop__products.sql<br/>   |   |  |---base_my_shop__users.sql<br/>   |   |---stg_my_shop__orders.sql<br/>   |   |---stg_my_shop__products.sql<br/>   |   |---stg_my_shop__users.sql<br/>   |---stripe<br/>       |---_stripe_models.yml<br/>       |---_stripe_models.yml<br/>       |---stg_stripe__payments.yml</span></pre><p id="1da6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">显然，我们今天演示的结构可能不是100%适合您的用例，所以请随意相应地修改它——但是无论什么情况，都要确保清楚地定义这种结构背后的逻辑，并坚持下去。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><h2 id="78f3" class="ms mt iu bd mu mv mw dn mx my mz dp na lj nb nc nd ln ne nf ng lr nh ni nj nk bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph la lb iu lc b ld nl jv lf lg nm jy li lj nn ll lm ln no lp lq lr np lt lu lv in bi translated">数据模型管理是现代数据团队<strong class="lc iv">必须</strong>做好的最重要的支柱之一。对此类模型的薄弱管理可能会导致数据质量下降、数据停机以及难以扩展和丰富您的数据资产。鉴于现代公司需要基于数据做出决策，糟糕的数据模型管理可能会带来灾难性的后果，并导致错误的决策。</p><p id="fdb5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在今天的文章中，我们对数据构建工具(dbt)如何帮助现代组织和数据团队更高效地管理数据模型进行了高度概括。但最重要的是，我们讨论了如何在dbt本身中构建项目和数据模型。数据构建工具是最强大的工具之一，但是使用正确的工具还不够，以正确的方式使用正确的工具也很重要。</p><p id="95b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">关于dbt项目结构的更全面的阅读，你可以参考<a class="ae kz" href="https://docs.getdbt.com/guides/best-practices/how-we-structure/1-guide-overview" rel="noopener ugc nofollow" target="_blank">官方dbt文档</a>。</p></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a> <strong class="lc iv">阅读媒介上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="oq or gq gs os ot"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kt ot"/></div></div></a></div></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">相关文章你可能也喜欢</strong></p><div class="oq or gq gs os ot"><a rel="noopener follow" target="_blank" href="/visual-sql-joins-4e3899d9d46c"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">SQL连接的直观解释</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">用维恩图和实际例子理解SQL连接</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph kt ot"/></div></div></a></div></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ot"><a rel="noopener follow" target="_blank" href="/2-rules-groupby-sql-6ff20b22fd2c"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">在SQL中使用GROUP BY时要遵循的2条规则</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">了解GROUP BY子句中要包含哪些列，以及如何在WHERE子句中包含聚合</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph kt ot"/></div></div></a></div></div><div class="ab cl ml mm hy mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu ot"><a rel="noopener follow" target="_blank" href="/sql-select-distinct-277c61012800"><div class="ou ab fp"><div class="ov ab ow cl cj ox"><h2 class="bd iv gz z fq oy fs ft oz fv fx it bi translated">DISTINCT不是SQL函数</h2><div class="pa l"><h3 class="bd b gz z fq oy fs ft oz fv fx dk translated">在SQL中使用DISTINCT关键字时，括号的使用如何会导致混淆</h3></div><div class="pb l"><p class="bd b dl z fq oy fs ft oz fv fx dk translated">towardsdatascience.com</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph kt ot"/></div></div></a></div></div></div>    
</body>
</html>