<html>
<head>
<title>Control your Airflow DAGs from an external database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从外部数据库控制您的气流Dag</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/control-your-airflow-dag-from-an-external-database-f56d88f7df29#2022-05-02">https://towardsdatascience.com/control-your-airflow-dag-from-an-external-database-f56d88f7df29#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/e99702f6f090ed72508c7cbd58aa8626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bfWlGk1As43U9r_tV_CdQA.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">荷兰Zaandam的Zaanse Schans(作者)</p></figure><div class=""/><p id="5387" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Apache Airflow是一个非常流行的框架，用于调度、运行和监控任务，这些任务被分组到DAG(有向无环图)中。每个DAG都有几个描述DAG将如何以及何时执行的参数。DAG本身由安排在流中的任务组成。DAG参数被定义为<a class="ae la" href="https://github.com/apache/airflow/blob/main/airflow/models/dag.py#L184" rel="noopener ugc nofollow" target="_blank"> DAG类</a>的属性，并存储在代码中。这种解决方案在许多情况下是足够的。</p><p id="0f28" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，dag的配置可以被委托并存储在别处——在与外部用户的GUI链接的一些数据库中。</p><p id="38ea" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">由此，dag的一些参数可以在不接触代码源的情况下被定义，例如由非开发者定义。例如，想象一个化学实验室，其中自动化过程由气流控制，化学家可以使用web界面改变一些参数。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="d5cf" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个简短的故事中，我将展示如何使用外部配置源来动态创建和配置Dag。这里的一个假设是，所有Dag在任务和关系方面都是相似的。因此，只有几个参数可以通过数据库进行配置:</p><ul class=""><li id="5a9f" class="li lj jf ke b kf kg kj kk kn lk kr ll kv lm kz ln lo lp lq bi translated">调度时间</li><li id="ce10" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz ln lo lp lq bi translated">执行参数</li></ul><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/75f2f4511bfbad8537124e8f72fa9a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-yvjMW48kSoVpKOx6abmw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">动态配置的Dag流(按作者)</p></figure><p id="7210" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该解决方案由两个Dag组成:</p><ul class=""><li id="3007" class="li lj jf ke b kf kg kj kk kn lk kr ll kv lm kz ln lo lp lq bi translated"><strong class="ke jg"> read_config </strong>负责从数据库获取配置</li><li id="889a" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz ln lo lp lq bi translated"><strong class="ke jg"> dynamic_dags </strong>负责根据配置创建Dag</li></ul><h1 id="9a1e" class="mb mc jf bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">读取配置</h1><p id="eb10" class="pw-post-body-paragraph kc kd jf ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">有人可能会问，为什么我们需要两个DAG，为什么不将所有内容都放在一个DAG中。这是因为Airflow处理Python文件的方式。调度程序每隔n秒扫描一次<code class="fe ne nf ng nh b">dags/</code>文件夹中的文件，并使用Python解释器对其进行评估。扫描频率由<code class="fe ne nf ng nh b">dag_dir_list_interval</code>参数控制。<br/>因此，在评估部分，我们不应该做任何昂贵的动作——显然连接到数据库和读取表是其中之一。</p><p id="f8a1" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">相反，数据库读取部分应该转移到由操作符运行的代码中(比如<a class="ae la" href="https://airflow.apache.org/docs/apache-airflow/stable/howto/operator/python.html" rel="noopener ugc nofollow" target="_blank"> PythonOperator </a>)。这正是发生在<code class="fe ne nf ng nh b">read_config</code>达格的事情。</p><p id="9d72" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在DAG中，有一个由<a class="ae la" href="https://airflow.apache.org/docs/apache-airflow/stable/howto/operator/python.html" rel="noopener ugc nofollow" target="_blank"> PythonOperator </a>运行的任务</p><ul class=""><li id="ec45" class="li lj jf ke b kf kg kj kk kn lk kr ll kv lm kz ln lo lp lq bi translated">从数据库中读取配置(即<code class="fe ne nf ng nh b">config.dags</code></li><li id="2d21" class="li lj jf ke b kf lr kj ls kn lt kr lu kv lv kz ln lo lp lq bi translated">将配置放入气流变量中</li></ul><p id="f607" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样。气流变量存储用于保存配置(使用JSON格式)。下面是DAG的定义:</p><pre class="lx ly lz ma gt ni nh nj nk aw nl bi"><span id="d2df" class="nm mc jf nh b gy nn no l np nq">import logging<br/>from datetime import timedelta<br/><br/>import airflow<br/>import mysql.connector<br/>from airflow import DAG<br/>from airflow.models.connection import Connection<br/>from airflow.models.variable import Variable<br/>from airflow.operators.python import PythonOperator<br/><br/>logger = logging.getLogger("airflow.task")<br/><br/>default_args = {<br/>    "owner": "airflow",<br/>    "depends_on_past": False,<br/>    "retries": 0,<br/>    "retry_delay": timedelta(minutes=5),<br/>}<br/><br/>mysql_connection = Connection.get_connection_from_secrets("mysql")<br/><br/><br/>def read_dags_config():<br/>    db_conn = mysql.connector.connect(host=mysql_connection.host, user=mysql_connection.login,<br/>                                      password=mysql_connection.password, database='config')<br/>    cursor = db_conn.cursor()<br/>    cursor.execute("select id, enabled, schedule, description from config.dags")<br/><br/>    rows = cursor.fetchall()<br/><br/>    if rows is None:<br/>        rows = []<br/><br/>    logger.info(f"Config rows: {rows}")<br/>    if len(rows) &gt; 0:<br/>        Variable.set("dags_config", rows, serialize_json=True)<br/><br/><br/>with DAG(<br/>        "read_config",<br/>        default_args=default_args,<br/>        schedule_interval="@hourly",<br/>        start_date=airflow.utils.dates.days_ago(0),<br/>        catchup=False) as dag:<br/>    PythonOperator(task_id="read-config", python_callable=read_dags_config, dag=dag)</span></pre><p id="920e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">来自数据库的配置每小时准备就绪。这些行被序列化为JSON并保存在Airflow变量中:</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/f9b94f3b1a0a28b8aa1904a2a4d00948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AHvtV5CHtR76-90M9hi0-Q.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">气流中的变量列表(按作者)</p></figure><h1 id="ef5b" class="mb mc jf bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">动态DAG</h1><p id="e9ba" class="pw-post-body-paragraph kc kd jf ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ij bi translated">第二个dag(动态DAG)负责创建DAG。该解决方案使用了Airflow处理Python文件的方式。基本上，在扫描<code class="fe ne nf ng nh b">dags/</code>中的文件时，Airflow会寻找类型为<a class="ae la" href="https://github.com/apache/airflow/blob/main/airflow/models/dag.py#L185" rel="noopener ugc nofollow" target="_blank"> DAG </a>的对象。在内部，py文件由Python解释器评估，然后扫描<code class="fe ne nf ng nh b">globals()</code>字典。</p><p id="571b" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">程序很简单。首先，我们从包含要创建的Dag列表的变量中获取配置。接下来，我们遍历列表并运行返回<code class="fe ne nf ng nh b">DAG</code>对象的函数。以及作为变量放入global()字典中的<code class="fe ne nf ng nh b">DAG</code>对象。</p><pre class="lx ly lz ma gt ni nh nj nk aw nl bi"><span id="5c97" class="nm mc jf nh b gy nn no l np nq">from datetime import timedelta<br/><br/>import airflow<br/>from airflow import DAG<br/>from airflow.models.variable import Variable<br/>from airflow.operators.python import PythonOperator<br/><br/>default_args = {<br/>    "owner": "airflow",<br/>    "depends_on_past": False,<br/>    "start_date": airflow.utils.dates.days_ago(0),<br/>    "retries": 2,<br/>    "retry_delay": timedelta(minutes=5),<br/>}<br/><br/><br/>def create_dag(dag_id: str, schedule: str = None, description: str = None):<br/>    dag = DAG(<br/>        dag_id,<br/>        default_args=default_args,<br/>        schedule_interval=schedule,<br/>        dagrun_timeout=timedelta(hours=1),<br/>        catchup=False,<br/>        description=description)<br/><br/>    task_1 = PythonOperator(task_id="task_1", python_callable=lambda: x+1, dag=dag)<br/>    task_2 = PythonOperator(task_id="task_2", python_callable=lambda: 1, dag=dag)<br/><br/>    task_1 &gt;&gt; task_2<br/><br/>    return dag<br/><br/><br/>dags_config = Variable.get("dags_config", deserialize_json=True)<br/><br/>for dag_id, schedule, description in dags_config:<br/>    globals()[f"dag-{dag_id}"] = create_dag(f"dag-{dag_id}", schedule, description)</span></pre><p id="81ed" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里，应该强调两个重要部分。一个功能<code class="fe ne nf ng nh b">create_dag</code>负责定义任务和它们之间关系的整个过程。最后一部分，迭代DB中的配置。注意内置方法<code class="fe ne nf ng nh b">globals()</code>的用法，它返回一个字典。</p><figure class="lx ly lz ma gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/8c31f5d8a33f6be734a4344982ab7e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6w8QmldDZpLp4Pd4Nh_BxA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">创建的动态Dag列表(按作者)</p></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="5816" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">综上所述，气流还是无非是一个常规的Python代码。因此，使用语言和生态系统的所有特性没有任何障碍。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="7ca7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望你喜欢这个故事，它会对你的日常工作有所帮助。如果您有任何问题或建议，请随时通过<a class="ae la" href="https://twitter.com/MrTheodor" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我。</p></div></div>    
</body>
</html>