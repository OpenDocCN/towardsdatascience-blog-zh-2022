<html>
<head>
<title>A Complete Guide to Graphs in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python图形完全指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-complete-guide-to-graphs-in-python-845a0a3381a1#2022-05-17">https://towardsdatascience.com/a-complete-guide-to-graphs-in-python-845a0a3381a1#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a98a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python中构造和使用图形数据结构</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2bc2ca5e51676fa2e33c1455a60a26ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*duDGm4HjGKiLNxvM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> JJ英</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="0ae2" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="1275" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">用编程术语来说，图是一种抽象数据类型，它充当数据元素的非线性集合，包含关于元素及其相互连接的信息。这可以用<em class="mo"> G </em>来表示，其中<em class="mo"> G = (V，E) </em>和<em class="mo"> V </em>表示一组顶点，<em class="mo"> E </em>是连接这些顶点的一组边。这些边可以简单地以[1，0]的形式表示顶点之间的关系，无论是否存在连接，或者可以表示诸如距离、关系强度或它们交互次数之类的值的给定权重。当我们想要映射对象之间的关系时，特别是当有多个关系时，以及当我们想要搜索完成任务流的最佳方式时，这可能是有用的。</p><p id="5251" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在Python中实现这种抽象数据类型有两种常见的方法。第一个是邻接矩阵，第二个是邻接表。出于我们的目的，我们将实现邻接表形式，但有必要理解为什么会这样。</p><p id="4b31" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">邻接矩阵</strong></p><p id="ec13" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">二维数组形式的邻接矩阵是将图实现为数据结构的最简单方法之一。这将表示为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a128e2f673be4fae1a6d092c3b2917d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*C1m7YSgPxxvqqIRxhkYNaA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4f5d" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">其中每一行和每一列代表图中的一个顶点。存储在代表行<em class="mo"> v </em>和列<em class="mo"> w </em>的交叉点的单元中的值指示是否存在从顶点<em class="mo"> v </em>到顶点<em class="mo"> w </em>的边，并且大小代表“重量”。当这些顶点中的两个由一条边连接时，我们可以说它们是相邻的。</p><p id="1dfc" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">邻接矩阵实现的优点是简单，对于小图易于可视化。然而，如果许多单元格是空的，那么我们有一个“稀疏”的矩阵，所以我们使用大量的存储来显示很少的信息。因此，这种实现的问题是所使用的内存存储量。</p><p id="f1a8" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">邻接表</strong></p><p id="4523" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">实现稀疏连通图的一个更节省空间的方法是使用邻接表。在这个实现中，我们保存一个图形对象中所有顶点的主列表，然后每个顶点对象维护一个它所连接的其他顶点的列表。</p><p id="7d48" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">这种实现的优点是，我们可以紧凑地表示稀疏图，以便我们只显示图中包含的顶点以及它们的实际连接，而不是也表示没有连接。使用这种方法还可以让我们轻松地找到所有直接连接到单个顶点的链接。</p><h2 id="48f7" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">履行</h2><p id="661c" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">记住这一点，知道我们希望数据结构如何包含以及我们可能希望如何与它交互，我们可以考虑我们希望如何在实际的数据结构中实现这一点。通常与此相关的主要方法包括:</p><ul class=""><li id="b02a" class="mv mw it lx b ly mp mb mq li mx lm my lq mz mn na nb nc nd bi translated"><code class="fe ne nf ng nh b">addVertex(vert)</code>:在id等于key的图形中添加一个<code class="fe ne nf ng nh b">vertex</code></li><li id="ae94" class="mv mw it lx b ly ni mb nj li nk lm nl lq nm mn na nb nc nd bi translated"><code class="fe ne nf ng nh b">addEdge(fromVert, toVert)</code>:向连接两个顶点的图形添加新的有向边</li><li id="e046" class="mv mw it lx b ly ni mb nj li nk lm nl lq nm mn na nb nc nd bi translated"><code class="fe ne nf ng nh b">getVertex(vertKey)</code>:在名为<code class="fe ne nf ng nh b">vertKey</code>的图中找到顶点</li><li id="5f3b" class="mv mw it lx b ly ni mb nj li nk lm nl lq nm mn na nb nc nd bi translated"><code class="fe ne nf ng nh b">getVertices()</code>:返回图形中所有顶点的列表</li><li id="8791" class="mv mw it lx b ly ni mb nj li nk lm nl lq nm mn na nb nc nd bi translated">如果顶点在图中，则<code class="fe ne nf ng nh b">in</code>返回形式为<code class="fe ne nf ng nh b">vertex in graph</code>的语句的<code class="fe ne nf ng nh b">True</code>，否则返回<code class="fe ne nf ng nh b">False</code></li></ul><p id="04dd" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在Python中实现这种抽象数据类型有两种常见的方法。第一个是邻接矩阵，第二个是邻接表。出于我们的目的，我们将实现邻接表的形式，但它是值得理解为什么是这样的情况。</p><p id="7ace" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">顶点类</strong></p><p id="1c4e" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在创建包含所有顶点的图之前，我们需要创建一个顶点类来表示图中的每个顶点。在这个实现中，每个顶点使用一个字典来跟踪它以<code class="fe ne nf ng nh b">connectedTo</code>属性的形式连接到的顶点。当我们创建一个新的顶点时，我们用键的<code class="fe ne nf ng nh b">id</code>初始化这个顶点，键通常是一个代表这个顶点的字符串，还有一个空的<code class="fe ne nf ng nh b">connectedTo</code>字典。我们还必须向这个<code class="fe ne nf ng nh b">Vertex</code>类添加功能，这样我们就可以向我们的字典添加邻居，</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="5c6f" class="kz la it nh b gy nr ns l nt nu">Class Vertex:</span><span id="0287" class="kz la it nh b gy nv ns l nt nu">    def __init__(self, key):<br/>        self.id = key<br/>        self.connectedTo = {}</span><span id="5e24" class="kz la it nh b gy nv ns l nt nu">    def addNeighbor(self, nbr, weight = 0):<br/>        self.connectedTo[nbr] = weight</span><span id="b28d" class="kz la it nh b gy nv ns l nt nu">    def __str__(self):<br/>        return f"{str(self.id)} connected to: {str([x.id for x in<br/>                  self.connectedTo])}"</span><span id="245b" class="kz la it nh b gy nv ns l nt nu">    def getConnections(self):<br/>        retun self.connectedTo.keys()</span><span id="962e" class="kz la it nh b gy nv ns l nt nu">    def getId(self):<br/>        return self.id</span><span id="ada6" class="kz la it nh b gy nv ns l nt nu">    def getWeight(self, nbr):<br/>        return self.connectedTo.get(nbr)</span></pre><p id="ac45" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated"><strong class="lx iu">图形类</strong></p><p id="7f2e" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">在这种情况下，我们实现图形的方式是，图形包含一个将顶点名称映射到顶点对象的字典。这意味着在构造时，我们只需要创建一个空字典，当它们被添加到图中时，可以用来存储<code class="fe ne nf ng nh b">Vertex</code>对象。我们还可以添加一个<code class="fe ne nf ng nh b">numVertices</code>属性，它将存储图中顶点的数量，以便在以后需要时可以很容易地提取出来。</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="9789" class="kz la it nh b gy nr ns l nt nu">class Graph:</span><span id="a3a8" class="kz la it nh b gy nv ns l nt nu">    def __init__(self):<br/>        self.vertList = {}<br/>        self.numVertices = 0</span></pre><p id="6f9c" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">现在我们有了我们的图，我们要添加的第一件事是给我们的图添加一个顶点。在这个简单的实现中，我们将只关注添加一个具有给定id的顶点。为此，我们需要使用键的id创建一个新的顶点类，使用键作为<code class="fe ne nf ng nh b">vertList</code>字典中的键，并将创建的顶点作为值添加到字典中。然后我们可以返回它，这样用户就可以看到他们创建的顶点:</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="7f09" class="kz la it nh b gy nr ns l nt nu">    def addVertex(self, key):<br/>        """<br/>        Add a vertex to the Graph network with the id of key</span><span id="1528" class="kz la it nh b gy nv ns l nt nu">        Time complexity is O(1) as we are only adding a single<br/>        new vertex which does not affect any other vertex<br/>        """</span><span id="11da" class="kz la it nh b gy nv ns l nt nu">        #add 1 to the number of vertices attribute<br/>        self.numVertices += 1</span><span id="3091" class="kz la it nh b gy nv ns l nt nu">        #instantiate a new Vertex class<br/>        newVertex = Vertex(key)</span><span id="1098" class="kz la it nh b gy nv ns l nt nu">        #add the vertex with the key to the vertList dictionary<br/>        self.vertList[key] = newVertex</span><span id="8425" class="kz la it nh b gy nv ns l nt nu">        #return the NewVertex created<br/>        return newVertex</span></pre><p id="aa6e" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">如果你想看一个顶点本身呢？</p><p id="277d" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">然后我们可以创建一个方法，如果有匹配的键，它将返回实际的顶点。我们可以使用字典的<code class="fe ne nf ng nh b">get()</code>方法来实现，因为如果关键字不在字典中，它将返回<code class="fe ne nf ng nh b">None</code>，否则将返回实际的顶点。这将允许用户查看顶点包含的内容，然后查看图形中其他顶点的链接。</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="3e10" class="kz la it nh b gy nr ns l nt nu">    def getVertex(self, key):<br/>        """<br/>        If vertex with key is in Graph then return the Vertex</span><span id="bbd1" class="kz la it nh b gy nv ns l nt nu">        Time complexity is O(1) as we are simply checking whether<br/>        the key exists or not in a dictionary and returning it<br/>        """</span><span id="c1fe" class="kz la it nh b gy nv ns l nt nu">        #use the get method to return the Vertex if it exists<br/>        #otherwise it will return None<br/>        return self.vertList.get(key)</span></pre><p id="e98d" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">作为补充，我们可以使用关键字<code class="fe ne nf ng nh b">in</code>来检查一个顶点是否在图中。为此，我们使用了<code class="fe ne nf ng nh b">__contains__</code>邓德方法，该方法允许用户使用<code class="fe ne nf ng nh b">vertex in graph</code>符号检查一个顶点是否在字典中。因为每个键代表一个顶点，那么我们可以简单地返回<code class="fe ne nf ng nh b">key</code>是否在<code class="fe ne nf ng nh b">vertList</code>中，这将返回<code class="fe ne nf ng nh b">True</code>或<code class="fe ne nf ng nh b">False</code>。</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="b47a" class="kz la it nh b gy nr ns l nt nu">    def __contains__(self, key):<br/>        """<br/>        Check whether vertex with key is in the Graph</span><span id="19dd" class="kz la it nh b gy nv ns l nt nu">        Time complexity is O(1) as we are simply checking whether <br/>        the key is in in the dictrionary or not</span><span id="ec7b" class="kz la it nh b gy nv ns l nt nu">        """</span><span id="1b0a" class="kz la it nh b gy nv ns l nt nu">        #returns True or False depending if in list<br/>        return key in self.vertList</span></pre><p id="a940" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">图的一个重要属性是顶点之间的连接或边，它包含了顶点如何连接的信息，无论是它们的距离还是另一种度量。为此，我们可以创建<code class="fe ne nf ng nh b">addEdge</code>函数来添加一条连接两个顶点的边，默认权重为0。</p><p id="2f25" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">下面我们实现它的方式是建议一个有向图，因为连接只从顶点<code class="fe ne nf ng nh b">f</code>到顶点<code class="fe ne nf ng nh b">t</code>进行，然而这可以容易地扩展到包括两个方向的连接。我们需要确保的是顶点<code class="fe ne nf ng nh b">f</code>和<code class="fe ne nf ng nh b">t</code>实际上都在图中，所以如果它们还不存在，那么我们可以调用已经创建的<code class="fe ne nf ng nh b">addVertex()</code>方法来创建这些顶点。然后我们可以从每个顶点使用<code class="fe ne nf ng nh b">addNeighbor()</code>方法来添加从<code class="fe ne nf ng nh b">f</code>到<code class="fe ne nf ng nh b">t</code>的邻居。</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="14b8" class="kz la it nh b gy nr ns l nt nu">    def addEdge(self, f, t, weight = 0):<br/>        """<br/>        Add an edge to connect two vertices of t and f with weight<br/>        assuming directed graph</span><span id="f363" class="kz la it nh b gy nv ns l nt nu">        Time complexity of O(1) as adding vertices if they don't <br/>        exist and then add neighbor<br/>        """</span><span id="2ef6" class="kz la it nh b gy nv ns l nt nu">        #add vertices if they do not exist<br/>        if f not in self.vertList:<br/>            nv = self.addVertex(f)<br/>        if t not in self.vertList:<br/>            nv = self.addVertex(t)</span><span id="8618" class="kz la it nh b gy nv ns l nt nu">        #then add Neighbor from f to t with weight<br/>        self.vertList[f].addNeighbor(self.vertList[t], weight)</span></pre><p id="59df" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">我们现在有了图的主要功能，而不是能够添加顶点，检查它们是否存在，以及能够添加顶点之间的连接。因此，我们可以开始添加额外的功能来帮助使用数据结构。</p><p id="7ba4" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">第一个是能够返回图中顶点的完整列表。这将简单地打印出所有的顶点名称，但是当我们想要快速浏览当前结构的图形时，这是很有用的。</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="18c5" class="kz la it nh b gy nr ns l nt nu">    def getVertices(self):<br/>        """<br/>        Return all the vertices in the graph</span><span id="5c9d" class="kz la it nh b gy nv ns l nt nu">        Time complexity is O(1) as we simply return all the keys<br/>        in the vertList dictionary<br/>        """<br/>       <br/>        return self.vertList.keys()</span></pre><p id="aa34" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">第二是能够返回图中顶点的数量。这很简单，因为我们在构造函数方法中创建了<code class="fe ne nf ng nh b">numVertices</code>属性，然后每当我们调用<code class="fe ne nf ng nh b">addVertex</code>方法时，我们就给它加1。因此，我们简单地返回这个属性来显示图中有多少个顶点。</p><pre class="kj kk kl km gt nn nh no np aw nq bi"><span id="1c4b" class="kz la it nh b gy nr ns l nt nu">    def getCount(self):<br/>        """<br/>        Return a count of all vertices in the Graph<br/>       <br/>        Time complexity O(1) because we just return the count<br/>        attribute<br/>        """</span><span id="fa05" class="kz la it nh b gy nv ns l nt nu">        return self.numVertices</span></pre><p id="47c8" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">然后，我们可以将所有这些放在一起，得到最终产品:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="131a" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">当然，还有其他方法可以扩展这种实现，包括:</p><ul class=""><li id="4f99" class="mv mw it lx b ly mp mb mq li mx lm my lq mz mn na nb nc nd bi translated">能够迭代每个顶点</li><li id="33e0" class="mv mw it lx b ly ni mb nj li nk lm nl lq nm mn na nb nc nd bi translated">能够从网络中移除顶点</li><li id="fd12" class="mv mw it lx b ly ni mb nj li nk lm nl lq nm mn na nb nc nd bi translated">能够移除或改变网络中的边</li></ul><p id="4d63" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">但是这个简单的实现可以为这些添加奠定基础。</p><h2 id="eb50" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h2><p id="d75e" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">图是一种非常通用的数据结构，可以用各种方式来表示各种问题。这可以包括一个道路网络，一个友谊网络或者一个棋子在棋盘上的移动。它可用于搜索算法，如广度优先搜索或深度优先搜索，或提取不同图形的共同属性，如最短路径、网络直径或某些节点的中心性。上面的实现经过一些调整就可以用在这些例子中，所以您现在已经有了更详细地研究这些的基础！</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="f899" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">这是探索数据结构及其在Python中的使用和实现系列的第8篇文章。如果您错过了前三篇关于Python中的队列、链表和堆栈的文章，您可以在以下链接中找到它们:</p><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-queues-in-python-cd2baf310ad4"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Python中队列的完整指南</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">什么是队列以及如何用Python实现队列</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-linked-lists-in-python-c52b6cb005"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Python中链表的完整指南</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">什么是链表，如何在Python中实现它们</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ks oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener follow" target="_blank" href="/a-complete-guide-to-stacks-in-python-ee4e2045a704"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">Python中堆栈的完整指南</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在Python中构造和使用堆栈数据结构</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow ks oi"/></div></div></a></div><p id="0a7e" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">本系列的后续文章将涉及链表、队列和图形。为了确保您不会错过任何内容，请注册以便在发布时收到电子邮件通知:</p><div class="of og gp gr oh oi"><a href="https://philip-wilkinson.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">每当菲利普·威尔金森发表文章时，就收到一封电子邮件。</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">每当菲利普·威尔金森发表文章时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="or l"><div class="oz l ot ou ov or ow ks oi"/></div></div></a></div><p id="9e47" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">如果你喜欢你所读的，但还不是一个中等会员，那么考虑使用我下面的推荐代码注册，在这个平台上支持我自己和其他了不起的作者:</p><div class="of og gp gr oh oi"><a href="https://philip-wilkinson.medium.com/membership" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">通过我的推荐链接加入Medium—Philip Wilkinson</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">philip-wilkinson.medium.com</p></div></div><div class="or l"><div class="pa l ot ou ov or ow ks oi"/></div></div></a></div><p id="5a60" class="pw-post-body-paragraph lv lw it lx b ly mp ju ma mb mq jx md li mr mf mg lm ms mi mj lq mt ml mm mn im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>