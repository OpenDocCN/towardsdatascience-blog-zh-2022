<html>
<head>
<title>The What, Why and How of Generative Flow Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成流网络是什么，为什么和如何</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-what-why-and-how-of-generative-flow-networks-4fb3cd309af0#2022-05-17">https://towardsdatascience.com/the-what-why-and-how-of-generative-flow-networks-4fb3cd309af0#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dda1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在TensorFlow 2中构建第一个GFlowNet的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/240875830777b88ecba9bac076a7be12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XseGb3kMKz8NSqfa"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">组合对象是由积木组成的。(照片由<a class="ae kv" href="https://unsplash.com/@rhfhanssen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">鲁本·汉森</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="5df1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成流网络(GFlowNets)是一种机器学习技术，用于以与其相关联的回报成比例的频率生成合成对象。</p><p id="fe4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将解释所有这些词的含义，概述GFlowNets为什么有用，讨论它们是如何被训练的，然后我们将剖析TensorFlow 2的实现。</p><h1 id="12c5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">建立你的直觉</h1><p id="dfd5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">2021年，Emmanuel Bengio和合著者在<a class="ae kv" href="https://arxiv.org/abs/2106.04399" rel="noopener ugc nofollow" target="_blank"> NeurIPS推出了GFlowNets。GFlowNets是一种深度学习技术，用于以与环境中这些对象的预期回报成比例的频率“构建对象”。</a></p><p id="9222" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们第一篇论文中令人振奋的例子是新化学结构的发现(或者我也将它们称为“分子”)。化学结构或分子是“组成的”，因为它们是由离散的构件(原子)组成的。可以测试化学结构的感兴趣的性质，例如抗生素活性。一些分子是强效抗生素——当在实验室中对细菌进行测试时，大多数细菌都会死亡，并获得一个我们可以认为是巨大“奖励”的测量值。大多数分子不会杀死细菌，因此，从实验室测试中返回一个小的“奖励”值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/a7f352ee3fd6a2966bcaafa086183200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dD8u29l_F7r1g2bt"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">分子是由原子构成的。一些分子具有抗生素特性，但大多数没有。(照片由<a class="ae kv" href="https://unsplash.com/@vlisidis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">特里·维利迪斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄)</p></figure><p id="d1ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GFlowNet是构建对象的概率模型。一般来说，GFlowNet的使用方式如下:</p><ol class=""><li id="3476" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">从起点开始，它输出可能的构建块的概率分布。</li><li id="36ca" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它根据预测的分布随机选择一个构造块。请注意，这一步是随机的。有些行动会更有可能，有些会更少。</li><li id="29d8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">添加完第一个构建块后，它接受到这一点的构建对象作为输入，并在可能的构建块上生成一个新的概率分布，然后添加下一个。</li><li id="c296" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它以这种方式进行，直到选择一个终止动作。</li><li id="c838" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">终止操作完成生成的对象，然后可以根据环境查询该对象以获得相关的奖励值。</li></ol><p id="91e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要了解的一些关键事项:</p><ul class=""><li id="1926" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ne mw mx my bi translated">施工被视为一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Markov_chain" rel="noopener ugc nofollow" target="_blank">马尔可夫过程</a>。也就是说，当选择下一个构建块时，唯一的输入是正在构建的对象的当前状态。</li><li id="3f89" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">我们一直使用“积木”的形象，但“行动”可能是更合适的术语。当构建一个分子时，你不仅要选择一个碳原子，还要选择它的位置。将每一步都看作是选择一个动作，这样更容易想象GFlowNets的其他应用。在下面的代码示例中，我们通过在网格中移动来构建路径。每个动作都是对相邻单元的一步。</li><li id="8804" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">学习可能行动的概率分布(我们将很快讨论如何完成)。预测的分布被称为“策略”。</li><li id="3b63" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">该模型最直观的部分是“远期政策”。这是建设性的部分，输出了下一步行动的概率分布。该模型还包括一个“向后策略”，它描述了可以导致当前状态的动作的分布。</li><li id="7a79" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">从开始到结束的一系列完整的动作称为“轨迹”。</li></ul><p id="93dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道了GFlowNets是构造对象的概率模型。GFlowNets的关键特征是，它们以与回报成比例的频率构建对象<em class="nf">。</em></p><p id="577f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你多次重复这个随机的构建过程，你会在高回报区域得到更多的物体，在低回报区域得到更少的物体。以我们的抗生素分子为例，该模型将生成更多类似于强抗生素的分子，但也会生成一些类似于弱抗生素的分子。输出概率将与回报成正比。</p><p id="ee33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Emmanuel Bengio写了一篇<a class="ae kv" href="http://folinoid.com/w/gflownet/" rel="noopener ugc nofollow" target="_blank">博文</a>和附带的<a class="ae kv" href="https://milayb.notion.site/GFlowNet-Tutorial-919dcf0a0f0c4e978916a2f509938b00" rel="noopener ugc nofollow" target="_blank">教程</a>，值得研究。</p><h1 id="2454" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">物流网的应用</h1><p id="3178" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在你明白GFlowNet是做什么的了。你为什么想要一个？它们是用来做什么的？</p><p id="7fdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们用于从非常大的环境中进行智能采样。</p><p id="5560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，坚持化学结构的例子，假设你有一些训练数据开始(一堆化学结构和它们相关的抗生素活性)。你首先训练一个模型(独立于你的GFlowNet ),它可以预测给定化学结构的抗生素活性。我们姑且称之为<em class="nf">代理</em>奖励函数，因为它是目前化学结构和抗生素“奖励”之间关系的最佳表征。现在你想用你的代理模型来挑选新的、未经测试的化学结构，在实验室里进行试验。</p><p id="e244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，你的下一步是什么？一种继续进行的方法是使用你的训练数据作为起点，详尽地生成每一种可能的化学结构。困难在于空间呈指数增长。即使从仅仅10或20个可能的“积木”开始，你也可以在每个分子上有许多可能的位置，导致数百个可能的动作。如果你详尽地列举这种行为的每一种组合，仅仅经过几个步骤，你就会有数十亿种可能性，你很快就会淹没你的计算资源，甚至没有开始探索可能的化学空间。</p><p id="274d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是随机选择行动，这将让你更深入地探索，但不是穷尽。这种方法的问题是均匀随机性。由于大多数分子不是抗生素，很可能绝大多数取样结构的回报很低。</p><p id="248d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是GFlowNets的切入点。首先训练一个GFlowNet来反映代理模型学习到的奖励函数。然后，使用GFlowNet生成许多结构，并使用代理模型对它们进行优先级排序。这样，你已经从可能的化学空间中取样，但是以一种丰富有希望的候选者的方式，同时也允许对不太有希望的结构进行一些探索。</p><p id="7889" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，GFlowNets用于从非常非常大的环境中进行智能采样。</p><h1 id="ba0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何训练GFlowNets</h1><p id="7ed7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在你知道什么是GFlowNets，以及它们是如何使用的了。你如何训练一个模型来展示你想要的行为？你如何训练一个模型来生成与奖励成比例的对象？</p><p id="15e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这个主题的深入讨论，我将向您推荐<a class="ae kv" href="https://arxiv.org/abs/2201.13259" rel="noopener ugc nofollow" target="_blank">这篇论文</a>，它讨论了可用于训练GFlowNets的各种目标函数。出于本文的目的，我们将坚持轨迹平衡。</p><p id="1d13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们到了GFlowNets的“流”部分。作者让我们把环境中所有可能的轨迹想象成一个有水流过的管道网络。每个“管道”都是从一个状态到另一个状态的动作。水从原点(所有轨迹的起点)流过所有的动作，在已知“回报”的终点状态流出。目标是通过管道分配水，使流出的水量与回报成比例。</p><p id="b583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">弹道平衡损失函数是实现这一目标的一种方法。对于每条轨迹，概率的前向流动(从起点到终点状态)应该与从终点状态到起点的回报流动成比例。也就是说，沿着轨迹的前向政策概率的乘积应该与沿着相同轨迹的后向政策概率和回报的乘积成比例。写成一个损失函数，看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/d1168b5367fa461ff559c0869107b5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRVFMk_wSsVcqfA58rQR4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://arxiv.org/abs/2201.13259" rel="noopener ugc nofollow" target="_blank">马尔金等人</a>的方程14。</p></figure><p id="a13e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中:</p><ul class=""><li id="fb0a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ne mw mx my bi translated">z是一个单一的学习值，表示从原点通过整个网络的总流量。</li><li id="ed6e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">P_F是前向策略，P_B是后向策略。注意，对于每一条轨迹，你沿着轨迹取每一个动作的概率的乘积。</li><li id="bbba" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">r是与特定轨迹相关的报酬。也就是说，它是轨迹产生的物体的回报。</li><li id="0f68" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">θ代表将被改变以最小化该函数的模型参数。</li><li id="5b55" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">n是计算损失值的轨迹长度。</li></ul><p id="6964" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直观来看，内部分是前向流(从起点到终点)与后向流(从回报到起点)的比值。理想情况下，该比率将收敛到1。取该比值的<em class="nf">对数</em>意味着如果向前的流量较大，<em class="nf">对数</em>将大于零。如果回流较大，对数将小于零。取整件事的平方，最小值将为零(即<em class="nf"> log </em>内部的比值将为1)。</p><p id="443c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种安排的另一个好处是，当把许多概率相乘时，我们避免了下溢的问题。乘法变成对数下的和。</p><p id="58b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为训练集中的每个样本计算该轨迹平衡损失函数。很关键的一点是，奖励和终态在你的训练数据中是固定值，但是<em class="nf">轨迹是学习到的</em>。在每一个学习时期，向前和向后的政策都将改变，模型将决定平衡概率的行动顺序，以便正确地反映回报。</p><h1 id="e0bb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在TensorFlow 2中构建一个GFlowNet</h1><p id="fea1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，您已经理解了什么是GFlowNets，为什么它们有用，以及它们是如何被训练的，您已经准备好构建一个GFlowNets了。作者在github 上提供了他们所有的<a class="ae kv" href="https://github.com/GFNOrg/gflownet" rel="noopener ugc nofollow" target="_blank">代码，你绝对应该研究一下。虽然本吉奥实验室使用</a><a class="ae kv" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>实现了他们的GFlowNets，但我们将使用<a class="ae kv" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> TensorFlow 2 </a>。</p><p id="7dc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程的所有代码可以在:<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/" rel="noopener ugc nofollow" target="_blank">https://github.com/mbi2gs/gflownet_tf2/</a>找到</p><h2 id="6082" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">环境</h2><p id="b931" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，在最初的GFlowNet出版物中描述的环境是一个n维立方体，其边长为<em class="nf"> H </em>，奖励函数在角上最高。对于这个例子，我们将使用一个2维的8x8网格，因为它很容易绘制和观察发生了什么。文件`<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/env.py" rel="noopener ugc nofollow" target="_blank"> env.py </a>'定义了<strong class="ky ir">re warden environment</strong>类。奖励环境的核心是一个基于输入坐标计算奖励的函数:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="b88a" class="nh lt iq nu b gy ny nz l oa ob">def reward_fn(self, coord):<br/>   """Calculate reward function according to section 4.1 in<br/>   <a class="ae kv" href="https://arxiv.org/abs/2106.04399." rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2106.04399.</a><br/>   :param x_coord: (array-like) Coordinates<br/>   :return: (float) Reward value at coordinates<br/>   """<br/>   assert len(coord) &gt;= 1<br/>   assert len(coord) == self.dim<br/>   r1_term = 1<br/>   r2_term = 1<br/>   reward = self.r0<br/>   for i in range(len(coord)):<br/>      r1_term *= int(0.25&lt;np.abs(coord[i]/(self.length-1)-0.5))<br/>      r2_term *= int(<br/>                 0.3 &lt; np.abs(coord[i]/(self.length-1)-0.5)&lt;= 0.4)<br/>      reward += self.r1*r1_term + self.r2*r2_term<br/>   return reward</span></pre><p id="b421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终的环境看起来是这样的，较低的奖励用紫色，最高的奖励用黄色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/18a48d28103c72850f0906f6951787ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*T5vgCfbtwUFyPkhb"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank">电池3输出</a></p></figure><h2 id="f002" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">向前和向后采样</h2><p id="54d2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir"> GFNAgent </strong>类在<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gfn.py" rel="noopener ugc nofollow" target="_blank"> gfn.py. </a>中定义，从转发策略采样需要:</p><ul class=""><li id="cfeb" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ne mw mx my bi translated">从原点<code class="fe od oe of nu b">(0,0)</code>开始。</li><li id="b15c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">使用该模型生成可能动作(向上、向右或终止)的概率分布。</li><li id="f72b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">根据概率选择行动。</li><li id="a353" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">应用终止或移动到新位置的动作。</li><li id="869e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">继续，直到终止操作。</li></ul><p id="496c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解采样过程是理解GFlowNet实际工作的最佳方式。在python中，前向采样函数如下:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="329b" class="nh lt iq nu b gy ny nz l oa ob">def sample_trajectories(self, batch_size=3, explore=False):<br/>   """Sample `batch_size` trajectories using the current policy.<br/>   :param batch_size: (int) Number of trajectories to sample<br/>   :param explore: (bool) If True, mix policy with uniform<br/>                   distribution to encourage exploration.<br/>   :return: (tuple of nd.array) (trajectories, one_hot_actions,<br/>            rewards)<br/>   """<br/>   # Start at the origin<br/>   still_sampling = [True]*batch_size<br/>   positions = np.zeros((batch_size, self.dim), dtype='int32')<br/>   trajectories = [positions.copy()]<br/>   one_hot_actions = []<br/>   batch_rewards = np.zeros((batch_size,))<br/>   for step in range(self.max_trajectory_len-1):<br/>      # Convert positions to one-hot encoding<br/>      one_hot_position = tf.one_hot(<br/>                           positions, self.env_len, axis=-1)<br/>      # Use forward policy to get log probabilities over actions<br/>      model_fwrd_logits = self.model.predict(one_hot_position)[0]<br/>      model_fwrd_probs = tf.math.exp(model_fwrd_logits)<br/>      if explore:<br/>         # Mix with uniform distribution to encourage exploration<br/>         unif = self.unif.sample(<br/>                   sample_shape=model_fwrd_probs.shape[0])<br/>         model_fwrd_probs = self.gamma*unif + \<br/>                           (1-self.gamma)*model_fwrd_probs<br/>      # Don’t select impossible actions (like moving out of<br/>      # the environment)<br/>      normalized_actions = self.mask_and_norm_forward_actions(<br/>                                   positions, model_fwrd_probs)<br/>      # Select actions randomly, proportionally to input<br/>      # probabilities<br/>      actions = tfd.Categorical(probs=normalized_actions).sample()<br/>      actions_one_hot = tf.one_hot(<br/>                          actions, self.action_space).numpy()<br/>      # Update positions based on selected actions<br/>      for i, act_i in enumerate(actions):<br/>         if act_i == (self.action_space — 1) and still_sampling[i]:<br/>            still_sampling[i] = False<br/>            batch_rewards[i] = self.env.get_reward(positions[i,:])<br/>         elif not still_sampling[i]:<br/>            positions[i,:] = -1<br/>            actions_one_hot[i,:] = 0<br/>         else:<br/>            positions[i, act_i] += 1<br/>      trajectories.append(positions.copy())<br/>      one_hot_actions.append(actions_one_hot)<br/>   return np.stack(trajectories, axis=1), \<br/>          np.stack(one_hot_actions, axis=1), \<br/>          batch_rewards</span></pre><p id="c352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些需要强调的细节:</p><ul class=""><li id="04a2" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ne mw mx my bi translated">在提供给模型之前，位置坐标被转换成一个热点矢量。</li><li id="bbe6" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">有一个“探索”的选项，将统一分布与模型策略混合起来，作为一种鼓励非策略决策的方式。Gamma是控制探索程度的参数(通过控制策略和统一的混合比例)。</li><li id="af20" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">有些动作是不可能的，但是模型一开始并不知道(比如将模型带出环境的动作)。我们执行一个屏蔽步骤来迫使不可能的动作的概率为零。同时，你稍后会看到，我们也在训练模型识别那些不可能的步骤。</li><li id="8371" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ne mw mx my bi translated">上面的函数一次采样多个轨迹。对于每个终止的轨迹，添加一个填充符号(<code class="fe od oe of nu b">-1</code>)，而其余的完成采样。</li></ul><p id="ec0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">采样反向轨迹非常相似(参考"<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/aece0a5463dc0df4d1773bebdb136efbb35fe317/gfn.py#L183" rel="noopener ugc nofollow" target="_blank"> back_sample_trajectory() </a>"函数)，但是使用向后策略而不是向前策略。落后的政策可能感觉没有必要，但它是实现工作模式的关键。在训练过程中，每次一对<em class="nf">(位置，奖励)</em>被输入到模型中，它就从反向策略中采样，将奖励流回原点，然后将正向策略与反向采样的轨迹匹配，一个动作接一个动作。我们将在下一节中看到它是如何在代码中工作的，但是要知道向后策略是必要的！</p><h2 id="e1c3" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">训练循环</h2><p id="8dfc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">训练过程从采样轨迹开始，并通过查询环境来确定奖励。可以反复采样，然后训练，然后采样，然后训练。每次迭代，模型都会更好地逼近环境，如果GFlowNet可以学习任何奖励结构，它将通过从未知区域智能采样来加速探索过程。也可以从独立于GFlowNet策略收集的训练数据集开始(这被称为“离线”训练)。对于本教程，我们将使用离线培训。</p><p id="6518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练过程从混洗和分批训练数据开始。在这个演示中，我们使用一个生成器函数"<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/aece0a5463dc0df4d1773bebdb136efbb35fe317/gfn.py#L286" rel="noopener ugc nofollow" target="_blank"> train_gen() </a>"来生成10个(位置，回报)对的混洗批次，每个时期遍历整个数据集。</p><p id="9284" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/aece0a5463dc0df4d1773bebdb136efbb35fe317/gfn.py#L376" rel="noopener ugc nofollow" target="_blank"> train() </a>”函数遍历预设数量的历元。在每个时期内，它为每个训练样本计算一个损失值，并由此对模型权重进行梯度更新。如果历元期间的平均损失低于任何先前的损失，则保存模型权重。这样，最后可以加载最佳的一组砝码。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0226" class="nh lt iq nu b gy ny nz l oa ob">def train(self, verbose=True):<br/>   """Run a training loop of `length self.epochs`.<br/>   At the end of each epoch, save weights if loss is better<br/>   than any previous epoch.<br/>   At the end of training, read in the best weights.<br/>   :param verbose: (bool) Print additional messages while training              <br/>   :return: (None) Updated model parameters<br/>   """<br/>   if verbose:<br/>      print('Start training...')<br/>   # Keep track of loss during training<br/>   train_loss_results = []<br/>   best_epoch_loss = 10**10<br/>   model_weights_path = './checkpoints/gfn_checkpoint'<br/>   for epoch in range(self.epochs):<br/>      epoch_loss_avg = tf.keras.metrics.Mean()<br/>      sampler = self.train_gen()<br/>      # Iterate through shuffled batches of deduplicated data            <br/>      for batch in sampler:<br/>         loss_values, gradients = self.grad(batch)                <br/>         self.optimizer.apply_gradients(                    <br/>          zip(gradients, self.model.trainable_variables + [self.z0])                <br/>         )<br/>         losses = []<br/>         for sample in loss_values:<br/>            losses.append(sample.numpy())<br/>         epoch_loss_avg(np.mean(losses))<br/>      # If current loss is better than any previous, save weights                     <br/>      if epoch_loss_avg.result() &lt; best_epoch_loss:                      <br/>         self.model.save_weights(model_weights_path)                    <br/>         best_epoch_loss = epoch_loss_avg.result()<br/>      train_loss_results.append(epoch_loss_avg.result())            <br/>      if verbose and epoch % 9 == 0:<br/>         print(f'Epoch: {epoch} Loss: {epoch_loss_avg.result()}')       <br/>      # Load best weights              <br/>      self.model.load_weights(model_weights_path)</span></pre><p id="fdb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用“<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/aece0a5463dc0df4d1773bebdb136efbb35fe317/gfn.py#L364" rel="noopener ugc nofollow" target="_blank"> grad() </a>函数计算渐变。这个函数使用tf。GradientTape()对象来计算每个模型参数相对于损失的梯度。请注意，参数“<code class="fe od oe of nu b">z0</code>”被添加到正在更新的参数列表中。</p><h2 id="f803" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">损失函数</h2><p id="5b32" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">训练过程的核心是轨迹平衡损失函数。回想一下，还有其他损失函数可以使用，但是轨迹平衡往往优于以前的方法(见脚注3)。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="17e5" class="nh lt iq nu b gy ny nz l oa ob">def trajectory_balance_loss(self, batch):<br/>   """Calculate Trajectory Balance Loss function as described in<br/>   <a class="ae kv" href="https://arxiv.org/abs/2201.13259." rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2201.13259.</a><br/>   I added an additional piece to the loss function to penalize<br/>   actions that would extend outside the environment.<br/>   :param batch: (tuple of ndarrays) Output from self.train_gen()    <br/>                 (positions, rewards)<br/>   :return: (list) Loss function as tensor for each value in batch<br/>   """<br/>   positions, rewards = batch<br/>   losses = []<br/>   for i, position in enumerate(positions):<br/>      reward = rewards[i]<br/>      # Sample a trajectory for the given position using<br/>      # backward policy<br/>      trajectory, back_actions = self.back_sample_trajectory(<br/>                                                    position)<br/>      # Generate policy predictions for each position in trajectory<br/>      tf_traj = tf.convert_to_tensor(<br/>                   trajectory[:,…], dtype=’float32')<br/>      forward_policy, back_policy = self.model(tf_traj)<br/>      # Use “back_actions” to select corresponding forward<br/>      # probabilities<br/>      forward_probs = tf.reduce_sum(<br/>          tf.multiply(forward_policy, back_actions),<br/>          axis=1)<br/>      # Get backward probabilities for the sampled trajectory<br/>      # (ignore origin)<br/>      backward_probs = tf.reduce_sum(<br/>         tf.multiply(back_policy[1:,:],<br/>         back_actions[:-1,:self.dim]),<br/>         axis=1)<br/>      # Add a constant backward probability for transitioning <br/>      # from the termination state<br/>      backward_probs = tf.concat([backward_probs, [0]], axis=0)<br/>      # take log of product of probabilities (i.e. sum of log <br/>      # probabilities)<br/>      sum_forward = tf.reduce_sum(forward_probs)<br/>      sum_backward = tf.reduce_sum(backward_probs)<br/>      # Calculate trajectory balance loss function and add to <br/>      # batch loss<br/>      numerator = self.z0 + sum_forward<br/>      denominator = tf.math.log(reward) + sum_backward<br/>      tb_loss = tf.math.pow(numerator — denominator, 2)</span></pre><p id="2cd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">损失分别应用于每个<em class="nf">(位置，奖励)</em>对。注意，给定一个训练位置，第一步是使用向后策略对返回原点的轨迹进行采样。然后，为该采样轨迹中的每个位置计算相应的前向概率。<code class="fe od oe of nu b">z0</code>乘以向前概率与回报乘以向后概率的比例形成了最终的损失值，但是我们应用了对数，所以乘法变成了加法。</p><p id="1dbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，本演示中的向后策略不包括终止可能性。相反，第一个向后动作总是被假定为终止动作，所以我们只在第一个向后步骤中包括一个恒定的可能性。从那里一直回到原点，我们只采样转移概率。请注意，从原点的转移概率没有定义，并被排除在后向轨迹之外。</p><p id="ff05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们增加了一些额外的损失条款来惩罚不可能的行为，比如离开环境。我们通过识别环境边缘的位置，合计从该边缘到环境之外的概率，并将这些错误的总和加到损失中。我们对向前和向后策略都这样做。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="f76b" class="nh lt iq nu b gy ny nz l oa ob">      # Penalize any probabilities that extend beyond the <br/>      # environment<br/>      fwrd_edges = tf.cast(<br/>         np.argmax(trajectory, axis=2) == (self.env_len-1),<br/>         dtype=’float32')<br/>      back_edges = tf.cast(<br/>         np.argmax(trajectory, axis=2) == 0,<br/>         dtype=’float32')<br/>      fedge_probs = tf.math.multiply(<br/>         tf.math.exp(forward_policy[:,:self.dim]),<br/>         fwrd_edges)<br/>      bedge_probs = tf.math.multiply(<br/>         tf.math.exp(back_policy[:,:self.dim]),<br/>         back_edges)[1:,:] # Ignore backward policy for the origin<br/>      fedge_loss = tf.reduce_sum(fedge_probs)<br/>      bedge_loss = tf.reduce_sum(bedge_probs)<br/>      combined_loss = tf.math.add(<br/>         tb_loss, tf.math.add(fedge_loss, bedge_loss))<br/>      losses.append(combined_loss)<br/>   return losses</span></pre><h2 id="198e" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated">示范</h2><p id="03c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">笔记本“<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank"> gflownet_demo.ipynb </a>”将所有的片段放在一起，组成一个离线培训工作流程。</p><p id="3358" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先初始化一个GFlowNet代理(它也初始化一个奖励环境)。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="f557" class="nh lt iq nu b gy ny nz l oa ob">from gfn import GFNAgent<br/>agent = GFNAgent()</span></pre><p id="1d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe od oe of nu b">agent.model.summary()</code>向我们展示了模型结构，默认情况下，它由两个密集层组成，每层32个单元，一个密集的向前策略和一个密集的向后策略。共有1765个可训练参数，另外还有一个用于<code class="fe od oe of nu b">z0</code>。</p><p id="8271" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">未经过训练的策略，在初始化之后看起来非常一致。垂直或横向转变(箭头)或终止(红色八边形)的可能性在每一点上基本一致。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="acf5" class="nh lt iq nu b gy ny nz l oa ob">agent.plot_policy_2d()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/859860f5fafa437695e553a523d641bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/0*y24DxbEC55IbQ2vM"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank">电池8输出</a></p></figure><p id="0c4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过对许多轨迹进行采样，并估计在环境中每个位置结束的可能性，来可视化这种未经训练的策略的结果。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="a147" class="nh lt iq nu b gy ny nz l oa ob">l1_error_before = agent.compare_env_to_model_policy()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/8ada1851904dd10227aea54198e1dda4.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*ftr6BQxdkNyEX435"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank">电池9输出</a></p></figure><p id="a02a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，大多数轨迹都在原点附近结束。鉴于每个职位都有很高的终止可能性，这是意料之中的。训练的目标是让这个情节看起来更像奖励景观(每个角落的模式)。记住，一个训练有素的GFlowNet生成对象的概率与回报成正比。</p><p id="54b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于演示的目的，我们从环境中深入取样，直到大多数职位及其相关报酬都在数据集中。请注意，训练数据是重复的，因此只表示唯一的<em class="nf">(位置，奖励)</em>对。在这种情况下，在对5000个轨迹进行采样后，我们最终得到了所有四种模式(每个角中的最大值)和几乎所有的64个(8×8)位置。采样数据显示在下图中，x的大小与该点的回报成比例。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="b442" class="nh lt iq nu b gy ny nz l oa ob">agent.sample(5000)<br/>agent.plot_sampled_data_2d()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/36e7496689fe7c5c37b21596f873f51e.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/0*cweqSqL69iHDLH_S"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank">电池6输出</a></p></figure><p id="71d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们训练模型！</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="6111" class="nh lt iq nu b gy ny nz l oa ob">agent.train()</span></pre><p id="e896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练进行200个时期，在停止之前，损失大约减少两个数量级。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="63f1" class="nh lt iq nu b gy ny nz l oa ob">Start training…<br/>Epoch: 0 Loss: 5.823361873626709<br/>Epoch: 9 Loss: 1.9640847444534302<br/>Epoch: 18 Loss: 1.6309585571289062<br/>Epoch: 27 Loss: 1.0532681941986084<br/>… … … …<br/>Epoch: 171 Loss: 0.03023693338036537<br/>Epoch: 180 Loss: 0.050495393574237823<br/>Epoch: 189 Loss: 0.046723444014787674<br/>Epoch: 198 Loss: 0.06047442555427551</span></pre><p id="6346" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过训练，我们可以再次可视化策略，看起来有了很大的改善。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="d584" class="nh lt iq nu b gy ny nz l oa ob">agent.plot_policy_2d()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/8123ce58e2467641f2f79b91798f5fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/0*Pk15EXkv0YGf2ZE5"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank">电池11输出</a></p></figure><p id="53a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们<a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/aece0a5463dc0df4d1773bebdb136efbb35fe317/gfn.py#L412" rel="noopener ugc nofollow" target="_blank">通过使用学习到的向前策略对2000个轨迹进行采样，来可视化环境</a>中每个位置的结束概率。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="671d" class="nh lt iq nu b gy ny nz l oa ob">l1_error_after = agent.compare_env_to_model_policy()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/4f6594bca15c1b16c4980f5b1ed72934.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/0*kf-onWR4JZ2Uo5eW"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/mbi2gs/gflownet_tf2/blob/main/gflownet_demo.ipynb" rel="noopener ugc nofollow" target="_blank">电池12输出</a></p></figure><p id="3673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这看起来更像他们奖励景观！当然，它并不完美，你可以花很多时间调整超参数来完善模型。但是，这无疑是在学习一个明智的政策。</p><p id="9c62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还可以使用L1误差(每个位置差异的绝对值)来比较学习的概率分布(根据学习的策略绘制许多轨迹来估计)和目标(归一化奖励环境)。</p><p id="e167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在训练之前，L1误差是1.5，而在训练之后，它减小到0.2。</p><h1 id="0fe7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="9cb4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在你知道什么是GFlowNet，它们为什么有用，以及它们是如何被训练的。您已经完成了演示，可以研究TensorFlow 2中的实现。您已经准备好构建自己的应用程序并将其应用到自己的工作中。祝学习优秀政策好运！</p></div></div>    
</body>
</html>