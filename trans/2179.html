<html>
<head>
<title>Do Not Use If-Else For Validating Data Objects In Python Anymore</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要再使用If-Else来验证Python中的数据对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/do-not-use-if-else-for-validating-data-objects-in-python-anymore-17203e1d65fe#2022-05-16">https://towardsdatascience.com/do-not-use-if-else-for-validating-data-objects-in-python-anymore-17203e1d65fe#2022-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/37dc3b91d6d822f35480f4c26782a19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u33riilOHX-VvkOjBhCrdg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/sneakyelbow-373923/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2498921" rel="noopener ugc nofollow" target="_blank">sneakeyelbow</a>发自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2498921" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="6c9f" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Cerberus——一种简洁易读的验证字典属性的方法</h2></div><p id="6cb4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的Python程序中使用大量字典来保存带有属性的数据对象并不常见。一个典型的例子是Web开发。假设我们正在使用Python开发后端web服务，验证从前端接收的JSON有效负载将是非常重要的。此外，数据科学在某些情况下也可能需要验证数据条目。</p><p id="bfbc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最直观但可能是最糟糕的解决方案是使用大量if-else条件。如果我们只验证一个或两个简单需求的属性，这可能是好的，但是根本不可伸缩。面向对象的方法被认为是更先进的。然而，有时，我们可能不想过度设计我们的应用程序。</p><p id="bb3b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍一个令人惊叹的第三方库— Cerberus。它将在很大程度上简化代码验证。它还使验证规则变得可重用和灵活。它也支持许多复杂的场景。</p><h1 id="59fd" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">1.从典型示例快速开始</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6f04312608804ead5125692a37a35a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ntgFR069KQfudgwn2HtuLQ.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1785760" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/kim_hester-3648659/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1785760" rel="noopener ugc nofollow" target="_blank"> kim_hester </a></p></figure><h2 id="30f0" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">1.1安装</h2><p id="5089" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">像往常一样，Python使得安装第三方库变得非常容易。我们只需要运行<code class="fe nh ni nj nk b">pip</code>命令来安装它。</p><pre class="mm mn mo mp gt nl nk nm nn aw no bi"><span id="15ac" class="mq lv jj nk b gy np nq l nr ns">pip install cerberus</span></pre><p id="6508" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们就可以开始使用它了。对于第一个例子，让我把它分成几个部分来阐明术语。</p><h2 id="7428" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">1.2基本用法</h2><p id="1998" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">首先，我们需要从刚刚安装的<code class="fe nh ni nj nk b">cerberus</code>模块中导入<code class="fe nh ni nj nk b">Validator</code>类。</p><pre class="mm mn mo mp gt nl nk nm nn aw no bi"><span id="5d9c" class="mq lv jj nk b gy np nq l nr ns">from cerberus import Validator</span></pre><p id="de77" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以定义一个“模式”。这个模式将包含我们想要用来验证我们的数据字典的所有规则。这个模式也是一个字典。</p><pre class="mm mn mo mp gt nl nk nm nn aw no bi"><span id="a54b" class="mq lv jj nk b gy np nq l nr ns">schema = {<br/>    'name': {<br/>        'type': 'string'<br/>    },<br/>    'age': {<br/>        'type': 'integer'<br/>    }<br/>}</span></pre><p id="bc39" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的模式告诉Cerberus，我们的字典中有两个字段。“姓名”字段应为字符串，“年龄”字段应为整数。</p><p id="79aa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以使用这个模式初始化我们的“验证器”。我们的验证器将是一个Cerberus <code class="fe nh ni nj nk b">Validator</code>类的实例。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="4864" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator(schema)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/d8560a2a2e4c84d7c1b4dd9dd089b48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhKdAjfQi0VR8IEntnUxWw.png"/></div></div></figure><p id="732e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们创建一个样本字典来测试这个验证器。对于任何“验证器”实例，我们可以调用它的<code class="fe nh ni nj nk b">validate()</code>方法来验证数据字典。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="766d" class="nw lv jj nk b be nx ny l nz ns">my_profile = {'name': 'Christopher Tao', 'age': 34}<br/>profile_validator.validate(my_profile)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ob"><img src="../Images/b723962576793832bf43c4e7c73345a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPx4xoif7LfTVOTppQ92qg.png"/></div></div></figure><p id="feaa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它返回<code class="fe nh ni nj nk b">True</code>,所以这意味着字典通过了验证。在下一个示例中，如果我们将年龄值更改为字符串，将会失败。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="b65b" class="nw lv jj nk b be nx ny l nz ns">my_profile = {'name': 'Christopher Tao', 'age': '34'}<br/>profile_validator.validate(my_profile)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oc"><img src="../Images/4239a41e33901738f48c2865af6b7439.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dNV8ya7oArPyCigucwu5bA.png"/></div></div></figure><p id="29fc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你一定在问我们怎么能不知道失败的原因。它将被存储在验证器中。通过调用验证器的属性<code class="fe nh ni nj nk b">errors</code>，我们可以从验证器中得到所有的错误(如果不是只有一个的话)。</p><pre class="mm mn mo mp gt nl nk nm nn aw no bi"><span id="0698" class="mq lv jj nk b gy np nq l nr ns">profile_validator.errors</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi od"><img src="../Images/37a6fca9fe8959a6edc62ee010af31b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4q6Ot1wFupk4ovL3C3NdPg.png"/></div></div></figure><h2 id="474d" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">1.3更复杂的验证规则</h2><p id="6b18" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">当然，我们可以有更复杂的规则，而不仅仅是一种数据类型。例如，我们希望我们的用户至少18岁，那么我们可以将<code class="fe nh ni nj nk b">min</code>规则添加到模式中。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="f6cb" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator()<br/>my_profile = {'name': 'Alice', 'age': 16}<br/>profile_validator.validate(document=my_profile, schema={<br/>    'name': {<br/>        'type': 'string'<br/>    },<br/>    'age': {<br/>        'type': 'integer',<br/>        'min': 18<br/>    }<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/7fafc449b59621f66e0ce9b93a4f7e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsezGP2PgQ9tYmzC2u8ACg.png"/></div></div></figure><p id="e83f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，验证器是在没有模式的情况下初始化的。然后，可以在<code class="fe nh ni nj nk b">validate()</code>方法中动态地给它分配一个模式。这只是一种更灵活的方式。万一我们的模式规则在它的生命周期中可以被改变，这将是非常方便的。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi of"><img src="../Images/e955aa81e4f53819ff383edc5ef75f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*FQhxZgObIKSftWyJOClG_w.png"/></div></figure><p id="8d92" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">错误显示了失败的原因，没有任何额外的努力，这是我喜欢这个库的原因之一。</p><h2 id="cd41" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">1.4验证嵌套字典</h2><p id="61d2" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">如果我们的字典是嵌套的呢？换句话说，JSON文档中有子文档。别担心，它是由地狱犬支持的。</p><p id="aae2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们需要在配置文件字典中有一个包含街道号和街道名的地址字典，我们可以如下定义模式。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="48a1" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator()<br/>profile_validator.validate({<br/>    'name': 'Chris',<br/>    'address': {<br/>        'street_no': '1',<br/>        'street_name': 'One St'<br/>    }<br/>}, {<br/>    'name': {'type': 'string'},<br/>    'address': {<br/>        'type': 'dict',<br/>        'schema': {<br/>            'street_no': {'type': 'integer'},<br/>            'street_name': {'type': 'string'}<br/>        }<br/>    }<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/92998746650f980cb9fae09870969ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hGQlwE9r_TYTmSZfbplq0Q.png"/></div></div></figure><p id="4b6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于“address”子文档，我们只需要告诉模式它是一个<code class="fe nh ni nj nk b">dict</code>类型，并在其中定义一个子模式。然后，它就会工作。该错误还包括层次关系，以便我们可以轻松地排除故障。</p><h1 id="f349" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">2.走向未知</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/1c8f26e1bcf545d1b5088d4500e6a583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CGjr1Z3dk_kT2XVpZfZyPA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4988985" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/lucioliu-4032922/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4988985" rel="noopener ugc nofollow" target="_blank"> Lucio Liu </a></p></figure><p id="1450" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">常见的情况是，我们无法预测实际可能得到的字段，因此我们需要处理未知字段的验证。我想用这个功能来展示地狱犬是多么灵活。所以，让我们深入了解未知的细节:)</p><h2 id="89c7" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">2.1默认情况下，未知不可接受</h2><p id="48c8" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">例如，我们的验证器只知道我们将有一个“name”字段。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="fec2" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({'name': {'type': 'string'}})</span></pre><p id="007e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，我们的字典有一个未知的字段“年龄”。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="1a38" class="nw lv jj nk b be nx ny l nz ns">profile_validator.validate({'name':'Chris', 'age': 34})</span></pre><p id="0c50" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们置之不理，这将导致验证失败。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oh"><img src="../Images/1e964028b1e7947820203d6ae1d93986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DLyUqIg5Z2zqkPH5-V96Vg.png"/></div></div></figure><p id="2f87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要担心，Cerberus有一个非常全面的解决方案来处理未知领域。</p><h2 id="f640" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">2.2允许未知</h2><p id="4055" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">一个非常常见的需求是，我们希望忽略未知字段，让它们通过。在这种情况下，我们需要将验证器的<code class="fe nh ni nj nk b">allow_unknown</code>属性设置为<code class="fe nh ni nj nk b">True</code>。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="ccd7" class="nw lv jj nk b be nx ny l nz ns">profile_validator.allow_unknown = True</span></pre><p id="7801" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，作为未知字段的<code class="fe nh ni nj nk b">age</code>字段将不会被验证，而是被忽略。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="c812" class="nw lv jj nk b be nx ny l nz ns">profile_validator.validate({'name':'Chris', 'age': 34})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/bf69384a2a09883532eda3d1d61b0e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAOq-fPNdwqoepai4nJerw.png"/></div></div></figure><h2 id="e20f" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">2.3允许特定数据类型未知</h2><p id="f961" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">另一个常见的需求是，我们可能希望忽略某些数据类型。例如，字符串字段是非常自由的样式，我们想忽略它，但是我们不允许任何其他数据类型，比如整数是未知的。</p><p id="9249" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们可以确保<code class="fe nh ni nj nk b">allow_unknown</code>为False，并为其指定特定的数据类型。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="8d30" class="nw lv jj nk b be nx ny l nz ns">profile_validator.allow_unknown = False<br/>profile_validator.allow_unknown = {'type': 'string'}</span></pre><p id="60bc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">验证器模式没有改变，但是让我们用模式中不存在的<code class="fe nh ni nj nk b">firstname</code>和<code class="fe nh ni nj nk b">lastname</code>创建一个字典。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="7f6a" class="nw lv jj nk b be nx ny l nz ns">profile_validator.validate({'firstname':'Chris', 'lastname': 'Tao'})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oj"><img src="../Images/8daa1bef3db587465b00f6a80d13b6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-GLvQwwenqfOsBAsturXg.png"/></div></div></figure><p id="bb0a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它通过了验证，因为它允许任何字符串类型的未知字段。但是，如果我们添加一个整数字段，它将失败。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="293d" class="nw lv jj nk b be nx ny l nz ns">profile_validator.validate({<br/>    'firstname':'Chris', <br/>    'lastname': 'Tao',<br/>    'age': 34<br/>})<br/>profile_validator.validate(my_profile)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ok"><img src="../Images/9aa51f90546e1f43229dc2177675099a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kW0zSxnMP_6j85dOToBzOQ.png"/></div></div></figure><h2 id="c1c9" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">2.4初始化时允许未知</h2><p id="b573" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">如果我们知道我们需要接受未知字段，我们也可以在实例化验证器时添加这个标志，如下所示。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="f68a" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({}, allow_unknown=True)</span></pre><p id="e6d5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如上图，方案为空，但<code class="fe nh ni nj nk b">allow_unknown</code>被设置为<code class="fe nh ni nj nk b">True</code>。因此，它将接受任何字段。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/613cfe328682edb064cf3a5952506510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5v0wJCb11kKWB7N7yB2EQ.png"/></div></div></figure><h2 id="4679" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">2.5允许在特定级别未知</h2><p id="02ed" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我们甚至可以在子文档级别设置<code class="fe nh ni nj nk b">allow_unknown</code>。例如，我们仍然希望字典在根级别得到严格的验证，但是对于<code class="fe nh ni nj nk b">address</code>对象，我们不希望添加太多的约束来允许一些不确定性。</p><p id="c795" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以将模式定义如下。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="a5d4" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({<br/>    'name': {'type': 'string'},<br/>    'address': {<br/>        'type': 'dict',<br/>        'allow_unknown': True<br/>    }<br/>})</span></pre><p id="a9b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意<code class="fe nh ni nj nk b">allow_unknown</code>被设置为<code class="fe nh ni nj nk b">address</code>级别下的<code class="fe nh ni nj nk b">True</code>。所以，无论我们在<code class="fe nh ni nj nk b">address</code>子文档中定义什么，都没问题。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="ce2e" class="nw lv jj nk b be nx ny l nz ns">profile_validator.validate({<br/>    'name': 'Chris',<br/>    'address': {<br/>        'street_no': 1,<br/>        'street_name': 'One St'<br/>    }<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/d982e163dc79999f6c99c2ac605458cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dobNvOWR1c8G52TTwGEHdw.png"/></div></div></figure><p id="d610" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们在根级别添加一个未知字段<code class="fe nh ni nj nk b">age</code>，它将会失败。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="5dbd" class="nw lv jj nk b be nx ny l nz ns">profile_validator.validate({<br/>    'name': 'Chris',<br/>    'age': 34,<br/>    'address': {<br/>        'street_no': 1,<br/>        'street_name': 'One St'<br/>    }<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/c0e57a2e964441845989c2225adc37bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHJHUwyMIRxI8Kpg5LXSgQ.png"/></div></div></figure><h1 id="d543" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">3.必填字段</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/32462b9cdcc58244d9ea82c68baae064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lf9Lcoq71jxVsHpL2aRG3A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4390885" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/minka2507-3728206/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4390885" rel="noopener ugc nofollow" target="_blank"> minka2507 </a></p></figure><p id="5707" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们知道我们可以使用地狱犬来处理未知领域。不如我们把一些字段强制设置为必填字段？</p><p id="4b37" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，如果字典遗漏了模式中定义的一些字段，将不会捕获任何错误。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="98ed" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({<br/>    'name': {'type': 'string'},<br/>    'age': {'type': 'integer'}<br/>})<br/>profile_validator.validate({'name': 'Chris'})</span></pre><p id="d929" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，模式定义了<code class="fe nh ni nj nk b">age</code>字段，但是字典没有它。验证结果仍然是好的。</p><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oo"><img src="../Images/b8eccb3cbf06c8a4b3e48edd622644f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFfaoxVdnqiBxOJkcs-8bw.png"/></div></div></figure><p id="c293" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想让所有的字段都是强制性的，我们可以添加一个标志<code class="fe nh ni nj nk b">require_all</code>并将其设置为<code class="fe nh ni nj nk b">True</code>。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="124f" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({<br/>    'name': {'type': 'string'},<br/>    'age': {'type': 'integer'}<br/>}, require_all=True)<br/>profile_validator.validate({'name': 'Chris'})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/f7f1e36ea8c77cd3ad6b92653fa8285c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSEPCtUMMNCkz7FidDiT1Q.png"/></div></div></figure><p id="eebf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们也可以将某些字段设置为必填字段。这可以通过特定的规则<code class="fe nh ni nj nk b">required</code>来完成。可以将其添加到模式定义的字段中。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="84a8" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({<br/>    'name': {'type': 'string', 'required': True},<br/>    'age': {'type': 'integer'}<br/>})<br/>profile_validator.validate({'age': 34})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/718a6145ab332ad0563019a4e04a6cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zu6moj1DAUKZgD1scBX8IA.png"/></div></div></figure><h1 id="fcf6" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">4.标准化字典</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="ab gu cl or"><img src="../Images/8a6114b27b73601817acd38de8b587be.png" data-original-src="https://miro.medium.com/v2/format:webp/1*blvlXFKk0ZVBBLevDXbxBA.jpeg"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/users/huoadg5888-8934889/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4415649" rel="noopener ugc nofollow" target="_blank"> huoadg5888 </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4415649" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="4e43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">令我惊讶和印象深刻的是，Cerberus不仅可以验证字典，还可以纠正它们。这在保证数据质量的应用中可能非常有用。</p><p id="3efe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可能有来自不同数据源的用户配置文件。当我们想把它们组合成一个单一的真实来源时，我们发现年龄在一个数据库中以整数的形式出现，而在另一个数据库中却是字符串类型。在这种情况下，Cerberus提供了一个名为<code class="fe nh ni nj nk b">normalize()</code>的函数，它可以统一数据类型以确保数据的一致性。</p><p id="c884" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了实现这一点，我们需要指定字段的类型。例如，我们希望将<code class="fe nh ni nj nk b">age</code>字段统一为整数类型。代码如下。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="c143" class="nw lv jj nk b be nx ny l nz ns">profile_validator = Validator({<br/>    'name': {'type': 'string'},<br/>    'age': {'coerce': int}<br/>})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div class="gh gi os"><img src="../Images/178f964cd22fb1032fae876d51379d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*KVpCzD0sdFp6zj-LiPN18Q.png"/></div></figure><p id="e378" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b">coerce</code>告诉验证器我们想要的数据类型是什么。请注意，这不会用于验证目的。因此，如果我们有一个带有字符串类型的<code class="fe nh ni nj nk b">age</code>字段的字典，它仍然可以通过。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="c890" class="nw lv jj nk b be nx ny l nz ns">my_profile = {'name': 'Chris', 'age': '34'}<br/>profile_validator.validate(my_profile)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ot"><img src="../Images/9d2081ef5eb0e0646f718fc885a1c640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Fx4kt5FU3FejG80089PZw.png"/></div></div></figure><p id="7ae8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想要“规范化”字典，我们可以如下调用验证器的<code class="fe nh ni nj nk b">normalize</code>方法。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="fddc" class="nw lv jj nk b be nx ny l nz ns">my_profile_normalized = profile_validator.normalized(my_profile)</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ou"><img src="../Images/bdda7e9b10afb97bfac78e977b226086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*csNRRsbdRV6Q-iGtPd1Ulw.png"/></div></div></figure><p id="ba58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到<code class="fe nh ni nj nk b">age</code>值在规格化后被转换为整数。</p><h1 id="8344" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">5.其他规则和定制规则</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/b8a61bdec53ad56792607822341abe86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IQ7Iao9XD7IEAU5k_4XNA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/spiritze-3079232/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2208371" rel="noopener ugc nofollow" target="_blank">spiritize</a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2208371" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>获得</p></figure><h2 id="2f43" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">5.1支持的规则</h2><p id="b564" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">到目前为止，我没有介绍太多类型的验证规则。这是因为在Cerberus中大约有30种不同类型的现成规则。以下是一些例子:</p><ul class=""><li id="d2cb" class="ov ow jj la b lb lc le lf lh ox ll oy lp oz lt pa pb pc pd bi translated">列表包含一个特定的项目</li><li id="3666" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">dependencies</code>一个字段的规则只有在另一个字段出现时才会生效</li><li id="1e2d" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">empty</code>字符串值不能为空</li><li id="5954" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">nullable</code>允许为<code class="fe nh ni nj nk b">None</code>类型的值</li><li id="780c" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">forbidden</code>该值不得在预定义列表中</li><li id="30a9" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">excludes</code>如果出现另一个字段，则该字段不能存在</li><li id="0550" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">regex</code>字符串值必须与正则表达式匹配</li><li id="3db5" class="ov ow jj la b lb pe le pf lh pg ll ph lp pi lt pa pb pc pd bi translated"><code class="fe nh ni nj nk b">allof/anyof/noneof/oneof</code>定义多个规则，并且值必须满足所有规则、任何规则、不满足任何规则或至少满足其中一个规则。</li></ul><p id="f196" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不能介绍Cerberus中的每一个规则，但是你可以从文档中查看所有的规则。</p><p id="ca4b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://docs.python-cerberus.org/en/stable/validation-rules.html#of-rules" rel="noopener ugc nofollow" target="_blank">https://docs . python-Cerberus . org/en/stable/validation-rules . html</a></p><h2 id="df1a" class="mq lv jj bd lw mr ms dn ma mt mu dp me lh mv mw mg ll mx my mi lp mz na mk nb bi translated">5.2定制规则</h2><p id="f0be" class="pw-post-body-paragraph ky kz jj la b lb nc kk ld le nd kn lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">如果Cerberus提供的30条规则都不符合我们的要求，该怎么办？为了最大限度地提高灵活性，Cerberus还允许我们定义定制的规则。</p><p id="7fb3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定制规则需要被定义为具有如下三个参数的函数。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="c199" class="nw lv jj nk b be nx ny l nz ns">def my_rule(field, value, error):<br/>    if value % 2 != 0:<br/>        error(field, "Must be an even number")</span></pre><p id="60ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b">field</code>是字段的名称，<code class="fe nh ni nj nk b">value</code>将是我们想要验证的值，<code class="fe nh ni nj nk b">error</code>是一个函数，它将定义存储在验证器的<code class="fe nh ni nj nk b">errors</code>属性中的错误消息。</p><p id="2581" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我刚才定义的<code class="fe nh ni nj nk b">my_rule</code>就是简单的检查一个数是否是偶数。一旦定义了它，我们就可以用关键字<code class="fe nh ni nj nk b">check_with</code>在模式中使用它。</p><pre class="mm mn mo mp gt nl nk nt bn nu nv bi"><span id="6ee8" class="nw lv jj nk b be nx ny l nz ns">my_validator = Validator({<br/>    'my_number': {'check_with': my_rule}<br/>})<br/>my_validator.validate({'my_number': 10})</span></pre><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/c188937fde5c07cacf2f1451da8dc74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7MCE2kp7x8H7x9KxIb3zFg.png"/></div></div></figure><h1 id="7e44" class="lu lv jj bd lw lx ly lz ma mb mc md me kp mf kq mg ks mh kt mi kv mj kw mk ml bi translated">摘要</h1><figure class="mm mn mo mp gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/797d612079d9768c5de2beb030b34c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZaSD30Xtc2QNImYGhCfU3w.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3042751" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/seaq68-4191072/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3042751" rel="noopener ugc nofollow" target="_blank"> Sven Lachmann </a></p></figure><p id="fda4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了Python中的第三方库Cerberus。它为我们验证字典提供了一个非常好的解决方案。它非常灵活，这可以从处理未知字段和定义必填字段的例子中看出。此外，它支持大约30个现成的规则，以及我们自己定制的验证规则。</p><div class="is it gp gr iu pk"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd jk gy z fp pp fr fs pq fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">medium.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ja pk"/></div></div></a></div><p id="6b98" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p><blockquote class="pz"><p id="c180" class="qa qb jj bd qc qd qe qf qg qh qi lt dk translated">除非另有说明，所有图片都是作者的</p></blockquote></div></div>    
</body>
</html>