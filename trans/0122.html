<html>
<head>
<title>Cross Validation and Grid Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉验证和网格搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cross-validation-and-grid-search-efa64b127c1b#2022-02-05">https://towardsdatascience.com/cross-validation-and-grid-search-efa64b127c1b#2022-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e2bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在随机森林模型上使用 sklearn 的 GridSearchCV</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ac4052f9b4dd5ecc8e52a15a05e0e54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-LcJEuYvBjUFh1DhSOicA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由 Annie Spratt 通过 Unsplash 提供</p></figure><p id="0d62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为机器学习问题找到最佳的调整参数通常是非常困难的。我们可能会遇到<strong class="kx ir">过度拟合，</strong>，这意味着我们的机器学习模型在我们的训练数据集上训练得过于具体，当应用于我们的测试/维持数据集时，会导致更高水平的错误。或者，我们可能会遇到<strong class="kx ir">欠拟合，</strong>，这意味着我们的模型没有针对我们的训练数据集进行足够具体的训练。当应用于测试/维持数据集时，这也会导致更高水平的误差。</p><p id="f4e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在为模型定型和测试执行常规定型/验证/测试拆分时，模型会对随机选择的特定数据部分进行定型，对单独的数据集进行验证，最后对维持数据集进行测试。在实践中，这可能会导致一些问题，尤其是当数据集的大小相对较小时，因为您可能会删除一部分对训练最佳模型至关重要的观察值。将一定比例的数据排除在训练阶段之外，即使其 15–25%仍然包含大量信息，否则这些信息将有助于我们的模型更有效地训练。</p><p id="2bbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的问题有了一个解决方案——<strong class="kx ir">交叉验证</strong>。交叉验证的工作方式是将我们的数据集分成随机的组，选出一组作为测试，然后在其余的组上训练模型。对作为测试组的每个组重复这一过程，然后将模型的平均值用于结果模型。</p><p id="7d2c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最常见的交叉验证类型之一是 k-fold 交叉验证，其中“k”是数据集中的折叠数。使用 k =5 是常见的第一步，下面的例子很容易说明这一原理:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lr"><img src="../Images/a117cb190b1213c366963b95ed210628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSlot50Mu-NDODADz3pz4g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="424e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们看到模型的五次迭代，每次迭代都将不同的褶皱作为测试集，并在其他四个褶皱上进行训练。所有五次迭代完成后，将结果迭代平均在一起，创建最终的交叉验证模型。</p><p id="4a87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然交叉验证可以极大地有益于模型开发，但是在进行交叉验证时，也应该考虑一个重要的缺点。因为模型的每次迭代(最多 k 次)都需要运行完整的模型，所以随着数据集变大以及“k”值的增加，计算成本会变得很高。例如，在具有 100 万个观察值的数据集上运行 k = 10 的交叉验证模型需要运行 10 个单独的模型，每个模型都使用所有 100 万个观察值。对于小型数据集来说，这并不是一个问题，因为计算时间可能只有几分钟，但是当处理大型数据集，其规模可能达到数 Gb 或 Tb 时，所需的时间将会显著增加。</p><p id="9717" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文的剩余部分，我们将在我之前的文章中创建的随机森林模型上实现交叉验证。此外，我们将实现所谓的网格搜索，它允许我们在超参数网格上运行模型，以确定最佳结果。</p><p id="8f74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">数据:</strong>该数据集提供了乘客的信息，如年龄、机票等级、性别，以及乘客是否幸存的二元变量。这些数据也可以用于 Kaggle Titanic ML 比赛，所以本着保持比赛公平的精神，我不会展示我进行 EDA &amp;数据争论的所有步骤，或者直接发布代码。我将构建我在上面提到的文章中开发的先前的模型。</p><p id="e61c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">提醒一下，使用的基本随机森林训练模型如下所示:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="0bae" class="ly lz iq lu b gy ma mb l mc md"># Train/Test split<br/>x_train, x_test, y_train, y_test = train_test_split(X, y, test_size = .25, random_state = 18)</span><span id="9336" class="ly lz iq lu b gy me mb l mc md"># Model training<br/>clf = RandomForestClassifier(n_estimators = 500, max_depth = 4, max_features = 3, bootstrap = True, random_state = 18).fit(x_train, y_train)</span></pre><p id="a5e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们取得的成果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/a28fb68f1aa27767421b6b9816d0645b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ippqhWy3GoSx9pg-ct1SGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="0e75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于本文，我们将保留这个训练/测试分割部分，以保持模型之间的维持测试数据一致，但是我们将使用交叉验证和网格搜索对训练数据进行参数调整，以查看我们的结果输出与使用上面的基本模型得到的输出有何不同。</p><p id="3053" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> GridSearchCV: </strong> <br/>我们将在本文中使用的模块是 sklearn 的 GridSearchCV，它将允许我们传递我们的特定估计量、我们的参数网格和我们选择的交叉验证折叠数。此方法的文档可以在<a class="ae ls" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GridSearchCV.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。下面重点介绍了一些主要参数:</p><ul class=""><li id="82c7" class="mg mh iq kx b ky kz lb lc le mi li mj lm mk lq ml mm mn mo bi translated"><strong class="kx ir">估计器</strong> —此参数允许您选择要运行的特定模型，在我们的示例中为随机森林分类。</li><li id="f2ef" class="mg mh iq kx b ky mp lb mq le mr li ms lm mt lq ml mm mn mo bi translated"><strong class="kx ir"> param_grid </strong> —该参数允许您传递正在搜索的参数网格。这个网格必须格式化为一个字典，其中的键对应于特定估计器的参数名，值对应于要为特定参数传递的值列表。</li><li id="7a41" class="mg mh iq kx b ky mp lb mq le mr li ms lm mt lq ml mm mn mo bi translated"><strong class="kx ir"> cv — </strong>该参数允许您更改交叉验证的折叠次数。</li></ul><p id="9e13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">模型训练:<br/> </strong>我们将首先为随机森林分类模型创建一个参数值网格。网格中的第一个参数是 n_estimators，它选择随机森林模型中使用的树木数量，这里我们选择 200、300、400 或 500 的值。接下来，我们选择 max_feature 参数的值，它限制了每棵树考虑的特征数量。我们将该参数设置为“sqrt”或“log2”，它将采用数据集中估计量的平方根或以 2 为底的对数的形式。第三个参数是 max_depth，它将随机森林模型中每棵树的最大深度设置为 4、5、6、7 或 8。最后，标准参数将通过“基尼”或“熵”进行搜索，以找到理想的标准。该网格如下所示:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="6de3" class="ly lz iq lu b gy ma mb l mc md">grid = { <br/>    'n_estimators': [200,300,400,500],<br/>    'max_features': ['sqrt', 'log2'],<br/>    'max_depth' : [4,5,6,7,8],<br/>    'criterion' :['gini', 'entropy'],<br/>    'random_state' : [18]<br/>}</span></pre><p id="2ea7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建网格后，我们可以运行 GridSearchCV 模型，将 RandomForestClassifier()传递给我们的估计器参数，将我们的网格传递给 param_grid 参数，并将交叉验证折叠值设为 5。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="f204" class="ly lz iq lu b gy ma mb l mc md">rf_cv = GridSearchCV(estimator=RandomForestClassifier(), param_grid=grid, cv= 5)<br/>rf_cv.fit(x_train, y_train)</span></pre><p id="3082" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以使用了”。best_params_ "方法来为我们的模型输出最佳参数。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="b61c" class="ly lz iq lu b gy ma mb l mc md">rf_cv.best_params_</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/5ec68b585befd66576a66a2cf38b70d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/format:webp/1*HAwJgf9Vy-mFdzzwNrmsMQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1eb8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了最佳的参数列表，我们可以使用这些参数运行基本的 RandomForestClassifier 模型，并与使用没有网格搜索的原始训练/测试分割获得的结果进行比较来测试我们的结果。</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="71a9" class="ly lz iq lu b gy ma mb l mc md">rf2 = RandomForestClassifier(n_estimators = 200, max_depth = 7, max_features = 'sqrt',random_state = 18, criterion = 'gini').fit(x_train, y_train)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b2db2df311d870d42d26395ab7da1b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*pF1ZT8dxIeQSkQl-huTRTw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="114d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">我们的更优模型的结果优于我们的初始模型，准确性得分为 0.883，而先前为 0.861，F1 得分为 0.835，而先前为 0.803。</strong></p><p id="c0f6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">合并 GridSearchCV 的一个缺点是运行时。如前所述，交叉验证和网格调整会导致较长的训练时间，因为模型必须经过多次迭代。整个 GridSearchCV 模型运行大约需要 4 分钟，这看起来不多，但是考虑到我们在这个数据集中只有大约 1k 个观察值。你认为进行 10 万次观察或者数百万次观察需要多长时间？</p><p id="e4cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">结论:<br/> </strong>通过使用交叉验证和网格搜索，当与我们的原始训练/测试分割相比时，我们能够以最小的调整获得更有意义的结果。交叉验证是一种非常重要的方法，用于通过对训练数据集的所有部分进行训练和测试来创建更好的拟合模型。</p><p id="e6c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您花时间阅读这篇文章！我希望你喜欢阅读，并了解了更多关于如何将交叉验证和网格搜索应用到你的机器学习模型中。如果你喜欢你所读的，请关注我的个人资料，成为第一批看到未来文章的人！</p></div></div>    
</body>
</html>