<html>
<head>
<title>A Beginner-Friendly Introduction to Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对初学者友好的Kubernetes介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-beginner-friendly-introduction-to-kubernetes-540b5d63b3d7#2022-06-19">https://towardsdatascience.com/a-beginner-friendly-introduction-to-kubernetes-540b5d63b3d7#2022-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8a5b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">没必要这么复杂，对吧？</h2><div class=""/><div class=""><h2 id="e1f0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">通过动手MLFlow部署示例</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/feb1d4a871b385a178b78f5fa4e640a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bERTGuchH3I5G56x"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">洛伦佐·埃雷拉在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="f612" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">让我们开始吧。</h1><p id="6c92" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果你正在阅读这篇文章，很可能是因为你听说过这个时髦词“<em class="mw">Kubernetes</em>”(K8s)，你很可能在技术领域。您可能也对什么是容器化(或者称为Docker / dockerization)有所了解，所以我将跳过这个细节，直接进入K8s是什么。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="7626" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">介绍</h1><p id="63e7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">简而言之，K8s只是一个容器编排框架。这实质上意味着K8s是一个旨在<strong class="mc jd">自动化容器化应用的生命周期</strong>的系统——从可预测性、可伸缩性到可用性。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><blockquote class="nj nk nl"><p id="1f4c" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated"><strong class="mc jd">如果您正在使用Kubernetes来设置您的数据科学基础架构，请务必查看一下</strong><a class="ae lh" href="https://saturncloud.io/" rel="noopener ugc nofollow" target="_blank"><strong class="mc jd">Saturn Cloud</strong></a><strong class="mc jd">，这是一个可扩展、灵活的数据科学平台，提供包括GPU在内的计算。</strong></p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="d2f2" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">我们为什么需要Kubernetes？</h2><p id="e522" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">K8s的兴起和需求背后的驱动原因源于微服务的使用越来越多，远离传统的单片类型的应用。因此，容器为这些单独的微服务提供了完美的主机，因为容器管理依赖性、独立、与操作系统无关和短暂等优点。</p><p id="d690" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">具有许多组件的复杂应用程序通常由数百甚至数千个微服务组成。如果我们要使用定制的程序或脚本来管理所有这些不同的组件，在确保可用性的同时扩展这些微服务是一个极其痛苦的过程，因此需要一种适当的方式来管理这些组件。</p><p id="daf2" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">线索<em class="mw"> Kubernetes </em>。</p><h2 id="ba46" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">Kubernetes的优势</h2><p id="f177" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Kubernetes承诺使用以下功能解决上述问题:</p><ol class=""><li id="1f0b" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ok ol om on bi translated"><strong class="mc jd">高可用性</strong> —这意味着无论您有新的更新要推出，还是有一些意外的pods崩溃，您的应用程序都将一直正常运行。</li><li id="df93" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated"><strong class="mc jd">可伸缩性</strong>——这确保了应用程序的高性能，无论是单个用户还是一千个用户同时涌入你的应用程序。</li><li id="23ba" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated"><strong class="mc jd">灾难恢复</strong> —这确保了如果您的物理或基于云的基础架构发生意外，您的应用将始终拥有最新的数据和状态。</li></ol></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="993a" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">它是如何在引擎盖下工作的</h1><p id="e75f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">K8s使用主从式架构，其中一个节点充当主节点，在集群中发号施令，而其他节点充当从节点/工作节点，执行由主节点决定的应用程序工作负载。</p><h2 id="c807" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">简单的Kubernetes建筑</h2><p id="dd35" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">带有一个主节点和两个工作节点的简单K8s设置如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/2baa56a0f0582d716e92db4cb6252244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h26nFoT4C8J_jt8ZyUReFA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">带有一个主节点和两个从节点的K8s设置示例(由作者举例说明)</p></figure><h2 id="51a6" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">主节点</h2><p id="6471" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">顾名思义，主节点是集群的老板，决定集群状态和每个工作节点的工作。为了设置一个主节点，需要在其上运行4个进程:</p><p id="042f" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 1。API服务器</strong></p><ul class=""><li id="1125" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">主<strong class="mc jd">入口点</strong>供用户与集群交互(即集群网关)；当我们使用<code class="fe ov ow ox oy b">kubectl</code>时，它是发送请求的地方</li><li id="61d3" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">用于<strong class="mc jd">认证</strong>和请求验证的看门人，确保只有特定用户能够执行请求</li></ul><p id="e518" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 2。调度器</strong></p><ul class=""><li id="20f2" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">决定下一个pod将在哪个节点上旋转，但不旋转pod本身(<em class="mw"> kubelet </em>这样做)</li></ul><p id="6b0c" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 3。控制器管理器</strong></p><ul class=""><li id="15b2" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">检测群集状态变化(例如，pod正在死亡)并尝试将群集恢复到其原始状态</li><li id="dea8" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">例如，如果一个pod意外死亡，<em class="mw">控制器管理器</em>向<em class="mw">调度器</em>发出请求，以决定哪个节点启动新的pod来替换死亡的pod。库伯莱然后旋转新的吊舱。</li></ul><p id="dec3" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 4。<em class="mw">etcd</em>T24】</strong></p><ul class=""><li id="2a8c" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">集群脑！</li><li id="8105" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">群集状态的键值存储</li><li id="8371" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">所做的任何群集更改都将存储在此处</li><li id="8f47" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">这里不存储应用程序数据，只存储集群状态数据。记住，主节点不做工作，它是集群的<strong class="mc jd">大脑</strong>。具体来说，<em class="mw"> etcd </em>存储集群状态信息，以便上面的其他进程知道关于集群的信息</li></ul><h2 id="ae6d" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">从属/工作节点</h2><p id="9699" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">每个worker节点必须安装3个节点进程，以允许Kubernetes与它进行交互，并在每个节点内独立启动pod。需要的3个过程是:</p><p id="06a7" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 1。库伯莱</strong>又名<code class="fe ov ow ox oy b"><em class="mw">kubelet</em></code></p><ul class=""><li id="322b" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">与节点和容器交互</li><li id="516e" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">负责获取配置文件并使用容器运行时启动pod(<em class="mw">见下文！</em>)安装在节点上</li></ul><p id="519b" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 2。容器运行时间</strong></p><ul class=""><li id="68f6" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">安装的任何容器运行时(例如，<em class="mw"> Docker </em>，<em class="mw"> containerd </em>)</li></ul><p id="fb8e" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 3。库贝代理</strong>又名<code class="fe ov ow ox oy b"><em class="mw">kube-proxy</em></code></p><ul class=""><li id="8ad6" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">实现Kubernetes <em class="mw">服务</em>概念的一部分的网络代理</li><li id="3e35" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">位于节点之间，智能地转发请求(节点内或节点间转发)</li></ul></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="f9a4" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">库伯内特斯的成分</h1><p id="9afd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在我们知道了K8s的工作原理，让我们来看看Kubernetes中一些最常见的<em class="mw">T4组件，我们将使用它们来部署我们的应用程序。</em></p><h2 id="ae07" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">1.豆荚</h2><ul class=""><li id="06f8" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">K8s的最小单元，通常包含应用程序的实例</li><li id="54a5" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">容器上的抽象</li><li id="5f7a" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">每个pod都有自己的IP地址(公有或私有)</li><li id="65a8" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">短暂—重新创建pod时的新IP地址</li></ul><h2 id="be80" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated"><strong class="ak"> 2。服务</strong></h2><ul class=""><li id="24d0" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">因为pod本来就是短暂的，所以服务提供了一种方法来“给予”pod一个永久的IP地址</li><li id="8197" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">使用<em class="mw">服务</em>，如果pod终止，其IP地址在重新创建时不会改变</li><li id="a311" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">充当<em class="mw">几乎</em>的<strong class="mc jd">负载平衡器</strong>，将流量路由到pod，同时保持静态IP</li><li id="2cf1" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">像负载平衡器一样，<em class="mw">服务</em>也可以是内部的或外部的，其中外部<em class="mw">服务</em>是面向公众的(公共IP ),内部<em class="mw">服务</em>是针对内部应用的(私有IP)</li></ul><h2 id="be3b" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated"><strong class="ak"> 3。入口</strong></h2><ul class=""><li id="ac82" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">有了服务，我们现在可以在某个端口上公开一个web应用程序，比如IP地址10.104.35上的8080。实际上，在<code class="fe ov ow ox oy b"><a class="ae lh" href="http://10.104.35:8080." rel="noopener ugc nofollow" target="_blank">http://10.104.35:8080</a></code> <a class="ae lh" href="http://10.104.35:8080." rel="noopener ugc nofollow" target="_blank">上访问面向公众的应用是不切实际的。</a></li><li id="e683" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">因此，我们需要一个具有正确域名的入口点(例如，<code class="fe ov ow ox oy b">https://my-domain-name.com</code>)，然后将请求转发给服务(例如，<code class="fe ov ow ox oy b"><a class="ae lh" href="http://10.104.35:8080)" rel="noopener ugc nofollow" target="_blank">http://10.104.35:8080</a></code> <a class="ae lh" href="http://10.104.35:8080)" rel="noopener ugc nofollow" target="_blank"> ) </a></li><li id="fc35" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">本质上，<strong class="mc jd"> Ingress向集群</strong>【1】内的服务<em class="mw">公开来自集群</em>外<em class="mw">的HTTP和HTTPs路由。</em></li><li id="9c90" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><a class="ae lh" href="https://www.f5.com/services/resources/glossary/ssl-termination#:~:text=SSL%20termination%20refers%20to%20the,along%20to%20a%20web%20server." rel="noopener ugc nofollow" target="_blank"> SSL终止</a>(又称为<em class="mw"> SSL卸载</em> ) —即服务及其pod的流量是明文</li><li id="1685" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">也就是说，单独创建入口资源没有任何效果。还需要一个<em class="mw">入口控制器</em>来满足入口。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pc"><img src="../Images/870b9bdaba4c97f3831353f140504950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTTFa2yX7Z0f54NzDi1w_w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Ingress如何与Ingress控制器一起工作(由作者说明)</p></figure><h2 id="68b8" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated"><strong class="ak"> 4。入口控制器</strong></h2><ul class=""><li id="622b" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">对群集中服务的传入流量进行负载平衡</li><li id="733b" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">还管理需要与外部服务通信的服务的出口流量</li></ul><blockquote class="nj nk nl"><p id="92e2" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated"><strong class="mc jd"><em class="it">Ingress和Ingress控制器有什么区别？</em> </strong></p><p id="37c1" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated">入口<em class="it">包含路由流量的规则，决定传入请求应该路由到集群中的哪个</em>服务<em class="it">。</em></p><p id="1841" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated">Ingress控制器<em class="it">是Ingress的</em>实际实现<em class="it">，负责第四层或第七层代理。</em>入口控制器<em class="it">的例子有</em> <a class="ae lh" href="https://github.com/kubernetes/ingress-nginx" rel="noopener ugc nofollow" target="_blank"> <em class="it">入口NGINX控制器</em> </a> <em class="it">和</em> <a class="ae lh" href="https://github.com/kubernetes/ingress-gce" rel="noopener ugc nofollow" target="_blank"> <em class="it">入口GCE </em> </a> <em class="it">。每个云提供商和其他第三方提供商将拥有自己的</em>入口控制器<em class="it">实施方案。</em></p><p id="fcda" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated"><em class="it">完整名单可以在</em> <a class="ae lh" href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" rel="noopener ugc nofollow" target="_blank"> <em class="it">这里</em> </a> <em class="it">找到。</em></p></blockquote><h2 id="2a6f" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">5.配置图</h2><ul class=""><li id="fe65" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">顾名思义，它本质上是一个配置文件，您希望公开给用户修改</li></ul><h2 id="06d8" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">6.秘密</h2><ul class=""><li id="0427" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">也是一个配置文件，但用于存储密码等敏感信息</li><li id="5103" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">Base64编码</li></ul><h2 id="eec0" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">7.卷</h2><ul class=""><li id="32ce" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">用于持久数据存储</li><li id="748d" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">因为pod本身是短暂的，所以卷用于持久存储信息，以便现有的和新的pod可以引用应用程序的某些状态</li><li id="7550" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">几乎就像您的豆荚的“外部硬盘驱动器”</li><li id="8fe9" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">卷可以本地存储在运行pod的同一个节点上，也可以远程存储(例如云存储，NFS)</li></ul><h2 id="ed85" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">8.部署</h2><ul class=""><li id="c0cd" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ou ol om on bi translated">用于定义pod的蓝图</li><li id="c786" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">实际上，我们处理的是部署，而不是pod本身</li><li id="e596" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">部署通常有副本，因此当应用程序的任何组件失效时，总会有备份</li><li id="bae7" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">然而，像数据库这样的组件不能被复制，因为它们是有状态的应用程序。在这种情况下，我们需要Kubernetes组件:<strong class="mc jd"> StatefulSet </strong>。这很难做到，通常情况下，数据库应该托管在Kubernetes集群之外</li></ul><blockquote class="pd"><p id="c4c4" class="pe pf it bd pg ph pi pj pk pl pm mv dk translated">好吧，那可能太多了，难以消化。让我们开始动手练习吧！一定要花些时间重新阅读上面的内容，以便清楚地了解整个K8s架构中每个组件的职责。</p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="f510" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">我们来练习一下！</h1><p id="04d8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">因为本文的重点是理解K8s的组件本身，而不是如何设置K8s集群，所以我们将简单地使用<code class="fe ov ow ox oy b">minikube</code>来设置我们自己的本地集群。之后，我们将部署一个简单但现实的应用程序—一个<a class="ae lh" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLFlow服务器</a>。</p><p id="fa5f" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">如果你想了解源代码，我已经把它们包含在GitHub repo <a class="ae lh" href="https://github.com/davidcjw/mlflow-kubernetes-medium-example" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="1825" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">我们将建立什么</h2><p id="5419" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">一个典型的应用程序有一个带有后端服务的web服务器来保存数据——这是我们今天要复制和部署的目标。为了让事情变得更简单，我们将部署一个<a class="ae lh" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLFlow web服务器</a>，它将数据保存在谷歌云平台(GCP)上的云SQL数据库中。</p><p id="f202" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">设置如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pn"><img src="../Images/2e53baea52f9e582adaa87b3eb1cb5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rz_U5aba3xOT1kNp.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.mlflow.org/docs/latest/tracking.html#id31" rel="noopener ugc nofollow" target="_blank">具有远程跟踪服务器、后端和工件存储的ml flow</a>(图片来源:<a class="ae lh" href="https://www.mlflow.org/docs/latest/tracking.html#scenario-4-mlflow-with-remote-tracking-server-backend-and-artifact-stores" rel="noopener ugc nofollow" target="_blank"> MLFlow文档</a>)</p></figure><p id="f2fc" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">对于那些不知道的人来说，MLFlow主要是一个实验跟踪工具，允许数据科学家通过记录数据和模型工件来跟踪他们的数据科学实验，并可以选择使用MLFlow定义的标准化包来部署他们的模型。出于本文的目的，我们将使用PostgreSQL后端(托管在云SQL上)和blob存储(在Google云存储上)部署MLFlow跟踪web服务器。</p><p id="9753" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">在此之前，我们必须安装一些东西(如果你已经安装了这些东西，请跳过<em class="mw">)。</em></p><h2 id="1a9b" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">装置</h2><ol class=""><li id="421f" class="of og it mc b md me mg mh mj oz mn pa mr pb mv ok ol om on bi translated"><a class="ae lh" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li><li id="0140" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated">K8s命令行工具，<code class="fe ov ow ox oy b">kubectl</code>。我们最好的朋友——我们用它来与我们的K8s星团互动，不管它是<em class="mw"> minikube </em>、<em class="mw">云</em>还是<em class="mw">混合</em>星团</li><li id="a404" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated"><a class="ae lh" href="https://minikube.sigs.k8s.io/docs/start/#what-youll-need" rel="noopener ugc nofollow" target="_blank"> Minikube </a>安装指南</li><li id="fbd9" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated"><a class="ae lh" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank">谷歌云SDK </a></li><li id="9629" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated"><em class="mw"><code class="fe ov ow ox oy b">kubectl</code>、<code class="fe ov ow ox oy b">kubens</code>、<code class="fe ov ow ox oy b">kubectx</code>可选</em>电动工具。按照<a class="ae lh" href="https://github.com/ahmetb/kubectx" rel="noopener ugc nofollow" target="_blank">这个</a>安装。</li></ol><h2 id="fee7" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">设置本地集群</h2><p id="56c8" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">从<code class="fe ov ow ox oy b">minikube start</code>开始你的集群。就是这样！您已经用一个命令创建了自己的本地Kubernetes集群:)</p><p id="091b" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">您可以验证上面列出的各种组件是用<code class="fe ov ow ox oy b">minikube status</code>创建的。如果您有几个K8s集群上下文，请确保切换到minikube。</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="fef5" class="nu lj it oy b gy ps pt l pu pv"># Check context<br/>kubectx</span><span id="bb37" class="nu lj it oy b gy pw pt l pu pv"># If not on minikube, switch context<br/>kubectx minikube</span></pre><p id="59f5" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">对于本地集群设置，让我们从设置外部组件开始，然后继续部署Kubernetes对象。</p><p id="9651" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 1。为MLFlow创建一个docker file</strong></p><p id="3fd9" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">我们首先需要一个将要部署的MLFlow web服务器的Docker映像。不幸的是，MLFlow没有我们可以在DockerHub上使用的官方图像，所以我在这里创建了一个供大家使用。让我们从DockerHub中调出我创建的图像。</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="9244" class="nu lj it oy b gy ps pt l pu pv">docker pull davidcjw/example-mlflow:1.0</span></pre><p id="b606" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">[ <em class="mw">可选的</em> ]要测试映像是否在本地工作，只需运行:</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="b188" class="nu lj it oy b gy ps pt l pu pv">docker run -p 8080:8080 davidcjw/example-mlflow:1.0</span></pre><p id="dd30" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 2。在GCP上创建一个云SQL (PostgreSQL)实例</strong></p><p id="9b8b" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">这将用于存储记录到MLFlow跟踪服务器上的运行的元数据。如前所述，在Kubernetes集群之外创建有状态应用程序更容易。</p><ul class=""><li id="cffe" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">首先，在GCP上创建一个账户和项目，如果你还没有的话</li><li id="a429" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated">使用CLI和以下命令创建一个实例:</li></ul><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="340f" class="nu lj it oy b gy ps pt l pu pv">gcloud sql instances create &lt;<strong class="oy jd">your_instance_name</strong>&gt; \<br/>  --assign-ip \<br/>  --authorized-networks=&lt;<strong class="oy jd">your_ip_address</strong>&gt;/32 \<br/>  --database-version=POSTGRES_14 \<br/>  --region=&lt;<strong class="oy jd">your_region</strong>&gt; \<br/>  --cpu=2 \<br/>  --memory=3840MiB \<br/>  --root-password=&lt;<strong class="oy jd">your_password</strong>&gt;</span></pre><p id="81d7" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">要找到<code class="fe ov ow ox oy b">&lt;your_ip_address&gt;</code>，简单谷歌“我的ip是什么”。对于<code class="fe ov ow ox oy b">&lt;region&gt;</code>，可以指定离你比较近的地区。对我来说，我指定了<code class="fe ov ow ox oy b">asia-southeast1</code>。</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="2bb3" class="nu lj it oy b gy ps pt l pu pv"><strong class="oy jd">NOTE! </strong>These configs are intended for this example deployment and not suitable for production environments. For production environments, you would want to have minimally <strong class="oy jd">multi-zonal availability</strong> connected over a <strong class="oy jd">Private IP</strong>.</span></pre><p id="d70d" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 3。创建一个谷歌云存储桶</strong></p><p id="4a92" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">这将用于存储用户记录的数据和模型人工制品。在GCP上创建一个桶，并为以后记录URI。对于我自己，我已经使用下面的命令在<code class="fe ov ow ox oy b">gs://example-mlflow-artefacts</code>创建了一个:</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="38ac" class="nu lj it oy b gy ps pt l pu pv">gsutil mb -l &lt;<strong class="oy jd">your_region</strong>&gt; gs://example-mlflow-artefacts</span></pre><p id="4094" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 4。在本地</strong> <code class="fe ov ow ox oy b"><strong class="mc jd">minikube</strong></code> <strong class="mc jd">集群</strong>上创建ConfigMap和Secret</p><p id="cdb9" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">现在，激动人心的部分—在我们的Kubernetes集群上部署所需的各种组件。在此之前，了解一些关于K8s对象的事情是绝对必要的。</p><p id="507e" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">Kubernetes资源是使用具有特定格式的<code class="fe ov ow ox oy b">.<em class="mw">yaml</em></code>文件创建的(<em class="mw">请参考Kubernetes文档[2]了解您正在创建的任何资源类型</em>)。它们用于定义哪些容器化的应用程序在哪个端口上运行，更重要的是，用于定义这些应用程序如何运行的策略。</p><p id="9add" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"/><code class="fe ov ow ox oy b"><strong class="mc jd">.yaml</strong></code><strong class="mc jd">文件有效地定义了我们的集群状态！</strong></p><p id="a1d0" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><a class="ae lh" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/" rel="noopener ugc nofollow" target="_blank">描述Kubernetes对象</a> ( <code class="fe ov ow ox oy b"><em class="mw">.yaml</em></code>文件):</p><ul class=""><li id="08c0" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated">总是以<code class="fe ov ow ox oy b">apiVersion</code>、<code class="fe ov ow ox oy b">kind</code>开头，并有<code class="fe ov ow ox oy b">metadata</code></li><li id="84cb" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">apiVersion</code>:定义Kubernetes API的版本号(如果您使用的版本处于稳定模式，通常是v1)</li><li id="eeb7" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">kind</code>:定义组件类型(如Secret、ConfigMap、Pod等)</li><li id="d548" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">metadata</code>:唯一标识一个对象的数据，包括<code class="fe ov ow ox oy b">name</code>、<code class="fe ov ow ox oy b">UID</code>和<code class="fe ov ow ox oy b">namespace</code> ( <em class="mw">以后会详细介绍！</em>)</li><li id="5f47" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">spec</code>(或规格)/ <code class="fe ov ow ox oy b">data</code>:特定于组件的细节</li></ul><p id="6db2" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 4a。</strong>让我们从<em class="mw"> ConfigMap </em>开始，因为当我们使用<em class="mw">部署</em>部署我们的MLFlow应用程序时，将需要这些配置(<strong class="mc jd">注意</strong> : <em class="mw">资源创建的顺序很重要，特别是当有配置或秘密附加到部署时)。</em></p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="3598" class="nu lj it oy b gy ps pt l pu pv"># configmap.yaml<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>  name: mlflow-configmap<br/>data:<br/>  <em class="mw"># property-like keys; each key maps to a simple value</em><br/>  DEFAULT_ARTIFACT_ROOT: <!-- -->&lt;<strong class="oy jd">your_gs_uri</strong>&gt;<br/>  DB_NAME: postgres<br/>  DB_USERNAME: postgres<br/>  DB_HOST: &lt;<strong class="oy jd">your_cloud_sql_public_ip</strong>&gt;</span></pre><blockquote class="nj nk nl"><p id="b4c2" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated">💡<strong class="mc jd"> <em class="it">亲提示！</em> </strong> <em class="it">始终有一个官方K8s文档的标签处于打开状态，因此您可以参考他们为每个K8s组件准备的示例</em> <code class="fe ov ow ox oy b"><em class="it">.yaml</em></code> <em class="it">文件。</em></p></blockquote><p id="466e" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 4b。</strong>接下来，让我们为秘密创建一个。请注意，机密必须是base64编码的。只需使用以下工具即可完成:</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="7523" class="nu lj it oy b gy ps pt l pu pv">echo -n "&lt;your_password&gt;" | base64</span></pre><p id="830b" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">我们唯一需要编码的是我们之前在Cloud SQL上创建PostgreSQL实例时定义的密码。让我们对其进行base64编码，并将标准输出复制到下面的<code class="fe ov ow ox oy b">.<em class="mw">yaml</em></code>文件中。</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="e2c4" class="nu lj it oy b gy ps pt l pu pv"># secrets.yaml<br/>apiVersion: v1<br/>kind: Secret<br/>metadata:<br/>  name: mlflow-postgresql-credentials<br/>type: Opaque<br/>data:<br/>  postgresql-password: &lt;<strong class="oy jd">your_base64_encoded_password</strong>&gt;</span></pre><p id="3808" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">使用以下方式应用配置映射和密码:</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="fdab" class="nu lj it oy b gy ps pt l pu pv">kubectl apply -f k8s/configmap.yaml<br/>kubectl apply -f k8s/secrets.yaml</span><span id="6793" class="nu lj it oy b gy pw pt l pu pv">&gt;&gt;&gt; configmap/mlflow-configmap created<br/>&gt;&gt;&gt; secret/mlflow-postgresql-credentials created</span></pre><p id="419c" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">太好了！我们现在可以引用我们创建的秘密和配置。</p><p id="e7e9" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 5。创建部署和服务</strong></p><p id="892f" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 5a。</strong>先说<em class="mw">部署</em>。为了理解部署，让我们后退一步，回忆一下<em class="mw">部署</em>和<em class="mw"> Pod </em>之间的主要区别在于，前者有助于创建将要部署的Pod的副本。因此，<em class="mw">部署</em>的<code class="fe ov ow ox oy b">yaml</code>文件包含了<em class="mw"> Pod </em>的配置，以及我们想要创建的副本数量。</p><p id="84dd" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">如果我们看一下下面的<code class="fe ov ow ox oy b">yaml</code>文件，我们会注意到<code class="fe ov ow ox oy b">metadata</code>和<code class="fe ov ow ox oy b">spec</code>在配置中出现了两次，第一次在配置文件的顶部，第二次在“<em class="mw">模板</em>键的下面。这是因为在下面<strong class="mc jd">定义的所有内容"<em class="mw">模板</em>"键都用于<em class="mw"> Pod </em>配置。</strong></p><blockquote class="pd"><p id="7cb7" class="pe pf it bd pg ph px py pz qa qb mv dk translated">简而言之，一个Pod组件部署我们应用程序的一个实例，而一个部署(通常)由该Pod的多个部署组成。如果我们部署中的副本数量为1，那么它基本上与单个单元相同(但是可以选择纵向扩展)。</p></blockquote><pre class="qc qd qe qf qg po oy pp pq aw pr bi"><span id="d354" class="nu lj it oy b gy ps pt l pu pv"># deployment.yaml<br/><strong class="oy jd">apiVersion</strong>: apps/v1<br/><strong class="oy jd">kind</strong>: Deployment<br/><strong class="oy jd">metadata</strong>:<br/>  <strong class="oy jd">name</strong>: mlflow-tracking-server<br/>  <strong class="oy jd">labels</strong>:<br/>      <strong class="oy jd">app</strong>: mlflow-tracking-server<br/><strong class="oy jd">spec</strong>:<br/>  <strong class="oy jd">replicas</strong>: 1<br/>  <strong class="oy jd">selector</strong>:<br/>    <strong class="oy jd">matchLabels</strong>:<br/>      <strong class="oy jd">app</strong>: mlflow-tracking-server-pods<br/>  # Pod configurations defined here in `template`<br/>  <strong class="oy jd">template</strong>:<br/>    <strong class="oy jd">metadata</strong>:<br/>      <strong class="oy jd">labels</strong>:<br/>        <strong class="oy jd">app</strong>: mlflow-tracking-server-pods<br/>    <strong class="oy jd">spec</strong>:<br/>      <strong class="oy jd">containers</strong>:<br/>        - <strong class="oy jd">name</strong>: mlflow-tracking-server-pod<br/>          <strong class="oy jd">image</strong>: davidcjw/example-mlflow:1.0<br/>          <strong class="oy jd">ports</strong>:<br/>            - <strong class="oy jd">containerPorts</strong>: 5000<br/>          <strong class="oy jd">resources</strong>:<br/>            <strong class="oy jd">limits</strong>:<br/>              <strong class="oy jd">memory</strong>: 1Gi<br/>              <strong class="oy jd">cpu</strong>: "2"<br/>            <strong class="oy jd">requests</strong>:<br/>              <strong class="oy jd">memory</strong>: 1Gi<br/>              <strong class="oy jd">cpu</strong>: "1"<br/>          <strong class="oy jd">imagePullPolicy</strong>: Always<br/>          <strong class="oy jd">env</strong>:<br/>          - <strong class="oy jd">name</strong>: DB_PASSWORD<br/>            <strong class="oy jd">valueFrom</strong>:<br/>              <strong class="oy jd">secretKeyRef</strong>:<br/>                <strong class="oy jd">name</strong>: mlflow-postgresql-credentials<br/>                <strong class="oy jd">key</strong>: postgresql-password<br/>          - <strong class="oy jd">name</strong>: DB_USERNAME<br/>            <strong class="oy jd">valueFrom</strong>:<br/>              <strong class="oy jd">configMapKeyRef</strong>:<br/>                <strong class="oy jd">name</strong>: mlflow-configmap<br/>                <strong class="oy jd">key</strong>: DB_USERNAME<br/>          - <strong class="oy jd">name</strong>: DB_HOST<br/>            <strong class="oy jd">valueFrom</strong>:<br/>              <strong class="oy jd">configMapKeyRef</strong>:<br/>                <strong class="oy jd">name</strong>: mlflow-configmap<br/>                <strong class="oy jd">key</strong>: DB_HOST<br/>          - <strong class="oy jd">name</strong>: DB_NAME<br/>            <strong class="oy jd">valueFrom</strong>:<br/>              <strong class="oy jd">configMapKeyRef:</strong><br/>                <strong class="oy jd">name</strong>: mlflow-configmap<br/>                <strong class="oy jd">key</strong>: DB_NAME<br/>          - <strong class="oy jd">name</strong>: DEFAULT_ARTIFACT_ROOT<br/>            <strong class="oy jd">valueFrom</strong>:<br/>              <strong class="oy jd">configMapKeyRef</strong>:<br/>                <strong class="oy jd">name</strong>: mlflow-configmap<br/>                <strong class="oy jd">key</strong>: DEFAULT_ARTIFACT_ROOT</span></pre><p id="b3df" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">需要回答两个重要问题:pod副本如何组合在一起以被<em class="mw">部署</em>识别为一个副本？2)<em class="mw">部署</em>如何知道它属于哪一组pod副本？</p><ol class=""><li id="d88d" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ok ol om on bi translated"><code class="fe ov ow ox oy b">template &gt; metadata &gt; labels</code>:与其他组件如<em class="mw"> ConfigMap </em>和<em class="mw"> Secret </em>不同，此元数据关键字<code class="fe ov ow ox oy b">labels</code>是强制性的，因为在此部署下创建的每个pod副本将具有唯一的ID(例如，<em class="mw"> mlflow-tracking-xyz </em>，<em class="mw"> mlflow-tracking-abc </em>)。为了能够将它们作为一个组来共同识别，使用了标签，使得这些pod副本中的每一个都将接收这些相同的标签集。</li><li id="68c1" class="of og it mc b md oo mg op mj oq mn or mr os mv ok ol om on bi translated"><code class="fe ov ow ox oy b">selector &gt; matchLabels</code>:用于确定本次部署下的吊舱组。注意这里的标签必须<strong class="mc jd">与【1】中的标签</strong>完全匹配。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/b219b6382866a771a9a3566a4c7bd52c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z8oXpFp8vUVsnhy1_DWi3Q.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="04b8" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd">其他关键配置</strong>:</p><ul class=""><li id="36c5" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated"><code class="fe ov ow ox oy b">replicas</code>:用于确定pod副本的数量</li><li id="c38a" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">containers &gt; image</code>:每个pod使用的图像</li><li id="75a8" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">containers &gt; env</code>:我们在这里指定将在每个pod中初始化的环境变量，从我们之前创建的<em class="mw"> ConfigMap </em>和<em class="mw"> Secret </em>中引用。</li></ul><p id="f76e" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 5b。</strong> <em class="mw">服务</em> —如上所述，服务几乎像负载平衡器一样用于将流量分配给每个pod副本。因此，以下是关于<em class="mw">服务</em>的一些重要注意事项。</p><ul class=""><li id="d5f7" class="of og it mc b md nm mg nn mj oh mn oi mr oj mv ou ol om on bi translated"><code class="fe ov ow ox oy b">selector</code>:这个键值对应该与之前在<em class="mw">部署</em>中指定的<code class="fe ov ow ox oy b">template &gt; metadata &gt; labels</code>相匹配，这样<em class="mw">服务</em>就知道将请求路由到哪组pod。</li><li id="3f47" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">type</code>:默认为<code class="fe ov ow ox oy b">ClusterIP</code>，这是集群的内部IP地址(其他服务类型的列表可以在<a class="ae lh" href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types" rel="noopener ugc nofollow" target="_blank">这里</a>找到)。对于我们的用例，我们将使用<code class="fe ov ow ox oy b">NodePort</code>在节点IP地址的端口上公开我们的web应用程序。请注意<code class="fe ov ow ox oy b">NodePort</code>的值只能在30000–32767之间。</li><li id="c631" class="of og it mc b md oo mg op mj oq mn or mr os mv ou ol om on bi translated"><code class="fe ov ow ox oy b">targetPort</code>:这是您的pod公开应用程序的端口，在<em class="mw">部署</em>中指定。</li></ul><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="a115" class="nu lj it oy b gy ps pt l pu pv">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  labels:<br/>    app: mlflow-tracking-server<br/>  name: mlflow-tracking-server<br/>spec:<br/>  type: NodePort<br/>  selector:<br/>    app: mlflow-tracking-server-pods<br/>  ports:<br/>  - port: 5000<br/>    protocol: TCP<br/>    targetPort: 5000<br/>    nodePort: 30001</span></pre><p id="bbd8" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> 5c。</strong>整合在一起</p><p id="90eb" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">事实上，您可以将几个<code class="fe ov ow ox oy b">.yaml</code>配置放在一个文件中——特别是<em class="mw">部署</em>和<em class="mw">服务</em>配置，因为我们将一起应用这些更改。为此，只需使用<code class="fe ov ow ox oy b">---</code>在一个文件中区分这两个配置:</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="06f1" class="nu lj it oy b gy ps pt l pu pv"># deployment.yaml<br/>apiVersion: v1<br/>kind: Deployment<br/>...<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>...</span></pre><p id="2453" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">最后，我们使用<code class="fe ov ow ox oy b">kubectl apply -f k8s/deployment.yaml</code>应用这些更改。恭喜你。您现在可以通过<code class="fe ov ow ox oy b">&lt;node_IP&gt;:&lt;nodePort&gt;</code>访问您的MLFlow服务器。以下是如何找出你的<code class="fe ov ow ox oy b">node_IP</code>是什么:</p><pre class="ks kt ku kv gt po oy pp pq aw pr bi"><span id="e82b" class="nu lj it oy b gy ps pt l pu pv">kubectl get node -o wide</span><span id="9f98" class="nu lj it oy b gy pw pt l pu pv"># or equivalently:<br/>minikube ip</span></pre><p id="52fd" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd">如果你是苹果芯片或Windows用户… </strong></p><p id="1a01" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated">如果你像我一样使用Darwin(或Windows，WSL)上的Docker驱动程序，使用上述方法将无法直接到达节点IP。完成此<a class="ae lh" href="https://minikube.sigs.k8s.io/docs/handbook/accessing/" rel="noopener ugc nofollow" target="_blank">链接</a>中列出的步骤4和5，以访问您的应用程序。</p><h2 id="4b65" class="nu lj it bd lk nv nw dn lo nx ny dp ls mj nz oa lu mn ob oc lw mr od oe ly iz bi translated">清理</h2><p id="d6af" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">最后，我们完成了测试应用程序，清理就像<code class="fe ov ow ox oy b">minikube delete --all</code>一样简单。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><blockquote class="nj nk nl"><p id="a393" class="ma mb mw mc b md nm kd mf mg nn kg mi no np ml mm nq nr mp mq ns nt mt mu mv im bi translated"><strong class="mc jd">如果您正在使用Kubernetes来设置您的数据科学基础架构，请务必查看一下</strong> <a class="ae lh" href="https://saturncloud.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="mc jd">土星云</strong> </a> <strong class="mc jd">，这是一个可扩展、灵活的数据科学平台，提供包括GPU在内的计算。</strong></p></blockquote></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="62d3" class="li lj it bd lk ll ne ln lo lp nf lr ls ki ng kj lu kl nh km lw ko ni kp ly lz bi translated">最后的话</h1><p id="e814" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">感谢您的阅读，希望这有助于您了解Kubernetes。如果你发现了任何错误，或者你想在另一篇文章中了解更多，请告诉我！</p><p id="91a2" class="pw-post-body-paragraph ma mb it mc b md nm kd mf mg nn kg mi mj np ml mm mn nr mp mq mr nt mt mu mv im bi translated"><strong class="mc jd"> <em class="mw">支持我！</em> </strong> —如果你喜欢我的内容并且<em class="mw">没有</em>订阅Medium，请考虑支持我并通过我在这里的推荐链接<a class="ae lh" href="https://davidcjw.medium.com/membership" rel="noopener">订阅</a> ( <em class="mw">注意:你的一部分会员费将作为推荐费</em>分摊给我)。</p><h1 id="0f34" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">参考</h1><p id="6ecd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">【1】<a class="ae lh" href="https://kubernetes.io/docs/concepts/services-networking/ingress/#what-is-ingress" rel="noopener ugc nofollow" target="_blank">什么是Ingress？</a><br/>【2】<a class="ae lh" href="https://kubernetes.io/docs" rel="noopener ugc nofollow" target="_blank">Kubernetes文档</a><br/>【3】<a class="ae lh" href="https://www.youtube.com/watch?v=s_o8dwzRlu4" rel="noopener ugc nofollow" target="_blank">娜娜的Kubernetes速成班</a><br/>【4】<a class="ae lh" href="https://minikube.sigs.k8s.io/docs/handbook/accessing/" rel="noopener ugc nofollow" target="_blank">访问应用(Minikube) </a></p></div></div>    
</body>
</html>