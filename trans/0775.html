<html>
<head>
<title>Introduction to Simulation with SimPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SimPy 仿真简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-simulation-with-simpy-322606d4ba0c#2022-03-04">https://towardsdatascience.com/introduction-to-simulation-with-simpy-322606d4ba0c#2022-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9364" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第二部分:排队系统的性能测量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6b601a2529c50f13b7d576a3ef47874d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T8Ab5mpPOVWmOIyf"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@unarchive?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰里米·贝赞格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="301e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/introduction-to-simulation-with-simpy-b04c2ddf1900">在之前的文章</a>中，我们提供了关于<strong class="lb iu">离散事件模拟(DES) </strong>的基本概念和原理的概述。我们描述了什么是模拟，什么是模型，什么是 DES，什么是 SimPy。我们介绍了一些在模拟研究中使用的概率和统计的基本概念，以及如何为系统模拟生成概率结果。</p><p id="c36b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将展示如何使用 SimPy 框架<strong class="lb iu">来模拟一个排队系统</strong>。为此，我们将描述一些与排队系统相关的基本概念，这些概念是通常用来衡量此类系统性能的量。</p><h1 id="e351" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">排队系统</strong></h1><p id="6d62" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">离散事件模拟技术最常见的应用是排队系统。他们还将等待排队系统命名为 T17。</p><p id="8571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多产品和服务行业都有一个排队系统，在这个系统中，实体(<strong class="lb iu">顾客、客户</strong>，产品)到达一个站点(服务设施)，在<strong class="lb iu">队列或队列</strong>中等待(或不等待),直到他们获得由<strong class="lb iu">服务器</strong>提供的某种服务，并在结束时离开系统。例如:银行、加油站、卡车称重设施、港口、机场、医疗中心、急诊室、工厂、计算机系统、网络、修理厂和工作人员等。</p><p id="4ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排队系统(等候线系统)由三部分组成:1)到达过程；2)排队或等候过程；3)服务设施。</p><p id="ae3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)<strong class="lb iu">到达流程</strong>是客户到达并请求服务的过程。在现实世界的设施或过程中，到达通常随机发生，并由<strong class="lb iu">概率分布函数</strong>描述。到达过程最重要的特征是到达之间的<strong class="lb iu">时间</strong>(两次连续到达之间的时间)。</p><p id="f72d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多真实世界的系统近似为泊松分布，以描述固定时间段内的到达次数。但是在离散事件模拟技术的<strong class="lb iu">实际应用</strong>中，使用了以下规则:如果单位时间内的到达次数为泊松，则到达之间的时间遵循连续的<strong class="lb iu">指数分布</strong>。</p><p id="f201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与到达过程相关的另一个重要因素是潜在客户的<strong class="lb iu">人口。当它的数量大到到达率不随相继顾客的到达而变化时，假定它是<strong class="lb iu">无穷大</strong>。相反，如果这一比率取决于已经到达并接受服务的人数，则应将其视为<strong class="lb iu">有限人口</strong>。</strong></p><p id="435a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)排队过程的特征在于排队行为、排队规则和等待区域。</p><p id="fc95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">排队行为</strong>指顾客在等待服务时可以采取的行动。最常见的三种是:<strong class="lb iu"> balk </strong>(队伍太长时离开)；<strong class="lb iu">骑师</strong>(从一条线移到一条更短的线)；<strong class="lb iu">食言</strong>(如果队伍移动缓慢，则离开)。</p><p id="9211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">队列规则</strong>与空服务器选择下一个客户机的方式有关。最常见的有:FIFO(先进先出)；后进先出法；优先(通常在急诊室)；车间调度中最短加工时间优先；网络调度程序中的循环调度。</p><p id="6a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排队过程的另一个特征与每个队列中可以等待的顾客数量有关。在某些情况下，这个数字相当大，并不意味着任何实际问题，并且等待区域被认为是无限的。相比之下，当有可能由于等候区空间不足而拒绝几个顾客进入队列时，队列的长度应被认为是<strong class="lb iu">有限的</strong>。</p><p id="c01f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)服务设施的特征在于服务机制和服务费率。</p><p id="7da6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">服务机制</strong>显示了不同的配置:单个服务器(柜员、ATM、急诊室的入院服务、CPU、传送带)；多个服务器，相同或不同(银行柜员、超市收银员)；顺序服务器(垃圾处理系统中的起重机和焚烧炉、制造配置、急诊室)。</p><p id="4c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">服务费率</strong>可以是确定性的，也可以是概率性的。如前所述，现实世界的设施有一些由概率分布描述的随机成分。模拟研究中最常用的是表示服务器处理时间的正态分布或表示排队系统中服务时间分布的指数分布(这种假设很少是可信的)。</p><p id="321f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">总服务成本</strong>由等待成本和服务成本组成。许多模拟研究中的概念想法是<strong class="lb iu">到</strong>T6 确定最小化总服务成本的配置。</p><p id="337b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://en.wikipedia.org/wiki/Kendall%27s_notation" rel="noopener ugc nofollow" target="_blank"> Kendall 符号对排队模型进行描述和分类。</a>我们会在下面的文章中描述。</p><h1 id="6545" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">排队系统的性能测量</strong></h1><p id="581c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">某些数量衡量等待系统的性能。三个最常见的是:1)排队的平均延迟；2)平均排队顾客数；3)服务器忙于服务客户的时间比例。</p><p id="4fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1) <strong class="lb iu">平均排队延迟</strong>衡量“普通顾客”在接受服务前应该等待的时间。</p><p id="3b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2) <strong class="lb iu">时间平均排队顾客数</strong>显示“平均顾客”到达系统时应该看到的排队长度。</p><p id="852e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)服务器忙于服务客户的时间比例称为<strong class="lb iu">服务器利用率</strong>。它测量服务器繁忙时间的百分比。低值意味着服务能力过剩，因此成本效率低。非常高的值意味着<strong class="lb iu">瓶颈的可能性，</strong>因此存在客户流失的可能性。</p><h1 id="d3c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用 SimPy 模拟单服务台排队系统</h1><p id="e814" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用 SimPy 来模拟位于高速公路边的称重站的卡车到达和服务。</p><p id="f8b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该系统的负责人在安装之前，希望确保至少在很长一段时间内，不会有卡车停在路边等待称重。停在公路边的卡车会引起司机的抱怨，并可能引发交通事故。</p><p id="4f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，他们决定聘请一名数据科学家对提议的系统进行模拟研究。</p><p id="41b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他发现卡车会按照平均 3 分钟的指数分布随机到达。称重站的制造商保证称重过程由平均值为 3 分钟、标准偏差为 0.5 的<strong class="lb iu">正态分布</strong>表示。<strong class="lb iu">三辆以上的卡车停在公路边上</strong>是一种危险状况。</p><p id="00cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获得所需性能指标的代码如下:</p><p id="0876" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，他导入了 SimPy，Pandas 作为<em class="ms"> pd，</em> Numpy 作为<em class="ms"> np </em>，以及<em class="ms"> scipy.stats </em>模块，该模块包含了再现遵循指数分布和正态分布的随机数序列的方法(<em class="ms">norm</em>&amp;<em class="ms">expon</em>)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="6e6a" class="my lw it mu b gy mz na l nb nc">import simpy</span><span id="5da6" class="my lw it mu b gy nd na l nb nc">import pandas as pd<br/>import numpy  as np</span><span id="3691" class="my lw it mu b gy nd na l nb nc">from scipy.stats import norm<br/>from scipy.stats import expon</span></pre><p id="6610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，包括一个初始化模块，在该模块中，称重站中存在的秤的数量、队列中可容纳的最大卡车数量、两种分布的参数、模拟结束的时间以及将用于存储中间结果的列表的值被初始化。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="31db" class="my lw it mu b gy mz na l nb nc"># initialization module</span><span id="d1aa" class="my lw it mu b gy nd na l nb nc">NUMBER_TRUCK_SCALES = 1<br/>NOT_ALLOWED_NUMBER  = 4</span><span id="5a75" class="my lw it mu b gy nd na l nb nc">TRUCK_ARRIVAL_MEAN  = 3</span><span id="cfbf" class="my lw it mu b gy nd na l nb nc">TRUCK_SERVICE_MEAN  = 3.0<br/>TRUCK_SERVICE_STD   = 0.5</span><span id="abd0" class="my lw it mu b gy nd na l nb nc">SIM_TIME  = 100</span><span id="570e" class="my lw it mu b gy nd na l nb nc">arrivals, departures = [],[]<br/>in_queue, in_system  = [],[]<br/>tme_in_queue, len_in_queue = [],[]</span></pre><p id="bd73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟算法的核心代码如下。</p><p id="c29e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建一个环境实例。Environment()) 在这里我们可以定义<em class="ms">资源</em>和<em class="ms">进程</em>对象。然后，我们用资源(<em class="ms"> scales_lines = simpy)定义称重站。Resource(env，capacity = NUMBER _ TRUCK _ SCALES)</em>我们选择一个随机种子来生成卡车到达间隔时间和秤服务时间序列。</p><p id="c791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">卡车是我们的活动部件。它们用两个<em class="ms">流程对象建模:1)env . Process(truck _ arrival(env，scales _ lines))；</em> 2) <em class="ms">环境过程(wheighing(env，number_scales，next_truck_id，time_of_arrival)) </em>。最后，我们运行模拟一段预定的时间(<em class="ms">env . run(until = SIM _ TIME)</em>)。Yield 语句被编码以建立离散事件调度。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="27dd" class="my lw it mu b gy mz na l nb nc">def truck_arrival(env, number_scales):</span><span id="c7d0" class="my lw it mu b gy nd na l nb nc">    # IDs for trucks<br/>    next_truck_id = 0</span><span id="4525" class="my lw it mu b gy nd na l nb nc">    while True:<br/>       ## exponential distribution for arrivals<br/>       next_truck = expon.rvs(scale = TRUCK_ARRIVAL_MEAN, size = 1)</span><span id="0b5d" class="my lw it mu b gy nd na l nb nc">       # Wait for the truck<br/>       yield env.timeout(next_truck)<br/>       time_of_arrival = env.now<br/>       arrivals.append(time_of_arrival)<br/>       next_truck_id += 1<br/>       print('%3d arrives at %.2f' % (next_truck_id, env.now))<br/>       <br/>       env.process(wheighing(env, number_scales, <br/>                   next_truck_id,time_of_arrival))</span><span id="b3d7" class="my lw it mu b gy nd na l nb nc">#..................................................................</span><span id="e682" class="my lw it mu b gy nd na l nb nc">def wheighing(env, number_scales, truck_number, time_of_arrival):</span><span id="5feb" class="my lw it mu b gy nd na l nb nc">    with scales_lines.request() as req:</span><span id="b86d" class="my lw it mu b gy nd na l nb nc">        print('%3d enters the queue at %.2f' % <br/>               (truck_number, env.now))</span><span id="d727" class="my lw it mu b gy nd na l nb nc">        queue_in = env.now<br/>        length   = len(scales_lines.queue)<br/>        tme_in_queue.append(queue_in)<br/>        len_in_queue.append(length)</span><span id="e431" class="my lw it mu b gy nd na l nb nc">        yield req<br/>        print('%3d leaves the queue at %.2f' % <br/>                (truck_number, env.now))</span><span id="b08b" class="my lw it mu b gy nd na l nb nc">        queue_out = env.now<br/>        length    = len(scales_lines.queue)<br/>        tme_in_queue.append(queue_out)<br/>        len_in_queue.append(length)</span><span id="a443" class="my lw it mu b gy nd na l nb nc">        # normal distribution for the weighing process<br/>        r_normal = norm.rvs(loc =TRUCK_SERVICE_MEAN,<br/>                            scale =TRUCK_SERVICE_STD,size=1)</span><span id="1501" class="my lw it mu b gy nd na l nb nc">        yield env.timeout(r_normal)<br/>        print('%3d permanece %.2f' % (truck_number,r_normal))</span><span id="e853" class="my lw it mu b gy nd na l nb nc">        time_of_departure = env.now<br/>        departures.append(time_of_departure)</span><span id="319b" class="my lw it mu b gy nd na l nb nc">        time_in_system = time_of_departure - time_of_arrival<br/>        in_system.append(time_in_system)</span><span id="1f32" class="my lw it mu b gy nd na l nb nc">        time_in_queue = queue_out - queue_in<br/>        in_queue.append(time_in_queue)</span><span id="c799" class="my lw it mu b gy nd na l nb nc">#.................................................................</span><span id="278b" class="my lw it mu b gy nd na l nb nc">## set up the environment<br/>env = simpy.Environment()</span><span id="e194" class="my lw it mu b gy nd na l nb nc">## defining resources<br/>scales_lines = simpy.Resource(env, capacity = NUMBER_TRUCK_SCALES)</span><span id="ca90" class="my lw it mu b gy nd na l nb nc">## selecting a random seed for the probability distributions<br/>RANDOM_SEEDS = [1234, 5678, 9012, 3456, 7890]<br/>np.random.seed(seed= RANDOM_SEEDS[1])</span><span id="6503" class="my lw it mu b gy nd na l nb nc">## defining the truck arrival process<br/>env.process(truck_arrival(env, scales_lines))</span><span id="bae6" class="my lw it mu b gy nd na l nb nc">## run the simultion<br/>env.run(until = SIM_TIME)</span></pre><p id="5476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，描述用于计算队列长度的时间加权平均值、服务器利用率和不允许等待的卡车在队列中的时间百分比的例程:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c2f8" class="my lw it mu b gy mz na l nb nc">def avg_line(df_length):</span><span id="5798" class="my lw it mu b gy nd na l nb nc">   ## finds the time average number of customers in the waiting line</span><span id="c5d1" class="my lw it mu b gy nd na l nb nc">   ## use the next row to figure out how long the queue was   </span><span id="301f" class="my lw it mu b gy nd na l nb nc">   df_length['delta_time'] = df_length['time'].shift(-1) <br/>                            - df_length['time']</span><span id="6e1b" class="my lw it mu b gy nd na l nb nc">   ## drop the last row because it would have an infinite delta time </span><span id="5f29" class="my lw it mu b gy nd na l nb nc">   df_length = df_length[0:-1]</span><span id="172f" class="my lw it mu b gy nd na l nb nc">   avg =np.average(df_length['len'],weights=df_length['delta_time'])</span><span id="d76b" class="my lw it mu b gy nd na l nb nc">   return avg</span><span id="b6b8" class="my lw it mu b gy nd na l nb nc">#.................................................................</span><span id="d71d" class="my lw it mu b gy nd na l nb nc">def server_utilization(df_length):</span><span id="645e" class="my lw it mu b gy nd na l nb nc">   ## finds the server utilization </span><span id="0ce0" class="my lw it mu b gy nd na l nb nc">   sum_server_free = df_length[df_length['len']==0]  ['delta_time'].sum()</span><span id="6ecc" class="my lw it mu b gy nd na l nb nc">   ## the process begins with the server empty<br/>   first_event =  df_length['time'].iloc[0]<br/>   sum_server_free = sum_server_free + first_event</span><span id="ba40" class="my lw it mu b gy nd na l nb nc">   utilization = round((1 - sum_server_free / SIM_TIME) * 100, 2)</span><span id="395d" class="my lw it mu b gy nd na l nb nc">   return utilization</span><span id="6b35" class="my lw it mu b gy nd na l nb nc">#..................................................................</span><span id="8f22" class="my lw it mu b gy nd na l nb nc">def not_allowed_perc(df_length):</span><span id="22c1" class="my lw it mu b gy nd na l nb nc">   ## finds the percentage of time of trucks on queue<br/>      not allowed to be waiting</span><span id="5102" class="my lw it mu b gy nd na l nb nc">   sum_not_allowed = df_length[df_length['len']&gt;=  NOT_ALLOWED_NUMBER]['delta_time'].sum()</span><span id="9d2d" class="my lw it mu b gy nd na l nb nc">   not_allowed = round((sum_not_allowed / SIM_TIME) * 100, 2)</span><span id="0093" class="my lw it mu b gy nd na l nb nc">   return not_allowed</span></pre><p id="dbae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将列表转换为数据帧，计算绩效指标并打印:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c8ea" class="my lw it mu b gy mz na l nb nc">df1 = pd.DataFrame(tme_in_queue, columns = ['time'])<br/>df2 = pd.DataFrame(len_in_queue, columns = ['len'])<br/>df_length = pd.concat([df1, df2], axis = 1)</span><span id="6a67" class="my lw it mu b gy nd na l nb nc">avg_length  = avg_line(df_length)</span><span id="dca9" class="my lw it mu b gy nd na l nb nc">utilization = server_utilization(df_length)</span><span id="c04f" class="my lw it mu b gy nd na l nb nc">not_allowed = not_allowed_perc(df_length)</span><span id="700c" class="my lw it mu b gy nd na l nb nc">df3 = pd.DataFrame(arrivals,   columns = ['arrivals'])<br/>df4 = pd.DataFrame(departures, columns = ['departures'])<br/>df_chart = pd.concat([df3, df4], axis = 1)</span><span id="642b" class="my lw it mu b gy nd na l nb nc">avg_delay_inqueue = np.mean(in_queue)</span><span id="f320" class="my lw it mu b gy nd na l nb nc">avg_delay_insyst  = np.mean(in_system)</span><span id="d3be" class="my lw it mu b gy nd na l nb nc">print('  ')<br/>print('The average delay in queue is %.2f'  % (avg_delay_inqueue))<br/>print('The average delay in system is %.2f' % (avg_delay_insyst))<br/>print('The average number of trucks in queue is %.2f' %  (avg_length))<br/>print('The utilization of the server is %.2f' % (utilization))<br/>print('The probability of not allowed trucks in queue is %.2f' % (not_allowed))</span></pre><p id="35ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，一个图表显示了称重站的到达和离开，另一个图表显示了队列中卡车数量的变化:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="30d5" class="my lw it mu b gy mz na l nb nc">import plotly.graph_objects as go</span><span id="bcbe" class="my lw it mu b gy nd na l nb nc">fig1 = go.Figure()</span><span id="3d7d" class="my lw it mu b gy nd na l nb nc">fig1.add_trace(go.Scatter(x = df_chart['arrivals'],<br/>                          mode = 'markers',name = 'Arrivals'))</span><span id="1274" class="my lw it mu b gy nd na l nb nc">fig1.add_trace(go.Scatter(x = df_chart['departures'], <br/>                          mode = 'markers',name = 'Departures'))</span><span id="ebce" class="my lw it mu b gy nd na l nb nc">fig1.update_layout(title = 'Arrivals &amp; Departures <br/>           at the Weighing Station',<br/>           xaxis_title = 'Time' , yaxis_title = 'Truck ID',<br/>           width = 800, height = 600)<br/>fig1.show()</span><span id="0785" class="my lw it mu b gy nd na l nb nc">fig2 = go.Figure(go.Waterfall(x = df_length['time'],<br/>                              y = df_length['len'],<br/>                              measure = ['absolute']* 100,<br/>                              connector = {"line":{"color":"red"}}))</span><span id="69e1" class="my lw it mu b gy nd na l nb nc">fig2.update_layout(title = 'Number of Trucks in Queue',<br/>          xaxis_title = 'Time' , yaxis_title = 'Number of Trucks',<br/>          width = 800, height = 600)<br/>fig2.show()</span></pre><h1 id="4d73" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">分析</strong></h1><p id="983f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一辆卡车平均要等 5.77 分钟才能得到服务。称重系统的平均延迟为 8.71 分钟。平均来说，大约有 2 辆卡车在排队。服务器的利用率很高，空闲时间很少，没有瓶颈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/f3979f8a55c59a0253151dda53e0e582.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHRD43Ej7zVKMABZtTUAZA.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/567a3c1799c6dc8465e409048bb105ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZF65WGd84CFSSFhE_ADowQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者用 Plotly 制作的图表。</p></figure><p id="4c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管上述所有性能指标都在可接受的范围内，但在系统运行时间的 15.82%中，有危险数量的卡车停在公路边。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/96980db922073c549ae37e16b14b1daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlHlYl8F5Cw-oDS1d1yJJA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者用 Plotly 制作的图表。</p></figure><p id="a6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我们将看到提出了哪些替代方案来解决这个问题。使用模拟技术的最大优点是评估所提出的系统，就像它实际存在一样。</p><p id="ebda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别忘了订阅我的电子邮件来接收下面的文章。</p></div></div>    
</body>
</html>