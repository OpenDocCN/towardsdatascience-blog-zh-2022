<html>
<head>
<title>Develop and Deploy Serverless Event-Driven Machine Learning Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发和部署无服务器事件驱动的机器学习应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/develop-and-deploy-serverless-event-driven-applications-using-zappa-flask-and-aws-f39b817a9937#2022-07-04">https://towardsdatascience.com/develop-and-deploy-serverless-event-driven-applications-using-zappa-flask-and-aws-f39b817a9937#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27ba" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Zappa、Python、Flask和AWS创建托管机器学习模型的应用编程接口(API)</h2></div><h2 id="a414" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">目录:</h2><h2 id="ede3" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">1.无服务器介绍<br/> 2。AWS <br/> 3上的IAM权限。开发烧瓶应用程序<br/> 4。用Zappa <br/> 5展开。用密钥保护API</h2><h1 id="18dd" class="le kj it bd kk lf lg lh kn li lj lk kq jz ll ka ku kc lm kd ky kf ln kg lc lo bi translated">1.介绍</h1><p id="bd10" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">随着全球各地的公司开始扩大其数据科学和机器学习能力，通过无服务器计算部署端点的过程在最近几个月出现了大幅增长。根据最近一篇关于DataDog [1]的文章，大多数云提供商(AWS、GCP等)的无服务器架构正在被超过50%的客户主流采用。尽管这种适应性的重大变化有多种驱动因素和原因，但在本文开始时，有一点很重要，即虽然无服务器计算可能是许多应用程序的最佳解决方案，但它肯定不是所有应用程序的最佳解决方案。记住这一点，让我们仔细看看无服务器方法的一些关键优势。</p><h2 id="0335" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">关注业务逻辑——“关注什么，而不是如何”</h2><p id="3a87" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">随着数据科学家开始处理他们的项目，他们经常面临如何将他们的应用程序部署到云的难题，这迫使他们有时更多地关注部署过程，而不是模型本身的开发。无服务器计算的最大优势之一是它的易用性，我们将在本章后面看到。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/594fca6c835c192714df47f10ad75fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dnqpvSrTrFBwlRuu"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图1——该图显示了对业务逻辑的关注增加，而对架构的关注减少的趋势。(图片由作者提供)</p></figure><h2 id="1b82" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">高效、可扩展且强大—“可扩展性始终是关键”</h2><p id="1860" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">无服务器基础架构的另一个巨大优势是能够以“随用随付”的方式按需扩展和缩减。提供商处理几乎所有与可伸缩性相关的项目，并管理所需的资源。然而，这是以限制对特定运行时设置的访问为代价的。如图2所示，根据需要扩展和缩减的能力也大大有助于节省成本。我们在这里可以看到，传统的可伸缩性是逐步增加的，而无服务器的可伸缩性更加线性。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mi"><img src="../Images/31130a971e1853d2f38a0b45efe340ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MW8EN5HmSHTwOk9z"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图2 —展示无服务器计算相对于传统方法的可扩展性的图表(图片由作者提供)</p></figure><h2 id="e638" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">方便且易于部署</h2><p id="61cd" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">相对于全服务器架构，无服务器架构提供了许多优势。最大的优势之一是在部署基础架构和之后进行管理时的易用性。Zappa可以使用CloudFormation来处理这两个项目，cloud formation本质上是IaC(基础设施即代码)。记住这一点，让我们开始吧！</p><h1 id="1719" class="le kj it bd kk lf lg lh kn li lj lk kq jz ll ka ku kc lm kd ky kf ln kg lc lo bi translated">2.AWS上的IAM权限</h1><p id="47b9" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">在开始使用Zappa之前，让我们先在AWS中按顺序获取权限。首先，在AWS中导航到IAM，单击用户组，并创建一个新组。我们可以称这个群为“zappa_group”。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/603c7a1c55ac9f063acfe980fb7404b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*xuTjo1kCgPxc7QjiAKCv0A.png"/></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图AWS的IAM菜单。(作者截图)</p></figure><p id="065b" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">创建组后，单击“添加权限”，然后单击“创建内联策略”。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ne"><img src="../Images/a3818b7d57cd9bb0a5abcca6bf462dc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CivNB9YWYkY8p5n6x-Rjtg.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图AWS的IAM下拉菜单。(作者截图)</p></figure><p id="8c0c" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">单击JSON选项卡，并向其中添加以下策略:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="a498" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">这个策略将使Zappa能够创建基础设施，并相应地为您标记它。请注意，您需要将AWS_ACCOUNT_NUMBER更改为您各自的号码。您可以通过单击屏幕右上角的用户名在下拉选项卡中找到它。</p><p id="2b59" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">现在导航到“用户”并创建一个新用户。我们可以称这个用户为“zappa_user”。如果你觉得更有创意，请随意更改名称！将用户添加到您创建的组中，以赋予用户适当的权限。完成后，请务必记下访问密钥和密码。</p><p id="71be" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">导航到您的终端命令行，并添加您的密钥。您可以使用vim在本地编辑aws密钥文件:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="b582" class="ki kj it ni b gy nm nn l no np">vim ~/.aws/credentials</span></pre><p id="0a8d" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">进入编辑器后，单击“I”插入新内容，并添加您的密钥。如果您已经有一个名为default的配置文件，我建议您创建一个名为“zappa”的新配置文件:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="5cab" class="ki kj it ni b gy nm nn l no np">[zappa] <br/>aws_access_key_id = ADD_KEY_HERE <br/>aws_secret_access_key = ADD_SECRET_HERE</span></pre><p id="87a4" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">至此，我们已经完成了AWS上的权限，现在可以把注意力转移到Zappa上了。</p><h1 id="8c45" class="le kj it bd kk lf lg lh kn li lj lk kq jz ll ka ku kc lm kd ky kf ln kg lc lo bi translated">3.开发烧瓶应用程序</h1><p id="839c" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">现在我们有了一些关于无服务器方法的背景知识，让我们继续准备一个Flask应用程序。我们的目标是使用scikit-learn训练一个简单的机器学习模型，保存工件，并将其加载到Flask API中。</p><p id="ade9" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">我们可以从创建一个新目录开始，输入目录:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="ea1d" class="ki kj it ni b gy nm nn l no np">mkdir sklearn-zappa-ml-with-preprocessing</span><span id="bee5" class="ki kj it ni b gy nq nn l no np">cd sklearn-zappa-ml-with-preprocessing</span></pre><p id="fbc3" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">现在让我们创建一个名为“venv”的新虚拟环境并激活它:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="ffe2" class="ki kj it ni b gy nm nn l no np">virtualenv venv</span><span id="4e5c" class="ki kj it ni b gy nq nn l no np">source venv/bin/activate</span></pre><p id="0534" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">现在让我们继续安装感兴趣的库。对于本教程，我们当然需要zappa来进行部署，flask来构建应用程序，scikit-learn来管理我们的模型，joblib来保存和加载我们的模型:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="5842" class="ki kj it ni b gy nm nn l no np">pip install zappa scikit-learn flask joblib</span></pre><p id="ffc6" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">安装完我们的库后，让我们再次激活虚拟环境:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="bb30" class="ki kj it ni b gy nm nn l no np">source venv/bin/activate</span></pre><p id="9c10" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">让我们继续创建一个名为train的新目录和另一个名为models的目录，在train目录中，我们将创建一个名为<em class="nr"> train.py </em>的文件:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="03e7" class="ki kj it ni b gy nm nn l no np">mkdir train<br/>mkdir models<br/>cd train<br/>vim train.py</span></pre><p id="93dd" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">在train.py文件中，我们将添加以下代码:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c140" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">回想一下，我们在这里的目标是训练一个样本模型，并演示我们可以加载分类器本身，以及预处理工件。如果您检查models目录，您现在应该看到两个joblib文件。</p><p id="e8ce" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">回到主目录，我们现在创建一个名为app.py的新文件:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="6e53" class="ki kj it ni b gy nm nn l no np">vim app.py</span></pre><p id="fe85" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">在这个文件中，我们将准备我们的API框架。我们将导入我们的库，加载模型，并准备两条路径:一条路径到主目录“/”，另一条路径到“/predict”:</p><figure class="mj mk ml mm gt mn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c3b1" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">到目前为止，我们应该有以下目录结构:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="7c6d" class="ki kj it ni b gy nm nn l no np">sklearn-zappa-ml-with-preprocessing<br/>    |__ venv</span><span id="503f" class="ki kj it ni b gy nq nn l no np">    |__ models<br/>        |__ rfc.joblib<br/>        |__ scaler.joblib</span><span id="27d6" class="ki kj it ni b gy nq nn l no np">    |__ train<br/>        |__ train.py</span><span id="78d8" class="ki kj it ni b gy nq nn l no np">    |__ app.y</span></pre><p id="1f6c" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">我们可以通过运行Flask服务器来测试我们的模型:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="957b" class="ki kj it ni b gy nm nn l no np">python3 app.py</span></pre><p id="6b7a" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">使用Postman [2]，您可以通过创建针对本地服务器的POST请求来测试API:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ns"><img src="../Images/aa509d2ce3d7ea15cf3a60ce93bd6169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7U45yypdTvWrzDHEpSZ4w.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图5—显示POST请求的Postman应用程序的屏幕截图，带有示例输入数据(作者的屏幕截图)</p></figure><h1 id="bbac" class="le kj it bd kk lf lg lh kn li lj lk kq jz ll ka ku kc lm kd ky kf ln kg lc lo bi translated">4.使用Zappa部署</h1><p id="ecb6" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">既然我们已经确认了我们的应用程序可以在本地工作，现在让我们开始配置Zappa。我们可以从使用Zappa中的init函数开始:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="13fe" class="ki kj it ni b gy nm nn l no np">zappa init</span></pre><p id="a046" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">当您完成初始化过程时，会要求您提供一些项目:</p><ul class=""><li id="16f8" class="nt nu it lr b ls mz lv na kr nv kv nw kz nx mh ny nz oa ob bi translated"><strong class="lr iu">环境</strong>:您可以指定感兴趣的环境，比如dev、test或prod。出于本教程的目的，请输入“dev”</li><li id="e41a" class="nt nu it lr b ls oc lv od kr oe kv of kz og mh ny nz oa ob bi translated"><strong class="lr iu">应用程序路径</strong>:这里你需要设置主应用程序的路径。我们可以使用默认值“app.app”</li><li id="a598" class="nt nu it lr b ls oc lv od kr oe kv of kz og mh ny nz oa ob bi translated"><strong class="lr iu">桶名</strong>:您可以在这里指定感兴趣的AWS S3桶。我建议您保留默认值，让Zappa为您处理这个问题。</li><li id="9e0c" class="nt nu it lr b ls oc lv od kr oe kv of kz og mh ny nz oa ob bi translated">全局:你可以使用这个特性来优化分配。出于本教程的目的，输入“n ”,这是跳过此功能的默认值。</li></ul><p id="45ad" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">完成此过程后，Zappa将在您的当前目录中生成一个名为zappa_settings.json的文件。继续操作并打开该文件以检查设置。打开文件，继续添加两个新的键值对:“slim_handler”和“tags”。slim_handler配置将用于优化部署过程，因为我们使用的是scikit-learn——一个相对较大的库。此外,“标签”将用于确保我们创建的基础架构被适当标记，以用于组织和计费目的。</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="a8ca" class="ki kj it ni b gy nm nn l no np">{<br/>“dev”: {<br/>    “app_function”: “app.app”,<br/>    “profile_name”: “zappa”,<br/>    “project_name”: “sklearn-zappa-m”,<br/>    “runtime”: “python3.8”,<br/>    “s3_bucket”: “zappa-123456789”,<br/>    “slim_handler”: true,<br/>    “tags”: {<br/>        “Project”: “ZappaProject”,<br/>        “Stage”: “dev”<br/>        }<br/>    }<br/>}</span></pre><p id="526f" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">确认设置正确后，现在可以使用以下命令部署API了:</p><pre class="mj mk ml mm gt nh ni nj nk aw nl bi"><span id="9a1f" class="ki kj it ni b gy nm nn l no np">zappa deploy dev</span></pre><p id="4a1c" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">这将继续并准备您的基础设施，以服务于我们之前准备的Flask端点。最后，需要了解两个主要组件:管理API外部流量的API Gateway，以及包含应用程序逻辑的脚本AWS Lambda。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oh"><img src="../Images/7fa46a393e72f4fb0c27f1438a7d6c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wwE84c9pVfbq45g6"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图AWS架构的表示(图片由作者提供)</p></figure><p id="63b7" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">完成部署过程后，Zappa将向您返回一个URL，其结构如下所示:</p><p id="4f78" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated"><a class="ae oi" href="https://xg7dv0vv93.execute-api.us-east-2.amazonaws.com/dev" rel="noopener ugc nofollow" target="_blank">https://123456789.execute-api.us-east-2.amazonaws.com/dev</a></p><p id="d87d" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">您可以使用postman再次测试应用程序的部署，并在上面的URL末尾添加“/predict”。您应该会收到一个状态为200的成功响应，与我们之前看到的类似。</p><h1 id="8930" class="le kj it bd kk lf lg lh kn li lj lk kq jz ll ka ku kc lm kd ky kf ln kg lc lo bi translated">5.用密钥保护API</h1><p id="e488" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx kr ly lz ma kv mb mc md kz me mf mg mh im bi translated">既然已经成功部署了API，现在全世界都可以看到和使用它了。在许多情况下，我们的API端点可能是保密的，我们只想授予特定用户或应用程序访问权限。我们可以使用两种方法之一来实现这一点:API密钥和IAM权限。让我们看一个使用API键实现这一点的例子。</p><p id="1caa" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">继续操作，在您的AWS帐户上导航到API Gateway。您应该能够看到刚刚部署的应用程序列在该页面中。如果没有，请确保选择了正确的区域。</p><p id="187d" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">点击API，然后点击左侧的Resources。单击名为{proxy+}的资源，您将看到类似下图的内容:</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi oj"><img src="../Images/c95cd8eedc06360c875a7f2c143aec35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hZ_Pwq4EKJwT6zSTY9V9g.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图7 —来自AWS API网关的屏幕截图。(作者截图)</p></figure><p id="e977" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">您可以看到API键当前被设置为“不需要”。继续点击下面的“任何”和“方法请求”。将“需要API密钥”更改为True。注意，为了使用它，我们需要<strong class="lr iu">和</strong>都生成一个密钥，并将其添加到一个使用计划中。</p><p id="01b6" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">您可以通过单击屏幕左侧的API密钥来生成密钥。单击“操作”，然后单击“创建API密钥”。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ok"><img src="../Images/05e32bfaf0d13f10182e0fb42b533885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i3Lp99LfhxhGqDjb3rppZA.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图8—显示AWS上API键下拉菜单的屏幕截图(作者截图)</p></figure><p id="a3e4" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">接下来，继续创建新的使用计划。为计划命名和描述，然后根据需要设置限制和配额设置。单击next，然后将API密钥添加到使用计划中。</p><p id="2e48" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">这样，你现在应该都准备好了。您可以在Postman上测试密钥，方法是将密钥添加到您的请求的标头中。密钥应该是“x-api-key”，值应该是您生成的密钥。</p><figure class="mj mk ml mm gt mn gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ol"><img src="../Images/99e082b086c9f8a88316223d06d89dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AKLX59lygyOZIrP0BduJbw.png"/></div></div><p class="mu mv gj gh gi mw mx bd b be z dk translated">图9 —添加了api键的postman请求(作者截图)</p></figure><p id="280f" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">这样，您现在就有了一个在AWS上部署和保护的无服务器机器学习模型！概括地说，这种模型部署方法的主要优点之一是，您将使用“随用随付”模型，确保您不会收到无意义的账单，即使在不活动时也是如此。</p><p id="5943" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">参考资料:</p><p id="f41c" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">[1]<a class="ae oi" href="https://www.prnewswire.com/news-releases/datadogs-2022-state-of-serverless-report-finds-serverless-reaching-mainstream-adoption-301560418.html" rel="noopener ugc nofollow" target="_blank">https://www . prnewswire . com/news-releases/data dogs-2022-state-of-server less-report-finds-server less-reaching-mainstream-adoption-301560418 . html</a></p><p id="a2ed" class="pw-post-body-paragraph lp lq it lr b ls mz ju lu lv na jx lx kr nb lz ma kv nc mc md kz nd mf mg mh im bi translated">[2]https://www.postman.com/<a class="ae oi" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>