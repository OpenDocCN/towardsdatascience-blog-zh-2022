<html>
<head>
<title>Classical Strategies for Scaling up Graph Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">放大图形神经网络的经典策略</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/classical-strategies-for-scaling-up-graph-neural-networks-69dd10cd21a#2022-07-18">https://towardsdatascience.com/classical-strategies-for-scaling-up-graph-neural-networks-69dd10cd21a#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e14" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">总结了使网络运行速度更快、占用内存更少的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fdf432976ef9b266e6f445a45f6636ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o3zlMFPWd7MwRP6u"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">纳斯蒂亚·杜尔希尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9472" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" rel="noopener" target="_blank" href="/how-to-create-a-graph-neural-network-in-python-61fd9b83b54e">我之前的帖子</a>中，我谈到了图形神经网络(GNNs)如何成为一个热门的研究主题，因为在复杂网络(图形)的深度学习相关任务上取得了进展。</p><p id="e097" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这是一个如此重要的主题，许多研究都集中在改进GNNs上。有两个主要目标:使它们更强大(就预测性能而言)并使它们运行得更快，消耗的内存更少。</p><p id="d01c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本帖中，我们将看到，今天，使用消息传递框架的传统gnn训练起来非常慢，并且需要大量的内存。我假装指导你一些已经到位的策略，尝试将gnn扩展到非常大的图。</p><h1 id="7ca1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">分析消息传递框架的复杂性</h1><p id="2af7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">消息传递框架包括聚集来自节点邻居的信息以及节点本身的信息，以生成节点表示。</p><p id="edcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经在<a class="ae kv" rel="noopener" target="_blank" href="/how-to-create-a-graph-neural-network-in-python-61fd9b83b54e">这篇文章</a>中看到了一点这是如何工作的，以及它与<a class="ae kv" rel="noopener" target="_blank" href="/testing-if-two-graphs-are-isomorphic-cf6c44ab551e">这篇文章</a>中的WL测试的关系。现在，让我们评估一下拥有一个大图的深度网络可能有多困难。</p><p id="94dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们记住，每增加一层GNN就意味着网络上多了一跳。</p><p id="f529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们看看GraphSAGE [1]架构，它为每层上的每个节点选择固定数量的邻居，我们可以看到内存消耗是如何开始失控的。</p><p id="f731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设F为网络的X数据集上的要素数，L为图层数。首先，你将有一个O(LF)的内存消耗来保存网络的权重矩阵。这本身问题不大。</p><p id="1eff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来看看内存消耗，它来自于在内存中保存节点的嵌入，这是为了在训练期间计算每个目标节点的嵌入而需要的。</p><p id="6892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设b是批量大小，r是使用GraphSAGE采样的节点数。让我们假设每层采样相同数量的节点。在这种情况下，您需要的内存量将是O(bFr^L).关于这种计算的更多信息可以在[2]中找到</p><p id="5b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题在于网络层数之间的指数关系。这说明了为什么现在存在的一些架构不能超越3或4层。</p><p id="9716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(<em class="mp">这里需要注意的是，一些研究指出，深入研究GNNs可能不会带来性能提升，然而，这一讨论超出了本文的范围</em>)。</p><p id="ed2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们回顾一下研究人员为了改善GNNs的可扩展性问题而采用的一些策略。</p><h1 id="3f2b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">取样方法</h1><p id="889a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">采样方法试图通过对计算图进行采样来减少我们在任何给定时间点需要处理的节点数量。根据取样的方式和地点，我们可以有三种不同的分类。</p><h2 id="0938" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">节点采样</h2><p id="7fbd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是我们刚刚看到的GraphSAGE实现的方法。其思想是，在训练期间，我们可能不需要考虑整个节点邻域，而是可以选择一些节点。</p><p id="f5df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，这仍然带来了复杂性问题。此外，随机采样可能不是一个好策略，因为没有选择这些节点的标准，这可能会对性能产生负面影响。</p><h2 id="03a0" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">子图采样</h2><p id="0a3a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">子图采样背后的想法是，可能有一种方法可以将一个非常大的复杂网络分成更小的组件，然后在训练期间批量处理这些组件。这种方法有两个主要的例子:ClusterGCN [2]和GraphSAINT [3]。</p><p id="2c41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ClusterGCN在训练之前对图应用聚类算法(或社区检测算法)。因此，通过生成几个聚类(子图)，就有了一批随时可用的子图。</p><p id="d618" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，GraphSAINT有一些采样方法，考虑到采样的重要性和偏差，定义哪些节点和哪些边应该添加到采样的子图中。</p><p id="34bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种方法都成功地改善了模型训练的时间和记忆复杂性。然而，两者都包括生成子图的潜在缓慢的预处理步骤。此外，他们有一些假设，现在可以推广到每一个网络。例如，如果图上没有社区结构会发生什么？ClusterGCN在这些情况下可能不太好用。</p><h2 id="a3ae" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">分层取样</h2><p id="6da7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">层采样策略包括对每个层上要考虑的节点进行采样。请注意，这不同于节点采样。在节点采样中，每个节点都经过每一层，只是计算邻居的变化。在图层采样中，一个图层可能根本没有一个节点。</p><p id="211e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种策略的主要例子是FastGCN [4]。该架构假设节点之间独立，然后应用一些蒙特卡罗近似来生成采样。</p><p id="3837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这里节点之间的独立性是一个非常强的假设。我们正在处理一个图，根据定义，节点之间有某种关系(一条边)。</p><h1 id="1a52" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">通过预计算简化架构</h1><p id="b74d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">另一类扩展GNNs的策略是简化架构。这种策略背后的想法是打破经典GCN论文[5]中定义的消息传递框架，支持另一种类型的架构，通过预计算更好地扩展。我们将探索这种架构的两个例子。</p><h2 id="913d" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">简化图形卷积神经网络(SGC)</h2><p id="ec32" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">该架构[6]始于这样一个假设，即产生GNNs良好性能的是邻居的聚合，而不是GNN各层之间的非线性(ReLU等)。</p><p id="0848" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你去除非线性，你会看到整个GNN开始看起来像一个矩阵乘法序列。以三层网络为例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/3a246b84ac215f7f2164781ceff96c25.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*a-XRKhFaHKxr__YMQ7cWMw.png"/></div></figure><p id="ef38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中S是归一化邻接矩阵，X是特征向量，P是网络层的权重矩阵。</p><p id="ad8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以清楚地看到，这些乘法运算的整个左侧不依赖于网络的权重。这意味着我们可以在训练网络之前将其相乘。</p><p id="550c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该体系结构的作者表明，这种方法与传统的GNNs相比是有竞争力的，表明人们可以消除网络的非线性，并预先计算大量以前在训练期间会发生的信息。</p><h2 id="c8f6" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">可扩展初始图神经网络(SIGN)</h2><p id="159c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个架构[7]是基于计算机视觉领域的初始网络。这个网络背后的基本思想是，人们可以预先计算多个没有可训练权重的聚合，然后在一个模型上连接它们以生成嵌入。</p><p id="29bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与SGC的想法非常相似。在SIGN上，该架构的作者预计算网络的每种类型的跳(通过对邻接矩阵求幂)，然后将其乘以特征矩阵，并且只有在那时他们才使用下游模型。</p><p id="f397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自这两个架构的想法表明，预计算是一个非常突出的研究领域，可以为GNNs产生非常强大的结果</p><h1 id="f265" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="3ddb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这绝不是对图形神经网络的缩放方法的广泛回顾。然而，我希望这能够向您展示一些最著名的方法，以及它们如何在扩展gnn的大背景下相互配合。</p><p id="180f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1]汉密尔顿，威廉&amp;英，雷克斯&amp;莱斯科维奇，朱尔。(2017).大型图上的归纳表示学习。</p><p id="41a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]蒋、刘维林、宣庆、李、杨、谢、曹瑞。(2019).聚类GCN:一种训练深度和大型图卷积网络的有效算法。</p><p id="aa37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]曾、韩青&amp;周、洪宽&amp;斯里瓦斯塔瓦、阿吉特什&amp;坎南、拉杰戈帕尔&amp;普拉桑纳、维克托。(2020).GraphSAINT:基于图抽样的归纳学习方法。</p><p id="0cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]陈、马杰、曹腾飞、萧。(2018).FastGCN:通过重要性抽样快速学习图形卷积网络。ICLR。</p><p id="71d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[5]基普夫，托马斯&amp;韦林，马克斯。(2016).基于图卷积网络的半监督分类。</p><p id="4941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[6]吴，费里克斯&amp;张，天一&amp;苏扎，Jr &amp;五十，克里斯托弗&amp;余，陶&amp;温伯格，基连。(2019).简化图形卷积网络。</p><p id="0dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[7]罗西，伊曼纽&amp;弗拉斯卡，法布里齐奥&amp;张伯伦，本&amp;埃纳德，大卫&amp;布朗斯坦，迈克尔&amp;蒙蒂，费德里科。(2020).SIGN:可扩展初始图神经网络。</p></div></div>    
</body>
</html>