<html>
<head>
<title>Newton-Raphson — Explained and Visualised</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">牛顿-拉夫森——解释和可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/newton-raphson-explained-and-visualised-23f63da21bd5#2022-02-10">https://towardsdatascience.com/newton-raphson-explained-and-visualised-23f63da21bd5#2022-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="420e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解牛顿拉夫森算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/dfb6e7907e821c2a68a29b0be01d6713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_WnGjS0CTe1kCJ_hQm1amg.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">牛顿-拉夫森方法(图片由作者提供)</p></figure><p id="e4ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以艾萨克·牛顿和约瑟夫·拉弗森命名的牛顿-拉夫森方法是一种设计的求根算法，这意味着它的目标是找到函数<em class="lq"> f(x)=0 </em>的值<em class="lq"> x </em>。从几何学上讲，我们可以把它看作是目标函数穿过轴<em class="lq"> x </em>时的<em class="lq"> x </em>的值。</p><p id="6e3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，用例并没有就此结束，事实上，这个算法对于跨越许多领域的广泛用例来说是非常通用的。例如，通过重新构造感兴趣的函数，您可以搜索<em class="lq"> x </em>的值，从而产生您选择的值，而不是被限制为0。</p><p id="7017" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实践中的一个复杂用例是使用Black-Scholes公式反解金融期权合同的隐含波动率。然而，牛顿-拉夫森算法也可以用于一些简单的事情，如回解，以找到你需要在期末考试中获得多少分数才能在给定的连续评估成绩中获得A。事实上，如果你曾经使用过微软Excel中的<em class="lq">求解器</em>功能，那么你可能使用过像牛顿-拉夫森这样的求根算法。</p><h1 id="67fc" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">分解公式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/767242342e31079022698800ac65b792.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*mVMZCy8ht5h71chPg5MJRA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">牛顿-拉夫森公式(图片由作者提供)</p></figure><p id="9bf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这个公式本身非常简单，但是乍看之下，想象它实际上在做什么可能有点棘手。</p><p id="e2b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们回顾一下总体方法:</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><ol class=""><li id="8716" class="ms mt it kw b kx ky la lb ld mu lh mv ll mw lp mx my mz na bi translated">初步猜测根可能在哪里</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/872af81eacefa03f9eb4b26bde8f89e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*rFlwqPOAhbe5PXqVC38WYQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="d0d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2.应用牛顿-拉夫森公式获得比初始猜测更接近根的更新猜测</p><p id="cb24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.重复步骤2，直到新的猜测足够接近。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="9911" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等，<em class="lq">够近了</em>？是的，不幸的是，Newton-Raphson方法给出了根的一个<em class="lq">近似值</em>，尽管通常对于任何合理的应用来说它已经足够接近了！你可能会问我们如何定义足够近？我们什么时候停止迭代？</p><p id="0ea5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，Newton-Raphson方法的实现将有两种处理何时停止的方式。首先，如果你的猜测从一个步骤到下一个步骤的变化不超过一个阈值，比如说0.00001，那么算法将停止，并说最近的猜测<em class="lq">足够接近</em>。第二种方法不太理想，只是简单地说，如果我们达到一定数量的猜测，但仍然没有达到阈值，那么我们就放弃。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e72e37f6bad0d49fa63bf2ae0c256297.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*XOtW2cZLBlGAZwjjbyoN5w.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">牛顿-拉夫森公式(图片由作者提供)</p></figure><p id="b9ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从公式中，我们可以看到，每个新的猜测只是我们以前的猜测调整了一些神秘的数量🔮。然而，如果我们通过一个例子来观想这个过程，很快就会清楚发生了什么！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/9322b50acacc37ee999dd76c352dd39d.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*GMxpwRfZcO35E-cd0gurLA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">示例函数</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f0a4ca21a35dacd6c5bcf1a5f04bb5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*ZmNeUP-otyMmM-fQ4AEsRg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">示例函数的导数</p></figure><p id="e3c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个例子，让我们考虑上面的函数，并初步猜测为<em class="lq"> x= </em> 10(注意这里实际的根是在<em class="lq"> x= </em> 4)。牛顿-拉夫森算法的最初几个猜测在下面的GIF中被可视化👇</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/dfb6e7907e821c2a68a29b0be01d6713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*_WnGjS0CTe1kCJ_hQm1amg.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">牛顿-拉夫森过程(GIF由作者提供)</p></figure><p id="b044" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们最初的猜测是在<em class="lq"> x= </em> 10。现在，请记住，为了计算我们的下一个猜测，我们需要评估函数本身及其在<em class="lq"> x= </em> 10的导数。然而，在10处计算的函数导数仅仅给出了该点处切线曲线的斜率。该切线在GIF中被绘制为<em class="lq">切线0 </em>。</p><p id="854b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，看看下一个猜测相对于前一个切线出现在哪里，你注意到什么了吗？下一个猜测出现在前一条切线穿过<em class="lq"> x- </em>轴的地方。这就是牛顿-拉夫逊法的高明之处！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/8e2fd2d9cb05c8928cc32427ee178e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vXZXouKoE6xAV8GxCk-_OQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e962c1bfa6e88a4fd8fc08f7c09681ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*hKIev1VV8elC1IaQdb_cbQ.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者图片</p></figure><p id="06c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，商<em class="lq">f(x)</em>/<em class="lq">f’(x)</em>简单地给出了我们当前猜测与切线穿过<em class="lq"> x </em>轴的点之间的距离(在<em class="lq"> x </em>方向上)。正是这个距离告诉我们每次要更新我们的猜测多少，正如我们在GIF中看到的，当我们接近根本身时，更新越来越小，这阻止了我们超越。</p><h2 id="7673" class="nl lt it bd lu nm nn dn ly no np dp mc ld nq nr me lh ns nt mg ll nu nv mi nw bi translated">功能用手很难区分怎么办？</h2><p id="d494" class="pw-post-body-paragraph ku kv it kw b kx nx ju kz la ny jx lc ld nz lf lg lh oa lj lk ll ob ln lo lp im bi translated">在上面的例子中，我们有一个很容易手动微分的函数，这意味着我们可以毫不费力地计算<em class="lq">f’(x)</em>。然而，在现实中可能不是这样，有一些有用的技巧来近似导数，而不需要知道它们的解析解。</p><p id="8b44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些导数近似方法超出了本文的范围，但是如果你感兴趣，你可以在这里阅读更多关于有限差分方法的内容。</p><h2 id="27eb" class="nl lt it bd lu nm nn dn ly no np dp mc ld nq nr me lh ns nt mg ll nu nv mi nw bi translated">问题</h2><p id="8f9f" class="pw-post-body-paragraph ku kv it kw b kx nx ju kz la ny jx lc ld nz lf lg lh oa lj lk ll ob ln lo lp im bi translated">敏锐的读者可能已经从上面的例子中发现了一个问题，即牛顿-拉夫森方法只能识别一个根，尽管我们的示例函数有两个根(<em class="lq"> x= </em> -2和<em class="lq"> x= </em> 4)。这当然是一个问题，但不是这种方法的唯一缺点。关于牛顿-拉夫森方法的更多有用信息，比如收敛的必要条件，你可以在这里查阅维基百科页面<a class="ae lr" href="https://en.wikipedia.org/wiki/Newton%27s_method" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><p id="2fee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">🙋‍♂️感谢你的阅读！请随意回答任何问题🙋‍♀️</p><div class="oc od gp gr oe of"><a href="https://medium.com/@riandolphin/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">加入我的推荐链接-海豚</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ko of"/></div></div></a></div></div></div>    
</body>
</html>