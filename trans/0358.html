<html>
<head>
<title>How to Build a Code Search Tool Using PyTorch Transformers and Annoy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立一个代码搜索工具使用 PyTorch 变压器和骚扰</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-build-a-code-search-tool-using-pytorch-transformers-and-annoy-29bc3920e6c7#2022-02-14">https://towardsdatascience.com/how-to-build-a-code-search-tool-using-pytorch-transformers-and-annoy-29bc3920e6c7#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">利用联合文本和代码嵌入进行搜索。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c5f34ada51ef4b03098eeff90b70e2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMGZByRNC88Q2tfwU4_BPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">根据<a class="ae kv" href="https://unsplash.com/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@markuswinkler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·温克勒</a>的照片修改</p></figure><p id="9713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有没有因为懒得自己写而在 google 上找一段代码片段？我们大多数人都是！那么从头开始构建自己的<strong class="ky ir">代码</strong>搜索工具怎么样？这就是我们将在这个项目中努力做的事情。我们将使用 StackOverflow 问题和相应代码样本的并行数据集来构建一个系统，该系统能够根据现有代码片段与自然语言表达的搜索查询的“匹配”程度来对它们进行排序。</p><p id="6936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想尝试这种方法，在博客的末尾有一个 Colab 笔记本链接。</p><h1 id="817a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">系统描述:</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/0f2bdd1da07d6e175e522897efe95a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*0enbCdqzGSBPxPLAsVgrgQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">系统图:作者照片</p></figure><p id="d732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们试图建立一个系统，它能够接受用自然语言表达的问题，然后从成千上万的 Python 代码片段中返回与这个问题最匹配的代码片段。</p><h1 id="e6b6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">它是如何工作的？</h1><p id="b8a9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">该系统将基于代码片段的学习嵌入和“如何做”问题的嵌入。搜索部分将使用 Annoy，这是 Python/C++中的近似最近邻实现。</p><h2 id="6275" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">数据:</h2><p id="90f9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://github.com/LittleYUYU/StackOverflow-Question-Code-Dataset/" rel="noopener ugc nofollow" target="_blank">stat QC</a>数据集，其中有从堆栈溢出中自动挖掘的(问题，代码片段)对。</p><p id="ea87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集的样本如下所示:</p><p id="6dba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题:<strong class="ky ir">如何使用 python 从 MongoDB 中的 10 亿个文档中获取随机的单个文档？</strong></p><p id="f25f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="496c" class="mq lt iq nd b gy nh ni l nj nk">import random</span><span id="9042" class="mq lt iq nd b gy nl ni l nj nk">collection = mongodb[""collection_name""]</span><span id="84f3" class="mq lt iq nd b gy nl ni l nj nk">rand = random.random()  # rand will be a floating point between 0 to 1.<br/>random_record = collection.find_one({ 'random' =&gt; { '$gte' =&gt; rand } })</span></pre><p id="733f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据集有 85，294 个单代码片段答案和 60，083 个多代码片段答案。</p><h2 id="326c" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">预处理:</h2><p id="c686" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">代码和问题都是字符串，所以我们需要在将它们输入模型之前对它们进行标记化。因为我们是在处理代码，所以我们不能使用常规的预先训练好的记号赋予器，因此必须自己构建。</p><p id="65bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要我们的标记器来拆分特殊字符，如“_”或“=”，并正确地拆分 camelCase 变量名。</p><p id="6a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们分两步走:</p><ul class=""><li id="8c20" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">在 camelCase 中，在特殊字符周围添加空格，在单词周围添加空格。</li><li id="0dd5" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">用空格预标记训练一个拥抱脸标记器。</li></ul><p id="458f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将产生以下结果:</p><p id="22f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">问题- &gt; </strong></p><p id="ed41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何使用 python 从 MongoDB 中的 10 亿个文档中获取一个随机的单个文档？</p><p id="24e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">标记化问题- &gt; </strong></p><p id="9a89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">['[CLS]'，'如何'，'到'，'得到'，' a '，'随机'，'单个'，'文档'，'从'，' 1 '，'比尔'，' # #离子'，'文档'，'在'，'蒙戈'，' db '，'使用'，' python '，'？'，'[SEP]']</p><p id="dadf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">代码片段- &gt; </strong></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="38b4" class="mq lt iq nd b gy nh ni l nj nk">class MyLabel(Label): pass    <br/>class AwesomeApp(App):<br/>    def build(self):<br/>        return MyLabel()</span></pre><p id="3f99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">令牌化代码-&gt;T3】</strong></p><p id="de86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">['[CLS]'，' class '，' my '，' label '，'('，' label '，')'，':'，' pass '，' class '，' awesome '，' app '，'('，' app '，')'，':'，' def '，' build '，'('，' self '，')'，':'，' return '，' my '，' label '，'('，')'，'，'，'[SEP]']</p><h2 id="ce1d" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">ML 部分:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/380c81afd2880b8c6df44d0632e25e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*q0swijzo0-kGBvwcCwN-2w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">系统的 ML 部分。作者图解。</p></figure><p id="76e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一部分中，我们将训练一个模型，它能够将一个字符串(代码片段或问题)映射到一个大小为 256 的固定维度向量。我们将应用于该输出向量的约束是，我们希望问题的向量与其对应的代码片段的向量之间的相似性高，而在所有其他情况下具有低的相似性。</p><p id="c155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用双线性相似性度量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/b9bd81cad0ce424b6bc8f747defcc081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgUmFKh5aBadZ2cnPabb9A.png"/></div></div></figure><p id="fc8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中 W 是可学习的参数。详见“<a class="ae kv" href="https://arxiv.org/abs/2010.10915" rel="noopener ugc nofollow" target="_blank">通用音频表征对比学习</a>”。</p><p id="d6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了学习有用的嵌入，我们需要正面的例子，它们是成对的“如何做”问题和它们相应的代码片段。我们还需要一个反例，它将是该批中的所有其他向量。这意味着正对的表示将被推到更高的相似性得分，而我们将样本向量和批中所有不相关向量之间的相似性引导到更低的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/bebaeed10a58c133ba148dabaab1ead2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bC7l7l6JGMseA7NdeUE6Hg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">x_i 和 y_j 是该批的嵌入向量。</p></figure><p id="f40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望批次矩阵尽可能接近恒等式。</p><p id="a686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种进行对比学习的方法摘自上面提到的论文。它允许在某种程度上获得“自由”的反例，因为它们已经被计算为批处理的一部分。与其他方法(如三元组丢失)相比，它还有一个很大的优势，因为我们可以获得 batch_size -1 个负样本，而不是每个正样本只有一个负样本，这迫使编码器学习更多有区别的嵌入。</p><p id="ae49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将文本输入映射到固定的 dim 向量的全部意义在于，它通过使用近似最近邻算法使搜索部分更加有效。</p><h2 id="1b47" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">搜索部分:</h2><p id="04b2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦我们将所有的代码片段编码成向量，并建立一个模型以同样的方式编码一个新问题，我们就可以开始系统的搜索部分了。我们将使用一个名为<a class="ae kv" href="https://github.com/spotify/annoy" rel="noopener ugc nofollow" target="_blank">的库来骚扰</a>。</p><p id="ec1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用 Annoy 将允许我们在 O(log(n))时间内查询 n 个代码片段的数据集。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="dbc1" class="mq lt iq nd b gy nh ni l nj nk"># We define the Annoy Index</span><span id="6d30" class="mq lt iq nd b gy nl ni l nj nk">t = AnnoyIndex(len(samples[0]["vector"]), "angular")</span><span id="0b4b" class="mq lt iq nd b gy nl ni l nj nk"># We add all the vectors to the index</span><span id="2e81" class="mq lt iq nd b gy nl ni l nj nk">for i, sample in enumerate(samples):<br/>    t.add_item(i, sample["vector"])</span><span id="d4c9" class="mq lt iq nd b gy nl ni l nj nk"># We then build the trees for the approximate search</span><span id="5f24" class="mq lt iq nd b gy nl ni l nj nk">t.build(100)</span><span id="c881" class="mq lt iq nd b gy nl ni l nj nk"># We can use it to query the NN of a question vector</span><span id="89a4" class="mq lt iq nd b gy nl ni l nj nk">indexes = t.get_nns_by_vector(search_vector, n=3, search_k=-1)</span></pre><h1 id="172c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">搜索查询的示例结果:</h1><p id="ab70" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><strong class="ky ir">如何转义 HTML 特殊字符？</strong></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="d17a" class="mq lt iq nd b gy nh ni l nj nk"># Search Result 1 --&gt;<br/>raw_html2 = raw_html.replace('\\n', '')<br/><br/># Search Result 2 --&gt;<br/>def escape(htmlstring):<br/>    escapes = {'\"': '&amp;quot;',<br/>               '\'': '&amp;#39;',<br/>               '&lt;': '&amp;lt;',<br/>               '&gt;': '&amp;gt;'}<br/>    # This is done first to prevent escaping other escapes.<br/>    htmlstring = htmlstring.replace('&amp;', '&amp;amp;')<br/>    for seq, esc in escapes.iteritems():<br/>        htmlstring = htmlstring.replace(seq, esc)<br/>    return htmlstring<br/><br/># Search Result 3 --&gt;<br/>mytext.replace(r"\r\n", r"\n")<br/><br/># Query encoded in 0.010133743286132812 seconds<br/># Search results found in in 0.00034046173095703125 seconds</span></pre><p id="42e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">如何唯一化列表？</strong></p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="be5c" class="mq lt iq nd b gy nh ni l nj nk"># Search Result 1 --&gt;<br/>seen = set()<br/>L = []<br/>if 'some_item' not in seen:<br/>                L.append('some_item')<br/>                seen.add('some_item')<br/><br/># Search Result 2 --&gt;<br/>def is_duplicate(a,b):<br/>        if a['name'] == b['name'] and a['cost'] == b['cost'] and abs(int(a['cost']-b['cost'])) &lt; 2:<br/>                return True<br/>        return False<br/><br/>newlist = []<br/>for a in oldlist:<br/>        isdupe = False<br/>        for b in newlist:<br/>                if is_duplicate(a,b):<br/>                        isdupe = True<br/>                        break<br/>        if not isdupe:<br/>                newlist.append(a)<br/><br/># Search Result 3 --&gt;<br/>&gt;&gt;&gt; L = [2, 1, 4, 3, 5, 1, 2, 1, 1, 6, 5]<br/>&gt;&gt;&gt; S = set()<br/>&gt;&gt;&gt; M = []<br/>&gt;&gt;&gt; for e in L:<br/>...     if e in S:<br/>...         continue<br/>...     S.add(e)<br/>...     M.append(e)<br/>... <br/>&gt;&gt;&gt; M<br/>[2, 1, 4, 3, 5, 6]<br/><br/>M = list(set(L))<br/><br/># Query encoded in 0.006329536437988281 seconds<br/># Search results found in in 0.0003654956817626953 seconds<br/></span></pre><p id="e060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，这个系统可以在几毫秒内，从 145，000 个可能的答案中找到相关的代码片段。</p><h1 id="fafa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="13a9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这个小项目中，我们训练了一个 transformer 模型来预测文本和代码的嵌入。这些嵌入然后被用来建立一个 KNN 搜索索引使用近似最近邻在苦恼。通过使用更大的问题/代码数据集或通过对不同的对比学习策略进行基准测试，这种方法还可以进一步改进。</p><p id="5119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过克隆存储库来运行自己的查询:</p><ul class=""><li id="a36a" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><a class="ae kv" href="https://github.com/CVxTz/code_search" rel="noopener ugc nofollow" target="_blank">https://github.com/CVxTz/code_search</a></li></ul><p id="1759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者通过运行这个 colab 笔记本:</p><ul class=""><li id="2294" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><a class="ae kv" href="https://colab.research.google.com/drive/1GagzOxiVuTYaGxqOL-7nYv2-AV_OlVfd?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://colab . research . Google . com/drive/1 gagzoxivutyagxqol-7ny v2-AV _ ol VFD？usp =分享</a></li></ul><p id="c017" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参考资料:</p><ul class=""><li id="00ad" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><a class="ae kv" href="https://arxiv.org/abs/2010.10915" rel="noopener ugc nofollow" target="_blank">通用音频表征的对比学习</a></li><li id="c9fd" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><a class="ae kv" href="https://github.com/spotify/annoy" rel="noopener ugc nofollow" target="_blank">https://github.com/spotify/annoy</a></li></ul></div></div>    
</body>
</html>