<html>
<head>
<title>Data Science at the Command Line</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">命令行中的数据科学</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-at-the-command-line-3ad09ee73d1a#2022-08-15">https://towardsdatascience.com/data-science-at-the-command-line-3ad09ee73d1a#2022-08-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="14f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">每个数据科学家都应该了解的关于shell的知识</h2></div><p id="15bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在已经50岁了，我们还是想不出该怎么称呼它。命令行、shell、终端、bash、提示符还是控制台？我们将把它称为命令行，以保持事情的一致性。</p><p id="3377" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了清楚起见，本文将集中讨论UNIX风格(Linux &amp; Mac)的命令行，忽略其余部分(如Windows的命令处理器和PowerShell)。我们观察到，如今大多数数据科学家都在基于UNIX的系统上工作。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a760432289fb428ee1376553be78e826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/0*Lc1mktW57FyCMhiP.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">命令行让你先睹为快(图片由作者提供)</p></figure><h1 id="4f69" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">这是什么？</h1><p id="2545" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">命令行是基于文本的计算机界面。你可以把它想象成一个操作系统的“引擎盖”。有些人误认为它只是过去的遗迹，但不要被愚弄。现代命令行前所未有的震撼！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mo"><img src="../Images/308dd7f47b043c3e8ddbceaa1639a66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eoHFjw_7JGYiJC-h.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="917a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过去，基于文本的输入和输出是你所拥有的一切(那是在打孔卡之后)。就像最早的汽车一样，第一个操作系统甚至没有引擎盖。一切都一览无余。在这种环境下，所谓的REPL(读取-评估-打印循环)方法是与计算机交互的自然方式。</p><p id="252a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">REPL意味着你输入一个命令，按下回车键，命令会立即被执行。它不同于编辑-运行-调试或编辑-编译-运行-调试循环，后者通常用于更复杂的程序。</p><h1 id="114f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">我为什么要用它？</h1><p id="4678" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">命令行一般遵循“让每个程序做好一件事”的UNIX哲学，因此基本命令非常简单。最根本的前提是，你可以通过组合这些简单的程序来做复杂的事情。旧的UNIX neckbeards指的是“与计算机进行对话”</p><p id="5dc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几乎世界上所有的编程语言都比命令行更强大，而且大多数点击式图形用户界面更容易学习。你为什么要在命令行上做任何事情呢？</p><p id="c6e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个原因是速度。一切触手可及。对于告诉计算机做简单的任务，如下载文件，用特定的前缀重命名一堆文件夹，或对CSV文件执行SQL查询，你真的不能击败命令行的灵活性。学习曲线是存在的，但是一旦你内化了一组基本的命令，它就像魔术一样。</p><p id="7140" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个原因是不可知论。无论您当前使用的是什么堆栈、平台或技术，您都可以从命令行与之交互。它就像万物之间的粘合剂。也是无处不在。哪里有电脑，哪里就有命令行。</p><p id="7525" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个原因是自动化。与GUI界面不同，在命令行中完成的一切最终都可以自动化。指令和计算机之间没有任何歧义。在基于GUI的工具中，所有那些你浪费生命的重复点击都可以在命令行环境中自动完成。</p><p id="0040" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第四个原因是扩展性。与GUI不同，命令行是非常模块化的。简单的命令是为无数用例创建复杂功能的完美构建块，而生态系统在50年后仍在增长。命令行将一直存在。</p><p id="a7c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第五个原因是没有其他选择。常见的情况是，第三方服务的一些更加模糊或前沿的功能可能根本无法通过GUI访问，只能通过CLI(命令行界面)使用。</p><h1 id="0799" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">它是如何工作的？</h1><p id="a682" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">命令行的工作方式大致分为四层:</p><p id="5b71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">终端</strong> =获取键盘输入的应用程序将它传递给正在运行的程序(例如shell)并呈现结果。由于现在所有的现代计算机都有图形用户界面(GUI ),终端是你和其他基于文本的堆栈之间必要的GUI前端层。</p><p id="1bca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Shell </strong> =解析终端应用程序传递的击键并处理运行命令和程序的程序。它的工作基本上是找到程序在哪里，处理变量之类的事情，还提供用TAB键完成的功能。这里有不同的选项，比如Bash、Dash、Zsh和Fish等等。所有这些都具有稍微不同的内置命令和选项集。</p><p id="fb59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">命令</strong> =与操作系统交互的计算机程序。常见的例子是像<code class="fe mp mq mr ms b">ls</code>、<code class="fe mp mq mr ms b">mkdir</code>和<code class="fe mp mq mr ms b">rm</code>这样的命令。有些是预先构建到shell中的，有些是在您的磁盘上编译的二进制程序，有些是文本脚本，有些是指向另一个命令的别名，但归根结底，它们都只是计算机程序。</p><p id="862a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">操作系统</strong> =执行所有其他程序的程序。它处理与所有硬件(如CPU、硬盘和网络)的直接交互。</p><h1 id="9702" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">提示符和波浪号</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2e333db1177ac18beb3a4af9c39d0b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/0*xq5ongMWYv4Nuf7_.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="cf9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个人来说，命令行看起来都略有不同。</p><p id="69a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过，通常有一个共同点:提示，可能由美元符号($)表示。这是一个可视的提示，指示状态结束的位置以及可以开始输入命令的位置。</p><p id="0770" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的电脑上，命令行显示:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="db64" class="my ls iq ms b gy mz na l nb nc">juha@ubuntu:~/hello$</span></pre><p id="d8dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">juha</code>是我的用户名，ubuntu是我的电脑名，<code class="fe mp mq mr ms b">~/hello</code>是我当前的工作目录。</p><p id="97c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那个波浪号(~)字符是怎么回事？甚至当前目录是<code class="fe mp mq mr ms b">~/hello</code>是什么意思？</p><p id="9160" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代字号是主目录的简写，是存放所有个人文件的地方。我的主目录是<code class="fe mp mq mr ms b">/home/juha</code>，所以我现在的工作目录是<code class="fe mp mq mr ms b">/home/juha/hello</code>，简称<code class="fe mp mq mr ms b">~/hello</code>。(约定~用户名一般指某人的主目录；<code class="fe mp mq mr ms b">~juha</code>指我的主目录等等。)</p><p id="588a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从现在开始，我们将省略提示中除美元符号以外的所有内容，以使我们的示例更加清晰。</p><h1 id="9c85" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">对命令的剖析</h1><p id="5397" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">之前，我们简单地将命令描述为与操作系统交互的计算机程序。虽然正确，但还是具体一点吧。</p><p id="c70e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您在提示符后键入内容并按enter键时，shell程序将尝试解析并执行它。假设:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="70bb" class="my ls iq ms b gy mz na l nb nc">$ generate million dollars <br/>generate: command not found</span></pre><p id="e46f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">shell程序获取第一个完整的单词<code class="fe mp mq mr ms b">generate</code>，并将其视为命令。</p><p id="5c9e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的两个单词<code class="fe mp mq mr ms b">million</code>和<code class="fe mp mq mr ms b">dollars</code>被解释为两个独立的参数(有时称为自变量)。</p><p id="48ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，负责促进执行的shell程序开始寻找一个<code class="fe mp mq mr ms b">generate</code>命令。有时是磁盘上的文件，有时是其他东西。我们将在下一章详细讨论这一点。</p><p id="677b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，没有找到名为<code class="fe mp mq mr ms b">generate</code>的命令，我们以一个错误消息结束(这是意料之中的)。</p><p id="cf57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们运行一个实际有效的命令:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="0e25" class="my ls iq ms b gy mz na l nb nc">$ df --human-readable<br/><br/>Filesystem      Size  Used Avail Use% Mounted on<br/>sysfs              0     0     0    - /sys<br/>proc               0     0     0    - /proc<br/>udev             16G     0   16G   0% /dev<br/>. . .</span></pre><p id="b459" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们运行一个命令“<code class="fe mp mq mr ms b">df</code>”(disk free的缩写)和“<code class="fe mp mq mr ms b">--human-readable</code>”选项。</p><p id="4875" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常在缩写选项前使用“-”(破折号)，在长格式选项前使用“-”(双破折号)。(这些惯例随着时间的推移而演变；更多信息请看这篇<a class="ae nd" href="https://blog.liw.fi/posts/2022/05/07/unix-cli/" rel="noopener ugc nofollow" target="_blank">博文</a>。)</p><p id="01fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，这些是同一件事:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="6cb0" class="my ls iq ms b gy mz na l nb nc">$ df -h <br/>$ df --human-readable</span></pre><p id="3e09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常也可以在一个破折号后合并多个缩写选项。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="e418" class="my ls iq ms b gy mz na l nb nc">df -h -l -a <br/>df -hla</span></pre><p id="cfe7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:格式最终由每个命令决定，所以不要假设这些规则是通用的。</p><p id="dc85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为像空格或反斜杠这样的字符有特殊的含义，所以将字符串参数用引号括起来是个好主意。但是，对于类似bash的shells，单引号(')和双引号(")是有区别的。单引号从字面上理解一切，而双引号允许shell程序解释变量之类的东西。例如:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="6b8d" class="my ls iq ms b gy mz na l nb nc">$ testvar=13 <br/>$ echo "$testvar" <br/>13 <br/>$ echo '$testvar' <br/>$testvar</span></pre><p id="dd9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想知道所有可用的选项，您通常可以通过<code class="fe mp mq mr ms b">--help</code>参数获得一个列表:</p><p id="5bf1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">提示:在命令行中输入的通常是一个很长的文件路径。大多数shell程序提供TAB键来自动完成路径或命令，以避免重复键入。试试吧！</p><h1 id="9b6b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">命令的不同类型</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b0c8b05c45decbbc2fb9300d6925852d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/0*Dcp2KFLAiF8JvF3Z.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="d8a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有五种不同类型的命令:二进制、脚本、内置、函数和别名。</p><p id="6837" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它们分为两类，基于文件的和虚拟的。</p><p id="3cbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二进制和脚本命令是基于文件的，通过创建新进程(新程序的操作系统概念)来执行。基于文件的命令往往更加复杂和重量级。</p><p id="e76e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内置、函数和别名是虚拟的，它们在现有的shell进程中执行。这些命令大多简单而轻量。</p><p id="be2b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kh ir">二进制文件</strong>是一个经典的可执行程序文件。它包含只有操作系统才能理解的二进制指令。如果你试图用文本编辑器打开它，你会得到乱码。二进制文件是通过将源代码编译成可执行的二进制文件来创建的。例如，Python解释器命令<code class="fe mp mq mr ms b">python</code>是一个二进制可执行文件。</p><p id="5de0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于二进制命令，shell程序负责从文件系统中找到与命令名匹配的实际二进制文件。但是，不要期望shell会在您的机器上到处寻找命令。相反，shell依赖于一个名为<code class="fe mp mq mr ms b">$PATH</code>的环境变量，这是一个用冒号(:)分隔的路径列表，可以进行迭代。总是选择第一个匹配。</p><p id="83ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查你当前的<code class="fe mp mq mr ms b">$PATH</code>，试试这个:</p><p id="92c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果想知道某个命令的二进制文件在哪里，可以调用which命令。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="c514" class="my ls iq ms b gy mz na l nb nc">$ which python <br/>/home/juha/.pyenv/shims/python</span></pre><p id="ba81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您已经知道在哪里可以找到文件，您可以使用<code class="fe mp mq mr ms b">file</code>实用程序来确定文件的一般类型。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="11da" class="my ls iq ms b gy mz na l nb nc">$ file /home/juha/.pyenv/shims/pip<br/>/home/juha/.pyenv/shims/pip: Bourne-Again shell script text executable, ASCII text<br/>$ file /usr/bin/python3.9<br/>/usr/bin/python3.9: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, stripped</span></pre><p id="a752" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脚本是包含人类可读程序的文本文件。Python、R或Bash脚本是一些常见的例子，您可以将它们作为命令来执行。</p><p id="4aff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常我们不把Python脚本作为命令来执行，而是像这样使用解释器:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="f9d8" class="my ls iq ms b gy mz na l nb nc">$ python hello.py <br/>Hello world</span></pre><p id="d287" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<code class="fe mp mq mr ms b">python</code>是命令，<code class="fe mp mq mr ms b">hello.py</code>只是它的一个参数。(如果你看看<code class="fe mp mq mr ms b">python --help</code>所说的，你可以看到它对应于变体“文件:程序从脚本文件读取”，这在这里确实有意义。)</p><p id="fd7a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们也可以像命令一样直接执行hello.py:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="daf1" class="my ls iq ms b gy mz na l nb nc">$ ./hello.py <br/>Hello world</span></pre><p id="f02e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要做到这一点，我们需要两样东西。首先，<code class="fe mp mq mr ms b">hello.py</code>的第一行需要使用特殊的<code class="fe mp mq mr ms b">#!</code>符号定义一个脚本解释器。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="895f" class="my ls iq ms b gy mz na l nb nc">#!/usr/bin/env python3 <br/>print("Hello world")</span></pre><p id="55f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mp mq mr ms b">#!</code>符号告诉操作系统哪个程序知道如何解释文件中的文本，并且有许多很酷的昵称，比如shebang、hashbang或者我最喜欢的hash-pling！</p><p id="1095" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要的第二件事是将文件标记为可执行。您可以使用<code class="fe mp mq mr ms b">chmod</code>(更改模式)命令来完成这个任务:<code class="fe mp mq mr ms b">chmod u+x hello.py</code>将为所有用户设置可执行标志。</p><p id="579c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<strong class="kh ir">内置</strong>是一个硬编码到shell程序本身的简单命令。像<code class="fe mp mq mr ms b">cd</code>、<code class="fe mp mq mr ms b">echo</code>、<code class="fe mp mq mr ms b">alias</code>和<code class="fe mp mq mr ms b">pwd</code>这样的命令通常是内置的。</p><p id="d6f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您运行<code class="fe mp mq mr ms b">help</code>命令(这也是内置的！)，您将获得所有内置命令的列表。</p><p id="7e0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">功能</strong>就像是用户定义的额外内置功能。例如:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="c4d8" class="my ls iq ms b gy mz na l nb nc">$ hello() { echo 'hello, world'; }</span></pre><p id="81e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以用作命令:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="d6b2" class="my ls iq ms b gy mz na l nb nc">$ hello <br/>hello, world</span></pre><p id="e87d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果想要列出当前可用的所有函数，可以调用(在Bash类shells中):</p><p id="7ad6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">别名就像宏。更复杂命令的简写或替代名称。</p><p id="6032" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，您希望new命令<code class="fe mp mq mr ms b">showerr</code>列出最近的系统错误:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="b1df" class="my ls iq ms b gy mz na l nb nc">$ alias showerr="cat /var/log/syslog"<br/>$ showerr<br/>Apr 27 10:49:20 juha-ubuntu gsd-power[2484]: failed to turn the kbd backlight off: GDBus.Error:org.freedesktop.UPower.GeneralError: error writing brightness<br/>. . .</span></pre><p id="226c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于函数和别名不是物理文件，所以它们在关闭终端后不再存在，通常在所谓的配置文件<code class="fe mp mq mr ms b">~/.bash_profile</code>或<code class="fe mp mq mr ms b">~/.bashrc</code>文件中定义，当新的交互或登录shell启动时执行。一些发行版还支持一个<code class="fe mp mq mr ms b">~/.bash_aliases</code>文件(很可能是从概要文件中调用的——它是一路向下的脚本！).</p><p id="a9bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您想获得shell当前活动的所有别名的列表，您可以不使用任何参数调用<code class="fe mp mq mr ms b">alias</code>命令。</p><h1 id="f5f6" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">将命令组合在一起</h1><p id="e419" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">几乎所有发生在你电脑上的事情都发生在进程内部。二进制和脚本命令总是启动一个新的进程。内置、函数和别名依附于现有shell程序的进程。</p><p id="78b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进程是用于运行命令(程序)实例的操作系统概念。每个进程都有一个ID、自己的保留内存空间和在系统上执行操作的安全特权。每个流程还有一个标准输入(<code class="fe mp mq mr ms b">stdin</code>)、标准输出(<code class="fe mp mq mr ms b">stdout</code>)和标准误差(<code class="fe mp mq mr ms b">stderr</code>)流。</p><p id="1d23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些溪流是什么？它们只是任意的数据流。没有指定编码，这意味着它可以是任何东西。文本，视频，音频，莫尔斯电码，任何命令的作者觉得合适的。最终，你的电脑只是一台美化了的数据转换机器。因此，每个进程都有输入和输出是有意义的，就像函数一样。将输出流与错误流分开也是有意义的。如果您的输出流是一个视频，那么您不希望基于文本的错误消息的字节与您的视频字节混合在一起(或者，在20世纪70年代，当您的照相排版被排版而不是显示在终端上的错误消息破坏后，标准错误流被实现)。</p><p id="1e04" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，stdout和stderr流通过管道返回到您的终端，但是这些流可以重定向到文件或通过管道成为另一个进程的输入。在命令行中，这是通过使用特殊的重定向操作符来完成的(<code class="fe mp mq mr ms b">|</code>、<code class="fe mp mq mr ms b">&gt;</code>、<code class="fe mp mq mr ms b">&lt;</code>、<code class="fe mp mq mr ms b">&gt;&gt;</code>)。</p><p id="a461" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说个例子。默认情况下，<code class="fe mp mq mr ms b">curl</code>命令下载一个URL并将其标准输出返回到终端。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/76b2b76f31fc8bc28a7f63ff2e7593c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/0*NYloc1T-2b7g1pL2.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">curl命令输入和输出(图片由作者提供)</p></figure><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="a4af" class="my ls iq ms b gy mz na l nb nc">$ curl https://filesamples.com/samples/document/csv/sample1.csv<br/>"May", 0.1, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0<br/>"Jun", 0.5, 2, 1, 1, 0, 0, 1, 1, 2, 2, 0, 1<br/>"Jul", 0.7, 5, 1, 1, 2, 0, 1, 3, 0, 2, 2, 1<br/>"Aug", 2.3, 6, 3, 2, 4, 4, 4, 7, 8, 2, 2, 3<br/>"Sep", 3.5, 6, 4, 7, 4, 2, 8, 5, 2, 5, 2, 5</span></pre><p id="3adf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们只想要前三排。我们可以使用管道操作符(<code class="fe mp mq mr ms b">|</code>)将两个命令连接在一起。第一个命令的标准输出(<code class="fe mp mq mr ms b">curl</code>)作为第二个命令的标准输入(<code class="fe mp mq mr ms b">head</code>)通过管道传输。默认情况下，第二个命令的标准输出(<code class="fe mp mq mr ms b">head</code>)仍然输出到终端。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="ac67" class="my ls iq ms b gy mz na l nb nc">$ curl https://filesamples.com/samples/document/csv/sample1.csv | head -n 3<br/>"May", 0.1, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 0<br/>"Jun", 0.5, 2, 1, 1, 0, 0, 1, 1, 2, 2, 0, 1<br/>"Jul", 0.7, 5, 1, 1, 2, 0, 1, 3, 0, 2, 2, 1</span></pre><p id="37be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，您希望数据在磁盘上，而不是在终端上。我们可以通过使用<code class="fe mp mq mr ms b">&gt;</code>操作符将最后一个命令(<code class="fe mp mq mr ms b">head</code>)的标准输出重定向到一个名为<code class="fe mp mq mr ms b">foo.csv</code>的文件中来实现这一点。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ng"><img src="../Images/47dba01f3041cfa66f5938ac7852fd51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i14ZLAh1zM8OVhyQ.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">命令卷曲管道与头部命令(图片由作者提供)</p></figure><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="3fc3" class="my ls iq ms b gy mz na l nb nc">$ curl https://filesamples.com/samples/document/csv/sample1.csv | head -n 3 &gt; foo.csv</span></pre><p id="6c11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，进程在结束时总是会返回值。当返回值为零(0)时，我们将其解释为成功执行。如果它返回任何其他数字，这意味着执行有一个错误，并提前退出。例如，任何未被try/except捕获的Python异常都会让Python解释器以非零代码退出。</p><p id="1ff3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用<code class="fe mp mq mr ms b">$?</code>变量检查先前执行的命令的返回值。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="58aa" class="my ls iq ms b gy mz na l nb nc">$ curl http://fake-url<br/>curl: (6) Could not resolve hostmm<br/>$ echo $?<br/>6</span></pre><p id="18f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前，我们通过管道将两个命令与流连接在一起，这意味着它们是并行运行的。当我们使用<code class="fe mp mq mr ms b">&amp;&amp;</code>操作符将两个命令组合在一起时，命令的返回值很重要。这意味着我们要等待上一个命令成功，然后再继续下一个命令。例如:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="6045" class="my ls iq ms b gy mz na l nb nc">cp /tmp/apple.png /tmp/usedA.png &amp;&amp; cp /tmp/apple.png /tmp/usedB.png &amp;&amp; rm /tmp/apple.png</span></pre><p id="0bb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们尝试将文件<code class="fe mp mq mr ms b">/tmp/apple</code>复制到两个不同的位置，最后删除原始文件。使用<code class="fe mp mq mr ms b">&amp;&amp;</code>操作符意味着shell程序检查每个命令的返回值，并在移动之前断言它为零(成功)。这可以防止我们在最后意外删除文件。</p><p id="65cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对编写更长的shell脚本感兴趣，那么现在是一个很好的时机，可以绕道去Bash“严格模式”的领地<a class="ae nd" href="http://redsymbol.net/articles/unofficial-bash-strict-mode/" rel="noopener ugc nofollow" target="_blank">将自己从许多令人头痛的事情中解救出来</a>。</p><h1 id="bdba" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">像老板一样管理数据科学项目</h1><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/2076483aff2b869e798231fdf772b1cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/0*Ow3CPfBWr2fAOAI-.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">作者图片</p></figure><p id="9a49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，当数据科学家冒险使用命令行时，是因为他们使用了第三方服务或云运营商提供的CLI(命令行界面)工具。常见的例子包括从AWS S3下载数据，在Spark集群上执行一些代码，或者为生产构建Docker映像。</p><p id="fb6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总是手动记忆并一遍又一遍地键入这些命令不是很有用。从团队合作和版本控制的角度来看，这不仅令人痛苦，而且是一种糟糕的做法。一个人应该总是记录神奇的配方。</p><p id="1b48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们建议使用自1976年以来的经典命令之一make命令。它是一个简单的、无处不在的、健壮的命令，最初是为编译源代码而创建的，但是可以被武器化，用于执行和记录任意脚本。</p><p id="9280" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mp mq mr ms b">make</code>的默认方式是在项目的根目录下创建一个名为<code class="fe mp mq mr ms b">Makefile</code>的文本文件。您应该始终将该文件提交到您的版本控制系统中。</p><p id="67ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个只有一个“目标”的非常简单的<code class="fe mp mq mr ms b">Makefile</code>。由于编译源代码的历史，它们被称为目标，但是你应该把目标看作一个任务。</p><p id="778f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Makefile </strong></p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="a28e" class="my ls iq ms b gy mz na l nb nc">hello:<br/>    echo "Hello world!"</span></pre><p id="5d63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记得我们说过这是1976年的经典之作吗？嗯，也不是没有怪癖。你必须<strong class="kh ir">非常小心</strong>用制表符缩进那个<code class="fe mp mq mr ms b">echo</code>语句，而不是任何数量的空格。如果你不这样做，你会得到一个“缺少分隔符”的错误。</p><p id="6076" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了执行我们的“hello”目标(或任务)，我们调用:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="6b36" class="my ls iq ms b gy mz na l nb nc">$ make hello<br/>echo "Hello world!"<br/>Hello world!</span></pre><p id="69f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意make是如何打印出食谱而不仅仅是输出的。您可以使用-s参数来限制输出。</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="1ed3" class="my ls iq ms b gy mz na l nb nc">$ make -s hello<br/>Hello world!</span></pre><p id="fe74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们添加一些有用的东西，比如下载我们的训练数据。</p><p id="d37b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Makefile </strong></p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="8f1e" class="my ls iq ms b gy mz na l nb nc">hello:<br/>    echo "Hello world!"<br/><br/>get-data:<br/>    mkdir -p .data<br/><br/>    curl &lt;https://filesamples.com/samples/document/csv/sample1.csv&gt;<br/>    &gt; .data/sample1.csv<br/>    echo "Downloaded .data/sample1.csv"</span></pre><p id="e8f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过以下方式下载示例培训数据:</p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="6178" class="my ls iq ms b gy mz na l nb nc">$ make -s get-data<br/>Downloaded .data/sample1.csv</span></pre><p id="cf1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(旁白:我们读者中更有经验的Makefile向导会注意到,<code class="fe mp mq mr ms b">get-data</code>实际上应该命名为<code class="fe mp mq mr ms b">.data/sample1.csv</code>,以利用Makefile的简写和数据依赖性。)</p><p id="127c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们将看一个数据科学项目中简单的<code class="fe mp mq mr ms b">Makefile</code>可能是什么样子的示例，这样我们就可以演示如何使用make变量，让您更有灵感:</p><p id="7c82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Makefile </strong></p><pre class="lc ld le lf gt mu ms mv mw aw mx bi"><span id="583c" class="my ls iq ms b gy mz na l nb nc">DOCKER_IMAGE := mycompany/myproject<br/>VERSION := $(shell git describe --always --dirty --long)<br/><br/>default:<br/>    echo "See readme"<br/><br/>init:<br/>    pip install -r requirements.txt<br/>    pip install -r requirements-dev.txt<br/>    cp -u .env.template .env<br/><br/>build-image:<br/>    docker build .<br/>        -f ./Dockerfile<br/>        -t $(DOCKER_IMAGE):$(VERSION)<br/><br/>push-image:<br/>    docker push $(DOCKER_IMAGE):$(VERSION)<br/><br/>pin-dependencies:<br/>    pip install -U pip-tools<br/>    pip-compile requirements.in<br/>    pip-compile requirements-dev.in<br/><br/>upgrade-dependencies:<br/>    pip install -U pip pip-tools<br/>    pip-compile -U requirements.in<br/>    pip-compile -U requirements-dev.in</span></pre><p id="60bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子<code class="fe mp mq mr ms b">Makefile</code>将允许您的团队成员在克隆存储库之后初始化他们的环境，当他们引入新的库时固定依赖项，并部署一个带有漂亮版本标签的新docker映像。</p><p id="6d80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您在代码库中始终提供一个漂亮的<code class="fe mp mq mr ms b">Makefile</code>和一个写得很好的自述文件，它将使您的同事能够使用命令行并始终如一地再现您的每个项目的魔力。</p><p id="42a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">结论</strong></p><p id="864f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">归根结底，有些人喜欢命令行，有些人不喜欢。</p><p id="3a55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是每个人都喜欢的，但每个数据科学家都应该尝试一下，给它一个机会。即使它在你的日常工具箱中找不到位置，了解基本面也是有好处的。能够与热衷于命令行的同事交流而不被他们的终端巫术吓倒是一件好事。</p><p id="b408" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这个话题激发了你的灵感，我强烈推荐接下来看看耶鲁安·扬森斯的免费书籍《命令行数据科学》。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="c74f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="np">原载于</em><a class="ae nd" href="https://valohai.com/blog/command-line-for-data-science/" rel="noopener ugc nofollow" target="_blank"><em class="np">https://valohai.com</em></a><em class="np">。</em></p></div></div>    
</body>
</html>