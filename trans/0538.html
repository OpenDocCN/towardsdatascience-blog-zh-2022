<html>
<head>
<title>How to decorate class method in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 Python 中修饰类方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-decorate-class-method-in-python-6627234b33a#2022-02-21">https://towardsdatascience.com/how-to-decorate-class-method-in-python-6627234b33a#2022-02-21</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/8c0385f7f7d025d8d1d84a20a86b16e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q434rNW8QXQQptBx"/></div></div><p class="kc kd gk gi gj ke kf bd b be z dk translated">劳拉·阿岱在<a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e3e0" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在 Python 中，函数是一级对象。这意味着它可以作为参数传递给其他函数。使用 decorator，无需重新编写函数代码就可以改变 Python 函数的行为。</p><p id="ae43" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">Python decorator 的一个流行例子是<code class="fe lf lg lh li b">@property</code>,它允许以安全的方式访问函数的值。您可以使用<code class="fe lf lg lh li b">@property</code>的 setter 属性安全地修改值。更多细节可以在这里找到<a class="ae kg" href="https://www.tutorialsteacher.com/python/property-decorator" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="63e0" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">Python 的装饰器特性天生就令人困惑(至少对我来说是这样)。此外，我对给定代码中的信息流非常挑剔。我发现使用<code class="fe lf lg lh li b">class</code>作为一种尽可能保持代码简单和抽象的方式很方便。为了演示一种简洁的方式来编写<code class="fe lf lg lh li b">decorate</code>代码，我编写了一个示例代码。</p><p id="c72c" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我在这个例子中定义了两个<code class="fe lf lg lh li b">classes</code>。</p><ul class=""><li id="2f4c" class="lj lk iu kj b kk kl ko kp ks ll kw lm la ln le lo lp lq lr bi translated"><code class="fe lf lg lh li b">GenericClass</code>:带有变量<code class="fe lf lg lh li b">initial_value</code>和方法<code class="fe lf lg lh li b">operation</code>的演示类。<code class="fe lf lg lh li b">operation</code>的主要目标是返回作为参数传入的值的总和。</li><li id="18a8" class="lj lk iu kj b kk ls ko lt ks lu kw lv la lw le lo lp lq lr bi translated"><code class="fe lf lg lh li b">DecoratorClass</code>:包含一个<code class="fe lf lg lh li b">wrapper</code>函数，用于修饰<code class="fe lf lg lh li b">GenericClass</code>对象的<code class="fe lf lg lh li b">operation</code>方法。<code class="fe lf lg lh li b">wrapper</code>函数的主要目的是使用<code class="fe lf lg lh li b">operator</code>函数和<code class="fe lf lg lh li b">value</code>变量来修饰<code class="fe lf lg lh li b">operation</code>方法。该操作符函数可以是 Python 的内置函数，如<code class="fe lf lg lh li b">max</code>或<code class="fe lf lg lh li b">min</code>,<code class="fe lf lg lh li b">value</code>可以是任意的<code class="fe lf lg lh li b">float</code>数。本质上，<code class="fe lf lg lh li b">wrapper</code>确保当<code class="fe lf lg lh li b">&lt;GenericClass_instance&gt;.operation(*args)</code>被调用时<code class="fe lf lg lh li b">operator(value, &lt;GenericClass_instance&gt;.operation(*args))</code>被返回。</li></ul></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="b6dd" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们深入一下这个例子。让我们构造一个<code class="fe lf lg lh li b">&lt;GenericClass&gt;</code>的实例。</p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="4e4e" class="mm mn iu li b gz mo mp l mq mr">example = GenericClass(initial_value = -10)</span></pre><p id="74ea" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这创建了一个<code class="fe lf lg lh li b">&lt;GenericClass&gt;</code>的<code class="fe lf lg lh li b">example</code>实例和 10 的实例变量<code class="fe lf lg lh li b">initial_value</code>。</p><p id="e32a" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们用实例变量<code class="fe lf lg lh li b">operator</code>和<code class="fe lf lg lh li b">value</code>构造一个<code class="fe lf lg lh li b">&lt;DecoratorClass&gt;</code>的实例。</p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="7dca" class="mm mn iu li b gz mo mp l mq mr">always_positive = DecoratorClass(operator=max, value=0.0)</span></pre><p id="cfe3" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在让我们来看几个更小的<code class="fe lf lg lh li b">always_positive</code>实例用例的例子。</p><p id="4f88" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">代码</em>:</p><p id="9dcb" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">获得 5、6 和-7 之间的最小值</p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="9560" class="mm mn iu li b gz mo mp l mq mr">min(5, 6, -7)</span></pre><p id="0910" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">输出</em>:</p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="bf1e" class="mm mn iu li b gz mo mp l mq mr">-7</span></pre><p id="2a1c" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是现在使用<code class="fe lf lg lh li b">always_positive</code>实例，我们可以修改输出，使其返回值大于 0。注意在<code class="fe lf lg lh li b">&lt;DecoratorClass&gt;</code>实例中，操作符是<code class="fe lf lg lh li b">max</code>，值是 0.0。这意味着包装函数的输出是这个修改的函数，使得<code class="fe lf lg lh li b">&lt;modified_function&gt; = max(0.0, &lt;func&gt;)</code></p><p id="6558" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">代码:</em></p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="91e5" class="mm mn iu li b gz mo mp l mq mr">modified_function = always_positive(min)</span><span id="c20c" class="mm mn iu li b gz mt mp l mq mr">print(modified_function)</span></pre><p id="809b" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">输出:</em></p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="b336" class="mm mn iu li b gz mo mp l mq mr">&lt;function __main__.DecoratorClass.__call__.&lt;locals&gt;.wrapper at #ID&gt;</span></pre><p id="eff2" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">输出返回修改函数的<code class="fe lf lg lh li b">type</code>和<code class="fe lf lg lh li b">id()</code>。</p><p id="b0ed" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在让我们在这个<code class="fe lf lg lh li b">modified_function</code>中传递几个参数并观察输出。</p><p id="f3b5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">代码</em>:</p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="c2ca" class="mm mn iu li b gz mo mp l mq mr">modified_function(5, 6, 7)</span></pre><p id="8136" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">输出</em>:</p><p id="4608" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe lf lg lh li b">5</code></p><p id="c9f3" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是显而易见的，因为<code class="fe lf lg lh li b">min(5, 6, 7)</code>是 5，并且即使函数被修改为总是正的，输出仍然保持为 5，因为显而易见 5 大于 0。</p><p id="a98b" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">代码:</em></p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="e717" class="mm mn iu li b gz mo mp l mq mr">modified_function(5, 6, -7)</span></pre><p id="c84a" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><em class="ms">输出:</em></p><p id="c236" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe lf lg lh li b">0.0</code></p><p id="eabe" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">由于作为<code class="fe lf lg lh li b">modified_function</code>参数传递的所有数字中最小的是-7，并且-7 明显小于 0，所以现在结果被修改为<code class="fe lf lg lh li b">always_positive.value</code>(在本例中为 0.0)。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="c2a3" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在让我们进一步扩展这个概念，使用 python decorator 修改类方法<code class="fe lf lg lh li b">&lt;GenericClass&gt;.operation</code>。装饰器<code class="fe lf lg lh li b">&lt;DecoratorClass&gt;</code>可以通过如下传递参数来实例化。</p><pre class="me mf mg mh gu mi li mj mk aw ml bi"><span id="e5f3" class="mm mn iu li b gz mo mp l mq mr">Class GenericClass:</span><span id="35e1" class="mm mn iu li b gz mt mp l mq mr">.<br/>.<br/>.</span><span id="37b4" class="mm mn iu li b gz mt mp l mq mr">   @DecoratorClass(operator=max, value=0.0)<br/>   def operation(self, *args) --&gt; float:<br/>       ...</span></pre><p id="19ee" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这用装饰器修改了类方法<code class="fe lf lg lh li b">&lt;GenericClass&gt;.operation()</code>,方式与我之前的例子<code class="fe lf lg lh li b">modified_function</code>相似。在这种情况下，代码更加抽象和复杂，可以处理任何帮助函数(如<code class="fe lf lg lh li b">min</code>或<code class="fe lf lg lh li b">max</code>等)。).</p><p id="fe9a" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个概念可以进一步扩展到修饰任何类方法来改变它的行为。像这样使用装饰函数的一个用例是“防止”更复杂函数的错误输出。</p><p id="c4e5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><strong class="kj iv">举例:</strong></p><p id="7f86" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个演示代码可以使用 Google Colab 打开。</p><figure class="me mf mg mh gu jv"><div class="bz fq l di"><div class="mu mv l"/></div></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="8980" class="mw mn iu bd mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns bi translated">如果你喜欢它…</h1><p id="975b" class="pw-post-body-paragraph kh ki iu kj b kk nt km kn ko nu kq kr ks nv ku kv kw nw ky kz la nx lc ld le in bi translated">如果你喜欢这篇文章，你可能也会喜欢我其他类似主题的文章。</p><div class="ny nz gq gs oa ob"><a href="https://sidbannet.medium.com/membership" rel="noopener follow" target="_blank"><div class="oc ab fp"><div class="od ab oe cl cj of"><h2 class="bd iv gz z fq og fs ft oh fv fx it bi translated">通过我的推荐链接加入 Medium 悉达多·班纳吉博士</h2><div class="oi l"><h3 class="bd b gz z fq og fs ft oh fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oj l"><p class="bd b dl z fq og fs ft oh fv fx dk translated">sidbannet.medium.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ka ob"/></div></div></a></div><p id="1d64" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">和<a class="ae kg" href="https://medium.com/@sidbannet" rel="noopener"> <em class="ms">关注我</em> </a>即将发布的关于随机建模、数据科学和 python 技巧的每周文章。</p><h2 id="98e4" class="mm mn iu bd mx oq or dn nb os ot dp nf ks ou ov nj kw ow ox nn la oy oz nr pa bi translated">我以前的故事:</h2><div class="ny nz gq gs oa ob"><a rel="noopener follow" target="_blank" href="/how-to-analyze-time-series-data-with-pandas-4dea936fe012"><div class="oc ab fp"><div class="od ab oe cl cj of"><h2 class="bd iv gz z fq og fs ft oh fv fx it bi translated">如何用熊猫分析时间序列数据</h2><div class="oi l"><h3 class="bd b gz z fq og fs ft oh fv fx dk translated">使用案例—熊猫的 COVID 时序数据分析</h3></div><div class="oj l"><p class="bd b dl z fq og fs ft oh fv fx dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="pb l om on oo ok op ka ob"/></div></div></a></div><div class="ny nz gq gs oa ob"><a rel="noopener follow" target="_blank" href="/how-to-build-plotly-choropleth-map-with-covid-data-using-pandas-in-google-colab-45951040b8e4"><div class="oc ab fp"><div class="od ab oe cl cj of"><h2 class="bd iv gz z fq og fs ft oh fv fx it bi translated">如何在 Google Colab 中使用 Pandas 构建带有 COVID 数据的 Plotly Choropleth 地图</h2><div class="oi l"><h3 class="bd b gz z fq og fs ft oh fv fx dk translated">在这个项目中，我将展示如何使用 pandas 和 plotly 在 Google Colab 中构建自己的 COVID 仪表板。</h3></div><div class="oj l"><p class="bd b dl z fq og fs ft oh fv fx dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="pc l om on oo ok op ka ob"/></div></div></a></div></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="5255" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi pd translated"><span class="l pe pf pg bm ph pi pj pk pl di"> A </span>关于我——我开发<strong class="kj iv">高性能计算模型</strong>来理解<em class="ms">湍流</em>、<em class="ms">多相流、</em>和<em class="ms">燃烧火焰</em>。我应用<strong class="kj iv">数据科学</strong>来加速<em class="ms">推进</em>装置的设计创新。我于 2011 年获得了威斯康辛大学麦迪逊分校的博士学位，主修<em class="ms">机械和化学工程</em>，辅修<em class="ms">数学</em>、<em class="ms">统计学</em>和<em class="ms">计算机科学</em>。请随意查看我的 GitHub 资源库，并在<a class="ae kg" href="https://www.linkedin.com/in/sidban" rel="noopener ugc nofollow" target="_blank"><em class="ms">Linkedin</em></a><em class="ms">上关注我。</em></p></div></div>    
</body>
</html>