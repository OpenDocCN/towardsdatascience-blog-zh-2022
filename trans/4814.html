<html>
<head>
<title>Multi-step time series forecasting with XGBoost</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">XGBoost多步时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multi-step-time-series-forecasting-with-xgboost-65d6820bec39#2022-10-26">https://towardsdatascience.com/multi-step-time-series-forecasting-with-xgboost-65d6820bec39#2022-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7087" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">本文以24小时电价预测为例，展示了如何使用XGBoost生成多步时间序列预测。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c57014a26f9554da318d62f2f5ff86f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uBb-6pMhLczY9rS9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@agebarros?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿格巴洛斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9ed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多博客文章和Kaggle笔记本都将XGBoost应用于时间序列数据。然而，根据我的经验，现有资料要么将XGBoost应用于时间序列<em class="ls">分类</em>，要么应用于<em class="ls">一步预测</em>。本文展示了如何将XGBoost应用于<em class="ls">多步提前</em>时间序列预测，即预测跨度大于1的时间序列预测。这与一步到位预测有很大不同，因此需要这篇文章。</p><p id="5178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XGBoost [1]是梯度提升树的快速实现。它在包括时间序列预测在内的许多领域取得了良好的效果。例如，论文“我们真的需要深度学习模型进行时间序列预测吗？”表明XGBoost可以在许多时间序列预测任务中胜过神经网络[2]。</p><p id="f076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，本文的目的不是对所选的预测问题产生高度准确的结果。相反，目的是说明如何使用XGBoost生成多输出预测。因此，本文不详细讨论时间序列数据探索和预处理，也不讨论超参数调优。关于这个主题已经有很多写得很好的材料了。</p><p id="c2c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的其余部分结构如下:</p><ol class=""><li id="fadf" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">首先，我们将仔细看看本教程中使用的原始时间序列数据集。</li><li id="1d0c" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">然后，我将描述如何获得一个带标签的时间序列数据集，该数据集将用于训练和测试XGBoost时间序列预测模型。</li><li id="ba80" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">最后，我将展示如何训练XGBoost时间序列模型，以及如何使用它生成多步预测。</li></ol><div class="mh mi gp gr mj mk"><a rel="noopener follow" target="_blank" href="/how-to-make-a-pytorch-transformer-for-time-series-forecasting-69e073d4061e"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">如何制作用于时间序列预测的PyTorch转换器</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">这篇文章将向你展示如何一步一步地将时序转换器架构图转换成PyTorch代码。</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">towardsdatascience.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kp mk"/></div></div></a></div><h1 id="81d3" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">数据集描述和问题表述</h1><p id="9246" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">本教程中的数据是丹麦以欧元/兆瓦时为单位的批发电力“现货市场”价格。这些数据可以在<a class="ae kv" href="https://www.energidataservice.dk/tso-electricity/Elspotprices" rel="noopener ugc nofollow" target="_blank"> Energidataservice </a> [4]上免费获得(根据“全球范围的、免费的、非排他性的和其他无限制的使用许可”[5])。数据具有每小时的分辨率，这意味着在给定的一天中，有24个数据点。我们将使用2017年1月1日至2021年6月30日的数据，这将产生一个包含39，384个批发电价每小时观察值的数据集。</p><p id="2b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程的目的是展示如何使用XGBoost算法生成一个预测<em class="ls"> Y </em>，包括给定输入的<em class="ls"> m </em>小时的预测电价，<em class="ls"> X，</em>包括<em class="ls"> n </em>小时的过去电价观测值。这类问题可以认为是单变量时间序列预测问题。更具体地说，我们将把预测问题公式化为有监督的机器学习任务。</p><h1 id="a87b" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">用XGBoost进行时间序列预测的数据准备</h1><p id="30bf" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">与任何其他机器学习任务一样，我们需要将数据分成训练数据集和测试数据集。请注意，数据点不被打乱是很重要的，因为我们需要保持观察的自然顺序。</p><p id="46dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于有监督的ML任务，我们需要一个带标签的数据集。我们通过所谓的固定长度滑动窗口方法获得由<em class="ls"> (X，Y) </em>对<em class="ls"> </em>组成的标记数据集。使用这种方法，长度为<em class="ls"> n+m </em>的窗口“滑过”数据集，并且在每个位置，它创建一个<em class="ls"> (X，Y) </em>对。滑动窗口从数据集的第一次观察开始，每次滑动移动<em class="ls"> S </em>步。在本教程中，我们将使用步长为12。滑动窗口方法摘自论文《我们真的需要深度学习模型进行时间序列预测吗[2]其中作者还使用XGBoost进行多步提前预测。</p><p id="cd84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在代码中，通过首先产生元组的列表来获得标记的数据集，其中每个元组包含用于切片数据的索引。第一个元组可能是这样的:<em class="ls"> (0，192)。</em>这意味着创建了一个由数据点0-192组成的切片。索引元组列表由函数<code class="fe nw nx ny nz b">get_indices_entire_sequence()</code>生成，该函数在repo的<code class="fe nw nx ny nz b">utils.py</code>模块中实现。为了方便起见，它显示如下。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d31e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，索引元组列表被用作函数<code class="fe nw nx ny nz b">get_xgboost_x_y()</code>的输入，该函数也在repo的<code class="fe nw nx ny nz b">utils.py</code>模块中实现。同样，它显示在下面。该函数的参数是指数列表、数据集(例如训练数据)、预测范围、<em class="ls"> m、</em>和输入序列长度、<em class="ls">n。</em>该函数输出两个numpy数组:</p><ol class=""><li id="7037" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">所有的模型输入，即具有形状的<em class="ls"> X，</em>(实例数，<em class="ls"> n </em>)。</li><li id="9168" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">所有目标序列，即形状为【实例数，<em class="ls"> m </em> ) <em class="ls">的<em class="ls"> Y、</em>。</em></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="563f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，这两个函数用于生成由<em class="ls"> (X，Y) </em>对组成的训练和测试数据集，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="b30d" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">使用XGBoost生成多步时间序列预测</h1><p id="61e9" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">一旦我们创建了数据，就必须实例化XGBoost模型。</p><p id="3771" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将它包装在scikit-learn的<code class="fe nw nx ny nz b">MultiOutputRegressor()</code>功能中，使XGBoost模型能够产生长度大于1的输出序列。这个包装器适合每个目标的一个回归量，目标序列中的每个数据点都被认为是这个上下文中的一个目标。因此，当我们预测提前24小时时，包装器实际上适合每个实例的24个模型。这使得该函数相对低效，但是该模型仍然比诸如变压器模型的神经网络训练得更快。对于好奇的读者来说，xgboost包现在似乎天生支持多输出预测[3]。</p><p id="f063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包装的对象还具有我们从其他scikit-learn和xgboost模型中了解到的<code class="fe nw nx ny nz b">predict()</code>函数，因此我们使用它来生成测试预测。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="15dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">XGBoost时间序列预测模型能够立即生成合理的预测，无需调整超参数。正如本文回购中的笔记本所示，其预测的平均绝对误差为13.1欧元/兆瓦时。测试数据集的平均值为54.61欧元/兆瓦时。</p><p id="be6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细观察下图中的预测，该图显示了相对于目标值的预测，我们可以看到该模型的预测通常遵循目标值的模式，尽管当然还有改进的空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/829b20a8b5f7e34b17416fc3aafeb3d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLfxveAmkFl2LfpDUVGOYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">XGBoost预测值与实际值(图片由作者提供)</p></figure><p id="8377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整示例可在本报告的笔记本中找到:</p><div class="mh mi gp gr mj mk"><a href="https://github.com/KasperGroesLudvigsen/xgboost_time_series" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">GitHub-KasperGroesLudvigsen/XGBoost _ time _ series:如何对多步时间序列使用XGBoost…</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">这是对《走向数据科学》一文的报道，文章标题是“用XGBoost进行多步时间序列预测”</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="od l mv mw mx mt my kp mk"/></div></div></a></div><h1 id="36dd" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">摘要</h1><p id="75f1" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">在本教程中，我们介绍了如何处理时间序列数据，以便将其用作XGBoost时间序列模型的输入，我们还了解了如何将XGBoost模型包装在多输出函数中，从而允许模型生成长度超过1的输出序列。从MAE和上面的图可以看出，XGBoost可以产生合理的结果，而无需任何高级数据预处理和超参数调整。这表明XGBoost非常适合时间序列预测——这一概念也在前面提到的学术文章[2]中得到支持。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="d26c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我希望你喜欢这篇文章🤞</p><p id="2bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请留下评论让我知道你的想法。</p><p id="3228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关注更多与数据科学的<a class="ae kv" rel="noopener" target="_blank" href="/how-to-make-a-pytorch-transformer-for-time-series-forecasting-69e073d4061e">时间序列预测</a>、<a class="ae kv" href="https://kaspergroesludvigsen.medium.com/the-10-most-energy-efficient-programming-languages-6a4165126670" rel="noopener">绿色软件工程</a>和<a class="ae kv" rel="noopener" target="_blank" href="/8-podcast-episodes-on-the-climate-impact-of-machine-learning-54f1c19f52d">环境影响</a>相关的帖子🍀</p><p id="2447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并随时在<a class="ae kv" href="https://www.linkedin.com/in/kaspergroesludvigsen/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系。</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><h1 id="dfc0" class="mz na iq bd nb nc ol ne nf ng om ni nj jw on jx nl jz oo ka nn kc op kd np nq bi translated">参考</h1><p id="80d4" class="pw-post-body-paragraph kw kx iq ky b kz nr jr lb lc ns ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">[1]<a class="ae kv" href="https://arxiv.org/abs/1603.02754" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1603.02754</a></p><p id="898f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://arxiv.org/abs/2101.02118" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2101.02118</a></p><p id="5b44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]<a class="ae kv" href="https://www.linkedin.com/posts/tunguz_datascience-machinelearning-artificialintelligence-activity-6985577378005614592-HnXU?utm_source=share&amp;utm_medium=member_desktop" rel="noopener ugc nofollow" target="_blank">https://www . LinkedIn . com/posts/tunguz _ data science-machine learning-人工智能-activity-6985577378005614592-HnXU？UTM _ source = share&amp;UTM _ medium = member _ desktop</a></p><p id="4e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]<a class="ae kv" href="https://www.energidataservice.dk/tso-electricity/Elspotprices" rel="noopener ugc nofollow" target="_blank">https://www . energidataservice . dk/tso-electricity/Elspotprices</a></p><p id="90fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[5]<a class="ae kv" href="https://www.energidataservice.dk/Conditions_for_use_of_Danish_public_sector_data-License_for_use_of_data_in_ED.pdf" rel="noopener ugc nofollow" target="_blank">https://www . energidataservice . dk/Conditions _ for _ use _ of _ Danish _ public _ sector _ data-License _ for _ use _ of _ data _ in _ ed . pdf</a></p></div></div>    
</body>
</html>