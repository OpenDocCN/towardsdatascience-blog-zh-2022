<html>
<head>
<title>End Python Dependency Hell with pip-compile-multi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 pip-compile-multi 结束 Python 依赖地狱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/end-python-dependency-hell-with-pip-compile-multi-56eea0c55ffe#2022-12-05">https://towardsdatascience.com/end-python-dependency-hell-with-pip-compile-multi-56eea0c55ffe#2022-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="27bc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保持项目的可复制性和复杂的 Python 依赖关系的组织性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/59dc59e603fb47dc094c0959e1b008a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OigNoAIlGNKT7ZfyQ5L7UQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约翰·巴克利普在<a class="ae kv" href="https://unsplash.com/s/photos/complex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="04c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大多数重要的 Python 项目都有复杂的依赖关系管理需求，普通的开源解决方案不足以解决这些需求。一些工具试图解决整个打包体验，而另一些工具旨在解决一两个狭窄的子问题。尽管有无数的解决方案，开发人员仍然面临着相同的依赖关系管理挑战:</p><ol class=""><li id="84b5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">新用户和贡献者如何轻松正确地安装依赖项？</li><li id="a591" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我如何知道我的依赖项都是兼容的？</li><li id="075b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我如何使构建具有确定性和可重复性？</li><li id="854e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我如何确保我的部署工件使用一致和兼容的依赖关系？</li><li id="e88f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我如何避免依赖性膨胀？</li></ol><p id="bbfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章将主要使用<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-compile-multi.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">pip-compile-multi</a></code>来回答这些问题，这是一个开源命令行工具，它扩展了流行的<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-tools.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">pip-tools</a></code>的功能，以满足具有复杂依赖关系的项目的需求。</p><h1 id="5077" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">锁定文件的问题是</h1><p id="6c8d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">部分解决方案是维护一个依赖关系<a class="ae kv" href="https://blog.shalvah.me/posts/understanding-lockfiles" rel="noopener ugc nofollow" target="_blank">锁文件</a>，像<code class="fe mg mh mi mj b"><a class="ae kv" href="https://python-poetry.org/docs/cli/#lock" rel="noopener ugc nofollow" target="_blank">poetry</a></code>和<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-tools.readthedocs.io/en/latest/#example-usage-for-pip-compile" rel="noopener ugc nofollow" target="_blank">pip-tools</a></code>这样的工具可以实现这一点。我们可以把 lockfile 想象成一个“依赖接口”:一个告诉项目需要什么外部依赖才能正常工作的抽象概念。为你的整个项目拥有一个单一的整体锁文件的问题是，作为一个接口，它不是<a class="ae kv" href="https://en.wikipedia.org/wiki/Interface_segregation_principle" rel="noopener ugc nofollow" target="_blank">良好分离的</a>:为了确保兼容性、确定性和可再现性，<em class="nh">代码的每个</em>消费者(用户、开发人员、打包系统、构建工件、部署目标)将需要安装<em class="nh">锁文件枚举的每个</em>单一依赖项——无论他们实际上是否使用它。例如，如果您曾经努力将您的林挺和测试库从您的产品构建中分离出来，您就会遇到这个问题。</p><p id="c854" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由此导致的依赖性膨胀可能是一个真正的问题。除了不必要的膨胀的构建时间和包/工件大小之外，它还增加了您的项目或应用程序中安全漏洞的表面积。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/05eb60a073236b68e8225f699ba88c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*k6PQuDGKmEXHzIILof-kIA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我在一个使用<a class="ae kv" href="https://pyup.io/safety/" rel="noopener ugc nofollow" target="_blank">安全</a>的项目中发现的漏洞。</p></figure><h1 id="0052" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">更好的解决方案</h1><p id="2052" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">理想情况下，我们可以将依赖接口重组为多个更窄的接口——多个锁文件:</p><ul class=""><li id="0b62" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nj ly lz ma bi translated">按功能分组相关性</li><li id="ba97" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nj ly lz ma bi translated">可以互相组合</li><li id="57cc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nj ly lz ma bi translated">可以独立消费</li><li id="768f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nj ly lz ma bi translated">是相互兼容的</li></ul><p id="146d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们能做到这一点，事情就会变得简单:</p><ul class=""><li id="d961" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nj ly lz ma bi translated">了解在哪里使用哪些依赖项</li><li id="55bb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nj ly lz ma bi translated">包装变型(例如定义 pip <a class="ae kv" href="https://packaging.python.org/en/latest/tutorials/installing-packages/#installing-extras" rel="noopener ugc nofollow" target="_blank">附加</a></li><li id="38f3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nj ly lz ma bi translated">多阶段构建(例如<a class="ae kv" href="https://docs.docker.com/build/building/multi-stage/" rel="noopener ugc nofollow" target="_blank"> Docker 多阶段</a></li></ul><p id="31cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-compile-multi.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">pip-compile-multi</a></code>做到了以上几点！这是一个轻量级的、<code class="fe mg mh mi mj b">pip</code>可安装的 CLI，构建在优秀的<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-tools.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">pip-tools</a></code>项目之上。您只需将您的<code class="fe mg mh mi mj b">requirements.txt</code>文件分割成一个或多个<a class="ae kv" href="https://pip.pypa.io/en/stable/reference/requirements-file-format/" rel="noopener ugc nofollow" target="_blank"> pip 需求文件</a>(通常带有后缀<code class="fe mg mh mi mj b">.in</code>)。每个文件可能包含一个或<code class="fe mg mh mi mj b">-r</code> / <code class="fe mg mh mi mj b">--requirement</code>选项，这些选项将文件链接成一个有向无环图(DAG)。依赖关系的 DAG 表示是<code class="fe mg mh mi mj b">pip-compile-multi</code>的核心。</p><h2 id="6de1" class="nk ml iq bd mm nl nm dn mq nn no dp mu lf np nq mw lj nr ns my ln nt nu na nv bi translated">例子</h2><p id="3168" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">比方说你的<code class="fe mg mh mi mj b">requirements.txt</code>长这样:</p><pre class="kg kh ki kj gt nw mj nx bn ny nz bi"><span id="7d6d" class="oa ml iq mj b be ob oc l od oe"># requirements.txt<br/><br/>flake8<br/>mypy<br/>numpy<br/>pandas<br/>torch&gt;1.12</span></pre><p id="c559" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一步是将这些依赖项分成功能组。我们将一组写到<code class="fe mg mh mi mj b">main.in</code>，另一组写到<code class="fe mg mh mi mj b">dev.in</code>。我们现在应该删除我们的<code class="fe mg mh mi mj b">requirements.txt</code>。我们的两个新的<code class="fe mg mh mi mj b">.in</code>文件可能看起来像这样，形成一个简单的双节点依赖 DAG:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/7f32f94fa03e1ec3e2df81c43acb21af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L_jWgNkfXplGx_SVpv8bdQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个简单的双节点依赖 DAG。主项目依赖项放在“main.in”中，我们的代码链接和相关的开发工具放在“dev.in”中。这使我们的依赖项保持逻辑分组。</p></figure><p id="4c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个节点是一个定义依赖组的<code class="fe mg mh mi mj b">.in</code>文件。每个有向边代表一个组对另一个组的需求。每个节点用一个或多个<code class="fe mg mh mi mj b">-r</code> / <code class="fe mg mh mi mj b">--requirement</code>选项定义自己的入边。</p><p id="4d9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们定义了这个依赖 DAG，运行<code class="fe mg mh mi mj b">pip-compile-multi</code>将生成一个等价的 lockfile DAG。该工具将为 DAG 中的每个<code class="fe mg mh mi mj b">.in</code>输出一个<code class="fe mg mh mi mj b">.txt</code> pip 需求文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/7d55300f084af44fae0345cc2928decf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fjUxAHqoFudMofnjBcpOZA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">pip-compile-multi 编译的锁文件 DAG。我已经删除了这些锁文件中自动生成的行内注释，但实际上您永远不需要手动编辑它们。</p></figure><p id="2da7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，生成的锁文件将创建在与<code class="fe mg mh mi mj b">.in</code>文件相同的目录中，并镜像它们的名称。</p><h2 id="a18c" class="nk ml iq bd mm nl nm dn mq nn no dp mu lf np nq mw lj nr ns my ln nt nu na nv bi translated">自动解决跨文件冲突</h2><p id="2283" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">将<code class="fe mg mh mi mj b">pip-compile-multi</code>与其他 lockfiles 工具如<code class="fe mg mh mi mj b">pip-tools</code>区分开来的杀手级特性是<a class="ae kv" href="https://pip-compile-multi.readthedocs.io/en/latest/features.html#autoresolve-cross-file-conflicts" rel="noopener ugc nofollow" target="_blank">自动解决跨文件冲突</a>，使用<code class="fe mg mh mi mj b">--autoresolve</code>标志可以轻松实现。在自动解决模式下，<code class="fe mg mh mi mj b">pip-compile-multi</code>将首先预解决所有依赖关系，然后使用该解决方案来约束每个节点的单个解决方案。这通过防止临时依赖关系中的任何冲突来确保每个锁文件保持相互兼容。为了使用自动解析，您的 DAG 必须正好有一个源节点(请注意，pip-compile-multi 文档反转了 DAG 边的方向，因此当我说 source 时，它们将指 sink 节点，反之亦然)。</p><h2 id="b257" class="nk ml iq bd mm nl nm dn mq nn no dp mu lf np nq mw lj nr ns my ln nt nu na nv bi translated">锁定文件验证</h2><p id="bd78" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">另一个有用的命令是<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-compile-multi.readthedocs.io/en/latest/features.html#check-that-pip-compile-multi-was-run-after-changes-in-in-file" rel="noopener ugc nofollow" target="_blank">pip-compile-multi verify</a></code>，它检查您的锁文件是否与您的<code class="fe mg mh mi mj b">.in</code>文件中指定的相匹配。这是一个简单而有价值的检查，您可以轻松地将其合并到您的 CICD 管道中，以防止错误的依赖关系更新。它甚至可以作为<a class="ae kv" href="https://pip-compile-multi.readthedocs.io/en/latest/precommit.html" rel="noopener ugc nofollow" target="_blank">预提交钩子</a>使用！</p><h1 id="8c11" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">充分利用 pip-compile-multi 的技巧</h1><h2 id="9eb7" class="nk ml iq bd mm nl nm dn mq nn no dp mu lf np nq mw lj nr ns my ln nt nu na nv bi translated">适当地组织依赖关系</h2><p id="dcba" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">如果你把你的依赖关系分组的很差，你就是在为失败做准备。尝试基于代码中依赖项的预期功能来定义组:不要将<code class="fe mg mh mi mj b">flake8</code>(一个代码 linter)与<code class="fe mg mh mi mj b">torch</code>(一个深度学习框架)放在一个组中。</p><h2 id="c60b" class="nk ml iq bd mm nl nm dn mq nn no dp mu lf np nq mw lj nr ns my ln nt nu na nv bi translated">具有单个源节点和单个接收器节点</h2><p id="8315" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我发现，当您可以将最普遍的依赖项组织成一个所有其他节点<em class="nh">都需要</em>(一个汇聚节点)的单一“核心”依赖项集，并将所有开发依赖项组织成一个节点<em class="nh">需要</em>所有其他节点(直接或间接)都需要(一个源)的节点时，效果最好。这种模式使您的 DAG 相对简单，并确保您可以使用 pip-compile-multi 强大的自动解析功能。</p><h2 id="8c5b" class="nk ml iq bd mm nl nm dn mq nn no dp mu lf np nq mw lj nr ns my ln nt nu na nv bi translated">启用画中画缓存</h2><p id="af8c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">设置<code class="fe mg mh mi mj b"><a class="ae kv" href="https://pip-compile-multi.readthedocs.io/en/latest/features.html#use-cache" rel="noopener ugc nofollow" target="_blank">--use-cache</a></code>标志可以显著提高<code class="fe mg mh mi mj b">pip-compile-multi</code>的速度，因为它支持在对<code class="fe mg mh mi mj b">pip-compile</code>的底层调用中进行缓存。</p><h1 id="47cb" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">真实世界的例子</h1><p id="a83c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了让事情更清楚，我们来看一个机器学习领域的例子。</p><p id="268d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个典型的机器学习系统将至少有两个组件:一个训练工作负载，它在一些数据上创建一个模型，以及一个推理服务器，它为模型预测提供服务。</p><p id="7a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个组件都有一些共同的依赖项，比如用于数据处理和建模的库。我们可以在一个名为<code class="fe mg mh mi mj b">main.in</code>的文本文件中列出这些，它只是一个<a class="ae kv" href="https://pip.pypa.io/en/stable/reference/requirements-file-format/" rel="noopener ugc nofollow" target="_blank"> pip 需求文件</a>:</p><pre class="kg kh ki kj gt nw mj nx bn ny nz bi"><span id="bf87" class="oa ml iq mj b be ob oc l od oe"># requirements/main.in<br/><br/>pandas<br/>torch&gt;1.12</span></pre><p id="f15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">训练组件可能对分布式通信、实验跟踪和度量计算有一些特殊的依赖性。我们会把这些放在<code class="fe mg mh mi mj b">training.in</code>:</p><pre class="kg kh ki kj gt nw mj nx bn ny nz bi"><span id="3efd" class="oa ml iq mj b be ob oc l od oe"># requirements/training.in<br/><br/>-r main.in<br/><br/>horovod<br/>mlflow==1.29<br/>torchmetrics</span></pre><p id="9aa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们添加了<code class="fe mg mh mi mj b">-r</code>标志，它告诉 pip-compile-multi<code class="fe mg mh mi mj b">training.in</code>需要来自<code class="fe mg mh mi mj b">main.in</code>的依赖项。</p><p id="7b59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">推理组件将有一些服务和监控的专有依赖项，我们将其添加到<code class="fe mg mh mi mj b">inference.in</code>:</p><pre class="kg kh ki kj gt nw mj nx bn ny nz bi"><span id="49ea" class="oa ml iq mj b be ob oc l od oe"># requirements/inference.in<br/><br/>-r main.in<br/><br/>prometheus<br/>torchserve</span></pre><p id="14ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，整个代码库共享相同的开发工具链。这些开发工具，比如 linters、单元测试模块，甚至<code class="fe mg mh mi mj b">pip-compile-multi</code>本身都在<code class="fe mg mh mi mj b">dev.in</code>中:</p><pre class="kg kh ki kj gt nw mj nx bn ny nz bi"><span id="30bb" class="oa ml iq mj b be ob oc l od oe"># requirements/dev.in<br/><br/>-r inference.in<br/>-r training.in<br/><br/>flake8<br/>pip-compile-multi<br/>pytest</span></pre><p id="4960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次注意，指示<code class="fe mg mh mi mj b">dev.in</code>的<code class="fe mg mh mi mj b">-r</code>标志依赖于<code class="fe mg mh mi mj b">training.in</code>和<code class="fe mg mh mi mj b">inference.in</code>。我们不需要一个<code class="fe mg mh mi mj b">-r main.in</code>，因为<code class="fe mg mh mi mj b">training.in</code>和<code class="fe mg mh mi mj b">inference.in</code>已经有了。</p><p id="4eae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，我们的依赖 DAG 如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/8e426d6d920e3374fac0b35b09d83536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yB1iFqrCRrabDrjJLCUwrw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个四节点依赖 DAG。</p></figure><p id="c70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们的<code class="fe mg mh mi mj b">.in</code>文件位于名为<code class="fe mg mh mi mj b">requirements/</code>的目录中，我们可以使用以下命令来解析我们的 DAG 并生成锁文件:</p><pre class="kg kh ki kj gt nw mj nx bn ny nz bi"><span id="4b60" class="oa ml iq mj b be ob oc l od oe">pip-compile-multi --autoresolve --use-cache --directory=requirements</span></pre><p id="04f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令成功后，您会在<code class="fe mg mh mi mj b">requirements/</code>中看到四个新文件:<code class="fe mg mh mi mj b">main.txt</code>、<code class="fe mg mh mi mj b">training.txt</code>、<code class="fe mg mh mi mj b">inference.txt</code>和<code class="fe mg mh mi mj b">dev.txt</code>。这些是我们的锁档。我们可以像使用有效的<code class="fe mg mh mi mj b">requirements.txt</code>文件一样使用它们。也许我们可以用它们来构建高效的 Docker 多级图像目标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="5be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我们可能是安装环境的新项目贡献者。我们可以简单地运行<code class="fe mg mh mi mj b">pip install -r requirements/dev.txt</code>(或者更好:<code class="fe mg mh mi mj b">pip-sync requirements/dev.txt</code>)在“开发”模式下安装项目，包括所有的开发依赖项。</p><h1 id="93c9" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论</h1><p id="c241" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">用于管理 Python 依赖关系的工具选项数量惊人。很少有工具能够很好地支持按功能划分依赖关系，我认为这已经成为一个常见的项目需求。虽然<code class="fe mg mh mi mj b">pip-compile-multi</code>不是灵丹妙药，但是它支持优雅的依赖分离，并且将它添加到您的项目中非常简单！</p></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><p id="9e39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除非另有说明，所有图片均为作者所有。</p></div></div>    
</body>
</html>