<html>
<head>
<title>PRegEx: Regular Expressions in Plain English in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">pre gex:Python 中普通英语的正则表达式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pregex-regular-expressions-in-plain-english-in-python-4670425d0eb5#2022-12-08">https://towardsdatascience.com/pregex-regular-expressions-in-plain-english-in-python-4670425d0eb5#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="236c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用 Python 创建正则表达式从未如此简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3216ec6ff6d7054ff0d48f45b8c0c174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jw1tYEigZg38tq1pubWmNg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/@pixabay/" rel="noopener ugc nofollow" target="_blank">像素</a>在<a class="ae ky" href="https://www.pexels.com/photo/alphabet-close-up-communication-conceptual-278887/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="d14a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住正则表达式(regex) <a class="ae ky" rel="noopener" target="_blank" href="/a-simple-and-intuitive-guide-to-regular-expressions-404b057b1081">中的元字符并不难</a>，但是构建一个匹配复杂文本模式的元字符有时很有挑战性。</p><p id="508c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们可以用简单的英语构建正则表达式会怎么样？</p><p id="dc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以使用名为 PRegEx 的 Python 库编写易于理解的正则表达式。这个库可以温和地向初学者介绍 regex 的世界，甚至帮助那些已经知道 regex 的人。</p><p id="998b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是这样工作的。</p><h2 id="3cb5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">安装库</h2><p id="7e19" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们需要安装 PRegEx(它需要 Python &gt;= 3.9)</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="4656" class="my lw it mu b be mz na l nb nc">pip install pregex</span></pre><h2 id="af22" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">探索 PRegEx 库</h2><p id="1c14" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们只想捕获包含姓氏、头衔和以下文本名称的行。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="0c2d" class="my lw it mu b be mz na l nd nc">text = """<br/>    Here are the full name of some people:<br/>    Smith, Mr. Robert<br/>    Johnson, Ms Mary<br/>    Wilson, Mrs. Barbara<br/>    Taylor, Dr Karen<br/>    Lewis, Mr. John<br/><br/>"""</span></pre><p id="07fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下代码用 PRegEx 解决这个问题。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="080c" class="my lw it mu b be mz na l nd nc">from pregex.core.classes import AnyButWhitespace<br/>from pregex.core.quantifiers import OneOrMore, Optional<br/>from pregex.core.operators import Either<br/><br/>family_name = OneOrMore(AnyButWhitespace())<br/>title = Either("Mrs", "Mr", "Ms", "Dr")<br/>given_name = OneOrMore(AnyButWhitespace())<br/><br/>pre = (<br/>    family_name +<br/>    ', ' +<br/>    title +<br/>    Optional(".") +<br/>    ' ' +<br/>    given_name<br/>)<br/><br/>pre.get_matches(text)</span></pre><p id="2d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="0b77" class="my lw it mu b be mz na l nd nc">['Smith, Mr. Robert',<br/> 'Johnson, Ms Mary',<br/> 'Wilson, Mrs. Barbara',<br/> 'Taylor, Dr Karen',<br/> 'Lewis, Mr. John']</span></pre><p id="4608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是等价的正则表达式模式。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="c80f" class="my lw it mu b be mz na l nd nc">&gt;&gt;&gt; pre.get_pattern()<br/>'\\S+, (?:Mrs|Mr|Ms|Dr)\\.? \\S+'</span></pre><p id="e6aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们从 pregex 导入的那些元素意味着什么:</p><ul class=""><li id="b00e" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe nn no np mu b">AnyButWhitespace</code>匹配除空白以外的任何字符(相当于 regex 中的<code class="fe nn no np mu b">\S</code>)</li><li id="1c08" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated"><code class="fe nn no np mu b">OneOrMore</code>匹配一个字符一次或多次(相当于 regex 中的<code class="fe nn no np mu b">+</code>)</li><li id="115b" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated"><code class="fe nn no np mu b">Either</code>匹配所提供的模式之一(相当于 regex 中的<code class="fe nn no np mu b">|</code>)</li><li id="ab8f" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated"><code class="fe nn no np mu b">Optional</code>零次或一次匹配一个字符(相当于 regex 中的<code class="fe nn no np mu b">?</code>)</li></ul><p id="f1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然现在我们使用普通英语来匹配文本模式，但我们仍然需要熟悉可以从 pregex 导入的所有元素。</p><p id="be5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过一些例子来探索 pregex 库。</p><h2 id="3f48" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">示例 1:获取正确的日期格式</h2><p id="bd4b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们希望在下面的文本中获得格式 DD-MM-YYYY。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="0f18" class="my lw it mu b be mz na l nd nc">text = """<br/>    04-13-2021<br/>    2021-04-13<br/>    2021-13-04<br/>"""</span></pre><p id="bfe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们如何用 pregex 解决的。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="10d5" class="my lw it mu b be mz na l nd nc">from pregex.core.classes import AnyDigit<br/>from pregex.core.quantifiers import Exactly<br/><br/>two_digits = Exactly(AnyDigit(), 2) <br/>four_digits = Exactly(AnyDigit(), 4)<br/><br/>pre = (<br/>    two_digits +<br/>    "-" +<br/>    two_digits +<br/>    "-" +<br/>    four_digits<br/>)<br/><br/>pre.get_matches(text)</span></pre><p id="0eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="7741" class="my lw it mu b be mz na l nd nc">['04-13-2021']</span></pre><p id="161d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是等价的正则表达式模式。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="bc61" class="my lw it mu b be mz na l nd nc">&gt;&gt;&gt; pre.get_pattern()<br/>'\\d{2}-\\d{2}-\\d{4}'</span></pre><p id="a2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们从 pregex 导入的那些元素意味着什么:</p><ul class=""><li id="7f25" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe nn no np mu b">AnyDigit</code>匹配从 0 到 9 的任何数字(相当于 regex 中的<code class="fe nn no np mu b">\d</code>)</li><li id="4676" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated"><code class="fe nn no np mu b">Exactly</code>匹配重复 n 次的精确字符数(类似于 regex 中的<code class="fe nn no np mu b">{n}</code>)</li></ul><h2 id="7d04" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">示例 2:获得正确的电子邮件格式</h2><p id="d1b9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们希望在下面的文本中得到正确的电子邮件格式。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="6f12" class="my lw it mu b be mz na l nd nc">text = """<br/>    example@python.com<br/>    example@@python.com<br/>    example@python.com.<br/>"""</span></pre><p id="e28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们如何用 pregex 解决的。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="71d2" class="my lw it mu b be mz na l nd nc">from pregex.core.classes import AnyButFrom<br/>from pregex.core.quantifiers import OneOrMore, AtLeast<br/>from pregex.core.assertions import MatchAtLineEnd<br/><br/>non_at_sign_space = OneOrMore(AnyButFrom("@", ' '))<br/>non_at_sign_space_dot = OneOrMore(AnyButFrom("@", ' ', '.'))<br/>domain = MatchAtLineEnd(AtLeast(AnyButFrom("@", ' ', '.'), 2))<br/><br/>pre = (<br/>    non_at_sign_space +<br/>    "@" +<br/>    non_at_sign_space_dot +<br/>    '.' +<br/>    domain<br/>)<br/><br/>pre.get_matches(text)</span></pre><p id="c69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="8a50" class="my lw it mu b be mz na l nd nc">['example@python.com']</span></pre><p id="7a1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是等价的正则表达式模式。</p><pre class="kj kk kl km gt mt mu mv bn mw mx bi"><span id="604f" class="my lw it mu b be mz na l nd nc">&gt;&gt;&gt; pre.get_pattern()<br/>'[^ @]+@[^ .@]+\\.[^ .@]{2,}$'</span></pre><p id="7f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们从 pregex 导入的那些元素意味着什么:</p><ul class=""><li id="a5bb" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><code class="fe nn no np mu b">AnyButFrom</code>匹配除括号内的字符之外的任何字符(相当于 regex 中的<code class="fe nn no np mu b">[^]</code>)</li><li id="6485" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated"><code class="fe nn no np mu b">AtLeast</code>匹配至少一定数量的重复 n 次的字符(类似于 regex 中的<code class="fe nn no np mu b">{n,}</code>)</li><li id="a838" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated"><code class="fe nn no np mu b">MatchAtLineEnd</code>在行尾断言位置(相当于当标志“多行”打开时 regex 中的<code class="fe nn no np mu b">$</code>)</li></ul><p id="638b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恭喜你！您已经完成了掌握正则表达式的第一步！如果你想学习如何构建标准的正则表达式，<a class="ae ky" rel="noopener" target="_blank" href="/a-simple-and-intuitive-guide-to-regular-expressions-404b057b1081">查看本指南</a>。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="f9bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用 Python 学习数据科学？<a class="ae ky" href="https://frankandrade.ck.page/26b76e9130" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">通过加入我的 10k+人电子邮件列表，获取我的免费 Python for Data Science 备忘单。</strong>T11】</a></p><p id="2a75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这样的故事，并想支持我成为一名作家，可以考虑报名成为一名媒体成员。每月 5 美元，让您可以无限制地访问数以千计的 Python 指南和数据科学文章。如果你使用<a class="ae ky" href="https://frank-andrade.medium.com/membership" rel="noopener">我的链接</a>注册，我会赚一小笔佣金，不需要你额外付费。</p><div class="oc od gp gr oe of"><a href="https://frank-andrade.medium.com/membership" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">通过我的推荐链接加入媒体——弗兰克·安德拉德</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">frank-andrade.medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div></div></div>    
</body>
</html>