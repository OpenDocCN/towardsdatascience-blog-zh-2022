<html>
<head>
<title>Constraint Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的约束编程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/constraint-programming-67ac16fa0c81#2022-05-02">https://towardsdatascience.com/constraint-programming-67ac16fa0c81#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="03ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在8，080，104个候选项中找出一个解决方案的编程范例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1318245996f819fd50754345caef6f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siFUe3QoPF-jYlDJVttp5A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="8c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">约束编程是一种技术，<strong class="lb iu">找到每一个解决方案</strong>，尊重一组预定义的约束。</p><p id="1357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于数据科学家来说，它是一个非常有价值的工具，可以用来解决各种各样的问题，比如调度、时间表、排序等等。在本文中，我们将看到如何以两种不同的方式使用CP:</p><ol class=""><li id="f9d0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">可满足性</strong>:目标是通过缩小潜在解决方案的大集合来找到一个或多个可行的解决方案(<em class="me">即</em>，考虑我们的约束的解决方案)；</li><li id="673c" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu ma mb mc md bi translated"><strong class="lb iu">优化</strong>:目标是根据一个目标函数找到最佳可行解，就像线性规划(LP)一样。</li></ol><p id="23a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用来自<a class="ae ky" href="https://developers.google.com/optimization" rel="noopener ugc nofollow" target="_blank"> Google的CP-SAT或-Tools </a>，一个优秀的免费开源CP求解器。请注意，它与MPSolver的<strong class="lb iu">不同，MP solver专用于线性和混合整数编程。CP和LP之间的区别相当令人困惑，我们将在文章的最后触及这个话题。</strong></p><p id="b801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以用下面的<a class="ae ky" href="https://colab.research.google.com/drive/1huTlPTaahdEEO29KKdlW9ic5zAwB3D58?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab笔记本</a>运行代码。</p><h1 id="5c1d" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated"><strong class="ak"> 🪖 I. </strong>三个童子军问题的可满足性</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/d750a8ec5366e7d7b7db81254351dd67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ecB7NyzmEihvfZ65"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="a938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" rel="noopener" target="_blank" href="/integer-programming-vs-linear-programming-in-python-f1be5bb4e60e">上一篇</a>中，我们创造了一支军队来击败对手。但是有一个小问题:我们必须猜测他的军队有多强大。</p><p id="02b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我们就派斥候去了解一下<strong class="lb iu">的确切数字</strong>。我们的3名侦察兵观察了敌营，这是他们告诉我们的:</p><ul class=""><li id="7a16" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nd mb mc md bi translated"><strong class="lb iu">侦察兵1</strong>:<em class="me">士兵数量是13的倍数</em>；</li><li id="9afe" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated"><strong class="lb iu">侦察兵2</strong>:<em class="me">士兵数量是19的倍数</em>；</li><li id="081b" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated"><strong class="lb iu">侦察兵3</strong>:<em class="me">士兵数量是37的倍数</em>；</li><li id="56f8" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated">他们都同意士兵人数<strong class="lb iu">不超过一万</strong>。</li></ul><p id="eb3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的侦察兵有一种个人的清点士兵的方法，但是我们可以<strong class="lb iu">结合</strong>这三种观察做一个模型。</p><p id="029b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把士兵的数量称为<em class="me">军</em>。我们可以将我们的问题转化为以下同余系统:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/a28b46f9e2ce445e8741361fdc9b6e8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4iLRmFqz9Lgh5jcS3RkbqA.png"/></div></div></figure><p id="044d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉这个符号，这是它在<strong class="lb iu">编程术语</strong>中的意思:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9d3600ed1470db91aa02cb8a74926fe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLKf0ZAlsIauO5oWCCSlIw.png"/></div></div></figure><p id="c8a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用OR-Tools来实现吧。我们需要做的第一件事是导入并创建<strong class="lb iu"> CP-SAT模型和求解器</strong>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e32b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">建模过程</strong>与我们在线性编程中所做的非常相似。</p><p id="2323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建我们的CP模型的第一步是声明<strong class="lb iu">变量</strong>。在这个例子中，我们只有一个:<em class="me">军队</em>，士兵的数量。</p><p id="87d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须给出下限和上限。<strong class="lb iu">下限</strong>是1，因为我们知道有军队，而<strong class="lb iu">上限</strong>根据侦察兵的说法是10，000:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9ed43ab942f8e4c9467f29389746733a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chXXQplZZmimL8WbKnQoww.png"/></div></div></figure><p id="d160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在OR-Tools中，我们使用<code class="fe nh ni nj nk b">NewIntVar</code>方法来创建这个变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步是声明<strong class="lb iu">约束</strong>。</p><p id="5c19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们确定了三个约束。模是一个特殊的运算符，所以我们需要一个特定的函数用CP-SAT来处理:<code class="fe nh ni nj nk b">AddModuloEquality</code>。如果你需要其他方法，你可以在<a class="ae ky" href="https://developers.google.com/optimization/reference/python/sat/python/cp_model" rel="noopener ugc nofollow" target="_blank">这个地址</a>找到参考指南。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="302f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不像线性规划，我们<strong class="lb iu">这里不用定义一个目标函数</strong>。</p><p id="4679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因很简单:没什么好优化的！我们只想找到一个满足我们约束的<strong class="lb iu">可行解</strong>，但是没有“好”或“坏”的答案。这是约束编程的一个关键特征。</p><p id="5f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模型是<strong class="lb iu">完成</strong>，我们现在可以要求或-工具来解决它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="00d0" class="np ml it nk b gy nq nr l ns nt">================= Solution =================<br/>Solved in 0.00 milliseconds</span><span id="3a45" class="np ml it nk b gy nu nr l ns nt">🪖 <strong class="nk iu">Army = 9139</strong></span><span id="8a7e" class="np ml it nk b gy nu nr l ns nt">Check solution:<br/>  - Constraint 1: 9139 % 13 = 0<br/>  - Constraint 2: 9139 % 19 = 0<br/>  - Constraint 3: 9139 % 37 = 0</span></pre><p id="e0b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在不到一毫秒的时间内得到了答案:敌军中有9139名士兵。万岁，我们现在可以发射侦察兵了！</p><p id="2f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将搜索空间限制在上限10000，这给了我们一个<strong class="lb iu">唯一解</strong>。但是如果我们推这个极限，情况还是这样吗？</p><p id="9609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CP的另一个好处是能够找到问题的每一个可能的解决方案。当搜索空间很大时，这可能需要很长时间，因为求解器必须强力搜索整个空间(而不是用试探法减少空间)。让我们通过打印每个可能的解来探索这个特性，每个解都有一个新的上限<strong class="lb iu"> 100，000 </strong>。</p><p id="dece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用OR-Tools，我们要求求解器根据<code class="fe nh ni nj nk b">enumerate_all_solutions</code>参数寻找每一个可能的解。然后我们给它分配一个<strong class="lb iu">回调</strong>类，打印求解器找到的每个解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们找到了<strong class="lb iu"> 10种解决方案</strong>！这是意料之中的，因为我们将上限提高了十倍:这些解都是9，139的倍数。</p><p id="b219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，这个例子与优化无关:这是一个纯粹的<strong class="lb iu">可满足性问题</strong>。另一方面，这个同余系统可以用<a class="ae ky" href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem" rel="noopener ugc nofollow" target="_blank">中国剩余定理</a>手动求解。但是CP不仅限于此…</p><h1 id="9301" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated"><strong class="ak">🍻二。优化和啤酒</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/a56089862956c38d59661817a907c616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*MC2frLKtps7KzfWm9bU9WA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="f5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来看另一个问题:我军还有几天就要面对敌人了。与此同时，军需官必须准备好战役中要用到的口粮。</p><p id="efc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">补给车的空间有限，一些口粮比其他的更受T21人欢迎。有三种可能的配给:</p><ul class=""><li id="f821" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nd mb mc md bi translated">🥖<strong class="lb iu">面包</strong>:只占1个空间但是人气3士兵没那么喜欢；</li><li id="2274" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated">🥩<strong class="lb iu">肉</strong>:占3格，人气10；</li><li id="84db" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated">🍺<strong class="lb iu">啤酒</strong>:占了7个空位但是士兵爱吃，人气26。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/cb38daf657905e0326caf2983e8db87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ohhu4xMwcjntxSt3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="c4f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">补给车的容量为<strong class="lb iu"> 19个车位</strong>。如何挑选最好的口粮来使<strong class="lb iu">的知名度最大化</strong>？</p><p id="b780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个我们已经见过的<strong class="lb iu">优化</strong>问题:实际上，它是著名的<a class="ae ky" href="https://en.wikipedia.org/wiki/Knapsack_problem" rel="noopener ugc nofollow" target="_blank">背包问题</a>的变体。我们可以重用前一篇文章中的代码，只需更改输入参数。</p><p id="0374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将使用约束编程来解决它。这种范式并不局限于寻找可行的解决方案。它还可以使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Constrained_optimization" rel="noopener ugc nofollow" target="_blank">不同的算法</a>来处理这种开销，从而执行优化。</p><p id="916a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个问题模型。首先，我们必须声明三个变量:🥖<strong class="lb iu">面包</strong>，🥩<strong class="lb iu">肉</strong>，和🍺<strong class="lb iu">啤酒</strong>。可以有0个，但数量不能超过最大容量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/5857d6e18ca80cca9437977afe208aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2TB2GazZ_46yRhkbWOh9Q.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="62cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们只有一个约束:面包、肉和啤酒所占据的空间<strong class="lb iu">不能超过货车的容量</strong> (19)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/4162b985f26a389f4d05a88af2280aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erkeHM-AVqXzt6rdX_lnAw.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="85b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望<strong class="lb iu">最大化所选口粮的总受欢迎度</strong>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/069c16e83b0bf7e1072a115ced22083c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2azOO5maKR8xM_l92y2yjA.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="cbbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模型完成，CP-SAT可以<strong class="lb iu">解决问题</strong>！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="ccef" class="np ml it nk b gy nq nr l ns nt">================= Solution =================<br/>Solved in 0.00 milliseconds</span><span id="b8e9" class="np ml it nk b gy nu nr l ns nt">Optimal value = <strong class="nk iu">68 popularity</strong><br/>Food:<br/>  - 🥖Bread = 2<br/>  - 🥩Meat  = 1<br/>  - 🍺Beer  = 2</span></pre><p id="51bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们获得了<strong class="lb iu">最高人气</strong> (68)可能容量19。</p><p id="3d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">约束是否得到尊重？我们赶紧查一下:1×2🥖 + 3×1 🥩 + 7×2 🍺= 19，确实≤ 19。</p><p id="926f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，我想问另一个问题:<strong class="lb iu">这个问题有多少种解决方案</strong>？再次，我们可以用一个具体的回调来回答它，来统计它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nf ng l"/></div></figure><pre class="kj kk kl km gt nl nk nm nn aw no bi"><span id="4844" class="np ml it nk b gy nq nr l ns nt">121</span></pre><p id="6e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们找到了容量为19的121个解决方案。但是这个数字很快就增加了:容量为1000，就有<strong class="lb iu">8080104</strong>个可能的解决方案！然而，CP-SAT在不到一秒的时间内就找到了最优解。怎么可能呢？</p><p id="9b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CP求解器不会用穷举搜索来强力解决问题，而是结合<strong class="lb iu">试探法和组合搜索。更具体地说，约束满足问题最流行的三种技术是<a class="ae ky" href="https://en.wikipedia.org/wiki/Backtracking" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a><a class="ae ky" href="https://en.wikipedia.org/wiki/Local_consistency" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">约束传播</strong></a><a class="ae ky" href="https://en.wikipedia.org/wiki/Local_search_(optimization)" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">局部搜索</strong> </a>。</strong></p><p id="8614" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CP-SAT很特别，因为它结合了CP和SAT:它是合并CP、LP、SAT和元启发式的更广泛趋势的一部分。</p><p id="52bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们说过前面的问题可以用线性编程来解决，所以让我们比较一下两种解决方案的代码:</p><div class="kj kk kl km gt ab cb"><figure class="nx kn ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/cac5e4a32ab15e3539db8305a0addffc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*yoDKrCAPjz81py6kOAjZYA.png"/></div></figure><figure class="nx kn ny nz oa ob oc paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/cf1ab338c267b1b5339171802cf8050a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*K2RxthvVBImgb0lLYHnzZg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk od di oe of translated">左:LP码，右:CP码(图片由作者提供)</p></figure></div><p id="2052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，语法非常相似，但并不相同:模型/解算器与解算器，<code class="fe nh ni nj nk b">NewIntVar</code>而不是<code class="fe nh ni nj nk b">IntVar</code>，等等。有一点翻译要做，但它很容易管理。</p><p id="6a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种技术<strong class="lb iu">非常接近</strong>:它们都处理带约束的变量，并使用数学和启发式方法进行优化。然而，CP仅限于离散参数，而LP处理连续参数。另一方面，您可以在CP中实现类似于<a class="ae ky" href="https://www.ibm.com/docs/en/icos/12.9.0?topic=variables-all-different-constraint" rel="noopener ugc nofollow" target="_blank">【所有不同】</a>的专门化约束，但在LP中却不能。下面总结了这两种技术之间的主要区别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/7d143e02215d626c40b8893a7a1ab428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qy8YsO-Bsx9J_MdW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供，表情符号由<a class="ae ky" href="https://openmoji.org/" rel="noopener ugc nofollow" target="_blank">open moji</a>(<a class="ae ky" href="https://creativecommons.org/licenses/by-sa/4.0/#" rel="noopener ugc nofollow" target="_blank">CC BY-SA 4.0</a>)</p></figure><p id="35e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于这个话题的内容，我推荐Irvin J. Lustig的这篇文章和Jean-Fran ois Puget的文章<a class="oh oi ep" href="https://medium.com/u/4e50789e7750?source=post_page-----67ac16fa0c81--------------------------------" rel="noopener" target="_blank">。在建模和优化方面，CPLEX的文档还详细描述了这个地址</a>的不同之处<a class="ae ky" href="http://ibmdecisionoptimization.github.io/docplex-doc/mp_vs_cp.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="0066" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/27ddf86f6d73bfadbb9ce51f13536a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLLPbmxqGxwzPttCVO90IA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">约束编程是<strong class="lb iu">数学优化</strong>工具箱中另一项令人难以置信的技术。与传统的声明式编程相比，这是一种完全不同的方法。在这篇文章中，</p><ul class=""><li id="71c7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nd mb mc md bi translated">我们看到<strong class="lb iu">CP的两个应用</strong>具有可满足性和优化性；</li><li id="d6b1" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated">我们在OR-Tools中实现了<strong class="lb iu"> CP模型</strong>，玩了回调函数；</li><li id="ac5e" class="lv lw it lb b lc mf lf mg li mh lm mi lq mj lu nd mb mc md bi translated">我们强调了CP和LP之间的<strong class="lb iu">差异</strong>。</li></ul><p id="e616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本介绍中，我们将自己限制在简单的问题上，但是CP在复杂的调度和路由问题上有着惊人的应用。这是我想在以后的文章中讨论的话题。</p><p id="6694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣了解更多，请随时在<strong class="lb iu"> Twitter </strong>上关注我，地址是<a class="ae ky" href="https://twitter.com/maximelabonne" rel="noopener ugc nofollow" target="_blank">@ maxime labanne</a>。感谢您的关注！</p><h1 id="a580" class="mk ml it bd mm mn mo mp mq mr ms mt mu jz mv ka mw kc mx kd my kf mz kg na nb bi translated">相关文章</h1><div class="ok ol gp gr om on"><a rel="noopener follow" target="_blank" href="/introduction-to-linear-programming-in-python-9261e7eb44b"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Python中的线性编程简介</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用谷歌或工具进行数学优化的指南</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener follow" target="_blank" href="/integer-programming-vs-linear-programming-in-python-f1be5bb4e60e"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">Python中整数与线性编程的比较</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">识别和解决任何优化问题的指南</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb ks on"/></div></div></a></div></div></div>    
</body>
</html>