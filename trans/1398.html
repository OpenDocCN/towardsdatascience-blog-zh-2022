<html>
<head>
<title>A Library to Unify Names in a Messy String Column</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个在混乱的字符串列中统一名称的库</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-library-to-unify-names-in-a-messy-string-column-d77e0ef521b2#2022-04-06">https://towardsdatascience.com/a-library-to-unify-names-in-a-messy-string-column-d77e0ef521b2#2022-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="62ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种统一熊猫字符串列中名字的方法。</h2></div><h2 id="1296" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h2><p id="7122" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">当处理pandas数据帧中的字符串列时，经常会遇到输入错误，同一名称有许多变体。我在查看SP IPTU房地产数据集的邻里专栏时遇到了这个问题(要了解如何下载这些数据的更多信息，请单击<a class="ae lx" href="https://gestaourbana.prefeitura.sp.gov.br/noticias/prefeitura-disponibiliza-base-do-iptu-em-formato-aberto-no-geosampa/" rel="noopener ugc nofollow" target="_blank">此处</a>)。下面是一个名称变体类型的示例:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/e06e7215836662884e88ddb8f2cc2381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YaKMYyAFR3ZfI1kC8t-aFQ.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="2b80" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">这是有问题的，因为我们只需要一种方法来书写每个实体的邻域名称。让我们看看如何解决这个问题。</p><h2 id="6154" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">方法学</h2><p id="e9bd" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">由于我们有许多以非常不同的方式书写的名字，第一步将是减少只有最可能的名字的名字列表。为此，我们可以查看每个唯一名称的出现次数，只保留出现频率最高的名称。对于我的情况，我的数据集有超过2000万条线，每个街区可能包含数千套公寓。我过滤了最有可能出现超过5000次的街区名称。如果数据集较小或每个唯一实体出现的次数较少，则应调整此过滤。这个过滤部分不是强制性的，但它有助于减少真实姓名候选人的数量。</p><p id="b826" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">从这个唯一名称列表中，我使用<a class="ae lx" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank"> fuzzywuzzy </a>包基于<a class="ae lx" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein </a>距离对相似名称执行重复数据删除:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3634" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">在这里，名为<em class="mv"> unique_bairro </em>的列表现在没有任何重复的名称。</p><p id="e699" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">在那之后，我们获得一个减少的邻居名称列表，这将是我们的候选，作为每个邻居的最终名称。我们称之为<em class="mv">邻居列表</em>。</p><p id="6eb6" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">然后，对于字符串列中所有唯一的名字，我们使用<a class="ae lx" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank"> fuzzywuzzy </a>包在邻居列表中获得一个匹配及其分数(其中100表示完全匹配)。</p><p id="4d42" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">下面是一个单词匹配过程的示例:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi mw"><img src="../Images/161707edbe4da7e9ce9a48cf66000753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9V8OFM2nat5qgbZkVrm_Q.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="400c" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">我们可以看到它成功的找到了96分的好配“圣埃菲格尼亚”。100分意味着完全匹配，通常80分以上是很好的候选人。</p><p id="d658" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">让我们再解释一下匹配过程如何与<a class="ae lx" href="https://github.com/seatgeek/fuzzywuzzy" rel="noopener ugc nofollow" target="_blank"> fuzzywuzzy </a>包一起工作:</p><ul class=""><li id="1c3d" class="mx my it lg b lh mo lk mp kr mz kv na kz nb lw nc nd ne nf bi translated">比率函数计算两个序列之间的标准<a class="ae lx" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein距离</a>相似性比率。</li><li id="ca6c" class="mx my it lg b lh ng lk nh kr ni kv nj kz nk lw nc nd ne nf bi translated">使用“最优部分”逻辑:如果短字符串的长度为k，而较长的字符串的长度为m，则算法会寻找最佳匹配长度为k的子字符串的得分。</li><li id="5758" class="mx my it lg b lh ng lk nh kr ni kv nj kz nk lw nc nd ne nf bi translated">字符串被<a class="ae lx" href="https://nlp.stanford.edu/IR-book/html/htmledition/tokenization-1.html" rel="noopener ugc nofollow" target="_blank">标记化</a>，并通过将它们转换成小写和去掉标点符号进行预处理。</li><li id="d8d6" class="mx my it lg b lh ng lk nh kr ni kv nj kz nk lw nc nd ne nf bi translated">字符串标记按字母顺序排序，然后连接在一起。之后，应用比率函数来获得相似性百分比。</li></ul><p id="a55d" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">现在我们已经看到了一个单词的过程，我们将在字符串列' bairros '中获得所有唯一名称的匹配。由此，我们创建了一个表，其中包含所有唯一名称的最佳匹配及其得分。以下是结果的一个示例:</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi nl"><img src="../Images/c574c2c26ba7702ee39b082254a67da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VtdtsW04TLeXVks23B88Qg.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="25fb" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">然后，我们过滤80分以上的分数，以确定所有唯一名称的匹配对应关系。<br/>当分数低于80分时，我们不承认任何比赛。</p><p id="d11c" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">我们可以对所有唯一的名称使用这种表对应来合并回原始的邻居表。我们现在有了具有统一名称的邻居列(列“最佳匹配”)。</p><h2 id="1050" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">一个应用整个过程的库</h2><p id="6ed0" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在混乱的字符串列中统一名称非常有用，可以应用于许多类型的字符串列。出于这个原因，我们决定将这个过程转换成一个简单的库，让每个人都可以使用。<br/>图书馆的知识库可以在<a class="ae lx" href="https://github.com/vincent-belz/unifyname" rel="noopener ugc nofollow" target="_blank">这里找到</a></p><p id="99f7" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">要使用该库，只需在终端中键入:</p><blockquote class="nm nn no"><p id="2ea9" class="le lf mv lg b lh mo ju lj lk mp jx lm np mq lo lp nq mr lr ls nr ms lu lv lw im bi translated">pip安装统一名称</p></blockquote><p id="ea7f" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">以下是我们如何在玩具数据集中应用该库的示例:</p><figure class="lz ma mb mc gt md"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ns"><img src="../Images/3176a0c67d055faa46df5be00b53f305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XLicJ2MrERAXAkIQDp4F7w.png"/></div></div><p class="mk ml gj gh gi mm mn bd b be z dk translated">作者图片</p></figure><p id="4860" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">点击<a class="ae lx" href="https://github.com/vincent-belz/unifyname/blob/master/demo/demo.ipynb" rel="noopener ugc nofollow" target="_blank">此处</a>可获得演示笔记本。</p><p id="ee65" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">图书馆成功地将名字统一为“圣埃菲金尼亚”</p><p id="730a" class="pw-post-body-paragraph le lf it lg b lh mo ju lj lk mp jx lm kr mq lo lp kv mr lr ls kz ms lu lv lw im bi translated">正如我们所看到的，处理一个具有许多不同名称的字符串列是很有挑战性的。我们提出了解决这个问题的方法。我们制作了一个易于使用的库，这样你就可以用一行代码申请你自己的数据集。为您自己的项目尝试一下吧！</p></div></div>    
</body>
</html>