<html>
<head>
<title>The Performance Advantage of No-Copy DataFrame Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无拷贝数据帧操作的性能优势</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-performance-advantage-of-no-copy-dataframe-operations-7bf8c565c9a0#2022-11-29">https://towardsdatascience.com/the-performance-advantage-of-no-copy-dataframe-operations-7bf8c565c9a0#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="57b8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">StaticFrame 如何通过采用 NumPy 数组视图超越 Pandas</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/316a9e044b1c692b78d22f96c6f225c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n885ehcxnbgn82fp-RC8kA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3009" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">NumPy 数组是一个 Python 对象，它将数据存储在一个连续的 C 数组缓冲区中。这些数组的优异性能不仅来自这种紧凑的表示，还来自数组在许多数组之间共享该缓冲区“视图”的能力。NumPy 经常使用“无复制”数组操作，在不复制底层数据缓冲区的情况下生成派生数组。通过充分利用 NumPy 的效率，<a class="ae lr" href="https://github.com/static-frame/static-frame" rel="noopener ugc nofollow" target="_blank"> StaticFrame </a> DataFrame 库为许多常见操作提供了比 Pandas 好几个数量级的性能。</p><h1 id="3eaa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">NumPy 数组的无拷贝操作</h1><p id="b4f4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">短语“无拷贝”描述了对容器(这里是数组或数据帧)的操作，其中创建了新的实例，但是底层数据被引用，而不是被拷贝。虽然为实例分配了一些新内存，但是与潜在的大量底层数据相比，这些内存的大小通常是微不足道的。</p><p id="ec0a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">NumPy 使无拷贝操作成为处理数组的主要方式。当您对 NumPy 数组进行切片时，您将获得一个新数组，该数组共享从其切片的数据。对数组切片是一种无拷贝操作。通过不必复制已经分配的连续缓冲区，而是将偏移量和步长存储到该数据中，可以获得非凡的性能。</p><p id="062c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，对一个包含 100，000 个整数(~0.1 s)的数组进行切片，然后复制同一个数组(~10 s)，两者之间的差别是两个数量级。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="5b9f" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; data = np.arange(100_000)<br/>&gt;&gt;&gt; %timeit data[:50_000]<br/>123 ns ± 0.565 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)<br/>&gt;&gt;&gt; %timeit data[:50_000].copy()<br/>13.1 µs ± 48.4 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)</span></pre><p id="99d1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过检查 NumPy 数组的两个属性来说明这是如何工作的。<code class="fe mz na nb mq b">flags</code>属性显示了如何引用数组内存的详细信息。如果设置了<code class="fe mz na nb mq b">base</code>属性，它将提供一个数组句柄，该数组实际上保存了该数组引用的缓冲区。</p><p id="34ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的例子中，我们创建一个数组，取一个切片，并查看切片的<code class="fe mz na nb mq b">flags</code>。我们看到，对于切片，<code class="fe mz na nb mq b">OWNDATA</code>是<code class="fe mz na nb mq b">False</code>，切片的<code class="fe mz na nb mq b">base</code>是原始数组(它们有相同的对象标识符)。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="d8a3" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; a1 = np.arange(12)<br/>&gt;&gt;&gt; a1<br/>array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])<br/><br/>&gt;&gt;&gt; a2 = a1[:6]<br/>&gt;&gt;&gt; a2.flags<br/>  C_CONTIGUOUS : True<br/>  F_CONTIGUOUS : True<br/>  OWNDATA : False<br/>  WRITEABLE : True<br/>  ALIGNED : True<br/>  WRITEBACKIFCOPY : False<br/>  UPDATEIFCOPY : False<br/><br/>&gt;&gt;&gt; id(a1), id(a2.base)<br/>(140506320732848, 140506320732848)</span></pre><p id="f7b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些派生的数组是原始数组的“视图”。视图只能在特定条件下拍摄:整形、转置或切片。</p><p id="4b3d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，在将最初的 1D 数组重新整形为 2D 数组后，<code class="fe mz na nb mq b">OWNDATA</code>是<code class="fe mz na nb mq b">False</code>，表明它仍然引用原始数组的数据。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="7bd3" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; a3 = a1.reshape(3,4)<br/>&gt;&gt;&gt; a3<br/>array([[ 0,  1,  2,  3],<br/>       [ 4,  5,  6,  7],<br/>       [ 8,  9, 10, 11]])<br/>&gt;&gt;&gt; a3.flags<br/>  C_CONTIGUOUS : True<br/>  F_CONTIGUOUS : False<br/>  OWNDATA : False<br/>  WRITEABLE : True<br/>  ALIGNED : True<br/>  WRITEBACKIFCOPY : False<br/>  UPDATEIFCOPY : False<br/><br/>&gt;&gt;&gt; id(a3.base), id(a1)<br/>(140506320732848, 140506320732848)</span></pre><p id="823c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个 2D 数组的水平和垂直切片同样会产生只引用原始数组数据的数组。同样，<code class="fe mz na nb mq b">OWNDATA</code>是<code class="fe mz na nb mq b">False</code>，切片的<code class="fe mz na nb mq b">base</code>是原数组。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="dde7" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; a4 = a3[:, 2]<br/>&gt;&gt;&gt; a4<br/>array([ 2,  6, 10])<br/><br/>&gt;&gt;&gt; a4.flags<br/>  C_CONTIGUOUS : False<br/>  F_CONTIGUOUS : False<br/>  OWNDATA : False<br/>  WRITEABLE : True<br/>  ALIGNED : True<br/>  WRITEBACKIFCOPY : False<br/>  UPDATEIFCOPY : False<br/><br/>&gt;&gt;&gt; id(a1), id(a4.base)<br/>(140506320732848, 140506320732848)</span></pre><p id="d3b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然创建共享内存缓冲区的轻量级视图提供了显著的性能优势，但也存在风险:改变这些数组中的任何一个都会改变所有数组。如下所示，将<code class="fe mz na nb mq b">-1</code>分配给我们的最具衍生性的数组反映在每个关联的数组中。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="6031" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; a4[0] = -1<br/>&gt;&gt;&gt; a4<br/>array([-1,  6, 10])<br/>&gt;&gt;&gt; a3<br/>array([[ 0,  1, -1,  3],<br/>       [ 4,  5,  6,  7],<br/>       [ 8,  9, 10, 11]])<br/>&gt;&gt;&gt; a2<br/>array([ 0,  1, -1,  3,  4,  5])<br/>&gt;&gt;&gt; a1<br/>array([ 0,  1, -1,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span></pre><p id="e780" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像这样的副作用应该引起你的注意。将共享缓冲区的视图传递给可能改变这些缓冲区的客户端会导致严重的缺陷。这个问题有两个解决方案。</p><p id="b00c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一种选择是调用者在每次创建新数组时进行显式的“防御性”复制。这消除了共享视图的性能优势，但确保了改变数组不会导致意外的副作用。</p><p id="5ba8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另一个不需要牺牲性能的选择是使数组不可变。通过这样做，可以共享数组的视图，而不用担心突变会导致意想不到的副作用。</p><p id="e44d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过在<code class="fe mz na nb mq b">flags</code>接口上将<code class="fe mz na nb mq b">writeable</code>标志设置为<code class="fe mz na nb mq b">False</code>，可以很容易地使 NumPy 数组成为不可变的。设置该值后，<code class="fe mz na nb mq b">flags</code>显示将<code class="fe mz na nb mq b">WRITEABLE</code>显示为<code class="fe mz na nb mq b">False</code>，试图改变该数组会导致异常。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="bcfa" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; a1.flags.writeable = False<br/>&gt;&gt;&gt; a1.flags<br/>  C_CONTIGUOUS : True<br/>  F_CONTIGUOUS : True<br/>  OWNDATA : True<br/>  WRITEABLE : False<br/>  ALIGNED : True<br/>  WRITEBACKIFCOPY : False<br/>  UPDATEIFCOPY : False<br/><br/>&gt;&gt;&gt; a1[0] = -1<br/>Traceback (most recent call last):<br/>  File "&lt;console&gt;", line 1, in &lt;module&gt;<br/>ValueError: assignment destination is read-only</span></pre><p id="7698" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通过包含 NumPy 数组的不可变视图，最佳性能是可能的，并且没有副作用的风险。</p><h1 id="d076" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">无拷贝数据帧操作的优势</h1><p id="135b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">基于不可变数组的数据模型以最小的风险提供最佳的性能，这一见解是创建 StaticFrame 数据帧库的基础。由于 StaticFrame(像 Pandas)管理存储在 NumPy 数组中的数据，所以使用数组视图(而不必制作防御性副本)提供了显著的性能优势。如果没有不可变的数据模型，Pandas 就不能使用数组视图。</p><p id="867b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">StaticFrame 并不总是比 Pandas 快:Pandas 对于连接和其他专门的转换有非常高性能的操作。但是当利用无拷贝数组操作时，StaticFrame 可以快得多。</p><p id="6e0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了比较性能，我们将使用<a class="ae lr" href="https://github.com/static-frame/frame-fixtures" rel="noopener ugc nofollow" target="_blank"> FrameFixtures </a>库创建两个 10，000 行、1，000 列的异构类型的数据帧。对于这两者，我们可以将静态框架<code class="fe mz na nb mq b">Frame</code>转换成熊猫<code class="fe mz na nb mq b">DataFrame</code>。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="dc61" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; import static_frame as sf<br/>&gt;&gt;&gt; import pandas as pd<br/>&gt;&gt;&gt; sf.__version__, pd.__version__<br/>('0.9.21', '1.5.1')<br/><br/>&gt;&gt;&gt; import frame_fixtures as ff<br/>&gt;&gt;&gt; f1 = ff.parse('s(10_000,1000)|v(int,int,str,float)')<br/>&gt;&gt;&gt; df1 = f1.to_pandas()<br/>&gt;&gt;&gt; f2 = ff.parse('s(10_000,1000)|v(int,bool,bool,float)')<br/>&gt;&gt;&gt; df2 = f2.to_pandas()</span></pre><p id="0378" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无复制操作优势的一个简单例子是重命名轴。对于熊猫，所有底层数据都是防御性复制的。使用 StaticFrame，所有底层数据都被重用；只需要制造轻质的外部容器。StaticFrame (~0.01 ms)几乎比熊猫(~100 ms)快四个数量级。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="cc43" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; %timeit f1.rename(index='foo')<br/>35.8 µs ± 496 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)<br/>&gt;&gt;&gt; %timeit df1.rename_axis('foo')<br/>167 ms ± 4.72 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="038c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">给定一个数据帧，通常需要在索引中加入一列。当 Pandas 这样做时，它必须将列数据复制到索引，以及复制所有底层数据。StaticFrame 可以重用索引中的列视图，也可以重用所有底层数据。StaticFrame (~1 ms)比熊猫(~100 ms)快两个数量级。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="8cf4" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; %timeit f1.set_index(0)<br/>1.25 ms ± 23.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/>&gt;&gt;&gt; %timeit df1.set_index(0, drop=False)<br/>166 ms ± 3.52 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="4cef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从数据帧中提取列的子集是另一种常见的操作。对于 StaticFrame，这是一个无复制操作:返回的 DataFrame 只是保存原始 DataFrame 中列数据的视图。StaticFrame (~10 s)做这个比熊猫(~100 s)快一个数量级。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="410a" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; %timeit f1[[10, 50, 100, 500]]<br/>25.4 µs ± 471 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each)<br/>&gt;&gt;&gt; %timeit df1[[10, 50, 100, 500]]<br/>729 µs ± 4.14 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)</span></pre><p id="8090" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">连接两个或多个数据帧是很常见的。如果它们有相同的索引，并且我们水平连接它们，StaticFrame 可以重用输入的所有底层数据，使这种形式的连接成为无拷贝操作。StaticFrame (~1 ms)做这个比熊猫(~100 ms)快两个数量级。</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="eee7" class="mu lt iq mq b be mv mw l mx my">&gt;&gt;&gt; %timeit sf.Frame.from_concat((f1, f2), axis=1, columns=sf.IndexAutoFactory)<br/>1.16 ms ± 50.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)<br/>&gt;&gt;&gt; %timeit pd.concat((df1, df2), axis=1)<br/>102 ms ± 14.4 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><h1 id="5732" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="8be7" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">NumPy 旨在利用数据的共享视图。因为 Pandas 允许就地变异，所以它不能充分利用 NumPy 数组视图。由于 StaticFrame 构建在不可变的数据模型上，因此消除了副作用突变的风险，并且包含了无拷贝操作，从而提供了显著的性能优势。</p></div></div>    
</body>
</html>