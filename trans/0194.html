<html>
<head>
<title>Kubernetes Deployment of a Machine Learning Rest API in the Cloud</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes 在云中部署机器学习 Rest API</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/kubernetes-deployment-of-a-machine-learning-rest-api-in-the-cloud-447debf6fb5c#2022-02-08">https://towardsdatascience.com/kubernetes-deployment-of-a-machine-learning-rest-api-in-the-cloud-447debf6fb5c#2022-02-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5053" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于 Kubernetes 概念基础以及如何在 Azure Kubernetes 服务上设置机器学习 Rest API 的分步指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/884b1b31467a72c94d25f1a10e07625b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64Io23eVHdWD_WB_s7PTvQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://pixabay.com/photos/container-storage-trade-haulage-4203677/" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><h2 id="86d2" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">什么是 Kubernetes？</strong></h2><p id="ed52" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为生产部署创建可扩展的 DevOps 管道需要支持多个日常部署、超大规模扩展和软件应用监控。Kubernetes 是一个强大的 DevOps 工具，用于实现可伸缩的软件应用程序部署。Kubernetes 是一个工具，用于自动部署一个应用程序的多个实例，扩展、更新和监控部署的健康状况。Kubernetes 通过<strong class="lu ir">容器编排</strong>来完成这些。</p><h2 id="f722" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">什么是容器编排？</strong></h2><p id="fdaa" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">它是容器化应用程序的多个实例的部署、扩展、管理和监控的自动化。</p><blockquote class="ml"><p id="1f4e" class="mm mn iq bd mo mp mq mr ms mt mu mk dk translated"><strong class="ak">注:</strong>在本教程中，我们将和 Kubernetes 一起讨论<strong class="ak"> <em class="mv"> docker 容器编排</em> </strong>。</p></blockquote><h2 id="f4d3" class="kw kx iq bd ky kz mw dn lb lc mx dp le lf my lh li lj mz ll lm ln na lp lq lr bi translated">目录</h2><p id="ce7b" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated"><strong class="lu ir"> 1 </strong> <a class="ae kv" href="http://medium.com/p/447debf6fb5c/#5d76" rel="noopener"> <strong class="lu ir"> Kubernetes 安装</strong> </a></p><p id="709e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir"> 2 </strong> <a class="ae kv" href="http://medium.com/p/447debf6fb5c/#8126" rel="noopener"> <strong class="lu ir"> Kubernetes 关键概念</strong> </a></p><p id="f873" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">3</strong><a class="ae kv" href="http://medium.com/p/447debf6fb5c/#9ffc" rel="noopener"><strong class="lu ir">Kubernetes 部署的概念</strong> </a></p><p id="3650" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir"> 4 </strong> <a class="ae kv" href="http://medium.com/p/447debf6fb5c/#5f90" rel="noopener"> <strong class="lu ir">在</strong> <strong class="lu ir"> Azure Kubernetes 服务</strong> </a>上设置机器学习应用的分步指南</p><h2 id="5d76" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Kubernetes 装置</h2><p id="9bba" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Kubectl :这是用于管理 Kubernetes 的命令行工具，用户通过它与 Kubernetes 集群通信。我们使用<strong class="lu ir"> <em class="ng"> Kubectl </em> </strong>将命令传递给 Kubernetes 集群。在本文的后面部分，我将描述 Kubernetes 集群及其组件。</p><p id="4896" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">在 Linux 上安装 Kubectl</strong></p><div class="nh ni gp gr nj nk"><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">在 Linux 上安装和设置 kubectl</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">在开始之前，您必须使用与您的集群相差一个次要版本的 kubectl 版本。对于…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">kubernetes.io</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div><p id="4581" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">在 Windows 上安装 ku bectl</strong></p><div class="nh ni gp gr nj nk"><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-windows/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">在 Windows 上安装和设置 kubectl</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">在开始之前，您必须使用与您的集群相差一个次要版本的 kubectl 版本。对于…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">kubernetes.io</p></div></div><div class="nt l"><div class="nz l nv nw nx nt ny kp nk"/></div></div></a></div><p id="6d95" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">在 MacOS 上安装 Kubectl</strong></p><div class="nh ni gp gr nj nk"><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-macos/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">在 macOS 上安装和设置 kubectl</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">在开始之前，您必须使用与您的集群相差一个次要版本的 kubectl 版本。对于…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">kubernetes.io</p></div></div><div class="nt l"><div class="oa l nv nw nx nt ny kp nk"/></div></div></a></div><h2 id="8126" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Kubernetes 的关键概念</h2><p id="ee1f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">Kubernetes 中有很多令人困惑的概念，对于初学者来说理解起来非常困难。在本教程中，我将阐述 Kubernetes 的基本概念，并解释如何在 Azure cloud 中使用 Kubernetes 执行逐步部署。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/aee77ec00fbcbfa2c0c264747198daf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DQ3jFSQ9iB4fjkQzLa_2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="25e0" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">此图展示了 Kubernetes 集群及其组件。它显示了一个具有单个节点和一个控制平面的群集。</p><p id="687b" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">Kubernetes 集群:它是服务器的组合，这些服务器相互作用以实现容器编排。Kubernetes 集群服务器有两种主要类型:</p><ul class=""><li id="afda" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated"><strong class="lu ir"> <em class="ng">控制平面</em> </strong>和</li><li id="c9c6" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> <em class="ng">节点</em> </strong></li></ul><p id="0cbe" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">控制平面:</strong>这是充当 Kubernetes 集群大脑的服务器。它控制集群内的活动。控制平面由使其能够在集群内执行控制的组件组成。控制平面组件包括以下内容:</p><ul class=""><li id="912c" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated"><strong class="lu ir"> Kubeapi-server </strong>:这是<strong class="lu ir"> <em class="ng">控制平面</em> </strong>的组件，作为向集群发送指令的媒介或路径。命令通过<strong class="lu ir"> <em class="ng"> kubectl </em> </strong>命令行工具通过<strong class="lu ir"><em class="ng">kube API-server</em></strong>传递到集群。</li><li id="8f4e" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">Kube-Controller-Manager</strong>:控制<strong class="lu ir"> <em class="ng">控制平面</em> </strong>中主要活动的组件。它执行用户从集群的<strong class="lu ir"><em class="ng"/></strong>传递到<strong class="lu ir"><em class="ng">kube API-server</em></strong>的指令。它控制诸如部署、扩展和监控集群中部署的容器的健康状况之类的活动。</li><li id="7d8c" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> etcd </strong>:这是<strong class="lu ir"> <em class="ng">控制平面</em> </strong>的组件，为 Kubernetes 集群存储数据。可以在其中找到有关集群中部署的信息。</li><li id="67ed" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> Kube-Scheduler </strong>:这是<strong class="lu ir"> <em class="ng">控制平面</em> </strong>的组件，用于调度 Kubernetes 集群中的活动。</li><li id="c45a" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">云控制器管理器</strong>:这是<strong class="lu ir"> <em class="ng">控制平面</em> </strong>的组件，管理云中的部署。<strong class="lu ir"><em class="ng">Cloud-controller-manager</em></strong>是在 Azure、AWS、Google 云平台等云服务中用于 Kubernetes 集群部署的组件。</li></ul><p id="6219" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">节点:</strong>这是<strong class="lu ir"> </strong>服务器，作为运行容器化应用程序的工作机。一个 Kubernetes 集群可以有多个节点，但是在本教程中，我们将把我们的示例限制在单个节点的 Kubernetes 集群。</p><p id="9377" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">节点组件包括以下内容:</p><ul class=""><li id="ca35" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated"><strong class="lu ir"> Kube-Proxy </strong>:这是<strong class="lu ir"> <em class="ng">节点</em> </strong>的组件，处理 Kubernetes 集群的网络任务。它管理网络服务，使得访问在<strong class="lu ir"> <em class="ng">节点</em> </strong>中运行的容器化应用成为可能。</li><li id="4cd0" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> Kubelet </strong>:这是作为 Kubernetes 集群的<strong class="lu ir"> <em class="ng">节点</em> </strong> <em class="ng"> </em>和<strong class="lu ir"> <em class="ng">控制平面</em> </strong>之间的通路的组件。<strong class="lu ir"> <em class="ng">节点</em> </strong>通过<strong class="lu ir"> <em class="ng"> kubelet </em> </strong>与<strong class="lu ir"> <em class="ng">控制平面</em> </strong>中的活动进行交互。</li><li id="3b43" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">容器运行时</strong> : <strong class="lu ir"> </strong>这是将要在 Kubernetes 集群中部署的容器的运行时。使用的容器运行时是<strong class="lu ir"> <em class="ng"> Docker </em> </strong>。</li></ul><h2 id="9ffc" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Kubernetes 部署的概念</h2><p id="5c63" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在 Kubernetes 中部署应用程序时，需要考虑一些重要的概念。这些概念是:</p><ul class=""><li id="ab2b" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated">分离舱</li><li id="cce9" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated">服务</li><li id="f36c" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated">部署</li></ul><p id="7346" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">吊舱:</strong>它们是由一组共享存储和网络资源的一个或多个类似容器产生的可部署单元。Docker 容器在 Kubernetes 集群的<strong class="lu ir"> <em class="ng">节点</em> </strong>中的 pods 内进行编排(部署、扩展和监控)。</p><p id="94d7" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">服务</strong>:它是一个网络接口，可以与 pod 中运行的容器进行交互。Kubernetes 中有不同类型的服务，但在本文中，我将讨论两种主要的服务类型:</p><ul class=""><li id="8259" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated"><strong class="lu ir">负载平衡器</strong>:这是一种允许用户从集群外部访问 pod 中正在运行的容器的服务。它向外界公开了 Kubernetes 集群中的应用程序。它使用户能够与部署的 Kubernetes 应用程序进行交互。<strong class="lu ir"> <em class="ng">负载平衡器</em> </strong>确保与 Kubernetes 集群中运行的应用程序的互联网连接。</li><li id="956a" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated">集群 IP:这是一种允许集群内部交互或连接的服务类型。该服务将 pods 中运行的容器连接到 Kubernetes 集群中的数据库系统。</li></ul><p id="90d5" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir"> Deployment </strong>:它是 Kubernetes 中的一个资源对象，处理包含容器化应用程序的 pod 的创建、容器的多个实例的伸缩、容器化应用程序的健康监控、容器化应用程序更新的推出和回滚。</p><h2 id="5f90" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">Azure Cloud 中的 Kubernetes 部署(云中的机器学习应用程序部署)</h2><p id="2656" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">我已经在 docker hub 上为<strong class="lu ir"> <em class="ng"> PixelLib </em> ( </strong>我为执行图像中的对象分割而构建的库)发布了一个 docker 图像。这个 docker 图像将被部署为一个机器学习应用程序，用于在 Azure Kubernetes 服务上检测图像中的对象。</p><p id="9124" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">创建一个免费的 azure 帐户:我们需要一个 Azure 帐户，以便能够在 Azure 上创建服务。当你创建一个 azure 帐户时，你将在第一个月免费使用 azure 服务。</p><div class="nh ni gp gr nj nk"><a href="https://azure.microsoft.com/en-us/free/" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">立即创建您的 Azure 免费帐户| Microsoft Azure</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">观看各种 Azure 服务的运行，了解如何部署资源，并设想您的云计划。观看…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">azure.microsoft.com</p></div></div><div class="nt l"><div class="oq l nv nw nx nt ny kp nk"/></div></div></a></div><p id="831c" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">安装 Azure CLI: </strong>我们<em class="ng"> </em>需要<strong class="lu ir"> <em class="ng"> azure cli </em> </strong>这是在 Azure 账号上创建服务并与之交互的命令行工具。Azure cli 使得在 Azure 帐户上创建服务和与服务通信变得非常方便。</p><p id="9bed" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">按照以下教程中的说明安装 azure cli:</p><div class="nh ni gp gr nj nk"><a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">如何安装 Azure CLI</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">Azure CLI 可安装在 Windows、macOS 和 Linux 环境中。它也可以在 Docker 中运行…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">docs.microsoft.com</p></div></div><div class="nt l"><div class="or l nv nw nx nt ny kp nk"/></div></div></a></div><p id="462c" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">使用 Azure CLI 连接到 Azure:</strong>当<strong class="lu ir"> <em class="ng"> azure cli </em> </strong>成功安装后，在命令行工具中使用此命令登录到您的 Azure 帐户。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="d31d" class="kw kx iq ot b gy ox oy l oz pa">az login</span></pre><p id="80f5" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">创建资源组:</strong>azure 中的资源组充当将在 azure 上托管的其他服务的主机。这是一种将许多服务组合在一起的方法。使用此命令在<strong class="lu ir"> <em class="ng"> azure cli </em> </strong>上创建一个资源组。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="89c8" class="kw kx iq ot b gy ox oy l oz pa">az group create --name resgroup --location eastus</span></pre><p id="6abf" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">资源组将在不到一分钟的时间内创建，这将是所创建的资源组的输出 json。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="0f2d" class="kw kx iq ot b gy ox oy l oz pa">{<br/>  "id": "/subscriptions/&lt;guid&gt;/resourceGroups/resgroup",<br/>  "location": "eastus",<br/>  "managedBy": null,<br/>  "name": "resgroup",<br/>  "properties": {<br/>    "provisioningState": "Succeeded"<br/>  },<br/>  "tags": null<br/>}</span></pre><p id="acd1" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">创建 Azure Kubernetes 服务:</strong>使用以下命令使用<strong class="lu ir"> <em class="ng"> azure cli </em> </strong>创建 Azure Kubernetes 服务:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="392a" class="kw kx iq ot b gy ox oy l oz pa">az aks create --resource-group resgroup --name deploymentcluster --node-count 1 --enable-addons monitoring --generate-ssh-keys</span></pre><p id="a099" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>您可以从创建 Azure Kubernetes 服务的命令中观察到，我们使用了之前创建的名为<strong class="lu ir"> <em class="ng"> resgroup </em> </strong>的资源组来创建 Kubernetes 集群。我们指定要创建的集群的名称为<strong class="lu ir"><em class="ng">deployment cluster</em></strong>，并将<strong class="lu ir"> <em class="ng">节点计数</em> </strong>指定为 1。<strong class="lu ir"><em class="ng"/></strong><strong class="lu ir"><em class="ng"/></strong>Kubernetes 集群的创建需要一些时间。创建后，它将返回一个关于集群的长 json 格式的信息。</p><p id="c03e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">连接到 Azure 上的 Kubernetes 集群:</strong>我们将使用这个命令创建 Kubernetes 集群并连接到它<strong class="lu ir">。</strong></p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="d613" class="kw kx iq ot b gy ox oy l oz pa">az aks get-credentials --resource-group resroup --name deploymentCluster</span></pre><p id="394d" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">连接后，它会显示以下输出:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="be97" class="kw kx iq ot b gy ox oy l oz pa">Merged "deploymentcluster" as current context in C:\Users\&lt;pathtokubenetesconfiglocation&gt;</span></pre><p id="ed6e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">它合并了来自 Azure 的 Kubernetes 集群，作为 Kubernetes 的当前上下文。Kubernetes 上下文是用于访问 Kubernetes 集群的配置。<strong class="lu ir"><em class="ng">deployment cluster</em></strong>是使用的配置集群。</p><p id="866d" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">Kubernetes 部署代码</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="8c24" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">逐步部署代码分解</strong></p><ul class=""><li id="8209" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated"><strong class="lu ir"> apiVersion </strong>:我们定义了部署的 api 版本为<strong class="lu ir"> <em class="ng"> apps/v1 </em>。</strong></li><li id="9f77" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">种类</strong>:设置为<strong class="lu ir"> <em class="ng">展开</em> </strong>。</li><li id="2b2f" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">元数据</strong>:包含部署的信息。我们将部署的名称设置为<strong class="lu ir"><em class="ng">pixellib-demo</em></strong>。</li><li id="1491" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> spec </strong>:它包含了整个部署和将要创建的 pod 的规范的完整列表。</li><li id="5962" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> spec.replicas </strong>:我们定义了 pod 的数量，并将其设置为 2。这意味着我们的应用程序将有两个实例在运行。</li><li id="e44b" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">spec . selector . matchlabels</strong>:选择<strong class="lu ir"> <em class="ng">部署中使用的 pod，</em> </strong>使用 pod 标签<em class="ng"/><strong class="lu ir"><em class="ng">app:pixellib-pod</em></strong>。</li><li id="5817" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> spec.template.metadata </strong>:我们为 pod 定义元数据。<strong class="lu ir">spec . template . metadata . name</strong>为 pod 指定一个名称，即<strong class="lu ir"> <em class="ng"> pixellib-pod </em> </strong>。<strong class="lu ir">spec . template . metadata . labels s</strong>指定 pod 的标签，即<strong class="lu ir"><em class="ng">app:pixellib-pod</em></strong>使部署可以选择带有该标签的 pod。我们稍后将定义的服务也将使用该标签来选择 pod。</li><li id="133a" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated">spec . template . spec . containers:我们为容器化的应用程序定义规范。<strong class="lu ir">spec . template . containers . name</strong>指定将从 docker 图像创建的容器的名称，该图像被命名为<strong class="lu ir"><em class="ng">pixellib-container</em></strong>。<strong class="lu ir">spec . template . containers . image</strong>指定将从其创建 docker 容器的图像，所使用的图像是 docker hub 上发布的 docker 图像 I，名称为<strong class="lu ir"><em class="ng">ayoolaolaofenwa/pixellibapi</em></strong>。<strong class="lu ir">spec . template . containers . imagepullpolicy</strong>设置为<strong class="lu ir"> <em class="ng"> IfNotPresent，</em></strong>that<strong class="lu ir"><em class="ng"/></strong>指定如果图像不可用，则应拉取或下载图像。<strong class="lu ir">spec . template . containers . ports . container port</strong>指定<strong class="lu ir"> </strong>容器端口，该端口必须与所使用的 docker 映像中暴露的端口相匹配，它是<strong class="lu ir"> <em class="ng"> 5000 </em> </strong>。</li></ul><p id="17e5" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">创建 Kubernetes 部署</strong></p><p id="7dc9" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">在部署文件所在的文件夹中打开命令行，输入命令使用<strong class="lu ir"> kubectl 创建部署。</strong></p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="fa8d" class="kw kx iq ot b gy ox oy l oz pa">kubectl apply -f app_deployment.yml</span><span id="23b0" class="kw kx iq ot b gy pd oy l oz pa">deployment.apps/pixellib-demo created</span></pre><p id="c4a4" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">这是创建部署时的输出:<strong class="lu ir"><em class="ng">pixellib-demo</em></strong>是 yaml 文件中为部署指定的名称。</p><p id="6348" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">检查创建的 pod:</strong>在 yaml 文件中，我们将 pod 的数量设置为 2，将有两个 pod(同一个应用程序的两个实例)。您可以使用以下命令检查窗格的状态:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="7443" class="kw kx iq ot b gy ox oy l oz pa">kubectl get pods</span><span id="e96b" class="kw kx iq ot b gy pd oy l oz pa">NAME                            READY  STATUS    RESTARTS     AGE<br/>pixellib-demo-676bdf6cf9-7vh2    0/1   Container      0      10s       <br/>                                       Creating     <br/>pixellib-demo-676bdf6cf9-9mvz2   0/1  Container       0       10s       <br/>                                      Creating</span></pre><p id="dc3b" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">这将是刚刚创建部署时 pod 的状态。我们可以看到，pod 的状态是<strong class="lu ir"><em class="ng">container creating</em></strong>(它仍然在拉 docker 图像，当图像被拉时，将从图像创建一个容器)并且 pod 的年龄是 10s(它是在 pod 被创建后的 10 秒)。pod 中的容器将在几分钟或几秒钟内创建，这取决于您的互联网连接速度。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="c346" class="kw kx iq ot b gy ox oy l oz pa">NAME                            READY  STATUS    RESTARTS     AGE<br/>pixellib-demo-676bdf6cf9-7vh2    1/1   Running     0         70s       <br/>                                          <br/>pixellib-demo-676bdf6cf9-9mvz2   1/1   Running     0         70s       <br/>                                      </span></pre><p id="26f1" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">pod 已准备好，容器已创建并正在运行。pod 的状态变为<strong class="lu ir"> <em class="ng">运行</em> </strong>。</p><p id="f123" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">Pods 运行失败时该怎么办:</strong>如果收到错误<strong class="lu ir"> <em class="ng"> ImagePullBackOff，</em> </strong> it <strong class="lu ir"> <em class="ng"> </em> </strong>表示 yaml 文件中指定的 docker 映像不存在。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="e4d8" class="kw kx iq ot b gy ox oy l oz pa">NAME                     READY      STATUS         RESTARTS      AGE<br/>pixellib-demo-676-7j2c2     0/1    ImagePullBackOff  0           10s</span></pre><p id="b37e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">您可以使用以下命令检查其中一个窗格以了解问题所在:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="8303" class="kw kx iq ot b gy ox oy l oz pa">kubectl describe pod pixellib-demo-676bdf6cf9-7vh2</span></pre><p id="7ffe" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">此命令将显示 pod 未能完成的原因。</p><p id="a1cf" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">为部署创建服务:</strong>我们已经成功创建了一个部署，我们需要创建一个 Kubernetes 服务来访问集群中运行的应用程序。</p><p id="4ee0" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">【Kubernetes 服务创建代码</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="d780" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">一步一步服务创建代码分解</strong></p><ul class=""><li id="adc9" class="oc od iq lu b lv nb ly nc lf oe lj of ln og mk oh oi oj ok bi translated"><strong class="lu ir"> apiVersion </strong>:我们为服务定义了 api 版本，即<strong class="lu ir"> <em class="ng"> v1 </em>。</strong></li><li id="c188" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">种类:</strong>我们将种类定义为<strong class="lu ir"> <em class="ng">服务</em>。</strong></li><li id="9a13" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir">元数据:</strong>我们指定服务的名称为<strong class="lu ir"><em class="ng">pixellib-Service</em></strong>。</li><li id="8ba0" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated">我们为将要创建的服务定义规范。</li><li id="88c4" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> spec.type: </strong>我们将服务类型定义为<strong class="lu ir"> <em class="ng"> LoadBalancer、</em> </strong>，这将使我们能够从外部访问 pod 内运行的应用。</li><li id="ff36" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> spec.ports: </strong>我们定义服务中使用的端口。我们将端口<strong class="lu ir"> <em class="ng"> 80 </em> </strong>映射到正在运行的容器的目标端口的端口<strong class="lu ir"> <em class="ng"> 5000 </em> </strong>。</li><li id="cecc" class="oc od iq lu b lv ol ly om lf on lj oo ln op mk oh oi oj ok bi translated"><strong class="lu ir"> spec.selector: </strong>我们从部署中指定将使用名为<strong class="lu ir"><em class="ng">app:pixellib-pod</em></strong>的服务的 pod。</li></ul><p id="4d9f" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">创建 Kubernetes 服务</strong></p><p id="cadc" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">在服务 yaml 文件所在的文件夹中打开命令行，输入命令使用<strong class="lu ir"> kubectl 创建服务。</strong></p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="d3fc" class="kw kx iq ot b gy ox oy l oz pa">kubectl apply -f app_service.yml</span><span id="0d6c" class="kw kx iq ot b gy pd oy l oz pa">service/deploy-service created</span></pre><p id="f061" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">这是创建服务时的输出:<strong class="lu ir"><em class="ng">pixellib-Service</em></strong>是 yaml 文件中为服务指定的名称。</p><p id="46af" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">访问 Kubernetes 部署:</strong>使用这个命令访问在 Kubernetes 集群的 pods 中运行的机器学习应用程序。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="9a4d" class="kw kx iq ot b gy ox oy l oz pa">kubectl get service pixellib-service</span></pre><p id="0675" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">我们获得了我们为 pixellib 应用程序部署创建的服务<strong class="lu ir"><em class="ng">pixellib-服务</em> </strong>。这将是输出:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="9800" class="kw kx iq ot b gy ox oy l oz pa">NAME             TYPE         CLUSTER-IP   EXTERNAL-IP  PORT(S) <br/>pixellib-service LoadBalancer 10.0.7.173   20.88.171.40 80:30832/TCP          </span></pre><p id="5178" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>在输出中，我们有<strong class="lu ir"> <em class="ng">外部 ip </em> </strong>，这是使我们能够访问在集群内运行的应用的 ip 地址。在这种情况下，ip 地址是<strong class="lu ir">20.88.171.40<em class="ng">。</em> </strong>这个 ip 地址作为 restapi 接口，供我们访问集群中运行的应用程序，执行对象的分割。我们可以在代码中粘贴 ip 地址并执行对象检测。</p><p id="cd14" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">样本图像</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/64c1d3f90830477883f1a38a89ea3993.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*aZN3YKtRWL-KeuRKfAkzgw.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/photos/GKCMEI3rMKE" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="71f8" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">测试代码</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="2a89" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">输出</strong></p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="b782" class="kw kx iq ot b gy ox oy l oz pa">{'boxes': [[145, 119, 282, 457], [162, 273, 261, 512], [238, 283, 398, 387], [442, 321, 496, 350], [411, 219, 422, 242], [31, 316, 51, 356], [352, 217, 366,</span><span id="5cf6" class="kw kx iq ot b gy pd oy l oz pa">243], [272, 264, 291, 317], [274, 241, 368, 306], [277, 233, 369, 309], [377, 307, 405, 350], [0, 157, 65, 563], [468, 301, 497, 328], [49, 307, 73, 328]],</span><span id="c4a5" class="kw kx iq ot b gy pd oy l oz pa">'class_ids': [0, 1, 2, 2, 9, 2, 9, 0, 5, 7, 2, 2, 7, 2], 'class_names': ['person', 'bicycle', 'car', 'car', 'traffic light', 'car', 'traffic light', 'person', 'bus', 'truck', 'car', 'car', 'truck', 'car'], 'mask_shape': [580, 498, 14],</span><span id="1e94" class="kw kx iq ot b gy pd oy l oz pa">'object_counts': {'bicycle': 1, 'bus': 1, 'car': 6, 'person': 2, 'traffic light': 2, 'truck': 2},</span><span id="22ef" class="kw kx iq ot b gy pd oy l oz pa">'scores': [99, 99, 99, 99, 97, 94, 90, 67, 65, 47, 47, 44, 37, 36]}</span></pre><p id="ee7e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">输出包括关于图像中检测到的对象的许多细节，包括<strong class="lu ir">框坐标值、类 id、类名、对象计数、分割掩模形状</strong>和<strong class="lu ir">预测分数</strong>。我们已经成功地在 Kubernetes 集群中运行了一个图像分割应用程序。</p><p id="0181" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">图像分割前端 API: </strong>如果你在浏览器中粘贴 ip 地址<strong class="lu ir"><em class="ng">20.88.171.40</em></strong>，它会加载一个简单的 web API 来执行对象分割。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/27d01c85f1aced63073bd2057ecdb41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0LFEwqzg_dBTc5f40xhjfg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pg"><img src="../Images/90bf2d8d455067a9bebec692a8a8e652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wn9LIc1Dci76lKft0_zazA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="d65b" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">您可以选择任意一幅图像，按下<strong class="lu ir"><em class="ng"/></strong>按钮，它<strong class="lu ir"> <em class="ng"> </em> </strong>将在几秒钟内显示一幅输出的分割图像。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4e0c06570ce13f048379b631a67ac34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*btnCuTEeXM_nyfMsHFUNnw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="9ec5" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">记录 Kubernetes 部署:</strong>如果在 Kubernetes 部署中加载应用程序时遇到错误，可以使用以下命令轻松调试部署:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="f7b7" class="kw kx iq ot b gy ox oy l oz pa">kubectl logs deployment.apps/&lt;name of your deployment&gt;</span></pre><p id="3a27" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">示例:</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="1236" class="kw kx iq ot b gy ox oy l oz pa">kubectl logs deployment.apps/pixellib-demo</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ph"><img src="../Images/bc30ea14b6463d6814469f9cdabd98e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asPc2ZraZ3bGgaWyxPeCHg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片</p></figure><p id="31b9" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">它将生成应用程序运行的报告。它生成在集群的 pod 内部运行的 flask 应用程序的日志。我们的应用程序运行良好，没有任何错误，如果有任何错误，我们可以很容易地从日志报告中观察到错误。</p><p id="ae9e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">删除 Kubernetes 部署:</strong></p><p id="22ad" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">使用这个命令可以很容易地删除 Kubernetes 部署，</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="8519" class="kw kx iq ot b gy ox oy l oz pa">kubectl delete -n default deployment pixellib-demo</span></pre><p id="7d7a" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">删除 Kubernetes 服务:</strong></p><p id="91c7" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">使用这个命令可以很容易地删除 Kubernetes 服务，</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="97e4" class="kw kx iq ot b gy ox oy l oz pa">kubectl delete -n default service pixellib-service</span></pre><p id="162e" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">删除 Kubernetes 集群</strong></p><p id="f2ee" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">您可以使用这个 azure cli 命令轻松删除用于部署的 Kubernetes 集群。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="84f0" class="kw kx iq ot b gy ox oy l oz pa">az aks delete --name deploymentcluster --resource-group resgroup</span></pre><p id="de7b" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">删除 Azure 资源组</strong></p><p id="36b9" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">使用此 azure cli 命令删除 azure 资源组。</p><pre class="kg kh ki kj gt os ot ou ov aw ow bi"><span id="d8c2" class="kw kx iq ot b gy ox oy l oz pa">az group delete -n resgroup</span></pre><h2 id="0d16" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h2><p id="bf2f" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">我们在本文中详细讨论了 Kubernetes、Kubernetes 集群的基本概念，以及其组件如何工作。我们还描述了 Kubernetes 部署的基础，并给出了如何在 azure cloud 中设置机器学习 rest API 的 Kubernetes 部署的分步指南。</p><p id="fc18" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">访问 PixelLibAPI github 库:</strong></p><div class="nh ni gp gr nj nk"><a href="https://github.com/ayoolaolafenwa/PixelLibAPI" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">GitHub-ayoolaolafenwa/PixelLibAPI</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">在 GitHub 上创建一个帐户，为 ayoolaolafenwa/PixelLibAPI 的开发做出贡献。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="pi l nv nw nx nt ny kp nk"/></div></div></a></div><p id="9d60" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">注意:</strong>阅读我在 docker 上的文章，在那里我解释了 docker 的基础知识以及如何将机器学习 Rest API docker 化。</p><div class="nh ni gp gr nj nk"><a rel="noopener follow" target="_blank" href="/docker-in-pieces-353525ec39b0"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">零碎的码头工人</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">了解 docker 的基本概念、工作原理，以及如何使用 docker 构建机器学习 Rest APIs。</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">towardsdatascience.com</p></div></div><div class="nt l"><div class="pj l nv nw nx nt ny kp nk"/></div></div></a></div><p id="85fc" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated"><strong class="lu ir">通过以下方式联系我:</strong></p><p id="2390" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">电子邮件:<a class="ae kv" href="https://mail.google.com/mail/u/0/#inbox" rel="noopener ugc nofollow" target="_blank">olafenwaayoola@gmail.com</a></p><p id="aa5b" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">Linkedin: <a class="ae kv" href="https://www.linkedin.com/in/ayoola-olafenwa-003b901a9/" rel="noopener ugc nofollow" target="_blank">阿尤拉·奥拉芬娃</a></p><p id="ee99" class="pw-post-body-paragraph ls lt iq lu b lv nb jr lx ly nc ju ma lf nd mc md lj ne mf mg ln nf mi mj mk ij bi translated">推特:<a class="ae kv" href="https://twitter.com/AyoolaOlafenwa" rel="noopener ugc nofollow" target="_blank"> @AyoolaOlafenwa </a></p></div></div>    
</body>
</html>