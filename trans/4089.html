<html>
<head>
<title>Leverage Cloud Technologies for Malware Hunting at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用云技术大规模搜索恶意软件</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/leverage-cloud-technologies-for-malware-hunting-at-scale-27718244ee6c#2022-09-10">https://towardsdatascience.com/leverage-cloud-technologies-for-malware-hunting-at-scale-27718244ee6c#2022-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7808" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用Apache Spark和Iceberg表索引数百TB的恶意软件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1af174806ad4b1577fd1602a23b86cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epDKX0ZmDPABhSlWTHxRsg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由Hes Mundt在Unsplash上拍摄</p></figure><p id="4011" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将展示如何使用Spark和<a class="ae lr" href="https://iceberg.apache.org/" rel="noopener ugc nofollow" target="_blank"> Iceberg </a>表实现类似于<a class="ae lr" href="https://github.com/CERT-Polska/ursadb" rel="noopener ugc nofollow" target="_blank"> UrsaDB </a>的恶意软件索引，并将该索引集成到<a class="ae lr" href="https://github.com/CERT-Polska/mquery" rel="noopener ugc nofollow" target="_blank"> Mquery </a>中，这是一个分析师友好的web GUI，用于提交<a class="ae lr" href="https://virustotal.github.io/yara/" rel="noopener ugc nofollow" target="_blank"> YARA </a>规则并显示结果。</p><p id="f8b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一概念验证是在<a class="ae lr" href="https://geek.collaboration.cyber.gc.ca/en/week/2022/home.html" rel="noopener ugc nofollow" target="_blank">极客周</a>期间开发的，极客周是由<a class="ae lr" href="https://cyber.gc.ca/en" rel="noopener ugc nofollow" target="_blank">加拿大网络安全中心</a>组织的年度研讨会，汇集了网络安全领域的主要参与者，为行业面临的重要问题提供解决方案。</p><h1 id="8ec2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">简而言之YARA</h1><p id="5d3a" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://virustotal.github.io/yara/" rel="noopener ugc nofollow" target="_blank"> YARA </a>是一款旨在帮助恶意软件研究人员识别和分类恶意软件样本的工具。使用YARA，您可以基于文本或二进制模式创建恶意软件家族的描述。每个描述，也称为规则，由一组字符串和一个决定其逻辑的布尔表达式组成。例如:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3759" class="mu lt iq mq b gy mv mw l mx my">rule silent_banker : banker<br/>{<br/>    meta:<br/>        description = "This is just an example"<br/>        threat_level = 3<br/>        in_the_wild = true<br/>    strings:<br/>        $a = {6A 40 68 00 30 00 00 6A 14 8D 91}<br/>        $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9}<br/>        $c = "UVODFRYSIHLNWPEJXQZAKCBGMT"<br/>    condition:<br/>        $a or $b or $c<br/>}</span></pre><p id="4f7c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果在文件中找到这些序列中的任何一个(a或b或c ),该规则将评估为真。YARA是一个用C语言编写的可执行文件，通常在命令行上调用，方法是向它传递一个规则和一个二进制文件文件夹以进行处理。</p><p id="db0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然YARA执行速度很快，但以暴力方式处理数百万个恶意软件样本会占用大量CPU和I/O资源，因此执行时间会非常长。</p><h1 id="25dd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">波兰证书</h1><p id="6a4b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了加快对YARA规则的评估，波兰计算机应急小组(CERT-Polska)建立了一个名为UrsaDB的定制数据库和一个名为Mquery的分析师友好的web GUI。</p><p id="6073" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UrsaDB充当<a class="ae lr" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank">布隆过滤器</a>来测试给定的字节序列是否可能出现在二进制文件中。假阳性匹配是可能的，但假阴性是不可能的。换句话说，查询返回“可能在文件中”或“肯定不在文件中”。</p><p id="910d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Mquery首先使用UrsaDB来查找可能包含所需字节序列的候选文件，然后使用YARA CLI来确认该文件是否匹配。因此，YARA CLI是在整个恶意软件语料库的一个小子集上进行评估的，这大大加快了整体执行时间。</p><p id="6a3a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们更深入地了解一下UrsaDB。</p><h1 id="f287" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">乌尔萨博</h1><p id="ebf9" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">UrsaDB中的主要指数是<code class="fe mz na nb mq b">3gram</code>指数。</p><p id="80b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于语料库中的每个文件，UrsaDB提取所有可能的唯一三字节组合。<code class="fe mz na nb mq b">3gram</code>索引本质上是一个大图，其中键是一个<code class="fe mz na nb mq b">3gram</code>，值是一个<code class="fe mz na nb mq b">list of files containing the 3gram</code>。</p><p id="2723" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，如果我们索引一个包含ASCII字符串<code class="fe mz na nb mq b">TEST MALWARE</code> (ASCII: <code class="fe mz na nb mq b">54 45 53 54 20 4D 41 4C 57 41 52 45</code>)的文本文件，那么数据库生成以下三元组(<code class="fe mz na nb mq b">_</code>表示空格字符):</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="565b" class="mu lt iq mq b gy mv mw l mx my">+---+-----------+---------+<br/>| # | Substring | Trigram |<br/>+---+-----------+---------+<br/>| 0 | TES       | 544553  |<br/>| 1 | EST       | 455354  |<br/>| 2 | ST_       | 535420  |<br/>| 3 | T_M       | 54204D  |<br/>| 4 | _MA       | 204D61  |<br/>| 5 | MAL       | 4D616C  |<br/>| 6 | ALW       | 414C57  |<br/>| 7 | LWA       | 4C5741  |<br/>| 8 | WAR       | 574152  |<br/>| 9 | ARE       | 415245  |<br/>+---+-----------+---------+</span></pre><p id="5b34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UrsaDB是一个自定义的C程序，运行在单台机器上，能够处理大量的恶意软件文件。UrsaDB CLI提供了索引、压缩和搜索<code class="fe mz na nb mq b">3gram</code>索引的方法，这些索引作为定制格式的二进制文件存储在磁盘上。</p><p id="8613" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UrsaDB仅限于单个机器，尽管可以集群多个UrsaDB实例，但它本身不受支持，并且跨机器管理多个索引很麻烦。UrsaDB还要求索引文件驻留在连接的存储设备上。</p><p id="4257" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">许多网络规模的公司正在重新评估他们对HDFS的使用，以支持云blob存储。Blob存储正迅速成为存储大型数据集的事实上的选择。这有很多原因，很多文章都提到了这个话题。</p><p id="fe4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的概念验证中，我们希望了解是否可以利用云blob存储，特别是冰山表来降低成本并简化大规模恶意软件索引的管理。</p><h1 id="5f84" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用火花和冰山构建3g指数</h1><p id="cc8d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">UrsaDB使用磁盘格式<a class="ae lr" href="https://github.com/CERT-Polska/ursadb/blob/master/docs/indextypes.md" rel="noopener ugc nofollow" target="_blank">将其索引存储为文件id和<code class="fe mz na nb mq b">3grams</code>的序列。此外，UrsaDB使用游程编码技术，该技术也用于</a><a class="ae lr" href="https://parquet.apache.org/docs/file-format/data-pages/encodings/" rel="noopener ugc nofollow" target="_blank">拼花文件</a>(拼花文件是Iceberg表的基础)。Parquet文件格式是众所周知的，通常用于大数据平台。</p><p id="843f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要构建索引的第一件事是将文件分成<code class="fe mz na nb mq b">3gram</code>的方法。这是构建索引时计算最密集的部分。我们尝试了许多方法，从纯粹的Spark SQL到定制的panda python UDFs，但是没有一种方法可以与利用ByteBuffer和令人难以置信的<a class="ae lr" href="https://fastutil.di.unimi.it/" rel="noopener ugc nofollow" target="_blank"> fastutil </a>库的定制Java实现相媲美。这是我们的自定义UDF，它将所有不同的<code class="fe mz na nb mq b">3grams</code>作为整数值返回。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/e1c07966b6664fb3cd368c87de104c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CI-CzyMAhjKsOuaDJhowVw.png"/></div></div></figure><p id="6eaa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用这个函数，很容易建立一个<code class="fe mz na nb mq b">3gram</code>索引。这就是转变的样子。请注意，我们在大多数例子中都使用了<code class="fe mz na nb mq b">%%sparksql</code>魔法。您可以在关于<a class="ae lr" href="https://medium.com/@jean-claude.cote/jupyterlab-sql-cell-editor-e6ac865b42df" rel="noopener"> jupyterlab-sql-editor </a>的前一篇文章中找到关于这个扩展的更多信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/b3a59cc3711f7b440c314ace61ba174d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EORhwJunVBp4eGlOf4o43Q.png"/></div></div></figure><p id="3c82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">shingling函数应用于一个字节序列，并以整数值列表的形式返回唯一的<code class="fe mz na nb mq b">3gram</code>。然后，我们分解列表并移动整数值，以获得代表a <code class="fe mz na nb mq b">3gram</code>的字节的三列。</p><p id="ddce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们选择将<code class="fe mz na nb mq b">3gram</code>的每个字节存储到它自己的列(a，b，c)中，而不是存储到一个单独的列中，因为这样更容易概念化，并且可以更好地压缩表。</p><p id="80d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们按照构成<code class="fe mz na nb mq b">3gram</code>的字节对表格进行排序；(甲、乙、丙)。对于每个拼花文件，Iceberg将存储a、b和c列的最小值/最大值。在查询时，Iceberg使用这些统计数据来快速识别对于给定的<code class="fe mz na nb mq b">3gram</code>应该扫描哪些拼花文件，并由此找到哪个恶意软件file_id包含给定的<code class="fe mz na nb mq b">3gram</code>。</p><p id="28c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">既然我们可以索引一个字节序列，我们所要做的就是获取恶意软件文件的字节。这在Spark中很容易。读取文件内容无非是使用带有<em class="ne">二进制文件</em>格式选项的<code class="fe mz na nb mq b">spark.read()</code>函数。<code class="fe mz na nb mq b">read()</code>函数返回包含文件路径、修改时间、文件大小和文件内容的数据帧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/da0ebba70eded033e84ef2916a8a3fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8SKNFyarGaQQKhop0fdOQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/7a36bcca00ffb39c8e35605e22846a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8Pf3QbThbMfAaDKqX1llA.png"/></div></div></figure><p id="e2fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们有了一个恶意软件表，我们就可以对<code class="fe mz na nb mq b">content</code>列应用收缩函数。这里，我们展示了与前面相同的示例，但是我们使用file_id_map表来获取给定文件路径的file_id。我们不在索引中保存文件路径，因为与存储一个简单的file_id相比，这将是相当大的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/6539cd3d6e8b97ada7c199d7deb11d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pDoJP1OpMNQMT6tkvhkkuA.png"/></div></div></figure><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e08f" class="mu lt iq mq b gy mv mw l mx my">-- We use Iceberg's WRITE ORDER BY to make sure the table is sorted</span><span id="18b3" class="mu lt iq mq b gy ni mw l mx my">ALTER TABLE {table_name} WRITE ORDERED BY ts, source, a, b, c, file_id`</span></pre><h1 id="802c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在Spark SQL中查询3gram索引</h1><p id="dd2c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Mquery负责解析YARA规则，并将字节或文本模式转换成一个要搜索的列表。Mquery包含一个UrsaDB代理，它使用这些“<code class="fe mz na nb mq b">3gram</code>来搜索”以形成一个UrsaDB查询。</p><p id="6e09" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们假设期望寻找的字节模式是<code class="fe mz na nb mq b"><strong class="kx ir">0 -1 -86 -69 -14 88</strong></code> <strong class="kx ir">。</strong> Mquery会生成以下4个<code class="fe mz na nb mq b">3grams</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/5e667bc33611ac06a49b80fb687098ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*hbwju_zfzxUfWtp6Ufiq8A.png"/></div></figure><p id="bedd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UrsaDB将查找包含所有4个<code class="fe mz na nb mq b">3grams</code>的候选文件，但不一定是按顺序排列的。然后对文件3和4执行YARA CLI，发现只有文件4匹配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ce2d40e9090c7c5d12dd72a3c4cbe1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*kVxRlJRLQc0C7boKrqEg5w.png"/></div></figure><p id="30eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">出于我们的目的，我们编写了一个定制代理来向Spark而不是UrsaDB提交查询。我们的pyspark代理获取要搜索的列表“<code class="fe mz na nb mq b">3gram</code>”并生成相应的Spark SQL查询。</p><p id="9d63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个<code class="fe mz na nb mq b">3gram</code>被转换成3个字节，每个字节在一个<code class="fe mz na nb mq b">where</code>子句中针对列a、b和c进行测试。查询的结果是具有特定<code class="fe mz na nb mq b">3gram</code>的文件列表。</p><p id="7439" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而有一个微妙之处。当给定4个<code class="fe mz na nb mq b">3gram</code>的列表时，我们必须只返回所有<strong class="kx ir">4<code class="fe mz na nb mq b">3gram</code>请求的文件。为了实现这一点，我们使用了一个<code class="fe mz na nb mq b"><em class="ne">group by + having</em></code>子句<em class="ne">。</em>完整的查询如下所示。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/271a29a7907dd596189b6e0f46c8ada3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nh0aei2xAnD68Dqe8KHwdw.png"/></div></div></figure><p id="3861" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于该表是按a、b和c列排序的，Iceberg可以使用它的元数据有效地删除大部分拼花文件。然后，在每个文件中，Spark将使用parquet文件页脚(页面统计)来进一步隔离潜在的匹配。因此，查询执行得相当快。</p><p id="0be4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">查询的结果是一个简单的<code class="fe mz na nb mq b">file_id</code>列表，它可以很容易地在集群中被打乱以评估最终的<code class="fe mz na nb mq b"><em class="ne">group by + having</em></code>子句。该查询的结果是具有所有4个<code class="fe mz na nb mq b">3grams</code>的文件列表，但不一定是顺序的。这4个<code class="fe mz na nb mq b">3grams</code>可能在恶意软件文件的任何地方。记住，索引就像一个布隆过滤器，给我们一个“候选文件”的小列表。我们现在必须让YARA支持这些候选人。火花在这里也能帮助我们。</p><h1 id="60ad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在分布式Spark集群上运行YARA</h1><p id="e1ce" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Spark是一个分析平台，可以分发并行运行的任意python代码。此外，当使用<a class="ae lr" href="https://github.com/VirusTotal/yara-python" rel="noopener ugc nofollow" target="_blank"> yara-python </a>绑定时，从python调用YARA C库很容易。</p><p id="5f1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在Spark中运行分布式YARA相当容易。下面是一个简单的python UDF，展示了yara-python对恶意软件文件内容的调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/caeb4bd80e07f8478cb5ebbc7759975c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iBN7bcATfmujucPrFBGkuw.png"/></div></div></figure><h1 id="68b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">把所有的放在一起</h1><p id="0deb" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这里有一个演示展示了对沉默的银行家YARA规则的评估。它显示以下内容:</p><ul class=""><li id="03dd" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated">首先，我们的定制pyspark Mquery代理将<code class="fe mz na nb mq b">3gram</code>列表转换成SQL语句。</li><li id="c376" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">其次，一个定制的Spark UDF找到候选文件，在这些文件上评估完整的YARA规则。</li><li id="f93e" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated">最后，匹配的文件被返回到Mquery web UI。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/366fbbfbf53d1c6cf700a77ca940c5e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Cki1XyRJaCfMDml0d9S6FQ.gif"/></div></div></figure><h1 id="151e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="9b8a" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在本文中，我们展示了如何利用Spark构建可伸缩的<code class="fe mz na nb mq b">3gram</code>索引。该索引以Iceberg表格式存储，并由廉价的datalake blob存储支持。</p><p id="36b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，我们演示了如何编写一个定制的Mquery代理来生成针对索引的Spark SQL查询。</p><p id="c0e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们展示了如何利用yara-python来分发yara规则的完整评估。</p><p id="35a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的初步结果是有希望的。我们能够索引和查询13tb的恶意软件，压缩比和执行时间与UrsaDB相当，但具有更便宜的存储和更容易的索引管理的优势。</p><p id="8dfc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们计划生产这种概念证明。在以后的文章中，我们将进一步深入这个项目，并给出关于实现、查询次数、压缩比和成本的更多细节。敬请期待！</p></div></div>    
</body>
</html>