<html>
<head>
<title>Nine Rules for Elegant Rust Library APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优雅的Rust库API的九条规则</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nine-rules-for-elegant-rust-library-apis-9b986a465247#2022-06-16">https://towardsdatascience.com/nine-rules-for-elegant-rust-library-apis-9b986a465247#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="db44" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从Python到Rust移植生物信息学库Bed-Reader的实践经验</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/86f6897d85b020363495a4a23e7bd640.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q2LGYXGFh1enNoKY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@dilucidus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kai Dahms </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4331" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢创建软件库。两个月前，我开始将我们的一个Python包移植到Rust crate中。这个新的Rust crate与Python包的易用性和表现力相匹配。一路上，我学到了九条规则，可以帮助你在Rust中创建漂亮的库。规则是:</p><ol class=""><li id="9159" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">创造一些不会让你尴尬的例子。</li><li id="b460" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">接受所有类型的字符串、路径、向量、数组和可重复项。</li><li id="d157" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">了解用户的需求，最好是吃你自己的狗粮。</li><li id="57de" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用生成器，因为不能使用关键字参数。</li><li id="c556" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编写好的文档来保持设计的诚实。</li><li id="c8be" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">接受所有类型。</li><li id="98cc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编写API测试。</li><li id="1838" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">定义并返回好的错误。</li><li id="ad1f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用Clippy。</li></ol><p id="ae93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，库是供其他程序使用的锈箱。库的API(应用程序编程接口)是程序可以调用的一组公共函数和对象。我们希望设计一个优雅的API，而不仅仅是功能性的API。功能API只是让用户做他们需要做的一切。一个优雅的API让他们以简单而明智的方式做他们需要做的事情。</p><p id="ee7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具体来说，这是我们面向Python的API和新的面向Rust的API。</p><blockquote class="mg mh mi"><p id="bed3" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">任务:</strong>列出前5个个体id，前5个SNP ids，以及每条唯一的染色体。然后，读取5号染色体中的每个值。</p></blockquote><p id="3ed3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj"> Python API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="a814" class="ms mt iq mo b gy mu mv l mw mx">&gt;&gt;&gt; with open_bed(file_name2) as bed3:<br/>...     print(bed3.iid[:5])<br/>...     print(bed3.sid[:5])<br/>...     print(np.unique(bed3.chromosome))<br/>...     val3 = bed3.read(index=np.s_[:,bed3.chromosome=='5'])<br/>...     print(val3.shape)</span><span id="396c" class="ms mt iq mo b gy my mv l mw mx">['iid_0' 'iid_1' 'iid_2' 'iid_3' 'iid_4']<br/>['sid_0' 'sid_1' 'sid_2' 'sid_3' 'sid_4']<br/>['1' '10' '11' '12' '13' '14' '15' '16' '17' '18' '19' '2' '20' '21' '22' '3' '4' '5' '6' '7' '8' '9']<br/>(100, 6)</span></pre><p id="fba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj"> Rust API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="5bdb" class="ms mt iq mo b gy mu mv l mw mx">let mut bed = Bed::new(file_name)?;<br/>println!("{:?}", bed.iid()?.slice(s![..5]));<br/>println!("{:?}", bed.sid()?.slice(s![..5]));<br/>println!("{:?}", bed.chromosome()?.iter().collect::&lt;HashSet&lt;_&gt;&gt;());<br/>let val = ReadOptions::builder()<br/>    .sid_index(bed.chromosome()?.map(|elem| elem == "5"))<br/>    .f64()<br/>    .read(&amp;mut bed)?;</span><span id="1bf8" class="ms mt iq mo b gy my mv l mw mx">// Outputs ndarray: ["iid_0", "iid_1", "iid_2", "iid_3", "iid_4"]<br/>// Outputs ndarray: ["sid_0", "sid_1", "sid_2", "sid_3", "sid_4"]<br/>// Outputs: {"12", "10", "4", "8", "19", "21", "9", "15", "6", "16", "13", "7", "17", "18", "1", "22", "11", "2", "20", "3", "5", "14"}<br/>assert!(val.dim() == (100, 6));</span></pre><p id="de27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些优雅吗？情人眼里出西施，但是作为Python API的用户，我觉得它很优雅。关于Rust API，我很高兴它紧密地遵循了Python的设计，并且相信它是优雅的。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="f127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">灵感:</strong>之前的两篇文章激发并启发了这些努力。首先，2016年，Pascal Hertleif在Rust 中编写了<a class="ae kv" href="https://deterministic.space/elegant-apis-in-rust.html" rel="noopener ugc nofollow" target="_blank">优雅的库API。后来，Brian Anderson创建并维护了</a><a class="ae kv" href="https://rust-lang.github.io/api-guidelines/" rel="noopener ugc nofollow" target="_blank"> Rust API指南</a>。相比之下，这篇文章更笼统，更具体，也不全面。它讨论了适用于所有语言的通用API设计原则，而不仅仅是Rust。它强调了我发现在移植Bed-Reader时最有用的特定技术和工具。它忽略了我没有面对的API设计问题(例如，设计宏)。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="6403" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">背景</strong> : <a class="ae kv" href="https://pypi.org/project/bed-reader/" rel="noopener ugc nofollow" target="_blank"> Bed-Reader </a>是一个用于读写PLINK Bed文件的库，PLINK Bed文件是生物信息学中用来存储基因型(DNA)数据的二进制格式。Bed格式的文件可能有1tb那么大。Bed-Reader让用户可以快速、随机地访问大量数据。它以用户选择的int8、float32或float64返回一个二维数组。Bed-Reader还让用户可以访问12条元数据，6条与个人相关，6条与SNPs相关(粗略地说，是DNA位置)。重要的是，基因型数据通常比元数据大100，000倍。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/e98244f6734c627bf7590a8c197cac36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eU1Slk6ioktd6RhBwgHQGQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">PLINK存储基因型数据和元数据</p></figure><p id="8445" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个优雅的Rust库API需要许多设计决策。根据我在读床者上的经验，以下是我推荐的决定。为了避免含糊不清，我将把这些建议表述为规则。规则在一般和特殊之间交替。</p><h2 id="2d0d" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则1:创造不会让你尴尬的例子</h2><p id="622d" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">您应该创建许多使用您的库的API的示例。您应该继续开发您的库的API，直到您对这些例子感到自豪。</p><p id="3787" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明这一点，让我们看看Bed-Reader的README.md文件中的三个例子。对于每项任务，我们将使用以下工具来查看解决方案</p><ul class=""><li id="56cd" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">Python API</li><li id="d1ba" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">仅仅是功能性的Rust API</li><li id="d988" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">更优雅的新Rust API</li></ul><blockquote class="mg mh mi"><p id="1f69" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">任务</strong>:从. bed文件中读取所有基因组数据。</p></blockquote><p id="b39e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj"> Python API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="4049" class="ms mt iq mo b gy mu mv l mw mx">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; from bed_reader import open_bed, sample_file<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; file_name = sample_file("small.bed")<br/>&gt;&gt;&gt; bed = open_bed(file_name)<br/>&gt;&gt;&gt; val = bed.read()<br/>&gt;&gt;&gt; print(val)<br/>[[ 1.  0. nan  0.]<br/> [ 2.  0. nan  2.]<br/> [ 0.  1.  2.  0.]]<br/>&gt;&gt;&gt; del bed</span></pre><p id="d6cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">仅功能性防锈API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="b161" class="ms mt iq mo b gy mu mv l mw mx">use crate::read;</span><span id="d292" class="ms mt iq mo b gy my mv l mw mx">let file_name = "bed_reader/tests/data/small.bed";<br/>let val = read(file_name, true, true, f32::NAN)?;<br/>println!("{val:?}");</span><span id="5a4a" class="ms mt iq mo b gy my mv l mw mx">// [[1.0, 0.0, NaN, 0.0],<br/>//  [2.0, 0.0, NaN, 2.0],<br/>//  [0.0, 1.0, 2.0, 0.0]],...</span></pre><p id="87c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">功能性Rust API做得很好！一方面，<code class="fe oe of og mo b">true, true</code>输入有点混乱。另一方面，它比Python短一行。我几乎可以为这个解决方案感到自豪。</p><p id="060a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">新的、更优雅的Rust API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="9e2f" class="ms mt iq mo b gy mu mv l mw mx">use ndarray as nd;<br/>use bed_reader::{Bed, ReadOptions, assert_eq_nan, sample_bed_file};<br/><br/>let file_name = sample_bed_file("small.bed")<strong class="mo ir">?</strong>;<br/>let mut bed = Bed::new(file_name)<strong class="mo ir">?</strong>;<br/>let val = ReadOptions::builder().f64().read(&amp;mut bed)<strong class="mo ir">?</strong>;<br/><br/>assert_eq_nan(<br/>    &amp;val,<br/>    &amp;nd::array![<br/>        [1.0, 0.0, f64::NAN, 0.0],<br/>        [2.0, 0.0, f64::NAN, 2.0],<br/>        [0.0, 1.0, 2.0, 0.0]<br/>    ],<br/>);</span></pre><p id="0901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与仅仅是功能性的API相比，新的API用构建器模式取代了令人困惑的<code class="fe oe of og mo b">true, true</code>输入。(详见规则4。)另一方面，它需要额外的一行代码。所以，不一定更好。</p><p id="aad5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下一个任务。</p><blockquote class="mg mh mi"><p id="8ccf" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">任务:</strong>从20到30读取每隔一个个体和SNPs (DNA定位)。</p></blockquote><p id="7698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj"> Python API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="9668" class="ms mt iq mo b gy mu mv l mw mx">&gt;&gt;&gt; file_name2 = sample_file("some_missing.bed")<br/>&gt;&gt;&gt; bed2 = open_bed(file_name2)<br/>&gt;&gt;&gt; val2 = bed2.read(index=np.s_[::2,20:30])<br/>&gt;&gt;&gt; print(val2.shape)<br/>(50, 10)<br/>&gt;&gt;&gt; del bed2</span></pre><p id="063b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe oe of og mo b">[::2,20:30]</code>的使用，这是Python NumPy的奇特索引的一个实例。Python科学程序员熟悉这种索引，非常适合指定要读取哪些基因组数据片段。</p><p id="71ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">仅仅是功能性防锈API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="0f78" class="ms mt iq mo b gy mu mv l mw mx">use crate::{counts, read_with_indexes};</span><span id="9a6f" class="ms mt iq mo b gy my mv l mw mx">let file_name = "bed_reader/tests/data/some_missing.bed";let (iid_count, _) = counts(file_name)?;<br/>let iid_index = (0..iid_count).step_by(2).collect::&lt;Vec&lt;_&gt;&gt;();<br/>let sid_index = (20..30).collect::&lt;Vec&lt;_&gt;&gt;();<br/>let val = read_with_indexes(<br/>    file_name,<br/>    iid_index.as_slice(),<br/>    sid_index.as_slice(),<br/>    true,<br/>    true,<br/>    f32::NAN,<br/> )?;<br/>println!("{:?}", val.shape());<br/>// [50, 10]</span></pre><p id="0349" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python在中的两行核心代码在Rust中变成了四条语句(和12行代码)。和以前一样，我们有不清楚的<code class="fe oe of og mo b">true, true</code>。此外，指定感兴趣的索引变得更加困难。此外，用户必须以某种方式理解索引必须被定义为向量(以便它们在某个地方被拥有)，但随后通过<code class="fe oe of og mo b">as_slice</code>传递(这是函数所期望的)。</p><p id="216b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子让我很尴尬，尤其是与Python相比。这促使我像这样改进Rust API:</p><p id="2af2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">新的、更优雅的Rust API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="c73d" class="ms mt iq mo b gy mu mv l mw mx">use ndarray::s;<br/><br/>let file_name = sample_bed_file("some_missing.bed")<strong class="mo ir">?</strong>;<br/>let mut bed = Bed::new(file_name)<strong class="mo ir">?</strong>;<br/>let val = ReadOptions::builder()<br/>    .iid_index(s![..;2])<br/>    .sid_index(20..30)<br/>    .f64()<br/>    .read(&amp;mut bed)<strong class="mo ir">?</strong>;<br/><br/>assert!(val.dim() == (50, 10));</span></pre><p id="f95e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我更喜欢这个。像Python一样，它支持有趣的索引。遗憾的是，Rust的标准范围——例如，<code class="fe oe of og mo b">20..30</code> —不支持步骤，所以API必须也支持<a class="ae kv" href="https://docs.rs/ndarray/latest/ndarray/macro.s.html" rel="noopener ugc nofollow" target="_blank">n数组切片</a> — <code class="fe oe of og mo b">s![..;2]</code>。(我们在规则6中看到Rust如何接受如此不同类型的输入。)</p><p id="a7c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看最后一个使用元数据的例子。</p><blockquote class="mg mh mi"><p id="220d" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">任务:</strong>列出前5个个体id，前5个SNP ids，以及每个唯一的染色体。然后，读取5号染色体中的每个值。</p></blockquote><p id="da48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在简介中看到了Python解决方案。仅仅是功能性的防锈解决方案有多糟糕？可悲的是，仅仅是功能性的API并不了解元数据。令人高兴的是，元数据文件只是六列文本文件，所以用户可以自己阅读，对吗？</p><p id="976d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">仅功能性防锈API: </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="4e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">呀，很尴尬。这是更好的防锈解决方案(我们在简介中也看到了)。</p><p id="b9f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">新的“优雅”Rust API: </em></p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="4438" class="ms mt iq mo b gy mu mv l mw mx">use std::collections::HashSet;<br/><br/>let mut bed = Bed::new(file_name)<strong class="mo ir">?</strong>;<br/>println!("{:?}", bed.iid()<strong class="mo ir">?</strong>.slice(s![..5]));<br/>println!("{:?}", bed.sid()<strong class="mo ir">?</strong>.slice(s![..5]));<br/>println!("{:?}", bed.chromosome()<strong class="mo ir">?</strong>.iter().collect::&lt;HashSet&lt;_&gt;&gt;());<br/>let val = ReadOptions::builder()<br/>    .sid_index(bed.chromosome()<strong class="mo ir">?</strong>.map(|elem| elem == "5"))<br/>    .f64()<br/>    .read(&amp;mut bed)<strong class="mo ir">?</strong>;<br/><br/>// Outputs ndarray: ["iid_0", "iid_1", "iid_2", "iid_3", "iid_4"]<br/>// Outputs ndarray: ["sid_0", "sid_1", "sid_2", "sid_3", "sid_4"]<br/>// Outputs: {"12", "10", "4", "8", "19", "21", "9", "15", "6", "16", "13", "7", "17", "18", "1", "22", "11", "2", "20", "3", "5", "14"}<br/>assert!(val.dim() == (100, 6));</span></pre><p id="7464" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">铁锈和蟒蛇差不多。然而，Rust更加冗长。例如，下面是借用单个id的一维NumPy/ndarray并打印前5项的代码:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="99bd" class="ms mt iq mo b gy mu mv l mw mx">print(bed.iid[:5]) # Python<br/>println!("{:?}", bed.iid()<strong class="mo ir">?</strong>.slice(s![..5])); // Rust</span></pre><p id="1a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些在语义上几乎相同，但是Python支持更简洁的数组相关语法。</p><p id="9bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是打印数组中唯一值的代码:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="c145" class="ms mt iq mo b gy mu mv l mw mx">print(np.unique(bed.chromosome)) # Python<br/>println!("{:?}", bed.chromosome()<strong class="mo ir">?</strong>.iter().collect::&lt;HashSet&lt;_&gt;&gt;()); // Rust</span></pre><p id="79a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python做得好一点，因为它成熟的NumPy库包含了<code class="fe oe of og mo b">np.unique</code>，而Rust的ndarray没有。</p><p id="56be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，要找到染色体“5”中的SNPs，代码是:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="c928" class="ms mt iq mo b gy mu mv l mw mx">np.s_[:,bed.chromosome=='5'] # Python<br/>bed.chromosome()<strong class="mo ir">?</strong>.map(|elem| elem == "5") // Rust</span></pre><p id="d85d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为Rust在这里打败了Python，因为它只使用了常见的语言特性，避免了不太常见的<code class="fe oe of og mo b">np.s_</code>。</p><p id="a1bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规则1的要点不是追求完美。相反，你应该瞄准有意义和有趣的例子。然后，在API上工作，直到这些例子可以被解决而不会感到尴尬，也许还会感到自豪。</p><h2 id="633d" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则2:接受所有类型的字符串、路径、向量、数组和可重复项</h2><p id="fb90" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">当给你的API一个路径时，你的用户可能希望使用一个<code class="fe oe of og mo b">String</code>或者一个<code class="fe oe of og mo b">&amp;String</code>或者一个<code class="fe oe of og mo b">&amp;str.</code>，你的用户可能希望给你一个<code class="fe oe of og mo b">PathBuf</code>、<code class="fe oe of og mo b">&amp;PathBuf</code>、<code class="fe oe of og mo b">&amp;Path</code>或者任何类型的字符串。此外，你的用户有时会希望给你自己的价值，有时是借来的价值。你可以用泛型来支持所有这些可能性。接受所有类型的向量、数组和可迭代对象怎么样？这也可以用泛型来支持。</p><blockquote class="mg mh mi"><p id="4ac0" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">更新:我创建了一个名为<em class="iq"> anyinput </em>的宏，让接受各种输入变得更容易。任何输入文件都有详细信息。如果使用<em class="iq"> anyinput </em>，可以跳到下一条规则。</p></blockquote><p id="881e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具体来说，对于路径，将路径定义为泛型类型<code class="fe oe of og mo b">P</code>，其中<code class="fe oe of og mo b">P</code>是<code class="fe oe of og mo b">AsRef&lt;Path&gt;</code>。例如，下面是打开. bed文件的函数<code class="fe oe of og mo b">Bed::new</code>的定义:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="2ba9" class="ms mt iq mo b gy mu mv l mw mx">pub fn new&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Self, BedErrorPlus&gt; {<br/>    Bed::builder(path).build()<br/>}</span></pre><p id="0361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是每个输入类型<code class="fe oe of og mo b">Bed::new</code>接受的:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="2def" class="ms mt iq mo b gy mu mv l mw mx">let path: &amp;str = "bed_reader/tests/data/small.bed";<br/>let _ = Bed::new(&amp;path)?; // borrow a &amp;str<br/>let _ = Bed::new(path)?; // move a &amp;str<br/>let path: String = "bed_reader/tests/data/small.bed".to_string();<br/>let _ = Bed::new(&amp;path)?; // borrow a String<br/>let path2: &amp;String = &amp;path;<br/>let _ = Bed::new(&amp;path2)?; // borrow a &amp;String<br/>let _ = Bed::new(path2)?; // move a &amp;String<br/>let _ = Bed::new(path)?; // move a String<br/>let path: &amp;Path = Path::new("bed_reader/tests/data/small.bed");<br/>let _ = Bed::new(&amp;path)?; // borrow a Path<br/>let _ = Bed::new(path)?; // move a Path<br/>let path: PathBuf = PathBuf::from("bed_reader/tests/data/small.bed");<br/>let _ = Bed::new(&amp;path)?; // borrow a PathBuf<br/>let path2: &amp;PathBuf = &amp;path;<br/>let _ = Bed::new(&amp;path2)?; // borrow a &amp;PathBuf<br/>let _ = Bed::new(path2)?; // move a &amp;PathBuf<br/>let _ = Bed::new(path)?; // move a PathBuf</span></pre><p id="6d3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您的函数中，<code class="fe oe of og mo b">.as_ref()</code>方法将有效地把这个输入转换成一个<code class="fe oe of og mo b">&amp;Path</code>。表情<code class="fe oe of og mo b">.as_ref().to_owned()</code>会给你一个拥有的<code class="fe oe of og mo b">PathBuf</code>。</p><p id="d859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于类似字符串的东西，用<code class="fe oe of og mo b">S: AsRef&lt;Str&gt;</code>定义你的函数。<code class="fe oe of og mo b">.as_ref()</code>方法将有效地将输入转换成<code class="fe oe of og mo b">&amp;str </code>和。<code class="fe oe of og mo b">as_ref().to_owned()</code>会给你一个拥有的<code class="fe oe of og mo b">String</code>。</p><p id="3344" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于向量、数组和可迭代的，有时我们只需要一些可迭代的东西。如果是这样，用<code class="fe oe of og mo b">I: IntoIterator&lt;Item = T&gt;</code>定义你的函数，其中<code class="fe oe of og mo b">T</code>是项目的类型，可能也是通用的。例如，<code class="fe oe of og mo b">MetadataBuilder::iid</code>是一个将单个id添加到内存元数据生成器的函数。(我们将在规则4中看到更多关于构建器的内容。)</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="b737" class="ms mt iq mo b gy mu mv l mw mx">pub fn iid&lt;I: IntoIterator&lt;Item = T&gt;, T: AsRef&lt;str&gt;&gt;(&amp;mut self, iid: I) -&gt; &amp;mut Self {<br/>    self.iid = Some(Some(Rc::new(<br/>        iid.into_iter().map(|s| s.as_ref().to_owned()).collect(),<br/>    )));<br/>    self<br/>}</span></pre><p id="95ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一会儿，我们将讨论这个函数可以接受什么以及代价是什么。首先，这里是一些<code class="fe oe of og mo b">MetadataBuilder::iid</code>接受的事情:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="0f3d" class="ms mt iq mo b gy mu mv l mw mx">let list: [&amp;str; 3] = ["i1", "i2", "i3"];<br/>let _ = Metadata::builder().iid(&amp;list).build()?; // borrow fixed-size array<br/>let _ = Metadata::builder().iid(list).build()?; // move fixed-size array<br/>let list: [String; 3] = ["i1".to_string(), "i2".to_string(), "i3".to_string()];<br/>let _ = Metadata::builder().iid(&amp;list).build()?; // borrow fixed-size array of String<br/>let _ = Metadata::builder().iid(list).build()?; // move fixed-size array of String<br/>let list: Vec&lt;&amp;str&gt; = vec!["i1", "i2", "i3"];<br/>let _ = Metadata::builder().iid(&amp;list).build()?; // borrow Vec&lt;&amp;str&gt;<br/>let list2 = &amp;list[..]; // borrowed slice<br/>let _ = Metadata::builder().iid(list2).build()?; // borrow slice<br/>let _ = Metadata::builder().iid(list).build()?; // move Vec&lt;&amp;str&gt;<br/>let list = nd::array!["i1", "i2", "i3"];<br/>let view = list.view();<br/>let _ = Metadata::builder().iid(&amp;view).build()?; // borrow nd view<br/>let _ = Metadata::builder().iid(view).build()?; // move nd view<br/>let _ = Metadata::builder().iid(&amp;list).build()?; // borrow ndarray<br/>let _ = Metadata::builder().iid(list).build()?; // move ndarray<br/>let list: std::str::Split&lt;&amp;str&gt; = "i1,i2,i3".split(",");<br/>let _ = Metadata::builder().iid(list).build()?; // move iterator</span></pre><p id="3010" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要随机访问的向量、数组和n数组是什么？那么你有一个选择。你可以把一切都当成锈片。例如:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="8f11" class="ms mt iq mo b gy mu mv l mw mx">pub fn any_slice&lt;A: AsRef&lt;[T]&gt;, T&gt;(slice: A) -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    let slice = slice.as_ref();<br/>    println!("slice len: {}", slice.len());<br/>    Ok(())<br/>}</span></pre><p id="ab01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这直接接受Rust中所有类似数组的东西，除了ndarrays和views。它们是通过转换成切片来间接接受的，例如<code class="fe oe of og mo b">nd_array1.as_slice().expect(“ndarray as_slice”)</code>。</p><p id="2707" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以将所有内容都视为ndarray视图。例如:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="2e9d" class="ms mt iq mo b gy mu mv l mw mx">pub fn any_array_view&lt;'a, T: 'a, A: Into&lt;nd::ArrayView1&lt;'a, T&gt;&gt;&gt;(<br/>    array: A,<br/>) -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    let array_view = array.into();<br/>    println!("array_view len: {}", array_view.len());<br/>    Ok(())<br/>}</span></pre><p id="f623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数直接接受所有类似数组的东西的借位，但是不接受移动。例如，这是可行的:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="9eec" class="ms mt iq mo b gy mu mv l mw mx">let array: [&amp;str; 3] = ["i1", "i2", "i3"];<br/>let _ = any_array_view(&amp;array)?; // borrow fixed-size array (can't move)</span></pre><p id="38df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的API只需要迭代借用用户的数据，<code class="fe oe of og mo b">IntoIterator</code>就很棒。但是，如果您需要自己的数据副本，您必须做出选择。</p><ul class=""><li id="7ded" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">使用<code class="fe oe of og mo b">IntoIterator</code>并重新分配。上面的<code class="fe oe of og mo b">iid</code>函数就是这么做的。如前所述，子表达式<code class="fe oe of og mo b">s.as_ref().to_owned()</code>将任何类似字符串的东西转化为拥有的<code class="fe oe of og mo b">String</code>。表情<code class="fe oe of og mo b">iid.into_iter()</code>...<code class="fe oe of og mo b">.collect()</code>，然后将任何可迭代的东西转换成所需的集合类型(在本例中是一个<code class="fe oe of og mo b">nd::array1&lt;String&gt;</code>)。对于Bed-Reader，我知道这些额外的分配并不重要，因为个体id数据通常比主要的基因组数据小1，000，000倍。</li><li id="9b1c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">或者，你可以要求用户给你一个特定类型的集合，并取得所有权。例如，上面的函数可能需要一个<code class="fe oe of og mo b">nd::array1&lt;String&gt;</code>。这样效率更高，但灵活性较差。</li></ul><blockquote class="mg mh mi"><p id="663b" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">性能提示:</strong>在Rust用户论坛上，<a class="ae kv" href="https://users.rust-lang.org/t/nine-rules-for-elegant-rust-library-apis/77208" rel="noopener ugc nofollow" target="_blank"> Kevin Reid指出</a>让这个泛型函数变小并调用一个非泛型函数来完成大部分工作是有好处的。这最小化了代码大小和编译时间。</p></blockquote><h2 id="c51c" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则3:了解用户的需求，最好是吃自己的狗粮</h2><p id="d419" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated"><a class="ae kv" href="https://fastlmm.github.io/" rel="noopener ugc nofollow" target="_blank">我们的基因组项目</a>已经阅读PLINK Bed文件超过10年了。两年前，一个用户要求我们把。bed将代码读入自己的Python包。我们基于我们的经验开发了这个包的Python API。例如，API仅在必要时读取元数据文件。此外，它将读取的任何元数据保存在内存中。这使得对大基因组数据的读取几乎可以立即开始，我们知道这对于例如集群运行是很重要的。</p><p id="b251" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们创建Python API时，我们重写了我们的其他工具来使用它，在我们进行的过程中改进了Python API。当我们创建Rust API时，我们重写了Python API来使用它，并在我们进行的过程中对Rust API进行了改进。这叫做“吃你自己的狗粮”。当我们开发Python API时，我们也向请求用户征求反馈。我们把他们愿意提供反馈视为对我们的帮助。</p><p id="541d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现随着Bed-Reader API的改进，内部和外部的用户代码都变得更简单了，这是非常令人满意的。</p><blockquote class="mg mh mi"><p id="4109" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated">坦白说:我们并不迫切需要一个Rust阅读器API。我创建它是因为我想学习如何在Rust中创建一个中等大小的API。我的设计基于Python API和Rust原则，而不是Rust用户需求。</p></blockquote><h2 id="1470" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则4:使用构建器，因为不能使用关键字参数。</h2><p id="b074" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">下面是一个使用关键字参数在Python中读取基因型数据的示例:</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="e2e8" class="ms mt iq mo b gy mu mv l mw mx">with open_bed(file_name, count_A1=False) as bed:<br/>    val = bed.read(<br/>        index=np.s_[:, :3],<br/>        dtype="int8",<br/>        order="C",<br/>        num_threads=1)<br/>    print(val.shape)</span></pre><p id="2bae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Rust中使用构建器的相同示例。</p><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="79b6" class="ms mt iq mo b gy mu mv l mw mx">let mut bed = Bed::new(filename)?;<br/>let val = ReadOptions::builder()<br/>    .sid_index(..3)<br/>    .i8()<br/>    .c()<br/>    .num_threads(1)<br/>    .read(&amp;mut bed)?;<br/>println!("{:?}", val.dim());</span></pre><p id="3e90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们是相似的。让我们来看看相应的参数，并详细比较Bed-Reader的Python和Rust方法是如何进行比较的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/8ef1932f3a8ad26752dbfb73aabfeebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*7F8JnnGUQ5JpTV_e-DfGoA.png"/></div></figure><ul class=""><li id="db6b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">Python的二维索引(<code class="fe oe of og mo b">index=np.s_[:, :3]</code>)变成了两个一维参数，其中用户通常只需要一个(<code class="fe oe of og mo b">.sid_index(..3)</code> )— Rust及其用户需要一维参数。此外，用户通常只需要索引一个维度。</li><li id="8ff3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">Python的字符串指定了与类型相关的三个选项(<code class="fe oe of og mo b">dtype='int8'</code>)中的一个，它变成了三个参数。Rust用户将使用一个(<code class="fe oe of og mo b">.i8()</code>)或无(当类型可以推断时)。</li><li id="8f95" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">Python的字符串指定两个选项之一(<code class="fe oe of og mo b">order='c'</code>)成为三个参数。Rust用户可以说<code class="fe oe of og mo b">.c()</code>(哪个更短)或者<code class="fe oe of og mo b">is_f(false)</code>(可以用变量设置)。</li><li id="20b4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">一个数(<code class="fe oe of og mo b">num_threads=1</code>)保持一个数(<code class="fe oe of og mo b">.num_threads(1)</code>)。</li><li id="691f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">一个Python布尔值(<code class="fe oe of og mo b">count_A1=False</code>)变成了三个参数。Rust用户可以说<code class="fe oe of og mo b">.count_a2()</code>或者<code class="fe oe of og mo b">.count_a1(false)</code>。</li></ul><p id="560d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Bed-Reader使用流行且强大的<a class="ae kv" href="https://crates.io/crates/derive_builder" rel="noopener ugc nofollow" target="_blank"> derive_builder </a>机箱来构建生成器。读床者的四个建设者是:</p><p id="eab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">参见文档和源代码的链接。</em></p><ul class=""><li id="09ae" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated"><code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.Bed.html#method.builder" rel="noopener ugc nofollow" target="_blank">Bed::builder</a></code> —需要选项时，打开Bed文件进行读取。(如果不需要选项，可以用<code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.Bed.html#method.new" rel="noopener ugc nofollow" target="_blank">Bed::new</a></code>代替。)</li><li id="d9ef" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated"><code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.ReadOptions.html#method.builder" rel="noopener ugc nofollow" target="_blank">ReadOptions::builder</a></code> —指定阅读选项，然后立即<code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.ReadOptionsBuilder.html#method.read" rel="noopener ugc nofollow" target="_blank">.read</a></code>或<code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.ReadOptionsBuilder.html#method.build" rel="noopener ugc nofollow" target="_blank">.build</a></code>(稍后阅读)。</li><li id="1435" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated"><code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.WriteOptions.html#method.builder" rel="noopener ugc nofollow" target="_blank">WriteOptions::builder</a></code> —指定写入选项，然后立即选择<code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.WriteOptionsBuilder.html#method.write" rel="noopener ugc nofollow" target="_blank">.write</a></code>或<code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.WriteOptionsBuilder.html#method.build" rel="noopener ugc nofollow" target="_blank">.build</a></code>(稍后写入)。</li><li id="4c36" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated"><code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.Metadata.html#method.builder" rel="noopener ugc nofollow" target="_blank">Metadata::builder</a></code> —指定创建内存元数据的选项，然后<code class="fe oe of og mo b"><a class="ae kv" href="https://docs.rs/bed-reader/0.2.19/bed_reader/struct.MetadataBuilder.html#method.build" rel="noopener ugc nofollow" target="_blank">.build</a></code>它。</li></ul><blockquote class="mg mh mi"><p id="04fe" class="kw kx mj ky b kz la jr lb lc ld ju le mk lg lh li ml lk ll lm mm lo lp lq lr ij bi translated"><strong class="ky ir">提示:</strong>在Rust用户论坛中，<a class="ae kv" href="https://users.rust-lang.org/t/nine-rules-for-elegant-rust-library-apis/77208" rel="noopener ugc nofollow" target="_blank"> H2CO3突出显示了</a>“<a class="ae kv" href="https://doc.rust-lang.org/book/ch05-01-defining-structs.html" rel="noopener ugc nofollow" target="_blank">结构更新语法</a>”(也称为功能记录更新(FRU))作为构建器的替代。使用默认值，用户可以通过仅指定非默认字段值来创建“选项结构”。</p></blockquote><h2 id="3460" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则5:编写好的文档来保持设计的诚实。</h2><p id="ab06" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">在某一点上，Bed-Reader Rust API的某些部分接受受限的内存中元数据对象，而某些部分则不接受。我试图解释文档中的这种不一致，但是越来越沮丧。我最终决定，我宁愿修复令人困惑的设计，而不是解释它。写文档激励我改进设计。</p><p id="a274" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写优秀文档的一些技巧:</p><ul class=""><li id="4543" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">使用Rust优秀的<a class="ae kv" href="https://doc.rust-lang.org/rustdoc/" rel="noopener ugc nofollow" target="_blank"> rustdoc系统</a>。</li><li id="cb50" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">记录每个公共函数、结构、枚举等。用<code class="fe oe of og mo b">#![warn(missing_docs)]</code>开始你的<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rustybed/src/lib.rs" rel="noopener ugc nofollow" target="_blank"> lib.rs </a>，你会被提醒记录所有的事情。</li><li id="555e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">在几乎所有的文档中都包含示例。如果你不能创建简单的例子，你的API设计需要更多的工作。用Rust的标准<code class="fe oe of og mo b">cargo test</code>命令测试这些例子。</li><li id="d609" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">不要惊慌。你的例子应该返回错误(通过<code class="fe oe of og mo b">?</code>)，而不是恐慌(通过<code class="fe oe of og mo b">.unwrap()</code>)。rustdoc手册告诉<a class="ae kv" href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html?highlight=errors#using--in-doc-tests" rel="noopener ugc nofollow" target="_blank">如何设置</a>进行测试。也见规则8。</li><li id="6f3f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">为你的项目写好<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rustybed/README-rust.md" rel="noopener ugc nofollow" target="_blank"> README.md </a>。它还可以作为API文档的介绍。在你的<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rustybed/src/lib.rs" rel="noopener ugc nofollow" target="_blank">库</a>中包含<code class="fe oe of og mo b">#![doc = include_str!("../README.md")]</code>。这种包含提供了一个额外的好处，即您的README.md中的任何示例都将作为测试运行。</li><li id="e729" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">阅读、重读和编辑你的文档，直到它很好地向你的用户解释了你的API。(生成文档并在浏览器中弹出的命令是<code class="fe oe of og mo b">cargo doc --no-deps --open</code>。)</li></ul><p id="e85b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里看到我写好文档的尝试:<a class="ae kv" href="https://docs.rs/bed-reader/latest/bed_reader/index.html" rel="noopener ugc nofollow" target="_blank">bed _ reader—Rust(docs . RS)</a>。源代码(可从文档中获得链接)显示了markdown格式，例如总结特性的表格。</p><h2 id="028d" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则6:接受所有类型的类型。</h2><p id="362b" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">当Bed-Reader的用户指定要阅读的个人或SNP时，他们可以给出:</p><ul class=""><li id="e066" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">索引号(例如，<code class="fe oe of og mo b">1</code>)</li><li id="8204" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">一个数组，vector，Rust slice，ndarray::Array，ndarray::索引号视图(<code class="fe oe of og mo b">[0, 10, -2]</code>)</li><li id="03ad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">一个锈层(<code class="fe oe of og mo b">3..</code>和<code class="fe oe of og mo b">10..=19</code>)或一个阵列切片(<code class="fe oe of og mo b">s![-20..-10;-2]</code>)</li><li id="8636" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr od ly lz ma bi translated">一个数组，vector，Rust slice，ndarray::Array，ndarray::布尔值的视图(<code class="fe oe of og mo b">[true, false true]</code>)</li></ul><p id="4dd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于Rust强大的打字能力，这怎么可能呢？关键是一个枚举和转换函数。具体来说，</p><ul class=""><li id="b63e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">用要存储的所有类型定义一个枚举。名为<code class="fe oe of og mo b">Index</code>的床阅读器枚举定义为:</li></ul><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="10b2" class="ms mt iq mo b gy mu mv l mw mx">#[derive(Debug, Clone)]<br/>pub enum Index {<br/>   #[allow(missing_docs)]<br/>    All,<br/>    #[allow(missing_docs)]<br/>    One(isize),<br/>    #[allow(missing_docs)]<br/>    Vec(Vec&lt;isize&gt;),<br/>    #[allow(missing_docs)]<br/>    NDArray(nd::Array1&lt;isize&gt;),<br/>    #[allow(missing_docs)]<br/>    VecBool(Vec&lt;bool&gt;),<br/>    #[allow(missing_docs)]<br/>    NDArrayBool(nd::Array1&lt;bool&gt;),<br/>    #[allow(missing_docs)]<br/>    NDSliceInfo(SliceInfo1),<br/>    #[allow(missing_docs)]<br/>    RangeAny(RangeAny),<br/>}</span></pre><ul class=""><li id="5af1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">实现<code class="fe oe of og mo b">From</code>函数将所有感兴趣的类型转换到你的枚举中。您转换的类型不能重叠。以下是Bed-Reader的四个<code class="fe oe of og mo b">From</code>实现:</li></ul><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="b403" class="ms mt iq mo b gy mu mv l mw mx">impl From&lt;isize&gt; for Index {<br/>    fn from(one: isize) -&gt; Index {<br/>        Index::One(one)<br/>    }<br/>}<br/>impl From&lt;&amp;isize&gt; for Index {<br/>    fn from(one: &amp;isize) -&gt; Index {<br/>        Index::One(one.to_owned())<br/>    }<br/>}<br/>impl&lt;const N: usize&gt; From&lt;[bool; N]&gt; for Index {<br/>    fn from(array: [bool; N]) -&gt; Index {<br/>        Index::VecBool(array.to_vec())<br/>    }<br/>}<br/>impl&lt;const N: usize&gt; From&lt;&amp;[bool; N]&gt; for Index {<br/>    fn from(array: &amp;[bool; N]) -&gt; Index {<br/>        Index::VecBool(array.to_vec())<br/>    }<br/>}</span></pre><ul class=""><li id="8372" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">在你的枚举上实现函数来做你需要的任何事情。例如，给定个体的计数，我需要知道一个<code class="fe oe of og mo b">Index</code>的长度。我定义<code class="fe oe of og mo b">.len(count)</code>。<a class="ae kv" href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank"> Clippy </a>(见规则10)提醒我也要定义<code class="fe oe of og mo b">is_empty</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="e0c9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">最后，如果你的枚举在一个常规函数中使用，用<code class="fe oe of og mo b">impl Into&lt;YourEnum&gt;</code>定义它，然后在你的函数中使用<code class="fe oe of og mo b">.into()</code>(见下文)。如果你的函数是构建器的一部分，并且你使用了<a class="ae kv" href="https://crates.io/crates/derive_builder" rel="noopener ugc nofollow" target="_blank"> derive_builder </a>，你可以用<code class="fe oe of og mo b">#[builder(setter(into))]</code>标记你的结构的字段(这里是)。例如:</li></ul><pre class="kg kh ki kj gt mn mo mp mq aw mr bi"><span id="a96e" class="ms mt iq mo b gy mu mv l mw mx">// Tells the length of an index if the count of items is exactly 100<br/>fn len100(index: impl Into&lt;Index&gt;) -&gt; Result&lt;usize, BedErrorPlus&gt; {<br/>    let index = index.into();<br/>    let len = index.len(100)?;<br/>    Ok(len)<br/>}<br/>let _ = len100(3..)?;</span><span id="4a7f" class="ms mt iq mo b gy my mv l mw mx">let _ = ReadOptions::builder().iid_index(3..).i8().build()?;</span></pre><p id="2597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">(拜</em> <a class="ae kv" href="https://users.rust-lang.org/t/nine-rules-for-elegant-rust-library-apis/77208" rel="noopener ugc nofollow" target="_blank"> <em class="mj">凯文读为《impl Into》上的提示</em> </a> <em class="mj">)。)</em></p><h2 id="9a23" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则7:编写API测试。</h2><p id="8aa9" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">编写API测试，而不仅仅是单元测试。这需要在src文件夹之外创建一个<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rustybed/tests/tests_api.rs" rel="noopener ugc nofollow" target="_blank"> tests/test_api.rs </a>文件。这让您可以像用户一样测试API的公共方法。比如<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rustybed/tests/tests_api.rs" rel="noopener ugc nofollow" target="_blank">阅床者的test_api.rs </a>说的是<code class="fe oe of og mo b">use bed_reader::Bed;</code>而不是<code class="fe oe of og mo b">use crate::Bed;</code>。</p><h2 id="4235" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则8:定义并返回好的错误。</h2><p id="23b0" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">定义并返回好的错误，例如，通过<a class="ae kv" href="https://docs.rs/thiserror/latest/thiserror/" rel="noopener ugc nofollow" target="_blank"> thiserror </a>箱。在Bed-Reader的<a class="ae kv" href="https://github.com/fastlmm/bed-reader/blob/rustybed/src/lib.rs" rel="noopener ugc nofollow" target="_blank"> lib.rs </a>中，我们为库定义的所有错误创建了一个名为BedError的枚举。然后我们创建一个名为BedErrorPlus的枚举来覆盖来自其他箱子的BedError和错误。</p><h2 id="ca33" class="ms mt iq bd nh ni nj dn nk nl nm dp nn lf no np nq lj nr ns nt ln nu nv nw nx bi translated">规则9:使用Clippy</h2><p id="d0ef" class="pw-post-body-paragraph kw kx iq ky b kz ny jr lb lc nz ju le lf oa lh li lj ob ll lm ln oc lp lq lr ij bi translated">用<a class="ae kv" href="https://github.com/rust-lang/rust-clippy" rel="noopener ugc nofollow" target="_blank">防锈纸</a>涂上严格的林挺。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="d662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，现在你有了:Rust库API的九条规则。当你创建了你的优雅的Rust crate并准备发布时，命令是<a class="ae kv" href="https://doc.rust-lang.org/cargo/commands/cargo-publish.html" rel="noopener ugc nofollow" target="_blank"> cargo publish </a>。</p><p id="d40e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用Bed-Reader的经验表明，我们可以拥有Rust的性能和Python的优雅。这是有代价的，也就是说，目前在Rust中创建一个好的API不像在Python中那么容易。遵循这九条规则，让创建一个优秀的Rust库API的过程变得更加简单。</p><p id="440a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mj">西雅图Rust Meetup用YouTube </em>  <em class="mj">上的</em> <a class="ae kv" href="https://www.youtube.com/watch?v=6-8-9ZV-2WQ&amp;t=61s" rel="noopener ugc nofollow" target="_blank"> <em class="mj">视频主持了一场关于这篇文章的演讲。请</em> </a><a class="ae kv" href="https://medium.com/@carlmkadie" rel="noopener"> <em class="mj">跟我上媒</em> </a> <em class="mj">。我写的是Rust和Python的科学编程、机器学习和统计学。我倾向于每月写一篇文章。</em></p></div></div>    
</body>
</html>