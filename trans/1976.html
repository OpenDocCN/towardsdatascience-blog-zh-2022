<html>
<head>
<title>Dynamically Add Arguments to Argparse | Python Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Argparse | Python模式动态添加参数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dynamically-add-arguments-to-argparse-python-patterns-a439121abc39#2022-05-05">https://towardsdatascience.com/dynamically-add-arguments-to-argparse-python-patterns-a439121abc39#2022-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用argparse.ArgumentParser根据用户输入指定不同的参数。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66da7a5805c0331ad63c5027a5a6216a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ATIG5q6qcJ1yULo_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><h1 id="d82a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="8acf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当数据科学家的需求超出Jupyter笔记本电脑所能提供的范围时，命令行界面(cli)工具就是他们的面包和黄油。Python的来自标准库的<em class="mn"> argparse </em>是我们在Python旅程中遇到的第一个相对容易地构建这种接口的工具。然而，尽管只使用ArgumentParser类的三个方法就可以很容易地构建一个带有argparse的小型易用cli，但是当接口增长并变得更加复杂时，就需要进行一些额外的规划。在本文中，我们探索了将cli划分为单独的子命令的方法，这些子命令带有可以在运行时加载的参数，以及如何将它们与设计模式结合起来，以便更容易地扩展它。</p><h1 id="39ff" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">多个子命令</h1><p id="b568" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">大多数cli工具都提供了多个命令，每个命令都有自己独特的一组参数。让我们以git为例，下面是您可以运行的所有git命令的列表:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="dfb6" class="mt la it mp b gy mu mv l mw mx">$ git --help<br/>[...]<br/>These are common Git commands used in various situations:<br/><br/>start a working area (see also: git help tutorial)<br/>   clone     Clone a repository into a new directory<br/>   init      Create an empty Git repository or reinitialize an existing one<br/><br/>work on the current change (see also: git help everyday)<br/>   add       Add file contents to the index<br/>   mv        Move or rename a file, a directory, or a symlink<br/>   restore   Restore working tree files<br/>   rm        Remove files from the working tree and from the index<br/><br/>examine the history and state (see also: git help revisions)<br/>   bisect    Use binary search to find the commit that introduced a bug<br/>   diff      Show changes between commits, commit and working tree, etc<br/>   grep      Print lines matching a pattern<br/>   log       Show commit logs<br/>   show      Show various types of objects<br/>   status    Show the working tree status<br/><br/>grow, mark and tweak your common history<br/>   branch    List, create, or delete branches<br/>   commit    Record changes to the repository<br/>   merge     Join two or more development histories together<br/>   rebase    Reapply commits on top of another base tip<br/>   reset     Reset current HEAD to the specified state<br/>   switch    Switch branches<br/>   tag       Create, list, delete or verify a tag object signed with GPG<br/><br/>collaborate (see also: git help workflows)<br/>   fetch     Download objects and refs from another repository<br/>   pull      Fetch from and integrate with another repository or a local branch<br/>   push      Update remote refs along with associated objects</span></pre><p id="7d3a" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这些是其中一些的论据:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2535" class="mt la it mp b gy mu mv l mw mx">$ git add --help</span><span id="2b8f" class="mt la it mp b gy nd mv l mw mx">SYNOPSIS</span><span id="74fd" class="mt la it mp b gy nd mv l mw mx"><em class="mn">git add</em> [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p] [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--sparse] [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [-renormalize] [--chmod=(+|-)x] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]] [--] [&lt;pathspec&gt;…​]</span><span id="4bd5" class="mt la it mp b gy nd mv l mw mx">$ git commit --help</span><span id="9917" class="mt la it mp b gy nd mv l mw mx">SYNOPSIS</span><span id="acc9" class="mt la it mp b gy nd mv l mw mx"><em class="mn">git commit</em> [-a | --interactive | --patch] [-s] [-v] [-u&lt;mode&gt;] [--amend]<br/>           [--dry-run] [(-c | -C | --squash) &lt;commit&gt; | --fixup [(amend|reword):]&lt;commit&gt;)]<br/>           [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty]<br/>           [--allow-empty-message] [--no-verify] [-e] [--author=&lt;author&gt;]<br/>           [--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;] [--[no-]status]<br/>           [-i | -o] [--pathspec-from-file=&lt;file&gt; [--pathspec-file-nul]]<br/>           [(--trailer &lt;token&gt;[(=|:)&lt;value&gt;])…​] [-S[&lt;keyid&gt;]]<br/>           [--] [&lt;pathspec&gt;…​]</span></pre><p id="2abe" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">你可以看到它们重叠但不相同。如果您尝试将一个命令与另一个命令的参数一起使用，显然会失败:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="5a98" class="mt la it mp b gy mu mv l mw mx">$ git add --reset-author<br/>error: unknown option `reset-author'<br/>usage: git add [&lt;options&gt;] [--] &lt;pathspec&gt;...</span></pre><p id="7467" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">假设你正在用Python为你的数据科学工作编写一个cli工具，也许你正在用深度学习编写一个工具来解决你领域中的问题</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/pick-your-deep-learning-tool-d01fcfb86845"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">挑选你的深度学习工具</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">为什么您的工具可以依赖于您组织的团队结构</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv ks nh"/></div></div></a></div><p id="2485" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">然后你很可能用标准库中的<em class="mn"> argparse </em>编写你的cli，因为它可能不是最好的，但它肯定是你学习的第一个。</p><p id="2ffa" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">构建一个参数解析器来使用子命令非常简单，我们将用一个例子来展示它。我们有一个示例应用程序，命令<em class="mn"> train </em>和<em class="mn"> infer，</em>各有不同的参数，可以是强制的，也可以是可选的。示例代码可在<a class="ae ky" href="https://github.com/mattiadg/example-cli/blob/main/src/sub_commands.py" rel="noopener ugc nofollow" target="_blank">https://github.com/mattiadg/example-cli</a>获得，为方便起见在此复制:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="4b32" class="mt la it mp b gy mu mv l mw mx"># src/sub_commands.py</span><span id="e096" class="mt la it mp b gy nd mv l mw mx">import argparse<br/><br/>from commands import train, infer<br/><br/><br/>if __name__ == "__main__":<br/>    parser = argparse.ArgumentParser("Example v2")<br/>    subparsers = parser.add_subparsers(help="Sub-commands help")<br/><br/>    parser_train = subparsers.add_parser("train", help="Train a model")<br/>    parser_train.add_argument(<br/>        "--model",<br/>        "-m",<br/>        required=True,<br/>        help="name of the deep learning architecture to use",<br/>    )<br/>    parser_train.add_argument(<br/>        "--save_model_path",<br/>        required=True,<br/>        help="Path to the directory where to save the model",<br/>    )<br/>    parser_train.add_argument(<br/>        "--dropout",<br/>        type=float,<br/>        default=0.1,<br/>        help="Dropout value, equal for each value",<br/>    )<br/>    parser_train.add_argument(<br/>        "--batch_size", type=int, help="Batch size during training"<br/>    )<br/>    parser_train.set_defaults(func=train)<br/><br/>    parser_infer = subparsers.add_parser("infer", help="Use a model for inference")<br/>    parser_infer.add_argument(<br/>        "--model_path", required=True, help="Path to the model to use for inference"<br/>    )<br/>    parser_infer.add_argument(<br/>        "--batch_size", type=int, help="Batch size during inference"<br/>    )<br/>    parser_infer.set_defaults(func=infer)<br/><br/>    args = parser.parse_args()<br/>    args.func(args)</span></pre><p id="474e" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">argparse中的子参数将完成这项工作。我们首先需要声明我们想要使用子参数:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="604b" class="mt la it mp b gy mu mv l mw mx">subparsers = parser.add_subparsers(help="Sub-commands help")</span></pre><p id="a5de" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">然后，我们用add_parser()方法为命令“train”和“infer”声明子参数:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2aac" class="mt la it mp b gy mu mv l mw mx">parser_train = subparsers.add_parser("train", help="Train a model")<br/>parser_infer = subparsers.add_parser("infer", help="Use a model for inference")</span></pre><p id="1aa2" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">然后，子解析器的行为将与任何其他解析器完全一样。让我们测试一下我们的cli:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="c32f" class="mt la it mp b gy mu mv l mw mx">$ python .\src\sub_commands.py train -m transformer --save_model_path $HOME/my_model_path/<br/>Training model with:<br/>model=transformer<br/>save_model_path=/home/me/my_model_path/<br/>dropout=0.1<br/>batch_size=None<br/>func=&lt;function train at 0x000001F9433493A0&gt;</span></pre><p id="9eca" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">它不接受特定于推断的参数:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="f43a" class="mt la it mp b gy mu mv l mw mx">$ python .\src\correct.py train -m transformer --save_model_path $HOME/my_model_path/ --model_path .<br/>usage: Example v2 [-h] {train,infer} ...<br/>Example v2: error: unrecognized arguments: --model_path .</span></pre><p id="b676" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">但是—当使用“推断”命令时，模型路径可以正常工作</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="54d7" class="mt la it mp b gy mu mv l mw mx">$ python .\src\correct.py infer --model_path $HOME/my_model_path/<br/>Inferring with model with:<br/>model_path=/home/me/my_model_path/<br/>batch_size=None<br/>func=&lt;function infer at 0x000001A1881AD1F0&gt;</span></pre><h1 id="620c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动态参数</h1><p id="c45f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们想要为我们想要训练的模型指定一些参数。在我们的例子中，我们有两个不同的模型，transformer和lstm。Lstm将输出向量的大小和状态向量的大小作为参数。变压器具有子层的大小，并且对于大的前馈子层具有不同的大小。两种模型类型都将层数作为参数。</p><p id="70fb" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">我没有找到将子解析器附加到命名参数(如model)的方法，所以我们必须遵循不同的路线。</p><p id="871d" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">首先，为了保持解析器代码的可管理性，我们不希望所有的参数都出现在同一个主文件中。我们将把新的参数保存在文件中，在文件中我们使用一个函数来定义各自的模型，该函数将解析器作为输入并添加新的参数。</p><p id="5a5c" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">Lstm看起来是这样的:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="727d" class="mt la it mp b gy mu mv l mw mx"># src/models/lstm.py</span><span id="5650" class="mt la it mp b gy nd mv l mw mx">def add_arguments(parser):<br/>    parser_lstm = parser.add_argument_group("lstm")<br/>    parser_lstm.add_argument("--num_layers", type=int, help="Number of LSTM layers")<br/>    parser_lstm.add_argument("--forward_size", type=int, help="Number of units in the forward propagation")<br/>    parser_lstm.add_argument("--state_size", type=int, help="Number of units for the state vector")</span></pre><p id="39c3" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">以下为变压器</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="5411" class="mt la it mp b gy mu mv l mw mx"># src/models/transformer.py</span><span id="a06a" class="mt la it mp b gy nd mv l mw mx">def add_arguments(parser):<br/>    parser_trafo = parser.add_argument_group("transformer")<br/>    parser_trafo.add_argument("--num_layers", type=int, help="Number of Transformer layers")<br/>    parser_trafo.add_argument("--forward_size", type=int, help="Number of units in the forward propagation")<br/>    parser_trafo.add_argument("--hidden_size", type=int, help="Number of units in the hidden FF layers")</span></pre><p id="7306" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">现在，我们不能在启动时添加来自不同模型的所有参数，因为它们有冲突的名称(— num_layers)，这会使解析器崩溃。在duplicate.py文件中，我们复制了上一节中的代码，并添加了来自两个模型的参数，您可以在<a class="ae ky" href="https://github.com/mattiadg/example-cli/blob/main/src/duplicate_arguments.py" rel="noopener ugc nofollow" target="_blank">https://github . com/matti adg/example-CLI/blob/main/src/duplicate _ arguments . py</a>找到:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="dc77" class="mt la it mp b gy mu mv l mw mx"># src/duplicate_arguments.py</span><span id="3a20" class="mt la it mp b gy nd mv l mw mx">import argparse<br/><br/>from commands import train, infer<br/>import models.lstm<br/>import models.transformer<br/><br/><br/>if __name__ == "__main__":<br/> .<br/> .<br/> .</span><span id="07d0" class="mt la it mp b gy nd mv l mw mx">models.lstm.add_arguments(parser)<br/>models.transformer.add_arguments(parser)<br/><br/>args = parser.parse_args()<br/>args.func(args)</span></pre><p id="1e02" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果我们现在跑</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="d8a4" class="mt la it mp b gy mu mv l mw mx">$ python .\src\duplicate_arguments.py infer --model_path $HOME/my_model_path/</span></pre><p id="3537" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">我们得到预期的误差</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="c76a" class="mt la it mp b gy mu mv l mw mx">argparse.ArgumentError: argument --num_layers: conflicting option string: --num_layers</span></pre><p id="c123" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">很明显，我们需要一种方法来动态地向我们的解析器<em class="mn">，</em>添加参数，也就是说，在运行时根据用户的输入。然而，ArgumentParser的任何方法都不允许我们直接这样做<em class="mn"/>，我们需要利用一点小技巧。</p><p id="daf9" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">我们需要解析参数两次，第一次获取模型值，然后加载相应的参数，第二次解析我们可以获取特定于命令的参数。</p><p id="f053" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">为此，我们需要解析器忽略用户插入的、尚未作为参数添加的参数。幸运的是，parse_known_args()恰恰做到了这一点！</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="78ad" class="mt la it mp b gy mu mv l mw mx"># src/model_loader.py</span><span id="9f1f" class="mt la it mp b gy nd mv l mw mx">import argparse<br/><br/>from commands import train, infer<br/><br/># src/model_loader.py</span><span id="77d5" class="mt la it mp b gy nd mv l mw mx">from commands import train, infer<br/>from models.loader import load_model_args<br/>.<br/>.<br/>.</span><span id="3214" class="mt la it mp b gy nd mv l mw mx">args_, _ = parser.parse_known_args()<br/><br/>load_model_args(parser_train, args_.model)<br/><br/>args = parser.parse_args()<br/>args.func(args)</span></pre><p id="4622" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">其中parser_train是train命令的子参数，如前所述，而游戏规则的改变者是这一行:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="0da3" class="mt la it mp b gy mu mv l mw mx">args_, _ = parser.parse_known_args()</span></pre><p id="0f28" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">它需要两个返回值，因为parse_known_args返回一个元组，在第一个位置包含已解析的参数，在第二个位置包含所有其他的参数。这是我们通过打印parser.parse_known_args()的结果得到的结果:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2f08" class="mt la it mp b gy mu mv l mw mx">$ python .\src\model_loader.py train -m transformer --save_model_path $HOME/my_model_path/ --num_layers 6 --forward_si<br/>ze 512 --hidden_size 2048</span><span id="1d8d" class="mt la it mp b gy nd mv l mw mx">(Namespace(model='transformer', save_model_path='/home/me/my_model_path/', dropout=0.1, batch_size=None, func=&lt;function train at 0x000001E0125DA3A0&gt;), ['--num_layers', '6', '--forward_size', '512', '--hidden_size', '2048'])</span></pre><p id="7abe" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">通过最新的修改，我们最终得到了预期的结果:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="5a07" class="mt la it mp b gy mu mv l mw mx">$ python .\src\model_loader.py train -m transformer --save_model_path $HOME/my_model_path/ --num_layers 6 --forward_si<br/>ze 512 --hidden_size 2048</span><span id="edfc" class="mt la it mp b gy nd mv l mw mx">Training model with:<br/>model=transformer<br/>save_model_path=C:\Users\matti/my_model_path/<br/>dropout=0.1<br/>batch_size=None<br/>num_layers=6<br/>forward_size=512<br/>hidden_size=2048<br/>func=&lt;function train at 0x000001E0125DA3A0&gt;</span></pre><p id="4b67" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">缺少的步骤只有load_model_args()函数，它为正确的模型加载参数。这是:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="2355" class="mt la it mp b gy mu mv l mw mx"># src/models/loader.py</span><span id="b727" class="mt la it mp b gy nd mv l mw mx">import importlib<br/><br/><br/>def load_model_args(parser, model):<br/>    module = importlib.import_module("."+model, "models")<br/>    module.add_arguments(parser)</span></pre><p id="2bee" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这是一个基本的实现，它只接受模型名，在“model”包中导入同名的模块，然后在作为输入接收的parser_train上调用其中的add_arguments函数(如上所示)。</p><p id="dfc6" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">这里缺少的是可用模型的列表。如果给定一个随机的模型名，我们的代码就会失败，因为它找不到相应的模块。另一种方法是预先将所有模型的所有add_arguments()函数和它们相应的名称添加到注册表中。然后，我们可以在— model参数中提供这些选项作为“<a class="ae ky" href="https://docs.python.org/3/library/argparse.html#the-add-argument-method" rel="noopener ugc nofollow" target="_blank">选择</a>”。使用Register模式可以很容易地做到这一点，我在上一篇文章中描述过:</p><div class="ne nf gp gr ng nh"><a rel="noopener follow" target="_blank" href="/python-polymorphism-with-class-discovery-28908ac6456f"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd iu gy z fp nm fr fs nn fu fw is bi translated">带寄存器的Python多态性| Python模式</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">学习一种模式来隔离包，同时扩展Python代码的功能。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">towardsdatascience.com</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv ks nh"/></div></div></a></div><p id="ebc3" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">为什么我们要使用这种似乎会增加代码复杂性的模式呢？答案是，这里的代码非常简单，但是当您有几个模型时，它会变得越来越复杂，并且还希望为不同的优化器、数据加载器、搜索算法和代码中需要参数化的任何东西提供特定的参数。然后，代码变得固有地复杂，最好通过为每个类别设置一个单一的入口点(注册表)来隔离更改，并使特定的代码只与通用代码接口。此外，主函数将只与通用代码(load_model_args、load_optimizer_args等)通信，代码库变得更容易推理。</p><h1 id="2d4b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="ba1a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们已经看到了如何使用Python标准库中的argparse构建越来越复杂的CLI。我们从简单地使用子参数向程序添加子命令开始，然后我们看到了如何使用parse_know_args根据用户的选择加载新的参数。最后，我们讨论了Register模式如何帮助我们的解析器实现关注点隔离。</p><p id="36f6" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">作为最新的评论，如果你对开发cli工具感兴趣，考虑使用提供比argparse更多特性的库，比如<a class="ae ky" href="https://github.com/janluke/cloup" rel="noopener ugc nofollow" target="_blank"> cloup </a>。</p><h1 id="b23b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">中等会员</h1><p id="9b6b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你喜欢我的文章吗？你是否正在考虑申请一个中级会员来无限制地阅读我的文章？</p><p id="554a" class="pw-post-body-paragraph lr ls it lt b lu my ju lw lx mz jx lz ma na mc md me nb mg mh mi nc mk ml mm im bi translated">如果您决定通过此链接订阅，您将通过您的订阅支持我，无需为您支付额外费用【https://medium.com/@mattiadigangi/membership<a class="ae ky" href="https://medium.com/@mattiadigangi/membership" rel="noopener"/></p></div></div>    
</body>
</html>