<html>
<head>
<title>Algorithms Explained #7: Huffman Coding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释#7:霍夫曼编码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-explained-7-huffman-coding-1be107beb546#2022-10-28">https://towardsdatascience.com/algorithms-explained-7-huffman-coding-1be107beb546#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d4b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种文本压缩算法的解释及其在Python中的实现</h2></div><p id="6e98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本算法讲解系列的前几篇文章中，我们经历了六种不同类型的算法(<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>)。在本文中，我们将深入研究一个用于文本压缩的贪婪算法的实际用例——霍夫曼编码。</p><h1 id="db47" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是霍夫曼编码？</h1><p id="af6d" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">霍夫曼编码是一种经常使用的技术，用于在不丢失信息的情况下将文本压缩到较小的大小。信息被编码为二进制字符串(1和0的比特)，目标是用尽可能少的比特明确地传输信息。</p><p id="8fa2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种贪婪算法通过评估字符的频率并使用按频率排序的二叉树，找到了将每个字符编码为二进制字符串的最佳方式。出现频率较高的字符被编码为较短位的字符串，而出现频率较低的字符被编码为较长位的字符串。</p><h1 id="0b00" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">霍夫曼编码是如何工作的？</h1><p id="80a7" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">该算法通过使用优先级队列<em class="mc"> Q </em>以自下而上的方式构建树<em class="mc"> T </em>来工作，该优先级队列选择两个最不频繁的对象并将它们合并在一起，进而创建一个新对象，其频率是两个合并对象的频率之和。重复这个过程，直到输入文本中的所有单词都被编码。</p><h1 id="0af6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">用Python实现霍夫曼编码</h1><p id="be95" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">考虑下面这个词——“最小”。</p><h2 id="03dc" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">I .创建一个树数据类</h2><p id="1758" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">第一步包括编写一个数据类来存储树的数据。我选择使用数据类而不是常规类，因为在Python 3中，默认情况下数据类有各种“dunder”方法。例如，生成的<code class="fe mp mq mr ms b">repr</code>(打印表示)字符串将包含类名，以及每个字段的名称和值，使用户更容易理解打印的树实例。</p><p id="1a6a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据类本身相对简单。它包含两个参数，<code class="fe mp mq mr ms b">left</code>表示左节点(str)，而<code class="fe mp mq mr ms b">right</code>表示右节点(str)。当构建树时，我们需要访问子节点，所以在这个数据类中，有一个函数<code class="fe mp mq mr ms b">children()</code>简单地返回<code class="fe mp mq mr ms b">left</code>和<code class="fe mp mq mr ms b">right</code>节点。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="031a" class="md lg it ms b gy nb nc l nd ne">from dataclasses import dataclass</span><span id="b4f9" class="md lg it ms b gy nf nc l nd ne"><a class="ae le" href="http://twitter.com/dataclass" rel="noopener ugc nofollow" target="_blank">@dataclass</a><br/>class Tree:<br/>   left: str<br/>   right: str</span><span id="c847" class="md lg it ms b gy nf nc l nd ne">   def children(self):<br/>      return self.left, self.right</span></pre><h2 id="9015" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">二。构建树</h2><p id="9424" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">接下来，我们将构建一个包含输入文本中按频率排序的所有字符的树。为此，我们将查看字符频率，并将这些字符存储在按频率排序的优先级队列<em class="mc"> Q </em>中。</p><p id="c056" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们开始构建一棵树，由此我们将来自<em class="mc"> Q </em>的具有最小频率的字符指定为根节点的左子节点，并将来自<em class="mc"> Q </em>的具有第二最小频率的字符指定为根节点的右子节点。然后，我们将根节点的值指定为两个子节点的频率之和。</p><p id="2c40" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到我们的词(“最小”)，按频率排序的唯一字符数是:<code class="fe mp mq mr ms b">{'m': 3, 'i': 2, 'n': 1, 'u': 1}</code>。因此，第一次迭代将构建一个深度为1的树，由计数为1的“u”作为左子节点，计数为1的“n”作为右子节点，sum (2)作为根节点。</p><figure class="mt mu mv mw gt nh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0411bd7b07776a94f2b56c863979aefe.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*CDd-ttUB-d6pSp__VXgKTA.png"/></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">从第一次迭代构建的树</p></figure><p id="5647" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们重复同样的过程，直到所有的字符都被编码，我们最终得到一个最大深度为3的树，如下图所示。</p><figure class="mt mu mv mw gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/0513491cc5d36b386d83a82d05beda64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grq8hX_EjEkgQQussVBH5Q.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">由单词“最小值”构造的树</p></figure><p id="cfbb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是用Python编写的<code class="fe mp mq mr ms b">HuffmanCodingTree</code>类中的<code class="fe mp mq mr ms b">_build_tree()</code>函数的代码片段，它从输入文本构建了一棵树。与上述过程类似，该函数执行以下操作:</p><ol class=""><li id="ca5a" class="nt nu it kk b kl km ko kp kr nv kv nw kz nx ld ny nz oa ob bi translated">统计输入文本中独特字符的频率，并将其存储为名为<code class="fe mp mq mr ms b">char_counts</code>的字典。</li><li id="cafd" class="nt nu it kk b kl oc ko od kr oe kv of kz og ld ny nz oa ob bi translated">按频率降序排列<code class="fe mp mq mr ms b">char_counts</code>，并将其存储为优先级队列<em class="mc"> Q </em>。</li><li id="3a5a" class="nt nu it kk b kl oc ko od kr oe kv of kz og ld ny nz oa ob bi translated">循环通过<em class="mc"> Q </em>弹出频率最低的两个字符，并将其指定为左右节点，然后将两个子节点的频率相加，并将该值指定为父节点。</li><li id="0284" class="nt nu it kk b kl oc ko od kr oe kv of kz og ld ny nz oa ob bi translated">将父节点作为包含树和父节点值的元组附加到<em class="mc"> Q. </em></li></ol><p id="9292" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数返回构建树的<em class="mc">树</em>。对于我们输入的文本“最小值”，返回的结果将是:<code class="fe mp mq mr ms b">Tree(left=Tree(left='m', right=Tree(left=Tree(left='u', right='n'), right='i'))</code>。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="032f" class="md lg it ms b gy nb nc l nd ne">def _build_tree(self):<br/>   # Get count of unique characters in chars<br/>   char_counts = dict(Counter(self.chars))<br/>   # Initiate priority queue Q of unique characters<br/>   # and sort by descending order of frequencies<br/>   Q = sorted(char_counts.items(), key=lambda x: x[1], reverse=True)<br/>  <br/>   while len(Q) &gt; 1:<br/>      # Get minimum value of Q to be assigned as left node<br/>      node_l, freq_l = Q.pop()<br/>      # Get next minimum value of Q to be assigned as right node<br/>      node_r, freq_r = Q.pop()<br/>      # Build tree with left and right nodes<br/>      parent_node = Tree(left=node_l, right=node_r)<br/>      # Sum frequencies of both returned values and assign to tree<br/>      parent_node_freq = freq_l + freq_r<br/>      # Add parent node to tree<br/>      Q.append((parent_node, parent_node_freq))<br/>      Q = sorted(Q, key=lambda x: x[1], reverse=True)</span><span id="53b3" class="md lg it ms b gy nf nc l nd ne">   return Q[0][0]</span></pre><h2 id="0d04" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">三。将霍夫曼编码分配给树</h2><p id="36aa" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">构建树之后，最后一步是分配编码。该算法将0赋给左边缘，1赋给右边缘，因此我们将编写一个名为<code class="fe mp mq mr ms b">_assign_huffman_coding()</code>的函数来完成这个任务，该函数有两个参数:<code class="fe mp mq mr ms b">node</code>和<code class="fe mp mq mr ms b">encoding</code>。</p><p id="a437" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数将递归调用自身，直到树中的所有节点都被编码。因此，第一步是定义基本情况，其中输入是单个节点。然后，我们将递归调用该函数来构建左右分支，直到它到达基本情况(只剩下一个节点)。该函数返回一个字典，将节点作为键，将编码作为值。</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="f073" class="md lg it ms b gy nb nc l nd ne">def _assign_huffman_coding(self, node, encoding=''):<br/>   # Case when node is a single node<br/>   if type(node) == str:<br/>      return {node: encoding}<br/>   huffman_dict = {}<br/>   (node_l, node_r) = node.children()<br/>   # Recursively build left branch <br/>   huffman_dict.update(self._assign_huffman_coding(node=node_l, encoding=encoding + '0'))<br/>   # Recursively build right branch <br/>   huffman_dict.update(self._assign_huffman_coding(node=node_r, encoding=encoding + '1'))<br/>  <br/>   return huffman_dict</span></pre><h1 id="979f" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">结果</h1><p id="996c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">对于单词“minimum ”,产生的编码树如下所示。编码由边缘的红色文本表示。</p><figure class="mt mu mv mw gt nh gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi no"><img src="../Images/08c68b98615e22ab3648282a70d3723a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mZwVEAxHNxzu17JJafn3tA.png"/></div></div><p class="nk nl gj gh gi nm nn bd b be z dk translated">单词“最小值”的霍夫曼树</p></figure><p id="9de0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要提取每个唯一字符的压缩代码，只需沿着从根节点到叶节点的边。例如，“m”的编码是<code class="fe mp mq mr ms b">0</code>,“u”的编码是<code class="fe mp mq mr ms b">100</code>。下表显示了单词“minimum”中每个独特字符的频率、编码和大小:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="ba71" class="md lg it ms b gy nb nc l nd ne">--------------------------------------------------<br/>|  Character | Frequency |  Encoding |    Size   |<br/>--------------------------------------------------<br/>|      m     |     3     |     0     | 3 x 1 = 3 |<br/>--------------------------------------------------<br/>|      i     |     2     |    11     | 2 x 2 = 4 |<br/>--------------------------------------------------<br/>|      u     |     1     |    100    | 1 x 3 = 3 |<br/>--------------------------------------------------<br/>|      n     |     1     |    101    | 1 x 3 = 3 |<br/>--------------------------------------------------<br/>| 4x8=32bits |   7 bits  |           |  13 bits  |<br/>--------------------------------------------------</span></pre><p id="48d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个字符的大小是8位，所以在没有压缩的情况下，单词“minimum”的大小将是7个字符x 8位= 56位。利用霍夫曼编码算法，我们能够将字的大小减少到32位(4个字符×每个字符8位)+ 7位(频率之和)+ 13位(频率之和×每个字符的深度)= 52位。我们设法将单词“minimum”的大小减少了4位——想象一下这对于一个段落或一个文档会是什么样子！</p><h2 id="5e3f" class="md lg it bd lh me mf dn ll mg mh dp lp kr mi mj lr kv mk ml lt kz mm mn lv mo bi translated">结论</h2><p id="7331" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Huffman编码算法用于文本压缩，它是一个有趣而实用的例子，用来说明以前在这个算法解释系列中涉及的概念，从贪婪算法到树遍历。实现霍夫曼编码算法有三个步骤:I)创建一个<em class="mc">树</em>数据类，II)从输入文本构建一个树，III)给树分配霍夫曼编码。</p><p id="a6a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要查看完整代码，请点击<a class="ae le" href="https://github.com/claudian37/DS_Portfolio/blob/master/huffman_code/huffman_code_script.py" rel="noopener ugc nofollow" target="_blank">此处</a>。更多文章参见本算法讲解系列:<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>、<a class="ae le" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>。</p></div></div>    
</body>
</html>