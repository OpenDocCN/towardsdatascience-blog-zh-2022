<html>
<head>
<title>Introduction to Simulation with SimPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SimPy 仿真简介</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/introduction-to-simulation-with-simpy-8d744c82dc80#2022-03-29">https://towardsdatascience.com/introduction-to-simulation-with-simpy-8d744c82dc80#2022-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">第三部分:排队系统方案的比较</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/088e2684ddcc5b0a7f95a8ebfc23b5c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bqi61Lw61MAYdxzl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@davidleveque?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·莱维克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是与使用<strong class="lb iu"> SimPy 框架的模拟技术应用相关的系列文章的第三篇。</strong></p><p id="917e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-simulation-with-simpy-b04c2ddf1900" rel="noopener">的第一篇文章</a>中，提供了关于离散事件模拟的基本概念和原理的概述。我们定义了模型、模拟技术、什么是<strong class="lb iu">离散事件模拟(DES) </strong>以及 SimPy 库的特征。我们描述了一些在模拟研究中使用的常见概率分布，以及我们如何生成模拟这种分布的数字序列。</p><p id="6ffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二篇<a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-simulation-with-simpy-322606d4ba0c" rel="noopener">文章</a>中，我们描述了<strong class="lb iu">排队系统</strong>(等待队列系统)的基本原理以及最常用于评估它们的性能指标。最后，我们用 SimPy 模拟了一个单服务台排队系统。</p><p id="2e08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将描述用于分类排队模型的肯德尔符号。此外，我们将模拟另一个等待系统，强调模拟技术的一个巨大优势:<strong class="lb iu">快速、经济地评估所研究系统的各种备选方案的能力。</strong></p><h1 id="de7f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">排队模型的肯德尔符号</strong></h1><p id="0384" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">英国数学家和统计学家大卫·乔治·肯德尔在 1953 年提出了一种对排队模型进行分类的符号。他用三个字母写成<strong class="lb iu"> <em class="ms"> A/S/c </em> </strong>，其中<strong class="lb iu"> A </strong>描述到达过程中的到达间隔时间，<strong class="lb iu"> S </strong>表示服务时间分布，<strong class="lb iu"> c </strong>表示服务人数。A 和 S 最常见的可以取的值是<strong class="lb iu"> <em class="ms"> M，D </em> </strong>或<strong class="lb iu"><em class="ms">G</em></strong>:<strong class="lb iu">M</strong>隐含一个指数(马尔可夫)分布；<strong class="lb iu"> D </strong>暗示确定性(非概率性)分布；<strong class="lb iu"> G </strong>暗示非指数概率分布。当然，<strong class="lb iu"> c </strong>是整数。</p><p id="66de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后来又增加了三个字母，这样现在的记法就有了下面的形式:<strong class="lb iu"> <em class="ms"> A/S/c/K/N/D </em> </strong>，其中<strong class="lb iu"> K </strong>是等候区的容量，<strong class="lb iu"> N </strong>是潜在顾客的人口数，<strong class="lb iu"> D </strong>是排队纪律。如果 K 被省略，等待区域被认为是无限的。如果省略 N，则假设调用人口为无穷大。如果省略 D，则假定队列规则为<strong class="lb iu"> FIFO </strong>(先进先出)。</p><p id="0434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些例子。</p><p id="692f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> M/M/1 </strong>:到达间隔时间呈指数分布，服务时间也呈指数分布，一个服务员，无限等待区，无限呼叫人口，先进先出原则。</p><p id="b3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> M/D/2/10/100/LIFO </strong>:到达间隔时间服从指数分布，服务时间服从确定性分布，两台相同的服务器，有限的排队长度(只有 10 个顾客可以等待)，有限的顾客数量(最多 100 个顾客可以到达系统)，排队规则为<strong class="lb iu"> LIFO </strong>(后进先出)。</p><p id="83ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">G/G/4///优先级</strong>:到达间隔时间非指数概率分布，服务时间非指数概率分布，4 个服务器，无限等待区，无限客户群，按照一个优先级条件服务部分客户。</p><h1 id="dfc4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">利用 SimPy 做管理决策</h1><p id="9b47" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用 SimPy 来模拟工厂中机器的故障及其相应的修复。管理层应该做出关于维修人员数量的决定，这将减少机器停止工作的时间，而不是雇佣额外的维修人员。</p><p id="dec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一名数据科学家受雇对当前的运行条件进行模拟研究，修理工的数量不断增加，为每一个备选方案指明某些性能指标，以量化其成本。</p><p id="d923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">她清楚地解释说,<strong class="lb iu">正在研究的系统是一个等待系统</strong>,其中<strong class="lb iu">机器是随机发生故障的客户</strong>,由<strong class="lb iu">服务器</strong> ( <strong class="lb iu">修理工</strong>)修理，他们花费<strong class="lb iu">随机的时间来修理它们。她发现每台机器平均每 10 分钟就出一次故障，机器故障间隔时间是指数级的。她还发现服务时间(以分钟为单位)并不遵循已知的概率分布，而是由下表表示:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/69adca89d94e95157e60046115f7494f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*aNwMK7NL1rcCSKBxcJRq5g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 1:机器维修时间及其相应的概率。图片作者。</p></figure><p id="093f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据肯德尔符号，它是一个 M/G/c 排队系统。</p><p id="c9e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">她编写了以下 Python 代码来获得所需的性能指标。</p><p id="74a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，她导入了 Pandas 库作为<em class="ms"> pd，</em> Numpy 作为<em class="ms"> np </em>，以及名为<em class="ms"> SimPy 的面向对象、基于流程的离散事件模拟框架。</em>她还导入了<em class="ms"> scipy.stats </em>模块，该模块包含了再现服从均匀和指数分布的随机数序列的方法。最后，她导入 matplotlib 作为<em class="ms"> plt </em>和 seaborn 作为<em class="ms"> sns </em>用于制图。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e6e5" class="mz lw it mv b gy na nb l nc nd">import pandas as pd<br/>import numpy  as np<br/>import simpy</span><span id="da34" class="mz lw it mv b gy ne nb l nc nd">from scipy.stats import uniform<br/>from scipy.stats import expon</span><span id="4bfb" class="mz lw it mv b gy ne nb l nc nd">import matplotlib<br/>import matplotlib.pyplot as plt<br/>import matplotlib.animation as animation</span><span id="70f4" class="mz lw it mv b gy ne nb l nc nd">import seaborn as sns</span></pre><p id="50ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修理时间(<em class="ms"> time_service </em>)随机变量必须是离散的，并按如下方式产生:一个列表(<em class="ms"> list_of_minutes </em>)表示修理中不同的平均时间；四个变量(<em class="ms"> prob1，prob2 </em>，…)表示它们相应的离散概率(表 1)。她对这些变量求和并四舍五入，以获得四个连续子区间([0，0.1]；[0.1, 0.4];[0.4, 0.8];[0.8, 1.0]).每个子区间的最终值被传递给一个列表(<em class="ms"> list_of_probs </em>)，两个列表都被转换为数据帧。然后两个数据帧在<em class="ms"> df_service </em>中连接，另一个数据帧与从均匀分布获得的随机变量一起用于函数<em class="ms">修复</em>以确定修复时间值。</p><p id="0c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包括一个初始化模块，其中她指示用于模拟机器故障间隔时间的指数分布的参数值。她还初始化了模拟结束的时间，以及将用于存储中间结果的变量和列表。她还包括了计算修复时间随机变量的程序。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0615" class="mz lw it mv b gy na nb l nc nd"># Initialization module</span><span id="46a8" class="mz lw it mv b gy ne nb l nc nd">MACHINE_FAILURE_MEAN  = 10</span><span id="d651" class="mz lw it mv b gy ne nb l nc nd">## Times in repairing<br/>list_of_minutes = [15,30,40,50]</span><span id="91a9" class="mz lw it mv b gy ne nb l nc nd"># discrete probabilities for times in repairing<br/>prob1, prob2, prob3, prob4 = 0.1, 0.3, 0.4, 0.2</span><span id="f0ac" class="mz lw it mv b gy ne nb l nc nd">prob1 = round(prob1, 4)<br/>prob2 = round(prob1 + prob2,4)<br/>prob3 = round(prob2 + prob3,4)<br/>prob4 = round(prob3 + prob4,4)<br/>list_of_probs = [prob1, prob2, prob3, prob4]</span><span id="7161" class="mz lw it mv b gy ne nb l nc nd">df1 = pd.DataFrame(list_of_minutes, columns = ['minutes'])<br/>df2 = pd.DataFrame(list_of_probs,   columns = ['range'])<br/>df_service = pd.concat([df1, df2], axis = 1)</span><span id="28c7" class="mz lw it mv b gy ne nb l nc nd">SIM_TIME = 100</span><span id="673a" class="mz lw it mv b gy ne nb l nc nd">max_length, number_rows = 0, 0<br/>avg_length, avg_delay = [],[]<br/>avg_out_system, avg_in_service = [],[]</span></pre><p id="4837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-simulation-with-simpy-b04c2ddf1900" rel="noopener">记住</a>SimPy 为数据分析师提供主动组件:<strong class="lb iu">流程</strong>生成实体，如故障机器，以及被动组件:<strong class="lb iu">资源</strong>如维修人员。</p><p id="f163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分析师编写了一个生成器函数(<em class="ms"> machine_failure </em>)来模拟机器的随机故障，该函数调用另一个函数(<em class="ms"> repairing </em>),其中机器想要使用有限能力的资源(修理工)。<em class="ms"> yield env.timeout() </em>是一种离散事件，在经过一定的模拟时间后触发。方法<em class="ms"> request() </em>生成一个事件，该事件在资源再次变得可用时被触发(<em class="ms"> yield req </em>)。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b2ba" class="mz lw it mv b gy na nb l nc nd">def machine_failure(env, number_repair):</span><span id="fed4" class="mz lw it mv b gy ne nb l nc nd">   # counter of failures<br/>   failure_number = 0</span><span id="29a5" class="mz lw it mv b gy ne nb l nc nd">   while True:<br/>      ## exponential distribution for failures<br/>      next_failure = expon.rvs(scale = MACHINE_FAILURE_MEAN , <br/>                               size = 1)</span><span id="72c4" class="mz lw it mv b gy ne nb l nc nd">      # Wait for the failure<br/>      yield env.timeout(next_failure)<br/>      time_of_failure = env.now<br/>      failures.append(time_of_failure)<br/>      failure_number += 1<br/>      print('failure %3d occurs at %.2f' % <br/>             (failure_number, env.now))</span><span id="e502" class="mz lw it mv b gy ne nb l nc nd">      env.process(repairing(env, number_repair, <br/>                  failure_number, time_of_failure))</span><span id="3d2f" class="mz lw it mv b gy ne nb l nc nd">#...................................................................</span><span id="6af4" class="mz lw it mv b gy ne nb l nc nd">def repairing(env, number_repair, failure_number, time_of_failure):<br/>    with repair_persons.request() as req:<br/>         print('%3d enters the queue at %.2f' % <br/>                (failure_number, env.now)) <br/>         <br/>         queue_in = env.now<br/>         length   = len(repair_persons.queue)<br/>         tme_in_queue.append(queue_in)<br/>         len_in_queue.append(length)</span><span id="344a" class="mz lw it mv b gy ne nb l nc nd">         yield req<br/>         print('%3d leaves the queue at %.2f' % <br/>                (failure_number, env.now)) </span><span id="3ce0" class="mz lw it mv b gy ne nb l nc nd">         queue_out = env.now<br/>         length    = len(repair_persons.queue)<br/>         tme_in_queue.append(queue_out)<br/>         len_in_queue.append(length)</span><span id="9b57" class="mz lw it mv b gy ne nb l nc nd">         # random variate with uniform distribution<br/>         r_v = uniform.rvs(size=1)<br/>         print(r_v)</span><span id="d86b" class="mz lw it mv b gy ne nb l nc nd">         # setting the repair time<br/>         for i,row in df_service.iterrows():<br/>              probab = df_service.loc[i, 'range']<br/>              if r_v &lt; probab:<br/>                  time_service = df_service.loc[i, 'minutes']<br/>                   break</span><span id="633f" class="mz lw it mv b gy ne nb l nc nd">         yield env.timeout(time_service)%<br/>         print('%3d stays at service %.2f' %<br/>                (failure_number,time_service))</span><span id="fd19" class="mz lw it mv b gy ne nb l nc nd">         time_repaired = env.now<br/>         repaired.append(time_repaired)</span><span id="0b01" class="mz lw it mv b gy ne nb l nc nd">         time_out_system = time_repaired - time_of_failure<br/>         out_system.append(time_out_system)</span><span id="ac00" class="mz lw it mv b gy ne nb l nc nd">         time_in_queue = queue_out - queue_in<br/>         in_queue.append(time_in_queue)</span><span id="8b11" class="mz lw it mv b gy ne nb l nc nd">         time_in_service = time_service<br/>         in_service.append(time_in_service)</span></pre><p id="9e67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，她编写了用于计算队列中的平均延迟、队列中机器的平均数量、机器离开系统的平均时间以及机器被修复的平均时间的函数。</p><p id="1528" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个备选方案都包括一个动画，显示等待维修的机器数量的变化。动画是使用 matplotlib 和 T2 seaborn 库开发的。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b307" class="mz lw it mv b gy na nb l nc nd">#...................................................................def avg_line(df_length):<br/>    ## finds the time weighted average of the queue length</span><span id="b6f0" class="mz lw it mv b gy ne nb l nc nd">    # use the next row to figure out how long the queue <br/>      was at that length</span><span id="9279" class="mz lw it mv b gy ne nb l nc nd">    df_length['delta_time'] = df_length['time'].shift(-1) -    df_length['time']</span><span id="9142" class="mz lw it mv b gy ne nb l nc nd">   # drop the last row because it would have an infinite time span<br/>   df_length = df_length[0:-1]</span><span id="0461" class="mz lw it mv b gy ne nb l nc nd">   avg =np.average(df_length['len'],weights=df_length['delta_time'])</span><span id="570c" class="mz lw it mv b gy ne nb l nc nd">   return avg</span><span id="258e" class="mz lw it mv b gy ne nb l nc nd">#...................................................................def calc_averages():</span><span id="338f" class="mz lw it mv b gy ne nb l nc nd">    df3 = pd.DataFrame(tme_in_queue, columns = ['time'])<br/>    df4 = pd.DataFrame(len_in_queue, columns = ['len'])<br/>    df_length = pd.concat([df3, df4], axis = 1)</span><span id="12cf" class="mz lw it mv b gy ne nb l nc nd">    # calculate the y lim for the number of machines in queue chart <br/>    max_length  = df4['len'].max(axis = 0)</span><span id="0b09" class="mz lw it mv b gy ne nb l nc nd">    # calculate the number of frames in the animation<br/>    number_rows = len(df4)</span><span id="3a39" class="mz lw it mv b gy ne nb l nc nd">    avg_length.insert(altern, avg_line(df_length))     <br/>    avg_delay.insert(altern,  np.mean(in_queue))</span><span id="4130" class="mz lw it mv b gy ne nb l nc nd">    avg_out_system.insert(altern, np.mean(out_system))<br/>    avg_in_service.insert(altern, np.mean(in_service))</span><span id="4fcb" class="mz lw it mv b gy ne nb l nc nd">    print('Alternative number: %1d' %(altern+1))<br/>    print('The average delay in queue is %.2f'  % <br/>           (avg_delay[altern]))</span><span id="e043" class="mz lw it mv b gy ne nb l nc nd">    print('The average number of machines in queue is %.2f' % <br/>           (avg_length[altern]))</span><span id="8796" class="mz lw it mv b gy ne nb l nc nd">    print('The average time machines out of system is %.2f' % <br/>            (avg_out_system[altern]))</span><span id="f81a" class="mz lw it mv b gy ne nb l nc nd">    print('The average time machines were being repaired is %.2f'<br/>            %(avg_in_service[altern]))</span><span id="1dc9" class="mz lw it mv b gy ne nb l nc nd">   #.............................................................<br/>    Writer = animation.FFMpegWriter(fps=2,<br/>                    metadata=dict(artist='Me'), bitrate=1800)</span><span id="b2f2" class="mz lw it mv b gy ne nb l nc nd">    fig = plt.figure(figsize=(10,6))<br/>    ax  = fig.gca()<br/>    plt.xlim(0, 100)<br/>    plt.ylim(0, max_length + 1)<br/>    ax.yaxis.get_major_locator().set_params(integer=True)<br/>    plt.title(' Number of Machines in Queue for Alternative %i'  <br/>                %NUMBER_REPAIR_PERSONS,fontsize=20)</span><span id="c210" class="mz lw it mv b gy ne nb l nc nd">    def animate(i):<br/>        data = df_length.iloc[:int(i+1)] #select data range<br/>        p = sns.scatterplot(x = data["time"], y = data["len"],<br/>                            marker = '*', s = 100, color="r")<br/>        p.set(xlabel='Time', ylabel='Number of Machines') <br/>        p.tick_params(labelsize=17)<br/>        plt.setp(p.lines,linewidth=4)</span><span id="92bc" class="mz lw it mv b gy ne nb l nc nd">    ani = matplotlib.animation.FuncAnimation(fig, animate, <br/>                     frames= number_rows,interval = 50, repeat=True)</span><span id="96bd" class="mz lw it mv b gy ne nb l nc nd">    altern_chart = 'machines_in_queue_alt %i.mp4' <br/>                   %NUMBER_REPAIR_PERSONS</span><span id="72b4" class="mz lw it mv b gy ne nb l nc nd">    ani.save(your_path + altern_chart,  writer = Writer)  <br/>    plt.show()</span></pre><p id="df97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟算法的中央核心包括一个<em class="ms">环境()</em>的实例，因为<strong class="lb iu">所有 SimPy 进程都生活在一个环境中。</strong></p><p id="7e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，她选择了一个种子值(<em class="ms"> 1234 </em>)，因此随机数生成器可以启动序列来生成模拟均匀分布和指数分布的数字流。她决定<strong class="lb iu">评估五个备选方案</strong> (Alt1: 1 修理工；Alt2: 2 名修理工；Alt3: 3 名修理工；Alt4: 4 名修理工；Alt 5: 5 修理工)。该代码为每个备选方案计算 4 个性能指标，并绘制相应的动画。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="213a" class="mz lw it mv b gy na nb l nc nd">RANDOM_SEEDS = [1234, 5678, 9012, 3456, 7890]<br/>np.random.seed(seed= RANDOM_SEEDS[1])</span><span id="8205" class="mz lw it mv b gy ne nb l nc nd">for altern in range(5):<br/>    failures, repaired    = [],[]<br/>    in_queue, in_service  = [],[]<br/>    out_system = []<br/>    tme_in_queue, len_in_queue = [],[]</span><span id="d469" class="mz lw it mv b gy ne nb l nc nd">    env = simpy.Environment() </span><span id="2466" class="mz lw it mv b gy ne nb l nc nd">    NUMBER_REPAIR_PERSONS = altern + 1</span><span id="d574" class="mz lw it mv b gy ne nb l nc nd">    repair_persons = simpy.Resource(env, <br/>                           capacity = NUMBER_REPAIR_PERSONS)</span><span id="f0c8" class="mz lw it mv b gy ne nb l nc nd">     env.process(machine_failure(env, repair_persons))<br/>     env.run(until = SIM_TIME)</span><span id="3844" class="mz lw it mv b gy ne nb l nc nd">     calc_averages()</span></pre><p id="e882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，一个表格恢复了性能的措施，以量化其相应的成本。</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="8f88" class="mz lw it mv b gy na nb l nc nd">##..................................................................def print_averages():</span><span id="38e0" class="mz lw it mv b gy ne nb l nc nd">    round_avg_delay  = [round(num, 2) for num in avg_delay]<br/>    round_avg_length = [round(num, 2) for num in avg_length]<br/>    round_avg_out_system = [round(num, 2) for num in avg_out_system]  <br/>    round_avg_in_service = [round(num, 2) for num in avg_in_service]</span><span id="57c4" class="mz lw it mv b gy ne nb l nc nd">    listoflists = []<br/>    listoflists.append(round_avg_delay)<br/>    listoflists.append(round_avg_length)<br/>    listoflists.append(round_avg_out_system)<br/>    listoflists.append(round_avg_in_service)</span><span id="3dbb" class="mz lw it mv b gy ne nb l nc nd">   fig, ax = plt.subplots(1,1)<br/>   column_labels = [" Alt. 1", " Alt. 2", " Alt. 3", <br/>                    " Alt. 4", " Alt. 5"]<br/>   row_labels = ["Avg. delay in queue", <br/>                 "Avg. number of machines in queue",<br/>                 "Avg. time machines out of system", <br/>                 "Avg. time in repair"]</span><span id="4360" class="mz lw it mv b gy ne nb l nc nd">   df=pd.DataFrame(listoflists, columns=column_labels)  <br/> <br/>   ax.axis('tight')<br/>   ax.axis('off')<br/>   ax.table(cellText = df.values, <br/>              colLabels=df.columns, rowLabels=row_labels,<br/>              rowColours =["skyblue"]*4, <br/>              colColours =["cyan"]*5, loc="center")<br/>   ax.set_title("Measures of Performance", fontsize=18, <br/>                 y= 0.8 , pad = 4)</span><span id="a53c" class="mz lw it mv b gy ne nb l nc nd">   plt.savefig(your_path +'perf_measures.png',<br/>               bbox_inches='tight', dpi=150)</span><span id="b080" class="mz lw it mv b gy ne nb l nc nd">   plt.show()</span></pre><h1 id="9961" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">分析</strong></h1><p id="e8a9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面的屏幕截图显示了第三个备选项(3 个修理工)的种子值为 1234 的一次模拟运行后的绩效评估值:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6fa6580fb1414e7f0b212a49a7191d65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*OYKQ0t7k3D5YyPSmEB5-tA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="6cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图显示了同一替代方案中等待维修的机器数量的变化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/56e17b83414fd5891561ddb63198dfd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIvFoqPAwuE3wlSDatOXzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者用 Matplotlib 制作的图</p></figure><p id="cb22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，表 2 恢复了每个备选方案的性能指标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/c93c85025545f9c383c236ceb136376a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*77uxaB9hp9vgb20jysrdYQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 2:种子值为 1234 的性能测量。图片作者。</p></figure><p id="9bec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看来，管理层应该选择雇佣两名修理工(备选方案 2)作为最佳解决方案。</p><p id="6593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">但是这个模拟研究有两个严重的缺点:</strong></p><p id="a361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)选择 100 作为最终模拟时间完全是任意的。然而，模拟运行的长度根据要研究的系统类型和要量化的性能测量而变化。</p><p id="8935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)获得的结果很大程度上依赖于模拟运行中使用的随机数序列。如果我们更改种子值并使用 RANDOM_SEEDS 列表的第二个元素(5678)，我们将获得以下汇总表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/af6c6cbb0ac2ea67cffb389f070df268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*HE0zQ_oyIpTaroWegAwncQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">表 3:种子值为 5678 的性能测量。图片作者。</p></figure><p id="1b32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只改变了种子值，一些性能指标的估计值发生了显著的变化。其原因是它们是随机变量的特殊实现，可能具有<strong class="lb iu">较大的方差</strong>。</p><p id="c0c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在下面的文章中指出解决这些严重缺陷的方法。</p></div></div>    
</body>
</html>