<html>
<head>
<title>Outlier Detection Techniques in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的离群点检测技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/outlier-detection-techniques-in-python-1fabf8e68bec#2022-05-18">https://towardsdatascience.com/outlier-detection-techniques-in-python-1fabf8e68bec#2022-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d68" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中带有示例的异常值检测方法指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/52ee0e4a147983a5cca58d8a2c0f2467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RdoBLuCACX8p3Wlpw_QE1w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.pexels.com/@sebastian/" rel="noopener ugc nofollow" target="_blank">塞巴斯蒂安·沃特曼</a>在<a class="ae ky" href="https://www.pexels.com/photo/black-wooden-king-chess-piece-411195/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="7a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">离群点检测是识别数据中极值的过程，在金融、保险、网络安全和医疗保健等各行各业都有许多应用。例如，在金融领域，它可以检测像信用卡欺诈这样的恶意事件。在保险业，它可以识别伪造或编造的文件。在网络安全中，它用于识别密码盗窃和网络钓鱼等恶意行为。最后，异常值检测已经被用于医疗环境中的罕见疾病检测。</p><p id="e23c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于异常值检测在各行各业都有许多重要的应用，在这些领域工作的数据科学家需要对进行此类分析的最新方法和工具有一个扎实的了解。</p><p id="e1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">离群点检测有许多方法，每种方法都有自己的优点。广泛用于离群点检测的两种方法是描述性统计和聚类。描述性统计是一种使用汇总统计对数据集中的特征进行定量描述的方法。这包括平均值、方差、最大值和最小值等计算。这还包括箱线图、直方图和散点图等图形表示。相反，聚类技术是一组无监督的机器学习算法，将数据集中的对象分组在一起，以便相似的对象在同一组中。</p><p id="e9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用描述性统计检测异常值的一种常用方法是使用四分位数范围(iqr)。该方法通过分析落在四分位数指定范围内的点来工作，其中四分位数是数据的四个等分部分。虽然IQR适用于包含单一形状或图案的数据，但它无法区分数据集中不同类型的形状或数据点组。</p><p id="8e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，聚类技术通过有效地将样本分成不同的形状，解决了IQR的局限性。用于异常值检测的常用聚类方法是DBSCAN，它是一种无监督聚类方法，解决了IQR的许多限制。它通过识别组来工作，使得每个组的成员密集地聚集在一起，然后将离群值识别为落在任何密集聚集的聚类之外的数据点。与IQR不同，DBSCAN能够捕捉形状和大小不同的星团。</p><p id="3392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas中的分位数方法便于计算IQR。对于聚类方法，Python中的Scikit-learn库有一个易于使用的DBSCAN算法实现，可以很容易地从Scikit-learn中的clusters模块导入。这种易用性对于初学者来说尤其理想，因为Scikit-learn软件包允许用户使用默认算法，只需要数据科学家提供最少的规范。此外，每种算法的界面都允许用户轻松修改参数，以进行快速原型制作和测试。</p><p id="4fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<a class="ae ky" href="https://www.kaggle.com/datasets/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank">信用卡欺诈数据集</a>。我们将应用IQR和DBSCAN来检测这些数据中的异常值，并比较结果。这些数据拥有<a class="ae ky" href="https://opendatacommons.org/licenses/dbcl/1-0/" rel="noopener ugc nofollow" target="_blank">开放数据库许可证</a>，可以自由共享、修改和使用。</p><p id="29c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">读入数据</strong></p><p id="7780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从导入Pandas库开始，并将我们的数据读入Pandas数据框:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="a52f" class="ma mb it lw b gy mc md l me mf">df = pd.read_csv("creditcard.csv")</span></pre><p id="335e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们使用Pandas方法set_option()放宽列和行的显示限制:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4b77" class="ma mb it lw b gy mc md l me mf">pd.set_option('display.max_columns', None)<br/>pd.set_option('display.max_rows', None)</span></pre><p id="9d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示目的，我们将使用数据的缩减采样版本:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f50f" class="ma mb it lw b gy mc md l me mf">df = df.sample(30000, random_state=42)</span><span id="8e34" class="ma mb it lw b gy mg md l me mf">df.to_csv("creditcard_downsampled5000.csv", index=False)</span></pre><p id="d675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用head()方法显示前五行数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1aae" class="ma mb it lw b gy mc md l me mf">print(df.head())</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/765590a6dbf0806390dad2f9dd8ed614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M_y9LpOdfUl_3xHU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，数据集具有从V1到V28的列，这反映了使用对应于交易信息的特征生成的28个主要成分。由于客户保密，有关原始功能的信息不公开。</p><p id="031c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据还包含交易金额、类别(对应于欺诈结果:欺诈为1，否则为0)和时间，时间是数据集中每笔交易和第一笔交易之间的秒数。</p><p id="a1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">四分位距(IQR) </strong></p><p id="2c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iqr是一种分析数据中的点如何分布在数据的各个部分的有用方法。一般来说，这是测量数据分布的好方法。iqr是根据四分位数定义的，即四个等分的数据组。</p><ul class=""><li id="ae4f" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mn mo mp mq bi translated">第一个四分位数(Q1)对应于25%的数据低于该点的值。</li><li id="dd73" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">第二个四分位数(Q2)是数据列的中值。该列中50%的数据低于该值。</li><li id="76e6" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">第三个四分位数(Q3)是列中75%的数据低于该值的点。</li><li id="fd6e" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mn mo mp mq bi translated">IQR是第三个四分位数(Q3)和第一个四分位数(Q1)之间的差值。</li></ul><p id="76de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算完第一个和第三个四分位数后，计算IQR就简单了。我们只取第三和第一个四分位数之差(第三季度减去Q1)。一旦有了IQR，我们就可以用它来检测数据列中的异常值。</p><p id="f0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用IQR检测异常值被称为1.5倍IQR规则。使用这个规则，我们计算上限和下限，我们可以用它来检测异常值。上限被定义为第三个四分位数加上1.5倍的IQR。下限定义为第一个四分位数减去1.5倍IQR。</p><p id="a383" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的工作方式如下:</p><ol class=""><li id="5f58" class="mi mj it lb b lc ld lf lg li mk lm ml lq mm lu mw mo mp mq bi translated">计算上限:Q3 + 1.5 x IQR</li><li id="40a0" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mw mo mp mq bi translated">计算下限:Q1-1.5 x IQR</li><li id="e09d" class="mi mj it lb b lc mr lf ms li mt lm mu lq mv lu mw mo mp mq bi translated">通过移除任何小于下限或大于上限的值来计算异常值。</li></ol><p id="8f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们对数据中的V13列执行这个操作。首先，让我们创建一个V13列的箱线图。我选择V13是因为我们的箱线图中该数据列的IQR很容易看到。箱线图是直观显示数据列中IQR的有用方法。我们可以使用三行简单的代码来生成V13的箱线图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="669d" class="ma mb it lw b gy mc md l me mf">sns.set()</span><span id="126d" class="ma mb it lw b gy mg md l me mf">sns.boxplot(y = df['V14'])<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/559b532916d1e93aa6b41d331b831dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nz_EMmdk74cG2VYc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8b39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到，我们将大量的信息浓缩在一个图中。很可能，我们首先会注意到的是蓝框，它对应于IQR。在蓝框内，垂直黑线对应于中间值。蓝框的左边缘和右边缘分别对应于Q3和Q1。最左边和最右边的垂直黑线分别对应于上限和下限。最后，最左边和最右边的黑点对应异常值。我们可以使用上限和下限的值来移除异常值，然后通过生成另一个箱线图来确认它们已经被移除。</p><p id="9855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先让我们计算这个列的IQR，这意味着我们首先需要计算Q1和Q3。幸运的是，熊猫有一个简单的方法，叫做分位数，可以让我们这样做。为了计算Q1，我们调用quantile()方法，参数输入为0.25(代表第25个百分点):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d97e" class="ma mb it lw b gy mc md l me mf">Q1=df['V13'].quantile(0.25)<br/>print("Q1:", Q1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/f3d198bab5caeaf8fe33bc484dc77ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/0*yNlz7Z_RS6MPBSq3"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="184b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到第一个四分位数(Q1)是-0.64。这意味着V13列中只有25%的数据低于-0.64。</p><p id="33c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了计算Q3，我们调用quantile()方法，参数输入为0.75(代表第75个百分点):</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="de62" class="ma mb it lw b gy mc md l me mf">Q3=df['V13'].quantile(0.75)<br/>print("Q3:", Q3)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/41e3d0d36ee0d13f1aba88bfd388e60f.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/0*DtLcm4PNQdF-MXr7"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="413b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到第三个四分位数(Q3)是0.66。这意味着V13列中75%的数据低于0.66。</p><p id="71a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IQR就是Q3和Q1的差值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fc5d" class="ma mb it lw b gy mc md l me mf">IQR=Q3-Q1</span></pre><p id="371f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，我们可以定义一个新的Pandas系列，它包含没有异常值的V13值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3c69" class="ma mb it lw b gy mc md l me mf">IQR=Q3-Q1<br/>print("IQR: ", IQR)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi na"><img src="../Images/83731b27e13e33f63b4b252fc703e298.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/0*8hwxG16m-86oeVoz"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到IQR是1.3。这是Q3和Q1之间的距离。</p><p id="2837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，我们可以计算上下界。下限是Q1-1.5倍IQR:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="b301" class="ma mb it lw b gy mc md l me mf">lower_bound = Q1 - 1.5*IQR<br/>print("Lower Bound:", lower_bound)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/db084be7efe6f9af2748b4f328e7c53f.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/0*1O14of6jgTxvbFu-"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="59ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到下界是-2.61。因此，任何低于-2.61的值都是异常值。</p><p id="d805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上限是Q3 + 1.5倍IQR:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="f0df" class="ma mb it lw b gy mc md l me mf">upper_bound = Q3 + 1.5*IQR<br/>print("Upper Bound:", upper_bound)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0e7a3c4808b80754306daced6b9cb428.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/0*BivVXbAOyHx2tL34"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d39b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到上限是2.62。因此，任何高于2.62的值都是异常值。</p><p id="ff93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们移除该列异常值的方法是移除高于2.62和低于-2.61的任何值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="03d1" class="ma mb it lw b gy mc md l me mf">df_clean = df[(df['V13']&gt;lower_bound)&amp;(df['V13']&lt;upper_bound)]</span></pre><p id="9136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以绘制清理后的数据:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fd5d" class="ma mb it lw b gy mc md l me mf">sns.boxplot(y = df_clean['V13'])<br/>plt.show()</span></pre><p id="9789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到上下边界之外的点已经被移除</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/e66a559472319fc6bc2c75cf987134cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AlQo0aBlj3ddKmsK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这种方法对于删除单个列中的异常值很有用，但它有一些明显的局限性。最大的限制是无法捕捉数据中的不同形状。例如，列中的某个点在一维箱线图中可能不是异常值，但在二维散点图中可能是异常值。</p><p id="30bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这一点，考虑一下美国的中值收入:在撰写本文时，它是44，225美元。尽管这一数值属于美国所有收入的IQR，但如果我们考虑其他因素，它可能会被视为异常值。例如，44，225美元对于已经执业10年的美国医生来说可能是一个异常收入。为了在我们的数据中捕捉不同的形状来描述这种情况，聚类是一种更好的方法。</p><p id="7255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据库扫描</strong></p><p id="2de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DBSCAN代表基于密度的带噪声应用空间聚类，是一种无监督聚类算法。。该算法通过寻找聚类来工作，使得每个聚类中的点密集/紧密地包装在一起。密度基于聚类中每个数据点附近有多少邻近点。附近的邻居越多，集群密度越高。这种方法将松散聚集的点或单独位于密集聚集的聚类之外的点识别为离群点。</p><p id="cb26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用DBSCAN来识别我们一直在处理的数据中的异常值。首先，让我们可视化一些集群，以了解算法是如何工作的。让我们绘制一个V13与V14的散点图:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="56cf" class="ma mb it lw b gy mc md l me mf">sns.scatterplot(df['V13'], df['V14'])</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/0c1f8ff3d6f21cbbc44e272a09dae54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qvF8pe1bXSXRAf7g"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c91c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，我们有一个非常密集的集群，有许多远离集群的离群点。有趣的是，这个二维空间中的一些异常点会落入V13的IQR，并错误地留在数据中。观察图中V13接近于0的点和V14接近于-20的点。V13的值很好，而V14的值是异常值。这使得这些点成为异常值。</p><p id="c334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们可以从V13和V14中删除离群值来补救这一点，但是对每一列都这样做是很费力的，尤其是如果您正在处理几十个特性的话。</p><p id="71f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何使用聚类来做得比IQR方法更好。让我们从Scikit-learn导入DBSCAN算法:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8db9" class="ma mb it lw b gy mc md l me mf">from sklearn.cluster import DBSCAN</span></pre><p id="7289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义我们的训练数据。让我们考虑第13列和第14列:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="950b" class="ma mb it lw b gy mc md l me mf">X_train = df[['V13', 'V14']]</span></pre><p id="beaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将我们的聚类方法用于训练数据。为了简单起见，让我们通过将输入参数留空来保持默认值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="30fa" class="ma mb it lw b gy mc md l me mf">model = DBSCAN()</span><span id="e7fd" class="ma mb it lw b gy mg md l me mf">model.fit(X_train)</span></pre><p id="7299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们生成一个散点图，在这里我们将标记异常值:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3e61" class="ma mb it lw b gy mc md l me mf">cluster_labels = model.labels_<br/>plt.scatter(df["V13"], df["V14"], c = cluster_labels)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/6db5e45f4d1ffc6284a499670312883e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tv2z1JuK7FutrJ2_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到，该算法在标记异常值方面做得很好，甚至是IQR方法可能会遗漏的异常值。散点图中的黑点对应于V13/V14 2D异常值，而红点是良好的数据点。</p><p id="2a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以根据这些聚类标签轻松地移除这些异常值。让我们将分类标签存储在数据框的新列中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6ffc" class="ma mb it lw b gy mc md l me mf">df['labels'] = cluster_labels</span></pre><p id="18d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来让我们移除离群值。Scikit-learn的DBSCAN实现将聚类标签值-1分配给有噪声的样本(异常值)。我们可以轻松地删除这些值，并将清除的数据存储在一个新变量中:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="116a" class="ma mb it lw b gy mc md l me mf">df_cluster_clean = df[df['labels'] != -1]</span></pre><p id="29f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们绘制清理后的数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/75152acabdfefd5364ad718f82ff20a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b1Uiv1pkkE9mz7Ig"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到原始数据中不再有异常点。最重要的是，IQR方法在我们只研究V13时遗漏的异常值也被剔除了。</p><p id="48b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，我们只考虑了二维的异常值。三维以上的可视化变得越来越困难。尽管如此，像DBSCAN这样的方法能够检测出数据中的异常值，这些数据包含的维度比我们能够可视化或解释的维度多得多，这是一个好消息。当涉及到高维空间中的离群点检测时，聚类确实是一种优越的方法。</p><p id="24be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中的代码可以在<a class="ae ky" href="https://github.com/spierre91/builtiin/blob/main/outlier_detectionpt2.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="5159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="485f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">离群点检测和剔除是数据科学和机器学习的重要组成部分。数据中的异常值可能会对数据中的统计数据的解释产生负面影响，如果公司根据这些错误的计算做出决策，可能会损失数百万美元。此外，离群值会对机器学习模型性能产生负面影响，这会导致样本外性能不佳。糟糕的机器学习模型性能是许多公司的一大担忧，因为这些预测被用来推动公司决策。因此，任何数据科学团队都应该熟悉异常值检测和剔除的可用方法。</p><p id="376f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在考虑选择哪种方法时，数据科学家应该对手头的数据有很好的理解。如果公司数据很简单，包含的列很少，IQR应该工作得很好。如果数据包含许多列，很可能数据中存在IQR无法捕获的形状和图案。正因如此，在考虑高维空间的离群点剔除任务时，像DBSCAN这样的聚类方法是很好的选择。</p><p id="f0ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有兴趣学习python编程的基础知识、Pandas的数据操作和python中的机器学习，请查看<a class="ae ky" href="https://www.amazon.com/dp/B08N38XW2Q/" rel="noopener ugc nofollow" target="_blank"><em class="ng">Python for Data Science and Machine Learning:Python编程、Pandas和sci kit-初学者学习教程</em> </a> <em class="ng">。我希望你觉得这篇文章有用/有趣。</em></p><p id="35d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="ng">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/data-science/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="ng">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="ng">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/data-science/how-find-outliers-examples" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="ng"/></strong></a><strong class="lb iu"><em class="ng">。</em> </strong></p></div></div>    
</body>
</html>