<html>
<head>
<title>Feature Selection with Simulated Annealing in Python, Clearly Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中模拟退火的特征选择，解释清楚</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/feature-selection-with-simulated-annealing-in-python-clearly-explained-1808db14f8fa#2022-08-09">https://towardsdatascience.com/feature-selection-with-simulated-annealing-in-python-clearly-explained-1808db14f8fa#2022-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="68e8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为机器学习选择最佳特征的全局搜索算法的概念和实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4717fa5230c3dfd123618c8afac1ba05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UzvJHc7Ldln-ayoCx9XPQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰尼斯W在<a class="ae ky" href="https://unsplash.com/s/photos/hot-glass?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0b4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征选择在机器学习中至关重要，因为它通过只保留最相关的预测器来提高计算效率和预测性能。</p><p id="7b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了过滤器和包装器方法等流行的特征选择类之外，模拟退火等全局搜索方法是我们可以使用的强大技术。</p><p id="2e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的一步一步的指南深入研究了模拟退火特性选择的理论和应用。</p><h2 id="227d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">内容</h2><blockquote class="mo mp mq"><p id="0a40" class="kz la mr lb b lc ld ju le lf lg jx lh ms lj lk ll mt ln lo lp mu lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it"> 1) </em> </strong> <a class="ae ky" href="#357f" rel="noopener ugc nofollow"> <em class="it">什么是退火？</em></a><em class="it"><br/></em><strong class="lb iu"><em class="it">2)</em></strong><a class="ae ky" href="#216d" rel="noopener ugc nofollow"><em class="it">门外汉对模拟退火的解释</em></a><em class="it"><br/></em><strong class="lb iu"><em class="it">3)</em></strong><em class="it"/><a class="ae ky" href="#1120" rel="noopener ugc nofollow"><em class="it">利弊</em><strong class="lb iu"><em class="it"/></strong><em class="it">对模拟退火进行特征选择</em> </a> <em class="it"> <br/> </em></p></blockquote><p id="6a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这里 找到这个项目<a class="ae ky" href="https://github.com/kennethleungty/Simulated-Annealing-Feature-Selection" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">的GitHub回购。</strong></a></p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="357f" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(1)什么是退火？</h1><p id="2a8d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">术语“退火”来自材料科学领域。这是一个过程，其中金属或玻璃等材料被加热并保持在高温，然后以受控方式缓慢冷却。</p><p id="56f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">退火的目的是将有利的<strong class="lb iu">物理特性</strong>(例如延展性)引入材料，以便更顺利地进行下游制造。</p><p id="894e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">热量导致材料中原子的随机重排，这消除了内部的弱连接和残余应力。</p><p id="0e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后的冷却使材料凝固，并确保所需的物理性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/444d8a8b0be2eb2de2aa62eef8945ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q2PMUK1Mloi8Xxqx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克莱门特·菲利普在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="216d" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(2)模拟退火的外行解释</h1><p id="bb24" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">那么这个看似不相关的物理退火是如何与特征选择联系起来的呢？你会惊奇地发现模拟退火是一种模仿退火工作方式的全局搜索方法。</p><p id="fc08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在特征选择的上下文中，模拟退火在许多可能的子集组合中找到给出最佳预测模型性能<strong class="lb iu">的</strong> <strong class="lb iu">特征</strong>的<strong class="lb iu">子集</strong>。</p><p id="c8be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种想法就像物理退火旨在为材料产生高性能的物理特性。</p><p id="95d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了想象模拟退火与物理退火的关系，我们可以想象以下比较:</p><ul class=""><li id="2c88" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">一个物质粒子→一个特征</li><li id="f3fa" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">材料本身→全套功能</li><li id="2243" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">粒子排列的当前状态→选定的特征子集</li><li id="c0e9" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">材料物理特性的变化→模型性能的变化</li></ul><p id="d3a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟退火中重复的“加热”和“冷却”阶段有助于我们找到最佳的全局特征子集。</p><p id="9d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是加热和冷却阶段在算法中的含义:</p><ul class=""><li id="2531" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><strong class="lb iu">加热</strong>:随机改变特征子集，评估模型性能的变化，并设置接受较差性能子集而非较好子集的高概率。这个阶段被认为是'<strong class="lb iu">勘探</strong>'。</li><li id="87ca" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><strong class="lb iu">降温</strong>:逐渐降低保留不良子集的概率，使高性能子集保留的可能性越来越大。这个阶段被认为是'<strong class="lb iu">开采</strong>'。</li></ul><p id="60da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本原理是初始加热让算法自由地<strong class="lb iu">探索</strong>搜索空间。随着冷却开始，算法被激励去利用T21，并聚焦于全局最佳特征子集。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="1120" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated"><em class="oh"> (3)用于特征选择的模拟退火的利弊</em></h1><h2 id="1dcf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">赞成的意见</h2><p id="8a1b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在三种常见的特征选择类(即内在、过滤器、包装器)中，包装器方法非常流行，因为它们比其他两种方法搜索更广泛的特征子集。然而，缺点是这些包装器方法是<strong class="lb iu">贪婪的</strong>方法。</p><p id="ed04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贪婪的方法选择搜索路径，以可能的长期收益为代价，追求每一步的<strong class="lb iu">最佳</strong>即时收益。结果是搜索可能陷入局部最优。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/1c6148ba635938d9c6b8a83ab4d32f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OfwWeCioTWpj5ZsPkqElBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:Extrema_example.svg" rel="noopener ugc nofollow" target="_blank">维基共享许可</a>下使用的全球和本地最小|图像插图</p></figure><p id="b362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，模拟退火是一种概率全局优化方法，采用由算法中赋予的随机性驱动的<strong class="lb iu">非贪婪</strong>方法。</p><p id="7d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非贪婪方法可以重新评估以前的子集，如果从长远来看似乎有潜在的好处，则朝着最初不利的方向前进。</p><p id="87fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，模拟退火具有更强的能力来摆脱局部最优并找到特征的全局最佳子集。</p><p id="1a8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它的非贪婪本质创造了捕获关键特征交互的更高概率，特别是如果这些交互只有在特征在子集中同时出现时才是重要的。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="d5f4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">骗局</h2><p id="d8cd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">一个缺点是模拟退火是计算密集型的，你将在后面的算法细节中看到。</p><p id="7d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，最好首先利用领域知识来缩小整个特性集的范围。对于较小的特征集，使用模拟退火进行进一步的特征选择变得更加有效。</p><p id="77c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个缺点是有许多算法参数需要调整，这可能是一个挑战。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="2000" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated"><strong class="ak"> (4)算法细节</strong></h1><p id="d20d" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated"><em class="mr">注:您可以参考本</em><a class="ae ky" href="https://github.com/kennethleungty/Simulated-Annealing-Feature-Selection" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="mr">GitHub repo</em></strong></a><em class="mr">中该演示的代码和数据。</em></p><h2 id="8bc9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">(一)概述</h2><p id="43b0" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">为了让算法更容易理解，我们把它一步步分解，并配以实例。</p><p id="f749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将算法情境化，我们将在<a class="ae ky" href="https://www.kaggle.com/competitions/titanic" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">【泰坦尼克】</strong> </a> <strong class="lb iu"> </strong>数据集上使用<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" rel="noopener ugc nofollow" target="_blank">随机森林</a>模型构建一个<strong class="lb iu">二元分类器</strong>(以预测乘客存活率)并将<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.roc_auc_score.html" rel="noopener ugc nofollow" target="_blank"> ROC-AUC分数</a>作为性能度量。</p><p id="5981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预处理后的训练数据共有<strong class="lb iu">九个</strong>预测器特征和一个<strong class="lb iu"> </strong>二元目标变量(<code class="fe oj ok ol om b"><strong class="lb iu">Survived</strong></code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/b8579f260b05114d7fbee070568cfc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4rgNM-HvkZ02XWYJiWYLEA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预处理过的泰坦尼克号数据集样本|作者提供的图片</p></figure></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="853c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤1 — </strong>生成特征的随机初始子集，以形成当前状态。这个步骤可以通过随机选择50%的原始特征来任意完成。</p><p id="669a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们最初的四个特征的<strong class="lb iu">随机</strong>子集是<code class="fe oj ok ol om b"><strong class="lb iu">Pclass</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Age</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Parch</strong></code>和<code class="fe oj ok ol om b"><strong class="lb iu">Title</strong></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/1de4fcd8aefe590dfe674c803c709449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5fzbv7i8qraVIwj7AWZLKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">绿框所示的初始特征子集|作者图片</p></figure><p id="5a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤2 — </strong>指定要运行的<strong class="lb iu">迭代</strong>的最大次数。这个数字是一个可调参数，但是为了简单起见，我们可以从一个整数(例如50)开始。</p><p id="32c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤3 — </strong>评估当前子集的模型性能，以获得初始性能指标。对于这种情况，我们在过滤到当前4特征子集(<code class="fe oj ok ol om b"><strong class="lb iu">Pclass</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Age</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Parch</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Title</strong></code>)的数据上训练随机森林分类器，并检索交叉验证的AUC分数。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><p id="7cad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">以下步骤(</em> <strong class="lb iu"> <em class="mr">步骤4至7 </em> </strong> <em class="mr">)代表</em> <strong class="lb iu"> <em class="mr">单次迭代</em> </strong> <em class="mr">。要运行的最大迭代次数已经在步骤2中定义了。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/23c406228b84c670a3281e7ec94695ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A9ydbYlr7x26GT3n6zujOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模拟退火中的单次迭代流程图(<strong class="bd op">步骤4至步骤7 </strong>)</p></figure><p id="1bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤4 — </strong>随机改变<strong class="lb iu">当前子集</strong>中的特征列表，通过添加、替换或删除一个特征来生成一个新的<strong class="lb iu">子集</strong> <strong class="lb iu">。</strong></p><p id="8632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，一个随机的改变产生了一个新的5特征子集，现在包括了<code class="fe oj ok ol om b"><strong class="lb iu">FamilySize</strong></code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/ee78967656d00492091bcb068c1f1823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRYLBNSIjjnQwqVnKFkNjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">下一次迭代的新特征子集。添加的新功能由蓝框表示|图片由作者提供</p></figure><p id="9ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">注意:如果一个子集之前已经被访问过，我们重复此步骤，直到生成一个新的未被访问的子集。</em></p><p id="d135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤5 — </strong>在<strong class="lb iu">新子集</strong>上运行模型，并且<strong class="lb iu">将</strong>性能指标(即AUC分数)与<strong class="lb iu">当前子集进行比较。</strong></p><p id="99ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤6 — </strong>如果<strong class="lb iu">新子集性能</strong><strong class="lb iu"/>更好，接受并更新新子集为当前状态，结束迭代。如果性能<strong class="lb iu">比</strong>差，继续步骤7。</p><p id="c5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">步骤7 — </strong>通过首先计算一个<strong class="lb iu">接受概率</strong>来评估是否接受表现最差的新子集(更多细节在后面)。接下来，在范围[0，1]内统一生成一个<strong class="lb iu">随机数</strong><strong class="lb iu"/>。</p><p id="5c21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<strong class="lb iu">随机数大于接受概率</strong>，则<strong class="lb iu">拒绝新子集</strong>并保留当前子集。否则，接受并更新新的子集作为当前状态。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/fe5bd692db3cec93d2b49623122e85ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dMY_B8OGuJG8M1xc0vRxdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个迭代的例子，其中新子集具有更差的性能，但仍然被接受并更新为当前状态，因为随机数比接受概率小</p></figure><p id="1dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每次迭代结束时，接受概率被调整以建立一个“冷却”计划。让我们看看这是如何工作的。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="3301" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">㈡接受概率</h2><p id="3410" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我们之前(在步骤7中)看到了如何使用<strong class="lb iu">接受概率</strong>来决定是否接受一个性能更差的新子集(从而做出<strong class="lb iu">非改进移动</strong>)。</p><p id="0295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接受概率计算如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5ea6dc157fb47d3d96c46d8cf5d27f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohzw4TuY1KNLWiZXGlW_HQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">接受概率公式|作者图片</p></figure><ul class=""><li id="6a9f" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><strong class="lb iu"> <em class="mr"> E </em> </strong>术语指的是性能指标，即AUC分数。<strong class="lb iu"> E </strong> <em class="mr"> new </em>是来自在新子集上训练的模型的交叉验证的AUC分数，而<strong class="lb iu"> E </strong> <em class="mr"> current </em>基于当前子集。这两项之间的差异<strong class="lb iu"> </strong>给出了模型性能的变化。</li><li id="faee" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><strong class="lb iu"> <em class="mr"> T </em> ᵢ </strong>代表迭代<strong class="lb iu"> <em class="mr"> i </em> </strong>时的<strong class="lb iu">温度</strong>。虽然初始温度(<strong class="lb iu"> Tₒ </strong>)是可调的，但我们可以先将其设置为默认的高(最大)值<strong class="lb iu"> 1 </strong>来启动加热阶段。</li><li id="ce1d" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">随着算法的进行，温度应该冷却并从初始的<strong class="lb iu"> Tₒ </strong>降低。一个流行的策略是<strong class="lb iu">几何缩减，</strong>在每次迭代后，温度由冷却因子<strong class="lb iu"> alpha (α) </strong>缩放。由于<strong class="lb iu"> α </strong>的典型范围在0.95和0.99之间，因此<strong class="lb iu"> α </strong>值可以默认设置为<strong class="lb iu"> 0.95 </strong>。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/eb7d1c5218f8d35b03720e973bdcbea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWqZzTyzOI-7wIbhiKMsJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">几何缩减计划的温度更新公式，其中alpha是介于0和1之间的因子值|图片由作者提供</p></figure><p id="b1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是参数如何影响接受概率:</p><ul class=""><li id="f592" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><strong class="lb iu">随着温度降低，接受概率降低</strong>。这意味着随机数大于接受概率的可能性更大。这意味着我们更有可能拒绝表现不佳的新子集。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/ac20f0ad26d5fb448a9ad5345af18e47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrCVwcuEsE02kbVyvSu0bw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">随着温度降低，接受概率降低|图片由作者提供</p></figure><ul class=""><li id="382b" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><strong class="lb iu">随着新子集模型性能恶化</strong>到更大程度(即<strong class="lb iu">E</strong>T22】当前与<strong class="lb iu">E</strong>T26】新之间的差异更大)，则<strong class="lb iu">接受概率降低</strong>。同样，这意味着我们更有可能<strong class="lb iu">拒绝</strong>表现不佳的新子集。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/d997a853f30f0a8a63288d85efafa753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQCCo5du3yYvi4iIG6FlwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">随着(<strong class="bd op">E</strong>T34】当前 — <strong class="bd op"> E </strong>新)的增加，接受概率降低|图片由作者提供</p></figure><p id="fb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从高温到低温的受控降低使得差的解决方案在搜索的早期具有更高的被接受的概率，但是稍后更有可能被拒绝。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="dd7d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">(三)终止条件</h2><p id="8e26" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">包含<strong class="lb iu">终止条件</strong>(又名<strong class="lb iu">停止标准</strong> ) <strong class="lb iu"> </strong>也是有帮助的，这样算法就不会不必要地迭代。</p><p id="6fc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">终止条件的一些例子包括:</p><ul class=""><li id="961e" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">达到可接受的性能阈值</li><li id="c170" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">达到特定的最终温度(例如<strong class="lb iu"> T=0.01 </strong>)</li><li id="5b0c" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">达到预定数量的连续迭代而性能没有提高</li></ul></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="2e6f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">(四)算法伪代码</h2><p id="3e1b" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在线搜索模拟退火将会产生许多代表该算法的令人生畏的伪代码。这里有一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/ed8ddbb332c163f51f770ba1680504e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t7PRW6eWxi9-qGqexHhe1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模拟退火算法的伪代码示例</p></figure><p id="0236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了前面几节的解释，不管使用什么符号和缩写，你现在都可以很好地欣赏和理解这些代码。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="218d" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(5) Python的实现</h1><p id="e583" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">理论概念建立后，让我们看看如何将模拟退火付诸实践。</p><p id="8971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是用Python实现该算法的代码。你也可以在这里查看完整的Python脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="092e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数<code class="fe oj ok ol om b"><strong class="lb iu">train_model</strong></code>使用三重交叉验证运行随机森林分类器，以获得AUC分数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="7444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mr">随意查看</em> <a class="ae ky" href="https://github.com/kennethleungty/Simulated-Annealing-Feature-Selection/blob/main/notebooks/02_Simulated_Annealing_Actual_Run.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="mr">本笔记本</em> </a> <em class="mr">查看完整输出。</em></p><p id="7fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Titanic数据集上运行模拟退火函数后，我们获得了如下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/3bcf942920649abd63c6c85d0a66d728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v2Ij3c20xGy-P-_ckozMuA.png"/></div></div></figure><p id="ba90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到最好的AUC得分是<strong class="lb iu"> 0.867 </strong>，对应<strong class="lb iu">迭代4 </strong>，特征集为【0，1，2，5，8】。当索引被映射到列名时，五个特征是<code class="fe oj ok ol om b"><strong class="lb iu">Pclass</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Sex</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Age</strong></code>、<code class="fe oj ok ol om b"><strong class="lb iu">Fare</strong></code>和<code class="fe oj ok ol om b"><strong class="lb iu">Title</strong></code>。</p><p id="42de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的是，这种实现假设较高的度量分数与较好的性能相关(例如，AUC、准确性)。然而，如果我们使用像RMSE这样的指标，分数越低越好，那么不等式符号需要相应地反转，例如，<code class="fe oj ok ol om b">metric <strong class="lb iu">&lt;</strong> prev_metric</code>而不是<code class="fe oj ok ol om b">metric <strong class="lb iu">&gt;</strong> prev_metric</code>。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h1 id="393d" class="nc lw it bd lx nd ne nf ma ng nh ni md jz nj ka mg kc nk kd mj kf nl kg mm nm bi translated">(6)包装</h1><p id="3c4e" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">到目前为止，我们已经介绍了Python中用于特征选择的模拟退火的概念和基本实现。</p><p id="7c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会很高兴地知道，先进的实现是可用的，使算法更健壮。</p><p id="98d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是<strong class="lb iu">重启</strong>的概念，其中如果在<em class="mr"> n次</em>迭代后没有找到新的最优解，则搜索重置为最后已知的最优解。它的目的是提供一个额外的保护层，防止搜索停留在性能不佳的局部最优解。</p><p id="fd4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个项目的GitHub repo可以在 这里找到<a class="ae ky" href="https://github.com/kennethleungty/Simulated-Annealing-Feature-Selection" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">，还有<a class="ae ky" href="https://github.com/kennethleungty/Simulated-Annealing-Feature-Selection#References" rel="noopener ugc nofollow" target="_blank">的引用</a>。一如既往，期待您对这个话题的反馈！</strong></a></p><h1 id="679e" class="nc lw it bd lx nd oz nf ma ng pa ni md jz pb ka mg kc pc kd mj kf pd kg mm nm bi translated">在你走之前</h1><p id="b703" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">欢迎您来到<strong class="lb iu">加入我的数据科学学习之旅！</strong>点击此<a class="ae ky" href="https://kennethleungty.medium.com/" rel="noopener"> Medium </a>页面，查看我的<a class="ae ky" href="https://github.com/kennethleungty" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，了解更多精彩的数据科学内容。与此同时，运行模拟退火进行特征选择也很有趣！</p><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/micro-macro-weighted-averages-of-f1-score-clearly-explained-b603420b292f"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">F1分数的微观、宏观和加权平均值，解释清楚</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">理解F1分数的微观平均、宏观平均和加权平均背后的概念</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a rel="noopener follow" target="_blank" href="/assumptions-of-logistic-regression-clearly-explained-44d85a22b290"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">逻辑回归的假设，解释清楚</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">理解并实现假设检验(用Python ),这是最重要的数据科学建模技术之一</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">towardsdatascience.com</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv ks ph"/></div></div></a></div></div></div>    
</body>
</html>