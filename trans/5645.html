<html>
<head>
<title>A solution for inconsistencies in indexing operations in pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫索引操作不一致的解决方案</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-solution-for-inconsistencies-in-indexing-operations-in-pandas-b76e10719744#2022-12-21">https://towardsdatascience.com/a-solution-for-inconsistencies-in-indexing-operations-in-pandas-b76e10719744#2022-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0eef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">摆脱烦人的设置 WithCopyWarning 消息</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/0c97da3cd3244e84993a901f8f48b137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*c2867ICA_q6okdAz-EfhmA.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由<a class="ae kr" href="https://unsplash.com/@kellysikkema" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kr" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="a494" class="ks kt iq bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">介绍</h2><p id="39ce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lb lx ly lz lf ma mb mc lj md me mf mg ij bi translated">pandas 中的索引操作非常灵活，因此，有许多情况可能表现得非常不同，从而产生意想不到的结果。此外，很难预测何时会出现<code class="fe mh mi mj mk b">SettingWithCopyWarning</code>以及这到底意味着什么。我将展示几个不同的场景，以及每个操作如何影响您的代码。之后，我们将看看一个叫做<code class="fe mh mi mj mk b">Copy on Write </code>的新特性，它可以帮助你摆脱不一致和<code class="fe mh mi mj mk b">SettingWithCopyWarnings</code>。我们还将研究这对性能和其他一般方法的影响。我是熊猫核心团队的一员。</p><h2 id="ae08" class="ks kt iq bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">索引操作</h2><p id="2115" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lb lx ly lz lf ma mb mc lj md me mf mg ij bi translated">让我们看看索引操作目前在 pandas 中是如何工作的。如果您已经熟悉索引操作，可以跳到下一节。但是要注意，很多情况下都有不同的行为形式。确切的行为很难预测。</p><p id="79d7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">当父数据帧和新数据帧的底层数据不共享时，pandas 中的操作产生一个副本。视图是与父对象共享数据的对象。对视图的修改可能会影响父对象。</p><p id="fabe" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">目前，一些索引操作返回副本，而另一些返回视图。确切的行为很难预测，即使对于有经验的用户也是如此。这在过去一直是我的一大烦恼。</p><p id="6c18" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">让我们从具有两列的数据帧开始:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="ca93" class="mu kt iq mk b be mv mw l mx my">df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})</span></pre><p id="6ee4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">对数据帧或系列的<strong class="lq ir"> getitem </strong>操作返回初始对象的子集。该子集可能由一列或一组列、一行或一组行或者两者的混合组成。数据帧或系列上的<strong class="lq ir"> setitem </strong>操作更新初始对象的子集。子集本身由调用的参数定义。</p><p id="b8eb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">数据帧上的常规<strong class="lq ir"> getitem </strong>操作在大多数情况下提供了一个视图:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="6209" class="mu kt iq mk b be mv mw l mx my">view = df["user_id"]</span></pre><p id="17d3" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">因此，新对象<code class="fe mh mi mj mk b">view</code>仍然引用父对象<code class="fe mh mi mj mk b">df</code>及其数据。因此，写入视图也会修改父对象。</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="5b72" class="mu kt iq mk b be mv mw l mx my">view.iloc[0] = 10</span></pre><p id="6698" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">这个<strong class="lq ir"> setitem </strong>操作将因此不仅更新我们的<code class="fe mh mi mj mk b">view</code>而且更新<code class="fe mh mi mj mk b">df</code>。这是因为<strong class="lq ir">底层数据</strong>在两个对象之间共享。</p><p id="112d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">只有当列<code class="fe mh mi mj mk b">user_id</code>在<code class="fe mh mi mj mk b">df</code>中只出现一次时才成立。一旦<code class="fe mh mi mj mk b">user_id</code>被复制，<strong class="lq ir"> getitem </strong>操作返回一个数据帧。这意味着返回的对象是副本而不是视图:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="ff51" class="mu kt iq mk b be mv mw l mx my">df = pd.DataFrame(<br/>    [[1, 10, 2], [3, 15, 4]], <br/>    columns=["user_id", "score", "user_id"],<br/>)<br/>not_a_view = df["user_id"]<br/>not_a_view.iloc[0] = 10</span></pre><p id="e158" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated"><strong class="lq ir">设置项</strong>操作不更新<code class="fe mh mi mj mk b">df</code>。我们也得到我们的第一个<code class="fe mh mi mj mk b">SettingWithCopyWarning</code>，尽管这是一个完全可以接受的操作。<strong class="lq ir"> getitem </strong>操作本身有更多的情况，比如类似列表的键，例如<code class="fe mh mi mj mk b">df[["user_id"]]</code>，多索引列等等。我将在后续文章中更详细地介绍执行索引操作的不同形式及其行为。</p><p id="6e8a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">让我们看看另一个比单个<strong class="lq ir"> getitem </strong>操作稍微复杂一点的例子:<strong class="lq ir">链式索引</strong>。链式索引意味着用一个布尔掩码过滤，后跟一个<strong class="lq ir"> getitem </strong>操作，或者反过来。这是一步完成的。我们没有创建新的变量来存储第一次操作的结果。</p><p id="eb8e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">我们再次从常规数据帧开始:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="8ef3" class="mu kt iq mk b be mv mw l mx my">df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})</span></pre><p id="6d30" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">我们可以通过以下方式更新所有得分高于 15 的<code class="fe mh mi mj mk b">user_ids</code>:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="6bc8" class="mu kt iq mk b be mv mw l mx my">df["user_id"][df["score"] &gt; 15] = 5</span></pre><p id="ebd0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">我们取列<code class="fe mh mi mj mk b">user_id</code>，然后应用过滤器。这非常好，因为列选择创建了一个视图，而<strong class="lq ir"> setitem </strong>操作更新了该视图。我们也可以切换两种操作:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="fc48" class="mu kt iq mk b be mv mw l mx my">df[df["score"] &gt; 15]["user_id"] = 5</span></pre><p id="281e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">这个执行命令产生另一个<code class="fe mh mi mj mk b">SettingWithCopyWarning</code>。与我们之前的例子相反，什么都没有发生。数据帧<code class="fe mh mi mj mk b">df</code>未被修改。这是无声的无操作。布尔掩码总是创建初始数据帧的副本。因此，初始的<strong class="lq ir"> getitem </strong>操作返回一个副本。返回值不赋给任何变量，只是一个临时结果。<strong class="lq ir">设置项</strong>操作更新这个临时副本。因此，修改会丢失。掩码返回副本，而列选择返回视图，这是一个实现细节。理想情况下，这样的实现细节应该是不可见的。</p><p id="bef9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">另一种方法如下:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="b2f9" class="mu kt iq mk b be mv mw l mx my">new_df = df[df["score"] &gt; 15]<br/>new_df["user_id"] = 10</span></pre><p id="f90d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">该操作按预期更新了<code class="fe mh mi mj mk b">new_df</code>，但无论如何显示了一个<code class="fe mh mi mj mk b">SettingWithCopyWarning</code>，因为我们不能更新<code class="fe mh mi mj mk b">df</code>。在这种情况下，我们大多数人可能都不想更新初始对象(例如<code class="fe mh mi mj mk b">df</code>)，但我们还是得到了警告。根据我的经验，这会导致不必要的<code class="fe mh mi mj mk b">copy</code>语句分散在代码库中。</p><p id="4242" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">这只是当前索引操作中不一致和恼人之处的一小部分。</p><p id="a3d5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">由于实际的行为很难预测，这就迫使许多其他方法的防御性副本。举个例子，</p><ul class=""><li id="a60f" class="mz na iq lq b lr ml lu mm lb nb lf nc lj nd mg ne nf ng nh bi translated">删除列</li><li id="9a44" class="mz na iq lq b lr ni lu nj lb nk lf nl lj nm mg ne nf ng nh bi translated">设置新索引</li><li id="812f" class="mz na iq lq b lr ni lu nj lb nk lf nl lj nm mg ne nf ng nh bi translated">重置索引</li><li id="b418" class="mz na iq lq b lr ni lu nj lb nk lf nl lj nm mg ne nf ng nh bi">…</li></ul><p id="3aa8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">全部复制底层数据。从实现的角度来看，这些副本是不必要的。这些方法可以很容易地返回视图，但是返回视图会导致不可预知的行为。理论上，一个<strong class="lq ir"> setitem </strong>操作可以通过整个调用链传播，一次更新许多数据帧。</p><h2 id="3fd8" class="ks kt iq bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">写入时复制</h2><p id="5f23" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lb lx ly lz lf ma mb mc lj md me mf mg ij bi translated">让我们看看一个叫做“写时复制”(CoW)的新特性如何帮助我们消除代码库中的这些不一致。CoW 表示以任何方式从另一个数据帧或序列<strong class="lq ir">派生的任何数据帧或序列<strong class="lq ir">总是表现为副本</strong>。因此，我们只能通过修改对象本身来改变对象的值。CoW 不允许更新与另一个数据帧或系列对象共享数据的数据帧或系列。有了这些信息，我们可以再次看看我们最初的例子:</strong></p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="b413" class="mu kt iq mk b be mv mw l mx my">df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})<br/>view = df["user_id"]<br/>view.iloc[0] = 10</span></pre><p id="63a4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated"><strong class="lq ir"> getitem </strong>操作提供了对<code class="fe mh mi mj mk b">df</code>及其数据的查看。<strong class="lq ir"> setitem </strong>操作在<code class="fe mh mi mj mk b">10</code>被写入第一行之前触发底层数据的拷贝。因此，该操作不会修改<code class="fe mh mi mj mk b">df</code>。这种行为的一个优点是，我们不必担心<code class="fe mh mi mj mk b">user_id</code>可能被复制或者使用<code class="fe mh mi mj mk b">df[["user_id"]]</code>而不是<code class="fe mh mi mj mk b">df["user_id"]</code>。所有这些情况的行为完全一样，没有恼人的警告显示。</p><p id="8d09" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">在更新对象的值之前触发复制会影响性能。这肯定会导致一些业务的小幅放缓。另一方面，许多其他操作可以<strong class="lq ir">避免</strong>防御副本，从而极大地提高性能。以下操作都可以用 CoW 返回视图:</p><ul class=""><li id="28d9" class="mz na iq lq b lr ml lu mm lb nb lf nc lj nd mg ne nf ng nh bi translated">删除列</li><li id="7d66" class="mz na iq lq b lr ni lu nj lb nk lf nl lj nm mg ne nf ng nh bi translated">设置新索引</li><li id="b700" class="mz na iq lq b lr ni lu nj lb nk lf nl lj nm mg ne nf ng nh bi translated">重置索引</li><li id="52f8" class="mz na iq lq b lr ni lu nj lb nk lf nl lj nm mg ne nf ng nh bi translated">还有很多。</li></ul><p id="cad9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">让我们考虑以下数据框架:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="b69d" class="mu kt iq mk b be mv mw l mx my">na = np.array(np.random.rand(1_000_000, 100))<br/>cols = [f"col_{i}" for i in range(100)]<br/>df = pd.DataFrame(na, columns=cols)</span></pre><p id="f80d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">使用<code class="fe mh mi mj mk b">add_prefix</code>将给定的字符串(例如<code class="fe mh mi mj mk b">test</code>)添加到每个列名的开头:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="e2a1" class="mu kt iq mk b be mv mw l mx my">df.add_prefix("test")</span></pre><p id="2d52" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">如果没有 CoW，这将在内部复制数据。当只看操作时，这是不必要的。但是由于返回视图可能有副作用，所以该方法返回一个副本。因此，操作本身相当慢:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="2444" class="mu kt iq mk b be mv mw l mx my">482 ms ± 3.43 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="33ef" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">这需要很长时间。我们实际上只修改了 100 个字符串，而没有触及任何数据。在这种情况下，返回视图可以显著提高速度:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="16c3" class="mu kt iq mk b be mv mw l mx my">46.4 µs ± 1.04 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</span></pre><p id="a133" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">同样的操作运行速度要快几个数量级。更重要的是，当使用 CoW 时，<code class="fe mh mi mj mk b">add_prefix</code>的运行时间是一个常量，不依赖于数据帧的大小。这个手术是在熊猫的主要分支上进行的。</p><p id="c348" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">只有当两个不同的对象共享相同的底层数据时，才需要复制。在上面的例子中，<code class="fe mh mi mj mk b">view</code>和<code class="fe mh mi mj mk b">df</code>引用了相同的数据。如果数据是一个<code class="fe mh mi mj mk b">DataFrame</code>对象专有的，则不需要复制，我们可以继续就地修改数据:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="1b34" class="mu kt iq mk b be mv mw l mx my">df = pd.DataFrame({"user_id": [1, 2, 3], "score": [10, 15, 20]})<br/>df.iloc[0] = 10</span></pre><p id="d470" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">在这种情况下，setitem 操作将继续原地操作，而不会触发复制。</p><p id="fd23" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">因此，我们最初看到的所有不同场景现在都有完全相同的行为。我们再也不用担心微妙的矛盾了。</p><p id="ee1c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">另一个目前具有奇怪且难以预测的行为的例子是链式索引。CoW 下的链式索引<strong class="lq ir">永远不会</strong>工作。这是奶牛机制的直接结果。最初选择的列可能会返回一个视图，但是当我们执行后续的<strong class="lq ir"> setitem </strong>操作时会触发一个副本。幸运的是，我们可以很容易地修改代码以避免链式索引:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="5de8" class="mu kt iq mk b be mv mw l mx my">df["user_id"][df["score"] &gt; 15] = 10</span></pre><p id="4820" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">我们可以使用<code class="fe mh mi mj mk b">loc</code>同时完成这两个操作:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="3092" class="mu kt iq mk b be mv mw l mx my">df.loc[df["score"] &gt; 15, "user_id"] = 10</span></pre><p id="1f9f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">总的来说，我们创建的每个对象的行为都像父对象的副本。我们不能意外地更新当前正在处理的对象之外的对象。</p><h2 id="9770" class="ks kt iq bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">如何尝试它</h2><p id="cdc6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lb lx ly lz lf ma mb mc lj md me mf mg ij bi translated">可以试试熊猫 1.5.0 以来的牛功能。开发仍在进行中，但一般机制已经工作。</p><p id="a98c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">您可以通过以下语句之一全局设置 CoW 标志:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="fca4" class="mu kt iq mk b be mv mw l mx my">pd.set_option("mode.copy_on_write", True)<br/>pd.options.mode.copy_on_write = True</span></pre><p id="e1b2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">或者，您可以使用以下命令在本地启用 CoW:</p><pre class="kg kh ki kj gt mq mk mr bn ms mt bi"><span id="29aa" class="mu kt iq mk b be mv mw l mx my">with pd.option_context("mode.copy_on_write", True):<br/>    ...</span></pre><h2 id="0c4f" class="ks kt iq bd ku kv kw dn kx ky kz dp la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">结论</h2><p id="2842" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lb lx ly lz lf ma mb mc lj md me mf mg ij bi translated">我们已经看到，熊猫的索引操作有许多难以预测的边缘情况和行为上的微妙差异。CoW 是一个旨在解决这些差异的新特性。根据我们对数据的处理，它可能会对性能产生积极或消极的影响。关于 CoW 的完整提案可在<a class="ae kr" href="https://docs.google.com/document/d/1ZCQ9mx3LBMy-nhwRl33_jgcvWo9IWdEfxDNQ2thyTb0/edit#heading=h.iexejdstiz8u" rel="noopener ugc nofollow" target="_blank">此处</a>找到。</p><p id="512b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lb mn ly lz lf mo mb mc lj mp me mf mg ij bi translated">感谢您的阅读。请在评论中分享您对索引和写时复制的想法和反馈。我将继续关注这个话题和熊猫。如果你想了解更多关于熊猫的信息，请关注我。</p></div></div>    
</body>
</html>