<html>
<head>
<title>Demystifying Modules and Packages in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Python中模块和包的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-modules-and-packages-in-python-968c13b3b990#2022-04-20">https://towardsdatascience.com/demystifying-modules-and-packages-in-python-968c13b3b990#2022-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a200" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">模块和包是任何大型项目的核心。我将展示一些涉及它们的技巧，比如如何组织包和创建名称空间。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1a949ee7a34b49d5eb97b1b1a03f05c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XK5ODNpfEC6unbzTEBJPow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由阿尔瓦罗·雷耶斯从Unsplash拍摄</p></figure><p id="1e33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在Github上检查复杂的项目时，我通常会发现自己迷失在无数的文件夹和源文件之间。这些报告的作者认为他们的定制对他们自己来说非常明显，这是完全可以理解的；可悲的是，我努力让自己对构建不同的文件夹和源文件有同样的感觉，但却没有用。</p><p id="283c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">揭秘一些处理包和模块的常见反应如何？</p><p id="61ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个快速教程中，我花时间模拟了一个具有以下全局结构的项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/7ac151d731fd93ff259df9f74ebc7f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wbv_y6530iFoSUKghTuKxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ed21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，我们项目的树状结构可以概括为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最感兴趣的是<code class="fe ly lz ma mb b">superlibrary</code>的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dataloader处理所有类型的数据加载器。</p><p id="1b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">Learners</code>包含按学习类型划分的模型。</p><p id="1355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">Preprocessor</code>拥有熊猫、NumPy和Scikit-Learn的各种预处理器模块。</p><p id="1ced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">Tests</code>是您集中所有测试的地方。</p><p id="1229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">Utils</code>通常包含各种执行优化或充当成本函数的函数。</p><p id="c246" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个函数只是一个简单的打印函数，也可以作为一个整体实现。</p><p id="6811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将进行简单快速的实验来强调一些概念，并举例回答如下问题:</p><blockquote class="mc md me"><p id="60ab" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">包装是如何制作的？</p><p id="c38b" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">如何控制进口包装？</p><p id="35c2" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">如何执行一个包作为主入口函数？</p><p id="4637" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">如何利用名称空间包？</p></blockquote><h1 id="ffc6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">实验</h1><h2 id="38e8" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">包装是如何制作的？</h2><p id="08dd" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">如果你检查我们的模拟项目的结构，你会注意到在我们的文件夹的不同层次传播<code class="fe ly lz ma mb b">__init__.py</code>。</p><p id="07f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包含此类文件的每个文件夹都被视为一个包。<code class="fe ly lz ma mb b">__init__.py</code> <em class="mf"> </em>文件的目的是包含可选的初始化代码，这些代码在遇到不同级别的包时运行。</p><p id="d6cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们将自己定位在<code class="fe ly lz ma mb b">preprocessor</code>文件夹中。我们将编写几行代码进行一些导入。</p><p id="4e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe ly lz ma mb b">preprocessor/__init__.py</code> <strong class="lb iu"> </strong>文件中写下以下几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="21b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们返回到预处理器目录的上一级(因此我们将查看<code class="fe ly lz ma mb b">preprocessor</code>、<code class="fe ly lz ma mb b">learner</code>、<code class="fe ly lz ma mb b">dataloader</code>、<code class="fe ly lz ma mb b">tests</code>和<code class="fe ly lz ma mb b">utils</code>目录)，打开Python解释器并执行以下操作:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="4836" class="nb mk it mb b gy nw nx l ny nz">&gt;&gt;&gt; from preprocessor import numpy_prep, pd_prep, sk_prep<br/>&gt;&gt;&gt; numpy_prep()<br/>This is the numpy implementation for the preprocessor.<br/>&gt;&gt;&gt; pd_prep()<br/>This is the Pandas implementation for the preprocessor.<br/>&gt;&gt;&gt; sk_prep()<br/>This is the sklearn implementation for the preprocessor.<br/>&gt;&gt;&gt; ...</span></pre><p id="6002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解这里做了什么很重要；<code class="fe ly lz ma mb b">preprocessor</code>目录中的<code class="fe ly lz ma mb b">__init__.py</code>文件将我们需要在更高层次调用的所有函数粘在了一起。</p><p id="9fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们为<code class="fe ly lz ma mb b">preprocessor</code>包提供了额外的逻辑功能，节省了您的时间和更复杂的导入行。</p><h2 id="fc29" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">如何控制进口包？</h2><p id="722c" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">比方说，使用与前面相同的层次结构配置，您想要控制某个行为，该行为包括导入所有带有星号的内容。</p><p id="388d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会写:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="39a3" class="nb mk it mb b gy nw nx l ny nz">from module import * .</span></pre><p id="4f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过添加一个新的<code class="fe ly lz ma mb b">__all__</code>属性来修改<code class="fe ly lz ma mb b">preprocessor/__init__.py</code> <strong class="lb iu"> </strong>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">__all__</code>正在接收一个受限的属性列表。</p><p id="876a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看如果我们在<code class="fe ly lz ma mb b">preprocessor</code>目录之上运行解释器会发生什么:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="c93c" class="nb mk it mb b gy nw nx l ny nz">&gt;&gt;&gt; from preprocessor import *<br/>&gt;&gt;&gt; numpy_prep()<br/>This is the numpy implementation for the preprocessor.<br/>&gt;&gt;&gt; pd_prep()<br/>This is the Pandas implementation for the preprocessor.<br/>&gt;&gt;&gt; sk_prep()<br/>Traceback (most recent call last):<br/>File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>NameError: name 'sk_prep' is not defined<br/>&gt;&gt;&gt; ...</span></pre><p id="b6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">sk_prep</code>函数被省略，不包含在<code class="fe ly lz ma mb b">__all__</code>属性中。这保护了加载<code class="fe ly lz ma mb b">sk_prep</code>的原始包免受任何意外行为的影响。</p><p id="5180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管一般不鼓励使用<code class="fe ly lz ma mb b">from module import *</code>,但它还是经常在声明大量名称的模块中使用。</p><p id="d1bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，此导入将导出所有不以下划线开头的名称。但是，如果指定了<code class="fe ly lz ma mb b">__all__</code>,则只导出明确说明的名称。</p><p id="af95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe ly lz ma mb b">__all__</code>被定义为空列表，则不会导出任何内容。如果<code class="fe ly lz ma mb b">__all__</code>包含未定义的名称，导入时会抛出<code class="fe ly lz ma mb b">AttributeError</code>。</p><h2 id="ba88" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">如何执行一个包作为主入口函数？</h2><p id="9aac" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">毫无疑问，你对写这样的东西很熟悉:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="ac4f" class="nb mk it mb b gy nw nx l ny nz">If __name__ == "__main__" :<br/>...</span></pre><p id="f8c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把它带到另一个水平怎么样？可以将<code class="fe ly lz ma mb b">learner</code>包作为主模块运行吗？</p><p id="898e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们转到<code class="fe ly lz ma mb b">learner</code>文件夹:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来我们要做的是确保在导入三个包中的每一个时，我们同时导入与每种学习类型相关的函数。</p><p id="8634" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ly lz ma mb b">clustering</code>包，我们在<code class="fe ly lz ma mb b">clustering/__init__.py</code>文件中写下几行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2df7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样为<code class="fe ly lz ma mb b">supervised_learning</code> <strong class="lb iu"> </strong>包装:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe ly lz ma mb b">reinforcement_learning</code>包:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="23f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在能够将所有必要的功能直接加载到学员目录中的新实现中。</p><p id="809d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们创建一个新文件，命名为<code class="fe ly lz ma mb b">__main__.py</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们返回到主<code class="fe ly lz ma mb b">superlibrary</code>目录，因此我们将在<code class="fe ly lz ma mb b">learner</code>目录的上一级，并运行以下内容:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="1168" class="nb mk it mb b gy nw nx l ny nz">Username@Host current_directory % python learner <br/>Methods for clustering :<br/>This is the implementation for model1.<br/>This is the implementation for model2.<br/>Methods for reinforcement learning :<br/>This is the implementation for model1.<br/>This is the implementation for model2.<br/>Methods for supervised learning :<br/>This is the implementation for model1.<br/>This is the implementation for model2.</span></pre><p id="5ab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">万岁！属性似乎比你所习惯的做得更多。它可以超越一个简单的文件，控制整个包，因此您可以导入或运行它。</p><h2 id="2d44" class="nb mk it bd ml nc nd dn mp ne nf dp mt li ng nh mv lm ni nj mx lq nk nl mz nm bi translated">如何利用名称空间包？</h2><p id="4ab5" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">在我们的最后一节中，假设您稍微修改了utils文件夹的内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在每个<code class="fe ly lz ma mb b">subpackage</code>中有一个名为<code class="fe ly lz ma mb b">modules</code> <strong class="lb iu"> </strong>的新模块，它没有<code class="fe ly lz ma mb b">__init__.py</code>初始化文件。</p><p id="8440" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许我们应该从一开始就谈论你可能遇到的这种类型的场景，以及其行为非常值得怀疑。没有<code class="fe ly lz ma mb b">__init__</code>文件的文件夹的行为几乎类似于一个包，但并不被视为包。</p><p id="6eba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更技术上来说，它被认为是一个<code class="fe ly lz ma mb b">namespace</code> <strong class="lb iu"> </strong>包。事实证明，我们可以用它来实现有趣的事情。</p><p id="0a31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以创建一些包含在每个<code class="fe ly lz ma mb b">backend_connectors</code>和<code class="fe ly lz ma mb b">custom_functions</code>包中的公共名称空间，这样<code class="fe ly lz ma mb b">modules</code>将作为一个<code class="fe ly lz ma mb b">single</code>模块..</p><p id="ab02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还不够信服？让我们在解释器中写一些高于前面提到的两个包的东西:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="6241" class="nb mk it mb b gy nw nx l ny nz">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.path.extend(['backend_connectors','custom_functions'])<br/>&gt;&gt;&gt; from modules import cloud_connectors, optimizers<br/>&gt;&gt;&gt; cloud_connectors<br/>&lt;module 'modules.cloud_connectors' from 'path_to_current_directory/cloud_connectors.py'&gt;<br/>&gt;&gt;&gt; optimizers<br/>&lt;module 'modules.optimizers' from 'path_to_current_directory/optimizers.py'&gt;<br/>&gt;&gt;&gt; ...</span></pre><p id="cad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在模块搜索路径中添加这两个包，我们从一种特殊的包中获益，这种包是为在一个公共名称空间下将不同的代码目录合并在一起而设计的，如图所示。对于大型框架，这可能非常有用。</p><p id="f8ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个关于Python在导入时如何感知<code class="fe ly lz ma mb b">modules</code>的技巧。</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="e0f4" class="nb mk it mb b gy nw nx l ny nz">&gt;&gt;&gt; import modules<br/>&gt;&gt;&gt; modules.__path__<br/>_NamespacePath(['backend_connectors/modules','custom_functions/modules'])<br/>&gt;&gt;&gt; modules.__file__<br/>&gt;&gt;&gt; modules<br/>&lt;module 'modules' (namespace)&gt;<br/>&gt;&gt;&gt; ...</span></pre><p id="bcd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您观察到一个联合的名称空间路径，一个缺失的<code class="fe ly lz ma mb b">__file__</code>属性(如果它有一个的话，这个属性应该与它的<code class="fe ly lz ma mb b">__init__</code>文件的路径相关联),以及它的类型的一个清楚的指示:名称空间。</p><p id="9272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了充分利用名称空间包，特别是在这种情况下，您不能在任何一个<code class="fe ly lz ma mb b">modules</code>目录中包含任何<code class="fe ly lz ma mb b">__init__.py</code>文件。假设您真的添加了它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细观察当你试图合并<code class="fe ly lz ma mb b">modules</code>目录时会发生什么:</p><pre class="kj kk kl km gt ns mb nt nu aw nv bi"><span id="d557" class="nb mk it mb b gy nw nx l ny nz">&gt;&gt;&gt; import sys<br/>&gt;&gt;&gt; sys.path.extend(['backend_connectors','custom_functions'])<br/>&gt;&gt;&gt; from modules import cloud_connectors, optimizers<br/>Traceback (most recent call last):<br/>File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>ImportError: cannot import name 'optimizers' from 'modules' (path_to_project_directory/superlibrary/utils/backend_connectors/modules/__init__.py)<br/>...</span></pre><p id="0729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，当您将普通包视为名称空间包时，Python无法加载您的函数。</p><h1 id="f4ba" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="3d9a" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">我希望这些内容能让你更清楚地了解一个适度复杂的项目的结构。这是一个热门话题，尽管它在社区中缺乏分享和写作的热情。关于Python如何处理包和模块，有太多东西需要学习。</p><p id="9af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前的材料旨在让读者意识到将一个人的项目放在一个可读的层次结构中的重要性，以便其他每个用户都有信心使用它。</p><p id="ad7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你的时间。</p></div></div>    
</body>
</html>