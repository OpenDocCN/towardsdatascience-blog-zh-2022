<html>
<head>
<title>How to Use JSON Schema to Validate JSON Documents in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JSON模式在Python中验证JSON文档</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-json-schema-to-validate-json-documents-ae9d8d1db344#2022-07-31">https://towardsdatascience.com/how-to-use-json-schema-to-validate-json-documents-ae9d8d1db344#2022-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0201" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解确保数据质量的标准方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7b756843abf369457baf066378441934.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r2xLc3zVN_fBSfmO.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://pixabay.com/illustrations/developer-programmer-technology-3461405/" rel="noopener ugc nofollow" target="_blank">图片由kreatikar拍摄于Pixabay </a></p></figure><p id="72fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSON文档可以包含任意数量的键/值对。键必须是字符串，但值可以是任何支持的类型，如字符串、数字、布尔值等。该值甚至可以是复杂类型，如数组或嵌套对象。这使得JSON文档既非常灵活又非常松散。然而，这使得数据处理更加困难，因为数据团队经常通过API获取数据，而这些API的响应通常是JSON格式的。拥有一致的数据格式可以使数据管道更加健壮。有了统一的数据输入，就不需要担心意外的数据类型，也不需要在数据清理上花太多时间。因此，您可以更专注于数据分析，提高工作效率。</p><p id="24c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将介绍如何使用JSON模式来验证JSON文档。基本概念以及基本和高级用例将通过简单的代码片段进行介绍，这些代码片段易于理解。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="83b5" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">什么是JSON模式？</h2><p id="6226" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">JSON模式是定义一些JSON数据模式的JSON文档。好吧，老实说，这种解释非常奇怪和难以理解，但一旦我们看到后面的代码，就会变得更加清晰。目前，我们需要理解两点:</p><ul class=""><li id="cf35" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">JSON模式本身是一个具有键/值对的有效JSON文档。每个键都有特殊的含义，用于定义一些JSON数据的模式。</li><li id="6b4f" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">模式类似于SQL数据库中的表定义，定义JSON中字段的数据类型。它还定义了哪些字段是必需的，哪些是可选的。</li></ul><p id="8c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个简单的JSON模式开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个JSON模式指定目标JSON是一个具有两个<strong class="lb iu"> <em class="nq">属性</em> </strong>(通常也称为<strong class="lb iu"> <em class="nq">键</em></strong>/<strong class="lb iu">/<em class="nq">字段</em> </strong>的对象，并且<code class="fe nr ns nt nu b">name</code>属性是必需的。让我们更深入地研究一下每个验证关键字:</p><ul class=""><li id="2537" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe nr ns nt nu b">type</code>关键字指定目标JSON是一个对象。它也可以是一个数组，通常是API响应的对象数组。我们将在后面看到如何定义数组字段的模式。然而，在大多数情况下，顶级的<code class="fe nr ns nt nu b">type</code>几乎总是<code class="fe nr ns nt nu b">object</code>。</li><li id="7692" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nr ns nt nu b">properties</code>关键字为JSON对象的每个字段指定模式。目标JSON的每个字段都被指定为一个键/值对，键是实际的字段名，值是目标JSON中的字段类型。每个字段的关键字<code class="fe nr ns nt nu b">type</code>与顶级关键字的含义相同。可以想象，这里的<code class="fe nr ns nt nu b">type</code>也可以是<code class="fe nr ns nt nu b">object</code>。在这种情况下，相应的字段将是一个嵌套对象，这将在后面演示。</li><li id="e2ca" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe nr ns nt nu b">required</code>关键字是一个数组，包含需要存在的属性。如果此处指定的任何属性缺失，将引发<code class="fe nr ns nt nu b">ValidationError</code>。</li></ul><p id="b03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了基本的验证关键字，即上面指定的<code class="fe nr ns nt nu b">type</code>、<code class="fe nr ns nt nu b">properties</code>和<code class="fe nr ns nt nu b">required</code>，还有其他模式关键字可以在在线文档和一些工具自动生成的JSON模式中看到。</p><p id="6ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个模式关键字，即<code class="fe nr ns nt nu b"><a class="ae ky" href="https://json-schema.org/draft/2020-12/json-schema-core.html#name-the-schema-keyword" rel="noopener ugc nofollow" target="_blank">$schema</a></code>和<code class="fe nr ns nt nu b"><a class="ae ky" href="https://json-schema.org/draft/2020-12/json-schema-core.html#name-the-id-keyword" rel="noopener ugc nofollow" target="_blank">$id</a></code>。<code class="fe nr ns nt nu b">$schema</code>定义用于模式的<a class="ae ky" href="https://json-schema.org/specification-links.html" rel="noopener ugc nofollow" target="_blank">草图</a>。如果未指定<code class="fe nr ns nt nu b">$schema</code>，将使用最新的<a class="ae ky" href="https://json-schema.org/draft/2020-12/release-notes.html" rel="noopener ugc nofollow" target="_blank">草图</a>，这通常是所希望的。作为一个初学者，如果你过多地潜入水中，你可能会很容易迷路。我们通常不需要接触<code class="fe nr ns nt nu b">$schema</code>字段，我们会在这篇文章的最后介绍一点。另一方面，<code class="fe nr ns nt nu b">$id</code>为模式定义了一个URI，使得当前模式可以从外部被其他模式访问。如果没有指定<code class="fe nr ns nt nu b">$id</code>，那么当前的模式只能在本地使用，这也是正常情况下需要的，至少对于小项目是这样。然而，对于更大的项目，您的机构可能有一个关于如何存储模式以及如何引用它们的内部系统。在这种情况下，您可以相应地设置<code class="fe nr ns nt nu b">$id </code>关键字。</p><p id="9aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个注释关键字，即<code class="fe nr ns nt nu b">title</code>和<code class="fe nr ns nt nu b">description</code>，它们分别指定JSON模式的标题和描述。它们可用于文档，并使您的模式更易于阅读和理解。它们也会被一些图形工具很好地显示出来。为了简单起见，在本文中不会指定它们，但是通常应该将它们添加到您的项目中以获得最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="8ff7" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">如何用Python验证JSON文档和模式？</h2><p id="8ef3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在Python中，我们可以使用<code class="fe nr ns nt nu b"><a class="ae ky" href="https://pypi.org/project/jsonschema/" rel="noopener ugc nofollow" target="_blank">jsonschema</a></code>库来验证一个<strong class="lb iu"> <em class="nq"> JSON实例</em> </strong>(也可以称为<strong class="lb iu"> <em class="nq"> JSON文档</em> </strong>，只要它是明确的)。可以安装<a class="ae ky" href="https://pip.pypa.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> pip </a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="54e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们根据上面定义的JSON模式来验证一些JSON实例。注意，从技术上讲<a class="ae ky" rel="noopener" target="_blank" href="/how-to-work-with-json-in-python-bdfaa3074ee4"> JSON是一个字符串</a>，但是我们需要指定要验证的JSON的底层数据，这样更方便。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="28a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明所定义的模式可以按预期用于验证JSON实例。不正确的数据类型或缺少某些必填字段将触发<code class="fe nr ns nt nu b">ValidationError</code>。但是，应该注意的是，默认情况下允许附加字段，这可能是也可能不是您想要的。如果您想要一个严格的模式，并且只允许由<code class="fe nr ns nt nu b">properties</code>关键字定义的字段，那么您可以将<code class="fe nr ns nt nu b">additionalProperties</code>指定为<code class="fe nr ns nt nu b">False</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="7edc" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">如何定义数组字段的模式？</h2><p id="3b18" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">尽管将数组作为顶级字段并不常见，但将其作为属性却非常常见。让我们给上面定义的模式添加一个数组属性。我们需要将<code class="fe nr ns nt nu b">type</code>设置为<code class="fe nr ns nt nu b">array</code>，并用<code class="fe nr ns nt nu b">items</code>关键字为每一项指定<code class="fe nr ns nt nu b">type</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="da7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，可以正确检查数组元素的类型。但是，默认情况下允许空数组。为了改变这种行为，我们可以将<code class="fe nr ns nt nu b">minItems</code>设置为1，或者您期望的对您的情况有意义的数字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="6bb3" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">如何定义嵌套对象字段的模式？</h2><p id="7f08" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如上所述，属性的<code class="fe nr ns nt nu b">type</code>关键字与顶级关键字具有相同的含义和语法。因此，如果一个属性的<code class="fe nr ns nt nu b">type</code>是<code class="fe nr ns nt nu b">object</code>，那么这个属性就是一个嵌套对象。让我们给JSON数据添加一个<code class="fe nr ns nt nu b">address</code>属性，它将是一个嵌套对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="905a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，嵌套对象字段具有与顶级字段完全相同的模式定义语法。因此，为嵌套对象定义模式相当简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1b94" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">使用<code class="fe nr ns nt nu b">$defs</code>来避免代码重复。</h2><p id="db98" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果需要在同一个模式中的多个地方使用<code class="fe nr ns nt nu b">address</code>字段，该怎么办？如果我们在任何需要的地方复制字段定义，就会有代码重复，这是程序员所讨厌的，因为它不是干的。在JSON模式定义中，我们可以使用<code class="fe nr ns nt nu b"><a class="ae ky" href="https://json-schema.org/draft/2020-12/json-schema-core.html#name-schema-re-use-with-defs" rel="noopener ugc nofollow" target="_blank">$defs</a></code>关键字来定义可以在其他地方引用的小子模式，以避免代码重复。让我们用<code class="fe nr ns nt nu b">$defs</code>重构上面的模式，以潜在地避免代码重复:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="675a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，使用<code class="fe nr ns nt nu b">$defs</code>定义子模式的新模式的工作方式和以前一样。但是，如果需要在同一模式的不同地方使用<code class="fe nr ns nt nu b">address</code>字段，它的优点是可以避免代码重复。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="e853" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">如何设置元组字段的模式？</h2><p id="d793" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后，如果我们希望<code class="fe nr ns nt nu b">scores</code>字段是一个元素数量固定的元组呢？可惜JSON schema中没有tuple字段，我们需要通过数组来实现一个tuple的定义。<a class="ae ky" href="https://json-schema.org/draft/2020-12/release-notes.html" rel="noopener ugc nofollow" target="_blank">一般逻辑</a>是一个数组有项(<code class="fe nr ns nt nu b">items</code>)并且可选地有一些位置定义的项在普通项(<code class="fe nr ns nt nu b">prefixItems</code>)之前。对于一个元组，只有<code class="fe nr ns nt nu b">prefixItems</code>没有<code class="fe nr ns nt nu b">items</code>，达到了一个元组有固定数量的元素的效果。重要的是，每个元组元素的类型必须显式定义。</p><p id="b23a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想为一个tuple字段定义模式，您需要对JSON schema的草稿有所了解，这要高级一些。草案是JSON模式的标准或规范，定义了验证器应该如何解析模式。有几个草案可用，最新的是<a class="ae ky" href="https://json-schema.org/draft/2020-12/release-notes.html" rel="noopener ugc nofollow" target="_blank">2020–12</a>。你可以在这里找到草稿列表<a class="ae ky" href="https://json-schema.org/specification-links.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="56ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常情况下，我们不需要担心<code class="fe nr ns nt nu b">$schema</code>字段和要使用的草稿。然而，当我们需要定义一个元组字段时，这是我们应该注意的事情。</p><p id="4dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果安装的<code class="fe nr ns nt nu b"><a class="ae ky" href="https://python-jsonschema.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">jsonschema</a></code>库是最新版本(撰写本文时为v4.9.0)，那么将使用最新草案(<a class="ae ky" href="https://json-schema.org/draft/2020-12/release-notes.html" rel="noopener ugc nofollow" target="_blank">2020–12</a>)。如果这是您想要的版本，您不需要通过<code class="fe nr ns nt nu b">$schema</code>关键字指定草稿。然而，为了清晰起见，最好总是在JSON模式中指定草稿的版本。为了简单起见，在这篇文章的开头省略了它，这样你就不会不知所措，但是建议在实践中使用它。</p><p id="7d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果您想使用一个不同的草案版本而不是最新的版本，那么您需要在草案版本中明确指定关键字<code class="fe nr ns nt nu b">$schema</code>。否则无法正常工作。</p><p id="98c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们分别使用草稿2020–12和2019–09定义<code class="fe nr ns nt nu b">scores</code>字段的模式，并演示如何使用<code class="fe nr ns nt nu b">$schema</code>关键字以及如何相应地定义元组字段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="84ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，使用关键字<code class="fe nr ns nt nu b">prefixItems</code>和<code class="fe nr ns nt nu b">items</code>的draft 2020–12元组字段的模式定义更直观，因此推荐使用。有关元组字段定义从2019–09到2020–12的变更的更详细说明，请查看<a class="ae ky" href="https://json-schema.org/draft/2020-12/release-notes.html" rel="noopener ugc nofollow" target="_blank">本发行说明</a>。</p><p id="1dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，需要注意的是，即使我们希望<code class="fe nr ns nt nu b">scores</code>字段是一个元组，它也必须被指定为一个数组(Python中的list ),而不是验证器的元组。不然就不行了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1fed" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">使用验证器有效地验证多个JSON文档</h2><p id="7c28" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你有一个有效的JSON模式，并想用它来验证许多JSON文档，那么<a class="ae ky" href="https://python-jsonschema.readthedocs.io/en/stable/validate/#jsonschema.validate" rel="noopener ugc nofollow" target="_blank">推荐</a>使用<code class="fe nr ns nt nu b">Validator.validate</code>方法，这比<code class="fe nr ns nt nu b">jsonchema.validate</code> API更有效。一个<a class="ae ky" href="https://python-jsonschema.readthedocs.io/en/stable/validate/#versioned-validators" rel="noopener ugc nofollow" target="_blank">验证器</a>是一个实现特定草稿的特殊类。比如有<code class="fe nr ns nt nu b">Draft202012Validator</code>、<code class="fe nr ns nt nu b">Draft201909Validator</code>、<code class="fe nr ns nt nu b">Draft7Validator</code>等。如果类名中没有指定草案版本，<code class="fe nr ns nt nu b">Validator</code>本身意味着所有验证器类都应该遵守的协议(类似于接口)。</p><p id="958e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了工作方式类似于<code class="fe nr ns nt nu b">jsonchema.validate</code> API的<code class="fe nr ns nt nu b">Validator.validate</code>方法之外，您还可以使用<code class="fe nr ns nt nu b">Validator.check_schema</code>来检查一个模式对于一个特定的草稿是否有效。你也可以使用<code class="fe nr ns nt nu b">Validator.is_valid</code>来悄悄地检查一个JSON是否有效，如果无效就不引发<code class="fe nr ns nt nu b">ValidationError</code>。让我们用一些简单的例子来演示这些方法的用法，这样可以使它们更容易理解:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="47d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们介绍了什么是JSON模式，以及如何使用它来验证JSON文档中的不同数据类型。我们已经介绍了字符串和数字等基本数据类型以及数组和嵌套对象等复杂数据类型的基础知识。此外，我们还学习了如何使用<code class="fe nr ns nt nu b">$defs</code>关键字来避免代码重复，该关键字用于定义子模式，对于复杂的模式来说非常方便。最后但并非最不重要的是，草案的基础知识介绍。我们现在知道了如何用不同的草案定义一个tuple字段的模式，以及如何用一个使用特定草案的验证器更有效地验证多个JSON文档。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相关文章:</p><ul class=""><li id="0dd4" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/how-to-work-with-json-in-python-bdfaa3074ee4">如何在Python中执行JSON转换、序列化和比较</a></li><li id="382c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><a class="ae ky" href="https://lynn-kwong.medium.com/python-typing-and-validation-with-mypy-and-pydantic-a2563d67e6d" rel="noopener">使用mypy和pydantic进行Python类型化和验证</a></li></ul></div></div>    
</body>
</html>