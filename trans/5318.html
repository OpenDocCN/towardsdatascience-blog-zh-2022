<html>
<head>
<title>Rethinking Survival Analysis: How to Make your Model Produce Survival Curves</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反思生存分析:如何让你的模型产生生存曲线</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/rethinking-survival-analysis-how-to-make-your-model-produce-survival-curves-7a9ef112e2af#2022-11-29">https://towardsdatascience.com/rethinking-survival-analysis-how-to-make-your-model-produce-survival-curves-7a9ef112e2af#2022-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="66eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用简单的 ML 方法预测事件时间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db01b5ebd439ad9008e26a360a2260c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z5pG4JYhBr7EqCLh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fa41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据驱动的公司中，<em class="lv">事件时间</em>应用程序在决策中扮演着至关重要的角色(也超出了我们的想象)。<strong class="lb iu">对于<em class="lv">事件时间分析</em>，我们指的是所有用于测量一些感兴趣的事件发生之前所经过的时间的技术</strong>。这个简单的定义可能会立即概括出在业务环境中开发时间事件应用程序的所有好处(不仅仅是好处)。</p><p id="f9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间-事件起源与医学领域相关，以回答诸如“被分析的个体能活多久？”。出于这个原因，术语<em class="lv">生存</em>和<em class="lv">事件发生时间</em>通常被用作同义词。如今，<strong class="lb iu">随着机器学习的大规模采用，在医疗/临床部门以外的公司中也经常会发现生存方法学的应用</strong>。制造商可能对估计某些发动机的预期寿命感兴趣；服务提供商可能需要计算其客户的预期寿命；金融机构可以评估借款人在一段时间内的破产风险。</p><p id="86a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">实际上，要对事件时间问题建模，有一套合适的方法</strong>。从经典的线性统计方法到更复杂的机器学习方法，再到前沿的深度学习解决方案，已经发布了大量的<em class="lv">生存框架</em>。他们都很棒，但是他们必须尊重生存建模理论的假设，这可能会导致低适应性或对实际用例的限制。出于这些原因，<strong class="lb iu">一种处理生存分析的便捷方法可能包括将时间-事件建模作为一个分类问题</strong>。这个想法并不新鲜，在这两部作品[ <a class="ae ky" href="https://arxiv.org/pdf/1909.11171.pdf" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]、[ <a class="ae ky" href="https://proceedings.neurips.cc/paper/2011/file/1019c8091693ef5c5f55970346633f92-Paper.pdf" rel="noopener ugc nofollow" target="_blank"> 2 </a> ](帖子底部的引文)中也能找到。</p><p id="25fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们提出了一个用预测能力进行生存分析的概括。<strong class="lb iu">我们的目标是将起始时间和感兴趣的事件之间的经过时间建模为多重二进制分类问题</strong>。通过适当和简单的后处理，我们可以获得可靠和稳健的个体生存曲线。<strong class="lb iu">我们可以使用我们最喜欢的分类算法</strong>，像往常一样搜索参数，并考虑校准我们的结果的可能性，使它们更可信。</p><h1 id="0c9f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">数据</h1><p id="d287" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">安排我们处理的数据来实现一个生存预测应用程序是简单的，不需要特别的努力。我们必须有一些输入特征(数字或分类)和一个原始目标，就像在标准回归/分类表格任务中一样。在这种情况下，<strong class="lb iu">目标表示<em class="lv">从监控开始到事件发生</em> </strong>经过了多长时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/68da2121d42e546bfc2bf067086c8a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eEC7or5XmWObpjORtwfV7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事件时间网格(在左侧)。已排序的事件时间网格(在右侧)。[图片由作者提供]</p></figure><p id="ab5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们想象成为一家提供在线订阅服务的公司。我们可能对计算客户在订阅时的预期寿命感兴趣。换句话说，当一个新客户登陆我们的平台并订阅获取服务时，我们想知道她/他还会成为我们的客户多久。我们可以通过开发一种输出概率生存曲线(每个客户一条)的生存方法来完成这项任务。<strong class="lb iu">生存曲线是单调概率的序列</strong>。对于每个时间步，我们有 0 到 1 之间的数字，表示在特定时间范围内某些事件(在我们的例子中是订阅)的生存可能性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6a424dc644c9074b8339d01f026808e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*Pj8AbRVb3U1OQcr51k-kwg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生存函数的图形表示。[图片由作者提供]</p></figure><p id="7ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们模拟了一些数字输入特征和一个目标，该目标代表了从第一次订阅开始个人保持我们的客户的时间。从我们的模拟中，我们观察到大多数客户在参与后的第一阶段就离开了(下图的左侧)。对于大多数公司来说，这是一种可靠的动态，在这种情况下，很多客户会在一段时间后流失。相反，我们有一群忠实的订户，他们仍然是我们服务的用户(下图右侧)。在我们的例子中，我们将最大可观察订阅时间限制为 700 个周期(比如说几天)。为了使我们的方法有效，这个假设是强制性的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/f455b7432d0d7b1657afc118a0e22beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rfjhv8ZB5T3MbaMc.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">事件时间分布(左侧)。二进制标签比例(右侧)。[图片由作者提供]</p></figure><h1 id="c9a4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">建模</h1><p id="6a04" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们开始将离开时间宁滨成规则长度的组(箱)。对于分析中的每个客户，我们最终都有一个标准化的分类目标，其中几个唯一的类等于所创建的箱的数量。在这一点上，我们可以<strong class="lb iu">用一热编码转换目标，产生一个 0 和 1 的多维二进制目标</strong>。一个识别我们的客户离开的时间范围(离开箱子)。作为最后一步，我们必须在目标序列中，在“离开库”之前用左边的 1 替换 0。这最后一步很重要，它在准备建模的目标中提供了一个临时路径，其中零标识了客户所处的时间范围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/c8b029518774f951e17b56e1e6cb7310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FpBV-sLrkJuvPo8WoWkhIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一键编码入库事件时间(左侧)。累积独热编码入库事件时间(右侧)。[图片由作者提供]</p></figure><p id="5aae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经以正确的格式获得了所有需要的东西。我们有一组特性和一个多维二元目标。换句话说，我们只需解决一个多维二元分类任务。解决它的一种可能性在于使用本地 scikit-learn 方法(<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.multioutput.ClassifierChain.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">分类链</em> </a>)。</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="8b43" class="nc lx it my b be nd ne l nf ng">from sklearn.multioutput import ClassifierChain<br/>from sklearn.linear_model import LogisticRegression<br/><br/>model = ClassifierChain(<br/>  LogisticRegression(random_state=33, max_iter=2000), cv=5<br/>)<br/>model.fit(X_train, y_train)</span></pre><p id="6c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用分类器链，<strong class="lb iu">我们将多输出分类目标建模为独立但相关的二元分类任务</strong>。我们之所以说依赖，是因为上一步的输出与初始特征连接在一起，并用作链中下一次训练的输入。</p><p id="d4a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在训练阶段之后，我们以一组相关的二元分类器结束。它们中的每一个都提供了一个概率结果，这是构建最终个体生存曲线的一部分。概率肯定在 0 和 1 之间，但是不能保证生存函数的单调约束。换句话说，<strong class="lb iu">第一时间区间中的生存概率必须高于在随后的时间范围</strong>中获得的生存概率。为了满足这一要求，我们在客户级别对分类器链获得的概率进行后处理操作。</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="9c5b" class="nc lx it my b be nd ne l nf ng">from sklearn.isotonic import IsotonicRegression<br/>from joblib import Parallel, delayed<br/><br/>isoreg = IsotonicRegression(y_min=0, y_max=1, increasing=True)<br/>x = np.arange(0, n_bins)<br/><br/>proba = model.predict_proba(X_test)<br/><br/>proba = Parallel(n_jobs=-1, verbose=1)(<br/>    delayed(isoreg.fit_transform)(x, p) <br/>    for p in proba<br/>)<br/>proba = 1 - np.asarray(proba)</span></pre><p id="b5ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地<strong class="lb iu">对最终概率应用保序回归，我们获得单调生存曲线作为最终输出</strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/01e20537c97dd8d096b0fc85f07b138c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y8nh28jhFKZg8ud0.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预测生存曲线的样本。[图片由作者提供]</p></figure><p id="9c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以像在标准监督任务中一样，使用我们感兴趣的度量来测量误差。我们可以使用例如 Brier 评分或更标准的逻辑损失。</p><pre class="kj kk kl km gt mx my mz bn na nb bi"><span id="2890" class="nc lx it my b be nd ne l nf ng">from sklearn.metrics import brier_score_loss, log_loss<br/><br/>brier_scores = Parallel(n_jobs=-1, verbose=1)(<br/>  delayed(brier_score_loss)(true, pred, pos_label=1) <br/>  for true,pred in zip(y_test,proba)<br/>)<br/><br/>logloss_scores = Parallel(n_jobs=-1, verbose=1)(<br/>  delayed(log_loss)(true, pred, labels=[0,1]) <br/>  for true,pred in zip(y_test,proba)<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/7fbd60c06e02119e45bee5af3887046a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ej5O3Tn0XhTDGvFD.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试数据的 Brier 分数分布(左侧)。测试数据的对数损失分布(在右边)。[图片由作者提供]</p></figure><h1 id="f166" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="32e3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这篇文章中，我们介绍了一种简单有效的方法，用我们选择的标准机器学习分类器来生成生存曲线。我们发现，我们可以通过将观察到的失败时间建模为二元目标序列来预测存活曲线。通过简单的概率后处理，我们获得了可靠的概率输出。所提出的方法可以很容易地推广和应用于许多情况下(也考虑删截观察，如果他们的添加是合理的，以提供性能的改善)。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="346d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/cerlymarco/MEDIUM_NoteBook" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">查看我的 GITHUB 回购</strong> </a></p><p id="3725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持联系:<a class="ae ky" href="https://www.linkedin.com/in/marco-cerliani-b0bba714b/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h2 id="9089" class="np lx it bd ly nq nr dn mc ns nt dp mg li nu nv mi lm nw nx mk lq ny nz mm oa bi translated">参考</h2><p id="de6e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">[1]钟，c；和 Tibshirani，R. (arXiv 2019)。<a class="ae ky" href="https://arxiv.org/pdf/1909.11171.pdf" rel="noopener ugc nofollow" target="_blank">作为分类问题的生存分析</a>。</p><p id="098a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]余，陈正宁；格雷内尔河；林，香港中文大学；神经信息处理系统进展 24–2011 年第 25 届神经信息处理系统年会。<a class="ae ky" href="https://proceedings.neurips.cc/paper/2011/file/1019c8091693ef5c5f55970346633f92-Paper.pdf" rel="noopener ugc nofollow" target="_blank">将患者特异性癌症存活分布作为一系列相关回归变量进行学习</a>。</p></div></div>    
</body>
</html>