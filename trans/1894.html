<html>
<head>
<title>Understanding graph embeddings with Neo4j and Emblaze</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Neo4j和Emblaze理解图嵌入</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understanding-graph-embeddings-with-neo4j-and-emblaze-7e2d6ef56b8c#2022-05-02">https://towardsdatascience.com/understanding-graph-embeddings-with-neo4j-and-emblaze-7e2d6ef56b8c#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9652" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图嵌入可以将图中丰富的关系和属性网络表示为向量。这些嵌入向量对于比较节点是有用的，并且它们也是机器学习算法的有价值的输入。<a class="ae kl" href="https://neo4j.com/product/graph-data-science/" rel="noopener ugc nofollow" target="_blank"> Neo4j Graph Data Science </a>只使用几行Python代码就可以从图中导出嵌入。</p><p id="5eea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然使用Neo4j生成嵌入非常简单，但要判断您的应用程序是否有正确的嵌入并不容易。Neo4j提供了几种嵌入算法的选择，每种算法都有多个可调超参数。如何理解不同嵌入结果之间的差异，并为您的用例选择最佳嵌入？进入<a class="ae kl" href="https://github.com/cmudig/emblaze" rel="noopener ugc nofollow" target="_blank"> Emblaze </a>，这是一个由<a class="ae kl" href="https://dig.cmu.edu/" rel="noopener ugc nofollow" target="_blank">卡耐基梅隆大学数据交互小组</a>开发的JupyterLab小部件，它很好地支持了对数据集的多种嵌入选项的交互探索。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/db0816c0d8b13f8857ffc8d04513f525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hSyDgSlXOq1n5kdfUjRyNg.gif"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">Emblaze图形嵌入可视化和动画(图片由作者提供)</p></figure><p id="a489" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将为涉及机场和航线的数据集生成几种不同的图嵌入。然后，我们将使用Emblaze来可视化和比较嵌入结果。要完成这个实践教程，你需要一个免费的<a class="ae kl" href="https://sandbox.neo4j.com/" rel="noopener ugc nofollow" target="_blank"> Neo4j沙盒账户</a>和一个JupyterLab环境。您可以<a class="ae kl" href="https://jupyter.org/install" rel="noopener ugc nofollow" target="_blank">使用pip来安装JupyterLab </a>，或者<a class="ae kl" href="https://www.anaconda.com/" rel="noopener ugc nofollow" target="_blank">将其作为Anaconda </a>的一部分。具备这些先决条件后，您可以按照下面的视频和教程进行操作。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="lc ld l"/></div></figure><p id="7298" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">登录Neo4j沙盒并创建一个新项目。选择“图形数据科学”数据集，然后点击“创建”。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi le"><img src="../Images/a5b6ea22d9914dc9c6c09effe6574efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*-N3_VMDbcPxMCZpemO-ORw.png"/></div><p class="ky kz gj gh gi la lb bd b be z dk translated">选择Neo4j沙盒中的图形数据科学项目(图片由作者提供)</p></figure><p id="e1f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Graph Data Science沙盒附带安装的Graph Data Science库，以及预加载的机场和航线数据集。当沙盒启动时，您可以展开关于项目的信息以显示连接细节。记下密码和Bolt URL，供以后使用。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lf"><img src="../Images/c17d4f0a923661ba59213a1e80e51edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4kZejrgSz83iPinfH0kPmA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">沙盒中的连接详细信息(图片由作者提供)</p></figure><p id="b402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在GitHub上找到<a class="ae kl" href="https://github.com/smithna/blogs/blob/main/emblaze_demo/Airports_Emblaze.ipynb" rel="noopener ugc nofollow" target="_blank"> Airports_Emblaze.ipynb笔记本</a>。切换到“Raw”视图，然后从浏览器中保存文件。默认情况下，下载的文件将被命名为Airports_Emblaze.ipynb.txt，但将其重命名以删除“.”。txt "扩展名。启动JupyterLab，然后打开Airports_Emblaze.ipynb。</p><p id="d4d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还没有安装Emblaze和GraphDataScience Python库，您可以使用笔记本前两个单元中的命令来安装它们。</p><p id="7892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第四个笔记本单元格中，用Neo4j沙箱中的连接信息替换bolt_url和密码。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="daf4" class="ll lm iq lh b gy ln lo l lp lq">bolt_url = "bolt://44.198.160.170:7687"<br/>user = "neo4j"<br/>password = "specifications-lifeboats-jacket"<br/>gds = GraphDataScience(bolt_url, auth=(user, password))</span></pre><p id="ce0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们使用的是GraphDataScience包，这是用于Neo4j 的<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/python-client/" rel="noopener ugc nofollow" target="_blank">新数据科学Python客户端。如果你是一个有经验的Neo4j用户，笔记本中的语法看起来和你习惯的有点不同，这就是原因。</a></p><p id="b689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">data science沙盒的预加载数据集包含表示机场和地理分区的节点。连接<code class="fe lr ls lt lh b">Airport</code>节点的<code class="fe lr ls lt lh b">HAS_ROUTE</code>关系包括一个<code class="fe lr ls lt lh b">distance</code>属性，该属性告知机场之间的距离。我们希望将这一资产价值转化为一个<code class="fe lr ls lt lh b">weight</code>，反映距离较近的机场之间更强的关系。下面的密码应用了一个简单的线性变换，从所有路线的最大距离中减去一条路线的距离，再加上1。这样我们对<code class="fe lr ls lt lh b">weight</code>总是有正面的评价。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="0c9e" class="ll lm iq lh b gy ln lo l lp lq">gds.run_cypher("""<br/>match (:Airport)-[r:HAS_ROUTE]-&gt;(:Airport)<br/>with collect(r) as routes, max(r.distance) as maxDistance<br/>foreach(route in routes | set route.weight = maxDistance + 1 — route.distance)<br/>""")</span></pre><p id="84ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以随意尝试其他变换，这些变换会将距离值较小的路径分配给较高的权重。例如，您可以尝试对距离应用负指数。</p><p id="3d99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将创建一个内存中的图形投影，它包含<code class="fe lr ls lt lh b">Airport</code>节点和<code class="fe lr ls lt lh b">HAS_ROUTE</code>与它们的<code class="fe lr ls lt lh b">weight</code>属性的关系。我们将把<code class="fe lr ls lt lh b">HAS_ROUTE</code>关系视为无向关系。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="5239" class="ll lm iq lh b gy ln lo l lp lq">G_routes, result = gds.graph.project(<br/>   "air-routes", <br/>   "Airport",                                   <br/>   {"HAS_ROUTE":<br/>      {"orientation":"UNDIRECTED", <br/>      "aggregation":"MAX"}<br/>   }, <br/>   relationshipProperties = "weight")</span></pre><p id="779a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢运行<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/algorithms/wcc/" rel="noopener ugc nofollow" target="_blank">弱连接成分</a> (WCC)算法，作为我探索性数据分析过程的一部分。这将在图中查找连接的节点集。我们首先调用算法stats模式来快速查看组件大小的分布。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="54c3" class="ll lm iq lh b gy ln lo l lp lq">routes_wcc = gds.wcc.stats(G_routes)</span><span id="07c4" class="ll lm iq lh b gy lu lo l lp lq">routes_wcc['componentDistribution']</span><span id="3b54" class="ll lm iq lh b gy lu lo l lp lq">--------------------------------</span><span id="a7a0" class="ll lm iq lh b gy lu lo l lp lq">{'p99': 1,<br/> 'min': 1,<br/> 'max': 3292,<br/> 'mean': 16.52358490566038,<br/> 'p90': 1,<br/> 'p50': 1,<br/> 'p999': 3292,<br/> 'p95': 1,<br/> 'p75': 1}</span></pre><p id="291c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来我们有一个包含3292个<code class="fe lr ls lt lh b">Airport</code>节点的巨大连接组件，然后是一些包含单个<code class="fe lr ls lt lh b">Airport</code>节点的小组件。也许那些小部件代表的是不与商业航空航线相连的通用航空机场。出于演示的目的，我们只对作为巨型组件一部分的机场感兴趣。</p><p id="7d01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次运行WCC算法，但这次是在mutate模式下更新内存中的图形。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="0460" class="ll lm iq lh b gy ln lo l lp lq">gds.wcc.mutate(G_routes, mutateProperty = 'componentId')</span></pre><p id="5993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还想将WCC生成的<code class="fe lr ls lt lh b">componentId</code>属性写入磁盘上的持久图，这样我们就可以在GDS会话后引用它。我们运行<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/graph-catalog-node-ops/#catalog-graph-write-node-properties-example" rel="noopener ugc nofollow" target="_blank">GDS . graph . write node properties()</a>函数来实现这一点。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="be43" class="ll lm iq lh b gy ln lo l lp lq">gds.graph.writeNodeProperties(G_routes, ['componentId'])</span></pre><p id="96d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们运行一个cypher查询来获得与巨型组件相关联的<code class="fe lr ls lt lh b">componentId</code>。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="9976" class="ll lm iq lh b gy ln lo l lp lq">gds.run_cypher("MATCH (a:Airport) RETURN a.componentId as componentId, count(*) as nodeCount ORDER BY count(*) DESC limit 1")</span><span id="bb79" class="ll lm iq lh b gy lu lo l lp lq">componentId   nodeCount<br/>---------------------------<br/>0             3292</span></pre><p id="b373" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可以投影一个子图，它只包含具有巨型组件的<code class="fe lr ls lt lh b">componentId</code>的节点。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="9a10" class="ll lm iq lh b gy ln lo l lp lq">G_connected_airports, result = gds.beta.graph.project.subgraph("connected-airports", G_routes, "n.componentId = 0", "*")</span></pre><p id="cd1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们编写一个函数，为子图中的每个机场节点创建<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/machine-learning/node-embeddings/fastrp/" rel="noopener ugc nofollow" target="_blank">快速随机投影</a> (FastRP)嵌入。我为这个项目选择了FastRP嵌入，因为它运行非常快，即使在沙盒环境中也是如此。FastRP擅长表示节点周围的局部邻域。嵌入将被添加到内存中的图形投影中。如果我们对其中一个嵌入感到满意，我们可以稍后将嵌入向量的属性写入磁盘图形。</p><p id="c974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于算法的每次运行，我们将生成长度为64的嵌入向量，并且我们将使用45的随机种子。<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/machine-learning/node-embeddings/fastrp/#_embedding_dimension" rel="noopener ugc nofollow" target="_blank">嵌入维度</a>是一个可调参数，但是我们在这里将它保持稳定，以便我们可以检查其他参数的影响。我为这个数据集选择了64的嵌入维数，因为它相对较小且简单。您可以随意尝试更长或更短的嵌入尺寸。设置随机种子可以保持算法重复运行时的一致性。随机种子值45是一个任意的选择。我们还将传入一个字典，其中包含每个嵌入的特定参数。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="40fc" class="ll lm iq lh b gy ln lo l lp lq">def train_fast_rp(graph, config):<br/>    result = gds.fastRP.mutate(<br/>        graph,<br/>        embeddingDimension = 64,<br/>        randomSeed = 45,<br/>        **config<br/>    )<br/>    return result</span></pre><p id="fc7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将对属性<code class="fe lr ls lt lh b">iterationWeights</code>的三个不同值进行实验。<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/machine-learning/node-embeddings/fastrp/#_iteration_weights" rel="noopener ugc nofollow" target="_blank">该属性</a>包含应用于算法每次迭代的权重列表。随着每一次迭代，FastRP算法从正在计算嵌入的节点向前移动一步。短列表意味着算法迭代次数少，每个节点的嵌入仅受其最近邻居的影响。更长的列表意味着算法迭代更多次，并且每个节点的嵌入受到更远的邻居的影响。</p><p id="bba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还将比较在关系上使用<code class="fe lr ls lt lh b">weight</code>参数的嵌入和那些将图视为未加权的嵌入。总之，这将给我们六个嵌入探索。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="1311" class="ll lm iq lh b gy ln lo l lp lq">configs = [{"iterationWeights": [1.0, 1.0], <br/>            "mutateProperty": "shallowUnweighted"},<br/>           {"iterationWeights": [0.0, 1.0, 1.0], <br/>            "mutateProperty": "mediumUnweighted"},<br/>           {"iterationWeights": [1.0, 1.0, 1.0, 1.0], <br/>            "mutateProperty": "deepUnweighted"},<br/>           {"iterationWeights": [1.0, 1.0], <br/>            "relationshipWeightProperty": "weight", <br/>            "mutateProperty": "shallowWeighted"},<br/>           {"iterationWeights": [0.0, 1.0, 1.0], <br/>            "relationshipWeightProperty": "weight", <br/>            "mutateProperty": "mediumWeighted"},<br/>           {"iterationWeights": [1.0, 1.0, 1.0, 1.0], <br/>            "relationshipWeightProperty": "weight", <br/>            "mutateProperty": "deepWeighted"}]</span></pre><p id="0bc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们为六种配置中的每一种运行<code class="fe lr ls lt lh b">train_fast_rp</code>函数。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="a267" class="ll lm iq lh b gy ln lo l lp lq">embedding_results = [train_fast_rp(G_connected_airports, config) for config in configs]</span></pre><p id="08c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以运行一个Cypher语句，该语句将从内存图中流式传输嵌入结果。除了嵌入向量之外，我们将返回<code class="fe lr ls lt lh b">Airport</code>节点的一些属性，以及与每个<code class="fe lr ls lt lh b">Airport</code>相关联的<code class="fe lr ls lt lh b">Continent</code>的名称。我们将根据<code class="fe lr ls lt lh b">HAS_ROUTES</code>关系的数量对前900个<code class="fe lr ls lt lh b">Airports</code>进行采样。采样将加速Emblaze性能。它还从结果集中排除了一些非常小的机场，使那些不是机场或地理爱好者的人更容易理解结果。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="4a62" class="ll lm iq lh b gy ln lo l lp lq">embedding_df = gds.run_cypher("""<br/>    call gds.graph.streamNodeProperties("connected-airports", <br/>        ["shallowUnweighted", <br/>         "mediumUnweighted", <br/>         "deepUnweighted", <br/>         "shallowWeighted", <br/>         "mediumWeighted", <br/>         "deepWeighted"]) <br/>    yield nodeId, nodeProperty, propertyValue<br/>    WITH gds.util.asNode(nodeId) as a,<br/>    MAX(case when nodeProperty = "shallowUnweighted" then       <br/>           propertyValue end) as shallowUnweighted,<br/>    MAX(case when nodeProperty = "mediumUnweighted" then <br/>           propertyValue end) as mediumUnweighted,<br/>    MAX(case when nodeProperty = "deepUnweighted" then <br/>           propertyValue end) as deepUnweighted,<br/>    MAX(case when nodeProperty = "shallowWeighted" then <br/>           propertyValue end) as shallowWeighted,<br/>    MAX(case when nodeProperty = "mediumWeighted" then <br/>           propertyValue end) as mediumWeighted,<br/>    MAX(case when nodeProperty = "deepWeighted" then <br/>           propertyValue end) as deepWeighted<br/>    MATCH (a)-[:ON_CONTINENT]-&gt;(c:Continent)<br/>    RETURN<br/>    a.descr as airport_name, <br/>    a.iata as airport_code, <br/>    c.name as continent,<br/>    shallowUnweighted,<br/>    mediumUnweighted,<br/>    deepUnweighted,<br/>    shallowWeighted,<br/>    mediumWeighted,<br/>    deepWeighted<br/>    ORDER BY size([(a)-[:HAS_ROUTE]-() | a]) DESC<br/>    LIMIT 900<br/>    """)</span></pre><p id="dbfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将编写一个函数，该函数获取一列<code class="fe lr ls lt lh b">embedding_df</code> Pandas数据帧，并将其转换为一个<a class="ae kl" href="https://dig.cmu.edu/emblaze/emblaze/datasets.html#emblaze.datasets.Embedding" rel="noopener ugc nofollow" target="_blank"> Emblaze嵌入</a>。Emblaze嵌入将包含每个<code class="fe lr ls lt lh b">Airport</code>的点数。相关的<code class="fe lr ls lt lh b">Continent</code>会给这些点着色。我们将基于余弦相似性计算每个<code class="fe lr ls lt lh b">Airport</code>的十个最近邻。最近邻计算类似于Neo4j的图形数据科学库中的<a class="ae kl" href="https://neo4j.com/docs/graph-data-science/current/algorithms/knn/" rel="noopener ugc nofollow" target="_blank"> k最近邻</a>算法。最后，我们将使用Emblaze的默认<a class="ae kl" href="https://umap-learn.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> UMAP降维算法</a>将每个嵌入从64维空间投影到2维空间。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="a62a" class="ll lm iq lh b gy ln lo l lp lq">def create_emblaze_embedding(embedding_df, column):<br/>    emb = emblaze.Embedding({<br/>             emblaze.Field.POSITION:<br/>             np.array(list(embedding_df[column])),<br/>             emblaze.Field.COLOR: embedding_df['continent']}, <br/>             n_neighbors = 10,<br/>             label=column, <br/>             metric='cosine')<br/>    emb.compute_neighbors()<br/>    return emb.project()</span></pre><p id="0a41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们对<code class="fe lr ls lt lh b">embedding_df</code>数据帧中的最后六列运行<code class="fe lr ls lt lh b">create_emblaze_embedding</code>函数。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="4b49" class="ll lm iq lh b gy ln lo l lp lq">emblaze_embeddings = [create_emblaze_embedding(embedding_df, column)    <br/>   for column in embedding_df.columns[3:]]</span></pre><p id="cae5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将嵌入转换成一个<a class="ae kl" href="https://dig.cmu.edu/emblaze/emblaze/datasets.html#emblaze.datasets.EmbeddingSet" rel="noopener ugc nofollow" target="_blank"> Emblaze嵌入集</a>。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="6ca8" class="ll lm iq lh b gy ln lo l lp lq">variants = emblaze.EmbeddingSet(emblaze_embeddings)</span></pre><p id="50f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了<a class="ae kl" href="https://dig.cmu.edu/emblaze/emblaze/thumbnails.html" rel="noopener ugc nofollow" target="_blank">文本缩略图</a>，它们将作为工具提示出现在Emblaze embedding viewer中。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="fdb1" class="ll lm iq lh b gy ln lo l lp lq">thumbnails = emblaze.TextThumbnails(embedding_df['airport_name'] + <br/>   " (" + embedding_df['airport_code'] + ")")</span></pre><p id="a996" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们创建了<a class="ae kl" href="https://dig.cmu.edu/emblaze/emblaze/viewer.html" rel="noopener ugc nofollow" target="_blank"> Emblaze viewer </a>，并将其显示为一个JupyterLab小部件。</p><pre class="kn ko kp kq gt lg lh li lj aw lk bi"><span id="7d56" class="ll lm iq lh b gy ln lo l lp lq">w = emblaze.Viewer(embeddings = variants, thumbnails = thumbnails)<br/>w</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lv"><img src="../Images/84ef0280c7d7cd796e6a437dd550470b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JdUlIEB93es2v39YtczmAA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">Emblaze嵌入浏览器(图片由作者提供)</p></figure><p id="9487" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在小部件的左侧，我看到了我们创建的六个嵌入的缩略图。缩略图旁边的条形用颜色编码，表示哪些嵌入最相似。我看到共享<code class="fe lr ls lt lh b">iterationWeights</code>参数值的嵌入对比共享相同<code class="fe lr ls lt lh b">relationshipWeight</code>属性的三个嵌入的集合有更多相似的颜色。这表明在确定节点在嵌入空间中的最终位置时，改变<code class="fe lr ls lt lh b">iterationWeights</code>属性比改变<code class="fe lr ls lt lh b">relationshipWeight</code>属性具有更大的影响。</p><p id="3ebe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以单击其中一个缩略图生成线条，显示当前显示的嵌入和您单击的缩略图之间相对位置变化最大的点。第二次单击新嵌入可以看到从以前的视图到新嵌入的动画过渡。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lw"><img src="../Images/f787f594c4b598b6e7472051d6123fd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hctye--M-WO_PP-FxFPiDw.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">放大图片，看看欧洲机场从轻度超重到中度超重变化最大的是什么</p></figure><p id="dbd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在搜索框中输入机场代码。我输入“MCI”，这是我在堪萨斯城当地机场的代码。可视化缩放至所选机场及其在嵌入空间中的最近邻机场。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lx"><img src="../Images/26edccc233f7f6181ab6069c1cd861ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jO9IXwhlZ1cdtDaN3F1akA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">搜索单个机场(图片由作者提供)</p></figure><p id="11fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单击不同的嵌入缩略图，当您切换到新的嵌入时，“邻居”面板会显示堪萨斯城机场的哪些机场将被添加或减去为邻居。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ly"><img src="../Images/a9a9a2deea4fd594aa26b775e73caad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2kxq9-q_E3BsBwwBFoOmA.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">比较单个机场不同嵌入中的邻居节点(图片由作者提供)</p></figure><p id="87fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们探索一下中等加权嵌入和中等非加权嵌入之间的变化。单击可视化的空白区域以取消选择所有机场。然后，双击中等权重的缩略图。单击缩略图表示中等体重。单击右侧面板上方的“建议”按钮。Emblaze生成一组节点，这些节点的邻居发生了有趣的变化。单击“加载选择”获得其中一个建议。我选择了从墨尔本国际机场开始，包括澳大利亚、新西兰和新喀里多尼亚的六个机场。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lz"><img src="../Images/082ff402e7ea2a98e4694c407c046d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOc6Fba_gt9FzObU3PHUIQ.png"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">六个澳大利亚机场从加权到不加权嵌入的变化(图片由作者提供)</p></figure><p id="5d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在右侧的详细信息面板中，我可以看到从加权嵌入到非加权嵌入的变化导致所有六个机场都失去了Townsville Airport (TSV)作为嵌入空间中的近邻。在嵌入空间中作为近邻添加的机场，如斐济(NAN)和巴厘岛(DPS)在距离上更远，但它们比汤斯维尔有更多到我们正在检查的机场的两跳连接航班。</p><p id="6a63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Neo4j和Emblaze探索图形嵌入帮助加强了我对不同算法参数如何影响嵌入输出的直觉。我希望您在处理图形数据时会发现这些工具的组合很有用。</p></div></div>    
</body>
</html>