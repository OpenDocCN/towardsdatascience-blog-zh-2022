<html>
<head>
<title>Python Concurrency — Threading and the GIL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python并发性——线程和GIL</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-concurrency-threading-and-the-gil-db940596e325#2022-08-09">https://towardsdatascience.com/python-concurrency-threading-and-the-gil-db940596e325#2022-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7da2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python并发系列的第1部分。线程和GIL是Python中比较有争议的话题，但是大多数时候被误解了。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00fcb674f8e7d3bf92b13b399c046c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qUqd-ZTZJY5IIDRZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·安维克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2bb5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">浏览Python并发系列:</h1><p id="d278" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><em class="mu">接下来的故事:</em></p><div class="mv mw gp gr mx my"><a rel="noopener follow" target="_blank" href="/python-concurrency-multiprocessing-327c02544a5a"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Python并发性——多重处理</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Python并发系列的第2部分。多重处理模块使我们能够执行真正的并行任务。然而…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">towardsdatascience.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm ks my"/></div></div></a></div><div class="mv mw gp gr mx my"><a rel="noopener follow" target="_blank" href="/python-concurrency-concurrent-futures-15b56dc9a14d"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">Python并发性——concurrent . futures</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">Python并发系列的第3部分。多线程和多处理带来的界面简单性。</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">towardsdatascience.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm ks my"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="8807" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">有些人喜欢线程，但更多人讨厌线程。然而，在许多情况下，这种厌恶可能源于关于Python中线程工作方式的错误信息。是的，编写多线程应用程序可能很难看，我们必须非常小心以避免常见的陷阱。然而，在大多数情况下，<strong class="ma iu">多线程是在Python </strong>中实现并发的最简单的方式。</p><p id="a4b0" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">线程经常被比作多处理或异步编程。虽然这是有意义的，因为所有三种范式都实现了某种形式的并发，但在某些情况下，每种范式都比其他范式更有意义。无论何时有I/O，线程都应该被认为是一个可靠的选择，不要让错误的厌恶阻止了你。</p><p id="2b78" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated"><em class="mu"> Async </em>炒作多，那是肯定的。但是一旦你在代码中写了<code class="fe nt nu nv nw b">async def</code>，就没有回头路了。你必须全力以赴。你将穿过兔子洞，对你的应用程序进行一次大爆炸式的重写，把所有东西都改成<em class="mu">异步</em>。不总是最好的主意。</p><p id="f4a2" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">本系列将介绍Python中并发性的基础知识，以及我在那个时代遇到的见解。这样的事情我希望我在开始用Python做并发的时候就知道了，忽略它们导致了一些长期困扰代码的神秘bug。</p><p id="aedd" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">这个故事将解决线程和全局解释器锁(GIL)。希望在本系列的最后，您能给threads一个机会。如果幸运的话，您将不再认为GIL是Python中必须淘汰的烦人的东西。一旦我们理解了GIL是如何简化许多事情的，我们可能会开始从不同的角度看待它。</p><h2 id="1434" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">故事结构</h2><ul class=""><li id="b116" class="oj ok it ma b mb mc me mf mh ol ml om mp on mt oo op oq or bi translated">纺一根线</li><li id="a33a" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">守护进程</li><li id="b859" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">线程返回？？？行列</li><li id="a9e2" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">全局解释器锁(GIL)</li><li id="88d5" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">I/O和CPU绑定的线程</li><li id="aada" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">线程锁和线程安全</li><li id="9ab7" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated"><code class="fe nt nu nv nw b">join</code>方法</li><li id="78e1" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">关键要点</li></ul><h2 id="2950" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">纺一根线</h2><p id="8d34" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">线程模块不是Python中最受欢迎的模块之一。公平地说，它有点晦涩难懂。一开始就变得令人困惑的事情之一是创建线程的方式；等等，在Python中有两种创建线程的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="791d" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">在这种方法中，我们将一个函数传递给作为目标的<code class="fe nt nu nv nw b">Thread</code>对象(以及它的参数)。另一种方法是直接从<code class="fe nt nu nv nw b">Thread</code>类继承并实现<code class="fe nt nu nv nw b">run</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="d889" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">这明显违反了Python 的<a class="ae ky" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅。</a></p><blockquote class="oz"><p id="66b8" class="pa pb it bd pc pd pe pf pg ph pi mt dk translated">应该有一种——最好只有一种——显而易见的方法来做这件事。</p><p id="6521" class="pa pb it bd pc pd pe pf pg ph pi mt dk translated">PEP 20—Python的禅宗</p></blockquote><p id="94b5" class="pw-post-body-paragraph ly lz it ma b mb pj ju md me pk jx mg mh pl mj mk ml pm mn mo mp pn mr ms mt im bi translated">虽然从函数中运行线程可能更简单，但是当我们想要存储状态时，类方法是有用的。因此，在这种情况下，拥有两种方法并不是一个坏主意。</p><h2 id="83a6" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">守护进程</h2><p id="53d2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在操作系统级别，<em class="mu">守护进程</em>是后台进程，运行时不与用户交互。在Python线程的上下文中，守护进程只是后台线程。<strong class="ma iu">与普通线程的区别在于，当只有守护线程在运行</strong>时，程序会退出。换句话说，程序将等待正常线程完成(不取消)；一旦完成，所有正在运行的守护进程将被终止，程序将退出。</p><p id="3ae4" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">例如，考虑下面这个我们将用作线程目标的函数，它休眠了<code class="fe nt nu nv nw b">sleep_secs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="01d0" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">考虑两个线程，一个普通线程和一个守护进程，分别有20秒和10秒的睡眠时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><blockquote class="po pp pq"><p id="28f8" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">正常线程，休眠20秒:初始化<br/>守护线程，休眠10秒:初始化<br/>守护线程，休眠10秒:完成<br/>正常线程，休眠20秒:完成</p></blockquote><p id="4b45" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">守护进程在正常线程之前完成，程序等待正常线程完成。然而，如果我们改变睡眠时间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><blockquote class="po pp pq"><p id="cf9e" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">正常线程，休眠10秒:初始化<br/>守护线程，休眠20秒:初始化<br/>正常线程，休眠10秒:完成</p></blockquote><p id="2bd0" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">正常线程在守护进程之前完成，程序不等待守护进程就退出。</p><p id="ec7c" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">Python中的线程取消是不可能的，至少直接不可能；我们必须等待线程完成或实现另一个机制。有时，我们最终会得到一个因为一些流氓线程而拒绝退出的多线程程序，并且我们可能最终会在操作系统级别杀死这个进程。守护进程的作用就是避免这种令人头疼的问题。</p><h2 id="3180" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">线程返回？？？行列</h2><p id="fca7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">线程的主要问题是如何返回函数的结果并不明显。虽然我们可能希望传递这样一个函数作为线程的目标:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="794c" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">然而，线程对象并不公开从其目标返回某些内容的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="41cd" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">虽然Python的异步协同例程使用线程实现了常规函数的返回，但人们必须发挥创造力。这种行为可能会阻止您在应用中使用多线程。但是不要烦恼；我们可以使用队列(<code class="fe nt nu nv nw b">queue.Queue</code>)来提取结果。</p><p id="4db3" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">我们可以在模块级别定义队列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><blockquote class="po pp pq"><p id="590d" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">线程正在工作…</p><p id="ddb2" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">线程正在工作…来自队列的函数结果</p></blockquote><p id="0090" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">或者，我最喜欢的是，将一个队列作为参数(<code class="fe nt nu nv nw b">q_out</code>)传递给线程函数，并将结果存储在那里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><blockquote class="po pp pq"><p id="f329" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">线程正在工作…</p><p id="3c80" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">线程正在工作…来自队列的函数结果</p></blockquote><p id="4380" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">这种队列方法也适用于永远运行的守护进程或线程。我知道这并不理想，尤其是在我们有许多线程和它们的队列的情况下，但是在较小的规模下这并不麻烦。</p><h2 id="e0d4" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">全局解释器锁(GIL)</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/b5de8fb677dac402cbc09ee2d11ca307.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/format:webp/1*QP9RH5xdbhZJQTj431w2zQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多线程和GIL概念图。</p></figure><p id="d378" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">与您可能听说的相反，Python使用实际的OS线程(Unix上的POSIX线程和Windows线程)。Python是多线程的。你可能也听说过Python不能同时运行多个线程；这是真的。</p><p id="4784" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">早在90年代初，Python解释器(CPython，最常用的一个)的多线程和内存管理就有问题。CPython引用计数(内存管理)在比赛条件下遇到了麻烦。多个线程修改了程序中对象被引用的次数；偶尔，由于比赛条件，计数是错误的。</p><p id="aaca" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">有时候，在应该计数的时候，计数从来没有达到0；内存从未被释放；内存泄漏。在其他情况下，计数在不应该的时候达到了0；该对象在不应该的时候被从内存中释放；程序崩溃了。</p><p id="5827" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">这个问题的解决方案是GIL，一个在解释器级别实现的锁，以避免线程同时运行，确保引用计数在程序的生命周期内是正确的。</p><p id="acac" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">GIL尽最大努力为所有活动线程提供时间，即使线程没有显式释放GIL。线程在休眠(<code class="fe nt nu nv nw b">time.sleep</code>)或执行I/O时释放GIL。但是，如果一段时间过去了，线程还没有“自愿”释放GIL，它将被迫这样做，从而给其他线程运行的机会。这个选择过程并不总是最佳的。</p><p id="5a0b" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">今天，对Python的一个主要批评是，它不是多线程的，并且不能(本机)利用多核等等。大多数人指责GIL。然而，GIL是一个简单而优雅的解决方案，它赋予了Python最珍贵的品质之一——简单，尤其是在内存管理方面。任何用C++做过内存管理的人，无疑都能体会到Python的简单。</p><p id="a0f3" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">GIL并不完美，但它让多线程变得非常简单且相对安全。主要问题是:</p><ul class=""><li id="cad9" class="oj ok it ma b mb no me np mh pv ml pw mp px mt oo op oq or bi translated">GIL和操作系统不协调。有时，操作系统可能会将CPU时间给不持有GIL的线程，反之亦然。</li><li id="9912" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">如果发生事件，I/O线程将发送一个GIL丢弃请求，并启动一个超时周期(5毫秒)，从而导致额外的延迟。</li><li id="541c" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">GIL将给予CPU绑定的线程更高的优先级。因此，给I/O线程增加了不希望的延迟。</li></ul><p id="2032" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">如果你想更多地了解GIL及其局限性，请查看大卫·比兹利的这篇精彩的<a class="ae ky" href="https://www.youtube.com/watch?v=Obt-vMVdM8s&amp;t=1771s" rel="noopener ugc nofollow" target="_blank">主题演讲</a>。</p><h2 id="2554" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">I/O和CPU绑定的线程</h2><p id="eec7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">本节将分析套接字服务器(I/O)线程在与CPU绑定的线程竞争GIL时会发生什么。编写服务器应用程序时，最重要的是以最小的延迟确认客户端请求。只要客户端知道其请求正在被处理，请求本身就可能需要更长时间。因此，了解多线程套接字服务器在与CPU密集型线程竞争时的行为是至关重要的。</p><p id="7c68" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">下面的代码实现了:</p><ul class=""><li id="433e" class="oj ok it ma b mb no me np mh pv ml pw mp px mt oo op oq or bi translated">一个简单的服务器(<code class="fe nt nu nv nw b">echo_server</code>)，它在给定的端口发送回它接收到的任何东西，一个echo服务器。</li><li id="96dc" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">另一个函数执行CPU相关的任务(<code class="fe nt nu nv nw b">hammer_cpu</code>)。</li><li id="70de" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">一切都储存在<code class="fe nt nu nv nw b">time_data</code>字典里。</li><li id="0620" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">当程序退出时(控制c或socket客户端断开)，数据被保存到一个文件中(<code class="fe nt nu nv nw b">save_time_data_to_file</code>)。为了捕捉退出信号，我们使用了<em class="mu"> atexit </em>模块。</li><li id="a18d" class="oj ok it ma b mb os me ot mh ou ml ov mp ow mt oo op oq or bi translated">最后，主函数启动线程；我们将所需的CPU线程数作为参数传递。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="523e" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">要运行服务器，请执行以下操作:</p><p id="47be" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated"><code class="fe nt nu nv nw b">$ python [server script name].py [experiment_name] [number of CPU-bound threads]</code></p><p id="0970" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">客户端是单线程的；它还存储数据，并在退出时保存。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="f7f0" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">要运行客户端:</p><p id="fb22" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated"><code class="fe nt nu nv nw b">$ python [client script name].py [experiment_name]</code></p><p id="1e5e" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">以下是发送到服务器的消息的接收时间图，分别对应于无CPU绑定线程、1个、2个和3个CPU绑定线程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi py"><img src="../Images/8a513ea410c4d59b0d2385b961215c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3MjQ4DsD6qmgiOeU3_Ibw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Echo客户端接收时间[图片由作者提供]。</p></figure><p id="d129" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">我们可以看到，随着CPU绑定线程数量的增加，不仅平均套接字响应时间会增加，而且它们的标准偏差也会增加。因此，echo服务器变得更加不稳定。这是GIL和操作系统不太协调的一个例子。请记住，在发生事件的情况下，I/O线程将请求GIL，但即使它得到了，操作系统也可能决定运行另一个不持有GIL的CPU绑定线程。</p><h2 id="01a1" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">线程锁和线程安全</h2><p id="a7f8" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">尽管有些人迫不及待地想让Python“放弃”GIL，但GIL让多线程编程变得尽可能简单。只要操作是<a class="ae ky" href="https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe" rel="noopener ugc nofollow" target="_blank">原子的</a>，即<a class="ae ky" href="https://docs.python.org/3/faq/library.html#what-kinds-of-global-value-mutation-are-thread-safe" rel="noopener ugc nofollow" target="_blank">线程安全的</a>，GIL将确保没有竞争条件。换句话说，由于GIL，没有两个操作会同时执行。</p><p id="6520" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">然而，大多数时候，我们希望进行非原子的操作，如果多线程没有正确完成，我们会遇到麻烦。考虑下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="c0f4" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">有一个线程(<code class="fe nt nu nv nw b">check_cache</code>)遍历<code class="fe nt nu nv nw b">my_cache </code>的元素，而另一个线程(<code class="fe nt nu nv nw b">add_to_cache</code>)则添加项目。迭代不是原子的。所以我们会得到一个异常:</p><blockquote class="po pp pq"><p id="21fd" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">"运行时错误:字典在迭代过程中改变了大小."</p></blockquote><p id="cb06" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">这个问题的解决方案是显式地使用线程锁。在下面的例子中，我们使用来自<em class="mu">线程</em>模块的<code class="fe nt nu nv nw b">Lock</code>对象。我们只有在获得锁的情况下才能对<code class="fe nt nu nv nw b">my_cache</code>进行操作；现在程序正常运行了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="1bc9" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">所以多线程的关键是问自己:</p><blockquote class="po pp pq"><p id="c49e" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">我使用的对象和执行的操作是线程安全的吗？</p></blockquote><p id="142b" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">如果没有，使用<code class="fe nt nu nv nw b">Lock</code>。线程安全问题不仅仅是程序崩溃，如果不解决，我们可能会遇到各种各样的错误。我们可能会弄错库存、账户余额等等。</p><h2 id="bd83" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">连接方法</h2><p id="a57a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><a class="ae ky" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank"> <em class="mu">线程</em> </a>模块为多线程应用程序实现各种同步原语和实用程序。你可能需要的一切都会在那里找到。例如信号量、锁(前面讨论过的)和许多其他的。它还实现了处理线程的方法；我们不会一一介绍，只介绍一个:迄今为止我们还没有讨论过的最重要的方法<code class="fe nt nu nv nw b">join</code>方法。</p><p id="6c81" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">当我们<code class="fe nt nu nv nw b">start</code>一个线程时，它不会阻塞。程序将继续执行下面的代码行，而不会等待线程完成。大多数时候这种行为恰恰是我们想要的；守护进程就是一个很好的例子；我们开火然后忘记。但是有时候，我们需要等待一个线程。在这种情况下，我们使用<code class="fe nt nu nv nw b">join</code>方法。</p><p id="f021" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">考虑下面的代码片段和打印顺序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><blockquote class="po pp pq"><p id="bc81" class="ly lz mu ma b mb no ju md me np jx mg pr nq mj mk ps nr mn mo pt ns mr ms mt im bi translated">线程函数init <br/>线程开始<br/>等待线程… <br/>线程函数循环完成<br/>线程完成</p></blockquote><p id="adc8" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated"><code class="fe nt nu nv nw b">join</code>方法让程序在打印“等待线程”后等待(10秒钟)</p><p id="6532" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">多线程应用的构建模块是使用队列和锁来连接线程。因此，我们必须彻底理解它们，以避免错误和重大错误。线程的特点是大多数潜在的异常都是隐藏的，直到最糟糕的时刻才会出现。</p><h2 id="2618" class="nx lh it bd li ny nz dn lm oa ob dp lq mh oc od ls ml oe of lu mp og oh lw oi bi translated">关键要点</h2><p id="5144" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">线程是实现并发的一种简单方式。我们不需要事件循环、时髦的函数定义，也不需要生成额外的进程并与之通信。我们可以坚持Python基础，实现并发性。既然我们已经知道了GIL和线程同步与通信的基础知识，我们就可以着手多线程编程了。</p><p id="0e2b" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">主要的收获是线程对I/O有意义，而不是CPU受限的任务。每当有CPU线程时，操作系统和GIL之间缺乏协调就会变得更加明显。如果您需要进行CPU密集型计算，请尝试多处理或以下技巧:到处添加一些<code class="fe nt nu nv nw b">time.sleep</code>,以便CPU绑定的线程释放GIL，让I/O线程完成它们的工作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="00ce" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated">我希望这个故事对你有用。 <a class="ae ky" href="https://medium.com/subscribe/@diego-barba" rel="noopener"> <em class="mu">订阅</em> </a> <em class="mu">到我的邮件列表如果你想知道更多这样的故事。</em></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="9016" class="pw-post-body-paragraph ly lz it ma b mb no ju md me np jx mg mh nq mj mk ml nr mn mo mp ns mr ms mt im bi translated"><em class="mu">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</em></p><div class="mv mw gp gr mx my"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">阅读迭戈·巴尔巴(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">medium.com</p></div></div><div class="nh l"><div class="pz l nj nk nl nh nm ks my"/></div></div></a></div></div></div>    
</body>
</html>