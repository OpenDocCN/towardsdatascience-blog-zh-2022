<html>
<head>
<title>Maximum Subarray Sum Using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 SQL 的最大子数组和</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/maximum-subarray-sum-using-sql-e1befa75d055#2022-12-23">https://towardsdatascience.com/maximum-subarray-sum-using-sql-e1befa75d055#2022-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0869" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何用声明式查询语言实现解决方案</h2></div><p id="40f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最大和子数组和问题要求你找出整数数组中元素和最大的那个子数组。这是一个流行的计算机科学编程问题，通常用命令式编程语言(如 C++、Java、Python 等)来解决。然而，看看如何在声明式查询语言(如 SQL)中实现它是很有趣的。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1fe0f675c32b205e37e7c3706adacbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hEmdWe3yWR4u1zgc"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae lr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="42f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这是尝试使用声明性 SQL 语法解决传统编程问题的一系列文章中的第一篇。为什么？因为好玩！</p><h1 id="743b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">问题陈述</h1><p id="7353" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">给定一个整数数组，找出具有最大元素和的整数连续子数组(至少有一个来自原始数组的元素)。</p><p id="c4d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题的讨论可以在很多地方找到，包括:</p><ol class=""><li id="fa4b" class="mp mq iq kh b ki kj kl km ko mr ks ms kw mt la mu mv mw mx bi translated"><a class="ae lr" href="https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/" rel="noopener ugc nofollow" target="_blank">极客之福</a></li><li id="ddd4" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://www.guru99.com/largest-sum-contiguous-subarray.html" rel="noopener ugc nofollow" target="_blank"> guru99 </a></li><li id="e4d5" class="mp mq iq kh b ki my kl mz ko na ks nb kw nc la mu mv mw mx bi translated"><a class="ae lr" href="https://www.scaler.com/topics/kadanes-algorithm/" rel="noopener ugc nofollow" target="_blank">定标器</a></li></ol><p id="0ac9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面所有的链接都讨论了传统编程语言的 O(n)时间实现。然而，我们着眼于完全用 SQL 构建一个 O(n)时间的解决方案(没有任何过程扩展)。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="898d" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">输入表模式</h1><pre class="lc ld le lf gt np nq nr bn ns nt bi"><span id="a23d" class="nu lt iq nq b be nv nw l nx ny">CREATE TABLE array_data(index SERIAL PRIMARY KEY, value INTEGER NOT NULL);<br/><br/>INSERT INTO array_data(value)<br/>VALUES(2), (4), (-3), (0), (-7), (4), (1), (-2), (7), (3), (1), (-6), (3);</span></pre><pre class="nz np nq nr bn ns nt bi"><span id="4797" class="nu lt iq nq b be nv nw l nx ny">SELECT * FROM array_data;</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6c33cfc7d90ac5db330b36344e52f720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*Ron875Wn2SsfEb7_ukQ_sw.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">表 array_data 的内容(图片由作者提供)</p></figure></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="4312" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">第一种解决方案:O(n)</h1><p id="5562" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">显而易见的第一种解决方案是生成子数组可以拥有的每一对有效索引(这是 O(n ),因为每个索引都与其后的一个索引成对出现),然后对于每一对索引，计算该范围内的值的总和。</p><p id="7f0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">计算总和需要输入(每对索引)的线性时间，因此该解决方案的总成本为 O(n)</p><pre class="lc ld le lf gt np nq nr bn ns nt bi"><span id="f7d2" class="nu lt iq nq b be nv nw l nx ny">WITH all_pair_sums AS (<br/>  SELECT<br/>    lhs.index AS begin_idx,<br/>    rhs.index AS end_idx,<br/>    SUM(for_values.value) AS array_sum<br/>  FROM<br/>    array_data lhs INNER JOIN array_data rhs<br/>  ON lhs.index &lt;= rhs.index<br/>  INNER JOIN array_data for_values<br/>  ON for_values.index BETWEEN lhs.index AND rhs.index<br/>  GROUP BY 1, 2<br/>  ORDER BY lhs.index ASC, rhs.index ASC<br/>)<br/><br/>SELECT * FROM all_pair_sums<br/>WHERE array_sum = (SELECT MAX(array_sum) FROM all_pair_sums);</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/602f82dc11840819a32af0f535d83781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*kXuZIcIxNeFYGU8nIExXig.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">SQL 中 O(n)解的结果(图片由作者提供)</p></figure><p id="7184" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">估计成本:</strong>对于一个 13 行的输入表，这个查询的估计成本(根据解释)是<a class="ae lr" href="https://explain.depesz.com/s/B2Gy" rel="noopener ugc nofollow" target="_blank"> 108M </a>。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="6479" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">第二种解决方案:O(n)</h1><p id="a93e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们可以执行的第一个优化是避免从给定的数组索引(begin_idx)开始重复计算每个数组的。相反，我们可以为从给定索引开始的每个子阵列维护一个运行总和。</p><p id="0c24" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这需要使用<a class="ae lr" href="https://www.postgresql.org/docs/current/tutorial-window.html" rel="noopener ugc nofollow" target="_blank">窗口函数</a>，并且将成本降低到 O(n)，因为我们正在处理它之前的每个数组索引的每个索引。</p><pre class="lc ld le lf gt np nq nr bn ns nt bi"><span id="3d4f" class="nu lt iq nq b be nv nw l nx ny">WITH all_pair_sums AS (<br/>  SELECT<br/>    lhs.index AS begin_idx,<br/>    rhs.index AS end_idx,<br/>    SUM(rhs.value) OVER (PARTITION BY lhs.index ORDER BY rhs.index ASC) AS array_sum<br/>  FROM<br/>    array_data lhs INNER JOIN array_data rhs<br/>  ON lhs.index &lt;= rhs.index<br/>  ORDER BY lhs.index ASC, rhs.index ASC<br/>),<br/><br/>with_max AS (<br/>  SELECT<br/>    begin_idx,<br/>    end_idx,<br/>    array_sum,<br/>    MAX(array_sum) OVER() AS max_subarray_sum<br/>  FROM all_pair_sums<br/>)<br/><br/>SELECT begin_idx, end_idx, array_sum<br/>FROM with_max<br/>WHERE array_sum = max_subarray_sum;</span></pre><p id="41bd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，<strong class="kh ir"> array_sum </strong>列存储从索引<strong class="kh ir"> begin_idx </strong>开始到<strong class="kh ir"> end_idx </strong>结束的数组的运行总和。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/602f82dc11840819a32af0f535d83781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*kXuZIcIxNeFYGU8nIExXig.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">SQL 中 O(n)解的结果(图片由作者提供)</p></figure><p id="1bcc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">估计成本:</strong>这个查询在一个 13 行的输入表上的估计成本(根据解释)是<a class="ae lr" href="https://explain.depesz.com/s/cZU0" rel="noopener ugc nofollow" target="_blank"> 371k </a>。与之前的方法相比，减少了 99.65%。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="e8db" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">第三种解决方案:O(n)</h1><p id="b8bf" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">观察:要找到从索引 I 开始到索引 j 结束的子数组的和，我们可以找到子数组[0..j]并从中减去子阵列[0..i-1]。换言之，<strong class="kh ir"> sum[i..j] = sum[0..j] — sum[0..i-1] </strong>。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/83ff53e85a7b8ccb1df18f5499f4a24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*KVAq3OmvdpKl7c6e98iQRA.png"/></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">索引为[2]的子阵列元素之和..9]通过执行 sum([0..9]) — sum([0..1])(图片由作者提供)</p></figure><p id="3379" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的列<strong class="kh ir"> array_sum </strong>存储子数组<strong class="kh ir">[0]的元素总和的值..【begin _ idx】。</strong></p><p id="34ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个解决方案的最终代码如下所示。</p><pre class="lc ld le lf gt np nq nr bn ns nt bi"><span id="6cef" class="nu lt iq nq b be nv nw l nx ny">WITH running_sum AS (<br/>  SELECT<br/>    index AS begin_idx,<br/>    value,<br/>    SUM(value) OVER (ORDER BY index ASC) AS array_sum<br/>  FROM<br/>    (SELECT 0 AS index, 0 AS value<br/>     UNION ALL<br/>     SELECT * FROM array_data<br/>    ) AS temp<br/>  ORDER BY index ASC<br/>),<br/><br/>running_sum_with_min AS (<br/>  SELECT<br/>    begin_idx,<br/>    value,<br/>    array_sum,<br/>    MIN(array_sum) OVER(ORDER BY begin_idx ASC) AS min_sum_so_far<br/>  FROM running_sum<br/>),<br/><br/>sum_of_subarray AS (<br/>  SELECT<br/>    begin_idx,<br/>    value,<br/>    array_sum,<br/>    min_sum_so_far,<br/>    array_sum - LAG(min_sum_so_far, 1) OVER(ORDER BY begin_idx ASC) AS subarray_sum<br/>  FROM running_sum_with_min<br/>),<br/><br/>max_sum_of_subarray AS (<br/>  SELECT<br/>    begin_idx,<br/>    value,<br/>    array_sum,<br/>    min_sum_so_far,<br/>    subarray_sum,<br/>    MAX(subarray_sum) OVER() AS max_subarray_sum<br/>  FROM sum_of_subarray<br/>)<br/><br/>SELECT *<br/>FROM max_sum_of_subarray<br/>WHERE subarray_sum = max_subarray_sum;</span></pre><p id="ce12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果打印中间表<strong class="kh ir"> max_sum_of_subarray </strong>，就是这个样子。以红色突出显示的行是保存具有最大总和的连续子数组的值的行。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi od"><img src="../Images/63831d65833e01cc235c7b92c0a3fc9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PU4Zk1hUw7cPMkiGvRn4g.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">max_sum_of_subarray 表(图片由作者提供)</p></figure><p id="f2fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种解决方案的一个缺点是，虽然我们有结束索引，但我们没有开始索引。通过在中间表上运行另一个查询来搜索值-4 的第一次出现，可以很容易地获取这个值。</p><p id="9616" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个子数组是索引[6..11].这个子数组中元素之和的值是 10 — (-4) =14。</p><p id="3577" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们插入了一个带有(index，value) = (0，0)的虚拟行，以确保第一个有效行(即 index = 1 的行)的延迟操作不会最终生成空值，从而导致不正确的结果。</p><p id="f6db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">估计成本:</strong>对于一个 13 行的输入表，这个查询的估计成本(根据解释)是<a class="ae lr" href="https://explain.depesz.com/s/cfeg" rel="noopener ugc nofollow" target="_blank"> 695 </a>。与第一种方法相比减少了 99.99%，与第二种方法相比减少了 99.81%。</p><h2 id="9b3f" class="oe lt iq bd lu of og dn ly oh oi dp mc ko oj ok me ks ol om mg kw on oo mi op bi translated">尽管在这个解决方案的 SQL 中的多个 cte 中有一个 ORDER BY 子句，为什么这个解决方案被称为 O(n)？</h2><p id="1854" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">原始输入表的<strong class="kh ir">索引</strong>列是主键列(因此是唯一的)。PostgreSQL 的默认索引类型是 B 树，允许进行排序的全表扫描，这是我们在本解决方案的所有 cte 中基本上正在做的事情。因此，我们希望优化器会注意到这一点(加上中间表也是经过排序的),并完全避免排序操作。即使无法推导出这一点，运行时间回归到<strong class="kh ir"> O(n log n) </strong>，但不会比这更差。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="ffbe" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">SQL 小提琴</h1><p id="45e1" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">这篇文章中所有解决方案的 SQL 链接可以在<a class="ae lr" href="http://sqlfiddle.com/#!17/b0eb547/8" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="06eb" class="ls lt iq bd lu lv nk lx ly lz nl mb mc jw nm jx me jz nn ka mg kc no kd mi mj bi translated">结论</h1><p id="3d3e" class="pw-post-body-paragraph kf kg iq kh b ki mk jr kk kl ml ju kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们看到了用 SQL 解决同一问题的多种方法，效率各不相同。尽管最后一个解决方案拥有最多的代码，但它在运行时间和 CPU 利用率方面是最高效的。将解决方案分解成更小的 cte 有助于代码的可读性和可维护性。</p><p id="da35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想看到更多的使用声明性 SQL 语法解决的常规编程问题，请添加评论，如果可能的话，我会尽力去做，或者写下为什么很难做到。</p></div></div>    
</body>
</html>