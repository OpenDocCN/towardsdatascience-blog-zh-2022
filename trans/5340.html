<html>
<head>
<title>Artificial Intelligence for Geospatial Analysis with Pytorch’s TorchGeo (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Pytorch 的 TorchGeo 进行地理空间分析的人工智能(第 2 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/artificial-intelligence-for-geospatial-analysis-with-pytorchs-torchgeo-part-2-ec3785fae284#2022-11-30">https://towardsdatascience.com/artificial-intelligence-for-geospatial-analysis-with-pytorchs-torchgeo-part-2-ec3785fae284#2022-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0de4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Pytorch 和 TorchGeo 包的端到端深度学习地理空间分割项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a58cf344e1883cd726445e8a9df45c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MMz-EotiFIIUgDB0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄</p></figure><h1 id="e47c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="2fb3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在前面的故事中(第 1 部分—这里是)，我们看到了如何使用 TorchGeo 创建一个<code class="fe mn mo mp mq b">RasterDataset </code>并使用一个<code class="fe mn mo mp mq b">RandomSampler </code>从中绘制补丁。在当前的故事中，我们进一步将图像和遮罩连接成一个<code class="fe mn mo mp mq b">IntersectionDataset</code>，用训练补丁(图像)和相应的标签(水遮罩)绘制元组。</p><p id="377f" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">所以让我们开始吧。</p><h1 id="b012" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据集</h1><p id="148e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将复制前面故事中的代码，只是为了在 Colab 中准备好环境。在此之后，我们将遵循与创建图像的<code class="fe mn mo mp mq b">RasterDataset </code>相同的过程，为遮罩创建数据集。我们需要注意的一点是通知<code class="fe mn mo mp mq b">RasterDataset </code>班，我们的面具不是“图像”。这样，当从掩膜数据集中提取样本时，它将返回带有“掩膜”键的数据，而不是通常在图像中使用的“图像”键。请注意，从我们的要点输出的代码显示了每个示例的键。</p><blockquote class="mw mx my"><p id="134c" class="lr ls mz lt b lu mr ju lw lx ms jx lz na mt mc md nb mu mg mh nc mv mk ml mm im bi translated">OBS:与前一个故事的另一个不同之处是，我们将一个转换函数传递给图像数据集，以将值正确地缩放为反射率值(除以 10，000)。</p></blockquote><p id="1320" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">此外，我们可以检查边界框是否相同，因此两个样本来自相同的地理区域。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1dd5" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">一旦我们设置了两个数据集(图像和掩膜)，我们就可以以一种非常方便的方式将两者结合起来，就像这样:</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="55e1" class="nj la it mq b be nk nl l nm nn">train_dset = train_imgs &amp; train_msks</span></pre><p id="3916" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，当我们从这个新的数据集中提取样本时，产生的目录应该有一个包含图像数据(已经缩放了 10，000)的条目和一个包含遮罩的条目。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="53bf" class="nj la it mq b be nk nl l nm nn">sample = train_dset[bbox]<br/>sample.keys()<br/><br/>output:<br/>dict_keys(['image', 'crs', 'bbox', 'mask'])</span></pre><h1 id="e9b0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据加载器</h1><p id="1401" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在 TorchGeo 中创建一个<code class="fe mn mo mp mq b">DataLoader </code>非常简单，就像用 Pytorch 一样(我们实际上使用的是同一个类)。请注意，我们还使用了已经定义的同一个采样器。此外，我们通知 dataloader 将用来提取数据的数据集、batch_size(每个批次中的样本数)和 collate 函数，该函数指定如何将多个样本“连接”成一个批次。</p><p id="11b6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">最后，我们可以通过 dataloader 进行迭代，从中获取批处理。为了测试它，我们将得到第一批。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="76b5" class="nj la it mq b be nk nl l nm nn">dataloader = DataLoader(dset_train, sampler=sampler, batch_size=8, collate_fn=stack_samples)<br/>batch = next(iter(dataloader))<br/>batch.keys()<br/><br/>output:<br/>dict_keys(['image', 'crs', 'bbox', 'mask'])</span></pre><h1 id="662c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">批量可视化</h1><p id="e7db" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们可以从数据集中提取批次，那么让我们创建一个函数来显示批次。</p><p id="a95b" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">函数 plot_batch 将自动检查批次中的项目数量，以及是否有相关的掩码来相应地排列输出网格。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="2d97" class="nj la it mq b be nk nl l nm nn">from typing import Iterable, List<br/>import torch<br/><br/>def plot_imgs(images: Iterable, axs: Iterable, chnls: List[int] = [2, 1, 0], bright: float = 3.):<br/>    for img, ax in zip(images, axs):<br/>        arr = torch.clamp(bright * img, min=0, max=1).numpy()<br/>        rgb = arr.transpose(1, 2, 0)[:, :, chnls]<br/>        ax.imshow(rgb)<br/>        ax.axis('off')<br/><br/><br/>def plot_msks(masks: Iterable, axs: Iterable):<br/>    for mask, ax in zip(masks, axs):<br/>        ax.imshow(mask.squeeze().numpy(), cmap='Blues')<br/>        ax.axis('off')<br/><br/>def plot_batch(batch: dict, bright: float = 3., cols: int = 4, width: int = 5, chnls: List[int] = [2, 1, 0]):<br/><br/>    # Get the samples and the number of items in the batch<br/>    samples = unbind_samples(batch.copy())<br/>    <br/>    # if batch contains images and masks, the number of images will be doubled<br/>    n = 2 * len(samples) if ('image' in batch) and ('mask' in batch) else len(samples)<br/><br/>    # calculate the number of rows in the grid<br/>    rows = n//cols + (1 if n%cols != 0 else 0)<br/><br/>    # create a grid<br/>    _, axs = plt.subplots(rows, cols, figsize=(cols*width, rows*width))  <br/><br/>    if ('image' in batch) and ('mask' in batch):<br/>        # plot the images on the even axis<br/>        plot_imgs(images=map(lambda x: x['image'], samples), axs=axs.reshape(-1)[::2], chnls=chnls, bright=bright) #type: ignore<br/><br/>        # plot the masks on the odd axis<br/>        plot_msks(masks=map(lambda x: x['mask'], samples), axs=axs.reshape(-1)[1::2]) #type: ignore<br/><br/>    else:<br/><br/>        if 'image' in batch:<br/>            plot_imgs(images=map(lambda x: x['image'], samples), axs=axs.reshape(-1), chnls=chnls, bright=bright) #type: ignore<br/>    <br/>        elif 'mask' in batch:<br/>            plot_msks(masks=map(lambda x: x['mask'], samples), axs=axs.reshape(-1)) #type: ignore</span></pre><p id="95dc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，绘制我们的批次:</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="bdf4" class="nj la it mq b be nk nl l nm nn">plot_batch(batch)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/aba595078ae180a2fe105eecff34e395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ii1JXS-5l4JatgjxHylNyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出:作者的图片。</p></figure><h1 id="0918" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据规范化(标准化)</h1><p id="21e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通常，机器学习方法(包括深度学习)受益于特征缩放。这意味着在 1 和零均值附近的标准偏差，通过应用以下公式(实际上归一化不同于标准化，但我将把解释留给读者:<a class="ae ky" href="https://www.naukri.com/learning/articles/normalization-and-standardization/" rel="noopener ugc nofollow" target="_blank">https://www . nau kri . com/learning/articles/normalization-and-standardization/</a>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/709a80fdc67abbe9fb85d7118e28858e.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*u9KCdUyaHD_7Dp-khHK6XA.png"/></div></figure><p id="5b5e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">为此，我们需要首先找到数据集中每个 6s 通道的平均值和标准差。</p><p id="cc44" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">让我们定义一个函数来计算这些统计数据，并将结果写入变量<code class="fe mn mo mp mq b">mean</code>和<code class="fe mn mo mp mq b">std</code>。我们将使用之前安装的 rasterio 包打开图像，并对每个批次/通道的统计数据进行简单平均。对于标准差，这种方法是一种近似方法。更精确的计算请参考:<a class="ae ky" href="http://notmatthancock.github.io/2017/03/23/simple-batch-stat-updates.html" rel="noopener ugc nofollow" target="_blank">http://notmatthancock . github . io/2017/03/23/simple-batch-stat-updates . htm</a>。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="3feb" class="nj la it mq b be nk nl l nm nn">import rasterio as rio<br/><br/><br/>def calc_statistics(dset: RasterDataset):<br/>        """<br/>        Calculate the statistics (mean and std) for the entire dataset<br/>        Warning: This is an approximation. The correct value should take into account the<br/>        mean for the whole dataset for computing individual stds.<br/>        For correctness I suggest checking: http://notmatthancock.github.io/2017/03/23/simple-batch-stat-updates.html<br/>        """<br/><br/>        # To avoid loading the entire dataset in memory, we will loop through each img<br/>        # The filenames will be retrieved from the dataset's rtree index<br/>        files = [item.object for item in dset.index.intersection(dset.index.bounds, objects=True)]<br/><br/>        # Reseting statistics<br/>        accum_mean = 0<br/>        accum_std = 0<br/><br/>        for file in files:<br/>            img = rio.open(file).read()/10000 #type: ignore<br/>            accum_mean += img.reshape((img.shape[0], -1)).mean(axis=1)<br/>            accum_std += img.reshape((img.shape[0], -1)).std(axis=1)<br/><br/>        # at the end, we shall have 2 vectors with lenght n=chnls<br/>        # we will average them considering the number of images<br/>        return accum_mean / len(files), accum_std / len(files)<br/><br/><br/>mean, std = calc_statistics(train_imgs)<br/>print(mean, std)<br/><br/>code output:<br/>[0.0771449  0.09890421 0.09758993 0.22216185 0.1854808  0.13288888] [0.04496952 0.05038998 0.06053346 0.10840577 0.0993342  0.08219175]</span></pre><p id="0c62" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这里每个列表中有 6 个值。现在，每当数据加载器创建一个批处理并传递给训练器时，我们必须使用这些值来规范化这些值。此外，如果我们想可视化这一批，我们需要“恢复”标准化，否则真实的颜色将是不正确的。然后我们将创建一个类来完成这个任务。我们将从<code class="fe mn mo mp mq b">torch.nn.Module</code>类继承它，并定义<code class="fe mn mo mp mq b">forward </code>方法和 revert 方法来“撤销”规范化。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="676a" class="nj la it mq b be nk nl l nm nn">class MyNormalize(torch.nn.Module):<br/>    def __init__(self, mean: List[float], stdev: List[float]):<br/>        super().__init__()<br/><br/>        self.mean = torch.Tensor(mean)[:, None, None]<br/>        self.std = torch.Tensor(stdev)[:, None, None]<br/><br/>    def forward(self, inputs: dict):<br/><br/>        x = inputs["image"][..., : len(self.mean), :, :]<br/><br/>        # if batch<br/>        if inputs["image"].ndim == 4:<br/>            x = (x - self.mean[None, ...]) / self.std[None, ...]<br/><br/>        else:<br/>            x = (x - self.mean) / self.std<br/><br/>        inputs["image"][..., : len(self.mean), :, :] = x<br/><br/>        return inputs<br/><br/>    def revert(self, inputs: dict):<br/>        """<br/>        De-normalize the batch.<br/><br/>        Args:<br/>            inputs (dict): Dictionary with the 'image' key<br/>        """<br/><br/>        x = inputs["image"][..., : len(self.mean), :, :]<br/><br/>        # if batch<br/>        if x.ndim == 4:<br/>            x = inputs["image"][:, : len(self.mean), ...]<br/>            x = x * self.std[None, ...] + self.mean[None, ...]<br/>        else:<br/>            x = x * self.std + self.mean<br/><br/>        inputs["image"][..., : len(self.mean), :, :] = x<br/><br/>        return inputs<br/></span></pre><p id="49d2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">一旦定义了类，我们就可以用从我们的数据集获得的<code class="fe mn mo mp mq b">mean </code>和<code class="fe mn mo mp mq b">std </code>值来实例化它，并测试正向传递和反向传递(代码输出已被抑制)。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="98b4" class="nj la it mq b be nk nl l nm nn">normalize = MyNormalize(mean=mean, stdev=std)<br/>norm_batch = normalize(batch)<br/>plot_batch(norm_batch)<br/><br/>batch = normalize.revert(norm_batch)<br/>plot_batch(batch)</span></pre><h1 id="baf0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">光谱指数</h1><p id="bca4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了提高我们的神经网络的性能，我们将执行一些特征工程，并给出其他光谱指数作为输入，如 NDWI(归一化差异水指数)、MNDWI(修正的 NDWI)和 NDVI(归一化差异植被指数)。</p><p id="8da7" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">TorchGeo 让我们更容易向原始数据集追加索引。为此，我们将使用转换模块，如下所示:</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="b9b2" class="nj la it mq b be nk nl l nm nn">from torchgeo.transforms import indices<br/><br/>ndwi_transform = indices.AppendNDWI(index_green=1, index_nir=3)<br/><br/>transformed_batch = ndwi_transform(batch)<br/>print(transformed_batch['image'].shape, transformed_batch['mask'].shape)<br/><br/>code output: <br/>torch.Size([8, 7, 512, 512]) torch.Size([8, 1, 512, 512])</span></pre><p id="57cc" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">请注意，我们现在在图像中有 7 个通道，而不是 6 个通道，因为我们附加了 NDWI 索引。</p><p id="ec04" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，我们可以将所有需要的转换组合成一个顺序对象。请注意，我们将把归一化作为最后的变换，因为光谱指数应该直接与原始反射率一起工作。</p><pre class="kj kk kl km gt nf mq ng bn nh ni bi"><span id="52f5" class="nj la it mq b be nk nl l nm nn">tfms = torch.nn.Sequential(<br/>    indices.AppendNDWI(index_green=1, index_nir=3),<br/>    indices.AppendNDWI(index_green=1, index_nir=5),<br/>    indices.AppendNDVI(index_nir=3, index_red=2),<br/>    normalize<br/>)<br/><br/>new_transformed_batch = tfms(batch)<br/>print(batch['image'].shape, batch['mask'].shape)<br/><br/>code output:<br/>torch.Size([8, 10, 512, 512]) torch.Size([8, 1, 512, 512])</span></pre><p id="f171" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，我们有了一个非常简单的方法来将我们想要的转换应用到我们的原始数据。</p><blockquote class="mw mx my"><p id="4efc" class="lr ls mz lt b lu mr ju lw lx ms jx lz na mt mc md nb mu mg mh nc mv mk ml mm im bi translated">重要提示:我们创建的 normalize 方法将只对原始波段应用归一化，并忽略之前附加的索引。这对于避免由于批次向量、平均值向量和标准差向量之间的不同形状而导致的错误非常重要。</p></blockquote><h1 id="7b7d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">笔记本</h1><p id="0ae3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我将把这个故事的完整的 Colab 笔记本留在这里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h1 id="52b8" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="2bbe" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在今天的故事中，我们已经看到了如何通过组合原始数据集中的图像和遮罩来创建 IntersectionDataset。此外，我们看到了如何使用神经网络。向原始数据追加转换。这些也可以用来添加扩充，但是这是一个更高级的主题，不在本系列中讨论。</p><p id="96f2" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在下一个故事中，我们将创建训练循环、损失函数，并检查我们新创建的深度神经网络的结果。所以，如果你很好奇，请继续关注我(并考虑通过订阅支持 Medium 和其他作者)。</p><p id="019a" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">下一个故事再见。</p><h1 id="82de" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">保持联系</h1><p id="8c78" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="mz">如果你喜欢这篇文章，想支持我当作家，可以考虑成为</em> <a class="ae ky" href="https://cordmaur.medium.com/membership" rel="noopener"> <em class="mz">中等会员</em> </a> <em class="mz">。每月只需 5 美元，我会从你的会员费中收取一小笔佣金，不需要你额外付费。或者你可以随时给我买杯咖啡。</em></p><h1 id="c3eb" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">进一步阅读</h1><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/artificial-intelligence-for-geospatial-analysis-with-pytorchs-torchgeo-part-1-52d17e409f09"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">使用 Pytorch 的 TorchGeo 进行地理空间分析的人工智能(第 1 部分)</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">使用 Pytorch 和 TorchGeo 包的端到端深度学习地理空间分割项目</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a rel="noopener follow" target="_blank" href="/artificial-intelligence-for-geospatial-analysis-with-pytorchs-torchgeo-part-3-7521131f30b1"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">使用 Pytorch 的 TorchGeo 进行地理空间分析的人工智能(第 3 部分)</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">使用 Pytorch 和 TorchGeo 包的端到端深度学习地理空间分割项目</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh ks nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://cordmaur.medium.com/membership" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">通过我的推荐链接加入媒体-毛里西奥·科代罗</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">阅读毛里西奥·科代罗的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">cordmaur.medium.com</p></div></div><div class="oc l"><div class="oj l oe of og oc oh ks nt"/></div></div></a></div></div></div>    
</body>
</html>