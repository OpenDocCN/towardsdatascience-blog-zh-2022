<html>
<head>
<title>What is the Python Global Interpreter Lock (GIL)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Python全局解释器锁(GIL)？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-gil-e63f18a08c65#2022-02-03">https://towardsdatascience.com/python-gil-e63f18a08c65#2022-02-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6244" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">理解Python中全局解释器锁的用途以及它如何影响多线程</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/920e8469f789ab18db786d7ac591badb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajSwGDgJm1hjaJSQKREOVw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@osmanrana?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">奥斯曼·拉纳</a>在<a class="ae kz" href="https://unsplash.com/s/photos/lines?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h2 id="3a0c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在我最近的一篇文章中，我讨论了编程中的一些基本概念，即<em class="mp">并发性</em>、<em class="mp">并行性</em>、<em class="mp">多线程</em>和<em class="mp">多处理</em>和<a class="ae kz" rel="noopener" target="_blank" href="/multithreading-multiprocessing-python-180d0975ab29">它们如何在Python </a>中实现。</p><p id="1820" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">在这种情况下最有争议的话题之一，无疑是Python的<strong class="ly iv">全局解释器锁</strong>，它本质上保护解释器——在Python中——不是线程安全的。</p><p id="ab70" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">在今天的文章中，我们将重温线程和多处理，并介绍全局解释器锁。此外，我们还将讨论GIL带来的限制，以及如何找到解决办法。我们还将讨论一些相关的概念，如线程安全和竞争条件。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="eb1c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">全局解释器锁</h2><p id="9e7a" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在<strong class="ly iv"> CPython </strong>中，全局解释器锁(GIL)是一个互斥锁，一次只允许一个线程控制Python解释器。换句话说，锁确保在任何给定时间只有一个线程在运行。因此，不可能利用具有线程的多个处理器。</p><blockquote class="nc"><p id="3bd1" class="nd ne iu bd nf ng nh ni nj nk nl mo dk translated"><strong class="ak"> GIL </strong>，是一个互斥体，保护对Python对象的访问，防止多个线程同时执行Python字节码— <a class="ae kz" href="https://wiki.python.org/moin/GlobalInterpreterLock" rel="noopener ugc nofollow" target="_blank"> Python Wiki </a></p></blockquote><p id="e2f4" class="pw-post-body-paragraph lw lx iu ly b lz nm jv mb mc nn jy me lj no mg mh ln np mj mk lr nq mm mn mo in bi translated">由于<strong class="ly iv"> CPython的内存管理不是线程安全的</strong>，<strong class="ly iv"> GIL </strong>防止竞争情况，而<strong class="ly iv">确保线程安全</strong>。Python中的线程共享相同的内存——这意味着当多个线程同时运行时，我们并不知道线程访问共享数据的确切顺序。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="d1d0" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">线程安全和竞争条件</h2><p id="2f4d" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">线程安全代码以不干扰其他线程的方式操作共享数据。因此，每次只有一个线程运行，GIL确保永远不会有<strong class="ly iv">竞争条件</strong>。</p><p id="7fb0" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">为了更好地理解什么是竞争条件，让我们考虑一个线程示例，其中我们有一个名为<code class="fe nr ns nt nu b">x</code>的共享变量:</p><pre class="kk kl km kn gu nv nu nw nx aw ny bi"><span id="ce3e" class="la lb iu nu b gz nz oa l ob oc">x = 10</span></pre><p id="f399" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">现在让我们假设两个线程正在运行，执行下面概述的操作:</p><pre class="kk kl km kn gu nv nu nw nx aw ny bi"><span id="da93" class="la lb iu nu b gz nz oa l ob oc"># Thread 1<br/>x += 10</span><span id="53a0" class="la lb iu nu b gz od oa l ob oc"># Thread 2<br/>x *= 5</span></pre><p id="1b82" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">现在，根据线程访问共享变量<code class="fe nr ns nt nu b">x</code>的顺序，我们可能会得到不同的结果。例如，如果我们假设<code class="fe nr ns nt nu b">Thread 1</code>首先访问共享变量<code class="fe nr ns nt nu b">x</code>，结果将是<code class="fe nr ns nt nu b">100</code>。</p><pre class="kk kl km kn gu nv nu nw nx aw ny bi"><span id="67b0" class="la lb iu nu b gz nz oa l ob oc">x += 10  # Thread 1: x = 20<br/>x *= 5   # Thread 2: x = 100</span></pre><p id="1d7f" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">或者，如果<code class="fe nr ns nt nu b">Thread 2</code>先访问<code class="fe nr ns nt nu b">x</code>，结果会不同:</p><pre class="kk kl km kn gu nv nu nw nx aw ny bi"><span id="14df" class="la lb iu nu b gz nz oa l ob oc">x *= 5   # Thread 2: x = 50<br/>x += 10  # Thread 1: x = 60</span></pre><p id="8d58" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">甚至还有第三种情况，线程1和2同时读取共享变量。在这种情况下，它们都将读入初始值<code class="fe nr ns nt nu b">x</code>(等于<code class="fe nr ns nt nu b">10</code>)，并且根据哪个线程将最后写入其结果，<code class="fe nr ns nt nu b">x</code>的结果值将是<code class="fe nr ns nt nu b">20</code>(如果线程1最后写入其结果)或<code class="fe nr ns nt nu b">50</code>(如果第二个线程最后写入其结果)。</p><p id="8c72" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">这是一个我们称之为<strong class="ly iv">竞争条件</strong>的例子。换句话说，当系统或代码的行为依赖于由不可控事件定义的执行顺序时，就会出现争用情况。</p><p id="08bf" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">这正是CPython GIL所做的。它通过确保在任何给定时间只有一个线程在运行来防止竞争情况。这让一些Python程序员的生活变得更加轻松，但同时也带来了限制，因为多核系统不能在线程环境中使用。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="19a5" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Python中的线程与多处理</h2><p id="a71c" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">如前所述，Python进程不能并行运行线程，但它可以在I/O绑定操作期间通过上下文切换并发运行线程。请注意，并行性和并发性听起来可能是等价的术语，但实际上它们不是。</p><p id="eae2" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">下图说明了在使用<code class="fe nr ns nt nu b"><a class="ae kz" href="https://docs.python.org/3/library/threading.html" rel="noopener ugc nofollow" target="_blank">threading</a></code> Python库时，两个线程是如何执行的以及上下文切换是如何工作的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oe"><img src="../Images/bd2a58082cedcf1658fa9d51a359c313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/0*uv_48CTvJO4aasbT.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python中的线程(并发)——来源:作者</p></figure><p id="fbc3" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">现在，如果您想利用多处理器和多核系统的计算能力，您可能需要看看允许进程并行执行的<code class="fe nr ns nt nu b"><a class="ae kz" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>包<strong class="ly iv"/>。当<strong class="ly iv">执行CPU受限的任务</strong>时，这通常是有用的。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj of"><img src="../Images/27d48571335fd2049c035a45b363bcc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/0*absCRPVFExZZkTVC.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python中的多处理(并行)—来源:作者</p></figure><p id="5265" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">多进程旁路全局解释器锁，因为它允许每个进程拥有自己的解释器，从而拥有自己的GIL。</p><p id="1bd4" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">要更全面地了解Python中的<strong class="ly iv">多处理和线程</strong>，请务必阅读下面分享的相关文章，该文章本质上是对Python中的<strong class="ly iv">并发</strong>和<strong class="ly iv">并行</strong>的深入探究。</p><div class="og oh gq gs oi oj"><a rel="noopener follow" target="_blank" href="/multithreading-multiprocessing-python-180d0975ab29"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">Python中的多线程和多处理</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">深入探讨Python中的多线程和多处理，以及它们与并发性和</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kt oj"/></div></div></a></div></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="76fa" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在Python中避开GIL</h2><p id="3617" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">值得一提的是，一些替代的Python实现，即<a class="ae kz" href="https://wiki.python.org/moin/Jython" rel="noopener ugc nofollow" target="_blank"> Jython </a>和<a class="ae kz" href="https://wiki.python.org/moin/IronPython" rel="noopener ugc nofollow" target="_blank"> IronPython </a>没有全局解释器锁，因此它们可以利用多处理器系统。</p><p id="25a8" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">现在回到CPython，尽管对于许多程序员来说，GIL的概念非常方便，因为它使事情变得容易得多。此外，开发人员并不真的必须与全局解释器锁交互(甚至接触)，除非他们需要用C扩展编写。在这种情况下，当扩展阻塞I/O时，您必须释放GIL，以便进程中的其他线程可以接管并执行。</p><p id="2413" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">一般来说，GIL的概念肯定不是理想的，因为在某些情况下，现代多处理器系统不能被充分利用。然而与此同时，许多长时间运行或阻塞的操作正在GIL 之外<strong class="ly iv">执行。这些操作包括输入输出、图像处理和数字运算。因此，只有在<strong class="ly iv">花费时间在GIL内部</strong>的多线程操作中，GIL才会成为瓶颈。</strong></p><p id="aa43" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">摆脱全局解释器锁是Python社区中的一个常见话题。取代GIL绝对不是一件容易的事情，因为这些特性和要求都需要满足。</p><p id="df62" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">然而，Sam Gross最近提出了一个CPython的概念验证实现，它支持多线程，而没有被称为<code class="fe nr ns nt nu b"><a class="ae kz" href="https://github.com/colesbury/nogil/" rel="noopener ugc nofollow" target="_blank">nogil</a></code>的全局解释器锁。这个概念验证实际上演示了如何删除GIL，从而使CPyhton解释器可以随着CPU内核的增加而扩展。</p><p id="f93e" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">你可以在<code class="fe nr ns nt nu b">nogil</code>作者的<a class="ae kz" href="https://docs.google.com/document/d/18CXhDb1ygxg-YXNBJNzfzZsDFosB5e6BfnXLlejd9l0" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中找到更多细节和潜在问题的答案。即使这可能是一个潜在的解决方案，也不要期望任何改变会很快发生。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="732d" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了围绕Python最有争议的话题之一，即全局解释器锁(又名GIL)。我们已经看到了它的用途以及它最初被实现的原因，但是此外，我们还讨论了它的存在所带来的限制。此外，我们讨论了线程安全，并通过一个例子演示了什么是竞争条件以及GIL如何防止它。</p><p id="3ed9" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated">最后，我们讨论了通过利用多核系统，最终避开Python GIL并实现真正并行的潜在方法。</p></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读媒体上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="og oh gq gs oi oj"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox kt oj"/></div></div></a></div></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mq jv mb mc mr jy me lj ms mg mh ln mt mj mk lr mu mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="og oh gq gs oi oj"><a rel="noopener follow" target="_blank" href="/augmented-assignments-python-caa4990811a0"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">Python中的扩充赋值</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">了解增强赋值表达式在Python中的工作方式，以及为什么在使用它们时要小心…</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox kt oj"/></div></div></a></div></div><div class="ab cl mv mw hy mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oj"><a rel="noopener follow" target="_blank" href="/dynamic-typing-in-python-307f7c22b24e"><div class="ok ab fp"><div class="ol ab om cl cj on"><h2 class="bd iv gz z fq oo fs ft op fv fx it bi translated">Python中的动态类型</h2><div class="oq l"><h3 class="bd b gz z fq oo fs ft op fv fx dk translated">探索Python中对象引用的工作方式</h3></div><div class="or l"><p class="bd b dl z fq oo fs ft op fv fx dk translated">towardsdatascience.com</p></div></div><div class="os l"><div class="pa l ou ov ow os ox kt oj"/></div></div></a></div></div></div>    
</body>
</html>