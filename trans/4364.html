<html>
<head>
<title>Is Your Python For-loop Slow? Use NumPy Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你的Python For-loop慢吗？请改用NumPy</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numpy-vectorization-speed-ffdab5deb402#2022-09-27">https://towardsdatascience.com/numpy-vectorization-speed-ffdab5deb402#2022-09-27</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="bc23" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">当速度很重要时，列表不是最好的。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d91f52b78be73f9486d926e64e0c489a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Cy59koaw0GolrYVJ9fpYA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/close-up-photography-of-gray-stainless-steel-fan-turned-on-surrounded-by-dark-background-1374448/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的Alireza Kaviani 拍摄的照片。</p></figure><p id="21e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">速度一直是开发人员关心的问题——尤其是对数据敏感的工作。</p><p id="50ec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">迭代能力是所有自动化和扩展的基础。我们所有人的首要选择是for循环。它优秀、简单、灵活。然而，它们不是为扩展到大规模数据集而构建的。</p><p id="51a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这就是矢量化的用武之地。当您在for循环中进行大量数据处理时，请考虑矢量化。Numpy在这里派上了用场。</p><p id="04f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这篇文章解释了NumPy操作与for循环相比有多快。</p><div class="lw lx gq gs ly lz"><a rel="noopener follow" target="_blank" href="/how-to-speed-up-python-data-pipelines-up-to-91x-80d7accfe7ec"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">如何将Python数据管道加速到91X？</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">一个5分钟的教程可以为您的大数据项目节省数月时间。</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><h1 id="fa0e" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">用NumPy比较For循环</h1><p id="7e67" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">我们来做一个简单的求和运算。我们必须总结一个列表中的所有元素。</p><p id="6057" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">sum是Python中的一个内置操作，可以在一系列数字上使用。但是让我们假设没有，您需要实现它。</p><p id="b4f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">任何程序员都会选择遍历列表并将数字添加到变量中。但是有经验的开发人员知道它的局限性，会选择优化的版本。</p><div class="lw lx gq gs ly lz"><a rel="noopener follow" target="_blank" href="/how-to-detect-memory-leakage-in-your-python-application-f83ae1ad897d"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">如何检测Python应用程序中的内存泄漏</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">标准的Python库，可以显示每一行的内存使用和执行时间</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="nl l mk ml mm mi mn kt lz"/></div></div></a></div><p id="4716" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是我们总结的列表和数字版本。在这个例子中，我们创建了一个包含100万个0到100之间的随机数的数组。然后我们使用这两种方法并记录执行时间。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">我在比较NumPy sum和list迭代的速度。—作者摘录。</p></figure><p id="00f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们运行这个程序，看看我们会得到什么。输出可能如下所示。</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="a101" class="nt mp iu np b gz nu nv l nw nx">$ python main.py <br/>Summation time with for-loop:  14.793345853999199<br/>Summation time with np.sum:  0.1294808290003857</span></pre><p id="ae14" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NumPy版本更快。这大约是循环所用时间的百分之一。</p><h1 id="bea0" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用Numpy加速计算的更多示例</h1><p id="4b8c" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">NumPy大量用于数值计算。也就是说，如果您正在处理庞大的数据集矢量化，NumPy的使用是不可避免的。</p><p id="14d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">大多数机器学习库使用NumPy来优化算法。如果你曾经创建过scikit learn to model，你应该已经使用过NumPy了。</p><p id="c9e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里还有一些处理大量数字数据时经常用到的例子。</p><h2 id="9fd1" class="nt mp iu bd mq ny nz dn mu oa ob dp my lj oc od na ln oe of nc lr og oh ne oi bi translated">NumPy与列表中乘积的总和</h2><p id="9f5e" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">这是一种流行的数值计算，你甚至可以在Excel上使用。让我们来衡量一下lists和NumPy版本的性能。</p><p id="3a29" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码将一个数组中的每个元素与另一个数组中的相应元素相乘。最后，我们总结所有的单个产品。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><p id="da19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面是上面代码的输出:</p><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="50ee" class="nt mp iu np b gz nu nv l nw nx">$ python main.py <br/>Sum of products with for loop:  26.099454337999987<br/>Sum of products with np.sum:  0.28206900699990456</span></pre><p id="447f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，NumPy版本比遍历列表快100倍。</p><h2 id="8ec7" class="nt mp iu bd mq ny nz dn mu oa ob dp my lj oc od na ln oe of nc lr og oh ne oi bi translated">NumPy和链表的矩阵乘法性能。</h2><p id="fad1" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">矩阵乘法是和积的扩展版本。它涉及的不是单个数组，而是数组的数组。</p><p id="da6b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在实现涉及大量数据的算法时，矩阵乘法也非常常见。这里是基准。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nm nn l"/></div></figure><pre class="kk kl km kn gu no np nq nr aw ns bi"><span id="39b9" class="nt mp iu np b gz nu nv l nw nx">$ python main.py<br/>Matrix multiplication with for loop:  1597.9121425140002<br/>Matrix multiplication with numpy:  2.8506258010002057<br/></span></pre><p id="88ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用NumPy的结果是深远的。我们的矢量化版本运行速度快了500多倍。</p><p id="8ebb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着数组的大小和维度的增长，NumPy的优势更加突出。</p><h1 id="5b2e" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">为什么NumPy比lists快？</h1><p id="3185" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">简单；它们被设计用于不同的目的。</p><p id="9d82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NumPy的角色是为数值计算提供一个优化的接口。然而，Python列表只是对象的集合。</p><p id="4b4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">NumPy数组只允许<strong class="lc iv">同类数据类型</strong>。因此，NumPy操作在算法的每一步之前都不必担心类型。这就是我们提高速度的地方——快速取胜。</p><p id="ea5d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，在NumPy中，整个数组，而不是单个元素，是一个被称为<strong class="lc iv">密集打包的</strong>对象。因此，它需要更少的内存。</p><p id="8629" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，NumPy操作(主要是)<strong class="lc iv">是用C </strong>实现的，而不是用Python本身。</p><div class="lw lx gq gs ly lz"><a rel="noopener follow" target="_blank" href="/challenging-cython-the-python-module-for-high-performance-computing-2e0f874311c0"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">挑战cy thon——高性能计算的Python模块。</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">现代的替代方案看起来很有希望，Python可以以闪电般的速度运行。</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="oj l mk ml mm mi mn kt lz"/></div></div></a></div><p id="57a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Python中的列表只不过是一个对象存储。单个对象占用空间，你很快就需要更多的内存来处理它们。此外，列表可以容纳不同类型的对象。但是不利的一面是，您必须对每个操作进行元素类型检查。这使得成本很高。</p><h1 id="b877" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">最后的想法</h1><p id="b858" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">这篇文章鼓励你将列表转换成NumPy数组，并使用向量化操作来加速执行。</p><p id="290c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">人们在列表中使用for循环是很自然的，因为这很简单。但如果涉及到很多数字，就不是最优的方式。为了更好地理解它，我们比较了一些简单运算的性能，比如求和、和积和矩阵乘法。在所有情况下，NumPy的表现都远远好于lists。</p><p id="396b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">For循环在编程中也有它们的位置。经验法则是当你的数据结构更复杂，需要迭代的项目更少时使用它们。</p><p id="9ef0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">没有NumPy的几百个数相加可能更好。此外，如果在每次迭代中你必须做比数值计算更多的工作，NumPy不是你的选择。</p><div class="lw lx gq gs ly lz"><a rel="noopener follow" target="_blank" href="/how-to-serve-massive-computations-using-python-web-apps-590e51624bc6"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">如何使用Python Web应用服务于大规模计算？</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">克服Python的局限性，并通过web请求将其用于繁重的数据分析和机器学习。</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">towardsdatascience.com</p></div></div><div class="mi l"><div class="ok l mk ml mm mi mn kt lz"/></div></div></a></div></div><div class="ab cl ol om hy on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="in io ip iq ir"><blockquote class="os ot ou"><p id="c7c5" class="la lb ov lc b ld le jv lf lg lh jy li ow lk ll lm ox lo lp lq oy ls lt lu lv in bi translated">感谢阅读，朋友！在<a class="ae kz" href="https://www.linkedin.com/in/thuwarakesh/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong></a><a class="ae kz" href="https://twitter.com/Thuwarakesh" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">Twitter</strong></a><a class="ae kz" href="https://thuwarakesh.medium.com/" rel="noopener"><strong class="lc iv">Medium</strong></a>上跟我打招呼。</p><p id="452c" class="la lb ov lc b ld le jv lf lg lh jy li ow lk ll lm ox lo lp lq oy ls lt lu lv in bi translated">还不是中等会员？请使用此链接<a class="ae kz" href="https://thuwarakesh.medium.com/membership" rel="noopener"> <strong class="lc iv">成为会员</strong> </a>因为，在没有额外费用的情况下，我赚取了一点佣金。</p></blockquote></div></div>    
</body>
</html>