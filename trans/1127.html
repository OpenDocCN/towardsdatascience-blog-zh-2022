<html>
<head>
<title>BigQuery UDFs Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery UDFs 完全指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-udfs-complete-guide-181cbdaea55b#2022-03-23">https://towardsdatascience.com/bigquery-udfs-complete-guide-181cbdaea55b#2022-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ce9e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于 Google BigQuery 用户定义函数你需要知道的一切</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/251b5ecaa3d7f5cfa4a2748cb313bdad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lJJlPweAYTviTJtK2hIxA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用 UDF 定制您的 BigQuery 体验——照片由<a class="ae ky" href="https://unsplash.com/s/photos/custom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@girlwithredhat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戴红帽的女孩</a>拍摄</p></figure><p id="6e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> G </span> oogle Cloud 的 BigQuery 是一款<strong class="lb iu">牛逼的数据分析甚至机器学习工具</strong>。它提供了许多现成的有用函数，但是如果你真的想深入 BQ，在某些时候你需要熟悉用户定义的函数。这些由您(用户)定义的函数将允许您<strong class="lb iu">简化您的 SQL 查询并更快地完成工作</strong>。</p><p id="a4de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将向您展示如何使用<strong class="lb iu"> SQL 或 JavaScript </strong>来定义函数，甚至如何使用来自<code class="fe me mf mg mh b">jStat</code>的一些统计函数——一个用于统计的 JavaScript 库。</p><p id="6796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个<a class="ae ky" href="https://github.com/niczky12/medium/blob/1bd90f4a8d29b134a064b18e549a01a98d3805b4/tech/bigquery/BigQuery_UDFs.ipynb" rel="noopener ugc nofollow" target="_blank"> Google Colab Notebook </a>为整个教程提供了易于运行的步骤，你可以重新创建和窃取你自己工作所需的所有代码。</p><h1 id="d206" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">制作玩具数据集</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/6a5aea1de7e7a534a0ddcc1ddb8f3098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRIAnz2ladsdudnEQmJK6w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">那只果冻兔太棒了！—<a class="ae ky" href="https://unsplash.com/@itshoobastank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Yuri Shiro ta</a>在<a class="ae ky" href="https://unsplash.com/s/photos/little-toy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我更喜欢编写易于复制的教程，我们将从验证我们的 Google Colab 会话开始我们的旅程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="50fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要一个玩具数据集。为此，我们可以使用<code class="fe me mf mg mh b">sklearn</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6e71b48260b397ecb2695aab4586d8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*bLoUlnGnOaKocQX1ER84kw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的数据框已经准备好了。—作者截图</p></figure><p id="08ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将它制作成一个 BigQuery 表，并检查它是否如预期的那样工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="93e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe me mf mg mh b">%%bigquery</code> Jupyter 神奇的函数来调用 BigQuery SQL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/aac0cf7b8eb94f568df7e183b364c663.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*YEGgfB6Xu7Pzs3PKdtgj2w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">BQ 的土地上一切似乎都很好——作者截图</p></figure><h1 id="b6c7" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">临时功能</h1><p id="f0bc" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在我们有了一个数据集，可以开始讨论用户定义函数或 UDF 了。我们将使用普通的 SQL 来定义带有关键字<code class="fe me mf mg mh b">CREATE FUNCTION</code>的函数。如果有任何困惑，欢迎在评论中询问更多细节。我们的<strong class="lb iu">函数将做一些超级简单的事情</strong>:如果标签是 1，将 x 乘以 100，否则，它将返回 x。下面是函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="30e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们已经失去了 GitHub 语法突出显示，因为它不知道这些 BigQuery SQL 关键字…😅</p><p id="eeb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来看看细节:</p><ul class=""><li id="2853" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">我们使用了<code class="fe me mf mg mh b">TEMP</code>关键字，这意味着我们的函数<strong class="lb iu">只存在于这个查询</strong>中。我们将不能再次重复使用它。</li><li id="367d" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe me mf mg mh b">move_x</code>是我们函数的<strong class="lb iu">名</strong>。</li><li id="1381" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe me mf mg mh b">x</code>和<code class="fe me mf mg mh b">labelid</code>是该功能的两个<strong class="lb iu">输入</strong>。我已经在这里定义了它们的类型，但是我们将在后面讨论更多的类型。</li><li id="e1d5" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe me mf mg mh b">RETURNS FLOAT64</code>告诉 BigQuery 函数返回什么类型的对象<strong class="lb iu"/>。</li><li id="9891" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe me mf mg mh b">AS</code>之后的都是函数的<strong class="lb iu">体。这基本上是一个简单的<code class="fe me mf mg mh b">CASE WHEN</code>子句。</strong></li><li id="504c" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">为了<strong class="lb iu">调用函数</strong>，我们只需在<code class="fe me mf mg mh b">SELECT</code>子句中传递我们需要的 2 个输入。这发生在 7 号线。</li></ul><p id="58ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是辉煌的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/fd5a2426b1a1215b2f9c06a079a20904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*UE2-mMK0iY78lYRUELFskQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请注意，new_x 在 label=1 的结尾更大—作者截图</p></figure><h1 id="c733" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">永久功能</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/257cb5335087d551e2fd691cb8f24534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eIzXgGLu33ZDVw3eRgtR9A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@nadah?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">纳达哈巴斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/pyramid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您试图在一个新的<code class="fe me mf mg mh b">SELECT</code>子句中调用这个函数，您将会看到这个<code class="fe me mf mg mh b">400 Function not found: move_x</code>错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/7daea06c81cf3ffbeff6e04eed2fa006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*-gGbvk3AjbmiXYG2qBm30w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的功能消失了😱—作者截图</p></figure><p id="0b3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是正如您所料，我们可以通过删除关键字<code class="fe me mf mg mh b">TEMPORARY</code>并在函数名中添加一个指示符<code class="fe me mf mg mh b">dataset</code>来轻松保存函数。就像表和模型一样，<strong class="lb iu">函数也必须存在于数据集</strong>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="54bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们添加了这个，我们就使用<code class="fe me mf mg mh b">ds.move_x()</code>再次调用我们的函数——而不用定义它。如果你想知道这个函数的作用，你可以在 BQ 界面的<code class="fe me mf mg mh b">Routines</code>下找到它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/89d5c9913d4240b52078a72cf3d245e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTUVBFk65u0KElEcEBQygg.png"/></div></div></figure><p id="cb1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您注意的话，您可能会注意到上面的描述字段是空的。如果你正在做一个更大的项目，养成记录你的功能的习惯。我们可以在 BQ 中使用<code class="fe me mf mg mh b">OPTIONS</code>关键字来做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="828c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe me mf mg mh b">DROP</code>子句随时删除您的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><h1 id="b692" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">关于类型的注释</h1><p id="3d86" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在上面的定义中，我们明确定义了<strong class="lb iu">输入和输出类型</strong>。我们告诉 BigQuery 期待一个 Float 和一个 Int，并且总是返回一个 Float。有些情况下，你可能不希望这样。在这种情况下，您可以将输入类型定义为<code class="fe me mf mg mh b">ANY</code>，甚至<strong class="lb iu">将输出类型保留为空</strong>，让 BigQuery 动态地计算出类型。这将意味着你的函数可能为不同的输入返回不同的类型，所以<strong class="lb iu">要小心！</strong> BigQuery 调用这个<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/user-defined-functions#templated-sql-udf-parameters" rel="noopener ugc nofollow" target="_blank">模板化的 SQL UDF 参数</a>。</p><p id="7f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示这是如何工作的，我制作了一个名为<code class="fe me mf mg mh b">multiply</code>的新函数，它有两个<code class="fe me mf mg mh b">ANY</code>输入，并将它应用于 3 种不同的列和标量组合。请注意，根据输入的不同，输出会有不同的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/98f5e6900fbfe91282eb1bdddaa9bafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*qYo1nKIJ6Ickb6GZI3kD0g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">new_label 是 int，因为 label 和 10 都是 int——作者截图</p></figure><blockquote class="od oe of"><p id="077a" class="kz la og lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">还要注意，我在这里混合了列和标量，这很好！</p></blockquote><h1 id="1b8d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">定义的 JavaScript</h1><p id="a82a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">到目前为止，我们在所有的函数定义中都使用了 SQL。但是<strong class="lb iu"> BigQuery 也支持 JavaScript </strong>进行函数定义。您所需要的只是<code class="fe me mf mg mh b">LANGUAGE</code>关键字和一个带有 JS 魔法的字符串，其他的一切，包括输入/输出定义，都保持不变。确保在 JS 定义中包含 return 语句:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向你证明这确实有效:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/d38a9551ebf79c9793e60f00932dda0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*Lnb0ybUFGbP2bRhLx8ya-w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">BigQuery 中的 JS—作者截图</p></figure><p id="679f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也没有什么可以阻止你在函数中定义更小的函数，只要你仍然以 return 语句结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript 函数不是无限的。它们可以访问很小的内存，所以要小心传递给它们的内容。理想情况下，你不会想要传入一个百万长度的数组。用 SQL 或者更好的存储过程来实现:</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/bigquery-stored-procedure-for-permutation-test-35597d6379e4"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">用于排列测试的 BigQuery 存储过程</h2><div class="ov l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb ks oo"/></div></div></a></div><h1 id="3ad8" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">使用 JavaScript 库</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/cca212546ce95d93c46816ab32786057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x4rqcW7nBleZAOgDEyfWLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mzakatiura?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mariia Zakatiura </a>在<a class="ae ky" href="https://unsplash.com/s/photos/library?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="42e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会问:“JavaScript 函数有什么意义？”。它们增加了混乱，引入了一种新的语言，通常看起来并不美观。我完全同意。对于这些单行函数，你应该坚持使用 SQL 函数。但是一旦你开始使用<strong class="lb iu">外部 JavaScript 库</strong>，事情就变得有趣了。例如，您可以使用<code class="fe me mf mg mh b">jStat</code>库并在 BigQuery 中实现统计测试。让我们看看如何在 BigQuery 中使用 JS 库。</p><h2 id="9942" class="pd mj it bd mk pe pf dn mo pg ph dp ms li pi pj mu lm pk pl mw lq pm pn my po bi translated">步骤 1 —获取代码</h2><p id="3810" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">对于我们的例子，我们将坚持使用<code class="fe me mf mg mh b">jStat</code>。进入<a class="ae ky" href="https://github.com/jstat/jstat/tree/1.x/dist" rel="noopener ugc nofollow" target="_blank"> GitHub </a>，在<code class="fe me mf mg mh b">dist</code>文件夹下，抓取一个你喜欢的文件。它们是相同的，但是<code class="fe me mf mg mh b">min</code>没有空格。点击<code class="fe me mf mg mh b">raw</code>并选择<code class="fe me mf mg mh b">save link as</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/9f7a9c37a8153a1839952f58e73085ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o4REiGkp6jWtI-4F0iGkIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><blockquote class="pq"><p id="7624" class="pr ps it bd pt pu pv pw px py pz lu dk translated">在从 GitHub 复制代码之前，一定要检查许可协议！</p></blockquote><p id="865b" class="pw-post-body-paragraph kz la it lb b lc qa ju le lf qb jx lh li qc lk ll lm qd lo lp lq qe ls lt lu im bi translated">一旦你保存了你的文件，把它上传到谷歌云存储。您上传到的 bucket 必须与您的 BigQuery compute 在<strong class="lb iu">相同的区域中。记下该位置的完整路径。如果你像我一样懒，你可以使用文件旁边的汉堡选项(3 点)来复制 Gsutil 路径:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/1946171cf44c06626d99e82cfc8cf933.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*5CrodMzQSEWe54QhrtUgew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">复制 blob 路径—作者截图</p></figure><p id="ee19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会给你这样的东西:<code class="fe me mf mg mh b">gs://YOUR_BUCKET/path_to_file.js</code></p><h2 id="c9c8" class="pd mj it bd mk pe pf dn mo pg ph dp ms li pi pj mu lm pk pl mw lq pm pn my po bi translated">第二步——使用代码</h2><p id="36b0" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在我们有了代码的副本，可以开始在查询中使用它了。我们仍然需要<strong class="lb iu">制作一个 UDF </strong>，但是 UDF 本身可以从谷歌云存储中引用一个库:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们在上面是如何调用<code class="fe me mf mg mh b">jStat.sumsprd</code>的。另外，请注意<code class="fe me mf mg mh b">library</code>接受一个数组，因此您可以提供多个 JavaScript 库来使用。你也可以创建自己的函数库！</p><h1 id="3b4b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">结论</h1><p id="ce0b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">谢谢你一直读到最后。希望您学到了一些关于 BigQuery 的新知识，并发现代码示例很有用。BigQuery UDFs 是一个伟大的工具，可以减少代码中的重复，提高分析系统的可靠性。想想你可以用外部库做的所有事情，或者你可以通过一个<strong class="lb iu">b 去掉公共步骤</strong>而去掉的代码量。</p><p id="e64d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我做的一件常见的事情是，通过使用该行的 id，在 ML 预测中添加一点可重复的噪声。有了这个功能，生活就轻松多了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/a38d51c47d0cda42f574f3733ed7bdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*emSwTDcbRyTKMVyIRvk2Zg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">行动中的随机噪音—作者截图</p></figure></div><div class="ab cl qh qi hx qj" role="separator"><span class="qk bw bk ql qm qn"/><span class="qk bw bk ql qm qn"/><span class="qk bw bk ql qm"/></div><div class="im in io ip iq"><p id="0560" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，请考虑关注我，<a class="ae ky" href="https://niczky12.medium.com/membership" rel="noopener"> <strong class="lb iu">订阅 Medium </strong> </a>，或者查看我的其他文章:</p><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/end-to-end-bigquery-machine-learning-e7e6e2e83b34"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">端到端 BigQuery 机器学习</h2><div class="qo l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">使用 Google Cloud BigQuery 参加 Kaggle 竞赛</h3></div><div class="ov l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="qp l oy oz pa ow pb ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/jupyter-notebooks-can-be-a-pain-but-i-️-pluto-f47913c5c16d"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">朱庇特笔记本可能是一种痛苦，但我❤️布鲁托</h2><div class="qo l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">朱莉娅的 Pluto.jl 将使教育变得更好</h3></div><div class="ov l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="qq l oy oz pa ow pb ks oo"/></div></div></a></div><div class="ol om gp gr on oo"><a rel="noopener follow" target="_blank" href="/advanced-random-sampling-in-bigquery-sql-7d4483b580bb"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">BigQuery SQL 中的高级随机采样</h2><div class="qo l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">了解如何以可重现的方式对 BigQuery 表中的行进行采样</h3></div><div class="ov l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">towardsdatascience.com</p></div></div><div class="ow l"><div class="qr l oy oz pa ow pb ks oo"/></div></div></a></div></div></div>    
</body>
</html>