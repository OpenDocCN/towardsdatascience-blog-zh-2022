<html>
<head>
<title>Graph Visualisation Basics with Python, Part III: Directed Graphs with graphviz</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python图形可视化基础，第三部分:graphviz有向图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/graph-visualisation-basics-with-python-part-iii-directed-graphs-with-graphviz-50116fb0d670#2022-06-04">https://towardsdatascience.com/graph-visualisation-basics-with-python-part-iii-directed-graphs-with-graphviz-50116fb0d670#2022-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1728" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用graphviz和Pydot包创建有向图</h2></div><p id="fc8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本系列的第一部分中，我分享了如何使用SchemDraw包创建流程图。在<a class="ae le" href="https://medium.com/towards-data-science/graph-visualisation-basics-with-python-part-ii-directed-graph-with-networkx-5c1cd5564daa" rel="noopener">第二部分</a>中，我描述了用NetworkX包创建一个有向无环图，同时探索特征、中心性概念并检索从根节点到叶子的所有可能路径。这一部分将着重于使用graphviz和pydot包构建有向无环图。我还将解释一下graphviz的样式和属性选项。让我们开始吧。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/e2d380be473f3ed2f56c24f69e5be0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3Kn5yt8ogIHfospr7qSsQ.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片来自<a class="ae le" href="https://unsplash.com/@kunosch" rel="noopener ugc nofollow" target="_blank">施韦策</a>来自<a class="ae le" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="74ef" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">graphviz包</h1><p id="f8cb" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">Graphviz 是一款开源的图形可视化软件。在Python 3.7+下工作的graphviz 包为这个软件提供了一个纯Python接口。这个包允许使用<a class="ae le" href="https://www.graphviz.org/doc/info/lang.html" rel="noopener ugc nofollow" target="_blank">点</a>语言创建无向图和有向图。</p><p id="279f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用graphviz构建Graph或DiGraph对象类似于使用NetworkX，因为我们只需要简单地定义Graph对象的节点和边，并相应地分配属性。然而，也有一些关键的区别。例如，在NetworkX包中，节点可以定义为任何可散列的对象(None除外)。但是在graphviz中，一个节点只能定义为一个字符串。</p><p id="1c9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前的<a class="ae le" rel="noopener" target="_blank" href="/graph-visualisation-basics-with-python-part-ii-directed-graph-with-networkx-5c1cd5564daa"> pos </a> t中，我指出了NetworkX包的图形可视化的不同限制，例如节点形状的有限选项，为单个节点获取唯一形状和边界框(bbox)属性的限制，等等。在这篇文章中，我将分享graphviz包不仅克服了这些限制，还为图形可视化提供了更多的灵活性选项。我将通过重建在之前的<a class="ae le" href="https://medium.com/towards-data-science/graph-visualisation-basics-with-python-part-ii-directed-graph-with-networkx-5c1cd5564daa" rel="noopener">帖子</a>中使用NetworkX创建的组织图来描述这一点，但在这篇帖子中使用graphviz。</p><h2 id="4d82" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">使用graphviz绘制器官图</h2><p id="afe1" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">为了使用graphviz包创建一个普通的organogram，我首先初始化一个graph对象，比如说将<code class="fe nl nm nn no b">f</code>初始化为<code class="fe nl nm nn no b">graphviz.Digraph(filename)</code>，其中<code class="fe nl nm nn no b">filename</code>是所创建的输出文件的名称。我创建了一个从A到H的八个名字的列表，以及该公司所有职位的列表。接下来，通过一个for循环，我为每个名字创建了八个节点，并添加了个人在组织中的相应位置作为标签。我指定了CEO和两个团队领导之间的界限，以及团队领导和他们相应的员工之间的界限。相同的代码如下所示:</p><pre class="lg lh li lj gt np no nq nr aw ns bi"><span id="cc45" class="mz md it no b gy nt nu l nv nw">import graphviz</span><span id="9675" class="mz md it no b gy nx nu l nv nw">f = graphviz.Digraph(filename = “output/plain organogram 1.gv”)</span><span id="374e" class="mz md it no b gy nx nu l nv nw">names = [“A”,”B”,”C”,”D”,”E”,”F”,”G”,”H”]</span><span id="95eb" class="mz md it no b gy nx nu l nv nw">positions = [“CEO”,”Team A Lead”,”Team B Lead”, “Staff A”,”Staff B”, “Staff C”, “Staff D”, “Staff E”]</span><span id="6959" class="mz md it no b gy nx nu l nv nw">for name, position in zip(names, positions):<br/>     f.node(name, position)<br/> <br/>#Specify edges<br/>f.edge(“A”,”B”); f.edge(“A”,”C”) #CEO to Team Leads<br/>f.edge(“B”,”D”); f.edge(“B”,”E”) #Team A relationship<br/>f.edge(“C”,”F”); f.edge(“C”,”G”); f.edge(“C”,”H”) #Team B relationship<br/> <br/>f</span></pre><p id="fd5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果，我得到了如下所示的简单组织图:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ny"><img src="../Images/d881775d6ef4d1c7e5de8c8166ec6a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcIS1HkCmrSL3T2vwsHCqQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">使用graphviz创建的普通组织图。图片作者。</p></figure><p id="ee0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上图中，每个节点的大小会自动调整以适应节点内的标签。对于NetworkX包来说，情况并非如此。</p><h1 id="767e" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">graphviz包的样式和属性</h1><p id="0475" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">如前所述，graphviz包提供了各种样式选项和属性来定制图形。下面详细描述了其中的一些可能性:</p><h2 id="bc27" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">节点形状</h2><p id="4f5c" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">使用graphviz创建的图中节点的默认形状是椭圆。使用graphviz可以获得各种各样的节点形状，可以在这里找到<a class="ae le" href="https://graphviz.org/doc/info/shapes.html" rel="noopener ugc nofollow" target="_blank"/>。这些形状可以是基于多边形的、基于记录的或用户定义的。此外，对于不同节点，也可以得到不同的形状。在下面的代码中，我将CEO的节点形状更改为椭圆形，将两个团队领导的节点形状更改为箱形，将员工的节点形状更改为纯文本。</p><pre class="lg lh li lj gt np no nq nr aw ns bi"><span id="f0d5" class="mz md it no b gy nt nu l nv nw">import graphviz</span><span id="7603" class="mz md it no b gy nx nu l nv nw">f = graphviz.Digraph(filename = "output/plain organogram 2.gv")</span><span id="a6a4" class="mz md it no b gy nx nu l nv nw">names = ["A","B","C","D","E","F","G","H"]</span><span id="73bf" class="mz md it no b gy nx nu l nv nw">positions = ["CEO","Team A Lead","Team B Lead", "Staff A","Staff B", "Staff C", "Staff D", "Staff E"]</span><span id="2783" class="mz md it no b gy nx nu l nv nw">for name, position in zip(names, positions):<br/>    if name == "A":<br/>        f.node(name, position, shape = "oval")<br/>        <br/>    elif name in ["B","C"]:<br/>        f.node(name, position, shape = "box")<br/>    else:<br/>        f.node(name, position, shape = "plaintext")</span><span id="62f4" class="mz md it no b gy nx nu l nv nw">#Specify edges<br/>f.edge("A","B"); f.edge("A","C")   #CEO to Team Leads<br/>f.edge("B","D"); f.edge("B","E")   #Team A relationship<br/>f.edge("C","F"); f.edge("C","G"); f.edge("C","H")   #Team B relationship<br/>    <br/>f</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oe"><img src="../Images/b3be83f6db6d8e2f57b1a209a3491240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FeQrDXiUGOI5qlThE_4amA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">普通组织图，不同员工有不同形状的节点。作者图片。</p></figure><h2 id="40bf" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">节点颜色和边颜色</h2><p id="e68d" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">还可以使用graphviz为不同的节点和边分配不同的颜色。我创建了一个颜色列表，然后使用下面代码中的for循环为每个节点分配一种颜色。我将黑色分配给CEO，将蓝色分配给团队A，将红色分配给团队b。同样，我将蓝色分配给连接团队A的边，将红色分配给连接团队b的边。</p><pre class="lg lh li lj gt np no nq nr aw ns bi"><span id="306a" class="mz md it no b gy nt nu l nv nw">import graphviz</span><span id="b47a" class="mz md it no b gy nx nu l nv nw">f = graphviz.Digraph(filename = "output/colorful organogram 1.gv")</span><span id="13ed" class="mz md it no b gy nx nu l nv nw">names = ["A","B","C","D","E","F","G","H"]</span><span id="dd30" class="mz md it no b gy nx nu l nv nw">positions = ["CEO","Team A Lead","Team B Lead", "Staff A","Staff B", "Staff C", "Staff D", "Staff E"]</span><span id="30ce" class="mz md it no b gy nx nu l nv nw">colors = ["black", "blue", "red", "blue", "blue", "red", "red", "red"]</span><span id="de27" class="mz md it no b gy nx nu l nv nw">for name, position, color in zip(names, positions, colors):<br/>    f.node(name, position, color = color)<br/>    <br/>#Specify edges<br/>#CEO to Team Leads<br/>f.edge("A","B", color = "blue", label = "A"); f.edge("A","C", color = "red", label = "B")   <br/>#Team A<br/>f.edge("B","D", color = "blue"); f.edge("B","E", color = "blue")   <br/>#Team B <br/>f.edge("C","F", color = "red"); f.edge("C","G", color = "red"); f.edge("C","H", color = "red")   <br/>    <br/>f</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi of"><img src="../Images/fe9f1d9c275539734be42b4a85a77301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCOhme5k35yOsxb9gkOxlw.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">使用graphviz创建的具有指定节点和边颜色的有机图。图片作者。</p></figure><h2 id="8d15" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">用颜色填充节点</h2><p id="37aa" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">在这一步，我通过填充节点内部的颜色来进一步定制图表。只需在定义节点和分配颜色时声明<code class="fe nl nm nn no b">style = “filled"</code>即可。</p><pre class="lg lh li lj gt np no nq nr aw ns bi"><span id="b66c" class="mz md it no b gy nt nu l nv nw">import graphviz</span><span id="fbc4" class="mz md it no b gy nx nu l nv nw">f=graphviz.Digraph(filename='output/filled_colorful_organogram.gv')</span><span id="e258" class="mz md it no b gy nx nu l nv nw">names = ["A","B","C","D","E","F","G","H"]</span><span id="acbf" class="mz md it no b gy nx nu l nv nw">positions = ["CEO","Team A Lead","Team B Lead", "Staff A","Staff B", "Staff C", "Staff D", "Staff E"]</span><span id="a4ed" class="mz md it no b gy nx nu l nv nw">colors = ["black", "skyblue", "mistyrose", "skyblue", "skyblue", "mistyrose", "mistyrose", "mistyrose"]</span><span id="4fd3" class="mz md it no b gy nx nu l nv nw">for name, position, color in zip(names, positions, colors):<br/>    if name== "A":<br/>        f.node(name, position, color = color)<br/>    else:<br/>        f.node(name, position, style = "filled", color = color)<br/>    <br/>#Specify edges<br/>f.edge("A","B"); f.edge("A","C")   #CEO to Team Leads<br/>f.edge("B","D"); f.edge("B","E")   #Team A relationship<br/>f.edge("C","F"); f.edge("C","G"); f.edge("C","H")   #Team B relationship<br/>    <br/>f</span></pre><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi og"><img src="../Images/2a513d3572a8edb870255fb9770fbe1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gHHy4n650HJnVJ3sjgEhrA.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">组织图中用指定颜色填充的节点。图片作者。</p></figure><h2 id="e752" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">从终端运行gv文件</h2><p id="d0cd" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">有向图对象<code class="fe nl nm nn no b">f</code>可以显示在<code class="fe nl nm nn no b">gv</code>扩展名的输出Graphviz点文件中，并使用<code class="fe nl nm nn no b">f.view()</code>保存。也可以打印这个用点语言编写的有向图对象的源代码，只需在笔记本中使用<code class="fe nl nm nn no b">f.source</code>即可。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi oh"><img src="../Images/ae7086d7a3d574159488dcf1fcebe359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e49NzPq6loPwBGUYvcbrmQ.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">上面DOT语言中有向图对象的源代码。图片作者。</p></figure><p id="a82d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的txt文件包含了点语言中有向图的源代码。我已经使用<code class="fe nl nm nn no b">pos</code>手动指定了节点的x和y位置。可以使用以下代码在终端中运行该文件:</p><pre class="lg lh li lj gt np no nq nr aw ns bi"><span id="4172" class="mz md it no b gy nt nu l nv nw">dot -Kfdp -n -Tjpeg -Gdpi=300 -O example_digraph.txt</span></pre><p id="9c38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将digraph对象生成为分辨率为300 dpi的jpeg文件。</p><h1 id="dfc8" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">Pydot包</h1><p id="661b" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">pydot包是Graphviz的一个接口。它是用纯Python编写的，可以解析并转储到Graphviz使用的DOT语言中。计算机中的文件夹树结构，由目录、子目录、文件等组成。也是有向图的一个例子。在下一节中，我将解释如何使用pydot包来获得文件夹树结构。</p><h2 id="e897" class="mz md it bd me na nb dn mi nc nd dp mm kr ne nf mo kv ng nh mq kz ni nj ms nk bi translated">使用Pydot包的文件夹树</h2><p id="db1b" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">我首先创建一个名为<code class="fe nl nm nn no b">G</code>的有向图对象。Python中的<a class="ae le" href="https://docs.python.org/3/library/os.html#os-file-dir" rel="noopener ugc nofollow" target="_blank"> os </a>模块提供了一种使用操作系统相关功能的可移植方式。<code class="fe nl nm nn no b">os.getcwd()</code>返回当前工作目录，包括路径，我指定为<code class="fe nl nm nn no b">rootDir</code>。从<code class="fe nl nm nn no b">rootDir</code>中，我只获得目录的名称(graph _ visualisation _ basics)并将其作为<code class="fe nl nm nn no b">currentDir</code>传递。我为<code class="fe nl nm nn no b">currentDir</code>添加一个节点，并用绿色填充。通过使用for循环，我为每个子目录和文件定义了节点，并在它们之间添加了边。接下来，我用黄色填充子目录的节点，用橙色填充文件。同时，我会忽略名称以<code class="fe nl nm nn no b">.</code>开头的隐藏文件夹。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="c069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe nl nm nn no b">Image(G.create_jpeg()</code>创建图形对象的图像，并通过<code class="fe nl nm nn no b">IPython.display.display()</code>显示。使用<code class="fe nl nm nn no b">G.write_jpeg(filename)</code>将图像文件保存为jpeg格式，其中<code class="fe nl nm nn no b">filename</code>是保存文件的名称。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ok"><img src="../Images/6e72cfdce9dfae1dac06532f64073883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNtxmDCqgcO9aM0Wt4JiGg.png"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">文件夹树结构包括使用上述代码创建的根目录、子目录和文件的层次结构。图片作者。</p></figure><h1 id="e09b" class="mc md it bd me mf nz mh mi mj oa ml mm jz ob ka mo kc oc kd mq kf od kg ms mt bi translated">结论</h1><p id="70d6" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">这是Python图形可视化基础系列的第三部分。这个系列背后的动机是分享我在使用SchemDraw、NetworkX和graphviz等包创建流程图和Python中的graph对象时学到的简单技术。在这篇文章中，我以organogram为例描述了如何使用graphviz包创建有向图对象。我还展示了为graphviz提供的图形组件设置样式和添加属性的各种选项。最后，我分享了如何使用Pydot包将系统中的文件夹树结构构建成一个图形。</p><p id="6c4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本系列文章的笔记本可以在这个<a class="ae le" href="https://github.com/hbshrestha/graph_visualisation_basics_with_Python" rel="noopener ugc nofollow" target="_blank">库</a>中找到。感谢您的阅读！</p></div></div>    
</body>
</html>