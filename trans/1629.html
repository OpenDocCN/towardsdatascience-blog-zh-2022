<html>
<head>
<title>How to Find Out the Bottleneck of My Python Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何找出我的Python代码的瓶颈</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-out-the-bottleneck-of-my-python-code-46383d8ef9f#2022-04-19">https://towardsdatascience.com/how-to-find-out-the-bottleneck-of-my-python-code-46383d8ef9f#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1805" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以战略性的方式调试性能问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/733471e2f0ab0f86664a950918ba293b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NuQh8IgNVNJD1VIw"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由Unsplash的makariostang 拍摄</p></figure><p id="892c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> M </span>通常情况下，开发人员需要优化代码以使其性能更好。这听起来像是正确的做法，但并不总是如此。代码优化是一个模糊的术语。没有明确的目标，很容易掉进兔子洞，浪费时间。在本文中，我想告诉你一个找到代码瓶颈的战略方法——从理解你是否应该优化你的代码到找出哪个函数导致了性能问题。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="e875" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">应该优化什么，什么时候优化？</h2><p id="cd7c" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们所说的代码优化是指重写代码，以便程序执行得更快，并使用更少的内存、CPU、磁盘空间或网络带宽。那么，是不是每个程序都需要偶尔优化一下呢？不会。通常，只有少数几类程序需要优化。</p><p id="840f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">实时应用</strong></p><p id="576b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成熟的实时应用如Apache Kafka和RabbitMQ以其高吞吐量和低延迟而闻名。许多公司已经在自己的环境中安装了它们。由于设置不同，性能可能会有所不同。</p><p id="6e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个<a class="ae ky" href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines" rel="noopener ugc nofollow" target="_blank">基准</a>可以帮助您评估性能。如果您发现与基准测试相比速度不够快，您可以微调配置或纵向或横向扩展硬件。</p><p id="9da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">具有SLA的应用</strong></p><p id="712b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种类型的程序是具有严格服务水平协议(SLA)的程序。换句话说，程序必须在一定的时间限制内交付结果，否则，它可能会影响业务。很明显，SLA是一个硬门槛，但是不要等到它过线了，那就来不及了。预防措施之一是监控流程，如果发现增长趋势或偏差模式，则发出警报。</p><p id="e4c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">其他行为异常的应用</strong></p><p id="ed72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">做代码优化的原因不是因为开发者的神感(虽然有帮助)，而是数字和事实。在这种情况下，监测起着至关重要的作用。它帮助开发人员理解程序在晴天如何运行，并从那里发现雨天。例如，资源(CPU/内存/磁盘)使用率呈上升趋势、峰值时间、可疑日志等。根本原因可能是多方面的——资源不足、代码中的错误、来自外部的高负载等等。</p><p id="fb1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经验法则是，如果程序与期望的速度相比不够快，就应该优化代码，无论是基准测试、SLA还是过去的平均性能。通过监控和警报，可以了解系统的健康状况，并帮助开发人员了解使用或行为的趋势，以便采取预先措施。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="23c1" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">优化什么？—硬件</h2><p id="3aa7" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">当你对数字感到失望时，下一步就是采取行动。开发人员很容易被各种解决方案淹没。大多数性能问题都与运行太慢或使用太多内存有关。</p><p id="5163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个潜在的解决方案是拥有更好的硬件。借助云计算，添加更多内核或内存可以在几秒钟内完成。但像任何解决方案一样，它也有利弊。添加更多资源是一种简单快捷的解决方案，可以有效地解决紧急生产问题。但是如果这是您解决性能问题的唯一解决方案，那么您的程序将会非常昂贵。横向扩展会导致成本倍增，而纵向扩展可能会达到云提供商为单台机器所能提供的极限。根据程序的设计，这可能需要从单台机器到分布式系统的代码重构。</p><p id="8a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要假设硬件是唯一的解决方案，在对代码进行并行化之前，一定要先在只有一个CPU和有限内存的机器上优化代码。在很多情况下，花时间在代码优化上是值得的。比如算法优化——将时间复杂度从O(n)提高到O(nlogn)或O(n)，语言切换——使用基于CPython的库或使用缓存减少繁重的I/O操作量等。</p><p id="3b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个问题是——我如何知道应该优化代码的哪一部分，因为重写整个代码肯定不是一个明智的决定。在下一节中，我将介绍Python中的程序概要分析，它可以帮助开发人员快速找到繁重的操作，并从那里进行改进。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="be2b" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">优化什么？—软件</h2><p id="6940" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">为了找出生产应用中的性能瓶颈，开发人员需要可操作的洞察力。一种现代的方法是应用分析，突出最慢的代码，即消耗大部分资源(如CPU和内存)的区域。剖析可以是生产(或类似生产的环境)中的<strong class="lb iu">一次性操作</strong>或<strong class="lb iu">持续过程</strong>。不同的分析器使用不同的方法收集信息，因此具有不同的运行时开销。为您的用例选择正确的分析器非常重要。</p><p id="9fce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一节中，我将介绍两种不同的分析方法和几种可视化结果的方式。</p><p id="6bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">举例</strong></p><p id="467d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将剖析这个<a class="ae ky" href="https://github.com/pletzer/scatter" rel="noopener ugc nofollow" target="_blank"> repo </a>的代码——一个计算入射波在2D物体上散射的简单程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/e922cfa44bf7d159e5c985a72d59363f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9sa-C8SM3mSg7Vtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://nesi.github.io/perf-training/python-scatter/introduction" rel="noopener ugc nofollow" target="_blank">https://nesi . github . io/perf-training/python-scatter/introduction</a></p></figure><p id="b329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">确定性分析器</strong></p><p id="7577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能听说过cProfile，这是Python中的一个内置分析器。cProfile是一个<a class="ae ky" href="https://docs.python.org/3/library/profile.html#what-is-deterministic-profiling" rel="noopener ugc nofollow" target="_blank">确定性分析器</a>，它反映了所有<em class="nj">函数调用</em>、<em class="nj">函数返回</em>和<em class="nj">异常</em>事件都被监控，并且这些事件之间的时间间隔被精确计时。</p><p id="9d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种类型的剖析器可以收集高分辨率的剖析信息，但有一个主要缺点:<strong class="lb iu">高开销</strong>。可以想象，如果应用程序有大量的函数调用，那么分析器将会收集太多的记录。如果函数很小，那么由于分析器本身的开销，结果可能不准确。</p><p id="e1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，下面是如何在这个例子中使用cProfile。cProfile的总执行时间是89.03秒。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8319" class="ml mm it nm b gy nq nr l ns nt">python -m cProfile scatter.py</span></pre><blockquote class="nu nv nw"><p id="aece" class="kz la nj lb b lc ld ju le lf lg jx lh nx lj lk ll ny ln lo lp nz lr ls lt lu im bi translated">如果没有cProfile，这个程序需要80.50秒，快了10%。因此，不建议在生产执行期间使用。</p></blockquote><p id="2c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">cProfile的输出如下所示，其中每一行都是执行过程中的一个函数调用。它记录了调用的次数、在该函数中花费的总时间，以及在该函数和所有子函数中花费的累计时间等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/423739423d0dbff67fceb92933ab431a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jc2mJiYKPQnoGM-NZBOabQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">cProfile的输出由<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="9a41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这个表对人类来说很难解释，因为它包含了太多我们并不真正关心的信息，比如Python的内部函数。此外，我们不知道每个函数如何与其他函数相关，也不知道较慢的函数的输入是什么。如果一个函数被多个函数调用，就很难找出哪个路径和相应的输入导致了缓慢。</p><p id="8b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种解决方案是将结果可视化为图形，以了解函数之间的关系。由于cProfile不提供任何可视化，我们需要使用像<code class="fe od oe of nm b"><a class="ae ky" href="https://jiffyclub.github.io/snakeviz/" rel="noopener ugc nofollow" target="_blank">snakeviz</a></code>和<code class="fe od oe of nm b"><a class="ae ky" href="https://github.com/jrfonseca/gprof2dot" rel="noopener ugc nofollow" target="_blank">gprof2dot</a></code>这样的库来实现。</p><p id="0554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">snakeviz </p><p id="9160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在命令行使用cProfile来创建一个配置文件，并使用snakeviz来解释结果。Snakeviz有两种可视化风格——冰柱和旭日。在一个函数中花费的时间由矩形的宽度或弧的角度范围来表示。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="139a" class="ml mm it nm b gy nq nr l ns nt">python -m cProfile -o <!-- -->scatter<!-- -->.prof <!-- -->scatter<!-- -->.py <br/># <!-- -->Execution time : 86.27 sec<br/>snakeviz scatter.prof</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/30a6be8231d58e8f2b7c2b879107e918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AXptUJL1mkR4Wp8xzT4KBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蛇语(冰柱作者:高T5)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/9e148f86a0ccdd231c82a45361133df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8x7JvUhG6k1ZO66OY_Taw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蛇语(旭日东升<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><p id="f81b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nj"> gprof2dot </em></p><p id="94e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gprof2dot创建了另一种可视化类型——点状图。我更喜欢这种类型的图表，因为它清楚地显示了功能之间的关系，颜色对比更容易发现重要的功能。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6eeb" class="ml mm it nm b gy nq nr l ns nt">gprof2dot --colour-nodes-by-selftime -f pstats output.pstats | \<br/>    dot -Tpng -o output.png</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/913cec6a6e216ef36117bc1b0e514310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EH8gMwJMb3RdO-OcKOefg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe od oe of nm b">gprof2dot (by @Xiaoxu Gao)</code>的输出</p></figure><p id="01f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">统计分析器</strong></p><p id="dda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只想在本地笔记本电脑上开发和调试应用程序的过程中大致了解一下性能，那么cProfile是可以的。但是不建议在生产中使用它，因为可能会有明显的性能影响。这就是统计剖析器的用处。</p><p id="50ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它通过定期对执行状态进行采样来测量应用程序的性能。这种方法不如确定性分析准确，但是它的开销也较小。由于开销较小，它可用于监控生产中正在进行的过程。对于某些应用程序，分析必须是生产中的一个连续过程，在其他环境中很难发现性能问题。</p><p id="3192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将列出一些最流行的统计分析器。他们中的大多数都有一个内置的可视化解决方案，所以我们不需要额外的软件包。</p><p id="a742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/joerick/pyinstrument" rel="noopener ugc nofollow" target="_blank"> <em class="nj"> pyinstrument </em> </a></p><p id="5547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nm b">pyinstrument</code>是一个统计python分析器，它每1 ms记录一次调用堆栈，而不是记录整个跟踪。您可以从命令行直接调用<code class="fe od oe of nm b">pyinstrument</code>:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="17f9" class="ml mm it nm b gy nq nr l ns nt">pyinstrument scatter.py</span></pre><p id="e499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以生成交互式网页:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c339" class="ml mm it nm b gy nq nr l ns nt">pyinstrument -r html -o output.html scatter.py</span></pre><p id="e7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与cProfile的原始输出不同，<code class="fe od oe of nm b">pyinstrument</code>给出了一个突出显示的函数调用树，这更容易理解。它花费的时间也比cProfile少。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/89247b9e3584878b1175ae74b8c33f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvEO0uYtn-cS5Jq3Aokw0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pyinstrument的输出(由<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="ddd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从树中可以明显看出<code class="fe od oe of nm b">computerScatteredWaveElement</code>函数是瓶颈。我非常喜欢<code class="fe od oe of nm b">pyinstrument</code>的简单性，它已经成为我的首选Python分析器。</p><p id="4149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nm b"><a class="ae ky" href="https://pyinstrument.readthedocs.io/en/latest/guide.html#profile-a-specific-chunk-of-code" rel="noopener ugc nofollow" target="_blank">pyinstrument</a></code> <a class="ae ky" href="https://pyinstrument.readthedocs.io/en/latest/guide.html#profile-a-specific-chunk-of-code" rel="noopener ugc nofollow" target="_blank">提供了一个Python接口</a>来剖析你的一大块代码。它帮助开发者只关注最有趣的部分。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e72d" class="ml mm it nm b gy nq nr l ns nt"><strong class="nm iu">from</strong> <strong class="nm iu">pyinstrument</strong> <strong class="nm iu">import</strong> Profiler<br/><br/>profiler = Profiler()<br/>profiler.start()<br/><br/>computerScatteredWaveElement()<br/><br/>profiler.stop()<br/>profiler.print()</span></pre><p id="5b5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://pyinstrument.readthedocs.io/en/latest/how-it-works.html#async-profiling" rel="noopener ugc nofollow" target="_blank">文件</a>，<code class="fe od oe of nm b">pyinstrument</code>可以配置<code class="fe od oe of nm b">async</code>功能。例如，我有一个简单的<code class="fe od oe of nm b">asyc</code>函数:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5f9f" class="ml mm it nm b gy nq nr l ns nt">import asyncio<br/>from pyinstrument import Profiler</span><span id="0f69" class="ml mm it nm b gy oj nr l ns nt">async def main():<br/>  p = Profiler()<br/>  with p:<br/>    await asyncio.sleep(5)<br/>  p.print()</span><span id="f881" class="ml mm it nm b gy oj nr l ns nt">asyncio.run(main())</span></pre><p id="079c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示。它通过跟踪主线程来工作。任何花费在主线程之外的时间都归于<code class="fe od oe of nm b">await</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/721350036a5dedb097536e59de46e737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1dPLqdm4xO5gHFfEWakJFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">pyinstrument异步仿形的输出(由<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure><p id="2bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nm b">pyinstrument</code>的一个缺点是它只能分析主线程，所以不能在多线程应用程序中使用。例如，我有一个简单的多线程代码:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="454e" class="ml mm it nm b gy nq nr l ns nt">def thread_function(name):<br/>  time.sleep(2)</span><span id="b10d" class="ml mm it nm b gy oj nr l ns nt">if __name__ == "__main__":<br/>  with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:<br/>    executor.map(thread_function, range(3))</span></pre><p id="51c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，输出忽略了其他两个线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7f88aac9c7c0827fe0746f0be150fe43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1xH6FP12zHfwOp4nSq65yQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在多线程代码上使用pyinstrument的输出(作者:<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="e5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/sumerc/yappi" rel="noopener ugc nofollow" target="_blank"> <em class="nj"> yappi </em> </a></p><p id="f862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">yappi代表另一种python分析器。它支持多线程、asyncio和gevent代码的分析。因为它是用C语言设计的，所以与用Python设计的分析器相比，它运行得更快。它还支持对代码的特定部分进行分析。</p><p id="fc88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是多线程应用程序的分析输出。您可以通过<code class="fe od oe of nm b">yappi.get_thread_stats()</code>检查每个线程的性能。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="33ce" class="ml mm it nm b gy nq nr l ns nt">threads = yappi.get_thread_stats()<br/>for thread in threads:<br/>  yappi.get_func_stats(ctx_id=thread.id).print_all()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/086d351ed330e28ad695c945044e6a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNY2XMW4vLwmsz1vXnH_pA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雅皮的产量(作者:高)</p></figure><p id="ee81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank"> py-spy </a></p><p id="1111" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nm b">py-spy</code>是另一个统计剖析器。一个重要的特性是，您可以将探查器附加到现有的进程上。<strong class="lb iu">这使得它非常适合长期运行的生产应用程序。</strong></p><p id="3234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of nm b">py-spy</code>获取应用程序的PID或想要运行的python程序的命令行。它从不同的python进程中读取内存，出于安全原因，这可能是不允许的。在某些操作系统中，您需要作为根用户运行它。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="647e" class="ml mm it nm b gy nq nr l ns nt">sudo py-spy record -o profile.svg -- python scatter.py<br/># Execution time : 78.78 sec<br/># Or<br/>sudo py-spy record -o profile.svg --pid &lt;pid&gt;</span></pre><p id="d391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是一个冰柱图，类似于snakeviz。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/65bace5e3f529eb25095d020d023efd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXT86XvUREi2VW3CSznvew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">py-spy的输出(作者:高T5)</p></figure><p id="7e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nj">其他剖析器</em></p><p id="c7b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我列出了一些其他选项供您探索和尝试。</p><p id="f752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nj">扑通:一个低开销的分析器</em></p><p id="557d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扑通是一个低开销的分析器，自2019年以来一直没有开发。它具有网络风格的可视化，其中圆圈的大小基于函数所花费的时间。箭头粗细表示函数被调用的频率。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0c4a" class="ml mm it nm b gy nq nr l ns nt">python -m plop.collector scatter.py<br/># Execution time : 73.72 sec<br/># profile output saved to profiles/scatter.py-20220418-1013-32.plop<br/># overhead was 1.1695748642208658e-05 per sample<br/># (0.0011695748642208657%)<br/>python -m plop.viewer --datadir=profiles/</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/c835e4a53bdd0053c183e9cdc598d9d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74ApV6vVpCZXr9mSDu6dlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扑通的输出(由<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a>)</p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="e7e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">内存分析器</strong></p><p id="e6aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了分析CPU时间，有时了解内存使用情况也很重要。<a class="ae ky" href="https://github.com/pythonprofilers/memory_profiler" rel="noopener ugc nofollow" target="_blank"> memory-profiler </a>是一个python模块，用于监控进程的内存消耗以及逐行分析内存消耗。它提供了一个装饰器接口，所以它不会创建太多的样板代码。</p><p id="d2f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出显示每一行的内存使用和增量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/1e3c3982f1636e293ffcf7fee033d844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sj84XAh3F3ukBXeG2msRSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存分析器的输出(作者:<a class="ob oc ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----46383d8ef9f--------------------------------" rel="noopener" target="_blank">高</a></p></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="0dd1" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">结论</h2><p id="8119" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">希望这篇文章对你有用！我们已经讨论了何时(不)优化我们的应用程序，以及在必要时如何做。一个快速的解决方案是改进硬件，但这不是一个可持续的解决方案，因为它最终会达到硬件的极限。另一种选择是分析应用程序，并重构导致性能问题的代码部分。</p><p id="d1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种类型的分析器。请务必了解每种分析器的优缺点，并选择适合您的用例的分析器。如果您有任何意见或想法，请告诉我。调试愉快！干杯！</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h2 id="d58a" class="ml mm it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">参考</h2><div class="oq or gp gr os ot"><a href="https://granulate.io/introduction-to-continuous-profiling/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">粒状博客——连续应用程序剖析:概述</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">通常，开发人员需要调查生产应用程序中的性能瓶颈，并…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">grate . io</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://pythonspeed.com/articles/do-you-need-cluster-or-multiprocessing/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">优化代码不同于并行化代码</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">你正在用Python处理大量的数据，这种处理似乎很容易并行化——而且速度很慢…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">pythonspeed.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>