<html>
<head>
<title>Time Series Classification with LightGBM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于LightGBM的时间序列分类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-classification-with-lightgbm-d79d2d81bfd0#2022-07-04">https://towardsdatascience.com/time-series-classification-with-lightgbm-d79d2d81bfd0#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="86ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用LazyProphet的示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48389f15f0ea32d9b09100080b5001a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8Jf7_GFFsRT-TEyuhdEWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/s/photos/colorful-trees?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@invisiblepower?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">隐形力量</a>拍摄的照片</p></figure><p id="cc4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理时间序列数据时，分类是一项常见的任务。类似于时间序列回归，趋势和季节性的存在使这项任务变得困难。幸运的是，使用LightGBM进行回归所得到的相同特性也可以用于分类。通过使用<a class="ae ky" href="https://github.com/tblume1992/LazyProphet" rel="noopener ugc nofollow" target="_blank"> LazyProphet </a>，这个任务就变得简单了。</p><h1 id="8cb5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">介绍</h1><p id="7637" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这篇文章是我之前对LazyProphet的评论的后续:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/lazyprophet-time-series-forecasting-with-lightgbm-3745bafe5ce5"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">LazyProphet:用LightGBM进行时间序列预测</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">都是关于功能的</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><p id="92dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那篇文章中，我们解决了标准时间序列回归问题，并在M4数据集上实现了单变量时间序列树的最先进(我认为)的结果。关键在于利用线性分段基函数。虽然并不都是独一无二的，但我们添加了一个扭曲——函数被加权以更好地适应数据。这使得树实现了显著更好的性能。如果你不知道这些是什么，一定要看看之前的文章！</p><p id="fbaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，LazyProphet还提供了“递归”预测功能，即使用以前的目标值进行预测。这要求我们在过程中的某个时刻使用未来预测，这对于从头开始编码和处理来说有点烦人。</p><p id="c20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们也有一些独特的方式来思考树木的趋势，这也有助于改进，你可以在这里查看一篇文章:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/handling-trends-in-tree-based-time-series-forecasting-fea5e4c066fb"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">基于树的时间序列预测中的趋势处理</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">事实是——没有趋势</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ks mv"/></div></div></a></div><p id="7af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，这些相同的技术也可以用来解决分类问题。在本文中，我们将快速浏览一下用<a class="ae ky" href="https://github.com/tblume1992/LazyProphet" rel="noopener ugc nofollow" target="_blank"> LazyProphet </a>解决这样一个问题。</p><p id="d2ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是首先，如果您还没有安装这个包，那么只需要一点点:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="648b" class="nq lw it nm b gy nr ns l nt nu">pip install LazyProphet</span></pre><p id="aebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看数据。</p><h1 id="3989" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例子</h1><p id="086f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于这个例子，我们将使用Scikit-Learn开放数据集的一个例子:自行车共享需求数据集。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="deac" class="nq lw it nm b gy nr ns l nt nu">from sklearn.datasets import fetch_openml<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>sns.set_style('darkgrid')</span><span id="4677" class="nq lw it nm b gy nv ns l nt nu">bike_sharing = fetch_openml("Bike_Sharing_Demand", version=2, as_frame=True)<br/>y = bike_sharing.frame['count']<br/>y = y[-800:].values<br/>plt.plot(y)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/5a82832d5fc84298061c165dc7ba74dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*WRFXP50b2zi1lRT0EqdHSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这些数据不是为二进制分类创建的，所以让我们来解决这个问题。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ea16" class="nq lw it nm b gy nr ns l nt nu">y_class = y &gt; 70<br/>y_class = y_class * 1<br/>plt.plot(y_class)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/127a2307b217dc0de955b9658cd3badb.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*TUSstzN89b3DiOnApaAcYg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="14fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们简单地将任何超过70的值标记为1，将所有低于0的值标记为0。显然存在一些季节性，以及600到700小时之间的一些“冲击”。</p><p id="6f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们简单地构建模型:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="7553" class="nq lw it nm b gy nr ns l nt nu">from LazyProphet import LazyProphet as lp</span><span id="281c" class="nq lw it nm b gy nv ns l nt nu">lp_model = lp.LazyProphet(seasonal_period=[24],<br/>                          n_basis=10,<br/>                          objective='classification',<br/>                          fourier_order=5,<br/>                          decay=.99,<br/>                          ar=3,<br/>                          return_proba=True)</span></pre><ul class=""><li id="6f9c" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><code class="fe oh oi oj nm b">seasonal_period</code> —数据的季节性。我们可以传递一个<em class="ok"> int </em>或<em class="ok"> float </em>以及一个<em class="ok"> list </em>。如果我们传递一个列表，我们可以为复杂的季节性传递多个值，比如<code class="fe oh oi oj nm b">[7, 365.25]</code>。</li><li id="37bf" class="ny nz it lb b lc ol lf om li on lm oo lq op lu od oe of og bi translated"><code class="fe oh oi oj nm b">n_basis</code> —要使用的分段基函数的数量。这是用来衡量“趋势”以及允许季节性随时间变化。</li><li id="d609" class="ny nz it lb b lc ol lf om li on lm oo lq op lu od oe of og bi translated"><code class="fe oh oi oj nm b">objective</code>—<code class="fe oh oi oj nm b">'classification'</code>或<code class="fe oh oi oj nm b">'regression'</code>。如果我们通过了<code class="fe oh oi oj nm b">classification</code>，那么LazyProphet使用一个二元交叉熵目标函数。如果我们通过<code class="fe oh oi oj nm b">regression</code>，那么LazyProphet将使用RMSE。</li><li id="efef" class="ny nz it lb b lc ol lf om li on lm oo lq op lu od oe of og bi translated"><code class="fe oh oi oj nm b">fourier_order</code> —用于近似季节性脉冲的正弦和余弦分量的数量。数字越大，它就越适合摆动！</li><li id="9bb3" class="ny nz it lb b lc ol lf om li on lm oo lq op lu od oe of og bi translated"><code class="fe oh oi oj nm b">decay</code> —趋势基函数的“衰减”或惩罚权重。如果你不知道这是什么，那么看看前面提到的文章。</li><li id="0c10" class="ny nz it lb b lc ol lf om li on lm oo lq op lu od oe of og bi translated"><code class="fe oh oi oj nm b">ar</code> —用于预测的过去值的数量。如果我们在这里传递一个int，那么LazyProphet会自动进行一步预测，并将该预测用于整个预测范围的下一步。</li><li id="ab33" class="ny nz it lb b lc ol lf om li on lm oo lq op lu od oe of og bi translated"><code class="fe oh oi oj nm b">return_proba</code> —布尔标志，如果设置为<code class="fe oh oi oj nm b">True</code>，则LazyProphet返回概率，如果设置为<code class="fe oh oi oj nm b">False</code>，则仅返回[1，0]分类。</li></ul><p id="0207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们只需要将模型与我们的数据相匹配，并预测100步:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="49cc" class="nq lw it nm b gy nr ns l nt nu">fitted = lp_model.fit(y_class)<br/>predicted_class = lp_model.predict(100)<br/>plt.plot(y_class)<br/>plt.plot(np.append(fitted, predicted_class), alpha=.5)<br/>plt.axvline(800)<br/>plt.show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4e29255a8b9ae488b2fa9b44432b09ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*nUy2jRaSSJt_KsSTUOYiEg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧！</p><p id="d7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对概率有一个合理的预测。当然，树模型与训练数据<em class="ok">不合理地</em>拟合得很好，所以我们应该小心评估我们的拟合度。可以用不同的超参数进行进一步的迭代。</p><p id="df4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时(比如在这个例子中),我们的标签是由一个实数而不是二进制数的时间序列派生出来的，或者与这个时间序列密切相关。如果是这种情况，我们只需要在构建模型对象时传递该系列。看起来会像这样:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="20a7" class="nq lw it nm b gy nr ns l nt nu">lp_model = lp.LazyProphet(seasonal_period=[24],<br/>                          n_basis=3,<br/>                          objective='classification',<br/>                          fourier_order=5,<br/>                          decay=.99,<br/>                          #ar=3, ar should be turned off here<br/>                          return_proba=True,<br/>                          series_features=y,<br/>                          )</span></pre><p id="8861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中“y”是我们处理成二元分类标签的原始系列。<strong class="lb iu">注意</strong> <strong class="lb iu">需要禁用ar</strong>。从这里开始，其余的程序是相同的！</p><h1 id="805b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="38f9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我们尝试用LazyProphet进行时间序列分类。因为核心是用LightGBM构建的，所以从回归问题转换到分类问题非常容易。但是，我们看到的真正性能提升来自加权基函数。</p><p id="dd1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请务必查看github 并公开您遇到的任何问题！</p><p id="43ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能会喜欢我写的其他几篇:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/gradient-boosted-arima-for-time-series-forecasting-e093f80772f6"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">时间序列预测的梯度增强ARIMA</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">提升PmdArima的Auto-Arima性能</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="oq l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/thymeboost-a0529353bf34"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">用百里香增强进行时间序列预测</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">一种梯度增强的时间序列分解方法</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="or l ng nh ni ne nj ks mv"/></div></div></a></div></div></div>    
</body>
</html>