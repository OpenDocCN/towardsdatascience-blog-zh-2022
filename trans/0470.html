<html>
<head>
<title>Create an Interactive Bubble Plot with PyQt5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyQt5创建交互式气泡图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/create-an-interactive-bubble-plot-with-pyqt5-48a6e0c1d0f7#2022-02-18">https://towardsdatascience.com/create-an-interactive-bubble-plot-with-pyqt5-48a6e0c1d0f7#2022-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cc21" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用GUI使Matplotlib图更吸引人</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1970e6101ce9a88d44ac8919a2bb3bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6RACvN2lrXhN-qJTRhV_eQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用PyQt5和Matplotlib创建的最终输出</p></figure><p id="85ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">pyqt 5简介</strong></p><p id="e689" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Qt GUI框架用于创建跨平台的用户界面。该框架是用C++编写的，但是PyQt5库允许它被导入并直接在Python中使用。它的易用性使它成为用Python创建GUI的最流行的应用程序之一。</p><p id="fb51" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">PyQt5在Python的数据可视化中有许多用途，其中一个是在matplotlib中制作的交互式绘图。交互式绘图允许以有效的方式交流更复杂的数据。在这篇文章中，我将演示如何创建一个交互式气泡图，以便用户可以深入数据。</p><p id="1df2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">系统需求</strong></p><p id="f6dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我使用了JupyterNotebook，但是也可以使用任何IDE。如果版本是允许交互式绘图的Matplotlib notebook，则matplotlib只能与PyQt5集成。</p><p id="eb6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Jupyter Notebook中，需要运行行%matplotlib notebook来更改预设，因为%matplotlib inline不允许交互式绘图。如果正在使用IDE，matplotlib notebook是自动设置。</p><p id="98c1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第一步:制作泡泡图</strong></p><p id="3caa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将使用的数据集是中情局每年出版的《2020年世界概况》。该数据集包含世界上每个国家的人民、经济和政府的一般信息。</p><p id="2fb1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">可以从这里下载:</p><p id="892a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://www.cia.gov/the-world-factbook/about/archives/download/factbook-2020.zip" rel="noopener ugc nofollow" target="_blank">https://www . CIA . gov/the-world-factbook/about/archives/download/factbook-2020 . zip</a></p><p id="f3a3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该数据集中使用的变量有:</p><ul class=""><li id="5d43" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">x:人均国内生产总值</li><li id="c67e" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">y:预期寿命</li><li id="f3e1" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">色调:出生率</li><li id="2398" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">规模:人口</li></ul><p id="8715" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">导入库</strong></p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5927" class="ml mm iq mh b gy mn mo l mp mq">from matplotlib import pyplot as plt<br/>import pandas as pd<br/>import seaborn as sns</span></pre><p id="8dfa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">数据清理</strong></p><p id="5bc4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在图表中使用每个变量之前，需要对其进行一些数据清理和数据扩充。</p><p id="7af4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">x变量:人均GDP目前是一个包含逗号和美元符号的字符串，需要删除这两个符号才能将字符串转换为整数值。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="07f2" class="ml mm iq mh b gy mn mo l mp mq">df = pd.read_csv(“factbook.csv”)</span><span id="a0df" class="ml mm iq mh b gy mr mo l mp mq">df[“GDP per Capita”] = df[“GDP per capita”].str.replace(‘,’,’’).str.replace(‘$’,’’).astype(float).astype(int)</span></pre><p id="eb95" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">y变量:出生率目前是一个连续变量，但由于它用于色调，因此需要通过创建箱来将其变为离散变量。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="9357" class="ml mm iq mh b gy mn mo l mp mq">bi = []<br/>for i in range(0,60,10):<br/>bi.append(i)<br/>df[‘Birth Rate’] =(pd.cut(df[‘ Birth rate’], bins = bi)</span></pre><p id="5b31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Size变量:Population当前是一个由逗号组成的字符串，为了转换成整数，需要删除逗号。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="8dab" class="ml mm iq mh b gy mn mo l mp mq">df[‘Population (M)’]=(df[‘Population’].str.replace(‘,’,’’)).astype(int)</span></pre><p id="437b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Seaborn是一个基于matplotlib构建的数据可视化库，将用于制作这个气泡图。也可以使用传统的matplotlib库。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="9d29" class="ml mm iq mh b gy mn mo l mp mq">bubble = sns.scatterplot(data=df, x=”GDP per Capita”, y=”Life expectancy at birth”, size=”Population (M)”, hue=”Birth Rate”, legend= True, sizes=(10, 300))</span></pre><p id="ca7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加尺寸和颜色的图例，并显示绘图。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="0339" class="ml mm iq mh b gy mn mo l mp mq">bubble.legend()<br/>plt.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/ce7476d9e3d9020865242c87c1893577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ICEWHm_SaIwF5PYA"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">锡伯恩地块</p></figure><p id="f19f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个初始图表清楚地显示了四个变量之间的关系。试图添加额外的变量会使可视化变得混乱，但是，在这个数据集中仍然有五个其他的变量。通过使可视化具有交互性，用户可以通过查看不同变量之间如何相互作用来更深入地研究数据。</p><p id="46ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第二步:设置PyQt5 </strong></p><p id="91af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用下面的import语句下载PyQt5的所有库和依赖项。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="3fff" class="ml mm iq mh b gy mn mo l mp mq">from PyQt5.QtWidgets import QDialog, QApplication, QPushButton, QVBoxLayout, QLabel, QComboBox, QSlider<br/>from PyQt5.QtCore import Qt<br/>from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas<br/>import math<br/>import sys<br/>import re</span></pre><p id="33ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先创建一个类和构造函数。然后设置弹出窗口的几何图形(指定几何图形是什么)。我选择do (400，400，900，900 ),因为我认为这对于用户来说足够大，可以从图中捕捉细节。setGeometry的参数是x、y、宽度和高度。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="1460" class="ml mm iq mh b gy mn mo l mp mq">class Window(QDialog):<br/># constructor<br/>def __init__(self, parent=None):<br/>    self.setGeometry(400, 400, 900, 900)</span></pre><p id="d722" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第三步:在构造函数中添加小部件</strong></p><p id="9f29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Widget 1: FigureCanvas </strong></p><p id="8286" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">图形小部件用于在可视化中显示图形。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="7a97" class="ml mm iq mh b gy mn mo l mp mq">self.figure = plt.figure()<br/>self.canvas = FigureCanvas(self.figure)</span></pre><p id="f1c8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Wiget 2: QComboBox </strong></p><p id="fd39" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在每个ComboBox的构造函数中添加代码。下面的代码是我命名为xComboBox的第一个代码，用于捕获x轴变量的用户输入。首先，初始化并命名ComboBox。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="22e3" class="ml mm iq mh b gy mn mo l mp mq">self.xComboBox = QComboBox(self)</span></pre><p id="2542" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">向ComboBox中添加项。addItems()用于包含选项的列表。在这种情况下，所有列名都作为选项添加到组合框中。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="2b08" class="ml mm iq mh b gy mn mo l mp mq">self.xComboBox.addItems([“Area”,”Death rate”, “ Birth rate”,”GDP per capita”,”Population”,”Electricity consumption”, “Highways”, “Total fertility rate”, “Life expectancy at birth”])</span></pre><p id="cc10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Wiget 3: QLabel </strong></p><p id="e10b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要创建一个标签，以便让用户知道其他小部件的用途。在这种情况下，它将允许用户知道组合框中的值将用于什么。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="34a4" class="ml mm iq mh b gy mn mo l mp mq">self.xLabel = QLabel(“&amp;X:”)</span></pre><p id="92ab" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建的标签需要链接到ComboBox，以使其成为一个组合对象。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="0e7d" class="ml mm iq mh b gy mn mo l mp mq">self.xLabel.setBuddy(self.xComboBox)</span></pre><p id="b211" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Wiget 4: QSlider </strong></p><p id="2690" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">滑块用于允许用户调整可视化中的值。PyQt5中的小部件是QSlider，它有一个必需的方向参数，可以是Qt。在这种情况下，水平方向在视觉上是最吸引人的。在这个可视化中，滑块将改变大小变量，以便用户可以增加或减少气泡，以确定可视性的最佳大小。(再看这个)</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="8e73" class="ml mm iq mh b gy mn mo l mp mq">self.mySlider = QSlider(Qt.Horizontal, self)</span></pre><p id="fceb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">滑块的几何形状需要调整，以最适合GUI窗口。setGeometry的参数同上，x，y，width和height。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="17b9" class="ml mm iq mh b gy mn mo l mp mq">self.mySlider.setGeometry(30, 40, 200, 30)</span></pre><p id="1fd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要将函数链接到滑块，以便在可视化中利用其值。首先，。需要使用valueChanged[int]来获得基于滑块位置的当前值。用要使用的函数名连接()。下面的按钮小部件中也会用到所使用的函数，这将在一节中讨论。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="d2b2" class="ml mm iq mh b gy mn mo l mp mq">self.mySlider.valueChanged[int].connect(self.changeValue)</span></pre><p id="ac9d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">小工具5:按钮</strong></p><p id="a920" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用QPushButton创建按钮小部件。这个函数中的参数是以字符串形式传入的按钮名称。按钮名为“绘制当前属性”,任何时候用户更改滑块值或组合框值时，都需要按下该按钮来更新图形。还需要有一个功能连接到按钮，以编程的行动时，按下执行。我创建了一个名为changeValue的函数，用于按钮和滑块。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="8a5b" class="ml mm iq mh b gy mn mo l mp mq">button = QPushButton(“Plot Current Attributes”, self)<br/>button.pressed.connect(self.changeValue)</span></pre><p id="c73b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> changeValue:滑块和按钮功能</strong></p><p id="38e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">按钮和滑块小部件需要连接到一个函数，以便在可视化中使用它们的值。我创建的changeValue函数可用于按钮和滑块。这可以通过*args参数实现，它允许传递任意数量的参数。对于按钮，调用函数时不会传递任何参数，但对于滑块，将传递位置值。这个函数在构造函数之外。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="ab91" class="ml mm iq mh b gy mn mo l mp mq">def changeValue(self, *args):</span></pre><p id="d139" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">检索用于散点图的comboBox小工具的所有当前值。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="3fe0" class="ml mm iq mh b gy mn mo l mp mq"># finding the content of current item in combo box<br/>x = self.xComboBox.currentText()<br/>y = self.yComboBox.currentText()<br/>s = self.sComboBox.currentText()<br/>c = self.cComboBox.currentText()</span></pre><p id="8566" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">清除当前剧情并创建新的支线剧情。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="804c" class="ml mm iq mh b gy mn mo l mp mq">#clear current figure<br/>self.figure.clear()</span><span id="be37" class="ml mm iq mh b gy mr mo l mp mq">#create a subplot<br/>ax = self.figure.add_subplot(111)</span></pre><p id="b1fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">调整大小和颜色变量。尺寸变量需要标准化，这样气泡的大小才合适。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="af85" class="ml mm iq mh b gy mn mo l mp mq">#normalize the size data<br/>if len(args) == 0:<br/>   df[“s_new”] = df[s]/df[s].abs().max()<br/>   df[“s_new”] = df[“s_new”] * 4<br/>else:<br/>   df[“s_new”] = df[s] / df[s].abs().max()<br/>   df[“s_new”] = df[“s_new”] * args * 4</span></pre><p id="1c71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">颜色变量需要离散化。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="62f6" class="ml mm iq mh b gy mn mo l mp mq">df[‘new_c’] = (pd.cut(df[c], bins=5))</span></pre><p id="5cac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦用户从组合框中选择新的值，用滑块设置新的大小，并调整新的数据，就可以创建散点图。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="f051" class="ml mm iq mh b gy mn mo l mp mq">#create scatter plot with new data<br/>b = ax.scatter(x=df[x], y=df[y], s = df[“s_new”], c = df[“new_c”].cat.codes)</span><span id="8743" class="ml mm iq mh b gy mr mo l mp mq">#create labels and title<br/>t = y + “ vs “ + x<br/>ax.set(xlabel=x, ylabel =y, title=t )</span></pre><p id="557b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为颜色和大小图例创建自定义标签。Matplotlib自动添加标签，但是对于颜色变量，需要显示范围。自动标签将只标记从1到n的颜色，n是颜色的数量。对于大小，我们对数据进行了标准化，以便自动标注会显示这些数据，并且我们希望图例中有真实的数据。这是一个可选的步骤，如果数据没有改变，没有必要这样做，因为自动标签将是正确的。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="01d6" class="ml mm iq mh b gy mn mo l mp mq">#create labels and title<br/>t = y + “ vs “ + x<br/>ax.set(xlabel=x, ylabel =y, title=t )</span><span id="f299" class="ml mm iq mh b gy mr mo l mp mq">#extract handles and labels for legend<br/>handles, labels = b.legend_elements(prop=”sizes”, alpha=0.6)</span><span id="5f14" class="ml mm iq mh b gy mr mo l mp mq">#create custom labels for size legend<br/>num_labels = len(handles)<br/>labels_new = list(np.arange((min(df[s])), (max(df[s])), ((max(df[s]) — min(df[s]))/(num_labels-1))))<br/>labels_new = list(np.around(np.array(labels_new), 1))</span><span id="6820" class="ml mm iq mh b gy mr mo l mp mq"># create custom labels that show ranges for color legend<br/>df[‘new_c’] = (pd.cut(df[c], bins=5))<br/>num_labels_c = len(b.legend_elements()[0])<br/>col_bins = pd.cut(df[c], bins=num_labels_c,precision=1)</span></pre><p id="b768" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加带有自定义标签的图例并格式化图表。需要调整图表的大小，以使图例适合图表的外部。这是通过将高度和宽度减少10%并将y0位置向上移动一点来实现的，这样颜色图例就可以在图形的底部，尺寸图例在右侧。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="da1d" class="ml mm iq mh b gy mn mo l mp mq"># get and adjust the position of the graph to fit the legends<br/>box = ax.get_position()<br/>ax.set_position([box.x0, box.y0 + box.height * 0.15, box.width * 0.9, box.height * 0.9])</span><span id="756e" class="ml mm iq mh b gy mr mo l mp mq">#color legend with custom labels<br/>legend1 =ax.legend(b.legend_elements()[0],col_bins , title = c, loc=’upper center’, bbox_to_anchor=(0.5, -0.15), ncol = 5)<br/>ax.add_artist(legend1)</span><span id="f016" class="ml mm iq mh b gy mr mo l mp mq">#size legend with custom labels<br/>legend2 = ax.legend(handles, labels_new, loc = “center left”, title=s, bbox_to_anchor=(1, 0.5))<br/>ax.set(xlabel=x, ylabel =y, title=t )</span></pre><p id="f419" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用figure小部件绘制新图形。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="f1dc" class="ml mm iq mh b gy mn mo l mp mq">#draw new graph<br/>self.canvas.draw()</span></pre><p id="cca7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第四步:格式化窗口小部件</strong></p><p id="f9ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦创建了所有的小部件，就需要对它们进行格式化。PyQt5有许多不同的布局，我选择使用QVBoxLayout()。这将小部件排列在一个垂直框中。还有QHBoxLayout()将小部件排列在一个水平框中，QGridLayout()以网格格式排列小部件，而QFormLayout()将小部件排列在两列中。</p><p id="57bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每个小部件都可以一个接一个地添加到布局中，它们将堆叠在一起。最后，一旦所有的小部件都在布局中，它需要用self.setLayout(LayoutName)设置。可以使用任何名称，但是这将初始化布局对象，并且需要调用它以便向特定布局添加小部件。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="f111" class="ml mm iq mh b gy mn mo l mp mq">grid = QVBoxLayout()<br/>grid.addWidget(self.xLabel)<br/>grid.addWidget(self.xComboBox)<br/>grid.addWidget(self.yLabel)<br/>grid.addWidget(self.yComboBox)<br/>grid.addWidget(self.sLabel)<br/>grid.addWidget(self.sComboBox)<br/>grid.addWidget(self.cLabel)<br/>grid.addWidget(self.cComboBox)<br/>grid.addWidget(self.canvas)<br/>grid.addWidget(self.mySlider)<br/>grid.addWidget(button)<br/>self.setLayout(grid)</span></pre><p id="997e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">第五步:主方法</strong></p><p id="25a0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">main方法创建该类的一个实例，并无限循环以获取对可视化所做的任何更改。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="c6aa" class="ml mm iq mh b gy mn mo l mp mq">if __name__ == ‘__main__’:<br/>   # creating apyqt5 application<br/>   app = QApplication(sys.argv)</span><span id="ec7e" class="ml mm iq mh b gy mr mo l mp mq">   # creating a window object<br/>   main = Window()</span><span id="e8e5" class="ml mm iq mh b gy mr mo l mp mq">   # showing the window<br/>   main.show()</span><span id="59a4" class="ml mm iq mh b gy mr mo l mp mq">   # loop<br/>   sys.exit(app.exec_())</span></pre><p id="6bfb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">最终输出</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/010d48d56fc477a114e6f39f1efb0be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KmzKKSUrU3mswU6C"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终图形用户界面</p></figure><p id="6608" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">总结</strong></p><p id="ef9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结合以上所有步骤，获得您的交互式气泡图！当该函数运行时，GUI应该在一个单独的窗口中弹出。完整的代码链接如下。虽然这是一个简单的例子，但是PyQt5可以集成到任何matplotlib可视化中。它允许创建添加深度和信息层的可视化，这是一般报告或静态可视化无法实现的。毕竟一图胜千言。</p><p id="9faf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完整代码可以在这里找到:<a class="ae lr" href="https://github.com/kruthik109/Data-Visualization/blob/main/Interactive-Bubble-Plot/widgets.py" rel="noopener ugc nofollow" target="_blank">https://github . com/kruthik 109/Data-Visualization/blob/main/Interactive-Bubble-Plot/widgets . py</a></p><p id="cf03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">来源</strong></p><p id="4134" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">中央情报局。(2020年4月6日)。<em class="mu">2020年世界概况</em>。中央情报局。检索于2022年2月22日，来自<a class="ae lr" href="https://www.cia.gov/the-world-factbook/about/archives/" rel="noopener ugc nofollow" target="_blank">https://www.cia.gov/the-world-factbook/about/archives/</a></p></div></div>    
</body>
</html>