<html>
<head>
<title>Quantum Measurement Mitigation With Qiskit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Qiskit减轻量子测量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/quantum-measurement-mitigation-with-qiskit-bb35b3d28eec#2022-04-13">https://towardsdatascience.com/quantum-measurement-mitigation-with-qiskit-bb35b3d28eec#2022-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">参与IBM量子开放科学奖的下一步</h2></div><p id="9c85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_measmitig&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><p id="80dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们将使用Qiskit实现一种量子测量误差缓解方法。我们这样做是为了参加IBM的第二届量子开放科学奖。他们要求解决一个量子模拟问题。他们希望我们在他们的7量子位Jakarta系统上使用Trotterization模拟一个三粒子系统的海森堡模型哈密顿量。难的部分不是模拟海森堡模型的哈密顿量。对一个三粒子系统来说，这样做也不成问题。并且，使用Trotterization是—是的，没错—也没问题。</p><p id="36cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">令人惊讶的是，问题是在一个实际的7量子位设备上做所有这些。量子系统极其脆弱。它们易受环境干扰，容易出错。不幸的是，我们没有资源来纠正这些硬件或低软件级别的错误。我们能做的最好的事情就是减少噪声对计算的影响。</p><p id="0423" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，有很多减少量子错误的方法。例如，在以前的帖子中，我们<a class="ae le" href="https://pyqml.medium.com/mitigating-quantum-errors-using-clifford-data-regression-98ab663bf4c6" rel="noopener">仔细研究了Clifford数据回归(CDR)方法</a>。我们甚至在模拟和实际的量子设备上使用它来降低噪声<a class="ae le" rel="noopener" target="_blank" href="/how-to-implement-quantum-error-mitigation-with-qiskit-and-mitiq-e2f6a933619c">(</a><a class="ae le" rel="noopener" target="_blank" href="/practical-error-mitigation-on-a-real-quantum-computer-41a99dddf740">https://towards data science . com/practical-error-impression-on-a-real-quantum-computer-41 a99 dddf 740</a>)。</p><p id="a586" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">CDR降低了计算可观察值的期望值时的噪声。但是要参与IBM的挑战，我们需要减少测量计数中的误差。IBM使用量子状态层析算法来计算结果状态与预期状态的匹配程度。这种算法适用于测量计数。</p><p id="3367" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，虽然我们可以从计数中计算期望值，但我们不能反过来做。因此，相反，我们需要调整我们的量子误差缓解方法来处理测量计数。换句话说，我们正在实施量子测量误差缓解。</p><p id="6600" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我说过用Trotterization模拟一个三粒子系统的海森堡模型哈密顿量不成问题吗？我是一个守信用的人。下面的源代码提供了所需的模拟。IBM提供这些代码作为他们的典型GitHub项目的一部分。</p><p id="b450" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有一个变化。如果我们将变量<code class="fe lf lg lh li b">measure</code>设置为<code class="fe lf lg lh li b">True</code>，我们将在电路中添加一个<code class="fe lf lg lh li b">ClassicalRegister</code>来接收测量值。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="828e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们想把重点放在度量缓解上。因此，我们照原样接受代码。我们最终以<code class="fe lf lg lh li b">qc</code>作为我们的量子电路。</p><p id="d410" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下图描述了电路图。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/ca194e82516f004445f16db5ca41529f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvLUlUvvQpEYHAqLdrZ4sA.png"/></div></div></figure><p id="8709" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要一个运行时环境。今天，我们可以接受模拟环境。但是为了尽可能接近真实的量子计算机，我们从真实的设备加载噪声特征。为此，我们连接到我们的IBM帐户并从中获取雅加达后端。<a class="ae le" rel="noopener" target="_blank" href="/how-to-run-code-on-a-real-quantum-computer-c1fc61ff5b4">这篇文章</a>详细阐述了如果你还没有一个免费的IBM帐户，你如何获得它。</p><p id="0b4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其实我们需要两个环境。在嘈杂的模拟器旁边，我们需要一个没有噪音的环境。Qiskit <code class="fe lf lg lh li b">QasmSimulator</code>为我们做了这项工作。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="8fcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们用两个模拟器运行我们的量子电路。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="lj lk ll lm gt lx li ly lz aw ma bi"><span id="e320" class="mb mc it li b gy md me l mf mg">noisy:       {'101': 106, '111': 124, '011': 141, '000': 113, '010': 124, '100': 115, '110': 207, '001': 94}<br/>noise-free:  {'101': 34, '110': 866, '011': 124}</span></pre><p id="180d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计数差异很大。所以，让我们去除噪音吧！我们可以为每个状态计算一个将噪声值变为无噪声值的修改量。</p><p id="4fad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们在有噪声的模拟中观察到状态|101⟩ 105次，但在无噪声的模拟中只有30次。当我们将噪声值乘以修正值30/105时，我们得到无噪声值。</p><p id="4a04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们对所有八个州都这样做。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="lj lk ll lm gt lx li ly lz aw ma bi"><span id="b6d4" class="mb mc it li b gy md me l mf mg">modifier:  [0.0, 0.0, 0.0, 0.8794326241134752, 0.0, 0.32075471698113206, 4.183574879227053, 0.0]</span></pre><p id="cee6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们添加一个小助手函数<code class="fe lf lg lh li b">sorted_counts</code>。它做两件事。一方面，它确保所有的状态键都存在。例如，代表州|000⟩的关键字<code class="fe lf lg lh li b">000</code>在无噪声计数中不存在。另一方面，该函数按键对计数进行排序，从<code class="fe lf lg lh li b">000</code>开始，到<code class="fe lf lg lh li b">111</code>结束。</p><p id="6f7d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是下一步的前提。我们将两个<code class="fe lf lg lh li b">counts</code>字典转换成列表，然后<code class="fe lf lg lh li b">zip</code>它们。这意味着我们得到成对的值。位置0时无噪声，位置1时有噪声。因此，我们通过将无噪声值除以有噪声值来计算每个状态的修正值。</p><p id="b471" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用这些修改器来减轻电路的后续测量。所以，让我们重新运行电路。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="lj lk ll lm gt lx li ly lz aw ma bi"><span id="caae" class="mb mc it li b gy md me l mf mg">noise-free:  {'000': 0, '001': 0, '010': 0, '011': 124, '100': 0, '101': 34, '110': 866, '111': 0}<br/>noisy:       {'000': 114, '001': 109, '010': 120, '011': 114, '100': 126, '101': 105, '110': 211, '111': 125}<br/>mitigated:   {'000': 0.0, '001': 0.0, '010': 0.0, '011': 100.25531914893618, '100': 0.0, '101': 33.679245283018865, '110': 882.7342995169082, '111': 0.0}</span></pre><p id="4ad8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们一眼就可以看出，与未减轻的计数相比，减轻的计数更接近无噪声。因此，让我们将这种缓解用于IBM挑战。</p><p id="271a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">IBM基于量子状态层析成像的保真度来评估我们的缓解性能。这听起来比实际更复杂。</p><p id="d2a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单来说，量子态层析术是在测量的基础上重建量子态。保真度告诉我们重建的状态和预期的状态有多接近。保真度为1表示完全符合。</p><p id="9d79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，有一个问题。量子位的量子状态是不可见的。它是两个基态的复合(如在复数中)线性组合。这些基本状态是零个|0⟩和一个|1⟩.布洛赫球是这种量子态最受欢迎的代表之一。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mh"><img src="../Images/8e566e3e8ab8e265abb1f11fddec447e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tXC9A6oAsNzcqlkdfJjlJA.png"/></div></div></figure><p id="5213" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">基本上，量子态是矢量|𝜓⟩.它的头部位于球体表面的任何地方。该表面还穿过基础状态，顶部是|0⟩，底部是|1⟩。</p><p id="4302" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，每当你看量子态时，你只会看到0或1。状态向量与基态的接近度表示测量任一值的概率。所以，你可以通过重复运行电路来估计接近度。但是，我们谈论的是一个球体。有无限多种可能的量子态具有相同的概率。例如，看看球体的赤道。那里的任何一点到位于球体两极的基态都有相同的距离。</p><p id="0afa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了重现量子态，我们需要从不同的角度来看这个球体。这就是我们在量子态层析成像中所做的。这些是X、Y和Z轴。如果我们有两个量子位，就有九个角度:XX，XY，XZ，YX，YY，YZ，ZX，ZY和ZZ。如果我们有一个由三个量子位组成的量子系统，就有27个不同的角度。因此，我们必须创建27个版本的量子电路，每个版本代表一个视角。</p><p id="5067" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，Qiskit为我们提供了创建这些电路的功能。这个函数要求输入量子电路不包含任何测量，但是我们在调用函数时定义了要测量的量子位。因此，我们设置<code class="fe lf lg lh li b">measure=False</code>。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="lj lk ll lm gt lx li ly lz aw ma bi"><span id="9a8e" class="mb mc it li b gy md me l mf mg">There are 27 circuits in the list</span></pre><p id="d62c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这些电路几乎相同，但它们的测量结果却大相径庭。因此，我们为每个回路计算单独的修正系数。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="lj lk ll lm gt lx li ly lz aw ma bi"><span id="3ce7" class="mb mc it li b gy md me l mf mg">noisy:      {'000': 125, '001': 120, '010': 136, '011': 123, '100': 115, '101': 125, '110': 132, '111': 148}<br/>nose-free:  {'000': 144, '001': 88, '010': 208, '011': 84, '100': 66, '101': 213, '110': 93, '111': 128}<br/>modifier:  [1.152, 0.7333333333333333, 1.5294117647058822, 0.6829268292682927, 0.5739130434782609, 1.704, 0.7045454545454546, 0.8648648648648649]<br/><br/><br/>noisy:      {'000': 139, '001': 112, '010': 127, '011': 133, '100': 113, '101': 127, '110': 136, '111': 137}<br/>nose-free:  {'000': 162, '001': 88, '010': 233, '011': 33, '100': 29, '101': 213, '110': 118, '111': 148}<br/>modifier:  [1.1654676258992807, 0.7857142857142857, 1.8346456692913387, 0.24812030075187969, 0.25663716814159293, 1.6771653543307086, 0.8676470588235294, 1.0802919708029197]</span><span id="a56a" class="mb mc it li b gy mi me l mf mg">...</span></pre><p id="c996" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要在状态层析成像函数中使用修饰符。我从IBM的源代码中取出原始代码并进行修改。进一步，我们用<code class="fe lf lg lh li b">OwnResult</code>。这是我们在上一篇文章中开发的一个类。它是Qiskit <code class="fe lf lg lh li b">Result</code>的包装器，允许我们更改计数。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="4b80" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe lf lg lh li b">state_tomo</code>将结果、层析成像电路和是否减轻的标志作为参数。<code class="fe lf lg lh li b">result</code>必须包含所有27个断层扫描电路的结果。我们从<code class="fe lf lg lh li b">target_state</code>的定义开始。这是我们与重建状态进行比较的状态。</p><p id="d9f9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lf lg lh li b">idx</code>变量是电流电路的计数器。我们用它来得到相应的修饰符。现在，我们遍历电路，计算减轻的计数，并把它们放入状态层析成像装配器的<code class="fe lf lg lh li b">OwnResult</code>对象中。最后，我们计算保真度。</p><p id="c4ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们运行所有这些电路。无声的工作作为对比。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="lo lp l"/></div></figure><pre class="lj lk ll lm gt lx li ly lz aw ma bi"><span id="79bb" class="mb mc it li b gy md me l mf mg">noisy state tomography fidelity = 0.2161 ± 0.0000<br/>noise-free state tomography fidelity = 0.8513 ± 0.0000<br/>mitigated state tomography fidelity = 0.8317 ± 0.0000</span></pre><p id="fe2c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果显示，通过我们的缓解措施，情况有了显著改善。我们几乎实现了无噪声保真度。然而，我们需要批判性地看待这些结果。</p><p id="0d89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用无噪声结果计算修改量。这是唯一可能的，因为我们的电路是经典可模拟的。所以，我们知道预期的结果。但是，当然，承担使用真正的量子计算机的所有压力只有在经典计算机难以完成的任务中才是有意义的。但是，如果我们不能经典地模拟它，我们就不能计算修改量。</p><p id="cbe8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们的结果作为概念的证明。我们看到，量子测量缓解效果很好，可以用于量子状态层析成像。</p><p id="828f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">量子机器学习要不要入门？看看<a class="ae le" href="https://www.pyqml.com/page?ref=medium_measmitig&amp;dest=/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">动手量子机器学习用Python </strong> </a> <strong class="kk iu">。</strong></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/c3892c668b9d47f57e47f1e6d80af7b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*yymQWGhESHNGUr_L.png"/></div></figure><p id="51db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里免费获得前三章<a class="ae le" href="https://www.pyqml.com/page?ref=medium_measmitig&amp;dest=/" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>