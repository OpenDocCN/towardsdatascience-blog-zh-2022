<html>
<head>
<title>5 Pandas Group By Tricks You Should Know in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5只熊猫按你在Python中应该知道的技巧分组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-pandas-group-by-tricks-you-should-know-in-python-f53246c92c94#2022-08-10">https://towardsdatascience.com/5-pandas-group-by-tricks-you-should-know-in-python-f53246c92c94#2022-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="560a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><div class=""><h2 id="2731" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">所有你需要知道的关于熊猫的数据框架组，以便有效地使用它</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ed140b18e0967f8702b61d4a359c0ab4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su4ktHu_pVffRid3-fb9bw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@steve_j?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯蒂夫·约翰森</a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="cbe2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">熊猫力量！</strong>🔋</p><p id="27e9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Pandas是广泛用于数据分析项目的Python库。然而，分析数据并不容易，因为要从中获得有价值的见解是很难的。为了更好地理解数据，您需要对其进行转换和聚合。这时<code class="fe me mf mg mh b"><strong class="lk jd">groupby</strong></code>出现了。</p><p id="0951" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Pandas中，<code class="fe me mf mg mh b"><strong class="lk jd">groupby</strong></code>本质上是将数据集中的所有记录分成不同的类别或组，并为您提供按这些组分析数据的灵活性。</p><p id="698b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是非常有效的，必须知道在数据分析功能，这给你几秒钟内有趣的见解。这也是为什么在数据科学工作面试中经常会被问到这个问题。所以，掌握它很重要。💯</p><p id="75d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将举例说明5个简单的熊猫<code class="fe me mf mg mh b">groupby</code>技巧，你必须知道这些技巧才能高效地进行数据分析，也才能在数据科学面试中胜出。</p><p id="8ee1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这篇文章很短，但你可以通过这个索引自由地导航到你最喜欢的部分，并下载整个笔记本，最后还有例子！</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="0dd9" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">  ∘ </strong><a class="ae lh" href="#41fa" rel="noopener ugc nofollow"><strong class="mh jd">How exactly group by works on pandas DataFrame?</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#782f" rel="noopener ugc nofollow"><strong class="mh jd">Number of Groups</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#06fd" rel="noopener ugc nofollow"><strong class="mh jd">Group Sizes</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#c09b" rel="noopener ugc nofollow"><strong class="mh jd">Get First and Last</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#461c" rel="noopener ugc nofollow"><strong class="mh jd">Get Groups</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#ae8f" rel="noopener ugc nofollow"><strong class="mh jd">Aggregate Multiple Columns with Different Aggregate Functions</strong></a></span></pre><blockquote class="ms mt mu"><p id="f557" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">📍注意:我使用的是自己创建的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank">虚拟销售数据</a>，你可以在我的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Github </strong> </a> repo上免费获得<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/LICENSE.md" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">麻省理工学院许可</strong> </a> <strong class="lk jd">！</strong>！</p></blockquote><p id="e360" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将数据集导入熊猫数据框架— <code class="fe me mf mg mh b"><strong class="lk jd">df</strong></code></p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="f25c" class="mm mn it mh b gy mo mp l mq mr">import pandas as pd<br/>df = pd.read_csv("Dummy_Sales_Data_v1.csv")<br/>df.head()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mz"><img src="../Images/5270b74767e862e28d0168b0ea02af4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nXUJphMbntLmVpn7.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">虚拟销售数据|作者图片</p></figure><p id="1919" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个简单的9999 x 12的数据集，我用Python中的<a class="ae lh" rel="noopener" target="_blank" href="/faker-an-amazing-and-insanely-useful-python-library-b313a60bdabf"><strong class="lk jd">Faker</strong></a><strong class="lk jd"/>创建的📚</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="cc54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在继续之前，让我们快速了解一下—</p><h2 id="41fa" class="mm mn it bd nh ni nj dn nk nl nm dp nn lr no np nq lv nr ns nt lz nu nv nw iz bi translated">“分组”到底是如何在熊猫数据框架上工作的？</h2><p id="f2e3" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">当您对DataFrame的任何分类列使用<code class="fe me mf mg mh b">.groupby()</code>函数时，它会返回一个<code class="fe me mf mg mh b"><strong class="lk jd">GroupBy</strong></code>对象。然后，您可以对该对象使用不同的方法，甚至聚合其他列来获得数据集的汇总视图。</p><p id="c82d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您使用下面<code class="fe me mf mg mh b">df</code>中<em class="mv">产品类别</em>列的<code class="fe me mf mg mh b">.groupby()</code>函数来获取<code class="fe me mf mg mh b">GroupBy</code>对象。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="1a60" class="mm mn it mh b gy mo mp l mq mr">df_group = df.groupby("Product_Category")<br/>type(df_group)</span><span id="49fe" class="mm mn it mh b gy oc mp l mq mr"># Output<br/><strong class="mh jd">pandas.core.groupby.generic.DataFrameGroupBy</strong></span></pre><p id="0b3b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">返回的<code class="fe me mf mg mh b"><strong class="lk jd">GroupBy</strong></code>对象只是一个字典，其中<em class="mv">键是唯一的组</em>，其中记录被拆分，值是每个组的列，这些列在<code class="fe me mf mg mh b">groupby</code>中没有提到。</p><p id="ec24" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当然，<code class="fe me mf mg mh b">GroupBy</code> object保存整个数据帧的内容，但以更结构化的形式保存。就像字典一样，有几种方法可以有效地获取所需的数据。✅</p><p id="8e37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们先从简单的事情开始，看看你的数据现在被分成多少个不同的组。</p><h1 id="782f" class="od mn it bd nh oe of og nk oh oi oj nn ki ok kj nq kl ol km nt ko om kp nw on bi translated">组数</h1><p id="9df9" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">一旦您将数据分成不同的类别，了解您的数据现在被分成多少个不同的组是很有趣的。</p><p id="a849" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单而常见的答案是在任何列上使用<code class="fe me mf mg mh b">nunique()</code>函数，这实际上给出了该列中唯一值的数量。因此，由于列中有许多唯一值，数据将被分成许多组。</p><p id="c0ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您可以查看使用产品类别可以形成多少个独特的组。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="2512" class="mm mn it mh b gy mo mp l mq mr">df.Product_Category.nunique()</span><span id="77f8" class="mm mn it mh b gy oc mp l mq mr">-- Output<br/><strong class="mh jd">5</strong></span></pre><p id="cfeb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，当你已经有一个<code class="fe me mf mg mh b">GroupBy</code>对象时，你可以直接使用它的<br/>方法<code class="fe me mf mg mh b"><strong class="lk jd">ngroups</strong></code>，它会给出你想要的答案。这是你如何使用它。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="6d9b" class="mm mn it mh b gy mo mp l mq mr">df_group = df.groupby("Product_Category")<strong class="mh jd"><br/>df_group.ngroups</strong></span><span id="8e79" class="mm mn it mh b gy oc mp l mq mr">-- Output<br/><strong class="mh jd">5</strong></span></pre><p id="0604" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦你知道了组的数量，你仍然不知道每个组的大小。下一个方法让你知道每个组有多大或多小。</p><h1 id="06fd" class="od mn it bd nh oe of og nk oh oi oj nn ki ok kj nq kl ol km nt ko om kp nw on bi translated">组大小</h1><p id="c130" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">使用函数<strong class="lk jd">可以很容易地获得每组<code class="fe me mf mg mh b">GroupBy</code>对象中的行数。大小()。</strong></p><p id="648d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您想要查看每组产品类别中有多少不同的行。这可以简单地如下获得—</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="6ef8" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df.groupby("Product_Category").size()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/e813ebb09597f38c669b3a0fad4acc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*kJPMSa8uZpyZTiKjsPyWQQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫按大小分组|作者图片</p></figure><p id="792c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它只是计算每个组中的行数。这里有人会说，使用聚合函数<code class="fe me mf mg mh b">count()</code>可以获得相同的结果。让我们试一试，</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="5719" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df.groupby("Product_Category").count()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/6a20e08524986c344f1338c2ad572bfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0H_rSRpXijAEb92nUIrQA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫按数量分组|图片按作者</p></figure><p id="5c54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以看到两个结果之间的相似之处——数字是相同的。然而，它们的计算方式有很大的不同。</p><p id="bd5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据<strong class="lk jd"> </strong> <a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.count.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">熊猫</strong> </a>，聚合函数<code class="fe me mf mg mh b">.count()</code>只计算每一列的<em class="mv">非空值</em> s，而<code class="fe me mf mg mh b">.size()</code>只是返回每一组中可用的行 s的<em class="mv">号，而不管有无值。</em></p><p id="ae8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，在使用这两个函数之前，您必须对它们之间的差异有深刻的理解。简而言之，如果想知道每组的每一列中有多少非空值，就使用<code class="fe me mf mg mh b">.count()</code>，否则就使用<code class="fe me mf mg mh b">.size()</code> ✅</p><p id="41cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦你得到每个组的大小，你可能想看看第一个，最后一个或记录在数据中的任何随机位置。在这种情况下，下一个方法可能很方便。</p><h1 id="c09b" class="od mn it bd nh oe of og nk oh oi oj nn ki ok kj nq kl ol km nt ko om kp nw on bi translated">获得第一和最后一名</h1><p id="9c4d" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">在数据被分成不同的组后，这些函数返回第一条和最后一条记录。它不是引用index，而是给出所有组中出现的第一行或最后一行。</p><p id="49ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您可以看到每个组中的第一条记录，如下所示:</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="8e60" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df.groupby("Product_Category").first()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/685225a9e1469031c4ffdc1f245b4ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_M5W5YELRYTIkhr7mKt4DQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">查看熊猫分组的第一行|作者图片</p></figure><p id="c544" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没错，用类似的方法，你可以看看每组的最后一行。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="c3ca" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df.groupby("Product_Category").last()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/1924ac1cd44fb0cff25306bc5e364cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4L_tBb46x2wiEP2LmdeHw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">查看熊猫分组的最后一行|作者图片</p></figure><p id="7697" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦所有行都被分组到每个<em class="mv">产品类别</em>下，它就返回第一行和最后一行。</p><p id="6b82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，您还可以在任何其他位置提取行。例如，也可以使用函数<code class="fe me mf mg mh b"><strong class="lk jd">.nth()</strong></code>提取每组中的第4行</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="955a" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df.groupby("Product_Category").nth(3)</strong></span></pre><p id="ab0c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">记住，Python中的索引是从零开始的，因此当你说<code class="fe me mf mg mh b">.nth(3)</code>时，你实际上是在访问第4行。</p><p id="7a07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从逻辑上讲，您甚至可以使用<code class="fe me mf mg mh b">.nth()</code>函数获得第一行和最后一行。例如，您可以使用<code class="fe me mf mg mh b">.nth(0)</code>和<code class="fe me mf mg mh b">.first()</code>获得每组的第一行，或者使用<code class="fe me mf mg mh b">.nth(-1)</code>和<code class="fe me mf mg mh b">.last()</code>获得最后一行。</p><blockquote class="ms mt mu"><p id="c650" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">那为什么这些不同的功能会存在呢？？ <em class="it">🚩</em></p></blockquote><p id="3bcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然可以使用<code class="fe me mf mg mh b">.first()</code>和<code class="fe me mf mg mh b">.nth(0)</code>来获取第一行，但是在处理<code class="fe me mf mg mh b"><strong class="lk jd">NaN</strong></code>或缺失值时有所不同。<code class="fe me mf mg mh b">.first()</code>给出每一列的第一个非空值，而<code class="fe me mf mg mh b">.nth(0)</code>返回组的第一行，不管这些值是什么。<code class="fe me mf mg mh b">.last()</code>的情况也是如此</p><p id="69b7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我推荐使用<code class="fe me mf mg mh b">.nth()</code>而不是其他两个函数来从一个组中获取所需的行，除非您专门寻找非空记录。💯</p><p id="46b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是假设，不是只从组中检索第一行或最后一行，您可能很想知道特定组的内容。下一个方法会很快给出这些信息。</p><h1 id="461c" class="od mn it bd nh oe of og nk oh oi oj nn ki ok kj nq kl ol km nt ko om kp nw on bi translated">获取组</h1><p id="794d" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">pandas <code class="fe me mf mg mh b">GroupBy</code>方法<code class="fe me mf mg mh b"><strong class="lk jd">get_group()</strong></code>用于从<code class="fe me mf mg mh b">GroupBy</code>对象中选择或提取一个组。</p><p id="3efd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，假设您想查看<em class="mv">“医疗保健”</em>组的内容。这可以用下面最简单的方法来完成。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="a652" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df_group.get_group('Healthcare')</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi os"><img src="../Images/094b2f5b96bf9e74b669fff0948be49b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMmY3wDKn9eSpjy6UUO9QA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫按get_group() |图片按作者分组</p></figure><p id="7c57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，数据集的结构没有变化，您仍然可以获得产品类别为'<em class="mv"> Healthcare' </em>'的所有记录。</p><p id="628d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于这种方法，我有一个有趣的用例— <strong class="lk jd">分割数据帧</strong></p><p id="234d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您想要选择产品类别为<em class="mv">【家庭】</em>的所有行。一种简单且广泛使用的方法是使用如下的括号符号<code class="fe me mf mg mh b"><strong class="lk jd">[ ]</strong></code>，</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="f149" class="mm mn it mh b gy mo mp l mq mr">df[df["Product_Category"]=='Home']</span></pre><p id="20c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这没什么不对的。但是使用下面的方法<code class="fe me mf mg mh b">.get_group()</code>可以得到完全相同的结果，</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="56d4" class="mm mn it mh b gy mo mp l mq mr">df_group = df.groupby("Product_Category")<br/>df_group.get_group('Home')</span></pre><p id="9b8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更进一步，当您比较这两种方法的性能并分别运行1000次时，当然<code class="fe me mf mg mh b">.get_group()</code>是省时的。✅</p><blockquote class="ot"><p id="ad08" class="ou ov it bd ow ox oy oz pa pb pc md dk translated">切片用。groupby()比逻辑比较快4倍！！</p></blockquote><p id="dac1" class="pw-post-body-paragraph li lj it lk b ll pd kd ln lo pe kg lq lr pf lt lu lv pg lx ly lz ph mb mc md im bi translated">这是通过在<code class="fe me mf mg mh b">.get_group()</code>方法中指定组名来一次只获取一个组。但是，如果您想一次浏览所有组的内容，该怎么办呢？？</p><blockquote class="ms mt mu"><p id="d563" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated"><strong class="lk jd">你还记得— </strong> <code class="fe me mf mg mh b"><strong class="lk jd">GroupBy</strong></code> <strong class="lk jd">对象是字典吗！！</strong> <em class="it">🚩</em></p></blockquote><p id="b8ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，您可以像使用dictionary一样直接遍历它——使用键和值参数。💯</p><p id="e2c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是你可以先睹为快每个组的内容。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="0f4a" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">for name_of_group, contents_of_group in df_group:</strong><br/>    print(name_of_group)<br/>    print(contents_of_group)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/4a734a499196615719d4b3900251cbde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztRMsGe5KVnthMpjsewBYw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">遍历每组熊猫分组依据|图片依据作者</p></figure><p id="5f82" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它将列出每个组的名称和内容，如上所示。在图片中只能看到一个组的内容，但是在笔记本中，你可以看到一个接一个列出的所有组的相同模式。</p><p id="4ef6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它基本上显示了每组中的第一行和最后五行，就像pandas DataFrame的<code class="fe me mf mg mh b">.head()</code>和<code class="fe me mf mg mh b">.tail()</code>方法一样。</p><p id="6d97" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，如果不汇总数据，熊猫<code class="fe me mf mg mh b">groupby</code>的使用是不完整的。在这最后一部分中，让我们探索如何在不同的列上使用不同的聚合函数。</p><h1 id="ae8f" class="od mn it bd nh oe of og nk oh oi oj nn ki ok kj nq kl ol km nt ko om kp nw on bi translated">用不同的聚合函数聚合多个列</h1><p id="c3b2" class="pw-post-body-paragraph li lj it lk b ll nx kd ln lo ny kg lq lr nz lt lu lv oa lx ly lz ob mb mc md im bi translated">对每个组中的列应用聚合函数是一种广泛使用的做法，以获得汇总结构，用于进一步的统计分析。</p><p id="c101" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据IBM<a class="ae lh" href="https://www.ibm.com/docs/da/tnpm/1.4.2?topic=data-aggregation" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd"/></a>，</p><blockquote class="ot"><p id="e1f8" class="ou ov it bd ow ox oy oz pa pb pc md dk translated">您可以分析汇总的数据，以获得关于特定资源或资源组的见解</p></blockquote><p id="9a5f" class="pw-post-body-paragraph li lj it lk b ll pd kd ln lo pe kg lq lr pf lt lu lv pg lx ly lz ph mb mc md im bi translated">这就是拥有聚合功能的熊猫<code class="fe me mf mg mh b">groupby</code>非常有用的地方。使用<code class="fe me mf mg mh b">groupby</code>，您可以根据单个列或多个列将数据集分成不同的组。然后对剩余的数字列应用聚合函数。</p><p id="acb1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们继续同一个例子。将数据按<em class="mv">产品类别</em>分组后，假设您想查看每个产品类别的平均<em class="mv">单价</em>和<em class="mv">数量</em>是多少。</p><p id="af50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您所需要做的就是使用方括号引用<code class="fe me mf mg mh b">GroupBy</code>对象中的这些列，并对它们应用聚合函数<code class="fe me mf mg mh b">.mean()</code>，如下所示</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="d1a0" class="mm mn it mh b gy mo mp l mq mr">#Create a groupby object<br/><strong class="mh jd">df_group = df.groupby("Product_Category")</strong></span><span id="c0ef" class="mm mn it mh b gy oc mp l mq mr">#Select only required columns<br/><strong class="mh jd">df_columns = df_group[["UnitPrice(USD)","Quantity"]]</strong></span><span id="21af" class="mm mn it mh b gy oc mp l mq mr">#Apply aggregate function<br/><strong class="mh jd">df_columns.mean()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/168a1abb2635302a031803dabae66538.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*FNy9DfP-eInQyDOzVlVAzA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫分组依据聚合函数|图片依据作者</p></figure><p id="e4a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样你可以得到每组的平均单价和数量。您可以根据需要添加更多列，并应用其他聚合函数，如<code class="fe me mf mg mh b">.min()</code>、<code class="fe me mf mg mh b">.max()</code>、<code class="fe me mf mg mh b">.count()</code>、<code class="fe me mf mg mh b">.median()</code>、<code class="fe me mf mg mh b">.std()</code>等。</p><blockquote class="ms mt mu"><p id="1f10" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated">🚩请注意，代码被分成3行只是为了便于理解，在任何情况下，只需如下一行代码就可以获得相同的输出。</p></blockquote><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="50ab" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">df.groupby("Product_Category")[["UnitPrice(USD)","Quantity"]].mean()</strong></span></pre><p id="c219" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管像上面这样写一行程序看起来很容易，也很有趣，但是你应该始终记住PEP-8关于一行中字符数的准则。你可以在下面的文章中读到更多。</p><div class="pk pl gp gr pm pn"><a rel="noopener follow" target="_blank" href="/5-most-powerful-one-liners-you-should-know-in-python-programming-c9d49a89b7f3"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd jd gy z fp ps fr fs pt fu fw jc bi translated">Python编程中您应该知道的5个最强大的一行程序</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">一行程序保持你的代码干净、清晰、简短和易于理解。</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">towardsdatascience.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb lb pn"/></div></div></a></div><p id="f899" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，您可以使用<code class="fe me mf mg mh b">GroupBy</code>方法<code class="fe me mf mg mh b"><strong class="lk jd">.aggregate()</strong></code>在同一列上应用多个聚合函数。只需提供要在列上应用的函数名列表。</p><p id="b77f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">举个例子，假设你想得到每个产品类别中<em class="mv">数量</em>的最大值、最小值、相加值和平均值。所以集合函数是<code class="fe me mf mg mh b">min</code>、<code class="fe me mf mg mh b">max</code>、<code class="fe me mf mg mh b">sum</code>和<code class="fe me mf mg mh b">mean</code> &amp;你可以这样应用它们。</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="6c61" class="mm mn it mh b gy mo mp l mq mr">df.groupby("Product_Category")<strong class="mh jd">[["Quantity"]].aggregate([min,<br/>                                                        max,<br/>                                                        sum,<br/>                                                        'mean'])</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/490bb6096b54dcbbfd85622946e15534.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*WWUQxi5DxMtmOoIFS0WWGQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫分组按同一列多重聚合|图片按作者</p></figure><p id="8880" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您将获得关于每组中<em class="mv">数量</em>的所有所需统计数据。</p><p id="53b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是等等，你注意到你在<code class="fe me mf mg mh b">.aggregate()</code>中提供的函数列表中的一些东西了吗？？</p><p id="6714" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">sum、min、max等所有函数都是直接编写的，但函数mean是以字符串形式编写的，即在单引号中，就像这样<code class="fe me mf mg mh b"><strong class="lk jd">‘mean’</strong></code></p><blockquote class="ms mt mu"><p id="d5bb" class="li lj mv lk b ll lm kd ln lo lp kg lq mw ls lt lu mx lw lx ly my ma mb mc md im bi translated"><strong class="lk jd">但为什么写得像一串呢？？</strong> <em class="it">🚩</em></p></blockquote><p id="6aa0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据<a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.core.groupby.DataFrameGroupBy.aggregate.html" rel="noopener ugc nofollow" target="_blank"> pandas </a>，传递给<code class="fe me mf mg mh b">.aggregate()</code>的函数必须是传递给数据帧或传递给<code class="fe me mf mg mh b">DataFrame.apply()</code>时起作用的函数。</p><p id="4d9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简而言之，当你提到<code class="fe me mf mg mh b"><strong class="lk jd">‘mean’ </strong></code> ( <em class="mv">加引号</em>)，<code class="fe me mf mg mh b">.aggregate()</code>搜索一个属于<code class="fe me mf mg mh b">pd.Series</code>即<code class="fe me mf mg mh b"><strong class="lk jd">pd.Series.mean()</strong></code>的函数<code class="fe me mf mg mh b">mean</code>。</p><p id="5796" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果您提到<code class="fe me mf mg mh b"><strong class="lk jd">mean</strong></code> ( <em class="mv">不带引号</em>)，<code class="fe me mf mg mh b">.aggregate()</code>将在默认Python中搜索名为<code class="fe me mf mg mh b">mean</code>的函数，该函数不可用，并将抛出<code class="fe me mf mg mh b">NameError</code>异常。</p><p id="d88f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，使用<code class="fe me mf mg mh b">.groupby()</code>您可以在不同的列上应用不同的聚合函数。在这种情况下，您需要向<code class="fe me mf mg mh b">.aggregate()</code>传递一个字典，其中<em class="mv">键将是列名</em>，而<em class="mv">值将是您想要应用的聚合函数</em>。</p><p id="5f1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，假设您想获得每个产品类别的<em class="mv">总订单</em>和<em class="mv">平均数量</em>。因此，您将传递给<code class="fe me mf mg mh b">.aggregate(</code>的字典将是— <code class="fe me mf mg mh b"><strong class="lk jd">{‘OrderID’:’count’, ’Quantity’:’mean’}</strong></code></p><p id="e2c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以通过简单地如下传递这个字典来获得想要的输出，</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="1a0b" class="mm mn it mh b gy mo mp l mq mr"><strong class="mh jd">function_dictionary =</strong> <strong class="mh jd">{'OrderID':'count','Quantity':'mean'}</strong><br/>df.groupby("Product_Category")<strong class="mh jd">.aggregate(function_dictionary)</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/699ddc95f81c38a431edc7e5e059ad7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*v2T_LVwgJduMWLkXaJVvCQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">多重聚合|作者图片</p></figure><p id="9cfb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，您可以根据需要在多个列上应用多个函数。</p><p id="95cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">熊猫<code class="fe me mf mg mh b"><strong class="lk jd">.groupby()</strong></code>和它的<code class="fe me mf mg mh b"><strong class="lk jd">GroupBy</strong></code>对象更加灵活。有一种方法可以通过单个函数<code class="fe me mf mg mh b"><strong class="lk jd">describe()</strong></code>获得按每个组拆分的基本统计摘要。您需要指定一个必需的列，并在其上应用<code class="fe me mf mg mh b">.describe()</code>,如下所示</p><pre class="ks kt ku kv gt mi mh mj mk aw ml bi"><span id="2b6d" class="mm mn it mh b gy mo mp l mq mr">df.groupby("Product_Category")[["Quantity"]]<strong class="mh jd">.describe()</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/6b566ad7f46a91d545706948a6844c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*Y9uoCrIYz77rhzKk4KSIsQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">每组的描述性统计|按作者分类的图片</p></figure><p id="a577" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，您可以获得每个产品类别中数量的完整描述性统计汇总。如你所见，它包含了单个函数的结果，如<code class="fe me mf mg mh b">count</code>、<code class="fe me mf mg mh b">mean</code>、<code class="fe me mf mg mh b">std</code>、<code class="fe me mf mg mh b">min</code>、<code class="fe me mf mg mh b">max</code>和<code class="fe me mf mg mh b">median</code>。</p><p id="b2e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就是这样！🏆</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="d591" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你从这篇文章中获得关于熊猫<code class="fe me mf mg mh b">.groupby() </code>及其灵活性的有价值的见解。</p><p id="ee7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在现实世界中，您通常会处理大量数据，并需要对不同组的数据进行类似的操作。熊猫<code class="fe me mf mg mh b">.groupby()</code>在所有这些场景中都非常灵活和方便。</p><blockquote class="ot"><p id="ba6e" class="ou ov it bd ow ox oy oz pa pb pc md dk translated"><em class="qf">有兴趣在媒体上阅读更多故事？？</em></p></blockquote><p id="f051" class="pw-post-body-paragraph li lj it lk b ll pd kd ln lo pe kg lq lr pf lt lu lv pg lx ly lz ph mb mc md im bi translated">💡考虑<a class="ae lh" href="https://medium.com/@17.rsuraj/membership" rel="noopener"> <strong class="lk jd">成为</strong></a><strong class="lk jd">媒体会员，可以无限制的获取</strong>媒体上的故事和每日有趣的媒体文摘。我会得到你的费用的一小部分，没有额外的费用给你。</p><p id="4d7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">💡请务必<a class="ae lh" href="https://medium.com/subscribe/@17.rsuraj" rel="noopener"> <strong class="lk jd">注册我的电子邮件列表</strong> </a>以免错过另一篇关于数据科学指南、技巧和提示、SQL和Python的文章。</p><p id="a1f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">💡这里有一个完整的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/pandas_groupby_deep_dive.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd">笔记本</strong> </a>里面有所有的例子。</p><p id="8466" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">感谢您的阅读！</strong></p></div></div>    
</body>
</html>