<html>
<head>
<title>Count Distinct Metrics at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模统计不同的指标</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/count-distinct-metrics-at-scale-95a394c03f1#2022-12-21">https://towardsdatascience.com/count-distinct-metrics-at-scale-95a394c03f1#2022-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f353" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何加速不同查询的计数并设计高效的聚集表</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/665dd74cd5305a2aaa4f9e9b1034a9fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYSnVmoVZ0oW8LY3gcBKhQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://beta.dreamstudio.ai/" rel="noopener ugc nofollow" target="_blank"> DreamStudio </a>生成的图像</p></figure><p id="155f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种复杂的算法，<a class="ae kv" href="https://en.wikipedia.org/wiki/HyperLogLog" rel="noopener ugc nofollow" target="_blank">超对数对数(HLL) </a>可以用来估计多重集中的不同元素。本文讨论了使用 HLL 大规模处理 count distinct 指标的实用方法。然而，这篇文章并没有探究 HLL 的内部运作。</p><p id="22be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据分析中最常见的度量之一是某些实体的计数差异。例如，您可能对有多少不同的用户感兴趣，或者对有多少不同的用户执行某个操作感兴趣，或者对有多少不同的设备访问了您的网站感兴趣。从概念上讲，count distinct 是一个简单的操作。例如，您可以编写以下 SQL 查询来从用户表中获取不同的用户-</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="13e7" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  count(distinct user_id) as unique_users<br/>FROM<br/>  user</span></pre><p id="00de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在处理大规模数据时，您可能会遇到两个计数不同的问题</p><ol class=""><li id="7f04" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr mi mj mk ml bi translated">高基数</li><li id="bd60" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr mi mj mk ml bi translated">添加</li></ol><h1 id="cd87" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated"><strong class="ak">高基数</strong></h1><p id="4c08" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">高基数指的是大量不同的值，想想具有数千万或数亿个唯一值的列。如果您正在大规模处理数据，您可能会经常遇到这些情况。例如，考虑下面的场景。</p><p id="6896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有一个非常受欢迎的消息应用程序，该应用程序记录用户活动的事件。记录的事件示例有 app_start、start_message、read_message、sent_message 等。在任何一天，你都有大约一千万的独立用户和几亿的总事件。事件表是具有以下模式的日期分区表</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/398427f7ab8702d721ff81a78047c2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*Oyn181SKiimoiMci3L-0sw.png"/></div></figure><p id="022a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要获得该应用在任何给定日期的 DAU(每日活跃用户),您可以编写以下查询</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="360f" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  count(distinct user_id)<br/>FROM<br/>  event<br/>WHERE<br/>  dt_partition = '2022-12-17'</span></pre><p id="41f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是由于表的大小(一个 dt 分区有 100 万个事件)和 user_id 的基数(1000 万个唯一的 user _ id)，这个查询会非常慢，而且需要大量资源。为了计算非重复计数，SQL 引擎必须检查所有的值，同时在内存中维护所有的唯一值。SQL 引擎将增加一些优化来加快速度，但在它的核心，这是一个非常资源密集型的计算。为了加快计算速度，可以使用近似相异操作。大多数 SQL 引擎都包含 count distinct 的近似版本，下面是一些来自<a class="ae kv" href="https://prestodb.io/docs/current/functions/aggregate.html#id6" rel="noopener ugc nofollow" target="_blank"> Presto </a>、<a class="ae kv" href="https://spark.apache.org/docs/latest/api/sql/index.html#approx_count_distinct" rel="noopener ugc nofollow" target="_blank"> Spark-SQL </a>、<a class="ae kv" href="https://docs.aws.amazon.com/redshift/latest/dg/r_COUNT.html" rel="noopener ugc nofollow" target="_blank">红移</a>、<a class="ae kv" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions#approx_count_distinct" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>的例子。使用近似不同的函数，您可以设置标准误差的上限。下面是使用近似函数和标准误差上限 0.005 时查询的样子。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="425d" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  approx_distinct(user_id, 0.005)<br/>FROM<br/>  event<br/>WHERE<br/>  dt_partition = '2022-12-17'</span></pre><p id="674d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">近似相异函数功能强大且有弹性，但仅在数据规模允许且用例对答案中的小错误稳健时使用。例如，近似不同函数对于财务会计用例来说不是一个好主意。超对数算法支持近似计数不同函数。超对数算法是一种概率数据结构，可用于估算数据集中不同元素的数量。它基于将输入数据映射到一组桶，然后使用空桶的数量来估计输入数据的基数(即不同元素的数量)的思想。</p><h1 id="ba93" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated"><strong class="ak">相加性</strong></h1><p id="b1fa" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">计算不同指标的另一个问题是它们不能在不同的维度上相加。让我们更深入地探讨一下这个问题。</p><p id="3f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用以下模式为日期-事件类型-事件子类型粒度上的事件构建一个聚合表</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/5ba6203296e408772b52b7f320b19f49.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*COJG2C_TuBwamEue1fc8PA.png"/></div></figure><p id="0652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用以下查询来构建该表</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="d5dc" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  dt_partition as event_date,<br/>  event_type,<br/>  event_subtype,<br/>  count(*) as event_count,<br/>  approx_distinct(user_id, 0.005) as distinct_user_count<br/>FROM<br/>  event<br/>GROUP BY<br/>  1, 2, 3</span></pre><p id="cacb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实践中，数据分析师、数据科学家和 ML 工程师广泛使用这种聚合表来执行探索性分析、进行实验、为 ML 创建数据集以及为仪表板提供动力。聚合表具有预计算的指标，可以进一步聚合到任何所需的粒度。例如，从<em class="np"> agg_event_type_daily </em>表中，我们可以简单地通过按<em class="np"> event_date </em>分组并对<em class="np"> event_count </em>求和来获得所有 event_type 的每日事件计数。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="125f" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  event_date,<br/>  sum(event_count) as daily_event_count<br/>FROM<br/>  agg_event_type_daily<br/>GROUP BY<br/>  1</span></pre><p id="342e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">聚集表中的计数不同指标无法进一步聚集，我们无法从 agg_event_type_daily 表中获取所有 event_type 的每日不同用户。为了解决这个问题，我们可以利用近似相异计数函数使用的数据结构，即 HLL 草图(超对数草图)。HLL 草图是一种概率数据结构，用于估计数据集中唯一元素的数量。不同底层集合的 HLL 草图可以被合并，得到的 HLL 草图可以用来得到底层集合的并集的唯一元素。让我们看看如何将 HLL 草图合并到一个汇总表中。<em class="np"> agg_event_type_daily </em>表的更新模式如下所示</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a86443b71358a5e2ef8f106ca52336c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*zTWQTQ8vgjF1jNZKF5_3yA.png"/></div></figure><p id="05a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对该表的查询如下</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="565c" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  dt_partition as event_date,<br/>  event_type,<br/>  event_subtype,<br/>  count(*) as event_count,<br/>  approx_distinct(user_id, 0.005) as distinct_user_count,<br/>  approx_set(user_id, 0.005) as distinct_user_sketch<br/>FROM<br/>  event<br/>GROUP BY<br/>  1, 2, 3</span></pre><p id="bb1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新的<em class="np"> agg_event_type_daily </em>表让我们可以在不同的粒度上聚合不同的用户计数。例如，我们现在可以获得如下的每日不同用户计数</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="3e44" class="lx ly iq lt b be lz ma l mb mc">SELECT<br/>  event_date,<br/>  cardinality(merge(distinct_user_sketch)) as daily_distinct_user_count<br/>FROM<br/>  agg_event_type_daily<br/>GROUP BY<br/>  1</span></pre><p id="8301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本例中使用的 HLL 函数是 Presto 特有的，但类似的函数也存在于其他查询引擎中，如<a class="ae kv" href="https://github.com/swoop-inc/spark-alchemy/wiki/Spark-HyperLogLog-Functions" rel="noopener ugc nofollow" target="_blank"> Spark </a>、<a class="ae kv" href="https://docs.aws.amazon.com/redshift/latest/dg/hyperloglog-functions.html" rel="noopener ugc nofollow" target="_blank"> Redshift </a>、<a class="ae kv" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>。</p><h1 id="efd6" class="mr ly iq bd ms mt mu mv mw mx my mz na jw nb jx nc jz nd ka ne kc nf kd ng nh bi translated">结论</h1><p id="74f1" class="pw-post-body-paragraph kw kx iq ky b kz ni jr lb lc nj ju le lf nk lh li lj nl ll lm ln nm lp lq lr ij bi translated">当您在大规模计算不同的度量时，并且您在准确性方面有一些余地，您应该</p><ul class=""><li id="9775" class="md me iq ky b kz la lc ld lf mf lj mg ln mh lr nr mj mk ml bi translated">使用<em class="np"> approx_distinct </em>函数来加速查询</li><li id="b5cb" class="md me iq ky b kz mm lc mn lf mo lj mp ln mq lr nr mj mk ml bi translated">将<em class="np"> HLL 地图</em>合并到聚合表中，以实现进一步聚合</li></ul></div></div>    
</body>
</html>