<html>
<head>
<title>Convert PASCAL VOC XML to YOLO for Object Detection</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将PASCAL VOC XML转换为YOLO用于对象检测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/convert-pascal-voc-xml-to-yolo-for-object-detection-f969811ccba5#2022-04-28">https://towardsdatascience.com/convert-pascal-voc-xml-to-yolo-for-object-detection-f969811ccba5#2022-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="52b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">预处理影像数据集的技巧和诀窍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b196e9cf8372649325d56492c3f9eaca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*WXA6ZkqMpKsYfcEmuxNbfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d05f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本教程涵盖以下分步指南:</p><ul class=""><li id="d249" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">将XML注释转换为YOLO注释</li><li id="cc61" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用新创建的YOLO注释可视化图像中的边界框</li><li id="bf3c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将数据集分为训练集、验证集和测试集</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b760" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">概观</h1><h2 id="b4fd" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">PASCAL VOC XML</h2><p id="811f" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">PASCAL视觉对象类(VOC)项目是最早的计算机视觉项目之一，旨在标准化数据集和注释格式。注释可以用于图像分类和对象检测任务。</p><p id="2831" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下代码片段是PASCAL VOC XML注释的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="381c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据其规范，注释将以人类可读的XML格式定义，并与图像具有相同的名称(除了扩展名之外)。它应该具有以下项目:</p><ul class=""><li id="4fe3" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">folder</code> —图像的父目录。</li><li id="2c61" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">filename</code> —图像的名称(包括扩展名)。</li><li id="3bee" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">path</code> —图像的绝对路径</li><li id="6c21" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">source:database</code> —文件在数据库中的原始位置。仅在使用数据库时适用。否则，它将默认为<code class="fe oa ob oc od b">Unknown</code>。</li><li id="3224" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">size:width</code> —图像的宽度，以像素为单位。</li><li id="1bb4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">size:height</code> —图像的高度，以像素为单位。</li><li id="849a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">size:depth</code> —图像的深度。对于对象检测任务，它表示通道的数量。</li><li id="c428" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">segmented</code>-确定注释是线性的(0)还是非线性的(1)。非线性是指多边形形状。</li><li id="2e74" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:name </code> —对象的标签。</li><li id="fded" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:pose</code> —确定对象的方向是否不同。正常图像默认为<code class="fe oa ob oc od b">Unspecified</code>。</li><li id="d10c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:truncated</code> —确定对象是完全可见(0)还是部分可见(1)。部分可见是指隐藏在另一个对象后面的对象。</li><li id="bacb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:difficult</code> —确定物体是易于识别(0)还是难以识别(1)。</li><li id="6caa" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:bndbox:xmin</code> —左上位置的x坐标。</li><li id="3035" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:bndbox:ymin</code> —左上位置的y坐标。</li><li id="fc7b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:bndbox:xmax</code> —右下角位置的x坐标。</li><li id="e458" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">object:bndbox:ymax</code> —右下角位置的y坐标。</li></ul><p id="e6e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">PASCAL VOC XML注释的一个主要问题是，我们不能直接使用它进行训练，尤其是在对象检测任务上。大多数最新的模型依赖于不同的注释格式。最受欢迎的是:</p><ul class=""><li id="20c2" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">COCO——一个JSON文件包含整个数据集的五个信息部分。</li><li id="23db" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">YOLO —每个图像的单独文本文件，与预期图像具有相同的名称。</li></ul><h2 id="3baa" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">YOLO</h2><p id="d8b1" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">YOLO的规格如下:</p><ul class=""><li id="94e2" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">每个对象在文本文件中都应该有自己的一行</li><li id="9d80" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">每一行应具有以下模式:<code class="fe oa ob oc od b">class x_center y_center width height</code></li><li id="16d9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">类别号必须是从0开始的整数</li><li id="19e6" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">x_center</code>、<code class="fe oa ob oc od b">y_center</code>、<code class="fe oa ob oc od b">width</code>、<code class="fe oa ob oc od b">height</code>必须为规范化形式(范围从0到1)</li></ul><p id="6910" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，上述注释可以用YOLO格式表示如下:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7734" class="nh mq it od b gy oi oj l ok ol">0 0.65814696485623 0.6966426858513189 0.07987220447284345 0.14148681055155876<br/>0 0.7124600638977636 0.6882494004796164 0.09584664536741214 0.11990407673860912</span></pre><p id="5c56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">继续下一节，学习如何将XML注释转换成YOLO文本文件。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3ac0" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">将PASCAL VOC XML转换为YOLO</h1><p id="25f4" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">在工作目录中创建一个名为<code class="fe oa ob oc od b">xml2yolo.py</code>的新脚本。确保数据集和Python脚本的结构如下:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0616" class="nh mq it od b gy oi oj l ok ol">root<br/>├──annotations (folder)<br/>├  ├── 1.xml<br/>├  ├── 2.xml<br/>├  └── n.xml<br/>├──images (folder)<br/>├  ├── 1.jpg<br/>├  ├── 2.jpg<br/>├  └── n.jpg<br/>└──xml2yolo.py</span></pre><h2 id="2a78" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">导入</h2><p id="c7c4" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">首先，在文件顶部追加以下导入语句:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c926" class="nh mq it od b gy oi oj l ok ol">import xml.etree.ElementTree as ET<br/>import glob<br/>import os<br/>import json</span></pre><h2 id="5a6a" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">效用函数</h2><p id="fdf3" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">然后，定义以下效用函数:</p><ul class=""><li id="3f34" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">xml_to_yolo_bbox</code> —将XML边界框(<code class="fe oa ob oc od b">xmin</code>、<code class="fe oa ob oc od b">ymin</code>、<code class="fe oa ob oc od b">xmax</code>、<code class="fe oa ob oc od b">ymax</code>)转换为YOLO边界框(<code class="fe oa ob oc od b">x_center</code>、<code class="fe oa ob oc od b">y_center</code>、<code class="fe oa ob oc od b">width</code>、<code class="fe oa ob oc od b">height</code>)</li><li id="296d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">yolo_to_xml_bbox</code> —将YOLO边界框转换为XML边界框</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4fc5" class="nh mq it od b gy oi oj l ok ol">def xml_to_yolo_bbox(bbox, w, h):<br/>    # xmin, ymin, xmax, ymax<br/>    x_center = ((bbox[2] + bbox[0]) / 2) / w<br/>    y_center = ((bbox[3] + bbox[1]) / 2) / h<br/>    width = (bbox[2] - bbox[0]) / w<br/>    height = (bbox[3] - bbox[1]) / h<br/>    return [x_center, y_center, width, height]</span><span id="143d" class="nh mq it od b gy om oj l ok ol">def yolo_to_xml_bbox(bbox, w, h):<br/>    # x_center, y_center width heigth<br/>    w_half_len = (bbox[2] * w) / 2<br/>    h_half_len = (bbox[3] * h) / 2<br/>    xmin = int((bbox[0] * w) - w_half_len)<br/>    ymin = int((bbox[1] * h) - h_half_len)<br/>    xmax = int((bbox[0] * w) + w_half_len)<br/>    ymax = int((bbox[1] * h) + h_half_len)<br/>    return [xmin, ymin, xmax, ymax]</span></pre><h2 id="627a" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">初始化</h2><p id="bcb6" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">继续将以下变量添加到脚本中:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="11bd" class="nh mq it od b gy oi oj l ok ol">classes = []<br/>input_dir = "annotations/"<br/>output_dir = "labels/"<br/>image_dir = "images/"</span><span id="678c" class="nh mq it od b gy om oj l ok ol">os.mkdir(output_dir)</span></pre><blockquote class="on oo op"><p id="d997" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">注意，如果在当前工作目录中存在一个名为labels的文件夹，那么<code class="fe oa ob oc od b">os.mkdir</code>将会产生一个错误。没有添加异常处理，因为它允许我们识别剩余文件并在干净的状态下工作。我们可以添加以下条件语句，在创建新目录之前检查该目录是否存在:</p></blockquote><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="e338" class="nh mq it od b gy oi oj l ok ol">if not os.path.isdir(output_dir):<br/>    os.mkdir(output_dir)</span></pre><h2 id="e730" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">获取XML文件</h2><p id="c7b0" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">之后，使用<code class="fe oa ob oc od b">glob.glob</code>函数获取<code class="fe oa ob oc od b">annotation</code>文件夹中所有<code class="fe oa ob oc od b">xml</code>文件的列表。循环检查标签文件是否有对应的图像:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="337d" class="nh mq it od b gy oi oj l ok ol">files = glob.glob(os.path.join(input_dir, '*.xml'))<br/>for fil in files:<br/>    basename = os.path.basename(fil)<br/>    filename = os.path.splitext(basename)[0]<br/>    if not os.path.exists(os.path.join(image_dir, f"{filename}.jpg")):<br/>        print(f"{filename} image does not exist!")<br/>        continue</span></pre><blockquote class="on oo op"><p id="d1bd" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">从逻辑上讲，标签文件应该有相应的图像文件。然而，图像文件不一定需要标签文件。一个图像文件可能不包含任何对象，我们称之为背景图像。</p></blockquote><p id="47b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码将打印出没有图像对的注释的名称。要么删除注释，要么填充丢失的图像。</p><h2 id="149c" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">解析XML文件的内容</h2><p id="1c5b" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">随后，使用<code class="fe oa ob oc od b">ET</code>模块解析xml文件的内容。调用<code class="fe oa ob oc od b">find</code>或<code class="fe oa ob oc od b">findall</code>函数从文件中提取特定的元素。每个元素对象都包含内置的<code class="fe oa ob oc od b">text</code>函数来获取底层值。追加结果，并将其保存为具有相同基本名称的文件。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="22f3" class="nh mq it od b gy oi oj l ok ol">files = glob.glob(os.path.join(input_dir, '*.xml'))<br/>for fil in files:<br/>    <br/>    ...</span><span id="125a" class="nh mq it od b gy om oj l ok ol">    result = []</span><span id="eae2" class="nh mq it od b gy om oj l ok ol">    tree = ET.parse(fil)<br/>    root = tree.getroot()<br/>    width = int(root.find("size").find("width").text)<br/>    height = int(root.find("size").find("height").text)</span><span id="f925" class="nh mq it od b gy om oj l ok ol">    for obj in root.findall('object'):<br/>        label = obj.find("name").text<br/>        if label not in classes:<br/>            classes.append(label)<br/>        index = classes.index(label)<br/>        pil_bbox = [int(x.text) for x in obj.find("bndbox")]<br/>        yolo_bbox = xml_to_yolo_bbox(pil_bbox, width, height)<br/>        bbox_string = " ".join([str(x) for x in yolo_bbox])<br/>        result.append(f"{index} {bbox_string}")</span><span id="5178" class="nh mq it od b gy om oj l ok ol">    if result:<br/>        with open(os.path.join(output_dir, f"{filename}.txt"), "w", encoding="utf-8") as f:<br/>            f.write("\n".join(result))</span></pre><blockquote class="on oo op"><p id="cf25" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">注意，新标签会自动添加到<code class="fe oa ob oc od b">classes</code>变量中。索引基于相应标签的第一次出现。因此，我们应该将classes变量保存为文本文件以供参考:</p></blockquote><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="cbc8" class="nh mq it od b gy oi oj l ok ol">with open('classes.txt', 'w', encoding='utf8') as f:<br/>    f.write(json.dumps(classes))</span></pre><p id="d990" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它将生成一个名为<code class="fe oa ob oc od b">classes.txt</code>的文本文件。文本文件将包含表示数据集中所有唯一类的字符串列表。例如:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="94e9" class="nh mq it od b gy oi oj l ok ol">["tablets"]</span></pre><h2 id="9dc4" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">运行脚本</h2><p id="31b0" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">转换的<a class="ae ou" href="https://gist.github.com/wfng92/c77c822dad23b919548049d21d4abbb8" rel="noopener ugc nofollow" target="_blank">完整脚本如下:</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b652" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行以下命令，将XML注释转换为YOLO格式的文本文件:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="cd3e" class="nh mq it od b gy oi oj l ok ol">python xml2yolo.py</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="c8e3" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">可视化边界框</h1><p id="fab0" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">在训练之前检查数据集的质量是一个很好的做法。有时，注释或图像配对可能是错误的。因此，需要验证数据集的质量。一个好方法是在相应图像的顶部绘制边界框。</p><p id="2527" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用<code class="fe oa ob oc od b">Pillow</code>或<code class="fe oa ob oc od b">OpenCV</code>包。本教程使用<code class="fe oa ob oc od b">Pillow</code>包来绘制边界框。</p><p id="a8a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建另一个名为<code class="fe oa ob oc od b">draw.py</code>的脚本来可视化注释和图像。</p><h2 id="65fb" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">导入</h2><p id="af9a" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">将以下导入语句添加到文件中:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3dd1" class="nh mq it od b gy oi oj l ok ol">from PIL import Image, ImageDraw</span></pre><h2 id="6363" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">效用函数</h2><p id="0cd1" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">我们将需要两个效用函数:</p><ul class=""><li id="7e8c" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">yolo_to_xml_bbox</code> —将YOLO边界框转换回XML格式(基于像素)。这主要是因为<code class="fe oa ob oc od b">Pillow</code>的所有<code class="fe oa ob oc od b">ImageDraw.Draw</code>功能都使用像素。</li><li id="ea4f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">draw_image</code> —在输入图像的顶部绘制边界框。然后，通过用户界面显示出来。</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9fba" class="nh mq it od b gy oi oj l ok ol">def yolo_to_xml_bbox(bbox, w, h):<br/>    # x_center, y_center width heigth<br/>    w_half_len = (bbox[2] * w) / 2<br/>    h_half_len = (bbox[3] * h) / 2<br/>    xmin = int((bbox[0] * w) - w_half_len)<br/>    ymin = int((bbox[1] * h) - h_half_len)<br/>    xmax = int((bbox[0] * w) + w_half_len)<br/>    ymax = int((bbox[1] * h) + h_half_len)<br/>    return [xmin, ymin, xmax, ymax]</span><span id="40ea" class="nh mq it od b gy om oj l ok ol">def draw_image(img, bboxes):<br/>    draw = ImageDraw.Draw(img)<br/>    for bbox in bboxes:<br/>        draw.rectangle(bbox, outline="red", width=2)<br/>    img.show()</span></pre><blockquote class="on oo op"><p id="d36f" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">将<code class="fe oa ob oc od b">outline</code>变量修改为边界框的不同颜色。</p></blockquote><h2 id="7c55" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">初始化</h2><p id="ee76" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">继续初始化以下变量:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7cdb" class="nh mq it od b gy oi oj l ok ol">image_filename = "images/medical_pills.jpg"<br/>label_filename = "labels/medical_pills.txt"<br/>bboxes = []</span></pre><blockquote class="on oo op"><p id="b713" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">相应地替换文件名。</p></blockquote><h2 id="c45a" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">图像处理</h2><p id="8e97" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">加载图像并将预处理数据存储到<code class="fe oa ob oc od b">bboxes</code>变量中:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="5c28" class="nh mq it od b gy oi oj l ok ol">img = Image.open(image_filename)</span><span id="f466" class="nh mq it od b gy om oj l ok ol">with open(label_filename, 'r', encoding='utf8') as f:<br/>    for line in f:<br/>        data = line.strip().split(' ')<br/>        bbox = [float(x) for x in data[1:]]<br/>        bboxes.append(yolo_to_xml_bbox(bbox, img.width, img.height))</span></pre><h2 id="0ee3" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">绘制边界框</h2><p id="d28d" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">最后，调用<code class="fe oa ob oc od b">draw_image</code>实用函数在图像上绘制边界框:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8dce" class="nh mq it od b gy oi oj l ok ol">draw_image(img, bboxes)</span></pre><h2 id="20e0" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">运行脚本</h2><p id="b66f" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">以下<a class="ae ou" href="https://gist.github.com/wfng92/f7d2e70f6e71ea672ffc2f96f8bb8cd0" rel="noopener ugc nofollow" target="_blank"> Github要点</a>中的完整脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5b2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保存文件并在终端上运行以下命令:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="823d" class="nh mq it od b gy oi oj l ok ol">python draw.py</span></pre><p id="19d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该脚本将显示一个图像，并在其上绘制相应的边界框。例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/c3c03f3211c7735fbe24007af906967b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*lHNXyU7Zn9BQ2B0Cco4Yzw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><blockquote class="on oo op"><p id="9f5d" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">如果边界框与预期结果不一致，则图像或注释是错误的。</p></blockquote></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ddfb" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">分成不同的组</h1><p id="5bd6" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">下一步是将数据集分成不同的部分。为简单起见，本教程分为三组，即训练、验证和测试。创建一个名为<code class="fe oa ob oc od b">split_datasets.py</code>的新Python脚本。</p><h2 id="6df8" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">导入</h2><p id="add6" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">像往常一样，在脚本顶部添加以下导入语句:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="b3c9" class="nh mq it od b gy oi oj l ok ol">import random<br/>import glob<br/>import os<br/>import shutil</span></pre><h2 id="1526" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">效用函数</h2><p id="b15f" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">之后，定义一个实用函数，将现有的图像和注释复制到新的文件夹中。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="56c1" class="nh mq it od b gy oi oj l ok ol">def copyfiles(fil, root_dir):<br/>    basename = os.path.basename(fil)<br/>    filename = os.path.splitext(basename)[0]</span><span id="1b74" class="nh mq it od b gy om oj l ok ol">    # image<br/>    src = fil<br/>    dest = os.path.join(root_dir, image_dir, f"{filename}.jpg")<br/>    shutil.copyfile(src, dest)</span><span id="2b98" class="nh mq it od b gy om oj l ok ol">    # label<br/>    src = os.path.join(label_dir, f"{filename}.txt")<br/>    dest = os.path.join(root_dir, label_dir, f"{filename}.txt")<br/>    if os.path.exists(src):<br/>        shutil.copyfile(src, dest)</span></pre><blockquote class="on oo op"><p id="a087" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">当脚本中有错误或缺陷时，使用复制而不是移动来防止数据的意外丢失。</p></blockquote><h2 id="5cc9" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">初始化</h2><p id="e25a" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">继续初始化以下变量:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6fe0" class="nh mq it od b gy oi oj l ok ol">label_dir = "labels/"<br/>image_dir = "images/"<br/>lower_limit = 0<br/>files = glob.glob(os.path.join(image_dir, '*.jpg'))</span></pre><blockquote class="on oo op"><p id="6206" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated"><code class="fe oa ob oc od b">glob</code>用于图像文件，而不是注释，因为可能会出现图像不包含标签的情况。如果图像总数与标签文件总数不匹配，请不要惊讶。</p></blockquote><p id="afa3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将调用<code class="fe oa ob oc od b">random.shuffle</code>函数来随机重组数据集的顺序:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="5ce0" class="nh mq it od b gy oi oj l ok ol">random.shuffle(files)</span></pre><blockquote class="on oo op"><p id="5046" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">请注意，所有三个部分的最终分割在每次运行中都是不同的。如果数据集不平衡，这可能是一个问题。相应地修改脚本。</p></blockquote><p id="237b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是定义分割比例。本教程使用以下比率:</p><ul class=""><li id="eaad" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">train</code> — 80%的数据集</li><li id="d26a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">val</code> —数据集的10%</li><li id="3ee4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">test</code> — 10%的数据集</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="5c75" class="nh mq it od b gy oi oj l ok ol">folders = {"train": 0.8, "val": 0.1, "test": 0.1}<br/>check_sum = sum([folders[x] for x in folders])</span><span id="7bab" class="nh mq it od b gy om oj l ok ol">assert check_sum == 1.0, "Split proportion is not equal to 1.0"</span></pre><blockquote class="on oo op"><p id="0e5e" class="ky kz oq la b lb lc ju ld le lf jx lg or li lj lk os lm ln lo ot lq lr ls lt im bi translated">添加一个断言来验证比率的最终总和等于1是一个很好的做法。这确保了每个部分之间没有数据集重叠。</p></blockquote><p id="0a84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需更改字典的底层值。例如，下面的代码片段:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3592" class="nh mq it od b gy oi oj l ok ol">folders = {"train": 0.6, "val": 0.2, "test": 0.2}</span></pre><p id="72ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将设定比率定义如下:</p><ul class=""><li id="6806" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">train</code> — 60%的数据集</li><li id="b556" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">val</code> — 20%的数据集</li><li id="320d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><code class="fe oa ob oc od b">test</code> — 20%的数据集</li></ul><p id="b27a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果比例不等于1，终端将输出以下错误消息。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="55f9" class="nh mq it od b gy oi oj l ok ol">AssertionError: Split proportion is not equal to 1.0</span></pre><h2 id="34d9" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">复制文件</h2><p id="e81d" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">最后但同样重要的是，将相应的图像和注释复制到所需的部分:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4c0d" class="nh mq it od b gy oi oj l ok ol">for folder in folders:<br/>    os.mkdir(folder)<br/>    temp_label_dir = os.path.join(folder, label_dir)<br/>    os.mkdir(temp_label_dir)<br/>    temp_image_dir = os.path.join(folder, image_dir)<br/>    os.mkdir(temp_image_dir)</span><span id="1915" class="nh mq it od b gy om oj l ok ol">    limit = round(len(files) * folders[folder])<br/>    for fil in files[lower_limit:lower_limit + limit]:<br/>        copyfiles(fil, folder)<br/>    lower_limit = lower_limit + limit</span></pre><p id="cfa7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码片段将为train、val和test创建相应的文件夹。如果文件夹在创建过程中存在(在脚本的后续运行中),将会引发一个错误。每次运行前删除生成的文件夹，以确保没有数据集重叠。</p><h2 id="8b77" class="nh mq it bd mr ni nj dn mv nk nl dp mz lh nm nn nb ll no np nd lp nq nr nf ns bi translated">运行脚本</h2><p id="2e3d" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">分割数据集的<a class="ae ou" href="https://gist.github.com/wfng92/20d7541d7fa455c4c1860b8735239d96" rel="noopener ugc nofollow" target="_blank">完整代码</a>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="172b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在终端中运行以下命令:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9363" class="nh mq it od b gy oi oj l ok ol">python split_datasets.py</span></pre><p id="d788" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成后，我们应该在工作目录中获得以下结构:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="cd7d" class="nh mq it od b gy oi oj l ok ol">root<br/>├──annotations (folder)<br/>├  ├── 1.xml<br/>├  ├── 2.xml<br/>├  └── n.xml<br/>├──images (folder)<br/>├  ├── 1.jpg<br/>├  ├── 2.jpg<br/>├  └── n.jpg<br/>├──test(folder)<br/>├  ├── images (folder)<br/>├  └── labels (folder)<br/>├──train(folder)<br/>├  ├── images (folder)<br/>├  └── labels (folder)<br/>├──val (folder)<br/>├  ├── images (folder)<br/>├  └── labels (folder)<br/>├──draw.py<br/>├──split_datasets.py<br/>└──xml2yolo.py</span></pre><p id="002e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以使用它来训练对象检测模型，使用支持YOLO注释的机器学习框架。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="8e57" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="823a" class="pw-post-body-paragraph ky kz it la b lb nt ju ld le nu jx lg lh nv lj lk ll nw ln lo lp nx lr ls lt im bi translated">让我们回顾一下今天的话题。</p><p id="8403" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文首先简要介绍了PASCAL VOC XML和YOLO格式。</p><p id="1fa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，它提供了将PASCAL VOC XML文件转换为YOLO注释的深入指导。</p><p id="65f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随后，它强调了验证新创建的注释的重要性。可以通过创建一个在图像顶部绘制边界框的脚本来进行验证。</p><p id="e13f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，它介绍了如何将数据集分成三个不同的部分，即训练、验证和测试。</p><p id="989c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢你阅读这篇文章。祝你有美好的一天！</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="cef0" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">参考</h1><ol class=""><li id="1b22" class="lu lv it la b lb nt le nu lh ow ll ox lp oy lt oz ma mb mc bi translated"><a class="ae ou" href="https://github.com/ultralytics/yolov5" rel="noopener ugc nofollow" target="_blank"> YOLOv5 —列车定制数据</a></li><li id="3dbe" class="lu lv it la b lb md le me lh mf ll mg lp mh lt oz ma mb mc bi translated"><a class="ae ou" href="https://www.kaggle.com/datasets/perfect9015/pillsdetectiondataset" rel="noopener ugc nofollow" target="_blank">ka ggle——药丸检测数据集</a></li></ol></div></div>    
</body>
</html>