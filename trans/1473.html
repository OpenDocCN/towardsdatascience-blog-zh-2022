<html>
<head>
<title>Forecasting with Trees: Hybrid Classifiers for Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用树预测:时间序列的混合分类器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/forecasting-with-trees-hybrid-classifiers-for-time-series-b2509abf15f8#2022-04-11">https://towardsdatascience.com/forecasting-with-trees-hybrid-classifiers-for-time-series-b2509abf15f8#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba3f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建用于时间序列预测的有效混合随机森林分类器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f165b369434bdece162a270945d3ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wJTK31k0odo6Hx2v"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@karthikeyan_600?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Karthikeyan Perumal </a>拍摄的照片</p></figure><p id="c1c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理时间序列时，我们习惯于考虑传统的预测任务，其中我们必须逐点预测一些感兴趣的KPI的未来值。还有一些情况下，我们必须预测系统的状态。这种状态可能采用离散值，并且是已知回归变量之间的一些组合的结果。换句话说，<strong class="lb iu">我们必须在依赖于时间的场景中解决分类任务。</strong></p><p id="9c85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">时间序列分类问题的建模与标准分类任务的建模非常相似</strong>。我们只需要关注我们所掌握的数据的时间动态。在这个意义上，基于树的算法的使用在一些基本假设下可能是最佳的。基于树的模型的威力是众所周知的，并且有文献记载。最近，我们注意到在非标准表格任务中，这类模型的采用也有所增加。我们特别指的是所有关于时间序列预测的应用。这项工作<a class="ae ky" href="https://www.sciencedirect.com/science/article/pii/S0169207021001679" rel="noopener ugc nofollow" target="_blank">在该领域做出了显著贡献</a>，与深度学习解决方案相比，梯度推进模型表现出色。</p><p id="71aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的帖子中，我们开始研究这个领域，并发现了如何在时间序列预测场景中构建有效的基于混合树的预测器。随着我们的发现的成功，我们试图在分类环境中复制类似的方法。<strong class="lb iu">我们希望通过混合线性模型和随机森林来测试不同的混合分类器解决方案。</strong></p><p id="09ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://arxiv.org/ftp/arxiv/papers/2009/2009.00534.pdf" rel="noopener ugc nofollow" target="_blank">这部作品</a>中介绍了优秀的杂交候选人。它旨在引入各种加权随机森林版本，以利用集成学习的有效性。特别是，我们对基于堆叠的随机森林感兴趣，该森林对每个决策树做出的出袋(OOB)预测进行逻辑回归训练。</p><p id="436b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有趣的混合随机森林架构在这里展示<a class="ae ky" href="https://arxiv.org/pdf/1904.10416.pdf" rel="noopener ugc nofollow" target="_blank">。作者提出了两步学习过程，其中，在对原始数据拟合线性模型之后，对从上一步获得的残差拟合随机森林(为了方便起见，我们将其称为“<em class="lv">线性森林”</em>)。在</a><a class="ae ky" href="https://github.com/cerlymarco/linear-tree" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">线性树</strong> </a>包中提供了一个有效且兼容scikit-learn的线性森林实现。这个库提供了混合线性模型和决策树的学习能力的<strong class="lb iu">算法的实现(如<em class="lv"> LinearTree </em>、<em class="lv"> LinearForest </em>或<em class="lv"> LinearBoosting </em>)。</strong></p><p id="16ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们试图通过从头开始构建我们的混合随机森林预测器来解决一个<strong class="lb iu">超越概率问题。</strong>我们的任务是<strong class="lb iu">提前预测时间序列超过固定阈值的概率。</strong>我们专注于二进制分类，这里我们只登记两种状态:<em class="lv">高于</em>或<em class="lv">低于</em>阈值。</p><h1 id="4d7d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实验设置</h1><p id="32f6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们从一些简单的随机漫步开始产生一些人工序列。我们认为它们是在预测时观察到的，即它们是我们可以用来构建预测算法的数据。预测的目标是已知随机游走的线性组合，其中每个序列的贡献大小是从指数分布中随机生成的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/7ca1241ffb0b5c75d1e717ae7dd5b59d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*krBKEzTcahK7NdRI.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输入和目标生成流程示例(图片由作者提供)</p></figure><p id="c477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这些方面来说，我们似乎正在准备执行一项回归任务。我们对预测目标的准时值不感兴趣。取而代之的是，我们专注于从两个连续的时间步骤中检测目标何时可能记录到<em class="lv">突变</em>。</p><p id="9be1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">突变</em>的定义取决于领域，根据应用领域可以有不同的解释。在我们的实验环境中，假设我们对预测目标与前一步相比何时出现负变化感兴趣。我们需要区分我们的目标系列，并应用一个固定的阈值(以零为中心的水平线)来区分正负变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/af27060bbca312b12ba904d1ed09be28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s2DRNWU4iZCLZRKXIfVbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阈值等于0%的二进制标签生成(图片由作者提供)</p></figure><p id="dac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的预测模型必须被训练以区分这两个创建的类。有了这种数据和以零为中心的固定阈值，我们面临的分类问题就产生了一种近乎完美的平衡状态。为了让事情更刺激，我们可以想象在不平衡的环境下工作。假设我们也对预测目标何时记录到<em class="lv">显著的</em>负变化感兴趣。这可以通过设置低于零的阈值来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/bade4563738a023d30b1a9f504d18313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ypHqjpzAFX-tU7sXRHWNxg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作为阈值水平函数的二进制标签生成(图片由作者提供)</p></figure><p id="443f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，阈值越低，要预测的感兴趣的负变化就越高(即标签分布越不平衡)。</p><h1 id="dc2f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结果</h1><p id="4b63" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">至此，我们已经为建模做好了准备。我们选择了三种不同的预测架构来测试我们的二元分类问题。我们从scikit-learn中提供的标准随机森林分类器开始。然后，作为<em class="lv">的混血儿</em>，我们要测试一个加权随机森林和线性森林。提醒一下:</p><ul class=""><li id="a9c0" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">加权随机森林</strong>是堆叠模型的一个特殊版本，其中估计器是使用袋外预测来拟合的。</li><li id="15d8" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">线性森林</strong>反复提供混合线性和随机森林结果的预测。</li></ul><p id="be08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们生成100对不同的特征(X)和目标(y ),以模拟更多不同的场景。对于每个场景，我们尝试使用不同阈值级别的所有提到的分类器来理解不平衡上下文中的行为。作为预处理，我们对输入特征进行简单的一阶微分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/f20d909e0bfb23282cdf59408a5dacdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z_2F6YI_7nTA_dc3.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">标准随机森林的测试数据结果(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/fb1e5923ac9424356a2471e9a8ecbfd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VlpV_wl53nq4XpIh.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">加权随机森林的测试数据结果(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/edfd1bbb1197909d12677d7738818bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*slKjeAcRpoG0fkKh.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">线性森林的测试数据结果(图片由作者提供)</p></figure><p id="0514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于所有测试的算法，当不平衡变得更强时(即阈值越低)，我们记录到性能下降(如预期的那样)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/4ced13278257b04bfb79e5d11112ae64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9KaAqtXUcpYtsCh9.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">目标变化阈值固定为0%的测试数据结果(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/69cb1952658725def0e6c1d3bb1a70e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jM7zhNeCMqbiOxar.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">目标变化阈值固定为-0.1%的测试数据结果(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/956a25e01f3e84ac2e8f690a2bacf232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jq1RtEYjcQYB1BKR.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">目标变化阈值固定为-0.2%的测试数据结果(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/08ec43a4f16e263f735c80bd939f9dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lgm9e9Z9MylHY1o_.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">目标变化阈值固定为-0.3%的测试数据结果(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/c233c44aab5dce52a1932a0576a96403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Xs0kDJ9_1Au6znah.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">目标变化阈值固定为-0.4%的测试数据结果(图片由作者提供)</p></figure><p id="b7f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看每个阈值设置中的性能，我们会注意到不同的模式。标签越平衡，线性森林记录的性能(在精确度和召回率方面)越好。标签分布越不平衡，加权随机森林的召回率越高。相反，标准随机森林可能总是在不平衡的上下文中达到最佳精度。</p><h1 id="5596" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="77f7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这篇文章中，我们从一个标准的时间序列预测问题切换到一个更有趣的分类任务。尽管有这种变化，我们还是采用了所有对用基于树的算法建模时间相关系统有用的预防措施。在这个意义上，我们测试了不同的混合随机森林体系结构，这些体系结构显示出是更经典的随机森林分类器的有价值的替代方案。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="71fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/cerlymarco/MEDIUM_NoteBook" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">查看我的GITHUB回购</strong> </a></p><p id="2464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持联系:<a class="ae ky" href="https://www.linkedin.com/in/marco-cerliani-b0bba714b/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a></p></div></div>    
</body>
</html>