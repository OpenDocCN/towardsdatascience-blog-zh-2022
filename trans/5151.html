<html>
<head>
<title>Augmenting Images for Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">增强深度学习的图像</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/augmenting-images-for-deep-learning-3f1ea92a891c#2022-11-17">https://towardsdatascience.com/augmenting-images-for-deep-learning-3f1ea92a891c#2022-11-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dd5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python 通过翻转、调整亮度、颜色抖动和随机噪声来增加数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/233e45ec0b08f8978b40557f79295b3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPv1OZJyc1QIfYRctrI8Mg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(来源:作者)</p></figure><p id="8293" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据收集既费时又费钱，说实话还很无聊。当我们收集数据的能力有限时，数据扩充可以发挥重要作用。它可以帮助我们建立一个更强大的数据集，减少过度拟合，增加训练数据量。</p><p id="4dc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将讨论数据扩充及其好处。我们也将保持实事求是。那就是通过遍历用于增强图像的 Python 代码。具体来说，我们将讨论如何进行这些扩充:</p><ul class=""><li id="1b38" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">翻转图像</li><li id="ba2d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">调节亮度</li><li id="f8ee" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">随机颜色抖动</li><li id="a38c" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">随机噪声(高斯、椒盐和删除)</li></ul><p id="9541" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将讨论增强图像的最佳实践。特别是，如何最好地验证我们的模型并在生产中测试它。</p><h2 id="c0b3" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">用例—自动化汽车</h2><p id="656f" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了保持有趣，我们将为自动驾驶汽车增加图像。你可以在<strong class="la iu">图 1 </strong>中看到我们的意思。汽车前面有一个摄像头，一个模型使用这些图像进行预测。这些预测然后被用来指导汽车。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/1d59a816c86e4bf7dd545fb0881bb9b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lk3_e68IEnRPw8mEhvbXCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:装有摄像头传感器自动汽车(来源:作者)</p></figure><p id="a0b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的目标是让赛车绕着赛道行驶，同时保持在橙色线内。在这个过程中，我们将讨论哪些增强对于这个特定的应用程序有意义。这是为了强调围绕数据扩充的选择需要一些批判性思维。</p><h1 id="4ab5" class="nh mj it bd mk ni nj nk mn nl nm nn mq jz no ka mt kc np kd mw kf nq kg mz nr bi translated">收集可靠的数据集</h1><p id="fad5" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在我们开始之前，有必要讨论一下数据收集。这是因为数据扩充是收集可靠数据集的替代或补充方法。</p><h2 id="f89b" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">什么是稳健数据集？</h2><p id="3351" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">稳健数据集是反映模型预期运行的所有条件的数据集。这些条件由照明条件、摄像机角度、房间颜色或背景中的物体等变量决定。在这样的数据集上训练将产生一个对这些变量的变化有弹性的模型。</p><blockquote class="ns"><p id="f874" class="nt nu it bd nv nw nx ny nz oa ob lt dk translated">稳健数据集=稳健模型</p></blockquote><p id="dc04" class="pw-post-body-paragraph ky kz it la b lb oc ju ld le od jx lg lh oe lj lk ll of ln lo lp og lr ls lt im bi translated">一个很好的例子来自我们对自动汽车的体验。我们收集数据，训练模型，并部署它。它完美地工作了！直到我们打开百叶窗…</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/5cfeeb998538c778dcc706dc1d3d30b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/1*TtQmYlWj4tQrN5HkG8a9Ag.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:在不同条件下努力表现的模型</p></figure><p id="e436" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">阳光从轨道上反射回来，把模型“弄糊涂了”。在这种情况下，它无法做出准确的预测。换句话说，该模型对光照条件的变化并不鲁棒。</p><h2 id="e13c" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">如何收集可靠的数据集</h2><p id="6771" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">构建强大的数据集始于良好的数据收集策略。你需要考虑所有会影响条件的变量。然后你需要收集数据来捕捉这些变量的变化。例如，对于不同的照明条件，我们可以:</p><ul class=""><li id="97af" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">开灯和关灯</li><li id="978e" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">打开和关闭百叶窗</li><li id="920d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在一天的不同时间收集数据</li></ul><p id="2c06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其他变量是图像背景的不同方面。这包括墙壁和地毯的颜色以及背景中不同的物体。为了说明这些，我们可以:</p><ul class=""><li id="e7ac" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">在不同的房间收集数据</li><li id="6274" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将不同的对象移到背景中</li></ul><p id="bc3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随着这些变化，我们正在做的是向我们的数据集添加噪声。希望模型将学会忽略这种噪音，只使用轨道进行预测。换句话说，我们希望模型使用真正的原因，而不是关联。</p><h1 id="f203" class="nh mj it bd mk ni nj nk mn nl nm nn mq jz no ka mt kc np kd mw kf nq kg mz nr bi translated">数据扩充的好处</h1><p id="ec25" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">数据扩充是指我们使用代码系统地或随机地改变图像。这允许我们人为地引入噪声并增加数据集的大小。实际上，目标与数据收集是一样的，因此好处是相似的。</p><h2 id="dbbd" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">构建强大的数据集</h2><p id="3bfb" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">通常我们会受到可以收集多少数据的限制。在这种情况下，数据扩充有助于提高数据集的稳健性。即使您已经设法收集了大量数据，增强也可以提供额外的一层健壮性。</p><p id="554a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不过，要做到这一点，我们需要批判性地思考扩增的类型。也就是说，它们应该模拟我们期望在真实世界中看到的条件。例如，稍后我们将看到如何调整图像的亮度来模拟不同的照明条件。</p><h2 id="a10d" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">减少对一组条件的过度拟合</h2><p id="6dc3" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">通过良好的扩充，我们可以减少过度拟合。需要明确的是，这不同于过度适应训练集。以<strong class="la iu">图 3 </strong>为例。假设，我们只在一个房间里收集数据。因此，该模型将背景中的对象与左转的预测相关联。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/c310b18d34dbc7beff0814b3f6ef991f.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*y4BJVKXQMga0b3FvKmCxbQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:过度适应房间中的对象(来源:作者)</p></figure><p id="3306" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个物体会出现在我们收集的所有图像中。这意味着它将出现在训练、验证甚至测试集中。该模型可以在所有这些集合上执行得很好，但是在生产中仍然执行得很差。例如，如果我们移走物体，它可能会变得“混乱”,不能左转。换句话说，模型过度适应了我们数据集中反映的条件。</p><p id="974a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据扩充有助于这种类型的过度拟合。稍后，我们将看到删除像素对上面的例子有什么帮助。也就是说，我们可以人为地从背景中去除物体。</p><h2 id="e091" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">模型收敛</h2><p id="d77a" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们可以用多种不同的方式来增强同一个图像。这可能会人为地扩大数据集的规模。考虑到深度学习需要大型数据集，这可以帮助模型参数的收敛。</p><h1 id="7a9a" class="nh mj it bd mk ni nj nk mn nl nm nn mq jz no ka mt kc np kd mw kf nq kg mz nr bi translated">用 Python 扩充数据</h1><p id="d84c" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">好了，记住所有这些，让我们继续实际增加数据。我们会检查代码，你也可以在<a class="ae oj" href="https://github.com/conorosully/medium-articles/blob/master/src/image_tools/image_augmentation.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个项目。</p><p id="fe74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们将使用下面的导入。我们有一些标准包装(第 2-3 行)。<strong class="la iu"> Glob </strong>用于处理文件路径(第 5 行)。我们还有一些用来处理图像的包(第 8-11 行)。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="2844" class="op mj it ol b be oq or l os ot">#Imports <br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/><br/>import glob<br/>import random<br/><br/>import torchvision.transforms as transforms<br/>import matplotlib.image as mpimg<br/>from PIL import Image, ImageEnhance<br/>import cv2</span></pre><p id="bf04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，我们将增强用于自动驾驶汽车的图像。你可以在<a class="ae oj" href="https://www.kaggle.com/datasets/conorsully1/jatracer-images?select=object_detection" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>上找到这些例子。这些图像都是 224 x 224 像素。我们用下面的代码显示其中的一个。</p><p id="9f33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记下图像名称(第 3 行)。前两个数字是 224 x 224 帧内的 x 和 y 坐标。在<strong class="la iu">图 4 </strong>中，你可以看到我们用绿色圆圈显示了这些坐标(第 11 行)。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="dd6e" class="op mj it ol b be oq or l os ot">read_path = "../../data/images/"<br/><br/>name = "32_50_c78164b4-40d2-11ed-a47b-a46bb6070c92.jpg"<br/><br/>#Get x,y coordinates from name<br/>x = int(name.split("_")[0])<br/>y = int(name.split("_")[1])<br/><br/>#Load image and add circle for coordinates<br/>img = mpimg.imread(read_path + name)<br/>cv2.circle(img, (x, y), 8, (0, 255, 0), 3)<br/><br/>plt.imshow(img)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/ac805c8f9e9400bbc9b8a74c799cfb0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*HNOFInB1vAbWCvoCFMAKww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 4:示例图片(来源:作者)</p></figure><p id="f972" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些坐标是目标变量。该模型使用这些图像来尝试预测它们。这个预测然后被用来指导汽车。在这种情况下，你可以看到汽车即将左转。理想的方向是朝着绿圈给出的坐标走。</p><h2 id="43e0" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">翻转图像</h2><p id="62f9" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">假设我们在逆时针方向上收集了一堆图像(即仅左转)。如果我们想让汽车右转，我们必须收集更多的数据。或者，由于我们的轨道是对称的，我们可以在 x 轴上翻转图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/b41540a29573adf17ac84072f2bc8026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZB4JB3NwBwDxNbs6A2rL6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 5:翻转对称轨道(来源:作者)</p></figure><p id="20a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用<strong class="la iu"> flip_img </strong>函数来实现这一点。请记住，在水平轴上翻转时，x 坐标也需要调整。我们在第 9 行从 224(图像宽度)中减去当前坐标。你可以在<strong class="la iu">图 6 </strong>中看到这个函数的结果。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="8748" class="op mj it ol b be oq or l os ot">def flip_img(name,img):<br/>    """Invert image and target on x axis"""<br/>    <br/>    # flip image<br/>    img = cv2.flip(img,1)<br/>    <br/>    # flip target variable<br/>    s = name.split("_")<br/>    s[0] = str(224 - int(s[0]))<br/>    name = "_".join(s)<br/>    <br/>    return name, img   </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/7f61aad68cdfeaa8c9d46fdd15afea7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*W6KFNEqSCOC9nZoApqZrdw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 6:水平翻转(来源:作者)</p></figure><p id="b66a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">即使你已经收集了两个方向的数据，翻转图像也是有意义的。这允许我们将数据集的大小加倍。但是垂直翻转呢？</p><p id="e2f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于某些应用，这可能是有意义的。对于我们的自动驾驶汽车来说……没那么多。看一下<strong class="la iu">图 7 </strong>。垂直翻转意味着汽车将在天花板上行驶。除非我们在太空中驾驶，否则这不是我们在生产中预期的情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/85cf3a2964852a0fa2932f0eb66819a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*slalzy2wfUTrx3jcuSHWMQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 7:垂直翻转(来源:作者)</p></figure><h2 id="7ca3" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">调整亮度</h2><p id="692b" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">通过<strong class="la iu"> adjust_brightness </strong>，我们可以使用<strong class="la iu"> factor </strong>参数来改变图像的亮度。查看<strong class="la iu">图 8 </strong>，如果我们增加因子(1.5)，图像会更亮。类似地，当系数小于 1 时，图像会变暗。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="add4" class="op mj it ol b be oq or l os ot">def adjust_brightness(img,factor=1):<br/>    """<br/>    Invert image on x axis<br/>        factor: &lt;1 will decrease brightness and &gt;1 will increase brightness<br/>    """<br/>    img = Image.fromarray(img)<br/><br/>    enhancer = ImageEnhance.Brightness(img)<br/>    img = enhancer.enhance(factor)<br/><br/>    return img</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00d709b9c79c92c2fbe84e3356b3d7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hCr3Q8K66rXlS58wE-ssw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 8:调整亮度(来源:作者)</p></figure><p id="f1b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个功能可以帮助我们模拟不同的光照条件。我们可以看到，如果我们在数据收集期间开灯和关灯，我们会得到类似的结果。</p><h2 id="371b" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">颜色抖动</h2><p id="038a" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们可以使用<strong class="la iu">抖动</strong>功能进一步扩大这些类型。这将随机改变图像的亮度、对比度、饱和度和色调。使用这些参数，我们可以定义这些方面的变化程度。你可以在<strong class="la iu">图 9 </strong>中看到一些例子。这些是使用默认参数值创建的。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="fac0" class="op mj it ol b be oq or l os ot">def jitter(img, b=0.2, c=0.2, s=0.2, h=0.1):<br/>    """<br/>    Randomly alter brightness, contrast, saturation, hue within given range<br/>    """<br/>    <br/>    img = Image.fromarray(img)<br/>    <br/>    transform = transforms.ColorJitter(<br/>    brightness=b, contrast=c, saturation=s, hue=h)<br/>  <br/>    # apply transform<br/>    img = transform(img)<br/>    <br/>    return img</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/00d8d3c3313ee32257d35f13e749b1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HCP1qM24LesseifArBSGw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 9:抖动增强(来源:作者)</p></figure><p id="b1aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，您需要考虑这些扩充对您的应用程序是否有意义。你可以看到，默认情况下，我们将色调因子设置为 0.1(即 h=0.1)。如图<strong class="la iu">图 10 </strong>所示，较高的色调因子会返回具有不同色彩轨迹的图像。然而，在生产中，我们的轨道将始终是橙色的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/00e1e5e3573d61ab6ce83eae8b9f69df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HF8ixMz0JqB5VRQ2zPDpWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 10:色调=0.5 时的抖动(来源:作者)</p></figure><p id="c7a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还应该考虑这些类型的转换的局限性。他们调整整个图像的颜色。现实中，光照条件更复杂。阳光可以从不同的角度反射出赛道。轨道的某些部分可能比其他部分更暗。如果你真的想捕捉这种噪音，你必须做好数据收集工作。</p><h2 id="18f1" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">输入噪声</h2><p id="7463" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">一种不太系统的方法是随机引入噪声。你可以在图 11 中看到一些例子。在每种情况下，我们都能够调整引入的噪声量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/d7ea61e4c52dc0ea00444ca11ba04f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlM5RFgcUec1KE_SJDqr_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 11:噪音(来源:作者)</p></figure><p id="c410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在进行这些放大时，请记住，我们 224 x 224 图像中的每个像素都有 3 个通道——R、G、b。每个通道可以取 0 到 255 之间的值。这些决定了像素的颜色。</p><p id="6004" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图 11 中的第一行是使用<strong class="la iu"> gaussian_noise </strong>函数创建的。我们创建一个与图像(第 4-5 行)具有相同尺寸(224 x 224 x 3)的随机噪声阵列。这个数组中的每个元素将从均值为 0 的正态分布和给定的方差(<strong class="la iu"> var </strong>)中采样。将此添加到图像中会随机调整 R、G、B 通道。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="6c7c" class="op mj it ol b be oq or l os ot">def gaussian_noise(img,var=5):<br/>    """Add guassian noise to image"""<br/>    <br/>    dims = np.shape(img)<br/>    noise = np.random.normal(0,var,size=dims).astype("uint8")<br/><br/>    img = img + noise<br/>    <br/>    return img</span></pre><p id="bb28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> sp_noise </strong>功能的工作方式类似。除了现在我们以给定的概率(<strong class="la iu"> prob </strong>)随机改变像素为黑色或白色。您可以在图 11 中的第二排看到这一点。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="bcd9" class="op mj it ol b be oq or l os ot">def sp_noise(img,prob=0.1):<br/>    """Add salt and pepper noise to image"""<br/>    <br/>    height,width,channels = np.shape(img)<br/>    img = np.array(img)<br/>    <br/>    #Iterate over all pixels<br/>    for i in range(height):<br/>        for j in range(width):<br/>            #Randomly change pixel values<br/>            if random.random()&lt;prob:<br/>                if random.random() &lt; 0.5:<br/>                    img[i][j] = np.array([255,255,255]) #white<br/>                else:<br/>                    img[i][j] = np.array([0,0,0]) #black<br/>                    <br/>    img = Image.fromarray(img)<br/>        <br/>    return img</span></pre><p id="03d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">高斯和椒盐噪声具有降低图像质量的效果。在生产中，模型可以使用不同质量的图像进行预测。这些扩充有助于创建一个对这些变化具有鲁棒性的模型。</p><p id="f03a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">delete_square 函数是添加噪声的另一种方法。它的工作原理是删除大块的图像。更具体地说，它将一个给定尺寸的随机正方形(<strong class="la iu">像素</strong>)变成黑色。图 11 的最后一行给出了示例。</p><pre class="kj kk kl km gt ok ol om bn on oo bi"><span id="85b0" class="op mj it ol b be oq or l os ot">def delete_square(img,pixels=20):<br/>    """Delete random square from image"""<br/>    <br/>    img = np.array(img)<br/>    h,w,channels = np.shape(img)<br/>    <br/>    #Random starting pixel<br/>    rh = random.randint(0,h)<br/>    rw = random.randint(0,w)<br/>  <br/>    sub = round(pixels/2)<br/>    add = pixels-sub<br/>    <br/>    #Boundries for square<br/>    hmin = max(rh-sub,0)<br/>    hmax = min(rh+add,h-1)<br/>    vmin = max(rw-sub,0)<br/>    vmax = min(rw+add,w-1)<br/>    <br/>    # Turn pixel within range black<br/>    img[hmin:hmax,vmin:vmax] = np.array([0,0,0])<br/><br/>    img = Image.fromarray(img)<br/>    return img</span></pre><p id="dee7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">删除也有助于建立一个更健壮的模型。在进行预测时，模型可能会关注某个特定的特征。例如，我们的模型可能只使用外部橙色车道。删除部分图像将强制模型使用多个特征。因此，如果某个特征发生了变化，模型仍然能够做出准确的预测。</p><p id="8139" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然耗时，与删除，你可能要采取更系统的方法。即排除图像的特定部分。你可以在<strong class="la iu">图 12 </strong>中看到这一点。这里我们已经从背景中删除了椅子。这是因为模型不会将其与右转相关联。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7eeb92d54e15f3bc7b7d973e68ef02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAL_QqtIo0dQ6RlStwbisQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 12:系统删除(来源:作者)</p></figure><h1 id="06c1" class="nh mj it bd mk ni nj nk mn nl nm nn mq jz no ka mt kc np kd mw kf nq kg mz nr bi translated">测量增强的效果</h1><p id="f8fa" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">所以我们已经看到了不同类型的增强。我们也看到了如何改变其中一些的水平。实际上，类型和级别可以被视为一个超参数。当调谐这些是重要的是要记住一些事情。</p><h2 id="0d32" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">不要扩充测试集</h2><p id="f76a" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">假设我们扩充整个数据集，并进行训练和测试分割。这可能会导致高估模型的性能。这是因为过度适应训练集不一定会导致测试集的性能不佳。</p><p id="d746" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以我们在<strong class="la iu">图 8 </strong>中看到的亮度增强为例。其中一些可能在训练中结束，而另一些可能在测试集中结束。现在考虑同样的事情会发生在其他的增强上。您可以看到测试集看起来与训练集非常相似。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00d709b9c79c92c2fbe84e3356b3d7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_hCr3Q8K66rXlS58wE-ssw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 8:调整亮度(来源:作者)</p></figure><p id="0180" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，最好不要增加测试集。这是因为测试集用于评估模型在生产中的性能。这里，不期望模型对扩充数据进行预测。</p><h2 id="2e54" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">测试集中没有反映所有条件</h2><p id="72e5" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">同时，您需要考虑到您的测试集并不健壮。因此，良好的测试性能并不意味着生产中的良好性能。这是因为您的模型可能会面临测试集中没有捕捉到的情况。因此，为了真正理解增强的影响，我们需要在生产中测试它们。</p><p id="3e8b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这让我们陷入了一个棘手的境地。生产环境中的测试非常耗时，并且您无法在所有环境中进行测试。这意味着不可能测量扩增的效果。最终，您将需要批判性地思考什么样的增强适合您的应用程序。领域知识和经验可能更好地表明什么会起作用。</p></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><p id="6b59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章！你可以成为我的<a class="ae oj" href="https://conorosullyds.medium.com/membership" rel="noopener"> <strong class="la iu">推荐会员</strong> </a> <strong class="la iu"> :) </strong>来支持我</p><div class="ph pi gp gr pj pk"><a href="https://conorosullyds.medium.com/membership" rel="noopener follow" target="_blank"><div class="pl ab fo"><div class="pm ab pn cl cj po"><h2 class="bd iu gy z fp pp fr fs pq fu fw is bi translated">通过我的推荐链接加入 Medium 康纳·奥沙利文</h2><div class="pr l"><h3 class="bd b gy z fp pp fr fs pq fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ps l"><p class="bd b dl z fp pp fr fs pq fu fw dk translated">conorosullyds.medium.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py ks pk"/></div></div></a></div><p id="7356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">| <a class="ae oj" href="https://twitter.com/conorosullyDS" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae oj" href="https://www.youtube.com/channel/UChsoWqJbEjBwrn00Zvghi4w" rel="noopener ugc nofollow" target="_blank"> YouTube </a> | <a class="ae oj" href="https://mailchi.mp/aa82a5ce1dc0/signup" rel="noopener ugc nofollow" target="_blank">时事通讯</a> —注册免费参加<a class="ae oj" href="https://adataodyssey.com/courses/shap-with-python/" rel="noopener ugc nofollow" target="_blank"> Python SHAP 课程</a></p><h2 id="1378" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">资料组</h2><p id="4c46" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><strong class="la iu"> JatRacer 图片</strong> (CC0:公共领域)<a class="ae oj" href="https://www.kaggle.com/datasets/conorsully1/jatracer-images" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/datasets/conorsully1/jatracer-images</a></p><h2 id="9545" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">参考</h2><p id="a8d8" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">H.Naveed，<strong class="la iu">调查:用于数据扩充的图像混合和删除</strong>(2021)<a class="ae oj" href="https://arxiv.org/abs/2106.07085" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2106.07085</a></p><p id="b5e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Gaudenz Boesch，<strong class="la iu">2022 年计算机视觉的图像数据增强</strong> <strong class="la iu">【指南】</strong><a class="ae oj" href="https://viso.ai/computer-vision/image-data-augmentation-for-computer-vision/#:~:text=Image%20augmentation%20algorithms%20include%20geometric,learning%2C%20and%20neural%20style%20transferring" rel="noopener ugc nofollow" target="_blank">https://viso . ai/Computer-Vision/Image-Data-Augmentation-for-Computer-Vision</a></p><p id="f146" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">如何在 PyTorch 中随机更改图像的亮度、对比度、饱和度和色调</strong>(2022)<a class="ae oj" href="https://www.geeksforgeeks.org/how-to-randomly-change-the-brightness-contrast-saturation-and-hue-of-an-image-in-pytorch/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/How-to-random-change-the-brightness-contrast-saturation-and-hue-of-an-image-in-py torch/</a></p><p id="72a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">C.Shorten &amp; T.M. Khoshgoftaar，<strong class="la iu">深度学习的图像数据增强调查</strong>(2019)<a class="ae oj" href="https://journalofbigdata.springeropen.com/articles/10.1186/s40537-019-0197-0" rel="noopener ugc nofollow" target="_blank">https://journalofbigdata . springer open . com/articles/10.1186/s 40537-019-0197-0</a></p><p id="bc8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Jason Brownlee，<strong class="la iu">用噪声训练神经网络以减少过拟合</strong>(2019)<a class="ae oj" href="https://machinelearningmastery.com/train-neural-networks-with-noise-to-reduce-overfitting/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/Train-Neural-Networks-With-Noise-to-Reduce-over fitting/</a></p></div></div>    
</body>
</html>