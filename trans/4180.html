<html>
<head>
<title>Don’t Repeat These 5 Programming Mistakes as a Data Scientist/Analyst</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为数据科学家/分析师，不要重复这5个编程错误</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/avoid-these-5-programming-mistakes-as-a-data-scientist-analyst-4b7017d509fe#2022-09-16">https://towardsdatascience.com/avoid-these-5-programming-mistakes-as-a-data-scientist-analyst-4b7017d509fe#2022-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高数据科学家工作效率的步骤</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7e2eee40958a9fc3aa0ec35c713c3a36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xR4qiZNXQQVzyW4iFx25Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:Unsplash</p></figure><p id="bfed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我目前作为数据科学经理的角色中，我与多位数据科学家合作，我看到他们中的许多人在处理大数据时犯了一些基本的数据操作错误(我也曾经犯过一些这样的错误！).这些错误会导致代码执行时间的急剧增加，有时还会导致大量的返工和浪费。</p><p id="e0f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇博文中，我将讨论如果你想成为一名更好(更高效)的数据科学家，你应该避免的5大编程错误。</p><h1 id="dcab" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated"><strong class="ak">处理大数据时应避免的5大错误:</strong></h1><h2 id="f9bf" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 1。在不知道数据级别/主键的情况下连接数据集</strong></h2><p id="4c56" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">数据级别被定义为每行具有唯一值的列或列的组合。数据的级别通常由一些ID变量定义(比如客户ID)。让我们用例子来理解这一点:</p><p id="f18b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nd">一、单列为级:</em>在下面的数据集中，Order ID列没有两行具有相同的值，所以Order ID是该数据集的数据(主键)级。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/e23cb8d731c470b9b91634ea47813487.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*nn0rkG-HKoXNyXsFNwuidQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据集1(作者提供的图片)</p></figure><blockquote class="nf ng nh"><p id="8a37" class="ky kz nd la b lb lc ju ld le lf jx lg ni li lj lk nj lm ln lo nk lq lr ls lt im bi translated">连续列(如Sales)不能定义为数据级别。</p></blockquote><p id="8563" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nd">二。作为级别</em>的多列:在下面的数据集中，我们可以看到订单ID对于多行是相同的，因此它不是该数据集的级别。如果我们仔细观察，我们会发现没有两行的订单ID和产品ID组合具有相同的值，因此这两列都是该数据集的数据级别(主键)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9433ef2f85deae566ac7db2d2bb07e59.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*4_MyaOzlLF3VuKW77Hjn6g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据集2(图片由作者提供)</p></figure><p id="97b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在执行连接时，理解数据的级别变得非常重要，因为连接主要是在数据集的主键上执行的。</p><blockquote class="nf ng nh"><p id="e6e2" class="ky kz nd la b lb lc ju ld le lf jx lg ni li lj lk nj lm ln lo nk lq lr ls lt im bi translated">在非主键上连接数据集可能会导致错误的结果。</p></blockquote><h2 id="2190" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 2。不过滤所需的行</strong></h2><p id="6cf1" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">有时，数据科学家不会在查询开始时筛选所需的行，而是等到最后一次查询时才筛选这些行。处理大数据是一种犯罪，因为它会大大增加执行时间，尤其是在应用连接等复杂操作时。</p><p id="32e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nd">不好的做法</em> </strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="1b12" class="mm lv it nn b gy nr ns l nt nu">Step 1: Transform data <br/>Step 2: Apply join operation<br/>Step 3: More transformation <br/><strong class="nn iu">Step 4: Filter rows</strong></span></pre><p id="e992" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nd">好的做法</em> </strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="fc1a" class="mm lv it nn b gy nr ns l nt nu"><strong class="nn iu">Step 1: Filter row<br/></strong>Step 2: Transform data <br/>Step 3: Apply join operation<br/>Step 4: More transformation</span></pre><h2 id="0c4a" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated"><strong class="ak"> 3。使用大量连接/自连接</strong></h2><p id="23ca" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">自连接就像一把双刃剑，如果你恰当地使用它们，它们可能是一件好事，但是如果你过于频繁地使用它们，它就是一个祸根，因为在Hadoop、Hive、Spark等分布式环境中，连接是最昂贵的任务。</p><p id="6b32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有一个组织内员工的工资数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/828d034e689e24a3c43780fb57e20abc.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/0*bNjpPJMMD8KdOzRv.png"/></div></figure><p id="52f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望添加一个列，其中包含与当前行相对应的工作角色(数据科学家、数据分析师、数据工程师)中所有员工的总工资。我们希望输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b7f6798d2c9dc271e8c8db20177a49b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*1QRCnn5i2JJTsm69hdqDMw.png"/></div></figure><p id="377b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你会使用自连接得到上面的输出吗？是不是最优的方式？</p><p id="52ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不，自连接不是获得该输出的最佳解决方案，相反，我们应该使用窗口函数来获得所需的结果(如下所示)。</p><p id="2bec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nd">不好练</em> </strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="83d3" class="mm lv it nn b gy nr ns l nt nu">## Using Joins <br/>select a.EMPID, a.NAME, a.JOB, b.TOTAL_JOB<br/>FROM employee_table a <br/>INNER JOIN<br/>(select EMPID, NAME, sum(SALARY) as TOTAL_JOB<br/>FROM employee_table<br/>GROUP BY EMPID, NAME) b<br/>on a.EMPID = b.EMPID<br/>and a.NAME = b.NAME</span></pre><p id="3d36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nd">善练</em> </strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="0270" class="mm lv it nn b gy nr ns l nt nu">## Using the window function <br/>select EMPID, NAME, JOB, SALARY, <br/><strong class="nn iu">sum(SALARY) over() as TOTAL<br/></strong>FROM<br/>employee_table</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/3a4d4218d4937c7a6b77639c41cc7a54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v4wk4OsB3QVaEstk.png"/></div></div></figure><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/fundato-sql-window-functions-part-1-ab61df519973"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">SQL窗口函数简介:第1部分</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">为数据科学面试做好准备</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div><h2 id="6f37" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">4.没有过滤所需的列</h2><p id="94f6" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在处理具有数百万行的大型数据集时，数据集中的列数超过所需的数量可能会导致运行时间增加。因此，建议在读取数据集时只选择所需的列。</p><p id="6f56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nd">不好的做法</em> </strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="3972" class="mm lv it nn b gy nr ns l nt nu">### Selecting all the columns #######<br/>select a.*, b.* <br/>from <br/>member_data as a<br/>join <br/>claims_data as b<br/>on a.member_id = b.member_id</span></pre><p id="75d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nd">好的做法</em> </strong></p><pre class="kj kk kl km gt nm nn no np aw nq bi"><span id="d504" class="mm lv it nn b gy nr ns l nt nu">### Selecting the required columns <br/>select a.member_id, a.age,<br/>a.address, b.claim_id<br/>from <br/>member_data as a<br/>join <br/>claims_data as b<br/>on a.member_id = b.member_id</span></pre><h2 id="55eb" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">5.每次查询后不进行质量检查</h2><p id="a902" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">质量检查对于及时发现错误并确保我们交付正确的输出非常重要。很多时候，我们跳过这一步，在分析的后期发现最终结果不正确，因此我们必须进行大量的回溯来找到错误的根源，然后重新运行我们的查询。这导致分析的周转时间急剧增加。</p><p id="77d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免上述问题，我们可以按照以下简单步骤对数据集执行质量检查:</p><ol class=""><li id="a33b" class="oq or it la b lb lc le lf lh os ll ot lp ou lt ov ow ox oy bi translated"><strong class="la iu">统计</strong>一个查询的<strong class="la iu">输入行/列</strong>和<strong class="la iu">输出行/列</strong>的数量，并确保得到预期的行/列数量。</li><li id="09cf" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><strong class="la iu">检查汇总统计数据</strong>(独特值、百分位数等。)<strong class="la iu"> </strong>在被操纵的柱子上。这将确保您在列中获得预期的值。</li><li id="af76" class="oq or it la b lb oz le pa lh pb ll pc lp pd lt ov ow ox oy bi translated"><strong class="la iu">检查数据集的前几行</strong>。这就像检查行的样本来推断数据集的正确性。</li></ol><p id="bbf8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在注释中分享您在处理数据时执行的质量检查步骤。</p><h1 id="9ba5" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">摘要</h1><p id="3cc9" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我们研究了一些常见错误，这些错误通过增加分析的周转时间降低了数据科学家的工作效率。</p><p id="b29f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过了解我们的数据(数据级别)、只处理所需的行和列的子集、不使用额外的连接以及对我们的查询执行质量检查来克服这些错误。</p></div><div class="ab cl pe pf hx pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="im in io ip iq"><h2 id="9a39" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">谢谢你</h2><p id="f0bf" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">我希望这个故事对你有用。你可以在收件箱里看到我所有的帖子。 <a class="ae pl" href="https://anmol3015.medium.com/subscribe" rel="noopener"> <strong class="la iu"> <em class="nd">在这里做那个</em> </strong> <em class="nd">！</em> </a></p><p id="7028" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nd">如果你自己喜欢体验媒介，可以考虑通过</em> <a class="ae pl" href="https://anmol3015.medium.com/membership" rel="noopener"> <strong class="la iu"> <em class="nd">注册会员</em> </strong> </a> <em class="nd">来支持我和其他几千名作家。它每个月只需要5美元，它极大地支持了我们，作家，你可以在媒体上看到所有精彩的故事。</em></p><h2 id="d09f" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">你可能喜欢的故事！</h2><div class="ny nz gp gr oa ob"><a rel="noopener follow" target="_blank" href="/sql-coding-best-practices-for-writing-clean-code-a1eca1cccb93"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">编写干净代码的SQL编码最佳实践</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">了解如何使您的SQL代码可解释</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">towardsdatascience.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op ks ob"/></div></div></a></div></div></div>    
</body>
</html>