<html>
<head>
<title>Random Sampling using SciPy and NumPy: Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SciPy和NumPy的随机抽样:第二部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/random-sampling-with-scipy-and-numpy-part-ii-234c2385828a#2022-04-14">https://towardsdatascience.com/random-sampling-with-scipy-and-numpy-part-ii-234c2385828a#2022-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f41cd3a6597b4aa46ff2aecf94bf207d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuGjm6woROpyx68MUo2l0Q.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">照片由<a class="ae jd" href="https://unsplash.com/@alpridephoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">андрейсизов</a>在<a class="ae jd" href="https://unsplash.com/s/photos/algorithm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><div class=""/><div class=""><h2 id="449f" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">奇特的算法，源代码演练和潜在的改进</h2></div><p id="d909" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae jd" rel="noopener" target="_blank" href="/random-sampling-using-scipy-and-numpy-part-i-f3ce8c78812e">在第一部分</a>中，我们讲述了逆变换采样(ITS)的基础知识，并创建了我们自己的ITS纯python实现来从标准正态分布中采样数字。然后，我们比较了我们稍微优化的功能和内置的SciPy功能的速度，发现我们有些欠缺——慢了<code class="fe lr ls lt lu b">40x</code>倍。</p><p id="3439" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这一部分中，我们的目的是通过挖掘SciPy和NumPy代码库的相关部分来解释为什么会出现这种情况，看看这些速度改进在哪里表现出来。总的来说，我们会发现它由以下几个部分组成:</p><ul class=""><li id="b568" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">由于是用Cython或直接用C编写的，所以函数速度更快</li><li id="f75e" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">与我们屡试不爽的逆变换采样相比，更新的采样算法速度更快</li></ul><h2 id="0185" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">我们如何在SciPy中生成正态分布的随机样本？</h2><p id="0e91" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">下面是从标准正态分布生成随机数<code class="fe lr ls lt lu b">1,000,000</code>的代码。</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="nh ni nj nk gt nn lu no np aw nq bi"><span id="414c" class="mj mk jg lu b gy nr ns l nt nu">43.5 ms ± 1.2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="e793" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以函数<code class="fe lr ls lt lu b">rvs</code>在刚刚超过<code class="fe lr ls lt lu b">40ms</code>的时间内生成<code class="fe lr ls lt lu b">1,000,000</code>个样本。为了进行比较，我们使用基于逆变换采样原理的算法在<code class="fe lr ls lt lu b">2.3s</code>中平均实现了这一点。为了理解速度差异，我们将不得不深入到那个<code class="fe lr ls lt lu b">rvs</code>方法中。</p><p id="93e9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，<em class="nv">(一般而言)</em>使用SciPy，逻辑的核心包含在下划线方法中——所以当我们想要查看<code class="fe lr ls lt lu b">rvs</code>时，我们真的想要查看<code class="fe lr ls lt lu b">_rvs</code>的代码。非下划线方法通常在传递给下划线方法之前执行一些参数类型检查或默认设置。</p><p id="80a1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们开始之前，让我们先简要概述一下SciPy在库中组织分发功能的方式。</p><h2 id="c7b7" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">RV _一般和RV _连续</h2><p id="5bc3" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">SciPy发行版是从一个简洁的继承结构中创建的，它具有:</p><ul class=""><li id="4e0b" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated"><code class="fe lr ls lt lu b">rv_generic</code>作为顶层类，提供<code class="fe lr ls lt lu b">get_support</code>和<code class="fe lr ls lt lu b">mean</code>等方法</li><li id="2fae" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated"><code class="fe lr ls lt lu b">rv_continuous</code>和<code class="fe lr ls lt lu b">rv_discrete</code>用更具体的方法继承它</li></ul><p id="c1ed" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以在上面的例子中，我们将我们的正态分布类<code class="fe lr ls lt lu b">snorm</code>初始化为<code class="fe lr ls lt lu b">stats.norm()</code>，这实际上是创建了一个<code class="fe lr ls lt lu b">rv_continuous</code>的实例，它继承了<code class="fe lr ls lt lu b">rv_generic</code>的很多功能。更具体地说，我们实际上创建了一个<code class="fe lr ls lt lu b">rv_frozen</code>实例，它是<code class="fe lr ls lt lu b">rv_continuous</code>的一个版本，但是分布的参数是固定的(例如，平均值和方差)。记住这一点，现在让我们看看<code class="fe lr ls lt lu b">rvs</code>方法的内部。</p><h2 id="69dc" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">房车</h2><p id="fa51" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">当我们在<code class="fe lr ls lt lu b">snorm.dist._rvs</code>上运行<code class="fe lr ls lt lu b">??</code>魔术时，我们看到下面的代码片段:</p><pre class="nh ni nj nk gt nn lu no np aw nq bi"><span id="d6f1" class="mj mk jg lu b gy nr ns l nt nu"># ?? snorm.dist._rvs<br/>def _rvs(self, size=None, random_state=None):<br/>    return random_state.standard_normal(size)</span></pre><p id="f903" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，似乎在我们创建的distribution类中的某个地方，我们已经在某个地方分配了一个<code class="fe lr ls lt lu b">random_state</code>对象，该<code class="fe lr ls lt lu b">random_state</code>对象包含一个方法，该方法可以返回根据标准正态分布分布的数字。</p><p id="4f85" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">原来，吐出这些随机数的</strong> <code class="fe lr ls lt lu b"><strong class="kx jh">random_state</strong></code> <strong class="kx jh">物体其实来自NumPy。</strong>我们通过查看<a class="ae jd" href="https://github.com/scipy/scipy/blob/b5d8bab88af61d61de09641243848df63380a67f/scipy/stats/_distn_infrastructure.py#L627" rel="noopener ugc nofollow" target="_blank"> rv_generic </a>的源代码来了解这一点，它在其<code class="fe lr ls lt lu b">__init__</code>方法中包含对一个名为<a class="ae jd" href="https://github.com/scipy/scipy/blob/e3cd846ef353b10cc66972a5c7718e80948362ac/scipy/_lib/_util.py#L209" rel="noopener ugc nofollow" target="_blank"> check_random_state </a>的SciPy util方法的调用，如果还没有传递种子，该方法将把<code class="fe lr ls lt lu b">random_state</code>设置为<code class="fe lr ls lt lu b">np.random.RandomState</code>的实例。下面是这段代码:</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="1b45" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">交给NumPy</h2><p id="fda0" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">因此，似乎提供如此高速采样的“魔法”实际上存在于NumPy而非SciPy中。这不应该太令人震惊，因为SciPy是故意构建在NumPy之上的，以防止两个库可能提供相同特性的重复和不一致。这在SciPy简介文档的第一行<a class="ae jd" href="https://docs.scipy.org/doc/scipy/tutorial/general.html" rel="noopener ugc nofollow" target="_blank">中有明确说明，这里是</a>:</p><p id="97d9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SciPy是建立在Python的NumPy扩展之上的数学算法和便利函数的集合</p><p id="4939" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要了解这是怎么回事，我们可以看看这里的<code class="fe lr ls lt lu b">np.random.RandomState</code>类<a class="ae jd" href="https://github.com/numpy/numpy/blob/b991d0992a56272531e18613cc26b0ba085459ef/numpy/random/mtrand.pyx#L120" rel="noopener ugc nofollow" target="_blank"/>。从使用中我们可以看出:</p><ul class=""><li id="ec81" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">用<code class="fe lr ls lt lu b">cdef</code>代替<code class="fe lr ls lt lu b">def</code>进行函数声明</li><li id="4228" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">一个<code class="fe lr ls lt lu b">.pyx</code>文件扩展名代替。巴拉圭</li></ul><p id="710b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两者都表明该函数是使用<a class="ae jd" href="https://cython.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> Cython </a>编写的——这是一种非常类似于python的语言，允许以几乎Python的语法编写函数，然后编译成优化的C/C++代码以提高效率。正如他们自己在文档中所说的<a class="ae jd" href="https://cython.readthedocs.io/en/latest/src/quickstart/overview.html" rel="noopener ugc nofollow" target="_blank">:</a></p><p id="e5b1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nv">“源代码被翻译成优化的C/C++代码，并被编译成Python扩展模块。这允许非常快速的程序执行和与外部C库的紧密集成，同时保持Python语言众所周知的高程序员生产率。”</em></p><p id="ddc2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本课程中，我们需要了解两件事来理解采样过程:</p><ul class=""><li id="d193" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">它是如何生成均匀分布的随机数(PRNG)的</li><li id="0461" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">它使用什么算法将这些均匀分布的数字转换成正态分布的数字</li></ul><h2 id="4581" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">PRNG</h2><p id="c7f1" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">正如在第一部分中提到的，生成随机样本需要某种形式的随机性。几乎总是这不是真正的随机，而是由“伪随机数发生器”(PRNG)产生的一系列数字。正如采样算法一样，有多种PRNGs可用，这里使用的具体实现在<code class="fe lr ls lt lu b">np.random.RandomState</code>的 <code class="fe lr ls lt lu b"><a class="ae jd" href="https://github.com/numpy/numpy/blob/b991d0992a56272531e18613cc26b0ba085459ef/numpy/random/mtrand.pyx#L180" rel="noopener ugc nofollow" target="_blank">__init__</a></code> <a class="ae jd" href="https://github.com/numpy/numpy/blob/b991d0992a56272531e18613cc26b0ba085459ef/numpy/random/mtrand.pyx#L180" rel="noopener ugc nofollow" target="_blank">方法</a>中详细介绍:</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2d62" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所示，当该类被初始化时，默认的PRNG被设置为<a class="ae jd" href="https://en.wikipedia.org/wiki/Mersenne_Twister" rel="noopener ugc nofollow" target="_blank">梅森扭结</a>算法的一个实现——如此命名是因为它的周期长度为<a class="ae jd" href="https://en.wikipedia.org/wiki/Mersenne_prime" rel="noopener ugc nofollow" target="_blank">梅森素数</a>(它在开始重复自身之前可以生成的随机数的数量)。</p><h2 id="4aab" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">取样过程</h2><p id="225b" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">沿着类<code class="fe lr ls lt lu b">np.random.RandomState</code>的代码往下，我们看到<a class="ae jd" href="https://github.com/numpy/numpy/blob/b991d0992a56272531e18613cc26b0ba085459ef/numpy/random/mtrand.pyx#L1344" rel="noopener ugc nofollow" target="_blank"/><code class="fe lr ls lt lu b"><a class="ae jd" href="https://github.com/numpy/numpy/blob/b991d0992a56272531e18613cc26b0ba085459ef/numpy/random/mtrand.pyx#L1344" rel="noopener ugc nofollow" target="_blank">standard_normal</a></code>的定义调用了一个叫做<code class="fe lr ls lt lu b">legacy_gauss</code>的东西。<code class="fe lr ls lt lu b">legacy_gauss</code>函数的C代码在这里是<a class="ae jd" href="https://github.com/numpy/numpy/blob/b991d0992a56272531e18613cc26b0ba085459ef/numpy/random/src/legacy/legacy-distributions.c#L18" rel="noopener ugc nofollow" target="_blank"/>，为了便于查看，我们将在这里显示它:</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0d06" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如在Wiki上的<a class="ae jd" href="https://en.wikipedia.org/wiki/Marsaglia_polar_method#Implementation" rel="noopener ugc nofollow" target="_blank">实现部分</a>中所看到的，这正是<a class="ae jd" href="https://en.wikipedia.org/wiki/Marsaglia_polar_method#Implementation" rel="noopener ugc nofollow" target="_blank"> Marsaglia极坐标方法</a>的C实现，用于在给定一串均匀分布的输入数的情况下，从正态分布中生成随机样本。</p><h2 id="a98f" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">概述</h2><p id="1a78" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">我们已经经历了很多，所以有必要回顾一下，确保一切都非常清楚。我们已经从:</p><ul class=""><li id="bf0d" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">一个用python写的名为<code class="fe lr ls lt lu b">_rvs</code>的函数启动</li><li id="11ac" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">一个NumPy类<code class="fe lr ls lt lu b">np.random.RandomState</code>，用Cython写的，它</li><li id="3515" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">使用Mersenne Twister算法生成均匀分布的数字，然后</li><li id="46b5" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">将这些数字输入用C编写的函数<code class="fe lr ls lt lu b">legacy_gauss</code>，该函数使用Marsaglia极坐标法生成正态分布的样本</li></ul><p id="2c4d" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以上强调了构建SciPy和NumPy的聪明人为了生成高效代码所付出的努力。在基础设施的更深层尽可能接近C语言(为了速度)之前，我们有一个可以被用户(比如你和我)调用的顶层，它是用python编写的(为了python的“程序员生产力”)。</p><h2 id="43f7" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">为什么SciPy调用NumPy函数被视为“遗留”？</h2><p id="5463" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">因为采样是数学/计算机科学的一个分支，仍然在向前发展。与其他领域不同，在这些领域中，某些原则在几个世纪前就已达成一致，并且从那以后没有发生变化，有效地对各种分布进行采样仍然有新的发展。随着新的开发得到测试，我们希望更新我们的默认流程，以纳入这些进步。</p><p id="bc75" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这正是2019年7月NumPy 1.17.0所发生的事情，当时<a class="ae jd" href="https://numpy.org/devdocs/release/1.17.0-notes.html" rel="noopener ugc nofollow" target="_blank">他们引入了2个影响采样的新功能</a>:</p><ul class=""><li id="ed24" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">一种新的默认伪随机数发生器(PRNG)的实现:<a class="ae jd" href="https://www.pcg-random.org/index.html" rel="noopener ugc nofollow" target="_blank">麦丽莎·奥尼尔的PCG算法家族</a></li><li id="a2ef" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">一个新的采样过程的实现:金字形神塔算法</li></ul><p id="f715" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，由于对prng向后兼容性的期望，他们没有创建突破性的改变，而是引入了一种新的方式来启动prng，并将旧的方式切换到引用“遗留”代码。</p><p id="9107" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里提到的向后兼容性是指在给定相同种子的情况下，希望PRNG函数生成相同的随机数字符串。两种不同的算法不会产生相同的随机数，即使它们被给予相同的种子。这种再现性对于测试尤其重要。</p><p id="ded5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看来SciPy还没有升级来利用这些新的发展。</p><h2 id="2665" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">我们能打败西皮吗？</h2><p id="cbc5" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">鉴于我们现在所知道的关于在SciPy中如何实现正态分布抽样的知识，我们能战胜它吗？</p><p id="5bff" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">答案是肯定的——通过利用NumPy为我们实现的最新采样技术。下面是采样的一个实现，其中我们:</p><ul class=""><li id="03d6" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">使用最新的PRNG</li><li id="c41c" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">使用新的金字形神塔算法将这些数字转换成正态分布的样本</li></ul><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="nl nm l"/></div></figure><pre class="nh ni nj nk gt nn lu no np aw nq bi"><span id="801e" class="mj mk jg lu b gy nr ns l nt nu"># test scipy speed<br/>%timeit snorm.rvs(size=n)</span><span id="88df" class="mj mk jg lu b gy nw ns l nt nu">51 ms ± 5.08 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span><span id="a390" class="mj mk jg lu b gy nw ns l nt nu"># test numpy speed<br/>%timeit nnorm.normal(size=n)</span><span id="16d8" class="mj mk jg lu b gy nw ns l nt nu">24.3 ms ± 1.84 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)</span></pre><p id="cc65" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以看起来我们现在已经和SciPy一样快了NumPy在他们的发布中强调了这是预计的2-10倍。</p><h2 id="8831" class="mj mk jg bd ml mm mn dn mo mp mq dp mr le ms mt mu li mv mw mx lm my mz na nb bi translated">结论:这个有多大用处？</h2><p id="12b7" class="pw-post-body-paragraph kv kw jg kx b ky nc kh la lb nd kk ld le ne lg lh li nf lk ll lm ng lo lp lq ij bi translated">说到实现定制分布抽样:非常有用。我们现在完全理解了追求SciPy式采样速度的决定，并且可以适当地实现定制分布采样。我们可以:</p><ul class=""><li id="c865" class="lv lw jg kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">坚持使用第一部分中的纯python逆采样转换实现(毕竟，在大多数上下文中，<code class="fe lr ls lt lu b">2s</code>对于<code class="fe lr ls lt lu b">1,000,000</code>的示例来说并不坏)</li><li id="f90f" class="lv lw jg kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">编写我们自己的采样程序——最好用C或Cython编写这个采样程序——这不是一个小问题</li></ul><p id="80d7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下一部分中，我们将研究如何做到这一点——在SciPy基础结构中实现一个高效的定制分布采样函数。这给了我们两全其美的东西——既可以灵活地实现我们选择的精确分布，又可以利用我们从<code class="fe lr ls lt lu b">rv_generic</code>和<code class="fe lr ls lt lu b">rv_continuous</code> SciPy类继承的高效且编写良好的方法。</p></div></div>    
</body>
</html>