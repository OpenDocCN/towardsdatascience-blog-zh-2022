<html>
<head>
<title>Identifying Goalkeepers’ Build-Up Style Using Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于机器学习的守门员组合风格识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/identifying-goalkeepers-build-up-style-using-machine-learning-a39348b0cfff#2022-09-19">https://towardsdatascience.com/identifying-goalkeepers-build-up-style-using-machine-learning-a39348b0cfff#2022-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ba9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于足球分析的聚类算法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07bd33ed6535eb83ce84fcae78c258c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXG7CkXQNYX3s7PLPdX-3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Á·阿尔瓦罗·门多萨在<a class="ae ky" href="https://unsplash.com/s/photos/goalkeeper?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="3b48" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="4252" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">准备阶段是一个球队控球并试图向对手射门得分的阶段。</p><p id="757d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">守门员是防守队员的最后一人，但也是组织进攻的第一人。</p><p id="ecae" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">了解守门员的构建方案是了解球队踢球风格的最重要的信息之一。</p><p id="f097" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">机器学习算法可以在分离守门员制定的不同构建方案中发挥作用。</p><p id="bf2f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我将向您展示如何使用聚类算法将守门员的传球分成几个聚类。事不宜迟，我们开始吧！</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="6b2d" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">履行</h1><h2 id="5d05" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">数据源</h2><p id="0e8f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于数据源，我们将使用来自StatsBomb的开放数据(经许可)。我们将从2020年欧锦赛开始分析守门员的组合模式。你可以在这里 通过GitHub库<a class="ae ky" href="https://github.com/statsbomb/open-data" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">阅读关于数据集的细节。</strong></a></p><h2 id="8e40" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">行动（或活动、袭击）计划</h2><p id="8e9a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了生成守门员的累积传球集群，我们必须在可视化之前准备好数据。这些步骤是:</p><ul class=""><li id="d079" class="nq nr it lt b lu mn lx mo ma ns me nt mi nu mm nv nw nx ny bi translated">加载数据，</li><li id="2c9c" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">准备数据，</li><li id="ebf6" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">使用K-Means算法对数据进行聚类，</li><li id="e303" class="nq nr it lt b lu nz lx oa ma ob me oc mi od mm nv nw nx ny bi translated">想象每个守门员的集群。</li></ul><h2 id="761c" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">加载数据</h2><p id="1df2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为有来自不同比赛的大量数据，我们需要检索2020年欧锦赛的比赛、赛季和比赛标识符。</p><p id="ee22" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了检索比赛和赛季id，我们可以查看competition.json文件。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cce4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从上面可以看到，2020欧洲杯对应的比赛和赛季id分别是55和43。接下来，我们将使用这些id检索匹配id。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3e0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">获得完整的匹配id后，下一步是将数据组合成一个数据帧。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="0fad" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">准备数据</h2><p id="6bf4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在检索完整的匹配数据之后，我们需要准备数据，以便它可以用于建模过程。首先，我们将过滤包含守门员信息的数据。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7562" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们过滤描述守门员传球的数据。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d755" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们选择列来简化建模和分析过程。这些列是球员和球队的名字，传球位置的起点和终点，传球的距离，以及传球的角度。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9b3a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为位置信息使用列表格式，所以我们需要提取这些值，并将它们放在单独的列中。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="6e71" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">聚集数据</h2><p id="5aff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用一种称为K-Means算法的聚类算法来将过程分成几个组。</p><p id="cc1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简而言之，K-Means会初始化几个质心，每个数据都属于一个基于最近距离的质心。重复该过程，直到算法捕捉到最佳误差值。</p><p id="ca91" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是在应用该算法之前，我们需要为每次传递提取位置、距离和角度等列。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0111" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们需要选择最佳的聚类数。我们可以用肘法来确定最佳聚类数。下面是查找号码的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5d6b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了推断结果，我们需要查看一个聚类点，该点形成一条肘形线。还有，我们需要看看在肘形线之后误差是否没有显著减少。</p><p id="ba2e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您从上面所看到的，值6是集群的最佳数量。在该值之后，误差不会显著减小。因此，我们将使用它来分隔每个守门员的传球。</p><p id="4cef" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们通过使用最佳数量的集群并将标签放入数据帧来再次进行建模过程。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="b656" class="ne la it bd lb nf ng dn lf nh ni dp lj ma nj nk ll me nl nm ln mi nn no lp np bi translated">想象结果</h2><p id="fa35" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们有了集群的标签。最后一步是可视化这些集群，并为每个守门员划分它们。</p><p id="d720" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了使见解更有意义，我们只根据通过次数取前3个聚类。</p><p id="736b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将使用mplsoccer库来可视化图表。下面是实现这一点的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a534" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们能从这个可视化中推断出什么？我们可以看到每支球队都有不同的风格。</p><p id="a07a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以看到像蒂博·库尔图瓦、吉安路易吉·多纳鲁马和曼努埃尔·诺伊尔这样的守门员把球传给他们的后卫或中场。</p><p id="53ca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">马尔滕·斯特克伦博格、乌古坎·恰基尔和罗宾·奥尔森演奏了不同的风格。他们试图将球传给对方半场。</p><p id="a830" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了这些信息，球队将知道在哪个位置进行预测，这样球员就可以阻止对手控球。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="1dd6" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">结束语</h1><p id="d7bc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">干得好！您已经学习了如何使用聚类算法来生成守门员的集结模式。我希望您可以将该概念应用于不同的数据或应用程序。</p><p id="8768" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你对我的文章感兴趣，你可以在Medium上关注我，看更多这样的文章。谢谢你看我的文章！</p></div></div>    
</body>
</html>