<html>
<head>
<title>Sending HL7 v2 Messages with Hasura, Hapi and Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hasura、哈比神和无服务器发送HL7 v2消息</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/sending-hl7-v2-messages-with-hasura-hapi-and-serverless-9cd1630876a4#2022-05-18">https://towardsdatascience.com/sending-hl7-v2-messages-with-hasura-hapi-and-serverless-9cd1630876a4#2022-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2fc03def2c35f77ec75da076031e1860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymxuizMWDV9lZ_KbaK6UZA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="9b6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">健康级别7 (HL7)版本2于80年代末开发，多年来一直是世界上最流行的数据交换标准。该标准最近被HL7快速医疗保健互操作性资源(FHIR)取代，但采用率比预期的<a class="ae la" href="https://venturebeat.com/2021/04/19/health-care-api-adoption-is-stymied-by-security-concerns-and-skills-gap/" rel="noopener ugc nofollow" target="_blank"/>要<a class="ae la" href="https://ehrintelligence.com/news/api-adoption-slow-widespread-fhir-uptake-expected-by-2024" rel="noopener ugc nofollow" target="_blank"/><a class="ae la" href="https://www.fedscoop.com/fhir-standard-adoption-stagnant-onc/" rel="noopener ugc nofollow" target="_blank">慢，所以即使在2022年，使用HL7 v2仍然令人惊讶地普遍。</a></p><p id="c4c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我将概述一个典型用例的解决方案:假设我们有一个传统的电子病历(EMR)系统，在一个诊所中有一个支持关系数据库，每当一个新病人注册时，它需要向另一个机构发送一条消息(例如ADT_A04)。下面的步骤可以作为演示在开发机器上运行—不需要云平台。虽然这篇文章关注的是HL7 v2，但我们目前正在研究为Hasura设置的GraphQL &amp; REST FHIR，所以如果你对此感兴趣，请去投票支持我们的<a class="ae la" href="https://github.com/whitebrick/hasura-fhir/discussions/1" rel="noopener ugc nofollow" target="_blank"> GitHub讨论</a>。</p><p id="0efd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">解决这个问题最常见的方法是使用一个名为<em class="lb">happy Connect</em>的集成工具，这是一个很好的基于Java的服务器应用程序，最初是在15年前开发的，主要面向医疗保健行业。尽管happy的核心是开源的，但是像FHIR支持这样的扩展需要订阅，截止到本文撰写时，订阅费用大约为每年2万美元。</p><p id="09b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">相比之下，Hasura虽然才出现了几年，但已经被从沃尔玛到空中客车等各行各业的组织所使用，并支持现代微服务架构和设计模式。Hasura是完全开源的(所有特性都可以免费获得)，用Haskell开发，可以作为Docker镜像快速部署。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="4eed" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">为什么是哈苏拉？</h1><p id="3b2c" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">选择Hasura而不是happy Connect的几个原因包括:</p><ul class=""><li id="2eaa" class="mm mn iq ke b kf kg kj kk kn mo kr mp kv mq kz mr ms mt mu bi translated"><strong class="ke ir">instant API</strong>:如果您正在通过支持RDBMS将HL7 v2添加到传统EMR，这可能只是许多(当前或未来)集成中的一个，因此在您现有的数据库上免费获得一个Instant API肯定会派上用场。此外，为了支持这一特性，Hasura <em class="lb">跟踪</em>DB模式，该模式具有自动生成表列映射的额外好处，便于分配给HL7消息模板字段，而不必手动编写SQL查询。</li><li id="52f8" class="mm mn iq ke b kf mv kj mw kn mx kr my kv mz kz mr ms mt mu bi translated"><strong class="ke ir"> GraphQL </strong>:如果你还在考虑REST和GraphQL，那么你就错过了联邦、模式拼接和远程连接的大画面，我鼓励你去看看由Uri Goldshtein 为Firely DevDays做的<a class="ae la" href="https://www.youtube.com/watch?v=i3Sj8JTp4MU" rel="noopener ugc nofollow" target="_blank">演讲。GraphQL还支持现代客户端框架(如Gatsby、Next.js、Gridsome ),可以快速开发定制屏幕和仪表盘(在医疗保健领域无处不在),无需开发定制端点即可读取/写入所需数据。</a></li><li id="e689" class="mm mn iq ke b kf mv kj mw kn mx kr my kv mz kz mr ms mt mu bi translated"><strong class="ke ir">同步事件:</strong>Hasura在后台创建并管理主机数据库中的触发器，以便同步触发相应的动作。另一方面，joyful的方法是定期轮询数据库，这种方法效率不高，并且与事件驱动的体系结构相反。</li><li id="7e06" class="mm mn iq ke b kf mv kj mw kn mx kr my kv mz kz mr ms mt mu bi translated"><strong class="ke ir">管理控制台:</strong>这种类型的集成可能是一个复杂的过程，因此任何有助于调试的东西通常都是必不可少的。joyful Connect确实有一个Java GUI，但是与Hasura相比，它缺少了一个对这个场景特别有用的特性:一个可视化的数据库浏览器。Hasura基于web的管理控制台允许我们在不离开web浏览器的情况下，可视化我们的DB以及完成对行、表和关系的CRUD操作。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="9ca7" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">演示概述</h1><p id="937f" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated"><em class="lb">要求:Git、Docker、Node.js、NPM、Java ≥8 </em></p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/71a9c3a07180e753d69e70fd1fe75982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0pwZMq5P_rCyneoS9_VwQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">图片由作者提供，徽标经许可使用</p></figure><p id="4b3d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个解决方案采用微服务方法，从Hasura连接到现有的EMR DB开始，并监视Patients表中的新插入。当一个新病人被注册时，Hasura将插入的数据转换成JSON格式的模板HL7消息，并将其作为HTTP请求发送给运行在无服务器框架上的<a class="ae la" href="https://github.com/hapifhir/hapi-hl7v2" rel="noopener ugc nofollow" target="_blank"> Java HAPI </a>服务(在本演示中使用无服务器离线)。Java HAPI是HL7处理的黄金标准——该服务解析JSON HL7消息，将其转换为ER7格式(管道分隔),并将其作为HTTP请求转发给HTTP-MLLP网关。网关是一个简单的Node.js应用程序，它接收ER7格式的HTTP请求体，并通过MLLP将其发送到最终目的地，接收ACK响应并将其返回给Java HAPI服务，该服务再将响应返回给Hasura。理想情况下，MLLP网关也将作为无服务器功能运行，但不幸的是，AWS API网关和应用程序负载平衡器目前只允许基于HTTP的调用。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="7184" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Postgres和Hasura入门</h1><p id="9b1f" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">Hasura支持Postgres、MS SQL、Citus和BigQuery，并且刚刚发布了MySQL的早期版本。在这个演示中，我们将使用Postgres和来自<a class="ae la" href="https://www.open-emr.org/" rel="noopener ugc nofollow" target="_blank"> OpenEMR </a>的稍微重构的<em class="lb"> patient_data </em>表。</p><p id="3bae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">按照下面的命令进行设置。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f8a7" class="nk lk iq ng b gy nl nm l nn no">$ git clone <a class="ae la" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:whitebrick/hl7v2-hasura-hapi-serverless.git<br/>$ cd hl7v2-hasura-hapi-serverless<br/>$ psql</span><span id="f39a" class="nk lk iq ng b gy np nm l nn no"># Create a new user, DB and add the pgcrypto extension<br/>postgres=# CREATE USER myemrusr WITH password 'myemrpwd';<br/>postgres=# CREATE DATABASE myemr OWNED BY myemrusr;<br/>postgres=# CREATE DATABASE myemr WITH OWNER = myemrusr;<br/>postgres=# \c myemr<br/>postgres=# CREATE EXTENSION pgcrypto;<br/>postgres=# \q</span><span id="e0e2" class="nk lk iq ng b gy np nm l nn no"># Test new user and DB and load data<br/>$ psql -U myemrusr myemr<br/>myemr=&gt; \i ./sql/openemr_patient_data_table_postgres.sql<br/>myemr=&gt; \i ./sql/openemr_patient_data_rows_postgres.sql</span></pre><p id="2524" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦我们设置好了<code class="fe nq nr ns ng b">patient_data</code>表，我们就可以从Docker启动Hasura，并配置它使用我们的新数据库，如下所示(注意，数据库主机是用于Mac的，参见Linux或Windows的<a class="ae la" href="https://hasura.io/docs/latest/graphql/core/guides/docker-networking/" rel="noopener ugc nofollow" target="_blank">指南</a>)。Hasura在DB中创建了一个新的模式<code class="fe nq nr ns ng b">hdb_catalog</code>来保存所有的元数据，这样它就不会接触到我们在<em class="lb"> public </em>模式中的数据，除非我们告诉它这样做。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5552" class="nk lk iq ng b gy nl nm l nn no"># Edit as required<br/>$ vi ./hasura_docker_run.bash</span><span id="a1a5" class="nk lk iq ng b gy np nm l nn no">docker run -d -p 8080:8080 \<br/>-e HASURA_GRAPHQL_DATABASE_URL= postgres://myemrusr:myemrpwd@host.docker.internal:5432/myemr \<br/>-e HASURA_GRAPHQL_ENABLE_CONSOLE=true \<br/>-e HASURA_GRAPHQL_DEV_MODE=true \<br/>-e HASURA_GRAPHQL_ADMIN_SECRET=admin \<br/>hasura/graphql-engine:latest</span><span id="f4d6" class="nk lk iq ng b gy np nm l nn no">$ bash ./hasura_docker_run.bash</span></pre><p id="8756" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在转到<a class="ae la" href="http://localhost:8080/console" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>，当提示输入管理员密码时，输入上面的值(本例中为“admin”)。一旦登录，我们需要做的第一件事就是<em class="lb">跟踪</em>T2表，这样Hasura就可以分析和监控它。点击<em class="lb">数据</em>导航选项卡，点击<code class="fe nq nr ns ng b">patient_data</code>工作台旁边的<em class="lb"> e轨迹</em>按钮。一旦被跟踪，我们现在可以从上面描述的方便的管理控制台可视化和管理数据库。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/79cc04de94c500ab884e429a7a9dfa0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PngyuZTKX1evOOTm8jKh0w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="0ba8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，Hasura理解了我们的表，这是使用即时API有多简单的快速示例，如果我们单击<em class="lb"> API </em>选项卡，我们可以简单地选择左侧的几个复选框，一个GraphQL查询就写在我们眼前——包括语法突出显示、代码完成和错误检查。然后，我们可以点击播放按钮来查看我们的查询结果。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/a7d936793e5abfc3a96842ec2fb30068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8aH9m_CPTWcDMgpvICzvg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="fdc8" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">无服务器运行HAPI</h1><p id="29b8" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">我们将离开Hasura一会儿，通过安装<a class="ae la" href="https://www.serverless.com/framework/docs/getting-started" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>并使用下面的命令构建和测试<a class="ae la" href="https://github.com/whitebrick/hapi-serverless" rel="noopener ugc nofollow" target="_blank">hapi-无服务器</a>来运行我们的HAPI微服务。<a class="ae la" href="https://github.com/dherault/serverless-offline" rel="noopener ugc nofollow" target="_blank">无服务器离线</a>插件允许我们在本地运行lambda，就像在云中一样，方法是在幕后使用docker，这就是为什么我们要提取<code class="fe nq nr ns ng b">lambda:java8</code>图像。</p><p id="ac4a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:由于无服务器离线使用Docker，初始请求可能需要一分钟左右的时间来处理。</strong></p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c017" class="nk lk iq ng b gy nl nm l nn no"># Build<br/>$ git clone <a class="ae la" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:whitebrick/hapi-serverless.git<br/>$ cd hapi-serverless<br/>$ npm install<br/>$ mvn package<br/>$ docker pull lambci/lambda:java8</span><span id="cdbc" class="nk lk iq ng b gy np nm l nn no"># Start<br/>$ npm start<br/>...<br/>Server ready: <a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span><span id="03b1" class="nk lk iq ng b gy np nm l nn no"># Test<br/>$ cd test/functional<br/>$ bash ./test_parsing.bash<br/>$ bash ./test_forwarding.bash</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="1593" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">从Hasura创建HL7 v2消息</h1><p id="80da" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">下一步是获取模板消息。尽管我们可以从头开始构建消息，但通常最好的做法是向消费者索要一个模板，这样任何与标准不符的地方都会被考虑在内。对于这个例子，我在谷歌上搜索ADT_04样本，北达科他州卫生部<a class="ae la" href="http://ndhealth.gov/disease/SS/Docs/NDImplementationGuide_v2.pdf" rel="noopener ugc nofollow" target="_blank">消息指南</a>首先出现。我从指南中复制了ER7格式的示例消息，并将其粘贴到文件<code class="fe nq nr ns ng b">./hl7/NDDH_ADT_A04.er7</code>中，然后将其发布到HAPI无服务器服务器，以获得<code class="fe nq nr ns ng b">./hl7/NDDH_ADT_A04.json</code>中的JSON表示。</p><p id="35e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在回到Hasura，我们将点击<em class="lb"> Events </em>选项卡，创建一个名为<code class="fe nq nr ns ng b">HL7-Send_ADT</code>的新事件，并将其附加到<code class="fe nq nr ns ng b">public</code>模式中的<code class="fe nq nr ns ng b">patient_data</code>表。我们只想触发新的<code class="fe nq nr ns ng b">Insert</code>操作，我们将从上面放入本地HAPI无服务器URL，但针对Docker网络进行了调整(<code class="fe nq nr ns ng b"><a class="ae la" href="http://host.docker.internal:3000/dev" rel="noopener ugc nofollow" target="_blank">http://host.docker.internal:3000/dev</a></code>这是针对Mac的，参见<a class="ae la" href="https://hasura.io/docs/latest/graphql/core/guides/docker-networking/" rel="noopener ugc nofollow" target="_blank">指南</a>针对Linux或Windows)。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/2ebbab3ea2a2c92fec7d686662ed2180.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHS8YhYULWDvcAuMTZwkSA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="30e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还想将超时时间增加到<code class="fe nq nr ns ng b">120</code>秒，以便让我们的HAPI无服务器Docker映像有足够的时间启动，将请求方法设置为<code class="fe nq nr ns ng b">POST</code>，将<code class="fe nq nr ns ng b">Content-Type</code>头设置为<code class="fe nq nr ns ng b">application/json</code>。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/73a558b7b74e6847ac9cd596ed176594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJfb4nT1alzleTTJG1RBOQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="6882" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来，我们要单击<em class="lb">添加有效负载转换</em>，在这里我们可以将插入的DB值映射到HL7 JSON模板。因为Hasura已经知道了我们的表，所以它可以自动创建预期的插入输入。然后我们粘贴来自<code class="fe nq nr ns ng b">./hl7/NDDH_ADT_A04.json</code>的模板，并开始将值映射到我们的列——对于这个演示，我们将只映射名字、姓氏和中间名。正如我们在下面看到的，transform editor还提供了语法突出显示、代码完成和验证，以及一个示例预览(一旦代码完成/有效就会显示)。使用Hasura自己的<a class="ae la" href="https://github.com/hasura/kriti-lang" rel="noopener ugc nofollow" target="_blank"> Kriti Lang </a>将<code class="fe nq nr ns ng b">{{$body.event.data.new.*}}</code>路径映射到输入的JSON结构，这看起来很熟悉，是受Go的模板语言的启发。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/2fbc7f8630c1e1648f3dd892c16f680d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgtCxI3FwUWmZoekmhWvAw.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="f75c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后点击页面最底部的<em class="lb">保存</em>按钮，现在让我们测试一下。点击<em class="lb">数据</em>导航选项卡上的返回，选择<code class="fe nq nr ns ng b">patient_data</code>表，然后选择<em class="lb">插入行</em>菜单选项卡，然后输入名称值(见下文)并点击<em class="lb">保存</em>按钮。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/ae10478630af8640f40f537b0ef4cc64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CwWDGIHV5nNxmZ8oG6pLoQ.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="922b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们的hapi-serverless仍然在运行，并且我们有正确的Docker网络URL，我们现在应该在终端日志上看到一个点击。如果我们单击返回到<em class="lb">事件</em>导航选项卡，选择<code class="fe nq nr ns ng b">HL7-Send_ADT</code>事件，然后选择<em class="lb">未决事件</em>子选项卡，我们应该会看到一个新事件在等待，因为我们的HAPI无服务器需要一些时间来启动和响应。最终，该事件将被移动到<em class="lb"> Processed Events </em>选项卡，并允许我们查看请求和响应，在那里我们可以看到我们的ER7转换。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/70507183c45377b3ef4587e91aa1f6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvUiHkU8yMvimc5Czd2kVA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="6cb2" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">HTTP到MLLP</h1><p id="5762" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">不幸的是，HTTP在80年代末不像在90年代末那样普及，所以我们只能用MLLP，但至少它仍然基于TCP/IP。为了通过MLLP转发ER7消息，我们使用Express和<a class="ae la" href="https://github.com/amida-tech/mllp" rel="noopener ugc nofollow" target="_blank"> mllp-node </a>包组装了一个非常<a class="ae la" href="https://github.com/whitebrick/http-mllp-node" rel="noopener ugc nofollow" target="_blank">基本的网关</a>在Node上运行。网关寻找一个头部，例如<code class="fe nq nr ns ng b">Forward-To: mllp://ack.whitebrick.com:2575</code>，并使用mllp-node发送带有相应控制字符的主体，然后返回一个HTTP响应。如果您有自己的端点来测试接收ACK消息，您可以在<code class="fe nq nr ns ng b">Forward-To</code>头中使用它，否则欢迎您使用我们上面的Apache Camel测试端点——详情<a class="ae la" href="https://hl7v2-test.whitebrick.com/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e379" class="nk lk iq ng b gy nl nm l nn no"># Build<br/>$ git clone <a class="ae la" href="mailto:git@github.com" rel="noopener ugc nofollow" target="_blank">git@github.com</a>:whitebrick/http-mllp-node.git<br/>$ cd <!-- -->http-mllp-node<br/>$ npm install<br/><br/># Start<br/>$ node gateway.js<br/>...<br/>HTTP server listening on port 3030</span><span id="3090" class="nk lk iq ng b gy np nm l nn no"># Test<br/>$ cd test/gateway-functional<br/>$ bash ./functional.bah</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="0f0a" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">从Hasura发送HL7 v2消息</h1><p id="7785" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">既然我们已经运行了MLLP网关，我们就可以使用HAPI无服务器的转发特性，不仅可以转换来自JSON的消息，还可以通过网关转发ER7数据并接收返回的响应。为了做到这一点，我们只需将下面的标题(根据您自己的Docker网络进行调整)添加到我们的事件配置中。</p><ul class=""><li id="cc1a" class="mm mn iq ke b kf kg kj kk kn mo kr mp kv mq kz mr ms mt mu bi translated"><code class="fe nq nr ns ng b">MLLP-Gateway</code> : <code class="fe nq nr ns ng b"><a class="ae la" href="http://host.docker.internal:3030" rel="noopener ugc nofollow" target="_blank">http://host.docker.internal:3030</a></code></li><li id="44c5" class="mm mn iq ke b kf mv kj mw kn mx kr my kv mz kz mr ms mt mu bi translated"><code class="fe nq nr ns ng b">Forward-To</code> : <code class="fe nq nr ns ng b">mllp://ack.whitebrick.com:2575</code></li></ul><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/c68701e44a2fcce5bbe7be1452077f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4wA45fkLoTzj6cXLxnM1A.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="10e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有了附加的标题，我们可以返回到<em class="lb">数据</em>页面，插入另一条记录来测试完整的发送和响应。如果一切顺利，我们现在应该看到<code class="fe nq nr ns ng b">retEr7</code>和<code class="fe nq nr ns ng b">retJson</code>值以及来自下游MLLP消费者的ACK数据。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/8fb536f5fbed7b652b2fe1ef04e9d1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GsZMcwZNBdD39XRCfsjjhg.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="8dc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样！我们现在有一个完整的端到端解决方案，因此当EMR创建新的患者记录时，Hasura从一个模板构建一个HL7 v2 JSON消息，通过MLLP网关发送它，捕获ACK响应，并在管理控制台中很好地显示结果。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="acb7" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">访问响应数据并发出错误警报</h1><p id="6903" class="pw-post-body-paragraph kc kd iq ke b kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ml kx ky kz ij bi translated">在发送了一些消息后，下一个明显的问题是:如果我想对响应数据做些什么，而不仅仅是在管理控制台中显示它，该怎么办？因为Hasura元数据存储在同一个DB中(但是是独立的模式),所以我们可以创建一个function+触发器，将感兴趣的数据复制到我们自己的表中，然后在新表上设置附加事件。例如，假设当HL7消息有错误响应时，我们希望通过发送电子邮件或Slack消息来发出警报。</p><p id="9781" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们首先返回到<em class="lb">数据</em>导航选项卡，单击左侧的<em class="lb"> SQL </em>菜单，粘贴下面的代码并点击<em class="lb">运行</em>按钮，为我们的错误消息创建一个新表。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="3762" class="nk lk iq ng b gy nl nm l nn no">CREATE table hl7_error_messages(<br/>  id serial PRIMARY KEY NOT NULL,<br/>  created_at timestamp without time zone DEFAULT now(),<br/>  request json,<br/>  response json<br/>)</span></pre><p id="0195" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果我们使用psql查看Hasura表<code class="fe nq nr ns ng b">hdb_catalog.event_log</code>和<code class="fe nq nr ns ng b">hdb_catalog.event_invocation_logs</code>，我们将从管理控制台视图中看到相同的数据。当Hasura运行任何事件(例如发送HL7消息)时，下面的触发器调用<code class="fe nq nr ns ng b">copy_hl7_error_messages</code>函数。然后，该函数检查事件名称是否与<code class="fe nq nr ns ng b">HL7-Send_ADT</code>匹配，并且在将它复制到我们新创建的<code class="fe nq nr ns ng b">hl7_error_messages</code>表之前，状态是否为不成功。额外的一行是取消转义并解析响应JSON，因为它将进入Postgres JSON字段。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c9bf" class="nk lk iq ng b gy nl nm l nn no">CREATE OR REPLACE FUNCTION copy_hl7_error_messages()<br/>RETURNS trigger AS<br/>$$<br/>DECLARE<br/>  event_name text;<br/>  response_json json;<br/>BEGIN<br/>  SELECT trigger_name INTO event_name FROM hdb_catalog.event_log WHERE id = NEW.event_id;<br/>  IF (event_name = 'HL7-Send_ADT') AND (NEW.status != 200 OR NEW.status IS NULL) THEN<br/>    -- unescape JSON<br/>    SELECT cast('{"data":{"message":' || cast(((NEW.response-&gt;'data'-&gt;'message') #&gt;&gt; '{}' )::jsonb as text) || '}}' as json) INTO response_json;<br/>    INSERT INTO hl7_error_messages (request, response)<br/>    VALUES (NEW.request, response_json);<br/>    RETURN NEW;<br/>  ELSE<br/>    RETURN NULL;<br/>  END IF;<br/>END;<br/>$$<br/>LANGUAGE plpgsql;</span><span id="1365" class="nk lk iq ng b gy np nm l nn no">CREATE TRIGGER copy_hl7_error_messages_trigger<br/>AFTER INSERT<br/>ON hdb_catalog.event_invocation_logs<br/>FOR EACH ROW<br/>EXECUTE PROCEDURE copy_hl7_error_messages();</span></pre><p id="8a99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">接下来点击数据库下的<em class="lb">默认</em>菜单链接，然后点击<em class="lb"> hl7_error_messages </em>旁边的<em class="lb">跟踪</em>按钮。现在，让我们通过终止网关节点进程并插入一个新的患者记录来测试这个功能。幸运的话，我们现在应该在<code class="fe nq nr ns ng b">hl7_error_messages</code>表中有一条记录，因为我们没有对消息进行转义，所以我们可以用JSONPath直接从API中查询它(见下文)。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/610629fcae1e85500d8bcf28cdb62910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fX_fHgs1yNNYWaspXSLRvA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">作者图片</p></figure><p id="d66f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然错误响应存在于一个<em class="lb">跟踪的</em>表中，我们可以继续通过Hasura创建任意数量的新事件，遵循我们之前所做的相同步骤，在新记录插入到<code class="fe nq nr ns ng b">hl7_error_messages</code>表<em class="lb">中时触发电子邮件/松弛通知警报挂钩。</em></p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="4bea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望这个演示为您下次使用HL7 v2提供了另一个选择，如果您正在采用微服务方法，我们很想知道如何实现。如果你需要帮助或想要更多关于医疗保健互操作性和集成的阅读，请前往whitebrick.com，不要犹豫。</p></div></div>    
</body>
</html>