<html>
<head>
<title>Making Sense of Text in a Hurry: A Regular Expressions Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速理解文本:正则表达式入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-sense-of-text-in-a-hurry-a-regular-expressions-primer-5250739abebc#2022-03-28">https://towardsdatascience.com/making-sense-of-text-in-a-hurry-a-regular-expressions-primer-5250739abebc#2022-03-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fb19ba947014ec22cb9873524b61fc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RyJppX0gpkKzCGKRpP8Fg.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由丁诺(Pexels.com)拍摄</p></figure><h1 id="d7cb" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">介绍</h1><p id="6890" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">无论您是第一次接触正则表达式，并且有想要理解的文本数据，还是您有研究堆栈溢出问题的经验，希望找到完全相同的用例，而不太理解您正在使用的正则表达式的混乱；当你使用它们来扩展你的经验时，这个介绍将证明是一个有用的基础。</p><p id="8adc" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">今天我们将讨论三个关键功能和三种关键模式。</p><h1 id="7fcb" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">正则表达式的简要说明</h1><p id="ce82" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">正则表达式是匹配文本中模式的有用工具。</p><p id="68b5" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">模式识别对于给定文本串的分类特别有用。例如，假设您有客户的网站数据，但是您想检查给定短语的出现情况；regex 来救援了！</p><h1 id="bad7" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">关键功能</h1><p id="2651" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">我们将使用<code class="fe mg mh mi mj b">re</code>包，并运行以下三个函数:</p><ul class=""><li id="e3d4" class="mk ml it lf b lg mb lk mc lo mm ls mn lw mo ma mp mq mr ms bi translated">重新搜索()</li><li id="dea7" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">重新拆分()</li><li id="c53f" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">re.findall()</li></ul><p id="3392" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">够简单！</p><h1 id="3bf0" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">搜索</h1><h2 id="2478" class="my kg it bd kh mz na dn kl nb nc dp kp lo nd ne kt ls nf ng kx lw nh ni lb nj bi translated">定义</h2><p id="5609" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">搜索允许我们在字符串中搜索给定的模式。如果模式出现在字符串中，函数将返回“匹配对象”,否则返回空值。</p><h2 id="e75d" class="my kg it bd kh mz na dn kl nb nc dp kp lo nd ne kt ls nf ng kx lw nh ni lb nj bi translated">例子</h2><p id="eb8f" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设您想要搜索一个名为 company description 的字符串，以查找包含“tech”的内容。出于示例的目的，让我们假设您将在公司描述中使用单词“tech”来对每个记录进行相应的分类。</p><p id="ad26" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">调用函数，传递模式和字符串。</p><pre class="nk nl nm nn gt no mj np nq aw nr bi"><span id="f3c5" class="my kg it mj b gy ns nt l nu nv">company_description = "selling tech products to retailers"<br/>re.search('tech', company_description)</span></pre><p id="b9c6" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">就这么简单，您有一个直接的方法来检测模式的存在。匹配对象本身将包括模式第一次出现的字符索引。</p><h1 id="f1c3" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">裂开</h1><h2 id="218f" class="my kg it bd kh mz na dn kl nb nc dp kp lo nd ne kt ls nf ng kx lw nh ni lb nj bi translated">定义</h2><p id="aeeb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">Split 允许我们将一个字符串“分割”成一个列表中不同的元素。在 split 中，我们使用正则表达式来指定函数拆分字符串的模式。以下是更多相关信息。</p><h2 id="0d64" class="my kg it bd kh mz na dn kl nb nc dp kp lo nd ne kt ls nf ng kx lw nh ni lb nj bi translated">例子</h2><p id="d70a" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设您希望根据潜在客户当前拥有的技术产品向他们进行营销，并且您甚至拥有这些数据，但不幸的是，每个客户的数据是一个长的连续字符串，用逗号分隔每项技术。</p><p id="3ac3" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">一个简单的解决方案是用逗号(和空格)拆分字符串。</p><pre class="nk nl nm nn gt no mj np nq aw nr bi"><span id="c99f" class="my kg it mj b gy ns nt l nu nv">technologies = 'salesforce, gainsight, marketo, intercom'<br/>re.split(', ', technologies)</span></pre><p id="1478" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">现在，您已经将每项技术分解到列表中它自己的条目中。</p><h1 id="6d15" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">芬达尔</h1><h2 id="c3b9" class="my kg it bd kh mz na dn kl nb nc dp kp lo nd ne kt ls nf ng kx lw nh ni lb nj bi translated">定义</h2><p id="f6fb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">Findall 与 search &amp; match 非常相似。关键区别在于“findall”中的“all”。findall 不只是返回第一次出现的位置，而是返回模式的每次出现。为了便于说明，我们用直接引用的模式来保持事情的简单，但是很快我们将回顾您也可以使用的不同模式。</p><h2 id="b6ad" class="my kg it bd kh mz na dn kl nb nc dp kp lo nd ne kt ls nf ng kx lw nh ni lb nj bi translated">例子</h2><p id="394e" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">假设你正在向电子商务公司销售退货处理产品，你浏览了一些潜在客户的网站，希望看看他们是否提供免费评论；在这种情况下，假设“免费退货”的提及量越大，表明注册该产品的倾向越高。</p><pre class="nk nl nm nn gt no mj np nq aw nr bi"><span id="bbe8" class="my kg it mj b gy ns nt l nu nv">website_text = 'free returns... yada yada yada... free returns... and guess what... free returns'<br/><br/>returns = re.findall('free returns', website_text)</span></pre><h1 id="5478" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">关键模式</h1><p id="5b91" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">现在您的工具箱中有了一些关键函数，让我们通过讨论模式来扩展它们的有用性。</p><p id="e0ff" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在上面的每个例子中，我们明确地定义了我们的模式；我们现在要做的是回顾如何在更复杂的条件下更快地达到目标。</p><p id="7897" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们将回顾以下内容:</p><ul class=""><li id="1a41" class="mk ml it lf b lg mb lk mc lo mm ls mn lw mo ma mp mq mr ms bi translated">数字</li><li id="9f91" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">话</li><li id="dbba" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">间隔</li></ul><h1 id="f85c" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">数字</h1><p id="9f67" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">与前面的例子类似，我们将使用 findall 但在这种情况下，我们将这样做，以找到一个数字的每一次出现。假设我们第一季度的月销售额记录在一个字符串中，我们希望提取这些数字。密切注意我们通过的模式。</p><pre class="nk nl nm nn gt no mj np nq aw nr bi"><span id="06a7" class="my kg it mj b gy ns nt l nu nv">string = 'Jan: 52000, Feb: 7000, Mar: 9100'<br/>print(re.findall(r"\d+", string))</span></pre><p id="7343" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">让我们将这个命令分成不同的部分:</p><ul class=""><li id="0798" class="mk ml it lf b lg mb lk mc lo mm ls mn lw mo ma mp mq mr ms bi translated">向 python 表明我们将使用正则表达式，这有助于 python 不会对你要做的事情感到困惑。</li><li id="cac1" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">我们使用反斜杠<code class="fe mg mh mi mj b">(\)</code>告诉 python 按字面意思处理下一个字符。有些情况下，一个“特殊的”字符告诉 python 做一些事情；在这种情况下，python 知道不要做任何时髦的事情。</li><li id="35e1" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated"><code class="fe mg mh mi mj b">d</code>是我们用来表示我们想要的数字。</li><li id="f982" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">不带+号运行同样的操作会将每个单独的数字视为列表中自己的项目。+表示我们希望将符合我们指定标准的完整单词作为一个单独的项目。</li></ul><h1 id="384a" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">话</h1><p id="5be2" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们再做一次，只是把数字换成单词。我们会说我们想要提取月份值。</p><pre class="nk nl nm nn gt no mj np nq aw nr bi"><span id="3f5a" class="my kg it mj b gy ns nt l nu nv">print(re.findall(r"[A-z]\w+", string))</span></pre><p id="3b4c" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我们看到这里包含了很多相同的东西:<code class="fe mg mh mi mj b">r</code>、反斜杠、+；但是我们现在看到，我们已经包括了<code class="fe mg mh mi mj b">w</code>，而不是 d。<code class="fe mg mh mi mj b">w</code>是任何字符的指示，从技术上讲，它也可以扩展到其他字符，所以我们指定它是谨慎的。</p><p id="2108" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">在<code class="fe mg mh mi mj b">\w+</code>语句之前，我们可以修改我们想要允许的特定字符类型的模式。在这种情况下，我们通过<code class="fe mg mh mi mj b">[A-z]</code>指定包含所有大写和小写字母。</p><h1 id="7ce6" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">间隔</h1><p id="ebfb" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">让我们重温一下之前为<code class="fe mg mh mi mj b">re.split</code>制作的例子。</p><p id="ca00" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">假设我们不想对逗号进行拆分，而是希望根据空格进行拆分。</p><pre class="nk nl nm nn gt no mj np nq aw nr bi"><span id="90c4" class="my kg it mj b gy ns nt l nu nv">print(re.split(r"\s", technologies))</span></pre><p id="ac7b" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">如您所见，考虑到逗号现在是如何被包含在各个项目中的，这真的没有多大用处。如果没有逗号，这将是一个更有用的方法。</p><h1 id="f1d3" class="kf kg it bd kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc bi translated">结论</h1><p id="b9a0" class="pw-post-body-paragraph ld le it lf b lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma im bi translated">你有它！几乎在任何时候，我们已经涵盖了相当多的内容。</p><p id="3d85" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">你学到了:</p><p id="7769" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">3 个关键的正则表达式函数:</p><ul class=""><li id="6c88" class="mk ml it lf b lg mb lk mc lo mm ls mn lw mo ma mp mq mr ms bi translated">重新搜索()</li><li id="d8c0" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">重新拆分()</li><li id="2c57" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">re.findall()</li></ul><p id="1483" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">3 种便捷模式:</p><ul class=""><li id="8929" class="mk ml it lf b lg mb lk mc lo mm ls mn lw mo ma mp mq mr ms bi translated">数字</li><li id="fab7" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">话</li><li id="740f" class="mk ml it lf b lg mt lk mu lo mv ls mw lw mx ma mp mq mr ms bi translated">间隔</li></ul><p id="04ea" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">和一些应该可以帮助你理解 regex 世界的规则。</p><p id="bbbb" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我希望这可以证明是有用的脚手架，您可以使用它来构建您的正则表达式知识和经验。</p><p id="1d04" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">我希望你喜欢这篇文章，并希望它对你的工作有所帮助！请分享什么有用，什么没用！</p><p id="8495" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">请随意查看我在 datasciencelessons.com 的其他帖子</p><p id="5331" class="pw-post-body-paragraph ld le it lf b lg mb li lj lk mc lm ln lo md lq lr ls me lu lv lw mf ly lz ma im bi translated">祝数据科学快乐！</p></div></div>    
</body>
</html>