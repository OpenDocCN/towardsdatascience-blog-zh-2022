<html>
<head>
<title>Vectorization: Must-know Technique to Speed Up Operations 100x Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">矢量化:将运算速度提高100倍的必备技术</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vectorization-must-know-technique-to-speed-up-operations-100x-faster-50b6e89ddd45#2022-05-24">https://towardsdatascience.com/vectorization-must-know-technique-to-speed-up-operations-100x-faster-50b6e89ddd45#2022-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9103" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">任何现代数据科学或机器学习应用程序都需要</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ecff461717448c09f0e93e03ecb1494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HGQKbakRageoKWHp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔伊·凯伯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="2490" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="ef0d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在当前的<a class="ae ky" href="https://en.wikipedia.org/wiki/Data_science" rel="noopener ugc nofollow" target="_blank">数据科学</a>或<a class="ae ky" href="https://en.wikipedia.org/wiki/Machine_learning" rel="noopener ugc nofollow" target="_blank">机器学习</a>应用中，通常会涉及到庞大的数据集和复杂的网络。因此，在处理计算工作量时，代码效率变得非常重要。</p><p id="7fbf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，在经典的<a class="ae ky" href="https://en.wikipedia.org/wiki/Multilayer_perceptron" rel="noopener ugc nofollow" target="_blank">多层感知器</a>(又名<a class="ae ky" href="https://en.wikipedia.org/wiki/Feedforward_neural_network" rel="noopener ugc nofollow" target="_blank">前馈神经网络</a>)中，网络通常包含多个线性层。假设输入层包含64个神经元，而第一个隐藏层包含128个隐藏神经元。然后，为了在给定输入的情况下计算隐藏层的输出，直接的方法是使用由<a class="ae ky" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>库提供的<code class="fe ms mt mu mv b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.dot.html" rel="noopener ugc nofollow" target="_blank">np.dot</a></code>方法:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="ac49" class="na la it mv b gy nb nc l nd ne">import numpy as np</span><span id="5694" class="na la it mv b gy nf nc l nd ne">feat = np.ones(64)<br/>w = np.random.rand(64,128)</span><span id="7add" class="na la it mv b gy nf nc l nd ne">feat.dot(w)</span></pre><p id="f0bd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们想计算执行这个方法的时间，我们可以使用<code class="fe ms mt mu mv b"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">%timeit</a></code>:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="19de" class="na la it mv b gy nb nc l nd ne">%timeit feat.dot(w)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/bccfa31c7d771791625d951d807aab3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7R1i7wajHhli837Yy-HQWg.png"/></div></div></figure><p id="59d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以看到，这种方法平均需要1.4微秒。</p><p id="80c7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，如果我们不使用<code class="fe ms mt mu mv b">np.dot</code>，而是在仍然使用Numpy数组的同时，恢复到传统的for循环，那么您应该这样写:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="660b" class="na la it mv b gy nb nc l nd ne">def loop(feat, w):<br/>    res = np.zeros(128)<br/>    for i in range(w.shape[1]):<br/>        s = 0<br/>        for j in range(len(feat)):<br/>            s += feat[j]*w[j][i]<br/>        res[i] = s<br/>    return res</span><span id="e8d4" class="na la it mv b gy nf nc l nd ne">loop(feat, w)</span><span id="251b" class="na la it mv b gy nf nc l nd ne">%timeit loop(feat, w)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/c8cea921443b06597af05fbf68a42155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-2fzpKUYs3R2YvfvfZWtA.png"/></div></div></figure><p id="bf34" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如你所看到的，像for循环这样直观的东西平均需要4.94毫秒，<strong class="lt iu">比使用之前的方法</strong>慢了3000倍以上。虽然这些都是很小的时间单位，但想象一下，当神经网络非常深入，数据集达到数百万或数十亿时，那么3000倍的差异很可能会产生影响，并决定应用程序的可行性。</p><p id="9887" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ni">顺便提一下，我们可以检查两种方法计算出的结果是否相同(打印前十个元素来验证):</em></p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b78a" class="na la it mv b gy nb nc l nd ne">feat.dot(w)[:10]<br/>## result: array([30.80125191, 34.84418376, 29.5061941 , 33.00162298, 31.77854219,<br/>       31.93457429, 30.25155328, 35.71776325, 35.45861881, 33.58667301])</span><span id="118f" class="na la it mv b gy nf nc l nd ne">loop(feat, w)[:10]<br/>## result: array([30.80125191, 34.84418376, 29.5061941 , 33.00162298, 31.77854219,<br/>       31.93457429, 30.25155328, 35.71776325, 35.45861881, 33.58667301])</span></pre><p id="1949" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，让我们回到今天的主题——矢量化。什么是矢量化？<a class="ae ky" href="https://en.wikipedia.org/wiki/Vectorization" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">矢量化</strong> </a> <strong class="lt iu">是一种处理整个数组而不是单个元素的编程风格。这通常会加快计算速度。使用<code class="fe ms mt mu mv b">np.dot</code>是矢量化的一个例子；这个函数由Numpy优化，它直接使用两个输入向量执行内积，而不需要使用for循环(通常是嵌套的for循环)手动进行乘法和求和。</strong></p><h1 id="5e8e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">为什么矢量化速度更快</h1><p id="94f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">矢量化比for循环更快的一个主要原因是Numpy操作的底层实现。</p><p id="9e4d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如你们许多人所知(如果你熟悉<a class="ae ky" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a>)，Python是一种动态类型语言。当你声明一个变量时，不需要指定数据类型，因为Python会在运行时为你推断出来。这不同于静态类型语言，静态类型语言需要指定数据类型以便编译器检查，这些语言包括Java和c。</p><p id="3edb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Python中，假设一个列表存储异构元素，在运行时，当执行某个操作时，必须检查列表中的每个单独元素(类型检查)。这将给常规列表增加一定的开销。另一方面，Numpy使用的是<code class="fe ms mt mu mv b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html" rel="noopener ugc nofollow" target="_blank">ndarray</a></code>，它是存储同质元素的固定大小项目的多维数组。<code class="fe ms mt mu mv b">ndarray</code>被优化，因为底层操作是使用高效的C操作完成的，这允许向量化。</p><h1 id="64c5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">矢量化的另一个例子</h1><p id="da2a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了让您更好地理解矢量化，另一个例子是常见的损失函数<a class="ae ky" href="https://en.wikipedia.org/wiki/Linear_regression" rel="noopener ugc nofollow" target="_blank">线性回归</a> — <a class="ae ky" href="https://en.wikipedia.org/wiki/Mean_squared_error" rel="noopener ugc nofollow" target="_blank">均方误差(MSE) </a>。回想一下，线性回归的MSE定义为数据集中预测值和实际标注值之间的均方误差，预测值是当前权重集与要素的点积。这可以使用矢量化实现，如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="60f4" class="na la it mv b gy nb nc l nd ne">def MSE(theta, X, y):<br/>    return ((X @ theta - y)**2).sum() / len(X)</span></pre><p id="6aea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ni">注意，除了使代码执行方式更快之外，代码也直观简单。不需要混乱的嵌套for循环。</em></p><h1 id="481f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">矢量化的条件</h1><p id="09dd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，您可能知道矢量化速度很快。但是我们可以对任何类型的函数使用矢量化吗？矢量化的条件是什么？</p><p id="6cb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要使用矢量化，一个关键要求是底层的元素操作应该相互独立。例如，在x和y的点积中，<code class="fe ms mt mu mv b">x_1 * y_1</code>的结果与<code class="fe ms mt mu mv b">x_2 * y_2</code>无关。当不满足这个独立性标准时，我们只能回到使用for循环。以下给出了无法应用矢量化时的3种常见情况:</p><ul class=""><li id="f600" class="nj nk it lt b lu mn lx mo ma nl me nm mi nn mm no np nq nr bi translated">循环依赖性</li></ul><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="59c5" class="na la it mv b gy nb nc l nd ne">for i in range(1, len(x1)):<br/>    x1[i] = x1[i-1] * x2[i-1]</span></pre><ul class=""><li id="6d57" class="nj nk it lt b lu mn lx mo ma nl me nm mi nn mm no np nq nr bi translated">间接存储器访问</li></ul><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="3e55" class="na la it mv b gy nb nc l nd ne">for i in range(len(x2)):<br/>    x1[x2[i]] = x3[i] * x4[i]</span></pre><ul class=""><li id="4820" class="nj nk it lt b lu mn lx mo ma nl me nm mi nn mm no np nq nr bi translated">代码分支</li></ul><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="567a" class="na la it mv b gy nb nc l nd ne">for i in range(len(x1)):<br/>    if i &lt; 8:<br/>        i += func()<br/>    x1[i] = x2[i] * x3[i]</span></pre><h1 id="673a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">np .矢量化方法</h1><p id="86f9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果一个方法是可向量化的(不是上面三个条件中的任何一个)，那么我们可以通过<code class="fe ms mt mu mv b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html" rel="noopener ugc nofollow" target="_blank">np.vectorize</a></code>函数注册它。举个例子，</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cfd3" class="na la it mv b gy nb nc l nd ne">def func(a, b):<br/>    return a+1 if a &gt;= b else a-1</span><span id="b808" class="na la it mv b gy nf nc l nd ne">func_vec = np.vectorize(func)<br/><br/>a = np.array([1, 2, 3, 4, 5, 6])<br/>b = 3<br/>func_vec(a, b)<br/># result: array([0, 1, 4, 5, 6, 7])</span></pre><p id="032e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以定义自己的定制函数并将其矢量化，这很好。然而，在注册自己的矢量化函数之前，请考虑是否存在执行相同操作的多种方法。上述功能可以通过以下方式实现:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="68ec" class="na la it mv b gy nb nc l nd ne">np.where(a&gt;=b, a+1, a-1)<br/># result: array([0, 1, 4, 5, 6, 7])</span></pre><p id="cc5d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这两种方法给出了相同的结果。哪个更快？当我们使用<code class="fe ms mt mu mv b">%timeit</code>时，我们得到如下结果:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="5867" class="na la it mv b gy nb nc l nd ne">%timeit func_vec(a, b)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/edea444ec8ba2a1e2cc088f66271bc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Hb5nrvT9OiMDPLL6HhslA.png"/></div></div></figure><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e917" class="na la it mv b gy nb nc l nd ne">%timeit np.where(a&gt;=b, a+1, a-1)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/5ad45f72f808e03ff886b2951c34f7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kf2urTA3Qy5svhrTLJePHQ.png"/></div></div></figure><p id="5342" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">答案似乎是使用<code class="fe ms mt mu mv b">np.where</code>比定义我们自己的矢量化函数快4倍。原因是使用预定义的Numpy方法利用了Numpy使用的底层优化C代码。</p><p id="ab52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，每当您想要定义一个定制的矢量化函数时，首先要考虑是否有任何预定义的方法可以做同样的工作；否则，您可以安全地注册自己的矢量化函数。</p><h1 id="0a4c" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">矢量化思维过程</h1><p id="35a9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在您已经知道了什么是矢量化，为什么要使用矢量化，以及何时使用矢量化，我想给您提供一个关于矢量化思维过程的额外提示。</p><p id="d2af" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有些公式可能无法直观地进行矢量化，为了帮助解决这个问题，这里有一个大纲，告诉你如何考虑如何对特定表达式进行矢量化。</p><h2 id="94c4" class="na la it bd lb nu nv dn lf nw nx dp lj ma ny nz ll me oa ob ln mi oc od lp oe bi translated">矢量化的步骤:</h2><ul class=""><li id="706b" class="nj nk it lt b lu lv lx ly ma of me og mi oh mm no np nq nr bi translated">给定一个迭代表达式，考虑等价的向量/矩阵表达式形式</li><li id="dc07" class="nj nk it lt b lu oi lx oj ma ok me ol mi om mm no np nq nr bi translated">将这个向量/矩阵分解成更小的部分</li><li id="f750" class="nj nk it lt b lu oi lx oj ma ok me ol mi om mm no np nq nr bi translated">向量化每个组件，例如元素式操作、<code class="fe ms mt mu mv b">XX^T</code>、<code class="fe ms mt mu mv b">X^TX</code>等。</li><li id="4925" class="nj nk it lt b lu oi lx oj ma ok me ol mi om mm no np nq nr bi translated">识别Numpy函数，例如<code class="fe ms mt mu mv b">np.dot</code>、<code class="fe ms mt mu mv b">np.sum</code>、<code class="fe ms mt mu mv b">np.outer</code>、您自己的<code class="fe ms mt mu mv b">np.vectorize</code>函数，以执行矢量化</li></ul><p id="9c7a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ni">一个有趣的注意事项是，向量化不限于Numpy事实上，它也可以应用于其他数据科学和深度学习库，包括Pandas、scikit-learn、Pytorch等。</em></p><h1 id="c1af" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="01e2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你能走到这一步，恭喜你！</p><p id="82d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">再次重申，矢量化是一种一次处理整个数组/矩阵而不是单个元素的编程方式。向量化的主要优势是(方式)更快的代码执行和更干净的代码。注意，并不是所有的公式或方法都可以向量化，如果可以的话，我们可以通过<code class="fe ms mt mu mv b">np.vectorize</code>注册它，假设现有的Numpy函数没有其他的方法(例如<code class="fe ms mt mu mv b">np.dot</code>、<code class="fe ms mt mu mv b">np.where</code>、<code class="fe ms mt mu mv b">np.sum</code>等)。</p><p id="b62b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是这篇文章的全部内容，希望你在这篇文章中学到了一些东西！下一集再见。</p><p id="1396" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请随意浏览我以前的帖子，如果有任何问题，请告诉我:</p><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/build-a-song-recommendation-system-using-streamlit-and-deploy-on-heroku-375a57ce5e85"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">使用Streamlit构建歌曲推荐系统并在Heroku上部署</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">了解如何使用Spotify音乐数据集的K近邻构建一个简单的歌曲推荐引擎</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://medium.datadriveninvestor.com/beginners-guide-to-web-scraping-using-beautifulsoup-and-python-999a927f20e6" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">使用BeautifulSoup和Python的Web抓取初学者指南</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">简单的教程涵盖了美丽的基础知识，并举例说明了如何抓取维基百科的文章</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="oz l"><div class="pf l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/beginners-guide-to-regular-expressions-in-python-d16d2fa31587"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">Python正则表达式初学者指南</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">关于正则表达式的简单教程，涵盖了你需要知道的所有基础知识</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pg l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a href="https://medium.datadriveninvestor.com/top-20-masters-programs-in-ai-data-science-2021-98aadb7db409" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">2021年人工智能和数据科学20大硕士项目</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">美国最好的机器学习/数据科学项目列表</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.datadriveninvestor.com</p></div></div><div class="oz l"><div class="ph l pb pc pd oz pe ks oq"/></div></div></a></div><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/top-nlp-books-to-read-2020-12012ef41dc1"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">2020年最佳NLP读物</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">这是我个人为自然语言处理推荐的书籍列表，供实践者和理论家参考</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pi l pb pc pd oz pe ks oq"/></div></div></a></div><h1 id="a149" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">参考</h1><p id="35e4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Vectorization" rel="noopener ugc nofollow" target="_blank">矢量化</a> <a class="ae ky" href="https://en.wikipedia.org/wiki/Vectorization" rel="noopener ugc nofollow" target="_blank">(数组编程)</a> <a class="ae ky" href="https://en.wikipedia.org/wiki/Vectorization" rel="noopener ugc nofollow" target="_blank">，维基百科</a></p><p id="9f9d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://numpy.org/doc/" rel="noopener ugc nofollow" target="_blank"> Numpy文档，Numpy </a></p><p id="5d73" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://simpleprogrammer.com/vectorization-and-broadcasting/" rel="noopener ugc nofollow" target="_blank">矢量化和广播</a>、<a class="ae ky" href="https://simpleprogrammer.com/vectorization-and-broadcasting/" rel="noopener ugc nofollow" target="_blank">简单程序员</a></p><p id="31ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://blog.paperspace.com/numpy-optimization-vectorization-and-broadcasting/" rel="noopener ugc nofollow" target="_blank"> Numpy优化矢量化和广播，Paperspace博客</a></p></div></div>    
</body>
</html>