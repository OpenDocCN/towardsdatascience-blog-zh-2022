<html>
<head>
<title>Dealing with Groups in Cross-Validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在交叉验证中处理组</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cross-validate-on-data-containing-groups-correctly-ffa7173a37e6#2022-02-28">https://towardsdatascience.com/cross-validate-on-data-containing-groups-correctly-ffa7173a37e6#2022-02-28</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/a2dbad64221c56a4df3f2090edb51b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mhiC4D2EB7o9Ch_2"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">尼古拉斯·孔德在<a class="ae jh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><div class=""/><div class=""><h2 id="3abf" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">您的数据包含组吗？让我们看看如何在这种情况下正确使用交叉验证</h2></div><p id="59b9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">构建模型时，您是否遇到过数据集内似乎存在某种“分组”的情况？您希望确保与同一组相关的所有数据都被考虑用于定型模型或评估模型，而不是两者都考虑。这确保了没有数据泄漏，也就是说，在训练期间，模型不会看到保留测试集中的数据。</p><p id="5b4f" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">这类数据的例子可以是<em class="lv">客户</em> <em class="lv">交易数据</em>，其中您希望将同一个客户的交易保存在一起。另一个例子可能是包含不同<em class="lv">年</em>的数据，并且您希望将与一年相关的所有数据保存在测试集或训练集中。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h2 id="6b07" class="md me jk bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">数据分割和交叉验证</h2><p id="d25e" class="pw-post-body-paragraph kz la jk lb b lc mw kl le lf mx ko lh li my lk ll lm mz lo lp lq na ls lt lu in bi translated">您可能会想——为什么我们需要拆分数据来训练模型？为什么我们不能把所有的数据都用于训练和测试呢？让我们想一想…</p><p id="4a05" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">你可能已经明白了，但原因是这样的-如果你使用所有的数据来训练模型，然后根据相同的数据评估这个模型，那么你的模型将几乎完美地执行，因为它在训练时已经看到了所有的数据。这种模型不能很好地概括现实世界中的情况，在现实世界中，数据可能与模型所看到的有些不同。为了避免这种情况，并确保我们是在看不见的数据上评估我们的模型，以及看看它们在现实世界中的表现，我们使用了数据分割。在分割过程中，我们使用一定百分比的数据作为保留集，而剩余部分用于训练。</p><figure class="nc nd ne nf gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj nb"><img src="../Images/e592dd2967ee4e2cb293ea97138eecc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vF12ApuHTrsIeSnRxZKzHQ@2x.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">训练/测试分割(图片由作者提供)</p></figure><p id="a6a7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在问题来了，我们如何知道分割数据的最佳方式是什么，这将给我们一个真正好的模型？为了解决这个问题，我们使用<strong class="lb jl"> <em class="lv">交叉验证</em> </strong>。</p><p id="9cfe" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">在<em class="lv">交叉验证</em>中，我们将数据分成块，并使用每个块来测试模型，同时对剩余的块进行训练。在检查完所有的块之后，我们取所有评估的平均值来返回最终的模型性能。这解决了两件事-</p><ul class=""><li id="70c8" class="ng nh jk lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">确保我们充分利用我们的数据</li><li id="e4e4" class="ng nh jk lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果我们比较不同的建模技术，我们可以比较它们的交叉验证性能，以选择最好的。</li></ul><blockquote class="nu nv nw"><p id="1307" class="kz la lv lb b lc ld kl le lf lg ko lh nx lj lk ll ny ln lo lp nz lr ls lt lu in bi translated">交叉验证有助于我们评估模型的性能，以及在数据有限的情况下它的泛化能力</p></blockquote><h2 id="b51b" class="md me jk bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">k倍</h2><p id="d91d" class="pw-post-body-paragraph kz la jk lb b lc mw kl le lf mx ko lh li my lk ll lm mz lo lp lq na ls lt lu in bi translated"><strong class="lb jl"> <em class="lv"> K倍</em> </strong>是做交叉验证最简单的方法。这里的“K”代表我们在创建拆分时将数据分成的块(折叠)的数量。下图显示了一个简单的三折叠示例，以及如何在对其他折叠进行训练的同时，使用每个折叠来评估模型的性能。</p><figure class="nc nd ne nf gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj oa"><img src="../Images/c809ad45b94d5fe3de1103e8b13b7645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4DhtX0Rq5XftsJlTDNRxw@2x.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">三重交叉验证(图片由作者提供)</p></figure><p id="c7ed" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">为了先看看这在代码中是什么样子，让我们随机创建一个小数据集来使用。</p><pre class="nc nd ne nf gu ob oc od oe aw of bi"><span id="774e" class="md me jk oc b gz og oh l oi oj">import numpy as np</span><span id="6cdf" class="md me jk oc b gz ok oh l oi oj"># create a dataset containing 6 samples<br/># each sample has 5 features<br/>X = [np.random.uniform(0.0, 10.0, 5) for _ in range(6)]</span></pre><p id="23d9" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">现在让我们看看KFold如何处理这个数据集。我们将使用KFold的scikit-learn实现。</p><pre class="nc nd ne nf gu ob oc od oe aw of bi"><span id="8d98" class="md me jk oc b gz og oh l oi oj">from sklearn.model_selection import KFold<br/>kf_cv = KFold(n_splits=3, shuffle=True, random_state=11)</span><span id="f376" class="md me jk oc b gz ok oh l oi oj">for split, (ix_train, ix_test) in enumerate(kf_cv.split(X)):<br/>    print(f“SPLIT {split+1}”)<br/>    print(f“TRAIN INDEXES: {ix_train}, TEST INDEXES: {ix_test}\n”)</span><span id="1e22" class="md me jk oc b gz ok oh l oi oj"><br/>## OUTPUT ##<br/>SPLIT 1<br/>TRAIN INDEXES: [0 1 3 5], TEST INDEXES: [2 4]</span><span id="4beb" class="md me jk oc b gz ok oh l oi oj">SPLIT 2<br/>TRAIN INDEXES: [0 1 2 4], TEST INDEXES: [3 5]</span><span id="b658" class="md me jk oc b gz ok oh l oi oj">SPLIT 3<br/>TRAIN INDEXES: [2 3 4 5], TEST INDEXES: [0 1]</span></pre><p id="14c6" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">正如你在上面的代码中看到的，我们运行KFold进行了3次折叠。因为我们的样本数据集由6个样本组成，所以它将它们分成每个包含2个样本的块，并使用这些块来创建训练/测试分割。</p><h2 id="99dc" class="md me jk bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">K-折叠组</h2><p id="6e92" class="pw-post-body-paragraph kz la jk lb b lc mw kl le lf mx ko lh li my lk ll lm mz lo lp lq na ls lt lu in bi translated">现在我们已经看到了K-Fold是如何工作的，如果我们的数据集中有组，我们该怎么办？使用常规K折叠时，无法指定组。幸运的是，我们有<strong class="lb jl"> <em class="lv">组K-Fold </em> </strong>，它只是K-Fold的增强，有助于考虑数据中的组。</p><figure class="nc nd ne nf gu iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj ol"><img src="../Images/eae3a513f3e823062eb47d1e68986404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gh6A9u6SnV0d6kw0jH2n9g.jpeg"/></div></div><p class="jd je gk gi gj jf jg bd b be z dk translated">由3个小组组成的小组文件夹(图片由作者提供)</p></figure><blockquote class="nu nv nw"><p id="8b34" class="kz la lv lb b lc ld kl le lf lg ko lh nx lj lk ll ny ln lo lp nz lr ls lt lu in bi translated">K-Fold组的属性(来自scikit的<a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GroupKFold.html" rel="noopener ugc nofollow" target="_blank">-learn</a>):</p><p id="5ed8" class="kz la lv lb b lc ld kl le lf lg ko lh nx lj lk ll ny ln lo lp nz lr ls lt lu in bi translated">-具有非重叠组的K重迭代器变量。<br/> -同一组不会出现在两个不同的折叠中(不同组的数量必须至少等于折叠的数量)。<br/> -褶皱大致平衡，即每个褶皱中不同组的数量大致相同。</p></blockquote><p id="cf0d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">让我们看看k-fold组如何在同一个数据集上工作。<em class="lv"> grps </em>只是一个代表每个样本属于哪个组的列表。我们将这个组列表作为参数与数据集一起传递给<em class="lv"> split()函数</em>。</p><pre class="nc nd ne nf gu ob oc od oe aw of bi"><span id="1b2c" class="md me jk oc b gz og oh l oi oj"># assign groups to samples<br/>grps = [1,2,1,1,2,3]</span><span id="2b7e" class="md me jk oc b gz ok oh l oi oj">from sklearn.model_selection import GroupKFold<br/>gkf_cv = GroupKFold(n_splits=3)</span><span id="c2e7" class="md me jk oc b gz ok oh l oi oj">for split, (ix_train, ix_test) in enumerate(gkf_cv.split(X, groups=grps)):<br/>    print(f“SPLIT {split+1}”)<br/>    print(f“TRAIN INDEXES: {ix_train}, TEST INDEXES: {ix_test}\n”)</span><span id="9a0e" class="md me jk oc b gz ok oh l oi oj"><br/>## OUTPUT ##<br/>SPLIT 1<br/>TRAIN INDEXES: [1 4 5], TEST INDEXES: [0 2 3]</span><span id="3f18" class="md me jk oc b gz ok oh l oi oj">SPLIT 2<br/>TRAIN INDEXES: [0 2 3 5], TEST INDEXES: [1 4]</span><span id="b0d3" class="md me jk oc b gz ok oh l oi oj">SPLIT 3<br/>TRAIN INDEXES: [0 1 2 3 4], TEST INDEXES: [5]</span></pre><blockquote class="nu nv nw"><p id="e921" class="kz la lv lb b lc ld kl le lf lg ko lh nx lj lk ll ny ln lo lp nz lr ls lt lu in bi translated">K-Fold组确保属于同一组的所有样本都在一起。</p></blockquote><h2 id="e732" class="md me jk bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">结论</h2><p id="4a30" class="pw-post-body-paragraph kz la jk lb b lc mw kl le lf mx ko lh li my lk ll lm mz lo lp lq na ls lt lu in bi translated">在某些机器学习问题的情况下，跟踪数据集中的分组是非常重要的，在这种情况下，Group K-Fold可以提供很大的帮助。</p><p id="bb08" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu in bi translated">既然明白了什么是团K折，那么这个<strong class="lb jl"> <em class="lv">团洗牌拆分</em> </strong>是什么？这些拆分与K-fold组有何不同？让我们在本系列的下一篇文章中尝试找到这些和其他问题的答案。敬请关注…</p><h2 id="bacf" class="md me jk bd mf mg mh dn mi mj mk dp ml li mm mn mo lm mp mq mr lq ms mt mu mv bi translated">参考</h2><ul class=""><li id="fc53" class="ng nh jk lb b lc mw lf mx li om lm on lq oo lu nl nm nn no bi translated"><a class="ae jh" href="https://machinelearningmastery.com/k-fold-cross-validation/" rel="noopener ugc nofollow" target="_blank">k倍交叉验证的温和介绍</a></li><li id="a484" class="ng nh jk lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html#sklearn.model_selection.KFold" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn: K倍</a></li><li id="966a" class="ng nh jk lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae jh" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GroupKFold.html" rel="noopener ugc nofollow" target="_blank">sci kit-Learn:K-Fold组</a></li><li id="41c9" class="ng nh jk lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae jh" href="https://scikit-learn.org/stable/modules/cross_validation.html" rel="noopener ugc nofollow" target="_blank"> Scikit-Learn:交叉验证用户指南</a></li></ul></div></div>    
</body>
</html>