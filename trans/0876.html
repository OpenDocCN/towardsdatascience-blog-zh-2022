<html>
<head>
<title>How to Normalize a NumPy Array to a Unit Vector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将 NumPy 数组规范化为单位向量</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/normalise-numpy-unit-vector-f9f086134507#2022-03-09">https://towardsdatascience.com/normalise-numpy-unit-vector-f9f086134507#2022-03-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="bb4e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">用 Python 将 numpy 数组归一化为单位向量</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/476791d37b1ca32dca6e1f80ee195b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSgGr2swZrIDiL6TDhEJEQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@sebastiansvenson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Sebastian Svenson </a>在<a class="ae kz" href="https://unsplash.com/s/photos/vector?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="d065" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">标准化是一个数据转换过程，发生在模型开发的早期阶段，目的是<strong class="ly iv">改变数据数值的分布形状</strong>。例如，您可能希望对数字数据点进行规范化，使它们的总和为 1，并被描述为概率分布。</p><p id="095f" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">各种机器学习模型受益于数据标准化，<strong class="ly iv">特别是那些利用欧几里德距离的模型</strong>。</p><p id="e1d9" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在今天的文章中，我们将展示如何<strong class="ly iv">将一个 numpy 数组规格化为一个单位向量</strong>。这意味着我们将改变向量的大小，使每个向量的长度为 1。</p><p id="b40c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">更具体地说，我们将使用以下工具来探索如何做到这一点:</p><ul class=""><li id="3fd9" class="mu mv iu ly b lz mp mc mq lj mw ln mx lr my mo mz na nb nc bi translated"><code class="fe nd ne nf ng b">scikit-learn</code>图书馆</li><li id="127f" class="mu mv iu ly b lz nh mc ni lj nj ln nk lr nl mo mz na nb nc bi translated"><code class="fe nd ne nf ng b">numpy</code>的<code class="fe nd ne nf ng b">linalg.norm()</code>方法，</li><li id="85b2" class="mu mv iu ly b lz nh mc ni lj nj ln nk lr nl mo mz na nb nc bi translated"><code class="fe nd ne nf ng b">scipy</code>中的<code class="fe nd ne nf ng b">linalg.norm()</code></li></ul></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="4413" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">首先，让我们创建一个 NumPy 数组，我们将在示例中引用它来演示一些概念。</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="7db4" class="la lb iu ng b gz nx ny l nz oa">import numpy as np<br/></span><span id="07b4" class="la lb iu ng b gz ob ny l nz oa"># Ensure values are reproducible<br/>np.random.seed(1234)</span><span id="1751" class="la lb iu ng b gz ob ny l nz oa">array_1d = np.random.rand(15) * 10</span><span id="084e" class="la lb iu ng b gz ob ny l nz oa">print(array_1d)<br/><strong class="ng iv"><em class="oc">array([1.9151945 , 6.22108771, 4.37727739, 7.85358584, 7.79975808,<br/>       2.72592605, 2.76464255, 8.01872178, 9.58139354, 8.75932635,<br/>       3.5781727 , 5.00995126, 6.83462935, 7.12702027, 3.70250755])</em></strong></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="68c5" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用 scikit-learn normalize()方法</h2><p id="b3ff" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">谈到归一化一个 numpy 数组，我们的第一个选择是<code class="fe nd ne nf ng b"><a class="ae kz" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.normalize.html" rel="noopener ugc nofollow" target="_blank">sklearn.preprocessing.normalize()</a></code>方法，该方法可用于<em class="oc">将输入向量单独缩放到单位范数(向量长度)</em>。下面分享的例子说明了这一点。</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="8b00" class="la lb iu ng b gz nx ny l nz oa">from sklearn.preprocessing import normalize</span><span id="045d" class="la lb iu ng b gz ob ny l nz oa"><strong class="ng iv">array_1d_norm = normalize(array_1d[:,np.newaxis], axis=0).ravel()</strong></span><span id="0e11" class="la lb iu ng b gz ob ny l nz oa">print(array_1d_norm)<br/><strong class="ng iv"><em class="oc">[0.07945112 0.25807949 0.18158971 0.32580306 0.32357003 0.11308402<br/> 0.11469016 0.33265366 0.39748051 0.36337736 0.14843915 0.20783595<br/> 0.28353203 0.29566176 0.15359713]</em></strong></span></pre><p id="bec9" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">注意，默认情况下，用于标准化输入的标准将被设置为<code class="fe nd ne nf ng b">'l2'</code>。这意味着，如果我们对规范化数组的元素求和，我们不应该期望它等于 1。事实上，这里的情况是这样的:</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="1849" class="la lb iu ng b gz nx ny l nz oa">print(sum(array_1d_norm))<br/><strong class="ng iv"><em class="oc">3.578845135327915</em></strong></span></pre><p id="b924" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">如果你希望得到的向量的和等于 1(概率分布)，你应该将<code class="fe nd ne nf ng b">'l1'</code>值传递给<code class="fe nd ne nf ng b">norm</code>参数:</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="a0d3" class="la lb iu ng b gz nx ny l nz oa">from sklearn.preprocessing import normalize</span><span id="c900" class="la lb iu ng b gz ob ny l nz oa"><strong class="ng iv">array_1d_norm = normalize(<br/>    array_1d[:,np.newaxis], <br/>    axis=0, <br/>    norm='l1',<br/>).ravel()</strong></span><span id="5d7b" class="la lb iu ng b gz ob ny l nz oa">print(array_1d_norm)<br/><strong class="ng iv"><em class="oc">[0.02220021 0.0721125  0.05073975 0.09103581 0.09041186 0.03159791<br/> 0.03204669 0.09295    0.1110639  0.10153481 0.04147683 0.05807347<br/> 0.07922445 0.08261373 0.04291807]</em></strong></span></pre><p id="8533" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">现在，如果我们对结果数组的值求和，我们应该期望它等于 1:</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="2407" class="la lb iu ng b gz nx ny l nz oa">print(sum(array_1d_norm))<br/><strong class="ng iv"><em class="oc">1</em></strong></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="69d4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用 numpy 和 linalg.norm()方法</h2><p id="29b9" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">我们的另一个选择是 numpy 的<code class="fe nd ne nf ng b"><a class="ae kz" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.norm.html" rel="noopener ugc nofollow" target="_blank">linalg.norm()</a></code>方法，它将根据<code class="fe nd ne nf ng b">ord</code>参数中指定的值(默认为<code class="fe nd ne nf ng b">None</code>)返回八个不同矩阵范数中的一个。</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="7c7e" class="la lb iu ng b gz nx ny l nz oa"><strong class="ng iv">array_1d_norm = array_1d / np.linalg.norm(array_1d)</strong></span><span id="f688" class="la lb iu ng b gz ob ny l nz oa">print(array_1d_norm)<br/><strong class="ng iv"><em class="oc">[0.07945112 0.25807949 0.18158971 0.32580306 0.32357003 0.11308402<br/> 0.11469016 0.33265366 0.39748051 0.36337736 0.14843915 0.20783595<br/> 0.28353203 0.29566176 0.15359713]</em></strong></span><span id="6f49" class="la lb iu ng b gz ob ny l nz oa">print(sum(array_1d_norm))<br/><strong class="ng iv"><em class="oc">3.578845135327915</em></strong></span></pre><p id="557c" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">同样，如果你想把这些值加起来等于 1(例如概率分布)，你需要指定<code class="fe nd ne nf ng b">ord=1</code>。</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="65b4" class="la lb iu ng b gz nx ny l nz oa"><strong class="ng iv">array_1d_norm = array_1d / np.linalg.norm(array_1d, ord=1)</strong></span><span id="70d3" class="la lb iu ng b gz ob ny l nz oa">print(array_1d_norm)<br/><strong class="ng iv"><em class="oc">[0.02220021 0.0721125  0.05073975 0.09103581 0.09041186 0.03159791<br/> 0.03204669 0.09295    0.1110639  0.10153481 0.04147683 0.05807347<br/> 0.07922445 0.08261373 0.04291807]</em></strong></span><span id="4de9" class="la lb iu ng b gz ob ny l nz oa">print(sum(array_1d_norm))<br/><strong class="ng iv"><em class="oc">1</em></strong></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="bf3d" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用 scipy linalg()方法</h2><p id="c6e4" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">或者，你甚至可以使用<code class="fe nd ne nf ng b"><a class="ae kz" href="https://docs.scipy.org/doc/scipy/tutorial/linalg.html" rel="noopener ugc nofollow" target="_blank">scipy.linalg()</a></code>方法，它本质上包含了与<code class="fe nd ne nf ng b">numpy</code>的<code class="fe nd ne nf ng b">linalg()</code>方法相同的功能，加上一些后者不包含的额外的和更高级的功能。</p><p id="5989" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">这里使用的符号与我们在前面的例子中使用的符号完全相同。</p><pre class="kk kl km kn gu nt ng nu nv aw nw bi"><span id="a1df" class="la lb iu ng b gz nx ny l nz oa">from scipy import linalg</span><span id="178a" class="la lb iu ng b gz ob ny l nz oa"><strong class="ng iv">array_1d_norm = array_1d / linalg.norm(array_1d, ord=1)</strong></span><span id="16ab" class="la lb iu ng b gz ob ny l nz oa">print(array_1d_norm)<br/><strong class="ng iv"><em class="oc">[0.02220021 0.0721125  0.05073975 0.09103581 0.09041186 0.03159791<br/> 0.03204669 0.09295    0.1110639  0.10153481 0.04147683 0.05807347<br/> 0.07922445 0.08261373 0.04291807]</em></strong></span><span id="5709" class="la lb iu ng b gz ob ny l nz oa">print(sum(array_1d_norm))<br/><strong class="ng iv"><em class="oc">1</em></strong></span></pre></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="f311" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的简短教程中，我们讨论了单位向量的 numpy 数组归一化。数据标准化是改变特定数据集中数值数据点分布的过程。这是在模型开发的早期阶段应用的一个常见的预处理转换步骤。</p><p id="0241" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">今天，我们展示了一些不同的方法来归一化 numpy 数组，最终将帮助您的机器学习模型执行得更好。</p><p id="4abd" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated">在我的另一篇关于 Medium 的文章中，您还可以了解到另一个关于数据预处理和转换的类似概念，称为<strong class="ly iv">特性缩放</strong>。</p><div class="od oe gq gs of og"><a rel="noopener follow" target="_blank" href="/feature-scaling-and-normalisation-in-a-nutshell-5319af86f89b"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">简而言之，特征缩放和标准化</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">为什么、如何以及何时调整要素的比例</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kt og"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="od oe gq gs of og"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">通过我的推荐链接加入 Medium-Giorgos Myrianthous</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="op l"><div class="ov l or os ot op ou kt og"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mp jv mb mc mq jy me lj mr mg mh ln ms mj mk lr mt mm mn mo in bi translated"><strong class="ly iv">你可能也会喜欢</strong></p><div class="od oe gq gs of og"><a rel="noopener follow" target="_blank" href="/random-seed-numpy-786cf7876a5f"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">random.seed 在 NumPy 中做什么</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">理解在 Python 中使用 NumPy 生成伪随机结构时如何创建可再现的结果</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ow l or os ot op ou kt og"/></div></div></a></div></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu og"><a rel="noopener follow" target="_blank" href="/scikit-learn-vs-sklearn-6944b9dc1736"><div class="oh ab fp"><div class="oi ab oj cl cj ok"><h2 class="bd iv gz z fq ol fs ft om fv fx it bi translated">Scikit-Learn 和 Sklearn 有区别吗？</h2><div class="on l"><h3 class="bd b gz z fq ol fs ft om fv fx dk translated">Python 中的 scikit-learn vs sklearn</h3></div><div class="oo l"><p class="bd b dl z fq ol fs ft om fv fx dk translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ox l or os ot op ou kt og"/></div></div></a></div></div></div>    
</body>
</html>