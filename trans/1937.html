<html>
<head>
<title>How to Iterate with Hamilton in a Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在笔记本上与汉密尔顿迭代</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-iterate-with-hamilton-in-a-notebook-8ec0f85851ed#2022-05-03">https://towardsdatascience.com/how-to-iterate-with-hamilton-in-a-notebook-8ec0f85851ed#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="08e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些不知道的人来说，<a class="ae kl" href="https://github.com/DAGWorks-Inc/hamilton/" rel="noopener ugc nofollow" target="_blank"> Hamilton </a>是一个通用的微框架，用于指定数据流，例如指定<a class="ae kl" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>转换。它帮助你构建你的代码库，并改进你的代码，例如，你总是用Hamilton编写单元可测试转换代码。它通过引入一种范式来做到这一点，在这种范式中，函数必须以自以为是的、声明性的方式来编写。参见这篇<a class="ae kl" rel="noopener" target="_blank" href="/functions-dags-introducing-hamilton-a-microframework-for-dataframe-generation-more-8e34b84efc1d"> TDS帖子</a>获取更广泛的介绍。</p><p id="dc90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Hamilton的一个开发含义是，它迫使您从一开始就将python函数组织成模块。如果在笔记本中迭代是您的开发方式，那么在笔记本环境中使用Hamilton似乎很困难。在本帖中，我将解释如何在笔记本上舒适地迭代汉密尔顿DAG。</p><h1 id="cb52" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤1 —安装Jupyter &amp; Hamilton</h1><p id="7e12" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我假设您已经设置了这个步骤。但是以防万一你没有:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c9b5" class="ly kn iq lu b gy lz ma l mb mc">pip install notebook<br/>pip install sf-hamilton</span></pre><p id="0a62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，要启动笔记本服务器，应该是:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="eed8" class="ly kn iq lu b gy lz ma l mb mc">jupyter notebook</span></pre><h1 id="57fe" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤2—设置文件</h1><ol class=""><li id="c96f" class="md me iq jp b jq lk ju ll jy mf kc mg kg mh kk mi mj mk ml bi translated">启动你的Jupyter笔记本。</li><li id="3058" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">转到您希望笔记本和Hamilton功能模块所在的目录。</li><li id="8268" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">创建一个或多个python文件。通过“新建&gt;文本文件”来完成。它将打开一个“文件”编辑器视图。给文件命名并给它一个<code class="fe mr ms mt lu b">.py</code>扩展名。保存之后，您会看到jupyter现在提供了python语法高亮显示。保持此选项卡打开，以便您可以翻回到它来编辑此文件。</li><li id="49a0" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">启动将在另一个浏览器选项卡中使用的笔记本。</li></ol><h1 id="e434" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">步骤3——迭代的基本过程</h1><p id="44bf" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">概括地说，您将在选项卡之间来回切换。您将向汉密尔顿函数python模块中添加函数，然后将该模块导入/重新导入到笔记本中以获得更改。然后，您将像往常一样使用Hamilton来运行和执行事物，并使用笔记本来执行您使用笔记本执行的所有标准事物。</p><p id="d25f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个例子。</p><p id="d8d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我添加到我们的哈密尔顿函数模块的一个函数。我将模块命名为<code class="fe mr ms mt lu b">some_functions.py</code>(显然选择一个更适合您情况的名称)。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="7bc8" class="ly kn iq lu b gy lz ma l mb mc">import pandas as pd</span><span id="a7bf" class="ly kn iq lu b gy mu ma l mb mc">def avg_3wk_spend(spend: pd.Series) -&gt; pd.Series:<br/>    """Rolling 3 week average spend."""<br/>    print("foo") # will use this to prove it reloaded!<br/>    return spend.rolling(3).mean()</span></pre><p id="587b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我在笔记本上设置的内容，以便能够使用Hamilton并导入该模块:</p><p id="7b99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元格1:这只是导入了我们需要的基本东西。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1276" class="ly kn iq lu b gy lz ma l mb mc">import importlib</span><span id="23eb" class="ly kn iq lu b gy mu ma l mb mc">import pandas as pd</span><span id="ae62" class="ly kn iq lu b gy mu ma l mb mc">from hamilton import driver</span></pre><p id="7945" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元格2:导入您的汉密尔顿功能模块</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="e666" class="ly kn iq lu b gy lz ma l mb mc"># import your hamilton function module(s) here<br/>import some_functions</span></pre><p id="7719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元格3:每当你对<code class="fe mr ms mt lu b">some_functions.py</code>做出更改并保存时，运行这个单元格</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="2d36" class="ly kn iq lu b gy lz ma l mb mc"># use this to reload the module after making changes to it.<br/>importlib.reload(some_functions)</span></pre><p id="d408" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样做的目的是重新加载模块，从而确保代码是最新的，以供您使用。</p><p id="0ce6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">单元格4:使用汉密尔顿</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6e43" class="ly kn iq lu b gy lz ma l mb mc">config = {}<br/>dr = driver.Driver(config, some_functions)<br/>input_data = {'spend': pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])}<br/>df = dr.execute(['avg_3wk_spend'], inputs=input_data)</span></pre><p id="4a4b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行该单元后，您应该会看到作为输出打印的<code class="fe mr ms mt lu b">foo</code>。</p><p id="dea2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好的，现在让我们说我们正在迭代我们的哈密尔顿函数。在另一个浏览器选项卡中，转到您的Hamilton功能模块(本例中为<code class="fe mr ms mt lu b">some_functions.py</code>),将<code class="fe mr ms mt lu b">print("foo")</code>更改为其他内容，例如<code class="fe mr ms mt lu b">print("foo-bar").</code>保存文件——它看起来应该是这样的:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4d0e" class="ly kn iq lu b gy lz ma l mb mc">def avg_3wk_spend(spend: pd.Series) -&gt; pd.Series:<br/>    """Rolling 3 week average spend."""<br/>    print("foo-bar")<br/>    return spend.rolling(3).mean()</span></pre><p id="e564" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到笔记本，重新运行单元3和单元4。您现在应该会看到一个不同的输出，例如<code class="fe mr ms mt lu b">foo-bar</code>。</p><p id="337b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">恭喜你！你刚刚用Jupyter笔记本成功迭代了Hamilton！</p><p id="37eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下，在我看来事情是这样结束的:</p><ul class=""><li id="4090" class="md me iq jp b jq jr ju jv jy mv kc mw kg mx kk my mj mk ml bi translated">下面是我的<code class="fe mr ms mt lu b">some_functions.py</code>文件的样子:</li></ul><figure class="lp lq lr ls gt na gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0f7103e226c73aa7723cbe83e8c144cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*iwbLF1dzfyX2ZxJqV7a_YQ.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><ul class=""><li id="701c" class="md me iq jp b jq jr ju jv jy mv kc mw kg mx kk my mj mk ml bi translated">我的笔记本看起来是这样的:</li></ul><figure class="lp lq lr ls gt na gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/52f136641d616e42826e50c447337159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*xNtsl3KtWdRjM6FbuaPr2w.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">作者图片</p></figure><h1 id="97fc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">帮助:我正在使用谷歌Colab，我不能做到以上几点</h1><p id="960a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">自从<code class="fe mr ms mt lu b">1.8.0</code>发布以来，你现在可以用你的驱动程序内联定义函数来构建DAG。<em class="ni">我们强烈建议只有在绝对必要的时候才使用这种方法</em>——用这种方法构建代码非常容易。</p><p id="aa22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设我们想要添加一个函数来计算<code class="fe mr ms mt lu b">avg_3wk_spend</code>的对数，而不是将其添加到<code class="fe mr ms mt lu b">some_functions.py</code>，我们可以直接在笔记本中执行以下步骤:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="15a2" class="ly kn iq lu b gy lz ma l mb mc"># Step 1 - define function<br/>import numpy as np</span><span id="57aa" class="ly kn iq lu b gy mu ma l mb mc">def log_avg_3wk_spend(avg_3wk_spend: pd.Series) -&gt; pd.Series:<br/>    “””Simple function taking the logarithm of spend over signups.”””<br/>    return np.log(avg_3wk_spend)</span></pre><p id="f523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们必须创建一个“临时python模块”来存放它。我们通过导入<code class="fe mr ms mt lu b">ad_hoc_utils</code>然后调用<code class="fe mr ms mt lu b">create_temporary_module</code>函数，传入我们想要的函数，并为我们正在创建的模块提供一个名称。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="f3d4" class="ly kn iq lu b gy lz ma l mb mc"># Step 2 - create a temporary module to house all notebook functions<br/>from hamilton import ad_hoc_utils<br/>temp_module = ad_hoc_utils.create_temporary_module(<br/>     log_avg_3wk_spend, module_name='function_example')</span></pre><p id="9c35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，您可以像对待python模块一样对待<code class="fe mr ms mt lu b">temp_module</code>,并将其传递给驱动程序，像平常一样使用Hamilton:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="8997" class="ly kn iq lu b gy lz ma l mb mc"># Step 3 - add the module to the driver and continue as usual<br/>dr = driver.Driver(config, some_functions, temp_module) <br/>df = dr.execute(['avg_3wk_spend', 'log_avg_3wk_spend'], inputs=input_data)</span></pre><h2 id="513d" class="ly kn iq bd ko nj nk dn ks nl nm dp kw jy nn no la kc np nq le kg nr ns li nt bi translated">这种方法的注意事项:</h2><p id="1d4d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">使用“临时python模块”不会通过在Spark上使用Ray、Dask或Pandas来实现计算的缩放。所以我们建议只将这种方法用于开发目的。</p><h1 id="2e10" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">提示:你可以直接导入函数</h1><p id="1da6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">将Hamilton函数放入一个模块的好处是，在另一个上下文中重用它非常容易。例如另一个笔记本，或者直接。</p><p id="d938" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，很容易直接使用笔记本中的功能，就像这样:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="42bf" class="ly kn iq lu b gy lz ma l mb mc">some_functions.avg_3wk_spend(pd.Series([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))</span></pre><p id="fc0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它调用我们在<code class="fe mr ms mt lu b">some_functions.py</code>模块中定义的<code class="fe mr ms mt lu b">avg_3wk_spend</code>函数。</p><h1 id="7807" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">提示:您可以使用ipython magic来自动加载代码</h1><p id="cf8f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">并排打开Python模块和Jupyter笔记本，然后将<a class="ae kl" href="https://ipython.org/ipython-doc/3/config/extensions/autoreload.html" rel="noopener ugc nofollow" target="_blank">% auto reload ipython magic</a>添加到笔记本以自动重新加载单元格:</p><pre class="lp lq lr ls gt lt lu nu bn nv nw bi"><span id="74d7" class="nx kn iq lu b be ny nz l oa mc">from hamilton.driver import Driver<br/><br/># load extension<br/>%load_ext autoreload<br/># configure autoreload to only affect specified files<br/>%autoreload 1  <br/># import &amp; specify my_module to be reloaded <br/># i.e. this is the data transformation module that I have open in other tab<br/>%aimport my_module  <br/><br/>hamilton_driver = Driver({}, my_module)<br/>hamilton_driver.execute(['desired_output1', 'desired_output2'])</span></pre><p id="6215" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，您将遵循以下流程:</p><ol class=""><li id="597c" class="md me iq jp b jq jr ju jv jy mv kc mw kg mx kk mi mj mk ml bi translated">在open python模块中编写数据转换</li><li id="88da" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">在笔记本中，实例化一个Hamilton驱动程序，并用一小部分数据测试DAG。</li><li id="dfe9" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">由于%autoreload，每次执行Hamilton DAG时，都会使用最新的更改重新导入模块。这种方法防止了无序的笔记本执行，并且函数总是驻留在干净的地方。py文件。</li></ol><p id="2aa0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鸣谢:<a class="ae kl" href="https://medium.com/@thijean/the-perks-of-creating-dataflows-with-hamilton-36e8c56dd2a" rel="noopener"> Thierry Jean的博客文章</a>提供了这最后一个技巧。</p><h1 id="312f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">最后</h1><p id="5991" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">感谢你阅读这篇文章。我们很乐意帮助您成功使用汉密尔顿。欢迎在我们的<a class="ae kl" href="https://github.com/DAGWorks-Inc/hamilton/" rel="noopener ugc nofollow" target="_blank"> github知识库</a>中留下问题/评论(我们也很喜欢⭐️！)，或者加入我们的<a class="ae kl" href="https://join.slack.com/t/hamilton-opensource/shared_invite/zt-1bjs72asx-wcUTgH7q7QX1igiQ5bbdcg" rel="noopener ugc nofollow" target="_blank"> slack服务器</a>寻求帮助，或者提供建议/改进。</p></div></div>    
</body>
</html>