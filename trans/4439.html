<html>
<head>
<title>3D Model Fitting for Point Clouds with RANSAC and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于RANSAC和Python的点云三维模型拟合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3d-model-fitting-for-point-clouds-with-ransac-and-python-2ab87d5fd363#2022-10-03">https://towardsdatascience.com/3d-model-fitting-for-point-clouds-with-ransac-and-python-2ab87d5fd363#2022-10-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="84cd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">3D Python</h2><div class=""/><div class=""><h2 id="9226" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">无监督三维点云二元分割的线性模型创建、检测和拟合的5步指南:RANSAC从头实现。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3a5c90d93e3fba52df5ba2befc41beb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*NeTNKLf0ToAz6FbEhy7-tw.gif"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">点云好玩！现在，让我们试着理解这个模糊的集合。弗·普克斯。我获得了研究员办公桌，ADAS激光雷达来自威力登传感器，操场是由Emm用Everypoint.io生成的(场景)。</p></figure><p id="16ba" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你有没有想过为什么我们会在周围的世界中发现如此多的几何图形？不，你没有？好消息，这意味着你是理智的。我倾向于对生活和事物有奇怪的疑问🙃。我觉得它非常迷人，尤其是❄️薄片的对称奇迹，美味中的基本形状🍈、或遗产设计🕌图案的奇迹。</p><p id="fe10" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们的世界充满了不同的几何风味。但是如果你环顾四周，我打赌你至少能找到五个简单的几何图形。我们注意到，我们发现的大多数形状都可以与几何图元联系起来，如平面、金字塔、圆柱体、立方体和球体。这是一个引人注目的观察结果；为什么？</p><p id="5f47" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们假设我们可以捕捉并数字化我们真实世界环境的细节。在这些3D数字复制品中检测组成场景的形状并将其用作语义提取层会不会很方便？做模特吗？为了场景理解？</p><p id="5ccc" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">哈哈，准确的说！在本教程中，我会给你一个快速的方法来定义三维平面，并使用它们作为基础来划分三维点云。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi md"><img src="../Images/173d83b57f920d32391f26b0843bda93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KEGZJVZO5XHL9MkM_K0-7g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">本教程涵盖了整个工作流程。我们获取一个点云场景，我们将使用随机样本一致性方法对其进行分割。F. Poux</p></figure><p id="e27a" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为此，我们将介绍一个健壮的算法，并从头开始实现它:RANSAC！你准备好了吗？让我们开始吧！</p><h1 id="4359" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">步骤0。战略</h1><p id="06d0" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">在直截了当地用一个有效的解决方案来处理这个项目之前，让我们先设计一个总体方案。本教程遵循由五个简单步骤组成的策略，如下图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/8d89242653e2bc9ece78c83e6c263013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SkoW9O98XUx76-AAcXcvQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">基于RANSAC平面模型拟合的点云二值分割策略图。F. Poux</p></figure><p id="b293" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，(1)我们在我与你分享的三个数据集中选择了一个点云数据集。然后，(2)在数据中选择一个几何模型进行检测。(3)研究了推广参数的定义。(4)我们将这三种成分与RANSAC配方混合在一起，(5)我们分割我们的点云:瞧！一个精心制作的点云！该战略已经制定，您可以在下面找到这些步骤的快速链接:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="dbc6" class="nh mf it nd b gy ni nj l nk nl">Step 1. The Point Cloud Data<br/>Step 2. Geometric Model Selection<br/>Step 3. Parameter's Definition<br/>Step 4. RANSAC Model Fitting (from scratch)<br/>Step 5. Point Cloud Binary Segmentation</span><span id="7c82" class="nh mf it nd b gy nm nj l nk nl">Perspectives &amp; Conclusion</span></pre><p id="46e8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在我们已经设置好了，让我们直接开始吧。</p><h1 id="c031" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">第一步。点云数据</h1><p id="cf9b" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">好了，我们走吧。我们将设计一个容易扩展到不同用例的方法。出于这个目的，不是一个而是三个数据集，你可以从中选择，下载，并做你的科学实验😁。选择这些来说明三种不同的场景，并提供基本的数据。多酷啊，匈奴？</p><div class="ks kt ku kv gt ab cb"><figure class="nn kw no np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/bbf5fe67d30e9a65028a6ce68105a990.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*w0v4CVWTNk74jhYnVEuHXA.png"/></div></figure><figure class="nn kw nt np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/3cd14512a6cfedfffbe401f2d6e6895b.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*oQVgjEkIMt4tx86S-zjd2w.png"/></div></figure><figure class="nn kw nu np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/2b203466039388662df3ee763a24a626.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*aHZLu4dnvTtwCkdGSeODPg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk nv di nw nx translated">这一集中可用的不同点云可以直接在提供的链接下载:研究员桌(。xyz)，汽车(。xyz)、操场(。xyz)。操场是Emm用Everypoint.io生成的(场景)。F. Poux</p></figure></div><p id="f5c6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们想要展示的场景如下:</p><ul class=""><li id="f3c3" class="ny nz it lj b lk ll ln lo lq oa lu ob ly oc mc od oe of og bi translated">🤖机器人:我们正在设计一个机器人，它需要清洁地面和桌子，并确保在清洁时避开障碍物。最重要的是，我们希望检测感兴趣的元素的位置，并将其作为未来清理任务的基础，以了解我们最初是否需要重新定位它们。</li><li id="f8ca" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">🚙ADAS(高级驾驶辅助系统):在这里，我们感兴趣的是让车辆能够自己驾驶:一辆自动驾驶的车辆。为此目的，我们使用威力登VLP-16扫描的一个时期，在此期间我们通常进行实时分析以检测目标。</li><li id="5c70" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">🏚️建筑公司:几年前建造的一个操场由于地基不稳定出现了问题。因此，我们希望评估元素的平面度，并确定是否有必要进行调平操作。</li></ul><p id="2b84" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了确保您的选择，您可以使用<a class="ae om" href="https://app.flyvast.com/flyvast/app/page-snapshot-viewer.html#/566/8f32e130-d775-8989-b574-d1d7cd08d5d0" rel="noopener ugc nofollow" target="_blank"> Flyvast WebGL应用程序</a>在线玩它们，然后在这里(<a class="ae om" href="https://drive.google.com/file/d/1OBgYx5c0-m4DGY1Lz2nl4NR56atvwU1e/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">研究员工作台)下载它们。</a>，【xyz】，<a class="ae om" href="https://drive.google.com/file/d/12dAMGQmET2NIdRCXQxWnhLDf2mZkngEC/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">车子(。【xyz】，</a><a class="ae om" href="https://drive.google.com/file/d/1rakvffprfchT_KmEUNw35GLY5OKC-67W/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">操场(。xyz) </a>)。</p><div class="on oo gp gr op oq"><a href="https://medium.com/@florentpoux/membership" rel="noopener follow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jd gy z fp ov fr fs ow fu fw jc bi translated">通过我的推荐链接加入Medium-Florent Poux博士</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">阅读弗洛伦特·普克斯博士的每一个故事(以及媒体上成千上万的其他作家)。您的会员费直接…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">medium.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe lb oq"/></div></div></a></div><h1 id="c5ee" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">第二步。选择几何模型</h1><p id="286b" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">在之前的一篇文章中，我们定义了RANSAC方法，该文章提出了自动分割和聚类:</p><blockquote class="pf pg ph"><p id="c568" class="lh li pi lj b lk ll kd lm ln lo kg lp pj lr ls lt pk lv lw lx pl lz ma mb mc im bi translated">RANSAC(随机样本一致性)是一种试错法，它将你的数据点分成两个部分:一个内部集和一个外部集。</p></blockquote><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/how-to-automate-3d-point-cloud-segmentation-and-clustering-with-python-343c9039e4f5"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jd gy z fp ov fr fs ow fu fw jc bi translated">如何使用Python实现3D点云分割和聚类的自动化</h2><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pm l pb pc pd oz pe lb oq"/></div></div></a></div><p id="7972" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了实现这一目标，我们采取了三个简单的步骤:</p><ul class=""><li id="dd35" class="ny nz it lj b lk ll ln lo lq oa lu ob ly oc mc od oe of og bi translated">我们选择一个几何模型，它符合我们数据集中的一个微小的随机样本(如果我们想定义一个平面，随机选取3个点)。</li><li id="12ec" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">然后，我们通过检查有多少点“接近”感兴趣的表面来估计拟合的好坏，因此我们得到一个内层计数。</li><li id="a931" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc od oe of og bi translated">我们在一定数量的迭代中重复这个过程，并保留使内层计数最大化的平面。</li></ul><p id="1d88" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这种方法不是火箭科学，而是一种针对嘈杂的真实世界数据集的超级实用的方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi kr"><img src="../Images/c53b64c6da527090f7d0d18b5e9075f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*VoFg74ymh8K2pOY-.gif"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">RANSAC通过多次迭代及其随机计算初始化来工作。来源:<a class="ae om" rel="noopener" target="_blank" href="/how-to-automate-3d-point-cloud-segmentation-and-clustering-with-python-343c9039e4f5"> <strong class="bd pn">如何用Python实现3D点云的自动分割和聚类</strong> </a>，F. Poux</p></figure><p id="8278" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在本教程中，我们选择了:平面几何！这是快速理解大量数据集的最佳方式。但是请容忍我；我现在给你一些重要的数学理解，我们用来描述欧几里得空间中的平面。<strong class="lj jd"> ℝ </strong>中平面的方程的一般形式为<strong class="lj jd"> 𝑎𝑥+𝑏𝑦+𝑐𝑧+𝑑=0 </strong>。</p><p id="a582" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">多美啊🦋。撇开笑不谈，𝑎,𝑏和𝑐常数是垂直于平面或平行于平面的任何向量的法向量<em class="pi">-</em>=(𝑎,𝑏,𝑐)的分量。当你掌握了这一点，玩变换(平移，旋转，缩放)并适应它是超级容易的。d常数将使平面从原点移动。</p><p id="0c56" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">意味着一个点<strong class="lj jd"> <em class="pi"> p </em> = (𝑥,𝑦,𝑧) </strong>属于由法向量<em class="pi">-</em>引导的平面，如果它满足等式。如果你理解了这一点，你就获得了指导几何拟合的第一手原理。太好了！</p><p id="a916" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在让我们用RANSAC到处安装飞机。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi po"><img src="../Images/fd73cac108ada1f3236fb1978defc420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrLAvB9IIKk5l4JxDgh6NA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">操场上的RANSAC飞机汤点云。这几乎是艺术，不是吗😀？F. Poux</p></figure><p id="ebc3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">兰萨克汤，是吗？好的，让我们定义参数使它正常工作。</p><h1 id="acc3" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">第三步。参数定义</h1><p id="d9f8" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">是时候弄脏我们矮小的编码者的手了！而这一次，让我们从零开始编写一个点云<strong class="lj jd">的RANSAC平面检测算法，更好地把握遮光罩下的东西。我们将用两个库来做这件事:<code class="fe pp pq pr nd b">random</code>和<code class="fe pp pq pr nd b">numpy</code>。很难再简约了。为了形象化，我们亲爱的(或甜蜜的敌人😊)<code class="fe pp pq pr nd b">matplotlib</code>和<code class="fe pp pq pr nd b">plotly</code>用于交互式Jupyter笔记本和Google Colab脚本。</strong></p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="de5b" class="nh mf it nd b gy ni nj l nk nl">import random<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>from mpl_toolkits import mplot3d</span><span id="7e56" class="nh mf it nd b gy nm nj l nk nl">import plotly.express as px</span></pre><h2 id="9fa3" class="nh mf it bd mg ps pt dn mk pu pv dp mo lq pw px mq lu py pz ms ly qa qb mu iz bi translated">A.明智地选择数据集</h2><p id="1ce2" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">你选择的武器是什么？我将把我的研究桌作为主要案例研究:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="b41d" class="nh mf it nd b gy ni nj l nk nl">dataset="the_researcher_desk.xyz"<br/>pcd = np.loadtxt(data_folder+dataset,skiprows=1)</span></pre><p id="7e90" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我通过从辐射属性中分离出几何属性来快速准备:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="1121" class="nh mf it nd b gy ni nj l nk nl">xyz=pcd[:,:3]<br/>rgb=pcd[:,3:6]</span></pre><p id="3661" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">好了，现在是时候设置一些参数了。</p><h2 id="adb9" class="nh mf it bd mg ps pt dn mk pu pv dp mo lq pw px mq lu py pz ms ly qa qb mu iz bi translated">B.手动参数设置</h2><p id="245b" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">我们需要定义一个阈值参数来确定一个点是属于拟合的平面形状(内层)还是一个离群点。我们将根据点到平面的距离来区分；因此，我们需要快速掌握点云中的单元。让我们用<code class="fe pp pq pr nd b">matplotlib</code>显示点云:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="a15d" class="nh mf it nd b gy ni nj l nk nl">plt.figure(figsize=(8, 5), dpi=150)<br/>plt.scatter(xyz[:,0], xyz[:,1], c=rgb/255, s=0.05)<br/>plt.title("Top-View")<br/>plt.xlabel('X-axis (m)')<br/>plt.ylabel('Y-axis (m)')<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qc"><img src="../Images/e1f7221d119f43ce45156577d0f454cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AARqDTuTggoo17rwFZ9ZRQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">研究桌面点云的俯视图。F. Poux</p></figure><p id="0a04" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有时，可能很难解释两点之间的区别，尤其是使用Google Colab和非交互式渲染。如果您在这样的场景中，您可以将<code class="fe pp pq pr nd b">plotly</code>与import <code class="fe pp pq pr nd b">plotly.express as px</code>一起使用，然后您可以通过</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="1c6b" class="nh mf it nd b gy ni nj l nk nl">fig = px.scatter(x=xyz[:,0], y=xyz[:,1], color=xyz[:,2])<br/>fig.show()</span></pre><div class="ks kt ku kv gt ab cb"><figure class="nn kw qd np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/d390255c764b58540c8559c72d9e5bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*3vwQAZOH1vOJEXhmCI7xxA.png"/></div></figure><figure class="nn kw qd np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/d2cea18b78abca179214b938ae905c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qHXg4UL7MvohgW_XXhAHCA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk qe di qf nx translated">左边是plotly点云，右边是场景的交互缩放。F. Poux</p></figure></div><p id="99c3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">它允许我们看到，平均来说，每个<code class="fe pp pq pr nd b">5 mm</code>都有相邻点，因此我们将阈值参数设置得高十倍(绝对是经验性的😊):<code class="fe pp pq pr nd b">threshold=0.05</code>。同样，我们将把迭代的次数设置为一个不受限的相当大的数；让我们说<code class="fe pp pq pr nd b">1000 iterations</code>:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="8e8d" class="nh mf it nd b gy ni nj l nk nl">iterations=1000</span></pre><h2 id="fee9" class="nh mf it bd mg ps pt dn mk pu pv dp mo lq pw px mq lu py pz ms ly qa qb mu iz bi translated">C.自动参数设置</h2><p id="3f32" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">我们可能有点受限，需要一些领域知识来设置阈值。因此，尝试绕过这一点向非专家开放这种方法将是令人兴奋的。我将与你分享一个可能有用的简单想法。如果我们计算数据集中各点之间的平均距离，并以此为基础设置阈值，会怎么样？</p><p id="217e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个值得探索的想法。为了尝试确定这样一个值，我们可以使用一个<code class="fe pp pq pr nd b">KD-Tree</code>来加速查询每个点的最近邻居的过程。在流程的这个阶段，我建议使用<code class="fe pp pq pr nd b">scikit-learn</code>实现，并在每个节点将KD树分成两个超平面:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="fb6e" class="nh mf it nd b gy ni nj l nk nl">from sklearn.neighbors import KDTree<br/>tree = KDTree(np.array(xyz), leaf_size=2)  </span></pre><p id="55bb" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们可以使用简单的查询方法查询点云中每个点的k-最近邻:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="0d74" class="nh mf it nd b gy ni nj l nk nl">tree.query(xyz, k=8)</span></pre><p id="880e" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其分别输出点距离和点索引:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/39664b028abaa9c2bd30ba4062ec878f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*NFqMHlDWrF2ufYaiFLepUA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">KD树查询的numpy输出。F. Poux</p></figure><p id="0942" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">🤓<strong class="lj jd">注意</strong> : <em class="pi">最近邻的第一个距离值始终等于</em> <code class="fe pp pq pr nd b"><em class="pi">0</em></code> <em class="pi">。你会问奇怪吗？这是因为我们对整个点云本身进行查询；因此，每个点到自身都有一个距离。因此，我们需要过滤每行的第一个元素:</em> <code class="fe pp pq pr nd b">nearest_dist, nearest_ind = tree.query(xyz, k=8)</code></p><p id="ae4b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">太好了！现在，如果我们对每个邻居候选进行平均，用<code class="fe pp pq pr nd b">np.mean(nearest_dist[:,1:],axis=0)</code>从最近到最远排序，我们得到:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="94ae" class="nh mf it nd b gy ni nj l nk nl">&gt;&gt; array([0.0046, 0.0052 , 0.0059, 0.0067, 0.0074, 0.0081, 0.0087])</span></pre><p id="cf4d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这意味着，如果我们通过考虑最近的邻居进行推理，我们将得到4.6 mm的平均距离。如果我们想要使用<code class="fe pp pq pr nd b">np.mean(nearest_dist[:,1:])</code>获得每个点到其第n个最近邻居的平均距离的局部表示，则在我们的情况下输出<code class="fe pp pq pr nd b">6.7</code> mm。</p><p id="7316" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了让您的实验顺利进行，我建议设置一个查询，使用8到15个点作为邻居，并对其进行平均。因此，它给出了点云中噪声比的良好局部表示。我们将在未来的教程中探索更巧妙的方法来寻找点云的噪波比。😉</p><div class="ks kt ku kv gt ab cb"><figure class="nn kw qh np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/2edfce7c92678d8fb92216e1eac2f960.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*vN4yGgfR_RJC-x36NiYp4Q.png"/></div></figure><figure class="nn kw qi np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/a6ed07248901ec620582cdc6486aefe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*bP05ezZ1iPuIErvgp9pCSA.png"/></div></figure></div><p id="c214" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">🧙‍♂️ <strong class="lj jd">专家</strong> : <em class="pi">有一种自动的方法每次都能得到正确的迭代次数。如果我们希望以概率p(例如99%)成功，我们数据中的异常值比率是e(例如60%)，我们需要s点来定义我们的模型(这里是3)。下面的公式给出了要进行的试验(迭代)次数:</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qj"><img src="../Images/9645e21500c09e27a083e64664b417d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*pwnlSrC9OVfkY_H32OQ_MA.png"/></div></figure><h1 id="a2f5" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">第四步。RANSAC模型拟合</h1><h2 id="85a3" class="nh mf it bd mg ps pt dn mk pu pv dp mo lq pw px mq lu py pz ms ly qa qb mu iz bi translated">A.寻找平面(1次迭代)</h2><p id="b630" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">让我们在自动化指定数量的迭代之前模拟一次迭代。</p><p id="45a3" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">首先，我们要从点云中随机选取三个点:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="5591" class="nh mf it nd b gy ni nj l nk nl">idx_samples = random.sample(range(len(xyz)), 3)<br/>pts = xyz[idx_samples]</span></pre><p id="64dd" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们要确定平面的方程。例如，找到方程𝑎𝑥+𝑏𝑦+𝑐𝑧+𝑑=0.的参数𝑎,𝑏,𝑐和𝑑为此，我们可以玩一个奇妙的线性代数性质，即两个向量的叉积生成一个正交向量。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qk"><img src="../Images/e97ae549da7e9a427da5bda2ac855367.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*eHawhCkyfXun0d7FWuXrkA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">Z向量是X和Y叉积的结果，这符合经验法则😀。F. Poux</p></figure><p id="8911" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因此，我们只需要从平面上的同一点定义两个向量<code class="fe pp pq pr nd b">vecA</code>和<code class="fe pp pq pr nd b">vecB</code>，然后计算它们的法线，这将是平面的法线。多棒啊。</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="1638" class="nh mf it nd b gy ni nj l nk nl">vecA = pts[1] - pts[0]<br/>vecB = pts[2] - pts[0]<br/>normal = np.cross(vecA, vecB)</span></pre><p id="d6d1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">从那里，我们将归一化我们的<code class="fe pp pq pr nd b">normal</code>向量，然后得到定义向量的𝑎,𝑏和𝑐，并使用落在平面上的三个点之一找到𝑑:<em class="pi">d =</em><strong class="lj jd">—</strong>(𝑎𝑥+𝑏𝑦+𝑐𝑧)</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="2c0b" class="nh mf it nd b gy ni nj l nk nl">a,b,c = normal / np.linalg.norm(normal)<br/>d=-np.sum(normal*pts[1])</span></pre><p id="a226" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，我们准备开始计算我们刚刚定义的平面上任何剩余的点💪。</p><h2 id="b3d4" class="nh mf it bd mg ps pt dn mk pu pv dp mo lq pw px mq lu py pz ms ly qa qb mu iz bi translated">B.点到平面的距离:阈值定义</h2><p id="e027" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">如果你相信我的话，下面是我们需要实现的:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ql"><img src="../Images/7e8012496e9550195424cd2911dc49ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*ZFDBYaloBEd0i1eJZNIOSw.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">点到平面的距离用上面的符号表示。点P(见下)到给定平面的距离就是向量w到单位法向量n上的投影长度，我们知道，向量n的长度等于1，点P到平面的距离就是向量w和n的点积的绝对值！F. Poux</p></figure><p id="17aa" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个距离是最短的，是点和平面之间的正交距离，如下图所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qm"><img src="../Images/a8c5039e6c270a2046391ad3398ec823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66oSaqgHSz33NVsVikwGPg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个法线n定义了平面，我们可以看到我们想要计算的点到平面的D距离是什么样子的。F. Poux</p></figure><p id="565d" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这意味着我们可以简单地计算这个距离，只需取点云中的每个点，这些点不是我们在一次Ransac迭代中用来建立平面的三个点的一部分，就像这样:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="bfed" class="nh mf it nd b gy ni nj l nk nl">distance = (a * xyz[:,0] + b * xyz[:,1] + c * xyz[:,2] + d<br/>            ) / np.sqrt(a ** 2 + b ** 2 + c ** 2)</span></pre><p id="624b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">对于我们的随机选择和平面拟合输出:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="3c03" class="nh mf it nd b gy ni nj l nk nl">array([-1.39510085, -1.41347083, -1.410467 , …, -0.80881761, -0.85785174, -0.81925854])</span></pre><p id="b5a1" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">🤓<strong class="lj jd">注意</strong> : <em class="pi">看到负值了？我们必须解决这个问题来得到无符号的距离，因为我们的法线在平面上可以翻转180°。</em></p><p id="d46f" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">非常好！从那里，我们可以对照阈值进行检查，并过滤所有符合标准的点，只保留点到平面距离在<code class="fe pp pq pr nd b">threshold</code>以下的点作为内嵌点。</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="9210" class="nh mf it nd b gy ni nj l nk nl">idx_candidates = np.where(np.abs(distance) &lt;= threshold)[0]</span></pre><p id="e4c8" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">🤓<strong class="lj jd">注意</strong>:<em class="pi"/><code class="fe pp pq pr nd b">[0]</code><em class="pi">允许我们在这一步只处理索引，不要用不必要的点坐标溢出我们的系统。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qn"><img src="../Images/e6663e91ddf7d1564d7ab224f8d439d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9c-rwYWAEfahFmvOtrY7Og.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一次迭代的结果。在青色中，平面适合三个采样点。蓝色表示被选为内线的点，得分为17 772。F. Poux</p></figure><p id="f160" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">你已经知道下一步会是什么了吗？🤔</p><h2 id="1921" class="nh mf it bd mg ps pt dn mk pu pv dp mo lq pw px mq lu py pz ms ly qa qb mu iz bi translated">C.迭代和函数定义</h2><p id="453d" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">的确，我们现在需要迭代一定的次数来找到最优平面！为此，我们将定义一个函数，该函数将输入点<code class="fe pp pq pr nd b">coordinates</code>、<code class="fe pp pq pr nd b">threshold</code>和<code class="fe pp pq pr nd b">iterations</code>的编号作为输入点，并返回平面<code class="fe pp pq pr nd b">equation</code>和点<code class="fe pp pq pr nd b">inliers</code>索引:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="7fc8" class="nh mf it nd b gy ni nj l nk nl">def function(coordinates, threshold, iterations):<br/>  ...<br/>  i=1<br/>  while i &lt; iterations:<br/>    do &lt;&lt;all below&gt;&gt;<br/>    if len(idx_candidates) &gt; len(inliers):<br/>      equation = [a,b,c,d]<br/>      inliers = idx_candidates<br/>    i+=1<br/>  return equation, inliers</span></pre><p id="c0f4" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">🤓<strong class="lj jd">注意</strong> : <em class="pi">我们在迭代参数上创建RANSAC循环。对于每个循环，我们将计算最佳拟合RANSAC平面，并保留方程和内嵌索引。使用</em> <code class="fe pp pq pr nd b">if</code> <em class="pi">语句，我们然后检查当前迭代的得分是否最大，在这种情况下，我们切换点索引。</em></p><p id="7a66" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">现在，让我们填充RANSAC函数，得到如下结果:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="c93e" class="nh mf it nd b gy ni nj l nk nl">def ransac_plane(xyz, threshold=0.05, iterations=1000):<br/>  inliers=[]<br/>  n_points=len(xyz)<br/>  i=1</span><span id="170a" class="nh mf it nd b gy nm nj l nk nl">  while i&lt;iterations:<br/>    idx_samples = random.sample(range(n_points), 3)<br/>    pts = xyz[idx_samples]</span><span id="0a1d" class="nh mf it nd b gy nm nj l nk nl">    vecA = pts[1] - pts[0]<br/>    vecB = pts[2] - pts[0]<br/>    normal = np.cross(vecA, vecB)<br/>    a,b,c = normal / np.linalg.norm(normal)<br/>    d=-np.sum(normal*pts[1])</span><span id="ad9d" class="nh mf it nd b gy nm nj l nk nl">    distance = (a * xyz[:,0] + b * xyz[:,1] + c * xyz[:,2] + d<br/>                ) / np.sqrt(a ** 2 + b ** 2 + c ** 2)</span><span id="40a0" class="nh mf it nd b gy nm nj l nk nl">    idx_candidates = np.where(np.abs(distance) &lt;= threshold)[0]</span><span id="0d81" class="nh mf it nd b gy nm nj l nk nl">    if len(idx_candidates) &gt; len(inliers):<br/>      equation = [a,b,c,d]<br/>      inliers = idx_candidates<br/>    <br/>    i+=1<br/>  return equation, inliers</span></pre><p id="ce4c" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在这里，我们为平面检测创建了一个RANSAC函数，它可以吃掉3D点云！！！！它以这种方式进行了充分的优化，让你可以攻击大的点云，而不会有烧毁电脑的风险🔥！现在，让我们扩展到我们想要分割点云的实际情况。</p><h1 id="2526" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">第五步。点云二值分割</h1><p id="a276" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">这是最后一步！至少在现阶段😀。我们将在两个变量中保留函数的结果:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="5328" class="nh mf it nd b gy ni nj l nk nl">eq,idx_inliers=ransac_plane(xyz,0.01)<br/>inliers=xyz[idx_inliers]</span></pre><p id="fb0b" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">非常好！但现在，我们还想对原始点云进行拆分，高效地抓住离群点。这是一个极好的转机。我们创建一个遮罩，作为快速过滤器来获取不属于内联体的其余点:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="9430" class="nh mf it nd b gy ni nj l nk nl">mask = np.ones(len(xyz), dtype=bool)<br/>mask[idx_inliers] = False<br/>outliers=xyz[mask]</span></pre><p id="5966" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">太棒了！我们现在有了一个内部集合和一个外部集合！让我们用<code class="fe pp pq pr nd b">matplotlib</code>来检验一下结果:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="a552" class="nh mf it nd b gy ni nj l nk nl">ax = plt.axes(projection='3d')<br/>ax.scatter(inliers[:,0], inliers[:,1], inliers[:,2], c = 'cornflowerblue', s=0.02)<br/>ax.scatter(outliers[:,0], outliers[:,1], outliers[:,2], c = 'salmon', s=0.02)<br/>plt.show()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qo"><img src="../Images/23bb4837fcaab681e7cea73a399eaec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*9Fk-f9qJqE_Ya-OrDWy9Gg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">研究桌的3D点云用我们的RANSAC函数分割。F. Poux</p></figure><p id="0cec" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">哇，它非常好用！我们在这个场景中找到了地面！多牛逼啊！最后一件事:分别导出两个数据集:</p><pre class="ks kt ku kv gt nc nd ne nf aw ng bi"><span id="5a93" class="nh mf it nd b gy ni nj l nk nl">result_folder=”../DATA/RESULTS/”<br/>np.savetxt(result_folder+dataset.split(“.”)[0]+”_inliers.xyz”, inliers, fmt=’%1.4f’, delimiter=’;’)<br/>np.savetxt(result_folder+dataset.split(“.”)[0]+”_outliers.xyz”, outliers, fmt=’%1.4f’, delimiter=’;’)</span></pre><p id="06b6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">其他数据集呢？这是我们使用自动阈值方法得到的结果，基于到第15个最近邻居的距离估计！多好啊！</p><div class="ks kt ku kv gt ab cb"><figure class="nn kw qp np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/bbb9ded9ad4b5ca6b7259e72d72941b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*-i9oUUoOyQbQn_0VurjMNg.png"/></div></figure><figure class="nn kw qp np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/11cfc6d19346e97715c490e5654ffb41.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*VRvQIIXkpCaVkhBmd4eNRw.png"/></div></figure><figure class="nn kw qp np nq nr ns paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><img src="../Images/eddb3d22e45a18dce749f3c4a9fcb16b.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*eXzUrUrk4SQhXZs0-i5A3Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk qq di qr nx translated">操场点云被分割，研究桌被分割，威力登adas激光雷达数据集被分割。正如我们所看到的，自动阈值方法允许以100%的自动化有效地处理手头的任务。F. Poux</p></figure></div><p id="d6ea" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">令人着迷的是，我们对噪声和数据环境具有超强的鲁棒性！你值得在这台<a class="ae om" href="https://colab.research.google.com/drive/1sK4tLAKJQ42ePKe71ReCHaYtUW5RTn5m?usp=sharing" rel="noopener ugc nofollow" target="_blank"> Google Colab笔记本</a>上访问和运行完整的代码。尽情享受吧！</p><h1 id="29bd" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论</h1><p id="403c" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">🥳万岁！您从头开始实现了一个完整的RANSAC模型拟合算法，用于平面检测和3D点云分割。最重要的是，您现在可以自动设置RANSAC参数，这样您就不会有99%的自动解决方案，而是100%的自动化。这是重要的一步！如果您想更深入地了解如何在您的项目中包含这项新技能，下面是下一步教程，它将允许您迭代RANSAC方法并使用聚类方法来检测点云中的实例:</p><div class="on oo gp gr op oq"><a rel="noopener follow" target="_blank" href="/how-to-automate-3d-point-cloud-segmentation-and-clustering-with-python-343c9039e4f5"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jd gy z fp ov fr fs ow fu fw jc bi translated">如何使用Python实现3D点云分割和聚类的自动化</h2><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">towardsdatascience.com</p></div></div><div class="oz l"><div class="pm l pb pc pd oz pe lb oq"/></div></div></a></div><p id="c5a6" class="pw-post-body-paragraph lh li it lj b lk ll kd lm ln lo kg lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我的贡献旨在浓缩可操作的信息，以便您可以从零开始为您的项目构建3D自动化系统。你可以从参加<a class="ae om" href="https://learngeodata.eu/" rel="noopener ugc nofollow" target="_blank">地理数据学院</a>的课程开始。</p><div class="on oo gp gr op oq"><a href="https://learngeodata.eu/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd jd gy z fp ov fr fs ow fu fw jc bi translated">3D学院-点云在线课程</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">教师、研究人员、开发人员和工程师的最佳3D在线课程。掌握三维点云处理和…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">learngeodata.eu</p></div></div><div class="oz l"><div class="qs l pb pc pd oz pe lb oq"/></div></div></a></div><h1 id="edc6" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">更进一步</h1><p id="efac" class="pw-post-body-paragraph lh li it lj b lk mw kd lm ln mx kg lp lq my ls lt lu mz lw lx ly na ma mb mc im bi translated">存在用于点云的其他高级分割方法。这是一个我深入参与的研究领域，你已经可以在文章[1-6]中找到一些设计良好的方法。对于更高级的3D深度学习架构，一些综合教程即将推出！</p><ol class=""><li id="b66c" class="ny nz it lj b lk ll ln lo lq oa lu ob ly oc mc qt oe of og bi translated"><strong class="lj jd"> Poux，F. </strong>，&amp; Billen，R. (2019)。基于体素的三维点云语义分割:无监督的几何和关系特征与深度学习方法。ISPRS国际地理信息杂志。8(5), 213;<a class="ae om" href="https://doi.org/10.3390/ijgi8050213" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/ijgi8050213</a>—杰克·丹格蒙德奖(<a class="ae om" href="https://www.geographie.uliege.be/cms/c_5724437/en/florent-poux-and-roland-billen-winners-of-the-2019-jack-dangermond-award" rel="noopener ugc nofollow" target="_blank">链接到新闻报道</a>)</li><li id="d4f9" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc qt oe of og bi translated"><strong class="lj jd"> Poux，F. </strong>，纽维尔，r .，纽约，g .-a .&amp;比伦，R. (2018)。三维点云语义建模:室内空间和家具的集成框架。<em class="pi">遥感</em>，<em class="pi"> 10 </em> (9)，1412。<a class="ae om" href="https://doi.org/10.3390/rs10091412" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/rs10091412</a></li><li id="b75a" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc qt oe of og bi translated"><strong class="lj jd"> Poux，F. </strong>，Neuville，r .，Van Wersch，l .，Nys，g .-a .&amp;Billen，R. (2017)。考古学中的3D点云:应用于准平面物体的获取、处理和知识集成的进展。<em class="pi">地学</em>，<em class="pi"> 7 </em> (4)，96。<a class="ae om" href="https://doi.org/10.3390/GEOSCIENCES7040096" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/GEOSCIENCES7040096</a></li><li id="e616" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc qt oe of og bi translated">Poux，F. ，Mattes，c .，Kobbelt，l .，2020年。室内三维点云的无监督分割:应用于基于对象的分类，摄影测量、遥感和空间信息科学国际档案。第111-118页。<a class="ae om" href="https://doi:10.5194/isprs-archives-XLIV-4-W1-2020-111-2020" rel="noopener ugc nofollow" target="_blank">https://doi:10.5194/ISPRS-archives-XLIV-4-W1-2020-111-2020</a></li><li id="70cd" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc qt oe of og bi translated">Poux，F. ，Ponciano，J.J .，2020。用于3d室内点云实例分割的自学习本体，ISPRS摄影测量、遥感和空间信息科学国际档案。第309-316页。<a class="ae om" href="https://doi:10.5194/isprs-archives-XLIII-B2-2020-309-2020" rel="noopener ugc nofollow" target="_blank">https://doi:10.5194/ISPRS-archives-XLIII-B2-2020-309-2020</a></li><li id="f8ac" class="ny nz it lj b lk oh ln oi lq oj lu ok ly ol mc qt oe of og bi translated">Bassier，m .、Vergauwen，m .、<strong class="lj jd"> Poux、F. </strong>、(2020)。用于建筑物内部分类的点云和网格特征。<em class="pi">遥感</em>。12, 2224.<a class="ae om" href="https://doi:10.3390/rs12142224" rel="noopener ugc nofollow" target="_blank">https://doi:10.3390/RS 12142224</a></li></ol></div></div>    
</body>
</html>