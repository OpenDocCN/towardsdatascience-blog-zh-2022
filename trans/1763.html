<html>
<head>
<title>Learn SQL Server Management Studio — Part 12 Ranking Window Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解SQL Server Management Studio —第12部分排名窗口函数</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learn-sql-server-management-studio-part-12-ranking-window-functions-b66b5e331d7a#2022-04-25">https://towardsdatascience.com/learn-sql-server-management-studio-part-12-ranking-window-functions-b66b5e331d7a#2022-04-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="edd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用SQL获取每个用户的最新记录？循序渐进教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c7078b08ea66ca3cf990db8ad48f6ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/0*aT1P4B65u4d1MBcQ"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">迈克尔·泽兹奇在<a class="ae ku" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="aa0f" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在最后几集里…</h2><p id="ab7a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">你好。欢迎来到SQL和SQL Server Studio系列教程的第12期。我的目标很简单:让你熟悉和适应这个工具和语言。“这有什么关系？”我知道你在问。事实证明，好奇心和副业往往是被新项目选中甚至获得新工作的关键。事实上，您已经使用了一个重要的工具，比如SQL Server Studio，并且编写了一些SQL查询，这将会给您一个清晰的开端。</p><ul class=""><li id="bba8" class="mk ml it lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated"><strong class="lt iu">在第1集</strong>中，我将向您展示<strong class="lt iu">如何设置我们的环境和本地服务器</strong> — <a class="ae ku" rel="noopener" target="_blank" href="/getting-started-with-sql-server-management-studio-part-1-step-by-step-setup-63428650a1e0">第1部分逐步设置SQL Server Studio </a></li><li id="1bba" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">在第2集</strong>中，我们将讲述<strong class="lt iu">如何创建数据库、表</strong>、<strong class="lt iu">和</strong>关于<strong class="lt iu">命名约定的重要注释— </strong> <a class="ae ku" rel="noopener" target="_blank" href="/getting-started-with-sql-server-management-studio-5cd24bb1a87c">第2部分数据库、表&amp;命名约定</a></li><li id="4264" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">在第三集</strong>中，我们介绍了<strong class="lt iu"> CRUD操作</strong>和<strong class="lt iu">主键和外键</strong> — <a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-3-crud-operations-primary-foreign-keys-9d884b32ad70">第三部分CRUD操作，主键&amp;外键</a></li><li id="30ca" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">在第4集</strong>中，我们讨论了<strong class="lt iu">模式&amp;的主要规范化步骤</strong> — <a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-4-schemas-normalization-80bcd6a5258">第4部分模式&amp;规范化</a></li><li id="bf2f" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">在第5集</strong>中，我们覆盖了<strong class="lt iu">存储过程&amp;调度</strong>，这是一个真正的野兽。我怎么强调这将如何促进和自动化你的日常(数据)生活都不为过。<a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-5-stored-procedures-scheduling-88fd9788d314">第五部分存储过程&amp;调度</a></li><li id="91bf" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">在第6集</strong>中，我们介绍了用于ETL 的<strong class="lt iu"> SSIS包，并回顾了如何在两个数据库之间以及一个数据库和Excel之间导入和导出数据。<a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-6-ssis-packages-9438dbc90437">第六部SSIS套餐简介</a></strong></li><li id="45d0" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">在第7集中，我们<strong class="lt iu">将SQL Studio连接到PowerBI </strong>并构建我们的第一个视觉效果。<a class="ae ku" href="http://part%207%20connect%20to%20powerbi%20%26%20first%20visuals/" rel="noopener ugc nofollow" target="_blank">第7部分连接到PowerBI &amp;第一视觉效果</a>。</li><li id="16b8" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">在第8集</strong>中，我们<strong class="lt iu">利用SQL视图</strong>的强大功能，这是一个简单的轻量级工具，用于组合和检索复杂的表。你不会相信没有他们你怎么活下去。<a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-8-leverage-the-views-206fbcef3957">第8部分利用观点</a></li><li id="78bc" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">在第9集中，我们利用临时表，在存储过程中临时存储和检索数据。找出中间结果并以表格形式缓存数据以备后用是非常有用的。在<a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-9-temporary-tables-f69aee616833">第九部分临时表格</a>中了解更多信息</li><li id="0c8a" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">第10集探讨了如何使用存储过程和调度任务将SQL数据导出为CSV文件并通过电子邮件发送。<a class="ae ku" rel="noopener" target="_blank" href="/learn-sql-server-management-studio-part-10-export-tables-by-email-as-csv-29bf2d990656">第10部分通过电子邮件以CSV格式导出SQL查询数据</a></li><li id="3ac1" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated"><strong class="lt iu">第11集</strong>跳入云端，在Azure Cloud中设置服务器和数据库。</li></ul><p id="54fb" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">别忘了回来😉。</p><h2 id="b3aa" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">期待什么？</h2><p id="3b14" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">数据以多种形式出现。在一段时间内，一个数据集(比如一个日志表)可能包含一个用户或一台机器的多条记录。我们怎么可能分割这些数据，只检索给定用户、机器或X的最新时间戳呢？</p><p id="ae20" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">这就是排名窗口函数的用处。它们的语法比我们在其他章节中看到的常规SELECT或CRUD操作要复杂一些(见上文)。老实说，我永远也搞不懂那个语法，总是需要参考我的神圣文本文件😉。</p><p id="0cd2" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">知道如何利用它将解决许多令人头痛的问题，并允许您对记录进行排序并过滤掉不需要的内容。事不宜迟…</p><h2 id="2edd" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h2><p id="8b72" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">我们假设您已经设置好了SQL Server Studio环境。如果你需要任何帮助，请查看上面提到的第一集。</p><p id="8554" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">让我们首先创建一个新表“日志”:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f51e" class="kv kw it ne b gy ni nj l nk nl">CREATE TABLE Logs</span><span id="98da" class="kv kw it ne b gy nm nj l nk nl">(Timestamp datetime,</span><span id="c09d" class="kv kw it ne b gy nm nj l nk nl">Username nvarchar(100))</span></pre><p id="f2d3" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">现在让我们用一些数据填充它:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="bd41" class="kv kw it ne b gy ni nj l nk nl">INSERT INTO [HR_data].[dbo].[Logs]</span><span id="621f" class="kv kw it ne b gy nm nj l nk nl">VALUES</span><span id="fb53" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE(), 'Max'),</span><span id="b9e1" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE()-1, 'Max'),</span><span id="0a01" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE()-2, 'Beth'),</span><span id="940a" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE()-3, 'Beth')</span></pre><p id="73d2" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">让我们添加更多的噪音，通过复制我们刚刚插入的内容。这将插入相同的行，只是时间戳会有几秒钟的差异，这取决于您执行查询的时间。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d44a" class="kv kw it ne b gy ni nj l nk nl">/* This is to add a bit more records/noise in our dataset */</span><span id="3d4f" class="kv kw it ne b gy nm nj l nk nl">INSERT INTO [HR_data].[dbo].[Logs]</span><span id="112d" class="kv kw it ne b gy nm nj l nk nl">VALUES</span><span id="f099" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE(), 'Max'),</span><span id="1a1c" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE()-1, 'Max'),</span><span id="56a4" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE()-2, 'Beth'),</span><span id="4cac" class="kv kw it ne b gy nm nj l nk nl">(GETUTCDATE()-3, 'Beth')</span></pre><p id="540f" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">运行快速选择查询来检查数据集:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5714" class="kv kw it ne b gy ni nj l nk nl">SELECT * FROM [HR_data].[dbo].[Logs]</span></pre><p id="e195" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">这将返回8条记录。</p><h2 id="f836" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">排名窗口功能</h2><p id="257f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">我们如何提取表中任何一个用户的最新时间戳呢？排名窗口功能来拯救我们。这是一个本机T-SQL函数。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ac42" class="kv kw it ne b gy ni nj l nk nl">SELECT Timestamp, Username</span><span id="b306" class="kv kw it ne b gy nm nj l nk nl">ROW_NUMBER() OVER(ORDER BY Timestamp DESC) AS Row#</span><span id="dd2d" class="kv kw it ne b gy nm nj l nk nl">FROM [HR_data].[dbo].[Logs]</span></pre><ul class=""><li id="c999" class="mk ml it lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">我们从选择时间戳和用户名开始。到目前为止一切顺利。</li><li id="0ba6" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">然后我们添加Row_Number()函数，它将为每条记录定义一个行号。</li><li id="8a87" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">OVER()有助于定义我们的目标。在这种情况下，我们将查看时间戳。在OVER()函数中，我们精确地定义了一个ORDER BY，并定义了它是升序(ASC)还是降序(DESC)。</li><li id="fc19" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">最后，我们设置了一个别名，这里将该列称为Row#</li></ul><p id="b0a0" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated"><strong class="lt iu">输出为:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/d260e2bddcd97126ec09e19f954f5b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*hpAYJVIycFKOKh_Mz5-1EA.png"/></div></div></figure><p id="0ff5" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">好吧，至少他们有排名。但是我们需要的是找到任何给定用户的最新时间戳。我们需要在ROW_NUMBER()中添加另一个元素。PARTITION BY的使用将帮助我们对FROM子句引用的数据集进行分区。正如我们在上面看到的，当不使用PARTITION BY时，结果的所有行都被视为一个组。</p><p id="f90d" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">我们可以这样编写我们的查询:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7c31" class="kv kw it ne b gy ni nj l nk nl">SELECT Timestamp, UserName,</span><span id="bb4f" class="kv kw it ne b gy nm nj l nk nl">ROW_NUMBER() OVER(PARTITION BY UserName ORDER BY Timestamp DESC) AS Row#</span><span id="ff68" class="kv kw it ne b gy nm nj l nk nl">FROM [HR_data].[dbo].[Logs]</span></pre><ul class=""><li id="5d00" class="mk ml it lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">OVER子句中添加了PARTITION BY。</li><li id="0c69" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">PARTITION BY要求我们至少定义一列，在我们的例子中，我们按用户名进行分区。</li></ul><p id="b6a6" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated"><strong class="lt iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7228f3b246f0095616ec3f28229c1ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*Xqy9w4YNOymdWJk89M4qrQ.png"/></div></figure><p id="2a5b" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">麦克斯和贝丝各有4张唱片。他们的记录是按时间戳排序的。</p><ul class=""><li id="ee26" class="mk ml it lt b lu mm lx mn le mo li mp lm mq mj mr ms mt mu bi translated">该分区由有针对性的<em class="nt">用户名</em>组成。有两个不同的用户名，ROW_NUMBER()根据分区对这些记录进行排序。</li><li id="904d" class="mk ml it lt b lu mv lx mw le mx li my lm mz mj mr ms mt mu bi translated">这就是为什么Max和Beth的记录从1到4，而我们之前的排名是从1到8。</li></ul><h2 id="6465" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后一步</h2><p id="c8d7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">我们最初的目标是为每个用户获取最新的时间戳。如上面的输出所示，我们知道哪个记录是每个用户的最新记录。只看第# = 1行。我们怎样才能把这些行分离出来呢？嵌套查询将帮助我们。</p><p id="7695" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">我们将首先重用运行良好的内容:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="a44f" class="kv kw it ne b gy ni nj l nk nl">SELECT Timestamp, UserName,</span><span id="440f" class="kv kw it ne b gy nm nj l nk nl">ROW_NUMBER() OVER(PARTITION BY UserName ORDER BY Timestamp DESC) AS Row#</span><span id="a202" class="kv kw it ne b gy nm nj l nk nl">FROM [HR_data].[dbo].[Logs]</span></pre><p id="611b" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">然后，我们用圆括号将它括在另一个SELECT语句中，并为嵌套查询提供别名“x ”:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="893f" class="kv kw it ne b gy ni nj l nk nl">SELECT * FROM</span><span id="7b9a" class="kv kw it ne b gy nm nj l nk nl">(<br/>SELECT Timestamp, UserName,</span><span id="2e57" class="kv kw it ne b gy nm nj l nk nl">ROW_NUMBER() OVER(PARTITION BY UserName ORDER BY Timestamp DESC) AS Row#</span><span id="156f" class="kv kw it ne b gy nm nj l nk nl">FROM [HR_data].[dbo].[Logs]<br/>) x</span></pre><p id="cf95" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">最后一步是添加一个WHERE条件，这样我们只查看Row# = 1:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="7576" class="kv kw it ne b gy ni nj l nk nl">SELECT * FROM</span><span id="17cf" class="kv kw it ne b gy nm nj l nk nl">(<br/>SELECT Timestamp, UserName,</span><span id="092c" class="kv kw it ne b gy nm nj l nk nl">ROW_NUMBER() OVER(PARTITION BY UserName ORDER BY Timestamp DESC) AS Row#</span><span id="cf29" class="kv kw it ne b gy nm nj l nk nl">FROM [HR_data].[dbo].[Logs]<br/>) x<br/>where x.Row# = 1</span></pre><p id="43bf" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated"><strong class="lt iu">输出:</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/17bef3edcc81bac9a3e5ba8ec77d5987.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*jcoFquPRjxNC0kkY4mT1fQ.png"/></div></figure><p id="52b1" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">我们现在有了两个不同用户的两个最新时间戳。任务已完成🙂</p><h2 id="142f" class="kv kw it bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后的话</h2><p id="5255" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz le ma mb mc li md me mf lm mg mh mi mj im bi translated">我们现在掌握了一个新工具，排名窗口功能。这可以解决许多问题，例如，当我们面对相同的行，只是时间戳不同。ROW_NUMBER()结合PARTITION BY将允许我们基于一个或多个属性对数据集进行分区。在我们的例子中是用户名。然后，我们可以根据时间戳对行进行排序。</p><p id="9c8b" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">最后，嵌套查询允许我们挑选出给定的等级。在我们的例子中，我们关注的是rank/row #1，即最近的时间戳。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="3bb5" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">我希望你觉得这篇文章有用，让我知道你的想法，或者如果有我应该涵盖的主题。与此同时，请随时订阅并关注我。下次见！</p><h1 id="b13b" class="oc kw it bd kx od oe of la og oh oi ld jz oj ka lh kc ok kd ll kf ol kg lp om bi translated">快乐编码🎉！</h1></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="ec06" class="pw-post-body-paragraph lr ls it lt b lu mm ju lw lx mn jx lz le na mb mc li nb me mf lm nc mh mi mj im bi translated">感谢阅读！喜欢这个故事吗？<a class="ae ku" href="https://medium.com/@maximegodfroid/membership" rel="noopener"> <strong class="lt iu">加入媒介</strong> </a>可完整访问我的所有故事。</p></div></div>    
</body>
</html>