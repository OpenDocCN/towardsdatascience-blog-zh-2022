<html>
<head>
<title>A Step-by-Step Tutorial to Develop a Multi-Output Model in TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TensorFlow中开发多输出模型的分步教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-step-by-step-tutorial-to-develop-a-multi-output-model-in-tensorflow-ec9f13e5979c#2022-10-14">https://towardsdatascience.com/a-step-by-step-tutorial-to-develop-a-multi-output-model-in-tensorflow-ec9f13e5979c#2022-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/689cea75b878d849cfb31080e15fde70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pAv-adjN7lo2G4NB"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">Pavel Neznanov 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><div class=""/><div class=""><h2 id="7f42" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">有完整的代码</h2></div><p id="59df" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我以前写过几篇关于TensorFlow的教程，其中包括顺序和函数API模型、卷积神经网络、强化神经网络等。在本文中，我们将使用Functional API处理一个模型，但是它将使用一个模型预测两个输出。</p><p id="f1af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你已经知道函数式API是如何工作的，对你来说应该很简单。如果您需要关于函数式API的教程或复习，这篇文章应该会有所帮助:</p><div class="is it gp gr iu lu"><a href="https://regenerativetoday.com/regression-in-tensorflow-using-both-sequential-and-function-apis/" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">TensorFlow中使用顺序API和函数API的回归</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">Tensorflow可以说是深度学习和神经网络领域中最受欢迎的包。我写了一些不同的…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">regenerativetoday.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi ja lu"/></div></div></a></div><p id="ffe4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们深入教程。首先导入必要的包:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6f98" class="ms mt jj mo b gy mu mv l mw mx">import tensorflow as tf<br/>from tensorflow.keras.models import Model<br/>from tensorflow.keras.layers import Dense, Input</span><span id="4bad" class="ms mt jj mo b gy my mv l mw mx">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import confusion_matrix<br/>import itertools</span></pre><p id="7e07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用一个名为auto_clean的公共数据集。请随意从该链接下载数据集。<strong class="la jk">这是一个免费的公共数据集。</strong></p><div class="is it gp gr iu lu"><a href="https://datahub.io/machine-learning/autos#resource-autos" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">汽车</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">DataHub.io by -我们构建能够释放数据潜力的解决方案，让我们从您的解决方案开始吧！了解更多关于我们的信息“现在…</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">数据中心. io</p></div></div><div class="md l"><div class="mz l mf mg mh md mi ja lu"/></div></div></a></div><p id="f247" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，用auto_clean.csv数据创建一个pandas数据框架:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7747" class="ms mt jj mo b gy mu mv l mw mx">df = pd.read_csv('auto_clean.csv')</span></pre><p id="b060" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集有201行和29列。这些是列:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="224b" class="ms mt jj mo b gy mu mv l mw mx">df.columns</span></pre><p id="8bd9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="77a7" class="ms mt jj mo b gy mu mv l mw mx">Index(['symboling', 'normalized-losses', 'make', 'aspiration', 'num-of-doors', 'body-style', 'drive-wheels', 'engine-location', 'wheel-base', 'length', 'width', 'height', 'curb-weight', 'engine-type', 'num-of-cylinders', 'engine-size', 'fuel-system', 'bore', 'stroke', 'compression-ratio', 'horsepower', 'peak-rpm', 'city-mpg', 'highway-mpg', 'price', 'city-L/100km', 'horsepower-binned', 'diesel', 'gas'], dtype='object')</span></pre><p id="250e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据集有一些空值，在本教程中，我将简单地删除有空值的行。有几种不同的方法来处理空值。请随意自己尝试一下。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="c9b9" class="ms mt jj mo b gy mu mv l mw mx">df = df.dropna()</span></pre><p id="9175" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，数据集有196行数据，这不是很多，但让我们看看我们可以用它做什么。</p><p id="ee4f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于这是一个多输出模型，<strong class="la jk">我选择气缸数和价格作为目标变量。</strong>这里，气缸数量是一个分类变量，价格是一个连续变量。你也可以选择两个分类变量或者两个连续变量。</p><h2 id="1685" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">数据准备</h2><p id="16e1" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">对于数据准备，首先，我们需要将分类变量转换为数值。这是我遵循的程序。</p><p id="b9eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">找出数据帧中的数字列:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7b2a" class="ms mt jj mo b gy mu mv l mw mx">num_columns = df.select_dtypes(include=np.number).columns<br/>num_columns</span></pre><p id="df05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="54d5" class="ms mt jj mo b gy mu mv l mw mx">Index(['symboling', 'normalized-losses', 'wheel-base', 'length', 'width', 'height', 'curb-weight', 'engine-size', 'bore', 'stroke', 'compression-ratio', 'horsepower', 'peak-rpm', 'city-mpg', 'highway-mpg', 'price', 'city-L/100km', 'diesel', 'gas'], dtype='object')</span></pre><p id="e66c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的输出显示了数字列名。我们需要将其余的列转换成数字。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="a73b" class="ms mt jj mo b gy mu mv l mw mx">cat_columns = []<br/>for col in df.columns:<br/>    if col not in num_columns:<br/>        cat_columns.append(col)<br/>cat_columns</span></pre><p id="9577" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="4319" class="ms mt jj mo b gy mu mv l mw mx">['make',<br/> 'aspiration',<br/> 'num-of-doors',<br/> 'body-style',<br/> 'drive-wheels',<br/> 'engine-location',<br/> 'engine-type',<br/> 'num-of-cylinders',<br/> 'fuel-system',<br/> 'horsepower-binned']</span></pre><p id="8c3a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我如何将这些列转换成数字的:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="0c5a" class="ms mt jj mo b gy mu mv l mw mx">for cc in cat_columns:<br/>    df[cc] = pd.Categorical(df[cc])<br/>    df[cc] = df[cc].cat.codes</span></pre><p id="7705" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个项目的资料准备就是这么做的。</p><h2 id="38aa" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">数据分割</h2><p id="c3e1" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">对于模型定型，我们不会使用数据集中的所有数据。20%的数据将保留用于验证，20%将用于测试模型的性能。为此，我使用了scikit-learn库中的train_test_split方法:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ba59" class="ms mt jj mo b gy mu mv l mw mx">train, test = train_test_split(df, test_size=0.2, random_state=2)<br/>train, val = train_test_split(train, test_size=0.2, random_state=23)</span></pre><p id="8f68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将把我们的两个输出变量分开，用它们组成一个NumPy数组。</p><p id="c694" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该函数将完成以下任务:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1a32" class="ms mt jj mo b gy mu mv l mw mx">def output_form(data):<br/>    price = data.pop('price')<br/>    price = np.array(price)<br/>    noc = data.pop('num-of-cylinders')<br/>    noc = np.array(noc)<br/>    return (price, noc)</span></pre><p id="c80b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用这个函数来训练、测试和验证数据:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6ccf" class="ms mt jj mo b gy mu mv l mw mx">train_y = output_form(train)<br/>test_y = output_form(test)<br/>val_y = output_form(val)</span></pre><p id="cdbf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将数据标准化是一个很好的做法。因为数据中的不同变量可以在不同的数据范围内。因此，我将使用describe函数，它给出所有变量的计数、平均值、标准差、最小值、第25、第50和第75百分位以及最大值。由此，平均值和标准差将用于标准化数据:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ea9a" class="ms mt jj mo b gy mu mv l mw mx">train_stats = train_stats.transpose()<br/>def norm(x):<br/>    return (x - train_stats['mean']) / train_stats['std']</span></pre><p id="1c90" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们有“norm”函数来标准化数据。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="0f10" class="ms mt jj mo b gy mu mv l mw mx">train_x = norm(train)<br/>test_x = norm(test)<br/>val_x = norm(val)</span></pre><p id="d719" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该从输入特征中删除目标变量。我们以前可以这样做的。但是让我们现在就开始吧:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="22e2" class="ms mt jj mo b gy mu mv l mw mx">train_x = train_x.drop(columns=['price', 'num-of-cylinders'])<br/>test_x = test_x.drop(columns=['price', 'num-of-cylinders'])<br/>val_x = val_x.drop(columns=['price', 'num-of-cylinders'])</span></pre><p id="0fbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经为模型准备好了特征和输出变量。</p><h2 id="e247" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">模型开发</h2><p id="8c9b" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">我们将使用两个函数进行模型开发。基础模型将仅定义密集图层，最终模型将向基础模型添加输出图层。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="35c6" class="ms mt jj mo b gy mu mv l mw mx">def base_model(inputs):<br/>    x= Dense(500, activation='tanh')(inputs)<br/>    x= Dense(500, activation='tanh')(x)<br/>    x= Dense(300, activation='tanh')(x)<br/>    x= Dense(300, activation='tanh')(x)<br/>    x= Dense(300, activation='tanh')(x)<br/>    x= Dense(300, activation='tanh')(x)<br/>    x= Dense(150, activation='tanh')(x)<br/>    x= Dense(150, activation='tanh')(x)<br/>    return x</span><span id="4e91" class="ms mt jj mo b gy my mv l mw mx">def final_model(inputs):<br/>    x = base_model(inputs)<br/>    price = Dense(units='1', name='price')(x)<br/>    <br/>    noc = Dense(units = '5', activation = 'sigmoid', name = 'noc')(x)<br/>    <br/>    model = Model(inputs=inputs, outputs = [price, noc])<br/>    <br/>    return model</span></pre><p id="7a32" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那是我们的模型。现在，训练模型，当然还有测试。</p><h2 id="00e4" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">培训和测试</h2><p id="7960" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">对于训练，需要定义输入和优化器。我将为这个模型和默认的学习率使用adam optimizer。请随意尝试任何其他优化和一些不同的学习率。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="69ec" class="ms mt jj mo b gy mu mv l mw mx">inputs = tf.keras.layers.Input(shape=(27,))</span></pre><p id="0d28" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，将此输入传递给模型:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6045" class="ms mt jj mo b gy mu mv l mw mx">model = final_model(inputs)</span></pre><p id="3548" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于模型编译，对于两个输出变量，将有两个损失函数和两个精度度量。这里的术语“noc”指的是“气缸数量”。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f82a" class="ms mt jj mo b gy mu mv l mw mx">model.compile(optimizer='adam', <br/>             loss = {'price': 'binary_crossentropy',<br/>                    'noc': 'mse'},<br/>             metrics={'price': tf.keras.metrics.RootMeanSquaredError(),<br/>                     'noc': 'accuracy'})</span></pre><p id="5e07" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">训练模型的一切都准备好了。训练开始了。我训练了400个纪元的模型。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7e09" class="ms mt jj mo b gy mu mv l mw mx">history = model.fit(train_x, train_y, <br/>                   epochs=400, validation_data=(val_x, val_y))</span></pre><p id="3325" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是最近三个时期的结果:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="40b6" class="ms mt jj mo b gy mu mv l mw mx">Epoch 398/400<br/>4/4 [==============================] - 0s 11ms/step - loss: 390353.6250 - price_loss: 390342.9688 - noc_loss: 10.6905 - price_root_mean_squared_error: 624.7744 - noc_accuracy: 0.7097 - val_loss: 8178957.5000 - val_price_loss: 8178956.0000 - val_noc_loss: 1.6701 - val_price_root_mean_squared_error: 2859.8875 - val_noc_accuracy: 0.9062<br/>Epoch 399/400<br/>4/4 [==============================] - 0s 12ms/step - loss: 424782.6250 - price_loss: 424775.5625 - noc_loss: 7.0919 - price_root_mean_squared_error: 651.7481 - noc_accuracy: 0.6935 - val_loss: 8497714.0000 - val_price_loss: 8497707.0000 - val_noc_loss: 7.1780 - val_price_root_mean_squared_error: 2915.0828 - val_noc_accuracy: 0.8125<br/>Epoch 400/400<br/>4/4 [==============================] - 0s 11ms/step - loss: 351160.1875 - price_loss: 351145.4062 - noc_loss: 14.7626 - price_root_mean_squared_error: 592.5753 - noc_accuracy: 0.7258 - val_loss: 8427407.0000 - val_price_loss: 8427401.0000 - val_noc_loss: 5.7305 - val_price_root_mean_squared_error: 2902.9985 - val_noc_accuracy: 0.9062</span></pre><p id="f8c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面的结果可以看出，在最后一个时期之后,“气缸数量”的训练精度为72.58%，验证精度为90.62%。</p><blockquote class="nw nx ny"><p id="dbb3" class="ky kz nz la b lb lc kk ld le lf kn lg oa li lj lk ob lm ln lo oc lq lr ls lt im bi translated">虽然看到验证准确性比训练准确性高得多可能看起来有点滑稽，但我们应该记住，数据集非常小，验证数据集只有20%。</p></blockquote><p id="192d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这里打印最终的损耗和准确度指标:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="ebd7" class="ms mt jj mo b gy mu mv l mw mx">loss, price_loss, noc_loss, price_root_mean_squared_error, noc_accuracy = model.evaluate(x=val_x, y=val_y)</span><span id="003c" class="ms mt jj mo b gy my mv l mw mx">print()<br/>print(f'loss: {loss}')<br/>print(f'price_loss: {price_loss}')<br/>print(f'noc_loss: {noc_loss}')<br/>print(f'price_root_mean_squared_error: {price_root_mean_squared_error}')<br/>print(f'noc_accuracy: {noc_accuracy}')</span></pre><p id="857d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="0c48" class="ms mt jj mo b gy mu mv l mw mx">1/1 [==============================] - 0s 18ms/step - loss: 8427407.0000 - price_loss: 8427401.0000 - noc_loss: 5.7305 - price_root_mean_squared_error: 2902.9985 - noc_accuracy: 0.9062<br/><br/>loss: 8427407.0<br/>price_loss: 8427401.0<br/>noc_loss: 5.730476379394531<br/>price_root_mean_squared_error: 2902.99853515625<br/>noc_accuracy: 0.90625</span></pre><h2 id="701a" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">估价</h2><p id="7cbe" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">我们使用训练和验证数据来训练模型。模型从未见过测试数据集。因此，我们将使用测试数据集进行评估。通常，预测函数用于预测任何数据的输出。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="fe0a" class="ms mt jj mo b gy mu mv l mw mx">predictions=model.predict(test_x)</span></pre><p id="b579" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们有两个输出，所以我们可以从如下预测中访问价格预测和no _ of _ clinders:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="495f" class="ms mt jj mo b gy mu mv l mw mx">price_pred = predictions[0]<br/>noc_pred = predictions[1]</span></pre><p id="01be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“气缸数量”的准确率是明确的，但对于价格，没有准确率，因为这是一个连续的变量。价格均方根误差看起来很合理。视觉解读可能会很有趣。</p><p id="80f7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下图显示了同一图中的实际价格和预测价格:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1958" class="ms mt jj mo b gy mu mv l mw mx">plt.figure(figsize=(8, 6))<br/>plt.scatter(range(len(price_pred)), price_pred.flatten(), color='green')<br/>plt.scatter(range(len(price_pred)), test_y[0], color='red')<br/>plt.legend()<br/>plt.title("Comparison of Actual and Predicted Prices", fontsize=18)<br/>plt.show()</span></pre><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d3478fa73389b2f389a4ad99923e6976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*K5RBTWNZhTpGR09GGW6RAA.png"/></div></figure><p id="7b66" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为预测比较接近实际情况。请随意使用其他评估方法来评估模型。我的重点是制作一个关于多输出模型的教程。</p><h2 id="a1a1" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">结论</h2><p id="2948" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">我希望这个教程是有帮助的，你将能够在你的工作或学术项目中使用它。我在这个模型中使用了两个输出变量。如果你有一个更复杂的数据集，请对两个以上的变量自由尝试这种方法。</p><p id="badf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">欢迎在推特上关注我，喜欢我的T2脸书页面。</p><h2 id="df28" class="ms mt jj bd na nb nc dn nd ne nf dp ng lh nh ni nj ll nk nl nm lp nn no np nq bi translated">更多阅读</h2><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/a-complete-guide-for-detecting-and-dealing-with-outliers-bad26b1e92b6"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">检测和处理异常值的完整指南</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">6种检测异常值的方法和4种处理异常值的方法</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="oe l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/what-is-a-recurrent-neural-network-and-implementation-of-simplernn-gru-and-lstm-models-in-keras-f7247e97c405"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">在Keras中实现简单网络、GRU和LSTM模型…</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">什么是递归神经网络以及三种递归神经网络在Tensorflow和</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="of l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/developing-a-convolutional-neural-network-model-using-the-unlabeled-image-files-directly-from-the-124180b8f21f"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">开发一个卷积神经网络模型使用未标记的图像文件直接从…</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">使用图像生成器将图像自动标记为子目录</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="og l mf mg mh md mi ja lu"/></div></div></a></div><div class="is it gp gr iu lu"><a rel="noopener follow" target="_blank" href="/20-very-commonly-used-functions-of-pyspark-rdd-90b8271c25b2"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd jk gy z fp lz fr fs ma fu fw ji bi translated">PySpark RDD的20个非常常用的功能</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">每个功能都用清晰的例子演示</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">towardsdatascience.com</p></div></div><div class="md l"><div class="oh l mf mg mh md mi ja lu"/></div></div></a></div></div></div>    
</body>
</html>