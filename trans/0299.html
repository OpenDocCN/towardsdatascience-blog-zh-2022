<html>
<head>
<title>Python Miniproject: Making the Game of Go from Scratch in PyGame</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python Miniproject:在PyGame中从头开始制作游戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-miniproject-making-the-game-of-go-from-scratch-in-pygame-d94f406d4944#2022-02-12">https://towardsdatascience.com/python-miniproject-making-the-game-of-go-from-scratch-in-pygame-d94f406d4944#2022-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8d6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">围棋这个古老的<a class="ae ko" href="https://en.wikipedia.org/wiki/Go_(game)" rel="noopener ugc nofollow" target="_blank">游戏已经玩了几千年了。围棋的棋盘配置比宇宙中的原子还要多，它是一种非常复杂和抽象的游戏，产生于一套简单的规则。2016年，DeepMind的AlphaGo程序在五局比赛中击败了顶级围棋职业选手Lee Sedol，成为头条新闻。在观看了一部关于AlphaGo-Lee比赛的精彩纪录片后，我认为尝试用Python从头开始编写一个基本的围棋游戏会很有趣。作为一名程序员，做这样有趣的小项目是我自身发展的一个重要部分，所以我希望你喜欢跟着做，并且在处理自己的项目时也有所启发！</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/7acd10aa8d2d8392326ac622258df192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKdP9_SjBhwySN338sL-Mw.jpeg"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">图片来自维基共享(CC BY-SA 4.0)</p></figure><p id="1b1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将探索如何使用Python和PyGame从头开始创建Go。在这个过程中，我们将看到如何使用数据科学中的工具来帮助我们更轻松地编写这个游戏。到文章结束时，你会明白:</p><ul class=""><li id="784d" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">如何用PyGame建立一个基本的游戏图形用户界面</li><li id="a8bc" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何使用集合和itertools编写简洁优雅的代码</li><li id="0e83" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何使用NumPy运算符进行快速矩阵运算</li><li id="6561" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">如何使用Networkx图形库分解复杂问题</li></ul><h2 id="b8a4" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">Go规则快速概述</h2><p id="2be3" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">围棋的规则其实挺简单的。黑白双方轮流将石头放在19x19的棋盘上(其他尺寸也是可以的，但这是标准尺寸)。形成连续链(由网格线连接)的一组宝石组成一组。如果一个或一组石头完全被另一种颜色包围，那么这些游戏被捕获并从棋盘上移走。游戏结束时，石头包围更多领土的玩家获胜。我在这里有意掩饰一些细节，但这是基本要点。我们现在的目标是设计一个程序，允许两名玩家在棋盘上放置石头，同时执行围棋规则，例如禁止非法移动和实施捕捉。</p><h2 id="79d2" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">设计过程</h2><p id="7dd1" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">当处理一个复杂的项目时，将问题分解成容易理解的部分会很有帮助。我试图创建封装和模块化的程序，用不同的功能来处理一个问题的各个子部分。在Go的例子中，我认为我需要函数来完成以下任务:</p><ul class=""><li id="7cbc" class="lf lg it js b jt ju jx jy kb lh kf li kj lj kn lk ll lm ln bi translated">使用PyGame绘制棋盘</li><li id="a8fd" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">在PyGame的(x，y)坐标和19x19网格的离散棋盘位置之间转换</li><li id="f89d" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">根据用户动作(如鼠标点击)更新游戏状态</li><li id="7aa4" class="lf lg it js b jt lo jx lp kb lq kf lr kj ls kn lk ll lm ln bi translated">检查尝试的移动是否有效</li></ul><p id="965e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我尽可能地将游戏的输入/输出与内部游戏状态分开。我创建了一个<code class="fe mr ms mt mu b">Game</code>类，它存储了关于一个给定游戏的所有数据，比如棋盘的状态和每个玩家捕获的石头或“囚犯”的数量。<code class="fe mr ms mt mu b">Game</code>类有一个<code class="fe mr ms mt mu b">draw()</code>函数来处理将棋盘状态呈现给PyGame GUI，还有一个<code class="fe mr ms mt mu b">update()</code>函数来检查用户动作，比如鼠标点击和按键。</p><h2 id="c1f4" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">代码</h2><p id="6b28" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">下面的GitHub库包含了围棋游戏的完整代码。请注意，这只是一个基本的、最基本的实现，缺少许多你可以在Go应用程序和网站中找到的功能，但我选择保持项目简单，专注于本质。您可以看一下代码，然后继续阅读我对一些代码亮点的解释。请随意在GitHub上分叉代码，摆弄它，并留下任何评论或问题。</p><div class="mv mw gp gr mx my"><a href="https://github.com/thomashikaru/gogame/blob/master/gogame.py" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd iu gy z fp nd fr fs ne fu fw is bi translated">gogame/gogame . py at master thomashikaru/gogame</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kz my"/></div></div></a></div><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="725d" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">用PyGame创建一个基本游戏</h2><p id="5e13" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated"><a class="ae ko" href="https://www.pygame.org/docs/" rel="noopener ugc nofollow" target="_blank"> PyGame </a>是一个用于创建基本GUI游戏的Python库。它支持在屏幕上绘制图形、监视鼠标点击和按键、播放声音以及游戏中可能出现的其他操作。导入PyGame后，您可以使用<code class="fe mr ms mt mu b">pygame.init()</code>来初始化一个PyGame GUI。其他有用的函数包括<code class="fe mr ms mt mu b">pygame.mouse.get_pos()</code>获取当前鼠标位置、<code class="fe mr ms mt mu b">blit()</code>向屏幕发送文本、<code class="fe mr ms mt mu b">flip()</code>用新的形状更新屏幕。请查看上面的代码，了解这些PyGame函数在实践中是如何工作的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi np"><img src="../Images/61cf9bdcf9aad2b0eeb2e5f07476e1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXAQp9zyioIzHM__AQwkRw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">我的围棋游戏截图。</p></figure><h2 id="d5c9" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated"><strong class="ak">NumPy操作的魔力</strong></h2><p id="17c1" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">正如你所知，围棋棋盘是一个二维矩阵。NumPy库有很多非常方便的函数来处理数组和矩阵。</p><p id="c9ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了生成均匀间隔的网格线，我使用了<code class="fe mr ms mt mu b">np.linspace()</code>和<code class="fe mr ms mt mu b">np.full()</code>函数。第一个函数<code class="fe mr ms mt mu b">np.linspace()</code>在给定的起始值和结束值之间创建一个等距值列表。同时，<code class="fe mr ms mt mu b">np.full()</code>创建一个所需形状的相同值的数组。这允许我快速地为形成围棋棋盘网格的线段生成一组起点和终点，然后我将它们输入到<code class="fe mr ms mt mu b">pygame.draw.line()</code>函数中。</p><p id="4f4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个非常有用的NumPy函数是<code class="fe mr ms mt mu b">np.where()</code>函数，它返回某个条件为真的数组中的索引。例如，行<code class="fe mr ms mt mu b">np.where(self.board == 1)</code>返回存储值1的棋盘位置(在我的游戏惯例中，这表示存在黑石)。</p><h2 id="4b1d" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">Itertools和集合</h2><p id="3113" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">我使用了<code class="fe mr ms mt mu b">itertools.product()</code>来替换嵌套的for循环。例如，要快速创建Go棋盘上所有网格点的列表(例如(0，0)到(18，18))，我可以使用<code class="fe mr ms mt mu b">itertools.product(range(19), range(19))</code>。</p><p id="f8f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与此同时，我使用<code class="fe mr ms mt mu b">collections.defaultdict()</code>创建了一个分数计数器，它优雅地处理递增，即使是空的。第<code class="fe mr ms mt mu b">self.prisoners = collections.defaultdict(int)</code>行创建了一个类似于Python字典的数据结构，除了当一个键第一次访问字典时，它被赋予一个相应的值0。我喜欢使用<code class="fe mr ms mt mu b">defaultdicts</code>让我的代码对键错误更加健壮，而不必编写一堆特殊的边缘情况检查。</p><h2 id="ff41" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">用图论方法识别石材群</h2><p id="c720" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">围棋游戏的一个基本单位是石头群。一群石头同生共死。当一群石头被完全包围时，所有的石头都可以被一次捕获。但是只要一组中的一块石头至少有一个自由空间(未被占据的相邻棋盘空间)，整个组就仍然活着。</p><p id="dfab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了我们的游戏程序的目的，我们有下面的数学问题:给定一个填充有三个不同值(0代表空白，1代表黑石，2代表白石)的N×N矩阵，产生每种颜色的石头组的列表，其中每个石头组是一个石头列表，使得该组中的所有石头形成一个连续的块。这个描述可能有点难以理解，所以请参考下图，看看你能不能算出每种颜色有多少个石组。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi nq"><img src="../Images/ae0644d1654ddd9209d3aabfd2cbbcf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWY_jRVg9ZI0TF8tsbL9Jw.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">每种颜色有多少组石头？</p></figure><p id="8617" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正确答案是有6个黑石组和2个白石组。不要被对角线方向放置的3块黑色石头误导——它们彼此不相连，因为它们没有通过网格线直接连接，所以每块石头都是自己的石头组。我很快意识到，编写一个程序来获取一个游戏板并自动找到所有的石头组并不简单，因此我开始考虑是否可以将这个问题简化为一个已经存在算法的现有问题。</p><p id="548e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现使用图论和<a class="ae ko" href="https://networkx.org/documentation/stable/reference/index.html" rel="noopener ugc nofollow" target="_blank"> Networkx图形库</a>得到了一个惊人的解决石头群计数问题的优雅方案。假设我们想找到所有的黑石组。基本的直觉是，我们从一个“网格图”开始，它看起来就像围棋棋盘的网格:每个顶点都连接到它上面、下面、左边和右边的顶点。然后我们移除所有没有黑色石头的顶点。这给我们留下了一个图，其中连接的组件直接对应于石头组！我们可以简单的用Networkx内置的<code class="fe mr ms mt mu b">connected_components()</code>函数返回答案！使用这个函数，我现在可以实现在游戏中检测捕获的代码。这意味着游戏将自动检测何时石头群被包围，将他们从棋盘上移除，并相应地增加囚犯的数量。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d60f865e0834140d8bdf1904322bcfb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*yaIlRbFvFqOkMdlcuRozjw.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">游戏现在可以检测石头群的捕获并更新棋盘。</p></figure><h2 id="bc96" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">后续步骤</h2><p id="7569" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">试用过代码的严肃围棋玩家可能已经注意到，游戏并没有100%完成。这个游戏并没有执行Ko的规则，不允许玩家重复之前的游戏位置。如果能在游戏结束时自动计算分数，以及像“撤销”这样的便利功能，那就更好了。最后(这是一个很大的挑战)，如果有一个人工智能可以对抗一个单独的人类玩家，那就太好了，因为现在这个游戏需要两个人类玩家。</p><p id="f1de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢阅读我用Python构建围棋游戏的经历，并且在这个过程中你学到了一些新东西。如果您有任何其他建议或反馈，请在下面留下评论！</p><h2 id="a815" class="lt lu it bd lv lw lx dn ly lz ma dp mb kb mc md me kf mf mg mh kj mi mj mk ml bi translated">参考</h2><p id="74a9" class="pw-post-body-paragraph jq jr it js b jt mm jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">[1] PyGame文档:<a class="ae ko" href="https://www.pygame.org/docs/" rel="noopener ugc nofollow" target="_blank">https://www.pygame.org/docs/</a></p><p id="97d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[2] Networkx文档:<a class="ae ko" href="https://networkx.org/documentation/stable/reference/index.html" rel="noopener ugc nofollow" target="_blank">https://Networkx . org/Documentation/stable/reference/index . html</a></p><p id="3a6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">[3]看看这部关于AlphaGo与Lee Sedol比赛的精彩纪录片:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="ns no l"/></div></figure></div></div>    
</body>
</html>