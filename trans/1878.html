<html>
<head>
<title>Grid Search VS Random Search VS Bayesian Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">网格搜索VS随机搜索VS贝叶斯优化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/grid-search-vs-random-search-vs-bayesian-optimization-2e68f57c3c46#2022-05-02">https://towardsdatascience.com/grid-search-vs-random-search-vs-bayesian-optimization-2e68f57c3c46#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="be5e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哪种超参数调优方法最好？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef2e645a8098d297d3afb7fb06cd5286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufCl0zSKGzBNPttN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@denisseleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·莱昂</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bc26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超参数调整是开发稳健预测模型的重要步骤。毕竟，坚持使用默认参数会阻止模型达到最佳性能。</p><p id="7691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就引出了一个问题:对于给定的模型，什么方法最适合寻找最优的超参数？</p><p id="4286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们深入研究3种流行的超参数调优方法，并确定哪一种更优越。</p><h2 id="ab92" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">网格搜索</h2><p id="e096" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">网格搜索是最常见的超参数调整方法，因为它的过程简单明了。这是一个<em class="mt">未知的</em>搜索方法，这意味着它不会从之前的迭代中学习。</p><p id="9f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法需要在搜索空间中测试每个超参数的唯一组合<em class="mt">，以确定产生最佳性能的组合。</em></p><p id="8e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种暴力方法的好处显而易见；有什么比尝试所有方法更好的方法来找到最佳解决方案呢？</p><p id="e200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这种方法扩展性不好；超参数搜索空间大小的增加将导致运行时间和计算的指数增长。</p><h2 id="d6f8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">随机搜索</h2><p id="ebe6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">随机搜索也是一种独立处理迭代的无信息搜索方法。</p><p id="4313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它不是在搜索空间中搜索所有超参数集，而是随机评估特定数量的超参数集。这个数字由用户决定。</p><p id="95a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它在超参数调整中执行较少的试验，该方法比网格搜索需要更少的计算和运行时间。</p><p id="04f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，由于随机搜索随机测试超参数集，它冒着错过理想的超参数集和放弃峰值模型性能的风险。</p><h2 id="b6e7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">贝叶斯优化</h2><p id="b44a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与独立处理超参数集的网格搜索和随机搜索不同，贝叶斯优化是一种<em class="mt">通知</em>的搜索方法，这意味着它从以前的迭代中学习。这种方法中的试验次数由用户决定。</p><p id="32fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，该过程基于贝叶斯定理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/e59552d550f0d070d23c425849dc5d70.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/1*FXULapHwrHuSAOaQ892HWA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贝叶斯定理</p></figure><p id="5cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个用例，该定理可以修改如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/c895006381c2f1d3349e9e80090e06c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/1*fVMoZ8u0m6_FjBtttQPCIw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">贝叶斯定理(修正)</p></figure><p id="c989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单来说，这种方法创建了一个概率模型，在这个模型中，它将超参数映射到它们对应的得分概率。</p><p id="2c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贝叶斯优化方法可以<em class="mt">收敛</em>到最优超参数，而不是费力地尝试每个超参数集或随机测试超参数集。因此，无需探索整个样本空间就可以获得最佳超参数。</p><p id="4e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用贝叶斯优化方法，用户不必忍受评估每个超参数集所带来的长时间运行。它们也不必包含随机性和错过最优解的风险。</p><p id="81e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，贝叶斯优化确实有自己的缺点。因为这是一种有根据的学习方法，所以需要额外的时间来确定下一个超参数，以基于先前迭代的结果进行评估。以减少试验次数为代价，贝叶斯优化每次迭代需要更多的时间。</p><h2 id="beb6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">个案研究</h2><p id="1883" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们已经探讨了三种超参数调优方法的细节。为了巩固我们对这些方法的理解，最好用一个例子。</p><p id="0102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用这三种方法来微调分类模型，并确定哪一种方法产生的结果最好。</p><p id="71d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本练习中，我们将使用来自Sklearn模块的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_digits.html" rel="noopener ugc nofollow" target="_blank">负载数字</a>数据集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2ac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是用网格搜索、随机搜索和贝叶斯优化来微调随机森林模型。</p><p id="3b99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每种方法都将基于以下因素进行评估:</p><ul class=""><li id="d397" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">执行的试验总数</li><li id="5377" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">产生最佳超参数所需的试验次数</li><li id="1e6b" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">模型的分数(本例中为f-1分数)</li><li id="f4bd" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">运行时间</li></ul><p id="b8e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机森林分类器对象和搜索空间如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="41a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总共有810种独特的超参数组合。</p><ol class=""><li id="d00e" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nm ne nf ng bi translated"><strong class="lb iu">网格搜索</strong></li></ol><p id="8dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们使用网格搜索方法获得最佳超参数，并对该过程进行计时。当然，这意味着我们将测试所有810个超参数集，并挑选出产生最佳结果的一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="43ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。随机搜索</strong></p><p id="8a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将使用随机搜索来确定最佳超参数，并对该过程进行计时。搜索限于100次尝试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e396" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。贝叶斯优化</strong></p><p id="a95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们使用贝叶斯优化执行超参数调整，并对该过程进行计时。在Python中，这可以通过<a class="ae ky" href="https://optuna.org/" rel="noopener ugc nofollow" target="_blank"> Optuna </a>模块来完成。</p><p id="d35a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的语法与Sklearn不同，但它执行相同的操作。</p><p id="1b51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了保持一致性，我们也将在此过程中使用100次试验。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经用所有三种方法执行了超参数调优，让我们看看每种方法的结果如何相互比较。</p><p id="4ade" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为方便起见，我们将所有3个超参数调整程序的结果存储在一个数据框中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/cb379abff3e378e897d37bb97e3f5888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FlrKzOpSg0f_tsfvD6J2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="2d40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网格搜索记录了最高分(与贝叶斯优化方法结合)。然而，该方法需要进行810次试验，并且仅设法在第680次迭代时获得最佳超参数。此外，它的运行时间远远超过了随机搜索和贝叶斯优化方法。</p><p id="dd61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随机搜索方法仅需要100次尝试，并且仅需要36次迭代来找到最佳超参数集。它的执行时间也最少。然而，随机搜索法在3种方法中得分最低。</p><p id="71c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">贝叶斯优化也进行了100次试验，但仅经过67次迭代就能够获得最高分，远远低于网格搜索的680次迭代。尽管它执行的试验次数与随机搜索相同，但它的运行时间更长，因为它是一种明智的搜索方法。</p><h2 id="b919" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">哪种方法最好？</h2><p id="5f62" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设网格搜索、随机搜索和贝叶斯优化在运行时间、迭代次数和性能之间都有各自的权衡，那么真的有可能就哪种方法是最好的达成共识吗？</p><p id="dad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大概不会。</p><p id="1f35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟，理想的超参数调优方法取决于用例。</p><p id="069e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问问你自己:</p><ul class=""><li id="704e" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">你的机器学习任务的约束是什么？</li><li id="ae0c" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">您的项目优先考虑最大化性能还是最小化运行时间和/或迭代次数？</li></ul><p id="ffba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回答这些问题将有助于决定最合适的超参数优化方法。</p><p id="e5b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果计算需求和运行时间不是限制因素，网格搜索是理想的。</p><p id="f2c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您愿意牺牲性能来换取更少的迭代和更短的运行时间，那么随机搜索是合适的(理论上，随机搜索可以找到最佳的超参数，但这完全取决于运气)。</p><p id="9c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望通过较少的试验获得最佳超参数，但希望每次迭代运行时间更长，那么贝叶斯优化是最佳选择。</p><h2 id="e1f7" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">我的2美分</h2><p id="fdb8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你讨厌外交答案，只想听听我的个人意见，我会说我通常倾向于贝叶斯优化。</p><p id="d574" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到用更大的训练数据集和搜索空间来微调模型所需的运行时间，我通常会避开网格搜索。随机搜索需要较少的迭代，是所有3种方法中最快的，但其成功程度取决于随机选择的超参数集。在某些情况下，它会选择最优的超参数；在其他情况下，它将完全忽略最优超参数。由于这种不一致性，我不喜欢依赖随机性来完成更大的机器学习任务。</p><p id="78a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢贝叶斯优化方法，因为它能够以较少的迭代次数持续获得最佳超参数。它的单个迭代可能比那些不知情的搜索方法花费更多的时间，但这对我来说很少是一个交易破坏者。</p><h2 id="5fb3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/b86dd55544f60888ece46fe67a71f3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fUOdjnotvBUZYq2y"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Prateek Katyal </a>拍摄</p></figure><p id="3d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从该分析中得出的主要结论是，每种超参数调优方法在运行时间、迭代次数和性能之间都有自己独特的权衡。</p><p id="3ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，对你来说最好的方法将取决于你的优先权和约束。对数据和目标的深刻理解将确保您做出正确的决策。</p><p id="f594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我祝你在数据科学的努力中好运！</p></div></div>    
</body>
</html>