<html>
<head>
<title>Building a Health Entity labelling service using Azure Kubernetes Service, Seldon Core and Azure Cognitive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure Kubernetes服务、Seldon Core和Azure Cognitive构建健康实体标签服务</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-health-entity-labelling-service-using-azure-kubernetes-service-seldon-core-and-azure-5dd6871a338#2022-06-16">https://towardsdatascience.com/building-a-health-entity-labelling-service-using-azure-kubernetes-service-seldon-core-and-azure-5dd6871a338#2022-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="29eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在本教程中，我们将在Azure生态系统中完全用Kubernetes构建一个推理服务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b70b9538231a625614a5aae78de49780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j3i_1OCsXSLg27z837uS0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/multi-colored-folders-piled-up-159519/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>拍摄</p></figure><p id="764e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本教程中，我们将使用以下技术:</p><ul class=""><li id="76c0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://azure.microsoft.com/en-us/services/kubernetes-service/" rel="noopener ugc nofollow" target="_blank"> AKS </a> : Azure云上的Azure Kubernetes服务作为我们部署ML模型的平台</li><li id="5838" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.seldon.io/solutions/open-source-projects/core" rel="noopener ugc nofollow" target="_blank"> Seldon core </a>:开源平台，用于在Kubernetes上快速部署机器学习模型</li><li id="96ee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.terraform.io/cdktf" rel="noopener ugc nofollow" target="_blank"> cdktf </a> <strong class="lb iu"> : </strong>将允许我们用python在Azure cloud中构建基础设施</li><li id="7362" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一个<a class="ae ky" href="https://azure.microsoft.com/en-us/services/cognitive-services/" rel="noopener ugc nofollow" target="_blank"> zure认知服务</a><strong class="lb iu">:</strong>Azure中现成的AI服务，可以通过API访问</li><li id="8252" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/openshift/source-to-image" rel="noopener ugc nofollow" target="_blank"> s2i </a>:一个用于从源代码创建docker图像的命令行工具</li><li id="a2a7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">Istio:一个开源项目，Istio使组织能够保护、连接和监控微服务</li></ul><p id="210a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；DR:代码在</strong><a class="ae ky" href="https://github.com/BogdanCojocar/medium-articles/tree/master/aks_seldon" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">GitHub</strong></a><strong class="lb iu">上。</strong></p><p id="4a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将在Azure中部署一个健康搜索实体推理服务。我们将使用cdktf部署基础设施，并将编写一个seldon核心模型，该模型将与Azure认知服务API进行交互，以分析健康数据。我们还将使用helm在AKS和其他各种依赖中安装seldon核心。我们假设您已经在您的环境中安装了kubectl、helm和azure CLI，并且您能够在基于linux的终端中运行这里显示的大多数命令。</p><h1 id="3df7" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">步骤1:编写azure基础设施</h1><p id="696c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了构建和部署基础设施，我们需要访问azure帐户(免费试用注册可用<a class="ae ky" href="https://azure.microsoft.com/en-us/free/" rel="noopener ugc nofollow" target="_blank">此处</a>)和安装在我们环境中的cdktf。我们可以使用brew实现这一目的:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4c7e" class="nl mk it nh b gy nm nn l no np">brew install cdktf</span></pre><p id="bd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在我们可以开始编码了。在cdktf中，我们需要做的第一件事是创建包含所有azure组件的主类，我们称之为<strong class="lb iu"> MLAzureStack: </strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们需要从<strong class="lb iu"> TerraformStack </strong>继承，还需要创建一个<strong class="lb iu">azuremprovider</strong>来帮助与azure cloud APIs进行通信，以便构建所需的基础设施。</p><p id="fbbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将创建一个资源组。这是一个逻辑容器，将容纳我们部署的所有基础架构。这是一个将你所有的资源组合在一起的好方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用一个类<strong class="lb iu"> StackVariables </strong>的vars实例，它将保存我们基础设施的所有自定义值。请访问github repo了解有关这方面的详细信息。</p><p id="9b49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一部分中，我们将创建Kubernetes集群。我们将创建一个包含2个节点和D2 V4虚拟机的基本集群，足以托管Seldon Core和Istio安装。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="1992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要创建负责文本分析API的认知帐户，该API将运行用于标记新数据的健康实体服务。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须用我们的代码创建一个docker容器，这个容器必须托管在Azure中。为此，我们将创建一个容器注册表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要的最后一项基础设施是创建一个密钥库。基本上，我们有敏感的信息，我们希望安全地存储。为此，我们创建了一个密钥库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在KeyVault中，我们可以定义我们希望给予新的秘密和密钥的权限。我们还创建了两个存储库秘密，用于保存认知访问密钥和端点。访问健康实体服务API需要这些值。</p><p id="8049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经准备好部署Azure堆栈了。我们需要从终端运行cdktf deploy命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="061e" class="nl mk it nh b gy nm nn l no np">cdktf deploy</span></pre><p id="f1c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将初始化terraform提供程序并部署声明的资源:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/8e0071eadf3c276f6106b041f220fd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxxpn6TJ_DUgScyo8w1W2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b33d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们导航到azure门户，我们应该看到在资源组中创建的所有资源:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/9f999ba5dd2d2546ccb1bc9fe5fd1952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZK-SH4eUGfjE_xHjsbHKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="e804" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">步骤2:编写谢顿核心模型</h1><p id="28d3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这一节中，我们将编写谢顿模型，该模型将接收新的请求，如果遇到新的请求，将发回带标签的健康数据。</p><p id="54f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个<code class="fe nu nv nw nh b">health_entity</code>类，它有一个<code class="fe nu nv nw nh b">__init__</code>方法和一个<code class="fe nu nv nw nh b">predict</code>方法，基本上负责处理请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在构造函数中，我们连接到KeyVault，得到我们之前定义的秘密。我们使用这些参数来创建一个负责处理ML请求的<code class="fe nu nv nw nh b">TextAnalyticsClient</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c4c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nu nv nw nh b">predict</code>方法中，我们将数据请求传递给医疗azure客户端。我们从API中取回一些<code class="fe nu nv nw nh b">entities</code>和一些在它们之间定义的<code class="fe nu nv nw nh b">relationships</code>。我们创建一个JSON响应，将所有信息返回给用户。</p><p id="fb9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们定义了<code class="fe nu nv nw nh b">health_entity.py</code>的文件夹中，我们还必须创建另一个文件<code class="fe nu nv nw nh b">.s2i/environment</code>，它将包含docker映像中Seldon使用的所有环境变量。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="87a7" class="nl mk it nh b gy nm nn l no np">MODEL_NAME=HealthModel<br/>API_TYPE=REST<br/>SERVICE_TYPE=MODEL<br/>PERSISTENCE=0</span></pre><p id="aa34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们将创建一个标准模型，并为REST请求提供服务。GRPC也得到支持。</p><h1 id="a16b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">步骤3:在AKS中安装Seldon核心</h1><p id="d1c8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了能够在AKS中部署谢顿模型，我们需要在集群中安装一些东西。我们将需要azure cli、helm和kubectl来运行一些安装脚本。</p><p id="a66a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将kubectl连接到Azure集群，我们需要在kube配置文件中添加所需的凭证:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="685f" class="nl mk it nh b gy nm nn l no np">az aks get-credentials --resource-group aksseldonml-rg --name aksseldonml-aks --admin</span></pre><p id="f860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以测试这是否可行，使用<code class="fe nu nv nw nh b">kubectl get ns</code>检查集群中可用的名称空间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/693d22e46ef20caa82a6817b91067959.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*R36uzj-b5KXeI5ebTPk2Qw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4b8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢顿核心需要的下一个组件是istio。首先，我们需要使用以下方式下载它:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0f13" class="nl mk it nh b gy nm nn l no np">curl -L <a class="ae ky" href="https://istio.io/downloadIstio" rel="noopener ugc nofollow" target="_blank">https://istio.io/downloadIstio</a> | sh -</span></pre><p id="991c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移动到istio包目录并将其添加到您的路径中，以便能够使用istio命令行实用程序<code class="fe nu nv nw nh b">istioctl</code>:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ccb9" class="nl mk it nh b gy nm nn l no np">cd istio-1.11.4 <br/>export PATH=$PWD/bin:$PATH</span></pre><p id="d70d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在集群上安装istio:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="f2e7" class="nl mk it nh b gy nm nn l no np">istioctl install --set profile=demo -y</span></pre><p id="e808" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名称空间标签<code class="fe nu nv nw nh b">istio-injection=enabled</code>指示Istio自动注入代理以及我们在该名称空间中部署的任何东西。我们将为包含推理模型的<code class="fe nu nv nw nh b">seldon</code>名称空间设置它:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="6cc1" class="nl mk it nh b gy nm nn l no np">kubectl create namespace seldon<br/>kubectl label namespace seldon istio-injection=enabled</span></pre><p id="c43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让Seldon Core使用Istio mesh，我们需要创建一个Istio网关，帮助将流量导入mesh:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="612f" class="nl mk it nh b gy nm nn l no np">kubectl apply -f - &lt;&lt; END<br/>apiVersion: networking.istio.io/v1alpha3<br/><strong class="nh iu">kind</strong>: Gateway<br/><strong class="nh iu">metadata</strong>:<br/>  <strong class="nh iu">name</strong>: seldon-gateway<br/>  <strong class="nh iu">namespace</strong>: istio-system<br/><strong class="nh iu">spec</strong>:<br/>  <strong class="nh iu">selector</strong>:<br/>    <strong class="nh iu">istio</strong>: ingressgateway<br/>  <strong class="nh iu">servers</strong>:<br/>  - <strong class="nh iu">port</strong>:<br/>      <strong class="nh iu">number</strong>: 80<br/>      <strong class="nh iu">name</strong>: http<br/>      <strong class="nh iu">protocol</strong>: HTTP<br/>    <strong class="nh iu">hosts</strong>:<br/>    - "*"<br/>END</span></pre><p id="9f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想检查是否所有的Istio组件安装正确，我们可以运行<code class="fe nu nv nw nh b">kubectl -n istio-system get all</code>，我们应该有类似的东西:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/168233539a6e692aa3fe185ab2e42e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2U4cEnUtap3h2DF-gHAvTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="193f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在安装Seldon之前，我们需要创建一个命名空间来托管它:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="b6ac" class="nl mk it nh b gy nm nn l no np">kubectl create namespace seldon-system</span></pre><p id="a386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以使用helm安装谢顿核心:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="7518" class="nl mk it nh b gy nm nn l no np">helm install seldon-core seldon-core-operator \<br/>    --repo <a class="ae ky" href="https://storage.googleapis.com/seldon-charts" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/seldon-charts</a> \<br/>    --set usageMetrics.enabled=true \<br/>    --set istio.enabled=true \<br/>    --namespace seldon-system</span></pre><p id="2ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nu nv nw nh b">kubectl -n seldon-system get pods:</code>检查Seldon控制器是否正在运行</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/828f4bb6e0e9d12da6ae61a714264c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNTfjreRodayHyul8n3JWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="8571" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">步骤4:部署Seldon health服务</h1><p id="ab26" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">不需要。我们已经设置好了环境，可以进行部署。我们将使用<code class="fe nu nv nw nh b">s2i</code>来构建docker映像。要安装它，我们可以运行:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="e8bd" class="nl mk it nh b gy nm nn l no np">brew install source-to-image</span></pre><p id="f532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用<code class="fe nu nv nw nh b">seldonio/seldon-core-s2i-python36:1.14.0-dev</code>作为基础构建一个docker映像。我们将把我们的新图像命名为<code class="fe nu nv nw nh b">seldon-health:0.1</code></p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="fd21" class="nl mk it nh b gy nm nn l no np">s2i build . seldonio/seldon-core-s2i-python36:1.14.0-dev seldon-health:0.1</span></pre><p id="7c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要登录到我们在步骤1中创建的Azure容器。这将允许我们在注册表中推送新的映像。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c9c1" class="nl mk it nh b gy nm nn l no np">az acr login --name seldonservice</span></pre><p id="80db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要标记图像，然后才能将其推送到Azure:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="a7f2" class="nl mk it nh b gy nm nn l no np">docker tag seldon-health:0.1 seldoncontainerregistry.azurecr.io/seldon-health:0.1</span></pre><p id="319f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以将图像发送到容器注册表中:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="53f1" class="nl mk it nh b gy nm nn l no np">docker push seldoncontainerregistry.azurecr.io/seldon-health:0.1</span></pre><p id="46e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦图像在azure容器中，我们就可以使用kubectl部署seldon模型。kubernetes清单包含我们刚刚部署的图像:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="dee9" class="nl mk it nh b gy nm nn l no np">kubectl apply -f - &lt;&lt; END<br/>apiVersion: machinelearning.seldon.io/v1<br/>kind: SeldonDeployment<br/>metadata:<br/>  name: seldon-health<br/>  namespace: seldon<br/>spec:<br/>  name: seldon-health<br/>  predictors:<br/>  - componentSpecs:<br/>    - spec:<br/>        containers:<br/>        - name: classifier<br/>          image: seldoncontainerregistry.azurecr.io/seldon-health:0.1<br/>    graph:<br/>      name: classifier<br/>    name: default<br/>    replicas: 1<br/>END</span></pre><p id="0bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nu nv nw nh b">kubectl -n seldon get pods:</code>来验证部署是否成功</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/5f4bff4c4ef8550271433a3e6ef9796b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dGe7AQ6EMo6yHzZVS6h4rQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="973a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">步骤5:测试健康服务</h1><p id="190a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们可以用两种方式来测试健康服务。首先，我们将使用<code class="fe nu nv nw nh b">seldon-core-microservice</code> CLI在本地测试代码，我们还将在AKS上测试部署。</p><p id="385f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要安装带有pip的seldon core CLI:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9633" class="nl mk it nh b gy nm nn l no np">pip install seldon-core</span></pre><p id="e27d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在一个单独的终端上我们可以运行一个本地的seldon核心微服务服务器:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="5687" class="nl mk it nh b gy nm nn l no np">cd model/ &amp;&amp; seldon-core-microservice --service-type MODEL health_entity</span></pre><p id="24fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该能够看到一个gunicorn服务器开始监听端口9000:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/8b84e76726aadf7a11ce8c19861fafff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-CZ2wzzY7NKLEQ41yhFRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="80bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在单独的终端上，我们可以运行curl命令来检查我们的服务:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="31ee" class="nl mk it nh b gy nm nn l no np">curl -X POST <a class="ae ky" href="http://localhost:9000/api/v1.0/predictions" rel="noopener ugc nofollow" target="_blank">http://localhost:9000/api/v1.0/predictions</a> -H 'Content-Type: application/json' -d '{ "data": { "ndarray": ["Patient needs to take 50 mg of ibuprofen every day."] } }'</span></pre><p id="b4f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们已经在curl请求中发送了一些医疗信息。我们应该得到一个带有标签信息的JSON:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="3abb" class="nl mk it nh b gy nm nn l no np">[<br/>   {<br/>      "entity":{<br/>         "name":"50 mg",<br/>         "category":"Dosage",<br/>         "confidence_score":0.99<br/>      }<br/>   },<br/>   {<br/>      "entity":{<br/>         "name":"ibuprofen",<br/>         "category":"MedicationName",<br/>         "confidence_score":1.0<br/>      }<br/>   },<br/>   {<br/>      "entity":{<br/>         "name":"every day",<br/>         "category":"Frequency",<br/>         "confidence_score":1.0<br/>      }<br/>   },<br/>   {<br/>      "relation_type":"DosageOfMedication",<br/>      "roles":[<br/>         {<br/>            "role":"Dosage",<br/>            "entity":"50 mg"<br/>         },<br/>         {<br/>            "role":"Medication",<br/>            "entity":"ibuprofen"<br/>         }<br/>      ]<br/>   },<br/>   {<br/>      "relation_type":"FrequencyOfMedication",<br/>      "roles":[<br/>         {<br/>            "role":"Medication",<br/>            "entity":"ibuprofen"<br/>         },<br/>         {<br/>            "role":"Frequency",<br/>            "entity":"every day"<br/>         }<br/>      ]<br/>   }<br/>]</span></pre><p id="f145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，我们得到了标记的医学术语，例如布洛芬被认为是<code class="fe nu nv nw nh b">MedicationName</code>类型的实体，我们还可以看到不同术语之间的关系，如50 mg(剂量)和布洛芬(药物),关系类型为<code class="fe nu nv nw nh b">DosageOfMedication.</code></p><p id="0adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以在AKS中使用类似的curl命令。我们需要为我们部署的seldon health服务获取集群ip和端口。为此，我们需要运行几个kubectl命令:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8eba" class="nl mk it nh b gy nm nn l no np">export INGRESS_HOST=<strong class="nh iu">$(</strong>kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}'<strong class="nh iu">)</strong><br/>export INGRESS_PORT=<strong class="nh iu">$(</strong>kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].port}'<strong class="nh iu">)</strong><br/>export INGRESS_URL=$INGRESS_HOST:$INGRESS_PORT<br/>echo $INGRESS_URL</span></pre><p id="1885" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了<code class="fe nu nv nw nh b">INGRESS_URL</code>,我们可以在curl命令中替换它:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0463" class="nl mk it nh b gy nm nn l no np">curl -X POST <a class="ae ky" href="http://localhost:9000/api/v1.0/predictions" rel="noopener ugc nofollow" target="_blank">http://$</a>INGRESS_URL<a class="ae ky" href="http://localhost:9000/api/v1.0/predictions" rel="noopener ugc nofollow" target="_blank">/api/v1.0/predictions</a> -H 'Content-Type: application/json' -d '{ "data": { "ndarray": ["Patient needs to take 50 mg of ibuprofen every day."] } }'</span></pre><p id="c159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该得到与本地请求相似的响应。</p><p id="f107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们终于到了教程的结尾。这是一个复杂的问题，但是我们已经设法在Azure中创建了一个端到端的Kubernetes ML解决方案。我们已经看到了如何使用CDKTF在python中创建复杂的基础设施，如何使用helm和kubectl在Kubernetes中安装各种框架，以及如何使用Seldon Core创建和部署ML RESTful服务，这种服务非常可扩展、安全且易于配置。</p></div></div>    
</body>
</html>