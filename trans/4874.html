<html>
<head>
<title>An Introduction to Regular Expressions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中正则表达式的介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-regular-expressions-in-python-23baebfa3ac#2022-10-29">https://towardsdatascience.com/an-introduction-to-regular-expressions-in-python-23baebfa3ac#2022-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/0bab4845429cd5c774909f34ecc5efdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkcsSMIOdr3NKQawSQlfXg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@jannerboy62?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>拍摄</p></figure><h2 id="0136" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">PYTHON基础</h2><div class=""/><div class=""><h2 id="3eae" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">探索Python中正则表达式的基本概念</h2></div></div><div class="ab cl lh li hx lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="im in io ip iq"><p id="a542" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">"<em class="mk">……这本书是关于什么的？</em>”——我问</p><p id="d12c" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">他告诉我</p><p id="b8b2" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">”<em class="mk">什么？我从来没有听说过他们”——我困惑地回答</em></p><p id="6074" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">他说:“哦，如果你读了这本书，你会发现它们非常有用。”</p><p id="3c2b" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我打开书，翻了翻索引，直接到了<em class="mk"> Python部分</em>。</p><p id="8893" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我必须承认。我当时超级迷茫。我一点也不明白这本书在说什么。所以我关了它。</p><p id="2d3a" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在那之后的某个时候，我正在做一个与自然语言处理相关的项目。我必须解析pdf文件，这简直成了一场噩梦。</p><p id="6aab" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我绝望地看着我的书柜，我看到那本书就在那里。我告诉自己，我必须试一试。所以我再次打开它，决心理解正则表达式。</p><p id="9bd8" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我花在学习它们上的每一分钟都是值得的！</p><p id="97bd" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">正则表达式非常强大和快速。一旦你掌握了这个概念，一个新的世界就展现在你面前。它们允许你搜索复杂的模式，否则很难找到。</p><p id="49d7" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><em class="mk">注:除特别注明外，所有图片均为作者所有。</em></p><h1 id="6f33" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">基础知识</h1><p id="4af8" class="pw-post-body-paragraph lo lp jj lq b lr nd kt lt lu ne kw lw lx nf lz ma mb ng md me mf nh mh mi mj im bi translated">正则表达式(Regex)是包含普通字符和特殊字符组合的字符串，用于描述在文本中查找文本的模式。</p><p id="f97b" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">什么？？？这听起来很复杂…<em class="mk">让我们分解一下，以便更好地理解。</em></p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/4a62cb98fdbfe2c6344e4736891dd56c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80V3olaritOqc28nduthhw.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">正则表达式(Regex)。所有图像，除非另有说明</p></figure><p id="deda" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">上图展示了正则表达式的样子。在Python中，开头的<strong class="lq jt"> r </strong>表示一个<strong class="lq jt">原始字符串</strong>。不强制使用，但建议使用。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/01e04a6351ff3da748802255d987d7dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*nARu6wEsIwuwMePP8ro_jw.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">正则表达式包含匹配自身的普通字符。tr匹配一个t后跟一个r</p></figure><p id="2802" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们说过一个正则表达式包含普通字符，或者换句话说，我们已经知道的文字字符。正常字符匹配自己。在图中所示的情况下，<strong class="lq jt"> tr </strong>与后面跟有<strong class="lq jt"> r </strong>的<strong class="lq jt"> t </strong>完全匹配。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/4452128e96a861659be94b74b3d9c7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O2lhvpqJJujNXE23FkvfhA.png"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">正则表达式包含匹配字符类型、位置或数量的元字符</p></figure><p id="f77d" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">正则表达式也包含<strong class="lq jt">元字符。</strong>这些<strong class="lq jt">特殊字符</strong>本身不匹配。相反，它们是在正则表达式中具有“特殊含义”的字符。特别地，它们可以代表:</p><p id="8674" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><strong class="lq jt"> 1。字符类型</strong></p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/4119af71c6ebc946d22ba0c8de7280fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8nuZ655mIR1W9-3N4TXfgA.png"/></div></div></figure><p id="9106" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在这种情况下，元字符表示字符类或特殊序列。例如，<strong class="lq jt"> \d </strong>代表一个数字，<strong class="lq jt"> \s </strong>表示<strong class="lq jt"> </strong>空格，<strong class="lq jt">【A-Za-Z】</strong>从A到Z，或A到Z的任何字母。</p><p id="7563" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><strong class="lq jt"> 2 </strong>。想法，如<strong class="lq jt">位置</strong>或<strong class="lq jt">重复</strong></p><p id="8a8c" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">元字符可以指示位置。此外，它们还可以充当量词<strong class="lq jt">来指定位于其左侧的字符需要匹配多少次。</strong></p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/4f6e9d57b4c88ecc8bf0bbf7364ea186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*zSB3O6rbdDfGnMEEFOVE2w.png"/></div></figure><p id="ab81" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在本例中，花括号中的<em class="mk"> 1和2表示紧邻左侧的字符，在本例中为/d，应该出现1到2次。此外，<em class="mk">加号</em> (+)表示从A到Z或A到Z的任何字母应该出现1次或更多次。</em></p><p id="14a1" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在表中，我们可以看到一个支持的元字符及其含义的列表。</p><figure class="nj nk nl nm gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e4ba7b5c0320e486a391c496f451189b.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*BNi_ga_frL-XnSZ31R4upA.png"/></div><p class="jc jd gj gh gi je jf bd b be z dk translated">下表显示了Python支持的一些最常见的元字符。改编自<a class="ae jg" href="https://www.datacamp.com/tutorial/python-regular-expression-tutorial#summary-table" rel="noopener ugc nofollow" target="_blank"> Python正则表达式教程。</a></p></figure><p id="94ae" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们说过正则表达式描述了一种模式。<strong class="lq jt">模式</strong>是映射到单词或标点符号的一系列字符。</p><p id="9040" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">数据科学家或软件工程师使用模式匹配来查找和替换特定的文本。它们的用例非常广泛，从验证字符串(如密码或电子邮件地址)、解析文档、执行数据预处理到帮助进行web抓取或数据提取。</p><p id="03a9" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">为什么<strong class="lq jt">正则表达式</strong>？他们非常强大和快速。它们允许我们搜索复杂的模式，否则很难找到。</p><h1 id="89b0" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated"><code class="fe ns nt nu nv b"> re</code>模块</h1><p id="3d01" class="pw-post-body-paragraph lo lp jj lq b lr nd kt lt lu ne kw lw lx nf lz ma mb ng md me mf nh mh mi mj im bi translated">Python有一个有用的库，<code class="fe ns nt nu nv b">re</code> <a class="ae jg" href="https://docs.python.org/3/library/re.html" rel="noopener ugc nofollow" target="_blank">模块</a>，用来处理regex。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="ce85" class="oa mm jj nv b gy ob oc l od oe">import re</span></pre><p id="9add" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">这个库为我们提供了几个使模式匹配更容易的函数。让我们看看其中的一些。</p><p id="2d91" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">为了在<strong class="lq jt">中搜索</strong>一个模式，我们可以使用<code class="fe ns nt nu nv b">.search()</code>功能。它接受正则表达式和字符串。该函数扫描整个字符串，寻找正则表达式给出匹配的第一个位置。如果字符串中没有与模式匹配的位置，则返回match或<code class="fe ns nt nu nv b">None</code>。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="19b3" class="oa mm jj nv b gy ob oc l od oe">&gt; re.<strong class="nv jt">search</strong>('\w{4}\d{4}', 'My password is abcd1234.')</span><span id="dd62" class="oa mm jj nv b gy of oc l od oe">&lt;re.Match object; span=(15, 23), match='abcd1234'&gt;</span></pre><p id="9e1c" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在代码中，我们希望找到一个重复四次的单词字符，然后是一个重复四次的数字。<code class="fe ns nt nu nv b">.search()</code>函数找到匹配:<code class="fe ns nt nu nv b">abcd1234</code>。</p><p id="f1d4" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">另一个帮助我们找到模式匹配的函数是<code class="fe ns nt nu nv b">.match()</code>。它还接受正则表达式和字符串。</p><p id="02bc" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><em class="mk">我们已经有了</em> <code class="fe ns nt nu nv b">.search()</code> <em class="mk">，为什么还需要另一个函数？</em></p><p id="2afa" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><code class="fe ns nt nu nv b">.match()</code>函数锚定在字符串的开头。这意味着只有在字符串的开头找到模式匹配，它才会返回相应的匹配。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="d4c7" class="oa mm jj nv b gy ob oc l od oe">&gt; re.<strong class="nv jt">match</strong>('\w{4}\d{4}', 'My password is abcd1234.')</span></pre><p id="581c" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在前面的例子中，我们将使用<code class="fe ns nt nu nv b">.match()</code>而不是<code class="fe ns nt nu nv b">.search()</code>。我们会发现没有匹配，因为在字符串的开头没有一个单词字符重复了四次，后跟一个重复了四次的数字。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="2c17" class="oa mm jj nv b gy ob oc l od oe">&gt; re.<strong class="nv jt">match</strong>('\w{4}\d{4}', 'abcd1234 is my password.')</span><span id="2287" class="oa mm jj nv b gy of oc l od oe">&lt;re.Match object; span=(0, 8), match='abcd1234'&gt;</span></pre><p id="dac2" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">让我们改变我们的字符串。我们在开头使用一个带有我们的模式的字符串。现在，<code class="fe ns nt nu nv b">.match()</code>函数能够找到匹配。</p><p id="731d" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">为了<strong class="lq jt">找到一个模式的所有匹配</strong>，我们可以使用<code class="fe ns nt nu nv b">.findall()</code>函数。它有两个参数:正则表达式和字符串。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="8f99" class="oa mm jj nv b gy ob oc l od oe">&gt; <!-- -->re.<strong class="nv jt">findall</strong>(r'\d{1,3}', 'My 3 cats have 15 kittens')</span><span id="d5c1" class="oa mm jj nv b gy of oc l od oe">['3', '15']</span></pre><p id="95b9" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在代码中，我们希望找到在指定字符串中重复1到3次的任何数字的所有匹配。<code class="fe ns nt nu nv b">findall()</code>函数返回找到的两个匹配项的列表:“3”和“15”。</p><p id="4b43" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><em class="mk">注意，不一定是同一个数字，只是“数字类”要重复1到3次</em>。</p><p id="0d51" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">要用另一串替换<strong class="lq jt">任何模式<strong class="lq jt">匹配，我们可以使用<code class="fe ns nt nu nv b">sub()</code>功能。它有三个参数:正则表达式、替换和字符串。</strong></strong></p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="d4bc" class="oa mm jj nv b gy ob oc l od oe">&gt; re.<strong class="nv jt">sub</strong>('\d', ' ', 'My1house2has3white4walls')</span><span id="0b0f" class="oa mm jj nv b gy of oc l od oe">'My house has white walls'</span></pre><p id="f57f" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在这个例子中，我们用空格替换了十进制数字的每一个匹配。</p><h1 id="e486" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">正则表达式在运行</h1><p id="6d6e" class="pw-post-body-paragraph lo lp jj lq b lr nd kt lt lu ne kw lw lx nf lz ma mb ng md me mf nh mh mi mj im bi translated">现在我们已经介绍了正则表达式的基本概念，让我们看看正则表达式的实际应用。</p><p id="52a0" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">想象一下，我们正在清理一些从网络上提取的文本。我们遇到一些字符串(例如:我的名字是#约翰·史密斯。I%live$in#London) 包含不应该出现的符号。我们如何清理这些琴弦？</p><p id="3ee1" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们将使用正则表达式和<code class="fe ns nt nu nv b">.sub()</code>函数。我们如何构建正则表达式？</p><p id="b397" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们将表明我们想要搜索符号<code class="fe ns nt nu nv b">#</code>、<code class="fe ns nt nu nv b">$</code>、<code class="fe ns nt nu nv b">%</code>、<code class="fe ns nt nu nv b">&amp;</code>，并将它们放在方括号<code class="fe ns nt nu nv b">[#$%&amp;]</code>中。这将表明<em class="mk">方括号之间的任何单个字符都可以匹配</em>。我们将把它们替换为空白区域<code class="fe ns nt nu nv b">“ “</code>。因此代码如下所示:</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="117c" class="oa mm jj nv b gy ob oc l od oe">&gt; my_string = "My&amp;name&amp;is#John Smith. I%live$in#London."<br/>&gt; re.sub(r"[#$%&amp;]", " ", my_string)</span><span id="7de6" class="oa mm jj nv b gy of oc l od oe">'My name is John Smith. I live in London.'</span></pre><p id="f7f1" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">现在，假设我们想要验证一个密码。该密码需要满足某些要求。因此，让我们编写正则表达式来帮助我们验证它们:</p><ol class=""><li id="68a0" class="og oh jj lq b lr ls lu lv lx oi mb oj mf ok mj ol om on oo bi translated">它必须以最少4个但最多8个数字开头:<code class="fe ns nt nu nv b">\d{4, 8}.</code>因为我们必须匹配开头，所以我们使用<code class="fe ns nt nu nv b">.match()</code></li><li id="39ac" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">数字后面必须有最少2个最多6个字母，大写或小写<code class="fe ns nt nu nv b">[a-zA-Z]{2,}</code>。</li><li id="dffb" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">之后可以包含任意字符<code class="fe ns nt nu nv b">.*</code>。</li><li id="0a67" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">它不能以下列符号结尾！，@，$，%，&amp;: <code class="fe ns nt nu nv b">[^!@$%&amp;]$</code>。注意这里我们在方括号中使用<code class="fe ns nt nu nv b">^</code>来否定符号的出现。<code class="fe ns nt nu nv b">$</code>将模式锚定到字符串的末尾。</li></ol><p id="12ef" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">所以我们定义了一个函数来验证密码:</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="ad8d" class="oa mm jj nv b gy ob oc l od oe">&gt; def validate_password(password): <br/>&gt;     if re.match(r"\d{4,8}[a-zA-Z]{2,}.*[^!@$%&amp;]$", password):<br/>&gt;         print(f"Valid Password {password}")<br/>&gt;     else:<br/>&gt;         print(f"Invalid Password {password}")</span></pre><p id="d3d9" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">我们可以使用一个无效的密码来测试它:4390Abac！以一个符号结尾。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="d0ba" class="oa mm jj nv b gy ob oc l od oe">&gt; validate_password("4390Abac!")</span><span id="0500" class="oa mm jj nv b gy of oc l od oe">Invalid Password 4390Abac!</span></pre><p id="e4b4" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">还有4390Abac！1符合要求。</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="ecb2" class="oa mm jj nv b gy ob oc l od oe">&gt; validate_password("4390Abac!1")</span><span id="ecfd" class="oa mm jj nv b gy of oc l od oe">Valid Password 4390Abac!1</span></pre><p id="2908" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">最后，假设我们必须从文档中提取日期。人们写日期的方式非常不同。月份可以与数字或名称一起出现。这一天可能在一个月之后，也可能在一个月之前。如此等等。</p><p id="626b" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在下面的例子中，我们需要将日期提取为:<code class="fe ns nt nu nv b"><em class="mk">ordinal_number</em> of <em class="mk">month_name</em> <em class="mk">year</em> <em class="mk">hh:mm.</em></code> <em class="mk"> </em>所以让我们构建正则表达式:</p><ol class=""><li id="ed03" class="og oh jj lq b lr ls lu lv lx oi mb oj mf ok mj ol om on oo bi translated">序数可以有1或2位数。后面是st，th，或者rd (so 2小字母):<code class="fe ns nt nu nv b">\d{1,2}[a-z]{2}</code>。在那之后我们有空白:<code class="fe ns nt nu nv b">\s</code>然后是单词<code class="fe ns nt nu nv b">of</code>和空白:<code class="fe ns nt nu nv b">\s</code></li><li id="99f6" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">然后，我们将表明我们想要匹配任何字母(大写或小写)至少一次:<code class="fe ns nt nu nv b">[a-zA-Z]+</code>。然后，空格:<code class="fe ns nt nu nv b">\s</code>。</li><li id="8180" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">然后，必须跟随一个4位数:<code class="fe ns nt nu nv b">\d{4}</code>和空格:<code class="fe ns nt nu nv b">\s</code></li><li id="4e6a" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ol om on oo bi translated">然后，我们希望匹配一个1或2位数的小时数<code class="fe ns nt nu nv b">\d{1,2}</code>，后跟一个冒号<code class="fe ns nt nu nv b">:</code>和一个两位数的分钟数<code class="fe ns nt nu nv b">\d{2}</code></li></ol><p id="b0e5" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">最后，我们将有下面的正则表达式:</p><p id="8193" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated"><code class="fe ns nt nu nv b">r”\d{1,2}[a-z]{2}\sof\s[a-zA-Z]+\s\d{4}\s\d{1,2}:\d{2}”</code></p><p id="043c" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">因此，我们的代码和输出将如下所示:</p><pre class="nj nk nl nm gt nw nv nx ny aw nz bi"><span id="7f56" class="oa mm jj nv b gy ob oc l od oe">&gt; my_date = 'Your appointment has been confirmed for 1st of september 2022 18:30'<br/>&gt; regex = r"\d{1,2}[a-z]{2}\sof\s[a-zA-Z]+\s\d{4}\s\d{1,2}:\d{2}"</span><span id="6c98" class="oa mm jj nv b gy of oc l od oe">&gt; re.findall(regex, my_date)</span><span id="15c4" class="oa mm jj nv b gy of oc l od oe">['1st september 2022 18:30']</span></pre><p id="f7a0" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">一个强大的工具，对吗？</p><p id="5898" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">在本文中，我们了解到正则表达式可以匹配普通或文字字符，以及可以表示字符类、数量或位置的元字符。我们探索了<code class="fe ns nt nu nv b">re</code>模块，它允许我们在字符串中查找、匹配、搜索和替换模式。最后，我们看到了一些如何使用正则表达式提取数据或验证表达式的例子。</p><p id="cbcd" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">然而，我们只是讨论了正则表达式的基本概念。而且还有更多！</p><p id="2934" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">如果你想了解更多关于如何掌握Python中的Regex，可以点击图片，看看我的课程。</p><p id="23d1" class="pw-post-body-paragraph lo lp jj lq b lr ls kt lt lu lv kw lw lx ly lz ma mb mc md me mf mg mh mi mj im bi translated">此外，查看这些有助于理解和测试正则表达式的资源:</p><ul class=""><li id="88f1" class="og oh jj lq b lr ls lu lv lx oi mb oj mf ok mj ou om on oo bi translated"><a class="ae jg" href="https://www.datacamp.com/courses/regular-expressions-in-python" rel="noopener ugc nofollow" target="_blank">https://www . data camp . com/courses/regular-expressions-in-python</a></li><li id="ed10" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ou om on oo bi translated"><a class="ae jg" href="https://www.regular-expressions.info/" rel="noopener ugc nofollow" target="_blank">https://www.regular-expressions.info/</a></li><li id="e43b" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ou om on oo bi translated"><a class="ae jg" href="https://regex101.com/" rel="noopener ugc nofollow" target="_blank">https://regex101.com/</a></li><li id="b342" class="og oh jj lq b lr op lu oq lx or mb os mf ot mj ou om on oo bi translated"><a class="ae jg" href="https://regexr.com/" rel="noopener ugc nofollow" target="_blank">https://regexr.com/</a></li></ul></div></div>    
</body>
</html>