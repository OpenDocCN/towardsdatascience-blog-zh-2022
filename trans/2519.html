<html>
<head>
<title>How to Use Partitions and Clusters in BigQuery Using SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用SQL在BigQuery中使用分区和集群</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-partitions-and-clusters-in-bigquery-using-sql-ccf84c89dd65#2022-06-01">https://towardsdatascience.com/how-to-use-partitions-and-clusters-in-bigquery-using-sql-ccf84c89dd65#2022-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cfc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优化成本，加快查询速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96cd96126de634bcbc1ef3e04a3e6285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-gUGGveFOgZBpbgt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让·格柏在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><h1 id="9ffc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">什么是分区和集群？</h1><p id="1637" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">分区和集群是两种非常有效的技术，可以最小化查询成本和提高性能(使用更少的资源，同时提高速度)。</p><blockquote class="mn"><p id="928f" class="mo mp it bd mq mr ms mt mu mv mw mm dk translated">这些技术背后的思想是限制运行查询时需要读取的数据量。</p></blockquote><p id="3ab8" class="pw-post-body-paragraph lr ls it lt b lu mx ju lw lx my jx lz ma mz mc md me na mg mh mi nb mk ml mm im bi translated">从本质上讲，我们不需要通读表中的每一条记录，而是读取其中的一小部分。</p><p id="f967" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">如果您不确定是使用分区还是集群，我仍然建议同时设置两者，因为这将提供速度和成本优势。你可以单独使用这两种技术<strong class="lt iu">或者结合使用</strong>来获得最佳效果。</p><h2 id="aa02" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">划分</h2><p id="5720" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">表分区</strong>是一种将大表分割成小表的技术。</p><p id="e2b8" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">下面是一个将经典表转换为按日期分区的表的示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/00812ba27b444339d1075a494eab6697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfnYWRz0nlvG-ODSZQhvWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分区如何将数据分成不同的块(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="11a0" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">BigQuery将在物理级别上分别存储不同的分区(这意味着数据将存储在不同的服务器上)。</p><p id="7d15" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">当您对表进行分区，然后执行查询时，也是BigQuery决定访问哪个分区，并最小化必须读取的数据。</p><p id="11b6" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">您可以基于一个列创建一个分区表，也称为<strong class="lt iu">分区键</strong>。在BigQuery中，可以使用不同的键对表进行分区:</p><ul class=""><li id="ed52" class="nu nv it lt b lu nc lx nd ma nw me nx mi ny mm nz oa ob oc bi translated"><strong class="lt iu">时间单位列</strong>:基于时间值(如时间戳或日期)对表进行分区。</li><li id="633b" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><strong class="lt iu">摄取时间</strong>:当BigQuery摄取数据时，根据时间戳对表进行分区。</li><li id="a9df" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><strong class="lt iu">整数范围</strong>:根据数字对表进行分区。</li></ul><p id="352a" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">BigQuery对每个表有4000个分区的限制。</p><h2 id="dc7c" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">我们的起始桌</h2><p id="ecd8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">对于我们的实验，我们有一个名为<code class="fe oi oj ok ol b">stackoverflow.question</code>的表，它是<strong class="lt iu"> 35GB大的</strong>，有<strong class="lt iu">2200万行</strong>。</p><p id="74d5" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">在进行任何分区或集群之前，我们需要一个经典表上的速度(我们的查询需要运行多长时间)和容量(读取了多少数据)基准。</p><p id="3bc0" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">下面的查询，我们称之为我们的<strong class="lt iu">基本查询</strong>，将用于比较性能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于评估分区和聚类技术性能的基本查询</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/be443f096d48e3ac683a2e3479bca915.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yz_tLSJ-dh7pFa95GMouKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">经典表的处理字节和执行时间(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="7e35" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">禁用缓存结果后，我们用了<strong class="lt iu">12.7秒</strong>来运行我们的查询，我们扫描了<strong class="lt iu"> 35GB的数据。</strong>在这种情况下，我们必须扫描表中的所有行，包括所有的标签和日期。</p><h2 id="58ea" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">对表进行分区的一个具体例子</h2><p id="4d81" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用时间单位列(在我们的例子中是日期列)进行分区。</p><p id="c18e" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">现在让我们使用我们的<code class="fe oi oj ok ol b">creation_date</code>列作为键来创建一个分区表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从初始的经典表创建一个分区表</p></figure><p id="67ab" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我们没有按天分区，而是用<code class="fe oi oj ok ol b">DATE_TRUNC(creation_date,MONTH)</code>将创建日期转换为月份。我们这样做是因为它减少了该表所需的分区数量。</p><p id="ea5f" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">如果我们尝试按天分区，BigQuery会返回一个错误:</p><blockquote class="op oq or"><p id="4659" class="lr ls os lt b lu nc ju lw lx nd jx lz ot ne mc md ou nf mg mh ov ng mk ml mm im bi translated">查询生成的分区太多，允许4000个，查询至少生成4967个分区</p></blockquote><p id="263c" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">让我们再次运行我们的<strong class="lt iu">基本查询</strong>，但是这次使用我们的分区表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/76710edf85fcac889c490b5e57e07154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7oxDkmMj2tAURBq1Nu8vg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">已分区表的已处理字节数和执行时间(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="48f2" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我们花了<strong class="lt iu">9.7秒</strong>来运行<strong class="lt iu"> </strong>这个查询，而<strong class="lt iu"> </strong>只扫描了<strong class="lt iu"> 7.1GB的数据</strong>。我们不能提高这么多的速度，但扫描的数据量少了很多，导致更便宜的查询。</p><blockquote class="op oq or"><p id="2207" class="lr ls os lt b lu nc ju lw lx nd jx lz ot ne mc md ou nf mg mh ov ng mk ml mm im bi translated"><strong class="lt iu"/></p></blockquote><ul class=""><li id="4f1a" class="nu nv it lt b lu nc lx nd ma nw me nx mi ny mm nz oa ob oc bi translated"><strong class="lt iu">partition _ expiration _ days</strong>:big query在到期时删除分区中的数据。这意味着超过此处指定天数的分区中的数据将被删除。</li><li id="93cd" class="nu nv it lt b lu od lx oe ma of me og mi oh mm nz oa ob oc bi translated"><strong class="lt iu">require _ partition _ filter</strong>:用户不在你的分区键上过滤(WHERE子句)就无法查询。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从我们最初的经典表创建一个分区表，并添加一些选项</p></figure><p id="06d7" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">您始终可以通过修改表格来更改选项的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用新值更新分区表中的选项</p></figure><p id="921d" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">关于选项和分区(以及集群)的所有信息都可以在您的表的细节部分找到。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/002c4a5d22fd584bc4db8811112cbe0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9aEA03Mng8C32Livk6S8jA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当前表的分区细节(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><h2 id="9378" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">簇</h2><p id="6e8a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">集群将允许BigQuery将相似的数据放在一起，从而允许查询扫描更少的数据。</p><p id="fb15" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">下面是一个将经典表转换为按名称聚集的表的示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/f58715ddab551616f501b5baa91bd529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63jGqL5ABjqGX6c5rH1INw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聚类如何将数据分成不同的块(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="2978" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">根据您为集群选择的列中的值，BigQuery将自动对这些值进行排序，并决定如何将它们存储在最佳存储块中。</p><p id="f0f3" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">集群最适合具有高基数的值，这意味着列具有各种可能的值<strong class="lt iu"> </strong>，例如<strong class="lt iu">电子邮件、用户id、名称、产品类别等……</strong></p><p id="1325" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">BigQuery允许对多个列进行集群，并且可以对不同的数据类型(字符串、日期、数字等)进行集群</p><p id="aa7c" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">BigQuery对每个表有4个集群列的限制。</p><h2 id="c0e9" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">聚集一个表的具体例子</h2><p id="acd4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将使用字符串值(在我们的例子中是StackOverflow表中的<code class="fe oi oj ok ol b">tags</code>列)进行聚类。</p><p id="4d53" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">要创建一个集群表，步骤与分区相同，但是语法将使用一个<code class="fe oi oj ok ol b">CLUSTER BY</code>子句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从初始的经典表创建一个聚集表</p></figure><p id="7986" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我们现在可以验证我们的表是基于包含在<code class="fe oi oj ok ol b">tags</code>列中的值进行聚类的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/0f434c4f2d3e314fd18cc26ab1952f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nUmzn0sWTblw1e7s0EwhuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">细节部分将显示哪些字段用于聚类(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="22d6" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">为了评估性能，我们现在使用聚集表运行与以前相同的查询。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/7b48cf1f9ac6798cd5dabeaec8a2ac7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ar7ftK1ifAOQXQYUCPzqHw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">集群表的处理字节和执行时间(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="cbac" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">运行这个查询花费了我们<strong class="lt iu"> 2.9秒</strong>，我们必须扫描<strong class="lt iu"> 265.9MB </strong> <strong class="lt iu">的数据</strong>。在这种情况下，速度提高了，需要扫描的数据量大大减少。</p><p id="2265" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">在这种情况下，查询验证器(绿色标签表示“该查询将处理35.8GB”)是不正确的。当使用聚簇表时，这个估计并不精确，将给出一个上限值。</p><h2 id="95fe" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated"><strong class="ak">划分+聚类</strong></h2><p id="0ffb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们现在可以很容易地结合这两种技术来优化更多。</p><p id="aa6f" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">下面是一个将经典表转换成表<strong class="lt iu">的例子，表<strong class="lt iu">按名称</strong>聚集，表<strong class="lt iu">按日期</strong>分区。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a947154aa2aa8dd58895642e072ffe98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFxB6C-LUkEtYiXIvS5nLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd pa">分区和聚类如何结合</strong>将数据分成不同的块(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="8f7c" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">如您所见，它与分区表非常相似，只是现在当每个分区中的值相似时，它们会被排序。</p><p id="c646" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">现在要创建一个使用这两种技术的表，就像在创建表时编写这两个子句一样简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从我们最初的经典表创建一个<strong class="ak">集群和分区的</strong>表</p></figure><p id="7517" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我们可以在表细节中观察到，该表同时使用了分区和集群。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/20ffa5c3633827a4c29efee8d4032e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yq2dokSQAFOR8UJvFCCEsg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">细节部分将显示哪些字段用于<strong class="bd pa">聚类和划分</strong>(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="5c61" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">为了再次分析性能，我们执行与之前相同的查询，但是这次我们使用最近生成的表，该表同时使用了<strong class="lt iu">集群和</strong>分区。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/68b7fbd7f69f247dffa01494f0bf0fc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cewYl6tbRnHMbCrHz4wiFg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个<strong class="bd pa">分区+集群</strong>表的处理字节和执行时间(图片由<a class="ae ky" href="https://romaingranger.medium.com/" rel="noopener">作者</a>提供)</p></figure><p id="0d8d" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">运行这个查询花费了我们<strong class="lt iu"> 3.1秒</strong>，并且只扫描了<strong class="lt iu"> 909.9MB的数据</strong>。这与我们看到的两种独立技术相当，现在这两种技术被结合起来以提高速度和成本。这里，它花费了几乎相同的时间，但是处理了更多的数据(因为使用了分区，BigQuery将不得不查看数据的几个部分，从而导致比我们只扫描一个集群分区时扫描更多的数据)。</p><p id="3948" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">一般来说，结合并实现这两种技术是一个很好的实践。当您使用cron作业或通过流从外部源接收数据时，按照接收时间进行分区可能会很有意思。</p><p id="749b" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">与其他数据仓库系统一样，当新数据进入时，BigQuery将自动执行自动重新聚类，并且不需要额外的成本。</p><p id="eed9" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">我希望这篇文章对您有用，并且您现在能够在您的项目中创建和实现集群和分区了！</p><h2 id="4c10" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">额外资源</h2><p id="d10b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">资料来源于Google云平台关于<strong class="lt iu">分区表的文档。</strong></p><div class="pd pe gp gr pf pg"><a href="https://cloud.google.com/bigquery/docs/partitioned-tables" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">分区表介绍| BigQuery | Google Cloud</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">本页概述了BigQuery中的已分区表。分区表是一种特殊的表，它…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">cloud.google.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div><p id="0cd3" class="pw-post-body-paragraph lr ls it lt b lu nc ju lw lx nd jx lz ma ne mc md me nf mg mh mi ng mk ml mm im bi translated">来源于关于<strong class="lt iu">集群表的Google云平台文档。</strong></p><div class="pd pe gp gr pf pg"><a href="https://cloud.google.com/bigquery/docs/clustered-tables" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">集群表介绍| BigQuery | Google Cloud</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">本文概述了BigQuery中的表聚类功能。当您在…中创建聚集表时</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">cloud.google.com</p></div></div><div class="pp l"><div class="pv l pr ps pt pp pu ks pg"/></div></div></a></div></div></div>    
</body>
</html>