<html>
<head>
<title>Algorithms Explained #2: Sorting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释#2:排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-explained-2-sorting-18d0875528fb#2022-10-10">https://towardsdatascience.com/algorithms-explained-2-sorting-18d0875528fb#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="529c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">三种排序算法的解释及其在Python中的实现</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/716d3b85bcb9c3d44d3eee5559ab07d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tzicMILFZqzoBj3cv_igQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/200degrees-2051452/" rel="noopener ugc nofollow" target="_blank"> 200度</a>来自<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="fe58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前一篇文章中，我介绍了递归，我们将在这篇文章的基础上构建排序算法。排序算法用于重新排列数组中的元素，使每个元素都大于或等于其前一个元素。有许多不同类型的排序算法，我将介绍三种最常见的值得熟悉的算法:选择排序、插入排序、合并排序。</p><p id="40b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为演示如何应用每种排序算法的例子，假设您正试图按作者的姓氏对书架上的<em class="lv"> n </em>本书进行排序。</p><h1 id="eb58" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">选择排序</h1><p id="308c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在选择排序中，首先在整个书架中查找作者姓氏出现在字母表中最早的那本书，并将该书放在书架的开头，从左数第1个位置。接下来，我们将从位置2的书开始，向右移动，在剩余的子数组中查找其作者的姓氏出现在字母表中最早的书，然后将该书放在位置2。重复这个过程，直到槽<em class="lv"> n — 1 </em>，我们将使用选择排序完成整个书架的排序。</p><p id="dd10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在Python中实现选择排序算法，我们需要跟踪两个子数组:已排序的子数组(当前索引<em class="lv"> i </em>右侧原始数组中的元素)和剩余的未排序子数组(当前索引<em class="lv"> i </em>左侧原始数组中的元素)。对于原始数组中的每个元素，我们需要遍历剩余的未排序子数组中的元素，以找到最小的元素，并将其与当前索引<em class="lv"> i </em>中的元素交换。</p><p id="4c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择排序算法的时间复杂度是O(n ),因为该算法中有两个for循环。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="525f" class="my lx it mu b gy mz na l nb nc">def selection_sort(arr):<br/>   n = len(arr)<br/>   for i in range(n):<br/>      # Find smallest element in the remaining indices of the array<br/>      min_idx = i<br/>      for j in range(i + 1, n):<br/>         if arr[j] &lt; arr[min_idx]:<br/>            min_idx = j</span><span id="dd4b" class="my lx it mu b gy nd na l nb nc">      # Swap smallest minimum element with the element in position i<br/>      arr[i], arr[min_idx] = arr[min_idx], arr[i]<br/>   <br/>   return arr</span></pre><h1 id="6f3f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">插入排序</h1><p id="66f3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在插入排序中，第一个I索引中的元素与最初在第一个I索引中的元素相同。类似于选择排序，我们从左到右遍历原始数组的每个元素。但是，这一次我们将比较当前索引<em class="lv"> i </em> (key)处的元素与当前索引右侧的已排序子数组中的每个元素，直到我们找到一个不超过当前元素的元素，并将它放在这个新位置。</p><p id="4631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">插入排序算法的时间复杂度的上限是O(n ),当数组中的元素顺序相反时会出现这种情况，因为内部while循环必须遍历已排序子数组中的每个元素。如果所有元素都已排序，并且内部while循环不必进行任何迭代，则插入排序算法的时间复杂度的下限是O(n)。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="dda4" class="my lx it mu b gy mz na l nb nc">def insertion_sort(arr):<br/>   n = len(arr)<br/>   for i in range(1, n):<br/>      key = arr[i]<br/>      j = i - 1</span><span id="92ac" class="my lx it mu b gy nd na l nb nc">      # Compare key to every element in the <br/>      # sorted subarray until the key is smaller <br/>      # than the current element <br/>      while j &gt;= 0 and key &lt; arr[j]:<br/>         arr[j + 1] = arr[j]<br/>         j -= 1</span><span id="7c46" class="my lx it mu b gy nd na l nb nc">      # Insert key in identified position<br/>      arr[j + 1] = key</span><span id="067b" class="my lx it mu b gy nd na l nb nc">  return arr </span></pre><h1 id="6619" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">合并排序</h1><p id="ac2c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">合并排序是一种分治算法，我们将问题分解成子问题，递归地解决子问题，然后将子问题的解决方案组合起来解决原始问题。在我们的图书分类示例中，我们将如何应用分而治之:</p><ol class=""><li id="8a2e" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><em class="lv"> Divide </em>:将数组分成两半；</li><li id="453d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><em class="lv">征服</em>:递归排序上一步得到的两半书中的书籍。基本情况发生在子阵列中只剩下一本书的时候；</li><li id="f22c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><em class="lv">合并</em>:将排序后的两半合并在一起。</li></ol><p id="cafc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并排序的运行时复杂度为O(n log n ),因为将数组分成块需要O(log n)时间，对每个块进行排序需要线性时间来合并两半。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ba2d" class="my lx it mu b gy mz na l nb nc">def merge_sort(arr):<br/>   # Terminating base case<br/>   if len(arr) &lt; 2:<br/>      return arr<br/>   else:<br/>      # Divide array into two subarrays<br/>      midpoint = len(arr) // 2<br/>      left = arr[:midpoint]<br/>      right = arr[midpoint:]</span><span id="142d" class="my lx it mu b gy nd na l nb nc">      # Sort subarrays<br/>      sorted_left = merge_sort(left)<br/>      sorted_right = merge_sort(right)</span><span id="a47c" class="my lx it mu b gy nd na l nb nc">      # Merge sorted subarrays<br/>      sorted_arr = []<br/>      while len(sorted_left) &gt; 0 and len(sorted_right) &gt; 0:<br/>         # Compare first elements of subarrays<br/>         if sorted_left[0] &lt; sorted_right[0]:<br/>            sorted_arr.append(sorted_left[0])<br/>            sorted_left.pop(0)<br/>         else:<br/>            sorted_arr.append(sorted_right[0])<br/>            sorted_right.pop(0)</span><span id="c002" class="my lx it mu b gy nd na l nb nc">      # Insert remaining items in sorted subarrays<br/>      sorted_arr.extend(sorted_left)<br/>      sorted_arr.extend(sorted_right)</span><span id="1306" class="my lx it mu b gy nd na l nb nc">   return sorted_arr</span></pre><h1 id="51a7" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="98b6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">选择排序、插入排序和合并排序是需要了解的典型排序算法。Python示例旨在帮助演示这些算法在实践中如何工作。在算法解释系列的下一部分，我将介绍搜索算法。</p><p id="aaf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多请看本算法讲解系列:<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>(本期文章)、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>。</p></div></div>    
</body>
</html>