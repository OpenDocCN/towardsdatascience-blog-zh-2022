<html>
<head>
<title>3 Ways to Deal with Heteroskedasticity in Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理时间序列中异方差的 3 种方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-ways-to-deal-with-heteroskedasticity-in-time-series-831f6499e688#2022-12-30">https://towardsdatascience.com/3-ways-to-deal-with-heteroskedasticity-in-time-series-831f6499e688#2022-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f41e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何稳定时间序列的方差，提高预测性能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e1399c45b9e37cbef7bebdff383bc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MmxhuYIRYOLpFg4P"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">塞缪尔·费拉拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是对<a class="ae ky" href="https://medium.com/towards-data-science/how-to-detect-heteroskedasticity-in-time-series-3413a8aa8da9" rel="noopener">我的上一篇文章</a>的后续。在那里，我描述了如何检测时间序列中的异方差。</p><p id="df5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里继续研究非常方差的问题。您将了解处理这种情况的三种方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc3c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">非恒定方差的影响</h1><p id="5af5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/how-to-detect-heteroskedasticity-in-time-series-3413a8aa8da9" rel="noopener">异方差影响预测模型的拟合</a>。</p><p id="6aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方差不恒定的时间序列通常具有长尾分布。数据是左偏或右偏的。这可能会损害某些算法的学习过程。与基于树的方法不同，诸如深度神经网络的方法受到这个问题的影响。</p><p id="210e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线性模型的估计系数仍然是无偏的。这意味着，平均而言，他们将是正确的。但是，它们不会是最精确的。</p><p id="9596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异方差也使任何假设观测值间方差不变的统计检验无效。</p><p id="9213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，如果不处理异方差，你的表现就会被搁置。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9085" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何应对异方差</h1><p id="8e85" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设你运行了一个统计测试，证实时间序列是异方差的。</p><p id="9ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此你能做些什么？</p><p id="933c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看三种可能的方法。</p><h2 id="5090" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">1.对数或幂变换</h2><p id="1d6d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">转换数据是消除异方差的最佳方法。目标是稳定方差，使分布更接近正态分布。</p><p id="14ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-data-science/how-to-detect-heteroskedasticity-in-time-series-3413a8aa8da9" rel="noopener">日志是做到这一点的有效转换</a>。平方根或立方根是两种可能的选择。这些是 Box-Cox 变换的特殊例子。</p><p id="73f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何使用 Python 将 Box-Cox 应用于时间序列:</p><pre class="kj kk kl km gt nl nm nn bn no np bi"><span id="5aad" class="nq md it nm b be nr ns l nt nu">import numpy as np<br/>from pmdarima.datasets import load_airpassengers<br/>from scipy.stats import boxcox<br/>from scipy.special import inv_boxcox<br/><br/># loading the data<br/>series = load_airpassengers(True)<br/><br/># transforming the series<br/># lambda_ is the transformation parameter<br/>series_transformed, lambda_ = boxcox(series)<br/><br/># reverting to the original scale<br/>original_series = inv_boxcox(series_transformed, lambda_)<br/><br/># check if it is the same as the original data<br/>np.allclose(original_series, series)<br/># True</span></pre><p id="7385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Box-Cox 依赖于转换参数 lambda。但是，它是在引擎盖下由<em class="nv"> scipy </em>自动优化的。没必要担心那个。当λ的值等于 0 时，应用 Box-Cox 变换与对数标度相同。</p><p id="292b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用函数<em class="nv"> inv_boxcox </em>将转换后的数据恢复到其原始比例。</p><p id="7759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Box-Cox 的一个局限性是，它只为正数据定义。Yeo-Johnson 转换类似于 Box-Cox 方法，解决了这个问题。</p><p id="8db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是脚本中使用的示例时间序列中 Box-Cox 的影响。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/629ec9beac2c0056f49c03f1f203d890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f0EqTcprSG4rBQPZ9TBNWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:原始时间序列(上图)和各自的 Box-cox 变换(下图)。方差在变换后变得稳定。图片作者。</p></figure><h2 id="fcb3" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">2.波动标准化</h2><p id="de44" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">波动率标准化是处理非恒定方差的另一种方法。</p><p id="48a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列的波动性是数据最近的变化水平。这种可变性通常用标准差来量化。波动率标准化的思想是根据其波动率对序列进行标准化。它导致了具有相同变化水平的观察结果。</p><p id="6bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">波动性标准化在具有许多时间序列的数据集中特别有用。例如，<a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-global-forecasting-models-3ca8e69a6524" rel="noopener">在训练全球预测模型时</a>。</p><h2 id="c01b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">例子</h2><p id="9c98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们看一个使用多元时间序列的例子。</p><p id="4dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标是预测序列中不同变量的未来值。我们将使用一个全球预测模型来做这件事。在这篇介绍性文章中，你可以了解更多关于<a class="ae ky" href="https://medium.com/towards-data-science/introduction-to-global-forecasting-models-3ca8e69a6524" rel="noopener">全球预测模型的信息。基本思想是使用几个时间序列作为输入建立一个单一的预测模型。</a></p><p id="5917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此示例中的数据集是葡萄酒销售时间序列。它看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/7bcc072e1e658a762e0a5d63d588d5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3YYJrxHf5uAJ9WXtR94Ffg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:葡萄酒销售多元时间序列。目标是预测超过测试开始标记的所有观察值。这些数据是公开的。查看参考文献[3]中的原始资料。图片作者。</p></figure><p id="6391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个变量(葡萄酒类型)中，方差在系列中看起来是稳定的。但是，很明显，不同的变量有不同程度的可变性。波动率标准化可用于稳定每个变量的方差。</p><p id="4132" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是在构建预测模型时如何应用波动率标准化。查看评论了解更多上下文。</p><pre class="kj kk kl km gt nl nm nn bn no np bi"><span id="a53d" class="nq md it nm b be nr ns l nt nu">import re<br/>import numpy as np<br/>import pandas as pd<br/><br/># using xgboost as the regression algorithm<br/>from xgboost import XGBRegressor<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import mean_absolute_error as mae<br/><br/># https://github.com/vcerqueira/blog/<br/>from src.tde import time_delay_embedding<br/><br/># https://github.com/vcerqueira/blog/tree/main/data<br/>wine = pd.read_csv('data/wine_sales.csv', parse_dates=['date'])<br/>wine.set_index('date', inplace=True)<br/><br/># train test split<br/># using the last 20% of data as testing<br/>train, test = train_test_split(wine, test_size=0.2, shuffle=False)<br/><br/># transforming the time series for supervised learning<br/>train_df, test_df = [], []<br/>for col in wine:<br/>    # using 12 lags to forecast the next value (horizon=1)<br/>    col_train_df = time_delay_embedding(train[col], n_lags=12, horizon=1)<br/>    col_train_df = col_train_df.rename(columns=lambda x: re.sub(col, 'Series', x))<br/>    train_df.append(col_train_df)<br/><br/>    col_test_df = time_delay_embedding(test[col], n_lags=12, horizon=1)<br/>    col_test_df = col_test_df.rename(columns=lambda x: re.sub(col, 'Series', x))<br/>    test_df.append(col_test_df)<br/><br/># different series are concatenated on rows<br/># to train a global forecasting model<br/>train_df = pd.concat(train_df, axis=0)<br/>test_df = pd.concat(test_df, axis=0)<br/><br/># splitting the explanatory variables from target variables<br/>predictor_variables = train_df.columns.str.contains('\(t\-')<br/>target_variables = train_df.columns.str.contains('Series\(t\+')<br/>X_train = train_df.iloc[:, predictor_variables]<br/>Y_train = train_df.iloc[:, target_variables]<br/>X_test = test_df.iloc[:, predictor_variables]<br/>Y_test = test_df.iloc[:, target_variables]<br/><br/># volatility standardization<br/># dividing by the standard deviation of past 12 lags<br/>X_train_vs = X_train.apply(lambda x: x / x.std(), axis=0)<br/>X_test_vs = X_test.apply(lambda x: x / x.std(), axis=0)<br/><br/># testing three methods<br/>## no normalization/preprocessing<br/>mod_raw = XGBRegressor()<br/>## volatility standardization<br/>mod_vs = XGBRegressor()<br/>## log transformation<br/>mod_log = XGBRegressor()<br/><br/># fitting on raw data<br/>mod_raw.fit(X_train, Y_train)<br/># fitting with log-scaled data<br/>mod_log.fit(np.log(X_train), np.log(Y_train))<br/># fitting with vol. std. data<br/>mod_vs.fit(X_train_vs, Y_train)<br/><br/># making predictions<br/>preds_raw = mod_raw.predict(X_test)<br/>preds_log = np.exp(mod_log.predict(np.log(X_test)))<br/>preds_vs = mod_vs.predict(X_test_vs)<br/><br/>print(mae(Y_test, preds_raw))<br/># 301.73<br/>print(mae(Y_test, preds_vs))<br/># 294.74<br/>print(mae(Y_test, preds_log))<br/># 308.41</span></pre><p id="717e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用波动率标准化对数据进行预处理可以提高预测性能。相对于这个问题中的对数变换，波动率标准化也更好。</p><h2 id="55bd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">3.加权回归</h2><p id="5e10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一种处理异方差的方法是选择合适的方法。例如，不假设观测值之间的方差相等。</p><p id="1b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以根据观察值的可变性为其分配权重。默认情况下，学习算法对数据集中的所有观察值给予相同的权重。然而，可变性更高的病例具有更少的信息。你可以通过减轻它们的重量来降低它们对方法的重要性。</p><p id="38d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些权重是根据拟合值的方差计算的。方差越大，权重越小。<a class="ae ky" href="https://www.statsmodels.org/dev/examples/notebooks/generated/wls.html" rel="noopener ugc nofollow" target="_blank">这里有一个来自<em class="nv"> statsmodels </em> Python 库</a>的例子。</p><p id="c781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nv"> scikit-learn </em>中的几个算法都有一个<em class="nv"> sample_weight </em>参数，可以用来设置权重。</p><h1 id="bcc7" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">方差建模</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a80cfcd41607b23139ec4627c07dfba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WXEako5jy1qjgQzQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nikola Knezevic 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="afd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以模拟方差的变化，而不是稳定它。</p><p id="f836" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过 ARCH(自回归条件异方差)等模型来实现。这种类型的模型用于根据时间序列的过去值预测方差。</p><p id="5fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GARCH(广义自回归条件异方差)扩展了 ARCH。除了使用序列的过去值，它还使用过去的方差。</p><p id="23a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://pypi.org/project/arch/" rel="noopener ugc nofollow" target="_blank"> <em class="nv"> arch </em> </a>库为这些方法提供了 Python 实现。</p><h1 id="439d" class="mc md it bd me mf ny mh mi mj nz ml mm jz oa ka mo kc ob kd mq kf oc kg ms mt bi translated">外卖</h1><p id="d041" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，您学习了如何处理时间序列中的异方差。我们讨论了三种方法:</p><ol class=""><li id="b943" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">对数或幂变换；</li><li id="e219" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">波动率标准化；</li><li id="87d4" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">加权回归。</li></ol><p id="6d0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人的偏好是转换数据。当我处理一个单一的时间序列时，我会选择选项 1。对于几个时间序列，我倾向于使用选项 2。但是，你可以使用交叉验证来优化<a class="ae ky" href="https://medium.com/towards-data-science/4-things-to-do-when-applying-cross-validation-with-time-series-c6a5674ebf3a" rel="noopener">。</a></p><p id="8d90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用 ARCH/GARCH 方法直接对方差建模。</p><p id="f901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你的阅读，下一个故事再见！</p><h2 id="ddc6" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">进一步阅读</h2><p id="6e56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">[1] <a class="ae ky" href="https://otexts.com/fpp2/transformations.html" rel="noopener ugc nofollow" target="_blank">关于电力变换</a>，预测原理与实践</p><p id="39b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2] <a class="ae ky" href="https://www.itl.nist.gov/div898/handbook/pmd/section1/pmd143.htm" rel="noopener ugc nofollow" target="_blank">关于加权回归</a>，工程统计手册</p><p id="d218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[3]罗布·海德曼和杨卓然(2018)。时间序列数据库。v 0 . 1 . 0 .<a class="ae ky" href="https://pkg.yangzhuoranyang.com/tsdl/" rel="noopener ugc nofollow" target="_blank">https://pkg.yangzhuoranyang.com/tsdl/</a>(GPL-3)</p></div></div>    
</body>
</html>