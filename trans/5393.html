<html>
<head>
<title>PLAXIS Output Visualisation Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Python 实现 PLAXIS 输出可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/plaxis-output-visualisation-using-python-a144d2367094#2022-12-03">https://towardsdatascience.com/plaxis-output-visualisation-using-python-a144d2367094#2022-12-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="6e54" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">PLAXIS 自动化系列</h2><div class=""/><div class=""><h2 id="cab1" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">逐步走向自动化的指南</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ff4e2bb196093622da704373cfbf674d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtJeCka-IbI3z1HfoX8scg.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">卢克·切瑟在<a class="ae le" href="https://unsplash.com/s/photos/excel?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6d98" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">PLAXIS 输出应用程序提供了使用内置绘图工具比较不同阶段输出的可能性。虽然它提供了一些基本的绘图功能，允许用户可视化结果，但人们经常使用 Excel，因为它允许在绘图格式、数据操作和结果共享方面的灵活性。</p><p id="1ca8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">毫无疑问，Excel 是一个强大而著名的数据可视化软件。但是，PLAXIS 没有提供与 Excel 的完全集成，这使得提取和可视化过程非常耗时。在数据可视化方面，有三个可能的改进领域:</p><ol class=""><li id="808a" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">将所有数据合并到一个工作表中进行绘图</li><li id="cfaf" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">创建绘图时，在 Excel 中自动选择数据系列</li><li id="e19a" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">使用定制的系列名称和轴标题创建绘图</li></ol><p id="fa24" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">本教程旨在扩展从<strong class="lh ja">第二教程</strong>中学到的教训。我们将提取多个阶段的输出，并使用图来比较结果。这可以通过以下三个步骤来完成:</p><ol class=""><li id="24f9" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">将外部模块安装到 PLAXIS 环境中</li><li id="fcb7" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">提取多个阶段的结果</li><li id="f8a1" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">使用 Excel 中的图表比较不同阶段的结果</li><li id="6bc0" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">用 Openpyxl 格式化</li></ol><p id="6222" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">和以前一样，本教程要求读者已经安装了 VS 代码和 PLAXIS 环境。如果您不熟悉这个页面，请按照下面文章中的说明进行操作。我们开始吧！</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/@philip.studio11/start-using-python-to-automate-plaxis-35a5297321e7" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ja gy z fp mx fr fs my fu fw iz bi translated">开始使用 Python 来自动化 PLAXIS</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">PLAXIS 是一个有限元建模软件，岩土工程师在某个特定的时候肯定会碰到它</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng ky ms"/></div></div></a></div><h1 id="75b7" class="nh ni iq bd nj nk nl nm nn no np nq nr kf ns kg nt ki nu kj nv kl nw km nx ny bi translated">PLAXIS 示例模型</h1><p id="179b" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">我们将使用第二节课中相同的 PLAXIS 2D 模型。如果您还没有这样做，请按照下面的说明来设置和计算模型。</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/@philip.studio11/goodbye-boring-plaxis-output-with-python-fc5c8b26cdb2" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ja gy z fp mx fr fs my fu fw iz bi translated">用 Python 告别枯燥的 PLAXIS 输出</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">如果你像我一样经常使用 PLAXIS，你一定会问这个问题:我到底为什么需要不断重复…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="oe l nd ne nf nb ng ky ms"/></div></div></a></div><p id="cd4c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">与上一个教程类似，我们将使用“open_output.py”打开 PLAXIS 文件，这样就可以启用 API 服务器。</p><p id="b619" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">概括一下，我们使用下面的代码来打开文件:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/34377f2787ba21fb08e85532e12f02d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plp7MXFNjl328XK7fhPGdQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 VS 代码</p></figure><p id="8acb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">运行上面的代码后，PLAXIS 2D 输入和输出应用程序应该会自动打开。从输出应用程序中，您应该看到“服务器在端口 10001 上活动”。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi og"><img src="../Images/23c37ac69e1125fc4bf740acea5b6714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjRp-clgxWemwmyl8GsAYw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 PLAXIS</p></figure><h1 id="38e9" class="nh ni iq bd nj nk nl nm nn no np nq nr kf ns kg nt ki nu kj nv kl nw km nx ny bi translated">步骤 1:将外部模块安装到 PLAXIS 环境中</h1><p id="e092" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">我们的目标是从 PLAXIS 中提取结果，并在 excel 中创建比较图。为此，我们需要三个外部模块:</p><ul class=""><li id="d0ea" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">熊猫</li><li id="9c71" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">Xlsxwriter</li><li id="c7fa" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">Openpyxl</li></ul><p id="3995" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过 PLAXIS 命令提示符安装外部模块的过程已经在第二篇教程中详细描述了。在继续以下步骤之前，请确保您已经完成了该流程。</p><p id="5f59" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">从上一个教程来看，熊猫和 xlsxwriter 都应该安装。请注意，Python 模块是版本敏感的，这是因为一些模块与其他模块有连接，因此版本更新可能会导致故障。这对于在 PLAXIS 环境中保持一致的模块依赖关系至关重要。</p><p id="7439" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我在本教程中使用的模块版本如下:</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="be1f" class="on ni iq oj b be oo op l oq or">pandas == 1.5.2<br/>xlsxwriter == 3.0.3<br/>openpyxl == 3.0.9<br/>defusedxml == 0.7.1</span></pre><p id="0c41" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">要检查模块的当前版本，我们可以在 PLAXIS 命令提示符下使用以下命令:</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="6f99" class="on ni iq oj b be oo op l oq or">python -m pip show pandas</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/cbf6a34d8675e94f3c7b7361a1f6a2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i1jw4a8qKlcK05snlHO1zQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 PLAXIS</p></figure><p id="a2dd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果版本不一致，我们可以使用以下命令来升级/降级版本:</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="f6a0" class="on ni iq oj b be oo op l oq or">python -m pip install --upgrade pandas==1.5.2</span></pre><p id="e5bd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">安装其余模块:</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="4c3c" class="on ni iq oj b be oo op l oq or">python -m pip install xlsxwriter==3.0.3<br/>python -m pip install openpyxl==3.0.9<br/>python -m pip install defusedxml==0.7.1</span></pre><p id="de79" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在某些情况下，您可能会在安装<em class="ot"> defusedxml </em>时遇到错误</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="07ba" class="on ni iq oj b be oo op l oq or">ERROR: Could not install packages due to an OSError: [WinError 5] Access is denied</span></pre><p id="0f33" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果是这种情况，请尝试以下代码:</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="6a73" class="on ni iq oj b be oo op l oq or">python -m pip install --upgrade defusedxml==0.7.1 --user</span></pre><p id="8e9b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我们已经安装了所有需要的模块。我们现在可以使用 Python 脚本从 PLAXIS 的不同阶段提取结果了。</p><h1 id="b9fb" class="nh ni iq bd nj nk nl nm nn no np nq nr kf ns kg nt ki nu kj nv kl nw km nx ny bi translated">步骤 2:提取多个阶段的结果</h1><p id="dd95" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">步骤 2 的主要目标是从“挖掘”模型的三个阶段中提取结果(弯矩)。然后，我们会将结果导出到 Excel 中一个名为“combined_Plate_1”的工作表中，该工作表包含以下各列:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/ff19e3665effaa49292adbd78671243b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IbAiFvXIS-CqCE2TtqYowA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 excel</p></figure><p id="2eff" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">首先，我们创建一个空的 python 文件，并将其命名为“plot_plate_combine.py”。</p><h2 id="ff30" class="ov ni iq bd nj ow ox dn nn oy oz dp nr lo pa pb nt ls pc pd nv lw pe pf nx iw bi translated">导入模块并启动服务器</h2><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="a8c3" class="on ni iq oj b be oo op l oq or">from plxscripting.easy import *<br/>import math<br/>import pandas as pd<br/>from openpyxl import load_workbook<br/>from openpyxl.chart import (<br/>    ScatterChart,<br/>    Reference,<br/>    Series,<br/>)<br/>###############################################<br/>PORT_i = 10000  # Define a port number.<br/>PORT_o = 10001<br/>PASSWORD = 'SxDBR&lt;TYKRAX834~'  # Define a password.<br/><br/><br/><br/># Start the scripting server.<br/>s_i, g_i = new_server('localhost', PORT_i, password=PASSWORD)<br/>s_o, g_o = new_server('localhost', PORT_o, password=PASSWORD)</span></pre><h2 id="9abe" class="ov ni iq bd nj ow ox dn nn oy oz dp nr lo pa pb nt ls pc pd nv lw pe pf nx iw bi translated">定义文件名</h2><p id="cac7" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">文件位置:C:\ Users \ phtsang \ Desktop \ PLAXIS _ v 22 \ Script</p><p id="141d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">文件名:可以是您想要的任何名称</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="0c2d" class="on ni iq oj b be oo op l oq or">EXCEL_PATH=r'C:\Users\phtsang\Desktop\PLAXIS_V22\Script\\'<br/>EXCEL_NAME='Plate_y.xlsx'<br/><br/><br/>FILENAME=EXCEL_PATH+EXCEL_NAME</span></pre><h2 id="89f3" class="ov ni iq bd nj ow ox dn nn oy oz dp nr lo pa pb nt ls pc pd nv lw pe pf nx iw bi translated">输入定义</h2><p id="b517" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">在这种情况下，我们将从以下阶段中提取‘Plate _ 1’的弯矩:</p><ul class=""><li id="1f3f" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">安装支柱[阶段 3]'</li><li id="58e6" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">第二(水下)开挖阶段[第 4 阶段]'</li><li id="1490" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">'第三挖掘阶段[第五阶段]'</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="8a9a" class="on ni iq oj b be oo op l oq or">###############################################<br/>#Inputs:<br/>plate_input=['Plate_1']<br/>phase_input=['Installation of strut [Phase_3]','Second (submerged) excavation stage [Phase_4]','Third excavation stage [Phase_5]']</span></pre><p id="0803" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您的脚本应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/0199790fb814d140d8c360af46090735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x61meVWAa6_QVI-dVJpwcw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 VS 代码</p></figure><h2 id="0634" class="ov ni iq bd nj ow ox dn nn oy oz dp nr lo pa pb nt ls pc pd nv lw pe pf nx iw bi translated">结果提取</h2><p id="298d" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">在预处理之后，我们将定义一个函数来提取弯矩(上一个教程的简化版)，并将其命名为“get_plate()”。</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="4019" class="on ni iq oj b be oo op l oq or">def get_plate(plate_o,phase_o):<br/><br/><br/>    plateY=g_o.getresults(plate_o,phase_o,g_o.ResultTypes.Plate.Y, "node")<br/>    plateM=g_o.getresults(plate_o,phase_o,g_o.ResultTypes.Plate.M2D, "node")<br/><br/><br/>    phasename=str(phase_o.Identification).split('[')[0]<br/>    col1='Bending Moment [kNm/m]'+'_'+phasename<br/><br/><br/>    results = {'Y': plateY,col1: plateM}<br/><br/><br/>    plateresults=pd.DataFrame(results)<br/>    plateresults = plateresults.sort_values(by=['Y'],ascending=False)<br/><br/><br/>    return plateresults</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi of"><img src="../Images/34377f2787ba21fb08e85532e12f02d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plp7MXFNjl328XK7fhPGdQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 VS 代码</p></figure><h2 id="e562" class="ov ni iq bd nj ow ox dn nn oy oz dp nr lo pa pb nt ls pc pd nv lw pe pf nx iw bi translated">导出到 Excel</h2><p id="26c4" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">与上一个教程不同，我们想要从多个阶段而不是单个阶段提取结果。因此，需要修改“export_excel()”函数。涉及三个动作:</p><ol class=""><li id="9f39" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma mg mh mi mj bi translated">遍历当前模型中现有阶段的名称</li><li id="e161" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">与用户输入的阶段(即阶段 3、4 和 5)进行交叉检查。</li><li id="17e0" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">如果匹配，则提取结果并导出到单个工作表(例如 Plate_1_Phase_3)</li><li id="b3c6" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma mg mh mi mj bi translated">将结果合并到新的数据框架中，并导出到工作表(' combined_Plate_1 ')</li></ol><p id="6bb0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些操作可以用下面的代码来完成。我们来分解一下！</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="9eef" class="on ni iq oj b be oo op l oq or">def export_excel(plate_input,phase_input,filename):<br/>    writer = pd.ExcelWriter(filename, engine='xlsxwriter')<br/>    combined=[]<br/>    for i in range(len(phase)):<br/>        for j in range(len(phase_input)):<br/>            if phase[i].Identification == phase_input[j]:<br/>                name=str(phase[i].Identification).split(' [')[1]<br/>                name=name.split(']')[0]<br/>                sheet_name = "%s_%s" % (plate[0].Name, name)<br/>                results = get_plate(plate[0], phase[i])<br/>                combined.append(results)<br/>                results.to_excel(writer,sheet_name=sheet_name,index=False)<br/><br/><br/>    combinedsheet='combined'+'_'+str(plate[0].Name)<br/>    combined=pd.concat(combined, axis=1)<br/>    combined.to_excel(writer,sheet_name=combinedsheet,index=False)<br/>    writer.save()<br/><br/><br/><br/>export_excel(plate_input,phase_input,FILENAME)</span></pre><ul class=""><li id="e41d" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">我们需要首先定义一个空列表“combined=[ ]”。这允许我们将每个阶段提取的结果附加到一个列表中，这样我们可以在最后一步将它们连接起来。</li><li id="5886" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">下一步是遍历模型的现有阶段，看看哪个阶段与我们的输入相匹配。这是使用 PLAXIS 命令“阶段[i]”完成的。“标识”,给出每个阶段的全名。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="9e30" class="on ni iq oj b be oo op l oq or">for i in range(len(phase)):<br/>        for j in range(len(phase_input)):<br/>            if phase[i].Identification == phase_input[j]:</span></pre><ul class=""><li id="b30d" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">以下代码用于命名目的。例如，“相位[0]”。“识别”将给出“支柱安装[阶段 3]”。我想得到位于方括号[ ]之间的“Phase_3”。然后，我将“Plate_1”和“Phase_3”组合起来，形成工作表名称。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="86d5" class="on ni iq oj b be oo op l oq or">name=str(phase[i].Identification).split(' [')[1]<br/>name=name.split(']')[0]<br/>sheet_name = "%s_%s" % (plate[0].Name, name)</span></pre><ul class=""><li id="a173" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">使用“get_plate()”函数提取 PLate_1 在每个阶段的弯矩，并将其存储为结果。然后通过“combined.append(results)”方法将结果追加到“组合”列表中。最后，使用“results.to_excel(writer，sheet_name=sheet_name，index=False)”将每个阶段的结果导出到单个工作表中。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="5b32" class="on ni iq oj b be oo op l oq or">results = get_plate(plate[0], phase[i])<br/>combined.append(results)<br/>results.to_excel(writer,sheet_name=sheet_name,index=False)</span></pre><ul class=""><li id="5f21" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">最后四行旨在合并“合并”列表中的结果，并导出到“合并 _ 板 _1”工作表。这是通过 pandas 的方法' concat()'完成的。输入“axis=1”作为参数是很重要的，因为它告诉 pandas 水平组合结果(按行)。默认情况下，“轴=0”垂直组合结果(按列)。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="73f4" class="on ni iq oj b be oo op l oq or">combinedsheet='combined'+'_'+str(plate[0].Name<br/>combined=pd.concat(combined, axis=1)<br/>combined.to_excel(writer,sheet_name=combinedsheet,index=False)<br/>writer.save())</span></pre><p id="306a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">您的最终脚本应该是这样的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ph"><img src="../Images/982b0d72c4987c1332563036bce71240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jms_WgeGo9DbVwXVe3ENKA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 VS 代码</p></figure><p id="138c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">既然我们已经从所有阶段提取了结果，那么我们可以继续使用 Python 在 Excel 中创建图。</p><h1 id="174a" class="nh ni iq bd nj nk nl nm nn no np nq nr kf ns kg nt ki nu kj nv kl nw km nx ny bi translated">步骤 3:使用 Excel 中的绘图和 Openpyxl 比较不同阶段的结果</h1><p id="71dc" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">最后，我们将学习 Openpyxl，它是一个允许我们创建 Excel 绘图的模块。</p><p id="609e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们创建一个函数，称它为“get_combined_plot()”。</p><ul class=""><li id="f7bb" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">df_inter 存储从“combined_Plate_1”获得的数据帧。工作表是我指定工作表' combined_Plate_1 '的地方，这样我可以在那里创建绘图。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="c388" class="on ni iq oj b be oo op l oq or">def get_combined_plot(filename,sheetname):<br/>    df_inter = pd.read_excel(filename, sheet_name = sheetname,engine="openpyxl")<br/>    wb=load_workbook(filename)<br/>    sheet=wb[sheetname]</span></pre><ul class=""><li id="5d2b" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">然后，创建一个名为“chart1”的图表对象，这是一个散点图。之后，我们使用 openpyxl 方法(x_axis.title 和 y_axis.title)分配轴标题。</li><li id="3b0c" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated"><em class="ot"> yvalue </em>使用方法“Reference()”存储结果的 Y 坐标。</li><li id="b0ca" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated"><em class="ot">位置</em> &amp; <em class="ot">船头</em>是我指定剧情的位置。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="e794" class="on ni iq oj b be oo op l oq or">    chart1=ScatterChart()<br/>    chart1.x_axis.title = 'Bending Moment (kNm/m)'<br/>    chart1.y_axis.title = 'RL (m)'<br/>    chart={'chart1':chart1} <br/>    yvalue=Reference(sheet,min_col=1,min_row=2,max_row=len(df_inter)+1)<br/>    position='G'<br/>    prow=1</span></pre><ul class=""><li id="5759" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">然后，从第二列中提取弯矩值，并将其存储在<em class="ot">值</em>中。</li><li id="a924" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">一旦我们有了 x 轴和 y 轴的数据，我们使用' Series()'创建一个系列，并使用' chart1.series.append(series)'将它分配给' chart1 '。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="2efb" class="on ni iq oj b be oo op l oq or">    if df_inter.columns.values[1].split(' [')[0] == 'Bending Moment'<br/>        value=Reference(sheet,min_col=2,min_row=2,max_row=len(df_inter)+1)<br/>        series=Series(yvalue,value,title=list(df_inter.columns.values)[1])<br/><br/>        chart1.series.append(series):</span></pre><ul class=""><li id="1af6" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">以下代码主要用于设置绘图样式的格式，如高度、刻度框和图例位置等(类似于典型的 excel 绘图设置)。官方文档中概述了更多的格式细节:</li></ul><div class="mp mq gp gr mr ms"><a href="https://openpyxl.readthedocs.io/en/stable/charts/introduction.html" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ja gy z fp mx fr fs my fu fw iz bi translated">图表- openpyxl 3.0.10 文档</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">默认情况下，图表的左上角锚定到单元格 E15，大小为 15 x 7.5 厘米(大约 5 列…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">openpyxl.readthedocs.io</p></div></div></div></a></div><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="c959" class="on ni iq oj b be oo op l oq or">    charts='chart1'<br/>    chart[charts].height=15<br/>    chart[charts].y_axis.tickLblPos = 'low'<br/>    chart[charts].legend.position = 'b'<br/><br/><br/>    if ord(position)&lt;89 and prow&lt;=2:<br/>        sheet.add_chart(chart[charts], position+str(1))<br/>    position=chr(ord(position)+10)<br/>    prow=prow+1<br/>    wb.save(filename)</span></pre><ul class=""><li id="9861" class="mb mc iq lh b li lj ll lm lo md ls me lw mf ma oh mh mi mj bi translated">上述步骤使用前两列(即“Y”和“弯矩[kNm/m]_ 支柱安装”)创建了绘图</li><li id="6cfa" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">最后一步是遍历其余的列，并将它们作为两个额外的系列添加到现有的绘图中。</li><li id="e322" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">为了识别柱中是否包含 Y 坐标或弯矩，我们需要使用 if-else 语句。</li><li id="162c" class="mb mc iq lh b li mk ll ml lo mm ls mn lw mo ma oh mh mi mj bi translated">如果列标题是' Y '，它将把列值存储到 y <em class="ot">值</em>(即 Y 轴)。如果列标题包含“弯矩”，它会将列值存储到<em class="ot">值</em>(即 x 轴)。</li></ul><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="9453" class="on ni iq oj b be oo op l oq or">    for i in range(3,len(df_inter.columns)+1):<br/>        if df_inter.columns.values[i-1].split('.')[0] != 'Y':<br/>            if df_inter.columns.values[i-1].split(' [')[0] == 'Bending Moment':<br/>                value=Reference(sheet,min_col=i,min_row=2,max_row=len(df_inter)+1)<br/>                series=Series(yvalue,value,title=list(df_inter.columns.values)[i-1])<br/>                chart1.series.append(series)<br/>        elif df_inter.columns.values[i-1].split('.')[0] == 'Y':<br/>            yvalue=Reference(sheet,min_col=i,min_row=2,max_row=len(df_inter)+1)      <br/>    wb.save(filename)</span></pre><p id="d934" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最终的脚本如下所示:</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="5d9c" class="on ni iq oj b be oo op l oq or">def get_combined_plot(filename,sheetname):<br/>    df_inter = pd.read_excel(filename, sheet_name = sheetname,engine="openpyxl")<br/>    wb=load_workbook(filename)<br/>    sheet=wb[sheetname]<br/><br/><br/>    chart1=ScatterChart()<br/>    chart1.x_axis.title = 'Bending Moment (kNm/m)'<br/>    chart1.y_axis.title = 'RL (m)'<br/>    chart={'chart1':chart1} <br/>    xvalue=Reference(sheet,min_col=1,min_row=2,max_row=len(df_inter)+1)<br/>    position='G'<br/>    prow=1<br/><br/><br/>    if df_inter.columns.values[1].split(' [')[0] == 'Bending Moment':<br/>        value=Reference(sheet,min_col=2,min_row=2,max_row=len(df_inter)+1)<br/>        series=Series(xvalue,value,title=list(df_inter.columns.values)[1])<br/><br/><br/>        chart1.series.append(series)<br/>        <br/>    charts='chart1'<br/>    chart[charts].height=15<br/>    chart[charts].y_axis.tickLblPos = 'low'<br/>    chart[charts].legend.position = 'b'<br/><br/><br/>    if ord(position)&lt;89 and prow&lt;=2:<br/>        sheet.add_chart(chart[charts], position+str(1))<br/>    position=chr(ord(position)+10)<br/>    prow=prow+1<br/>    wb.save(filename)<br/><br/><br/>    for i in range(3,len(df_inter.columns)+1):<br/>        if df_inter.columns.values[i-1].split('.')[0] != 'Y':<br/>            if df_inter.columns.values[i-1].split(' [')[0] == 'Bending Moment':<br/>                value=Reference(sheet,min_col=i,min_row=2,max_row=len(df_inter)+1)<br/>                series=Series(xvalue,value,title=list(df_inter.columns.values)[i-1])<br/>                chart1.series.append(series)<br/>        elif df_inter.columns.values[i-1].split('.')[0] == 'Y':<br/>            xvalue=Reference(sheet,min_col=i,min_row=2,max_row=len(df_inter)+1)      <br/>    wb.save(filename)                    <br/><br/><br/>combinedsheet='combined_Plate_1'<br/>get_combined_plot(FILENAME,combinedsheet)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pi"><img src="../Images/e56cbf0bf6f1ec5d58196452e10edb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Mbfa9S53o2O2ybjVM_vhQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 VS 代码</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pj"><img src="../Images/6f0f1a462af63f16cdc6a7efcf804a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-sUhSF3oDEuEmQTi-fuWA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 VS 代码</p></figure><p id="e876" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用以下命令运行脚本。</p><pre class="kp kq kr ks gt oi oj ok bn ol om bi"><span id="58a4" class="on ni iq oj b be oo op l oq or">(PLAXIS) C:\Users\phtsang\Desktop\PLAXIS_V22\Script&gt;python plot_plate_combine.py</span></pre><p id="f5c6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，如果您在之前指定的位置打开 excel 电子表格，并转到“combined_Plate_1”工作表。你可以看到我们已经提取了所有三个相位的 Y 坐标和弯矩。更重要的是，我们有一个包含所有结果的图，可以让我们比较不同阶段的弯矩！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pk"><img src="../Images/723bb6d4ebac90ef9b740b93758cd5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yC1xflvlZuPY5F8fxeeDsg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">作者截图自 excel</p></figure><p id="d9e1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">太棒了。您已经成功地从 PLAXIS 中提取了结果，并使用它们通过 Python 在 Excel 中创建了一个图。</p><h1 id="a92e" class="nh ni iq bd nj nk nl nm nn no np nq nr kf ns kg nt ki nu kj nv kl nw km nx ny bi translated">结论</h1><p id="9de2" class="pw-post-body-paragraph lf lg iq lh b li nz ka lk ll oa kd ln lo ob lq lr ls oc lu lv lw od ly lz ma ij bi translated">以上是关于使用 Python 实现 PLAXIS 输出可视化的第三篇教程。到目前为止，您应该能够提取多个阶段的结果，并在 excel 中创建图表以进行结果比较。这可以进一步扩展到包括不同阶段的多个结构元素，这意味着整个输出提取过程可以自动化。我将在以后的教程中进一步讨论这一点。</p><p id="a65b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你喜欢阅读这类内容，请随时关注我的页面。我将继续发布这一系列关于用 Python 自动化 PLAXIS 的教程。除此之外，我还热衷于分享关于如何使用 Python 来自动化工程中的工作流的知识。</p></div></div>    
</body>
</html>