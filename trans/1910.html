<html>
<head>
<title>14 Best Practices to Tune BigQuery SQL Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化BigQuery SQL性能的14个最佳实践</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/14-ways-to-optimize-bigquery-sql-for-ferrari-speed-at-honda-cost-632ec705979#2022-05-03">https://towardsdatascience.com/14-ways-to-optimize-bigquery-sql-for-ferrari-speed-at-honda-cost-632ec705979#2022-05-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ba7e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的查询跑得像法拉利一样快，但像本田一样便宜。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6319450f4a8c679c82bdd28cb084af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAbwJbmVtkdm6jB7AC7Amg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">数据管道类似于管道——我们需要在它破裂之前修复漏洞。图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6195292" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/elf-moondance-19728901/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=6195292" rel="noopener ugc nofollow" target="_blank">精灵月舞</a>。</p></figure><p id="c110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> P </span>优化不当的SQL查询就像管道内壁上的裂缝——几乎不能保持水分。当水压较低时，会有轻微的漏水，但一切仍然正常。当我们加大负荷时，噩梦就开始了。曾经可以忽略不计的裂缝现在突然大开，我们开始消耗资源，直到基础设施的完整性崩溃。</p><p id="60b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着大数据的激增，数据管道必须处理大量负载，成本越来越容易失控。查询不再仅仅是编写一个运行的语法。它还需要经济高效且快速。</p><p id="7bfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在服务器崩溃了太多次之后，我想是时候开始问… <em class="me">如何</em>？</p><ul class=""><li id="e838" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">第一:限制是一个陷阱。</li><li id="9f8d" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#754f" rel="noopener ugc nofollow"> #2:选择尽可能少的列。</a></li><li id="aa72" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#19aa" rel="noopener ugc nofollow"> #3:用EXISTS()代替COUNT()。</a></li><li id="1476" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#f633" rel="noopener ugc nofollow"> #4:使用近似聚合函数。</a></li><li id="1404" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#f255" rel="noopener ugc nofollow"> #5:用Windows函数替换自加入。</a></li><li id="78a2" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#e447" rel="noopener ugc nofollow"> #6:按INT64列排序或联接。</a></li><li id="5d34" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">优化你的反连接。</li><li id="33e8" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">尽早并经常整理你的数据。</li><li id="4e52" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#d951" rel="noopener ugc nofollow"> #9:顺序很重要(？)</a></li><li id="6920" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">利用分区和/或集群。</li><li id="7cd6" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#6dee" rel="noopener ugc nofollow"> #11:将订单按推至查询末尾(？)</a></li><li id="b804" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#509b" rel="noopener ugc nofollow"> #12:延迟资源密集型操作。</a></li><li id="eb51" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#780b" rel="noopener ugc nofollow"> #13:使用搜索()。</a></li><li id="63b2" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><a class="ae ky" href="#f148" rel="noopener ugc nofollow"> #14:利用缓存。</a></li></ul><p id="ba5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">注1:这里所有的查询都是基于</em> <a class="ae ky" href="https://cloud.google.com/bigquery/public-data" rel="noopener ugc nofollow" target="_blank"> <em class="me"> BigQuery公共数据</em> </a> <em class="me">编写的，每个人都可以访问。换句话说，您可以将查询复制并粘贴到BigQuery中，自己尝试查询。</em></p><p id="f8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="me">注2:虽然我们在本文中使用的是BigQuery，但是这里描述的大部分优化技术都是通用的SQL最佳实践，可以应用到其他平台，比如Amazon Redshift、MySQL、Snowflakes等。</em></p><h1 id="09d3" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#1:限制是一个陷阱。</h1><blockquote class="nl nm nn"><p id="61b9" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践</strong> : <code class="fe nr ns nt nu b">LIMIT</code>提高了性能，但没有降低成本。对于数据探索，可以考虑使用BigQuery的(免费)表预览选项。</p></blockquote><p id="37b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不得不说——</p><p id="2593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数SQL从业者曾经被<code class="fe nr ns nt nu b">LIMIT 1000</code>歪曲的安全错觉所欺骗。完全有理由假设，如果我们只显示1000行输出，数据库的负载会更少，因此成本会更低。</p><p id="3319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这不是真的。</p><p id="6d6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在 SQL数据库扫描全部数据后，<code class="fe nr ns nt nu b">LIMIT</code>子句的行限制应用于<em class="me">。更糟糕的是——大多数分布式数据库(包括BigQuery)基于数据扫描收费，但<em class="me">而不是</em>输出，这就是为什么<code class="fe nr ns nt nu b">LIMIT</code>不能帮助节省一毛钱。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/34b697c2529fa0e101581aecd01d17d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WAmX_JAQAAKpAuBCyaqg2A.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LIMIT子句通过减少洗牌时间来提高性能。图片由作者提供。</p></figure><p id="403a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并不都是悲观的。由于<code class="fe nr ns nt nu b">LIMIT</code>对输出行设置了上限，我们需要在BigQuery的网络上移动更少的数据。这种字节重排的减少显著提高了查询性能。</p><p id="4e6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行演示，我使用了BigQuery公共数据存储库中的<code class="fe nr ns nt nu b">crypto_ethereum</code>表，其中有1500万行数据。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="45df" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="b0ab" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  miner<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`</span><span id="c5a3" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 11s<br/>Slot Time      : 162s<br/>Bytes Processed: 617 MB<br/>Bytes Shuffled : 1.7 GB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="a539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe nr ns nt nu b">LIMIT</code>再次尝试查询。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="f804" class="oa mu it nu b gy ob oc l od oe"># Optimized (for speed only)</span><span id="06ef" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  miner<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`<br/>LIMIT<br/>  1000</span><span id="dbc8" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 2s<br/>Slot Time      : 0.01s<br/>Bytes Processed: 617 MB<br/>Bytes Shuffled : 92 KB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="0047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nr ns nt nu b">LIMIT</code>提高了速度，但不增加成本。</p><ul class=""><li id="f84e" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">成本:处理的字节保持不变，仍为617 MB。</li><li id="09d0" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">速度:字节混洗从1.7 GB下降到仅仅92 KB，这解释了槽时间的巨大改进(从162秒到0.01秒)。</li></ul><p id="4620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然使用<code class="fe nr ns nt nu b">LIMIT</code>总比没有好，但是如果纯粹是为了研究表格，还有更好的选择。我强烈推荐使用BigQuery的表预览选项。这个特性允许我们一页一页地浏览表格，一次最多200行，而且完全免费。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/706965900aeec0462dba06a9afa9381b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*GUq9WkPsPxiJVsKaNDkHoA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">BigQuery的表预览选项对于探索表结构非常有用。截图摘自<a class="ae ky" href="https://console.cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>。</p></figure><p id="be69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了成本优化，限制使用<code class="fe nr ns nt nu b">LIMIT</code>。</p><h1 id="754f" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#2:选择尽可能少的列。</h1><blockquote class="nl nm nn"><p id="a57c" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践:</strong>避免使用<code class="fe nr ns nt nu b">SELECT *</code>。只选择您需要的相关列，以避免不必要的、代价高昂的全表扫描。<a class="ae ky" href="https://cloud.google.com/bigquery/docs/best-practices-costs#avoid_select_" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="9065" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">BigQuery不是传统的基于行的数据库，而是一个<a class="ae ky" href="https://dataschool.com/data-modeling-101/row-vs-column-oriented-databases/" rel="noopener ugc nofollow" target="_blank">列</a>数据库。这种区别是有意义的，因为它读取数据的方式不同。</p><p id="22b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个表有100列，但是我们的查询只需要2个特定列的数据，那么基于行的数据库将遍历每一行——每行的所有100列——只提取感兴趣的2列。相比之下，列数据库将只处理2个相关的列，这有助于更快的读取操作和更有效的资源利用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/0d10a4bf69e95f7eb2dd8bf18dd2e730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8XPAxKlxZf123feNQagrSw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基于行的数据库和基于列的数据库读取数据是不同的。图片由作者提供。</p></figure><p id="5eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个典型的查询，写起来很快，但是运行起来很慢。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="2b16" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="5119" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  *<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`</span><span id="40a6" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 23s<br/>Slot Time      : 31 min<br/>Bytes Processed: 15 GB<br/>Bytes Shuffled : 42 GB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="a873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于列数据库可以跳过列，我们可以利用这一点，只查询我们需要的列。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="7a56" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="7689" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  timestamp,<br/>  number,<br/>  transactions_root,<br/>  state_root,<br/>  receipts_root,<br/>  miner,<br/>  difficulty,<br/>  total_difficulty,<br/>  size,<br/>  extra_data,<br/>  gas_limit,<br/>  gas_used,<br/>  transaction_count,<br/>  base_fee_per_gas<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`</span><span id="c452" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 35s<br/>Slot Time      : 12 min<br/>Bytes Processed: 5 GB<br/>Bytes Shuffled : 11 GB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="12ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，查询成本降低了3倍，因为我们需要处理的字节从15 GB减少到了5 GB。除此之外，我们还观察到，随着时隙时间从31分钟减少到12分钟，性能有所提高。</p><p id="edc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的唯一缺点是我们需要输入列名，这可能很麻烦，尤其是当我们的任务需要大部分列时，除了少数几个。在这种情况下，并不是所有的都丢失了，我们可以利用<code class="fe nr ns nt nu b">EXCEPT</code>语句来排除不必要的列。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="e6af" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="349c" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  *<br/>  EXCEPT (<br/>    `hash`,<br/>    parent_hash,<br/>    nonce,<br/>    sha3_uncles,<br/>    logs_bloom)<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`</span><span id="b7e3" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 35s<br/>Slot Time      : 12 min<br/>Bytes Processed: 5 GB<br/>Bytes Shuffled : 11 GB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="6be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除非绝对必要，否则避免<code class="fe nr ns nt nu b">SELECT *</code>。</p><h1 id="19aa" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#3:使用EXISTS()而不是COUNT()。</h1><blockquote class="nl nm nn"><p id="df4c" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践</strong>:如果我们不需要精确的计数，使用<code class="fe nr ns nt nu b">EXISTS()</code>，因为一旦找到第一个匹配行，它就退出处理循环。<a class="ae ky" href="https://www.oreilly.com/library/view/microsoft-sql-server/9780133408539/ch45lev2sec6.html" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="63f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当探索一个全新的数据集时，有时我们发现自己需要检查特定值的存在。我们有两个选择，要么用<code class="fe nr ns nt nu b">COUNT()</code>计算值的频率，要么检查值<code class="fe nr ns nt nu b">EXISTS()</code>是否。如果我们不需要知道值出现的频率，总是使用<code class="fe nr ns nt nu b">EXISTS()</code>来代替。</p><p id="2cbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为一旦找到第一个匹配行，<code class="fe nr ns nt nu b">EXISTS()</code>就会退出处理循环，如果找到目标值，则返回<code class="fe nr ns nt nu b">True</code>,如果目标值不在表中，则返回<code class="fe nr ns nt nu b">False</code>。</p><p id="4685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，<code class="fe nr ns nt nu b">COUNT()</code>将继续搜索整个表，以便返回目标值的准确出现次数，浪费不必要的计算资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/ffc77aedb53cebc9f142d575fcd4e262.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*gCmrwRGYLxH3Q2hD0WZCRQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一旦找到匹配项，EXISTS()子句就退出处理。图片由作者提供。</p></figure><p id="2a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想知道值<code class="fe nr ns nt nu b">6857606</code>是否存在于<code class="fe nr ns nt nu b">number</code>列中，我们使用了<code class="fe nr ns nt nu b">COUNT()</code>函数…</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="d957" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="8d1e" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  COUNT(number) AS count<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`<br/>WHERE<br/>  timestamp BETWEEN '2018-12-01' AND '2019-12-31'<br/>  AND number = 6857606</span><span id="a8a9" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 6s<br/>Slot Time      : 16s<br/>Bytes Processed: 37 MB<br/>Bytes Shuffled : 297 B<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="9f88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为只有一行与值匹配，所以<code class="fe nr ns nt nu b">COUNT()</code>返回1。现在，让我们用<code class="fe nr ns nt nu b">EXISTS()</code>来代替。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="e648" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="b53e" class="oa mu it nu b gy of oc l od oe">SELECT EXISTS (<br/>  SELECT<br/>    number<br/>  FROM<br/>    `bigquery-public-data.crypto_ethereum.blocks`<br/>  WHERE<br/>    timestamp BETWEEN "2018-12-01" AND "2019-12-31"<br/>    AND number = 6857606<br/>)</span><span id="186e" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 0.7s<br/>Slot Time      : 0.07s<br/>Bytes Processed: 37 MB<br/>Bytes Shuffled : 11 B<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="5e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询返回<code class="fe nr ns nt nu b">True</code>，因为该值存在于表中。使用<code class="fe nr ns nt nu b">EXISTS()</code>函数，我们不会得到关于其频率的信息，但是作为回报，查询性能得到了极大的提高——从16秒减少到0.07秒。</p><p id="58cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">难道不庆幸<code class="fe nr ns nt nu b">EXISTS()</code>功能的存在吗？</p><h1 id="f633" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#4:使用近似聚合函数。</h1><blockquote class="nl nm nn"><p id="5b77" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践</strong>:当你有一个大的数据集，并且你不需要精确的计数时，使用近似聚合函数。<a class="ae ky" href="https://cloud.google.com/bigquery/docs/best-practices-performance-compute#use_approximate_aggregation_functions" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="0a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nr ns nt nu b">COUNT()</code>扫描整个表以确定出现的次数。因为这是逐行进行的，所以操作将以O(n)的时空复杂度运行。对具有数亿行的大数据执行这样的操作将很快变得不可行，因为它需要大量的计算资源。</p><p id="353e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了加剧性能问题，<code class="fe nr ns nt nu b">COUNT(DISTINCT)</code>将需要大量的计算机内存来记录每个用户的唯一id。当列表超过内存容量时，多余的容量会溢出到磁盘中，导致性能急剧下降。</p><p id="ea84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在数据量很大的情况下，通过使用近似聚合函数来牺牲准确性以换取性能可能对我们最有利。例如:-</p><ul class=""><li id="7540" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions#approx_count_distinct" rel="noopener ugc nofollow" target="_blank">APPROX_COUNT_DISTINCT()</a></code></li><li id="e47d" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions#approx_quantiles" rel="noopener ugc nofollow" target="_blank">APPROX_QUANTILES()</a></code></li><li id="1576" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions#approx_top_count" rel="noopener ugc nofollow" target="_blank">APPROX_TOP_COUNT()</a></code></li><li id="cfcf" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions#approx_top_sum" rel="noopener ugc nofollow" target="_blank">APPROX_TOP_SUM()</a></code></li><li id="950f" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b"><a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions#hyperloglog_functions" rel="noopener ugc nofollow" target="_blank">HYPERLOGLOG++</a></code></li></ul><p id="37db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与通常的强力方法不同，近似聚合函数使用统计信息来产生近似结果，而不是精确结果。预计误差率1~2%。因为我们没有运行全表扫描，所以近似聚合函数在内存使用和时间方面是高度可伸缩的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/de89e1947eecaa6aea4f98f47ac27702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*H_AsGvUAQq9CdN_m45hTrA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">近似聚合函数使用统计信息快速提供近似结果。<a class="ae ky" href="https://www.flaticon.com/free-icon/statistics_2920326?k=1650474651450" rel="noopener ugc nofollow" target="_blank">放大镜</a>图标来自Flaticon的Freepik，经作者允许编辑。</p></figure><p id="5a9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们对220万个块中唯一以太坊矿工的数量感兴趣，我们可以运行以下查询…</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="1048" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="a635" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  COUNT(DISTINCT miner)<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`<br/>WHERE<br/>  timestamp BETWEEN '2019-01-01' AND '2020-01-01'</span><span id="1268" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 3s<br/>Slot Time      : 14s<br/>Bytes Processed: 110 MB<br/>Bytes Shuffled : 939 KB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="0690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">COUNT(DISTINCT)</code>函数返回了573名矿工，但用了14名矿工。我们可以将其与<code class="fe nr ns nt nu b">APPROX_COUNT_DISTINCT()</code>进行比较。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="0926" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="aff0" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  APPROX_COUNT_DISTINCT(miner)<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`<br/>WHERE<br/>  timestamp BETWEEN '2019-01-01' AND '2020-01-01'</span><span id="1fc5" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 2s<br/>Slot Time      : 7s<br/>Bytes Processed: 110 MB<br/>Bytes Shuffled : 58 KB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="2aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">令我高兴的是，<code class="fe nr ns nt nu b">APPROX_COUNT_DISTINCT()</code>返回了573名矿工的正确数字(运气？)在一半的时隙时间内。即使只有220万行数据，性能上的差异也很明显，但我想随着表变大，这种差异会对我们有利。</p><p id="600b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当不需要超精确计算时，请考虑使用近似聚合函数来获得更高水平的响应。</p><h1 id="f255" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#5:用Windows函数替换自连接。</h1><blockquote class="nl nm nn"><p id="2444" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated">最佳实践:自连接总是低效的，应该只在绝对必要的时候使用。在大多数情况下，我们可以用窗口函数来代替它。<a class="ae ky" href="https://cloud.google.com/bigquery/docs/best-practices-performance-patterns#self-joins" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="3128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自联接是指表与自身相联接。当我们需要一个表引用它自己的数据时，这是一个常见的连接操作，通常是在父子关系中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/4956c0fc18b251e039759fcab0b64236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yw5pF0c5Xz2w6X_BZspEWg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自联接通常比windows函数需要更多的读取，因此速度较慢。图片由作者提供。</p></figure><p id="b6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的用例——带有manager_id列的Employee表包含所有雇员和助理经理(也是公司的雇员)的行记录，他们也可能有自己的经理。要获得所有员工及其直接主管的列表，我们可以使用employee_id = manager_id执行自联接。</p><p id="d5d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这通常是一种SQL反模式，因为它可能会使输出行数平方，或者强制进行大量不必要的读取，随着表变大，这会成倍地降低我们的查询性能。</p><p id="d8ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想知道每个矿工今天和昨天开采的以太坊块数之间的差异，我们可以编写一个自连接，尽管这是低效的</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="7a5e" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="9f90" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_table AS (<br/>  SELECT<br/>    DATE(timestamp) AS date,<br/>    miner,<br/>    COUNT(DISTINCT number) AS block_count<br/>  FROM<br/>    `bigquery-public-data.crypto_ethereum.blocks`<br/>  WHERE<br/>    DATE(timestamp) BETWEEN "2022-03-01"<br/>    AND "2022-03-31"<br/>  GROUP BY<br/>    1,2<br/>  )</span><span id="9b4c" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  a.miner,<br/>  a.date AS today,<br/>  a.block_count AS today_count,<br/>  b.date AS tmr,<br/>  b.block_count AS tmr_count,<br/>  b.block_count - a.block_count AS diff<br/>FROM<br/>  cte_table a<br/>LEFT JOIN<br/>  cte_table b<br/>  ON<br/>    DATE_ADD(a.date, INTERVAL 1 DAY) = b.date<br/>    AND a.miner = b.miner<br/>ORDER BY<br/>  a.miner,<br/>  a.date</span><span id="4fed" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 12s<br/>Slot Time      : 36s<br/>Bytes Processed: 12 MB<br/>Bytes Shuffled : 24 MB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="2e1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与执行自连接相比，窗口功能与导航功能<code class="fe nr ns nt nu b">LEAD()</code>相结合将是更好的方法。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="1eff" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="4e47" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_table AS (<br/>    SELECT<br/>      DATE(timestamp) AS date,<br/>      miner,<br/>      COUNT(DISTINCT number) AS block_count<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.blocks`<br/>    WHERE<br/>      DATE(timestamp) BETWEEN "2022-03-01" AND "2022-03-31"<br/>    GROUP BY<br/>      1,2<br/>  )</span><span id="9778" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  miner,<br/>  date AS today,<br/>  block_count AS today_count,<br/>  LEAD(date, 1) OVER (PARTITION BY miner ORDER BY date) AS tmr,<br/>  LEAD(block_count, 1) OVER (PARTITION BY miner ORDER BY date) AS tmr_count,<br/>  LEAD(block_count, 1) OVER (PARTITION BY miner ORDER BY date) - block_count AS diff<br/>FROM<br/>  cte_table a</span><span id="caf0" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 3s<br/>Slot Time      : 14s<br/>Bytes Processed: 12 MB<br/>Bytes Shuffled : 12 MB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="73c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个查询给出了相同的结果，但是使用后一种方法在查询速度上有了显著的提高(从36秒的时间段减少到14秒的时间段)。</p><p id="c0c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe nr ns nt nu b">LEAD()</code>函数之外，还有很多其他的<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions" rel="noopener ugc nofollow" target="_blank">导航</a>、<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions" rel="noopener ugc nofollow" target="_blank">编号</a>和<a class="ae ky" href="https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions" rel="noopener ugc nofollow" target="_blank">聚合分析</a>函数可以用来代替自连接操作。就我个人而言，这些是我在日常工作中经常使用的功能</p><ul class=""><li id="0d1e" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">导航功能:<code class="fe nr ns nt nu b">LEAD()</code>，<code class="fe nr ns nt nu b">LAG()</code></li><li id="ad03" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">编号功能:<code class="fe nr ns nt nu b">RANK()</code>，<code class="fe nr ns nt nu b">ROW_NUMBER()</code></li><li id="42fd" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">聚合分析函数:<code class="fe nr ns nt nu b">SUM()</code>、<code class="fe nr ns nt nu b">AVG()</code>、<code class="fe nr ns nt nu b">MAX()</code>、<code class="fe nr ns nt nu b">MIN()</code>、<code class="fe nr ns nt nu b">COUNT()</code></li></ul><p id="67e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一次你看到自加入时，提醒自己它们只是机会之窗，让你灵活掌握窗口功能。</p><h1 id="e447" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#6:在INT64列上的ORDER BY或JOIN。</h1><blockquote class="nl nm nn"><p id="4b6d" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践</strong>:当您的用例支持时，总是优先比较<code class="fe nr ns nt nu b">INT64</code>，因为评估<code class="fe nr ns nt nu b">INT64</code>数据类型比评估字符串更便宜。<a class="ae ky" href="https://cloud.google.com/bigquery/docs/best-practices-performance-compute#use_int64_data_types_in_joins_to_reduce_cost_and_improve_comparison_performance" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="30d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">连接操作通过<em class="me">比较</em>它们的连接键将一个表映射到另一个表。如果连接键属于某些难以比较的数据类型，那么查询就会变得缓慢而昂贵。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/d540e1f8638626b6b8350ff71c2c4833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zkcZOqohl8tR6NAQ5W_yog.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的计算机比较整数比字符串快。图片由作者提供。</p></figure><p id="ff86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是，哪些数据类型很难比较，为什么？</p><p id="6fa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个原因是存储大小的不同。在我们的数据库中，每种数据类型都被分配了特定的存储空间块。确切的存储空间列在<a class="ae ky" href="https://cloud.google.com/bigquery/pricing#data" rel="noopener ugc nofollow" target="_blank"> BigQuery的定价页面</a>上。</p><p id="48e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档告诉我们，对于BigQuery，<code class="fe nr ns nt nu b">INT64</code>将总是占用8个字节的空间，不管它的长度如何，但是<code class="fe nr ns nt nu b">STRING</code>可以根据它的长度占用不同的空间。这里我们有点过于简化了，但是我们姑且说<code class="fe nr ns nt nu b">STRING</code> <em class="me">一般</em>占用2 + 4 * number_of_characters字节的存储，或者换句话说，比<code class="fe nr ns nt nu b">INT64</code>多很多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d79a28564074b18661eaf260ba588427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hQGRUgdlG3DgmU3BRDoUyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在计算机内存中，整数比字符串占用更少的存储空间。图片由作者提供。</p></figure><p id="6f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要数据科学家就能明白，扫描的字节越少，查询运行得越快。所以在存储大小部门，整数比字符串快。</p><p id="ebfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，<code class="fe nr ns nt nu b">INT64</code>比<code class="fe nr ns nt nu b">STRING</code>还有一个巨大的优势，那就是<a class="ae ky" href="https://database.guide/what-is-collation-in-databases/" rel="noopener ugc nofollow" target="_blank">排序</a>。排序规则告诉我们的数据库如何对字符串进行排序和比较。例如，当我们运行ORDER BY子句时，排序规则决定了大写和小写是否应该被视为相同。它还关注重音、日语假名字符类型、区分宽度和区分变体选择器。</p><p id="74bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些排序规则都增加了<code class="fe nr ns nt nu b">STRING</code>比较的复杂性，这实际上降低了菠萝在查询中的速度。另一方面，我们并不关心所有这些，因为我们唯一能做的比较就是它们是比其他数字小还是大。</p><p id="1ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，加入<code class="fe nr ns nt nu b">STRING</code>到底有多糟糕？</p><p id="5030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我看到了Borna Almasi的一篇精彩的文章，他比较了列类型对连接速度的影响。他的实验发现，整数比字节快1.2倍，比字符串快约1.4倍。</p><p id="4e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一些比较的字符长度更短/更长，这可能导致读取的字节更少/更多，因此速度不同。出于好奇，我决定使用一种类似的方法，但是比较每个正好10个字符的字符串和整数。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="650a" class="oa mu it nu b gy ob oc l od oe">WITH<br/>  keys AS (<br/>    SELECT<br/>      *<br/>    FROM<br/>      UNNEST(GENERATE_ARRAY(1000000000,1001000000)) AS key<br/>  ),<br/>  keys_hashed AS (<br/>    SELECT<br/>      key AS key_int,<br/>      CAST(key AS STRING) AS key_str,<br/>      CAST(CAST(key AS STRING) AS BYTES) AS key_byte<br/>    FROM<br/>      keys<br/>  )</span><span id="5d1f" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  *<br/>FROM<br/>  keys_hashed a<br/>LEFT JOIN<br/>  keys_hashed b<br/>  ON a.key_int = b.key_int<br/>  -- Change to key_str/key_byte for other experiments</span></pre><p id="5648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实验中，我对每种数据类型运行了10次查询，并基于T统计量计算了误差幅度。以下是调查结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/952b76ca0a9a8ce4f771b3c2fba38ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*C0D1Vf5eWs4lYiFArPe-OQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">耗时只是连接阶段的持续时间，而不是整个查询的持续时间。相对持续时间越长，意味着性能越慢。图片由作者提供。</p></figure><p id="4cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们的样本数据数量非常有限，但看起来对<code class="fe nr ns nt nu b">INT64</code>应用连接操作比<code class="fe nr ns nt nu b">BYTE</code>产生的性能更好，其次是<code class="fe nr ns nt nu b">STRING</code>，提高了39%以上。</p><p id="7e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次你用DDL创建一个表时，我建议优先考虑<code class="fe nr ns nt nu b">INT64</code>。这是一个简单的策略，但是如果我们考虑未来对这个表的所有查询所获得的性能收益，它会带来巨大的好处。</p><h1 id="086f" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#7:优化你的反连接。</h1><blockquote class="nl nm nn"><p id="a50a" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践:</strong>而不是<code class="fe nr ns nt nu b">NOT IN</code>，使用<code class="fe nr ns nt nu b">NOT EXISTS</code>操作符来编写反连接，因为它会触发一个更加资源友好的查询执行计划。<a class="ae ky" href="https://www.sqlshack.com/t-sql-commands-performance-comparison-not-vs-not-exists-vs-left-join-vs-except/" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="aeaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数SQL从业者都熟悉<code class="fe nr ns nt nu b">JOIN</code>操作符，但是很少有人知道反连接。这并不是说它复杂或高级，而是我们很少关心命名约定。事实上，您自己可能也在不知不觉中编写了几个反联接运算符。</p><p id="83f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从字面上看，“反连接”是一个带有exclusion子句(<code class="fe nr ns nt nu b">WHERE NOT IN</code>、<code class="fe nr ns nt nu b">WHERE NOT EXISTS</code>等)的<code class="fe nr ns nt nu b">JOIN</code>操作符，如果它在第二个表中有匹配项，就删除这些行。</p><p id="b92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想知道“汽车”表中的哪些汽车没有发生事故，我们可以从“汽车”表中查询汽车列表，然后过滤掉那些出现在“事故”表中的汽车。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/3956f4fa889bcdf48a0e41e2610f57fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/1*l_ZK9qi2x7KFxBqR4h0MSw.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反连接返回存在于一个表中而不存在于另一个表中的结果。图片由作者提供。</p></figure><p id="8b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这一点，这里还有一个例子可以在BigQuery上尝试。假设我们已经跟踪所有以太坊矿工的名字超过2年，并且我们将数据存储在两个单独的表中(2019年和2020年)。我们在这里的目标是找出哪些2019年的矿工在2020年停止采矿。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="d5cf" class="oa mu it nu b gy ob oc l od oe">WITH<br/>  miner2019 AS (<br/>    SELECT DISTINCT<br/>      miner<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.blocks`<br/>    WHERE<br/>      DATE(timestamp) BETWEEN '2019-01-01' AND '2019-12-31'<br/>  ),<br/>  miner2020 AS (<br/>    SELECT DISTINCT<br/>      miner<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.blocks`<br/>    WHERE<br/>      DATE(timestamp) BETWEEN '2020-01-01' AND '2020-12-31'<br/>  )</span></pre><p id="72b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们拿出2019年矿工的名单，然后如果他们的名字出现在2020年的名单中，就把他们的名字去掉，那么我们应该会得到一份停止采矿的矿工名单。这是可以应用反连接的许多场景之一。不管是好是坏，我们有很多方法可以编写反联接子句。</p><ul class=""><li id="d07c" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b">LEFT JOIN</code>方法</li><li id="410c" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b">NOT EXISTS</code>方法</li><li id="8551" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b">NOT IN</code>法</li><li id="64f1" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated"><code class="fe nr ns nt nu b">EXCEPT DISTINCT</code>方法</li></ul><p id="a733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法如下:-</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="5b93" class="oa mu it nu b gy ob oc l od oe"># LEFT JOIN METHOD<br/>SELECT<br/>  a.miner<br/>FROM<br/>  miner2019 a<br/>LEFT JOIN<br/>  miner2020 b ON a.miner = b.miner<br/>WHERE<br/>  b.miner IS NULL<br/></span><span id="627c" class="oa mu it nu b gy of oc l od oe"># NOT EXISTS METHOD<br/>SELECT<br/>  a.miner<br/>FROM<br/>  miner2019 a<br/>WHERE NOT EXISTS<br/>  (SELECT b.miner FROM miner2020 b WHERE a.miner = b.miner)<br/></span><span id="28de" class="oa mu it nu b gy of oc l od oe"># NOT IN METHOD<br/>SELECT<br/>  a.miner<br/>FROM<br/>  miner2019 a<br/>WHERE<br/>  a.miner NOT IN<br/>    (SELECT miner FROM miner2020)<br/></span><span id="e33b" class="oa mu it nu b gy of oc l od oe"># EXCEPT DISTINCT METHOD<br/>SELECT<br/>  a.miner<br/>FROM<br/>  miner2019 a<br/>EXCEPT DISTINCT<br/>SELECT<br/>  b.miner<br/>FROM<br/>  miner2020 b</span></pre><p id="2220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些方法都将返回相同的结果(大约491个矿工)，因为底层逻辑是相同的。这两种方法之间的唯一区别是它们触发不同的查询计划——一些比另一些更有效。以科学的名义，我在禁用缓存的情况下对每个方法运行了5次，并记录了查询性能。这是我的发现</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/0070fd997d9e3060633d1dab7b15c366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLIPMjohf703D-aVIg9UAg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反连接的不同写作风格比较。图片由作者提供。</p></figure><p id="fb8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数方法都有相似的性能，除了<code class="fe nr ns nt nu b">NOT IN</code>方法，它有几乎两倍的槽时间和字节混洗。</p><p id="deba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，真糟糕。根据我的经验，<code class="fe nr ns nt nu b">NOT IN</code>是反连接最常用的语法，因为它可读性强，但不幸的是，它的性能也最差。</p><p id="9936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于好奇，SQLShack在这里<a class="ae ky" href="https://www.sqlshack.com/t-sql-commands-performance-comparison-not-vs-not-exists-vs-left-join-vs-except/" rel="noopener ugc nofollow" target="_blank">花了很大力气</a>来讨论其性能不佳的根本原因。TLDR版本是，<code class="fe nr ns nt nu b">NOT IN</code>方法触发一些运行嵌套循环和计数操作的繁重操作，这显然是非常昂贵的。</p><p id="21ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事的寓意？编写反连接时避开<code class="fe nr ns nt nu b">NOT IN</code>。就我个人而言，我推荐默认使用<code class="fe nr ns nt nu b">NOT EXIST</code>方法，因为它具有很高的性能，阅读起来同样直观。</p><h1 id="8103" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#8:尽早并经常整理你的数据。</h1><blockquote class="nl nm nn"><p id="c109" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践</strong>:尽早并经常在查询中应用过滤功能，以减少数据混乱和在对最终查询结果没有贡献的无关数据上浪费计算资源。</p></blockquote><p id="8de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我听起来就像一张破唱片，但伟大的建议值得重复——只要有机会，就用<code class="fe nr ns nt nu b">SELECT DISTINCT</code>、<code class="fe nr ns nt nu b">INNER JOIN</code>、<code class="fe nr ns nt nu b">WHERE</code>、<code class="fe nr ns nt nu b">GROUP BY</code>或任何其他过滤功能整理你的数据。我们做得越早，查询的每个后续阶段的负载就越小，因此每一步的性能增益都是复合的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/a696be442fc67d2bec63d1a8e755ed24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*394MmoqzAJI8HpZ0KHBSMA.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尽早整理无关数据可以节省下游的计算资源。图片由作者提供。</p></figure><p id="b40c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想知道每个GitHub存储库的受欢迎程度，我们可以查看(I)浏览量和(ii)提交量。为了提取数据，我们可以<code class="fe nr ns nt nu b">JOIN</code>表<code class="fe nr ns nt nu b">repos</code>和<code class="fe nr ns nt nu b">commits</code>然后用<code class="fe nr ns nt nu b">GROUP BY</code>合计计数。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="5a02" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="2a4f" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_repo AS (<br/>    SELECT<br/>      repo_name,<br/>      watch_count<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_repos`<br/>    ),<br/>  cte_commit AS (<br/>    SELECT<br/>      repo_name,<br/>      `commit`<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_commits`<br/>  )</span><span id="3c55" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  r.repo_name,<br/>  r.watch_count,<br/>  COUNT(c.commit) AS commit_count<br/>FROM<br/>  cte_repo r<br/>LEFT JOIN<br/>  cte_commit c ON r.repo_name = c.repo_name<br/>GROUP BY<br/>  1,2</span><span id="0cad" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 3s<br/>Slot Time      : 8s<br/>Bytes Processed: 50 MB<br/>Bytes Shuffled : 91 MB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="65f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个场景中，<code class="fe nr ns nt nu b">GROUP BY</code>子句是在最外层的查询中执行的，所以每一行提交都是先<code class="fe nr ns nt nu b">JOIN</code>到存储库。由于多个提交可以属于同一个存储库，这导致了一个指数级的大表，我们需要使用<code class="fe nr ns nt nu b">GROUP BY</code>。</p><p id="fba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了比较，我们可以在<code class="fe nr ns nt nu b">commits</code>表中提前实现<code class="fe nr ns nt nu b">GROUP BY</code>。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="a8ab" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="1a29" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_repo AS (<br/>    SELECT<br/>      repo_name,<br/>      watch_count<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_repos`<br/>    ),<br/>  cte_commit AS (<br/>    SELECT<br/>      repo_name,<br/>      COUNT(`commit`) AS commit_count<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_commits`<br/>    GROUP BY<br/>      1<br/>  )</span><span id="66ad" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  r.repo_name,<br/>  r.watch_count,<br/>  c.commit_count<br/>FROM<br/>  cte_repo r<br/>LEFT JOIN<br/>  cte_commit c ON r.repo_name = c.repo_name</span><span id="1088" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 2s<br/>Slot Time      : 5s<br/>Bytes Processed: 50 MB<br/>Bytes Shuffled : 26 MB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="4429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们提前T13时，我们看到时隙和字节混洗有了巨大的改进。这是因为所有提交都从672，000条记录压缩为6条记录，因此需要移动的数据更少。</p><p id="1f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是用于比较的查询计划。对于上下文，在<code class="fe nr ns nt nu b">repos</code>和<code class="fe nr ns nt nu b">commits</code>表中分别有400，000和672，000条记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/37d746dd15b30844bbc8ca027ddcd287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpuzNxx7-TvK5scikRp4sg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用GROUP BY early可以大大减少读取的记录和写入的记录。截图摘自<a class="ae ky" href="https://console.cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>，由作者编辑。</p></figure><p id="831a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽可能随时随地整理数据。</p><h1 id="d951" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated"><strong class="ak"> #9:顺序很重要(？)</strong></h1><blockquote class="nl nm nn"><p id="937e" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">推测的最佳实践:</strong> BigQuery假设用户已经在<code class="fe nr ns nt nu b">WHERE</code>子句中提供了表达式的最佳顺序，并且不会尝试对表达式进行重新排序。您的<code class="fe nr ns nt nu b">WHERE</code>子句中的表达式应该首先排序为最具选择性的表达式。<a class="ae ky" href="https://cloud.google.com/blog/topics/developers-practitioners/bigquery-admin-reference-guide-query-optimization" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="9ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个建议激起了我的兴趣，因为如果它是真的，它将是最简单的实现，具有巨大的优化改进潜力。Google声称，不仅在我们的查询中(在不同的表上)尽早使用<code class="fe nr ns nt nu b">WHERE</code>很重要，而且在同一个表中<code class="fe nr ns nt nu b">WHERE</code>的顺序也很重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/a27b65269f879c5974da1cd302830329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vdaazmu-7rmBitAA18L9ng.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在比较子句之前先应用过滤子句是否更好？图片由作者提供。</p></figure><p id="89bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定亲自测试一下。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="6fc1" class="oa mu it nu b gy ob oc l od oe"># "Supposedly" Not Optimized</span><span id="1a97" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  miner<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`<br/>WHERE<br/>  miner LIKE '%a%'<br/>  AND miner LIKE '%b%'<br/>  AND miner = '0xc3348b43d3881151224b490e4aa39e03d2b1cdea'</span><span id="a775" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 7s<br/>Slot Time      : 85s<br/>Bytes Processed: 615 MB<br/>Bytes Shuffled : 986 KB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="66b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们使用的三个<code class="fe nr ns nt nu b">WHERE</code>子句中，<code class="fe nr ns nt nu b">LIKE</code>操作符是运行成本很高的字符串比较操作，而<code class="fe nr ns nt nu b">=</code>操作符选择了一个非常具体的挖掘器，这大大减少了相关行的数量。</p><p id="5e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在理想状态下，<code class="fe nr ns nt nu b">=</code>操作符将在其他两个操作符之前执行，因此昂贵的<code class="fe nr ns nt nu b">LIKE</code>操作将只在剩余行的子集上执行。</p><p id="084d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nr ns nt nu b">WHERE</code> do的顺序很重要，那么上述查询的性能无疑会比以<code class="fe nr ns nt nu b">=</code>操作符为第一操作符的类似查询差。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="7eb4" class="oa mu it nu b gy ob oc l od oe"># "Supposedly" Optimized</span><span id="7361" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  miner<br/>FROM<br/>  `bigquery-public-data.crypto_ethereum.blocks`<br/>WHERE<br/>  miner = '0xc3348b43d3881151224b490e4aa39e03d2b1cdea'<br/>  AND miner LIKE '%a%'<br/>  AND miner LIKE '%b%'</span><span id="1cce" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 8s<br/>Slot Time      : 92s<br/>Bytes Processed: 615 MB<br/>Bytes Shuffled : 986 KB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="bf87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是看起来，两个查询的槽时间和字节数是相当的，这表明BigQuery的SQL优化器足够聪明，可以运行最具选择性的<code class="fe nr ns nt nu b">WHERE</code>子句，而不管我们如何编写查询。这也得到了大多数StackOverflow答案的支持，比如这里的<a class="ae ky" href="https://stackoverflow.com/questions/3152182/sql-does-the-order-of-where-conditions-matter?rq=1" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae ky" href="https://stackoverflow.com/questions/642784/does-the-order-of-columns-in-a-where-clause-matter" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae ky" href="https://stackoverflow.com/questions/11436469/does-the-order-of-where-clauses-matter-in-sql#:~:text=No%2C%20that%20order%20doesn't%20matter%20(or%20at%20least,way%20to%20satisfy%20that%20query." rel="noopener ugc nofollow" target="_blank"/>。</p><p id="4be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我收集的信息来看，我们的<code class="fe nr ns nt nu b">WHERE</code>子句的顺序在大多数时候并不重要，除非在极端的极端情况下，如来自<a class="ae ky" href="https://stackoverflow.com/questions/642784/does-the-order-of-columns-in-a-where-clause-matter" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>的“注册用户”(是的，那是他的用户名)所指出的。</p><ul class=""><li id="a756" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">如果查询中有大量的表(10个或更多)。</li><li id="64ff" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">如果你的<code class="fe nr ns nt nu b">WHERE</code>子句中有几个<code class="fe nr ns nt nu b">EXISTS</code>、<code class="fe nr ns nt nu b">IN</code>、<code class="fe nr ns nt nu b">NOT EXISTS</code>或<code class="fe nr ns nt nu b">NOT IN</code>语句</li><li id="4c1b" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">如果使用嵌套CTE(公共表表达式)或大量cte。</li><li id="281e" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">如果您的<code class="fe nr ns nt nu b">FROM</code>子句中有大量子查询。</li></ul><p id="b345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可能不会影响我们的查询性能，但我认为为了以防万一，按重要性顺序排列我们的<code class="fe nr ns nt nu b">WHERE</code>子句不会有什么坏处。</p><h1 id="38ea" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#10:利用分区和/或集群。</h1><blockquote class="nl nm nn"><p id="73e1" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践:</strong>在大于1 GB的表上使用分区和集群来对数据进行分段和排序。对分区键或簇键应用筛选器可以显著减少数据扫描。<a class="ae ky" href="https://cloud.google.com/blog/topics/developers-practitioners/bigquery-admin-reference-guide-query-optimization" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="e4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查询一个巨大的数据集是一件痛苦的事情，因为它占用大量的资源，而且速度非常慢。为了提高可用性，将大型数据集分成多个较小数据集的数据库并不少见(例如:sales_jan2022、sales_feb2022、sales _ mar 2022……)。虽然这种方法避免了缺点，但它是以必须处理管理所有拆分表的逻辑噩梦为代价实现的。</p><p id="1fc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就把我们带到了BigQuery的分区表。在功能上，分区允许我们查询较大表的子集，而不必将它分成单独的较小的表。我们得到了性能，但没有缺点。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="7cde" class="oa mu it nu b gy ob oc l od oe">CREATE TABLE database.zoo_partitioned<br/>PARTITION BY zoo_name AS<br/>  (SELECT *<br/>   FROM database.zoo)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/2f49bb65efbfb9d94fb44b1ec44c5ab0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TTKj4Bqzx9W7ChuDpaczqA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分区将一个大表分解成更小的块。图片由作者提供。</p></figure><p id="6b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们对一个分区表运行查询时，BigQuery将过滤掉存储中不相关的分区，这样我们将只扫描指定的分区，而不是全表扫描。</p><p id="dfa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在与分区相同的并行中，我们还可以使用<em class="me">集群</em>将数据细化为更小的块。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="6970" class="oa mu it nu b gy ob oc l od oe">CREATE TABLE database.zoo_clustered<br/>CLUSTER BY animal_name AS<br/>  (SELECT *<br/>   FROM database.zoo)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/dc462cacc9faf2322d657362cce4dad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*itNmoOPJatGbwGIOi7z4XA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“animal_name”列上的聚类表。群集键指向块，但不指向特定的行。图片由作者提供。</p></figure><p id="087b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">聚集表根据我们选择的列将数据分类成块，然后通过聚集索引跟踪数据。在查询过程中，聚集索引指向包含数据的块，因此允许BigQuery跳过不相关的块。扫描时跳过不相关块的过程称为<em class="me">块修剪</em>。</p><p id="d7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个概念类似于一个图书图书馆——当书架根据流派组织起来时，我们可以很容易地找到我们想要的书。</p><p id="ea3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然一个重要的区别是它不指向确切的行，而只指向块。有趣的是，BigQuery不一定要为聚集列中的每个不同值创建一个块。换句话说，当我们搜索特定值时，BigQuery不会为1000个唯一值创建1000个块，并节省99%的字节扫描。根据经验，Google推荐至少1 GB的集群表，因为该算法可以将高基数数据分组到更好的块中，这最终会使集群表更有效。</p><p id="3387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，分区和集群都有助于减少BigQuery需要扫描的字节数。由于需要扫描的字节更少，查询运行起来更便宜、更快。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="756d" class="oa mu it nu b gy ob oc l od oe">CREATE TABLE database.zoo_partitioned_and_clustered<br/>PARTITION BY zoo_name<br/>CLUSTER BY animal_name AS<br/>  (SELECT *<br/>   FROM database.zoo)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/bf80ca552980469861ee3a947600db1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WGyDf7DPoSBW4gDm8I_pwQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分区和集群可以一起使用，以获得更好的性能。图片由作者提供。</p></figure><p id="553f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，分区和集群不一定是互斥的。对于大型表，将两者结合使用是非常有意义的，因为它们的效果可以复合。考虑<code class="fe nr ns nt nu b">bigquery-public-data.wikipedia.pageviews_2022</code>，一个分区和聚集的表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/c3cb2e603c01398cc1c2343b8a2291de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*y590Kpk7x4TA2kdoJrFUVw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以参考“Table Details”选项卡来验证表是分区的还是集群的。截图摘自<a class="ae ky" href="https://console.cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>，由作者编辑。</p></figure><p id="4f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过参考big query UI的详细信息页面，我们可以看到该表由<code class="fe nr ns nt nu b">datehour</code>列划分，并由<code class="fe nr ns nt nu b">wiki</code>和<code class="fe nr ns nt nu b">title</code>列聚集。它看起来和感觉上就像一个普通的表，但是当我们过滤它的时候，真正的奇迹发生了。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="89c3" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="449a" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  title<br/>FROM<br/>  `bigquery-public-data.wikipedia.pageviews_2022`<br/>WHERE<br/>  DATE(datehour) = '2022-01-01'<br/>  AND title = 'Kinzie_Street_railroad_bridge'</span><span id="1b74" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 1s<br/>Slot Time      : 27s<br/>Bytes Processed: 1.3 GB<br/>Bytes Shuffled : 408 B<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="7bc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我应用一个<code class="fe nr ns nt nu b">WHERE</code>语句来过滤它的分区<code class="fe nr ns nt nu b">datehour</code>时，处理的字节从483 GB减少到只有4 GB。如果我在<code class="fe nr ns nt nu b">title</code>集群上添加另一个过滤器，它会进一步下降到1.3 GB。我们只需支付0.0065美元，而不是2.4美元。如果这还不划算，我不知道什么才划算。</p><h1 id="6dee" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#11:将ORDER BY推到查询的末尾(？)</h1><blockquote class="nl nm nn"><p id="168a" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">推测的最佳实践:</strong>仅在最外层查询或窗口子句(分析函数)中使用<code class="fe nr ns nt nu b">ORDER BY</code>。<a class="ae ky" href="https://cloud.google.com/bigquery/docs/best-practices-performance-compute#order_query_operations_to_maximize_performance" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="1fd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nr ns nt nu b">ORDER BY</code>一直是一个资源密集型操作，因为它需要比较所有行，并按顺序组织它们。</p><p id="c34a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之所以建议延迟使用<code class="fe nr ns nt nu b">ORDER BY</code>直到最外层的查询，是因为表在查询开始时往往会更大，因为它们还没有经过从<code class="fe nr ns nt nu b">WHERE</code>或<code class="fe nr ns nt nu b">GROUP BY</code>子句的任何修剪。表越大，需要做的比较就越多，因此性能就越慢。</p><p id="c447" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们使用<code class="fe nr ns nt nu b">ORDER BY</code>纯粹是为了提高数据的可读性，那么就没有必要在早期对它们进行排序，因为数据的排序可能会在下游被扭曲。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/912b62527db3cbad0badb4c3d8f34ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OJNOZypskRbIPg-uHsN_cA.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不必要地使用ORDER BY会增加计算负载。图片由作者提供。</p></figure><p id="e618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的查询有针对<code class="fe nr ns nt nu b">cte_blocks</code>和<code class="fe nr ns nt nu b">cte_contracts</code>的<code class="fe nr ns nt nu b">ORDER BY</code>子句，但是它们没有实际用途，因为我们在这里没有计算任何顺序关系(前一行对下一行)。不仅如此，最外层查询中的<code class="fe nr ns nt nu b">ORDER BY</code>无论如何都会覆盖之前的排序。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="d21f" class="oa mu it nu b gy ob oc l od oe"># "Supposedly" Not Optimized</span><span id="7bea" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_blocks AS (<br/>    SELECT<br/>      *<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.blocks`<br/>    WHERE<br/>      DATE(timestamp) BETWEEN '2021-03-01' AND '2021-03-31'<br/>    ORDER BY<br/>      1,2,3,4,5,6<br/>  ),<br/>  cte_contracts AS (<br/>    SELECT<br/>      *<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.contracts`<br/>    WHERE<br/>      DATE(block_timestamp) BETWEEN '2021-03-01' AND '2021-03-31'<br/>    ORDER BY<br/>      1,2,4,5,6,7<br/>  )</span><span id="44e6" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  *<br/>FROM<br/>  cte_blocks b<br/>LEFT JOIN<br/>  cte_contracts c ON c.block_number = b.number<br/>ORDER BY<br/>  size,<br/>  block_hash</span><span id="e33c" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 14s<br/>Slot Time      : 140s<br/>Bytes Processed: 865 MB<br/>Bytes Shuffled : 5.8 GB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="a3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了比较，我们从两个<code class="fe nr ns nt nu b">cte_tables</code>中删除了无意义的<code class="fe nr ns nt nu b">ORDER BY</code>子句，并再次运行查询。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="0162" class="oa mu it nu b gy ob oc l od oe"># "Supposedly" Optimized</span><span id="a72f" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_blocks AS (<br/>    SELECT<br/>      *<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.blocks`<br/>    WHERE<br/>      DATE(timestamp) BETWEEN '2021-03-01'<br/>      AND '2021-03-31'<br/>  ),<br/>  cte_contracts AS (<br/>    SELECT<br/>      *<br/>    FROM<br/>      `bigquery-public-data.crypto_ethereum.contracts`<br/>    WHERE<br/>      DATE(block_timestamp) BETWEEN '2021-03-01' AND '2021-03-31'<br/>  )</span><span id="a87d" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  *<br/>FROM<br/>  cte_blocks b<br/>LEFT JOIN<br/>  cte_contracts c ON c.block_number = b.number<br/>ORDER BY<br/>  size,<br/>  block_hash</span><span id="e53c" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 14s<br/>Slot Time      : 145s<br/>Bytes Processed: 865 MB<br/>Bytes Shuffled : 5.8 GB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="78cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我们到目前为止建立的逻辑，前一个查询应该运行得慢得多，因为它需要对多个列执行额外的<code class="fe nr ns nt nu b">ORDER BY</code>子句，但是令我惊讶的是，这两个查询在性能上的差异可以忽略不计——140秒对145秒。</p><p id="d4ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有点违反直觉，但是进一步深入执行细节会发现，无论我们如何编写查询，两个查询都只运行最外层查询中的<code class="fe nr ns nt nu b">ORDER BY</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/2d726e688ac9bb7d0bd6e87b8a49cd91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5nfMqGumNTsCwMMRf5P3Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询计划告诉我们为查询执行的确切步骤。在这两种情况下，我只能找到两个ORDER BY操作符，并且它们都在最外层的查询中。截图摘自<a class="ae ky" href="https://console.cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>，由作者编辑。</p></figure><p id="6188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，万能的BigQuery的SQL优化器再一次足够聪明，能够找出冗余子句，并自动将它们从计算中排除。</p><p id="cca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在这里包含多余的<code class="fe nr ns nt nu b">ORDER BY</code>子句是无害的，但是我们应该总是删除不必要的<code class="fe nr ns nt nu b">ORDER BY</code>子句，并尽可能地在查询中延迟它们。因为尽管BigQuery SQL Optimizer令人印象深刻，但其他一些遗留数据库可能不具备同样的能力。</p><h1 id="509b" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#12:延迟资源密集型操作。</h1><blockquote class="nl nm nn"><p id="82e4" class="kz la me lb b lc ld ju le lf lg jx lh no lj lk ll np ln lo lp nq lr ls lt lu im bi translated"><strong class="lb iu">最佳实践:</strong>将复杂操作，如正则表达式和数学函数推到查询的末尾。<a class="ae ky" href="https://cloud.google.com/bigquery/docs/best-practices-performance-compute#order_query_operations_to_maximize_performance" rel="noopener ugc nofollow" target="_blank">来源</a>。</p></blockquote><p id="9ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展与延迟<code class="fe nr ns nt nu b">ORDER BY</code>语句相同的理念，我们希望将复杂的函数尽可能地推到查询中，以避免计算我们最终将丢弃的数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/912316a4170974ac8d1a26f13f6b9e7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*TpMnp7CFwJpN_YoK_WSQDg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将资源密集型操作延迟到查询末尾可以提高性能。图片由作者提供。</p></figure><p id="f1c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这适用于任何函数，比如<code class="fe nr ns nt nu b">LOWER()</code>、<code class="fe nr ns nt nu b">TRIM()</code>、<code class="fe nr ns nt nu b">CAST()</code>，但是我们将重点放在正则表达式和数学函数上，比如<code class="fe nr ns nt nu b">REGEXP_SUBSTR()</code>和<code class="fe nr ns nt nu b">SUM()</code>，因为它们往往会消耗更多的资源。</p><p id="b36c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示影响，我将在查询的早期运行<code class="fe nr ns nt nu b">REGEXP_REPLACE()</code>,而不是在后期。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="b5bc" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="642b" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_repo AS (<br/>    SELECT<br/>      REGEXP_REPLACE(repo_name, r"(.*)", "\\1") AS repo_name<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_repos`<br/>    ),<br/>  cte_commit AS (<br/>    SELECT<br/>      REGEXP_REPLACE(repo_name, r"(.*)", "\\1") AS repo_name<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_commits`<br/>  )</span><span id="2eb6" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  r.repo_name,<br/>  c.repo_name<br/>FROM<br/>  cte_repo r<br/>INNER JOIN<br/>  cte_commit c ON r.repo_name = c.repo_name</span><span id="4138" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 2s<br/>Slot Time      : 8s<br/>Bytes Processed: 20 MB<br/>Bytes Shuffled : 68 MB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="bcb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，我们再次运行相同的查询，只是在将两个初始表连接在一起之后，我们只调用最终表中的<code class="fe nr ns nt nu b">REGEXP_REPLACE()</code>。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="fff6" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="72f9" class="oa mu it nu b gy of oc l od oe">WITH<br/>  cte_repo AS (<br/>    SELECT<br/>      repo_name<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_repos`<br/>    ),<br/>  cte_commit AS (<br/>    SELECT<br/>      repo_name<br/>    FROM<br/>      `bigquery-public-data.github_repos.sample_commits`<br/>  )</span><span id="2028" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  REGEXP_REPLACE(r.repo_name, r"(.*)", "\\1") AS repo_name,<br/>  REGEXP_REPLACE(c.repo_name, r"(.*)", "\\1") AS repo_name<br/>FROM<br/>  cte_repo r<br/>INNER JOIN<br/>  cte_commit c ON r.repo_name = c.repo_name</span><span id="ad93" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 2s<br/>Slot Time      : 3s<br/>Bytes Processed: 20 MB<br/>Bytes Shuffled : 56 MB<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="d810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，槽时间从8s提高到3s，而字节混洗从68 MB下降到56 MB。</p><h1 id="780b" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#13:使用搜索()。</h1><p id="25e6" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">谷歌最近发布了一个预览版的<code class="fe nr ns nt nu b"><a class="ae ky" href="https://cloud.google.com/blog/products/data-analytics/pinpoint-unique-elements-with-bigquery-search-features" rel="noopener ugc nofollow" target="_blank">SEARCH()</a></code>功能，该功能将文本数据标记化，使得找到隐藏在非结构化文本和半结构化<code class="fe nr ns nt nu b">JSON</code>数据中的数据变得异常容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/76f63d0e8c6ea04b0ec4fa95cece757d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*rM4o01oiqjTmJXIl8TF19g.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SEARCH()函数允许我们搜索相关的关键字，而不必了解底层的数据模式。图片由作者提供。</p></figure><p id="6ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，在处理嵌套结构时，我们需要提前理解表模式，然后在运行组合的<code class="fe nr ns nt nu b">WHERE</code>和<code class="fe nr ns nt nu b">REGEXP</code>子句来搜索特定的术语之前，用<code class="fe nr ns nt nu b">UNNEST()</code>适当地展平任何嵌套数据。这些都是计算密集型运算符。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="6582" class="oa mu it nu b gy ob oc l od oe"># Not Optimized</span><span id="af4c" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  `hash`,<br/>  size,<br/>  outputs<br/>FROM<br/>  `bigquery-public-data.crypto_bitcoin.transactions`<br/>CROSS JOIN<br/>  UNNEST(outputs)<br/>CROSS JOIN<br/>  UNNEST(addresses) AS outputs_address<br/>WHERE<br/>  block_timestamp_month BETWEEN "2009-01-01" AND "2010-12-31"<br/>  AND REGEXP_CONTAINS(outputs_address, '1LzBzVqEeuQyjD2mRWHes3dgWrT9titxvq')</span><span id="5fe1" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 6s<br/>Slot Time      : 24s<br/>Bytes Processed: 282 MB<br/>Bytes Shuffled : 903 B<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="5000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一个<code class="fe nr ns nt nu b">SEARCH()</code>函数来简化语法，而不是让它们过于复杂。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="73ed" class="oa mu it nu b gy ob oc l od oe"># Optimized</span><span id="c900" class="oa mu it nu b gy of oc l od oe">SELECT<br/>  `hash`,<br/>  size,<br/>  outputs<br/>FROM<br/>  `bigquery-public-data.crypto_bitcoin.transactions`<br/>WHERE<br/>  block_timestamp_month BETWEEN "2009-01-01" AND "2010-12-31"<br/>  AND SEARCH(outputs, ‘`1LzBzVqEeuQyjD2mRWHes3dgWrT9titxvq`’)</span><span id="51dc" class="oa mu it nu b gy of oc l od oe">-----------------------<br/>Elapsed Time   : 6s<br/>Slot Time      : 24s<br/>Bytes Processed: 87 MB<br/>Bytes Shuffled : 903 B<br/>Bytes Spilled  : 0 B<br/>-----------------------</span></pre><p id="fe69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至可以为该列创建一个搜索索引，以支持点查找文本搜索。</p><pre class="kj kk kl km gt nw nu nx ny aw nz bi"><span id="b718" class="oa mu it nu b gy ob oc l od oe"># To create the search index over existing BQ table<br/>CREATE SEARCH INDEX my_logs_index ON my_table (my_columns);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/973052c6ab5cac4fae75b834a5db306a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*u0XFleCpZDxn3ZPKfZ2_ww.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">搜索索引指向所需记录的位置。图片由作者提供。</p></figure><p id="f0b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe nr ns nt nu b">SEARCH()</code>是一种极其强大、简单且经济的点查找文本搜索方式。如果您的用例需要在非结构化数据中搜索非常具体的术语(例如:日志分析)，请使用<code class="fe nr ns nt nu b">SEARCH()</code>进行优先排序。</p><h1 id="f148" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">#14:利用缓存。</h1><p id="2c3a" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">BigQuery为我们的查询提供了一个免费的、完全托管的缓存特性。当我们执行查询时，BigQuery会自动将查询结果缓存到一个临时表中，该表可以保存长达24小时。我们可以通过编辑器UI上的查询设置来切换该特性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/2907c22663e7fd24f35f22dfad052654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Em_fh27mW2hFb5ke4A-6A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认情况下，缓存功能处于启用状态，但可以关闭。截图摘自<a class="ae ky" href="https://console.cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>，由作者编辑。</p></figure><p id="0dde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当触发重复查询时，BigQuery返回缓存的结果，而不是重新运行查询，为我们节省了额外的费用和计算时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/19c520c351432705ef61b64df550782a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZuICvzvfGti2QsowRml8Yg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缓存结果作为临时表存储长达24小时，以便在需要时重用。图片由作者提供。</p></figure><p id="4e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过在运行查询后检查“作业信息”来验证缓存的结果是否被使用。处理的字节应该显示“0 B(结果缓存)”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/5f57c5e788e377ad5f6de3d32b5b850d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufk_6GBlLsjy2M2DOtvKmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用缓存的结果是免费的。截图摘自<a class="ae ky" href="https://console.cloud.google.com/bigquery" rel="noopener ugc nofollow" target="_blank"> BigQuery </a>，由作者编辑。</p></figure><p id="1c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们一有机会就疯狂地发出查询之前，重要的是要知道不是所有的查询都会被缓存。BigQuery在这里概述了异常<a class="ae ky" href="https://cloud.google.com/bigquery/docs/cached-results#cache-exceptions" rel="noopener ugc nofollow" target="_blank"/>。值得注意的一些更重要的问题是</p><ul class=""><li id="61cd" class="mf mg it lb b lc ld lf lg li mh lm mi lq mj lu mk ml mm mn bi translated">当查询使用非确定性函数时，例如<code class="fe nr ns nt nu b">CURRENT_TIMESTAMP()</code>，它不会被缓存，因为它会根据查询的执行时间返回不同的值。</li><li id="728f" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">当查询引用的表接收到流插入时，因为对表的任何更改都会使缓存的结果无效。</li><li id="5070" class="mf mg it lb b lc mo lf mp li mq lm mr lq ms lu mk ml mm mn bi translated">如果使用通配符<a class="ae ky" href="https://cloud.google.com/bigquery/docs/querying-wildcard-tables" rel="noopener ugc nofollow" target="_blank">查询多个表。</a></li></ul><h1 id="6a6c" class="mt mu it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">结束语</h1><p id="aec1" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">虽然这不是所有优化技巧和诀窍的详尽列表，但我希望这是一个良好的开端。如果我错过了任何重要的技术，请评论，因为我打算继续添加到这个列表中，这样我们都可以有一个简单的参考点。</p><p id="0de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运，一帆风顺。</p></div></div>    
</body>
</html>