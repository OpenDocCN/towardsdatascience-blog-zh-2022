<html>
<head>
<title>How To Make Memes with AI in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python制作带AI的迷因</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-make-memes-with-ai-in-python-986944bce5b4#2022-03-01">https://towardsdatascience.com/how-to-make-memes-with-ai-in-python-986944bce5b4#2022-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d5b27c32cade2a3b826f210e5a5ea0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Km3HV1X6MGlp6a1OBljzBw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">制作于<a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> makememe.ai </a>。<a class="ae jd" href="https://unsplash.com/photos/QARM_X5HWyI" rel="noopener ugc nofollow" target="_blank">图片</a>由<a class="ae jd" href="https://unsplash.com/@koutchinski" rel="noopener ugc nofollow" target="_blank"> Felix Koutchinski </a>根据<a class="ae jd" href="https://unsplash.com/license" rel="noopener ugc nofollow" target="_blank"> Unsplash许可</a></p></figure><div class=""/><p id="2b4e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近<a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> Makememe.ai </a>是<a class="ae jd" href="https://www.producthunt.com/posts/makememe-ai" rel="noopener ugc nofollow" target="_blank">产品搜索日</a>的产品。用户提供一个简单的描述，应用程序将其转化为一个可以与朋友分享的快速笑声。</p><figure class="lb lc ld le gt is"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="e3dc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> Makememe.ai </a>使用<a class="ae jd" href="https://openai.com/blog/gpt-3-apps/" rel="noopener ugc nofollow" target="_blank"> OpenAI的GPT-3 </a>，来执行自然语言任务，将用户的文本转换成meme。我们将通过Python代码和高级人工智能系统来学习如何用人工智能创造迷因！</p><p id="58c9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该项目现在在Github上开源。随意叉回购，并尝试建立在它之上。如果你想投稿，你需要<a class="ae jd" href="https://openai.com/api/" rel="noopener ugc nofollow" target="_blank">注册</a>获得OpenAI API访问权限，并且在分叉或克隆库之前请阅读OpenAI的<a class="ae jd" href="https://beta.openai.com/docs/going-live" rel="noopener ugc nofollow" target="_blank">上线政策</a>。</p><h1 id="5ec8" class="lh li jg bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">先验模因创新</h1><p id="52e1" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">Imgflip的创始人Dylan Wenzlau创造了一个人工智能系统来生成模因。迪伦从Imgflip用户的1亿条公共迷因说明中提取信息，构建了一个用于文本生成的深度卷积网络。在应用程序中，用户从48个可用的迷因中选择一个迷因，人工智能会生成文本覆盖在迷因上。这款应用只需点击几下就能创造出有趣的迷因。用户可以提供一些上下文(迷因的主题等)。)供人工智能用来创造迷因。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/f6a07d075a12b007d4e421fae075594e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R6cj5X9CJ4VvzpdFPGIw3g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">Imgfip系统的高级示意图。由Josh Bickett在lucid.app 上创建。<em class="ml">图片由作者提供。</em></p></figure><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/ae1adedf6afec21b72b278f853dca7d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nfSweqUpOmAesx0Xmf5Tbg.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">迪伦·温兹劳开发的人工智能创造的迷因</p></figure><p id="bd8b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://robgon.medium.com/" rel="noopener">罗伯特·a·冈萨维斯</a>创造了一个人工智能迷因系统，叫做<a class="ae jd" rel="noopener" target="_blank" href="/ai-memer-using-machine-learning-to-create-funny-memes-12fc1fe543e4">人工智能迷因</a>。他让任何人都可以在colab笔记本上获得代码。</p><p id="94b5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用户输入一个搜索查询，会收到10个与搜索匹配的meme图片选项。用户从10幅图像中选择一幅。然后，人工智能系统生成10个可能的字幕，用户选择他们最喜欢的。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/3ef26a46905ae23cecf603d803e9e003.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74GZFhpfCIjhPDKVBPA3rA.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">AI-Memer系统的高层图。由Josh Bickett在<a class="ae jd" href="https://lucid.app/documents" rel="noopener ugc nofollow" target="_blank"> lucid.app </a>上创建。<em class="ml">图片由作者提供。</em></p></figure><h1 id="cff7" class="lh li jg bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">Makememe.ai的方法——“提示一个模因”</h1><p id="dd0b" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">该应用采取了一种不同的方法，可以被描述为“促进一种模因”。用户提供<strong class="kf jh">一个输入</strong>——关于他们想要的模因是什么的描述。然后，用户按下“制作迷因”按钮。用户没有选择图像或文本。人工智能系统选择一幅图像，并将描述修改成迷因标题。然后将标题覆盖在图片上，形成最终的迷因。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mo"><img src="../Images/aec923e1a7ef92db656acd90c348d7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TfgPccuSJkDpE5_suJDb0w.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated"><a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> Makememe.ai </a>的系统高层图。由Josh Bickett在<a class="ae jd" href="https://lucid.app/documents" rel="noopener ugc nofollow" target="_blank"> lucid.app </a>上创建。<em class="ml">图片由作者提供。</em></p></figure><p id="5d04" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">示例用户输入</strong> : <em class="mp">“但愿办公室有新一季”</em></p><p id="1953" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">例子模因:</strong></p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mq"><img src="../Images/7cf023b64f09cfe52386d885d66244d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBGvoEjvsWQGyYaZkg27Vw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">制作于<a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> makememe.ai </a>。<a class="ae jd" href="https://unsplash.com/photos/B-x4VaIriRc" rel="noopener ugc nofollow" target="_blank">图片</a>由<a class="ae jd" href="https://unsplash.com/@sigmund" rel="noopener ugc nofollow" target="_blank"> Sigmund </a>在<a class="ae jd" href="https://unsplash.com/license" rel="noopener ugc nofollow" target="_blank"> Unsplash许可</a>下拍摄</p></figure><h1 id="b4f1" class="lh li jg bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">它是如何工作的</h1><p id="9aab" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我们将一步一步地走下去，一路上检查迷因。</p><ul class=""><li id="7fc0" class="mr ms jg kf b kg kh kk kl ko mt ks mu kw mv la mw mx my mz bi translated"><a class="ae jd" href="#8d0f" rel="noopener ugc nofollow">获取迷因描述</a> <a class="ae jd" href="http://8d0f" rel="noopener ugc nofollow" target="_blank"> ( </a> <a class="ae jd" href="#8d0f" rel="noopener ugc nofollow">用户输入</a>)</li><li id="80cc" class="mr ms jg kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae jd" href="#3496" rel="noopener ugc nofollow">选择一个符合描述的迷因</a></li><li id="f935" class="mr ms jg kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae jd" href="#5fac" rel="noopener ugc nofollow">将描述修改成符合</a>的迷因标题</li><li id="dd65" class="mr ms jg kf b kg na kk nb ko nc ks nd kw ne la mw mx my mz bi translated"><a class="ae jd" href="#9782" rel="noopener ugc nofollow">在选中的图片上叠加meme标题</a></li></ul><p id="de54" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里讨论的所有Python代码都在<a class="ae jd" href="https://github.com/joshbickett/makememe_ai" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> Github库</strong> </a> <strong class="kf jh"> </strong>中，代码主要驻留在<a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/make.py" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">make . py</strong></a><strong class="kf jh"/>文件中。如果你想在本地运行这个项目并亲自尝试，克隆代码并查看<a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">的自述文件</a>了解如何在你的电脑上运行它。</p><p id="3c4d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该项目建立在Python的<a class="ae jd" href="https://flask.palletsprojects.com/en/2.0.x/" rel="noopener ugc nofollow" target="_blank"> Flask框架</a>之上。我们不会涉及技术栈，所以如果概念不熟悉，我强烈推荐<a class="ae jd" href="https://www.youtube.com/channel/UCCezIgC97PvUuR4_gbFUs5g" rel="noopener ugc nofollow" target="_blank">科里·谢弗的</a> Youtube系列<a class="ae jd" href="https://www.youtube.com/watch?v=MwZwr5Tvyxo" rel="noopener ugc nofollow" target="_blank"> Python Flask教程:全功能Web应用</a>。</p><h2 id="8d0f" class="nf li jg bd lj ng nh dn ln ni nj dp lr ko nk nl lv ks nm nn lz kw no np md nq bi translated">获取迷因描述(用户输入)</h2><p id="6fc3" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">第一步是从网页上抓取模因描述。下面是网站描述的一个例子。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/084a69c27a4a6f21f9743c9fd9f8ca8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmAAA6kIDQADmDJ2cKM9Nw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">带有用户描述的<a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> makememe.ai </a>主页图片。<em class="ml">图片由作者提供。</em></p></figure><p id="424b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户按下“<strong class="kf jh">Make Meme”</strong>按钮时，python代码触发<code class="fe ns nt nu nv b">make()</code>函数并传入参数<code class="fe ns nt nu nv b">description</code> — <em class="mp">在我看来，开源项目是最好的项目。</em></p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="e71a" class="nf li jg nv b gy oa ob l oc od">def make(description):<br/>    user_input = description</span></pre><h2 id="3496" class="nf li jg bd lj ng nh dn ln ni nj dp lr ko nk nl lv ks nm nn lz kw no np md nq bi translated">选择一个与描述相符的迷因</h2><p id="e742" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">人工智能需要选择一个最符合描述的迷因。目前在项目目录中有20个图像选项供人工智能选择— <code class="fe ns nt nu nv b"><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/tree/main/makememe/static/meme_pics" rel="noopener ugc nofollow" target="_blank">./static/meme_pics</a></code></p><p id="f1ae" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">语义搜索</strong></p><p id="74e9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了选择最好的模因，我们需要找到一个模因的意义与用户在描述中试图传达的内容相一致的模因。为此，我们使用一种叫做<a class="ae jd" href="https://beta.openai.com/docs/guides/search" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">语义搜索</strong> </a>的方法。OpenAI有一个端点进行语义搜索。OpenAI在下面描述了它的工作原理。</p><blockquote class="oe of og"><p id="96ce" class="kd ke mp kf b kg kh ki kj kk kl km kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated">搜索端点(<a class="ae jd" href="https://beta.openai.com/docs/api-reference/searches" rel="noopener ugc nofollow" target="_blank"> /search </a>)允许您对一组文档进行语义搜索。这意味着您可以提供一个查询，比如一个自然语言问题或一个语句，并且所提供的文档将根据它们与输入查询的语义相关程度进行评分和排序。</p></blockquote><p id="65c4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语义学是语言学和逻辑学的一个分支，研究意义。因此<strong class="kf jh">语义搜索</strong>发现两个短语或文档在意义上有多接近。</p><p id="4dd5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个迷因图像都有自己的描述，可以与用户的描述进行比较。<strong class="kf jh">语义搜索</strong>比较两个短语。</p><p id="e24c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">短语一—用户描述:</strong> <em class="mp">在我看来，开源项目是最好的项目</em></p><p id="f59d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">短语二——每个模因被贴上</strong>标签的描述</p><p id="62a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的例子中，当使用<strong class="kf jh">语义搜索</strong>时，人工智能将选择下面的模因模板。这个模因被贴上了描述标签— <em class="mp">“这是我的观点。</em>改变主意<strong class="kf jh">。</strong>能看出和用户描述的相似度吗？我们将仔细检查代码，看看它是如何被选中的。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/c05a907bd5b8125e14bad500a133c780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lHZawDQbub5zYAOmmEYUEg.jpeg"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">用来创造迷因的图像。<a class="ae jd" href="https://medium.com/r?url=https%3A%2F%2Funsplash.com%2Fphotos%2FQARM_X5HWyI" rel="noopener">图片</a>由<a class="ae jd" href="https://unsplash.com/@koutchinski" rel="noopener ugc nofollow" target="_blank"> Felix Koutchinski </a>根据<a class="ae jd" href="https://unsplash.com/license" rel="noopener ugc nofollow" target="_blank"> Unsplash许可证</a>拍摄。</p></figure><p id="73db" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<strong class="kf jh">语义搜索</strong>，我们创建了一个名为<code class="fe ns nt nu nv b">documents</code>的<code class="fe ns nt nu nv b">array</code>来保存对迷因的20个描述。注意这个描述——<code class="fe ns nt nu nv b">"This is my opinion. Change my mind."</code>——在数组中是第11位。变量<code class="fe ns nt nu nv b">documents</code>使用OpenAI的命名约定作为其<a class="ae jd" href="https://beta.openai.com/docs/guides/search" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh">语义搜索</strong> </a>端点。搜索可以在更长的文本字符串上执行，比如文档，这就是命名约定的原因。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="27f1" class="nf li jg nv b gy oa ob l oc od">documents = ["sad", "indifferent", "waiting", "they don't know", "pompous", "this is better than that", "poor fix", "no responsibility", "ineffective solution", <strong class="nv jh">"This is my opinion. Change my mind."</strong>, "accurate depiction", "equal", "distracting", "three levels increasing", "stay away from", "ruin", "scary", "The subject has a strong preference for one option over another", "something is missing and I wish it was still here", "when not good"]</span></pre><p id="2674" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然meme的描述已经设置在<code class="fe ns nt nu nv b">document</code>变量中，我们可以将它们与用户的描述进行比较，以选择最合适的图像。</p><p id="b784" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的函数传入三个参数。在<strong class="kf jh">语义搜索</strong> API请求中发送<code class="fe ns nt nu nv b">documents</code>数组和<code class="fe ns nt nu nv b">user_input</code>。该搜索根据用户输入评估所有20个模因描述，并提供得分字典。高分意味着短语之间的语义相似度高。<code class="fe ns nt nu nv b">user_id</code>是为了OpenAI进行的AI安全研究而传入的。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="e283" class="nf li jg nv b gy oa ob l oc od">response = GPT.search_request(documents, user_input, user_id)</span></pre><p id="8d6a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在,<code class="fe ns nt nu nv b">response</code>有了一个分数字典，索引与<code class="fe ns nt nu nv b">documents</code>数组中的模因相匹配。</p><p id="3ee3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建一个名为<code class="fe ns nt nu nv b">best_result</code>的python字典来保存我们的结果，因为我们要寻找得分最高的迷因。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="92f1" class="nf li jg nv b gy oa ob l oc od">best_result = {<br/>    "index": -1,<br/>    "score": 0<br/>}</span></pre><p id="20c2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用一个<code class="fe ns nt nu nv b">for</code>循环来遍历<code class="fe ns nt nu nv b">response</code>中的每个<code class="fe ns nt nu nv b">key-value</code>对，并将最佳得分保存在我们之前创建的<code class="fe ns nt nu nv b">best_result</code>字典中。当我们循环通过<code class="fe ns nt nu nv b">response</code>时，如果新分数比前一循环周期保存的分数更好，我们将保存新分数。在<code class="fe ns nt nu nv b">for</code>循环完成后，我们就有了在<code class="fe ns nt nu nv b">best_result</code>字典中得分最高的迷因。在我们的例子中，这个模因叫做<strong class="kf jh"><em class="mp"/></strong><em class="mp">这是我的看法。改变主意</em><strong class="kf jh"><em class="mp"/>。</strong></p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="6086" class="nf li jg nv b gy oa ob l oc od">for d in response['data']:<br/>     if d["score"] &gt; best_result["score"]:<br/>          best_result["score"] = d["score"]<br/>          best_result["index"] = d["document"]</span></pre><p id="33ed" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是<code class="fe ns nt nu nv b">for</code>循环代码运行时Mac终端的截图。我们为<code class="fe ns nt nu nv b">response</code>打印<code class="fe ns nt nu nv b">key-value</code>对，并找到最佳的<strong class="kf jh">语义搜索</strong>分数。评分<code class="fe ns nt nu nv b">10.388</code>最高所以带有描述的meme——“<em class="mp">这是我的看法。改变我的想法”——</em>被选中。</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/aa3c0b819c3b1a09b087da89ebdd2b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgwAApn0gs8FLeE0i2Ey0g.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">在<a class="ae jd" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>本地运行项目时来自我终端的截图。<em class="ml">图片由作者提供。</em></p></figure><p id="67e4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从<code class="fe ns nt nu nv b">best_result</code>中选择的迷因保存在一个名为<code class="fe ns nt nu nv b">meme_description</code>的变量中。现在，我们已经选择了一个迷因图片来使用！</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="fd2b" class="nf li jg nv b gy oa ob l oc od">meme_description = documents[best_result["index"]]</span></pre><h2 id="5fac" class="nf li jg bd lj ng nh dn ln ni nj dp lr ko nk nl lv ks nm nn lz kw no np md nq bi translated">将描述修改成合适的迷因标题</h2><p id="5a97" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">现在我们已经选择了迷因，我们需要添加一些文本，以确保它能够发出笑声。我们将介绍GPT-3 <strong class="kf jh">提示</strong>和<strong class="kf jh">完成</strong>是如何帮助我们的。以下是OpenAI在他们的<a class="ae jd" href="https://beta.openai.com/docs/introduction/key-concepts" rel="noopener ugc nofollow" target="_blank">文档</a>中所说的。</p><blockquote class="oe of og"><p id="5bb8" class="kd ke mp kf b kg kh ki kj kk kl km kn oh kp kq kr oi kt ku kv oj kx ky kz la ij bi translated">完成点是我们API的中心。它为我们的模型提供了一个非常灵活和强大的简单接口。您输入一些文本作为<strong class="kf jh">提示</strong>，模型将生成一个文本<strong class="kf jh">完成</strong>，试图匹配您给它的任何上下文或模式。</p></blockquote><p id="da14" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们浏览了为这个项目创建的一个提示，以及我们如何通过一种叫做“少量学习”的方法获得迷因所需的标题。</p><p id="587d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> Makememe.ai </a>在一个名为<code class="fe ns nt nu nv b">generate_meme()</code>的函数中调用<strong class="kf jh">完成</strong>端点。该函数采用<code class="fe ns nt nu nv b">user_input</code>和<code class="fe ns nt nu nv b">meme_description</code>变量。这里<code class="fe ns nt nu nv b">user_id</code>再次被传递到<strong class="kf jh">完成</strong>端点，用于OpenAI的AI安全研究。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="e011" class="nf li jg nv b gy oa ob l oc od">meme = generate_meme(user_input, meme_description, user_id)</span></pre><p id="516b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们研究一下这个函数，看看发生了什么。我们有一个数组，看起来类似于我们之前看到的<code class="fe ns nt nu nv b">documents</code>数组，但是有一点小小的不同。<code class="fe ns nt nu nv b">memes</code>数组包含20个类，而不是我们之前在<code class="fe ns nt nu nv b">documents</code>中看到的字符串。我创建了每个类，所以它有一个人工智能提示与之相关联。如果选择了一个迷因(在我们的例子中是<code class="fe ns nt nu nv b"><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/generator/prompts/types/change_my_mind.py" rel="noopener ugc nofollow" target="_blank">Change_My_Mind</a></code>)，自定义提示将帮助解析<code class="fe ns nt nu nv b">user_input</code>以适应迷因的固有设计(并且有趣)。当我们查看提示时，这将更有意义。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="54e0" class="nf li jg nv b gy oa ob l oc od"><strong class="nv jh">def generate_meme(user_input, meme_description, user_id):</strong></span><span id="57a6" class="nf li jg nv b gy om ob l oc od">    memes = [They_Dont_Know, Indifferent, Poor_Fix, Sad, Waiting,   <br/>        Is_Better, Three_Levels_Increasing, Pompous,     <br/>        No_Responsibility, Ineffective_Solution, <strong class="nv jh">Change_My_Mind</strong>, <br/>        Accurate_Depiction, Equal, Distracting, Stay_Away_From,     <br/>        Ruin, Scary, Strong_Preference, Missing_Something, <br/>        When_Not_Good]</span></pre><p id="6c2f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们循环遍历这个数组中的每个迷因。每个类都有一个名为<code class="fe ns nt nu nv b">description</code>的静态变量，它对应于我们之前看到的<code class="fe ns nt nu nv b">documents</code>数组。例如，<code class="fe ns nt nu nv b"><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/generator/prompts/types/change_my_mind.py" rel="noopener ugc nofollow" target="_blank">Change_My_Mind</a></code>类有一个对<code class="fe ns nt nu nv b">"This is my opinion. Change my mind."</code>的描述。相比之下，我们之前选择的<code class="fe ns nt nu nv b">meme_description</code>具有相同的值。通过将<code class="fe ns nt nu nv b">meme_description</code>与这些类中的描述进行比较，我们可以发现它们何时相等。如果类描述<code class="fe ns nt nu nv b">meme.description</code>与所选的meme <code class="fe ns nt nu nv b">meme_description</code>匹配，那么我们将输入这个<code class="fe ns nt nu nv b">if</code>语句，并使用该特定<code class="fe ns nt nu nv b">meme</code>类的提示。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="d6b1" class="nf li jg nv b gy oa ob l oc od">for meme in memes:<br/>    if meme_description == meme.description:</span></pre><p id="3342" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们在<code class="fe ns nt nu nv b">if</code>语句中，并且在作用域中有了正确的<code class="fe ns nt nu nv b">meme</code>类，我们将创建这个类的一个实例。我们用该类的一个实例覆盖了我们的<code class="fe ns nt nu nv b">meme</code>变量(可以很容易地创建一个新变量)。这里的<code class="fe ns nt nu nv b">f-string</code>将追加<code class="fe ns nt nu nv b"><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/generator/prompts/types/change_my_mind.py" rel="noopener ugc nofollow" target="_blank">Change_My_Mind</a></code>和<code class="fe ns nt nu nv b">()</code>，这样语句就变成了<code class="fe ns nt nu nv b">eval('Change_My_Mind()')</code>，它将创建这个类的一个实例。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="14a7" class="nf li jg nv b gy oa ob l oc od">meme = eval(f'{meme.name}()')                </span></pre><p id="a236" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> GPT-3提示</strong></p><p id="2c9f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们使用OpenAI的<strong class="kf jh">完成</strong>端点。我们发送一个自定义提示，GPT 3将完成它，将用户的文本输入修改成适合迷因的迷因标题。下面是我们选择的迷因的提示示例。我们将逐步介绍提示符如何解析用户的文本。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="db03" class="nf li jg nv b gy oa ob l oc od">###<br/><strong class="nv jh">Message:</strong> Chocolate chip cookies are the best cookies. Try to change my mind.<br/><strong class="nv jh">Meme:</strong>{"opinion":" Chocolate chip cookies are the best cookies. Change my mind."}<br/>###<br/><strong class="nv jh">Message:</strong> Learning to code is one of the most rewarding experiences. Change my mind.<br/><strong class="nv jh">Meme:</strong>{"opinion":"Learning to code is one of the most rewarding experiences. Change my mind."}<br/>###<br/><strong class="nv jh">Message:</strong> In my opinion, Daft Punk is the greatest electronic band to exist.<br/><strong class="nv jh">Meme:</strong>{"opinion":"Daft Punk is the greatest electronic band to ever exist. Change my mind."}<br/>###</span></pre><p id="e133" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在提示中，我们使用一种叫做<strong class="kf jh">少量学习</strong>的方法，为给定的文本输入(消息:)提供我们想要的输出(模因:)的例子。示例为模型提供了我们目标的上下文。当模型看到<code class="fe ns nt nu nv b">Message: ~put our text here~</code>时，它将尝试完成文本<code class="fe ns nt nu nv b">meme: ~some json here~</code>。</p><p id="e754" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们发送从用户输入中获得的新示例。在我们的代码中，我们在提示后面添加了<code class="fe ns nt nu nv b">append_example()</code>。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="b8fa" class="nf li jg nv b gy oa ob l oc od">meme.append_example(user_input)</span></pre><p id="694d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们提示的底部现在在<code class="fe ns nt nu nv b">Message:</code>之后有了我们的例子。该模型将在<code class="fe ns nt nu nv b">Meme:</code>之后基于从少数镜头示例中学习到的内容来完成文本。</p><p id="992e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nv b">###</code>有两个用途。首先，这三个字符作为<code class="fe ns nt nu nv b">stop</code>令牌。基本上，人工智能需要知道何时停止提供新文本。其次，它给出了新示例开始和结束的模型上下文。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="0dc2" class="nf li jg nv b gy oa ob l oc od">...<br/>###<br/>Message: <!-- -->In my opinion, open-source projects are the best projects<br/>Meme:</span></pre><p id="a90c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在将提示发送到<code class="fe ns nt nu nv b"><strong class="kf jh">completion</strong></code> API端点，并从模型获得响应。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="2678" class="nf li jg nv b gy oa ob l oc od">response = GPT.completion_request(prompt, user_id)</span></pre><p id="db2e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们可能会收到的<strong class="kf jh">完成</strong>的示例。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="1cff" class="nf li jg nv b gy oa ob l oc od">{"opinion":"Open-sourced projects are the best project. Change my mind."}</span></pre><p id="26f1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我选择JSON格式让AI来完成，因为它很容易用Python来解析。这在后面的步骤中会更有意义。我们可以很容易地不使用JSON，响应可以简单地是文本，比如<code class="fe ns nt nu nv b">Open-sourced projects are the best project. Change my mind</code>。</p><p id="cfd3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模型注意到所有的例子都以<code class="fe ns nt nu nv b">Change my mind</code>结尾，并且它正确地遵循了这个模式。</p><p id="04bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这里没有<code class="fe ns nt nu nv b">###</code>字符。这是因为我们告诉API在到达<code class="fe ns nt nu nv b">###</code>时停止生成。模型用JSON文本进行响应，其中包含下一步要使用的meme标题。</p><p id="13ec" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还没有使用过提示，我推荐<a class="ae jd" href="https://beta.openai.com/signup" rel="noopener ugc nofollow" target="_blank">注册</a>open ai并尝试操场环境。</p><h2 id="9782" class="nf li jg bd lj ng nh dn ln ni nj dp lr ko nk nl lv ks nm nn lz kw no np md nq bi translated">将迷因标题覆盖在所选图像上</h2><p id="06b3" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我们现在将上一步中的迷因标题文本覆盖在我们从<strong class="kf jh">语义搜索</strong>中选择的图片上。我们使用一个名为<code class="fe ns nt nu nv b">Pillow</code>的Python库，它可以编辑图像并在图像上绘制文本。</p><p id="4d29" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ns nt nu nv b">json.loads()</code>方法将来自API的文本转换成我们可以使用的JSON对象。</p><p id="c65d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们之前实例化的<code class="fe ns nt nu nv b">meme</code>对象有一个将文本绘制到meme上的<code class="fe ns nt nu nv b">create()</code>方法。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="343f" class="nf li jg nv b gy oa ob l oc od">response = json.loads(response)                <br/>image_name = meme.create(response)</span></pre><p id="b434" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们示例中的<code class="fe ns nt nu nv b">create()</code>方法可以在<code class="fe ns nt nu nv b"><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/generator/prompts/types/change_my_mind.py" rel="noopener ugc nofollow" target="_blank">Change_My_Mind</a><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/generator/prompts/types/they_dont_know.py" rel="noopener ugc nofollow" target="_blank">.py</a></code>中找到。首先，该方法用<code class="fe ns nt nu nv b">Pillow</code>库的<code class="fe ns nt nu nv b">Image</code>类打开<code class="fe ns nt nu nv b"><a class="ae jd" href="https://github.com/joshbickett/makememe_ai/blob/main/makememe/static/meme_pics/change_my_mind.jpg" rel="noopener ugc nofollow" target="_blank">change_my_mind.jpg</a></code>。我们将图像定义为<code class="fe ns nt nu nv b">base</code>，因为它是绘制文本的基础。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="a09d" class="nf li jg nv b gy oa ob l oc od">Image.open(f"makememe/static/meme_pics/{self.name.lower()}.jpg").convert("RGBA") as base:</span></pre><p id="35fc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用我的自定义类<code class="fe ns nt nu nv b">Image_Manager</code>将文本添加到带有<code class="fe ns nt nu nv b">add_text()</code>的图像中。我们传递将要写入文本的<code class="fe ns nt nu nv b">base</code>图像。我们传递附加信息，如<code class="fe ns nt nu nv b">text</code>、<code class="fe ns nt nu nv b">position,</code>和<code class="fe ns nt nu nv b">font_size</code>。对于每一个定制类，比如<code class="fe ns nt nu nv b">Change_My_Mind</code>，文本<code class="fe ns nt nu nv b">position</code>和<code class="fe ns nt nu nv b">font_size</code>与特定meme的格式对齐。对于我们选择的迷因，<code class="fe ns nt nu nv b">position=(190,200)</code>。<code class="fe ns nt nu nv b">190</code>是<code class="fe ns nt nu nv b">x</code>文本位置，<code class="fe ns nt nu nv b">200</code>是<code class="fe ns nt nu nv b">y</code>文本位置。如果文本放在错误的地方，迷因可能没有意义或不好笑，所以每个迷因类都向<code class="fe ns nt nu nv b">add_text()</code>发送特定的细节。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="2795" class="nf li jg nv b gy oa ob l oc od">overlay_image = Image_Manager.add_text(base=base, text=meme_text['opinion'], position=(190,200), font_size=60, text_color="black", wrapped_width=22)</span></pre><p id="dc0f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前一步给了我们一个<code class="fe ns nt nu nv b">overlay_image</code>，它有一个透明的背景，但包含了迷因文本。我们在原始的<code class="fe ns nt nu nv b">base</code>迷因图像上添加了透明的<code class="fe ns nt nu nv b">overlay_image</code>。<code class="fe ns nt nu nv b">Image</code>类有一个名为<code class="fe ns nt nu nv b">alpha_composite()</code>的函数来做覆盖。叠加步骤的输出图像我们称之为<code class="fe ns nt nu nv b">out</code>，这就是最终的模因！</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="2e81" class="nf li jg nv b gy oa ob l oc od">out = Image.alpha_composite(base, overlay_image)</span></pre><p id="80fc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们为网站创建了一个<code class="fe ns nt nu nv b">image_name</code>来引用和展示迷因。我们将用户创建的所有模因保存在<code class="fe ns nt nu nv b">makememe/static/creations</code>目录下。最后，我们将名为<code class="fe ns nt nu nv b">out</code>的模因图像保存到<code class="fe ns nt nu nv b">file_location</code>。</p><pre class="lb lc ld le gt nw nv nx ny aw nz bi"><span id="3f08" class="nf li jg nv b gy oa ob l oc od">image_name = f'{date}.jpg'                <br/>file_location = f'makememe/static/creations/{image_name}'<br/>out.save(file_location)</span></pre><p id="c9c3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们做到了！我们使用<strong class="kf jh">语义搜索</strong>来选择符合用户描述的模因图像。然后，我们使用<strong class="kf jh"> GPT-3提示完成</strong>将用户的描述修改成一个幽默的迷因标题，并与我们选择的迷因保持一致。最后，我们给迷因图片添加了迷因标题。下面是我们最后的创作！</p><figure class="lb lc ld le gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d5b27c32cade2a3b826f210e5a5ea0a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Km3HV1X6MGlp6a1OBljzBw.png"/></div></div><p class="iz ja gj gh gi jb jc bd b be z dk translated">制作于<a class="ae jd" href="http://makememe.ai/" rel="noopener ugc nofollow" target="_blank"> makememe.ai </a>。<a class="ae jd" href="https://unsplash.com/photos/QARM_X5HWyI" rel="noopener ugc nofollow" target="_blank">图片</a>由<a class="ae jd" href="https://unsplash.com/@koutchinski" rel="noopener ugc nofollow" target="_blank"> Felix Koutchinski </a>根据<a class="ae jd" href="https://unsplash.com/license" rel="noopener ugc nofollow" target="_blank"> Unsplash许可</a></p></figure><h1 id="12f0" class="lh li jg bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">你如何参与这个项目</h1><p id="3eb3" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">为开源项目做贡献是了解软件开发和人工智能系统的好方法。我鼓励任何感兴趣的人尝试改进Github上的项目。实现你的想法，玩得开心！</p><p id="777a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一个喜欢的迷因，但在项目的<a class="ae jd" href="https://github.com/joshbickett/makememe_ai/tree/main/makememe/static/meme_pics" rel="noopener ugc nofollow" target="_blank"> 20个支持的迷因</a>下没有看到？欢迎大家叉库加迷因。一旦你为一个新的迷因准备好代码，做一个拉请求(PR)。我将查看拉取请求，并确认该meme是否可以添加到网站。如果你对添加一个meme的指导方针有疑问，请联系我，邮箱:<strong class="kf jh"> josh@makememe.ai </strong>或<strong class="kf jh"> </strong> <a class="ae jd" href="https://twitter.com/josh_bickett" rel="noopener ugc nofollow" target="_blank"> <strong class="kf jh"> DM我上Twitter </strong> </a> <strong class="kf jh">。</strong></p><p id="1061" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将AI GIF memes等创意带入生活！</p><p id="1e94" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有任何技术或一般问题，请随时通过<strong class="kf jh"> josh@makememe.ai </strong>联系我。如果您在代码中遇到任何问题，我很乐意帮助您解决它并提供想法！</p><h1 id="6254" class="lh li jg bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">项目更新</h1><p id="78bc" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">通过<a class="ae jd" href="https://twitter.com/josh_bickett" rel="noopener ugc nofollow" target="_blank">在Twitter </a>上关注我来了解项目的最新进展，我在Twitter上发布人工智能迷因并从事其他有趣的人工智能项目！</p><h1 id="0d72" class="lh li jg bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">感谢</h1><p id="9c11" class="pw-post-body-paragraph kd ke jg kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">我要感谢奥斯汀·Damiani和乌达拉·阿贝塞克拉对这个项目的帮助！</p></div></div>    
</body>
</html>