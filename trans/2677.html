<html>
<head>
<title>Tutorial: Data-Oriented-Python in 15 minutes — Less Complexity through Data/Logic Separation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">教程:面向数据——15分钟内的Python通过数据/逻辑分离降低复杂性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tutorial-data-oriented-python-in-15-minutes-less-complexity-through-data-logic-separation-b5ee00518772#2022-06-09">https://towardsdatascience.com/tutorial-data-oriented-python-in-15-minutes-less-complexity-through-data-logic-separation-b5ee00518772#2022-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8205" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个3步教程，教你Python面向数据方法的三个主要概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8f954958dbb541779a2f2d33f0fed8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rGVbxfFHYm3xqUi3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">面向数据的代码让一切变得更简单、更快乐。图片由作者提供。</p></figure><p id="b65d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated">你听说过面向数据的编程方法吗？如果没有，现在你有了。本教程是为了让你对它感到兴奋，用Python编写的。</p><p id="2bdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们要做一些非常简单的事情:</p><p id="9b06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">1.我们将看看一个常见的虹膜分类问题，我已经通过编写两个Python类为您“解决”了这个问题。</p><p id="63da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.然后我们将尝试在稍微不同的上下文中应用这些类，并重用它们。</p><p id="e470" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.这不会很顺利，所以我们将使用<strong class="la iu"> <em class="md">面向数据的方法</em> </strong>把我的几个类变成很酷的面向数据的Python代码。</p><p id="e637" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以跟着做，说明在下面和GitHub上。</p><h1 id="f063" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">第一步</h1><p id="c543" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">标准Python代码转变为面向数据的Python代码的最简单示例如下:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="943a" class="ng mf it nc b gy nh ni l nj nk"># NON DO VERSION-----------------------------------</span><span id="6de7" class="ng mf it nc b gy nl ni l nj nk">class data():</span><span id="17c9" class="ng mf it nc b gy nl ni l nj nk">  X = 1</span><span id="b910" class="ng mf it nc b gy nl ni l nj nk">  def add(self):</span><span id="faf5" class="ng mf it nc b gy nl ni l nj nk">    self.X = X+1<br/></span><span id="df18" class="ng mf it nc b gy nl ni l nj nk">## DO version--------------------------------------</span><span id="ec9e" class="ng mf it nc b gy nl ni l nj nk">class data(PRecord): ## (1) Using a base type PRecord = a map/dict in Python</span><span id="8901" class="ng mf it nc b gy nl ni l nj nk">  X = field() ## (2) Using an immutable type from pyristent</span><span id="aafc" class="ng mf it nc b gy nl ni l nj nk"><br/>def add(data): ## (3) Separating the logic (add) from the data</span><span id="cf52" class="ng mf it nc b gy nl ni l nj nk">  return data.set(X=data.X+1) ## (2) return a new data piece, as data is immutable!</span></pre><p id="ef44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">三个简单的步骤，听起来很简单，对吗？让我们简单地看一下我们在这里应用的这三个想法。</p><h1 id="90e9" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">简而言之，面向数据的方法</h1><p id="efaa" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">面向数据的方法被称为面向数据的编程(DOP)或面向数据的设计(DOD)。国防部从游戏设计领域走出来，目标是让数据计算和游戏运行得更快。DOP的人显然意识到DOD中用于游戏的想法在大多数数据密集型环境中有完全不同的意义！奇怪的是，使用的方法实际上是不同的。所以我在这里写的是以下的想法:</p><p id="48e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想法很简单:我们将数据与业务逻辑分离。我们通过使用通用结构并保持数据不变的方式来实现这一点。通过这样做，我们解耦了系统的各个部分，从而降低了整个系统的复杂性。<em class="md">(用我自己的话说)</em></p><p id="d66f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">这里的关键成分是:</strong></p><ul class=""><li id="020d" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">分离数据，使其成为“一等公民”。许多编程语言事实上已经有了“数据类”,这些数据类只保存数据，其他什么也不保存。</li><li id="6f9d" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">我们使用<a class="ae nv" href="https://www.geeksforgeeks.org/generics-in-c/" rel="noopener ugc nofollow" target="_blank">通用结构</a>，像<a class="ae nv" href="https://livebook.manning.com/book/programming-with-types/chapter-9/" rel="noopener ugc nofollow" target="_blank">映射和数组</a>，因为它们已经自带了像“打印”或“排序”这样的内置方法，不需要我们编写它们。</li><li id="a088" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">我们保持数据<a class="ae nv" href="https://www.eventstore.com/blog/event-immutability-and-dealing-with-change" rel="noopener ugc nofollow" target="_blank">不可变</a>,因为可变性产生了复杂性。没必要问“x=2吗？或者在代码的这一点上x=3？”。</li></ul><p id="228d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有这些因素都旨在通过让数据成为一等公民来降低复杂性。现在，让我们动手实践一下吧！</p><h1 id="c030" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">快速安装指南</h1><p id="d1f5" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">转到Github，<a class="ae nv" href="https://github.com/sbalnojan/DOP-Example" rel="noopener ugc nofollow" target="_blank">克隆存储库“DOP-Example”</a>并运行</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="f9db" class="ng mf it nc b gy nh ni l nj nk">./batect dev </span></pre><p id="bbe3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将打开一个Jupyter笔记本服务器，正确的笔记本已经加载，都在Docker中。打开<em class="md">“DO-Tutorial，ipynb”</em>，你就可以跟着做了。</p><h1 id="a496" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">编写第一个面向数据的Python</h1><p id="181a" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我编写了两个简单的类和一段Python代码，它们完成了以下任务:</p><p id="ced4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">- <em class="md"> ML_Dataset </em>可以加载并保存我的虹膜数据集，</p><p id="335a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">- <em class="md"> ML_Predictor </em>可将SVM拟合到ML_Dataset，预测单个结果，并将孔输入矩阵的预测写入ML_Dataset</p><p id="820a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">- <em class="md">程序代码</em>创建ML_Dataset，ML_Predictor，拟合预测器，将新生成的测试空间的预测写入数据集中，最后运行一个测试预测。</p><p id="44ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是这两个类的Python代码。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="5898" class="ng mf it nc b gy nh ni l nj nk">#### — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </span><span id="cb6d" class="ng mf it nc b gy nl ni l nj nk">### These are our two machine learning classes. We wrapped stuff into classes to possibly extend this and make it more reusable…</span><span id="ee6d" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_Dataset():</span><span id="05bc" class="ng mf it nc b gy nl ni l nj nk">  “”” Should hold our data, targets, predictions, basically X and y…</span><span id="fcbf" class="ng mf it nc b gy nl ni l nj nk">  Should also be able to fill itself, once we need it. “””</span><span id="e0f2" class="ng mf it nc b gy nl ni l nj nk">  X <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="c05a" class="ng mf it nc b gy nl ni l nj nk">  y <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="55e3" class="ng mf it nc b gy nl ni l nj nk">  y_pred <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="ec6d" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> load_iris(self):</span><span id="2ca7" class="ng mf it nc b gy nl ni l nj nk">    iris <strong class="nc iu">=</strong> datasets<strong class="nc iu">.</strong>load_iris()</span><span id="14d4" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>X <strong class="nc iu">=</strong> iris[“data”][:,3:] # petal width</span><span id="46eb" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>y <strong class="nc iu">=</strong> (iris[“target”]<strong class="nc iu">==</strong>2)<strong class="nc iu">.</strong>astype(np<strong class="nc iu">.</strong>int)<br/></span><span id="d376" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_CLF():</span><span id="e5db" class="ng mf it nc b gy nl ni l nj nk">  “””Should hold the classifier we want to use here,</span><span id="69a3" class="ng mf it nc b gy nl ni l nj nk">  should also be able to fit and predict. “””</span><span id="06c9" class="ng mf it nc b gy nl ni l nj nk">  clf <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="1864" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> fit_clf(self, m: ML_Dataset):</span><span id="9006" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>clf <strong class="nc iu">=</strong> svm<strong class="nc iu">.</strong>SVC(gamma<strong class="nc iu">=</strong>’scale’, decision_function_shape<strong class="nc iu">=</strong>’ovo’, probability<strong class="nc iu">=True</strong>)</span><span id="8c4b" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>fit(m<strong class="nc iu">.</strong>X,m<strong class="nc iu">.</strong>y)</span><span id="4afb" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> predict(self, X):</span><span id="ecf8" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">    return</strong> self<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>predict(X)</span><span id="adb2" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> write_preds(self,m):</span><span id="7cbf" class="ng mf it nc b gy nl ni l nj nk">  “””Writes predictions into an ML_Dataset using this classifier”””</span><span id="3f81" class="ng mf it nc b gy nl ni l nj nk">    m<strong class="nc iu">.</strong>y_pred <strong class="nc iu">=</strong> self<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>predict_proba(m<strong class="nc iu">.</strong>X)</span></pre><p id="fb54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我的小程序的样子:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ddae" class="ng mf it nc b gy nh ni l nj nk"><em class="md">#### — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </em></span><span id="ee0f" class="ng mf it nc b gy nl ni l nj nk"><em class="md">### Our running program. Yes, we’re still exploring stuff here.</em></span><span id="54a4" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># create our dataset, load stuff into it.</em></span><span id="206f" class="ng mf it nc b gy nl ni l nj nk">m <strong class="nc iu">=</strong> ML_Dataset()</span><span id="d64b" class="ng mf it nc b gy nl ni l nj nk">m<strong class="nc iu">.</strong>load_iris()</span><span id="3bbd" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># create our classifier and fit it to the dataset</em></span><span id="8c7a" class="ng mf it nc b gy nl ni l nj nk">c <strong class="nc iu">=</strong> ML_CLF()</span><span id="364a" class="ng mf it nc b gy nl ni l nj nk">c<strong class="nc iu">.</strong>fit_clf(m)</span><span id="4331" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># let’s try it out, into a new dataset to predict on into our dataset, then write our prediction in it and print them out…</em></span><span id="86d1" class="ng mf it nc b gy nl ni l nj nk">m<strong class="nc iu">.</strong>X <strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>linspace(0,3,1000)<strong class="nc iu">.</strong>reshape(<strong class="nc iu">-</strong>1,1)</span><span id="6b98" class="ng mf it nc b gy nl ni l nj nk">c<strong class="nc iu">.</strong>write_preds(m)</span><span id="96eb" class="ng mf it nc b gy nl ni l nj nk">print(m<strong class="nc iu">.</strong>y_pred)</span><span id="9653" class="ng mf it nc b gy nl ni l nj nk">print(“individual predictions: “, c<strong class="nc iu">.</strong>predict([[1.7],[1.5]]))</span></pre><p id="9a76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种特殊的情况下，这样做很好。现在让我们通过首先交换数据集来重用代码。</p><h1 id="c61b" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Pt 1分离数据和代码</h1><p id="9a5f" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">让我们将数据集换成不同的数据集。我放置了业务逻辑，将iris数据集加载到保存数据的类中。因此，我们需要改变这个类或者创建一个新的类来将我们的数据集换成一个不同的类。我们可以这样做，它看起来像这样:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="b9ea" class="ng mf it nc b gy nh ni l nj nk"><em class="md">#### — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </em></span><span id="3bd3" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># Option 1, write a new class</em></span><span id="5f37" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_Dataset_2():</span><span id="8650" class="ng mf it nc b gy nl ni l nj nk">  “”” Should hold our data, targets, predictions, basically X and y…</span><span id="72bb" class="ng mf it nc b gy nl ni l nj nk">  Should also be able to fill itself, once we need it. “””</span><span id="066d" class="ng mf it nc b gy nl ni l nj nk">  X <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="9710" class="ng mf it nc b gy nl ni l nj nk">  y <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="8e90" class="ng mf it nc b gy nl ni l nj nk">  y_pred <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="313b" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> load_different_dataset(self):</span><span id="5d1e" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>X <strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>array([[1],[2],[3],[4],[5]])</span><span id="d9ab" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>yy<strong class="nc iu">=</strong>np<strong class="nc iu">.</strong>array([1,0,0,1,1])</span><span id="80f5" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># Option 2, change the class</em></span><span id="37f8" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_Dataset():</span><span id="e604" class="ng mf it nc b gy nl ni l nj nk">  “”” Should hold our data, targets, predictions, basically X and y…</span><span id="2a33" class="ng mf it nc b gy nl ni l nj nk">  Should also be able to fill itself, once we need it. “””</span><span id="3e82" class="ng mf it nc b gy nl ni l nj nk">  X <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="23fc" class="ng mf it nc b gy nl ni l nj nk">  y <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="9376" class="ng mf it nc b gy nl ni l nj nk">  y_pred <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="05ed" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> load_iris(self):</span><span id="3437" class="ng mf it nc b gy nl ni l nj nk">    iris <strong class="nc iu">=</strong> datasets<strong class="nc iu">.</strong>load_iris()</span><span id="99f0" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>X <strong class="nc iu">=</strong> iris[“data”][:,3:] <em class="md"># petal width</em></span><span id="28ee" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>y <strong class="nc iu">=</strong> (iris[“target”]<strong class="nc iu">==</strong>2)<strong class="nc iu">.</strong>astype(np<strong class="nc iu">.</strong>int)</span><span id="8187" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> load_different_dataset(self):</span><span id="dc48" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>X <strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>array([[1],[2],[3],[4],[5]])</span><span id="b0f8" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>y <strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>array([1,0,0,1,1])</span></pre><p id="ee7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是每次我想交换东西的时候都要写一个新的类，这听起来是有问题的。让我们试试面向数据的方法，把数据从“代码”中分离出来。为此，编写一个类来保存数据X，y，y_pred，并编写一个函数将数据加载到数据类中。最后，我们编写第二个函数，将新数据加载到数据集中。可能是这样的:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="ab89" class="ng mf it nc b gy nh ni l nj nk"><em class="md">### THE DO Approach</em></span><span id="69f8" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_Dataset():</span><span id="e781" class="ng mf it nc b gy nl ni l nj nk">  “”” Should hold our data, targets, predictions, basically X and y…</span><span id="2287" class="ng mf it nc b gy nl ni l nj nk">  Should also be able to fill itself, once we need it. “””</span><span id="23e3" class="ng mf it nc b gy nl ni l nj nk">  X <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="2743" class="ng mf it nc b gy nl ni l nj nk">  y <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="3c13" class="ng mf it nc b gy nl ni l nj nk">  y_pred <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="dab4" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">def</strong> load_iris(m: ML_Dataset):</span><span id="0730" class="ng mf it nc b gy nl ni l nj nk">  iris <strong class="nc iu">=</strong> datasets<strong class="nc iu">.</strong>load_iris()</span><span id="b888" class="ng mf it nc b gy nl ni l nj nk">  m<strong class="nc iu">.</strong>X <strong class="nc iu">=</strong> iris[“data”][:,3:] <em class="md"># petal width</em></span><span id="f024" class="ng mf it nc b gy nl ni l nj nk">  m<strong class="nc iu">.</strong>y <strong class="nc iu">=</strong> (iris[“target”]<strong class="nc iu">==</strong>2)<strong class="nc iu">.</strong>astype(np<strong class="nc iu">.</strong>int)</span><span id="a5e3" class="ng mf it nc b gy nl ni l nj nk"><em class="md">## load old data</em></span><span id="3758" class="ng mf it nc b gy nl ni l nj nk">m <strong class="nc iu">=</strong> ML_Dataset()</span><span id="5e70" class="ng mf it nc b gy nl ni l nj nk">load_iris(m)</span><span id="d0ab" class="ng mf it nc b gy nl ni l nj nk"><em class="md">## load something new</em></span><span id="7b74" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">def</strong> load_new(m: ML_Dataset):</span><span id="b0d6" class="ng mf it nc b gy nl ni l nj nk">  m<strong class="nc iu">.</strong>X<strong class="nc iu">=</strong>np<strong class="nc iu">.</strong>array([[1],[2],[3],[4],[5]])</span><span id="89d7" class="ng mf it nc b gy nl ni l nj nk">  m<strong class="nc iu">.</strong>y<strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>array([1,0,0,1,1])</span><span id="dd5f" class="ng mf it nc b gy nl ni l nj nk">load_new(m)</span></pre><p id="8a17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这对我来说已经很容易理解了。让我们看看另一个问题，我们的数据的可变性。</p><h1 id="3bfe" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Pt 2不可变数据</h1><p id="07b2" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">让我们打印出目前为止使用的数据:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="c025" class="ng mf it nc b gy nh ni l nj nk">## OLD Approach</span><span id="5870" class="ng mf it nc b gy nl ni l nj nk">m <strong class="nc iu">=</strong> ML_Dataset()</span><span id="f4b0" class="ng mf it nc b gy nl ni l nj nk">load_iris(m)</span><span id="928e" class="ng mf it nc b gy nl ni l nj nk"><em class="md">## load something new</em></span><span id="6b05" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">def</strong> load_new(m: ML_Dataset):</span><span id="6786" class="ng mf it nc b gy nl ni l nj nk">…</span><span id="124d" class="ng mf it nc b gy nl ni l nj nk">## print out our dataset</span><span id="22f2" class="ng mf it nc b gy nl ni l nj nk">print(m<strong class="nc iu">.</strong>X)</span></pre><p id="4c7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意m.X的内容是如何变化的。我们不能简单地做一个print(m.X)，print(m_old_X)，因为数据确实在变化。在这种情况下，我们必须先打印，然后再修改。这很好，但是让我们来看看面向数据的方法，使用不可变数据的方法。</p><p id="cb8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于不可变数据，我们使用Python包<a class="ae nv" href="https://github.com/tobgu/pyrsistent" rel="noopener ugc nofollow" target="_blank"> pyrsistent </a>，并通过导入“from pyrsistent import field，PRecord”将我们的类重新创建为具有不可变字段的类。然后，我们通过向数据集加载新数据来创建数据集的新版本。这可能看起来像这样:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="49b3" class="ng mf it nc b gy nh ni l nj nk"><em class="md">### NEW DOP Implementation</em></span><span id="46ed" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># We’re using the module for immutable python pyrsistent here</em></span><span id="56a4" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_Dataset(PRecord):</span><span id="97bd" class="ng mf it nc b gy nl ni l nj nk">  X <strong class="nc iu">=</strong> field()</span><span id="88e8" class="ng mf it nc b gy nl ni l nj nk">  y <strong class="nc iu">=</strong> field()</span><span id="c65b" class="ng mf it nc b gy nl ni l nj nk">  y_pred <strong class="nc iu">=</strong> field()</span><span id="c9f4" class="ng mf it nc b gy nl ni l nj nk">  X_new <strong class="nc iu">=</strong> field()</span><span id="2840" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">def</strong> load_iris():</span><span id="c5b0" class="ng mf it nc b gy nl ni l nj nk"> iris <strong class="nc iu">=</strong> datasets<strong class="nc iu">.</strong>load_iris()</span><span id="73d1" class="ng mf it nc b gy nl ni l nj nk"> r_1 <strong class="nc iu">=</strong> ML_Dataset()</span><span id="f6f8" class="ng mf it nc b gy nl ni l nj nk"> r_2<strong class="nc iu">=</strong>r_1<strong class="nc iu">.</strong>set(X<strong class="nc iu">=</strong>iris[“data”][:,3:])</span><span id="c3f8" class="ng mf it nc b gy nl ni l nj nk"> r_3<strong class="nc iu">=</strong>r_2<strong class="nc iu">.</strong>set(y<strong class="nc iu">=</strong>iris[“target”])</span><span id="7e63" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu"> return</strong> r_3</span><span id="1938" class="ng mf it nc b gy nl ni l nj nk"><em class="md">## Here’s how we use it</em></span><span id="070d" class="ng mf it nc b gy nl ni l nj nk">r <strong class="nc iu">=</strong> load_iris()</span><span id="9113" class="ng mf it nc b gy nl ni l nj nk">r_2 <strong class="nc iu">=</strong> r<strong class="nc iu">.</strong>set(X <strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>linspace(0,3,1000)<strong class="nc iu">.</strong>reshape(<strong class="nc iu">-</strong>1,1))</span><span id="160b" class="ng mf it nc b gy nl ni l nj nk">## Just making sure this stuff is actually immutable!</span><span id="eacd" class="ng mf it nc b gy nl ni l nj nk">r<strong class="nc iu">.</strong>set(X<strong class="nc iu">=</strong>”1")</span><span id="366a" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># print(r.X)</em></span><span id="8415" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># &gt;&gt; [0. ]…… [0.01201201]</em></span><span id="43fa" class="ng mf it nc b gy nl ni l nj nk"><em class="md">## Oh that doesn’t work, let’s try direct item assignment maybe?</em></span><span id="d616" class="ng mf it nc b gy nl ni l nj nk">r[“X”]<strong class="nc iu">=</strong>1</span><span id="dd70" class="ng mf it nc b gy nl ni l nj nk"><em class="md">## &gt;&gt; TypeError: ‘ML_Dataset’ object does not support item assignment</em></span><span id="605f" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># Nice, so now this cannot happen accidentally.</em></span></pre><p id="54eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">太好了，Python现在阻止我覆盖数据，我现在基本上有了一个版本化的数据集。让我们看看第三步，使用通用数据结构的想法。</p><h1 id="4757" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">Pt 3通用数据结构</h1><p id="c0a6" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">我想到了给我的分类器对象添加“注释”的想法，这样我就可以留下类似“试验1，用params x，y，z进行试验”的注释。在我的旧代码中这样做，看起来会像这样:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="07f8" class="ng mf it nc b gy nh ni l nj nk"><em class="md">#### — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </em></span><span id="caf7" class="ng mf it nc b gy nl ni l nj nk"><em class="md">### These are our two machine learning classes. We wrapped stuff into classes to possibly extend this and make it more reusable…</em></span><span id="0274" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">class</strong> ML_CLF():</span><span id="3736" class="ng mf it nc b gy nl ni l nj nk">“””Should hold the classifier we want to use here,</span><span id="b78b" class="ng mf it nc b gy nl ni l nj nk">should also be able to fit and predict. “””</span><span id="4bc3" class="ng mf it nc b gy nl ni l nj nk">  clf <strong class="nc iu">=</strong> <strong class="nc iu">None</strong></span><span id="75bb" class="ng mf it nc b gy nl ni l nj nk">  trial_note <strong class="nc iu">=</strong> “trial 1”</span><span id="8d98" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> fit_clf(self, m: ML_Dataset):</span><span id="1dd0" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>clf <strong class="nc iu">=</strong> svm<strong class="nc iu">.</strong>SVC(gamma<strong class="nc iu">=</strong>’scale’, decision_function_shape<strong class="nc iu">=</strong>’ovo’, probability<strong class="nc iu">=True</strong>)</span><span id="d0fd" class="ng mf it nc b gy nl ni l nj nk">    self<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>fit(m<strong class="nc iu">.</strong>X,m<strong class="nc iu">.</strong>y)</span><span id="d452" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> predict(self, X):</span><span id="f343" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">    return</strong> self<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>predict(X)</span><span id="f0d3" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  def</strong> write_preds(self,m):</span><span id="599f" class="ng mf it nc b gy nl ni l nj nk">    “””Writes predictions into an ML_Dataset using this classifier”””</span><span id="c4c4" class="ng mf it nc b gy nl ni l nj nk">    m<strong class="nc iu">.</strong>y_pred <strong class="nc iu">=</strong> self<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>predict_proba(m<strong class="nc iu">.</strong>X)</span></pre><p id="7b98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们创建一个分类器并打印出来，看看我的笔记是什么样的:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="7a79" class="ng mf it nc b gy nh ni l nj nk"><em class="md">#### — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — </em></span><span id="2fd2" class="ng mf it nc b gy nl ni l nj nk"><em class="md">### Now let’s create another classifier.</em></span><span id="12f9" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># Let’s print it out to see the comment</em></span><span id="f57b" class="ng mf it nc b gy nl ni l nj nk">c <strong class="nc iu">=</strong> ML_CLF()</span><span id="c427" class="ng mf it nc b gy nl ni l nj nk">print(c)</span><span id="7d72" class="ng mf it nc b gy nl ni l nj nk"><em class="md"># &lt;__main__.ML_CLF object at 0x7f7b102cbdf0&gt;</em></span></pre><p id="95ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这不是我所期望的。我们可以通过提供__str__方法来解决这个问题。但是面向数据的方法采取了不同的路线。让我们像使用字典一样使用泛型类来使用字典的内置函数，如print()或item()。我们仍然希望保持它不变，所以我们使用来自pyrsistent的预编码，它本质上是一个字典。如果我们这样做，我们的代码可能如下所示:</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3b77" class="ng mf it nc b gy nh ni l nj nk"><strong class="nc iu">class</strong> ML_Predictor(PRecord):</span><span id="89fd" class="ng mf it nc b gy nl ni l nj nk">  clf <strong class="nc iu">=</strong> field()</span><span id="0ba8" class="ng mf it nc b gy nl ni l nj nk">  note <strong class="nc iu">=</strong> field()</span><span id="716e" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">def</strong> predict_stuff(m: ML_Predictor, d: ML_Dataset):</span><span id="21f4" class="ng mf it nc b gy nl ni l nj nk">  m_2 <strong class="nc iu">=</strong> m<strong class="nc iu">.</strong>set(clf<strong class="nc iu">=</strong>m<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>fit(r<strong class="nc iu">.</strong>X,r<strong class="nc iu">.</strong>y))</span><span id="7652" class="ng mf it nc b gy nl ni l nj nk"><em class="md">  # Al right! Now we got…</em></span><span id="87c1" class="ng mf it nc b gy nl ni l nj nk"><em class="md">  # — m, as the initialized and unfitted CLF</em></span><span id="e98c" class="ng mf it nc b gy nl ni l nj nk"><em class="md">  # — m_2 as the fitted predictor. From the outside, not easy to   distinguish…</em></span><span id="deab" class="ng mf it nc b gy nl ni l nj nk">  d_2 <strong class="nc iu">=</strong> d<strong class="nc iu">.</strong>set(y_pred <strong class="nc iu">=</strong> m_2<strong class="nc iu">.</strong>clf<strong class="nc iu">.</strong>predict_proba(d<strong class="nc iu">.</strong>X_new))</span><span id="c7d3" class="ng mf it nc b gy nl ni l nj nk"><strong class="nc iu">  return</strong> d_2</span><span id="817b" class="ng mf it nc b gy nl ni l nj nk"><em class="md">### Our Program — — — — — — — — — — — — — — — — — — — — — — — — — — </em></span><span id="c05f" class="ng mf it nc b gy nl ni l nj nk">r <strong class="nc iu">=</strong> load_iris()</span><span id="87e2" class="ng mf it nc b gy nl ni l nj nk">r_2 <strong class="nc iu">=</strong> r<strong class="nc iu">.</strong>set(X_new <strong class="nc iu">=</strong> np<strong class="nc iu">.</strong>linspace(0,3,1000)<strong class="nc iu">.</strong>reshape(<strong class="nc iu">-</strong>1,1))</span><span id="d08e" class="ng mf it nc b gy nl ni l nj nk">c <strong class="nc iu">=</strong> ML_Predictor(clf<strong class="nc iu">=</strong>svm<strong class="nc iu">.</strong>SVC(gamma<strong class="nc iu">=</strong>’scale’, decision_function_shape<strong class="nc iu">=</strong>’ovo’, probability<strong class="nc iu">=True</strong>), note<strong class="nc iu">=</strong>”This is trial 1; using SVC”)</span><span id="cabb" class="ng mf it nc b gy nl ni l nj nk">c_2 <strong class="nc iu">=</strong> c<strong class="nc iu">.</strong>set(clf<strong class="nc iu">=</strong>svm<strong class="nc iu">.</strong>SVC(gamma<strong class="nc iu">=</strong>’scale’, decision_function_shape<strong class="nc iu">=</strong>’ovo’, probability<strong class="nc iu">=True</strong>, kernel<strong class="nc iu">=</strong>’poly’), note<strong class="nc iu">=</strong>”This is trial 2\</span><span id="63dd" class="ng mf it nc b gy nl ni l nj nk">; using SVC with polyn. kernel”)</span><span id="c5cc" class="ng mf it nc b gy nl ni l nj nk">print(c)</span><span id="5f45" class="ng mf it nc b gy nl ni l nj nk">print(c_2)</span><span id="48dc" class="ng mf it nc b gy nl ni l nj nk">print(c<strong class="nc iu">.</strong>items()) <em class="md"># we can use all the default cool functions on this generic Map!```</em></span></pre><p id="b252" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">耶！为了使它完整，我还从之前的类中删除了业务逻辑。现在我们有了一段很好的可重用代码，使数据成为一等公民，更容易理解，也更容易模块化。</p><p id="1e9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就这样，您已经学到了Python面向数据方法的第一课。让我们回顾一下。</p><h1 id="4fff" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">概述</h1><ul class=""><li id="bff5" class="nm nn it la b lb mw le mx lh ob ll oc lp od lt nr ns nt nu bi translated">面向数据的Python让数据成为一等公民</li><li id="7c3c" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">至于降低复杂性</li><li id="9a8c" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">它将数据从业务逻辑中分离出来</li><li id="784f" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">它使用通用数据结构</li><li id="53d1" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">它只使用不可变的数据</li></ul><p id="8ae5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你感兴趣，我强烈推荐你继续阅读这种方法。</p><h1 id="75e7" class="me mf it bd mg mh mi mj mk ml mm mn mo jz mp ka mq kc mr kd ms kf mt kg mu mv bi translated">接下来读什么</h1><p id="8ac4" class="pw-post-body-paragraph ky kz it la b lb mw ju ld le mx jx lg lh my lj lk ll mz ln lo lp na lr ls lt im bi translated">遗憾的是，我没有任何特定于Python的资源。但是我有资源。</p><ul class=""><li id="193d" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">有一本名为《<a class="ae nv" href="https://www.manning.com/books/data-oriented-programming" rel="noopener ugc nofollow" target="_blank">面向数据编程</a>》的书，由曼宁出版，作者是耶霍纳坦·沙尔维特。他还在自己的<a class="ae nv" href="https://blog.klipse.tech/databook/2020/09/29/do-principles.html" rel="noopener ugc nofollow" target="_blank">网站</a>上免费发布了大量内容。</li><li id="c361" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">然后有一本书更针对面向数据的游戏设计社区。理查德·费边称之为“<a class="ae nv" href="https://www.amazon.de/Data-oriented-design-engineering-resources-schedules/dp/1916478700" rel="noopener ugc nofollow" target="_blank">面向数据的设计</a>”。这本书在他的网站上也有在线版本。</li><li id="e9a7" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">还有一个<a class="ae nv" href="https://github.com/dbartolini/data-oriented-design" rel="noopener ugc nofollow" target="_blank"> Github库</a>包含了很多还没有提到的信息，包括视频等等，所以也来看看吧。</li><li id="ec02" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">我发现一篇关于<a class="ae nv" href="https://www.moderndescartes.com/essays/data_oriented_python/" rel="noopener ugc nofollow" target="_blank">面向数据的Python </a>的文章解释得很好，即使我们依靠NumPy来处理像“指针优化”这样的大部分单词，我们仍然可以从中获得5-10倍的速度优势。</li></ul></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="6df6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="md">对如何建立伟大的数据公司、伟大的数据密集型产品、成为伟大的数据团队感兴趣，还是对如何利用开源构建伟大的东西感兴趣？然后考虑加入我的</em> <a class="ae nv" href="http://thdpth.com/" rel="noopener ugc nofollow" target="_blank"> <em class="md">免费简讯《三个数据点周四》</em> </a> <em class="md">。它已经成为数据初创企业、风投和数据领导者值得信赖的资源。</em></p></div></div>    
</body>
</html>