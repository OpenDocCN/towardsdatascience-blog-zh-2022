<html>
<head>
<title>Swarm Intelligence: Coding and Visualising Particle Swarm Optimisation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">群体智能:Python中粒子群优化的编码和可视化</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/swarm-intelligence-coding-and-visualising-particle-swarm-optimisation-in-python-253e1bd00772#2022-06-15">https://towardsdatascience.com/swarm-intelligence-coding-and-visualising-particle-swarm-optimisation-in-python-253e1bd00772#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7c42" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用简单的代码和动画解释自然启发的算法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/201df09defce7416644d782c8cd52f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IpEqCgAZ13ush6fY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">塞巴斯蒂安·佩纳·兰巴里在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="986c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们探索了受自然启发的优化算法粒子群优化的理论方面，然后将该算法应用于Python中的一个简单示例，用动画gif表示它，以便我们可以看到它是如何工作的。</p><p id="2808" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您正在使用带有反向传播的随机梯度下降训练深度学习模型，并且无法摆脱局部最小值，本文可能会帮助您找到解决问题的替代方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="3d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个群体是代理人或有机体的集合；群体智能可以被定义为群体的社会行为，其中自治的个体以分散的和自组织的方式相互作用。个体之间的相互作用提高了关于环境的经验知识，并使群体达到最佳状态。</p><p id="582c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在自然界观察到这样的智能。例如，众所周知，蚂蚁能找到从蚁群到食物源的最短路径。开始时，个人探索从目的地到目的地的各种方向。当找到一条有利的路线时，蚂蚁用信息素标记路线，信息素是蚂蚁沉积在地面上的化学物质。随着越来越多的蚂蚁走上同一条路，信息素会增强，吸引更多的蚂蚁。因此，大多数蚂蚁会跟随并收敛到最短的路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/6dd3a5d3552afde24fce8c8fa4193e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QUweeaXb0aRlJrhh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@i__prabir?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普拉比尔·卡什亚普</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一些受自然启发的算法模仿群体智能。蚁群优化(ACO)源自蚂蚁。人工蜂群(ABC)的灵感来自蜜蜂群集在它们的蜂巢周围。这篇文章是关于粒子群优化(PSO)的，它是由鸟群和鱼群暗示的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="c5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PSO最初是由James Kennedy和Russell Eberhart在1995年提出的。[1] [2]他们假设信息的社会共享会给群体带来好处。每当资源分布超出预测时，鱼群中的个体成员可以从其他成员的发现和经验中获利，而不是为了食物而竞争。关键词是“社交”。社会行为增加了个人的适应能力；结果，智能在蜂群中出现。个体的适应性和集体的智力是相互关联的。</p><p id="813e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">粒子群算法简单。粒子是搜索空间中的一些简单实体。我们创建一个粒子群，并用问题的目标函数来度量它们的个体适应度。然后，基于粒子的个人最佳位置和群体目前的最佳位置，粒子从当前位置移动到下一个位置。通过迭代移动，群体在几代中逐渐达到目标函数的最佳点。</p><p id="3bc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些符号:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="accf" class="mf mg iq mb b gy mh mi l mj mk">Number of particles         : i<em class="ml"><br/></em>Number of dimensions        : n<br/>Fitness function            : f(x_i)<br/>Particles                   : x_i = (x_i1, x_i2, ..., x_in)<br/>Current velocity            : v_i = (v_i1, v_i2, ..., v_in)<br/>Individual particle's best  : p_i = (p_i1, p_i2, ..., p_in)<br/>Global particles' best      : p_g = (p_g1, p_g2, ..., p_gn)<br/>Inertia component           : w * v_i(t)<br/>Cognitive component         : c_1 * r_1 * (p_i - x_i(t))<br/>Social component            : c_2 * r_2 * (g_i - x_i(t))<br/>Velocity adjustment         : v_i(t+1) &lt;- Inertia+Cognitive+Social<br/>Position adjustment         : x_i(t+1) &lt;- x_i(t)+v_i(t+1)</span></pre><p id="f870" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">速度调整受3个因素的影响:以前的速度(惯性分量)，个体粒子的最佳位置(认知分量)和群体的最佳位置(社会分量)。速度是一个移动的粒子在给定方向上的速度。粒子的运动在每个方向上都受到这些重量的影响。系数<em class="ml"> w </em>称为惯性权重，是保持粒子与上一代同向运动的力。<em class="ml"> c1 </em>和<em class="ml"> c2 </em>为常数加速度值，其中<em class="ml"> c1=c2 </em>由【1】应用于原算法。<em class="ml"> r1 </em>和<em class="ml"> r2 </em>表示超参数，它们会引起一些随机扰动。这些参数值的值越高，粒子的运动响应越快。我们还假设，在我们的情况下，适应度函数是针对最小化问题的。因此，当<em class="ml"> f(x_i) &lt; f(p_i) </em>时，单个粒子的最佳位置<em class="ml"> p_i </em>被<em class="ml"> x_i </em>覆盖。</p><p id="e5a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PSO算法如下:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="ba5a" class="mf mg iq mb b gy mh mi l mj mk">1. Initialise the particle population array x_i<br/>2. Loop<br/>3. For each particle, calculate the fitness using the <br/>   fitness function f(x_i)<br/>4. Compare the current fitness value with its best p_i. <br/>   Replace the best with the current value x_i <br/>   if it is better than the best.<br/>5. Check the swarm’s best particle from individual particle’s best <br/>   and assign the best array to the global best p_g.<br/>6. Calculate the velocity v_i(t+1) and update the position of <br/>   the particles to x_i(t+1)<br/>7. If a criterion is met, exit the loop.<br/>8. End loop</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="eba5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们把算法翻译成Python代码。为了可视化粒子的运动，我们可以将粒子的维度简化为两个，<em class="ml"> x </em>和<em class="ml"> y </em>。这些脚本是按程序编写的。</p><p id="4998" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。导入库</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="eaf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。定义适应度函数</strong></p><p id="68e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用的函数:<em class="ml">f(x,y)=(x-2y+3)^2+(2x+y-8)^2</em>。这个函数的全局最小值是0。所有粒子都应该从随机点向<em class="ml"> x </em>和<em class="ml"> y </em>坐标的最佳位置移动，在该位置值变得接近0。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8c42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3。更新速度</strong></p><p id="607e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将随机值应用于<em class="ml"> r1、r2 </em>和<em class="ml"> w </em>。<em class="ml"> c1 </em>和<em class="ml"> c2 </em>被赋予0.1的较小值。惯性值可以预定；从0.9开始，逐渐减少到0.4。在我们的例子中，我们生成最小值为0.5、最大值为1的正态分布，并按照[3]的实验，在每一代随机选择一个值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="db17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4。更新位置</strong></p><p id="f1fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如算法中所述，新位置是当前位置和速度的总和。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e71e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 5。PSO的主要功能</strong></p><p id="cee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们初始化粒子，它们的最佳位置，速度和适应值。我们还根据粒子的初始位置设置了全局最佳位置。然后我们从一代循环到另一代。当算法达到最大代数或成功标准时，它应该停止。在我们的例子中，它是当平均适应值超过特定值时。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="96f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 6。设置参数值并运行算法</strong></p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="2c1f" class="mf mg iq mb b gy mh mi l mj mk">population = 100<br/>dimension = 2<br/>position_min = -100.0<br/>position_max = 100.0<br/>generation = 400<br/>fitness_criterion = 10e-4</span></pre><p id="aaa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了100个粒子，它们的位置被随机放置在x和y坐标上，范围在-100到100之间。当函数取x和y时，粒子的位置是二维的。成功标准为0.001或更低。如果达到标准，该计划应在第400代之前停止。</p><p id="ba6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用上述配置运行算法，我们获得了以下结果:</p><pre class="kg kh ki kj gt ma mb mc md aw me bi"><span id="d035" class="mf mg iq mb b gy mh mi l mj mk">Global Best Position:  [2.60008033 2.799968  ]<br/>Best Fitness Value:  3.7383573411040855e-08<br/>Average Particle Best Fitness Value:  0.0009671024787191154<br/>Number of Generations:  68</span></pre><p id="d67e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于其随机性，每次运行程序时，结果都会发生变化。花了68代才达到成功标准。最佳粒子到达位置<em class="ml"> x≈2.6 </em>和<em class="ml"> y≈2.8，</em>，在这里适应度函数返回全局最小值。</p><p id="445d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们能够可视化粒子的运动，而不是把结果写在文本中，那将会更有洞察力。</p><p id="a0aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 7。Matplotlib绘图和动画</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="471a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">绘制函数的线框有助于了解全局最小值在哪里。应该为每一代人捕捉图像。下面是同一个示例的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/d7f4cae0a4fce0ec550222c3c6d589b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6oYjCLWxYTncDMbSfFcmTw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">动画粒子在几代人之间的运动。作者照片。</p></figure><p id="11d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一代中，粒子是分散的。他们迅速向网格的底部移动，看起来算法像预期的那样工作。我们可以通过改变适应度函数和超参数(如惯性权重<em class="ml"> w </em>以及认知和社会系数(<em class="ml"> c1 </em>和<em class="ml"> c2 </em>)来进行更多的实验，以优化算法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="4ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像PSO这样的群体智能是一类元启发式算法，被认为可以在合理的计算时间内找到复杂优化问题的近优解。如果我们应用该算法来训练神经网络，这是特别有用的。好处是双重的:全局搜索和并行化。</p><p id="137e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将每个粒子转化为一个n维数组，表示神经元之间的权重。正如我们在动画gif中看到的，每个粒子都向不同的方向运动。与局部搜索最优点的反向传播学习算法不同，PSO可以同时探索许多不同的权重参数集，从而有助于避免到达局部最小值的路径。此外，适应度函数独立于网络拓扑；评估每个粒子适应度的计算可以并行化。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="f3e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文探讨了粒子群优化算法，用简单的代码来理解其中的机制。如果你对PSO在ML中的应用感兴趣，我强烈推荐阅读下面这篇关于将机器学习集成到各种元启发式算法中的文章。</p><div class="mp mq gp gr mr ms"><a href="https://www.sciencedirect.com/science/article/pii/S0377221721003623" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">为解决组合优化问题的元启发式服务的机器学习…</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">机器学习与元启发式集成综述。*一个统一的分类法来提供…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.sciencedirect.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><p id="a4ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参考:</strong></p><p id="ecfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] J. Kennedy和R. Eberhart，“粒子群优化”，ICNN 95-神经网络国际会议论文集。<br/> [2]里坡，r .，肯尼迪，J. &amp;布莱克威尔，t .粒子群优化。群体智力1，33–57(2007)。<a class="ae kv" href="https://doi.org/10.1007/s11721-007-0002-0" rel="noopener ugc nofollow" target="_blank"/><br/>【3】r . Eber hart和史，“粒子群优化:发展、应用和资源”，2001年进化计算大会(IEEE Cat .№01ts 8546)，2002年8月。</p></div></div>    
</body>
</html>