<html>
<head>
<title>Building Deep Learning Pipelines with Tensorflow Extended</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Tensorflow扩展构建深度学习管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-deep-learning-pipelines-with-tensorflow-extended-913869f1f051#2022-06-29">https://towardsdatascience.com/building-deep-learning-pipelines-with-tensorflow-extended-913869f1f051#2022-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6e0b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你会看到像大公司一样建立深度学习管道是多么容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/e57a08a61269ee7297c64654a3f14f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*j8JAzg3y3DWW41MOukIoPA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://www.tensorflow.org/tfx/guide" rel="noopener ugc nofollow" target="_blank">来源</a>。2022年6月27日<a class="ae kr" href="https://github.com/tensorflow/tensorflow/blob/master/LICENSE" rel="noopener ugc nofollow" target="_blank">获得Apache 2.0 </a>许可</p></figure><h1 id="20d5" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">目标</h1><p id="a62d" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">在本教程中，我的目标是:</p><ul class=""><li id="f752" class="mg mh iq lm b ln mi lq mj lt mk lx ml mb mm mf mn mo mp mq bi translated">解释机器学习管道在生产中的作用</li><li id="50da" class="mg mh iq lm b ln mr lq ms lt mt lx mu mb mv mf mn mo mp mq bi translated">展示如何开始使用Tensorflow本地扩展</li><li id="2d9d" class="mg mh iq lm b ln mr lq ms lt mt lx mu mb mv mf mn mo mp mq bi translated">展示如何将Tensorflow扩展管道从本地环境移动到顶点AI</li><li id="e405" class="mg mh iq lm b ln mr lq ms lt mt lx mu mb mv mf mn mo mp mq bi translated">给你一些代码示例来适应和开始使用TFx。</li></ul><p id="7c1a" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">你可以点击查看本教程<a class="ae kr" href="https://github.com/piEsposito/tfx-tutorial-medium/settings" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><h1 id="5111" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">介绍</h1><p id="3bcf" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">一旦你完成了你的模型实验，是时候把东西投入生产了。将机器学习投入生产不仅仅是用REST API包装模型二进制文件并开始为其服务的问题，而是让重新创建(或更新)和重新部署您的模型成为可能。</p><p id="29ce" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">这意味着从预处理数据到训练模型以将其投入生产的步骤(我们称之为机器学习管道)应该被部署，并能够尽可能容易地运行，同时使跟踪它和参数化它成为可能(例如，使用不同的数据)。</p><p id="25ab" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在这篇文章中，我们将看到如何使用Tensorflow Extended (TFx)为深度学习模型建立机器学习管道，如何运行并部署到Google Vertex AI以及我们为什么要使用它。</p><p id="5576" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们将从TFx及其组件、实现和最小工作管道的概述开始，然后展示如何在Jupyter实验室(在Google Colab上)和Vertex AI管道上运行它。这里使用的代码改编自汉尼斯·哈普克的“<a class="ae kr" href="https://github.com/Building-ML-Pipelines/building-machine-learning-pipelines" rel="noopener ugc nofollow" target="_blank">构建机器学习管道</a>”。</p><h1 id="637a" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">TFx</h1><p id="4968" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">TFx是TensorFlow的生产框架。TFx不仅让用户以高性能的方式服务模型，还包装了Tensorflow生态系统的所有部分(从Keras到数据验证到服务)，让用户构建和运行可扩展的高性能机器学习管道。</p><p id="8429" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">它被组织成一系列组件，要求您编写更少的代码，但也很灵活。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/31ce30c0ff79f76f29846f2896e771c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-xv7DS_j0jQpxpfB"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://www.tensorflow.org/tfx/guide" rel="noopener ugc nofollow" target="_blank">来源</a>。在Apache 2.0 下获得许可的(2022–06–27)<a class="ae kr" href="https://github.com/tensorflow/tensorflow/blob/master/LICENSE" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="91a7" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">管道被编译成一系列蓝图，适用于不同的基础设施。你可以在本地或Vertex AI上运行它们。你可以在Apache Beam甚至Google Dataflow上运行一些昂贵的数据处理步骤。TFx不会锁定您的供应商，而是会适应您的资源和基础架构。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/d2e1716e07966c05711574839ca64b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*utyi2tKYEdo8sP4B"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://www.tensorflow.org/tfx/guide" rel="noopener ugc nofollow" target="_blank">来源</a>。根据Apache 2.0 获得许可</p></figure><p id="dc2f" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在这篇文章中，我们将为我们的管道使用以下组件:</p><h2 id="aa78" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">示例Gen</h2><p id="99c6" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">TFx管道的入口点是<code class="fe nr ns nt nu b">ExampleGen</code>组件。给定一个本地(或类似云存储的)路径，它根据输入规范收集<code class="fe nr ns nt nu b">.tfrecords</code>格式的文件。</p><p id="cff0" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们将使用一个较小的数据集，因此一个<code class="fe nr ns nt nu b">.csv</code>文件将是一个更好的选择。我们将使用一个指向本地csv文件的<code class="fe nr ns nt nu b">CsvExampleGen</code>文件。当我们转移到Vertex AI时，这个文件将被上传到一个谷歌云存储桶中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/973e5fe0f35d107e33764e36bc7cf279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/0*Uzzu-5BuJKrRLvCR"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由我生成</p></figure><h2 id="917f" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">改变</h2><p id="0d89" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">并不总是需要<code class="fe nr ns nt nu b">Transform</code>组件，但是当需要进行昂贵的预处理时，它很有用。为此，我们在<code class="fe nr ns nt nu b">module file</code>上创建了一个名为<code class="fe nr ns nt nu b">preprocessing_fn</code>的纯张量流函数。TFx将把这个转换应用到由<code class="fe nr ns nt nu b">ExampleGen</code>组件输入的所有数据点。</p><p id="2e39" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">这个函数需要是纯的(意味着没有副作用)，并且只使用Tensorflow操作，因为(I)这个预处理步骤可以序列化为TF图，并烘焙到最终的模型，以及(ii)这个步骤可以在Apache Beam上运行，这意味着它将被大规模并行化(对于非常大的数据集很好)。</p><p id="8d7b" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated"><code class="fe nr ns nt nu b">preprocessing_fn</code>接收一个<code class="fe nr ns nt nu b">tf.Example</code>对象(可以把它想象成一个奇特的字典)并应该返回一个<code class="fe nr ns nt nu b">dictionary</code>，它将被序列化为一个<code class="fe nr ns nt nu b">tf.Example</code>以输入到模型中。在这一步，只要你只使用TF函数，你可以做任何你想做的事情。</p><p id="24c8" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在构建管道时，我们将看到一个<code class="fe nr ns nt nu b">preprocessing_fn</code>及其参数的例子。</p><p id="2c37" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们指向这个模块文件来构建组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/929b49570aeaea546e0d7c65962c2c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*2J1J52YrzdX-4CE6"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由我生成</p></figure><h2 id="3030" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">运动鞋</h2><p id="e675" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">这里是<code class="fe nr ns nt nu b">model.fit</code>步骤发生的地方。与<code class="fe nr ns nt nu b">Transform</code>步骤相同，我们指向上面有<code class="fe nr ns nt nu b">run_fn</code>的<code class="fe nr ns nt nu b">module file</code>。<code class="fe nr ns nt nu b">run_fn</code>函数接收一系列<code class="fe nr ns nt nu b"><a class="ae kr" href="https://github.com/tensorflow/tfx/blob/9743f3dcb84b933f0eb672c46200b3485e2c9794/tfx/components/trainer/fn_args_utils.py#L61" rel="noopener ugc nofollow" target="_blank">fn_args</a></code>，这些将在构建管道时进行探索。</p><p id="886f" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated"><code class="fe nr ns nt nu b">run_fn</code>从<code class="fe nr ns nt nu b">Transform</code>接收实际的预处理实例。它将它提供给训练步骤中的模型，然后返回模型。返回的模型将被进一步验证，然后被推送到部署上下文。</p><p id="1aca" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">经过训练的组件可以在不同的基础设施上运行。您可以使用本地资源在本地运行它，或者设置基础设施必需品(如GPU和CPU)并在Vertex AI上作为托管容器运行它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/159468f486f4ac2e40deb20dcb8fbc49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*oy_GTl4lCPfK0W4B"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由我生成</p></figure><h2 id="0a56" class="nf kt iq bd ku ng nh dn ky ni nj dp lc lt nk nl le lx nm nn lg mb no np li nq bi translated">推进器</h2><p id="be73" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated"><code class="fe nr ns nt nu b">Pusher</code>是TFx管道的最后一个组件。它的目的是，给定从<code class="fe nr ns nt nu b">Trainer</code>得到的模型，将它推送到一个云存储桶，从那里它将被服务(或者由一个TF服务实例监听桶，或者由一个使用TF Lite的web/移动应用程序)。</p><p id="fbca" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在推送之前，可以在模型之上进行几个验证，例如评估它在测试集上的度量，甚至检查它是否实际运行在TF服务容器上。我们将保持简单，如果人们喜欢这个，我们将发布一个更复杂的管道。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/acf625c27895887bb899dda71babb117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/0*6K2MRW8TEKgdSZTT"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由我生成</p></figure><p id="ea49" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">有了这些组件，我们就可以开始实现管道，看看它实际上是如何工作的。</p><h1 id="876c" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">在Jupyter笔记本上实现管道</h1><p id="81c5" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我们将开始在Jupyter笔记本上实现，你可以在Colab <a class="ae kr" href="https://colab.research.google.com/github/piEsposito/tfx-tutorial-medium/blob/main/local/run_tfx_pipeline.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>打开它。我们将以交互方式运行它，并检查事情是如何运行的。之后，我们将构建相同的管道，但将其部署在Vertex AI管道上。</p><p id="463e" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">运行设置单元后，我们必须导入<code class="fe nr ns nt nu b">tfx</code>及其<code class="fe nr ns nt nu b">InteractiveContext</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="da1e" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们的数据将放在相对的<code class="fe nr ns nt nu b">data_local</code>目录中，所以我们只需要从中创建一个<code class="fe nr ns nt nu b">CsvExampleGen</code>。请注意，我们使用交互式上下文运行组件，然后将能够提交它们的输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3c33" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在开始处理数据集之前，获取数据集的统计数据和模式是一个很好的做法。将来，这不仅可以用于验证模式数据，还可以用于验证漂移数据。我们用<code class="fe nr ns nt nu b">SchemaGen </code>和<code class="fe nr ns nt nu b">StatisticsGen </code>来表示它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b9ab" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们现在将使用当前目录下的<code class="fe nr ns nt nu b">module.py</code>文件中的预处理函数对数据进行预处理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="3862" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们只输入缺失值和一次性编码的分类特征。这很简单，因为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7ca3" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">然后我们继续训练我们的模型。注意，我们使用transform组件的结果，并设置eval和training参数。因为我们使用这些组件来说明TFx管道的创建，所以我们不会对它们进行很长时间的培训:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="883b" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在我们的模块文件中，我们从转换组件中获取数据。我们在内部可以访问在转换组件之后生成的<code class="fe nr ns nt nu b">fn_args.train_files</code>和<code class="fe nr ns nt nu b">fn_args.eval_files</code>，因为我们将<code class="fe nr ns nt nu b">examples</code>作为关键字参数传递给了训练组件，所以它们在内部是可用的。</p><p id="f1a8" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">训练后，我们还可以访问预处理操作的张量流图，这将有助于将模型投入生产，而不必手动处理。我们还确保在生产中使用与训练和评估模型时所用数据相同的预处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d9e8" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在训练之后，我们只需要将我们的模型保存到它将要被保存的地方。在本教程中，我们将它保存在本地，但应该明确的是，我们可以将模型推送到云存储桶，在那里它将被生产环境访问(例如，桶上的TF服务容器监听)。</p><h1 id="9173" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">在Vertex AI上部署它</h1><p id="3903" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">TFx很棒，因为你可以使用相同的组件，并在云上运行它们。在某些情况下(如训练和转换数据)，可以将它设置为在处理大数据的特定基础设施上运行(作为数据流，您可以大规模并行化转换步骤)。</p><p id="ba1d" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">您还可以指定训练步骤所需的资源，Vertex AI将使用所述资源在VM上训练容器。我们现在将看看如何以最简单的方式做到这一点。</p><p id="de7f" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">要做到这一点，让我们打开笔记本的顶点人工智能部分<a class="ae kr" href="https://colab.research.google.com/github/piEsposito/tfx-tutorial-medium/blob/main/vertex_ai/run_tfx_pipeline.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="cdfe" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">我们的火车代码有相同的<code class="fe nr ns nt nu b">module.py</code>,还有一个<code class="fe nr ns nt nu b">base_pipeline.py</code>,它像我们在本地运行中所做的那样连接组件，但是没有交互上下文:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a703" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">这里的变化是，我们将运行这个管道，而不是使用<code class="fe nr ns nt nu b">InteractiveContext</code>来运行它，我们将创建一个<code class="fe nr ns nt nu b">.json</code>蓝图，然后在Vertex AI上运行它。</p><p id="c3ac" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">神奇的是:使用相同的管道，我们将构建json蓝图在<code class="fe nr ns nt nu b">Kubeflow</code>中运行它，然后使用Vertex AI管道(一个奇特的Kubeflow管道引擎)来实际运行它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="a14c" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">在运行它之前，转到<code class="fe nr ns nt nu b">pipeline_vertex.py</code>，将第29行改为您的项目名称，将第19行和第20行改为您创建的bucket。然后将本地数据上传到<code class="fe nr ns nt nu b">YOUR_BUCKET/data</code>和<code class="fe nr ns nt nu b">module.py</code>到<code class="fe nr ns nt nu b">YOUR_BUCKET/components</code>。</p><p id="9713" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">您还应该为此设置一个服务帐户。</p><p id="3e9d" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">然后运行笔记本上的所有单元并打开Vertex AI管道，您应该会看到类似的东西:(以及您创建的桶上的模型二进制文件)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/7ce0c0fa1c6c6d3453b961484d22c787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/0*pgc0XWTROQl2uh_3"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">由我在顶点人工智能管道上生成</p></figure><h1 id="46e3" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">结论</h1><p id="160f" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我们可以在TFx上使用相同的代码库，并在本地运行train作业(调试和处理小东西),并且在需要时，将它移动到Vertex AI，只需稍作修改。这样，我们就可以处理大型数据集和模型，并以一种可行的方式训练。</p><p id="82fe" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">很高兴看到TFx如何将Tensorflow生态系统的所有功能整合到一个适合生产的框架中。</p><p id="b7dc" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">本教程旨在简单明了地展示使用TFx是多么容易，同时给出一些代码示例供您入门。这里使用的大部分代码都是改编自汉尼斯·哈普克的机器学习管道，或者至少是受其启发，其中的Github库是在麻省理工学院许可下发布的。</p><p id="1e52" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">如果你发现任何错误，有疑问，想进一步讨论这个话题或者只是想交个朋友，请随时到piero.skywalker@gmail.com找我。</p><p id="41f9" class="pw-post-body-paragraph lk ll iq lm b ln mi jr lp lq mj ju ls lt mw lv lw lx mx lz ma mb my md me mf ij bi translated">谢谢！</p><h1 id="dbb9" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">参考</h1><div class="oc od gp gr oe of"><a href="https://github.com/Building-ML-Pipelines/building-machine-learning-pipelines" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">GitHub-Building-ML-Pipelines/Building-machine-learning-Pipelines:的代码库</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">奥莱利出版物《构建机器学习管道》的代码库，作者汉尼斯·哈普克和凯瑟琳·尼尔森…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kl of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://www.buildingmlpipelines.com/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">构建ML管道</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">公司在机器学习项目上投入了数十亿美元，但如果模型不能部署，那就是浪费金钱…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">www.buildingmlpipelines.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kl of"/></div></div></a></div></div></div>    
</body>
</html>