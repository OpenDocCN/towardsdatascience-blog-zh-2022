<html>
<head>
<title>Analyzing the Glass Dataset—Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析玻璃数据集—第1部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/part-i-analyzing-the-glass-dataset-c556788a496f#2022-02-11">https://towardsdatascience.com/part-i-analyzing-the-glass-dataset-c556788a496f#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="33c8" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">使用Julia及其生态系统的机器学习</h2><div class=""/><div class=""><h2 id="67b9" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">Julia很快，可以像解释语言一样使用，具有高度的可组合性，但不是面向对象的。它有一个快速增长的生态系统，可以帮助典型的ML工作流程的所有方面。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/62d4dc4854c04b2e00cdb3ae2439da42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i7jNN0FuoWLaT3lvSu0BtA.jpeg"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">罗宾·范·德·普洛格在Unsplash上拍摄的照片</p></figure><h1 id="f016" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">教程概述</h1><p id="9a64" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">这是教程的第一部分，展示了Julia的特定语言特性和它的生态系统中的各种高质量的包是如何在一个典型的ML工作流中方便地结合使用的。</p><ul class=""><li id="1604" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">第一部分"<em class="ne">分析玻璃数据集"</em>集中于如何使用<code class="fe nf ng nh ni b">ScientificTypes</code>、<code class="fe nf ng nh ni b">DataFrames</code>、<code class="fe nf ng nh ni b">StatsBase</code>和<code class="fe nf ng nh ni b">StatsPlots</code>等软件包对数据进行预处理、分析和可视化。</li><li id="f380" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">第二部分"<em class="ne">使用决策树"</em>关注ML工作流的核心:如何选择模型，以及如何使用它进行训练、预测和评估。这部分主要靠包<code class="fe nf ng nh ni b">MLJ</code>(=<strong class="lz ja">M</strong>achine<strong class="lz ja">L</strong>in<strong class="lz ja">J</strong>ulia<em class="ne">)</em>收入。</li><li id="8f86" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">第三部分“<em class="ne">如果事情还没有‘准备好使用’</em>”解释了如果可用的包没有提供您需要的所有功能，那么用几行代码创建您自己的解决方案是多么容易。</li></ul><h1 id="f81c" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">介绍</h1><p id="3bea" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">每一个ML工作流都从分析和预处理用于训练模型的数据开始。这些最初的步骤包括理解数据来自的应用领域内的数据、检查数据质量和识别其统计属性(使用可视化和统计测量)。</p><p id="a398" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">在本教程中，我们将使用“玻璃”数据集。这是一个用于教育目的的数据集。它带有<a class="ae le" href="https://www.cs.waikato.ac.nz/ml/weka/index.html" rel="noopener ugc nofollow" target="_blank"> Weka </a>工具包，可以从不同的网站下载(例如<a class="ae le" href="https://storm.cis.fordham.edu/~gweiss/data-mining/datasets.html" rel="noopener ugc nofollow" target="_blank">这里</a>)。该数据集的特征包含关于不同玻璃变体的信息(如用于其生产的材料和光学特征)，目标变量是产生的玻璃变体(见下文摘录)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">“玻璃”数据集中的几行</p></figure><p id="bd06" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">数据以一种叫做<a class="ae le" href="https://waikato.github.io/weka-wiki/formats_and_processing/arff_stable/" rel="noopener ugc nofollow" target="_blank"> ARFF(属性-关系文件格式)</a>的文件格式出现；Weka工具包使用的一种格式。因此，我们需要一个Julia包，它具有读取这种格式的功能:<code class="fe nf ng nh ni b">ARFFFiles.jl</code>。因为我们想将数据转换成一个<code class="fe nf ng nh ni b">DataFrame</code>以供进一步使用，所以也需要包<code class="fe nf ng nh ni b">DataFrames.jl</code>。<code class="fe nf ng nh ni b">ScientificTypes.jl</code>用特定于ML的特性扩充了标准的Julia类型，最后但同样重要的是，我们需要<code class="fe nf ng nh ni b">Downloads.jl</code>包来实现从网站下载数据的功能。</p><p id="02cd" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">因此，使用这些包、从上述网站下载数据、从磁盘读取数据并将其转换为<code class="fe nf ng nh ni b">DataFrame</code>(并使用<code class="fe nf ng nh ni b">ScientificTypes</code>)的代码如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">加载“玻璃”数据集并创建“数据框架”</p></figure><h1 id="03f0" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">数据集的第一个概述</h1><p id="3f65" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">为了对数据集有一个初步的了解，我们从中获取一些基本信息:</p><ul class=""><li id="81b8" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated"><code class="fe nf ng nh ni b">sz = size(glass)</code>给出了尺寸:<code class="fe nf ng nh ni b">(214, 10)</code>，即它有214行10列。</li><li id="0466" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">通过<code class="fe nf ng nh ni b">col_names = names(glass)</code>，我们得到了<code class="fe nf ng nh ni b">DataFrame</code>的列名:</li></ul><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="57db" class="nx lg iq ni b gy ny nz l oa ob">10-element Vector{String}: <br/>“RI”, “Na”, “Mg”, “Al”, “Si”, “K”, “Ca”, “Ba”, “Fe”, “Type”</span></pre><ul class=""><li id="3051" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">而<code class="fe nf ng nh ni b">schema(glass)</code>(来自<code class="fe nf ng nh ni b">ScientificTypes</code>)给出了所有列的数据类型。<code class="fe nf ng nh ni b">types</code>是Julia数据类型，而<code class="fe nf ng nh ni b">scitypes</code>是由<code class="fe nf ng nh ni b">ScientificTypes</code>引入的抽象层次。这里我们可以看到所有的特征都是<code class="fe nf ng nh ni b">Continuous</code>，目标变量是一个标称值(有七个不同的条目)。</li></ul><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="8ac4" class="nx lg iq ni b gy ny nz l oa ob">schema(glass) --&gt;<br/>┌───────┬───────────────┬──────────────────────────────────┐<br/>│ names │ scitypes      │ types                            │<br/>├───────┼───────────────┼──────────────────────────────────┤<br/>│ RI    │ Continuous    │ Float64                          │<br/>│ Na    │ Continuous    │ Float64                          │<br/>│ Mg    │ Continuous    │ Float64                          │<br/>│ Al    │ Continuous    │ Float64                          │<br/>│ Si    │ Continuous    │ Float64                          │<br/>│ K     │ Continuous    │ Float64                          │<br/>│ Ca    │ Continuous    │ Float64                          │<br/>│ Ba    │ Continuous    │ Float64                          │<br/>│ Fe    │ Continuous    │ Float64                          │<br/>│ Type  │ Multiclass{7} │ CategoricalValue{String, UInt32} │<br/>└───────┴───────────────┴──────────────────────────────────┘</span></pre><h1 id="38de" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">目标变量</h1><p id="d752" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">现在让我们仔细看看目标变量的特征。<code class="fe nf ng nh ni b">glass_types = unique(glass.Type)</code>给出了来自<code class="fe nf ng nh ni b">Type</code>列的唯一值列表:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="63bb" class="nx lg iq ni b gy ny nz l oa ob">6-element Vector{String}:<br/> “build wind float”<br/> “vehic wind float”<br/> “tableware”<br/> “build wind non-float”<br/> “headlamps”<br/> “containers”</span></pre><p id="5fad" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">因此，我们假设数据集中有6种不同的玻璃类型。但这只是事实的一部分。使用<code class="fe nf ng nh ni b">ScientificTypes</code>中的<code class="fe nf ng nh ni b">levels(glass.Type)</code>显示实际上有7种不同的玻璃类型:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="b0d6" class="nx lg iq ni b gy ny nz l oa ob">7-element Vector{String}:<br/> “build wind float”<br/> “build wind non-float”<br/> “vehic wind float”<br/> “vehic wind non-float”<br/> “containers”<br/> “tableware”<br/> “headlamps”</span></pre><p id="9c34" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">其中只有6个出现在玻璃数据集中(计数&gt; 0)。类型<em class="ne">‘车辆风非浮动’</em>不出现。关于它的存在的知识被储存在ARFF档案中，并被<code class="fe nf ng nh ni b">ScientificTypes</code>建立的类型系统保留下来。在这个例子中，我们可以看到使用这种类型系统的附加价值，而不是仅仅依赖语言的本机类型系统(在这个例子中，这可能会欺骗我们)。</p><p id="b5df" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">在下一步中，对<code class="fe nf ng nh ni b">countmap</code>(来自<code class="fe nf ng nh ni b">StatsBase</code>)的调用告诉我们，这些类型在目标变量中出现的频率。因此，我们对它们的分布有了一些了解:用于建筑物窗户的玻璃变体是最常见的类型，其次是用于前照灯的玻璃类型:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="f738" class="nx lg iq ni b gy ny nz l oa ob">type_count = countmap(glass.Type) --&gt;</span><span id="cdf7" class="nx lg iq ni b gy oc nz l oa ob">Dict{CategoricalArrays.CategoricalValue{String, UInt32}, Int64} with 6 entries:<br/> “vehic wind float” =&gt; 17<br/> “tableware” =&gt; 9<br/> “build wind non-float” =&gt; 76<br/> “build wind float” =&gt; 70<br/> “headlamps” =&gt; 29<br/> “containers” =&gt; 13</span></pre><p id="0cf9" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">一个图表当然比一系列数字更能提供信息。因此，让我们使用<code class="fe nf ng nh ni b">Plots</code>包中的条形图来可视化它:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="184f" class="nx lg iq ni b gy ny nz l oa ob">bar(type_count, group = glass_types, legend = false,<br/> xlabel = “glass types”, xrotation = 20,<br/> ylabel = “count”)</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi od"><img src="../Images/6861997d563029de1b5ef7aa8e3c7104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pz4E0g9SVnv2Q0FXnIWCA.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">不同玻璃类型的出现频率[图片由作者提供]</p></figure><p id="504d" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">这里我们也注意到，来自<code class="fe nf ng nh ni b">ScientifcTypes</code> <em class="ne"> </em>的额外信息已经被使用，因此显示<em class="ne">“车辆风非浮动”</em>的计数为零。</p><h1 id="6ff0" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">详细的功能</h1><p id="c464" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">现在来看特征变量:第一个特征<em class="ne"> RI </em>是所谓的<a class="ae le" href="https://en.wikipedia.org/wiki/Refractive_index" rel="noopener ugc nofollow" target="_blank">折射率</a>，这是一种光学特性，它告诉我们光穿过材料的速度。其他特征给出了不同元素的百分比，如钠(=拉丁文<strong class="lz ja"> Na </strong> trium)、镁(<strong class="lz ja"> Mg </strong>或<strong class="lz ja">Al</strong>umi um)，这些元素被用于生产玻璃。</p><h2 id="9bc2" class="nx lg iq bd lh oe of dn ll og oh dp lp mg oi oj lr mk ok ol lt mo om on lv iw bi translated">价值观是否合理？</h2><p id="f437" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">我们先从技术角度检查一下这些特性的值是否合理。从<code class="fe nf ng nh ni b">DataFrames</code>到<code class="fe nf ng nh ni b">describe</code>的调用给了我们一个关于数据集中值的范围的印象:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oo"><img src="../Images/520a2f2f51cc6355c14308a04784a064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qLuhKQEWhpJuk2gnGcdLUw.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">通过“描述(玻璃)”获得的统计特征</p></figure><ul class=""><li id="b104" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated"><em class="ne"> RI </em>在1.5左右略有变化。从上面提到的维基百科页面，我们了解到不同种类玻璃的典型RI值在1.49 … 1.69之间。因此,“glass”数据集中的<em class="ne"> RI </em>值似乎相当合理。</li><li id="63e3" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">其他特征是百分比。也就是说，它们必须在0 … 100的范围内，这适用于我们的数据。</li><li id="f6b9" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">硅是玻璃中最重要的成分(这里&gt; 70%)，其次是钠和钙。</li></ul><p id="5702" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">我们可以对百分比再做一次质量检查。每种玻璃成分的总和应为100%。我们使用来自<code class="fe nf ng nh ni b">DataFrames</code>的<code class="fe nf ng nh ni b">transform</code>函数，并在每一行中添加特性<em class="ne"> Na </em> … <em class="ne"> Fe </em>的所有值。结果存储在一个名为<code class="fe nf ng nh ni b">sumpct</code>的新列中:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="d9f4" class="nx lg iq ni b gy ny nz l oa ob">glass_wsum = transform(glass, <br/>                  Between(:Na, :Fe) =&gt; ByRow(+) =&gt; :sumpct)</span></pre><p id="79c5" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">查看这一新列并使用<code class="fe nf ng nh ni b">StatsBase</code>中的<code class="fe nf ng nh ni b">maximum</code>和<code class="fe nf ng nh ni b">minimum</code>函数，可以发现大多数行的总和并不完全是100%,但是它们在该值附近有很小的变化。这可以用测量和舍入误差来解释。所以对我们来说没问题。</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="7bf7" class="nx lg iq ni b gy ny nz l oa ob">maximum(glass_wsum.sumpct), minimum(glass_wsum.sumpct) ---&gt;</span><span id="5333" class="nx lg iq ni b gy oc nz l oa ob">(100.09999999999998, 99.02)</span></pre><h2 id="0edb" class="nx lg iq bd lh oe of dn ll og oh dp lp mg oi oj lr mk ok ol lt mo om on lv iw bi translated">统计和可视化</h2><p id="61e9" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">由于所有特征属性都是<code class="fe nf ng nh ni b">Continuous</code>类型，因此可以计算一些统计数据，并绘制它们的分布图，以获得更多的洞察力。</p><p id="2f5f" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><strong class="lz ja">峰度&amp;偏斜度</strong></p><p id="01fd" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">为了初步了解实值变量的分布，计算两个度量值<a class="ae le" href="https://en.wikipedia.org/wiki/Kurtosis" rel="noopener ugc nofollow" target="_blank"><em class="ne"/></a>和<a class="ae le" href="https://en.wikipedia.org/wiki/Skewness" rel="noopener ugc nofollow" target="_blank"> <em class="ne">偏斜度</em> </a>。</p><ul class=""><li id="4494" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">偏斜度是对分布的对称性(或者说不对称性)的一种度量。负值表示它的左尾巴更长(相当平)，质量集中在右边。我们称之为<em class="ne">左偏</em>或左尾分布。另一方面，正值表示<em class="ne">右偏</em>分布。</li><li id="21a9" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">峰度是对分布“尾部”的一种度量。它显示了尾巴向左或向右伸出的距离。正态分布的峰度为3。因此，通常将其他分布的峰度与该值进行比较，并计算出所谓的<em class="ne">过度峰度</em>。它表示所考虑的分布的峰度超过正态分布的峰度多少。这也是我们从<code class="fe nf ng nh ni b">StatsBase</code>包的<code class="fe nf ng nh ni b">kurtosis</code>函数中得到的值。</li></ul><p id="8ad4" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">以下表达式为“glass”数据集的所有要素创建了这些测量值的列表:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="2e8f" class="nx lg iq ni b gy ny nz l oa ob">[(atr, skewness(glass[:, atr]), kurtosis(glass[:, atr])) <br/>    for atr in col_names[1:end-1]]</span></pre><p id="4d7b" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">像这样的表达在Julia中被称为“理解”。这是一个数组，它的初始值是通过迭代计算的。<code class="fe nf ng nh ni b">for atr in col_names[1:end-1]</code>遍历<code class="fe nf ng nh ni b">glass</code>的列名(从第一个到倒数第二个)。对于每个列名(<code class="fe nf ng nh ni b">atr</code>)，它创建一个包含三个元素的元组:列名<code class="fe nf ng nh ni b">atr</code>本身以及该列的偏度(<code class="fe nf ng nh ni b">skewness(glass[:, atr])</code>)和峰度(<code class="fe nf ng nh ni b">kurtosis(glass[:, atr])</code>)，从而创建以下输出:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="40c9" class="nx lg iq ni b gy ny nz l oa ob">9-element Vector{Tuple{String, Float64, Float64}}:<br/> (“RI”, 1.6140150456617635, 4.7893542254570605)<br/> (“Na”, 0.4509917200116131, 2.953476583500219)<br/> (“Mg”, -1.1444648495986702, -0.42870155798810883)<br/> (“Al”, 0.9009178781425262, 1.9848317746238253)<br/> (“Si”, -0.7253172664513224, 2.8711045971453464)<br/> (“K”, 6.505635834012889, 53.392326556204665)<br/> (“Ca”, 2.0326773755262484, 6.498967959876067)<br/> (“Ba”, 3.392430889440864, 12.222071204852575)<br/> (“Fe”, 1.7420067617989456, 2.5723175586721645)</span></pre><p id="b7f8" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">从这些图中我们已经可以看出，例如，<em class="ne"> K </em>和<em class="ne"> Ba </em>的分布是非对称和长尾的。但是在大多数情况下，如果我们将分布可视化，我们会得到更多的见解。</p><p id="6f89" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><strong class="lz ja">功能<em class="ne">RI</em>T18】</strong></p><p id="0f8c" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">先说特征<em class="ne"> RI </em>。violin plot可以使用<code class="fe nf ng nh ni b">StatsPlots</code>包中的<code class="fe nf ng nh ni b">violin</code>函数创建，它很好地展示了它的分布情况。<code class="fe nf ng nh ni b">violin(glass.RI, legend = false)</code>产生以下情节:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/538825c1388a4ef9717b7d20085103fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGcEwAr93Qpwfmjdgsabig.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">特征RI的分布[图片由作者提供]</p></figure><p id="98d1" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">直方图的条形根据目标值着色，还显示了特征值和最终玻璃类型之间的关系。为此，我们可以使用<code class="fe nf ng nh ni b">histogram</code>函数(同样来自<code class="fe nf ng nh ni b">StatsPlots</code>；参见图表下方的Julia代码):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/8e7ef0adebf051f117f84adc9db46096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-Zi1K38HpZzyslzcHQTeg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">RI值直方图，按玻璃类型分组[图片由作者提供]</p></figure><p id="7569" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><strong class="lz ja">特色<em class="ne">娜</em>……<em class="ne">菲</em> </strong></p><p id="247a" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">我们可以对剩下的特征<em class="ne"> Na </em> … <em class="ne"> Fe </em>做同样的处理。描绘分布的小提琴图的一个很好的替代方案是<em class="ne">箱线图</em>。有时小提琴图给人更多的洞察力，有时箱线图。所以我们最好两者都创造出来。如果我们并排绘制每个特征的所有三种图表类型，我们可以很容易地对它们进行比较，从而得到以下图表网格:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/251416cd73b0998a9ff6c7471cdb3162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvpYZHAXMjEoD_-qdzWwZg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">小提琴图、箱线图和直方图的特征Na…Fe[图片由作者提供]</p></figure><p id="79a3" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">用于生成该绘图网格的Julia代码如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a185" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">前三行具有相似的结构:每一行创建一个图表数组(首先是小提琴，然后是箱线图，最后是直方图)。同样，我们使用“理解”来达到这个目的:我们从2到9进行迭代，因为我们想要一个图来表示<code class="fe nf ng nh ni b">glass</code>数据帧的第2到9列。对于这些列中的每一列，我们用适当的参数创建各自的图表(与我们在上面对特征<em class="ne"> RI </em>所做的方式相同)(每个图表获得例如特征名称作为其<code class="fe nf ng nh ni b">xlabel</code>)。</p><p id="2d96" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><code class="fe nf ng nh ni b">plot</code>功能(绘制整个网格；第7行)将一个子情节数组作为其参数，并根据<code class="fe nf ng nh ni b">layout</code>参数将它们排列在一个网格中(这里是一个8 x 3的网格)。因此，我们必须应用以下步骤(第5行中的代码)创建一个适当的数组，该数组以正确的顺序包含子情节(即，对于每个素材，一个小提琴情节、一个箱线图和直方图):</p><ul class=""><li id="bbee" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated"><code class="fe nf ng nh ni b">hcat</code>将三个数组<code class="fe nf ng nh ni b">violins</code>、<code class="fe nf ng nh ni b">boxes</code>和<code class="fe nf ng nh ni b">histos</code>连接起来，从而创建一个8 x 3的绘图矩阵(每种类型的图表对应一列)</li><li id="eb0e" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">由于Julia矩阵是按列优先的顺序处理的，我们用<code class="fe nf ng nh ni b">permutedims</code>切换维度，创建一个3×8矩阵(因此<em class="ne"> Na </em>的三个图表在第一列，而<em class="ne"> Mg </em>的图表在第二列，依此类推)</li><li id="b536" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">最后，我们必须使用<code class="fe nf ng nh ni b">vec</code>将矩阵“展平”成一个数组(根据<code class="fe nf ng nh ni b">plot</code>的需要)。</li></ul><p id="a655" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><strong class="lz ja">相关性</strong></p><p id="5894" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">在处理数字属性时，知道它们是否相关以及相关程度如何总是很重要的，因为有些模型不太适合强相关的属性。</p><p id="7109" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">除此之外，两个属性之间的强相关性表明其中一个可能是多余的，因为它没有携带太多的附加信息。这些知识可用于减少特征的数量，从而使训练和评估模型的计算更加可行。</p><p id="10c7" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><em class="ne">相关矩阵</em></p><p id="52b6" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">函数<code class="fe nf ng nh ni b">cor</code>(来自<code class="fe nf ng nh ni b">StatsPlots)</code>)以矩阵的形式给出我们想要的信息，该矩阵具有每对特征的相关性(所谓的<em class="ne">相关性矩阵</em>):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/f06d7ddcff10b5dbc9717b92b87d1930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-Zpev2FagmXvOE4li7BTA.png"/></div></div></figure><p id="b9ed" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">像往常一样，可视化使数字更容易理解。在这种情况下，热图是合适的图表类型(我们使用来自<code class="fe nf ng nh ni b">StatsPlots</code>的<code class="fe nf ng nh ni b">heatmap </code>创建)。由于相关矩阵是对称的，可视化它的下半部分就足够了(可以使用<code class="fe nf ng nh ni b">LowerTriangular</code>从<code class="fe nf ng nh ni b">LinearAlgebra</code>包中提取；见图表下方的Julia代码)。用于热图的色标<code class="fe nf ng nh ni b">:tol_sunset</code>来自<code class="fe nf ng nh ni b">ColorSchemes</code>包。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/a565b5c5c0e0abc499eadc07c724ad5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o0irNWTBaZbekYVUSVf0eg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">相关矩阵热图[图片由作者提供]</p></figure><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="b94f" class="nx lg iq ni b gy ny nz l oa ob">heatmap(LowerTriangular(cor_mat), yflip = true,<br/> seriescolor = :tol_sunset,<br/> xticks = (1:9, col_names[1:9]),<br/> yticks = (1:9, col_names[1:9]))</span></pre><p id="af0c" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">从热图(和关联矩阵)中可以看出，不同玻璃属性之间最强的正关联是:</p><ul class=""><li id="e3f6" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">Ca/RI → 0.810403</li><li id="8200" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">钡铝比→ 0.479404</li><li id="7eea" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">钡/钠→ 0.326603</li><li id="85a6" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">钾/铝→ 0.325958</li></ul><p id="9be2" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">…当我们看数字时，只有前两个是真正“强”的。</p><p id="b406" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">可以观察到明显的负相关性:</p><ul class=""><li id="9051" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated">Si/RI = -0.542052</li><li id="604d" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">钡/镁= -0.492262</li><li id="4a33" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">铝/镁= -0.481798</li><li id="7e3b" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">钙/镁= -0.443750</li></ul><p id="5c40" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated"><em class="ne">相关图和角图</em></p><p id="fac5" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">下面的图更详细地展示了不同属性对之间的相关性:</p><ul class=""><li id="8d8f" class="mt mu iq lz b ma mv md mw mg mx mk my mo mz ms na nb nc nd bi translated"><em class="ne">关联图</em>在下半部分显示了散点图(每个散点图都有相应的SD线),在上半部分显示了热图。散点图以蓝色显示正相关，以红色显示负相关，以黄色显示中性相关。</li><li id="6bdb" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated"><em class="ne">角图</em>(此处为紧凑形式)显示了与图表下半部分的<em class="ne">相关图</em>相同的散点图。此外，它在顶部和右侧空白处显示每个属性的直方图。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/f9105eba8ed0f8833e3baa4b64885665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8782hb-inIY8LqpSgH3qg.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">“玻璃”特征的相关图[图片由作者提供]</p></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ot"><img src="../Images/902a199654dd73895dce00952488d94f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jK-wkEwPCexQZkis-py-YQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">“玻璃”特征的角图[图片由作者提供]</p></figure><p id="313b" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">这些图都是用一行Julia代码使用<code class="fe nf ng nh ni b">StatsPlots</code>中的函数创建的，如下所示:</p><pre class="kp kq kr ks gt nt ni nu nv aw nw bi"><span id="3b60" class="nx lg iq ni b gy ny nz l oa ob"><a class="ae le" href="http://twitter.com/df" rel="noopener ugc nofollow" target="_blank">@df</a> glass corrplot(cols(1:9))<br/><a class="ae le" href="http://twitter.com/df" rel="noopener ugc nofollow" target="_blank">@df</a> glass cornerplot(cols(1:9), compact = true)</span></pre><h1 id="aee9" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">结论</h1><p id="35e7" class="pw-post-body-paragraph lx ly iq lz b ma mb ka mc md me kd mf mg mh mi mj mk ml mm mn mo mp mq mr ms ij bi translated">上面的例子展示了如何仅仅使用几行代码来执行典型ML工作流的重要步骤。本教程的第二部分将继续这一旅程，重点关注训练、预测和评估等步骤。</p><p id="75ca" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">不同Julia包的功能如何容易地组合，以及它们如何很好地一起工作，变得很清楚，即使它们是独立开发的。本教程的第三部分将解释这种可组合性的内部工作原理。敬请关注！</p><p id="0ebe" class="pw-post-body-paragraph lx ly iq lz b ma mv ka mc md mw kd mf mg no mi mj mk np mm mn mo nq mq mr ms ij bi translated">当然，这些例子只能触及表面。有关更多信息，请参见下面给出的资源。</p><h1 id="220b" class="lf lg iq bd lh li lj lk ll lm ln lo lp kf lq kg lr ki ls kj lt kl lu km lv lw bi translated">进一步的信息</h1><ul class=""><li id="f0cd" class="mt mu iq lz b ma mb md me mg ou mk ov mo ow ms na nb nc nd bi translated">在<a class="ae le" href="https://www.youtube.com/user/PyDataTV" rel="noopener ugc nofollow" target="_blank">Julia for Data Analysis and Beyond</a>中，Stefan Karpinski(Julia的创建者之一)解释了Julia的主要优势及其设计背后的基本原理。为什么朱丽亚在<a class="ae le" href="https://youtu.be/x4oi0IKf52w" rel="noopener ugc nofollow" target="_blank">？—<em class="ne">Tim Holy对Julia </em> </a>中编程的特性和优势进行了高度描述，您将获得同一主题的更深入的论述。</li><li id="2c4b" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">Bogumil Kaminski教授在JuliaCon 2021上就数据帧进行了全面的<a class="ae le" href="https://www.youtube.com/watch?v=tJf24gfcSto" rel="noopener ugc nofollow" target="_blank">指导。他是这个包的主要作者。</a></li><li id="558b" class="mt mu iq lz b ma nj md nk mg nl mk nm mo nn ms na nb nc nd bi translated">Plots.jl包的文档和教程可以在<a class="ae le" href="https://docs.juliaplots.org/stable/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。有几个<a class="ae le" href="https://docs.juliaplots.org/stable/ecosystem/#ecosystem" rel="noopener ugc nofollow" target="_blank">附加包，比如StatsPlots.jl </a>。</li></ul></div></div>    
</body>
</html>