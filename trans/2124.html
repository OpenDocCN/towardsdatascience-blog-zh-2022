<html>
<head>
<title>3 Not-So-Common Pandas Tricks You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的3个不常见的熊猫把戏</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-not-so-common-pandas-tricks-you-should-know-b26cc7536291#2022-05-12">https://towardsdatascience.com/3-not-so-common-pandas-tricks-you-should-know-b26cc7536291#2022-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2456" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">充分利用熊猫</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5e7998c570b99b6b22ec64048c4c29c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-KVYoF1dI7RqBd_3y_pig.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@joshuachun?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·钟</a>在<a class="ae ky" href="https://unsplash.com/s/photos/style?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在读这篇文章，你一定听说过或用过熊猫。因此，我跳过了谈论大熊猫有多棒的部分。😊</p><p id="2649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过例子展示一些不常用的熊猫功能。在我三年的熊猫之旅中，我并没有经常遇到它们。</p><p id="b9fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习熊猫或者其他软件工具的最好方法是练习。这就是我们要做的。第一步是创建一个样本数据框架。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fc3b" class="ma mb it lw b gy mc md l me mf">import numpy as np<br/>import pandas as pd</span><span id="2cf4" class="ma mb it lw b gy mg md l me mf">df = pd.DataFrame({<br/>   <br/>   "date": pd.date_range(start="2021-11-20", periods=100, freq="D"),<br/>   "class": ["A","B","C","D"] * 25,<br/>   "amount": np.random.randint(10, 100, size=100)</span><span id="c265" class="ma mb it lw b gy mg md l me mf">})</span><span id="789e" class="ma mb it lw b gy mg md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/9df150c0ddc2786c1c8903bb28bc03f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gU9yrKuqHiQ3vW9bj79dSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df的前5行(图片由作者提供)</p></figure><p id="db54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个3列100行的数据帧。date列包含100个连续的日期，class列包含4个与object数据类型一起存储的不同值，amount列包含10到100之间的随机整数。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="825c" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">1.至_期间</h2><p id="722d" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们使用具有许多不同间隔或周期的日期，例如日、周、月、季度等等。使用哪一种取决于手头的任务。例如，在收入仪表板中，我们可能希望显示月收入或季度收入。</p><p id="7573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Pandas中，操作日期的函数在dt访问器下可用。to_period函数允许将日期转换为特定的时间间隔。我经常使用的周期是月和季度。</p><p id="9525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">month方法仅返回月份，这在许多情况下没有用，例如报告历史收入。我们需要能够区分2020年12月和2021年12月。这可以通过在to_period函数中使用“M”句点来实现。同样，我们可以用“Q”提取季度信息。</p><p id="0c39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为年-月和季度创建新的列。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="5ed9" class="ma mb it lw b gy mc md l me mf">df["month"] = df["date"].dt.to_period("M")<br/>df["quarter"] = df["date"].dt.to_period("Q")</span><span id="afa7" class="ma mb it lw b gy mg md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/27ea62bf6f52175ed4a28cf9405a5fbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-LmEOX1NnX5sV72HSeev4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df的前5行(图片由作者提供)</p></figure><p id="54f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也检查一下数据框架中不同的年-月和季度值。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="da08" class="ma mb it lw b gy mc md l me mf">df["month"].value_counts()</span><span id="2542" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>2021-12    31<br/>2022-01    31<br/>2022-02    27<br/>2021-11    11<br/>Freq: M, Name: month, dtype: int64</span><span id="4b15" class="ma mb it lw b gy mg md l me mf">--------------------------<br/>df["quarter"].value_counts()</span><span id="e84b" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>2022Q1    58<br/>2021Q4    42<br/>Freq: Q-DEC, Name: quarter, dtype: int64</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="fb82" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">2.累计和分组</h2><p id="38c1" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">累积是熊猫非常有用的功能。它计算列中值的累积和。我们通常是这样使用它的:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="8c64" class="ma mb it lw b gy mc md l me mf">df["cumulative_sum"] = df["amount"].cumsum()</span><span id="6501" class="ma mb it lw b gy mg md l me mf">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/aa95a3eb78745373c24a1d0f6dc2be35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kVjiDrmF2WGV-BWL0xtCTA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df的前5行(图片由作者提供)</p></figure><p id="9871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们得到了“金额”列中值的累积和。但是，它不考虑类。在某些情况下，我们可能需要分别计算不同类别的累计和。</p><p id="ed2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢天谢地，熊猫让这个任务变得非常简单。我们只需要按类列对行进行分组，然后应用cumsum函数。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="7ade" class="ma mb it lw b gy mc md l me mf">df["class_cum_sum"] = df.groupby("class")["amount"].cumsum()</span></pre><p id="9b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们确认一下a班的成绩。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="e052" class="ma mb it lw b gy mc md l me mf">df[df["class"]=="A"].head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/12508061cf8e2133d3280db0ef38f059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sfnq2xRWKVmu1p7gFA87IQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="a491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“类累积和”列包含为每个类单独计算的累积和值。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="ff9b" class="ma mb it bd mp mq mr dn ms mt mu dp mv li mw mx my lm mz na nb lq nc nd ne nf bi translated">3.类别数据类型</h2><p id="2e0a" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li ni lk ll lm nj lo lp lq nk ls lt lu im bi translated">我们经常需要处理分类数据，这些数据具有有限的、通常是固定数量的可能值。在我们的数据框架中，class列是一个具有4个不同值的分类变量:A、B、C、d。</p><p id="4f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，该列的数据类型变为“object”。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="53fe" class="ma mb it lw b gy mc md l me mf">df.dtypes</span><span id="d976" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>date              datetime64[ns]<br/>class                     object<br/>amount                     int64<br/>month                  period[M]<br/>quarter            period[Q-DEC]<br/>cumulative_sum             int64<br/>class_cum_sum              int64</span></pre><p id="3b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas还有一个“category”数据类型，它消耗的内存比object数据类型少得多。因此，最好尽可能使用category数据类型。</p><p id="a141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们复制class列，但是使用“category”数据类型。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="3560" class="ma mb it lw b gy mc md l me mf">df["class_category"] = df["class"].astype("category")</span><span id="12ca" class="ma mb it lw b gy mg md l me mf">df.dtypes</span><span id="8e4f" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>date              datetime64[ns]<br/>class                     object<br/>amount                     int64<br/>month                  period[M]<br/>quarter            period[Q-DEC]<br/>cumulative_sum             int64<br/>class_cum_sum              int64<br/>class_category          category<br/>dtype: object</span></pre><p id="cd16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以比较class和class_category列的内存消耗。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="835a" class="ma mb it lw b gy mc md l me mf">df.memory_usage()</span><span id="4b52" class="ma mb it lw b gy mg md l me mf"><strong class="lw iu"># output</strong><br/>Index             128<br/>date              800<br/>class             800<br/>amount            800<br/>month             800<br/>quarter           800<br/>cumulative_sum    800<br/>class_cum_sum     800<br/>class_category    304<br/>dtype: int64</span></pre><p id="935c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">class_category列消耗的内存不到class列的一半。相差496字节，不算多。然而，当我们处理大型数据集时，这种差异肯定会很重要。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="7fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="nn">媒介会员</em> </a> <em class="nn">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅</em><a class="ae ky" href="https://sonery.medium.com/subscribe" rel="noopener"><em class="nn"/></a><em class="nn">如果你想在我发表新文章时收到电子邮件。</em></p><p id="bd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>