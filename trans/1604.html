<html>
<head>
<title>VAE: Variational Autoencoders — How to Employ Neural Networks to Generate New Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VAE:可变自动编码器——如何利用神经网络生成新图像</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/vae-variational-autoencoders-how-to-employ-neural-networks-to-generate-new-images-bdeb216ed2c0#2022-04-18">https://towardsdatascience.com/vae-variational-autoencoders-how-to-employ-neural-networks-to-generate-new-images-bdeb216ed2c0#2022-04-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="7a71" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph">神经网络</h2><div class=""/><div class=""><h2 id="3b7f" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">VAEs概述，并附有一个完整的Python示例，教您如何自己构建一个</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/71184aa147c4638ce9795bc96b7bda72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwZqFku5i8gDtLOQMuw2Cw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">可变自动编码器(VAE)。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h1 id="67b3" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">介绍</h1><p id="a511" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">本文将带您了解<strong class="md je">变型自动编码器(VAE) </strong>，它与著名的<strong class="md je"> GANs(生成对抗网络)</strong>一起，属于更广泛的一组<strong class="md je">深度生成模型</strong>。</p><p id="fd60" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">与GAN不同，VAE使用自动编码器架构，而不是一对发生器-鉴别器网络。因此，VAEs中使用的思想应该相对容易理解，尤其是如果您过去使用过自动编码器的话。</p><p id="4b12" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果你想了解我未来关于神经网络的文章，比如GANs ，请随意<a class="ae li" href="https://bit.ly/3sItbfx" rel="noopener ugc nofollow" target="_blank">订阅</a>电子邮件通知<strong class="md je">。</strong></p><h1 id="c15f" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated"><strong class="ak">内容</strong></h1><ul class=""><li id="8fb4" class="nc nd iu md b me mf mh mi mk ne mo nf ms ng mw nh ni nj nk bi translated">VAE在机器学习算法领域的地位</li><li id="ffa9" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">VAEs的结构及其工作原理的解释</li><li id="aaea" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">一个完整的Python示例，展示了如何使用Keras/Tensorflow构建VAE</li></ul><h1 id="3bd3" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">VAE在机器学习算法领域的地位</h1><p id="7ecf" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">下图是我整理最常见的机器学习算法的尝试。不过，这并不是一件容易的事情，因为我们可以根据算法的底层结构或它们旨在解决的问题，在多个维度上对它们进行分类。</p><p id="6d60" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我试图将这两个方面都考虑进去，这使我将神经网络归入它们自己的类别。虽然我们通常以<strong class="md je">监督</strong>的方式使用神经网络，但必须承认一些例子，如自动编码器，更像是<strong class="md je">非监督/自我监督</strong>算法。</p><p id="30d6" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">尽管<strong class="md je">变型自动编码器(VAE) </strong>与GANs有着相似的目标，但它们的架构更接近于其他类型的自动编码器，如<a class="ae li" rel="noopener" target="_blank" href="/autoencoders-ae-a-smart-way-to-process-your-data-using-unsupervised-neural-networks-9661f93a8509">欠完整自动编码器</a>。因此，您可以通过点击下方的<strong class="md je">互动图表中的自动编码器组找到VAEs👇。</strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">机器学习算法分类。由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>创建的互动图表。</p></figure><p id="2d01" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je"> <em class="ns">如果你喜欢数据科学和机器学习</em> </strong> <em class="ns">，请</em> <a class="ae li" href="https://bit.ly/3sItbfx" rel="noopener ugc nofollow" target="_blank"> <em class="ns">订阅</em> </a> <em class="ns">获取我的新文章的邮件。如果你不是中等会员，可以在这里</em>  <em class="ns">加入</em> <a class="ae li" href="https://bit.ly/36Mozgu" rel="noopener ugc nofollow" target="_blank"> <em class="ns">。</em></a></p><h1 id="3fad" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated"><strong class="ak">VAEs的结构及其工作原理的解释</strong></h1><p id="e115" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">让我们先来分析一个标准的<a class="ae li" rel="noopener" target="_blank" href="/autoencoders-ae-a-smart-way-to-process-your-data-using-unsupervised-neural-networks-9661f93a8509">欠完整自动编码器</a> (AE)的架构，然后再深入研究使VAEs不同的元素。</p><h2 id="1676" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak">未完成AE </strong></h2><p id="66b0" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">下面是一个典型AE的图示。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oe"><img src="../Images/b18e78587979ef3a7a49b8358ca3215e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RiTYPEsnHnN5XfdsNolIzw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">欠完整自动编码器架构。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者、</a>使用<a class="ae li" href="http://alexlenail.me/NN-SVG/index.html" rel="noopener ugc nofollow" target="_blank"> AlexNail的NN-SVG工具</a>创建。</p></figure><p id="1908" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">欠完成AE的目标是有效地<strong class="md je">将来自输入数据的信息</strong>编码到<strong class="md je">低维潜在空间(瓶颈)</strong>。我们通过确保使用<strong class="md je">解码器</strong>以最小损失重建输入来实现这一目标。</p><p id="1b0b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">请注意，在训练过程中，当我们试图发现“最佳”潜在空间的参数值时，我们将同一组数据传递到输入和输出层。</p><h2 id="6eda" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak">变分AE </strong></h2><p id="ac62" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">现在，让我们通过分析其架构来看看VAE与不完整的AE有何不同:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj of"><img src="../Images/f5aa6fd421429cb52f0ba06cf615907e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qtXrzMLorYDl4SzKqoZxBg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">VAE建筑。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="6394" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">我们注意到VAE的潜在空间不是由点向量(单个节点)组成的。相反，输入被映射到正态分布，其中Zμ和Zσ是均值和方差，即在模型训练期间学习的参数。</p><p id="e2be" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">同时，从具有均值Zμ和方差Zσ的分布中采样潜在向量Z，并将其传递给解码器以获得预测输出。</p><p id="3414" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">重要的是要理解，通过设计，VAE的<strong class="md je">潜在空间是连续的</strong>，这使我们能够从它的任何部分取样以生成新的输出(例如，新的图像)，使VAE成为<strong class="md je">生成模型</strong>。</p><h2 id="dbf0" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak">正规化的需要</strong></h2><p id="266b" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">将输入编码到一个分布中，只让我们走了一半，就创建了一个适合生成“有意义的”输出的潜在空间。</p><p id="bbdf" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">然而，我们可以通过添加一个正则化项来实现所需的正则性，该正则化项表示为<strong class="md je"> Kulback-Leibler散度</strong> (KL散度)。我们将在稍后的Python部分详细讨论它。</p><h2 id="d393" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak">关于潜在空间的直觉</strong></h2><p id="58de" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们可以用下面的例子来想象信息是如何在潜在空间中传播的。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj og"><img src="../Images/859dcf16a30286159f67e958a507cc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN5ILV7z8mHM3oUS_VDqzg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">思考正则化连续潜在空间的直观方式。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="e408" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如您所见，将数据映射为单个点并不能训练模型理解这些点之间的相似性/差异。因此，我们不能使用这样的空间来生成新的“有意义的”数据。</p><p id="a1a4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">在变分自动编码器的情况下，我们将数据映射为分布并正则化潜在空间，这给了我们分布之间的<strong class="md je">“梯度”</strong>或<strong class="md je">“平滑过渡”</strong>。因此，当我们从这样的潜在空间中采样一个点时，我们生成与训练数据非常相似的新数据<strong class="md je">。</strong></p><div class="kt ku kv kw gu ab cb"><figure class="oh kx oi oj ok ol om paragraph-image"><a href="https://solclover.com/membership"><img src="../Images/63320331b74bd98eea6402472b4209ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*qkXay39OnVc2IosW6rkxtw.png"/></a></figure><figure class="oh kx oi oj ok ol om paragraph-image"><a href="https://www.linkedin.com/in/saulius-dobilas/"><img src="../Images/60fb21d1cb2701bfb6b71f61c99403e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vabxOXtQ4T034N_mscHSmQ.png"/></a></figure></div><h1 id="6911" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated"><strong class="ak">一个完整的Python例子，展示了如何用Keras/Tensorflow构建VAE</strong></h1><p id="d0a8" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">最后，是时候建立我们自己的VAE了！</p><h2 id="8500" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">设置</h2><p id="06cf" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们需要以下数据和库:</p><ul class=""><li id="6f24" class="nc nd iu md b me mx mh my mk on mo oo ms op mw nh ni nj nk bi translated"><a class="ae li" href="https://www.tensorflow.org/api_docs/python/tf/keras/datasets/mnist/load_data" rel="noopener ugc nofollow" target="_blank"> MNIST手写数字数据</a>(版权由Yann LeCun和Corinna Cortes根据<a class="ae li" href="https://creativecommons.org/licenses/by-sa/3.0/" rel="noopener ugc nofollow" target="_blank">知识共享署名-相同方式共享3.0许可证</a>持有；数据来源:<a class="ae li" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank">MNIST数据库</a></li><li id="e97d" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用于数据操作的Numpy </li><li id="a808" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated">用于可视化的<a class="ae li" href="https://matplotlib.org/stable/api/index.html" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>、<a class="ae li" href="https://graphviz.org/" rel="noopener ugc nofollow" target="_blank"> Graphviz </a>和<a class="ae li" href="https://plotly.com/python/" rel="noopener ugc nofollow" target="_blank"> Plotly </a></li><li id="ad75" class="nc nd iu md b me nl mh nm mk nn mo no ms np mw nh ni nj nk bi translated"><a class="ae li" href="https://www.tensorflow.org/api_docs/python/tf" rel="noopener ugc nofollow" target="_blank">用于神经网络的Tensorflow/Keras </a></li></ul><p id="6936" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">让我们导入所有的库:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><p id="a12a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上面的代码打印了本例中使用的包版本:</p><pre class="kt ku kv kw gu or os ot ou aw ov bi"><span id="3c85" class="nt lk iu os b gz ow ox l oy oz">Tensorflow/Keras: 2.7.0<br/>numpy: 1.21.4<br/>matplotlib: 3.5.1<br/>graphviz: 0.19.1<br/>plotly: 5.4.0</span></pre><p id="53a1" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们加载MNIST手写数字数据并显示前十位数字。请注意，我们将仅在可视化中使用数字标签(y_train，y_test ),而不用于模型训练。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pa"><img src="../Images/42f40b3b126c844198d0dea9e8806428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gEa1BA4Ce864MxMOKHtnA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">MNIST数据集的前十位数字。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="64ba" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如您所见，我们在训练集中有60，000张图像，在测试集中有10，000张图像。请注意，它们的尺寸是28 x 28像素。</p><p id="686d" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">设置的最后一步是通过将图像从28x28调整为784来拼合图像。</p><p id="4dcc" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">通常，我们会使用<a class="ae li" rel="noopener" target="_blank" href="/convolutional-neural-networks-explained-how-to-successfully-classify-images-in-python-df829d4ba761"> <strong class="md je">卷积层</strong> </a>而不是展平图像，尤其是在处理较大的图片时。然而，我想保持这个例子简单，因此使用<strong class="md je">密集层</strong>和平面数据，而不是<strong class="md je">卷积层</strong>。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><pre class="kt ku kv kw gu or os ot ou aw ov bi"><span id="7606" class="nt lk iu os b gz ow ox l oy oz">New shape of X_train:  (60000, 784)<br/>New shape of X_test:  (10000, 784)</span></pre><h2 id="0d77" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated">建立变分自动编码器模型</h2><p id="f772" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我们将从定义一个函数开始，这个函数将帮助我们从潜在空间分布<em class="ns"> Z </em>中取样。</p><p id="8bea" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">这里我们采用了一个<strong class="md je">重新参数化技巧</strong>，它允许损失通过均值<em class="ns"> (z均值)</em>和方差<em class="ns"> (z对数西格玛)</em>节点反向传播，因为它们是确定性的。</p><p id="ce41" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">同时，我们通过添加一个非确定性参数ε来分离采样节点，该参数是从标准正态分布中采样的。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><p id="1783" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在，我们可以定义<strong class="md je">编码器模型</strong>的结构。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><p id="b7c0" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上面的代码创建了一个编码器模型，并打印了它的结构图。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pb"><img src="../Images/9553ba83dfc51d8c950f3819e650ba79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYOy_nRiu2hm_vJXoezP1Q.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">VAE模型编码器部分的示意图。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="29a4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">请注意我们如何将来自<em class="ns">编码器-隐藏层-3 </em>的相同输出发送到<em class="ns">Z-均值</em>和<em class="ns">Z-对数-适马</em>中，然后在<strong class="md je">自定义λ层</strong><em class="ns">(Z-采样层)</em>中重新组合它们，用于从潜在空间进行采样。</p><p id="8a93" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们创建<strong class="md je">解码器模型</strong>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><p id="b9bd" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上面的代码创建了一个解码器模型并打印了它的结构图。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pc"><img src="../Images/5d27b72b9182550dedda122b1bf0d29c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sgCG9BrBl21EnaPJ_Lo-vQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">VAE模型解码器部分的示意图。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="5417" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">正如您所看到的，解码器是一个非常简单的模型，它从最新的空间获取输入，并在为784个输出节点生成值之前，将它们通过几个隐藏层。</p><p id="bac9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">接下来，我们<strong class="md je">组合编码器和解码器</strong>模型以形成<strong class="md je">变型自动编码器模型(VAE)。</strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><p id="6955" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果您密切关注编码器模型中的潜在空间层，您会注意到编码器生成三组输出:Z均值[0]、Z对数西格玛[1]和Z [2]。</p><p id="dae8" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">上面的代码通过指定编码器接受名为“visible”的原始输入来链接模型。然后，在编码器[0]、[1]、[2]生成的三个输出中，我们取第三个输出(Z [2])并将其传递给解码器，解码器生成我们命名为“output”的输出。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pd"><img src="../Images/376de7e7f2354fdba6286c56dde64359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fu-oMTxJRHzRpzwUBBBBcA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">连接编码器和解码器以构建VAE模型。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h2 id="b99b" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak">自定义损失功能</strong></h2><p id="d6a0" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在训练VAE模型之前，最后一步是创建一个<strong class="md je">自定义损失函数</strong>并编译该模型。</p><p id="57d0" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">正如本文前面提到的，我们将使用<strong class="md je"> KL散度</strong>来衡量潜在空间分布和参考标准正态分布之间的损失。“<strong class="md je"> KL损失</strong>是标准<strong class="md je">重建损失</strong>(在这种情况下，MSE)的补充，用于确保输入和输出图像保持接近。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><h2 id="ad7d" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak"> VAE模特培训</strong></h2><p id="8fff" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">装配了可变自动编码器模型后，让我们在25个时期内对其进行训练，并绘制损失图。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pe"><img src="../Images/755ef21d9259835121d76d673b7e17d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rh6nyZtyo5jCe5MXn4G70Q.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">随时间变化的自动编码器模型损耗。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><h2 id="70cf" class="nt lk iu bd ll nu nv dn lp nw nx dp lt mk ny nz lv mo oa ob lx ms oc od lz ja bi translated"><strong class="ak">显现潜在空间并生成新数字</strong></h2><p id="4c35" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">由于我们的潜在空间是二维的，我们可以在潜在的2D平面上想象不同数字的邻域:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nq nr l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">编码在潜在空间中的MNIST数字的2D可视化。图表作者<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="4b92" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">绘制潜在空间中的数字分布给了我们视觉上将不同区域与不同数字相关联的好处。</p><p id="e19a" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">假设我们想要生成一个数字3的新图像。我们知道3位于潜在空间的顶部中间。因此，让我们选择[0，2.5]的坐标，并生成与这些输入相关联的图像。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pf"><img src="../Images/d9692d1f98dfa26008a1e6aeefc1724b.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*xWd7VYquFs9rnWdmlebIkA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">VAE模型产生的新数字。图片来自<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>。</p></figure><p id="77b6" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">正如所料，我们得到了一个形状非常像数字3的图像，因为我们从3所占据的潜在空间中的一个区域采样了一个向量。</p><p id="0eb4" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">现在让我们从整个潜在空间中生成900个新数字。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oq nr l"/></div></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pg"><img src="../Images/66452958874c05682627e667457cd896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yfZ6X68X2kilJtFpmspJ2Q.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">使用我们的VAE模型生成900个新数字。图片由<a class="ae li" href="https://solclover.com/" rel="noopener ugc nofollow" target="_blank">作者</a>提供。</p></figure><p id="b761" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">从整个潜在空间生成许多图像的酷之处在于，它让我们看到不同形状之间的逐渐过渡。这证实了我们能够成功地调整我们的潜在空间。</p><h1 id="843c" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">结束语</h1><p id="b4bd" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">值得注意的是，我们可以使用变分自动编码器来编码和生成比MNIST数字更复杂的数据。</p><p id="94f9" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">因此，我鼓励您将我的简单教程应用到与您所在领域相关的真实世界数据中，从而更上一层楼。</p><p id="ff8b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">为了您的方便，我在我的<a class="ae li" href="https://github.com/SolClover/Art049_NN_VAE" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中保存了一个Jupyter笔记本，其中包含了上述所有代码。</p><p id="cd54" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated"><strong class="md je">如果你想在我发表一篇关于机器学习/神经网络(例如，生成对抗网络(GAN))的新文章时得到通知</strong>，请<a class="ae li" href="https://bit.ly/3sItbfx" rel="noopener ugc nofollow" target="_blank">订阅以接收电子邮件</a>。</p><p id="6d8b" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果你不是媒体会员，并且想继续阅读成千上万伟大作家的文章，你可以使用我下面的个性化链接加入:</p><div class="ph pi gq gs pj pk"><a href="https://bit.ly/3J6StZI" rel="noopener  ugc nofollow" target="_blank"><div class="pl ab fp"><div class="pm ab pn cl cj po"><h2 class="bd je gz z fq pp fs ft pq fv fx jd bi translated">通过我的推荐链接加入Medium索尔·多比拉斯</h2><div class="pr l"><h3 class="bd b gz z fq pp fs ft pq fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ps l"><p class="bd b dl z fq pp fs ft pq fv fx dk translated">solclover.com</p></div></div><div class="pt l"><div class="pu l pv pw px pt py lc pk"/></div></div></a></div><p id="b6d7" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">如果您有任何问题或建议，请随时联系我们！</p><p id="f412" class="pw-post-body-paragraph mb mc iu md b me mx ke mg mh my kh mj mk mz mm mn mo na mq mr ms nb mu mv mw in bi translated">干杯！🤓<br/> <strong class="md je">索尔·多比拉斯</strong></p></div></div>    
</body>
</html>