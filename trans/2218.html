<html>
<head>
<title>How To Do Logging in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中进行日志记录</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-do-logging-in-python-37fee87b718c#2022-05-17">https://towardsdatascience.com/how-to-do-logging-in-python-37fee87b718c#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4905" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">跟踪程序中的事件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6fb74092e121652304809cb5f787c6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ODv4swqwS_0_3bYc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">维克多·塔拉舒克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python编程语言中最常用的函数之一是<code class="fe lv lw lx ly b">print()</code>语句；<code class="fe lv lw lx ly b">print()</code>是您在学习Python时首先要学习的函数之一。就功能而言，没有任何东西可以与之媲美。但是它不应该用于所有的情况，比如你在调试的时候——尤其是当你在处理一个复杂的程序的时候。</p><p id="2674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个简单的程序中使用<code class="fe lv lw lx ly b">print()</code>语句可能不会有什么问题，但我个人不建议这样做。您最好养成使用日志来调试代码的习惯。日志是程序员工具箱中最有用的工具之一。它用于帮助更好地理解程序的流程，并识别在开发程序时可能没有考虑到的场景。</p><p id="ff49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python为我们提供了一个名为<code class="fe lv lw lx ly b">logging</code>的内置日志模块。在这篇文章中，我们将介绍一些重要的概念，这些概念将允许你开始把<code class="fe lv lw lx ly b">logging</code>添加到你的应用程序中。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5485" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">Table of contents:</strong> <br/>--&gt; <a class="ae ky" href="#e4e6" rel="noopener ugc nofollow">A simple introduction to Python's logging module</a><br/>--&gt; <a class="ae ky" href="#826c" rel="noopener ugc nofollow">Configuring the logger</a><br/>--&gt; <a class="ae ky" href="#7300" rel="noopener ugc nofollow">Creating your own logger object</a><br/>--&gt; <a class="ae ky" href="#dd42" rel="noopener ugc nofollow">Understanding when to use logging</a></span></pre><h1 id="e4e6" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">Python日志模块的简单介绍</h1><p id="810d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">日志是与程序相关的事件的自动生成的、带有时间戳的文档。为了产生这样的信息，记录器不断地监视应用程序的流程并存储必要的信息(即谁在什么时间访问了程序)。</p><p id="5a98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，可以使用<code class="fe lv lw lx ly b">logging</code>模块来创建日志。它是大多数第三方库使用的一种流行的内置Python，这意味着您可以将您的日志消息与您正在使用的库的日志消息集成在一起，但这并不是它唯一酷的地方。</p><p id="60d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">logging</code>模块的另一个很酷的特性是它提供了一组函数来简化日志记录过程。每个日志记录函数都以事件的严重级别命名，这使得记录程序中最紧急的事件成为可能。</p><p id="af1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义的级别(按严重性递增顺序排列)如下:</p><ul class=""><li id="2492" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><strong class="lb iu"> DEBUG </strong> : <em class="no">用于记录与源代码相关的底层细节，例如，通知开发人员某个函数已被调用或者某个对象的值存储在变量</em>中。</li><li id="db96" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><strong class="lb iu"> INFO </strong> : <em class="no">用于与程序中发生的事情相关的通用信息，例如正在读取的文件或正在发送的电子邮件。</em></li><li id="6b1b" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><strong class="lb iu">警告</strong> : <em class="no">用来警告你现在还没有错误，但是将来可能会有错误。</em></li><li id="7724" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><strong class="lb iu">错误</strong> : <em class="no">用于可预防的错误。</em></li><li id="7beb" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><strong class="lb iu">关键</strong> : <em class="no">用于导致系统失败或无法恢复的错误</em></li></ul><p id="69ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，并非所有日志消息都是平等的。</p><p id="602a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看<code class="fe lv lw lx ly b">logging</code>模块附带的默认记录器:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5e2b" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">import </strong>logging </span><span id="6955" class="md me it ly b gy nu mg l mh mi"><strong class="ly iu">&gt;&gt;&gt;</strong> logging.debug("debug message")<br/><strong class="ly iu">&gt;&gt;&gt;</strong> logging.info("info message")<br/><strong class="ly iu">&gt;&gt;&gt;</strong> logging.warning("warning message")<br/>WARNING:root:This is a warning message<br/><strong class="ly iu">&gt;&gt;&gt;</strong> logging.error("error message")<br/>ERROR:root:error message<br/><strong class="ly iu">&gt;&gt;&gt;</strong> logging.critical("critical message")<br/>CRITICAL:root:critical message</span></pre><p id="3006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到两件事:</p><ol class=""><li id="86b4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nv nl nm nn bi translated"><code class="fe lv lw lx ly b">logging.debug()</code>和<code class="fe lv lw lx ly b">logging.info()</code>功能未被记录。这是因为默认配置是只记录严重级别为<code class="fe lv lw lx ly b">WARNING</code>或以上的消息。</li><li id="1852" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nv nl nm nn bi translated">记录信息的输出格式为<code class="fe lv lw lx ly b">severity_level:logger_name:logging_message</code>。</li></ol><p id="78d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以配置我们的日志消息，您将在下一节看到。</p><h1 id="826c" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">配置记录器</h1><p id="93b7" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在上一节中，我们已经用默认设置介绍了日志模块，但是有时默认设置并不是我们想要的。在这种情况下，我们可以通过配置<code class="fe lv lw lx ly b">logging.basicConfig()</code>来设置我们的记录器。</p><p id="3d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">logging.basicConfig()</code>最常用的参数包括:</p><ul class=""><li id="ef0b" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">filename</code> —指定使用指定的<code class="fe lv lw lx ly b">filename</code>而不是<code class="fe lv lw lx ly b">StreamHandler</code>创建一个<code class="fe lv lw lx ly b">FileHandler</code>；记录输出被发送到带有给定<code class="fe lv lw lx ly b">filename</code>的磁盘文件。</li><li id="deec" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">filemode</code> —如果指定了<code class="fe lv lw lx ly b">filename</code>，那么文件将在给定的<code class="fe lv lw lx ly b">filemode</code>中打开。默认模式为“a”:了解更多关于不同<a class="ae ky" href="https://docs.python.org/3/library/functions.html#filemodes" rel="noopener ugc nofollow" target="_blank">模式</a>的信息。</li><li id="31bf" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">format</code> —指定的格式字符串将用于处理程序；默认的格式字符串是<code class="fe lv lw lx ly b">levelname:name:message</code>[如上所示]。</li><li id="9e7a" class="nf ng it lb b lc np lf nq li nr lm ns lq nt lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">level</code>—root logger应设置的指定严重性级别。</li></ul><p id="b159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们进一步探索这些参数。</p><p id="f201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">level</code>参数来设置日志消息的严重性级别。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5e9e" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">import </strong>logging<br/><strong class="ly iu">from </strong>datetime <strong class="ly iu">import </strong>date</span><span id="d3a0" class="md me it ly b gy nu mg l mh mi">logging.basicConfig(level=logging.INFO)</span><span id="587c" class="md me it ly b gy nu mg l mh mi"><strong class="ly iu">def </strong>calculate_age(year_of_birth:<strong class="ly iu">int</strong>) -&gt; <strong class="ly iu">int</strong>:<br/>    """Compute the age of a person"""<br/>    current_year = date.today().year<br/>    <strong class="ly iu">return </strong>current_year - year_of_birth<br/><br/>year_of_birth = 1994<strong class="ly iu"><br/><br/></strong>logging.info(f"User was born in {year_of_birth} and is approximately {calculate_age(year_of_birth)} years old")</span><span id="f028" class="md me it ly b gy nu mg l mh mi">"""<br/>INFO:root:User was born in 1994 and is approximately 28 years old<br/>"""</span></pre><p id="7c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想把我们的日志消息发送到一个文件而不是控制台，我们必须把参数<code class="fe lv lw lx ly b">filename</code>传递给我们的<code class="fe lv lw lx ly b">logging.basicConfig()</code>并提供一个我们想用来保存文件的名字。</p><p id="dc8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="no">注意</em> </strong> <em class="no"> : </em> <code class="fe lv lw lx ly b"><em class="no">basicConfig()</em></code> <em class="no">只有在root logger尚未配置的情况下才能调用——只能调用一次。因此，想象接下来的几个代码片段正在更新上面的脚本，而不是扩展它。</em></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b939" class="md me it ly b gy mf mg l mh mi">logging.basicConfig(level=logging.INFO, filename="example.log") </span></pre><p id="2390" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们的代码执行这个更新，现在会将所有后续的日志消息附加到当前工作目录中名为<code class="fe lv lw lx ly b">example.log</code>的文件中——这意味着如果该文件已经存在，那么logger会简单地将您的新日志添加到文件的末尾。</p><p id="7ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过设置<code class="fe lv lw lx ly b">filemode</code>来改变这种行为。默认情况下，<code class="fe lv lw lx ly b">filemode</code>参数设置为<code class="fe lv lw lx ly b">"a"</code>，表示文件为<em class="no">打开写入，如果存在</em>则追加到文件末尾<strong class="lb iu">源</strong> : <a class="ae ky" href="https://docs.python.org/3/library/functions.html#filemodes" rel="noopener ugc nofollow" target="_blank">测井文件</a>。让我们将<code class="fe lv lw lx ly b">filemode</code>改为<code class="fe lv lw lx ly b">"w"</code>::<em class="no">打开进行写入，首先截断文件。</em></p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="27f2" class="md me it ly b gy mf mg l mh mi">logging.basicConfig(level=logging.INFO, <br/>                    filename="example.log",<br/>                    filemode="w")</span></pre><p id="2319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次程序运行时，日志文件都会被重写，因为我们对<code class="fe lv lw lx ly b">filemode</code>做了更改。</p><p id="ff77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，正在存储的日志消息来自默认格式— <code class="fe lv lw lx ly b">levelname:name:message</code>。我们可以通过在默认配置中设置<code class="fe lv lw lx ly b">format</code>参数来改变这一点。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5c1d" class="md me it ly b gy mf mg l mh mi">"""<br/>INFO:root:User was born in 1994 and is approximately 28 years old<br/>"""</span></pre><p id="41ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该消息看起来像这样，但是将被写入一个名为<code class="fe lv lw lx ly b">app.log</code>的文件，而不是控制台。</p><p id="bb0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模块<code class="fe lv lw lx ly b">logging</code>还提供了<a class="ae ky" href="https://docs.python.org/3/library/logging.html#:~:text=LogRecord%20attributes%C2%B6" rel="noopener ugc nofollow" target="_blank">几个速记元素</a>，可以很容易地添加到输出格式中。例如，我们可以使用<code class="fe lv lw lx ly b">%(asctime)s</code>来输出一个人类可读的<code class="fe lv lw lx ly b">LogRecord</code>创建时间。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8796" class="md me it ly b gy mf mg l mh mi">logging.basicConfig(level=logging.INFO, <br/>                    filename="example.log",<br/>                    format="%(asctime)s - %(message)s")</span><span id="8ed3" class="md me it ly b gy nu mg l mh mi">logging.info(f"User was born in {year_of_birth} and is approximately {calculate_age(year_of_birth)} years old")</span></pre><p id="8b39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe lv lw lx ly b">example.log</code>文件中的新日志消息将如下所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5e17" class="md me it ly b gy mf mg l mh mi">2022-05-17 08:13:16,693 - User was born in 1994 and is approximately 28 years old</span></pre><h1 id="7300" class="mj me it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">创建您自己的记录器对象</h1><p id="bfeb" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">到目前为止，我们一直在使用名为<code class="fe lv lw lx ly b">root</code>的默认记录器。<code class="fe lv lw lx ly b">logging</code>文档建议我们创建自己的<code class="fe lv lw lx ly b">Logger</code>类的logger对象——当应用程序中有多个模块时，这甚至更重要。</p><blockquote class="nw"><p id="7089" class="nx ny it bd nz oa ob oc od oe of lu dk translated"><em class="og">记录器永远不要直接实例化，而要一直通过模块级函数</em> <code class="fe lv lw lx ly b"><em class="og">logging.getLogger(name)</em></code> <em class="og">。对同名的</em> <code class="fe lv lw lx ly b"><em class="og">getLogger()</em></code> <em class="og">的多次调用将总是返回对同一个Logger对象的引用。<br/>——</em><strong class="ak"><em class="og">来源</em></strong><em class="og">:</em><a class="ae ky" href="https://docs.python.org/3/library/logging.html#:~:text=Loggers%20should%20NEVER%20be%20instantiated%20directly%2C%20but%20always%20through%20the%20module%2Dlevel%20function%20logging.getLogger(name).%20Multiple%20calls%20to%20getLogger()%20with%20the%20same%20name%20will%20always%20return%20a%20reference%20to%20the%20same%20Logger%20object." rel="noopener ugc nofollow" target="_blank"><em class="og">Logger对象文档</em> </a> <em class="og">】。</em></p></blockquote><p id="5afd" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">以下是我的<a class="ae ky" href="https://github.com/kurtispykes/fraud-detection-project" rel="noopener ugc nofollow" target="_blank">欺诈检测项目</a>中的一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="79b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">python文件的名称是<code class="fe lv lw lx ly b">predict.py</code>:因此，我们在名为<code class="fe lv lw lx ly b">predict</code>的<code class="fe lv lw lx ly b">_logger</code>变量中实例化了一个定制日志记录器(见第11行)。</p><blockquote class="nw"><p id="e954" class="nx ny it bd nz oa ob oc od oe of lu dk translated">“建议我们使用模块级记录器，通过将名称参数<code class="fe lv lw lx ly b">__name__</code>传递给<code class="fe lv lw lx ly b">getLogger()</code>来创建一个记录器对象，因为记录器本身的名称会告诉我们从哪里记录事件。<code class="fe lv lw lx ly b">__name__</code>是Python中一个特殊的内置变量，它计算当前模块的名称。<br/> —【来源:<a class="ae ky" href="https://docs.python.org/3/library/logging.html#:~:text=Loggers%20should%20NEVER%20be%20instantiated%20directly%2C%20but%20always%20through%20the%20module%2Dlevel%20function%20logging.getLogger(name).%20Multiple%20calls%20to%20getLogger()%20with%20the%20same%20name%20will%20always%20return%20a%20reference%20to%20the%20same%20Logger%20object." rel="noopener ugc nofollow" target="_blank">记录器对象文档</a>】。</p></blockquote><h1 id="dd42" class="mj me it bd mk ml mm mn mo mp mq mr ms jz oo ka mu kc op kd mw kf oq kg my mz bi translated">了解何时使用日志记录</h1><p id="4224" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">如果你和我一样，你可能还在思考如何知道应该给出什么样的日志消息。</p><p id="1335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志文档为我们提供了有用的指导。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/2b8af6ebf1f64aa058ce0e8b47a89f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EULb61c2eQiJLHvQBcCjIg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd os">何时使用日志记录；【来源:</strong> <a class="ae ky" href="https://docs.python.org/3/howto/logging.html#:~:text=Task%20you%20want,and%20application%20domain" rel="noopener ugc nofollow" target="_blank"> <strong class="bd os">日志记录HOWTO </strong> </a> <strong class="bd os">】。</strong></p></figure><p id="5ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于日志，我们还可以讨论很多，但是这已经足够让你开始了。将我们在这篇文章中讨论的东西应用到一个个人项目中来巩固知识。需要时，不要害怕参考<a class="ae ky" href="https://docs.python.org/3/howto/logging.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="2182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="no">感谢阅读。</em></p><p id="331c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">联系我:</strong><br/><a class="ae ky" href="https://www.linkedin.com/in/kurtispykes/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a><br/><a class="ae ky" href="https://twitter.com/KurtisPykes" rel="noopener ugc nofollow" target="_blank">Twitter</a><br/><a class="ae ky" href="https://www.instagram.com/kurtispykes/" rel="noopener ugc nofollow" target="_blank">insta gram</a></p><p id="2f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这样的故事，并希望支持我的写作，可以考虑成为一名灵媒。每月支付5美元，你就可以无限制地阅读媒体上的故事。如果你使用<a class="ae ky" href="https://kurtispykes.medium.com/membership" rel="noopener">我的注册链接</a>，我会收到一小笔佣金。</p><p id="4cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经是会员了？<a class="ae ky" href="https://kurtispykes.medium.com/subscribe" rel="noopener">订阅</a>在我发布时得到通知。</p><div class="ot ou gp gr ov ow"><a href="https://kurtispykes.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">每当Kurtis Pykes发表文章时都收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">kurtispykes.medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk ks ow"/></div></div></a></div></div></div>    
</body>
</html>