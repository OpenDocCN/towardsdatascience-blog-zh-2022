<html>
<head>
<title>It All Comes Down To Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这一切都归结于设计模式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/it-all-comes-down-to-design-patterns-c7034eb39ef9#2022-06-16">https://towardsdatascience.com/it-all-comes-down-to-design-patterns-c7034eb39ef9#2022-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过软件设计模式发现真善美</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b7af19bc36ec6b3ab0068f9e2f50045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uHysXbEZQwEasMJHpJa-sw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4956" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然软件架构不是关于编码的，但是作为一个软件架构师，你仍然需要有大量关于开发的知识，特别是设计模式。</p><p id="321c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么在你的IT工具箱下添加设计模式将有益于你的职业发展有许多原因，但是三个最重要的原因是:</p><ul class=""><li id="55ac" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">设计模式在你使用的任何库、包和框架中都很普遍。如果你理解了一个模式的用法和它的基本原理，你将获得更深的洞察力，这将允许你更快地在许多语言中导航。</li><li id="2102" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">与开发团队拥有一个<strong class="la iu">通用词汇表</strong>可以让你更容易、更准确地传达你的设计规范。</li><li id="c2b9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">能够根据对象之间的<strong class="la iu">交互</strong>来思考有助于设计一个能够经受住时间考验的抽象解决方案。</li></ul><blockquote class="mi"><p id="dd78" class="mj mk it bd ml mm mn mo mp mq mr lt dk translated">一切都是设计好的；很少有东西是设计好的！</p></blockquote><p id="772b" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">诚然，我没有进行任何科学研究来评估哪些是最常用的模式。这是基于我作为开发人员和架构师在这个领域的经验观察。我们将首先钻研一些关于实体设计的基础知识，然后我们将探索我最重视的一组模式。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="4367" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">坚实的原则</h1><p id="f1a1" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">我们之前已经看到了坚实的原则如何应用于架构本身，但是这里我们将关注它们在软件工程设计中的重要性。我们只会玩弄它们(也就是说，不会提供任何代码)，但是对于每个想要了解他们的开发团队想要做什么的架构师来说，这将是一个很好的起点。</p><p id="d6f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">先说个定义……正如<a class="ae ob" href="https://en.wikipedia.org/wiki/Robert_C._Martin" rel="noopener ugc nofollow" target="_blank">鲍勃大叔</a>所说:<em class="oc"/><a class="ae ob" href="https://sites.google.com/site/unclebobconsultingllc/getting-a-solid-start" rel="noopener ugc nofollow" target="_blank"><em class="oc">它们不是法律。它们不是完美的真理。这些陈述的顺序是:一天一个苹果，医生远离我。</em>这意味着它们不是某种“魔法”,不会带来牛奶、蜂蜜和伟大软件的乐土，但它们仍然是健壮和持久软件的重要贡献者。</a></p><p id="9a83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简而言之，这些原则围绕着两个主要概念，它们是成功的企业应用程序的构建块:<strong class="la iu">耦合</strong>是一个类了解另一个类并与之交互的程度，而<strong class="la iu">内聚</strong>表示一个类具有单一目的的程度。换句话说:</p><blockquote class="od oe of"><p id="27b4" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated">耦合是关于类之间如何交互的，而内聚则关注单个类是如何设计的。</p></blockquote><p id="5387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">固体代表以下术语:</p><h2 id="2203" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated"><strong class="ak"> ➊ — </strong>单一责任原则</h2><blockquote class="od oe of"><p id="ac76" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">一个类应该有且只有一个理由改变。</em> </strong></p></blockquote><p id="fee6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是不言自明的，但是说起来容易做起来难——向现有的类中添加新的行为总是很诱人的，但是这是灾难的一个处方:每个行为都可能是将来改变的原因，所以更少的行为导致在改变期间引入错误的机会更少。</p><h2 id="bf02" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated"><strong class="ak"> ➋ — </strong>开闭原理</h2><blockquote class="od oe of"><p id="fecd" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated">你应该能够扩展一个类的行为，而不用修改它。T12】</p></blockquote><p id="edd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您使用的类应该对扩展开放，但对修改关闭。实现这一点的一种方法是通过继承，即创建一个子类，这样原始类就不会被修改，但自定义代码会被添加到子类中以引入新的行为。</p><h2 id="eac9" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated"><strong class="ak"> ➌ — </strong>利斯科夫替代原理</h2><blockquote class="od oe of"><p id="a8b0" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">派生类必须可以替换其基类。</em> </strong></p></blockquote><p id="b547" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当将类A的行为扩展到子类B时，你必须确保你仍然可以在不破坏任何东西的情况下与B交换A。这可能有点吸引人，尤其是当把这一原则与开闭原则结合起来时。</p><h2 id="8588" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated"><strong class="ak"> ➍ — </strong>界面偏析原理</h2><blockquote class="od oe of"><p id="1f57" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated"><strong class="la iu"> <em class="it">制作客户特定的细粒度接口。</em>T24】</strong></p></blockquote><p id="7152" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接口和类必须尽可能的专门化，这样调用客户端就不会依赖于它们不使用的方法。这与单一责任原则是相辅相成的。</p><h2 id="23a8" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated"><strong class="ak"> ➎ — </strong>依存倒置原则</h2><blockquote class="od oe of"><p id="4200" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated">依靠抽象，而不是具体。 </p></blockquote><p id="9240" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">高级类不应该依赖于低级类。它们都应该依赖于抽象。同样，抽象不应该依赖于细节。细节应该依赖于抽象。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="ed05" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">设计模式</h1><p id="f885" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">四位作者(Gamma，Helm，Johnson &amp; Vlissides)在1994年出版了著名的著作《<a class="ae ob" href="https://www.amazon.co.uk/dp/0201633612" rel="noopener ugc nofollow" target="_blank">设计模式:可重用的面向对象软件的元素</a>》，其中包括23种面向对象的设计模式。由于它的名字很长，人们开始称它为“四人帮(g of)的书”。</p><p id="0885" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从定义开始:</p><blockquote class="od oe of"><p id="0806" class="ky kz oc la b lb lc ju ld le lf jx lg og li lj lk oh lm ln lo oi lq lr ls lt im bi translated">软件设计模式是对软件工程中常见问题的优化的、可重复的解决方案。这是一个解决问题的模板，可以在许多不同的情况下使用。</p></blockquote><p id="91c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设计模式不是规定性的，而是有目的地保持高层次。他们的目标是提高代码质量，并最终坚持坚实的原则。他们也遵守这个规则:1。界面设计，2。偏好组合而非继承；3 .封装任何可变性。</p><p id="40c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为架构师，首先要知道的是基于设计模式的意图或目的的不同类别，概括如下:</p><ul class=""><li id="477d" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">创建:它们提供对象实例化机制。</li><li id="ea4f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">结构</strong>:他们专注于将物体组合成更大的结构。</li><li id="05df" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">行为</strong>:他们负责有效的沟通和跨对象的责任分配。</li></ul><p id="1804" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下图显示了我们将要探索的GoF模式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/bb9c8e2aebb5b055ee6a69c4ceb5e8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*-h45nKu9YwTNBHnuG1A2JA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最常见的设计模式</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="443f" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➊——建筑|创意</h2><p id="da6a" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">构建器模式旨在以<strong class="la iu">一步一步</strong>的方式构建一个复杂的对象，并将构建与其表示分离开来。本质上，它允许使用相同的代码产生不同类型和表示的对象。</p><p id="40dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:几种复杂的物体可以用相同的整体构建过程来构建，尽管各个构建步骤有所不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/5e3950343cde7e9724c78ec8cf05eff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IIA0KIGSc9FI4moR_11fWQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建器模式</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="14a2" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➋ —工厂方法|创新</h2><p id="03f8" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">工厂方法为<strong class="la iu">创建对象</strong>定义了一个接口，但是实例化是由子类完成的。</p><p id="7ef6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:事先不知道对象的确切类型和依赖关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/5634413dbf860cc92556c0b985c370db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MW6c9owh-1cyx58NqDF7FA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工厂方法</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="9e49" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➌——抽象工厂|创意</h2><p id="1077" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">抽象工厂捕获如何创建相关对象的<strong class="la iu">系列，而不指定它们的具体类。</strong></p><p id="7274" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:存在不同的情况，需要不同的规则集实现，这些情况要么是事先未知的，要么是可扩展性问题。<br/> ⭐️ <strong class="la iu">与抽象方法</strong>的区别:<br/>抽象工厂:创建其他工厂，这些工厂又创建从基类派生的对象。<strong class="la iu"> <br/> </strong>【工厂方法:创建从特定基类派生的对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/9006aae20bf458c386d619e36cb70076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QsvIVAEeIij4IQqqK5E_6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抽象工厂</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="af03" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➍ —装饰|结构</h2><p id="4431" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">装饰模式通过将对象放在包含这些行为的特殊包装类中，动态地将新的责任附加到对象上，因此对原始方法的签名没有影响(组合优于继承)。</p><p id="fd29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:在运行时给对象分配额外的行为，而不破坏使用这些对象的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/49569f12b54f60519deb61b4b30c63d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adpb5OfoOIxG1eQMKrTM0w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰图案</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="1239" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➎——立面|结构</h2><p id="b6a5" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">Facade模式为库、api、框架或任何其他复杂的类集提供了一个简化的接口。它实际上是一个复杂的从属子系统的包装器。</p><p id="0171" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:通过将子系统封装在单个接口对象中，将子系统与其潜在客户分离，该接口对象成为该系统的唯一接入点/网关。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/32f9d8924eee6d940e043dbf2255499a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kJcgku5RJjUgAvBMTencfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">立面图案</p></figure><h2 id="6acb" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➎ —存储库</h2><p id="7b18" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">存储库模式不是GoF模式的一部分，但是它是一个特定于数据的facade实现，所以在这里值得一提。它解决了数据检索和持久化的代码集中化问题，并为数据访问操作提供了<strong class="la iu">抽象，即类似于内存中的域对象集合，允许执行CRUD方法，并消除了任何数据库问题。</strong></p><p id="be4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:将业务逻辑与数据访问代码解耦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/3f79993402d9f77f2440defdae79d13e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X_12PxJLBSGdaBIeC_aruw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">知识库模式</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="6253" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➏ <strong class="ak"> — </strong>战略|行为</h2><p id="427d" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">策略模式定义了一系列算法，将每个算法放在一个单独的类中，并使它们可以互换。将行为封装在单独的类中，消除了任何条件语句，并在运行时选择正确的算法(即策略)。</p><p id="944b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:一个业务规则有不同的实现，或者需要不同的算法变体。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/a1f49805e4b903d373362aee0f86b60a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JU5IDcyRleFNzPIvv-P-iA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">战略模式</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="630d" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➐ —模板法|行为</h2><p id="dae8" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">模板方法旨在从不同的过程中抽象出一个共同的过程。它定义了算法的<strong class="la iu">框架</strong>，将一些步骤推迟到子类。子类可以覆盖一些行为，但不能改变框架。</p><p id="749d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:有一组一致的步骤可以遵循，但各个步骤可能有不同的实现方式。<br/> ⭐️ <strong class="la iu">与策略模式</strong>的差异:<br/>模板:通过<strong class="la iu">子类</strong>在<strong class="la iu">编译时</strong>选择算法。<strong class="la iu"> <br/> </strong>策略:由<strong class="la iu">容器</strong>在<strong class="la iu">运行时</strong>选择算法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/af9e71200b6aca6643da52f5e11e4dfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m001ZMHTFrqF5bL0yBe3Aw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模板方法</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="0d06" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➑ —责任链|行为</h2><p id="7511" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">责任链模式建议通过启用一个或多个<strong class="la iu">处理程序</strong>来满足请求，从而避免客户端(请求的发送者)与接收者之间的耦合。这些处理程序链接成一个链，即每个处理程序都有一个对链中下一个处理程序的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/39b587702e3bf4d5696b41022bf7f4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuJn5bGmMOGDETdJ7l06lA.png"/></div></div></figure><p id="a32a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:一个以上的对象可能会处理一个请求，而处理程序(也不是序列)事先并不知道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/06400861bdb0ab3add5c065ff66ed4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WFU13YADVnaruOKDv-SOMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">责任链</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="05d7" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➒ —观察家|行为</h2><p id="9c2c" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">Observer模式(也称为Publish/Subscribe或PubSub)通过定义对象之间的一对多依赖关系，实现了简单的<strong class="la iu">广播</strong>通信，因此当一个对象经历状态变化时，它的所有依赖对象都会得到通知并自动更新。观察者有责任记录他们正在“观察”的事件。</p><p id="2a3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:当一个对象的改变需要改变其他对象，而你不知道需要改变多少个对象时。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/f00a70428d01ff0203ec27ffda82be8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ELA-CNXgpG1oKEebpNQT4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">观察者模式</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h2 id="b4aa" class="oj nf it bd ng ok ol dn nk om on dp no lh oo op nq ll oq or ns lp os ot nu ou bi translated">➓ —命令|行为</h2><p id="ee33" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">Command模式通过将两个类之间的请求转换成独立的对象来处理它们，这些对象封装了关于请求的所有信息，包括数据、方法参数、业务逻辑等。</p><p id="8517" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> —用法说明</strong>:在不知道被请求操作的内部或者请求的接收者的情况下，需要向对象发出请求。<br/> ⭐️ <strong class="la iu">注意:</strong>责任链模式可以使用命令将请求表示为对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/230ed329db3a07e3012769370af0bd41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZEhHFQkmVm8KGLAJCVU8w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">命令模式</p></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="f930" class="ne nf it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">脚注</h1><p id="f826" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">在这篇文章中，我们仅仅触及了一些设计模式的表面，但是我希望它能让你对构建软件的贡献因素有一个很好的了解，并且提升所有的能力:可扩展性、可维护性和可测试性。让应用程序设计<strong class="la iu">对变化具有弹性</strong>是交付成功解决方案的关键。</p><blockquote class="mi"><p id="0d91" class="mj mk it bd ml mm ph pi pj pk pl lt dk translated">好的设计显而易见。伟大的设计是透明的。</p></blockquote><p id="1811" class="pw-post-body-paragraph ky kz it la b lb ms ju ld le mt jx lg lh mu lj lk ll mv ln lo lp mw lr ls lt im bi translated">感谢阅读！</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="4640" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oc">我经常在媒体上写关于领导力、技术&amp;的数据——如果你想阅读我未来的帖子，请</em><a class="ae ob" href="https://medium.com/@semika" rel="noopener"><em class="oc">‘关注’我</em> </a> <em class="oc">！</em></p><div class="pm pn gp gr po pp"><a href="https://semika.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="pq ab fo"><div class="pr ab ps cl cj pt"><h2 class="bd iu gy z fp pu fr fs pv fu fw is bi translated">每当Semi Koen发布时收到电子邮件。</h2><div class="pw l"><h3 class="bd b gy z fp pu fr fs pv fu fw dk translated">每当Semi Koen发布时收到电子邮件。我经常写关于领导力、技术和数据的文章——如果你愿意的话…</h3></div><div class="px l"><p class="bd b dl z fp pu fr fs pv fu fw dk translated">semika.medium.com</p></div></div><div class="py l"><div class="pz l qa qb qc py qd ks pp"/></div></div></a></div></div></div>    
</body>
</html>