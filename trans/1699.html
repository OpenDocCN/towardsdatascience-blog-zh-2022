<html>
<head>
<title>Parsing PII for Economists — The STATA Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为经济学家解析PII——STATA方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/parsing-pii-for-economists-the-stata-way-ad9d4cc1ac37#2022-04-21">https://towardsdatascience.com/parsing-pii-for-economists-the-stata-way-ad9d4cc1ac37#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8b61" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">良好的编码实践和伪代码，用于在STATA(经济学家的常用语言)中从个人层面数据解析PII</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/249689b924d7c2fa15ef64ae669f5eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XXdxVrWfZUzid5x4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/ko-kr/photo/ipad-187041/" rel="noopener ugc nofollow" target="_blank">像素</a>的免费使用照片</p></figure><h1 id="4e62" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c6d4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在过去的两年里，我在一个经济学实验室工作，对社会科学研究领域的各种概念越来越熟悉。特别是，PII(代表个人身份信息(PII))包含在应用程序、调查和管理操作中收集的各种个人级别的数据中。当研究人员想要将不同的数据集链接在一起，并在不同的数据或时间跨度上跟踪个人的运动或活动时，PII尤其有价值。这允许在研究中进行更动态和更深入的分析。然而，PII本身是敏感的，因此需要谨慎对待。这就是为什么包含PII的数据通常会被严格的安全协议分开处理。无论如何，本文将考察一些<strong class="lt iu">的好的编码实践和伪代码，以便使用STATA——许多经济学的首选软件——解析出PII。</strong></p><h1 id="985b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用局部变量和全局变量</h1><p id="196c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">尽管STATA不是编程语言，但良好的编码实践仍然适用。使用局部变量和全局变量可以更方便地管理代码路径。假设您正在对包含您需要使用的文件的目录的文件路径进行硬编码。如果要修改路径，就必须修改使用该路径的每一行代码。这就是本地人和全球人发挥作用的地方。</p><p id="0152" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">局部变量可以是任何东西，从标量到变量，再到存储在局部内存中的变量列表和字符串。这里，本地内存意味着在脚本中定义的本地变量只在该脚本中有效。它们将无法从另一个脚本中引用。另一方面，全局变量可以被全局引用，不管它是从哪个脚本调用的。</p><p id="c1d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们假设有一个你要读入的数据集叫做“pii_data.dta”。它位于“O:/josh/data”中。您可以通过以下两种方式定义数据目录路径:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="fe34" class="mx la it mt b gy my mz l na nb">local data_dir = “O:/josh/data”</span><span id="20e4" class="mx la it mt b gy nc mz l na nb">global data_dir = “O:/josh/data”</span><span id="487f" class="mx la it mt b gy nc mz l na nb">use "`data_dir'/pii_data.dta" # read in data using local path</span><span id="72fe" class="mx la it mt b gy nc mz l na nb">use "$data_dir/pii_data.dta" # read in data using global path</span></pre><p id="d1f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意局部变量和全局变量在语法上的不同。STATA局部使用反勾号(`)和撇号(')，而全局使用美元符号($)。</p><h1 id="3b31" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">定义模式</h1><p id="c28c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在从数据中解析出PII之前，应该先定义一个“模式”。这里定义一个模式意味着确定我们将提取什么类型的PII，以及信息将存储在什么变量中。这取决于你从事的研究或项目试图从PII中得到什么。全名是否足够，还是必须分开成单独的列(例如，名、中间名、姓和后缀)?).您只对每个人的年龄感兴趣，还是对出生的具体年月日感兴趣？</p><p id="3ab7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本例中，我们将假设数据包含全名、出生日期、地址和邮政编码信息。我们将模式定义为以下变量:</p><p id="42fe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">名_名|名_中间|名_姓|名_后缀| dob_yyyy | dob_mm | dob_dd |地址_bldnum |地址_字符串|地址_城市|地址_st |地址_zip</p><h1 id="e8be" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">解析名称</h1><p id="48f8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">名字可以有许多不同的格式。在某些情况下，它只出现在一列中，每个单元格中有全名。在其他情况下，它出现在单独的列中，每个列代表全名的一部分(例如姓氏)。就我个人而言，我发现后缀很少被提取到单独的列中。不幸的是，为了增强实体解析的性能(即，如果那些观察值利用概率匹配算法共享相似的PII，则链接不同数据集中的不同数据点并给予它们相同的唯一个体标识符的过程)，具有诸如后缀的附加信息有助于将一个数据点与另一个数据点区分为两个不同的个体或实体。</p><p id="baaa" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设数据包含三个与姓名相关的列，即姓氏、名字和中间名。我们希望转换这三列，使它们符合我们的模式，该模式有四个与名称相关的列。这样做的STATA代码如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e66d" class="mx la it mt b gy my mz l na nb">gen n_last = strtrim(stritrim(lower(LASTNAME)))</span><span id="78a6" class="mx la it mt b gy nc mz l na nb">gen n_first = strtrim(strtrim(lower(FIRSTNAME)))</span><span id="3151" class="mx la it mt b gy nc mz l na nb">gen n_mid = strtrim(strtrim(lower(MIDDLENAME)))<br/></span><span id="61cf" class="mx la it mt b gy nc mz l na nb">foreach var of varlist n_* {</span><span id="8611" class="mx la it mt b gy nc mz l na nb">    replace `var’ = subinstr(`var’, “-“, “ “, .)</span><span id="74ae" class="mx la it mt b gy nc mz l na nb">    replace `var’ = strtrim(stritrim(subinstr(`var’, “.”, “”, .)))<br/></span><span id="e863" class="mx la it mt b gy nc mz l na nb">/* check for suffix */</span><span id="bb2b" class="mx la it mt b gy nc mz l na nb">    gen `var’_suff = regexs(0) if regexm(`var’, “(1|11|111|[  ]i|ii|iii|[  ]iv|[  ]v|[  ]v[i]+|jr|sr|[0-9](nd|rd|th)*)$”</span><span id="6fb4" class="mx la it mt b gy nc mz l na nb">    replace `var’ = strtrim(stritrim(subinstr(`var’, `var’_suff, “”, 1)))</span><span id="6536" class="mx la it mt b gy nc mz l na nb">}</span><span id="297a" class="mx la it mt b gy nc mz l na nb">gen suffix = “”</span><span id="fcd5" class="mx la it mt b gy nc mz l na nb">foreach var of varlist n_*_suff {</span><span id="af05" class="mx la it mt b gy nc mz l na nb">replace suffix = `var’ if missing(suffix) &amp; !missing(`var’)</span><span id="733a" class="mx la it mt b gy nc mz l na nb">}</span><span id="cebc" class="mx la it mt b gy nc mz l na nb">drop n_*_suff n_suffix</span><span id="04e6" class="mx la it mt b gy nc mz l na nb">replace name_raw = raw_name</span><span id="fdb5" class="mx la it mt b gy nc mz l na nb">replace name_first = n_first</span><span id="6c9e" class="mx la it mt b gy nc mz l na nb">replace name_middle = n_mid</span><span id="9271" class="mx la it mt b gy nc mz l na nb">replace name_last = n_last</span><span id="1de5" class="mx la it mt b gy nc mz l na nb">Replace name_suffix = suffix</span></pre><p id="a168" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">前三行很简单——它们只是清除每个name变量中的空格，并将它们复制到新生成的变量中进行处理。请注意<em class="nd"> strtrim </em>和<em class="nd"> stritrim </em>函数对于清理STATA中的字符串变量很有用。</p><p id="155c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来是for循环。它在我们刚刚创建的三个变量之间循环。</p><p id="df5b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">循环的前两行(对于每个变量…)删除了特殊字符“-”和“.”。通常建议在应用之前删除它们，因为它们会妨碍正则表达式的有效应用。</p><p id="c30c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">循环中的下一部分是利用正则表达式，这在其他编程语言中很常见。这里，我们试图获取混合到每个名称列中的任何后缀。如果后缀始终只混合在一列中就好了，但这种情况很少发生。这就是为什么我们必须遍历名字、中间名和姓氏列，以查看它们中是否存在任何后缀。欢迎来到真实世界数据的世界，这里的数据很少有一致性！正则表达式旨在获取典型的后缀，包括第二、第三、第四、jr、sr等。如果作为第一个参数输入的变量满足第二个参数中的正则表达式模式，STATA中的<em class="nd"> regexm </em>函数返回1，否则返回0。</p><h1 id="146a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">DOB解析</h1><p id="9a83" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在STATA中解析出生日期(DOB)非常简单，因为有一些定制的函数。假设DOB列是年、月和日的字符串格式(按此顺序)，我们可以很容易地解析DOB，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0f3b" class="mx la it mt b gy my mz l na nb">replace dob_yyyy = year(date(DOB, “YMD”))</span><span id="93bd" class="mx la it mt b gy nc mz l na nb">replace dob_mm = month(date(DOB, “YMD”))</span><span id="af95" class="mx la it mt b gy nc mz l na nb">replace dob_dd = day(date(DOB, “YMD”))</span></pre><p id="a86f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，date函数首先将日期字符串变量转换为date对象，year、month和day函数允许您提取日期的相关部分。如果DOB变量是非字符串格式的，那么在继续上面的代码之前，您必须将格式改为字符串。另外，请注意date函数的第二个参数是日期的格式(例如YMD，MDY…)，所以请确保您指定了正确的格式。然而，真实世界的数据通常在一列中混合了多种格式，在解析之前需要仔细检查。</p><h1 id="3791" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">解析地址</h1><p id="67ab" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">典型的地址格式如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e34e" class="mx la it mt b gy my mz l na nb">2301 County Street, Ann Arbor, MI 40000 apt 220</span></pre><p id="6cf2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它以某个街道地址开始，后面是城市、州、邮政编码和更细粒度的信息，如公寓号。如果数据包含这些不同的组件，那么将它们解析成我们之前定义的地址模式会更容易。但是假设数据在一列中带有完整的地址，那么用于解析地址信息的STATA代码如下:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ffd2" class="mx la it mt b gy my mz l na nb">gen raw_addr = ADDRESS</span><span id="1895" class="mx la it mt b gy nc mz l na nb">replace raw_addr = strtrim(stritrim(lower(raw_addr)))</span><span id="e54a" class="mx la it mt b gy nc mz l na nb">gen bldnum = strtrim(regexs(0) if regexm(raw_addr, “^([0–9]+) [ ]”)</span><span id="fb4c" class="mx la it mt b gy nc mz l na nb">gen street = strtrim(strtrim(subinstr(raw_addr, bldnum, “”, 1)))</span><span id="51fa" class="mx la it mt b gy nc mz l na nb">replace ZIP = “” if ZIP == “0” # zipcodes that are just 0 are probably missing zipcodes that have been filled in with 0s by the agency</span><span id="e11f" class="mx la it mt b gy nc mz l na nb">replace addr_raw = raw_addr</span><span id="29cf" class="mx la it mt b gy nc mz l na nb">replace addr_bldnum = bldnum</span><span id="c02f" class="mx la it mt b gy nc mz l na nb">Replace addr_str = street</span><span id="d8a7" class="mx la it mt b gy nc mz l na nb">Replace addr_str = substr(addr_str, 1,5)</span><span id="075c" class="mx la it mt b gy nc mz l na nb">Replace addr_city = strtrim(stritrim(lower(CITY)))</span><span id="c642" class="mx la it mt b gy nc mz l na nb">Replace addr_st = strtrim(stritrim(lower(STATE)))</span><span id="e639" class="mx la it mt b gy nc mz l na nb">Replace addr_zip = ZIP</span></pre><p id="be8c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">与名称解析类似，我们也利用正则表达式来解析地址。STATA的正则表达式模式和语法几乎类似于任何其他编程语言中使用的正则表达式，因此请参考Python <a class="ae ky" href="https://docs.python.org/3/howto/regex.html" rel="noopener ugc nofollow" target="_blank">文档</a>中的正则表达式以深入了解它。</p><p id="9ab7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">希望这有所帮助！以后请考虑关注我更多的文章！</p><h1 id="7bff" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关于作者</h1><p id="85a0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="nd">数据科学家。在密歇根大学刑事司法行政记录系统(CJARS)经济学实验室担任副研究员。Spotify前数据科学实习生。Inc .(纽约市)。即将入学的信息学博士生。他喜欢运动，健身，烹饪美味的亚洲食物，看kdramas和制作/表演音乐，最重要的是崇拜耶稣基督。结账他的</em> <a class="ae ky" href="http://seungjun-data-science.github.io" rel="noopener ugc nofollow" target="_blank"> <em class="nd">网站</em> </a> <em class="nd">！</em></p></div></div>    
</body>
</html>