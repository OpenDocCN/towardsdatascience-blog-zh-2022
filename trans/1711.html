<html>
<head>
<title>If You Are Using Python and Google Cloud Platform, This Will Simplify Life for You (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果您正在使用Python和Google云平台，这将简化您的生活(第2部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/if-you-are-using-python-and-google-cloud-platform-this-will-simplify-life-for-you-part-2-bef56354fd4c#2022-04-22">https://towardsdatascience.com/if-you-are-using-python-and-google-cloud-platform-this-will-simplify-life-for-you-part-2-bef56354fd4c#2022-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="774f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用工件注册表管理您的私有包，并将其导入Cloud Composer DAGs</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a36e839b53f318ddff115c1b47677d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R2dIqGQBFhp8wdOd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Max van den Oetelaar 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在专业环境中使用python，我可以告诉您，您已经在寻找一种在私有存储库中部署Python包的方法。好吧，让我来介绍一下<a class="ae kv" href="https://cloud.google.com/artifact-registry" rel="noopener ugc nofollow" target="_blank">工件注册</a>，这是<a class="ae kv" href="https://cloud.google.com/" rel="noopener ugc nofollow" target="_blank">谷歌云平台</a>的工件管理服务，可能正是你所需要的。</p><h2 id="259a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">工件注册解决的3个问题</h2><p id="2784" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设你有一个python类(比如一个日志类)，它被一个气流<a class="ae kv" href="https://airflow.apache.org/docs/apache-airflow/stable/concepts/dags.html" rel="noopener ugc nofollow" target="_blank">有向无环图</a> (DAG)和一个<a class="ae kv" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云函数</a>使用。</p><p id="31fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">实施DRY原则</strong>:如果没有一个管理python包的解决方案，您最终会将python类与Airflow DAG一起部署，也就是说，您必须将python类复制到DAG文件夹中。</p><p id="c9f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，您需要部署与云函数打包在一起的python类，复制相同的代码片段。工件注册库使您能够通过将python类部署到一个库中，并从该库中从Airflow DAG和Cloud函数中提取，来执行非常重要的DRY(不要重复自己)原则。当您需要修改或修复python类中的任何bug时，这为您提供了一个单一的地方。</p><p id="2463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">部署安全版本</strong> : <strong class="ky ir"> </strong>每次您对python类进行更改时，都存在破坏气流DAG和/或云函数的风险。我们称之为<strong class="ky ir">回归</strong>。虽然有可能用非回归测试来降低破坏东西的风险，但是这些测试通常是不够的。此外，您会希望用python类的工作版本来精确定位每个版本。精彩！Python工件注册库允许您这样做。</p><p id="14f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">管理对包的访问</strong> : <strong class="ky ir"> </strong>如果你不在乎隐私，也就是说，如果你不介意你的python包被世界上任何人看到和使用，我鼓励你把它们放在<a class="ae kv" href="https://pypi.org/" rel="noopener ugc nofollow" target="_blank">公共python库</a>。但是如果您需要控制谁查看您的包，正如在专业环境中经常出现的情况，工件注册库是一个很好的工具，因为它使您能够只与选定的人共享您的库。</p><p id="4a78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">说够了！让我们构建一个python工件注册库，在里面部署一些东西，并尝试从一个Airflow DAG中拉出这个库。</p><p id="ad20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要的是将私有python包安装到<a class="ae kv" href="https://cloud.google.com/functions" rel="noopener ugc nofollow" target="_blank">云函数</a>或者<a class="ae kv" href="https://cloud.google.com/run" rel="noopener ugc nofollow" target="_blank">云运行</a>，敬请参考<a class="ae kv" rel="noopener" target="_blank" href="/if-you-are-using-python-and-google-cloud-platform-this-will-simplify-life-for-you-6be4f777fa3a">这篇文章</a>。</p><h2 id="d1d8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">为您的包创建一个存储库</h2><p id="d246" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">假设您可以访问<a class="ae kv" href="https://cloud.google.com/resource-manager/docs/creating-managing-projects" rel="noopener ugc nofollow" target="_blank"> GCP项目</a>和<a class="ae kv" href="https://cloud.google.com/shell" rel="noopener ugc nofollow" target="_blank">云外壳</a>，为python包创建一个存储库是很简单的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><ul class=""><li id="3271" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><em class="nb">&lt;your _ repository _ name&gt;是您想要给python库</em>起的名字</li><li id="d2af" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr mx my mz na bi translated"><em class="nb"> &lt;您的存储库位置&gt;是存储库的位置。类似于“美国-中部1”或“欧洲-西部1”的内容</em></li><li id="4ad7" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr mx my mz na bi translated"><em class="nb">&lt;your _ repository _ description&gt;是描述存储库</em>的用法或效用的文本</li></ul><h2 id="555b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">部署简单的Python包</h2><p id="26c6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在我们的存储库已经创建好了，让我们在其中部署一个玩具python包。我们将使用一个包含计算两点间<a class="ae kv" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank">哈弗线距离</a>的函数的库。图书馆可以在这里找到<a class="ae kv" href="https://gitlab.com/marcdjoh/sample-python-package" rel="noopener ugc nofollow" target="_blank"/>。这是您将库部署到先前创建的工件注册库的方式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="83b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在克隆了样例包存储库之后，我们构建了一个轮子，并使用python库<strong class="ky ir"><em class="nb">‘twine’</em></strong>将轮子上传到工件注册库。</p><p id="c786" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们是如何使用<strong class="ky ir"><em class="nb">【g cloud auth】</em></strong>对gcp账户进行认证的。该过程还在本地保存认证凭证，然后由<strong class="ky ir"><em class="nb">【twine】</em></strong>在上传到工件注册表时使用。</p><h2 id="3ffa" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">部署一个简单的气流DAG，它来自私有Python包</h2><p id="f704" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在GCP构建DAG的最快方法是创建一个Cloud Composer环境。这是一个漫长的过程(创建环境需要20分钟左右)，涉及许多操作，包括在<a class="ae kv" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">Google Kubernetes Engine</a>(GKE)集群中启动大量资源，以及部署<a class="ae kv" href="https://cloud.google.com/sql" rel="noopener ugc nofollow" target="_blank"> Cloud SQL </a> Postgres实例。以下命令实际上创建了一个服务帐户，并在GKE集群上安装了Airflow。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="99f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于Airflow现在已经启动并运行，我们可以继续安装私有的python包了，这个包已经在工件注册表中进行了推送。为此，我们需要做两件事。</p><ul class=""><li id="f0ed" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><strong class="ky ir">向Cloud Composer提供python存储库url </strong></li></ul><p id="2775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过运行<strong class="ky ir"> <em class="nb"> gcloud工件打印-设置</em> </strong>命令来获取这些信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="3fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令的输出应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/51eabb82458fa38cc78bd4934f27e25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R5T_hGeSfCR_3vtarYJC3g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复制名为pip.conf的文件中的最后两行，并将该文件上传到文件夹<strong class="ky ir"> config/pip </strong>中的Cloud Composer bucket中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><ul class=""><li id="5cdd" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated"><strong class="ky ir">安装私有python包</strong></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4975" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<strong class="ky ir"><em class="nb">update-pypi-package</em></strong>选项，并提供要安装的软件包的名称和版本。</p><p id="1245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几分钟后…</p><p id="7c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">不起作用……</strong></p><p id="adf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该得到一条错误消息，指出安装pypi包失败了。</p><p id="d8bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，让我们来揭开这到底是怎么回事。当我们运行带有<strong class="ky ir"><em class="nb">update-pypi-package</em></strong>选项的<strong class="ky ir"><em class="nb">g cloud composer environments update</em></strong>命令时，会触发一个<a class="ae kv" href="https://cloud.google.com/build" rel="noopener ugc nofollow" target="_blank"> Cloud Build </a>实例，并尝试构建一个安装了python包的自定义Cloud Composer映像。在发出更新命令后不到5分钟，这个构建就会出现在构建历史中(在云控制台中)。</p><p id="a7e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建包括11个步骤(至少在本文使用的Composer版本中是这样的——Composer-1 . 17 . 8-air flow-2 . 1 . 4 ),它在第7步失败，在这一步它试图安装私有python包。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/04673f0a7f2c7dfa3b859e60b5fc3c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YUFbvSoqZvDBwdRZMh2LvQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通读错误堆栈指出了问题的根本原因。实际上，构建很难验证工件注册。嗯，这不是我所期望的，因为构建服务帐户拥有读取工件注册表的权限。</p><h2 id="f4a6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">为云构建提供身份认证密钥</h2><p id="11fc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在一些测试和学习迭代以及通读工件注册表<a class="ae kv" href="https://cloud.google.com/artifact-registry/docs/python/authentication" rel="noopener ugc nofollow" target="_blank">文档</a>之后，我发现了一个解决方案，它包括在我们之前创建的pip.conf文件中包含一个服务帐户密钥。这不符合安全最佳实践，显然看起来像是一种变通方法。然而，在撰写本文时，这是让Cloud Composer从任何工件注册库安装包的唯一方法。</p><p id="e145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要做到这一点，服务帐户应该拥有从工件注册中心读取的权限。请遵循以下7个步骤:</p><ol class=""><li id="c34f" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr nj my mz na bi translated">创建一个服务帐户(或者使用一个现有的帐户),并赋予它工件注册阅读器角色</li><li id="a005" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr nj my mz na bi translated">使用服务帐户创建一个json服务帐户密钥</li><li id="ff1f" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr nj my mz na bi translated">用<strong class="ky ir"> <em class="nb"> gcloud工件打印-设置</em> </strong>命令生成私有python库url。这一次，<strong class="ky ir">使用json-key选项并提供服务帐户密钥的路径</strong></li><li id="140c" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr nj my mz na bi translated">验证新生成的extra-index-url是否嵌入了服务帐户json密钥，即url应该看起来像<code class="fe nk nl nm nn b"><strong class="ky ir"><em class="nb">https://_json_key_base64:&lt;KEY&gt;@&lt;LOCATION&gt;-python.pkg.dev/&lt;PROJECT&gt;/&lt;REPOSITORY&gt;/simple/</em></strong></code>，其中&lt;密钥&gt;是嵌入的服务帐户密钥</li><li id="a8c7" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr nj my mz na bi translated">用新生成的url ( - extra-index-url)替换pip文件的内容</li><li id="be37" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr nj my mz na bi translated">将修改后的pip.conf复制到Cloud Composer bucket中</li><li id="730b" class="ms mt iq ky b kz nc lc nd lf ne lj nf ln ng lr nj my mz na bi translated">运行软件包安装命令</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="46dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几分钟后… <strong class="ky ir">它开始工作了</strong></p><p id="3859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后要做的事情是通过将<em class="nb"> dag.py </em>文件复制到Cloud Composer bucket中来部署DAG。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="b7aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DAG只包含一个任务，除了打印(1，2)和(3，4)之间的<a class="ae kv" href="https://en.wikipedia.org/wiki/Haversine_formula" rel="noopener ugc nofollow" target="_blank">哈弗线距离</a>之外什么也不做。距离的计算是通过从工件注册中心导入私有python包— <em class="nb"> mypythonlib </em>来完成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h1 id="7da4" class="no lt iq bd lu np nq nr lx ns nt nu ma jw nv jx md jz nw ka mg kc nx kd mj ny bi translated">结束注释</h1><p id="045d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在pip配置文件中嵌入服务帐户密钥看起来更像是补偿Cloud Composer实现缺陷的一种解决方法。Cloud Composer团队有一个未解决的<a class="ae kv" href="https://issuetracker.google.com/issues/204418653?pli=1" rel="noopener ugc nofollow" target="_blank">问题</a>,即让工件注册中心的认证更直接地依赖于IAM角色。</p><p id="e683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢你的时间。请在这里找到示例python包<a class="ae kv" href="https://gitlab.com/marcdjoh/sample-python-package" rel="noopener ugc nofollow" target="_blank">的代码，在这里</a>找到气流DAG <a class="ae kv" href="https://gitlab.com/marcdjoh/airflow-dag-pull-from-artifact-registry" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="8b9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">直到下一次写作，拜拜。</p></div></div>    
</body>
</html>