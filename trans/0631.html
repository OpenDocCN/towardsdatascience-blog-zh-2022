<html>
<head>
<title>Overview on apply, map, applymap, iterrows &amp; itertuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用、映射、应用映射、iterrows 和 itertuples 概述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/overview-on-apply-map-applymap-iterrows-itertuples-df752a11f451#2022-02-25">https://towardsdatascience.com/overview-on-apply-map-applymap-iterrows-itertuples-df752a11f451#2022-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c654" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">附有示例的实用指南</h2></div><p id="a753" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">数据清理和特征工程在处理数据时是必不可少的。我最近回顾了一些过去的个人项目，并对它们进行了重构或继续构建。其中之一是 iaito 订单细节的可视化。合气道是模仿武士刀来学习合气道的。iaito 的制造属于高混合小批量制造类别，因为在我们的情况下，每个 iaito 都是为所有者定制的(即按订单生产)。</p><div class="ln lo gp gr lp lq"><a rel="noopener follow" target="_blank" href="/data-visualization-using-matplotlib-seaborn-97f788f18084"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd iu gy z fp lv fr fs lw fu fw is bi translated">使用 Matplotlib 和 Seaborn 实现数据可视化</h2><div class="lx l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">towardsdatascience.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md me lq"/></div></div></a></div><p id="ae2b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在 2012 年开始构建数据集，同时帮助 iaidoka 成员翻译 iaito 订单细节。每个记录包含每个所有者的 iaito 零件规格。出于隐私考虑，诸如所有者的全名和地址等敏感信息永远不会在数据集中捕获。</p><p id="8247" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，使用数据集的更新版本，我们将浏览几个常见的数据操作用例以及可能不太明显的注意事项。涵盖的操作概述如下:</p><ul class=""><li id="2f41" class="mf mg it kk b kl km ko kp kr mh kv mi kz mj ld mk ml mm mn bi translated">应用</li><li id="c09a" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">地图</li><li id="c51d" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">应用地图</li><li id="c4b0" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">for 循环</li><li id="15ba" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">iterrows</li><li id="5ce0" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">迭代元组</li><li id="df19" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">…向量化…</li><li id="985d" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">词典</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="50ef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将进行通常的库导入，检查数据框并进行一些基本的数据清理。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c1e9" class="nj nk it nf b gy nl nm l nn no"># import libraries<br/>import pandas as pd<br/>import numpy as np<br/>import re<br/>pd.set_option('display.max_columns', None)</span><span id="7b73" class="nj nk it nf b gy np nm l nn no"># load the dataset<br/>df = pd.read_excel('project_nanato2022_Part1.xlsx')<br/>print(f'df rows: {df.shape[0]}, df columns: {df.shape[1]}')<br/>df.head(1)</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nq"><img src="../Images/c67212e848829ac57f76fd85b238c246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qdLnfhKbMTrB1h9vkrDX5A.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">导入的数据框|按作者分类的影像</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="fe1e" class="nj nk it nf b gy nl nm l nn no"># Check for null or missing values<br/>df.isnull().sum()[df.isnull().sum()&gt;0]</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/4602538c2c3f5f170f93166c7bfd63e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*Qxy43KXckIBozrQCQANLDA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">有 44 个空值的列|作者图片</p></figure><p id="b5ad" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">包含空值的列…？没什么大不了的。检查数据总是好的做法。看来<code class="fe oc od oe nf b">unnamed column</code>号是多余的，可以安全丢弃。尽早丢弃或输入空值(如果可以的话)有助于简化数据清理过程&amp;减少内存使用。</p><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/a6df546503c984e0c8c182b7b22ea9a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*zK6G_E6BfuieJ1IEMfq8ZQ.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">在删除未命名的列|按作者排序的图像之前</p></figure><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/1cde766fa123f24c61b0ff07c0baa821.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*a0IkKICUQwkrA_fxJs4kaA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">删除未命名的列|作者的图像后</p></figure><p id="b822" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，列标题被重命名，详细信息可在笔记本中找到。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="ae97" class="nj nk it bd oh oi oj dn ok ol om dp on kr oo op oq kv or os ot kz ou ov ow ox bi translated">用例#1</h2><p id="207b" class="pw-post-body-paragraph ki kj it kk b kl oy ju kn ko oz jx kq kr pa kt ku kv pb kx ky kz pc lb lc ld im bi translated">我们将从一个简单的用例开始——计算所有者姓名的字符长度。实际上，这可以推导出广告文本的长度等。本质上，这是从现有的数据列派生出一个新的数据列。我们将通过这个用例的<code class="fe oc od oe nf b">apply</code>、<code class="fe oc od oe nf b">map</code>、<code class="fe oc od oe nf b">applymap</code>和<code class="fe oc od oe nf b">for</code>循环。我们还将对每个实现进行计时，以便进行比较。使用<code class="fe oc od oe nf b">timeit</code>，循环次数保持在 100 次。</p><p id="864b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从文档中更好地了解操作。在<code class="fe oc od oe nf b">apply</code>的情况下，它描述了一个函数沿着数据帧的一个轴的应用，其中一系列对象被传递给该函数。<code class="fe oc od oe nf b">map</code>用另一个值替换系列值。<code class="fe oc od oe nf b">mapapply</code>对 DataFrame 的元素应用一个函数-输入需要的数据帧；在我们浏览这些例子的时候，需要记住一些事情。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="017f" class="nj nk it nf b gy nl nm l nn no"># apply<br/>%timeit -n100 df['name_L1'] = df['owner'].apply(lambda x: len(x))</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/281f73ab26f0883c0056bcbfcd3281af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*BvDtNZAFElTtnhBoS6rnvQ.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">按作者应用计算时间|图像</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="04b2" class="nj nk it nf b gy nl nm l nn no"># map<br/>%timeit -n100 df['name_L2'] = df['owner'].map(lambda x: len(x))</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/016d29f0263c1e144a39a3cfd9b84351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ro1EpRRQuIGy931myJJqiA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">地图计算时间|作者图片</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="bab6" class="nj nk it nf b gy nl nm l nn no"># applymap - applies to elementwise, so pass in a dataframe<br/>%timeit -n100 df['name_L3'] = df[['owner']].applymap(lambda x: len(x))</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/3739e2057797d3154e33f6ce598ba9da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*luX_E8T0gDGq71yle7O3sA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">应用地图计算时间|作者图片</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a2c1" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># for loop<br/>t_name = []<br/>for ele in df['owner']:<br/>    t_name.append(len(ele))<br/>df['name_L4'] = t_name</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/de9ee3fc83a33689d03a41bb1fdb12bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*raWW6yepXBnVVRHP12c2PA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">for 循环计算时间|作者图片</p></figure><p id="f3e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据使用情况，里程和最佳操作会有所不同。对于上面的用例，无论是<code class="fe oc od oe nf b">for</code>循环还是<code class="fe oc od oe nf b">map</code>都足够了，尽管前者更加冗长。我们<em class="ph">也许</em>可以摆脱<code class="fe oc od oe nf b">apply</code>，但是在处理更大的数据集(例如，数百万条记录)时，它无法伸缩。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="7eca" class="nj nk it bd oh oi oj dn ok ol om dp on kr oo op oq kv or os ot kz ou ov ow ox bi translated">用例 2</h2><p id="caf4" class="pw-post-body-paragraph ki kj it kk b kl oy ju kn ko oz jx kq kr pa kt ku kv pb kx ky kz pc lb lc ld im bi translated">对于下一个用例，weight 列由 iaito 的预期重量范围组成。我们使用<code class="fe oc od oe nf b">for</code>循环和<code class="fe oc od oe nf b">apply</code>将值提取到两个新的单独的列中。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="9f9e" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># for loops and splitting of strings<br/>w_lower1, w_upper1 = [], []<br/>for weight in df['weight_(g)']:<br/>    w_lower1.append(weight.split('-')[0])<br/>    w_upper1.append(weight.split('-')[1])<br/>df['w_lower1(g)'] = w_lower1<br/>df['w_upper1(g)'] = w_upper1</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/674d3c32256ca310a6ccb12e74e8db21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*tmEerR_p8BJSSHDMabZYbg.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">for 循环计算时间|作者图片</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="91f0" class="nj nk it nf b gy nl nm l nn no"># helper function to split weight column<br/>def splitter(row):<br/>    return [row.str.split('-')[0][0],  row.str.split('-')[0][1],]</span><span id="4bb8" class="nj nk it nf b gy np nm l nn no">%%timeit -n100<br/># .apply result_type='expand' creates a dataframe<br/>frame = df[['weight_(g)']].apply(splitter, axis=1, result_type='expand')<br/>frame.rename(columns={0:'w_lower2(g)',<br/>                      1:'w_upper2(g)',<br/>                     },inplace=True)<br/>df[frame.columns] = frame</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/6d9343ba814a4ef3f6c1b431fb405e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*Qm9UPeb6E3E_D9rhqaAaJw.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">按作者应用计算时间|图像</p></figure><p id="f976" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于<code class="fe oc od oe nf b">apply</code>实施，实施轴必须为 1，才能使用<code class="fe oc od oe nf b">result_type</code>。在上面的例子中，用<code class="fe oc od oe nf b">expand</code>返回一个新的数据帧。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="9796" class="nj nk it bd oh oi oj dn ok ol om dp on kr oo op oq kv or os ot kz ou ov ow ox bi translated">用例#3</h2><p id="fbd1" class="pw-post-body-paragraph ki kj it kk b kl oy ju kn ko oz jx kq kr pa kt ku kv pb kx ky kz pc lb lc ld im bi translated">对于第三个也是最后一个例子，我们将创建一个新的 name 列，标题后面跟着所有者的姓名。我们可以从性别一栏推断出标题。我们将经历这些操作:</p><ul class=""><li id="185f" class="mf mg it kk b kl km ko kp kr mh kv mi kz mj ld mk ml mm mn bi translated"><code class="fe oc od oe nf b">for</code>循环</li><li id="161b" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><code class="fe oc od oe nf b">iterrows</code></li><li id="9c89" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><code class="fe oc od oe nf b">itertuples</code></li><li id="e7c9" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">列表理解+ <code class="fe oc od oe nf b">apply</code></li><li id="1dc1" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">…向量化…</li><li id="01a7" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld mk ml mm mn bi translated">词典</li></ul><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="07ce" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># for loop<br/>res = []<br/>for i in range(len(df['gender'])):    <br/>    if df['gender'][i] == 'M':<br/>        res.append('Mr. ' + df['owner'][i])<br/>    else:<br/>        res.append('Ms. ' + df['owner'][i])<br/>df['name1'] = res</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5b87d33173d5f1444f519d49142f8a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*CPyu8WDk0QiRMhuSlLdQjg.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">for 循环计算时间|作者图片</p></figure><p id="fc77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oc od oe nf b">iterrows</code>顾名思义，遍历数据框行。它是作为一个索引序列对来实现的。让我们休息一下，然后再仔细检查一下。</p><figure class="na nb nc nd gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi pl"><img src="../Images/91f08789a641a34b245c0c114774f753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uh-xUoyjX-SWun3T"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">布莱恩·麦高恩在<a class="ae pm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="770b" class="nj nk it nf b gy nl nm l nn no"># cap at the 1st data record<br/>for ele in df[['owner', 'gender']].iloc[:1].iterrows():<br/>    print(ele,'\n')<br/>    print(f"index\n{ele[0]}",'\n')<br/>    print(f"series\n{ele[1]}",'\n')</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/275106b3038ef760902e2568af78ea23.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*toOJ6IasqihMTr1BQ63VpA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">iterrows 对象|作者图片</p></figure><p id="dfae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">列标题构成了系列的索引。对 iterrows 如何工作有了更好的理解，我们可以这样继续:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="7c36" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># iterrows implementation<br/>res = []<br/>for ele in df[['owner', 'gender']].iterrows():<br/>    if ele[1][1] == 'M':<br/>        res.append('Mr. ' + ele[1][0])<br/>    else:<br/>        res.append('Ms. ' + ele[1][0])<br/>df['name2'] = res</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/e8f006d2fce7bf62830d11f93e00483d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*JNggK8ptr31iFIG2CZzCJg.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">iterrows 按作者计算时间|图像</p></figure><p id="f336" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe oc od oe nf b">itertuples</code>以命名元组的形式遍历数据帧。关闭默认的<code class="fe oc od oe nf b">index</code>会将第一列的值移入索引。它比<code class="fe oc od oe nf b">iterrows</code>还要快。让我们仔细看看。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="1fe4" class="nj nk it nf b gy nl nm l nn no"># cap at 1st record, default index on<br/>for ele in df[['owner', 'gender']].iloc[:1].itertuples():<br/>    print(f"index\n{ele[0]}")<br/>    print(f"tuples\n{ele[1], ele[2]}")</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi po"><img src="../Images/a482754b5dfdcbd778ad01825dbce63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*XkJg34dAuypPWeDqiFhY0g.png"/></div></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">itertuples #1 |作者图片</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f487" class="nj nk it nf b gy nl nm l nn no"># cap at first record, index off<br/>for ele in df[['owner', 'gender']].iloc[:1].itertuples(index=False):<br/>    print(f"index\n{ele[0]}")<br/>    print(f"tuples\n{ele[1]}")</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/269a966674107b63500c081764824ad4.png" data-original-src="https://miro.medium.com/v2/resize:fit:222/format:webp/1*2ekzTmBpSb4GW-rAVa2PVg.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">itertuples #2 |作者图片</p></figure><p id="5306" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">综上所述，itertuples 实现类似，但速度更快，如下图所示。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="cc66" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/>res = []<br/># itertuples implementation<br/>for ele in df[['owner', 'gender']].itertuples(index=False):<br/>    if ele[1] == 'M':<br/>        res.append('Mr. ' + ele[0])<br/>    else:<br/>        res.append('Ms. ' + ele[0])<br/>df['name3'] = res</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/a9c8685449941ea2cb7f7fb3425e7451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*sbjCd9nrzS14NuaRNCmTOA.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">itertuples 按作者计算时间|图像</p></figure><p id="ce70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">列表理解和应用的结合也是一种备选解决方案，只是没有那么有效。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="dd7a" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># combination of list comprehension and apply<br/>title_ = ['Mr. ' if x == 'M' else 'Ms. ' for x in df['gender'] ]<br/>df['t'] = title_<br/>def name_(row):<br/>    return row['t'] + row['owner']<br/>df['name4'] = df.apply(name_,axis=1)</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/a15fdb904650eb4acf06e2161ef2531b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*QL2q6FNZSpJttJjiEiSxQQ.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">按作者列出理解和应用计算时间|图片</p></figure><p id="26e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，向量指令。在本节中，我们将探索通过代码矢量化进行优化。所以比较的是标量(非矢量)指令和矢量指令。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="209b" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># vectorization<br/>arr1 = df['owner'].array<br/>arr2 = df['gender'].array<br/>arr3 = []<br/>for i in range(len(arr1)):<br/>    if arr2[i] == 'M':<br/>        arr3.append('Mr. ' + arr1[i])<br/>    else:<br/>        arr3.append('Ms. ' + arr1[i])<br/>df['name5'] = arr3</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/dd74370830bddb926e6cb8164426919d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*gbBuyLcuJ74kl8NQkNdI5A.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">向量指令计算时间|作者图片</p></figure><p id="0290" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，可以将数据框转换成字典。我们还可以将数据框转换成字典，然后对其进行处理。但是，对于字典来说，一定要注意人们可能希望如何转换键-值对。如果忽略这一点，意外的结果可能会令人惊讶。我们将通过两个例子:1。使用<code class="fe oc od oe nf b">list</code>作为<code class="fe oc od oe nf b">orient</code>参数来完成工作。默认<code class="fe oc od oe nf b">dict</code>输入。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="d1cb" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># create dictionary from subset of data<br/>df_dict = df.to_dict('list')</span><span id="3f9e" class="nj nk it nf b gy np nm l nn no">name_list = []<br/>for idx in range(len(df_dict['gender'])):<br/>    if  df_dict['gender'][idx] == 'M':<br/>        name_list.append( 'Mr. ' + str(df_dict['owner'][idx]) )<br/>    else:<br/>        name_list.append( 'Ms. ' + str(df_dict['owner'][idx]) )<br/>df_dict['name6'] = name_list</span><span id="d787" class="nj nk it nf b gy np nm l nn no"># convert dictionary back to dataframe<br/>df_new = pd.DataFrame.from_dict(df_dict)</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/9cbfb74fa9cc2a55649e68fa141fd154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*qguE3lGH6O8Bn9zHN8v3UQ.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">计算字典列表操作的时间</p></figure><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e483" class="nj nk it nf b gy nl nm l nn no">%%timeit -n100<br/># create dictionary from data<br/>df_dict2 = df.to_dict()<br/>df_dict2['name7'] = {}<br/>for idx in range(len(df_dict2['gender'])):<br/>    if  df_dict2['gender'][idx] == 'M':<br/>        df_dict2['name7'][idx] =  'Mr. ' + str(df_dict['owner'][idx]) <br/>    else:<br/>        df_dict2['name7'][idx] =  'Ms. ' + str(df_dict['owner'][idx])</span><span id="f093" class="nj nk it nf b gy np nm l nn no"># convert dictionary back to dataframe<br/># separated to deconflict with timeit <br/>df_new2 = pd.DataFrame.from_dict(df_dict2)</span></pre><figure class="na nb nc nd gt nr gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/f4d3a67eca956bacf5067aca455f87ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*HjBpu8iWWrhGAVOqdVJPcw.png"/></div><p class="nx ny gj gh gi nz oa bd b be z dk translated">计算字典操作的时间</p></figure><h2 id="7645" class="nj nk it bd oh oi oj dn ok ol om dp on kr oo op oq kv or os ot kz ou ov ow ox bi translated">结论</h2><p id="b712" class="pw-post-body-paragraph ki kj it kk b kl oy ju kn ko oz jx kq kr pa kt ku kv pb kx ky kz pc lb lc ld im bi translated">恭喜你！你坚持到了文章的结尾。我们已经讨论了<code class="fe oc od oe nf b">apply</code>、<code class="fe oc od oe nf b">map</code>、<code class="fe oc od oe nf b">applymap</code>、<code class="fe oc od oe nf b">for</code>循环、<code class="fe oc od oe nf b">iterrows</code>、<code class="fe oc od oe nf b">itertuples</code>、向量化指令、字典。最佳操作和里程取决于用例，但总的来说，我们可以看到一些操作比其他操作更有效，这肯定是生产级代码的考虑因素之一。</p><p id="cd26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据集和笔记本可以分别在<a class="ae pm" href="https://github.com/AngShengJun/petProj/blob/master/proj_nanato/project_nanato2022_Part1.xlsx" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae pm" href="https://github.com/AngShengJun/petProj/blob/master/proj_nanato/1_Overview%20on%20apply%2C%20map%2C%20applymap%2C%20iterrows%20%26%20itertuples_2022Feb.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>访问，以供参考和个人使用。如果您想将数据集用于您自己的项目，请指明适当的认证。</p><p id="f613" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">暂时就这样了。感谢阅读。</p><h2 id="5df3" class="nj nk it bd oh oi oj dn ok ol om dp on kr oo op oq kv or os ot kz ou ov ow ox bi translated">2022 年 2 月 27 日更新:</h2><ol class=""><li id="8580" class="mf mg it kk b kl oy ko oz kr pt kv pu kz pv ld pw ml mm mn bi translated">添加了关于数据集所有权和权限的说明。</li><li id="52c1" class="mf mg it kk b kl mo ko mp kr mq kv mr kz ms ld pw ml mm mn bi translated">添加字典操作</li></ol></div></div>    
</body>
</html>