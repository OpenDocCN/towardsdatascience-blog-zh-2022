<html>
<head>
<title>An Overview of QuickSort Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速排序算法综述</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-overview-of-quicksort-algorithm-b9144e314a72#2022-03-10">https://towardsdatascience.com/an-overview-of-quicksort-algorithm-b9144e314a72#2022-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e82d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">排序是以结构化的方式组织元素的过程。Quicksort 是最流行的排序算法之一，它在典型情况下使用<code class="fe kl km kn ko b">nlogn</code>比较来对 n 个元素的数组进行排序。快速排序基于<strong class="jp ir">分治策略。</strong>我们将在本教程中看看快速排序算法，看看它是如何工作的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/0d3480f0bb5597b06ceaae16f8c5d8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/0*UhtvKDTP7-srp75V"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">快速排序算法概述|作者图片</p></figure><h1 id="a294" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">快速排序的想法</h1><p id="0cbc" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">快速排序是一种快速排序算法，它通过将一个大的数据数组拆分成更小的子数组来工作。<strong class="jp ir">这意味着每一次迭代都是通过将输入分成两个部分，对它们进行排序，然后再重新组合来实现的。</strong>对于大型数据集，该技术非常高效，因为其平均和最佳情况的复杂度为<code class="fe kl km kn ko b">O(n*logn).</code></p><p id="fdfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是由东尼·霍尔在 1961 年创建的，至今仍是最有效的通用排序算法之一。它的工作方式是递归地将子列表排序到给定中枢的任一侧，并围绕该中枢动态地移动列表中的元素。</p><p id="a8ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，快速排序方法可以概括为三个步骤:</p><ul class=""><li id="2e20" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated"><strong class="jp ir">选择:</strong>选择一个元素。</li><li id="b404" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir"> Divide: </strong>拆分习题集，将较小的部分移到枢轴的左边，将较大的项目移到右边。</li><li id="ab8c" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">重复合并:</strong>重复上述步骤，合并之前已经排序的数组。</li></ul><h2 id="cd70" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated">快速排序的优势</h2><p id="44a1" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们来了解一下使用快速排序的几个主要好处:</p><ul class=""><li id="38ae" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">它工作迅速有效。</li><li id="8486" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">与其他排序算法相比，它具有最好的时间复杂度。</li><li id="986a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">快速排序的空间复杂度为<code class="fe kl km kn ko b">O(logn)</code>，对于空间有限的情况，这是一个很好的选择。</li></ul><h2 id="290b" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated">快速排序的局限性</h2><p id="9297" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">尽管快速排序是最快的算法，但它也有一些缺点。让我们来看看快速排序的一些缺点。</p><ul class=""><li id="1e1f" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">这种排序技术被认为是不稳定的，因为它不能保持键值对的初始顺序。</li><li id="29a8" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">当枢轴元素最大或最小时，或者当所有组件具有相同的尺寸时。快速排序的性能会受到这些最坏情况的显著影响。</li><li id="00fe" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">这很难实现，因为这是一个递归过程，尤其是在递归不可用的情况下。</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="7137" class="lb lc iq bd ld le nl lg lh li nm lk ll lm nn lo lp lq no ls lt lu np lw lx ly bi translated">运行中的快速排序算法</h1><p id="32e8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们通过一个例子来更好地理解快速排序算法。在本例中，数组<em class="nq">(如下图所示)</em>包含未排序的值，我们将使用 Quicksort 对其进行排序。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/3dcb67da0628d9b42d975eaf870ff1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QIWKneBcRWh7NkHI"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">未排序和排序的数组|按作者排序的图像</p></figure><h2 id="d1a3" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated"><strong class="ak"> 1)。选择枢轴</strong></h2><p id="e0b4" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">该过程从从列表中选择<strong class="jp ir">一个元素(称为枢纽)</strong>开始；这可以是任何元素。枢轴可以是:</p><ul class=""><li id="648e" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">任意元素</li><li id="a7b4" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">第一个或最后一个元素</li><li id="bee3" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">中间分子</li></ul><p id="22e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我们将使用最后一个元素<code class="fe kl km kn ko b">4,</code>作为我们的枢纽。</p><h2 id="9dad" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated"><strong class="ak"> 2)。重新排列阵列</strong></h2><p id="7c6e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">现在，这里的目标是重新排列列表，使得所有小于枢轴的元素都朝向它的左边，所有大于枢轴的元素都朝向它的右边。</p><ul class=""><li id="0463" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">从第一个索引开始，<strong class="jp ir">枢轴元素与所有项目</strong>进行比较。如果元素大于 pivot 元素，则追加第二个指针。</li><li id="20a6" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">当与其他元素比较时，<strong class="jp ir">如果找到一个比 pivot 元素更小的元素，这个更小的元素将与之前识别的更大的元素进行交换。</strong></li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nw"><img src="../Images/c8a1d7b0d93f28e477fbfb0c89517c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJMPKKBclYT0HjXK-py55w.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">重新排列元素|按作者排列图像</p></figure><p id="2b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们简化上面的例子，</p><ul class=""><li id="970f" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">从<code class="fe kl km kn ko b">7</code>开始的每一个元素都将与轴心(<code class="fe kl km kn ko b">4</code>)进行比较。因为<code class="fe kl km kn ko b">7</code>比<code class="fe kl km kn ko b">4</code>大，所以第二个指针将放置在<code class="fe kl km kn ko b">7</code>处。</li><li id="60dd" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">下一个元素，元素<code class="fe kl km kn ko b">2</code>现在将与枢轴进行比较。由于<code class="fe kl km kn ko b">2</code>小于<code class="fe kl km kn ko b">4</code>，所以会被之前找到的更大的数字<code class="fe kl km kn ko b">7</code>所代替。</li><li id="17f5" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">数字<code class="fe kl km kn ko b">7</code>和<code class="fe kl km kn ko b">2</code>互换。现在，pivot 将与比<code class="fe kl km kn ko b">4</code>小的下一个元素<code class="fe kl km kn ko b">1</code>进行比较。</li><li id="efd5" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">所以再一次，<code class="fe kl km kn ko b">7</code>会和<code class="fe kl km kn ko b">1</code>对调。</li><li id="a5d0" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><strong class="jp ir">该过程继续，直到到达倒数第二个元素，</strong>并且在最后，枢轴元素然后被第二个指针替换。此处，编号<code class="fe kl km kn ko b">4</code>(枢轴)将替换为编号<code class="fe kl km kn ko b">6</code>。</li></ul><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/3e874d98f5cf14dabb0309c1b3d63198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x1_b09fTK_Ep_ozn0TbINw.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">重新排列元素|按作者排列图像</p></figure><blockquote class="nx ny nz"><p id="fc96" class="jn jo nq jp b jq jr js jt ju jv jw jx oa jz ka kb ob kd ke kf oc kh ki kj kk ij bi translated">由于元素<code class="fe kl km kn ko b">2</code>、<code class="fe kl km kn ko b">1</code>和<code class="fe kl km kn ko b">3</code>少于 4 个，它们位于枢轴的左侧。元素可以按任何顺序排列:<code class="fe kl km kn ko b">‘1’,’2’,’3’, or ‘3’,’1’,’2’, or ‘2’,’3’,’1’</code>。唯一的要求是所有的元素必须少于主元素。同样，在右侧，不管它们的顺序如何，所有组件都应该大于轴心。</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi od"><img src="../Images/6ec9077f461dc21557275c7322550d87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kX-E4vcwqyB3KH5q"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">在已排序的位置进行透视|按作者排序的图像</p></figure><p id="c176" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，该算法搜索每一个小于中枢的值。小于 pivot 的值将放在左边，而大于 pivot 的值将放在右边。一旦值被重新排列，它将把轴心设置在它的排序位置。</p><p id="2771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">③。划分子阵列</strong></p><p id="7a41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们划分了数组，我们可以将这个问题分解成两个子问题。首先，<strong class="jp ir">将数组</strong>的段排序到枢轴的左边，然后将数组的段排序到枢轴的右边。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oe"><img src="../Images/c79b47602df33148a8528f99b18f0674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8FB82juugcflR_4i"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">按作者对子数组|图像进行排序</p></figure><ul class=""><li id="063c" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">与我们在步骤 2 中重新排列元素的方式相同，<strong class="jp ir">我们将分别为左右子部分中的每一个选择一个枢轴元素。</strong></li><li id="b747" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">现在，我们将重新排列子列表，使所有元素都小于轴心点，轴心点向左。例如，元素<code class="fe kl km kn ko b">3</code>在三个元素中最大，满足条件，因此元素<code class="fe kl km kn ko b">3</code>处于其排序位置。</li><li id="9b17" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">以类似的方式，我们将再次处理子列表，并对元素<code class="fe kl km kn ko b">2</code>和<code class="fe kl km kn ko b">1</code>进行排序。当我们最后得到一个元素时，我们将停止这个过程。</li><li id="c7fa" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">对右侧子列表重复相同的过程。<strong class="jp ir">子阵列被细分，直到每个子阵列只包含一个元素。</strong></li><li id="53cc" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">至此，数组已排序:)</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="f3d7" class="lb lc iq bd ld le nl lg lh li nm lk ll lm nn lo lp lq no ls lt lu np lw lx ly bi translated">快速排序算法</h1><h2 id="bd5c" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated">快速排序函数算法</h2><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="20ac" class="ms lc iq ko b gy oj ok l ol om">//start –&gt; Starting index,  end --&gt; Ending index<br/>Quicksort(array, start, end)     <br/>{  <br/>   if (start &lt; end)     <br/>   {  <br/>      pIndex = Partition(A, start, end)<br/>      Quicksort(A,start,pIndex-1)<br/>      Quicksort(A,pIndex+1, end)<br/>   }<br/>}</span></pre><h2 id="c1ee" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated"><strong class="ak">分区</strong>函数算法</h2><p id="0580" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">使用分区方法以一定的顺序重新排列子阵列。你会发现各种各样的分区方法。这里我们将看到一个最常用的方法。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="eb78" class="ms lc iq ko b gy oj ok l ol om">partition (array, start, end)<br/>{<br/>    // Setting rightmost Index as pivot<br/>    pivot = arr[end];  <br/> <br/>    i = (start - 1)  // Index of smaller element and indicates the <br/>                   // right position of pivot found so far</span><span id="d74d" class="ms lc iq ko b gy on ok l ol om">for (j = start; j &lt;= end- 1; j++)<br/>    {<br/>        // If current element is smaller than the pivot<br/>        if (arr[j] &lt; pivot)<br/>        {<br/>            i++;    // increment index of smaller element<br/>            swap arr[i] and arr[j]<br/>        }<br/>    }<br/>    swap arr[i + 1] and arr[end])<br/>    return (i + 1)<br/>}</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="e64c" class="lb lc iq bd ld le nl lg lh li nm lk ll lm nn lo lp lq no ls lt lu np lw lx ly bi translated">快速排序实现</h1><p id="efb6" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们看看用 JavaScript 和 Python 编程语言编写的快速排序程序。</p><p id="9d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">T17】JavascriptT19】</strong></p><p id="11cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从创建一个允许你交换两个组件的函数开始。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="0c40" class="ms lc iq ko b gy oj ok l ol om">function swap(arr, i, j) <br/>{    let temp = arr[i];<br/>    arr[i] = arr[j];<br/>    arr[j] = temp;<br/>}</span></pre><p id="5dfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们添加一个函数，该函数使用最后一个元素(最后一个值)作为透视，将所有较小的项目移动到透视的左侧，将所有较大的元素移动到透视的右侧，并将透视放在排序后的数组中的适当位置。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="9d59" class="ms lc iq ko b gy oj ok l ol om">function partition(arr, start, end) {<br/> <br/>    // pivot<br/>    let pivot = arr[end];<br/> <br/>/* Index of a smaller element that specifies the pivot's correct position so far. */<br/> <br/> let i = (start - 1);<br/> <br/>    for (let j = start; j &lt;= end - 1; j++) {<br/> <br/>        // If current element is smaller than the pivot<br/>        if (arr[j] &lt; pivot) {<br/> <br/>           <br/>            i++;<br/>            swap(arr, i, j);<br/>        }<br/>    }<br/>    swap(arr, i + 1, end);<br/>    return (i + 1);<br/>}</span></pre><p id="1f87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们添加 main 函数，它将对元素进行分区和排序。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="fbd6" class="ms lc iq ko b gy oj ok l ol om">function quickSort(arr, start, end) {<br/>    if (start &lt; end) {<br/> <br/>        // The partitioning index is represented by pi.<br/>        <br/>        let pi = partition(arr, start, end);<br/> <br/>        // Separately sort elements before and after partition<br/>        quickSort(arr, start, pi - 1);<br/>        quickSort(arr, pi + 1, end);<br/>    }<br/>}</span></pre><p id="3ec6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们添加一个函数来打印数组。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="6c2f" class="ms lc iq ko b gy oj ok l ol om">function printArray(arr, size) {<br/>    for (let i = 0; i &lt; size; i++)<br/>        document.write(arr[i] + " ");<br/> <br/>    document.write("");<br/>}<br/> <br/>// Let's start by sorting the unsorted.<br/> <br/>let arr = [7, 2, 1, 6, 8, 5, 3, 4];<br/>let n = arr.length;<br/> <br/>document.write("Orginal array:" + arr);<br/>quickSort(arr, 0, n - 1);<br/>document.write("Sorted array:"+arr);</span></pre><p id="b69e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是快速排序实现(Js)的完整代码</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oo op l"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">JavaScript 中的快速排序实现</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oq"><img src="../Images/410160c799ecdd146dcee64e6345359a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EcGnNOKjHLNvkgms"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">代码输出(Javascript) |作者截图</p></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="fde2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="nq"> Python </em> </strong></p><p id="f69b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们首先创建一个函数，它负责对数组的第一个和最后一个元素进行排序。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="38e6" class="ms lc iq ko b gy oj ok l ol om">def find_pviot_index(A,start,end):<br/>    pivot=A[end]<br/>    p_index=start<br/>    for iter in range(start,end):<br/>        if A[iter] &lt;= pivot:<br/>            A[p_index],A[iter]=A[iter],A[p_index]<br/>            p_index+=1<br/>    A[p_index],A[end]=pivot,A[p_index]<br/>    return p_index</span></pre><p id="18bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将添加实现 QuickSort 的主函数。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="caca" class="ms lc iq ko b gy oj ok l ol om">def quick_sort(A,start,end):<br/>    if start &lt; end:<br/>        pivot_index=find_pviot_index(A,start,end)<br/>        print("--------------",A)<br/>        quick_sort(A,start,pivot_index-1)<br/>        quick_sort(A,pivot_index+1,end)</span></pre><p id="f7a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们添加一个函数来打印数组。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="f7d3" class="ms lc iq ko b gy oj ok l ol om">A=list()<br/>n=int(input("Set of numbers you want to enter: "))<br/>for x in range(0,n):<br/>    num=int(input("Enter Num:"))<br/>    A.append(num)<br/>print("Orignal array:",A)     <br/>quick_sort(A,0,n-1)<br/>print("Sorted array :",A)</span></pre><p id="2475" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nq">这里是用 Python 实现 Quicksort 的完整代码。</em></p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="oo op l"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">Python 中的快速排序实现</p></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi or"><img src="../Images/89c4deae1efc19f98e039efc7b010dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*waK4a4Y1ICjj1oi9gMV5EQ.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">代码输出(Python) |作者截图</p></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="db30" class="lb lc iq bd ld le nl lg lh li nm lk ll lm nn lo lp lq no ls lt lu np lw lx ly bi translated">快速排序复杂性</h1><p id="b4d5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们看看快速排序在最好、一般和最坏情况下的空间和时间复杂度。一般来说，QuickSort 消耗的时间可以写成如下。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="6283" class="ms lc iq ko b gy oj ok l ol om">T(n) = T(k) + T(n-k-1) + O(n)</span></pre><p id="e59a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，<code class="fe kl km kn ko b">T(k)</code>和<code class="fe kl km kn ko b">T(n-k-1)</code>指的是两次递归调用，而最后一项<code class="fe kl km kn ko b">O(n)</code>指的是分区过程。小于 pivot 的项目数用<code class="fe kl km kn ko b">k</code>表示。</p><h2 id="8d76" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated">时间复杂度</h2><p id="1d0a" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><strong class="jp ir"> 1)。最佳情况复杂度:</strong>当划分算法总是选择中间元素或中间元素附近作为支点时，最佳情况场景发生。快速排序的最佳时间复杂度是<code class="fe kl km kn ko b"> O (n*logn)</code>。以下是最佳情况下的重现。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="7381" class="ms lc iq ko b gy oj ok l ol om">T(n) = 2T(n/2) + O(n)</span><span id="8aec" class="ms lc iq ko b gy on ok l ol om">//solution O(nLogn)</span></pre><p id="396a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2)。平均情况复杂性:</strong>当数组元素处于无序序列中，没有适当地增加或减少时，就会出现这种情况。Quicksort 的平均案例时间复杂度为<code class="fe kl km kn ko b">O(n*logn)</code>。以下是平均情况下的重现。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="2414" class="ms lc iq ko b gy oj ok l ol om">T(n) = T(n/9) + T(9n/10) + O(n)</span><span id="a16f" class="ms lc iq ko b gy on ok l ol om">//solution O(nLogn)</span></pre><p id="6d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3)。最差情况复杂性:</strong>最差情况是分区算法每次都选择最大或最小的元素作为枢纽元素。快速排序最坏情况下的时间复杂度是<code class="fe kl km kn ko b">O (n2)</code>。以下是最差情况下的复发。</p><pre class="kq kr ks kt gt of ko og oh aw oi bi"><span id="19be" class="ms lc iq ko b gy oj ok l ol om">T(n) = T(0) + T(n-1) + O(n)</span><span id="9b5e" class="ms lc iq ko b gy on ok l ol om">//solution O(n2)</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi os"><img src="../Images/850080b61955d45aea1368fcd9a4a723.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*vSGCF6_QiP1Ek_VVNRoEdg.png"/></div></div><p class="kx ky gj gh gi kz la bd b be z dk translated">时间复杂度|快速排序|作者图片</p></figure><h2 id="bdc0" class="ms lc iq bd ld mt mu dn lh mv mw dp ll jy mx my lp kc mz na lt kg nb nc lx nd bi translated">空间复杂性</h2><p id="1cf5" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">快速排序的空间复杂度为<code class="fe kl km kn ko b">O(log n).</code></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/e0edc90a758ade2675bf87d173524df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Kc27HbGf0boSlUm16FLMIg.png"/></div><p class="kx ky gj gh gi kz la bd b be z dk translated">空间复杂性|快速排序|作者图片</p></figure><h1 id="d06f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">快速排序应用程序</h1><p id="5ac7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">排序算法用于查找信息，因为快速排序是最快的，所以它经常被用作更有效的搜索方法。</p><ul class=""><li id="3762" class="me mf iq jp b jq jr ju jv jy mg kc mh kg mi kk mj mk ml mm bi translated">它适用于不需要稳定排序的地方。</li><li id="acea" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">因为它是尾递归的，所以每次调用优化都可以进行。</li><li id="4b38" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">它在事件驱动的模拟和运筹学中是有用的。</li></ul><h1 id="11b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">快速排序是否优于其他算法？</h1><p id="48c2" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">快速排序可能有一些缺点，但它是最快、最有效的排序算法。快速排序具有<code class="fe kl km kn ko b">O (logn)</code>空间复杂度，这使得它成为空间受限情况下的绝佳选择。</p><p id="ef5c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然最坏情况下的运行时间总是一样的，但是 Quicksort 往往比 HeapSort <code class="fe kl km kn ko b">(nlogn)</code>要快。快速排序比堆排序占用更少的空间(因为堆是一个几乎满的二叉树，有指针开销)。所以，在对数组进行排序时，quicksort 是首选。</p><h1 id="9c35" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e20e" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">快速排序可能有一些缺点，但它是最快的排序算法。快速排序是一种有效的算法，在实践中表现良好。</p><p id="e1ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们学习了什么是快速排序，它的优点和缺点，以及如何实现它。如果你想要任何算法的详细解释或者算法对比，欢迎在下面随意评论。</p><h1 id="1c3b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">参考资料和推荐读物</h1><ul class=""><li id="8653" class="me mf iq jp b jq lz ju ma jy ou kc ov kg ow kk mj mk ml mm bi translated"><a class="ae ox" href="https://www.tutorialspoint.com/data_structures_algorithms/quick_sort_algorithm.htm" rel="noopener ugc nofollow" target="_blank">https://www . tutorialspoint . com/data _ structures _ algorithms/quick _ sort _ algorithm . htm</a></li><li id="e23a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">https://www.geeksforgeeks.org/quick-sort/<a class="ae ox" href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener ugc nofollow" target="_blank"/></li><li id="6f4a" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated">【https://www.cs.dartmouth.edu/~thc/cs5-F96/lec28.html T4】</li><li id="f490" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><a class="ae ox" rel="noopener" target="_blank" href="/quicksort-in-python-dbefa7dcf9cc">https://towardsdatascience . com/quick sort-in-python-db EFA 7 DC F9 cc</a></li><li id="563c" class="me mf iq jp b jq mn ju mo jy mp kc mq kg mr kk mj mk ml mm bi translated"><a class="ae ox" href="https://github.com/its-harshil/Hacktoberfest_2021/blob/9b7bc632d47df33e70f1649451f1b887c13d4ec3/quick_sort.py" rel="noopener ugc nofollow" target="_blank">https://github . com/its-harshil/Hacktoberfest _ 2021/blob/9b7b c 632d 47 df 33 e 70 f 1649451 f1 b 887 c 13d 4 EC 3/quick _ sort . py</a></li></ul></div></div>    
</body>
</html>