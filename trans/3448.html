<html>
<head>
<title>Pytest with Marking, Mocking, and Fixtures in 10 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10分钟内完成标记、模仿和固定装置的Pytest</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pytest-with-marking-mocking-and-fixtures-in-10-minutes-678d7ccd2f70#2022-07-31">https://towardsdatascience.com/pytest-with-marking-mocking-and-fixtures-in-10-minutes-678d7ccd2f70#2022-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="108e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python pytest编写健壮的单元测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/27ddfe8ab65b4d675851b914991022cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H56kk-voyUbD-j1x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰夫·谢尔登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2472" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" rel="noopener" target="_blank" href="/unit-testing-with-mocking-in-10-minutes-e28feb7e530">上一篇关于单元测试的文章</a>中，我阐述了单元测试的目的、单元测试生态系统和最佳实践，并用Python内置的<code class="fe lv lw lx ly b">unittest</code>包演示了基本和高级的例子。有不止一种方法(和不止一个Python包)来执行单元测试，本文将演示如何用Python <code class="fe lv lw lx ly b">pytest</code>包实现单元测试。本文将紧密跟随上一篇文章的流程，因此您可以比较<code class="fe lv lw lx ly b">unittest</code> vs. <code class="fe lv lw lx ly b">pytest</code>的各个组件。</p><p id="c915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe lv lw lx ly b">unittest</code>包是面向对象的，因为测试用例是以类的形式编写的，但是<code class="fe lv lw lx ly b">pytest</code>包是功能性的，导致代码行更少。就个人而言，我更喜欢<code class="fe lv lw lx ly b">unittest</code>,因为我觉得代码可读性更强。也就是说，这两个包，或者更确切地说是框架，都同样强大，在它们之间进行选择只是个人喜好的问题。</p><div class="lz ma gp gr mb mc"><a rel="noopener follow" target="_blank" href="/unit-testing-with-mocking-in-10-minutes-e28feb7e530"><div class="md ab fo"><div class="me ab mf cl cj mg"><h2 class="bd iu gy z fp mh fr fs mi fu fw is bi translated">10分钟后模拟单元测试</h2><div class="mj l"><h3 class="bd b gy z fp mh fr fs mi fu fw dk translated">使用内置的unittest Python包有效地测试您的代码库</h3></div><div class="mk l"><p class="bd b dl z fp mh fr fs mi fu fw dk translated">towardsdatascience.com</p></div></div><div class="ml l"><div class="mm l mn mo mp ml mq ks mc"/></div></div></a></div><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mr">更新</em> </strong> <em class="mr">:本文是系列文章的一部分。查看其他“10分钟内”话题</em> <a class="ae ky" href="https://medium.com/@kayjanwong/list/in-10-minutes-eeaa9aa67055" rel="noopener"> <em class="mr">此处</em> </a> <em class="mr">！</em></p><h1 id="0402" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">目录</h1><ol class=""><li id="29cc" class="nk nl it lb b lc nm lf nn li no lm np lq nq lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#026e" rel="noopener">设置Pytest </a></li><li id="0e10" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#7fc6" rel="noopener">单元测试的结构</a></li><li id="ed4e" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#944e" rel="noopener">运行单元测试</a></li><li id="a4c3" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#d31e" rel="noopener">高级:内置断言</a></li><li id="bab7" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#8c34" rel="noopener">高级:跳过单元测试(通过标记)</a></li><li id="cae0" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#8145" rel="noopener">高级:单元测试中的模拟</a></li><li id="3107" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><a class="ae ky" href="https://medium.com/p/678d7ccd2f70/#ce33" rel="noopener">高级:其他</a></li></ol></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="026e" class="ms mt it bd mu mv oh mx my mz oi nb nc jz oj ka ne kc ok kd ng kf ol kg ni nj bi translated">设置Pytest</h1><p id="bc7c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">与<code class="fe lv lw lx ly b">unittest</code>不同，<code class="fe lv lw lx ly b">pytest</code>不是内置的Python包，需要安装。这可以简单地通过终端上的<code class="fe lv lw lx ly b">pip install pytest</code>来完成。</p><p id="077b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">unittest</code>的最佳实践也适用于<code class="fe lv lw lx ly b">pytest</code>，因此</p><ul class=""><li id="d890" class="nk nl it lb b lc ld lf lg li op lm oq lq or lu os ns nt nu bi translated">所有的单元测试必须写在一个<code class="fe lv lw lx ly b">tests/</code>目录中</li><li id="8d0f" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated">文件名应该严格以<code class="fe lv lw lx ly b">tests_</code>开头</li><li id="bb77" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated">函数名应该严格以<code class="fe lv lw lx ly b">test</code>开头</li></ul><p id="e867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">必须遵循命名约定，以便检查器可以在运行时发现单元测试。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="7fc6" class="ms mt it bd mu mv oh mx my mz oi nb nc jz oj ka ne kc ok kd ng kf ol kg ni nj bi translated">单元测试的结构</h1><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="4267" class="ox mt it ly b be oy oz l pa pb">def test_function_with_scenario_one():<br/>    print("Testing function with scenario one")<br/>    assert 1 + 1 == 2, f"Check addition value {1 + 1} does not match {2}"</span></pre><p id="5931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">pytest</code>中的单元测试是在函数中编写的，断言是在函数中做出的。这使得<code class="fe lv lw lx ly b">pytest</code>很容易理解，并且单元测试代码看起来短小精悍！</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="944e" class="ms mt it bd mu mv oh mx my mz oi nb nc jz oj ka ne kc ok kd ng kf ol kg ni nj bi translated">运行单元测试</h1><p id="cdf5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">可以通过在命令行中键入<code class="fe lv lw lx ly b">pytest</code>来运行单元测试，这将发现所有的单元测试，如果它们遵循命名约定的话。单元测试输出返回测试运行的总数、通过、跳过和失败的测试数、运行测试所用的总时间以及失败堆栈跟踪(如果有)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/00e044bd0cd61f217d6c6400f1a7b889.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-L5DdbOF6sPLUMpW58pfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:运行单元测试——作者图片</p></figure><p id="35a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要对特定的目录、文件或函数运行单元测试，命令如下</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="028e" class="ox mt it ly b be oy oz l pa pb">$ pytest tests/<br/>$ pytest tests/test_sample.py<br/>$ pytest tests/test_sample.py::test_function_one</span></pre><p id="55ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有更多定制可以附加到命令中，例如</p><ul class=""><li id="8d85" class="nk nl it lb b lc ld lf lg li op lm oq lq or lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">-x</code>:立即退出或快速失败，在遇到第一次测试失败时停止所有单元测试</li><li id="7785" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">-k "keyword"</code>:指定选择性运行测试的关键字，可以匹配文件名或函数名，可以包含<code class="fe lv lw lx ly b">and</code>和<code class="fe lv lw lx ly b">not</code>语句</li><li id="ff8d" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">--ff</code>:第一次失败，从上次失败的测试开始运行所有测试(<strong class="lb iu">首选</strong>)</li><li id="c07a" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">--lf</code>:上次失败，运行上次运行失败的测试(<strong class="lb iu">缺点</strong>:可能无法发现之前通过的测试中的失败)</li><li id="933c" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">--sw</code>:逐步地，在第一次测试失败时停止，并从那里继续下一次运行(<strong class="lb iu">缺点</strong>:可能无法发现先前通过的测试中的失败)</li></ul><p id="ca32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">额外提示:如果单元测试运行时间太长，你可以并行运行它们，而不是顺序运行！安装<code class="fe lv lw lx ly b">pytest-xdist</code> Python包，并在运行单元测试时将其添加到命令中，</p><ul class=""><li id="513c" class="nk nl it lb b lc ld lf lg li op lm oq lq or lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">-n &lt;number of workers&gt;</code>:并行运行测试的工人数量</li></ul><p id="569d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">调试错误</strong>:当您的测试脚本从基本目录或任何源目录中的一个文件夹导入时，您可能会面临错误<code class="fe lv lw lx ly b">ModuleNotFoundError</code>。例如，您的函数驻留在<code class="fe lv lw lx ly b">src/sample_file.py</code>中，而您驻留在<code class="fe lv lw lx ly b">tests/</code>目录中的测试脚本执行导入<code class="fe lv lw lx ly b">from src.sample_file import sample_function</code>。</p><p id="010d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这个问题，在基本目录中创建一个配置文件<code class="fe lv lw lx ly b">pytest.ini</code>,以指示相对于基本目录执行导入的目录。要添加到配置文件中的内容示例如下:</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="3bff" class="ox mt it ly b be oy oz l pa pb">[pytest]<br/>pythonpath = .</span></pre><p id="3fba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个配置文件可以扩展到更多的用途，这将在后面的章节中详细说明。目前，这种配置允许您绕过<code class="fe lv lw lx ly b">ModuleNotFoundError</code>错误。</p><blockquote class="pd"><p id="c1d2" class="pe pf it bd pg ph pi pj pk pl pm lu dk translated">在了解了单元测试的基本结构以及如何运行它们之后，是时候深入研究了！</p></blockquote></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="e6a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，单元测试可能不像调用函数和测试给定输入的预期输出那样简单。可以有高级的逻辑，例如浮点精度的计算、预期错误的测试、将测试分组在一起、单元测试的有条件跳过、模拟数据等。这可以通过<code class="fe lv lw lx ly b">pytest</code>包中的上下文管理器和装饰器来完成(基本上已经为您编码好了！).</p><h1 id="d31e" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">高级:内置断言</h1><p id="1002" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">除了测试预期的输出，您还可以测试预期的错误，以确保函数在以非设计方式使用时会抛出错误。这可以通过<code class="fe lv lw lx ly b">pytest.raises</code>上下文管理器，使用<code class="fe lv lw lx ly b">with</code>关键字来完成。</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="9851" class="ox mt it ly b be oy oz l pa pb">import pytest<br/><br/>def test_expected_error():<br/>    with pytest.raises(TypeError):<br/>        assert 1 + "a", "This should raise an error"</span></pre><h1 id="8c34" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">高级:跳过单元测试(通过标记)</h1><p id="7ad8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">单元测试可以使用<code class="fe lv lw lx ly b">pytest.mark</code> decorator进行标记，这允许各种扩展功能，例如，</p><ol class=""><li id="f32c" class="nk nl it lb b lc ld lf lg li op lm oq lq or lu nr ns nt nu bi translated"><strong class="lb iu">将单元测试分组</strong>:多个单元测试可以作为一个组来运行</li><li id="9ce1" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">标记为失败</strong>:表示单元测试预计会失败</li><li id="844c" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">标记为跳过/有条件跳过</strong>:单元测试默认行为将被跳过，或者在满足某些条件时被跳过</li><li id="ac5b" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><strong class="lb iu">标记为插入参数</strong>:测试单元测试的各种输入</li></ol><blockquote class="pn po pp"><p id="d6f1" class="kz la mr lb b lc ld ju le lf lg jx lh pq lj lk ll pr ln lo lp ps lr ls lt lu im bi translated">装饰者可以被堆叠以提供多种扩展功能。例如，可以将测试标记为一个组，并标记为跳过！</p></blockquote><p id="3d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面阐述的各种功能以这种方式实现，</p><h2 id="29f0" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">a)对单元测试进行分组</h2><p id="66b1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">取代在一个文件夹、文件中或者通过关键字搜索来运行单元测试，单元测试可以被分组并且用<code class="fe lv lw lx ly b">pytest -m &lt;group-name&gt;</code>来调用。测试的输出将显示运行的测试数量以及由于不在组中而被取消选择的测试数量。</p><p id="38ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过下面的例子用<code class="fe lv lw lx ly b">pytest.mark.&lt;group-name&gt;</code>装饰器来实现，</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="1113" class="ox mt it ly b be oy oz l pa pb">import pytest<br/><br/>@pytest.mark.group1<br/>def test_sample():<br/>    pass</span></pre><p id="226c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使这个工作，我们需要在配置文件中定义这个组，下面的内容可以添加到<code class="fe lv lw lx ly b">pytest.ini</code>文件中的现有内容中，</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="893f" class="ox mt it ly b be oy oz l pa pb">markers =<br/>    group1: description of group 1</span></pre><h2 id="7645" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">b)标记为失败</h2><p id="63be" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">对于预计会失败的测试，可以用<code class="fe lv lw lx ly b">pytest.mark.xfail</code>装饰器进行标记。如果单元测试失败(与正常场景中抛出错误相反)，输出将显示<code class="fe lv lw lx ly b">xfailed</code>，如果单元测试意外通过，输出将显示<code class="fe lv lw lx ly b">xpassed</code>。一个例子如下，</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="2681" class="ox mt it ly b be oy oz l pa pb">import pytest<br/><br/>@pytest.mark.xfail<br/>def test_fail():<br/>    assert 1 == 2, "This should fail"</span></pre><h2 id="b8ff" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">c)标记为跳过/有条件跳过</h2><p id="6bfd" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">将一个单元测试标记为跳过或在满足某些条件时跳过与上一节类似，只是装饰者分别是<code class="fe lv lw lx ly b">pytest.mark.skip</code>和<code class="fe lv lw lx ly b">pytest.mark.skipif</code>。如果在较新的Python版本或较新的Python包版本中测试不再按预期工作，跳过单元测试是有用的。</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="52a7" class="ox mt it ly b be oy oz l pa pb">import sys<br/>import pytest<br/><br/>@pytest.mark.skip<br/>def test_skip():<br/>    raise Exception("This test should be skipped")<br/><br/>@pytest.mark.skipif(sys.version_info.major == 2, reason="requires Python 3.x")<br/>def test_skipif():<br/>    pass</span></pre><h2 id="268c" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">d)标记为插入参数</h2><p id="7db1" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">在某些情况下，我们会希望针对一些输入来测试函数，例如，针对正常情况和边缘情况来测试代码库。与在一个单元测试中编写多个断言或编写多个单元测试不同，我们可以按照如下方式自动测试多个输入，</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="ab60" class="ox mt it ly b be oy oz l pa pb">import pytest<br/><br/>@pytest.mark.parametrize("n", [2, 4, 6])<br/>def test_even_number(n):<br/>    assert not n % 2, f"{n} is not an even number"<br/><br/>@pytest.mark.parametrize(["n", "expected_output"], [(1, 3), (2, 6)])<br/>def test_multiplication(n, expected_output):<br/>    assert n * 3 == expected_output, "Check multiplication"</span></pre></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="8145" class="ms mt it bd mu mv oh mx my mz oi nb nc jz oj ka ne kc ok kd ng kf ol kg ni nj bi translated">高级:单元测试中的模拟</h1><p id="078e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">模拟在单元测试中用来替换函数的返回值。替换不应该在测试环境中运行的操作是有用的，例如，当测试环境没有相同的数据访问时，替换连接到数据库并加载数据的操作。</p><p id="596f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">pytest</code>中，嘲讽可以代替函数内函数的返回值。这对于测试期望的函数和替换我们正在测试的期望函数中的嵌套函数的返回值是有用的。</p><blockquote class="pn po pp"><p id="87db" class="kz la mr lb b lc ld ju le lf lg jx lh pq lj lk ll pr ln lo lp ps lr ls lt lu im bi translated">因此，模拟减少了单元测试的依赖性，因为我们测试的是期望的函数，而不是它对其他函数的依赖性。</p></blockquote><p id="8677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果所需的函数通过连接到数据库来加载数据，我们可以模拟加载数据的函数，使它不连接到数据库，而是提供要使用的替代数据。</p><p id="8d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要实现模拟，安装<code class="fe lv lw lx ly b">pytest-mock</code> Python包。在这个例子中，在<code class="fe lv lw lx ly b">src/sample_file.py</code>文件中，我们定义了期望的函数和要模仿的函数。</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="8d96" class="ox mt it ly b be oy oz l pa pb">def load_data():<br/>    # This should be mocked as it is a dependency<br/>    return 1<br/><br/>def dummy_function():<br/>    # This is the desired function we are testing<br/>    return load_data()</span></pre><p id="49ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在测试脚本中，我们通过指定完整的点路径来定义要模拟的函数，并定义应该返回的值，</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="e3e2" class="ox mt it ly b be oy oz l pa pb">from src.sample_file import dummy_function<br/><br/>def test_mocking_function(mocker):<br/>    mocker.patch("src.sample_file.load_data", return_value=2)<br/>    assert dummy_function() == 2, "Value should be mocked"</span></pre><p id="52cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Mocking可以修补代码库中的任何函数，只要您定义完整的虚线路径。请注意，您不能模拟正在测试的期望函数，但是可以模拟期望函数所依赖的任何依赖项，甚至是嵌套依赖项。</p><h1 id="ce33" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">高级:其他</h1><h2 id="951e" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">a) Pytest配置</h2><p id="bc4c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">正如前面章节中所讨论的，配置文件<code class="fe lv lw lx ly b">pytest.ini</code>可以在基本目录中定义，以绕过<code class="fe lv lw lx ly b">ModuleNotFoundError</code>并定义单元测试组。现在看起来应该是这样的，</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="877d" class="ox mt it ly b be oy oz l pa pb">[pytest]<br/>pythonpath = .<br/>markers =<br/>    group1: description of group 1</span></pre><p id="01f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置文件允许用户指定运行单元测试的默认模式，例如，<code class="fe lv lw lx ly b">pytest --ff</code>用于失败的第一次设置，或者<code class="fe lv lw lx ly b">pytest -ra -q</code>用于压缩的输出结果。默认模式可以通过在配置文件中添加行<code class="fe lv lw lx ly b">addopts = -ra -q</code>来指示。</p><p id="e43b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了抑制警告，我们还可以将<code class="fe lv lw lx ly b">ignore::DeprecationWarning</code>或<code class="fe lv lw lx ly b">ignore::ImportWarning</code>添加到配置文件中。</p><p id="4772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以向配置文件中添加更多的项目，但这些是更常见的项目。<code class="fe lv lw lx ly b">pytest</code>配置文件的官方文档可以在<a class="ae ky" href="https://docs.pytest.org/en/6.2.x/customize.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h2 id="95bb" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">b)重用变量(通过夹具)</h2><p id="9224" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">Fixtures可以用来标准化跨多个单元测试的输入。例如，可以定义一个fixture来加载一个文件或创建一个对象，作为多个测试的输入，而不是在每个测试中重写相同的代码行。</p><pre class="kj kk kl km gt ot ly ou bn ov ow bi"><span id="7f1a" class="ox mt it ly b be oy oz l pa pb">import pytest<br/><br/>@pytest.fixture<br/>def input_dict():<br/>    return {"a": 1}<br/><br/>def test_fixture(input_dict):<br/>    assert input_dict["a"] == 1, f"Check fixture {input_dict}"</span></pre><p id="9ca4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">夹具可以在同一个Python文件中定义，也可以在由<code class="fe lv lw lx ly b">pytest</code>自动处理的文件<code class="fe lv lw lx ly b">tests/conftest.py</code>中定义。</p><h2 id="d59a" class="pt mt it bd mu pu pv dn my pw px dp nc li py pz ne lm qa qb ng lq qc qd ni qe bi translated">c)考虑浮点精度</h2><p id="161e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">当断言数值的相等条件时，由于<a class="ae ky" href="https://docs.python.org/3/tutorial/floatingpoint.html" rel="noopener ugc nofollow" target="_blank">浮点运算限制</a>，小数点位置的值可能会有差异。</p><p id="e494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们可以用一定的容差来比较数值的相等性。默认情况下，使用<code class="fe lv lw lx ly b">assert output_value == <strong class="lb iu">pytest.approx</strong>(expected_value)</code>将允许相等比较放宽到公差<code class="fe lv lw lx ly b">1e-6</code>。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><p id="2770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你已经学习了更多关于用<code class="fe lv lw lx ly b">pytest</code>实现单元测试的知识，以及一些你可以用单元测试做的很酷的技巧。还提供了更多的功能，比如使用<code class="fe lv lw lx ly b">monkeypatch</code>模仿数据，在fixtures中定义范围，结合<code class="fe lv lw lx ly b">unittest</code> Python包使用<code class="fe lv lw lx ly b">pytest</code>，等等。有需求的话可以出续集；)</p><p id="6f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">感谢您的阅读！如果你喜欢这篇文章，请随意分享。</strong></p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="fb58" class="ms mt it bd mu mv oh mx my mz oi nb nc jz oj ka ne kc ok kd ng kf ol kg ni nj bi translated">相关链接</h1><ul class=""><li id="5291" class="nk nl it lb b lc nm lf nn li no lm np lq nq lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">pytest</code>文档:<a class="ae ky" href="https://docs.pytest.org" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org</a></li><li id="2cae" class="nk nl it lb b lc nv lf nw li nx lm ny lq nz lu os ns nt nu bi translated"><code class="fe lv lw lx ly b">pytest</code>教程:<a class="ae ky" href="https://www.tutorialspoint.com/pytest/index.htm" rel="noopener ugc nofollow" target="_blank">https://www.tutorialspoint.com/pytest/index.htm</a></li></ul></div></div>    
</body>
</html>