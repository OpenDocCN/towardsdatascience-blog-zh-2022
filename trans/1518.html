<html>
<head>
<title>This Little Python Exercise Taught Me a Lot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这个小Python练习教会了我很多</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/this-little-python-exercise-taught-me-a-lot-65a60e1100bf#2022-04-13">https://towardsdatascience.com/this-little-python-exercise-taught-me-a-lot-65a60e1100bf#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="93fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你想成为一名优秀的程序员，不要满足于你想到的第一个解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37848e08ba51008d41fd1fed95d9e147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ok6tfss61M3_3z5R"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约翰·施诺布里奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e17c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决编程挑战是提高技能和学习新工具的好方法，即使是用你已经知道的语言。这就是为什么我觉得这个小问题很吸引人:</p><blockquote class="ls lt lu"><p id="ab27" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">给定一个包含重复字母的字符串<em class="iq"> s </em>，例如“hhhhhhhaaaaaaaaabbbbbbbvvvvvaaaahhhh”，输出一个摘要列表，显示每个相同字符序列的起始位置和字符</p></blockquote><p id="72b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于上面的字符串，输出将是:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="95ed" class="me mf iq ma b gy mg mh l mi mj">[(0, 'h'), (7, 'a'), (15, 'b'), (22, 'v'), (27, 'a'), (31, 'h')]</span></pre><h2 id="b39b" class="me mf iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">解决方案1</h2><p id="d2d8" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">第一种解决方法是根据每个字符在字符串中各自的位置，这可以通过</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="94b7" class="me mf iq ma b gy mg mh l mi mj">enumerate(s)</span></pre><p id="b979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这还不够，因为我们需要扫描“变化”——当前角色与其前任不同的位置。让我们迭代字符串的两个副本，移动一个字符，如下所示:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="216c" class="me mf iq ma b gy mg mh l mi mj">enumerate(zip(s[1:],s),1)</span></pre><p id="9ea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">枚举现在从1开始，因为我们从相对于前一个字符的索引1开始查找字符。</p><p id="b0eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了完成这个解决方案，我们需要只保留代表一个新字符的元组。我们还需要确保在输出中包含第一个字符(第0个索引处的字符)。空字符串的情况需要单独处理，以避免异常。</p><p id="541c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的功能:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="ad4e" class="me mf iq ma b gy mg mh l mi mj">def summarize_string1(s):<br/>    if not s:<br/>        return []<br/>    return [(0,s[0])] + \<br/>[(i, c) for (i, (c, pc)) in enumerate(zip(s[1:],s),1) if c != pc]</span></pre><p id="2c24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注<em class="lv"> i </em>代表索引，<em class="lv"> c </em>代表字符，<em class="lv"> pc </em>代表前一个字符。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="cc19" class="me mf iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">itertools.groupby</h2><p id="d8b3" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">事实证明，Python的<em class="lv"> itertools </em>模块可以帮助我们让这段代码更加优雅。</p><p id="aa6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该模块中的<em class="lv"> groupby </em>函数将一个序列作为输入，并将其分解成子序列，其中每个子序列中的项目共享同一个键。这听起来有点抽象，所以让我们分解一下，看看在这种情况下如何让它工作。</p><p id="66bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们再看看</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="24f2" class="me mf iq ma b gy mg mh l mi mj">enumerate(s)</span></pre><p id="6edb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它根据单个字符及其位置生成一个项目序列，例如(0，' h ')、(1，' h')…等等。</p><p id="de56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们希望将这个序列中字母相同的项目组合在一起，因此我们编写这个lambda函数来提取字符作为键:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="1245" class="me mf iq ma b gy mg mh l mi mj">lambda x: x[1]</span></pre><p id="b214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备编写如下代码:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="84c1" class="me mf iq ma b gy mg mh l mi mj">from itertools import groupby<br/>def summarize_string2(s):<br/>    result = []<br/>    for key, group in groupby(enumerate(s),lambda x: x[1]):<br/>        result.append(next(group))<br/>    return result</span></pre><p id="72c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理解这段代码的关键是理解groupby函数在这里是如何工作的。它检查我们的字符串<em class="lv"> s </em>的枚举字符，并将lambda函数应用于元组(0，' h ')、(1，' h ')等。当它意识到它到达了一个键不同的项时，它“打包”到目前为止它处理过的所有项，并把它们放入一个iterable(我们在变量<em class="lv">组中接收到它)</em>和它们相关的公共键中。因为<em class="lv">组</em>是一个<em class="lv">生成器</em>而不是一个合适的列表，访问它的第一个元素的最简单的方法是使用Python的内置<em class="lv"> next，</em>以上面代码<em class="lv">中描述的方式。</em>下一个(组)的可能替代项是</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="3cc4" class="me mf iq ma b gy mg mh l mi mj">list(group)[0]</span></pre><p id="25a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提取第一个元素。</p><p id="ac36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们对这个问题的第二个解决方案。我认为代码更好，但是在性能方面，它比解决方案1慢50%。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="ea52" class="me mf iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">使用numpy</h2><p id="98ff" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">numpy用于数值计算，通常不用于处理字符串。但是它有一个diff函数，我们可以在这里利用它。</p><p id="2377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们使用numpy的代码:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="7e30" class="me mf iq ma b gy mg mh l mi mj">import numpy as np</span><span id="3e3d" class="me mf iq ma b gy nn mh l mi mj">def summarize_string3(s):<br/>    str_arr = np.array(list(s.encode('ascii')))<br/>    loc = np.diff(str_arr,prepend=0).nonzero()[0]<br/>    return [(i, s[i]) for i in loc]</span></pre><p id="c3bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">str_arr是字符串到整数数组的转换。每个整数代表字符串中的一个字母，通过它的ASCII码(如果字符串包含ASCII子集中没有的unicode字符，它就不起作用)。</p><p id="1fb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">np.diff是什么？它查找numpy数组中连续条目之间的差异。无论相同的字符在哪里，显然相同的ASCII码将填充数组，差异将为零。非零元素只会出现在字符序列的开头。预先添加一个任意的零条目允许我们自动捕获第一个元素，因为没有一个字母或可打印字符的ASCII码是0。</p><p id="16fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然numpy被认为非常快，但对于我在本文中使用的特定示例数组，我们的解决方案的numpy版本大约比前面的解决方案慢4倍。转换成数组一定消耗了大量的处理器时间。</p><h2 id="8784" class="me mf iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">一锤定音</h2><p id="9a08" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">这个有趣的编码小挑战让我们看到了解决同一个问题的不同方法。当选择工具来解决特定的编码问题时，每个工具所提供的效用应该与最终解决方案的可读性及其解决特定问题的效率相权衡。</p><h2 id="6893" class="me mf iq bd mk ml mm dn mn mo mp dp mq lf mr ms mt lj mu mv mw ln mx my mz na bi translated">资源</h2><ul class=""><li id="4dca" class="no np iq ky b kz nb lc nc lf nq lj nr ln ns lr nt nu nv nw bi translated">本文中三个函数的代码也可以作为要点<a class="ae kv" href="https://gist.github.com/kishkash555/020ede77fff9c2849c20eb175382a365" rel="noopener ugc nofollow" target="_blank">获得</a>。</li><li id="97c7" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">参见文档<a class="ae kv" href="https://docs.python.org/3/library/itertools.html#itertools.groupby" rel="noopener ugc nofollow" target="_blank"> itertools.groupby </a>，<a class="ae kv" href="https://numpy.org/doc/stable/reference/generated/numpy.diff.html" rel="noopener ugc nofollow" target="_blank"> numpy.diff </a>，<a class="ae kv" href="https://docs.python.org/3/library/functions.html#next" rel="noopener ugc nofollow" target="_blank"> next </a></li><li id="3c88" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">如何使用<a class="ae kv" href="https://docs.python.org/3/library/timeit.html#timeit.timeit" rel="noopener ugc nofollow" target="_blank"> timeit </a>模块为您的代码计时</li></ul></div></div>    
</body>
</html>