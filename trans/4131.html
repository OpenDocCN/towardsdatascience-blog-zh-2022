<html>
<head>
<title>The Math behind RSA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RSA背后的数学原理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-math-behind-rsa-910f88b94c36#2022-09-13">https://towardsdatascience.com/the-math-behind-rsa-910f88b94c36#2022-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0005" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">RSA及其算法背后的数学原理的详细演示</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3361f6c351f6f5d7fe48ee08acc22a4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8gTaGaGuGwMrqlLT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Towfiqu barb huya</a>拍摄的照片</p></figure><p id="770b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常发现数学结果在计算机科学中令人着迷的应用。<em class="ls"> RSA </em>就是这样一个应用。</p><p id="6ede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> RSA </em>是<em class="ls">非对称加密</em>的实现，也叫<em class="ls">公钥加密</em>，由Diffie和Hellman在<em class="ls">密码学新方向【1】</em>中介绍。</p><p id="fe6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非对称加密背后的想法是每台机器<strong class="ky ir"> A </strong>生成两个函数<strong class="ky ir"> <em class="ls"> f </em> </strong>和<strong class="ky ir"> <em class="ls"> g </em> </strong>使得:</p><pre class="kg kh ki kj gt lt lu lv lw aw lx bi"><span id="7332" class="ly lz iq lu b gy ma mb l mc md"><strong class="lu ir"><em class="ls">g(f(message)) = message</em></strong></span></pre><p id="2c5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<strong class="ky ir"> <em class="ls"> f </em> </strong>用于加密消息，并由<strong class="ky ir"> A </strong>公开<em class="ls">。每台要向<strong class="ky ir"> A </strong>发送消息的机器计算<em class="ls"> f(消息)</em>、<em class="ls">、</em>，并将结果发送给<strong class="ky ir"> A </strong>、<em class="ls">。</em></em></p><p id="dd7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls"> g </em> </strong>用于解密，由<strong class="ky ir"> A </strong>保密。在接收到加密消息<em class="ls"> f(消息)</em>，<em class="ls"> </em> <strong class="ky ir"> A </strong>后，计算<em class="ls"> g(f(消息))=消息</em>并检索初始消息。</p><p id="2700" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使通信安全，从<strong class="ky ir"> <em class="ls"> f </em> </strong>导出<strong class="ky ir"> <em class="ls"> g </em> </strong>在计算上应该是不可行的。</p><p id="56c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于这种革命性的想法，<em class="ls"> RSA </em>被发明出来。<em class="ls"> RSA </em>基于简单却神奇的数学结果。在接下来的部分中，我们将探索基础数学。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="9f53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面，<em class="ls"> N </em>是大于0的正整数。除非另有说明，所有整数都是正数。</p><h1 id="f057" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">欧拉极限函数</h1><p id="9e0d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">考虑<strong class="ky ir"><em class="ls">【N】</em></strong>比<em class="ls">N</em><strong class="ky ir">与<em class="ls"> N </em>互质</strong>。</p><p id="9391" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如<em class="ls"> φ(8) = 4 </em>，因为有4个小于8且与8互质的整数分别是1、3、5、7。</p><p id="5649" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以看出，对于任意两个<strong class="ky ir">互质</strong>整数<em class="ls"> p </em>和<em class="ls"> q </em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/f667cff78e73b39398c5beab84232ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W_zbPSuWNTZyDSJoZa9FQg.png"/></div></div></figure><p id="e513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想想吧。通过知道有多少个整数互质且小于<em class="ls"> p，</em>以及有多少个整数互质且小于<em class="ls"> q </em>，我们就知道有多少个整数互质且小于<em class="ls"> N=p.q </em>而无需处理<em class="ls"> p </em>和<em class="ls"> p.q </em>之间以及<em class="ls"> q </em>和<em class="ls"> p.q </em>之间的整数。</p><p id="cae5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个例子可能有助于突出这个神奇的等式。</p><p id="6e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">走72路。它等于8×9互质。</p><ul class=""><li id="c95e" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated"><em class="ls"> φ </em> (8) = 4:与8互质的整数是1，3，5，7</li><li id="def7" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated"><em class="ls"> φ </em> (9) = 6:与9互质的整数是1，2，4，5，7，8</li></ul><p id="254f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的等式告诉我们，有4x6=24个数互质且小于72。我们甚至没有考虑这些数字以及它们与72的关系，但是我们知道有多少是互质的，并且少于72。这就是数学的魔力。</p><p id="5623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在以后的文章中展示这个等式是如何工作的。现在，我们关注的是<em class="ls"> RSA </em>背后的所有结果以及它们是如何协同工作的。</p><h1 id="4832" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">欧拉定理</h1><p id="4a5c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">欧拉定理规定，对于任意正整数<em class="ls">m</em>T22】与<em class="ls"> N互质，我们有:</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/1def9e72b6f2d4158577cea6eadee64d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oorX2MJ6BIDf9pcHKRX6rg.png"/></div></div></figure><p id="4ee5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，如果我们将<em class="ls">的任意一个正整数<em class="ls"> m </em>与<em class="ls"> N </em>互质到<em class="ls"> φ(N) </em>的幂，然后除以<em class="ls"> N </em>，除法的余数将等于1。</em></p><p id="052f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，对于任何正整数k，我们有:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/b9fc726b3d8234b84f6f548ffa398786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sebkMF9PMx68g4pdYoGbDQ.png"/></div></div></figure><p id="6fb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将每条边乘以m得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/bf74e13914ca01d18800f3f3f18535c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TvPxZPXFggLz0KRIkl_-XQ.png"/></div></div></figure><p id="5fdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">公式<strong class="ky ir"> <em class="ls"> k.φ(N) + 1 </em> </strong>提醒<strong class="ky ir"> Bezout </strong> <strong class="ky ir">恒等式</strong>，它说明对于每一个数<em class="ls"> e </em> <strong class="ky ir">与<em class="ls"> φ(N) </em>互质</strong>，都有两个整数<em class="ls"> d </em>和<em class="ls"> k </em>这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/aec6d49bbbd2d2cabcc78ce6eca60601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ZqhXWoWIxLQAvtVWLD34Q.png"/></div></div></figure><p id="7ba8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果Bezout的身份现在还不直观，请不要担心，我们将在下一篇文章中回到这个问题。</p><p id="8923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过替换上面的公式，我们得到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/82819314b001fbb4825d24dcf481affe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKAMBhBGLtnYBPInsDnOlA.png"/></div></div></figure><p id="e42a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也可以写成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/7d46374416c80bb8397ef7818159e504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvgcW-wVxkBNeiPN4oGaug.png"/></div></div></figure><p id="3690" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过考虑<strong class="ky ir"> <em class="ls"> f </em> </strong>映射<em class="ls"> x </em>到<strong class="ky ir"> <em class="ls"> f(x) = x^e mod N，<br/> </em> </strong>和<strong class="ky ir"><em class="ls"/></strong>映射<em class="ls"> x </em>到<strong class="ky ir"> <em class="ls"> g(x) = x^d mod N，</em> 【T80</strong></p><p id="3793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">细心的读者会注意到，Bezout等式中出现的<em class="ls"> k </em>是一个整数，可能是也可能不是正的。但是，只有一个正的<em class="ls"> k </em>给出<strong class="ky ir"><em class="ls">m^kφ(n)</em>≡<em class="ls">1 mod n</em></strong>。在负的<em class="ls"> k </em>的情况下，我们只需将<strong class="ky ir"> <em class="ls"> k.φ(N) </em> </strong>移到等式的另一部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/020d0532d10316d6bbb75a7540d9d15c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rq8FplY2ipDD0jgmtsmsqw.png"/></div></div></figure><p id="e56b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在有两个函数<strong class="ky ir"> <em class="ls"> f </em> </strong> <em class="ls"> </em>和<strong class="ky ir"> <em class="ls"> g </em> </strong>，当我们计算<strong class="ky ir"> <em class="ls"> g(f(m)) </em> </strong>时，这两个函数给出了初始整数<em class="ls"> m </em>。整数<em class="ls"> m </em>将作为要发送的消息。<br/> <strong class="ky ir"> <em class="ls"> f </em> </strong>会公开，<strong class="ky ir"> <em class="ls"> g </em> </strong>会私有。这意味着整数<em class="ls"> e </em>和<em class="ls"> N </em>将是公共的，而整数<em class="ls"> d </em>是私有的。对<em class="ls"> (e，N) </em>是公钥，对<em class="ls"> (d，N) </em>是私钥。<strong class="ky ir">我们需要选择<em class="ls"> N </em>，这样在只知道<em class="ls"> e </em>和<em class="ls"> N </em> </strong>的情况下计算<em class="ls"> d </em>是不可行的。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="c0a4" class="ml lz iq bd mm mn ob mp mq mr oc mt mu jw od jx mw jz oe ka my kc of kd na nb bi translated">N的选择</h1><p id="8055" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了从<em class="ls"> e </em>中导出<em class="ls"> d </em>，攻击者必须首先计算<em class="ls"> φ(N) </em>。</p><p id="9b74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们选择<em class="ls"> N </em>为质数，<em class="ls"> φ(N) </em>就简单地等于<em class="ls"> N-1 </em>因为<em class="ls"> 1 </em>和<em class="ls"> N-1 </em>之间的所有数都与<em class="ls"> N </em>互质。在这种情况下，因为<em class="ls"> N </em>是公开的，所以<em class="ls"> φ(N) </em>对攻击者来说是不费力就知道的。</p><p id="a69c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个质数的平方<em class="ls">N</em>p:<strong class="ky ir"><em class="ls">N = p</em></strong>怎么样？<br/>嗯，可以很容易的看出<strong class="ky ir"> <em class="ls"> φ(p ) = p(p-1) </em> </strong>。于是，知道<em class="ls"> p </em>就足以知道<em class="ls"> φ(N) </em>。通过在<em class="ls"> 1 </em>和<em class="ls"> N </em>之间执行二分搜索法，可以在对数时间复杂度内获得<em class="ls"> p </em>。</p><p id="9c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，通过选择两个不同的质数p<em class="ls">和q</em>:<strong class="ky ir"><em class="ls">N = p . q .</em></strong>的乘积<em class="ls"> N </em>可以很容易地改善这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/e8905024a48ecc2a4a87cb770cf03fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Au9DELZeGqCSsvfTN1yhA.png"/></div></div></figure><p id="d4fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了计算<em class="ls"> φ(N) </em>，应该知道<em class="ls"> p </em>和<em class="ls"> q </em>。计算<em class="ls"> p </em>和<em class="ls"> q </em>的时间复杂度相对于<em class="ls"> N </em>来说不只是线性的。如果攻击者达到每秒测试超过10个⁰数的惊人速度(想象一下1000个谷歌大小的公司，使用他们所有的服务器进行搜索，每个服务器以每秒100亿个数字的速度执行)，如果选择大的<em class="ls"> p </em>和<em class="ls"> q </em>(例如2048位宽，这是今天使用的大小)，他们仍然需要超过10个⁹⁰世纪才能导出<em class="ls"> p </em>和<em class="ls"> q </em>。所以选择<strong class="ky ir"> <em class="ls"> N=p.q </em> </strong>两个素数的乘积就足以安全<em class="ls"> RSA </em>。</p><p id="cda1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><p id="1aa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来总结一下<em class="ls"> RSA </em>。</p><p id="cc6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每台机器通过执行以下操作生成其<em class="ls">(公共、私有)密钥对</em>:</p><ol class=""><li id="4cf9" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oh no np nq bi translated">随机生成两个2048位的大素数<em class="ls"> p </em>和<em class="ls"> q </em></li><li id="b34e" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated">计算<em class="ls"> N=p.q </em>和<em class="ls"> φ(N) = (p-1)。(q-1) </em></li><li id="9578" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated">选择一个数字<em class="ls"> e </em>与<em class="ls"> φ(N) </em>互质</li><li id="8c89" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated">使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" rel="noopener ugc nofollow" target="_blank">欧几里德扩展算法</a>，计算<em class="ls">d</em>e模<em class="ls"> φ(N) </em>的倒数</li><li id="3f93" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated">将<em class="ls"> (e，N) </em>存储为公钥，将<em class="ls"> (d，p，q，N) </em>存储为私钥。</li></ol><p id="e576" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<strong class="ky ir"> A </strong>和<strong class="ky ir"> B </strong>之间的消息的加密和解密如下:</p><ol class=""><li id="48df" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oh no np nq bi translated"><strong class="ky ir"> A </strong>将消息表示为小于<em class="ls"> N </em>的整数<em class="ls"> m </em></li><li id="5110" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated"><strong class="ky ir"> A </strong>计算<strong class="ky ir"> <em class="ls"> c=m^eB mod NB </em> </strong>其中<em class="ls"> (eB，NB) </em>是<strong class="ky ir"> B </strong>的公钥。c是加密的信息。</li><li id="fb8f" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated"><strong class="ky ir"> A </strong>将<em class="ls"> c </em>发送给<strong class="ky ir"> B </strong></li><li id="e9ef" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated"><strong class="ky ir"> B </strong>计算<strong class="ky ir"><em class="ls">c^db mod nb</em></strong><em class="ls"/>其中<em class="ls"> dB </em>是其私钥<em class="ls">，</em>并检索由<strong class="ky ir"> A </strong>加密的初始整数<em class="ls"> m </em>。</li><li id="ce56" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oh no np nq bi translated"><strong class="ky ir"> B </strong>将整数<em class="ls"> m </em>转换为初始消息</li></ol><p id="52a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样，这就是<em class="ls"> RSA </em>的基本算法。这不难理解，但我仍然无法想象发明者是如何想出这个绝妙的主意，即可以用这个数学来发明一种革命性的加密方式。</p><p id="7d4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在以后的文章中，我们将对我们看到的每一个数学结果有更多的直觉。敬请期待！</p><h1 id="e203" class="ml lz iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">参考</h1><p id="514d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">[1] W. Diffie，M. E. Hellman，密码学的新方向(1976)，IEEE信息论汇刊</p><p id="da36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] R. Rivest，A. Shamir，L. Adleman，获得数字签名和公开密钥密码系统的方法(1978年)，美国计算机学会通讯</p><p id="b5e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]维基百科，欧拉的全能函数，<a class="ae kv" href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Euler%27s_totient_function</a></p><p id="e3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]维基百科，欧拉定理，【https://en.wikipedia.org/wiki/Euler%27s_theorem T2】</p></div></div>    
</body>
</html>