<html>
<head>
<title>4 Examples To Help You Understand Nested Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助您理解嵌套循环的 4 个示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-examples-to-help-you-understand-nested-loops-94bb7df797c4#2022-03-04">https://towardsdatascience.com/4-examples-to-help-you-understand-nested-loops-94bb7df797c4#2022-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="01dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对嵌套 for 循环如何工作以及如何将它们用于各种任务有更好的直觉和理解。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1747b2d1621a7423a5441236f43eb1bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTmdNayH1LFWlgBMGApD6g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布伦特·德·兰特在<a class="ae ky" href="https://unsplash.com/@brentderanter" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="99fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嵌套的 for 循环迭代多个索引，例如行和列。具有两个级别的嵌套循环有一个内循环，该内循环在外循环的每次迭代中执行。理论上，您可以在任意多的层中嵌套一个循环，但是很难跟踪在两层以上的循环中会发生什么。</p><p id="e913" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数任务，可以使用矢量化运算或更有效的内置函数。但是，如果您正在努力理解嵌套循环的内部工作原理，我希望这些例子可以帮助您更好地理解嵌套 for 循环的工作原理，以及如何将它们用于各种任务。</p><p id="5351" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://github.com/TalkingDataScience/nested_for_loops" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到本文使用的代码。</p><p id="72f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过使用嵌套的 for 循环来解决以下四个任务:</p><ol class=""><li id="57a6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建乘法表</li><li id="20cc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">矩阵加法</li><li id="0a07" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">创建希尔伯特矩阵</li><li id="60e5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">找出伯努利数</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="097f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入示例之前，让我们使用一个嵌套的 for 循环来迭代这个小矩阵。它将打印每个元素的位置(索引)和它的值，这样我们就可以看到嵌套的 for 循环在矩阵上的迭代顺序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/0f9fc1972d732bf7e865bc7ae3564ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*7RkPTNP1jf47p3mUkMH3fg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="036f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，外部循环遍历所有行，对于每一行，内部循环遍历该行的所有元素。在这种情况下，当我们循环一个矩阵时，我们遵循命名索引<em class="mt"> i </em>和<em class="mt"> j </em>的惯例，这就是在数学中索引矩阵的方式。但是你可以给它们起任何你想要的名字，这有助于你记住迭代的顺序。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e5bd" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">乘法表</h1><p id="831c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们从一个简单的例子开始，它的输入、迭代和输出都非常简单。我们将创建一个乘法表。</p><ul class=""><li id="42b5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">我们指定表的大小，并创建一个矩阵来保存这些值</li><li id="6ecd" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">创建一个嵌套的 for 循环，外部循环遍历行，内部循环遍历列</li><li id="726a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">通过将每个行索引乘以列索引来计算矩阵中每一项的值，并将它们存储在矩阵中</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3ef7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来分解一下每个循环中发生了什么。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="bd5f" class="nx mv it nt b gy ny nz l oa ob"><strong class="nt iu">Outer loop, loop 1</strong>, <strong class="nt iu">for i=1: </strong>The first outer loop stays on index i=1 (row 1) and the inner loop iterates over the entire length of index j, the columns. That is, we iterate over each j element (j=1 to j=n) in this row (i=1):<br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=n</strong>:<br/>    i=1, j=1, multiplies i=1 with j=1 and assigns value to mult_table[row i=1, col j=1]<br/>    i=1, j=2, multiplies i=1 with j=2 and assigns value to mult_table[row i=1, col j=2]<br/>    i=1, j=3, multiplies i=1 with j=3 and assigns value to mult_table[row i=1, col j=3]<br/>    ...<br/>    i=1, j=1n, multiplies i=1 with j=n and assigns value to mult_table[row i=1, col j=n]</span><span id="f47e" class="nx mv it nt b gy oc nz l oa ob"><strong class="nt iu">Outer loop, loop 2</strong>,<strong class="nt iu"> i=1:</strong> The second outer loop stays on index i=2 (row 2) and the inner loop iterates over the entire length of index j, the columns:    <br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=n</strong>:<br/>    i=2, j=1, multiplies i=2 with j=1 and assigns alue to mult_table[row i=2, column j=1]<br/>    i=2, j=2, multiplies i=2 with j=2 and assigns value to mult_table[row i=2, column j=2]<br/>    i=2, j=3, multiplies i=2 with j=3 and assigns value to mult_table[row i=2, column j=3]<br/>    ...<br/>    i=2, j=n, multiplies i=2 with j=n and assigns value to mult_table[row i=2, j=n]</span></pre><p id="ba10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环继续像这样迭代，每行的列中的每个元素，直到我们迭代完最后一行 n。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="57f1" class="nx mv it nt b gy ny nz l oa ob"><strong class="nt iu">Outer loop, loop n</strong>,<strong class="nt iu"> i=n:</strong> The last outer loop stays on index i=n (row n) and the inner loop iterates over the entire length of index j, the columns:<br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=n</strong>:<br/>    i=n, j=1, multiplies i=n with j=1 and assigns value to mult_table[row i=n, col j=1]<br/>    i=n, j=2, multiplies i=n with j=2 and assigns value to mult_table[row i=n, col j=2]<br/>    i=n, j=3, multiplies i=n with j=3 and assigns value to mult_table[row i=n, col j=3]<br/>    ...<br/>    i=n, j=n, multiplies i=10 with j=n and assigns value to mult_table[row i=n, col j=n]</span></pre><p id="738f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个嵌套的 for 循环中，我们一次填充乘法表的一行，从左到右将值添加到列中。行 I 的每次迭代包含或嵌套了列 j 的 10 次迭代。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0f47" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">矩阵加法</h1><p id="dc50" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在矩阵加法中，被加的矩阵必须具有相同的维数(行数和列数)。矩阵加法是一个简单的运算，我们将两个矩阵的相应元素相加。</p><p id="a10e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将 A (a_11)的第一行(i=1)和第一列(j=1)中的元素添加到 B (b_11)的第一行(i=1)和第一列(j=1)中的相应元素，依此类推。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e5bc2216bc0c2832e9ecce7f5b7a3191.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nTvlygkM_pcymDaCodUZSg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="07d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用小数字，以便于看到矩阵的每一个加法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/359565f0b6fd251fd4578c7f900b27d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmbXxArMES_61TAW43MiEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="dd36" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">我们创建两个矩阵，A 和 B，我们将添加。我们还创建了一个矩阵 C，用于存储结果。</li><li id="cbc2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">创建一个嵌套的 for 循环，外层循环遍历行，内层循环遍历列。</li><li id="bb33" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">我们将矩阵 A 和 B 中的每个对应元素相加，并将总和存储在矩阵 c 中的对应索引中。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，迭代遵循与乘法表中相同的模式。唯一不同的是，它同时迭代三个矩阵 A、B 和 C。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="c209" class="nx mv it nt b gy ny nz l oa ob"><strong class="nt iu">Outer loop, loop 1</strong>, <strong class="nt iu">i=1: </strong>The first outer loop stays on index i=1 (row 1) and the inner loop iterates over the entire length of index j (j=1 to j=3), for all three matrices A, B and C:<br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=3</strong>:<br/>    Adding matrix A[row i=1, col j=1] to matrix B[row i=1, j=1] and assigns value to matrix C[row i=1, col j=1]<br/>    Adding matrix A[row i=1, col j=2] to matrix B[row i=1, j=2] and assigns value to matrix C[row i=1, col j=2]<br/>    Adding matrix A[row i=1, col j=3] to matrix B[row i=1, j=3] and assigns value to matrix C[row i=1, col j=3]</span><span id="628c" class="nx mv it nt b gy oc nz l oa ob"><strong class="nt iu">Outer loop, loop 2</strong>, <strong class="nt iu">i=2: </strong>Here i=2 (row 2 in all matrices), and the inner loop iterates over the entire length of index j (j=1 to j=3), for all three matrices A, B and C.<br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=3</strong>:<br/>    Adding matrix A[row i=2, col j=1] to matrix B[row i=2, j=1] and assigns value to matrix C[row i=2, col j=1]<br/>    Adding matrix A[row i=2, col j=2] to matrix B[row i=2, j=2] and assigns value to matrix C[row i=2, col j=2]<br/>    Adding matrix A[row i=2, col j=3] to matrix B[row i=2, j=3] and assigns value to matrix C[row i=2, col j=3]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c8aa" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">希尔伯特矩阵</h1><p id="a39b" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">希尔伯特矩阵是一个正方形矩阵，其中每个元素是一个单位分数，定义如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/eb963d09a3ee7305ab281fd1b1f42850.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*ne6NIW6gzmUlUZ9rz44pjQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是 5×5 希尔伯特矩阵:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a4d049785b025a69a84c35d345aa308b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*K2HxQuR0F-ery5BVGG-TYg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b1a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将定义一个创建任意大的希尔伯特矩阵的函数:</p><ul class=""><li id="2be8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated">创建选定大小的矩阵 H</li><li id="6d77" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">创建一个嵌套的 for 循环，外部循环遍历行，内部循环遍历列</li><li id="4f76" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">计算矩阵中每一项的值</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f90b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个循环中，它按照以前的模式，一次填充矩阵的一行，从左到右在列中填充值。对于每个元素，它根据公式计算单位分数，并将值赋给希尔伯特矩阵。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="e23d" class="nx mv it nt b gy ny nz l oa ob"><strong class="nt iu">Outer loop, loop 1</strong>, <strong class="nt iu">i=1: </strong>The first outer loop stays on index i=1 (row 1) and the inner loop iterates over the entire length of index j, the columns. That is, we iterate over each j element (j=1 to j=n) in this row (i=1):<br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=n</strong>:<br/>    i=1, j=1, calculates 1/(row i=1 + col j -1) and assigns value to hilbert[row i=1, col j=1]<br/>    i=1, j=2, calculates 1/(row i=1 + col j -1) and assigns value to hilbert[row i=1, col j=2]<br/>    i=1, j=3, calculates 1/(row i=1 + col j -1) and assigns value to hilbert[row i=1, col j=3]<br/>    …<br/>    i=1, j=n, calculates 1/(row i=1 + col j -1) and assigns value to hilbert[row i=1, col j=n]</span><span id="9654" class="nx mv it nt b gy oc nz l oa ob"><strong class="nt iu">Outer loop, loop n</strong>, <strong class="nt iu">i=n: </strong>The last outer loop stays on index i=n (row n) and the inner loop iterates over the entire length of index j, the columns. That is, we iterate over each j element (j=1 to j=n) in this row (i=n):<br/>    <strong class="nt iu">Inner loop: The inner loop will iterate from j=1 to j=n</strong>:<br/>    i=n, j=1, calculates 1/(row i=n + col j -1) and assigns value to hilbert[row i=n, col j=1]<br/>    i=n, j=2, calculates 1/(row i=n + col j -1) and assigns value to hilbert[row i=n, col j=2]<br/>    i=n, j=3, calculates 1/(row i=n + col j -1) and assigns value to hilbert[row i=n, col j=3]<br/>    ...<br/>    i=n, j=n, calculates 1/(row i=n + col j -1) and assigns value to hilbert[row i=n, col j=n]</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="051e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">寻找伯努利数</h1><p id="2de4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">最后，我将展示一个例子，说明我们如何通过使用嵌套的 for 循环来求解有索引的数学方程。我们将编写一个函数来寻找第二个伯努利数的第一个数字。第二伯努利数可以用下面的等式表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/e3b9b85e739fbdc4d28d84979ec9e8a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kvpqSV-q3xdJ5RiFrjQaiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解如何计算这些数字，让我们来计算第二个数字 B_2。当 k=0 时，只有一项 j=0。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/7202a02db3a7d7ea2b887822ad91c45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*11x_zE9ZPiGHqfJ7qFH1xA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4cdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当 k=1 时，需要计算 j=0 和 j=1 的两项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/769ccf41881abc4fc87d2edd7f09bc34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bl7zxCBu0f7mN-175kDtIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当 k=2 时，j=0，j=1，j=2 有三项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d66342ee9889a14d1b98061ea241d17e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSYndFCYH-34XzLvAddrNQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，如果我们想找到更高的伯努利数，这个方程很快就变得复杂了。我们可以让 R 用一个嵌套的 for 循环来替我们完成这项工作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a1e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们不像前面三个例子那样遍历行和列。相反，我们正在计算 k 和 j 的每一项，如上面求解伯努利数 2 的例子所示。</p><ul class=""><li id="b5e0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nr mb mc md bi translated"><strong class="lb iu">外循环的迭代次数</strong>是等式中 k 的<strong class="lb iu">外和，范围从 0 到 n，如等式中所定义。</strong></li><li id="4858" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nr mb mc md bi translated">作为 j 的<strong class="lb iu">内求和的<strong class="lb iu">内循环</strong>的迭代次数由 k 决定，因为它的范围从 0 到 k</strong></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2725" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="e7ec" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">出于某种原因，我发现嵌套循环有些令人困惑，即使它们的逻辑非常清楚。我不愿意承认的是，嵌套循环经常会产生我没有预料到的结果，这也不是我想要的。在那些场合，我发现回到这些简单的例子有助于“重置”我的思维。如果您发现嵌套循环令人困惑，我希望这些例子可以帮助您。</p><p id="70a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在这个<a class="ae ky" href="https://github.com/TalkingDataScience/nested_for_loops" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中找到本文使用的代码。</p></div></div>    
</body>
</html>