<html>
<head>
<title>Implementing Various Root-Finding Algorithms in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现各种求根算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-various-root-finding-algorithms-in-python-67917ef090b3#2022-04-11">https://towardsdatascience.com/implementing-various-root-finding-algorithms-in-python-67917ef090b3#2022-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b23e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过在数据科学和逻辑回归中实际应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ea0d2d1ebc7bc5f78be4b42e4a8c5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiY4HEL_3n_TPxu_oYR_aA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Doggo寻找根</p></figure><p id="702d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据科学中，你会发现我们的许多任务包括最大化或最小化统计数据。在回归分析中，你会找到使误差平方和最小化的参数。在朴素贝叶斯中，你识别出<strong class="la iu">最大化</strong>后验概率的类别。还有很多其他的例子，比如决策树<strong class="la iu">最大化</strong>信息增益，SVM <strong class="la iu">最大化</strong>余量，EM算法<strong class="la iu">最大化</strong>完全对数似然的期望，<em class="lu">等等</em>。这些计算中有一些非常基本，简单的代数就能很好地完成。然而，一些更复杂的计算需要数值算法来近似它们。</p><p id="1ce1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用于机器学习的最流行的优化算法当然是<em class="lu">梯度下降算法</em>。但是也有其他方法可以在数值上逼近一个函数的最大值或最小值。本文将向您展示一些可以替代<em class="lu">梯度下降算法</em>的<em class="lu">求根算法</em>。注意，每种求根算法都有特定的收敛要求；因此，没有一种算法可以普遍适用于所有问题。</p><p id="7072" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">求根算法是对满足任何连续函数<em class="lu"> f(x) </em>的<em class="lu"> f(x) = 0 </em>的<em class="lu"> x </em>值进行近似的数值方法。设<em class="lu"> g(x) </em>为<em class="lu"> f(x) </em>的导数。然后最大化或最小化<em class="lu"> f(x) </em>可以通过找到<em class="lu"> g(x) </em>的根来完成，其中<em class="lu"> g(x) = 0 </em>。我们使用求根算法来找到这些根<em class="lu">。</em></p><p id="4b79" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这里给出的所有算法都是迭代算法。因此，如果我提到“当前的<em class="lu"> x </em>的值”，它仅仅意味着当前迭代的值。</p><p id="5bd0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们所有的例子，我将在下面使用这个函数，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/f30052a50b4159410c5b694830a47ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Tu6KxI4iWK6G6jEflVUsw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的主要功能</p></figure><p id="9668" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将试图找出这个函数的根。如果你想最大化或最小化，你必须先求导。</p><h1 id="6a80" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1.定点方法</h1><p id="4bc0" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">为了让我们开始，我选择了最简单的算法(在我看来)来让你感受一下求根算法是如何工作的。这个算法的思想是，在你设置了<em class="lu"> f(x) = 0 </em>之后，你要把剩下的方程排列成下面的形式<em class="lu"> x = g(x) </em>。让我向您展示如何使用我们的函数来实现这一点，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/d2f32a05cb0b8e8d538378d15b436a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kMnqCIa7SKQPxzcnnt3rEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">x = g(x)格式的最终结果</p></figure><p id="1aef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，您可以为任何<em class="lu"> f(x) </em>找到多个<em class="lu"> g(x) </em>，每个<em class="lu"> g(x) </em>具有不同的收敛特性。接下来是从迭代的角度来看<em class="lu"> x = g(x) </em>方程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/655884bc60ab9cc8941bab63bef219b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WjVZDkygUYN8Va1C1vJs2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">就迭代而言，x = g(x)</p></figure><p id="bf8a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LHS是<em class="lu"> x，</em>的下一次迭代更新，RHS包含<em class="lu"> x </em>的当前值。</p><p id="0f4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们重述一下，要使用定点迭代找到<em class="lu"> f(x) </em>的根，您必须:</p><ol class=""><li id="314b" class="mv mw it la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">设置<em class="lu"> f(x) = 0 </em></li><li id="e3d6" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">重新排列为<em class="lu"> x = g(x) </em></li><li id="a8b1" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">设置一个初始值<em class="lu"> x⁰ </em></li><li id="6e2f" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">将<em class="lu"> x </em>改为<em class="lu"> g(x) </em>进行更新</li><li id="1c1f" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果<em class="lu"> |f(x)| </em>的值不小于εϵ，则转到步骤4</li></ol><p id="962c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你们中的一些人可能通过查看代码更容易理解这个概念，所以下面是我在Python中是如何做的，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c1e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不需要在定点方法的代码中指定我们的f(x)函数，只需要指定<em class="lu"> g(x) </em>形式。</p><p id="b1f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我调用下面的代码，</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1413" class="nq lx it nm b gy nr ns l nt nu">FixedPoint(g, 4)</span></pre><p id="30e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我会得到</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e30e" class="nq lx it nm b gy nr ns l nt nu">2.965794554141745</span></pre><p id="bc1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定点方法到此结束。</p><h1 id="a242" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2.牛顿-拉夫森方法</h1><p id="34b6" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">牛顿-拉夫森方法是最常用的求根方法之一，在数据科学中有实际应用。我们将在后面探索这个应用程序。</p><p id="3a96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">牛顿-拉夫森方法的思想是，给定我们当前的<em class="lu"> x </em>的值，我们想要在<em class="lu"> x </em>处画出<em class="lu"> f(x) </em>的切线。然后我们在切线与<em class="lu"> x </em>轴相交的截距处设置<em class="lu"> x </em>的下一个值。</p><p id="e406" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们做数学。回想一下在初中数学课上，我们被告知给定在<em class="lu"> xy </em>平面上的2个点的坐标，我们可以用这个公式求出通过这2个点的直线的斜率，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/861508b8fd30527b090a5a2676a72fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8VYjswe3Wjpj5nb87xbSOA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">梯度公式</p></figure><p id="7877" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">把这个转化成我们的问题，我们有两组坐标。我们的第一个坐标是我们当前迭代的<em class="lu"> x </em>及其在函数中对应的<em class="lu"> y </em>值，或者简称为<em class="lu"> f(x) </em>。我们的第二个坐标是新的<em class="lu"> x </em>值及其对应的<em class="lu"> y </em>值。但是回想一下，我们将新的<em class="lu"> x </em>值设置为切线和<em class="lu"> x </em>轴的交点，这意味着它的<em class="lu"> y </em>值将始终是<em class="lu"> 0 </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/0d2c9573ed76b5df7181c37d4c01e86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kdmu-F3Uzaya2ZePjn6Svw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的坐标</p></figure><p id="fdab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">给定这些坐标，我们想要找到通过这些点的线的梯度。梯度就是由集合定义在当前x值处评估的<em class="lu"> f(x) </em>的导数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/bef442e02689f92d0c2831c162313142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jF37sdLs6LgpTjbnPFrw6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获得牛顿-拉夫逊公式</p></figure><p id="006d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算的最后一行是牛顿-拉夫森公式。概括地说，这个算法的步骤非常简单，</p><ol class=""><li id="a106" class="mv mw it la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">设置一个初始值x⁰</li><li id="463a" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">给定<em class="lu"> x </em>的电流值，找到<em class="lu"> f(x) </em>和<em class="lu">f’(x)</em></li><li id="76b3" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">使用牛顿-拉夫森公式更新x</li><li id="85c8" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果<em class="lu"> |f(x)| </em>的值不小于εϵ，则转到步骤2</li></ol><p id="5e75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将此代码化，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="e343" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我使用了一个外部库来计算导数。如果能手动计算导数就更理想了。</p><p id="407d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行下面的代码行，</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6041" class="nq lx it nm b gy nr ns l nt nu">NewtonRaphson(f, 4)</span></pre><p id="b8ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会回来</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e112" class="nq lx it nm b gy nr ns l nt nu">2.9657944029135495</span></pre><p id="23fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就结束了牛顿-拉夫森方法。</p><h1 id="be1b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3.割线法</h1><p id="42d4" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">割线法是牛顿-拉夫逊法的一种近似。我们不是使用<em class="lu"> x </em>的当前值来计算<em class="lu"> x </em>的下一个值，而是使用<em class="lu"> x </em>的当前值和先前值来计算<em class="lu"> x </em>的下一个值。当函数的导数很难得到时，我们就用割线法。</p><p id="98aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为此，我们使用在当前值<em class="lu"> x </em>处评估的导数<em class="lu"> f(x) </em>的以下近似值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/7a6dc86cc80d249d22bb148c46816160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K51zqtnyBlqgYK4sol_yJw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">割线法导数逼近</p></figure><p id="e780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这个近似值使用了当前和先前的<em class="lu"> x </em>的迭代。然后我们把这个近似值代入牛顿-拉夫森公式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/66eb711a6372707b776482b7f054015e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*okyw6ZM4ZrRt_nvt9l-YvA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从牛顿-拉夫逊到割线</p></figure><p id="4481" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一行是割线公式，我们将用它来逼近函数的根。让我们回顾一下，</p><ol class=""><li id="caf0" class="mv mw it la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">设定一个初始值<em class="lu"> x⁰ </em>和<em class="lu"> x </em>，表示<em class="lu"> x </em>的先前和当前值</li><li id="3a34" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">给定<em class="lu"> x </em>的最后两个值，使用割线公式更新<em class="lu"> x </em></li><li id="bba0" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果<em class="lu"> |f(x)| </em>的值不小于εϵ，则转到步骤2</li></ol><p id="ef3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将此代码化，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="259f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行下面的代码行，</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="94ee" class="nq lx it nm b gy nr ns l nt nu">SecantMethod(f, 2, 4)</span></pre><p id="e74c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会回来</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1d9c" class="nq lx it nm b gy nr ns l nt nu">2.9657943958960433</span></pre><p id="9d24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">割线法到此结束。</p><h1 id="d112" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">4.二分法</h1><p id="13c1" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">二分法是一种括号法，这意味着它需要两次初始猜测。但是与割线法不同，在割线法中，最初的两次猜测是连续的，二分法要求最初的两次猜测将根括起来。</p><p id="0aa0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设<strong class="la iu"> <em class="lu"> L </em> </strong>为下界猜测，<strong class="la iu"><em class="lu"/></strong>为上界猜测。大意是如果<em class="lu">f(</em><strong class="la iu"><em class="lu">L</em></strong><em class="lu">f(</em><strong class="la iu"><em class="lu">U</em></strong><em class="lu">)&lt;0</em>或者换句话说，<em class="lu">f(</em><strong class="la iu"><em class="lu">L</em></strong><em class="lu">)</em>和<em class="lu">f(</em><strong class="la iu"><em class="lu">U<em class="lu">我们用一种有点类似于二分搜索法的方法来求这个根。注意，这意味着<strong class="la iu"> <em class="lu"> L </em> </strong>和<strong class="la iu"> <em class="lu"> U </em> </strong>必须是不同的符号。</em></em></strong></p><p id="635d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设<strong class="la iu"> <em class="lu"> R </em> </strong>为我们当前对f(x)的根的猜测，我们设<strong class="la iu"> <em class="lu"> R </em> </strong>为<strong class="la iu"> <em class="lu"> L </em> </strong>和<strong class="la iu"> <em class="lu"> U </em> </strong>的中点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/1057b13903d130c4603aa0bf36c7f59f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7Yv9B21nFeZnCTqSxwpJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">二分法更新公式</p></figure><p id="f29b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果R不是f(x)的实际根，我们将需要评估根是在<strong class="la iu"> <em class="lu"> R </em> </strong>之下还是之上。我们可以使用与之前类似的逻辑对此进行测试，即测试是否<em class="lu">f(</em><strong class="la iu"><em class="lu">L</em></strong><em class="lu">)f(</em><strong class="la iu"><em class="lu">R</em></strong><em class="lu">)&lt;0和f(</em><strong class="la iu"><em class="lu">R</em></strong><em class="lu">)f(</em><strong class="la iu"><em class="lu">U</em></strong><em class="lu">&lt;0)如果前者成立，那么我们希望将搜索区域限制在<strong class="la iu"> <em class="lu"> L </em> </strong>和<strong class="la iu"> <em class="lu"> R </em> </strong>内，因此我们更新<strong class="la iu"><em class="lu"/></strong><em class="lu">=</em><strong class="la iu"><em class="lu">R</em></strong>并保持<strong class="la iu"> <em class="lu"> L </em> </strong>的值。同样如果后者成立，我们更新<strong class="la iu"><em class="lu">L</em></strong><em class="lu">=</em><strong class="la iu"><em class="lu">R</em></strong>并保持<strong class="la iu"> <em class="lu"> U </em> </strong>的值。我们一直这样做，直到<em class="lu">f(</em><strong class="la iu"><em class="lu">R</em></strong><em class="lu">)</em>足够接近零。</em></p><p id="1683" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们回顾一下，</p><ol class=""><li id="0ee8" class="mv mw it la b lb lc le lf lh mx ll my lp mz lt na nb nc nd bi translated">设置一个初始化的猜测值<strong class="la iu"> <em class="lu"> L </em> </strong>和<strong class="la iu"> <em class="lu"> U </em> </strong>，其中至少有一根<strong class="la iu"> <em class="lu"> R </em> </strong>必须在区域<strong class="la iu"><em class="lu">L</em></strong><em class="lu">&lt;</em><strong class="la iu"><em class="lu">R</em></strong><em class="lu">&lt;</em>之间</li><li id="bb9d" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">使用二分法更新公式将<strong class="la iu"> <em class="lu"> R </em> </strong>设置为<strong class="la iu"> <em class="lu"> L </em> </strong>和<strong class="la iu"> <em class="lu"> U </em> </strong>的中点。</li><li id="232e" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">检查是否有<em class="lu">f(</em><strong class="la iu"><em class="lu">L</em></strong><em class="lu">)f(</em><strong class="la iu"><em class="lu">R</em></strong><em class="lu">)&lt;0和f(</em><strong class="la iu"><em class="lu">R</em></strong><em class="lu">)f(</em><strong class="la iu"><em class="lu">U</em></strong></li><li id="2df8" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果是前者，设置<strong class="la iu"><em class="lu">U</em></strong><em class="lu">=</em><strong class="la iu"><em class="lu">R</em></strong>并保持<strong class="la iu"> <em class="lu"> L </em> </strong>的值。如果是后者，设置<strong class="la iu"><em class="lu">L</em></strong><em class="lu">=</em><strong class="la iu"><em class="lu">R</em></strong>并保持<strong class="la iu"> <em class="lu"> U </em> </strong>的值。</li><li id="07c7" class="mv mw it la b lb ne le nf lh ng ll nh lp ni lt na nb nc nd bi translated">如果<em class="lu">|</em><strong class="la iu"><em class="lu">f(r)</em></strong><em class="lu">|</em>的值不小于εϵ，则转到步骤2</li></ol><p id="6074" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们把它编码，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8293" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行下面的代码行，</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6d4e" class="nq lx it nm b gy nr ns l nt nu">BisectionMethod(f, 0, 5)</span></pre><p id="dbb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会回来</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="de9c" class="nq lx it nm b gy nr ns l nt nu">2.96579440290151</span></pre><p id="b48f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就结束了二分法。</p><h1 id="92f8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">5.假定位法</h1><p id="b235" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">对于假定位法，我会非常简要的说明一下。该方法与二分法相同，除了我们在每次迭代中使用不同的公式更新<strong class="la iu"> <em class="lu"> R </em> </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ee41adb54285e19d598f4418aea0eb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swuMlrrbot7vdyC6uZSajw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误位置更新公式</p></figure><p id="fabd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个更新和对分更新的区别在于，这个考虑的是<em class="lu">f(</em><strong class="la iu"><em class="lu">L</em></strong><em class="lu">)</em>和<em class="lu">f(</em><strong class="la iu"><em class="lu">U</em></strong><em class="lu">)</em>哪个更接近零。</p><p id="9bac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以从二分法中回收代码来提高效率。但是为了清楚起见，我将再次给出完整的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c1f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行下面的代码行，</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="52a0" class="nq lx it nm b gy nr ns l nt nu">FalsePosition(f, 0, 4)</span></pre><p id="ebc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">会回来</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="31de" class="nq lx it nm b gy nr ns l nt nu">2.965794050755957</span></pre><p id="fc14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就结束了伪定位方法。对于本文中的所有算法，您可以通过设置一个较小的epsilon值来增加近似的准确性，以换取运行时间。</p><h1 id="1fb9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">真实数据科学应用</h1><p id="bd37" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">这是一个关于牛顿-拉夫森方法如何用于数据科学的数学解释推导。如果你只是在寻找关于求根方法的解释，跳过这一节。</p><p id="703d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我确实提到过牛顿-拉夫森方法通常用于数据科学。事实上，它被用来估计广义线性模型(GLM)的参数。最流行的GLM当然是逻辑回归(LR)。我将演示在LR拟合中使用牛顿-拉夫森方法。</p><p id="1bdb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">LR以下面的方式模拟结果的概率，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/226fdffe32d0f04f1b9c81a3f7bd5489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ext2kGFOBXb7BzPQlhtBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">逻辑回归</p></figure><p id="9f2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拟合LR包括找到使其似然性或对数似然性最大化的所有β参数。为了简单起见，我们通常选择后者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/196a4b0203a42601b9ec3c3becc71981.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pbrQ8WDH05vKSrFL_qRcPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">似然和对数似然</p></figure><p id="9f1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，估计概率(或等式中的p-hat)是β的函数。因此，我们现在的任务是找到使对数似然最大化的β。</p><p id="09ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回想一下牛顿-拉夫森公式，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/fb6f97fb01461349c4bcdf0bb5832890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MYfNh4AaerHuyWNtAIOmLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">牛顿-拉夫逊求根公式</p></figure><p id="e3e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个公式用来求一个函数<em class="lu"> f(x) </em>的根。如果我们想找到使函数最大化的<em class="lu"> x </em>，我们需要在<em class="lu">f’(x)</em>上应用这个函数。牛顿-拉夫森公式因此被更新为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/184fe9de06cf3ff40ed9e939d98f62da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uSP18P6A6iidhjaz8gVHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数最大化的牛顿-拉夫逊公式</p></figure><p id="3fd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将此转化为我们的LR问题，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/5025b58d93f02c947efeb9ff65bc9883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8H7YVAgy0IMS6XPj0I0Ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LR的牛顿-拉夫逊公式</p></figure><p id="6e94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意到，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/ea4dcf92bb360eaac4a84b881d8bfa9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B4X6qKipoi-qn-0NqZ6_fg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">衍生产品的定义</p></figure><p id="b60a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一阶导数只是由每个参数导出的对数似然的向量(<em class="lu"> n×1 </em>)。二阶导数等于负雅可比矩阵(<em class="lu"> n×n </em>)。负雅可比矩阵的逆也是一个(<em class="lu"> n×n </em>)矩阵。当二阶导数的倒数乘以一阶导数时，我们得到一个(<em class="lu"> n×1 </em>)向量。</p><p id="0dc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们用雅可比矩阵相对于<em class="lu"> y </em>的期望值来代替雅可比矩阵，这个算法就叫做<strong class="la iu"> Fisher Scoring </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/4f080be12435397c2e5f7ec1ab2e1b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e85xww53uyRHTA1VCo5CoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">费希尔信息</p></figure><p id="8826" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">费希尔评分算法现在可以定义为:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/173c6e2a83f3f40cb0dabc6c18a9f0b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNxA5TqZTKZSCt4awEafpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">费希尔评分</p></figure><p id="a389" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">估计参数现在只是这个费希尔评分公式的迭代。如果你使用R(编程语言)通过<em class="lu">远程</em>包来做你的GLMs，默认的参数估计技术是Fisher评分算法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/b162d348ce0e7c64f8f65b4af5c0a968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWzOSa_PjBHFCGudLT1s5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以R表示的GLM输出</p></figure><p id="b485" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意最后一行陈述了费希尔评分迭代的次数。这仅仅意味着牛顿-拉夫森方法的迭代次数。</p><h1 id="0360" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">恭喜</h1><p id="c7ff" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">你已经完成了基本求根算法的所有解释。特别感谢那些完成并理解逻辑回归部分的人。在GitHub 上找到完整的代码。如果你喜欢这篇文章，请考虑鼓掌并关注。请在评论中分享你的反馈和想法。感谢您的阅读！</p></div></div>    
</body>
</html>