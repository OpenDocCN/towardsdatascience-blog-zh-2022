<html>
<head>
<title>Automate Excel Worksheets Combination with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python自动组合Excel工作表</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automate-excel-worksheets-combination-with-python-181052177baf#2022-02-14">https://towardsdatascience.com/automate-excel-worksheets-combination-with-python-181052177baf#2022-02-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="488d" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://towardsdatascience.com/tagged/automation-with-pywin32" rel="noopener" target="_blank">使用PYWIN32实现自动化</a></h2><div class=""/><div class=""><h2 id="615f" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">用Python将多个Excel工作簿和多个工作表合并，并保持格式</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/2a36741e2b7062c34631366be66b2e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ATBWrJqaOLmv7SA3ab-Sw.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://unsplash.com/@artmilitonian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Artem Militonían </a>在<a class="ae li" href="https://unsplash.com/s/photos/lazy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="9bcc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我的创造力(懒惰)对重复任务的另一种自动化。所以，我被要求<strong class="ll je">根据文件名</strong>中的日期组合几个Excel工作簿 <strong class="ll je">。一开始，我非常乐观，因为使用Python这个任务很简单。我需要做的就是用<code class="fe mf mg mh mi b">pandas</code>读取文件，然后使用神奇的<code class="fe mf mg mh mi b">append</code>方法，然后保存到一个新文件。搞定了。</strong></p><p id="d680" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不幸的是，这个计划没有成功，因为所有的Excel工作簿内部都有多个工作表，并且根据工作表中的值有一些预设的格式。好了，图片说话比较好，练习册看起来像下图。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj mj"><img src="../Images/497ee541f6a38b8a8c30e4a5c6d77c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*uv0BQVaSLE9R4W_gBVieqQ.gif"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">工作簿示例。作者GIF。</p></figure><p id="c824" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">所以格式设置得很好，使用<code class="fe mf mg mh mi b">pandas</code>合并它们会删除所有格式，这是不可接受的。有一秒钟我想我会遵循KISS(保持简单愚蠢)方法，即打开每个Excel工作簿，一个一个地复制和粘贴。但是，处理速度快死我了🤦‍♂️.</p><p id="7f7a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我将再次使用我最喜欢的Python库来完成这个自动化任务，它是✨ <strong class="ll je"> PyWin32 ✨ </strong>。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj mr"><img src="../Images/9b739a98ba3cb4a946005298c981e06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OtJkQuP8LOe6Ved3kh346A.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">25个练习册将在后面的示例中合并。图片作者。</p></figure><p id="3906" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于本教程，准备了25个Excel工作簿，每个工作簿只有一个工作表(由Python脚本生成)。这些工作簿包含2019年5月至9月马来西亚选定州的每个分公司的利润信息，如下图所示。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ms"><img src="../Images/1ef133f8825f314402cfdf3cac5096b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*II7f2-mkmMSkeeq-Cx-zHQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">每个工作簿的内部外观。图片作者。</p></figure><p id="ad98" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">工作簿按照以下格式命名:<state> <white space=""> <yyyymmdd>。xlsx，而工作表的命名遵循以下格式:<state> _ <m>。</m></state></yyyymmdd></white></state></p><p id="12a0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每个工作表都有如下预设格式:</p><ol class=""><li id="33b8" class="mt mu iu ll b lm ln lp lq ls mv lw mw ma mx me my mz na nb bi translated">自动过滤</li><li id="635e" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated">自动调整</li><li id="b9ce" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated">条件格式</li></ol></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><p id="06ee" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在本文中，将演示两种类型的Excel工作表的复制粘贴:</p><ol class=""><li id="2855" class="mt mu iu ll b lm ln lp lq ls mv lw mw ma mx me my mz na nb bi translated">复制整个Excel表格并将其作为新工作表粘贴到另一个Excel工作簿中</li><li id="16b4" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated">复制一个Excel工作表的数据表<strong class="ll je">并粘贴到另一个Excel工作表的现有数据表</strong>的下方</li></ol><p id="cc31" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最后但同样重要的是，我将在下面的每个示例中频繁地提到类似对象、方法或属性这样的词。我曾经写过一篇文章(<a class="ae li" rel="noopener" target="_blank" href="/automate-excel-with-python-7c0e8c7c6256">使用Python实现Excel的自动化</a>)来解释对象、方法或属性的概念。我亲爱的读者是鼓励和欢迎阅读文章每当他们有疑问的三个概念。</p><blockquote class="nh"><p id="1913" class="ni nj iu bd nk nl nm nn no np nq me dk translated">开始吧！</p></blockquote></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="b419" class="nr ns iu bd nt nu nv nw nx ny nz oa ob kj oc kk od km oe kn of kp og kq oh oi bi translated">A.复制整个Excel工作表并<strong class="ak">将其作为新工作表</strong>粘贴到另一个Excel工作簿中</h1><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oj ok l"/></div></figure><p id="1fbf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可以观看视频或继续阅读本部分。</p><h2 id="8585" class="ol ns iu bd nt om on dn nx oo op dp ob ls oq or od lw os ot of ma ou ov oh ja bi translated"><strong class="ak"> 1 .将一个工作簿中的一个工作表复制/合并到另一个现有工作簿中</strong></h2><p id="458e" class="pw-post-body-paragraph lj lk iu ll b lm ow ke lo lp ox kh lr ls oy lu lv lw oz ly lz ma pa mc md me in bi translated">此示例将演示如何将一个工作表从一个工作簿复制到另一个现有工作簿。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="fc64" class="ol ns iu mi b gz pf pg l ph pi">import win32com.client as win32<br/>from pathlib import Path<br/>win32c =  win32.constants</span><span id="15d9" class="ol ns iu mi b gz pj pg l ph pi"><strong class="mi je"># create excel object</strong><br/>excel = win32.gencache.EnsureDispatch('Excel.Application')</span><span id="c017" class="ol ns iu mi b gz pj pg l ph pi"><strong class="mi je"># excel can be visible or not</strong><br/>excel.Visible = True  # False</span></pre><p id="75ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">第一步是导入库并创建<strong class="ll je"> Excel对象</strong>。然后，我们将打开相关的工作簿。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="a17f" class="ol ns iu mi b gz pf pg l ph pi"><strong class="mi je"># open workbooks</strong><br/>f_path = Path.cwd() # your path<br/>f1_name = 'Penang 20190901.xlsx'<br/>f2_name = 'Sabah 20190901.xlsx'<br/>filename1 = f_path / f1_name<br/>filename2 = f_path / f2_name<br/>wb1 = excel.Workbooks.Open(filename1)<br/>wb2 = excel.Workbooks.Open(filename2)<br/>sheetname = "Penang_9"</span></pre><p id="5a00" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在本例中，我们将名为“Penang_9”的工作表从“Penang 20190901.xlsx”复制到名为“Sabah 20190901.xlsx”的现有工作簿中。打开工作簿后，我们可以开始复制工作表的操作。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="0050" class="ol ns iu mi b gz pf pg l ph pi"><strong class="mi je"># copy worksheet above from wb1 to wb2</strong><br/>wb1.Worksheets(sheetname).Copy(<em class="pk">Before</em>=wb2.Sheets(1))</span></pre><p id="48ad" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于此操作，我们使用了<strong class="ll je">从<strong class="ll je">工作表对象</strong>复制方法</strong>。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="8864" class="ol ns iu mi b gz pf pg l ph pi"><strong class="mi je"># remove hashtag to save and quit modified Excel file</strong><br/>#wb2.Save()<br/>#wb2.SaveAs(Filename = r"new file name.xlsx") # save as new Workbook<br/>#wb2.Close(True)<br/>#excel.Quit()</span></pre><p id="fc6f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">最后一步是使用<strong class="ll je"> Save </strong>或<strong class="ll je">Save as</strong>T16】方法保存处理后的工作簿。<strong class="ll je">关闭方法</strong>关闭Excel工作簿，而<strong class="ll je">退出方法</strong>退出使用Python创建的Excel对象。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h2 id="77ba" class="ol ns iu bd nt om on dn nx oo op dp ob ls oq or od lw os ot of ma ou ov oh ja bi translated"><strong class="ak"> 2 .将多个工作簿中的工作表复制/合并为一个工作簿</strong></h2><p id="5cea" class="pw-post-body-paragraph lj lk iu ll b lm ow ke lo lp ox kh lr ls oy lu lv lw oz ly lz ma pa mc md me in bi translated">在第一个示例中，我对工作表名称进行了硬编码，对于大量文件而言，这样做并不可取。该脚本将非常长，需要付出更多努力将所有工作表名称保存为单独的变量。</p><p id="99cb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">工作表中的T24索引T25就在这里。通过如下使用Excel <strong class="ll je">索引属性</strong> <a class="ae li" rel="noopener" target="_blank" href="/automate-excel-with-python-7c0e8c7c6256"> (Excel对象、方法和属性)</a> <strong class="ll je"> </strong>，我们可以创建一个更可持续的函数来组合来自多个工作簿的工作表。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="0acc" class="ol ns iu mi b gz pf pg l ph pi"># return Sheet with index = 1 without stating Sheet Name<br/>ws_name = wb1.Sheets(1)</span></pre><p id="b626" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于本例，我们将根据日期将25个Workbooks合并为5个。每个工作簿最初仅包含一个工作表。如示例A1所示，需要4个步骤。</p><p id="1863" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je"> i .导入库</strong></p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="bf17" class="ol ns iu mi b gz pf pg l ph pi">import re<br/>import os<br/>import win32com.client as win32<br/>from pathlib import Path<br/>win32c =  win32.constants</span></pre><p id="bd55" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">需要使用正则表达式(re)库来标识文件名中的日期。</p><p id="d413" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je"> ii .定义复制工作表的功能</strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl ok l"/></div></figure><p id="1f87" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该功能用于将工作表从一个工作簿复制到另一个工作簿。IF-ELSE条件用于确定是否有工作簿打开。如果没有，它将打开第一个工作簿并保存为<code class="fe mf mg mh mi b">wb1</code>，否则它将打开第二个工作簿并保存为<code class="fe mf mg mh mi b">wb2.</code>，然后<code class="fe mf mg mh mi b">wb2</code>中的工作表将被复制到<code class="fe mf mg mh mi b">wb1</code>。</p><p id="c2cf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">内部for循环将合并同一个<code class="fe mf mg mh mi b">f_list</code>中的工作簿，然后外部循环将在该过程完成时移动到下一个<code class="fe mf mg mh mi b">f_list </code>。<code class="fe mf mg mh mi b">combine list </code>是一个嵌套列表，里面包含<code class="fe mf mg mh mi b">f_list </code>，而<code class="fe mf mg mh mi b">f_list</code>包含</p><ol class=""><li id="4be2" class="mt mu iu ll b lm ln lp lq ls mv lw mw ma mx me my mz na nb bi translated">带有扩展名(f[0])的文件名，</li><li id="e514" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated">状态(f[1])和</li><li id="27d4" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated">文件的日期(f[2])。</li></ol><p id="626e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每个<code class="fe mf mg mh mi b">f_list</code>包含日期相同的文件元组，如下图所示。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj pm"><img src="../Images/db7a88ea14ae14a23e1f812467396a64.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*vPnoLwINNoFwsNmogEUWOg.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">combine_list截图。图片作者。</p></figure><p id="57a2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">三。根据标准</strong>定义将文件名放入单独列表的函数</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl ok l"/></div></figure><p id="11d4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该功能是根据文件名中的日期对文件进行分组，并保存到<code class="fe mf mg mh mi b">combine_list</code>。所有文件名保存在<code class="fe mf mg mh mi b">filename_list </code>参数中。对于每个文件名，我们将使用正则表达式(re)编译一个模式，如下所示。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="7213" class="ol ns iu mi b gz pf pg l ph pi">pattern = re.compile(r"([\w]+) ([\d]{8}).xlsx")<br/>x = pattern.search(f)</span></pre><p id="02ed" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的行中，我们想要标识州名和日期，日期是文件名中的一个8位数字。<strong class="ll je"> x </strong>将返回搜索结果，使用<code class="fe mf mg mh mi b">group</code>我们可以选择文本中的任何部分来使用。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="b2ef" class="ol ns iu mi b gz pf pg l ph pi">temp_name = x.group(1)        <br/>temp_date = x.group(2)</span></pre><p id="5759" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">索引从0开始，索引0指的是整个文本，索引1指的是第一个括号，在本例中是州名，索引2指的是第二个括号，它指的是日期。IF-ELSE条件是将获得的第一个日期保存为参考日期，然后将其与文件名中的其余日期进行比较。每个匹配将作为一个元组保存到<code class="fe mf mg mh mi b">file_list</code>。然后，元组会被追加到主列表中，也就是<code class="fe mf mg mh mi b">combined_list</code>。</p><p id="2606" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">添加到<code class="fe mf mg mh mi b">combined_list</code>的每个文件名都将被添加到<code class="fe mf mg mh mi b">used_filename</code>，WHILE循环将继续，直到<code class="fe mf mg mh mi b">used_filename</code>的长度等于初始列表<code class="fe mf mg mh mi b">filename_list</code>。<code class="fe mf mg mh mi b">filename_list</code>、<code class="fe mf mg mh mi b">files</code>的克隆在一开始就被创建，并被用作FOR-LOOP的标准。每次一个文件名被添加到<code class="fe mf mg mh mi b">used_filename</code>中，它就会从<code class="fe mf mg mh mi b">files</code>中被删除，所以不会有重复。</p><p id="6f97" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">四。设置参数并调用函数</strong></p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="954d" class="ol ns iu mi b gz pf pg l ph pi"># your path<br/>f_path = r"C:\Users\Desktop\Automate Excel Report Format" </span><span id="33d8" class="ol ns iu mi b gz pj pg l ph pi"># get all files in the directory<br/>filename_list = os.listdir(f_path + "\\" + "Sample File") </span><span id="c095" class="ol ns iu mi b gz pj pg l ph pi"># create excel object<br/>excel = win32.gencache.EnsureDispatch('Excel.Application')</span><span id="e01d" class="ol ns iu mi b gz pj pg l ph pi"># excel can be visible or not<br/>excel.Visible = True  # False <br/>group_file_according_criteria(f_path, filename_list, excel)</span></pre><p id="e9d8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe mf mg mh mi b">filename_list </code>是需要合并的文件列表。由于文件是根据格式命名的，我们可以根据州或日期来组合文件。在此示例中，工作簿根据日期进行合并。原始工作簿保存在名为“Sample File”的文件夹中，而合并的工作簿保存在名为“combined”的文件夹中。这两个文件夹位于同一目录中。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pn"><img src="../Images/07f8d4805e9c3049154417d27feda8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WW9rs3ION8o0xCB6_hKUaA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动化脚本的输出。</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj po"><img src="../Images/db55b5f7fc1a52462a0b782aa5b3af80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*tOI3DdIYy5MlKeazELOCuw.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动化脚本的输出。</p></figure><p id="8de8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">合并所有月份相同的工作表。</p><p id="400e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">总之，本示例显示如何根据日期将同一文件夹中的工作簿分组到一个列表中，然后将同一列表中所有工作簿的工作表合并到一个工作簿中。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="ac8b" class="nr ns iu bd nt nu nv nw nx ny nz oa ob kj oc kk od km oe kn of kp og kq oh oi bi translated">B.复制一张Excel表的数据表<strong class="ak">并粘贴到另一张Excel表的现有数据表</strong>下方</h1><h2 id="8fbc" class="ol ns iu bd nt om on dn nx oo op dp ob ls oq or od lw os ot of ma ou ov oh ja bi translated"><strong class="ak"> 1。合并两个工作表的数据表</strong></h2><p id="37d9" class="pw-post-body-paragraph lj lk iu ll b lm ow ke lo lp ox kh lr ls oy lu lv lw oz ly lz ma pa mc md me in bi translated">为了确保我们只复制数据表，我们需要知道要复制的列和行的确切数量。因此，<code class="fe mf mg mh mi b">pandas.DataFrame.shape </code>函数将用于获取行数。<em class="pk">在这个例子中，列数是硬编码的，因为作者没有想到除了使用Python字典之外的更好的方法来返回列的字母表</em>😂<em class="pk">。</em></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl ok l"/></div></figure><p id="a835" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">复制数据表的步骤与复制整个工作表(示例A1)略有不同，因为需要知道行数。主要区别是使用<code class="fe mf mg mh mi b">pandas</code>库读取数据表的大小，这里使用的<strong class="ll je">复制方法</strong>在<strong class="ll je"> Range对象</strong>下。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="44d6" class="ol ns iu mi b gz pf pg l ph pi">wb1.Sheets(sheetname1).Range(f"A2:E{df_penang.shape[0] + 1}").Copy(<em class="pk">Destination</em> = wb2.Sheets(sheetname2).Range(f"A{df_sabah.shape[0] + 2}"))</span></pre><p id="8ab2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">除此之外，请注意，复制数据表时，选定的范围从单元格A2开始。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="e129" class="ol ns iu mi b gz pf pg l ph pi">Range(f"<strong class="mi je">A2</strong>:E{df_penang.shape[0] <strong class="mi je">+ 1</strong>}")</span></pre><p id="9be9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是因为第一行是表头行，也因为这样，最后一行是<code class="fe mf mg mh mi b">df.shape[0]+1</code>返回的行数。如果数据的行数是1000行，不包括标题行(<code class="fe mf mg mh mi b">df.shape</code>返回不考虑标题的行数)，最后一行将是1001。</p><p id="137d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后，为了定位粘贴复制数据的位置，我们需要在目标工作表的数据表的行数上加2。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="79f4" class="ol ns iu mi b gz pf pg l ph pi">Range(f"A{df_sabah.shape[0] <strong class="mi je">+ 2</strong>}")</span></pre><p id="6460" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果在目标工作表中，数据表的行数也是1000，则在标题行计数后，最后一行也将是1001。因此，粘贴复制的数据表的位置将在第1002行。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h2 id="7101" class="ol ns iu bd nt om on dn nx oo op dp ob ls oq or od lw os ot of ma ou ov oh ja bi translated"><strong class="ak"> 2。合并多个工作表的数据表</strong></h2><p id="4045" class="pw-post-body-paragraph lj lk iu ll b lm ow ke lo lp ox kh lr ls oy lu lv lw oz ly lz ma pa mc md me in bi translated">对于这个例子，我使用了在第A2部分中创建的文件。文件名以“Combined _ Dated”开头，每个文件内部都有5个工作表，表示5个州在同一日期的利润记录，如下图所示。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pn"><img src="../Images/07f8d4805e9c3049154417d27feda8d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WW9rs3ION8o0xCB6_hKUaA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动化脚本的输出。</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj po"><img src="../Images/db55b5f7fc1a52462a0b782aa5b3af80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*tOI3DdIYy5MlKeazELOCuw.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动化脚本的输出。</p></figure><p id="2bc5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由于有多个工作表，最好使用工作表索引来标识工作表，而不是使用工作表名称。在这一部分中，我们将利用下面两个Excel对象属性。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="f491" class="ol ns iu mi b gz pf pg l ph pi"># return number of Worksheet in the Workbook<br/>wb1.Sheets.<strong class="mi je">Count</strong></span><span id="b420" class="ol ns iu mi b gz pj pg l ph pi"># return the name of a Worksheet (Sheet with index = 1)<br/>ws_name = wb1.Sheets(1).<strong class="mi je">Name</strong></span></pre><p id="410f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">与其他3个例子一样，这一部分也需要4个步骤。</p><p id="7d73" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">一、导入库</strong></p><p id="932e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在示例A2中，正则表达式(re)用于比较工作簿的名称。在本例中，它将用于比较工作表的名称。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="e44c" class="ol ns iu mi b gz pf pg l ph pi">import win32com.client as win32<br/>from pathlib import Path<br/>import pandas as pd<br/>import re</span></pre><p id="d296" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">二。定义打开工作簿的函数</strong></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl ok l"/></div></figure><p id="ef24" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该函数用于打开工作簿，调用<code class="fe mf mg mh mi b">copy_data_table</code>函数比较两个工作簿中的工作表，并将数据表粘贴到具有相同州名的工作表中。</p><p id="e890" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">IF-ELSE条件用于确定是否有工作簿打开。如果没有，它将打开第一个工作簿并保存为<code class="fe mf mg mh mi b">wb1</code>，否则它将打开第二个工作簿并保存为<code class="fe mf mg mh mi b">wb2</code>。然后<code class="fe mf mg mh mi b">wb2</code>中的工作表中的所有数据表都会被<code class="fe mf mg mh mi b">copy_data_table</code>函数复制到<code class="fe mf mg mh mi b">wb1</code>中。这里的<strong class="ll je">计数方法</strong>将用于返回<code class="fe mf mg mh mi b">wb1</code>中的张数。并且假设<code class="fe mf mg mh mi b">wb1</code>和<code class="fe mf mg mh mi b">wb2</code>有相同数量的工作表，那么<strong class="ll je">计数</strong>的结果将被用于获取<code class="fe mf mg mh mi b">wb2</code>中工作表的名称。</p><p id="8201" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe mf mg mh mi b">copy_data_table</code>函数将为外部for循环中的每个循环返回<code class="fe mf mg mh mi b">wb1</code>和<code class="fe mf mg mh mi b">save_path</code>。这是因为我们每次将数据表复制粘贴到<code class="fe mf mg mh mi b">wb1</code>中，都需要知道<strong class="ll je">更新后的</strong> <code class="fe mf mg mh mi b">wb1</code>中数据表的最新大小，才能粘贴下一个数据表。</p><p id="e14d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">三。定义复制数据表的功能</strong></p><p id="6ce7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">此函数用于将所有工作表的数据表从一个工作簿复制到另一个工作簿。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="pl ok l"/></div></figure><p id="4b7f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我知道上面的剧本看起来很吓人，但是别担心，我会牵着你的手走完理解的旅程😉。</p><p id="65a1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在上面的脚本中有两个FOR循环和两个IF- ELSE条件。我来一一解释一下。</p><p id="f5d4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">1.FOR循环</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="e42d" class="ol ns iu mi b gz pf pg l ph pi">for n in range(<em class="pk">number_of_sheet_1</em>):<br/>    # read the shape of dataframe of both file<br/>    ws_name_1 = <em class="pk">wb1</em>.Sheets(n+1).Name<br/>    state_name_wb1 = (re.split("_", ws_name_1))[0]</span><span id="1d77" class="ol ns iu mi b gz pj pg l ph pi">    # use RE to compile pattern to find a match<br/>    for ws_name_2 in <em class="pk">wb2_ws_namelist</em>:<br/>        pattern = re.compile(r"<em class="pk">(</em>[<em class="pk">\w</em>]+<em class="pk">)</em>_[<em class="pk">\d</em>]{1}")<br/>        x = pattern.search(ws_name_2)</span><span id="d4cd" class="ol ns iu mi b gz pj pg l ph pi">        # assume we are combine according state, which will be in<br/>        first parenthesis<br/>        state_name_wb2 = x.group(1)</span></pre><p id="9b59" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当我们将多个工作表从一个工作簿复制到另一个工作簿时，我们将使用索引属性首先选择工作簿1 (wb1)中的一个工作表，然后使用名称属性来标识工作簿2 (wb2)中与<code class="fe mf mg mh mi b">wb1</code>具有相同州名的工作表。</p><p id="8afb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在外部FOR循环中，下面的脚本将获取wb1中当前索引为<strong class="ll je">的工作表的名称。正则表达式将用于获取州名。</strong></p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="67ee" class="ol ns iu mi b gz pf pg l ph pi">ws_name_1 = wb1.Sheets(n+1).Name        <br/>state_name_wb1 = (re.split("_", ws_name_1))[0]</span></pre><p id="60b6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一旦我们从wb1中得到一个工作表名称，我们将把它与wb2中的工作表名称列表进行比较。这是内部FOR循环。wb2中的工作表名称列表已经保存在<code class="fe mf mg mh mi b">wb2_ws_namelist</code>中。</p><p id="0e06" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在内部FOR循环中，工作簿2中每个工作表的州名将通过正则表达式获取，如下面的脚本所示。</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="833d" class="ol ns iu mi b gz pf pg l ph pi">pattern = re.compile(r"([\w]+)_[\d]{1}")            <br/>x = pattern.search(ws_name_2)            <br/># assume we are combine according state, which will be in first parenthesis            <br/>state_name_wb2 = x.group(1)</span></pre><p id="0e15" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后，IF-ELSE条件用于比较工作簿1中当前选定工作表的状态名和工作簿2中每个工作表的状态名</p><p id="834d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">2.如果-否则</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="4714" class="ol ns iu mi b gz pf pg l ph pi"># for the match worksheet, calculate their number of rows and copy the data from one to another</span><span id="74e5" class="ol ns iu mi b gz pj pg l ph pi"><strong class="mi je">if state_name_wb1 == state_name_wb2:</strong><br/>    <strong class="mi je">if <em class="pk">save_path</em> =="":</strong><br/>        file_path_1 = <em class="pk">main_file_path<br/>    </em><strong class="mi je">else:</strong><br/>        file_path_1 = <em class="pk">save_path</em></span><span id="89cf" class="ol ns iu mi b gz pj pg l ph pi">df_main = pd.read_excel(file_path_1, <em class="pk">sheet_name</em> = ws_name_1)<br/>    df_second = pd.read_excel(<em class="pk">file_path</em>, <em class="pk">sheet_name</em> = ws_name_2)</span><span id="06bd" class="ol ns iu mi b gz pj pg l ph pi"><strong class="mi je"># copy the data table</strong><br/>    <em class="pk">wb2</em>.Sheets(ws_name_2).Range(f"A2:E{df_second.shape[0] +            1}").Copy(<em class="pk">Destination</em> =<br/><em class="pk">wb1</em>.Sheets(ws_name_1).Range(f"A{df_main.shape[0] + 2}"))</span><span id="d602" class="ol ns iu mi b gz pj pg l ph pi"><strong class="mi je">else:</strong><br/>    pass</span></pre><p id="b147" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">外部IF-ELSE条件是比较两个打开的工作簿的工作表名称中的州名。如果状态名相等，那么我们将进入内部IF-ELSE。</p><p id="007c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在内部IF_ELSE中，如果<code class="fe mf mg mh mi b">save_path</code>为空，这意味着这个IF-ELSE条件之外的FOR循环刚刚开始，还没有数据表被复制。在这个阶段，我们将使用原<code class="fe mf mg mh mi b">wb1</code>的<code class="fe mf mg mh mi b">file_path</code>。否则，我们将使用已处理的<code class="fe mf mg mh mi b">wb1</code>中的<code class="fe mf mg mh mi b">save_path</code>。</p><p id="39a3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后，我们将使用<code class="fe mf mg mh mi b">pandas.shape</code>函数获取当前<code class="fe mf mg mh mi b">wb1</code>和<code class="fe mf mg mh mi b">wb2</code>中数据表的形状，并使用<strong class="ll je">复制方法</strong>中的结果，将数据表粘贴到准确的位置。</p><p id="e937" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">工作簿2中工作表的数据表与工作簿1中当前选定的工作表具有相同的状态名，该数据表将被复制到工作簿1中当前选定的工作表。</p><p id="367b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">3.在所有循环完成后</p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="4af5" class="ol ns iu mi b gz pf pg l ph pi"><em class="pk">save_path</em> = f_path + "\\Combined Data Table\\" + "Combined_Dated_State.xlsx"<br/><em class="pk">wb1</em>.SaveAs(<em class="pk">Filename</em> = <em class="pk">save_path</em>) # use save as to save as a new Workbook<br/># when overwriting previous saved file, will have pop up window, asking whether save<br/><em class="pk">wb1</em>.Close(True)<br/><em class="pk">wb2</em>.Close(True)<br/><em class="pk">wb1</em> = excel.Workbooks.Open(<em class="pk">save_path</em></span><span id="0243" class="ol ns iu mi b gz pj pg l ph pi">return <em class="pk">wb1</em>, <em class="pk">save_path</em></span></pre><p id="9a98" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由于有多个工作簿，工作簿1每次都必须与另一个工作簿合并保存，以便pandas可以读取最新数据帧的形状，并计算出正确的目的地以粘贴数据表。<code class="fe mf mg mh mi b">wb1</code>和<code class="fe mf mg mh mi b">save_path</code>也需要返回到下一个循环的主函数。</p><p id="8cde" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">再次保存工作簿时，会有一个弹出窗口，询问是否在现有工作簿上保存，只需单击“是”😁。</p><p id="a176" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">四。调用主函数</strong></p><pre class="kt ku kv kw gu pb mi pc pd aw pe bi"><span id="f71d" class="ol ns iu mi b gz pf pg l ph pi">f_path = r"C:\Users\<em class="pk">D</em>esktop<em class="pk">\A</em>utomate Excel Report Format"<br/># get all files in the directory<br/>filename_list = os.listdir(f_path + "\\Combined\\") </span><span id="3389" class="ol ns iu mi b gz pj pg l ph pi"># create excel object<br/>excel = win32.gencache.EnsureDispatch('Excel.Application')</span><span id="7459" class="ol ns iu mi b gz pj pg l ph pi"># excel can be visible or not<br/>excel.Visible = True  # False</span><span id="8ed8" class="ol ns iu mi b gz pj pg l ph pi">open_workbook(f_path, filename_list, excel)</span></pre><p id="470d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该示例使用了示例B2的输出。由于工作簿中的工作表是根据一种格式命名的，因此我们可以根据状态来组合文件。最终的合并工作簿保存在名为“合并数据表”的文件夹中。这两个文件夹位于同一目录中。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pp"><img src="../Images/ac921992cd3addef15809a219f32d676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofDgW8bk1QpkcoEbRcvbVw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动化脚本的输出。</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pq"><img src="../Images/437e6e569f9799df0ae74f18ede27182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lguKl4kbVef5S4ysVnv8qA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">自动化脚本的输出。</p></figure><p id="4233" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">总之，此示例显示了如何根据工作表的名称将同一文件夹中不同工作簿的工作表合并到一个工作簿中。最初，每个工作簿只有一个月的数据。合并后，最终的工作簿将包含5个月的数据。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><p id="3be0" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这就是从多个工作簿中自动合并工作表的教程。感谢阅读到最后。</p><h1 id="90f6" class="nr ns iu bd nt nu pr nw nx ny ps oa ob kj pt kk od km pu kn of kp pv kq oh oi bi translated">保持联系</h1><p id="458a" class="pw-post-body-paragraph lj lk iu ll b lm ow ke lo lp ox kh lr ls oy lu lv lw oz ly lz ma pa mc md me in bi translated">订阅<a class="ae li" href="https://www.youtube.com/channel/UCiMtx0qbILP41Ot-pkk6eJw" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><h1 id="9435" class="nr ns iu bd nt nu pr nw nx ny ps oa ob kj pt kk od km pu kn of kp pv kq oh oi bi translated">边注</h1><p id="f08d" class="pw-post-body-paragraph lj lk iu ll b lm ow ke lo lp ox kh lr ls oy lu lv lw oz ly lz ma pa mc md me in bi translated">在<a class="ae li" rel="noopener" target="_blank" href="/automate-excel-with-python-7c0e8c7c6256">用Python自动化Excel</a>中，我解释了Excel VBA的<strong class="ll je">对象、方法和属性</strong>。这是使用<code class="fe mf mg mh mi b">pywin32</code>时你必须知道的三个主要概念。</p><p id="7906" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果您对<strong class="ll je">自动化数据透视表并从数据透视表中提取过滤后的数据到pandas DataFrame </strong>感兴趣，您可以使用<a class="ae li" href="https://kahemchu.medium.com/automate-excel-with-python-pivot-table-899eab993966" rel="noopener">用Python自动化数据透视表(创建、过滤和提取)</a>。</p><p id="1478" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你的工作使用Google Sheet而不是Microsoft Excel，你可以参考这篇文章“自动化Google Sheet Report ”,了解可能的自动化。</p><h1 id="95ee" class="nr ns iu bd nt nu pr nw nx ny ps oa ob kj pt kk od km pu kn of kp pv kq oh oi bi translated">参考</h1><ol class=""><li id="7014" class="mt mu iu ll b lm ow lp ox ls pw lw px ma py me my mz na nb bi translated"><a class="ae li" href="https://trenton3983.github.io/files/solutions/2020-06-22_pivot_table_win32com/create_pivot_table_with_win32com.html" rel="noopener ugc nofollow" target="_blank">如何用Python win32com模块在Excel中创建透视表</a></li><li id="d690" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated"><a class="ae li" href="https://docs.microsoft.com/en-us/office/vba/api/overview/excel" rel="noopener ugc nofollow" target="_blank"> Excel VBA参考</a></li><li id="4b54" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated"><a class="ae li" href="https://docs.microsoft.com/en-us/office/vba/api/excel.range.copy" rel="noopener ugc nofollow" target="_blank"> Excel VBA复制方法</a></li><li id="b500" class="mt mu iu ll b lm nc lp nd ls ne lw nf ma ng me my mz na nb bi translated"><a class="ae li" href="https://www.geeksforgeeks.org/python-sets/" rel="noopener ugc nofollow" target="_blank"> Python集— GeeksforGeeks </a></li></ol><p id="7037" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="pk">祝贺并感谢你阅读到最后。希望你喜欢这篇文章。</em>😊</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pz"><img src="../Images/45d1ff23c351f6c675c22bff6c999f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0TjZT9aM2ZbhVoavjrg-bw.jpeg"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@prochurchmedia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亲教会媒体</a>在<a class="ae li" href="https://unsplash.com/s/photos/thank?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div></div>    
</body>
</html>