<html>
<head>
<title>Understand async/await with asyncio for Asynchronous Programming in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 Python 中异步编程的 async/await with asyncio</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/understand-async-await-with-asyncio-for-asynchronous-programming-in-python-e0bc4d25808e#2022-12-25">https://towardsdatascience.com/understand-async-await-with-asyncio-for-asynchronous-programming-in-python-e0bc4d25808e#2022-12-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c78b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一种新的方式编写异步代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/92993285d88e5d9a17d6aff6aedd279e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mZ-v7t912Q8Rd7_Q"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/photos/vuOqMK4NWc8" rel="noopener ugc nofollow" target="_blank">帕特里克·亨德利</a>在 Unsplash 拍摄</p></figure><p id="1e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数 Python 开发人员可能只使用过 Python 中的同步代码，甚至是一些资深的 Python 爱好者。然而，如果你是一名数据科学家，你可能使用过<em class="lv">多处理</em>库来并行运行一些计算。如果你是一名 web 开发人员，你可能有机会通过<em class="lv">线程</em>实现并发。<em class="lv">多处理</em>和<em class="lv">线程</em>都是 Python 中的高级概念，都有自己特定的应用领域。</p><p id="5a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<em class="lv">多处理</em>和<em class="lv">线程</em>之外，Python 的并发家族中还有一个相对较新的成员——<em class="lv">asyncio</em>，这是一个使用<code class="fe lw lx ly lz b">async</code> / <code class="fe lw lx ly lz b">await</code>语法编写并发代码的库。与<em class="lv">线程</em>类似，<em class="lv"> asyncio </em>适用于实际中非常常见的 io 绑定任务。在本帖中，我们将介绍<em class="lv"> asyncio </em>的基本概念，并演示如何使用这个新库来编写异步代码。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="02de" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">CPU 受限和 IO 受限的任务</h2><p id="0846" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在我们开始使用 asyncio 库之前，有两个概念我们应该弄清楚，因为它们决定了应该使用哪个库来解决您的特定问题。</p><p id="e721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受 CPU 限制的任务大部分时间都在用 CPU 进行繁重的计算。如果你是一名数据科学家，需要通过处理大量数据来训练一些机器学习模型，那么这是一项 CPU 密集型任务。如果是这种情况，你应该使用<a class="ae ky" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">多处理</em> </a>来并行运行你的作业，充分利用你的 CPU。</p><p id="3406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，IO 绑定的任务花费大部分时间等待 IO 响应，这些响应可能是来自网页、数据库或磁盘的响应。对于需要从 API 或数据库获取数据的 web 开发，这是一个 IO 绑定的任务，可以通过<a class="ae ky" href="https://levelup.gitconnected.com/how-to-write-concurrent-python-code-with-multithreading-b24dec228c43" rel="noopener ugc nofollow" target="_blank"> <em class="lv">线程</em> </a>或<a class="ae ky" href="https://docs.python.org/3/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> asyncio </em> </a>实现并发，以最大限度地减少外部资源的等待时间。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="edbf" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">线程与异步</h2><p id="b3c5" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">好了，我们知道<em class="lv">线程</em>和<em class="lv">异步</em>都适合 io 绑定的任务，但是它们有什么区别呢？</p><p id="2cd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，乍看之下你可能觉得难以置信，<em class="lv">线程</em>使用多线程，而<em class="lv"> asyncio </em>只用一个线程。对于<em class="lv">线程化</em>，更容易理解，因为线程轮流运行代码，从而实现并发。但是如何用单线程实现并发呢？</p><p id="b4c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，<em class="lv">线程化</em>通过抢占式多任务处理实现并发，这意味着我们无法确定何时在哪个线程中运行哪个代码。决定哪个代码应该在哪个线程中运行的是操作系统。操作系统可以在线程之间的任何点切换控制。这就是为什么我们经常看到<em class="lv">线程</em>的随机结果。<a class="ae ky" href="https://levelup.gitconnected.com/how-to-write-concurrent-python-code-with-multithreading-b24dec228c43" rel="noopener ugc nofollow" target="_blank">如果你想了解更多关于<em class="lv">线程</em>的知识，这篇文章</a>会很有帮助。</p><p id="6047" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<em class="lv"> asyncio </em>通过协作多任务实现并发。我们可以决定代码的哪一部分可以等待，从而控制切换到运行代码的其他部分。这些任务需要协作并宣布何时控制将被切换出去。所有这些都是在单线程中用<code class="fe lw lx ly lz b">await</code>命令完成的。现在它可能看起来难以捉摸，但当我们稍后看到代码时，它会变得更加清晰。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="5a1f" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">什么是协程？</h2><p id="8977" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">这是 asyncio 中一个奇特的名字。很难解释它是什么。许多教程根本没有解释这个概念，只是用一些代码向你展示它是什么。不过，我们先试着了解一下是什么。</p><p id="f014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 中协程的<a class="ae ky" href="https://docs.python.org/3.10/glossary.html#term-coroutine" rel="noopener ugc nofollow" target="_blank">定义是:</a></p><blockquote class="nf ng nh"><p id="4f54" class="kz la lv lb b lc ld ju le lf lg jx lh ni lj lk ll nj ln lo lp nk lr ls lt lu im bi translated">协程是子程序的一种更一般化的形式。子程序在一点进入，在另一点退出。协程可以在许多不同的点进入、退出和恢复。</p></blockquote><p id="e8c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你第一次看到它的时候，这可能看起来很奇怪。然而，当你和<em class="lv">阿辛西奥</em>合作越来越多的时候，就会越来越有意义。</p><p id="d953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个定义中，我们可以把子程序理解为函数，尽管两者之间有差异。通常，一个函数只在被调用时进入和退出一次。但是 Python 中有一个特殊的函数叫做<a class="ae ky" rel="noopener" target="_blank" href="/demystify-iterators-and-generators-in-python-f21878c9897">生成器</a>，可以多次进出。</p><p id="0211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">协程的行为很像生成器。实际上，在旧版本的 Python 中，协程是由生成器定义的。这些协程被称为基于生成器的协程。然而，协程现在已经成为 Python 的一个原生特性，可以用新的<code class="fe lw lx ly lz b">async def</code>语法来定义。尽管基于生成器的协程现在已经被弃用，但它们的历史和存在可以帮助我们理解什么是协程，以及如何在代码的不同部分之间切换或产生控制。如果你想了解更多关于 Python 中协程的历史和规范，<a class="ae ky" href="https://peps.python.org/pep-0492/" rel="noopener ugc nofollow" target="_blank"> PEP 492 </a>是一个很好的参考。然而，对于初学者来说，阅读和理解可能并不容易。</p><p id="08fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，现在抽象的概念已经够多了。如果你不知何故迷路了，不能理解所有的概念，没关系。随着时间的推移，当你用 asyncio 库编写和读取越来越多的异步代码时，它们会变得更加清晰。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="992e" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">定义协程函数</h2><p id="32fb" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">既然已经介绍了基本概念，我们可以开始编写我们的第一个协程函数了:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="2a61" class="np mi it lz b be nq nr l ns nt">async def coro_func():<br/>    print("Hello, asyncio!")</span></pre><p id="39cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">coro_func()</code>是一个协程函数，当调用它时，它将返回一个协程对象:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="bf8a" class="np mi it lz b be nq nr l ns nt">coro_obj = coro_func()<br/><br/>type(coro_obj)<br/># coroutine</span></pre><p id="0e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，术语<em class="lv">协程</em>可以指协程函数或协程对象，这取决于上下文。</p><p id="a26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到，当调用协程函数时，不会调用<code class="fe lw lx ly lz b">print</code>函数。如果您使用过生成器，您不会感到惊讶，因为它的行为与生成器功能相似:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="1519" class="np mi it lz b be nq nr l ns nt">def gen_func():<br/>    yield "Hello, generator!"<br/><br/>generator = gen_func()<br/>type(generator)<br/># generator</span></pre><p id="247a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在生成器中运行代码，您需要迭代它。例如，您可以使用<code class="fe lw lx ly lz b">next</code>函数来迭代它:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="056c" class="np mi it lz b be nq nr l ns nt">next(generator)<br/># 'Hello, generator!'</span></pre><p id="cc28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，要运行协程函数中定义的代码，你需要<strong class="lb iu"> <em class="lv">等待</em> </strong>它。但是，您不能像迭代生成器一样等待它。一个协程只能在由<code class="fe lw lx ly lz b">async def</code>语法定义的另一个协程中等待:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="540a" class="np mi it lz b be nq nr l ns nt">async def coro_func():<br/>    print("Hello, asyncio!")<br/><br/>async def main():<br/>    print("In the entrypoint coroutine.")<br/>    await coro_func()</span></pre><p id="60af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在的问题是我们如何运行<code class="fe lw lx ly lz b">main()</code>协程函数。显然，我们不能把它放在另一个协程函数中等待它。</p><p id="4b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于顶级入口点协程函数，通常命名为<code class="fe lw lx ly lz b">main()</code>，我们需要使用<code class="fe lw lx ly lz b">asyncio.run()</code>来运行它:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="c2fa" class="np mi it lz b be nq nr l ns nt">import asyncio<br/><br/>async def coro_func():<br/>    print("Hello, asyncio!")<br/><br/>async def main():<br/>    print("In the entrypoint coroutine.")<br/>    await coro_func()<br/><br/>asyncio.run(main())<br/># In the entrypoint coroutine.<br/># Hello, asyncio!</span></pre><p id="eaf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们需要在这里导入内置的<em class="lv"> asyncio </em>库。</p><p id="a392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在引擎盖下，它由一个叫做<a class="ae ky" href="https://docs.python.org/3/library/asyncio-eventloop.html" rel="noopener ugc nofollow" target="_blank">事件循环</a>的东西处理。然而，有了现代 Python，你再也不需要担心这些细节了。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="4dcb" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">在协程函数中返回值</h2><p id="1226" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们可以在协程函数中返回值。该值通过<code class="fe lw lx ly lz b">await</code>命令返回，并可分配给一个变量:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="4b0e" class="np mi it lz b be nq nr l ns nt">import asyncio<br/><br/>async def coro_func():<br/>    return "Hello, asyncio!"<br/><br/>async def main():<br/>    print("In the entrypoint coroutine.")<br/>    result = await coro_func()<br/>    print(result)<br/><br/>asyncio.run(main())<br/># In the entrypoint coroutine.<br/># Hello, asyncio!</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="61f5" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">同时运行多个协程</h2><p id="57ee" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">在你的代码中只有一个协程并不有趣，也没有用。当有多个协同程序应该并发运行时，它们会大放异彩。</p><p id="63d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先看一个协程等待错误的例子:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="2a56" class="np mi it lz b be nq nr l ns nt">import asyncio<br/>from datetime import datetime<br/><br/>async def async_sleep(num):<br/>    print(f"Sleeping {num} seconds.")<br/>    await asyncio.sleep(num)<br/><br/>async def main():<br/>    start = datetime.now()<br/><br/>    for i in range(1, 4):<br/>        await async_sleep(i)<br/>    <br/>    duration = datetime.now() - start<br/>    print(f"Took {duration.total_seconds():.2f} seconds.")<br/><br/>asyncio.run(main())<br/># Sleeping 1 seconds.<br/># Sleeping 2 seconds.<br/># Sleeping 3 seconds.<br/># Took 6.00 seconds.</span></pre><p id="4ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，注意我们需要在协程函数中使用<code class="fe lw lx ly lz b">asyncio.sleep()</code>函数来模拟 IO 阻塞时间。</p><p id="6ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，创建的三个协程对象被逐个等待。因为当等待的协程对象已经完成时，控制只被处理到下一行代码(这里是下一个循环)，所以这三个协程实际上是一个接一个等待的。因此，运行代码需要 6 秒钟，这与同步运行代码是一样的。</p><p id="2742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该用<code class="fe lw lx ly lz b">async.gather() </code>函数同时运行多个协程。</p><p id="3055" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">async.gather()</code>用于同时运行多个 awaitables。顾名思义，一个<a class="ae ky" href="https://docs.python.org/3.10/library/asyncio-task.html#awaitables" rel="noopener ugc nofollow" target="_blank">可用的</a>是可以通过<code class="fe lw lx ly lz b">await</code>命令等待的东西。它可以是一个协程、一个任务、一个未来，或者任何实现了<code class="fe lw lx ly lz b">__await__()</code>魔法方法的东西。</p><p id="d013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来看看<code class="fe lw lx ly lz b">async.gather()</code>的用法:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="dc05" class="np mi it lz b be nq nr l ns nt">import asyncio<br/>from datetime import datetime<br/><br/>async def async_sleep(num):<br/>    print(f"Sleeping {num} seconds.")<br/>    await asyncio.sleep(num)<br/><br/><br/>async def main():<br/>    start = datetime.now()<br/><br/>    coro_objs = []<br/>    for i in range(1, 4):<br/>        coro_objs.append(async_sleep(i))<br/>    <br/>    await asyncio.gather(*coro_objs)<br/>    <br/>    duration = datetime.now() - start<br/>    print(f"Took {duration.total_seconds():.2f} seconds.")<br/><br/>asyncio.run(main())<br/># Sleeping 1 seconds.<br/># Sleeping 2 seconds.<br/># Sleeping 3 seconds.<br/># Took 3.00 seconds.</span></pre><p id="2f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们需要解包<code class="fe lw lx ly lz b">async.gather()</code>函数的 awaitables 列表。</p><p id="ecff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次协程对象是并发运行的，代码只花了 3 秒钟。</p><p id="725f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你检查<code class="fe lw lx ly lz b">asyncio.gather()</code>的返回类型，你会看到它是一个<a class="ae ky" href="https://docs.python.org/3.10/library/asyncio-future.html#asyncio.Future" rel="noopener ugc nofollow" target="_blank"> Future </a>对象。未来对象是一种特殊的数据结构，表示某些工作在其他地方完成，可能已经完成，也可能尚未完成。当等待未来对象时，会发生三种情况:</p><ul class=""><li id="e5d7" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">当 future 已成功解决(意味着底层工作已成功完成)时，它将立即返回返回值(如果可用)。</li><li id="2244" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">当未来未成功解决并且引发异常时，该异常将传播到调用方。</li><li id="a88c" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">当未来还没有解决时，代码会一直等到它解决。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="9aa5" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">一个更实用的 async with 和 aiohttp 的例子</h2><p id="5a22" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">上面我们刚刚写了一些伪代码来演示<em class="lv"> asyncio </em>的基础。现在让我们编写一些更实用的代码来进一步演示<em class="lv"> asyncio </em>的用法。</p><p id="78c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将编写一些代码来同时从对一些网页的请求中获取响应，这是一个经典的 IO 绑定任务，正如本文开头所解释的。</p><p id="8739" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们不能使用我们熟悉的<em class="lv">请求</em>库来获得来自网页的响应。这是因为<em class="lv">请求</em>库不支持<em class="lv"> asynico </em>库。这实际上是 asynico 库的一个主要限制，因为许多经典的 Python 库仍然不支持 asyncio 库。然而，随着时间的推移，这将会变得更好，更多的异步库将会出现。</p><p id="b1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决<em class="lv">请求</em>库的问题，我们需要使用<em class="lv"> aiohttp </em>库，它是为异步 http 请求(以及更多请求)而设计的。</p><p id="2dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要首先安装 aiohttp，因为它仍然是一个外部库:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="0520" class="np mi it lz b be nq nr l ns nt">pip install aiohttp</span></pre><p id="d4e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强烈建议在<a class="ae ky" href="https://lynn-kwong.medium.com/how-to-create-virtual-environments-with-venv-and-conda-in-python-31814c0a8ec2" rel="noopener">虚拟环境</a>中安装新的库，这样它们就不会影响系统库，你也不会有兼容性问题。</p><p id="8ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是使用<em class="lv"> aiohttp </em>库执行 http 请求的代码，它也大量使用了<code class="fe lw lx ly lz b">async with</code>语法:</p><pre class="kj kk kl km gt nl lz nm bn nn no bi"><span id="f93a" class="np mi it lz b be nq nr l ns nt">import asyncio<br/>import aiohttp<br/><br/>async def scrape_page(session, url):<br/>    print(f"Scraping {url}")<br/>    async with session.get(url) as resp:<br/>        return len(await resp.text())<br/><br/>async def main():<br/>    urls = [<br/>        "https://www.superdataminer.com/posts/66cff907ce8e",<br/>        "https://www.superdataminer.com/posts/f21878c9897",<br/>        "https://www.superdataminer.com/posts/b24dec228c43"<br/>    ]<br/><br/>    coro_objs = []<br/><br/>    async with aiohttp.ClientSession() as session:<br/>        for url in urls:<br/>            coro_objs.append(<br/>                scrape_page(session, url)<br/>            )<br/>    <br/>        results = await asyncio.gather(*coro_objs)<br/><br/>    for url, length in zip(urls, results):<br/>        print(f"{url} -&gt; {length}")<br/><br/>asyncio.run(main())<br/># Scraping https://www.superdataminer.com/posts/66cff907ce8e<br/># Scraping https://www.superdataminer.com/posts/f21878c9897<br/># Scraping https://www.superdataminer.com/posts/b24dec228c43<br/># https://www.superdataminer.com/posts/66cff907ce8e -&gt; 12873<br/># https://www.superdataminer.com/posts/f21878c9897 -&gt; 12809<br/># https://www.superdataminer.com/posts/b24dec228c43 -&gt; 12920</span></pre><p id="48fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">async with</code>语句使得在进入或退出上下文时执行异步调用成为可能。在引擎盖下，它是通过<code class="fe lw lx ly lz b">async def __aenter__()</code>和<code class="fe lw lx ly lz b">async def __aexit__()</code>魔法方法实现的，这是一个相当高级的话题。有兴趣的话，先了解一下 Python 中的<a class="ae ky" rel="noopener" target="_blank" href="/understand-context-managers-in-python-and-learn-to-use-them-in-unit-tests-66cff907ce8e">正则上下文管理器</a>的一些知识。而在那之后，<a class="ae ky" href="https://bbc.github.io/cloudfit-public-docs/asyncio/asyncio-part-3" rel="noopener ugc nofollow" target="_blank">这个帖子</a>如果你想更深一层的话，可以是一个很好的参考。然而，通常您不需要深入研究，除非您想创建自己的异步上下文管理器。</p><p id="b9f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe lw lx ly lz b">async with</code>语法，<em class="lv"> aiohttp </em>库的用法实际上与<em class="lv">请求</em>库非常相似。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="dc7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们介绍了异步编程的基本概念。用简单易懂的例子介绍了带有<code class="fe lw lx ly lz b">async/await</code>、<code class="fe lw lx ly lz b">asyncio.run()</code>和<code class="fe lw lx ly lz b">asyncio.gather()</code>语句的<em class="lv"> asyncio </em>库的基本用法。有了这些知识，你将能够使用<em class="lv"> asyncio </em>库读写基本的异步代码，并且能够更舒适地使用异步 API 框架，如<a class="ae ky" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h2 id="e7d5" class="mh mi it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">相关文章:</h2><ul class=""><li id="14a9" class="nu nv it lb b lc na lf nb li oi lm oj lq ok lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.superdataminer.com/posts/f21878c9897" rel="noopener ugc nofollow" target="_blank">解开 Python 中迭代器和生成器的神秘面纱</a></li><li id="3bba" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><a class="ae ky" href="https://www.superdataminer.com/posts/b24dec228c43" rel="noopener ugc nofollow" target="_blank">如何用多线程编写并发 Python 代码</a></li></ul></div></div>    
</body>
</html>