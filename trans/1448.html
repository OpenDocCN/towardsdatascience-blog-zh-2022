<html>
<head>
<title>Making Machine Learning More Accessible for Application Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让应用程序开发人员更容易使用机器学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/making-machine-learning-more-accessible-for-application-developers-9765f90c6b22#2022-04-09">https://towardsdatascience.com/making-machine-learning-more-accessible-for-application-developers-9765f90c6b22#2022-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a2b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><a class="ae ki" href="https://github.com/towhee-io/towhee" rel="noopener ugc nofollow" target="_blank"> Towhee </a>可以帮助加速机器学习应用的开发</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f48f8562a33be66210718f1477e94f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QvCFN8CNViOH_ejD"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae ki" href="https://unsplash.com/photos/w7ZyuGYNpRQ" rel="noopener ugc nofollow" target="_blank">许海波</a>在<a class="ae ki" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="88a1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="3d59" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">试图手工制作算法来理解人类生成的内容通常是不成功的。例如，计算机很难仅仅通过分析图像的低级像素来“掌握”图像的语义内容，例如汽车、猫、大衣等。<a class="ae ki" href="https://en.wikipedia.org/wiki/Color_histogram" rel="noopener ugc nofollow" target="_blank">颜色直方图</a>和<a class="ae ki" href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform" rel="noopener ugc nofollow" target="_blank">特征检测器</a>在一定程度上发挥了作用，但对于大多数应用来说，它们很少足够精确。</p><p id="af25" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在过去的十年里，大数据和深度学习的结合从根本上改变了我们处理计算机视觉、自然语言处理和其他机器学习(ML)应用的方式；从垃圾邮件检测到逼真的文本到视频合成，各种任务都取得了令人难以置信的进步，某些任务的准确性指标达到了超人的水平。这些改进的一个主要积极副作用是增加了<em class="ms">嵌入向量</em>的使用，即通过在深度神经网络中获取中间结果而生成的模型工件。OpenAI的<a class="ae ki" href="https://beta.openai.com/docs/guides/embeddings" rel="noopener ugc nofollow" target="_blank">文档页面</a>给出了一个很好的概述:</p><blockquote class="mt mu mv"><p id="6eec" class="lr ls ms lt b lu mn ju lw lx mo jx lz mw mp mc md mx mq mg mh my mr mk ml mm im bi translated"><em class="it">嵌入是一种特殊的数据表示格式，可以很容易地被机器学习模型和算法利用。嵌入是一段文本的语义的信息密集表示。每个嵌入是浮点数的向量，使得向量空间中两个嵌入之间的距离与原始格式的两个输入之间的语义相似性相关。例如，如果两个文本相似，那么它们的矢量表示也应该相似。</em></p></blockquote><p id="de9e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下表显示了三个查询图像以及它们在嵌入空间中对应的前五个图像(我使用了<a class="ae ki" href="https://frankzliu.com/blog/making-machine-learning-more-accessible-for-application-developers" rel="noopener ugc nofollow" target="_blank"> Unsplash Lite </a>的前1000个图像作为数据集):</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mz"><img src="../Images/fa5a01ea20f8996807f490295c21a441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WG6g9nsc-O7mVqJ6Pd2Dg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><p id="9ce7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">你在上面看到的这些结果是基于<a class="ae ki" href="https://arxiv.org/abs/1512.03385" rel="noopener ugc nofollow" target="_blank"> ResNet50 </a>的<em class="ms">图像嵌入模型</em>生成的，这是一个众所周知的纯卷积图像分类模型。嵌入不仅限于图像，还可以为各种不同类型的非结构化数据生成，包括图像、音频、时序数据和分子结构。将多种不同类型的数据嵌入同一个空间的模型，也就是通常所说的<em class="ms">多模态嵌入模型</em>，也已经存在，并且正在越来越多的应用中使用。</p><p id="6e8f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们将在接下来的两节中看到的，生成这些高质量的嵌入可能很困难，尤其是在大规模的情况下。</p><h1 id="fc9b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">训练嵌入任务的新模型</h1><p id="6015" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">理论上，训练一个新的ML模型并使用它生成嵌入听起来很容易:采用最新的和最好的预建模型，由最新的架构支持，并用一些数据训练它。很简单，对吧？</p><p id="6dbe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">没那么快。从表面上看，使用最新的模型架构来实现最先进的结果似乎很容易。然而，这与事实相去甚远。让我们来看看一些与训练嵌入模型相关的常见陷阱(这些也适用于一般的机器学习模型):</p><ol class=""><li id="c5a2" class="na nb it lt b lu mn lx mo ma nc me nd mi ne mm nf ng nh ni bi translated"><em class="ms">没有足够的数据</em>:在没有足够数据的情况下，从头开始训练一个新的嵌入模型，容易出现<em class="ms">过拟合</em>的现象。在实践中，只有最大的全球性组织有足够的数据来从头开始培训一个新的模型是值得的；其他人必须依靠<a class="ae ki" href="https://docs.towhee.io/fine-tune/train-operators/quick-start/" rel="noopener ugc nofollow" target="_blank"> <em class="ms">微调</em> </a>，这是一个过程，在这个过程中，具有大量数据的已经训练好的模型然后使用较小的数据集进行提取。</li><li id="7583" class="na nb it lt b lu nj lx nk ma nl me nm mi nn mm nf ng nh ni bi translated"><em class="ms">差超参数选择</em> : <a class="ae ki" href="https://en.wikipedia.org/wiki/Hyperparameter_(machine_learning)" rel="noopener ugc nofollow" target="_blank">超参数</a>为常量，用于控制训练过程，如模型学习的快慢或单批训练使用多少数据。微调模型时，选择一组适当的超参数极其重要，因为某些值的微小变化可能会导致非常不同的结果。<a class="ae ki" href="https://arxiv.org/abs/2110.00476" rel="noopener ugc nofollow" target="_blank">该领域的最新研究</a>还显示，使用改进的训练程序从头开始训练相同的模型，ImageNet-1k的准确性提高了5%以上(这是一个很大的进步)。</li><li id="381c" class="na nb it lt b lu nj lx nk ma nl me nm mi nn mm nf ng nh ni bi translated"><em class="ms">高估自我监督模型</em>:术语<em class="ms">自我监督</em>指的是一种训练程序，其中输入数据的“基本面”是通过利用数据本身来学习的，而不需要标签。一般来说，自监督方法非常适合预训练(即，在用较小的标记数据集对模型进行微调之前，用大量未标记数据以自监督方式训练模型)，但直接使用自监督嵌入可能会导致次优性能。</li></ol><p id="8c68" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解决上述所有三个问题的一个常见方法是，首先使用大量数据训练一个自我监督的模型，然后根据标记的数据对模型进行微调。这已经证明<a class="ae ki" href="https://arxiv.org/abs/1810.04805" rel="noopener ugc nofollow" target="_blank">对NLP </a>很有效，但是<a class="ae ki" href="https://arxiv.org/abs/2003.14323" rel="noopener ugc nofollow" target="_blank">对CV </a>还没那么有效。</p><h1 id="6612" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">使用嵌入模型有其自身的缺陷</h1><p id="4289" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这些只是与训练嵌入模型相关联的许多常见错误中的一些。这样做的直接结果是，许多寻求使用嵌入的开发人员直接使用学术数据集上预先训练的模型，如<a class="ae ki" href="https://image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet </a>(用于图像分类)和<a class="ae ki" href="https://rajpurkar.github.io/SQuAD-explorer/" rel="noopener ugc nofollow" target="_blank"> SQuAD </a>(用于问题回答)。尽管目前有大量的预训练模型可用，但为了提取最大的嵌入性能，应该避免几个陷阱:</p><ol class=""><li id="55ef" class="na nb it lt b lu mn lx mo ma nc me nd mi ne mm nf ng nh ni bi translated"><em class="ms">训练和推理数据不匹配</em>:使用由其他组织训练的现成模型已经成为一种流行的方式来开发ML应用程序，而不需要数千个GPU/TPU小时。理解特定嵌入模型的局限性以及它如何影响应用程序的性能是极其重要的；如果不了解模型的训练数据和方法，很容易误解结果。例如，一个被训练来嵌入音乐的模型在应用于语音时会表现不佳，反之亦然。</li><li id="35b7" class="na nb it lt b lu nj lx nk ma nl me nm mi nn mm nf ng nh ni bi translated"><em class="ms">层选择不当</em>:使用全监督神经网络作为嵌入模型时，特征一般取自激活的倒数第二层(正式名称为<em class="ms">倒数第二层</em>)。然而，这可能导致次优性能，具体取决于应用。例如，当使用为图像分类而训练的模型来嵌入徽标和/或品牌的图像时，使用较早的激活可能会导致性能提高。这是因为较好地保留了对非复杂图像分类至关重要的低级特征(边缘和拐角)。</li><li id="3a0e" class="na nb it lt b lu nj lx nk ma nl me nm mi nn mm nf ng nh ni bi translated"><em class="ms">不同的推理条件</em>:训练和推理条件必须<em class="ms">完全</em>相同，以从嵌入模型中提取最大性能。实际上，情况往往并非如此。例如，来自<code class="fe no np nq nr b"><a class="ae ki" href="https://pytorch.org/vision/stable/index.html" rel="noopener ugc nofollow" target="_blank">torchvision</a></code>的标准<code class="fe no np nq nr b">resnet50</code>模型在使用双三次插值与最近邻插值进行下采样时会产生两种完全不同的结果(见下文)。</li></ol><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f9c57c11c5b788621d82c0113cca479e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H2WxwoMCAV874FIb"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae ki" href="https://unsplash.com/photos/CcmxhowdIFc" rel="noopener ugc nofollow" target="_blank"> Patrice Bouchard </a>在<a class="ae ki" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mz"><img src="../Images/351f467ab0307b73483246dead692936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*La9tFiiX4B_MfEMTdZycrg.png"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><h1 id="f59a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">部署嵌入模型</h1><p id="184d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦您跨越了与培训和验证模型相关的所有障碍，扩展和部署它就成为了下一个关键步骤。同样，嵌入模型部署说起来容易做起来难。<em class="ms"> MLOps </em>是与DevOps相邻的一个油田，专门用于此目的。</p><ol class=""><li id="6cc0" class="na nb it lt b lu mn lx mo ma nc me nd mi ne mm nf ng nh ni bi translated"><em class="ms">选择正确的硬件</em>:与大多数其他ML模型类似，嵌入式模型可以在各种不同类型的硬件上运行，从标准的日常CPU到可编程逻辑(FPGAs)。完整的<a class="ae ki" href="https://www.jaewoong.org/pubs/fpt16-accelerating-bnn.pdf" rel="noopener ugc nofollow" target="_blank">研究论文</a>分析了成本与效率之间的权衡，强调了大多数组织在这方面面临的困难。</li><li id="8b8f" class="na nb it lt b lu nj lx nk ma nl me nm mi nn mm nf ng nh ni bi translated"><em class="ms">模型部署平台</em>:有很多MLOps和分布式计算平台可用(包括很多开源的)。弄清楚这些如何适合您的应用程序本身就是一个挑战。</li><li id="6dd6" class="na nb it lt b lu nj lx nk ma nl me nm mi nn mm nf ng nh ni bi translated"><em class="ms">嵌入向量的存储</em>:随着应用程序的扩展，您需要为您的嵌入向量找到一个可扩展的、更持久的存储解决方案。这就是<a class="ae ki" href="https://frankzliu.com/blog/a-gentle-introduction-to-vector-databases" rel="noopener ugc nofollow" target="_blank"> <em class="ms">矢量数据库</em> </a>的用武之地。</li></ol><h1 id="3908" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">我自己学着做！</h1><p id="768b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我为你的热情喝彩！需要记住几个关键的事情:</p><p id="a216" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> ML与软件工程非常不同</strong>:传统的机器学习源于统计学，这是一门与软件工程非常不同的数学分支。正则化和特征选择等重要的机器学习概念都有很强的数学基础。虽然用于训练和推理的现代库(<a class="ae ki" href="https://pytorch.org" rel="noopener ugc nofollow" target="_blank"> PyTorch </a>和<a class="ae ki" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>是两个众所周知的库)已经使得训练和生产嵌入模型变得非常容易，但是理解不同的超参数和训练方法如何影响嵌入模型的性能仍然非常重要。</p><p id="e8a2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">学习使用PyTorch或Tensorflow可能并不直观</strong>:如前所述，这些库大大加快了现代ML模型的训练、验证和部署。对于经验丰富的ML开发人员或熟悉HDL的程序员来说，构建新模型或实现现有模型可能非常直观，但对于大多数软件开发人员来说，潜在的概念可能很难理解。还有选择哪个框架的问题，因为这两个框架使用的执行引擎有相当多的差异(个人推荐PyTorch)。</p><p id="ac6e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">找到一个适合你的代码库的MLOps平台需要时间</strong>:这里有一个MLOps平台和工具的<a class="ae ki" href="https://github.com/kelvins/awesome-mlops" rel="noopener ugc nofollow" target="_blank">精选列表</a>。有数百个不同的选项可供选择，评估每个选项的利弊本身就是一个长达数年的研究项目。</p><p id="6374" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">说了这么多，我想把我上面的陈述修改为:我为你的热情鼓掌，<em class="ms">但是我不建议学习ML和MLOps </em>。这是一个相当漫长而乏味的过程，会占用最重要的事情的时间:开发一个用户会喜欢的可靠的应用程序。</p><h1 id="68d6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">用Towhee加速数据科学</h1><p id="27d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ki" href="https://towhee.io" rel="noopener ugc nofollow" target="_blank"> Towhee </a>是一个<a class="ae ki" href="https://github.com/towhee-io/towhee" rel="noopener ugc nofollow" target="_blank">开源项目</a>，它帮助软件工程师开发和部署应用程序，这些应用程序仅用几行代码就利用了嵌入式技术。Towhee为软件开发人员提供了开发他们自己的ML应用程序的自由和灵活性，而不必深入嵌入模型和机器学习。</p><p id="71e9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">一个简单的例子</strong></p><p id="e41a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个<code class="fe no np nq nr b">Pipeline</code>是由几个子任务组成的单个嵌入生成任务(在Towhee中也称为<code class="fe no np nq nr b">Operators</code>)。通过在<code class="fe no np nq nr b">Pipeline</code>中抽象出整个任务，Towhee帮助用户避免了上面提到的许多嵌入生成陷阱。</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="d744" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; from towhee import pipeline<br/>&gt;&gt;&gt; embedding_pipeline = pipeline('image-embedding-resnet50')<br/>&gt;&gt;&gt; embedding = embedding_pipeline('https://docs.towhee.io/img/logo.png')</span></pre><p id="b227" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上面的示例中，图像解码、图像变换、特征提取和嵌入归一化是编译到单个管道中的四个子步骤——您无需担心模型和推理细节。Towhee为各种任务提供了预构建的嵌入管道，包括音频/音乐嵌入、图像嵌入、人脸嵌入等等。有关管道的完整列表，请随时访问我们的<a class="ae ki" href="https://towhee.io/pipelines" rel="noopener ugc nofollow" target="_blank"> Towhee hub </a>。</p><p id="e429" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu">方法链接API </strong></p><p id="284e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Towhee还提供了一个名为<code class="fe no np nq nr b">DataCollection</code>的Pythonic非结构化数据处理框架。简而言之，<code class="fe no np nq nr b">DataCollection</code>是一个方法链API，它允许开发者在真实世界的数据上快速构建嵌入和其他ML模型的原型。在下面的例子中，我们使用<code class="fe no np nq nr b">DataCollection</code>通过<code class="fe no np nq nr b">resnet50</code>嵌入模型计算嵌入。</p><p id="d42a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这个例子，我们将构建一个“应用程序”，让我们用一个数字<code class="fe no np nq nr b">3</code>来过滤质数:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="2a43" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; from towhee.functional import DataCollection <br/>&gt;&gt;&gt; def is_prime(x):<br/>...     if x &lt;= 1:<br/>...         return False<br/>...     for i in range(2, int(x/2)+1):<br/>...         if not x % i:<br/>...             return False<br/>...     return True<br/>... <br/>&gt;&gt;&gt; dc = (<br/>...     DataCollection.range(100)<br/>...         .filter(is_prime) # stage 1, find prime<br/>...         .filter(lambda x: x%10 == 3) # stage 2, find primes that ends with '3'<br/>...         .map(str) # stage 3, convert to string<br/>... ) <br/>...<br/>&gt;&gt;&gt; dc.to_list()</span></pre><p id="e35a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe no np nq nr b">DataCollection</code>可用于开发整个应用程序，只需一行代码。下一节将展示如何使用<code class="fe no np nq nr b">DataCollection</code>开发一个反向图像搜索应用程序——继续阅读了解更多。</p><p id="0dbe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> Towhee培训师</strong></p><p id="c588" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如上所述，完全或自我监督的训练模型通常擅长于一般的任务。然而，你有时会想要创建一个嵌入模型，它擅长于一些非常具体的事情，例如区分猫和狗。Towhee专门为此提供了一个培训/微调框架:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="0d06" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; from towhee.trainer.training_config import TrainingConfig<br/>&gt;&gt;&gt; training_config = TrainingConfig( <br/>...     batch_size=2, <br/>...     epoch_num=2, <br/>...     output_dir='quick_start_output' <br/>... )</span></pre><p id="3fc8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您还需要指定一个数据集进行训练:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="b841" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; train_data = dataset('train', size=20, transform=my_data_transformer)<br/>&gt;&gt;&gt; eval_data = dataset('eval', size=10, transform=my_data_transformer)</span></pre><p id="2094" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一切就绪后，从现有运营商那里培训新的嵌入模型是小菜一碟:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="771d" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; op.train( <br/>...     training_config, <br/>...     train_dataset=train_data, <br/>...     eval_dataset=eval_data <br/>... )</span></pre><p id="0d53" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦完成，您就可以在应用程序中使用相同的操作符，而无需更改其余的代码。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b7ad3fb5e9c64f2feb96177c9845b02b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Ee4XOm9ZxjdX3YKh.png"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">作者图片</p></figure><h1 id="177b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">一个示例应用程序:反向图像搜索</h1><p id="1650" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了演示如何使用Towhee，让我们快速构建一个小型的<a class="ae ki" href="https://en.wikipedia.org/wiki/Reverse_image_search" rel="noopener ugc nofollow" target="_blank">反向图像搜索</a>应用程序。反向图像搜索是一个众所周知的。让我们开始吧:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="332a" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; import towhee<br/>&gt;&gt;&gt; from towhee.functional import DataCollection</span></pre><p id="793c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于这个示例应用程序，我们将使用一个小数据集和10个查询图像(此处的<a class="ae ki" href="https://drive.google.com/file/d/1bg1RtUjeZlOfV2BiA2nf7sn5Jec9b-9I/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">可用</a>)。使用<code class="fe no np nq nr b">DataCollection</code>，我们可以加载数据集和查询图像:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="76aa" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; dataset = DataCollection.from_glob('./image_dataset/dataset/*.JPEG').unstream() <br/>&gt;&gt;&gt; query = DataCollection.from_glob('./image_dataset/query/*.JPEG').unstream()</span></pre><p id="eb7b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一步是计算整个数据集集合的嵌入:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="e8b7" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; dc_data = ( <br/>... dataset.image_decode.cv2() <br/>...     .image_embedding.timm(model_name='resnet50') <br/>... ) <br/>...</span></pre><p id="152d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这一步创建嵌入向量的本地集合—数据集中的每个图像一个。这样，我们现在可以查询最近的邻居:</p><pre class="kk kl km kn gt ns nr nt nu aw nv bi"><span id="6233" class="nw la it nr b gy nx ny l nz oa">&gt;&gt;&gt; result = ( <br/>...     query.image_decode.cv2() # decode all images in the query set <br/>...         .image_embedding.timm(model_name='resnet50') # compute embeddings using the `resnet50` embedding model <br/>...         .towhee.search_vectors(data=dc_data, cal='L2', topk=5) # search the dataset <br/>...         .map(lambda x: x.ids) # acquire IDs (file paths) of similar results <br/>...         .select_from(dataset) # get the result image <br/>...     )<br/>...</span></pre><p id="4aa8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还提供了一种使用<a class="ae ki" href="https://github.com/ray-project/ray" rel="noopener ugc nofollow" target="_blank"> Ray </a>部署应用程序的方法。只需指定<code class="fe no np nq nr b">query.set_engine('ray')</code>就可以了！</p><h1 id="59ce" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结束语</h1><p id="7663" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后一点:我们并不认为<a class="ae ki" href="https://github.com/towhee-io/towhee" rel="noopener ugc nofollow" target="_blank"> Towhee </a>是一个成熟的端到端模型服务或MLOps平台，这也不是我们的目标。相反，我们的目标是加速需要嵌入和其他ML任务的应用程序的开发。有了Towhee，我们希望能够在您的本地机器上实现嵌入模型和管道的快速原型化(<code class="fe no np nq nr b">Pipeline</code> + <code class="fe no np nq nr b">Trainer</code>)，允许仅用几行代码(<code class="fe no np nq nr b">DataCollection</code>)开发一个以ML为中心的应用程序，并允许轻松快速地部署到您自己的集群中(通过<a class="ae ki" href="https://github.com/ray-project/ray" rel="noopener ugc nofollow" target="_blank"> Ray </a>)。</p><p id="2c52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们一直在寻找人们加入我们的开源社区——如果你对此感兴趣，请随时通过<a class="ae ki" href="https://slack.towhee.io" rel="noopener ugc nofollow" target="_blank"> Slack </a>和<a class="ae ki" href="https://twitter.com/towheeio" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我们联系。</p><p id="a25b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是所有的人——希望这篇文章是有益的。如果您有任何问题、意见或顾虑，请在下面留下您的评论。敬请关注更多内容！</p><p id="1738" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="ms">原载于2022年4月9日</em><a class="ae ki" href="https://frankzliu.com/blog/making-machine-learning-more-accessible-for-application-developers" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://frankzliu.com</em></a><em class="ms">。</em></p></div></div>    
</body>
</html>