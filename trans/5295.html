<html>
<head>
<title>13 Tips for using PyTest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 PyTest 的 13 个技巧</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/13-tips-for-using-pytest-5341e3366d2d#2022-11-28">https://towardsdatascience.com/13-tips-for-using-pytest-5341e3366d2d#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8414cd2adfe9b667e9c42eede23b33a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6oWzUw7FJZifK2E_pWPeA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/s/photos/python?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kf" href="https://unsplash.com/@altumcode?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> AltumCode </a>拍摄的照片</p></figure><p id="9b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单元测试对于软件开发来说是一项非常重要的技能。有一些很棒的 Python 库可以帮助我们编写和运行单元测试，比如<a class="ae kf" href="https://nose.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Nose </a>和<a class="ae kf" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> Unittest </a>。但是我最喜欢的是<a class="ae kf" href="https://docs.pytest.org/en/7.2.x/" rel="noopener ugc nofollow" target="_blank"> PyTest </a>。</p><p id="f04b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近更详细地阅读了 PyTest 的文档，以便更深入地了解它的特性。</p><p id="19b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一些我认为有用的模糊特性的列表，我将开始把它们集成到我自己的测试工作流程中。我希望这个列表中有一些你不知道的新东西…</p><blockquote class="le lf lg"><p id="2253" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><em class="it">💻这篇文章中的所有代码片段都可以在</em><a class="ae kf" href="https://github.com/julian-west/e4ds-snippets/tree/master/pytest/pytest_tips" rel="noopener ugc nofollow" target="_blank"><em class="it">e4ds-snippets GitHub 资源库</em> </a> <em class="it">中找到。</em></p></blockquote><h1 id="253e" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">编写测试的一般提示👨‍🎓</h1><h1 id="71b3" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.如何编写好的单元测试</h1><p id="c3cd" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">好了，这一条并不是专门针对 PyTest 库的，但是第一条建议是浏览一下<a class="ae kf" href="https://docs.pytest.org/en/7.1.x/explanation/anatomy.html" rel="noopener ugc nofollow" target="_blank"> PyTest 的文档</a>关于构建你的单元测试。这很值得一读。</p><p id="a8c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个好的测试应该验证某种预期的行为，并且能够独立于其他代码运行。也就是说，测试中应该包含设置和运行要测试的行为所需的所有代码。</p><p id="226c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以概括为四个阶段:</p><ul class=""><li id="9211" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated"><strong class="ki iu">安排</strong> —执行测试所需的设置。例如定义输入</li><li id="bfaa" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated"><strong class="ki iu">动作</strong> —运行您想要测试的功能</li><li id="a1a0" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated"><strong class="ki iu">断言</strong> —验证函数的输出是否符合预期</li><li id="147e" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated"><strong class="ki iu">清理</strong>——(可选)清理测试中产生的任何工件。例如输出文件。</li></ul><p id="53de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="9e81" class="nl lm it nh b be nm nn l no np"># example function<br/>def sum_list(my_list):<br/>    return sum(my_list)</span></pre><pre class="nq ng nh ni bn nj nk bi"><span id="b75f" class="nl lm it nh b be nm nn l no np"># example test case<br/>def test_sum_list():<br/>    # arrange<br/>    test_list = [1, 2, 3]<br/>    # act<br/>    answer = sum_list(test_list)<br/>    # Assert<br/>    assert answer == 6</span></pre><p id="6845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这是一个微不足道的例子，但是让所有的测试都有一个通用的结构有助于提高可读性，编写更好的测试。</p><p id="9afa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/explanation/anatomy.html" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/7.1.x/explanation/anatomy.html</a></p><h1 id="f835" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.测试异常</h1><p id="59e8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">通常，我们首先想到的测试是函数成功运行时的预期输出。</p><p id="b3bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当函数引发异常时，验证函数的行为也很重要。尤其是当您知道哪种类型的输入会引发某些异常时。</p><p id="afd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<code class="fe nr ns nt nh b">pytest.raises</code>上下文管理器<a class="ae kf" href="https://docs.pytest.org/en/7.1.x/how-to/assert.html#assertions-about-expected-exceptions" rel="noopener ugc nofollow" target="_blank">测试异常</a>。</p><p id="44ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="e755" class="nl lm it nh b be nm nn l no np">import pytest<br/><br/>def divide(a, b):<br/>    """Divide to numbers"""<br/>    return a/b<br/><br/>def test_zero_division():<br/>    with pytest.raises(ZeroDivisionError):<br/>        divide(1,0)<br/>def test_type_error():<br/>    with pytest.raises(TypeError):<br/>        divide("abc",10)</span></pre><p id="dcff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/how-to/assert.html#assertions-about-expected-exceptions" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/7.1 . x/how-to/assert . html # assertions-about-expected-exceptions</a></p><h1 id="4def" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3.测试记录/打印</h1><p id="44ae" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">PyTest 允许您测试代码中的打印和日志记录语句。</p><p id="4c14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两个内置的 PyTest fixtures，<a class="ae kf" href="https://docs.pytest.org/en/6.2.x/reference.html#std-fixture-capsys" rel="noopener ugc nofollow" target="_blank"> capsys </a>和<a class="ae kf" href="https://docs.pytest.org/en/6.2.x/reference.html#std-fixture-caplog" rel="noopener ugc nofollow" target="_blank"> caplog </a>，可用于跟踪功能打印到终端的信息。</p><h2 id="8e84" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">测试打印输出</h2><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="85df" class="nl lm it nh b be nm nn l no np">def printing_func(name):<br/>    print(f"Hello {name}")</span></pre><pre class="nq ng nh ni bn nj nk bi"><span id="c583" class="nl lm it nh b be nm nn l no np">def test_printing_func(capsys):<br/>    printing_func(name="John")<br/>    # use the capsys fixture to record terminal output<br/>    output = capsys.readouterr()<br/>    assert output.out == "Hello John\n"</span></pre><p id="e379" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/6.2.x/reference.html#std-fixture-capsys" rel="noopener ugc nofollow" target="_blank">https://docs . py test . org/en/6.2 . x/reference . html # STD-fixture-cap sys</a></p><h2 id="b529" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">测试日志输出</h2><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="49ec" class="nl lm it nh b be nm nn l no np">import logging<br/><br/>def logging_func():<br/>    logging.info("Running important function")<br/>    # some more code...<br/>    logging.info("Function completed")<br/><br/><br/>def test_logging_func(caplog):<br/>    # use the caplog fixture to record logging records<br/>    caplog.set_level(logging.INFO)<br/>    logging_func()<br/>    records = caplog.records<br/>    # first message<br/>    assert records[0].levelname == 'INFO'<br/>    assert records[0].message == "Running important function"<br/>    # second message<br/>    assert records[1].levelname == 'INFO'<br/>    assert records[1].message == "Function completed"</span></pre><p id="0d78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/6.2.x/reference.html#std-fixture-caplog" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/6.2 . x/reference . html # STD-fixture-cap log</a></p><h1 id="82e2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.测试彩车</h1><p id="abeb" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">涉及浮点运算的算法会在 Python 中引起问题。</p><p id="8a1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，这个简单的函数会导致一个奇怪的错误:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="02a1" class="nl lm it nh b be nm nn l no np">def subtract_floats(a,b):<br/>    return a - b<br/><br/><br/>def test_substract_floats():<br/>    assert subtract_floats(1.2, 1.0) == 0.2</span></pre><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/af2d8f8ef5fc8870e23c33d7e410b3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ME3PNI8y6yHUR1UK.png"/></div></div></figure><p id="df1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">预期的输出应该是<code class="fe nr ns nt nh b">0.2</code>，但是 Python 返回了<code class="fe nr ns nt nh b">0.19999999999999996</code>。</p><p id="ddfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数的逻辑没有任何问题，它应该不会在这个测试用例中失败。</p><p id="10a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了消除测试中的浮点舍入误差，您可以使用<a class="ae kf" href="https://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-approx" rel="noopener ugc nofollow" target="_blank">近似函数</a></p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="5c1b" class="nl lm it nh b be nm nn l no np">import pytest<br/><br/>def test_substract_floats():<br/>    assert subtract_floats(1.2, 1.0) == pytest.approx(0.2)</span></pre><p id="c549" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试现在通过了。</p><p id="3e39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，您也可以将<code class="fe nr ns nt nh b">approx</code>函数应用于 numpy 数组。这在比较数组和数据帧时很有用。</p><p id="82bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="a3ee" class="nl lm it nh b be nm nn l no np">import pytest<br/>import numpy as np<br/><br/>np.array([0.1, 0.2]) + np.array([0.2, 0.4]) == pytest.approx(np.array([0.3, 0.6]))                                                          </span></pre><p id="c5da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/reference/reference.html#pytest-approx" rel="noopener ugc nofollow" target="_blank">https://docs . py test . org/en/7.1 . x/reference/reference . html # py test-approx</a></p><h1 id="f5b4" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">节省您时间的提示⏳</h1><h1 id="d7fb" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.通过只运行某些测试来节省时间</h1><p id="5add" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">运行测试应该有助于您的工作流程，而不是一个障碍。长时间运行的测试套件会降低您的速度，让您无法定期运行测试。</p><p id="26dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，您不需要在每次进行更改时都运行整个测试套件，尤其是当您只处理代码库的一小部分时。</p><p id="d167" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，能够运行与您正在处理的代码相关的测试子集是很方便的。</p><p id="97dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">PyTest 提供了一些选项来选择要运行的测试:</p><h2 id="3130" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">使用<code class="fe nr ns nt nh b">-k</code>标志</h2><p id="7e9d" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在运行 PyTest 时，您可以使用<code class="fe nr ns nt nh b">-k</code>标志来只运行匹配给定子串的测试。</p><p id="3dec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果您有以下测试:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="46c5" class="nl lm it nh b be nm nn l no np">def test_preprocess_categorical_columns():<br/>    ...<br/><br/>def test_preprocess_numerical_columns():<br/>    ...<br/><br/>def test_preprocess_text():<br/>    ...<br/><br/>def test_train_model():<br/>    ...</span></pre><p id="3246" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用以下命令只运行包含子字符串' categorical '的第一个测试:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="187d" class="nl lm it nh b be nm nn l no np"># run first test only<br/>pytest -k categorical</span></pre><p id="9da3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以运行以下命令，只运行包含名称“预处理”的测试(前三个测试):</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="318e" class="nl lm it nh b be nm nn l no np"># run first three tests only<br/>pytest -k preprocess</span></pre><p id="5b37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逻辑表达式也是允许的。例如，下面将运行包含“预处理”的测试，但排除包含“文本”的测试。这将运行前两个测试，但不会运行第三个:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="9882" class="nl lm it nh b be nm nn l no np"># run first two tests only<br/>pytest -k "preprocess and not text"</span></pre><p id="500b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">命令行标志文档中提供了对<code class="fe nr ns nt nh b">-k</code>标志的有效短语的完整解释:<a class="ae kf" href="https://docs.pytest.org/en/7.2.x/reference/reference.html#command-line-flags" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/7.2 . x/reference/reference . html #命令行标志</a></p><h2 id="9e07" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">在单个测试文件中运行测试</h2><p id="9bd9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如果您的测试被拆分到多个文件中，您可以通过在运行 PyTest 时显式传递文件名来从单个文件中运行测试:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="77ee" class="nl lm it nh b be nm nn l no np"># only run tests defined in 'tests/test_file1.py' file<br/>pytest tests/test_file1.py</span></pre><h2 id="4a38" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">使用标记</h2><p id="d09c" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">您还可以使用 pytest“标记”来标记某些测试。这对于标记“慢”测试很有用，然后您可以用<code class="fe nr ns nt nh b">-m</code>标志将其排除。</p><p id="0ff6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比如说。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="3ab5" class="nl lm it nh b be nm nn l no np">import time<br/>import pytest<br/><br/>def my_slow_func():<br/>    # some long running code...<br/>    time.sleep(5)<br/>    return True<br/><br/>@pytest.mark.slow<br/>def test_my_slow_func():<br/>    assert my_slow_func()</span></pre><p id="c775" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nr ns nt nh b">my_slow_func</code>将比其他测试花费更长的时间。</p><p id="3d53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用了<code class="fe nr ns nt nh b">@pytest.mark.slow</code>装饰器之后，我们可以使用<code class="fe nr ns nt nh b">-m</code>标志来排除每次运行这个测试:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="6051" class="nl lm it nh b be nm nn l no np"># exclude running tests marked as slow<br/>pytest -m "not slow"</span></pre><p id="355f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你在某些情况下需要跳过测试，标记也很方便。例如，如果您的 CI 构建使用多个版本的 Python 运行测试，并且您知道某个测试将会在某个版本的 Python 上失败。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="0b4c" class="nl lm it nh b be nm nn l no np">import sys<br/><br/>@pytest.mark.skipif(sys.version_info &lt; (3, 10), reason="requires python3.10 or higher")<br/>def test_function():<br/>    ...</span></pre><p id="58c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/example/markers.html" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/7.1.x/example/markers.html</a>T12<a class="ae kf" href="https://docs.pytest.org/en/7.1.x/how-to/skipping.html" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/7.1.x/how-to/skipping.html</a></p><h1 id="f8d0" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">6.仅重新运行失败的测试</h1><p id="e68e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当您运行整个测试套件时，您可能会发现少数测试失败了。</p><p id="624d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您调试了问题并更新了代码，而不是再次运行整个测试套件，您可以使用<code class="fe nr ns nt nh b">--lf</code>标志只运行上次运行失败的测试。</p><p id="be47" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在再次运行整个测试套件之前，您可以验证更新的代码是否通过了这些测试。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="43f7" class="nl lm it nh b be nm nn l no np"># only run tests which failed on last run<br/>pytest --lf</span></pre><p id="1e3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者，您仍然可以运行整个测试套件，但是使用<code class="fe nr ns nt nh b">--ff</code>标志从上次失败的测试开始。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="1bde" class="nl lm it nh b be nm nn l no np"># run all tests but run failed tests first<br/>pytest --ff</span></pre><p id="a38e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/how-to/cache.html#rerunning-only-failures-or-failures-first" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/7.1 . x/how-to/cache . html # re running-only-failures-or-failures-first</a></p><h1 id="fa47" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">节省您编写代码的技巧🚀</h1><h1 id="2fad" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">7.参数化测试</h1><p id="aa36" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">当您想要测试特定函数的多个不同输入时，人们通常会在测试函数中编写多个 assert 语句。例如:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="c460" class="nl lm it nh b be nm nn l no np">def remove_special_characters(input_string):<br/>    return re.sub(r"[^A-Za-z0-9]+", "", input_string)<br/><br/><br/>def test_remove_special_characters():<br/>    assert remove_special_characters("hi*?.") == "hi"<br/>    assert remove_special_characters("f*()oo") == "foo"<br/>    assert remove_special_characters("1234bar") == "bar"<br/>    assert remove_special_characters("") == ""</span></pre><p id="83e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 PyTest 中使用“参数化测试”有一个更好的方法:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="fa62" class="nl lm it nh b be nm nn l no np">import pytest<br/><br/>@pytest.mark.parametrize(<br/>    "input_string,expected",<br/>    [<br/>        ("hi*?.", "hi"),<br/>        ("f*()oo", "foo"),<br/>        ("1234bar", "1234bar"),<br/>        ("", ""),<br/>    ],<br/>)<br/>def test_remove_special_characters(input_string, expected):<br/>    assert remove_special_characters(input_string) == expected</span></pre><p id="6ade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这有利于减少重复代码。此外，PyTest 为每个参数化的输入运行单独的测试。因此，如果其中一项测试失败，将更容易识别。然而，在使用多个 assert 语句的原始实现中，PyTest 将其作为单个测试运行。如果任何断言语句失败，整个测试将“失败”。</p><h1 id="c3bb" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">8.从文档字符串运行测试</h1><p id="0f57" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">另一个很酷的技巧是直接从 docstrings 定义和运行测试。</p><p id="37af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以如下定义文档字符串中的测试用例:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="7c20" class="nl lm it nh b be nm nn l no np">def add(a, b):<br/>    """Add two numbers<br/><br/>    &gt;&gt;&gt; add(2,2)<br/>    4<br/>    """<br/>    return a + b</span></pre><p id="d6cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在运行<code class="fe nr ns nt nh b">pytest</code>命令时，通过添加<code class="fe nr ns nt nh b">--doctest-modules</code>标志，您可以将 docstring 测试包含到您的测试套件中。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="03c7" class="nl lm it nh b be nm nn l no np">pytest --doctest-modules</span></pre><p id="9c32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 docstrings 中定义测试对使用您的代码的其他开发人员非常有帮助，因为它在函数定义中明确显示了函数的预期输入和输出。</p><p id="d8f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发现这对于使用“简单”数据结构作为输入和输出的函数非常有效。而不是编写向测试套件添加更多代码的全面测试。</p><p id="7610" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/how-to/doctest.html#how-to-run-doctests" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/7.1 . x/how-to/doctest . html # how-to-run-doc tests</a></p><h1 id="9171" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">9.内置 pytest 夹具</h1><p id="806a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">PyTest 包括许多非常有用的内置装置。</p><p id="fb85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在技巧 3 中简要介绍了其中的一些装置——capsys 和 cap log——但是完整的列表可以在这里找到:<a class="ae kf" href="https://docs.pytest.org/en/stable/reference/fixtures.html#built-in-fixtures" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/stable/reference/fixtures . html # built-in-fixtures</a></p><p id="8211" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的测试可以通过简单地将它们作为参数添加到测试函数中来访问这些装置。</p><p id="d678" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来，两个最有用的内置夹具是<code class="fe nr ns nt nh b">request</code>夹具和<code class="fe nr ns nt nh b">tmp_path_factory</code>夹具。</p><p id="d9f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里查看我关于使用<code class="fe nr ns nt nh b">request</code>夹具在参数化测试中使用<a class="ae kf" href="https://engineeringfordatascience.com/posts/pytest_fixtures_with_parameterize/" rel="noopener ugc nofollow" target="_blank">夹具的文章。</a></p><p id="7f20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nr ns nt nh b">tmp_path_factory</code> fixture 可以用来创建运行测试的临时目录。例如，如果您正在测试一个需要将文件保存到某个目录的函数。</p><p id="0fce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/stable/reference/fixtures.html#built-in-fixtures" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/stable/reference/fixtures . html #内置固定装置</a><br/><a class="ae kf" href="https://docs.pytest.org/en/7.1.x/how-to/tmp_path.html#the-tmp-path-factory-fixture" rel="noopener ugc nofollow" target="_blank">https://docs . pytest . org/en/7.1 . x/how-to/tmp _ path . html # the-tmp-path-factory-fixture</a></p><h1 id="dfce" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">帮助调试的提示</h1><h1 id="0e8c" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">10.增加测试的冗长度</h1><p id="9ef3" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">PyTest 的默认输出可能非常小。如果测试失败，增加终端输出中提供的信息量会很有帮助。</p><p id="8954" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可以通过使用详细标志<code class="fe nr ns nt nh b">-vv</code>来添加</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="af24" class="nl lm it nh b be nm nn l no np"># increase the amount of information provided by PyTest in the terminal output<br/>pytest -vv</span></pre><p id="cb1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.2.x/reference/reference.html#command-line-flags" rel="noopener ugc nofollow" target="_blank">https://docs . py test . org/en/7.2 . x/reference/reference . html #命令行标志</a></p><h1 id="d489" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">11.显示测试持续时间</h1><p id="73f9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">如果您的测试套件需要很长时间来运行，您可能想要了解哪些测试运行的时间最长。然后，你可以尝试优化这些测试，或者使用标记来排除它们，如上所示。</p><p id="f9c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<code class="fe nr ns nt nh b">--durations</code>标志找出哪些测试运行时间最长。</p><p id="2334" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还需要传递 verbosity 标志来显示完整的持续时间报告。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="6859" class="nl lm it nh b be nm nn l no np"># show top 5 longest running tests<br/>pytest --durations=5 -vv</span></pre><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/a0ccb8d2254f369ffd4cea723b25d189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*L1k5laNitxtGpT75.png"/></div></div></figure><p id="1a2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.2.x/reference/reference.html#command-line-flags" rel="noopener ugc nofollow" target="_blank">https://docs . py test . org/en/7.2 . x/reference/reference . html #命令行标志</a></p><h1 id="a7c3" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">12.在代码中显示 print 语句的输出</h1><p id="6c99" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">有时，您会在源代码中使用 print 语句来帮助调试函数。</p><p id="db15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，如果测试通过，Pytest 不会显示这些打印语句的输出。</p><p id="3eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过使用<code class="fe nr ns nt nh b">-rP</code>标志来覆盖这种行为。</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="49c1" class="nl lm it nh b be nm nn l no np">def my_function_with_print_statements():<br/>    print("foo")<br/>    print("bar")<br/>    return True<br/><br/><br/>def test_my_function_with_print_statements():<br/>    assert my_function_with_print_statements()<br/></span></pre><pre class="nq ng nh ni bn nj nk bi"><span id="8024" class="nl lm it nh b be nm nn l no np"># run tests but show all printed output of passing tests<br/>pytest -rP</span></pre><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi og"><img src="../Images/90af7177302009ebcec4e18015ff0f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c50HBfvybCKQdcPg.png"/></div></div></figure><p id="0753" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/7.2.x/reference/reference.html#command-line-flags" rel="noopener ugc nofollow" target="_blank">https://docs . py test . org/en/7.2 . x/reference/reference . html #命令行标志</a></p><h1 id="bf67" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">13.为参数化测试分配 id</h1><p id="eea2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">运行参数化测试的一个潜在问题是，它们在终端输出中以相同的名称出现。即使他们在技术上测试不同的行为。</p><p id="1994" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以将 id 添加到您的参数化测试中，为每个参数化测试赋予一个唯一的名称，以帮助识别它。它还增加了测试的可读性，因为你可以清楚地知道你要测试什么。</p><p id="1782" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有两个向测试中添加 id 的选项:</p><h2 id="4be1" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">选项 1:<code class="fe nr ns nt nh b">id</code>参数</h2><p id="25f2" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">重用技巧 7 中的参数化示例:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="9e65" class="nl lm it nh b be nm nn l no np">@pytest.mark.parametrize(<br/>    "input_string,expected",<br/>    [<br/>        ("hi*?.", "hi"),<br/>        ("f*()oo", "foo"),<br/>        ("1234bar", "1234bar"),<br/>        ("", ""),<br/>    ],<br/>    ids=[<br/>        "remove_special_chars_from_end",<br/>        "remove_special_chars_from_middle",<br/>        "ignore_numbers",<br/>        "no_input",<br/>    ],<br/>)<br/>def test_remove_special_characters(input_string, expected):<br/>    assert remove_special_characters(input_string) == expected</span></pre><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oh"><img src="../Images/61c693248af61ad0d339872c13295b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q0iI16z8TV6ByVdI.png"/></div></div></figure><h2 id="fe03" class="nu lm it bd ln nv nw dn lr nx ny dp lv kr nz oa lz kv ob oc md kz od oe mh of bi translated">选项 2:使用<code class="fe nr ns nt nh b">pytest.param</code></h2><p id="4447" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">或者使用<code class="fe nr ns nt nh b">pytest.param</code>包装:</p><pre class="nc nd ne nf gt ng nh ni bn nj nk bi"><span id="7561" class="nl lm it nh b be nm nn l no np">@pytest.mark.parametrize(<br/>    "input_string,expected",<br/>    [<br/>        pytest.param("hi*?.", "hi", id="remove_special_chars_from_end"),<br/>        pytest.param("f*()oo", "foo", id="remove_special_chars_from_middle"),<br/>        pytest.param("1234bar", "1234bar", id="ignore_numbers"),<br/>        pytest.param("", "", id="no_input"),<br/>    ],<br/>)<br/>def test_remove_special_characters(input_string, expected):<br/>    assert remove_special_characters(input_string) == expected</span></pre><p id="2035" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一般来说，我更喜欢使用选项 1，因为我认为它更整洁。但是，如果您正在运行包含许多行的大量参数化输入，那么使用选项 2 可能更具可读性。</p><p id="f655" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://docs.pytest.org/en/stable/example/parametrize.html#different-options-for-test-ids" rel="noopener ugc nofollow" target="_blank">https://docs . py test . org/en/stable/example/parameter ize . html # different-options-for-test-ids</a></p><h1 id="e356" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="5494" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">PyTest 是一个很棒的测试框架，有很多有用的特性。文档通常非常好，我强烈推荐浏览更多信息和其他优秀特性。</p><p id="127c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望您学到了一些新东西——我很想知道您还有哪些使用 PyTest 的技巧。</p><p id="d104" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试愉快！</p><blockquote class="le lf lg"><p id="240b" class="kg kh lh ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">本文最初发表于<a class="ae kf" href="https://engineeringfordatascience.com/posts/tips_for_using_pytest/" rel="noopener ugc nofollow" target="_blank">engineeringfordatascience.com</a></p></blockquote></div></div>    
</body>
</html>