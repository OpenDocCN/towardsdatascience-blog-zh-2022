<html>
<head>
<title>What You Need to Know About Generated Columns in MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于MySQL中生成的列，您需要了解什么</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/what-you-need-to-know-about-generated-columns-in-mysql-23871b376d66#2022-06-28">https://towardsdatascience.com/what-you-need-to-know-about-generated-columns-in-mysql-23871b376d66#2022-06-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46fa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将自动生成的数据添加到表中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6209f24827e89e8d998d12feea3498e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SneGw09QTdjtT8sy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汉斯·雷尼尔斯在Unsplash的照片</p></figure><p id="bdda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL生成的列是一个强大的、易于使用的高级工具，可以帮助任何想要向表中添加自动生成的数据的人——在这篇博客中，我们将学习掌握它们所需的一切。</p><p id="42bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的列允许您在不使用<code class="fe lv lw lx ly b">INSERT</code>和<code class="fe lv lw lx ly b">UPDATE</code>子句的情况下在表中存储自动生成的数据。这个有用的特性从版本5.7 开始就是MySQL <a class="ae ky" href="https://dev.mysql.com/doc/refman/5.7/en/mysql-nutshell.html" rel="noopener ugc nofollow" target="_blank">的一部分，它代表了触发器生成数据的另一种方法。此外，生成的列可以帮助您使查询更容易、更有效。</a></p><p id="3e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们学习掌握MySQL中生成的列所需要知道的一切。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="01dd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是MySQL生成的列？</h1><p id="0444" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">生成的列类似于普通列，但您不能手动更改其值。这是因为表达式定义了如何根据从同一行的其他列中读取的其他值来生成生成列的值。所以，生成的列在表的域内工作，它的定义不能包含<code class="fe lv lw lx ly b">JOIN</code>语句。</p><p id="3646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，您可以将生成的列视为一种视图，但仅限于列。注意，生成的列不同于SQL触发器，只有在使用语法如下的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/create-table-generated-columns.html" rel="noopener ugc nofollow" target="_blank">CREATE TABLE</a></code>或<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table-generated-columns.html" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/alter-table-generated-columns.html" rel="noopener ugc nofollow" target="_blank">ALTER TABLE</a></code>语句时才能定义它们:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9918" class="nh mh it ly b gy ni nj l nk nl">generate_column_name column_type [GENERATED ALWAYS] AS (generation_expression)<br/>[VIRTUAL | STORED] [NOT NULL | NULL]<br/>[UNIQUE [KEY]] [[PRIMARY] KEY][COMMENT 'string']</span></pre><p id="e401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AS (generated_column_expression)</code>子句指定您添加或更新到表中的列是一个生成的列。<code class="fe lv lw lx ly b">generation_expression</code>定义了MySQL将用来计算列值的表达式，它不能引用另一个生成的列或除当前表的列之外的任何内容。</p><p id="05fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意，生成表达式只能包含不可变的函数。例如，不能在生成的列表达式定义中使用返回当前日期的函数，因为它是可变函数。</p><p id="a94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以在<code class="fe lv lw lx ly b">AS</code>前面加上<code class="fe lv lw lx ly b">GENERATED ALWAYS</code>关键字，以使生成的列更加明确，但这是可选的。然后，您可以指明生成的列的类型是<code class="fe lv lw lx ly b">VIRTUAL</code>还是<code class="fe lv lw lx ly b">STORED</code>。你将在下一章了解这两种类型的区别。默认情况下，如果查询中没有明确指定，MySQL会将生成的列标记为<code class="fe lv lw lx ly b">VIRTUAL</code>。</p><p id="b507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看在一个<code class="fe lv lw lx ly b">CREATE TABLE</code>查询中生成的列语法:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="baf4" class="nh mh it ly b gy ni nj l nk nl">CREATE TABLE users (<br/>id INT AUTO_INCREMENT PRIMARY KEY,<br/>email VARCHAR(100) NOT NULL,<br/>first_name VARCHAR(60) NOT NULL,<br/>last_name VARCHAR(60) NOT NULL,<br/>full_name varchar(120) GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name))<br/>);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/1a9aae1f62790d79378dbecefa4da756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-R2Q2-sStHnRsQ-i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype </a>中的<code class="fe lv lw lx ly b">CREATE TABLE</code>查询</p></figure><p id="27ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe lv lw lx ly b">full_name</code>列将自动存储<code class="fe lv lw lx ly b">first_name</code>和<code class="fe lv lw lx ly b">last_name</code>列的连接。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="41e2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">MySQL中存在哪些类型的生成列？</h1><p id="bf59" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如前所述，您可以将生成的列定义为<code class="fe lv lw lx ly b">VIRTUAL</code>或<code class="fe lv lw lx ly b">STORED</code>。现在让我们仔细看看这两种类型。</p><h2 id="fa64" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">虚拟生成的列</h2><p id="815e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">MySQL不存储标记为<code class="fe lv lw lx ly b">VIRTUAL</code>的生成列。这意味着MySQL会在需要时动态评估其价值。这通常在任何<code class="fe lv lw lx ly b">BEFORE</code>查询被触发后立即发生。换句话说，虚拟生成的列不占用存储空间。</p><h2 id="d59d" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">存储生成的列</h2><p id="1878" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">MySQL存储任何生成的标记为<code class="fe lv lw lx ly b">STORED</code>的列。这意味着每当您插入或更新一行时，MySQL负责评估它的值并将其存储在磁盘上。换句话说，存储列需要存储空间，就像普通列一样。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b285" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">虚拟生成的列与存储生成的列</h1><p id="0195" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们进一步了解虚拟列和存储生成列的优缺点。</p><h2 id="fe1c" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">虚拟生成的列</h2><p id="784e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><strong class="lb iu">优点</strong></p><ul class=""><li id="9941" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">它们的创建是即时的，因为MySQL只需改变<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema.html" rel="noopener ugc nofollow" target="_blank">表元数据。</a></li><li id="39d5" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">它们不需要磁盘空间。</li><li id="aa1a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe lv lw lx ly b">INSERT</code>和<code class="fe lv lw lx ly b">UPDATE</code>查询没有开销，因为MySQL不需要生成它们。</li></ul><p id="9fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="a889" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">MySQL在读取表时必须对它们进行评估，这使得涉及它们的SELECT查询变得更慢。</li></ul><h2 id="4e32" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">存储生成的列</h2><h2 id="e09a" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">赞成的意见</h2><ul class=""><li id="ac42" class="ny nz it lb b lc my lf mz li om lm on lq oo lu od oe of og bi translated">MySQL可以读取它们，就像它们是普通的列一样，这保证了在没有开销的情况下快速检索。</li></ul><h2 id="cf7d" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">骗局</h2><ul class=""><li id="3ffe" class="ny nz it lb b lc my lf mz li om lm on lq oo lu od oe of og bi translated">当添加到一个新表中时，MySQL必须重建整个表。</li><li id="091c" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><code class="fe lv lw lx ly b">INSERT</code>或<code class="fe lv lw lx ly b">UPDATE</code>会带来开销，因为MySQL必须生成它们。</li><li id="afc4" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">它们需要磁盘空间(注意，您可以在一个表中混合虚拟列和存储列，它们都支持<a class="ae ky" href="https://arctype.com/blog/mysql-index-performance/" rel="noopener ugc nofollow" target="_blank"> MySQL索引</a>和二级索引。但是正如官方文档中的<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/create-table-secondary-indexes.html#create-table-secondary-indexes" rel="noopener ugc nofollow" target="_blank">所解释的，虚拟列上的二级索引比存储的生成列占用更少的空间和内存，这意味着虚拟生成列在涉及二级索引时效率更高。)</a></li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="df49" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么采用生成的列？</h1><p id="1a53" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">采用生成列有几个原因，但下面三个是最重要的原因。</p><ul class=""><li id="9439" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated"><strong class="lb iu">它们为您提供了缓存功能，使您的查询速度更快</strong>:生成的列使您有可能定义包含有用数据的列，这样您就可以在需要时高效地检索这些数据。</li><li id="eda6" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">它们允许您简化查询表达式</strong>:您可以将复杂性分散到生成的列中，然后在简单的过滤操作中使用它们，而不是让查询变得复杂。</li><li id="99a7" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated"><strong class="lb iu">它们使您能够定义函数索引</strong> : MySQL将<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-functional-key-parts" rel="noopener ugc nofollow" target="_blank">函数索引</a>实现为隐藏的虚拟生成列。换句话说，生成的列使您有可能定义涉及MySQL函数的高效和高级索引。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cd83" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">MySQL生成的实际例子中的列</h1><p id="c666" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们在一些例子中看看生成的列，这些例子来自我作为一个与数据驱动的初创公司合作的<a class="ae ky" rel="noopener" target="_blank" href="/working-for-a-data-driven-startup-whose-value-surged-700-in-less-than-one-year-168e8c43565a">后端开发人员的经历</a>。</p><h2 id="fdaa" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">1.出于一致性原因，使用生成的列来连接列</h2><p id="0a6f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在开发应用程序的前端时，您可能会注意到数据表示中的某些模式。例如，在体育运动中，一个队中的运动员通常用以下格式来标识:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="02b6" class="nh mh it ly b gy ni nj l nk nl">first_name [first_character_middle_name.] last_name [(jersey_number)]</span></pre><p id="8074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，您可以通过将这四列与以下生成的列聚合来轻松生成该数据字段:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bae2" class="nh mh it ly b gy ni nj l nk nl">string_identifier VARCHAR(255) GENERATED ALWAYS AS<br/>(CONCAT(first_name, ' ', IF(middle_name IS NULL, '', CONCAT(LEFT(middle_name, 1), '. ')), last_name, IF(jersey_number IS NULL, '', CONCAT(' (', jersey_number, ')'))))<br/>STORED</span></pre><p id="1e37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2a95" class="nh mh it ly b gy ni nj l nk nl">Cristiano Ronaldo (7)<br/>Lionel A. Messi (10)</span></pre><p id="1649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，生成的列使您能够直接在数据库级别标准化数据字段格式。此外，存储生成的列避免了每次需要时构建该字段的不可避免的开销。</p><h2 id="3bbb" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">2.使用生成的列来自动生成哈希id</h2><p id="acd2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">通常，您使用网站URL中的资源id或<a class="ae ky" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">REST API</a>来检索您需要的数据。但是公开暴露你的身份会带来安全问题。当您发现自己使用自动递增的id时尤其如此，这很容易预测，并使抓取或bot攻击更容易。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bfe0" class="nh mh it ly b gy ni nj l nk nl">public_id VARCHAR(40) GENERATED ALWAYS AS SHA1(CONCAT("PLAYER", id)) VIRTUAL</span></pre><p id="e1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，您可以考虑通过使用自动生成的、随机的、更安全的公共id来隐藏您的原始id。您可以通过散列您的id，使用虚拟生成的列来实现这一点，如下所示:</p><p id="28eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，为了避免生成已知的哈希值，您可以用一个特殊的关键字连接您的id。点击了解更多关于MySQL加密和压缩功能的信息<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/encryption-functions.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="ecef" class="nh mh it bd mi nn no dn mm np nq dp mq li nr ns ms lm nt nu mu lq nv nw mw nx bi translated">3.定义生成的列以简化数据筛选</h2><p id="c66f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">筛选数据时，有些列比其他列更有用。此外，您经常需要更改存储在列中的值的表示形式，以使筛选更简单或更直观。您可以定义一个有用的生成列，以所需的格式存储执行筛选所需的信息，而不是在每个筛选查询中都这样做。</p><p id="d4c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可以定义一个生成的列，以便更容易地找到篮球队的队员，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7d17" class="nh mh it ly b gy ni nj l nk nl">filter_string VARCHAR(255) GENERATED ALWAYS AS<br/>(CONCAT(first_name, ' ', last_name, IF(birthdate IS NULL, '', CONCAT(' ', DATE_FORMAT(birthdate, "%m-%d-%Y"))))<br/>STORED</span></pre><p id="096d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种列将产生:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6b5a" class="nh mh it ly b gy ni nj l nk nl">LeBron James 12-30-1984<br/>Stephen Curry 03-14-1988</span></pre><p id="67f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这包含数据有用的过滤和球员的出生日期在美国的格式。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="909e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">生成的列与触发器</h1><p id="cf7f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如前所述，您只能在表中使用生成的列。此外，它们只能涉及不可变的函数，MySQL生成它们的值以响应<code class="fe lv lw lx ly b">INSERT</code>或<code class="fe lv lw lx ly b">UPDATE</code>查询。另一方面，<a class="ae ky" href="https://dev.mysql.com/doc/refman/8.0/en/trigger-syntax.html" rel="noopener ugc nofollow" target="_blank">触发器</a>是一个存储程序，每当与特定表相关的<code class="fe lv lw lx ly b">INSERT</code>、<code class="fe lv lw lx ly b">UPDATE</code>或<code class="fe lv lw lx ly b">DELETE</code>事件发生时，MySQL就会自动执行该程序。</p><p id="940d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，触发器可以涉及几个表和所有MySQL函数。与生成的列相比，这使它们成为更完整的解决方案。同时，MySQL触发器本质上使用和定义起来更复杂，并且比生成的列更慢。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2c77" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="7924" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">MySQL生成的列无疑是一个很好的工具，可以服务于多种用途并带来多种好处。采用它们既简单又有效，尽管没有多少数据库开发人员使用它们。无论哪种方式，知道如何利用它们对于使你的后端应用程序更快、更干净、更简单来说都是必不可少的。我希望通过真实世界的例子解释生成列的用例，能够帮助您获得更多数据库领域的知识，直到下一次。</p><p id="2c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望这篇文章对你有所帮助。请随意留下任何问题、评论或建议。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="93cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="op">原载于2022年6月28日</em><a class="ae ky" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank"><em class="op">【https://arctype.com】</em></a><em class="op">。</em></p></div></div>    
</body>
</html>