<html>
<head>
<title>An Elegant Guide to Testing Your Data Science Pipeline Using Pytest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytest测试数据科学管道的简明指南</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-elegant-guide-to-testing-your-data-science-pipeline-using-pytest-4859b0c32591#2022-09-19">https://towardsdatascience.com/an-elegant-guide-to-testing-your-data-science-pipeline-using-pytest-4859b0c32591#2022-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f854" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数据科学项目Pytest综合指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/043bd95e12ffa5fd5d26a6c85c7ee137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1dbdezZmoOC-DItz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安妮·斯普拉特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="4750" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动机</h1><p id="11e4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">今天的数据科学团队面临的最大障碍之一是将他们的数据驱动管道从jupyter笔记本过渡到可执行、可再现和有组织的文件，包括函数和类。</p><p id="2c2c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们大多数人来说，在数据科学项目的生命周期中，在jupyter笔记本上工作是一项有趣而愉快的任务。</p><p id="1f27" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，构建一个没有错误的、经过充分测试的、可靠的、在生产中不会中断的数据管道却不是这样。</p><p id="01ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，设想这样一种情况，您在数据管道中编写了一个函数，将两个数相除:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="d46b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在jupyter笔记本中工作时，作为程序员，您知道应该在方法中放入什么，以及期望输出什么。</p><p id="7124" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">想想在这个简单的划分中到底会有什么地方出错，你在没有测试的情况下把这个方法推向生产<strong class="lq ir">，</strong>，你猜怎么着？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr mq l"/></div></figure><p id="0019" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">分母为零时管道崩溃！</p><p id="63fb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，为了减少数据管道中的错误，并确保函数按照预期的方式工作，在将代码投入生产之前，根据不同的示例输入(或数据情况)对它们进行测试是非常重要的一步。</p><p id="ce5e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">换句话说，这里的目标是为管道创建一个可靠的自动化框架。</p><p id="73c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，自动化框架被定义为一种有组织的方法来编写测试用例，执行它们，并报告自动化测试的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/09f68059976dd0ecda718ad0b6ad6b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fr6Lse2z0lOraz1LwK-3kw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">测试框架概述(图片由作者提供)</p></figure><p id="e478" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通常，您应该始终测试数据科学项目中的函数，因为它:</p><ul class=""><li id="750c" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">确保代码端到端按预期运行，从而提高可靠性。</li><li id="b2cc" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">帮助您检测不同方法可能失败的边缘情况。</li><li id="0906" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">允许其他团队成员在测试的帮助下理解您的代码——降低代码复杂性。</li><li id="2ac7" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">在不干扰其他功能的情况下，帮助用优化/改进版本交换现有代码。</li><li id="0519" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated">支持生成关于代码的可操作见解，如运行时、预期输入/输出等。</li></ul><p id="035d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">谢天谢地，Python提供了少数开源库，如<a class="ae kv" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank"> unittest </a>、<a class="ae kv" href="https://nose.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> nose </a>、<a class="ae kv" href="https://behave.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">behavior</a>等。，但在Python开发者社区中脱颖而出的是<a class="ae kv" href="https://docs.pytest.org/en/7.1.x/" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> Pytest </strong> </a>。</p><p id="4529" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，在本文中，我将详细介绍如何利用Pytest为您的数据科学项目构建测试套件。</p><p id="fbbd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们开始吧🚀！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="e873" class="kw kx iq bd ky kz no lb lc ld np lf lg jw nq jx li jz nr ka lk kc ns kd lm ln bi translated">Pytest入门</h1><p id="3697" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">作为一个快速介绍，Pytest是一个测试框架，用于编写测试代码，在Python中的编码管道上执行它们，并生成相应的测试报告。</p><p id="bef5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我看来，Pytest最大的优点是它与数据管道集成的直观和简单的过程。</p><p id="2dac" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">测试已经是一项数据科学家们不太感兴趣的工作了。</p><p id="2fce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这方面，Pytest真正使编写测试套件的任务变得简单而有趣，这反过来极大地有助于确定数据科学项目的可靠性。</p><p id="c228" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要安装Pytest，请执行以下命令:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt mq l"/></div></figure><p id="cdf8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，您应该导入Pytest来利用它的核心测试功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt mq l"/></div></figure><p id="7939" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样，您就可以编写测试用例并执行它们了。</p><h1 id="f627" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">将Pytest投入使用</h1><p id="760a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经在<code class="fe nu nv nw nx b">project.py</code>中编写了<code class="fe nu nv nw nx b">divide_two_numbers()</code>方法。</p><p id="74e8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，让我们为测试创建一个单独的文件(<code class="fe nu nv nw nx b">test_file.py</code>)。</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="c553" class="oc kx iq nx b gy od oe l of og">project<br/>├── project.py<br/>└── test_file.py</span></pre><p id="7e96" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们上面定义的方法(<code class="fe nu nv nw nx b">divide_two_numbers()</code>)，我们来写一个测试函数。</p><p id="49b9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将根据不同的输入检查该方法返回的输出的数据类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh mq l"/></div></figure><p id="9c6d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要执行这个测试功能，打开当前工作目录中的命令行并运行命令<code class="fe nu nv nw nx b">pytest</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi mq l"/></div></figure><p id="f678" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如所料，该方法在第二次断言时失败，分母为零，这允许您更正函数。</p><p id="c52d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所有这些都很好，但现在你应该有两个问题:</p><ol class=""><li id="fc41" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj oj mz na nb bi translated">在上面的<code class="fe nu nv nw nx b">pytest</code>命令中，我们从未指定测试文件的名称。然而，在结果中，我们只看到了对<code class="fe nu nv nw nx b">test_file.py</code>的提及。Pytest是如何推断出<code class="fe nu nv nw nx b">test_file.py</code>是我们列出所有测试用例的特定文件的？</li><li id="84ef" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj oj mz na nb bi translated">接下来，pytest是如何找到它需要执行的方法的？换句话说，pytest是如何将<code class="fe nu nv nw nx b">divide_two_numbers()</code>与<code class="fe nu nv nw nx b">test_divide_two_numbers_method()</code>区分开来，并指出测试用例是在后一种方法中列出的？</li></ol><p id="83e5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">答案在于Pytest中的“测试搜索”(也称为“测试发现”)技术。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="58b8" class="kw kx iq bd ky kz no lb lc ld np lf lg jw nq jx li jz nr ka lk kc ns kd lm ln bi translated">Pytest中的测试搜索</h1><p id="4af5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Pytest实现了以下测试发现方法来查找测试函数、文件和Python类:</p><ol class=""><li id="5c8f" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj oj mz na nb bi translated">如果在Pytest执行期间没有指定目录(或文件), Pytest将从当前目录开始发现，并递归到子目录中。</li><li id="a752" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj oj mz na nb bi translated">在每个目录中，它在文件名中搜索一个模式:<code class="fe nu nv nw nx b">test_*.py</code>或<code class="fe nu nv nw nx b">*_test.py</code>。这就是为什么在上面的测试中，<code class="fe nu nv nw nx b">project.py</code>文件没有被选中。</li><li id="486f" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj oj mz na nb bi translated">从模式匹配的文件中，它收集:</li></ol><ul class=""><li id="d799" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">一个Python类的所有<code class="fe nu nv nw nx b">"test”</code>前缀方法<strong class="lq ir">在</strong>之外。例如，从下面的方法中，只有<code class="fe nu nv nw nx b">test_method1()</code>会被收集，而<code class="fe nu nv nw nx b">method2_test()</code>不会。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok mq l"/></div></figure><ul class=""><li id="bf0c" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated">所有<code class="fe nu nv nw nx b">"test"</code>前缀的方法<strong class="lq ir">在</strong>内，一个<code class="fe nu nv nw nx b">"Test”</code>前缀的Python类没有<code class="fe nu nv nw nx b">__init__()</code>方法。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ol mq l"/></div></figure><p id="f879" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，在上面的代码块中，从<code class="fe nu nv nw nx b">Test_Class1</code>开始，只有<code class="fe nu nv nw nx b">test_method1()</code>会被收集，因为它以关键字<code class="fe nu nv nw nx b">"test"</code>为前缀。</p><p id="3086" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，不会从<code class="fe nu nv nw nx b">Test_Class2</code>收集任何方法，因为它有<code class="fe nu nv nw nx b">__init__()</code>方法。</p><p id="bcd5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，不会从<code class="fe nu nv nw nx b">Class3_Test</code>收集任何方法，因为类名没有以关键字<code class="fe nu nv nw nx b">"Test"</code>为前缀。</p><h2 id="198a" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">自定义测试搜索</h2><p id="f713" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">虽然Pytest的默认测试发现机制直观明了，但是在某些情况下，您可能需要定制测试搜索模式。</p><p id="7003" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为此，您可以在项目根目录中声明的配置文件(<code class="fe nu nv nw nx b">pytest.ini</code>)中配置不同的命名约定。</p><blockquote class="ox oy oz"><p id="2aaa" class="lo lp pa lq b lr mk jr lt lu ml ju lw pb mm lz ma pc mn md me pd mo mh mi mj ij bi translated">Pytest还支持对文件扩展名<code class="fe nu nv nw nx b">.ini</code>的替代，你可以在这里阅读<a class="ae kv" href="https://docs.pytest.org/en/7.1.x/reference/customize.html#config-file-formats" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="6c1b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该目录现在的结构如下:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="317a" class="oc kx iq nx b gy od oe l of og">project<br/>├── project.py<br/>├── test_file.py<br/>└── pytest.ini</span></pre><p id="192e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们在配置文件中设置了三个变量来定制搜索模式。这些是<code class="fe nu nv nw nx b">python_files</code>、<code class="fe nu nv nw nx b">python_classes</code>和<code class="fe nu nv nw nx b">python_functions</code>。这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pe mq l"/></div></figure><p id="83e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用这种搜索模式，Pytest将在以<code class="fe nu nv nw nx b">"check_"</code>为前缀的文件中搜索测试函数。</p><p id="f1d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，测试函数也应该以<code class="fe nu nv nw nx b">"check_"</code>为前缀。</p><p id="8f2a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，测试类(如果有的话)应该以关键字<code class="fe nu nv nw nx b">"_Check"</code>结尾，以便考虑进行测试。</p><p id="ca83" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，如果我们运行<code class="fe nu nv nw nx b">pytest</code>命令，我们会得到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pf mq l"/></div></figure><p id="b180" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Pytest未识别出任何测试，因为新定义的测试搜索模式与目录中的任何方法和文件都不匹配。</p><p id="6121" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要纠正这一点，您应该将<code class="fe nu nv nw nx b"><strong class="lq ir">test</strong>_file.py</code>重命名为<code class="fe nu nv nw nx b"><strong class="lq ir">check</strong>_file.py</code>，将<code class="fe nu nv nw nx b"><strong class="lq ir">test</strong>_divide_two_numbers_method()</code>重命名为<code class="fe nu nv nw nx b"><strong class="lq ir">check</strong>_divide_two_numbers_method()</code>。</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="dc8b" class="oc kx iq nx b gy od oe l of og">project<br/>├── project.py<br/>├── check_file.py<br/>└── pytest.ini</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg mq l"/></div></figure><p id="3ab6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">遵循测试搜索模式后，我们重新运行该命令并获得以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ph mq l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在这里，我删除了被零除测试用例。</p></figure><p id="144c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要获得详细的测试输出，请在运行<code class="fe nu nv nw nx b">pytest</code>命令时使用<code class="fe nu nv nw nx b">-v</code>选项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pi mq l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="e8df" class="kw kx iq bd ky kz no lb lc ld np lf lg jw nq jx li jz nr ka lk kc ns kd lm ln bi translated">标记测试</h1><p id="d76b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设您的管道中有各种模块，它们一起工作来完成一个共同的目标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/9d2f71bb41d0c5998413e3abc0cb1392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*BkW38la0ejiDiRCG_PyRYA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有多个模块的代码管道(图片由作者提供)</p></figure><p id="875e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，每个模块也可能有自己的测试套件。</p><p id="7b4f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设您对一个特定的模块(比如说模块1)做了一些修改，您希望在提交修改之前对其进行测试。</p><p id="ae28" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这种情况下，运行整个测试套件将是多余和耗时的，因为您没有对管道的其他模块进行任何更改。</p><p id="37cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，其他模块可能已经在之前的测试运行中彻底测试过。</p><p id="924b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这就是Pytest中的测试标记派上用场的地方。</p><p id="cf99" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">顾名思义，标记允许您将测试组织成不同的类别。</p><p id="6d88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在测试时，您可以使用这些标记通过Pytest运行特定的测试——避免不必要的计算和运行时使用。</p><p id="c9c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从技术上讲，您可以使用<code class="fe nu nv nw nx b">@pytest.mark.{marker-name}</code>装饰器来标记一个测试。</p><h2 id="449d" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">实现标记</h2><p id="813b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在上面的划分示例中，让我们定义四种不同的测试方法，如下从<code class="fe nu nv nw nx b">check_function1()</code>到<code class="fe nu nv nw nx b">check_function4()</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pk mq l"/></div></figure><p id="2914" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要标记测试函数，您应该导入标记，如上所示。</p><p id="b046" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，我们用<code class="fe nu nv nw nx b">mark.non_zero_input</code> decorator标记前三个方法，用<code class="fe nu nv nw nx b">mark.zero_input</code> decorator标记最后一个方法。</p><p id="2214" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您定义一个自定义标记时(就像我们上面所做的)，在配置文件中指定它是一个好的实践(<code class="fe nu nv nw nx b">pytest.ini</code>)。</p><p id="c84e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它有两个主要好处:</p><ol class=""><li id="706a" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj oj mz na nb bi translated">它避免了Pytest可能抛出的任何不必要的警告。</li><li id="24cb" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj oj mz na nb bi translated">如果有人想了解您的管道及其测试套件，在配置文件中声明自定义标记可以帮助他们了解他们的角色，这将有助于他们毫无麻烦地使用您的代码。</li></ol><p id="8e5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以在配置文件中声明自定义标记，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg mq l"/></div></figure><p id="ef69" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">接下来，假设您只想运行那些对应于<code class="fe nu nv nw nx b">non_zero_input</code>标记的测试函数。</p><p id="b183" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以使用命令:<code class="fe nu nv nw nx b">pytest -m {marker-name}</code>来做到这一点。下面演示了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pl mq l"/></div></figure><p id="947c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的测试输出中，我们注意到Pytest忽略了<code class="fe nu nv nw nx b">check_function4()</code>进行测试，只采用了在<code class="fe nu nv nw nx b">non_zero_input</code>标记下定义的前三个方法。</p><h2 id="4917" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">关于Pytest中的标记要知道的事情</h2><p id="9abd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">除了我们上面讨论的关于Pytest标记的概述之外，还有一些关于它们的事情你应该知道。</p><h2 id="9dcf" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">→ #1一个功能可以有多个标记</h2><p id="b14e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在Pytest中，测试函数不一定属于单个标记。相反，您可以将多个标记定义为单个函数的装饰者，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok mq l"/></div></figure><h2 id="0343" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">→ #2您可以为整个班级定义一个标记</h2><p id="bb6a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于编写模块化代码，Python中的类通常是测试代码管道的首选，因为一个类通常有多个方法。</p><p id="8f95" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要为类中定义的函数声明一个标记，可以为整个类指定一个标记，Pytest将其扩展到类中的每个方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pg mq l"/></div></figure><p id="356b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是，如果希望不同的方法属于不同的标记，也可以为类中的每个方法单独声明标记。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pm mq l"/></div></figure><h2 id="7e77" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">→# 3 py test中的一些预定义标记</h2><p id="d9c5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">除了上面讨论的自定义标记，Pytest还提供了一些标记，涵盖了开发人员在测试过程中可能需要的一般功能。</p><ul class=""><li id="8f53" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe nu nv nw nx b"><strong class="lq ir">mark.skip</strong></code>:顾名思义，在一个方法上声明这个标记，是为了在测试过程中有意跳过它。例如，考虑下面的测试:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pn mq l"/></div></figure><p id="f42c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，如果您执行<code class="fe nu nv nw nx b">pytest</code>命令，我们会得到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pl mq l"/></div></figure><p id="d6e0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的输出中，我们注意到一个<strong class="lq ir">跳过了</strong>测试，以及在为方法定义<code class="fe nu nv nw nx b">skip</code>装饰器时指定的原因。</p><ul class=""><li id="0352" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe nu nv nw nx b"><strong class="lq ir">mark.xfail</strong></code>:Pytest提供的另一个有用的固有装饰器是<code class="fe nu nv nw nx b">xfail</code>(简称<em class="pa"> expected-failure </em>)。</li></ul><p id="a169" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设您意识到一个特定的测试函数没有被正确编码。因此，您预期它在某些情况下会失败。</p><p id="16cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用<code class="fe nu nv nw nx b">xfail</code>标记，您可以在您的测试套件中将测试功能标记为预期的失败。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pn mq l"/></div></figure><p id="efb9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，如果您执行<code class="fe nu nv nw nx b">pytest</code>命令，我们会得到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="po mq l"/></div></figure><p id="1a93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的输出中，我们注意到一个<strong class="lq ir"> XFAIL </strong>测试，以及在为该方法定义<code class="fe nu nv nw nx b">xfail</code>装饰器时指定的原因。</p><p id="c160" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以使用以下命令在Pytest中找到预定义标记的完整列表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="bc7c" class="kw kx iq bd ky kz no lb lc ld np lf lg jw nq jx li jz nr ka lk kc ns kd lm ln bi translated">书写固定装置</h1><p id="893e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">编写模块化代码是开发大型项目的关键步骤。良好的开发实践表明:</p><blockquote class="pp"><p id="dd81" class="pq pr iq bd ps pt pu pv pw px py mj dk translated">如果你写同样的代码两次，你就做错了！</p></blockquote><p id="bd60" class="pw-post-body-paragraph lo lp iq lq b lr pz jr lt lu qa ju lw lx qb lz ma mb qc md me mf qd mh mi mj ij bi translated">这同样适用于设计测试套件。</p><p id="9023" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Pytest中的Fixtures类似于项目中的通用函数，可以在管道中的任何地方使用。</p><p id="668e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">唯一的区别是函数应该显式导入，而fixtures则不需要。</p><p id="a0c1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Fixtures不仅减少了您编写的代码量，还使您的测试套件简明易懂。</p><h2 id="8a33" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">创建夹具</h2><p id="2b44" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通常，在Pytest中，您应该在一个独立于测试用例的文件中声明您的fixtures。</p><p id="458d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">出于演示目的，让我们创建一个文件<code class="fe nu nv nw nx b">conftest.py</code>。</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="731b" class="oc kx iq nx b gy od oe l of og">project<br/>├── project.py<br/>├── test_file.py<br/>├── conftest.py<br/>└── pytest.ini</span></pre><p id="b451" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<code class="fe nu nv nw nx b">fixture</code>装饰器的帮助下，夹具被声明如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh mq l"/></div></figure><p id="ddd9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个例子中，我们的目标是针对相同的输入测试加法和减法模块。</p><p id="6088" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一种简单的方法是在两个函数中定义测试输入。</p><p id="eef5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，使用fixtures，您可以将测试输入作为参数传递给测试方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh mq l"/></div></figure><p id="cea9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">测试函数<strong class="lq ir">收到的参数应该与夹具名称<code class="fe nu nv nw nx b">test_inputs</code>相同</strong>。</p><p id="e760" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，如果你注意到，我们从来没有进口设备。</p><blockquote class="ox oy oz"><p id="2462" class="lo lp pa lq b lr mk jr lt lu ml ju lw pb mm lz ma pc mn md me pd mo mh mi mj ij bi translated">永远记住，您在fixtures文件中创建的任何fixture都可以被当前目录和每个子目录中的每个测试函数递归地访问。</p></blockquote><p id="ab4d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，如果我们执行<code class="fe nu nv nw nx b">pytest</code>命令，我们会得到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="qe mq l"/></div></figure><p id="bd9f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">总而言之，在<code class="fe nu nv nw nx b">pytest.fixture</code>装饰器的帮助下，我们在一个单独的文件中定义了一个夹具。</p><p id="027a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当fixture的名称作为任何测试方法中的参数传递时，Pytest获取fixture返回的对象。</p><h2 id="e2dd" class="oc kx iq bd ky om on dn lc oo op dp lg lx oq or li mb os ot lk mf ou ov lm ow bi translated">固定装置的范围</h2><p id="41a6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在上面夹具的定义中，我们在装饰器中传递了<code class="fe nu nv nw nx b">scope</code>参数。</p><p id="b1e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从本质上讲，设备的主要目的是分发信息。</p><p id="62ba" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在fixture声明的上下文中，Scope定义了当被测试函数调用时，fixture应该多长时间返回一次对象的新副本。</p><p id="4e97" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">例如，在上面的例子中，<code class="fe nu nv nw nx b">scope=’function’</code>表示fixture将为每个函数创建一个新的输入列表副本。</p><p id="9ecc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">换句话说，fixtures是在测试第一次请求时创建的，并根据它们的<code class="fe nu nv nw nx b">scope</code>销毁，T1可以取以下五个值之一:</p><ul class=""><li id="d986" class="mt mu iq lq b lr mk lu ml lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe nu nv nw nx b">scope = 'function'</code>:这是fixture的默认范围，每个测试功能创建一个新的副本。</li><li id="4a3a" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated"><code class="fe nu nv nw nx b">scope = 'class’</code>:夹具的单个副本可用于一个类中的所有测试方法。</li><li id="4921" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated"><code class="fe nu nv nw nx b">scope = 'module'</code>:每个模块调用一次夹具。</li><li id="de06" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated"><code class="fe nu nv nw nx b">scope = 'package'</code>:夹具的作用范围在包级别。</li><li id="290f" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated"><code class="fe nu nv nw nx b">scope = 'session'</code>:测试套件的每次运行只创建一次fixture。</li></ul></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="80ff" class="kw kx iq bd ky kz no lb lc ld np lf lg jw nq jx li jz nr ka lk kc ns kd lm ln bi translated">结论</h1><p id="3506" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">至此，我们结束了关于使用Pytest开发测试套件的介绍性博客。恭喜你！</p><p id="948d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望这篇文章让您详细了解了为什么测试是必不可少的，以及如何利用Pytest来测试您的数据科学项目。</p><p id="d309" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有几件事，比如参数化，生成测试报告等。我很快会在另一篇博客中发表:)</p><p id="8009" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">感谢阅读！</strong></p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="9bdb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://subscribepage.io/450q" rel="noopener ugc nofollow" target="_blank"> 🧑‍💻<strong class="lq ir">成为数据科学专家！获取包含450多个熊猫、NumPy和SQL问题的免费数据科学掌握工具包。</strong>T12】</a></p><p id="5626" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">✉️ <a class="ae kv" href="https://medium.com/subscribe/@avi_chawla" rel="noopener"> <strong class="lq ir">注册我的电子邮件列表</strong> </a>不要错过另一篇关于数据科学指南、技巧和提示、机器学习、SQL、Python等的文章。Medium会将我的下一篇文章直接发送到你的收件箱。</p><p id="abf0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我喜欢写基本的数据科学概念、工具、技巧和诀窍。你可以在LinkedIn上和我联系。</p></div></div>    
</body>
</html>