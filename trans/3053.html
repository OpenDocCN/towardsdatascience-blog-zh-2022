<html>
<head>
<title>PyScript v. Flask: How to Create a Python App in the Browser or on a Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyScript v. Flask:如何在浏览器或服务器上创建Python应用程序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/pyscript-v-flask-how-to-create-a-python-app-in-the-browser-or-on-a-server-2cfe4dd0df9d#2022-07-05">https://towardsdatascience.com/pyscript-v-flask-how-to-create-a-python-app-in-the-browser-or-on-a-server-2cfe4dd0df9d#2022-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1e6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">PyScript允许您在不需要服务器的情况下用Python创建web应用程序。Flask是一个Python web应用程序框架，用于制作基于服务器的应用程序。我们使用两者编写相同的简单应用程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14841a8ba5d8f8a1ac24f4d64e0036be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A0sshth4nz8YsG4L"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多梅尼科·洛亚在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyScript是浏览器中的Python，它承诺了一种编写web应用程序的新方法。目前它还处于<em class="lv"> alpha </em>阶段，但已经是一个可用的系统了。</p><p id="f79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们需要新的方法吗？的确，我可以用PyScript创建一个全功能的web应用程序(借助一些HTML，可能还有一点Javascript ),但是我已经可以用Flask做到了！</p><p id="2937" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Flask，Python代码在服务器上运行，并根据需要更新网页。使用PyScript，Python代码在浏览器中运行，并直接与网页交互。</p><p id="3452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，使用PyScript比使用基于服务器的应用程序更好还是更容易呢？我们将比较两个类似的应用程序，一个用PyScript编写，另一个使用基于Python的应用程序框架Flask。</p><p id="b222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中运行代码至少有一个好处，那就是部署。一个基于浏览器的应用程序只需要被复制到一个网络服务器上，它就可以工作了。然而，基于服务器的应用程序可能需要更多的努力才能部署到Heroku、Azure或AWS等平台上。但是一旦你习惯了部署基于服务器的应用，这并不需要太多的努力。</p><p id="5faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里使用的PyScript应用程序在以前的文章中已经介绍过了，所以您可以看看这些文章来更深入地了解PyScript是如何工作的(参见下面的注释)。</p><p id="2df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先查看PyScript应用程序，然后看看我们如何使用Flask构建类似的东西。</p><p id="a7d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序本身相当简单，但它包含了仪表板类型应用程序的所有基础:它允许用户交互，加载远程数据，显示交互式图表，并使用Bootstrap UI框架使一切看起来很好。</p><p id="0761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，该应用程序显示了代表2020年英国伦敦天气状况的四个图表之一。这些图表是最高和最低月气温、降雨量和日照时间，它们使用了我在Github上的英国历史天气报告中的数据。</p><p id="16d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户可以从下拉菜单中选择一个图表，新的图表将会显示出来。这两个版本的应用程序都不会刷新页面:在PyScript应用程序中，对Python代码的调用会读取数据并直接更新图表，而在Flask应用程序中，会对服务器进行异步回调，服务器会使用用于更新图表的数据进行响应。</p><p id="39f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看代码。</p><h1 id="b0fa" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">PyScript应用程序</h1><p id="d315" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">PyScript应用程序是一个HTML网页，其结构如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标签包含了你能在网页上找到的所有常见的东西，还包含了对PyScript CSS和Javascript文件的引用。<code class="fe mv mw mx my b">&lt;body&gt;</code>标签包含页面的HTML和任何所需的Javascript，而<code class="fe mv mw mx my b">&lt;py-script&gt;</code>包含——谁会想到呢——py script代码。</p><p id="8420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PyScript部分可以引用一个外部文件，但是由于CORS限制，在本地运行该文件时它将不起作用，它必须在一个服务器上运行(当然，那个服务器也可以在您的本地机器上运行)。</p><p id="f7d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是对头部的近距离观察:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d8e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先引用运行PyScript所需的PyScript文件，然后引用将在HTML中使用的Boostrap和Plotly CDNs。</p><p id="a3e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mv mw mx my b">&lt;py-env&gt;</code>简单地列出了将在<code class="fe mv mw mx my b">&lt;py-script&gt;</code>部分使用的Python库。</p><p id="864c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看正文的第一部分，HTML和Javascript:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="027a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不需要太多的细节，我们从一个自举超大屏幕元素开始，它充当一个标题。接下来是一个下拉菜单，允许选择要显示的图表。</p><p id="ec42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有一个<code class="fe mv mw mx my b">&lt;div&gt;</code>作为图表的容器，最后是一个简短的Javascript函数，它获取图表数据和容器的id，并使用Plotly库绘制图表。这个函数将直接从Python代码中访问。</p><p id="4d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是整理出来的用户界面。剩下的工作是加载远程数据，过滤它以获得我们想要的特定数据，并创建图表数据。所有这些都是用Python实现的。</p><p id="934f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是包含Python代码的PyScript部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="32ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，与任何Python程序一样，我们导入所有需要的库。</p><p id="bb0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得数据，我们需要使用Pyodide包中的函数<code class="fe mv mw mx my b">open_url</code>(PyScript基于Pyodide，其库集成到了py script中)。然后我们可以从这些数据中创建一个熊猫数据框架。</p><p id="4006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们过滤数据。数据框架目前包含几十年的数据，但我们只打算使用2020年的数据。这就是下面的代码将为我们做的。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="da06" class="nd lx it my b gy ne nf l ng nh">df = df[df['Year']==2020]</span></pre><p id="3023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码的剩余部分主要是函数定义。</p><p id="daf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe mv mw mx my b">plot()</code>创建Plotly图表，并使用Javascript函数在其容器中绘制图表。它接受一个用于选择要显示的图表的参数，用Plotly Python包创建图表数据，最后调用我们前面看到的Javascript函数在其容器中显示图表。</p><p id="cad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意调用Javascript函数是多么容易。我们只需导入<code class="fe mv mw mx my b">js</code>库，所有的Javascript函数都可供我们使用。</p><p id="5180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来的两个函数依赖于它们前面的<code class="fe mv mw mx my b">imports</code>。<code class="fe mv mw mx my b">selectChange()</code>是当下拉菜单中的值改变时将被调用的函数。它从<code class="fe mv mw mx my b">&lt;select&gt;</code>标签中读取新值，并调用我们刚刚看到的Python <code class="fe mv mw mx my b">plot()</code>函数来显示所选图表。</p><p id="aac8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用<code class="fe mv mw mx my b">js </code>包中的<code class="fe mv mw mx my b">document</code>可以让我们以与内置Javascript函数完全相同的方式查询DOM。</p><p id="c65d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要将用户更改选定值所生成的事件与该函数联系起来。这就是<code class="fe mv mw mx my b">setup()</code>的工作。首先，这个函数为Python函数<code class="fe mv mw mx my b">selectChange()</code>创建一个代理，Javascript可以使用这个代理直接调用这个函数。代理叫做<code class="fe mv mw mx my b">change_proxy</code>。</p><p id="615d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们设置一个事件监听器来检测下拉菜单中的变化，并指示它通过我们刚刚设置的代理调用<code class="fe mv mw mx my b">selectChange</code>函数。</p><p id="45d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后两行简单地运行<code class="fe mv mw mx my b">setup()</code>来设置代理和事件监听器，并调用<code class="fe mv mw mx my b">plot("Tmax")</code>来默认显示一个图表。</p><p id="6c1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于那些习惯于传统网页开发或Python编程的人来说，这个应用程序可能感觉不太直观。但是PyScript应用程序的设计非常优雅:用户界面由HTML和CSS定义(在Javascript的帮助下),而应用程序的逻辑几乎完全在PyScript部分定义。</p><p id="c3dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，这是为每项工作使用正确的工具。HTML和CSS都是关于如何显示内容的，而Python是用于编程的，这两者应该并且确实是分开的。</p><h1 id="4445" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">烧瓶应用程序</h1><p id="3abf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这种分离也存在于基于服务器的应用程序中。但是在这种情况下，Python逻辑在服务器上运行。</p><p id="ffac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个基本的Flask应用程序由两个组件组成，基于服务器的Python代码和HTML模板。当应用程序被调用时，它将HTML模板作为网页返回。它还可能用Python代码中的值填充模板中的字段，尽管我们在这里没有使用这种功能。</p><p id="96fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不熟悉Flask应用，我在文章“<a class="ae ky" href="https://alan-jones.medium.com/how-to-create-and-run-a-flask-app-533b7b101c86" rel="noopener">如何创建和运行Flask应用</a>”中写了一个简单的介绍，在<a class="ae ky" href="https://flask.palletsprojects.com/en/2.1.x/quickstart/" rel="noopener ugc nofollow" target="_blank"> Flask网站</a>上有更全面的介绍。</p><p id="eae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，Flask应用程序的Python部分定义了端点和Python函数，这些函数决定了当这些端点被寻址时会发生什么。这个应用程序定义了两个端点，一个对应于根，另一个调用回调函数。</p><p id="f943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根端点简单地返回HTML模板，而回调端点加载所需的数据并返回Plotly图表数据以显示在web页面上。</p><p id="d362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先来看看HTML。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="e542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件在功能上与PyScript应用程序的HTML部分相同。事实上，除了缺少PyScript部分之外，大部分代码都是相同的。</p><p id="09a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，事件监听器和它调用的函数现在是用Javascript编写的，当然，不需要代理。</p><p id="c084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最大的变化是访问Python代码的方式。这是通过调用服务器上的回调函数来完成的。</p><p id="3200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在这里重复这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cf82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数是异步的，这意味着在它被调用后，应用程序的执行不会停止，而是允许该函数在后台继续执行，直到它完成。这是调用服务器函数的理想方法，因为我们不能确定服务器需要多长时间来响应，也不想在等待响应时冻结应用程序。</p><p id="bb8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器上的回调端点称为<code class="fe mv mw mx my b">callback</code>，它期望看到一个称为<code class="fe mv mw mx my b">data</code>的参数，该参数将保存下拉菜单中的选择值。</p><p id="d63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务器将以JSON格式的图表数据进行响应，这将用于绘制图表，就像以前一样，使用Plotly Javascript库。</p><p id="6a4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将Python代码留在了服务器上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="49b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从导入开始，然后我们可以看到两个端点的定义。代码的格式如下:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="6f35" class="nd lx it my b gy ne nf l ng nh">@app.route('/')<br/>def index():<br/>    <em class="lv"># some code that returns a web page or other data</em></span></pre><p id="8df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个端点是根，使用Flask函数<code class="fe mv mw mx my b">render_template()</code>返回我们上面看到的HTML模板。</p><p id="a16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个端点是回调函数。这不返回网页，只返回网页自我更新所需的数据。它调用函数<code class="fe mv mw mx my b">getGraph()</code>，该函数的工作与PyScript版本相同，它加载并过滤数据，然后创建图表数据，该数据返回给异步Javascript函数。</p><p id="5b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你能看到，Flask应用程序和PyScript版本做的完全一样。</p><p id="836b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么你为什么要选择一种方法而不是另一种呢？</p><h1 id="8cf3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="bfab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">两个应用程序都可以工作，而且看起来一样。那么，如何选择使用哪种方法呢？</p><p id="a5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们应该意识到这是一个非常简单的应用程序。更复杂的应用程序可能会下载更多的数据，可能需要更多的处理，或者可能需要更复杂的用户界面。</p><p id="b580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这些例子说明了这种类型的应用程序所需的基本操作。</p><p id="e2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在一台典型的家用笔记本电脑上运行了这两个应用程序，它们都运行得很好。PyScript应用程序的加载时间要长得多，但响应时间可能会稍微快一些。坦率地说，在您等待PyScript版本加载(需要几秒钟)之后，它们之间并没有太大的区别。</p><p id="4198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个变量:</p><ul class=""><li id="f236" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">互联网连接的速度将决定向服务器发出请求的速度以及数据返回的速度</li><li id="6547" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">服务器的力量。大多数服务器比任何台式机或笔记本电脑都更强大</li><li id="f0de" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">用户计算机的能力。当然，一个较弱的硬件会比一个更强的硬件慢，但这将对PyScript应用程序产生更大的影响，因为处理是在本地完成的。</li></ul><h1 id="a5f0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">获胜者是…</h1><p id="0f87" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这两种技术都是有效和有用的。PyScript可能还有很长的发展路要走，毫无疑问还会改进，但是，即使是现在，它也是轻量级应用的一个好的解决方案。</p><p id="354a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有大量的处理工作要做，那么目前基于服务器的解决方案可能仍然是最好的方法，但是随着硬件变得更强大(它总是这样)和PyScript的改进，这种情况可能会改变。</p><p id="99ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">PySript是工具箱中另一个看起来很有前途的工具。我怀疑它会完全取代基于服务器的应用程序，但对于后端处理在典型主机能力范围内的应用程序，PyScript可能会找到自己的位置。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="41cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一如既往，感谢阅读。要下载代码或找到更多关于PyScript、Python、Flask和其他数据科学相关主题的文章，请参见我的<a class="ae ky" href="http://alanjones2.github.io" rel="noopener ugc nofollow" target="_blank"> Github网页</a>。</p><div class="od oe gp gr of og"><a href="https://alanjones2.github.io" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">AlanJones:编码、科学和技术</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用Streamlit、Plotly、Python和Flask为web构建数据可视化应用程序。适用于…的文章、教程和应用程序</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">alanjones2.github.io</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="e3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以订阅我的时事通讯<a class="ae ky" href="http://technofile.substack.com" rel="noopener ugc nofollow" target="_blank"> Technofile </a>来了解我正在做的事情。</p><div class="od oe gp gr of og"><a href="https://technofile.substack.com" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">技术文件</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">技术、科学、数据科学和编码。点击阅读阿兰·琼斯的技术文件，这是一个子堆栈出版物，包含…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">technofile.substack.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><h1 id="4cd9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">笔记</h1><ol class=""><li id="f8e2" class="ni nj it lb b lc mo lf mp li ow lm ox lq oy lu oz no np nq bi translated">文章<a class="ae ky" rel="noopener" target="_blank" href="/create-an-interactive-web-app-with-pyscript-and-pandas-3918ad2dada1">用PyScript和Pandas创建一个交互式web应用</a>包含了使用Pandas绘图的原始Web应用。<a class="ae ky" href="https://medium.com/technofile/how-to-use-ploty-with-pyscript-578d3b287293" rel="noopener">如何结合PyScript使用Plotly</a>展示了如何使用Plotly创建一个类似的应用程序。</li><li id="ef07" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu oz no np nq bi translated">天气数据来自我的报告<a class="ae ky" href="https://github.com/alanjones2/uk-historical-weather" rel="noopener ugc nofollow" target="_blank">英国历史天气</a>，并来自英国气象局<a class="ae ky" href="https://www.metoffice.gov.uk/research/climate/maps-and-data/historic-station-data" rel="noopener ugc nofollow" target="_blank">历史气象站数据</a>。它是根据<a class="ae ky" href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" rel="noopener ugc nofollow" target="_blank">英国开放政府许可证</a>发布的，可以在相同的条件下使用。</li></ol></div></div>    
</body>
</html>