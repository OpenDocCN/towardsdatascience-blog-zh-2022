<html>
<head>
<title>How to Find Any Function’s Optimum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何找到任何函数的最优值</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-find-any-functions-optimum-a8d713bf1d25#2022-04-27">https://towardsdatascience.com/how-to-find-any-functions-optimum-a8d713bf1d25#2022-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="48ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优化指标、模型和功能的聪明方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/46400519ff5f3075fd53589f21705f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RQug8m-RHiUcrD4N.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:最小-最大值，“增长-增加-体积”，Tumisu，<a class="ae ky" href="https://pixabay.com/photos/growth-increase-volume-sales-4822683/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="cc30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接使用优化器，无论是最小化器还是最大化器，是一个很少被讨论的主题。这些工具可以很容易地用来寻找，例如，任何函数的局部或全局最小值。我们将深入研究几个示例，第一个示例估计模式，第二个示例找到驱动最高F1分数的最佳值。请记住，这种方法可以推广，并且在搜索任何函数曲面上的最小值(或最大值)时非常有效。让我们开始吧。</p><h2 id="f026" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">估计模式</h2><p id="1da3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在这个例子中，我们将使用<a class="ae ky" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html" rel="noopener ugc nofollow" target="_blank">核密度估计</a> (KDE)来估计真实模式，这是一种以非参数方式估计随机变量的概率密度函数(PDF)的方法。我们将使用具有高斯内核的KDE(图2 ),并在其负内核输出上使用最小化器。换句话说，我们正在尝试使用极小值来搜索模式的分布。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/dec56cee9bc18915ec21de27850f649f.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*6tcTXBD0ulzm2xwzlKa46w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:[1，2，3，4，5，6，9]的高斯KDE图</p></figure><p id="04aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是用于这个例子的代码，它非常简单，很容易修改，就像我们将看到的其他问题一样。在图3中，我们可以看到一个“向量”,然后由高斯KDE估计，并使用负输出值在最小化函数中搜索模式。极小值从平均值开始，不超过它的界限。这一数值分布的平均值为3.556。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/73656ee3b882d7db23906f9c86e0c29e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lq3MjtfbKc_sNg3GEJEaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:最小化高斯核KDE的代码</p></figure><p id="1170" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，值3.556介于向量的第三和第四个成员之间，这是高斯KDE的最高输出(图4)，也就是说，在使用最小值时，代码中的负值最低。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/3cbd7cc2c74593142713f9636636e7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHQQ10RzemQjyFsglTXIrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:每个向量项的核值。</p></figure><h2 id="f5d0" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">为F1分数优化</h2><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">再举个例子，有点类似。在这个例子中，我们试图找到逻辑回归边界的最佳阈值，使用强力优化器和F1分数函数，它试图找到全局最小值。</p><p id="2772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们有一个真实概率向量和预测概率向量的例子。我们有一个包装器函数，它使用阈值计算可能的y_pred向量，这是蛮力搜索通过的。这是在brute()函数内部完成的。我们针对所有可能的预测向量计算真实值的F1，并且蛮力函数bookeeps最好的最小结果恰好是阈值0.7。我们期望优化器找到阈值0.7，这将产生与y_true相同的y_pred向量(基于y_pred_proba)，如图5所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/44a54bf39e679817b258ff0733f2dd28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y_YQE9zMnhXjVGWhfDMaeg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:理论LogReg模型输出的F1强力优化器。</p></figure><h2 id="eb1a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">摘要</h2><p id="4bdd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我希望这篇短文能说服您使用这个不常见但非常有用的工具来优化任何函数，无论是度量、模型、算法还是其他。我要感谢Natanel Davidovits在很多年前向我介绍了这个想法并提供了上面的代码。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="4e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ori Cohen博士拥有计算机科学博士学位，主要研究机器学习。他是<a class="ae ky" href="https://book.mlcompendium.com/" rel="noopener ugc nofollow" target="_blank"> ML &amp; DL纲要</a>和<a class="ae ky" href="http://www.stateofmlops.com" rel="noopener ugc nofollow" target="_blank">StateOfMLOps.com</a>的作者，并且对AIOps &amp; MLOps领域很感兴趣。现在，他是Justt.ai数据科学的高级数据总监。</p></div></div>    
</body>
</html>