<html>
<head>
<title>Time series forecasting with dynamical systems methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用动力系统方法进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-with-dynamical-systems-methods-fa4afdf16fd0#2022-02-01">https://towardsdatascience.com/time-series-forecasting-with-dynamical-systems-methods-fa4afdf16fd0#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bc87" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用动态系统通过标准的经典机器学习算法来预测时间序列数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5af26251814879888a255e31d2fce13a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sIBZsLlL5RjseRSF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@yiorgosntrahas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约尔戈斯·恩特拉哈斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间序列预测是数据科学家在日常工作中面临的另一种任务。正因为如此，将这种工具添加到我们的工具箱中非常重要。这将是今天帖子的重点。</p><p id="d699" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多方法可以解决这个问题，在这篇文章中，我将重点讨论一些我们可以用来将标准学习算法(如SVM或梯度推进)应用于时间序列数据的动力系统方法。进行这种预测的其他可能性有:</p><ul class=""><li id="c368" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">预测的统计方法，如ARIMA</li><li id="aa55" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">深度学习方法论，如LSTM和RNN</li></ul><p id="e882" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们理解为什么获取我们的时间序列数据并将其直接应用于回归变量不是一个好主意。</p><p id="5d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" href="https://github.com/TNanukem/paper_implementations/blob/main/Takens%20Embedding%20Theorem.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae kv" href="https://www.kaggle.com/tiagotoledojr/taken-s-embedding-theorem" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>中可以找到用于生成这篇文章(以及更多)结果的代码。</p><h2 id="45bb" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">为什么默认算法通常不尽如人意</h2><p id="12a0" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">统计学习理论是从数学上证明我们的机器学习模型实际上具有学习能力的基础。为了让这些保证成立，必须对我们试图建模的数据进行一些假设[1]，其中之一是:</p><ul class=""><li id="7111" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">样品必须以i.i.d .的方式取样</li></ul><p id="65ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们处理一个时间序列时，我们的数据集的例子是相互独立的(如果是，那么你的序列可能是一个随机序列)。</p><p id="d7d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，动力系统理论有一些方法可以用来打破我们数据点之间的时间依赖性，这样我们就可以使用标准的机器学习算法来进行预测。我们现在来谈谈多恩嵌入定理。</p><h2 id="e890" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">多恩嵌入定理</h2><p id="08ee" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这个定理是由Takens [2]在80年代提出的，它讨论了如何将我们的时间序列嵌入(从一个空间到另一个空间)其时间滞后的空间，我们称之为相位空间，消除序列实例之间的时间依赖性。</p><p id="4afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">级数越确定，我们就会越清楚地看到相空间上形成的吸引子。吸引子可以被看作是时间序列在相空间上产生的“画”。例如，如果我们有一个随时间变化的周期函数，这个周期依赖将被视为相空间上的一个椭圆。请看下面的例子，当我们嵌入正弦函数时会发生什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/b40ae089f50823c871de52ab786747bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*nwi6dU1-_RuwLyJa4Dze1g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正弦函数相空间表示。由作者开发。</p></figure><p id="2cb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，并不是所有的时间序列都是确定的，因此相空间中的吸引子不会被很好地定义。</p><p id="8553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在我们知道我们可以把我们的级数嵌入到相空间中，以消除时间依赖性，但是怎么做呢？为此，我们必须定义两个参数:</p><ul class=""><li id="997d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">m -&gt;称为嵌入维数，这个参数将告诉我们相空间的维数</li><li id="b95f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">d -&gt;称为时间延迟，这将告诉我们相空间的每个轴将代表多少时间滞后</li></ul><p id="ca50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">听起来有点抽象，对吧？让我们以方程式的形式来看，让事情变得清楚明白。</p><p id="0a4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设f(t)为我们的时间序列。给定<em class="nf"> m </em>和<em class="nf"> d </em>，我们的相空间嵌入将是如下矩阵:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f39aafc6b64a787a1c4ff0329c33e043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*gLSfAY43eOYZAATisoUOlA.png"/></div></figure><p id="a853" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们空间的每一个<em class="nf"> m </em>轴都将被表示为我们定义的时滞的倍数。</p><h2 id="edb9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">实现镜头的嵌入</h2><p id="021c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">让我们实现一些代码来将时间序列转换到我们的相空间。首先，让我们导入所需的库:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="6ce7" class="mg mh iq ni b gy nm nn l no np">import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="a493" class="mg mh iq ni b gy nq nn l no np">from nolitsa import dimension, delay</span><span id="7668" class="mg mh iq ni b gy nq nn l no np">import plotly.express as px<br/>import plotly.graph_objects as go</span><span id="6cad" class="mg mh iq ni b gy nq nn l no np">from sktime.datasets import load_airline, load_shampoo_sales, load_lynx</span><span id="df85" class="mg mh iq ni b gy nq nn l no np">from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import r2_score, mean_squared_error<br/>from sklearn.model_selection import train_test_split</span><span id="407b" class="mg mh iq ni b gy nq nn l no np">from gtda.time_series import SingleTakensEmbedding, takens_embedding_optimal_parameters<br/>from openml.datasets.functions import get_dataset</span></pre><p id="90b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于Taken的实现，我们只能使用numpy:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="5d41" class="mg mh iq ni b gy nm nn l no np">def takens(data, m=2, d=1):<br/>    emb = np.array([data[0:len(data) - d*m]])<br/>    for i in range(1, m):<br/>        emb = np.append(emb, [data[i*d:len(data) - d*(m - i)]], axis=0)<br/>        <br/>    return emb.T</span></pre><p id="29a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从乔托-TDA包中得到一个洛伦兹函数:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="5ae7" class="mg mh iq ni b gy nm nn l no np">lorenz = get_dataset(42182).get_data(dataset_format='array')[0][0:, 0]<br/>t = [i for i in range(len(lorenz))]</span><span id="2195" class="mg mh iq ni b gy nq nn l no np">emb = takens(lorenz, m=3, d=5)</span><span id="eff6" class="mg mh iq ni b gy nq nn l no np">fig = go.Figure()<br/>fig.add_trace(go.Scatter3d(<br/>    x=emb[:, 0], y=emb[:,1], z=emb[:, 2], mode='lines'<br/>))<br/>fig.show()</span></pre><p id="5551" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码生成了以下图形:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/04860cdb790607a068c829c436832067.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*cXwWEH7sRkw4R-J_0bkBUg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">洛伦兹函数相空间表示。由作者开发。</p></figure><p id="d24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所看到的，我们有一个定义非常明确的吸引子，许多人称之为蝴蝶吸引子。</p><p id="a1f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，你可能会奇怪，我怎么知道我应该为<em class="nf"> m </em>和<em class="nf"> d </em>使用哪些参数？洛伦兹函数已经被很好的研究过了，这些值是很多年前发现的。</p><p id="a1f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果你有一个新的时间序列，你如何找到这些值？我们有一些试探法，可以用来尝试找到好的候选人。</p><h2 id="07ce" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">查找<em class="ns"> m </em>和<em class="ns"> d </em></h2><p id="7884" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">为了找到这些参数，我们将使用python的NoLiTSA包中的一些实现。这个软件包实现了几个非线性时间序列分析的函数和算法。如果您尚未安装此软件包，您可以使用以下软件进行安装:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="dca5" class="mg mh iq ni b gy nm nn l no np">pip install git+https://github.com/manu-mannattil/nolitsa.git</span></pre><p id="105c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须首先找到我们的时间延迟。为此，通常使用互信息图。该图表示时间序列中两个实例的相关程度。换句话说，它可以被看作是通过观察其他实例而获得的关于一个实例的信息量。</p><p id="3997" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码片段将生成正弦的互信息并绘制出来:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="a10b" class="mg mh iq ni b gy nm nn l no np">t = [i for i in np.arange(0, 20, 0.1)]<br/>y = [np.sin(i) for i in t]</span><span id="ad23" class="mg mh iq ni b gy nq nn l no np">plt.figure(figsize=(9,4))<br/>plt.xlabel('Time delay (d)')<br/>plt.ylabel('Mutual Information')<br/>plt.plot(delay.dmi(y, maxtau=20))</span></pre><p id="3efb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给了我们情节:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/acb33e5b5ebfe8b25f174a7566945f96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*kdrNhToiGZRh9B49ZvTBjA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正弦函数的互信息。由作者开发</p></figure><p id="535e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">启发式方法是选择互信息的第一个局部最小值作为时间延迟。我们可以通过使用以下代码来实现这一点:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="2db1" class="mg mh iq ni b gy nm nn l no np">def find_optimal_delay(x, maxtau=50):<br/>    mi = delay.dmi(x, maxtau=maxtau)<br/>    diffmi = np.diff(mi)</span><span id="4df3" class="mg mh iq ni b gy nq nn l no np">return np.where(diffmi &gt; 0)[0][0]</span></pre><p id="67b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经定义了时间延迟，我们可以继续研究给定时间延迟的嵌入维数。为此，我们将使用伪最近邻。</p><p id="6b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个度量告诉我们，给定一个维度，我们的点的邻居中有多少是“假邻居”。伪邻居是在给定维度上的给定点附近的点，但是当我们将空间展开到另一个维度后，它就不再存在了。</p><p id="84ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用以下公式绘制假最近邻的比例:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="41d7" class="mg mh iq ni b gy nm nn l no np">dim = np.arange(1, 10)<br/>f1, f2, f3 = dimension.fnn(y, tau=4, dim=dim)</span><span id="b30d" class="mg mh iq ni b gy nq nn l no np">plt.figure(figsize=(9,4))<br/>plt.xlabel('Dimension (m)')<br/>plt.ylabel('False Nearest Neighbors')<br/>plt.plot(f1)</span></pre><p id="f60d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">情节是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/4b21fdde14bd43b46842338c2e8cfe38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*LArZGoLeFFq-Zbi9AI2Wwg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正弦函数的假最近邻比例</p></figure><p id="fd13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，启发是，任何FNN结果小于20%的维度都是好的候选。所以我们可以创建函数来找到它:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="82c3" class="mg mh iq ni b gy nm nn l no np">def find_optional_dimension(x, tau, max_dim=10):<br/>    dim = np.arange(1, max_dim)<br/>    f1, f2, f3 = dimension.fnn(x, tau=tau, dim=dim)</span><span id="e2f3" class="mg mh iq ni b gy nq nn l no np">return np.where(f1 &lt; 0.2)[0][0] + 1</span></pre><p id="8080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这些都是经验试探法，因此不能保证找到最佳值。此外，如果使用乔托-TDA包(已经实现了Taken)中的自动搜索，也不能保证值会匹配。</p><p id="72a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们看看如何使用所有这些来预测我们的时间序列。</p><h2 id="7621" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">用嵌入法预测时间序列</h2><p id="10f1" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">好的，这里的想法是，在嵌入完成后，我们有一个X矩阵，把时间序列的延迟放入一个新的空间。我们可以使用这个矩阵上的前m-1个条目作为我们的回归函数的特征来预测最后一列。</p><p id="1c60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这在代码中是怎样的，我们将使用一个维持集:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="a553" class="mg mh iq ni b gy nm nn l no np">def forecast_on_phase_space(y, m, d, forecast_horizon):<br/>    emb = takens(y, m, d)<br/>    <br/>    # Divide into train and test<br/>    X = emb[:, :m-1]<br/>    y = emb[:, m-1]<br/>    <br/>    X_train = X[:len(X)-forecast_horizon, :]<br/>    y_train = y[:len(y)-forecast_horizon]<br/>    X_test = X[len(X)-forecast_horizon:, :]<br/>    y_test = y[len(y)-forecast_horizon:]<br/>    <br/>    # Fit the regressor on the training data<br/>    rf = RandomForestRegressor()<br/>    rf.fit(X_train, y_train)<br/>    <br/>    # Predict the test data<br/>    preds = rf.predict(X_test)<br/>    <br/>    print(f'R²: {r2_score(y_test, preds)}')<br/>    print(f'RMSE: {mean_squared_error(y_test, preds, squared=False)}')<br/>    <br/>    # Plot the result<br/>    preds_ = [np.nan for i in range(len(y)-forecast_horizon)] + list(preds)<br/>    t = [i for i in range(len(y))]</span><span id="4dbf" class="mg mh iq ni b gy nq nn l no np">    fig = go.Figure()<br/>    fig.add_trace(go.Scatter(<br/>        x=t, y=y, mode='lines'<br/>    ))<br/>    fig.add_trace(go.Scatter(<br/>        x=t, y=preds_, mode='lines', line=dict(color='red')))<br/>    fig.show()</span></pre><p id="6e4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码将生成以下预测:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/955a6f7cc224c50f261417029fc0c906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cRlkjSOqx2fX_kQsu678WA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">洛伦兹函数预测。由作者生成。</p></figure><p id="7fbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来不错，对吧？让我们看看，如果我们使用一个不那么确定的真实数据集，会发生什么。为此，让我们安装sktime库，并使用库中免费提供的航空公司数据:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="ae79" class="mg mh iq ni b gy nm nn l no np">!pip install sktime</span><span id="0a87" class="mg mh iq ni b gy nq nn l no np">airline = load_airline()<br/>forecast_on_phase_space(airline, 3, 1, 50)</span></pre><p id="cb08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这会产生:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/3cc3f861dc1902a475f97faf15408099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-fqj3OC-E9a1Xs0_S9v9Bg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">航线数据集预测。由作者生成</p></figure><p id="bfef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不太好吧？嗯，我们没有对这个系列做任何类型的预处理，我们可以做很多事情来进一步改进它，但是，这将在随后的情节中探索。</p><p id="32ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有人可能会问:好吧，但是如果我想从一个未知的序列中预测几个新的值，而没有延迟呢？在您的示例中，您使用了一个保持，但是在真实的场景中，我现在将有X来支持回归变量。预测()。</p><p id="204c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是正确的。在真实的场景中，您需要使用您拥有的数据来预测下一个点，然后反馈它以生成新的延迟来预测下一个点。请注意，您将在每个后续预测中传播错误。这是处理时间序列的一个很大的缺点。</p><h2 id="ece9" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">结论</h2><p id="63b4" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这篇文章旨在介绍图森的嵌入定理，它可以作为一种工具来帮助时间序列预测任务。像其他方法一样，它也有一些缺点，可以改进。</p><p id="0dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望写更多关于我们如何对未来做出更好预测的帖子。现在，我希望这对你有用。</p><p id="84f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里使用的每一个数据集都来自公共领域，可以在post上使用的开源包中免费获得。</p><h2 id="263e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">感谢</h2><p id="1fea" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我必须在这里感谢圣保罗大学的前教授Rodrigo Mello，他在2019年的一次大学课堂上首次向我介绍了这些概念。</p><p id="3f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[1] Pagliosa，Lucas &amp; Mello，Rodrigo .(2016).对依赖于时间的数据应用核函数以提供监督学习保证。专家系统及其应用。71.10.1016/j.eswa</p><p id="6261" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2] Takens F. (1981)在紊流中检测奇怪的吸引子。在:兰德d，年轻的LS。动力系统和紊流，沃里克，1980年。数学讲义，第898卷。斯普林格，柏林，海德堡。<a class="ae kv" href="https://doi.org/10.1007/BFb0091924" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1007/BFb0091924</a></p><p id="ed78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3] Box，G. E. P .，Jenkins，G. M .和Reinsel，G. C. (1976年)时间序列分析、预测和控制。第三版。霍尔登日。g系列。</p></div></div>    
</body>
</html>