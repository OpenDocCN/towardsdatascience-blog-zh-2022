<html>
<head>
<title>BigQuery SQL Optimization 1: Filter as Early as Possible</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">BigQuery SQL优化1:尽早过滤</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bigquery-sql-optimization-1-filter-as-early-as-possible-60dfd65593ff#2022-09-07">https://towardsdatascience.com/bigquery-sql-optimization-1-filter-as-early-as-possible-60dfd65593ff#2022-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f866" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，我会看到一些查询在早期准备了一个列，但却在后期使用该列进行筛选。或者用<em class="ko">过滤掉本来可以用<em class="ko">过滤掉的有</em>的东西。这降低了查询速度，增加了处理成本。让我们看看对此我们能做些什么！</em></p><p id="4210" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是一个示例场景，其中创建了相同的输出，但有一次查询通过之前的过滤进行了优化:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/01a93f174a38749bb610297e1f6673f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0YJaiBfNNaWDRNPGlacccA.png"/></div></div><p class="lb lc gj gh gi ld le bd b be z dk translated">从公用表表达式(CTE)到最终输出查询(作者图片)的数据处理量</p></figure><p id="d4e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们处理的数据越少，查询速度就越快。所以我们越早过滤掉数据越好。如果同样的事情可以在几秒钟内完成，没有人愿意等几分钟。但是有时会很难，尤其是在处理<em class="ko">嵌套数据时——稍后会有更多介绍……</em></p><h1 id="aed3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">尽早过滤</h1><p id="fb13" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">查询<code class="fe mi mj mk ml b">SELECT movie, sum(tickets_sold) FROM movie_sales GROUP BY movie</code>在以下阶段执行:</p><p id="50b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">阶段1 </em> : <strong class="js iu">取出所有条目</strong> <code class="fe mi mj mk ml b">FROM</code>表<code class="fe mi mj mk ml b">movie_sales</code></p><p id="6d0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">阶段2 </em> : <strong class="js iu">根据您在<code class="fe mi mj mk ml b">movie</code>列中找到的所有值对条目</strong>进行分组，并通过求和<code class="fe mi mj mk ml b">tickets_sold</code>在组内进行聚合</p><p id="1afa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">阶段3 </em> : <strong class="js iu">输出</strong>在<code class="fe mi mj mk ml b">SELECT</code>中定义的结果(这可能是反直觉的，因为<code class="fe mi mj mk ml b">SELECT</code>在查询中先<em class="ko">后</em>执行，但最后<em class="ko">执行，因为它“仅”定义了输出。在其他语言中，它会被称为<code class="fe mi mj mk ml b">print()</code>或<code class="fe mi mj mk ml b">echo</code></em></p><p id="8dfa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们只对某些电影的销量感兴趣，可以选择两种不同的过滤方式:<code class="fe mi mj mk ml b">WHERE movie='xyz'</code>或者<code class="fe mi mj mk ml b">HAVING movie='xyz'</code>。但是想象一下<em class="ko">在每个场景中，查询引擎要将</em>从一个阶段拖到另一个阶段需要多少数据:</p><ul class=""><li id="2c47" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">使用<code class="fe mi mj mk ml b">HAVING</code>,它将整个表拖到阶段2，并且只在聚合后过滤</li><li id="b19c" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">使用<code class="fe mi mj mk ml b">WHERE</code>,在获取数据时，它会扔掉所有不需要的东西，这样它只会将很少的数据传递到下一阶段</li></ul><p id="d2cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在查询级别，我们有3种过滤方式:</p><ol class=""><li id="a32c" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn na ms mt mu bi translated"><code class="fe mi mj mk ml b">WHERE</code>与<code class="fe mi mj mk ml b">FROM</code>一起工作</li><li id="494f" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated"><code class="fe mi mj mk ml b">HAVING</code>与<code class="fe mi mj mk ml b">GROUP BY</code>一起工作</li><li id="5ac5" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn na ms mt mu bi translated"><code class="fe mi mj mk ml b">QUALIFY</code>与<code class="fe mi mj mk ml b">OVER</code>一起工作(窗口功能)</li></ol><p id="2bf0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以向<code class="fe mi mj mk ml b">WHERE</code>或者甚至更早的查询/cte移动的过滤器越多越好。或者换句话说:你应该在信息可用的最早时间点进行过滤。例如，如果过滤器需要<em class="ko">聚合</em>，那么我们不能将其移动到<code class="fe mi mj mk ml b">WHERE</code>，因为只有<code class="fe mi mj mk ml b">GROUP BY</code>聚合—不要过滤<em class="ko">聚合</em>在后面的<code class="fe mi mj mk ml b">WHERE</code>，使用前面的<code class="fe mi mj mk ml b">HAVING</code>。</p><p id="fd88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:<code class="fe mi mj mk ml b">SELECT movie, sum(tickets_sold) FROM movie_sales GROUP BY movie HAVING avg(rating)&gt;2.5</code>在这里，我们可以使用<code class="fe mi mj mk ml b">WITH</code>将查询放到一个公共表表达式中，并在后面的查询中进行过滤:</p><pre class="kq kr ks kt gt nb ml nc nd aw ne bi"><span id="7bd5" class="nf lg it ml b gy ng nh l ni nj">WITH prep as (<br/>  SELECT movie, sum(tickets_sold), avg(rating) as avg_rating<br/>  FROM movie_sales <br/>  GROUP BY movie <br/>)</span><span id="7296" class="nf lg it ml b gy nk nh l ni nj">SELECT upper(movie) as movie, tickets_sold<br/>FROM prep<br/>WHERE avg_rating &gt; 2.5</span></pre><p id="fd12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时将过滤器移至<code class="fe mi mj mk ml b">WHERE</code>可能会更复杂，但这通常是值得的，因为它显著提高了性能——尤其是当它在高峰时间运行时(即周一早上，当周/月报告的所有数据都被处理时)。</p><p id="5fb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些更具挑战性的案例…</p><h1 id="4c9c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用数组上的子查询进行过滤</h1><p id="4b3d" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当处理嵌套数据时，将过滤器延迟到后面阶段的模式非常诱人，因为当我们不习惯所有这些子查询时，我们只想给子查询一个别名并使用那个名称。有时查询引擎可以弥补，但并不总是那么理想。</p><p id="7f2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一开始，使用数组可能会令人困惑…我已经介绍了<a class="ae nl" rel="noopener" target="_blank" href="/https-medium-com-martin-weitzmann-bigquery-sql-on-nested-data-cf9589c105f4"> <strong class="js iu"> BigQuery:嵌套数据上的SQL</strong></a>，并在<a class="ae nl" rel="noopener" target="_blank" href="/bigquery-creating-nested-data-with-sql-727b761f1755"> <strong class="js iu"> BigQuery:使用SQL </strong> </a>创建嵌套数据中解释了更多的数据准备概念。对于这一部分，你应该有点熟悉那里解释的想法。</p><p id="f43d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是在这里同样适用——如果我们可以将过滤器上移一两个阶段，那么我们将节省处理时间，因为查询引擎不需要将如此多的数据从一个阶段拖到另一个阶段。</p><p id="de52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些简单的数组数据示例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi no"><img src="../Images/241ae045ffa62f6b9dcea3fb4ddee9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/0*nuJCFfuVa6s-TYDb.png"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">两行嵌套结果</p></figure><p id="92da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以对<em class="ko">成分</em>数组进行一些聚合:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">子查询中包含数组聚合的未筛选查询</p></figure><p id="53f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们只想吃不含泡菜的饭菜呢？我们可以将<code class="fe mi mj mk ml b">SELECT ... FROM t1</code>包装到另一个<code class="fe mi mj mk ml b">WITH t2 AS</code>语句中，并检查字符串<code class="fe mi mj mk ml b">listIngr</code>是否包含子字符串<code class="fe mi mj mk ml b">"pickles"</code>。但之后我们会把所有泡菜餐拖到这个额外的阶段<code class="fe mi mj mk ml b">t2</code>。相反，我们应该将<code class="fe mi mj mk ml b">WHERE</code>与子查询结合使用！</p><p id="4e93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用子查询过滤的一个好方法是使用<strong class="js iu"><em class="ko">exist</em></strong><em class="ko">s(&lt;子查询&gt; ) </em>和<strong class="js iu">在子查询中设置条件</strong>。</p><ul class=""><li id="bb4e" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated">因此，如果我们不想在一顿饭中有任何泡菜，子查询不应该返回任何东西！</li><li id="02e9" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated">如果我们想确保饭菜中有西红柿，那么<em class="ko">子查询应该返回一些东西</em></li></ul><pre class="kq kr ks kt gt nb ml nc nd aw ne bi"><span id="7a4f" class="nf lg it ml b gy ng nh l ni nj">SELECT<br/>  ...<br/>FROM t1<br/>WHERE<br/>  NOT EXISTS(select 1 from unnest(ingredient) as i where i="pickles")</span></pre><p id="f08d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们为每个<code class="fe mi mj mk ml b">where i="pickles"</code>返回1，并且<em class="ko"> exists() </em>检查子查询是否返回了任何内容。如果是，<em class="ko"> exists() </em>将返回<em class="ko"> true </em>和<em class="ko"> NOT </em>将其转换为<em class="ko"> false </em>并发送给<em class="ko">，在那里</em>过滤出泡菜。</p><p id="f764" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们希望两个条件都为真(没有泡菜，但是有西红柿),我们将使用两个子查询，每个子查询创建自己的过滤器布尔:</p><pre class="kq kr ks kt gt nb ml nc nd aw ne bi"><span id="96cf" class="nf lg it ml b gy ng nh l ni nj">SELECT<br/>  ...<br/>FROM t1<br/>WHERE<br/>  -- only meals without pickles!<br/>  NOT EXISTS(select 1 from unnest(ingredient) as i where i="pickles")<br/>  AND<br/>  -- only meals with tomatoes!<br/>  EXISTS(select 1 from unnest(ingredient) as i where i="tomatoes")</span></pre><p id="787a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">添加可读的注释，与类似<code class="fe mi mj mk ml b">AND</code>的布尔操作符一起使用，有助于理解查询。我们将在下一节看到一个更实际的例子。</p><h1 id="73c8" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">证明优化是可行的</h1><p id="e306" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如前所述，策略相当简单:多次运行优化和非优化的查询，并查看消耗的槽时间。插槽的性能并不一致——因此，运行查询3到5次，记录其性能并取平均值，会给你一个思路。</p><p id="b87a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有一些东西可以帮助我们:</p><ul class=""><li id="546f" class="mm mn it js b jt ju jx jy kb mo kf mp kj mq kn mr ms mt mu bi translated"><a class="ae nl" href="https://cloud.google.com/bigquery/docs/cached-results#disabling_retrieval_of_cached_results" rel="noopener ugc nofollow" target="_blank">禁用缓存</a>以始终获得完整的性能结果</li><li id="b1af" class="mm mn it js b jt mv jx mw kb mx kf my kj mz kn mr ms mt mu bi translated"><a class="ae nl" href="https://cloud.google.com/bigquery/docs/table-sampling" rel="noopener ugc nofollow" target="_blank">表样</a>不过度扩展可用插槽，降低成本。与<code class="fe mi mj mk ml b">LIMIT</code>相比，它实际上减少了处理，但不适合<em class="ko">随机</em>采样，如<code class="fe mi mj mk ml b">WHERE rand()&lt;0.1</code></li></ul><h1 id="4639" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">GA4示例</h1><p id="975c" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">这个例子采用了基本的Google Analytics 4数据——产品分析的一个常见用例:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3cf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们优化了没有嵌套的数据——但是如果我们想过滤某些页面标题呢？让我们来看看:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div><p class="lb lc gj gh gi ld le bd b be z dk translated">WHERE子句中的子查询看起来并不漂亮，但通常是有效的</p></figure><p id="747b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们可以开始采样了——比较v3和v4。禁用缓存并在大表上添加<code class="fe mi mj mk ml b">TABLESAMPLE SYSTEM (10 PERCENT)</code>或从您的<em class="ko"> _TABLE_SUFFIX </em>中删除日期。记录并比较平均槽时间(不是总运行时间)。</p><p id="270e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个简单的例子中，差异实际上是可以忽略的，因为查询引擎可以优化我们的低效率，因为我们不改变值。但是查询通常没有这个简单。相反，它们会更改值，涉及其他表、聚合、窗口函数、多个cte等，达到查询引擎无法补偿的程度。即使您的用例现在如此简单，它也可能在以后演变成更复杂的东西。</p><p id="2b3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，通过将过滤器提升到早期阶段来调整您的查询将使您在周一的第一份报告更新竞赛中获得优势。通过尽早过滤数据来减轻查询引擎的负担。</p><p id="520f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重构快乐！</p></div></div>    
</body>
</html>