<html>
<head>
<title>Building a Khmer Spelling Checker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建高棉语拼写检查器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-a-khmer-spelling-checker-7e3356677335#2022-05-26">https://towardsdatascience.com/building-a-khmer-spelling-checker-7e3356677335#2022-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="987c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解BK树和编辑距离(又名Levenshtein距离)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14171320af313e825f5ca236725f098d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4J-GRS3RPx7OO4aFFAya8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><h1 id="ddb2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">一.动机</h1><p id="6bb8" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">最近，我有机会开发一个高棉键盘应用程序。像任何其他键盘应用程序一样，拼写检查和拼写建议是用户体验的核心功能。在尝试实现这些特性时，我遇到了一种流行的方法，它依赖于两个概念来进行拼写检查:编辑距离(又名Levenshtein距离)和BK树。因此，这篇文章将讨论这些概念及其缺点，并分享一个依赖于它们的高棉语拼写检查器的Python实现。</p><h1 id="278d" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">二。编辑距离(又名莱文斯坦距离)</h1><p id="8044" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">编辑距离是将一个字符串转换成另一个字符串所需的最小步骤/操作数。有多种技术可以计算编辑距离。然而，最流行的是由苏联数学家弗拉基米尔·莱文斯坦提出的莱文斯坦距离。他的方法允许在编辑距离中考虑三种类型的字符串操作:插入、删除和替换/替换。在拼写检查的上下文中，编辑距离允许我们测量两个单词的<strong class="ls iu"/>差异。</p><h2 id="3374" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">算法</h2><p id="d1c2" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以通过动态规划有效地计算编辑距离。它使用由2D阵列表示的矩阵来存储子串之间的临时距离，以节省计算成本。让我们看看如何计算“កាល”和“ក្បាល".”之间的编辑距离</p><p id="1fdb" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤1: </strong>初始化一个大小为(len(word1) + 1，len(word2) +1)的空2D数组</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/637f165609fb9abe569b9aa393f03c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shbrCBcdVB9lyg66ZOifEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:步骤1-初始化2D阵列。图片作者。</p></figure><p id="a8b9" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第二步:</strong>用列索引填充第一行的单元格。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/43b825b7debb044fc73575ec365a26e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*of_D0QrQNfEDhTQG2vhtEg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:步骤2-填写第一行。图片作者。</p></figure><p id="6234" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">第三步:在第一列的单元格中填入它们的行索引。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/8d15b259ab81118c637f2ef87aba2ea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Purj_WpYVeMKum5ON4SGfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:步骤3-填写第一列。图片作者。</p></figure><p id="6efa" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤4: </strong>在位置(1，1)，我们查看该位置的两个单词的字符:单词1 (ក)和单词2 (ក).因为它们是相同的，所以我们将当前单元格的值设置为其左上邻居的值。因此，cell (1，1)的值变为0。然后，我们移动到第1行的下一列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/37647593cb6d5de1a92c3df357fcddbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lP06R8HCQMtmvg2pgEJudw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:步骤4——当word1和word2的字符相同时。图片作者。</p></figure><p id="fe65" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤5: </strong>在位置(1，2)，我们再次比较该位置的两个单词的特征:单词1 (ក)和单词2 (្).这一次两个人物是不同的。因此，当前单元格的值是min([left，top，top-left]) + 1。然后，我们对剩余的单元格重复步骤4和5。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/869c4db3b99fdd3c168092ee79388d2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yc9luzUFfHXudIvB8km2gQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:步骤5——当word1和word2的字符不同时。图片作者。</p></figure><p id="03a6" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第六步:</strong>我们填充完所有单元格后，最小编辑距离就是2D矩阵的右下角单元格。因此，单词“កាល”和“ក្បាល”之间的最小编辑距离是2。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/27c934d31289c9b98bd9464a57d31f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuLRSeiILyu0slEKTNKeyg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:步骤6-产生的2D矩阵和最小编辑距离。图片作者。</p></figure><p id="6e5b" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">此外，为了知道哪种编辑操作组合导致最小的编辑距离，我们需要从左上角到右下角的单元格执行最短路径搜索。当然，可以有多种组合，因为可以有多条最短路径通向右下角的单元。</p><h1 id="9fc4" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">三。BK树</h1><p id="e8df" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">构建拼写检查器的一个简单方法是找到用户提供的单词与字典中所有其他单词之间的编辑距离，并将编辑距离最小的单词返回给该单词。然而，如果字典很大，这种方法需要时间和计算。BK树允许我们通过使用利用编辑距离的树数据结构来限制所需的比较次数，从而更快地执行搜索。树中的每个节点都是一个单词。连接不同节点的每条边是该节点与其父节点之间的编辑距离。为了更好地理解BK树，我们可以看一个例子，看看如何为一个4个单词的字典构建树:{"ស្គម、ស្អាត、កាល、ក្បាល"}.然后，我们将进一步研究如何在树中搜索匹配的节点。</p><h2 id="9ea8" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated"><strong class="ak"> BK树构造算法</strong></h2><p id="0a0f" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated"><strong class="ls iu">第一步:</strong>添加第一个单词“ស្គម”作为树的根节点。然后继续下一个词，“ស្អាត".</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/c502724fc13fc8b2d7d8401ef4758c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCwUhexaxdKbJdPkyUOW-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图7:步骤1-添加第一个单词作为根节点。图片作者。</p></figure><p id="a12d" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第二步:</strong>设置根节点为当前节点。然后计算“ស្អាត”到当前节点之间的编辑距离。所以dist(ស្អាត，ស្គម) = 3。之后，我们查看当前节点的子节点。由于当前节点没有距离等于ស្គមdist(ស្អាត的子节点，我们插入“ស្អាត”作为当前节点的子节点。然后我们转到下一个词，“កាល".”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/4d9d60cb5b26c0820b1c92c4bfa9428d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NP2F7KoPJY2ysaVlNmCP0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:步骤2-添加第二个单词。图片作者。</p></figure><p id="d441" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第三步:</strong>设置根节点为当前节点。然后计算“កាល”到当前节点之间的编辑距离。所以我们得到dist(កាល，ស្គម) = 4。类似于步骤2，当前节点没有距离等于ស្គម).dist(កាល的子节点因此，我们插入“កាល”作为当前节点的子节点。然后我们转到下一个词，“ក្បាល".”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/4f834598a8d63f5d34af26b9a4e8b6ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9453hh6ntHj7IRz3ZKiA4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:步骤3-添加第三个单词。作者图片</p></figure><p id="7001" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第四步:</strong>设置根节点为当前节点。然后计算“ក្បាល”到当前节点之间的编辑距离，这给我们dist(ក្បាល，ស្គម) = 4。这一次，当前节点有一个距离为4的子节点，即ស្គម).的dist(កាល在这个场景中，我们通过将子节点设置为当前节点，将插入过程下推到该子节点。之后，我们重复插入过程，当前节点为“កាល”，得到dist(ក្បាល，កាល) = 2。在这个阶段，没有一个“កាល”的孩子的距离与កាល).的dist(ក្បាល相等因此，我们插入“ក្បាល”作为“កាល".”的子代</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a985c47112a3b1d150d5470bb2324325.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA_grjBQsMwdpMAS01mMFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9:步骤4-添加第四个单词(当一个孩子有相同的编辑距离时)。作者图片</p></figure><p id="6e78" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">在构建树之后，我们可以搜索它来找到匹配的节点作为单词更正。</p><h2 id="a8fa" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">BK树搜索</h2><p id="1ec4" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我们可以应用任何树搜索算法来搜索BK-树。在我们的例子中，我选择了深度优先搜索。然而，BK-tree给我们的一个特殊功能是能够修剪/跳过树中的大部分节点。它通过允许我们只查看编辑距离在特定容差阈值内的节点来实现这一点。更具体地说，我们只查看当前节点的子节点，其编辑距离在[dist(word，current_node)-N，dist(word，current_node) + N]之间，其中N是容差级别。</p><p id="f974" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">让我们看看，如果用户输入单词“កាក”,并且我们的容忍级别N = 2，将会返回什么。</p><p id="1182" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤1: </strong>初始化一个空栈和一个空匹配列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/c4a65dd792b0d2b29a2a2d26bd5b95b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pIsNAbCrGGeOOSRX_hoNDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10:步骤1-初始化空堆栈和匹配。图片作者。</p></figure><p id="ccf9" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤2: </strong>将根节点(ស្គម)添加到堆栈中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/392d27b77d442b16915d6294ba63e341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4B_WmfJ5ZrlQabvhlgUw4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图11:步骤2——将第一个根节点添加到堆栈中。图片作者。</p></figure><p id="47a2" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第三步:</strong>获取堆栈顶部的节点(ស្គម).之后，我们发现dist(ស្គម，កាក) = 4 &gt; N。因此，我们没有将它添加到匹配列表中。然后看看它的孩子“ស្អាត”和“កាល".”对于每个孩子，如果dist(ស្គម，កាក) - 2 ≤ dist(孩子，ស្គម) ≤ dist(ស្គម，កាក) + 2，那么我们把它加到堆栈中。在这种情况下，“ស្អាត”和“កាល”都被添加到堆栈中，因为2 ≤ dist(ស្អាត，ស្គម) = 3 ≤ 6，2 ≤ dist(កាល，ស្គម) = 4 ≤ 6。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/7297320572654405d62a2ca6dd63e02a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AoWvye0Dq0xhzM_Wu3kYwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图12:步骤3-遍历树1。图片作者。</p></figure><p id="927a" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第四步:</strong>获取栈顶节点(កាល).然后，dist(កាល，កាក) = 1 ≤ N。所以我们把它添加到匹配列表中。我们再次找到可以添加到堆栈中的“កាល”的孩子。这次只能添加“ក្បាល”，因为-1 ≤ dist(ក្បាល，កាល) = 2 ≤ 3。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/734730973d7ee6a9ffead5d1b16a86e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXEuYmuL67UILYIeg5IVpA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图13:步骤3-遍历树2。图片作者。</p></figure><p id="257f" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤5: </strong>获取栈顶节点(ក្បាល).然后，dist(ក្បាល，កាក) = 3 &gt; N。因此，我们没有将它添加到匹配列表中。由于“ក្បាល”没有任何子节点，因此我们不再向堆栈中添加任何节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/17b89b0e482128264b225a5632530f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1ZO1-aKZt-3j7cczs_ocw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图14:步骤3-遍历树3。图片作者。</p></figure><p id="e791" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">第五步:</strong>获取栈顶节点(ស្អាត).然后，dist(ស្អាត，កាក) = 4 &gt; N。因此，我们没有将它添加到匹配列表中。由于“ស្អាត”没有任何子节点，因此我们不再向堆栈中添加任何节点。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/7ce8814a22aa342cb707708b38910ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qccJdXVBxyJzMumZLHnAlQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图15:步骤4-遍历树3。图片作者。</p></figure><p id="8ab0" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated"><strong class="ls iu">步骤7: </strong>由于堆栈中不再有节点，算法结束。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/115aab39c1e8f2da84ce046401813919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1C3TZP5ril_Jll7zdQF35w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图16:搜索的结果。图片作者。</p></figure><p id="dd5e" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">在上面的例子中，搜索遍历了所有节点。但是，当字典中的单词量很大时，这种方法会让我们跳过很多不必要的节点。</p><h1 id="c478" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">四。缺点</h1><p id="52ba" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">这种提供可接受结果的拼写检查和建议方法有一些缺点。</p><ol class=""><li id="3289" class="ne nf it ls b lt my lw mz lz ng md nh mh ni ml nj nk nl nm bi translated">树构建过程可能需要很长时间才能完成，因此需要预先计算并保存到文件中。</li><li id="c01f" class="ne nf it ls b lt nn lw no lz np md nq mh nr ml nj nk nl nm bi translated">建议的质量很大程度上取决于字典中的单词。如果这个单词不在字典中，它就不能被建议。</li><li id="5179" class="ne nf it ls b lt nn lw no lz np md nq mh nr ml nj nk nl nm bi translated">它没有任何先前的上下文单词，因此建议可能不适合整个句子结构。</li></ol><h1 id="983a" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">动词 （verb的缩写）代码</h1><p id="cc03" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">在了解了这些概念之后，我有机会编写一个利用它们的python包。我做的第一件事是准备一本高棉语词典。为了做到这一点，我从<a class="ae ns" href="https://sbbic.org/2010/07/29/sbbic-khmer-word-list/" rel="noopener ugc nofollow" target="_blank"> SBBIC </a>下载了一个开源(麻省理工学院许可)高棉语单词数据集，并进行了一些预处理，最终得到了一个大约4万个独特单词的列表。然后，我使用下面的代码来构建BK树，将树保存到XML文件中，并使用它来提出拼写建议。此外，我还将它打包成一个python库，可以通过pip安装。</p><h2 id="813c" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">编辑距离</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="8036" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">BK树结构</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="2106" class="mm kz it bd la mn mo dn le mp mq dp li lz mr ms lk md mt mu lm mh mv mw lo mx bi translated">BK树搜索/拼写检查和建议</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="edb9" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">不及物动词结论</h1><p id="ecba" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">学习编辑距离和BK树让我实现了一个简单而有效的拼写检查和建议功能。我希望这篇文章能为你提供足够的理解，让你在其他编程语言中实现这些概念，并把它们扩展到不仅仅是拼写检查。快乐学习！</p><h1 id="82eb" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">参考</h1><p id="c150" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">背靠背瑞典。(2019).<em class="nv">编辑两根弦之间的距离Levenshtein距离(LeetCode上的“编辑距离”)</em>【YouTube频道】。YouTube。从https://www.youtube.com/watch?v=MiqoA-yF-0M<a class="ae ns" href="https://www.youtube.com/watch?v=MiqoA-yF-0M&amp;t=5s" rel="noopener ugc nofollow" target="_blank">取回&amp; t=5s </a></p><p id="93aa" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">EpicFactFind。(2019).<em class="nv">用Levenshtein距离和Bk树进行拼写检查</em>【YouTube频道】。YouTube。从https://www.youtube.com/watch?v=oIsPB2pqq_8<a class="ae ns" href="https://www.youtube.com/watch?v=oIsPB2pqq_8" rel="noopener ugc nofollow" target="_blank">取回</a></p><p id="3c2c" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">茹拉夫斯基博士。<em class="nv">最小编辑距离</em>【PowerPoint幻灯片】。斯坦福大学。从https://web.stanford.edu/class/cs124/lec/med.pdf<a class="ae ns" href="https://web.stanford.edu/class/cs124/lec/med.pdf" rel="noopener ugc nofollow" target="_blank">取回</a></p><p id="67fa" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">北卡罗来纳州库马尔(2022年)。<em class="nv"> BK-Tree |简介&amp;实现。</em>极客forGeeks。检索自<a class="ae ns" href="https://www.geeksforgeeks.org/bk-tree-introduction-implementation/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/bk-tree-introduction-implementation/</a></p><p id="0426" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">米什拉，B . h .(未注明)。<em class="nv">布尔夏德·凯勒树(BK树)。</em> OpenGenus。从https://iq.opengenus.org/burkhard-keller-tree/<a class="ae ns" href="https://iq.opengenus.org/burkhard-keller-tree/" rel="noopener ugc nofollow" target="_blank">取回</a></p><p id="221a" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">SBBIC。(2017).<em class="nv"> SBBIC高棉语词表</em>【数据集】。SBBIC。从https://sbbic.org/2010/07/29/sbbic-khmer-word-list/<a class="ae ns" href="https://sbbic.org/2010/07/29/sbbic-khmer-word-list/" rel="noopener ugc nofollow" target="_blank">取回</a></p><p id="3721" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">辛格(2020)。BK树:未探索的数据结构。走向数据科学。检索自<a class="ae ns" href="https://medium.com/future-vision/bk-trees-unexplored-data-structure-ec234f39052d" rel="noopener">https://medium . com/future-vision/bk-trees-unexplored-data-structure-EC 234 f 39052d</a></p><p id="e326" class="pw-post-body-paragraph lq lr it ls b lt my ju lv lw mz jx ly lz na mb mc md nb mf mg mh nc mj mk ml im bi translated">图沙尔·罗伊——让编码变得简单。(2015).<em class="nv">最小编辑距离动态编程</em>【YouTube频道】。YouTube。从https://www.youtube.com/watch?v=We3YDTzNXEk<a class="ae ns" href="https://www.youtube.com/watch?v=We3YDTzNXEk" rel="noopener ugc nofollow" target="_blank">取回</a></p></div></div>    
</body>
</html>