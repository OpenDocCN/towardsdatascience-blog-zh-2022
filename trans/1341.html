<html>
<head>
<title>Coding Interview: Two-Sum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试:两个总和</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coding-interview-two-sum-bbc615c0e952#2022-04-04">https://towardsdatascience.com/coding-interview-two-sum-bbc615c0e952#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1d2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个博客教程来理解二和问题，它的变种，以及一些有效解决它的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5022f94f047570b02a6ccc3dc20c8387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2x-CAwfeui5YM4148VxgRA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。两笔加总|作者图片|图标</p></figure><p id="c92c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在技术面试中，最常出现的问题之一就是<code class="fe lu lv lw lx b">Two-Sum</code>。在这篇博客教程中，我们将看到如何解决<code class="fe lu lv lw lx b">Two-Sum</code>问题，它的变体以及用<code class="fe lu lv lw lx b">Big(O)</code>符号表示的时间和空间复杂性。</p><p id="f8c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们开始吧！</p><h1 id="e023" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">问题陈述</h1><p id="7b90" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">让我们来看看这个问题的基本定义:</p><blockquote class="mv mw mx"><p id="ef8f" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated">给定一个整数数组<code class="fe lu lv lw lx b">nums</code>和一个<code class="fe lu lv lw lx b">target</code>，如果有任何一对数字的总和为<code class="fe lu lv lw lx b">target</code>，则返回<code class="fe lu lv lw lx b">true</code>，否则返回<code class="fe lu lv lw lx b">false</code>。</p></blockquote><p id="b326" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="4706" class="ng lz it lx b gy nh ni l nj nk"><strong class="lx iu">Case 1</strong><br/><strong class="lx iu">Input</strong>: nums = [3,1,5,2,9] target = 7<br/><strong class="lx iu">Output</strong>: True</span><span id="d1ea" class="ng lz it lx b gy nl ni l nj nk"><strong class="lx iu">Case 2</strong><br/><strong class="lx iu">Input</strong>: nums = [3,1,5,2,9] target = 1<br/><strong class="lx iu">Output</strong>: False</span></pre><p id="43f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得一提的是，结果的类型可以是<code class="fe lu lv lw lx b">boolean</code>(如上例所示)，或者可能需要返回总计为<code class="fe lu lv lw lx b">target</code>的一对数字的索引。</p><blockquote class="mv mw mx"><p id="943e" class="ky kz my la b lb lc ju ld le lf jx lg mz li lj lk na lm ln lo nb lq lr ls lt im bi translated">在开始处理和解决问题的一些方法之前，<strong class="la iu">强烈建议</strong>澄清疑问并确定问题的范围。你可以问面试官一些问题来帮助你定义问题的范围:<br/> -数组排序了吗？<br/> -内存使用有什么限制吗？<br/> -运行时是否有任何约束？</p></blockquote><p id="6432" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于实际目的，我们假设现在数组<code class="fe lu lv lw lx b">nums</code>将是未排序的，并且没有内存和运行时约束。</p><p id="1f53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我们怎么解决呢？一步一步来，首先，我们会看到如何以最不优化的方式解决它，然后我们可以如何改善它，让我们去做吧！</p><h1 id="f9c8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">方法1:暴力</h1><p id="2003" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">有时候，为了更接近最优解，建议先用一种<em class="my">蛮力</em>的方法，这种方法显然不会是最优的，但会为理解问题提供基础，为优化让路。</p><p id="b517" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一种方法是比较从<code class="fe lu lv lw lx b">nums</code>可能形成的所有可能的对，如果我们找到总计为<code class="fe lu lv lw lx b">target</code>的对，我们完成该过程。该函数如代码片段1所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段1。二和:暴力解决方案</p></figure><p id="8c94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管这种方法找到了解决方案，但是由于为了得到解决方案而必须进行的比较的数量，它不是最佳的解决方案，也就是说，对于<code class="fe lu lv lw lx b">nums</code>、<code class="fe lu lv lw lx b">n-1</code>中的每个<code class="fe lu lv lw lx b">n</code>元素，进行比较，这产生了二次O(N)执行时间。存储器使用保持恒定O(1 ),因为不需要额外的存储器来执行比较。</p><p id="bf95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">优化这种暴力方法的一种方法是使用额外的内存，这将导致运行时和内存中的O(N)复杂度，让我们看看如何做到这一点。</p><h1 id="89c8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">方法2:使用Set()进行优化</h1><p id="e153" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这种方法的目的是通过利用额外的内存来避免二次比较的次数，在这种情况下，通过利用Python中的set或<code class="fe lu lv lw lx b">set()</code>。</p><p id="6977" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">set()</code>允许我们在常数时间O(1)内插入或查询，唯一要考虑的方面是<code class="fe lu lv lw lx b">set()</code>将需要O(N)顺序的内存，如果是问题范围内的约束，就必须考虑。</p><p id="9810" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法的思想是将<code class="fe lu lv lw lx b">nums</code>的所有元素放入<code class="fe lu lv lw lx b">set()</code>。然后遍历<code class="fe lu lv lw lx b">nums</code>的每个元素，检查<code class="fe lu lv lw lx b">set()</code>中是否存在<code class="fe lu lv lw lx b">target — num</code>，如果存在，返回<code class="fe lu lv lw lx b">true</code>。代码片段2显示了函数定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段2。两和:使用set()的解决方案</p></figure><p id="dc52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将N个元素插入到<code class="fe lu lv lw lx b">n</code>需要O(N) x O(1 ),结果是O(N)。循环遍历<code class="fe lu lv lw lx b">nums</code>中的每个<code class="fe lu lv lw lx b">num</code>以验证<code class="fe lu lv lw lx b">set()</code>中是否存在补码<code class="fe lu lv lw lx b">target — num</code>也需要O(N)，结果是O(N) + O(N)最终在运行时接近O(N)，在内存中接近O(N)。</p><p id="0a1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得一提的是，使用<code class="fe lu lv lw lx b">set()</code>的方法只有在返回值为<code class="fe lu lv lw lx b">boolean</code>时才有效，也就是说，不需要返回额外的信息。如果我们需要返回总计为<code class="fe lu lv lw lx b">target</code>的数字的索引，我们可以使用<code class="fe lu lv lw lx b">hashmap</code>来代替。我们来看看怎么做。</p><h1 id="53c0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">方法3:使用HashMap()进行优化</h1><p id="b5d7" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这种方法解决了这样一种变化，即需要返回相加到<code class="fe lu lv lw lx b">target</code>的一对数字的索引，而不仅仅是返回<code class="fe lu lv lw lx b">true</code>或<code class="fe lu lv lw lx b">false</code>。</p><p id="5e7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="11b3" class="ng lz it lx b gy nh ni l nj nk"><strong class="lx iu">Case 1</strong><br/><strong class="lx iu">Input</strong>: nums = [3,1,5,2,9] target = 7<br/><strong class="lx iu">Output</strong>: [2, 3]</span><span id="91cb" class="ng lz it lx b gy nl ni l nj nk"><strong class="lx iu">Case 2</strong><br/><strong class="lx iu">Input</strong>: nums = [3,1,5,2,9] target = 1<br/><strong class="lx iu">Output</strong>: []</span></pre><p id="9eb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这种变化，<code class="fe lu lv lw lx b">hashmap()</code>帮助我们跟踪指数。接下来，我们只需要检查<code class="fe lu lv lw lx b">target — nums[i]</code>的补码是否存在于<code class="fe lu lv lw lx b">hashmap()</code>中，如果存在，返回<code class="fe lu lv lw lx b">current</code>和<code class="fe lu lv lw lx b">complement</code>索引。该函数如代码片段3所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段3。Two-Sum:使用hashmap()的解决方案</p></figure><p id="dc82" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个<code class="fe lu lv lw lx b">hashmap()</code>中插入和查询键需要恒定的O(1)时间，所以用<code class="fe lu lv lw lx b">n</code>元素填充<code class="fe lu lv lw lx b">hashmap()</code>需要恒定的时间O(N)，这也导致线性顺序内存使用O(N)。遍历<code class="fe lu lv lw lx b">nums</code>的每个元素以检查<code class="fe lu lv lw lx b">target — nums[i]</code>是否存在于<code class="fe lu lv lw lx b">hashmap()</code>中需要O(N)个常数时间，结果是执行时间和内存使用的总时间为O(N)。</p><p id="fcad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然利用<code class="fe lu lv lw lx b">hashmap()</code>有助于我们验证<code class="fe lu lv lw lx b">target — nums[i]</code>是否作为键存在，但是我们仍然可以更有效地使用它。请注意，在第8行，我们完全循环通过<code class="fe lu lv lw lx b">nums</code>来填充<code class="fe lu lv lw lx b">hashmap()</code>，然后循环通过第12行的<code class="fe lu lv lw lx b">nums</code>来验证补数，这导致遍历2次<code class="fe lu lv lw lx b">nums</code>。让我们看看如何通过仅循环一次<code class="fe lu lv lw lx b">nums</code>来使这种方法更有效。</p><h1 id="554b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">方法4:使用HashMap() II进行优化</h1><p id="4f4a" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这种方法的思想是只遍历<code class="fe lu lv lw lx b">nums</code>一次，以验证<code class="fe lu lv lw lx b">target — nums[i]</code>是否作为键存在于<code class="fe lu lv lw lx b">hashmap()</code>中。这将使执行时间更有效，尽管它仍然是线性的，而不是在<code class="fe lu lv lw lx b">nums</code>上迭代两次，现在我们将只做一次。代码片段4显示了函数的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段4。Two-Sum:使用hashmap() II的解决方案</p></figure><p id="4d10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们在这种情况下循环通过<code class="fe lu lv lw lx b">nums</code>，执行时间也是线性的O(N)，并且由于我们使用了<code class="fe lu lv lw lx b">hashmap()</code>，内存使用也是线性的O(N)。通过避免在<code class="fe lu lv lw lx b">nums</code>上迭代两次并且只做一次来进行优化。</p><p id="2bf4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">回到原来的问题，我们只需要返回<code class="fe lu lv lw lx b">true</code>或<code class="fe lu lv lw lx b">false</code>，如果<code class="fe lu lv lw lx b">nums</code>已经排序了，我们将如何处理这个问题？我们来看看怎么做。</p><h1 id="48ea" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">方法5:排序数组的优化</h1><p id="8144" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">假设不是<code class="fe lu lv lw lx b">nums</code>不排序，而是发现<code class="fe lu lv lw lx b">nums</code>按非降序排序。</p><p id="3b2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><pre class="kj kk kl km gt nc lx nd ne aw nf bi"><span id="08c3" class="ng lz it lx b gy nh ni l nj nk"><strong class="lx iu">Case 1</strong><br/><strong class="lx iu">Input</strong>: nums = [1,2,3,5,9] target = 7<br/><strong class="lx iu">Output</strong>: True</span><span id="1749" class="ng lz it lx b gy nl ni l nj nk"><strong class="lx iu">Case 2</strong><br/><strong class="lx iu">Input</strong>: nums = [1,2,3,5,9] target = 1<br/><strong class="lx iu">Output</strong>: False</span></pre><p id="1314" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，问题条件是合适的，因此不再需要使用额外的内存来跟踪已经访问过的号码。在这种情况下，通过实现<strong class="la iu">两个指针</strong>的技术，我们可以确定是否有一对总计为<code class="fe lu lv lw lx b">target</code>。代码片段5展示了该函数的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段5。Two-Sum(排序数组):使用双指针技术的解决方案</p></figure><p id="6475" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法的执行时间是线性的O(N ),因为在最坏的情况下，我们只遍历每个nums元素一次。空间使用是恒定的，因为不需要额外的内存使用。</p><h1 id="9891" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="23aa" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">两和问题可以有不同的变化和条件，总是建议尽可能澄清，以避免误解，并选择正确的路径。在这篇博客中，我们看到了一些变化，以及如何处理它们，从基于蛮力的方法到寻找更优化的方法。</p><p id="bd80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有具体的变化或任何其他问题，我们可以在博客中分解，请留下你的评论。</p><h1 id="5ebf" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">参考</h1><p id="e3d6" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">[1]<a class="ae no" href="https://leetcode.com/problems/two-sum/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/two-sum/</a></p><p id="5718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae no" href="https://leetcode.com/ferneutron/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/ferneutron/</a></p></div></div>    
</body>
</html>