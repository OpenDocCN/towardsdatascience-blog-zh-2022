<html>
<head>
<title>Dealing with Date and Time in Pandas DataFrames</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫数据帧中日期和时间的处理</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dealing-with-date-and-time-in-pandas-dataframes-7d140f711a47#2022-12-06">https://towardsdatascience.com/dealing-with-date-and-time-in-pandas-dataframes-7d140f711a47#2022-12-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何操作熊猫数据框中的日期和时间值，让您的生活更轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9418d82b0f23984493c5f8f1cddf9141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ljlYa8fqjUGtNqQP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@esteejanssens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃斯特·扬森斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="04a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您经常需要对 Pandas 数据帧执行的一个常见任务是操作日期和时间。根据日期和时间值最初在数据集中的编码方式，您通常需要花费大量精力来操作它们，以便可以将它们用于数据分析目的。在这篇文章中，我将向你展示一些常见的技术来处理你的熊猫数据帧中的日期和时间。</p><p id="e3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在本文中使用的 CSV 文件是:</p><ul class=""><li id="f620" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu"> AAPL.csv </strong> —苹果历史数据集(<a class="ae ky" href="https://www.kaggle.com/datasets/prasoonkottarathil/apple-lifetime-stocks-dataset" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/datasets/prasoonkottarathil/Apple-lifetime-stocks-Dataset</a>)。许可证— <a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0:公共领域</a></li><li id="6db1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu"> Flights.csv </strong> — 2015 年航班延误和取消数据集(<a class="ae ky" href="https://www.kaggle.com/datasets/usdot/flight-delays" rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/datasets/usdot/flight-delays</a>)。许可证— <a class="ae ky" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank"> CC0:公共领域</a></li></ul><h1 id="4d7b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将列转换为<code class="fe nb nc nd ne b">datetime64</code>数据类型</h1><p id="fb56" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们将<strong class="lb iu"> AAPL.csv </strong>文件加载到熊猫数据帧中:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="dd62" class="no mk it ne b be np nq l nr ns">import pandas as pd<br/><br/>df = pd.read_csv('AAPL.csv')<br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/57a8a371cbdae5619ed1e29c29c48d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*oO9I8wjsypXiAl6tYHAnTQ.png"/></div></div></figure><p id="5ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以检查数据帧中每一列的数据类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="7fed" class="no mk it ne b be np nq l nr ns">df.dtypes</span></pre><p id="038d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下面的输出可以看出，<code class="fe nb nc nd ne b">Date</code>列被表示为一个<code class="fe nb nc nd ne b">object</code>:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="9fcb" class="no mk it ne b be np nq l nu ns"><strong class="ne iu">Date          object<br/></strong>Open         float64<br/>High         float64<br/>Low          float64<br/>Close        float64<br/>Adj Close    float64<br/>Volume         int64<br/>dtype: object</span></pre><p id="6b16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe nb nc nd ne b">datetime.strptime()</code>函数将<code class="fe nb nc nd ne b">Date</code>列转换为<code class="fe nb nc nd ne b">datetime64</code>数据类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="686f" class="no mk it ne b be np nq l nr ns">from datetime import datetime<br/><br/>df['Date'] = df['Date'].apply(<br/>    lambda x: datetime.strptime(x,'%Y-%m-%d'))<br/>df</span></pre><blockquote class="nv nw nx"><p id="8cc0" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">您可以从<a class="ae ky" href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/datetime . html # strftime-and-strptime-format-codes</a>获取格式代码列表(如<code class="fe nb nc nd ne b">%Y</code>、<code class="fe nb nc nd ne b">%m</code>、<code class="fe nb nc nd ne b">%d</code>)。</p></blockquote><p id="ef7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可以检查<code class="fe nb nc nd ne b">Date</code>列的数据类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="71cc" class="no mk it ne b be np nq l nr ns">df.dtypes</span></pre><p id="6f35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且<code class="fe nb nc nd ne b">Date</code>列现在是类型<code class="fe nb nc nd ne b">datetime64</code>:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="c3ee" class="no mk it ne b be np nq l nu ns"><strong class="ne iu">Date         datetime64[ns]</strong><br/>Open                float64<br/>High                float64<br/>Low                 float64<br/>Close               float64<br/>Adj Close           float64<br/>Volume                int64<br/>dtype: object</span></pre><blockquote class="nv nw nx"><p id="7ae2" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">datetime64[ns]</code>中的<code class="fe nb nc nd ne b">[ns]</code>指定了 DateTime 对象的精度，单位为纳秒。</p></blockquote><h2 id="c7d2" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">基于特定日期查找行</h2><p id="945d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">将<code class="fe nb nc nd ne b">Date</code>列转换为<code class="fe nb nc nd ne b">datetime64</code>数据类型可以让您轻松地执行与日期相关的操作，例如查找 2018 年 12 月的所有行:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="be02" class="no mk it ne b be np nq l nr ns">df[(df['Date'].dt.month == 12) &amp; <br/>   (df['Date'].dt.year == 2018)]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/16c5d9a1b909c1ce78bf91064e35d079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*RNKyYU4TI4vO4_ssf4B4tg.png"/></div></figure><h2 id="0500" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">根据星期几查找行</h2><p id="cb9d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">您还可以使用<code class="fe nb nc nd ne b">dayofweek</code>属性来查找一周中的某一天(比如星期一、星期二等等)。例如，以下语句查找日期在星期一的所有行:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="fd9f" class="no mk it ne b be np nq l nr ns"># 0 is Monday, 1 is Tue, etc<br/>df[df['Date'].dt.dayofweek == 0].sample(5)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/31b7de3826c4f0fcb76bee02da3781b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*PcSGS5tlSb57vlByHk55gQ.png"/></div></figure><h2 id="67d6" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">按星期几排序</h2><p id="b427" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在处理日期时，您会遇到的另一个常见场景是根据一周中的某一天对数据进行排序(例如从星期一到星期天，或者从星期天到星期六)。</p><p id="e680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个你可以使用的技巧。首先，使用<code class="fe nb nc nd ne b">strftime()</code>函数从<code class="fe nb nc nd ne b">Date</code>列(一个<code class="fe nb nc nd ne b">datetime64[ns]</code>对象)中提取星期几:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="4a2c" class="no mk it ne b be np nq l nr ns">df['Day'] = df['Date'].apply(<br/>    lambda x: x.strftime('%a'))<br/>df</span></pre><p id="2e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提取的星期几保存到名为<code class="fe nb nc nd ne b">Day</code>的新列中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/70385297204715a99f81b9513578cb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*MhIQvcjEJ4c4IFzEkUkhGw.png"/></div></figure><p id="f631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，定义要订购的日期顺序:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="6024" class="no mk it ne b be np nq l nr ns">#---define your category order---<br/>cats = ['Mon','Tue','Wed','Thu','Fri'] # omit Sat and Sun</span></pre><blockquote class="nv nw nx"><p id="f731" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">在上面我省略了周六和周日，因为这两天(周末)没有股票数据。</p></blockquote><p id="2485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过传递您之前定义的日期顺序，使用<code class="fe nb nc nd ne b">CategoricalDtype</code>类创建一个新的分类数据类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="50e9" class="no mk it ne b be np nq l nr ns">from pandas.api.types import CategoricalDtype<br/><br/>cat_type = CategoricalDtype(categories=cats, ordered=True)</span></pre><p id="851e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，将<code class="fe nb nc nd ne b">Day</code>列转换为您刚刚创建的新分类类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="879d" class="no mk it ne b be np nq l nr ns">#---cast the Day column as categorical---<br/>df['Day'] = df['Day'].astype(cat_type)<br/>df.dtypes</span></pre><p id="3672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以看到<code class="fe nb nc nd ne b">Day</code>属于<code class="fe nb nc nd ne b">category</code>数据类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="a360" class="no mk it ne b be np nq l nu ns">Date           object<br/>Open          float64<br/>High          float64<br/>Low           float64<br/>Close         float64<br/>Adj Close     float64<br/>Volume          int64<br/>Day          category<br/>dtype: object</span></pre><p id="8a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想打印出所有按星期排序的股票数据，你现在可以使用<code class="fe nb nc nd ne b">groupby()</code>功能:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="5e74" class="no mk it ne b be np nq l nr ns">for _, gp in df.groupby('Day'):<br/>    display(gp.sample(3))</span></pre><p id="ff9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，分组是按<code class="fe nb nc nd ne b">Day</code>排序的，首先是星期一，然后是星期二，依此类推:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/2f6fa338bec3fe0b555de1284e7db738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*ikMpbpoj5iCHGsdZvPBQBQ.png"/></div></figure><p id="92fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想首先显示星期二，然后显示星期三，依此类推，更改<code class="fe nb nc nd ne b">cats</code>变量中的顺序:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="95c0" class="no mk it ne b be np nq l nr ns">cats = ['Tue','Wed','Thu','Fri','Mon'] # omit Sat and Sun<br/>cat_type = CategoricalDtype(categories=cats, ordered=True)<br/><br/>#---cast the Day column as categorical---<br/>df['Day'] = df['Day'].astype(cat_type)<br/><br/>for _, gp in df.groupby('Day'):<br/>    display(gp.sample(3))</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bba4074485a4cc377aafd156f89a9d6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*NApP90Jv6QKtRq1vgrtrFQ.png"/></div></figure><h2 id="a105" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">在加载期间转换日期时间列</h2><p id="c103" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在前面的部分中，在将整个 CSV 文件加载到 DataFrame 中之后，您将<code class="fe nb nc nd ne b">Date</code>列转换为<code class="fe nb nc nd ne b">datetime64</code>数据类型。另一种方法是在使用<code class="fe nb nc nd ne b">parse_dates</code>参数加载 CSV 时执行转换:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="8e6a" class="no mk it ne b be np nq l nr ns">df = pd.read_csv("AAPL.csv", parse_dates=['Date'])</span></pre><p id="28ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">parse_dates</code>参数指定要解析为<code class="fe nb nc nd ne b">datetime64</code>对象的列。</p><blockquote class="nv nw nx"><p id="8b02" class="kz la ny lb b lc ld ju le lf lg jx lh nz lj lk ll oa ln lo lp ob lr ls lt lu im bi translated">注意，如果将<code class="fe nb nc nd ne b">parse_dates</code>参数设置为<code class="fe nb nc nd ne b">True</code>，Pandas 将尝试将索引解析为一个<code class="fe nb nc nd ne b">datetime64</code>对象</p></blockquote><h1 id="a53e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将多个列解析为日期</h1><p id="8c16" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">有时数据集中的日期分别存储在不同的列中，例如一列表示年份，一列表示月份，等等。虽然以这种方式保存数据有利也有弊，但是如果可以将所有不同的列合并成一个列，有时会更容易。这种表示的一个很好的例子是在<strong class="lb iu"> flights.csv </strong>文件中。</p><p id="e0a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们加载<strong class="lb iu"> flights.csv </strong>文件，观察前五列中的五个示例行:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="0b7e" class="no mk it ne b be np nq l nr ns">df = pd.read_csv("flights.csv")<br/><br/># display sample 5 rows and first 5 columns<br/>df.sample(5).iloc[:,:5]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/5ff4ea47853e790312f7970cf4a2a896.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*PQQAYQ2laflAdAqBc3ACHQ.png"/></div></figure><h2 id="98f3" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">在加载时合并列</h2><p id="b05f" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在<strong class="lb iu"> flights.csv </strong>文件中，每个航班的日期使用三个不同的列来表示——<strong class="lb iu">年</strong>、<strong class="lb iu">月</strong>日。为了执行数据分析，如果可以使用<code class="fe nb nc nd ne b">parse_dates</code>参数将三列合并成一个日期列，会更容易:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="1eab" class="no mk it ne b be np nq l nr ns">df = pd.read_csv("flights.csv", <br/>                 parse_dates=[[0,1,2]])<br/>df.sample(5).iloc[:,:5]</span></pre><p id="2b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我使用了列索引来指示要合并到单个列中的列。我还可以指定列的名称:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="7dbc" class="no mk it ne b be np nq l nr ns">df = pd.read_csv("flights.csv", <br/>                 parse_dates=[['YEAR','MONTH','DAY']])</span></pre><p id="29be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是前三列被删除并替换为一个新列，新列的名称是三个列名的串联:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/6e4981e284de1662fc7e1f5d4046d757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*iSBpGnC3Hcw9XJzNzZW9uA.png"/></div></figure><p id="c3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，在本文的前面，我用一个列表— <code class="fe nb nc nd ne b">parse_dates=[‘Date’]</code>设置了<code class="fe nb nc nd ne b">parse_dates</code>参数。将其设置为列表将导致各个列作为<code class="fe nb nc nd ne b">datetime</code>对象加载。如果你将它设置为列表的<em class="ny">列表，比如<code class="fe nb nc nd ne b">parse_dates=[[‘YEAR’,’MONTH’,’DAY’]]</code>，那么这些列将被合并成一个单独的<code class="fe nb nc nd ne b">datetime</code>对象。</em></p><p id="cd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个如下所示的 CSV:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="f46a" class="no mk it ne b be np nq l nu ns">DATE,YEAR,MONTH,DAY<br/>2015-09-13,2015,9,13<br/>2015-09-14,2015,9,14</span></pre><p id="1328" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将<code class="fe nb nc nd ne b">DATE</code>列转换为<code class="fe nb nc nd ne b">datetime</code>对象，同时使用以下<code class="fe nb nc nd ne b">parse_dates</code>参数值将<code class="fe nb nc nd ne b">YEAR</code>、<code class="fe nb nc nd ne b">MONTH</code>和<code class="fe nb nc nd ne b">DAY</code>列合并为单个<code class="fe nb nc nd ne b">datetime</code>对象:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="26b9" class="no mk it ne b be np nq l nr ns">df = pd.read_csv("test.csv", <br/>                 parse_dates=['DATE',['YEAR','MONTH','DAY']])</span></pre><p id="5710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/c343fde60a2a45b8a387c53d09e6f7e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*9w9Gg0fWE60k9xFPEhzP7Q.png"/></div></figure><p id="70c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印出<code class="fe nb nc nd ne b">df</code>中的<code class="fe nb nc nd ne b">dtypes</code>确认两列的数据类型:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="bcdb" class="no mk it ne b be np nq l nr ns">YEAR_MONTH_DAY    datetime64[ns]<br/>DATE              datetime64[ns]<br/>dtype: object</span></pre><h2 id="7412" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">加载 DataFrame 后合并列</h2><p id="7206" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用<code class="fe nb nc nd ne b">to_datetime()</code>功能加载数据帧后，您也可以合并数据帧的列:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="427a" class="no mk it ne b be np nq l nr ns">df = pd.read_csv("flights.csv")<br/>df['DATETIME'] = pd.to_datetime(df[['YEAR', 'MONTH', 'DAY']])<br/>df.sample(5).iloc[:,-3:]</span></pre><p id="6acd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下输出显示了数据帧的最后三列，最后一列是三列的组合结果— <code class="fe nb nc nd ne b">YEAR</code>、<code class="fe nb nc nd ne b">MONTH</code>和<code class="fe nb nc nd ne b">DAY</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/97c246fe7d3f6eed66d07efc9a1105f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*DbDgOg7OJU0OEUONLrAiAQ.png"/></div></figure><h2 id="1179" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">格式化时间</h2><p id="9602" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">除了在三个单独的列中存储预定出发日期之外，您还会注意到有一个名为<code class="fe nb nc nd ne b">SCHEDULED_DEPARTURE</code>的列:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="8ec3" class="no mk it ne b be np nq l nr ns">df[['SCHEDULED_DEPARTURE']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/d5e2b3c4c852220ccacaa5a9eeb368cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*qj3v4rYSPPGjUOIWeOkaWQ.png"/></div></figure><p id="3183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此列是一个整数列，存储数字，如 5，10，直到 2359。每个值代表的实际上是 HHMM 格式的出发时间。所以 5 实际上代表 00:05，而 2359 实际上代表 23:59。如果您要对这个列执行分析，您肯定需要进一步处理这个列。</p><p id="8d7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我要做的是将四列合并成一个<code class="fe nb nc nd ne b">datetime</code>列:</p><ul class=""><li id="27df" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe nb nc nd ne b">YEAR</code></li><li id="3ccf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nb nc nd ne b">MONTH</code></li><li id="e9ee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nb nc nd ne b">DAY</code></li><li id="2877" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe nb nc nd ne b">SCHEDULED_DEPARTURE</code></li></ul><p id="931b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在上一节中所看到的，将前三者结合起来是很容易的。第四列需要一些处理:</p><ul class=""><li id="a28f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您需要将出发时间格式化为一个字符串，然后提取前两个数字来表示小时(HH)</li><li id="63d3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">然后提取代表分钟(MM)的最后两位数字</li></ul><p id="8124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述操作可以按如下方式实施:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="ccef" class="no mk it ne b be np nq l nr ns">import datetime<br/><br/># function to convert HHMM to datetime.time<br/>def format_time(time):<br/>    # format the time as string<br/>    time = "{0:04d}".format(int(time))<br/>    # extract hh and mm and then convert to time<br/>    hhmm = datetime.time(int(time[0:2]), int(time[2:4]))<br/>    return hhmm<br/><br/>df['SCHEDULED_DEPARTURE'] = \<br/>    df['SCHEDULED_DEPARTURE'].apply(format_time)<br/>df[['SCHEDULED_DEPARTURE']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f51ef2cbfaeac23033be9ce42dec927a.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*QLy0Wnv_khwMIYxusZlzbQ.png"/></div></figure><h2 id="ead7" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated"><strong class="ak">合并日期和时间列</strong></h2><p id="d09c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">既然我们的 dataframe 有两个数据类型为<code class="fe nb nc nd ne b">datetime</code>的列— <code class="fe nb nc nd ne b">DATETIME</code>和<code class="fe nb nc nd ne b">SCHEDULED_DEPARTURE</code>，我们现在可以将它们合并成一个列。以下代码片段使用<code class="fe nb nc nd ne b">apply()</code>函数和<code class="fe nb nc nd ne b">datetime.combine()</code>函数来组合两个指定的列:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="639f" class="no mk it ne b be np nq l nr ns">from datetime import datetime<br/><br/>df['SCHEDULED_DEPARTURE'] = \<br/>    df.apply(<br/>        lambda r: datetime.combine(r['DATETIME'], r['SCHEDULED_DEPARTURE']), <br/>        axis=1)<br/>df.sample(5)[['SCHEDULED_DEPARTURE']]</span></pre><p id="cf0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nb nc nd ne b">SCHEDULED_DEPARTURE</code>列现在包含出发日期和时间:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/196c4d8045a9c6dd9f832983f31d1457.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/format:webp/1*ie5F87NUf9IDPynA8pa4Pw.png"/></div></figure><p id="453a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以轻松找到在特定时间起飞的所有航班:</p><pre class="kj kk kl km gt nk ne nl bn nm nn bi"><span id="1096" class="no mk it ne b be np nq l nr ns">df[(df['SCHEDULED_DEPARTURE'].dt.month == 12) &amp; <br/>   (df['SCHEDULED_DEPARTURE'].dt.year == 2015) &amp; <br/>   (df['SCHEDULED_DEPARTURE'].dt.hour &gt;= 22) &amp; <br/>   (df['SCHEDULED_DEPARTURE'].dt.minute &gt; 30)]\<br/>   [['FLIGHT_NUMBER','SCHEDULED_DEPARTURE']]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/13d8402de8422f834ecc2618e47216bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*myB-7pypTeM8jNCGf81JQw.png"/></div></figure><h2 id="7ee5" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">如果你喜欢阅读我的文章，并且认为它对你的职业/学习有所帮助，请考虑注册成为一名灵媒会员。每月 5 美元，你可以无限制地访问 Medium 上的所有文章(包括我的)。如果你使用下面的链接注册，我会赚一小笔佣金(不需要你额外付费)。你的支持意味着我将能够投入更多的时间来写这样的文章。</h2><div class="pj pk gp gr pl pm"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">阅读李维孟(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">weimenglee.medium.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa ks pm"/></div></div></a></div><h1 id="71e4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">摘要</h1><p id="d5d7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我希望这篇文章在处理您的 Pandas 数据帧中的日期和时间时对您有用。特别是，我介绍了:</p><ul class=""><li id="2c9a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">如何在加载数据帧后将列转换为<code class="fe nb nc nd ne b">datetime64</code>数据类型</li><li id="99fa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何在加载期间将列作为<code class="fe nb nc nd ne b">datetime64</code>对象加载</li><li id="4c93" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何找到特定日期的星期几</li><li id="1eff" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何根据星期几对数据帧进行排序</li><li id="d226" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何在加载时将不同的列组合成一个<code class="fe nb nc nd ne b">datetime64</code>对象</li><li id="36e0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据框加载后如何将不同的列组合成一个<code class="fe nb nc nd ne b">datetime64</code>对象</li><li id="0f60" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何将字符串转换为时间格式</li><li id="1761" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如何组合日期和时间列</li></ul></div></div>    
</body>
</html>