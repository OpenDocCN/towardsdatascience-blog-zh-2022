<html>
<head>
<title>How Git truly works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git的真实工作方式</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-git-truly-works-cd9c375966f6#2022-05-24">https://towardsdatascience.com/how-git-truly-works-cd9c375966f6#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ea9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解Git的内部知识并掌握它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8273e6c8991492d07f79cac7f0021000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LAwJNx2Wzc-KuQap"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="e1ed" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">#简介</h1><p id="43d8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Git无疑是现代软件开发的主要<strong class="lq ir">基石之一。它是协调开发人员工作的必备工具箱，并成为多年来开源运动的基本引擎。简单来说，截至2021年11月，Git的主要存储库管理器GitHub报告称有超过7300万开发人员和超过2亿个</strong>存储库。</p><p id="230d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有几个程序员每天都和Git打交道，并且共同应用关键概念。在本次讲座中，我们将<strong class="lq ir"> <em class="mp">进行下一步</em> </strong>，深入探究Git的内部结构和基本基础。什么是分支？什么是头？合并一个分支意味着什么？今天，我们将回答这些问题和其他问题。</p><p id="e7c2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mp">在我们开始之前，我要特别感谢拉朱·甘地，他通过精彩的讲座“Git next steps”帮助我完成了这篇文章，该讲座可以在</em><a class="ae kv" href="https://www.oreilly.com/live-events/git-next-steps/0636920457459/0636920057583/" rel="noopener ugc nofollow" target="_blank"><em class="mp">O ' Reilly</em></a><em class="mp">上找到。他清晰完整的解释是我灵感的源泉。</em></p><h1 id="c419" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">#基础</h1><p id="0a1a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Blobs、树和提交是Git数据结构的主要组成部分。正如一所房子是由砖块建造的，或者一个图形是由边和节点组成的，这些元素构成了Git的基础。</p><p id="e6d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了理解这些，让我们从一个例子开始。假设我们创建了一个空的存储库。当我们启动命令<em class="mp"> git init </em>时，git会自动创建一个名为<em class="mp">的隐藏文件夹。git </em>用于存放内部零件。</p><h2 id="846f" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated"><strong class="ak">斑点</strong></h2><p id="3dac" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，假设我们创建一个名为<em class="mp"> myfile.txt </em>的文件，并使用命令<em class="mp"> git add myfile.txt. </em>将其添加到我们的存储库中</p><p id="3d6e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当我们执行这个操作时，Git创建一个<strong class="lq ir"> blob </strong>，一个位于子文件夹<em class="mp">中的文件。git/objects </em> <strong class="lq ir">存储<em class="mp"> myfile.txt、</em>的内容</strong>，不包含<em class="mp"> </em>的任何相关元数据(如创建时间戳、作者等)。因此，<strong class="lq ir">创建blob就像存储文件</strong>内容的图片。</p><p id="5d7c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">blob的名称<strong class="lq ir">与其内容</strong>的散列相关。一旦内容被散列，前两个字符用于在<em class="mp">中创建一个子文件夹。git/objects </em>，而散列的剩余字符构成了blob的名称。</p><p id="a67e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">总之，当向Git添加文件时，会发生以下步骤:</p><ol class=""><li id="d4b7" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj nh ni nj nk bi translated">Git获取文件的内容并对其进行哈希处理</li><li id="f26e" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">Git在<em class="mp">中创建一个blob。git/objects </em>文件夹。哈希的前两个字符用于在该路径中创建子文件夹。在其中，Git创建了一个blob，其名称由哈希的剩余字符组成。</li><li id="8e42" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">Git将原始文件的内容(它的压缩版本)存储在blob中。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/629db935823d6c6ee4cb7176311fd6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hq8Zv4TYoWk0T7IHw-ruaQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建blob时Git执行的过程的描述(图片由作者提供)</p></figure><p id="b639" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请注意，如果我们有一个名为<em class="mp"> myfile.txt </em>的文件和另一个名为<em class="mp"> ourfile.txt、</em>的文件，并且这两个文件<strong class="lq ir">共享相同的内容，则它们具有相同的散列值</strong>，因此它们存储在同一个blob中。</p><p id="a83b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还要注意，如果我们稍微修改<em class="mp"> myfile.txt </em>并将其重新添加到存储库中，Git会执行相同的过程，因为内容发生了变化，所以会创建一个新的blob。</p><h2 id="b084" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">树</h2><p id="974e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设现在我们在存储库中创建了一个名为<em class="mp">子文件夹的子文件夹。</em>我们还可以在这个子文件夹中创建一个名为<em class="mp"> yourfile.txt </em>的文件，并将其添加到存储库中。这样做的时候，Git根据我们在上一段中定义的过程为<em class="mp"> yourfile.txt </em>创建一个新的blob。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d806ce3071f84df2a8ca23295db87614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dvd_mrmqoJnkzen0ZhJsbg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git散列第二个名为yourfile.txt的文件，该文件存储在文件夹中。git/objects(图片由作者提供)</p></figure><p id="aa66" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此时，我们用命令<em class="mp"> git commit提交<em class="mp"> myfile.txt </em>和<em class="mp"> yourfile.txt </em>。</em>这样做时，Git采取了两个步骤:</p><ul class=""><li id="f8c1" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj ns ni nj nk bi translated">它创建了存储库的根树</li><li id="97bf" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj ns ni nj nk bi translated">它创建了<strong class="lq ir">提交</strong></li></ul><p id="8b44" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们专注于第一步。那么，什么是根树呢？一个<strong class="lq ir">根树存储了整个库</strong>的文件和文件夹的结构。它是一个文件，包含对存储库中包含的每个blob或子文件夹的引用，<strong class="lq ir">以递归方式构建</strong>。</p><p id="54a1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">根树的每一行引用一个斑点或其他子树<strong class="lq ir">，这些子树又以相同的方式引用其他斑点或其他子树</strong>。因此，树<strong class="lq ir">相当于目录</strong>:正如我们可以从目录中访问<em class="mp">文件和子文件夹一样，我们也可以从树</em>中访问<em class="mp">blob和子树。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/4d5647ed91379b262418b52496466811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gw7h15ENDCA1Gx-qvLpkGA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">与mysubfolder相关的根树和子树的内容(图片由作者提供)</p></figure><p id="5b9f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦Git创建了根树和所有相关的子树，它就执行我们上面描述的相同的散列和存储操作。更准确地说，它<strong class="lq ir">对每棵树</strong>进行散列，并使用前两个字符在<em class="mp">中创建一个子文件夹。git/objects </em>而剩余的散列字符形成保存文件的名称。因此，从这个过程中，我们得到了与数据结构中树的数量一样多的新文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/104cf2068c5a691b4052f8c6b3261856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5VuY5BYuTlY3DugIYDUEEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Git散列根树和与mysubfolder相关的子树，两者都存储在文件夹中。git/objects(图片由作者提供)</p></figure><h2 id="b456" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">犯罪</h2><p id="1604" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当运行命令<em class="mp"> git commit </em>时，第二步是创建提交。提交内容存储在一个文件中，该文件包含与根树、父提交(如果有)相关的信息，以及一些元数据，如提交者的姓名和电子邮件以及提交消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/45fbcd1a80f81dcdd04b79ee982e285a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v51EiPc4I8f0vWDwQwS-Yw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">提交文件包含对根树的散列、作者和提交者、提交时间戳(在本例中为163267988)、父提交(在本例中为空，因为这是我们的第一次提交)和提交消息(作者的图像)的引用</p></figure><p id="2bdb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦创建了提交文件，Git就对其内容进行散列，并使用散列名称将内容存储在一个新文件中，与上面完全一样(前两个字符构成了<em class="mp">中的子文件夹名称)。git/objects </em>，而哈希的剩余部分构成了实际的名称)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/ec74642e45fca850e57eb755e896b90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_x6GDjOwoOO2faCQirQOSg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">到目前为止所有树、提交和blobs的结构(图片由作者提供)</p></figure><p id="58cd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那就是。恭喜你，你刚刚意识到Git是如何构造的。现在，有了这些概念，定义branch、tag、head和merge的概念就非常简单了！</p><h1 id="2269" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">#砖块</h1><h2 id="a193" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">分支</h2><p id="c500" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">分支被命名为提交的引用。例如，当创建一个名为<em class="mp"> mybranch </em>的新分支时(以命令<em class="mp"> git checkout -b mybranch </em>为例)，<em class="mp"> </em> Git在路径<em class="mp">中生成一个新文件。git/refs/heads </em>命名为<em class="mp"> mybranch。</em>这个文件的内容<strong class="lq ir">是创建分支</strong>的提交的散列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/d1be6bf93702ec3ad68b642220439667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*w56-HlRoMJBVDX5ZJkpOiA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最初，master和mybranch都指向同一个提交(作者图片)</p></figure><p id="5ee6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，当我们在<em class="mp"> mybranch </em>上提交时，Git执行之前定义的操作(它创建根树并提交文件)，然后<strong class="lq ir">用新的提交散列</strong>更新分支的文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c1d910f86b1fac74840107db3ae36284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*ABBp03j0hMSVNbHUQO7B7Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行新的提交，并且用文件mybranch的内容对其进行更新。文件mybranch现在指向新的提交(作者图片)</p></figure><p id="47b8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，<strong class="lq ir">分支是跟踪提交的文件</strong>，并且这些文件的内容在我们执行的每次提交时都被更新。</p><h2 id="1a44" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">标签</h2><p id="4a0b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">标签是对特定提交的永久引用。例如，当我们创建一个名为<em class="mp"> mytag </em>的新标签时(使用命令<em class="mp">Git tag mytag</em>),<em class="mp"/>Git在路径<em class="mp">中生成一个新文件。git/refs/tags </em>命名为<em class="mp"> mytag。</em>和分支的情况一样，这个文件包含创建标签的提交的散列。</p><p id="f5db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然而，当我们继续我们的工作并在同一个(或其他)分支上提交时，标记文件没有更新，并且<strong class="lq ir">继续指向从</strong>创建它的特定提交。与分支文件不同，<strong class="lq ir">标签在执行新提交</strong>时不会移动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/cde8976919848ab354080c2cb87a3f57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*ro1Sgqi-Em30zSmtga300A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行了新的提交，但文件mytag没有更新(作者图片)</p></figure><h2 id="64c8" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated"><strong class="ak">头</strong></h2><p id="0ebb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">HEAD在Git中执行一些任务:</p><ul class=""><li id="fe80" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj ns ni nj nk bi translated">这是git如何知道哪个提交被检出的<strong class="lq ir">，所以当我们执行<em class="mp"> git分支</em>时，Git查看HEAD以知道我们在哪个分支上。</strong></li><li id="1371" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj ns ni nj nk bi translated">它引用下一个提交的父提交，所以HEAD指向的提交将是下一个提交的父提交。回想一下，当我们执行提交时，<strong class="lq ir">父提交存储在提交文件</strong>中。</li></ul><p id="b33b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我们在主分支上，HEAD引用这个分支。如果我们打开头文件，我们会看到“ref: refs/heads/master”。相反，如果我们切换到分支<em class="mp"> mybranch </em>并打开<em class="mp">中的头文件。git </em>文件夹我们看到:“ref: refs/heads/mybranch”。因此，HEAD并不直接指向一个提交，而是指向一个分支，该分支又指向那个分支上最近的提交。通过这种方式，Git跟踪哪个提交当前被签出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/0b280e755bf5aaeec86e4005273eaec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uq1FcSSGvD3k_q0tH2pGyA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们在树枝上。HEAD指向文件mybranch，它又指向一个特定的提交。与分支主文件相关的文件主文件指向另一个提交文件(作者图片)</p></figure><p id="434d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当我们在一个分支上执行提交时，Git读取头文件的内容，而<strong class="lq ir">写入作为父提交</strong>引用的提交。从这个意义上说，HEAD(间接)提供了下一个提交的父提交。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/85e45521f6c313518083419a38ab37c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBh4UTk1jmn3bROWPx-YtQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">提交文件的内容。HEAD(间接)提供父提交(图片由作者提供)</p></figure><p id="e420" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，在Git中，我们可以检查到以前的提交，并从那里开始进行更改。这种模式称为<strong class="lq ir">“分离模式”</strong>。在这种情况下，<strong class="lq ir"> HEAD直接指向提交，而不是指向分支</strong>。请注意，这可能很危险，因为我们有丢失新提交的风险。事实上，在执行了提交之后，如果我们检查到一个分支，我们就不能再回到这个新的提交<strong class="lq ir">，因为它没有被任何分支</strong>引用！这就是为什么当我们处于分离模式时，在提交任何变更之前创建一个新的分支总是一个好的实践的原因！</p><h2 id="ec3d" class="mq kx iq bd ky mr ms dn lc mt mu dp lg lx mv mw li mb mx my lk mf mz na lm nb bi translated">合并</h2><p id="d7a8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Merge允许连接两个或多个提交。有两种类型的合并:</p><ul class=""><li id="111c" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj ns ni nj nk bi translated">第一种发生在两个分支分叉的时候。Git创建了一个有两个父母的孩子。第一个父级是我们所在的分支，而第二个父级是将要合并的分支。提交文件将有两个父节点，HEAD被移动到新的子节点。</li><li id="6937" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj ns ni nj nk bi translated">第二种情况发生在两个分支没有分叉，但实际上一个分支是另一个分支的延续。在这种情况下，合并被称为快进合并，它不是真正的合并，因为<strong class="lq ir">没有冲突</strong>。在这种情况下，Git只是将HEAD和当前分支移动到从要合并的分支指向的同一个提交。</li></ul><p id="4e3a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">就是这样。恭喜你走了这么远！希望你喜欢这篇文章！到目前为止，您应该已经很好地理解了Git是如何工作的。有问题请随时评论！</p><p id="4c3f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">回头见，保持黄金！:)</p></div></div>    
</body>
</html>