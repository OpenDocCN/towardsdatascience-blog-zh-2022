<html>
<head>
<title>Julia’s Flux vs Python’s TensorFlow: How Do They Compare?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia 的 Flux vs Python 的 TensorFlow:它们如何比较？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059#2022-12-02">https://towardsdatascience.com/julias-flux-vs-python-s-tensorflow-how-do-they-compare-574a3fb5e059#2022-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b1d9" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">深度学习</h2><div class=""/><div class=""><h2 id="6252" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">端到端深度学习项目比较</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f29006347df2ef4700434740d357c002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VV1SpcGYj0JoGrOk-0GZCw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">第三人在<a class="ae lh" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="cea3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">在我的</strong> <a class="ae lh" rel="noopener" target="_blank" href="/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f"> <strong class="lk jd">上一篇文章</strong> </a> <strong class="lk jd">中，我研究了 Julia 在速度方面比 Python/Numpy 有什么优势。</strong></p><p id="06f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然知道这些很有用，但这并不是全部。了解它们在语法、库可用性/集成、灵活性、文档、社区支持等方面的比较也很重要。</p><p id="2834" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">本文在 TensorFlow 和 Flux (Julia 的 native TensorFlow equivalent)两个方面从头到尾贯穿了一个图像分类深度学习问题。这应该很好地概述了这两种语言在一般用法上的比较，并有望帮助您深入了解 Julia 在这种情况下是否是您的潜在选择(或优势)。</strong></p><p id="f692" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">我还将努力强调 Julia 生态系统与 Python 和 TensorFlow 的成熟组合相比的优势，以及更重要的差距或缺点。</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="cffa" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">介绍</h1><p id="d24a" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我特意为这个特殊的探索选择了一个图像分类问题，因为它在数据准备和深度学习框架本身方面都提出了一些很好的挑战:</p><ol class=""><li id="7351" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">影像需要从磁盘加载(不会使用现成的数据集，如 MNIST)，因此将探索加载和预处理方法和惯例</li><li id="30f7" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">图像通常表示为 3D 矩阵(高度、宽度、颜色通道)，因此需要特别注意维度排序</li><li id="7101" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">为了避免过度拟合，通常需要图像增强，以探索库的可用性和易用性</li><li id="e8a2" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">就空间要求而言，图像本质上是一种“大”数据类型，这迫使我们对批处理、RAM 分配和 GPU 使用情况进行调查</li></ol><p id="1e5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong> <em class="nw">虽然整篇文章中都提供了代码片段，但是 Jupyter 笔记本中包含了完整的端到端工作实现(从图片下载到模型训练),可以使用 Julia 和 Python 版本的代码。有关笔记本的链接，请参见下一部分。</em></p><p id="d9a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">顺便说一句，如果这是你第一次听说朱莉娅，我推荐你读“什么是朱莉娅？”一节来快速入门:</p><div class="nx ny gp gr nz oa"><a rel="noopener follow" target="_blank" href="/is-julia-really-faster-than-python-and-numpy-242e0a5fe34f"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">Julia 真的比 Python 和 Numpy 快吗？</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">C 的速度和 Python 的简单性</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">towardsdatascience.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lb oa"/></div></div></a></div><h1 id="e32d" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">参考笔记本</h1><p id="b856" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">本节详细介绍了笔记本的位置，以及在线环境的环境设置要求，如<a class="ae lh" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Colab </a>和<a class="ae lh" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> Deepnote </a>。</p><h2 id="acdc" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">笔记本</h2><p id="3ac2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">可以在此处找到适合您本地环境的原始笔记本:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/thetestspecimen/notebooks/tree/main/julia-python-image-classification" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">笔记本/Julia-python-图像-主要测试样本分类/笔记本</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">Jupyter 笔记本。在 GitHub 上创建一个帐户，为测试样本/笔记本的开发做出贡献。</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="pf l ol om on oj oo lb oa"/></div></div></a></div><p id="30ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…或者在 deepnote 或 colab 中快速启动。</p><p id="fc4d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python 笔记本:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fthetestspecimen%2Fnotebooks%2Fblob%2Fmain%2Fjulia-python-image-classification%2Frps_python_tensorflow.ipynb"><div class="gh gi pg"><img src="../Images/2589425fa59ea0462fa60c913015d133.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*sq2nvEUbjhdd9bKo4QbsRw.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/julia-python-image-classification/rps_python_tensorflow.ipynb"><div class="gh gi pg"><img src="../Images/ab36cfbae94a8d3e5dd11db50b483d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*0rcFSSNzLLx1AuzpHApFuQ.png"/></div></a></figure><p id="d8e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">朱莉娅笔记本:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://deepnote.com/launch?url=https%3A%2F%2Fgithub.com%2Fthetestspecimen%2Fnotebooks%2Fblob%2Fmain%2Fjulia-python-image-classification%2Frps_julia_flux.ipynb"><div class="gh gi pg"><img src="../Images/2589425fa59ea0462fa60c913015d133.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*sq2nvEUbjhdd9bKo4QbsRw.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/julia-python-image-classification/rps_julia_flux_colab.ipynb"><div class="gh gi pg"><img src="../Images/ab36cfbae94a8d3e5dd11db50b483d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*0rcFSSNzLLx1AuzpHApFuQ.png"/></div></a></figure><h2 id="5b13" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">Julia 的环境设置</h2><p id="7852" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated"><strong class="lk jd">深度笔记</strong></p><p id="afeb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于 deepnote 使用了 docker 实例，你可以很容易地建立一个“本地”docker 文件来包含 Julia 的安装说明。这意味着你不必像在 Colab 中那样用安装代码污染 Jupyter 笔记本。</p><p id="42ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在环境部分选择“本地”。/Dockerfile "。这将打开实际的 docker 文件，您应该在其中添加以下内容:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="b8ec" class="pm mm it pi b be pn po l pp pq">FROM deepnote/python:3.10<br/><br/>RUN wget https://julialang-s3.julialang.org/bin/linux/x64/1.8/julia-1.8.3-linux-x86_64.tar.gz &amp;&amp; \<br/>    tar -xvzf julia-1.8.3-linux-x86_64.tar.gz &amp;&amp; \<br/>    mv julia-1.8.3 /usr/lib/ &amp;&amp; \<br/>    ln -s /usr/lib/julia-1.8.3/bin/julia /usr/bin/julia &amp;&amp; \<br/>    rm julia-1.8.3-linux-x86_64.tar.gz &amp;&amp; \<br/>    julia  -e "using Pkg;pkg\"add IJulia\""<br/><br/>ENV DEFAULT_KERNEL_NAME "julia-1.8"</span></pre><p id="97ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以从<a class="ae lh" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank">这个</a>页面把上面的更新到最新的 Julia 版本，但是在我写作的时候 1.8.3 是最新的版本。</p><p id="916f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Colab </strong></p><p id="9cad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于 colab，所有的下载和安装代码都必须包含在笔记本本身中，并且在安装代码运行后刷新页面。</p><p id="34a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">幸运的是，<a class="ae lh" href="https://github.com/ageron" rel="noopener ugc nofollow" target="_blank"> Aurélien Geron </a>在他的 GitHub 上为 colab 的 Julia 提供了一个<a class="ae lh" href="https://colab.research.google.com/github/ageron/julia_notebooks/blob/master/Julia_Colab_Notebook_Template.ipynb" rel="noopener ugc nofollow" target="_blank">入门笔记本</a>，这可能是最好的入门方式。</p><p id="57ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong> <em class="nw">如果你使用上面的“在 colab 中打开”按钮(或者我链接的库中以“Colab”结尾的 Julia 笔记本)，我已经在 Julia 笔记本中包含了这个起始代码。</em></p><h1 id="45f0" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">数据</h1><p id="2693" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">本文中使用的<a class="ae lh" href="https://www.kaggle.com/datasets/drgfreeman/rockpaperscissors" rel="noopener ugc nofollow" target="_blank">数据</a>是一组图像，描绘了游戏“石头剪子布”中手的三种可能位置组合。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/dafa860c0ec9b4d087956d2e3c39e9e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*GX_eTlI8tqLA3RddujhQxg.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">来自<a class="ae lh" href="https://www.kaggle.com/datasets/drgfreeman/rockpaperscissors" rel="noopener ugc nofollow" target="_blank">数据集</a>三个不同类别的四个例子。作者合成图像。</p></figure><p id="75be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个图像都是 PNG 类型，尺寸为 300(宽)像素 x 200(高)像素，全彩色。</p><p id="79c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">原始数据集总共包含 2188 幅图像，但是本文使用了一个更小的选择，它由三个类别中的每一个类别的 200 幅图像组成(总共 600 幅图像)。这主要是为了确保笔记本可以相对容易地运行，并且数据集是平衡的。</p><p id="9cd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文中使用的较小数据集可从以下网址获得:</p><div class="nx ny gp gr nz oa"><a href="https://github.com/thetestspecimen/notebooks/tree/main/datasets/rock_paper_scissors" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">笔记本/数据集/石头剪刀布主测试样本/笔记本</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">该数据集是对原始“石头剪刀布”数据集的选择，详见下面的参考资料部分…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ps l ol om on oj oo lb oa"/></div></div></a></div><h1 id="ac61" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">这个计划</h1><p id="319c" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">有两个独立的笔记本。一个是使用 TensorFlow 深度学习框架用 Python 编写的，另一个是用 Julia 编写的，利用了 Flux 深度学习框架。</p><p id="b9d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两个笔记本使用完全相同的原始数据，并将经历相同的步骤，最终得到一个经过训练的模型。</p><p id="9011" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然不可能在两个笔记本之间精确匹配方法论(如你所料)，但我已经尽力让它们尽可能接近。</p><h2 id="6a6e" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">大纲</h2><p id="4ee8" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">每个笔记本包括以下步骤:</p><ol class=""><li id="0166" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">从远程位置下载图像数据，并提取到本地存储</li><li id="caa0" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">从本地文件夹结构加载图像以备处理</li><li id="5a31" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">查看图像数据，并查看样本图像</li><li id="a35a" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">将数据分成训练/验证集</li><li id="cd89" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">增强训练图像以避免过度拟合</li><li id="7bf9" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">为模型准备图像(缩放等。)</li><li id="2f13" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">批量数据</li><li id="7f2b" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">创建模型和相关参数</li><li id="336b" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">火车模型(应该能使用 CPU 或 GPU)</li></ol><h1 id="bcac" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—包装</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/7c96b83a91e16ac2020803ee2d90be7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rLs3KeF8lYr78rEjhQE2-w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com/s/photos/packages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lh" href="https://unsplash.com/@fempreneurstyledstock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Leone Venter </a>拍摄的照片</p></figure><p id="2455" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来的比较部分将探索 Julia 与 Python 实现的一些差异(好的或坏的)。通常会按照上一节中的要点进行细分。</p><h2 id="64ff" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">软件包安装</h2><p id="65fe" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">首先，简单介绍一下软件包的安装和使用。</p><p id="52ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这两种语言遵循相似的模式:</p><ol class=""><li id="d826" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">确保软件包安装在您的环境中</li><li id="a6d0" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">将该包“导入”到您的代码中以使用它</li></ol><p id="def7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">唯一真正的区别是，Julia 既可以在运行代码之前在“环境”中安装包，也可以从代码内部安装包(如本文在 Julia 笔记本中所做的那样):</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="8622" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 中的“Pkg”相当于 Python 中的“pip”，也可以从 Julia 的命令行界面访问。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/caa5f82037c7b0728b8502ebd92289e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*tsOXIuTgqO1A0l1G9llQqg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用命令行添加包的示例。作者截图</p></figure><h2 id="fd86" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">包装使用</h2><p id="052f" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">就能够从代码中访问已安装的包而言，您通常会使用关键字“using”而不是 Python 中使用的“import”:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px pv l"/></div></figure><p id="11bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 也有一个“导入”关键字。有关差异的更多详细信息，请查看<a class="ae lh" href="https://docs.julialang.org/en/v1/manual/modules/#Standalone-using-and-import" rel="noopener ugc nofollow" target="_blank">文档</a>。在大多数一般用例中，“使用”更合适。</p><p id="74b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong> <em class="nw">在本文中，当引用模块中的方法时，我特意使用了完整路径，包括模块名。这不是必须的，它只是让我们更清楚地知道方法是从哪个包中被引用的。例如，这两个是等效的和有效的:</em></p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="6374" class="pm mm it pi b be pn po l pp pq">using Random<br/><br/>Random.shuffle(my_array) # Full path<br/><br/>shuffle(my_array) # Without package name</span></pre><h1 id="d3fc" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—下载和提取</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/a0f35c488c4e3f2015619f66beb94616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9X_nAgpVVIBLRkFnZPqUlQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">米格尔·Á的照片。<a class="ae lh" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素上的帕德里纳</a></p></figure><p id="fbe9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">图像数据以 zip 文件的形式远程提供。zip 文件包含三个类别的文件夹，每个文件夹包含 200 张图片。</p><p id="6f9e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一步，下载并提取图像文件。这在两种语言中都相对容易，有了可用的库，在 Julia 中可能更直观。Python 实现:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pz pv l"/></div></figure><p id="ce6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 实现<strong class="lk jd">会是什么样子</strong>会是什么样子:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="6b70" class="pm mm it pi b be pn po l pp pq">using InfoZIP<br/><br/>download("https://github.com/thetestspecimen/notebooks/raw/main/datasets/rock_paper_scissors/rock_paper_scissors.zip","./rock_paper_scissors.zip")<br/><br/>root_folder = "rps"<br/>isdir("./$root_folder") || mkdir("./$root_folder")<br/><br/>InfoZIP.unzip("./rock_paper_scissors.zip", "./$root_folder")</span></pre><p id="a6da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能会注意到，我说的是<strong class="lk jd">它可能是什么样子</strong>。如果你看一下笔记本，你会发现在 Julia 中，我实际上使用了一个自定义函数来进行解压缩，而不是使用上面详述的<a class="ae lh" href="https://juliapackages.com/p/infozip" rel="noopener ugc nofollow" target="_blank"> InfoZIP </a>包。</p><p id="97be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">原因是我无法在我使用的所有环境中安装 InfoZIP 包，所以我认为包含它是不公平的。</p><p id="eb85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是包装的问题吗？我想不会。我认为这可能是因为在线环境(colab 和 deepnote)主要不是面向 Julia 的，有时这会引起问题。InfoZIP 在本地安装并运行良好。</p><blockquote class="qa"><p id="8f5d" class="qb qc it bd qd qe qf qg qh qi qj md dk translated">这是包装的问题吗？我想不会。</p></blockquote><p id="b731" class="pw-post-body-paragraph li lj it lk b ll qk kd ln lo ql kg lq lr qm lt lu lv qn lx ly lz qo mb mc md im bi translated">我还应该注意，在 colab 中使用 GPU 实例时使用“Plots”库(相当于 matplotlib)会导致安装失败！</p><p id="0606" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可能看起来相对微不足道，但它直接说明了在处理一种新的语言时可能会遇到的潜在问题。此外，由于社区较小，你不太可能在网上找到问题的解决方案。</p><p id="70c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仍然值得指出的是，当我在本地的计算机上工作时，我对这两个包都没有这样的问题，我希望随着时间的推移，在线环境如 colab 和 deepnote 可能会变得更加 Julia 友好。</p><h1 id="7e88" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—处理图像</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qp"><img src="../Images/a7fe6da212c6a174127f9fe7f02cb9a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56I1EoPtXbfw6rsVPnApGg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@iwnxx?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊万·希姆科</a>在<a class="ae lh" href="https://unsplash.com/s/photos/photos?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="8163" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在图像已经在本地环境中，可以看看我们如何加载它们并与之交互。</p><p id="ce1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qq pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qr pv l"/></div></figure><p id="ee40" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">朱莉娅:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qs pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qt pv l"/></div></figure><p id="ad4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在前面的部分中，事情相对来说是相似的。现在事情开始出现分歧…</p><p id="d8cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个加载图像的简单示例突出了 Python 和 Julia 之间的一些明显差异，尽管从两个看起来相似的代码块中可能不会立即看出来。</p><h2 id="0a4d" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">零分度与一分度</h2><p id="cfe8" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一般来说，这两种语言的主要区别之一可能是，Julia 对数组和矩阵使用从 1 开始的索引，而不是从 0 开始。</p><p id="5173" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python —“随机 _ 图像”的第一个元素:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="6163" class="pm mm it pi b be pn po l pp pq">img = mpimg.imread(target_folder + "/" + random_image[0])</span></pre><p id="3d7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">朱莉娅——“图像通道”形状的第一个要素:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="59d1" class="pm mm it pi b be pn po l pp pq">println("Colour channels: ", size(img_channels)[1])</span></pre><p id="9d1d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我可以理解这是一个有争议的差异。在现实中，这一切都归结于偏好，但抛开任何个人偏好，1-indexing 在数学上更有意义。</p><p id="cedd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样值得记住的是这种语言所针对的工作领域(即更多基于数学/统计的编程专业人员，而不是纯粹的程序员/软件工程师)。</p><p id="b5f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不管你的立场如何，有一点是非常需要注意的，特别是如果你正在考虑将一个项目从 Python 移植到 Julia。</p><h2 id="29f2" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">图像是如何加载和用数字表示的</h2><p id="0f16" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">当使用 python 和“imread”加载图像时，它们被加载到一个 numpy 数组中，其形状(高度、宽度、RGB 颜色通道)为 float32 数字。很简单。</p><p id="4d35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Julia 中，图像被加载为:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="6aa1" class="pm mm it pi b be pn po l pp pq">Type: Matrix{RGB{N0f8}}</span></pre><p id="779d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不太清楚…所以让我们稍微探讨一下。</p><blockquote class="qu qv qw"><p id="97e3" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">在 JuliaImages 中，默认情况下，显示所有图像时假定 0 表示“黑色”，1 表示“白色”或“饱和”(后者适用于 RGB 图像的通道)。</p><p id="a6aa" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">也许令人惊讶的是，<strong class="lk jd">这种 0 到 1 的约定甚至在每个颜色通道仅使用 8 位对强度进行编码时也适用</strong>。JuliaImages 使用一种特殊的类型<code class="fe ra rb rc pi b">N0f8</code>，它将一个 8 位的“整数”解释为 1/255，从而以 256 步对 0 到 1 的值进行编码。</p><p id="864d" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">——<a class="ae lh" href="https://juliaimages.org/latest/tutorials/quickstart/" rel="noopener ugc nofollow" target="_blank">Juliaimages.org</a></p></blockquote><p id="b900" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实证明，Julia 使用的这种奇怪的约定实际上对机器/深度学习非常有帮助。</p><p id="f400" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 Python 中处理图像时，您经常要做的事情之一是将值缩放 1/255，以便所有值都在 0 和 1 之间。这对于 Julia 是不必要的，因为缩放是由图像本身使用的“N0f8”类型自动完成的！</p><p id="42e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不幸的是，您在本文中看不到这种比较，因为图像是 PNG 类型的，而且 Python 中的 imread 无论如何都将数组作为 0 到 1 之间的浮点值返回(顺便说一下，这是它唯一支持的格式)。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rd"><img src="../Images/92b8328c4fa59101a3ecf2eeef8ae087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hEQeKquRA3fyRDdSi6ehPA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">迈克尔·马森在<a class="ae lh" href="https://unsplash.com/s/photos/pixels?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3f5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果您要在 Python 中加载 JPG 文件，您将从 imread 接收 0 到 255 之间的整数值作为输出，并且必须在稍后的预处理管道中对它们进行缩放。</p><p id="7464" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了自动缩放，还有一点值得注意的是图像实际上是如何存储的。Julia 使用了将每个像素表示为一种对象的概念，因此如果我们查看输出类型和形状:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="191e" class="pm mm it pi b be pn po l pp pq">Type: Matrix{RGB{N0f8}}<br/>Shape: (200, 300)</span></pre><p id="c325" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">字面意思是 200x300 的矩阵。那三个颜色通道呢？我们期望 200x300x3，对吗？</p><p id="8df8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，Julia 将 200x300 矩阵中的每一项视为一个“像素”，在这种情况下，它有三个值，分别代表红色、绿色和蓝色(RGB)，如类型“<strong class="lk jd"> RGB </strong> {N0f8}”所示。我认为它就像一个对象矩阵，对象被定义为有三个变量。</p><p id="ef8a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，疯狂的背后是有原因的:</p><blockquote class="qu qv qw"><p id="7c66" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">这种设计选择有利于通用代码处理灰度和彩色图像，而无需引入额外的循环或检查颜色维度。它还为 3d 灰度图像提供了更合理的支持——3d 灰度图像的尺寸可能恰好为 3——因此有助于统一“计算机视觉”和“生物医学图像处理”社区。</p><p id="9eb9" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated"><a class="ae lh" href="https://juliaimages.org/latest/tutorials/quickstart/" rel="noopener ugc nofollow" target="_blank">-Julian images . org</a></p></blockquote><p id="ef42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">看起来这些决定是经过深思熟虑的。</p><p id="0ecc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，你不能将这种格式的图像输入到神经网络中，即使是 Flux 也不行，所以在以后的阶段需要将它分割成“合适的”3D 矩阵。正如你将看到的，事实证明这非常简单。</p><h1 id="31b4" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—数据准备管道</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi re"><img src="../Images/89705072cd0531af4cf52367fd402b79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwAzdScwyFi0RCm5J1vcew.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> JJ 英</a>在<a class="ae lh" href="https://unsplash.com/s/photos/pipeline?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3575" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就易用性而言，这绝对是 Python 和 TensorFlow 击败 Julia 的领域之一。</p><h2 id="4f47" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">Python 实现</h2><p id="eba4" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我可以或多或少地将我所有的图像加载到一个批量优化的数据集中，准备好投入到一个深度学习模型中，只需四行代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rf pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rf pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="6561" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">训练图像增强与模型层一样容易处理:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rg pv l"/></div></figure><h2 id="bb4e" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">Julia 实现</h2><p id="4a34" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在 Julia 中实现同样的功能需要更多的代码。让我们加载图像，并将它们分成训练集和验证集:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rh pv l"/></div></figure><p id="3b96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我应该注意的是，在现实中，您可以删除该方法的“加载和缩放”以及“洗牌”部分，并在以后以更简洁的形式处理它，因此它并不像看起来那么糟糕。我主要把这些部分作为参考。</p><p id="66f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Python 和 Julia 之间一个有用的区别是，如果你愿意，你可以定义类型，但这不是绝对必要的。一个很好的例子是上面函数中为“image_size”指定的“Tuple{Int，Int}”类型。这确保了整数总是被传递，而不必在函数本身中做任何特定的检查。</p><p id="32e1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">增强管道</strong></p><p id="1e21" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">图像增强非常简单，就像 TensorFlow 一样。由于 Augmentor 包，您还可以使用“Resize”层(前面提到的一种更简洁的形式)在这里添加图像大小调整:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ri pv l"/></div></figure><p id="7a96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您还应该注意到，Augmentor(使用 Julia 图像的包装)能够将“RGB{N0f8}”类型更改为 float32 类型的 3D 矩阵，以便传递到深度学习模型中:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rj pv l"/></div></figure><p id="37e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想将上面的三个步骤进行分解，因为我认为理解它们具体做什么是很重要的，因为我可以看到这可能会很混乱:</p><ol class=""><li id="1c9e" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><a class="ae lh" href="https://docs.juliahub.com/Augmentor/C7n2B/0.6.1/autodocs/#Augmentor.SplitChannels" rel="noopener ugc nofollow" target="_blank"> SplitChannels </a> —获取形状为 160(高)x 160(宽)的矩阵{RGB{N0f8}}的输入，并使用类型数组{N0f8}将其转换为 3(颜色通道)× 160(高)× 160(宽)。<strong class="lk jd">这里值得注意的是，颜色通道成为第一维，而不是像 python/numpy 中那样成为最后一维。</strong></li><li id="2df2" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><a class="ae lh" href="https://docs.juliahub.com/Augmentor/C7n2B/0.6.1/autodocs/#Augmentor.PermuteDims" rel="noopener ugc nofollow" target="_blank"> PermuteDims </a> —只是重新排列数组的形状。在我们的例子中，我们将输出的尺寸改为 160(宽)x 160(高)x 3(颜色通道)。<strong class="lk jd">注:</strong>高度和宽度的顺序也被调换了。</li><li id="951a" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><a class="ae lh" href="https://docs.juliahub.com/Augmentor/C7n2B/0.6.1/autodocs/#Augmentor.ConvertEltype" rel="noopener ugc nofollow" target="_blank">转换类型</a> —将 N0f8 转换为 float32。</li></ol><p id="41ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能想知道为什么维度需要如此多的转换。这样做的原因是由于在后面的阶段中需要将输入形状输入到通量中的<a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/models/layers/#Flux.Conv" rel="noopener ugc nofollow" target="_blank"> Conv 层</a>中。一旦我们完成了配料，我会更详细地介绍，因为这是我对整个过程的主要不满之一…</p><p id="5911" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">应用增强</strong></p><p id="8a68" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们有一个有趣的情况。我需要把增强管道应用到图像上。没问题！由于优秀的<a class="ae lh" href="https://evizero.github.io/Augmentor.jl/stable/interface/#Augmentor.augmentbatch!" rel="noopener ugc nofollow" target="_blank"> augmentbatch！()</a>增强器包提供的功能。</p><p id="0f03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了无论我如何努力，我都不能让它与数据一起工作。不断的错误(当我疯狂地试图找出一个解决方案时，忘记记下确切的问题，但在各种论坛上都有类似的问题)。</p><p id="dd2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总有可能这是我的错，我有点希望是这样！</p><p id="8855" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一种变通方法，我使用了一个使用“非批处理”方法<a class="ae lh" href="https://evizero.github.io/Augmentor.jl/stable/interface/#Augmentor.augment" rel="noopener ugc nofollow" target="_blank">增强</a>的循环。我还使用<a class="ae lh" href="https://github.com/FluxML/OneHotArrays.jl" rel="noopener ugc nofollow" target="_blank"> OneHotArrays </a>包对标签进行了一次性编码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rk pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rl pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rm pv l"/></div></figure><p id="33e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我认为这很好地说明了 Julia 生态系统的某些领域可能会给你带来一些实现上的麻烦。你也不一定能在网上找到解决方案，因为社区比较小。</p><p id="d2b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，Julia 的一个主要优势是，如果你不得不求助于像 for 循环这样的东西来解决问题，或者只是实现一点定制的需求，你可以相当肯定地说，你编写的代码将是优化的和快速的。不是每次使用 Python 都可以依赖的东西。</p><p id="a3c1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来自列车管道的一些示例增强图像:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rn pv l"/></div></figure><p id="ffd4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">批处理数据</strong></p><p id="a2c0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 中的批处理是 TensorFlow 级别的简单操作。在朱莉娅中，有多种方法可以做到这一点。在这种情况下，将使用 Flux 内置的<a class="ae lh" href="https://fluxml.ai/Flux.jl/v0.10/data/dataloader/#Flux.Data.DataLoader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ro pv l"/></div></figure><p id="98b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个方法没什么值得注意的。和罐头上写的一模一样。(正如我前面提到的，这是您可以混洗数据的另一个位置。)</p><p id="df99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们已经准备好将数据传递给模型，但是首先要稍微绕一下路…</p><h1 id="cd5f" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">混乱的输入形状</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rp"><img src="../Images/87f6041a5f767933d0e12c63e1d1f468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKzos3Gu3bHTOp4CBcjL6Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com/s/photos/confusing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@tdederichs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Torsten dede RICS</a>拍摄的照片</p></figure><p id="291c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我想回到模型的输入形状。您可以在上一节的最后一个代码块中看到数据集具有形状:</p><p id="fafd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nw">数据:160(宽)x 160(高)x 3(颜色通道)x 32(批次大小)<br/>标签:3(标签)x 32(批次大小)</em> </strong></p><p id="6688" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在 TensorFlow 中，输入形状为:</p><p id="93a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="nw">数据:32(批次尺寸)x 160(高度)x 160(宽度)x 3(颜色通道)<br/>标签:32(批次尺寸)x 3(标签)</em> </strong></p><p id="239a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">来自 Julia 文档:</p><blockquote class="qu qv qw"><p id="205a" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">图像数据应按 WHCN 顺序(宽度、高度、通道、批次)存储。换句话说，一个 100×100 的 RGB 图像将是一个<code class="fe ra rb rc pi b">100×100×3×1</code>数组，一批 50 个将是一个<code class="fe ra rb rc pi b">100×100×3×50</code>数组。</p><p id="1415" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">- <a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/models/layers/#Flux.Conv" rel="noopener ugc nofollow" target="_blank"> fluxml.ai </a></p></blockquote><p id="368f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我不知道为什么选择这个惯例，尤其是高度和宽度的切换。</p><p id="8f33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">坦白说，没什么好抱怨的，这只是一个惯例。事实上，如果根据以前的经验，我会怀疑一些经过深思熟虑的优化是原因。</p><p id="0a74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与其他语言相比，我在定义上遇到了一些稍微奇怪的变化，但我发现这是有真正原因的(正如你所希望的)。</p><p id="64ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个具体的(相关的)例子，以<a class="ae lh" href="https://juliaimages.org/" rel="noopener ugc nofollow" target="_blank">朱莉娅的图片</a>包为例。</p><blockquote class="qu qv qw"><p id="862b" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">我们使用 CHW(即通道-高度-宽度)顺序而不是 HWC 的原因是，这为<code class="fe ra rb rc pi b">Array</code>提供了一种记忆友好的索引机制。默认情况下，在 Julia 中，第一个索引也是最快的(即，在内存中有相邻存储)。更多细节，请参考性能提示:<a class="ae lh" href="https://docs.julialang.org/en/v1/manual/performance-tips/#Access-arrays-in-memory-order,-along-columns-1" rel="noopener ugc nofollow" target="_blank">按内存顺序访问数组，沿着</a>列</p><p id="8196" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">——<a class="ae lh" href="https://juliaimages.org/latest/tutorials/quickstart/" rel="noopener ugc nofollow" target="_blank">juliaimages.org</a></p></blockquote><h2 id="787e" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">额外的困惑</h2><p id="8b99" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这引出了我的一个主要抱怨。</p><p id="2509" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我可以接受这是一种不同的语言，所以有一个潜在的很好的理由来制定一个新的约定。然而，在加载图像并准备好插入深度学习模型的过程中，我不得不到处改变输入形状:</p><ol class=""><li id="6897" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">图像加载到:矩阵{RGB{N0f8}}(高 x 宽)</li><li id="9ed4" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">拆分通道:{N0f8}(通道 x 高度 x 宽度)</li><li id="59ae" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">移动通道<strong class="lk jd">和</strong>开关高度和宽度:{N0f8}(宽度 x 高度 x 通道)</li><li id="907a" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">转换为 float32</li><li id="57f3" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">Batchsize(作为最后一个元素):{float32}(宽度 x 高度 x 通道 x batchsize)</li></ol><p id="f199" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然,(通道 x 高度 x 宽度)对于图像来说是最理想的，这就是 native Julia 加载图像的方式。难道不是:</p><p id="3e23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(通道 x 高度 x 宽度 x 批次大小)？</p><p id="0bec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可能会省去很多潜在的困惑。</p><p id="2dfd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我真心希望有人能指出我愚蠢地忽略了一些东西(真的)。主要是因为我对设计这种语言时对细节和思想的关注印象深刻。</p><p id="51ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好的。抱怨够了。回到项目上。</p><h1 id="21a1" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—模型</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rq"><img src="../Images/9a409084b87da351e97987cd8087baa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-iTCZ3mH8KfXnLpIPXtg5g.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/photo/blue-volkswagen-beetle-scale-model-10215969/" rel="noopener ugc nofollow" target="_blank"> DS stories </a>在<a class="ae lh" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>上拍摄</p></figure><p id="929c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 中的模型定义与 TensorFlow 的顺序方法非常相似。它只是被称为<a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/models/layers/#Flux.Chain" rel="noopener ugc nofollow" target="_blank">链</a>而不是。</p><p id="95e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"/></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rr pv l"/></div></figure><p id="ac1a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">主要区别:</p><ol class=""><li id="1118" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">如果您想要使用它，您必须显式地将模型(和数据)加载到 GPU 上</li><li id="c9d8" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">你必须显式地指定输入和输出通道(input=&gt;output) — <em class="nw">我相信有</em> <a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/outputsize/#Shape-Inference" rel="noopener ugc nofollow" target="_blank"> <em class="nw">形状推理宏</em> </a> <em class="nw">能对此有所帮助，但我们不会在这里深入讨论</em></li></ol><p id="19c7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总而言之，使用起来非常直观。它还迫使您对数据如何在模型中移动和重塑有一个正确的理解。如果你问我，这是一次很好的练习。</p><p id="0a48" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有比黑箱系统更危险的了，也没有思考。我们当然都这样做，因为有时我们只是想尽快得到答案，但这可能会导致一些难以追踪和令人困惑的结果。</p><blockquote class="qa"><p id="c700" class="qb qc it bd qd qe qf qg qh qi qj md dk translated">没有比黑箱系统更危险的了，也没有思考。我们都这样做…</p></blockquote><h2 id="c94e" class="ou mm it bd mn ov rs dn mr ox rt dp mv lr ru pa mx lv rv pc mz lz rw pe nb iz bi translated">计算设备规格</h2><p id="a7ae" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在笔记本的代码中，您可以看到我通过使用变量“calc_device”明确定义了哪个设备(CPU 或 GPU)应该用于计算。</p><p id="1fb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将“calc_device”变量改为 gpu 将使用 gpu。将其更改为 cpu 以仅使用 cpu。你当然可以直接用 gpu 或者 cpu 替换所有的“calc_device”变量，工作方式完全一样。</p><h1 id="8d44" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—损耗、精度和优化器</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rx"><img src="../Images/37d7d7516ebdce9e448cfe2d7e7c2f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aq6oCGcWmTP1d-n8xKt7Zg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片来自<a class="ae lh" href="https://pixabay.com/users/quincecreative-1031690/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2886223" rel="noopener ugc nofollow" target="_blank"> 3D 动画制作公司</a>来自<a class="ae lh" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2886223" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="19cf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">同样，非常类似于张量流:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="px pv l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu pv l"/></div></figure><p id="b597" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有几件事值得注意:</p><h2 id="489c" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">逻辑交叉熵</h2><p id="cccd" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">你可能已经注意到模型没有 softmax 层(如果不是快速浏览)。</p><blockquote class="qu qv qw"><p id="7917" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">这在数学上等同于<code class="fe ra rb rc pi b">crossentropy(softmax(ŷ), y)</code>，但在数值上比单独使用函数<code class="fe ra rb rc pi b"><a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/models/losses/#Flux.Losses.crossentropy" rel="noopener ugc nofollow" target="_blank">crossentropy</a></code>和<a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/models/nnlib/#Softmax" rel="noopener ugc nofollow" target="_blank"> softmax </a>更稳定。</p><p id="6cf0" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">- <a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/models/losses/#Flux.Losses.logitcrossentropy" rel="noopener ugc nofollow" target="_blank"> fluxml.ai </a></p></blockquote><h2 id="5aed" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">onecold</h2><p id="d146" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">onehot 的反义词。很好的名字，不知道为什么有人以前没有想到。</p><h2 id="148c" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">单行函数定义</h2><p id="ff12" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如果你不熟悉 Julia，也值得指出的是，损失函数和精度函数实际上是一行中正确的函数定义。即与此相同:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="fd1c" class="pm mm it pi b be pn po l pp pq">function loss(X, y)<br/>  return Flux.Losses.logitcrossentropy(model(X), y)<br/>end</span></pre><p id="99dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">朱莉娅语言的许多伟大特征之一。</p><p id="9f5a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(注意:实际上你可以省略上面的 return 关键字。缩短函数的另一种方法。)</p><h1 id="79bf" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">比较—培训</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ry"><img src="../Images/f7469ccfb281097f0708c4bbfc57e09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5UkhRRQnPXBTOE5BdxHvCw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">维克多·弗雷塔斯在<a class="ae lh" href="https://unsplash.com/s/photos/training?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b40a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在朱莉娅，训练可以是复杂的，也可以是简单的。确实有很大的灵活性，在我将要向您展示的内容中，我甚至还没有触及它的表面。</p><p id="804f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想让它变得非常简单，在 TensorFlow 中有一个我称之为“model.fit”的等价物:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="fd33" class="pm mm it pi b be pn po l pp pq">for epoch in 1:10<br/>    Flux.train!(loss, Flux.params(model), train_batches, opt)<br/>end</span></pre><p id="7837" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没错，基本上就是一个 for 循环。您还可以添加一个回调参数来处理打印损失或准确性(这不会像 TensorFlow 那样自动完成)或提前停止等问题。</p><p id="e490" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，当处理大量数据(如图像)时，使用上述方法可能会导致问题，因为它需要将所有训练数据加载到内存中(本地或 GPU 上)。</p><p id="6713" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，以下函数允许将批处理一批一批地加载到 GPU(或 CPU 运行的内存)上。它还打印训练损失和准确度(所有批次的平均值)，以及整个认证数据集的认证损失。</p><p id="e9df" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">注意:</strong>如果验证集非常大，您也可以逐批计算验证损失/准确度，以节省内存。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="rz pv l"/></div></figure><p id="a4af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">实际上，它有两个循环:一个用于历元，一个内部循环用于批处理。</p><p id="a48a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的是:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="0742" class="pm mm it pi b be pn po l pp pq">x, y = device(batch_data), device(batch_labels)<br/>gradients = Flux.gradient(() -&gt; loss(x, y), Flux.params(model))<br/>Flux.Optimise.update!(optimiser, Flux.params(model), gradients)</span></pre><p id="f608" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是将一批数据加载到设备(cpu 或 gpu)上，并通过模型运行数据。</p><p id="8655" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有剩下的代码是统计数据的收集和打印。</p><p id="b847" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">比张量流更复杂，但不极端。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="sa pv l"/></div></figure><p id="f125" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…我们完成了。一次有趣的旅行。</p><h1 id="48b6" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">总结(和 TL；博士)</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sb"><img src="../Images/c2285dcc72c0fad1399369aac6aa9b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgGwp6aVG-WXPMXJh1WyTg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/photo/close-up-shot-of-a-text-on-a-green-surface-6980523/" rel="noopener ugc nofollow" target="_blank">安 H </a>在<a class="ae lh" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="8ce2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在文章的开头，我说过，除了速度之外，在决定一门语言与你已经使用的语言相比是否值得投资时，还有其他重要的衡量标准。我特别点名:</p><ol class=""><li id="5e36" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">句法</li><li id="0fc4" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">灵活性</li><li id="c411" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">库可用性/集成</li><li id="4e4e" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">证明文件</li><li id="87d1" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">社区支持</li></ol><p id="9160" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在经历了整个项目后，我认为总结一些发现可能是个好主意。请记住，这是基于我在为本文生成代码时的印象，仅仅是我的观点。</p><h2 id="5fa9" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">句法</h2><p id="6031" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我认为来自 Python 的语法非常相似，相对容易掌握，而且我认为在相当多的情况下，它甚至比 Python 更“高级”和更容易使用。</p><p id="25d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们先解决有争议的问题。是的，Julia 使用 1 索引数组而不是 0 索引数组。我个人更喜欢这样，但我怀疑会有很多人不喜欢。还有更细微的区别，比如数组切片包含了最后一个元素，这与 Python 不同。只是要小心一点！</p><p id="72ad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是有很多好东西…</p><p id="7ac9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，当使用函数时，你不需要冒号或 return 关键字。你甚至可以在不丢失代码含义的情况下创建一个简洁的行:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="413d" class="pm mm it pi b be pn po l pp pq"># this returns the value of calculation, no return keyword needed<br/>function my_func(x , y)<br/>      x * y + 2<br/>end<br/><br/># you can shorten this even further<br/><br/>my_func(x, y) = x * y + 2</span></pre><p id="b294" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意标准函数表达式中“end”的使用。这在 Julia 中被用作缩进无关紧要，在我看来这是一个巨大的进步。空格对制表符的传奇不适用于朱莉娅。</p><p id="5c9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">常见的 if-else 类型语句也可以用在非常简洁明了的单行语句中:</p><pre class="ks kt ku kv gt ph pi pj bn pk pl bi"><span id="7f17" class="pm mm it pi b be pn po l pp pq"># ternary - if a is less than b print(a) otherwise print(b)<br/><br/>(a &lt; b) ? print(a) : print(b)<br/><br/># only need to do something if the condition is met (or not met)? <br/># use short circuit evaluation.<br/><br/># if a is less than b print(a+b), otherwise do nothing<br/><br/>(a &lt; b) &amp;&amp; print(a+b)<br/><br/># if a is less than b do nothing, otherwise print(a+b)<br/><br/>(a &lt; b) || print(a+b) </span></pre><p id="3655" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我可能只是触及了表面，但已经给我留下了深刻的印象。</p><h2 id="84cf" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">灵活性</h2><p id="cfb7" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">我认为灵活性是朱莉娅真正擅长的。</p><p id="a497" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如我已经提到的，你可以像 Python 一样编写简洁明了的代码，但是如果你需要或者想要使用它们，也可以使用其他的特性。</p><p id="331c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一个也是最重要的可能是使用类型的选项，这在 Python 中是不可能的。尽管推断类型听起来是个好主意，但它们确实有各种缺点，比如使代码更难阅读和跟踪，以及引入难以跟踪的错误。</p><blockquote class="qa"><p id="4a6f" class="qb qc it bd qd qe qf qg qh qi qj md dk translated">在最有意义的时候灵活地指定类型是一种优秀的能力</p></blockquote><p id="6262" class="pw-post-body-paragraph li lj it lk b ll qk kd ln lo ql kg lq lr qm lt lu lv qn lx ly lz qo mb mc md im bi translated">在最有意义的时候灵活地指定类型是 Julia 的一个优秀能力。不过，我很高兴它没有被强制推行。</p><p id="d813" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Julia 也面向科学和数学社区。因此，在代码中使用 unicode 字符是一个非常有用的特性。我不太可能会用到它，但由于我来自数学/工程背景，我很欣赏它的包容性。</p><h2 id="e1c5" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">库可用性/一致性</h2><p id="e4b2" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这是一个有点混杂的包。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi sc"><img src="../Images/db0d5700e5da5be904b26debfa754c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fx9r5HES7x0RLetE8QA7PQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">在<a class="ae lh" href="https://unsplash.com/s/photos/library?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae lh" href="https://unsplash.com/@inakihxz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">伊尼基·德尔·奥尔莫</a>拍摄的照片</p></figure><p id="e916" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这篇文章使用了相当多的包。从 Flux 和 Images 等大型软件包，到 OneHotArrays 和 Augmentor 等定制软件包。</p><p id="e79f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总的来说，平均来说，它们没有达到 Python / TensorFlow 中的复杂程度、集成和易用性。做同样的事情需要更多的努力，你可能会发现更多的问题，遇到更多的矛盾。我对此并不感到惊讶，毕竟这是一个不太成熟的生态系统。</p><p id="937d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，通过简单的一行界面批量处理和优化数据的能力是 TensorFlow 的一个非常好的功能。事实上，您不必编写额外的代码来打印培训和验证损失/准确性也非常有用。</p><p id="c518" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，我认为朱莉娅的图书馆生态系统有足够的多样性和复杂性，可以真正做得更多。总的来说，这些包也可以很好地组合在一起。我不认为这是一个交易破坏者。</p><p id="0daf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">总结一下我在这篇文章中遇到的主要问题:</p><ol class=""><li id="d12e" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">我无法让软件包<a class="ae lh" href="https://juliapackages.com/p/infozip" rel="noopener ugc nofollow" target="_blank"> InfoZIP </a>在所有环境下一致安装</li><li id="0231" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">我拿不到<a class="ae lh" href="https://evizero.github.io/Augmentor.jl/stable/interface/#Augmentor.augmentbatch!" rel="noopener ugc nofollow" target="_blank">！augmentbatch() </a>函数来处理本文中的数据，这将是非常有用的</li><li id="a906" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">由于某种原因，在 JuliaImages 和 Flux 之间定义图像形状的方法有点混乱，这导致了大量的矩阵整形。这并不难，只是似乎没有必要。</li></ol><h2 id="663a" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">证明文件</h2><p id="e714" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">核心语言的文档是一个非常完整和可靠的来源。我建议的唯一一件事是，对于一些方法给出的例子可以更详细和多样一些。一个小的吹毛求疵，否则优秀的东西。</p><p id="819d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">超越核心语言，文档的细节和可用性会有所不同。</p><p id="5bc9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我对较大的包印象深刻，我想无论如何它几乎都是核心包。就这篇文章而言，那将是<a class="ae lh" href="https://juliaimages.org/stable/" rel="noopener ugc nofollow" target="_blank">Julian images</a>和<a class="ae lh" href="https://fluxml.ai/Flux.jl/stable/" rel="noopener ugc nofollow" target="_blank"> Flux </a>。我认为它们非常全面，我尤其喜欢强调为什么事情会以某种方式完成的努力:</p><blockquote class="qu qv qw"><p id="5c32" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">我们使用 CHW(即通道高度宽度)顺序而不是 HWC 的原因是，这为<code class="fe ra rb rc pi b">Array</code>提供了一种记忆友好的索引机制。默认情况下，在 Julia 中，第一个索引也是最快的(即，在内存中有相邻存储)。</p><p id="d771" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">——<a class="ae lh" href="https://juliaimages.org/stable/tutorials/quickstart/" rel="noopener ugc nofollow" target="_blank">juliaimages.org</a></p></blockquote><p id="534e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">随着包变得越来越小，文档通常都在那里，但是有点简洁。ZipFile 就是一个很好的例子。</p><p id="ab07" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然，通常包是开源的，托管在 Github 上，贡献通常是受欢迎的。正如 JuliaImages 所说:</p><blockquote class="qu qv qw"><p id="57ff" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">请帮助改进这份文档——如果有什么让你困惑，很可能你并不孤单。在你阅读的过程中很容易做到:只需点击上面的“在 GitHub 上编辑”链接，然后<a class="ae lh" href="https://help.github.com/articles/editing-files-in-another-user-s-repository/" rel="noopener ugc nofollow" target="_blank">直接在你的浏览器</a>中编辑文件。您的更改在永久生效之前会经过开发人员的审核，所以不要担心您是否会说错话。</p><p id="3031" class="li lj nw lk b ll lm kd ln lo lp kg lq qx ls lt lu qy lw lx ly qz ma mb mc md im bi translated">——<a class="ae lh" href="https://juliaimages.org/stable/" rel="noopener ugc nofollow" target="_blank">juliaimages.org</a></p></blockquote><h2 id="fb57" class="ou mm it bd mn ov ow dn mr ox oy dp mv lr oz pa mx lv pb pc mz lz pd pe nb iz bi translated">社区</h2><p id="482b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这个社区正是我所期望的，充满活力和热情，但比 Python/tensor flow 的要小得多。如果你需要查询的答案，尤其是更多定制的查询，你可能需要比平时更深入地挖掘 Google 和 StackOverflow 之类的东西。</p><p id="dd11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这显然会随着采用而改变，但幸运的是文档非常好。</p><h1 id="fe8f" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">结论</h1><p id="6567" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">总的来说，我认为 Julia 实际上是一种很好的语言。</p><p id="0500" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种语言的创造者试图把他们喜欢使用的语言的精华部分结合成一种超级语言，他们称之为 Julia。</p><p id="e985" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我看来，他们做得非常好。该语法确实易于使用和理解，但也可以包含高级和稍微晦涩的元素——这是一种非常灵活的语言。</p><p id="9acb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它也真的很快。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi rx"><img src="../Images/bfa02513fd1cfe6f441b1c6bd83eb9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CWkefGbl8IwOdIIaqF3qQQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com/users/wokandapix-614097/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1820039" rel="noopener ugc nofollow" target="_blank"> Wokandapix </a>来自<a class="ae lh" href="https://pixabay.com//?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=1820039" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="c225" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，可能会有一个轻微的学习曲线来转换你目前正在使用的语言，但同样，我不认为它会像你想象的那样严重。为了帮助您，Julia 的文档包括了对主要语言的详细比较:</p><div class="nx ny gp gr nz oa"><a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">与其他语言的显著区别</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">虽然 MATLAB 用户可能会觉得 Julia 的语法很熟悉，但 Julia 不是 MATLAB 的克隆。有主要的句法和…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">docs.julialang.org</p></div></div></div></a></div><p id="b41d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我看到的唯一缺点是，即使已经存在了 10 年，与竞争对手相比，它还是相对较新。这对文件和学习资源的质量和数量有直接影响。这似乎比大多数人愿意承认的对收养有更大的影响。金钱也有帮助，一如既往…但我没有数据来评论这种情况。</p><p id="cc0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">成为最好的产品或解决方案并不能保证成功和被广泛接受。现实世界不是这样的。</p><p id="9e71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…但是在了解了 Julia 的工作方式(即使是最基础的)之后，我真的希望更多的人看到它的潜力并加入进来。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="7e23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你觉得这篇文章有趣或者有用，记得关注我，或者<a class="ae lh" href="https://medium.com/@maclayton/subscribe" rel="noopener">注册我的时事通讯</a>来获取更多类似的内容。</p><p id="8be7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你还没有，你也可以考虑订阅媒体。你的会员费不仅直接支持我，也支持你所阅读的其他作家。你还可以完全不受限制地访问媒体上的每个故事。</p><p id="3b03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用我的推荐链接注册会给我一点回扣，对你的会员资格没有影响，所以如果你选择这样做，谢谢你。</p><div class="nx ny gp gr nz oa"><a href="https://medium.com/@maclayton/membership" rel="noopener follow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd jd gy z fp of fr fs og fu fw jc bi translated">加入我的介绍链接媒体-迈克克莱顿</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">阅读迈克·克莱顿(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">medium.com</p></div></div><div class="oj l"><div class="sd l ol om on oj oo lb oa"/></div></div></a></div><h1 id="3618" class="ml mm it bd mn mo op mq mr ms oq mu mv ki or kj mx kl os km mz ko ot kp nb nc bi translated">参考</h1><p id="cf02" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">[1]朱利安·德·拉·布鲁尔-特勒奥，<a class="ae lh" href="https://www.kaggle.com/datasets/drgfreeman/rockpaperscissors" rel="noopener ugc nofollow" target="_blank">石头剪子布图像</a> (2018)，卡格尔，许可证:<a class="ae lh" href="https://creativecommons.org/licenses/by-sa/4.0/" rel="noopener ugc nofollow" target="_blank"> CC BY-SA 4.0 </a></p></div></div>    
</body>
</html>