<html>
<head>
<title>An Introduction to Data Leakage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据泄漏介绍</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/an-introduction-to-data-leakage-f1c58f7c1d64#2022-02-14">https://towardsdatascience.com/an-introduction-to-data-leakage-f1c58f7c1d64#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b897" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对数据的粗心处理会破坏你的机器学习模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ade934fed9d8bbfa0ffc4630c74ad22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3SAjdl5WqdhZjDuYalk_Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://www.pexels.com/photo/photo-of-gray-faucet-2339722/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae ky" href="https://www.pexels.com/@jibarofoto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">路易斯·金特罗</a>的照片</p></figure><p id="1859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行机器学习任务时，维护数据卫生至关重要。</p><p id="b55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们对这个话题给予了很多关注，重点放在处理过时、不完整或不正确的数据的重要性上。毕竟，忽视数据的整洁会毁掉你建立可靠模型的机会。</p><p id="4b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，尽管对这一主题进行了大量的报道，却缺乏对数据卫生的一个巨大威胁的认识:数据泄漏。</p><p id="4c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们探讨什么是数据泄漏，它是如何发生的，以及如何防止它。</p><h2 id="23e8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数据泄露</h2><p id="2f0a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，让我们快速回顾一下训练集和测试集之间的关系。</p><p id="2797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">训练集</strong>是用于训练机器学习模型的数据子集，而<strong class="lb iu">测试集</strong>是用于测试模型的数据子集。简单吧？</p><p id="0aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对这种关系强调不够的是，训练数据需要完全独立于测试数据。测试集中的值应该与训练集中的值无关。</p><p id="da3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">数据泄露</strong>是使用训练数据以外的信息训练模型时出现的现象。它本质上违反了训练数据的独立性，并允许它被来自外部来源的信息所改变。</p><p id="4664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反过来，这可以通过提供误导性的评估指标来掩盖模型性能中的缺陷。如果您在这种情况下未能识别数据泄漏，您可能会误以为您的模型是健壮的，但在部署后发现它完全不可靠。</p><p id="98e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，确保在处理数据时不会无意中导致任何数据泄漏是非常重要的。</p><h2 id="0eb6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">数据泄露的例子</h2><p id="0437" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">就像厨师小心处理肉类和农产品以避免交叉污染一样，数据科学家必须正确处理他们的培训和测试集以避免数据泄露。</p><p id="77b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是，只要你小心谨慎，数据泄露是很容易避免的。消除它不需要编写额外的代码行。</p><p id="75e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坏消息是，您可能会犯一些看似无关紧要的错误，从而使您的项目暴露在数据泄露的风险之下。您的模型不会通知您此类错误，因此您需要保持警惕以避免它们。</p><p id="2ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来介绍几个可能导致数据泄露的错误。</p><h2 id="2404" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">1.不删除重复项</h2><p id="29b6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这是从一开始就危及你的项目的一个相当简单的方法。</p><p id="6773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果包含重复项，您将冒在定型集和测试集中出现相同记录的风险，从而消除两个数据子集之间的独立关系。</p><p id="7e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的解决方法是在将数据分成训练集和测试集之前删除重复的记录。</p><h2 id="b39b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">2.分割数据前的要素缩放</h2><p id="92db" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">特征缩放是预处理中的一个重要步骤，因为它可以确保模型不会偏向于某个特定的特征。</p><p id="dcdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，在将数据分成训练集和测试集之前，有时会错误地应用诸如标准化和规范化之类的特征缩放技术。这是一个错误，因为它允许测试数据的值影响训练数据的缩放方式。</p><p id="dec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征缩放需要在数据被分割后的发生<em class="mt">。在适当的特征缩放中，需要仅基于训练集中的值来缩放训练数据。之后，需要基于用于缩放训练数据的参数来缩放测试集。</em></p><h2 id="1287" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">3.拆分数据前的数据扩充</h2><p id="4bb8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">数据扩充是解决数据不平衡和增强模型性能的一种好方法。</p><p id="689a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它的有效性取决于您在训练模型时如何应用它。</p><p id="406e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据增强不只是凭空创造数据；它依靠真实数据和某些算法来生成人工记录。</p><p id="61a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对算法如何被用来创建合成数据感到好奇，请查看我的文章，其中我给出了SMOTE的概要，这是一种更流行的数据增强方法。</p><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/create-artificial-data-with-smote-2a31ee855904"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">用SMOTE创建人工数据</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">如何利用简单的算法来弥补数据的不足</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><p id="61cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自然，创建的人工数据的类型取决于输入这种算法的数据。在这个步骤中包括来自测试集的数据将不可避免地影响添加到训练集中的数据。</p><p id="d3d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，数据扩充只能在拆分数据后<em class="mt">进行。为了正确执行数据扩充，您为训练模型而生成的人工数据必须仅来自训练数据。</em></p><h2 id="6e65" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">个案研究</h2><p id="945c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了巩固到目前为止所学的一切，让我们通过一个快速的案例研究来应用我们所学的一切。我们将使用一个提供保险公司客户信息的数据集(无版权)。数据可以在<a class="ae ky" href="https://www.kaggle.com/arashnic/imbalanced-data-practice" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="5f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是数据集的预览。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/c1ab3f135c500b75e4bc9c3145e7addf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*KZ4XdnKwWy7zEra-8VX2hw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="9f09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标变量是“响应”，它代表一个客户是否有兴趣申请保险。</p><p id="4f92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们可以删除所有缺失值的记录，并用one-hot-encoding对分类变量进行编码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c52b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以用drop_duplicates()方法删除任何重复项，这样所有的客户机都是惟一的。请注意，这一步是在将数据分成训练集和测试集之前进行的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然已经处理了重复数据，我们可以将数据分成训练集和测试集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以使用sklearn的<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.MinMaxScaler.html" rel="noopener ugc nofollow" target="_blank"> MinMaxScaler </a>通过归一化来缩放特征。为了避免数据泄漏，最小最大缩放器应该首先转换训练数据，然后基于用于缩放训练数据的参数来转换测试数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以通过应用SMOTE来处理任何数据不平衡。在此之前，让我们看看当前的训练集和测试集有多不平衡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/e3c01a0f12e3b174c02bc142de1017a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*H3tIXbT_N06nyeQ7NJY43w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="a931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在训练集和测试集中有相当大的不平衡。</p><p id="9046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过使用SMOTE为训练数据生成人工记录来解决。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="1c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看现在的训练集和测试集有多不平衡。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/8907f7742639b51f0fc59732630812f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*tKurVlUZbT0cS8P0K6QjLQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码输出(由作者创建)</p></figure><p id="69df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于该步骤是在训练测试分割后<em class="mt">执行的，SMOTE仅使用训练数据创建人工数据。测试集在整个过程中未被触及，并且保持不平衡。</em></p><p id="4319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自始至终，我们对数据集应用了许多技术。然而，由于对训练集和测试集的小心处理，我们能够避免任何数据泄漏。</p><h2 id="dc19" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/625913d30b14cbbc2a38e72f277c424d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9x0sOBOSg3Cs4u8O"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普拉蒂克·卡蒂亚尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7898" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，避免数据泄露是非常简单的。</p><p id="1491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您注意到了，所有提供的示例都演示了当一个步骤在错误的时间执行时，而不是一起执行时，数据泄漏是如何发生的。</p><p id="69e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其随意执行预处理步骤而不注意顺序，不如事先规划好管道。这将使您能够检查每个步骤，并确保在整个过程中训练数据独立于测试数据。</p><p id="8045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我祝你在数据科学的努力中好运！</p><h2 id="03ae" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">参考</h2><ol class=""><li id="c6c3" class="ns nt it lb b lc mo lf mp li nu lm nv lq nw lu nx ny nz oa bi translated">莫比乌斯。(2022).从不平衡的保险数据中学习，第4版。2022年2月13日从<a class="ae ky" href="https://www.kaggle.com/arashnic/imbalanced-data-practice." rel="noopener ugc nofollow" target="_blank">https://www.kaggle.com/arashnic/imbalanced-data-practice.</a>检索</li></ol></div></div>    
</body>
</html>