<html>
<head>
<title>Running Faster than Ever Before</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跑得比以往任何时候都快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/running-faster-than-ever-before-afd1d213a3ae#2022-06-23">https://towardsdatascience.com/running-faster-than-ever-before-afd1d213a3ae#2022-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c1a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Python 3.11与Python 3.10和Julia 1.7相比表现如何？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3671128cc599ebca29b772732be6fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GoUDobCA1QlhrW0X"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">肯尼·埃利亚松在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="18d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">性能并不总是数据科学家优先考虑的事情。然而，随着我们手上的数据量不断增加，更快地完成计算不是很好吗？即将到来的Python 3.11版本被寄予厚望，因为与当前稳定的版本3.10相比，预计<a class="ae kv" href="https://docs.python.org/3.11/whatsnew/3.11.html" rel="noopener ugc nofollow" target="_blank">性能会提高10-60%</a>。我真的对这一声明很感兴趣，我想尝试一下我的应用程序的新版本，这些应用程序主要集中在蛋白质组学和质谱学上。</p><p id="2272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我关注了截至2022年6月的当前Python 3.10和3.11测试版的性能。与MS相关的函数包括从磁盘读取文本文件，对字符串和字典的操作，以及对<em class="ls"> numpy </em>数组的循环和操作。这些操作非常通用，因此这些函数的性能应该反映一般的性能趋势。</p><p id="c501" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们在这里谈论速度，我在想，我们为什么不也比较一下Python 3.11和<a class="ae kv" href="https://julialang.org/" rel="noopener ugc nofollow" target="_blank"> Julia </a>的性能。它是一种正在积极发展的编程语言，是专门为科学计算设计的，考虑到了可伸缩性和性能。Julia的语法与Python并没有太大的不同，这使得它对于希望进一步扩展其计算工具箱的数据科学家来说是一种非常有吸引力的语言。</p><p id="36b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望直接查看基准测试的结果，请随意跳到文章末尾的总结部分。</p><h2 id="17fd" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">设置</h2><p id="b88c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">这些测试已经在Kubuntu 22.04中用Python 3.10.4、Python 3.11 beta3和Julia 1.7.3运行过。最初，我在Jupyter笔记本上运行Python 3.10和Julia测试，然而，我在安装3.11测试版的所有必要依赖项时遇到了一些困难。因此，我通过运行脚本完成了对两个Python版本的测试。</p><p id="e231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码、笔记本和示例数据可以在<a class="ae kv" href="https://github.com/dev-ev/julia-vs-python-ms-scripting" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到。</p><h2 id="8ec6" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">读取和解析文本文件</h2><p id="8f61" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">第一个函数从光盘中读取一个文本文件，将MS数据解析到一个字典中，该字典包括文本字符串、数值和<em class="ls"> pandas </em> dataframes。函数<em class="ls"> load_mgf </em>的完整代码相当长，你可以在<a class="ae kv" href="https://github.com/dev-ev/julia-vs-python-ms-scripting/blob/main/mgf_read_match.py" rel="noopener ugc nofollow" target="_blank">的脚本</a>中找到。该函数转换一个纯文本文件，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="95cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个对象列表(字典)，每个代表一个质谱，包含文本、数字数据和一个<em class="ls">pandas</em>data frame<em class="ls">‘ms _ data’</em>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Github存储库中的示例文件包含1000个项目(光谱):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="beed" class="lt lu iq mu b gy my mz l na nb">1000</span></pre><p id="8c87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在库<a class="ae kv" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> timeit </em> </a>的帮助下，我们在Python的两个版本中重复运行这个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="f3b2" class="lt lu iq mu b gy my mz l na nb">Running version:<br/>3.10.4 (main, Apr  2 2022, 09:04:19) [GCC 11.2.0]<br/>Timing the load_mgf function:<br/>Mean time 251.7 ms, standard deviation 7.5 ms for 200 repeats</span><span id="2052" class="lt lu iq mu b gy nc mz l na nb">Running version:<br/>3.11.0b3 (main, Jun  1 2022, 23:49:29) [GCC 11.2.0]<br/>Timing the load_mgf function:<br/>Mean time 217.8 ms, standard deviation 8.6 ms for 200 repeats</span></pre><p id="78b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们观察到Python 3.11的处理时间减少了10%以上！这非常令人兴奋，因为我们不需要以任何方式更改代码就可以获得这种性能提升！</p><p id="056f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们<a class="ae kv" href="https://github.com/dev-ev/julia-vs-python-ms-scripting/blob/main/mgf_read_match.jl" rel="noopener ugc nofollow" target="_blank">在Julia </a>中实现相同的功能，尽可能地模仿Python函数的逻辑。使用<em class="ls"> @benchmark </em>，看看有多快:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="501a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Julia的性能证明在这个基准测试中得到证实，平均运行时间不到Python的一半！看起来很有希望！</p><h2 id="46b8" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">循环和字典操作</h2><p id="4d7c" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">下一个函数从列表中读取文本字符串，使用字典匹配字符，并计算相应值的总和。对于质谱分析人员来说，这个函数从列表中计算肽的质量。</p><p id="0ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们准备一个10，000个肽(字符串)的列表，每个肽由20个氨基酸残基(字符)组成，指定为单独的大写字母:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="3b34" class="lt lu iq mu b gy my mz l na nb">10000<br/>'FFKGSQDTGYTYFNFMSHFY'</span></pre><p id="ed42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用普通循环来计算列表中每个序列的质量。每个可能的残基对应一个数字质量值，我们可以使用字典来指定:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="17b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种更简洁的方法是使用<a class="ae kv" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> functools </em> </a>包中的<em class="ls"> reduce </em>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="009c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用两个版本的Python对函数进行基准测试:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="f3fc" class="lt lu iq mu b gy my mz l na nb">Running version:<br/>3.10.4 (main, Apr  2 2022, 09:04:19) [GCC 11.2.0]<br/>Timing the calculate_masses_loop function:<br/>Mean time 11.83 ms, standard deviation 0.97 ms for 200 repeats<br/>Timing the calculate_masses_reduce function:<br/>Mean time 24.15 ms, standard deviation 1.95 ms for 200 repeats</span><span id="ffca" class="lt lu iq mu b gy nc mz l na nb">Running version:<br/>3.11.0b3 (main, Jun  1 2022, 23:49:29) [GCC 11.2.0]<br/>Timing the calculate_masses_loop function:<br/>Mean time 7.90 ms, standard deviation 0.88 ms for 200 repeats<br/>Timing the calculate_masses_reduce function:<br/>Mean time 19.65 ms, standard deviation 1.72 ms for 200 repeats</span></pre><p id="ef57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python 3.11在基于循环的函数上快了49%！不幸的是，聪明的<em class="ls">calculate _ mass _ reduce</em>实现通常要慢得多，但是Python 3.11在这个函数上仍然比3.10版本快18%。</p><p id="2d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些计算应该在Julia中变得更快吗？让我们创建一个类似的循环函数，它将计算每个序列的质量，并在一个10，000长的序列列表上对其进行基准测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="44df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">令人惊讶的是，这个实现比Python中的函数慢多了！我们可以通过预先分配masses数组来优化代码，而不是在每次迭代中添加一个新的单元素数组。让我们看看这是否有所不同:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="eb8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两种实现在Julia中略有不同，但Python 3.11是这一轮的明显赢家！</p><h2 id="de05" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">数值数组上的运算</h2><p id="91ea" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">谈到Python中的数字运算，我们当然希望避免多级for循环和重复的if-else语句。因此，在实现一个用于处理大量实验质谱数据的函数时，我们将使用<em class="ls"> numpy </em>数组对逻辑进行矢量化。完整的功能<em class="ls"> find_matches </em>可以在脚本中找到<em class="ls"> </em> <a class="ae kv" href="https://github.com/dev-ev/julia-vs-python-ms-scripting/blob/main/mgf_read_match.py" rel="noopener ugc nofollow" target="_blank">。该算法的核心部分采用数值，作为<em class="ls"> pandas </em>系列<em class="ls"> s['ms_data']['m/z'] </em>引入，并对相应的<em class="ls"> numpy </em>数组执行一系列操作:</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="30bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用我们之前通过<em class="ls"> load_mgf </em>加载到内存中的1000 MS光谱对函数<em class="ls"> find_matches </em>进行基准测试。重复运行该函数，我们得到:</p><pre class="kg kh ki kj gt mt mu mv mw aw mx bi"><span id="c9a8" class="lt lu iq mu b gy my mz l na nb">Running version:<br/>3.10.4 (main, Apr  2 2022, 09:04:19) [GCC 11.2.0]<br/>Timing the find_matches function:<br/>Mean time 2.08 s, standard deviation 89.2 ms for 50 repeats</span><span id="25db" class="lt lu iq mu b gy nc mz l na nb">Running version:<br/>3.11.0b3 (main, Jun  1 2022, 23:49:29) [GCC 11.2.0]<br/>Timing the find_matches function:<br/>Mean time 2.07 s, standard deviation 26.0 ms for 50 repeats</span></pre><p id="b332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个版本的平均时间惊人地相似。也许，在3.11的测试版中，numpy代码没有太大的变化。这将是很有趣的，看看它是否会被修改。</p><p id="fb55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Julia中实现一个类似的函数，我们可以在数组<em class="ls">s[' ms _ data '][' m/z ']【T21]上重复上面Python代码中相同的操作。在Julia代码中，矢量化运算以点为前缀:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的基准测试结果显示，Julia中的函数比<em class="ls"> numpy </em>中快一倍，但这并不是终点。Julia允许将数组操作融合到一个循环中，避免分配临时的中间数组。融合操作以“at-dot”宏为前缀:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c48d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做了这一点小小的改变后，让我们对结果函数<em class="ls"> matchesfuse </em>进行基准测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="72f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">融合进一步削减了60%的运行时间！由此，Julia完全主导了数组操作基准测试，优化后的函数运行速度比Python/<em class="ls">numpy</em>analog快5倍！这个令人印象深刻的表演真的激励我，至少对我来说，投入更多的时间去研究朱莉娅。</p><h2 id="2480" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lf mc md me lj mf mg mh ln mi mj mk ml bi translated">摘要</h2><p id="59ae" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们在基本操作(循环、字符串操作、算术运算)和数值数组的计算中测试了Python 3.11 beta，所有这些都是在质谱数据的上下文中进行的。我们将3.11与当前的Python版本3.10.4以及最新的Julia 1.7.3进行了比较。测试结果汇总如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/5c0f46857ef9841d060891f4d275903e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*BloTSzCkwAgahGiZphl7uA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">质谱相关基准功能的运行时间总结。作者图片</p></figure><p id="3167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与Python 3.10相比，新的3.11在循环、字符串和字典操作等一般操作上提供了显著的性能提升，完成基准测试的速度提高了10–49%。与此同时，使用<em class="ls"> numpy </em>的计算在两个Python版本中花费的时间完全相同，而Julia在同一组数值计算的速度上提供了2到5倍的显著提升。然而，在Python中，使用循环和字典匹配的函数工作得更快，尤其是在新版本3.11中。</p></div></div>    
</body>
</html>