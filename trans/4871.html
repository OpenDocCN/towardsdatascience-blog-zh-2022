<html>
<head>
<title>The Best Methods for One-Hot Encoding Your Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一次性编码数据的最佳方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/the-best-methods-for-one-hot-encoding-your-data-c29c78a153fd#2022-10-29">https://towardsdatascience.com/the-best-methods-for-one-hot-encoding-your-data-c29c78a153fd#2022-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c1cd" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据准备</h2><div class=""/><div class=""><h2 id="002a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">onehotencode vs get _ dummies vs to _ category</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/2d9d43cf8436f01326318eee933cb3c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmiT8F1Rn7u7eoZCUaKc5Q.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://pixabay.com//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2326145" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a>的Gerd Altmann 提供</p></figure><p id="f45c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">在将数据输入机器/深度学习模型之前，对数据进行预处理是整个过程中最重要的阶段之一。如果没有经过适当预处理的数据，无论你的模型多么先进和巧妙，最终都将是低效和不准确的。</strong></p><p id="3996" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">对于独立分类数据来说，一种热编码可能是最常用的预处理方法，可确保模型能够公平、无偏见地解释输入数据。</strong></p><p id="ab0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">本文将探索使用一次性方法对分类数据进行编码的三种最常见的方法，并讨论为什么首先要使用这种技术。</strong></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f00b" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">介绍</h1><p id="0b8b" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">本文将对以下方法进行比较和讨论:</p><ul class=""><li id="9eb7" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><strong class="lk jd">熊猫</strong> — get_dummies()</li><li id="6efc" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">Scikit-Learn</strong>—OneHotEncoder()</li><li id="7a6b" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">Keras</strong>—to _ categorial()</li></ul><p id="37cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有方法基本上达到相同的结果。然而，它们以完全不同的方式进行，并且具有不同的特性和选项。</p><p id="a41e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，哪种方法最适合您的具体情况呢？</p><h1 id="b506" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">什么是一键编码？</h1><p id="0a8d" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在我们开始之前，我认为有必要先简单介绍一下为什么你会想使用这种方法。</p><p id="b66b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个热编码基本上是一种准备分类数据的方法，以确保机器学习/深度学习模型将类别视为彼此独立。</p><h2 id="7b9f" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">确凿的例子</h2><p id="ed1e" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">让我们举一个实际的例子来说明这个观点。我们有三个类别:</p><ul class=""><li id="759c" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">鸡肉</li><li id="2203" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">岩石</li><li id="cb00" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">枪</li></ul><p id="c3be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">他们之间没有任何关系，完全独立。</p><p id="7e27" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了将这些类别输入到机器学习模型中，我们需要将它们转化为数值，因为机器/深度学习模型无法处理任何其他类型的输入。那么如何最好地做到这一点呢？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi om"><img src="../Images/4dbefee1bf32df2d19b6404abdc2e232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-YNWKETx7HQlzAHOCkriIg.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一只逃跑的鸡。<a class="ae lh" href="https://unsplash.com/@tumbao1949?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">詹姆斯·温斯科特</a>在<a class="ae lh" href="https://unsplash.com/s/photos/chicken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="45ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最简单的方法是给每个类别分配一个编号:</p><ol class=""><li id="66d3" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md on no np nq bi translated">鸡肉</li><li id="ec97" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">岩石</li><li id="7b55" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md on no np nq bi translated">枪</li></ol><p id="8362" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法(称为顺序编码)的问题是，当数字一个接一个时，模型可以推断出类别之间的关系。</p><p id="70b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">枪比鸡重要是因为它的编号更高吗？鸡是半块石头吗？如果你有三只鸡，那和一把枪一样吗？</p><p id="f5af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果这些值是标签，如果模型输出的答案是1.5，那会怎么样呢？所有这些说法都是无稽之谈，但由于模型只看到数字，而不是我们看到的名字，因此推断这些东西对模型来说是完全可行的。</p><p id="4359" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了避免这种情况，我们需要将类别完全分开。这就是一键编码所实现的目标:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/835c174f582720d650529b00f6b4141e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*ucpQA-IsrY7PiWFkMtwzhA.jpeg"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">一个热点编码的例子——作者列表</p></figure><p id="6046" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些值只能是1或0(开或关)。1表示是那个东西，0表示不是。</p><p id="6502" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以在第一排你有一只鸡(没有石头也没有枪)，第二排有一块石头(没有鸡也没有枪)等等。由于这些值要么是开，要么是关，因此不可能以任何方式将一个与另一个相关联。</p><h1 id="d260" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">快速笔记</h1><p id="6ef8" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">在更详细地研究这三种方法之前，我只想指出，我将使用Colab的一种替代方法，我通常使用它来为本文提供代码。</p><p id="a62a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将使用的替代方案是<a class="ae lh" href="https://deepnote.com/" rel="noopener ugc nofollow" target="_blank"> deepnote </a>。它本质上与Colab相同，它让您可以在在线环境中运行Jupyter笔记本(有一些差异，我不会在这里深入讨论，但可以查看网站了解更多信息)。</p><p id="c661" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样做的主要原因是，为了演示本文中一些方法的最新特性，我需要访问Pandas 1.5.0(撰写本文时的最新版本)，而我似乎无法在Colab中实现这一点。</p><p id="3865" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，在deepnote中，我可以指定一个Python版本(在本例中是3.10)，还可以创建自己的requirements.txt来确保环境安装Pandas 1.5.0，而不是默认版本。</p><p id="334f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它还允许非常简单的从Jupyter笔记本直接嵌入到本文中(您将会看到)，这非常有用。</p><p id="b5c9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我仍然会像往常一样让笔记本在colab中可用，但是一些代码不会运行，所以请记住这一点。</p><h1 id="0cf2" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">数据</h1><p id="a354" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这些数据基本上与饮酒对考试成绩的影响有关。不是你需要记住的东西，但如果你感兴趣的话…</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi op"><img src="../Images/6a2ac9961d79b33ddfd5dd31ec55ba8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqsCrfit6lLrgUVWOZ3mEQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@viniciusamano?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">vini cius“amnx”Amano</a>在<a class="ae lh" href="https://unsplash.com/s/photos/alcohol?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="13b4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和以往一样，我把数据放在一个笔记本上。您可以在以下任一deepnote中访问它:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/2589425fa59ea0462fa60c913015d133.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*sq2nvEUbjhdd9bKo4QbsRw.png"/></div></figure><p id="4eb7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(如前所述，熊猫1.5.0已在deepnote中推出。只需在右边的“环境”部分激活Python 3.10，在右边的“文件”部分创建一个名为“requirements.txt”的文本文件，其中有一行“pandas==1.5.0”。然后运行笔记本。)</p><p id="8dda" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者colab:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://colab.research.google.com/github/thetestspecimen/notebooks/blob/main/one_hot_encoding_comparison.ipynb"><div class="gh gi oq"><img src="../Images/ab36cfbae94a8d3e5dd11db50b483d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*0rcFSSNzLLx1AuzpHApFuQ.png"/></div></a></figure><p id="bf8d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">(由于需要Pandas 1.5.0，下面的一些方法将不起作用)</p><p id="b138" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我选择了一个数据集，它包括各种不同的分类和非分类列，这样就可以很容易地看出每种方法是如何根据数据类型工作的。这些列如下所示:</p><ul class=""><li id="44a9" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><strong class="lk jd">性别</strong> —二进制字符串(“M”代表男性，“F”代表女性)</li><li id="3777" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">年龄</strong> —标准数值栏(int)</li><li id="6c79" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd"> Medu </strong> —母亲的教育程度—多类整数表示(0[无]，1[初等教育]，2 [五至九年级]，3[中等教育]或4[高等教育])</li><li id="b0f7" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd"> Mjob </strong> —母亲的工作—多类字符串表示—('教师'，'健康'保健相关，民事'服务'(如行政或警察)，'在家'或'其他')</li><li id="6dd0" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd"> Dalc </strong> —工作日酒精消耗量—多类分级整数表示(从1[非常低]到5[非常高])</li><li id="0215" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd"> Walc </strong> —周末饮酒量—多类分级整数表示(从1[非常低]到5[非常高])</li><li id="d5f5" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd"> G3 </strong> —最终成绩(标签)—多类分级整数表示(数字:从0到20)</li></ul><p id="d0e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">前五行的示例如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="ec67" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">和数据类型:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ot os l"/></div></figure><h1 id="bd84" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">熊猫—获取_假人()</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ou"><img src="../Images/07eea096d0e73bae18b66ffbbdc5a4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEVUf20GNVyFhXhtkil9KA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@millerthachiller?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">帕斯卡·米勒</a>在<a class="ae lh" href="https://unsplash.com/s/photos/panda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="752d" class="ob mm it ow b gy pa pb l pc pd">pandas.get_dummies(data, prefix=None, prefix_sep=’_’, dummy_na=False, columns=None, sparse=False, drop_first=False, dtype=None)</span></pre><p id="f4eb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="c589" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我会把Pandas的get_dummies()方法描述为一个非常中庸的一次性编码器。它让事情变得简单，同时提供合理数量的选项，允许您适应最常见的用例。</p><p id="3a49" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以非常简单地将Pandas dataframe传递给get_dummies()，它会计算出哪些列最适合一种热编码。</p><p id="8bec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，正如您将看到的那样，这并不是处理事情的最佳方式:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe os l"/></div></figure><p id="de1b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您查看上面的输出，您将看到只有类型为“Object”的列被一次性编码(sex和MJob)。任何整数数据类型列都被忽略了，这在我们的例子中并不理想。</p><p id="bef7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，您可以指定要编码的列，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe os l"/></div></figure><p id="61b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">需要注意的一点是，当使用get_dummies()时，它将所有内容都保存在dataframe中。没有额外的数组需要处理。它只是被整齐地保存在一个地方。OneHotEncoder()或to _ categorical()方法则不是这种情况，我们将在后续章节中讨论。</p><p id="111f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在某些特定情况下，删除每个热编码序列的第一列可能是可取或有用的(例如，为了避免多重共线性)。get_dummies()内置了这种能力:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe os l"/></div></figure><p id="a983" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，请注意上面的“Medu_0”现在是如何丢失的。</p><p id="9f7e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在的工作方式是，如果Medu_1到Medu_4都是零，这实际上意味着Medu_0(唯一的其他选择)被“选择”。</p><p id="034f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以前，当包含Medu_0时(即不使用drop_first)，绝不会出现所有值都为零的情况。因此，实际上通过删除列，我们不会丢失关于类别的任何信息，但是我们确实减少了列的总量，因此减少了运行模型所需的处理能力。</p><p id="59c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在决定删除一个专栏是否合适时，有更多微妙的事情需要考虑，但是由于这种讨论需要自己写一整篇文章，所以我将把它留给您来研究。</p><h2 id="d58f" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">附加选项</h2><p id="656f" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">除了“drop_first”之外，还有其他方法，如“sparse”来生成稀疏矩阵，以及“dummy_na”来帮助处理数据中可能存在的NaN值。</p><p id="a6c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您需要这种程度的灵活性，还可以对前缀和分隔符进行一些定制。</p><h2 id="b54f" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">用from_dummies()反转get_dummies()</h2><p id="b366" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">直到最近还没有从Pandas库中反转get_dummies()的方法。您必须手动完成这项工作。</p><p id="42f8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，从<strong class="lk jd"> Pandas 1.5.0 </strong>开始，有了一种叫做<strong class="lk jd"> from_dummies() </strong>的新方法:</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="2e9b" class="ob mm it ow b gy pa pb l pc pd">pandas.from_dummies(data, sep=None, default_category=None)</span></pre><p id="d813" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://pandas.pydata.org/docs/dev/reference/api/pandas.from_dummies.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="45f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这允许在不编写自己的方法的情况下实现反转。它甚至可以通过使用“default_category”参数来处理利用“drop_first”的一键编码的反转，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pf os l"/></div></figure><p id="afa2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要在编码中使用“drop_first”时进行反转，必须指定丢弃的项目:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pf os l"/></div></figure><h1 id="45b6" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">scikit-learn — OneHotEncoder()</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/f2ee08e471d1d2ea685b65f4434bad60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yw9qb30V48E6Zk4iUjP5ww.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae lh" href="https://unsplash.com/s/photos/learn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ef36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Scikit-Learn中的OneHotEncoder()方法可能是所有热编码方法中最全面的。</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="f748" class="ob mm it ow b gy pa pb l pc pd">sklearn.preprocessing.OneHotEncoder(*, categories='auto', drop=None, sparse=True, dtype=&lt;class 'numpy.float64'&gt;, handle_unknown='error', min_frequency=None, max_categories=None)</span></pre><p id="4a7d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="7000" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您所看到的，上面的方法输入可以处理:</p><ul class=""><li id="274b" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">为一个热门编码自动挑选类别</li><li id="e1c1" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">drop columns(不仅仅是第一种，还有更广泛的选择)</li><li id="65e8" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">生成稀疏矩阵</li><li id="29bf" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">处理可能出现在未来数据集中的类别(handle_unknown)</li><li id="33c7" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">您可以根据频率或最大类别数来限制编码返回的类别数量</li></ul><p id="13d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该方法还使用了fit-transform方法，这对于在机器和深度学习的输入管道中使用该方法非常有用。</p><h2 id="228e" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">编码器</h2><p id="26ef" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这种方法与所有其他方法的区别之一是，您创建了一个编码器“对象”，它存储了将用于编码数据的所有参数。</p><p id="1ff2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，这可以在代码的后面引用、重用和调整，使它成为一种非常灵活的方法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ph os l"/></div></figure><p id="3f99" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦编码器被实例化，我们就可以一次性编码一些数据:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pi os l"/></div></figure><p id="832a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，我使用了“fit_transform”方法，但与所有遵循“fit”/“transform”模式的sklearn方法一样，您也可以在单独的步骤中拟合和转换数据。</p><p id="c9ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">OneHotEncoder所做的是提取它认为应该一键编码的列，并将它们作为一个新数组返回。</p><p id="0328" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这与get_dummies()不同，后者将输出保存在同一个数据帧中。如果您想以最小的努力将所有数据包含在一个数据帧中，那么这是值得考虑的事情。</p><p id="70a2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还应该注意的是，OneHotEncoder在“auto”时识别更多get_dummies()的输入列，如下所示。</p><p id="250e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论如何，指定您希望作为目标的列仍然是一个很好的做法。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pj os l"/></div></figure><p id="6243" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了保持一致性，我将用get_dummies()对与前面相同的列进行编码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><p id="641e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">已编码的列，以及编码器的参数:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pl os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pm os l"/></div></figure><h2 id="c29f" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">反转OneHotEncoder</h2><p id="da49" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">有一个非常简单的方法来反转编码，因为编码器被保存为它自己的对象(在本例中为“skencoder”)，所以所有用于进行一次性编码的原始参数都保存在这个对象中。这使得反转非常容易:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pm os l"/></div></figure><h2 id="d0dc" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">其他有用信息</h2><p id="0a88" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">使用OneHotEncoder的另一个优点是，有大量的属性和帮助方法可以让您访问编码中使用的信息。我在下面提供了一些例子:</p><p id="a803" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">属性</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="po os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pp os l"/></div></figure><p id="56ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">方法</strong></p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pq os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pr os l"/></div></figure><h2 id="ca5c" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">高级功能</h2><p id="969f" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如前所述，OneHotEncoder有很多有用的特性，使它成为一种非常灵活的使用方法。</p><p id="be59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将在下面谈到其中的一些方法。</p><p id="a174" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">最小频率</strong></p><p id="5a6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以用来限制编码类别。如果你有一个由几个重要的类别主导的特性，但是有许多更小的类别，那么你可以有效地将这些更小的类别归入一个单独的“其他”类别。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ps os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pt os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="po os l"/></div></figure><p id="c401" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能会发现，您不想为不频繁的类别指定准确的记录数量。在这种情况下，您可以指定与可用记录总数相比的最小记录数。为此，您需要指定总计数的一部分。</p><p id="4ec3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我们的例子中有395条记录，所以为了达到与指定正好60条记录作为限制相同的结果，我们可以指定60 / 395 = 0.152，或者为了简单起见，指定0.16(这基本上意味着一个类别必须占总计数的16%才能被认为是重要的)</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pr os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pt os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="po os l"/></div></figure><p id="2087" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">最大类别数</strong></p><p id="9dad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">解决这个问题的另一种方法是指定类别的最大数量。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pu os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pr os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="po os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="po os l"/></div></figure><p id="9816" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">处理未知</strong></p><p id="adfb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">处理未知是一个非常有用的特性，尤其是在用于机器学习或神经网络模型的流水线中。</p><p id="0802" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本质上，它允许您在不中断输入管道的情况下，为将来可能出现的另一个类别制定计划。</p><p id="88d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，您可能有一个像“Medu”这样的特征，将来由于某种原因，在“高等教育”的最终类别之上的“PhD”类别被添加到输入数据中。理论上，这个额外的类别会破坏你的输入管道，因为类别的数量已经改变了。</p><p id="82ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">处理未知允许我们避免这种情况。</p><p id="cee3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然我不会给出一个具体的例子，但这很容易理解，尤其是如果你已经阅读了前两节关于“最大类别”和“最小频率”的内容。</p><p id="85d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">设置选项:</p><ul class=""><li id="f443" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><strong class="lk jd">【错误】</strong>:这只会引发一个错误，如果你试图添加额外的类别，你可以说这是标准行为</li><li id="aa23" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">【ignore】</strong>:这将导致任何额外的类别都被编码为全零，因此如果最初有3个类别[1，0，0]，[0，1，0]和[0，0，1]，那么额外的类别将被编码为[0，0，0]。反转后，该值将为“无”。</li><li id="7386" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">' incocrative _ if _ exist '</strong>:如果您已经在编码器中实现了' max_categories '或' min_frequency '，那么附加类别将与任何非频繁类别一起映射到' XXX _ incocrative _ sk learn '。否则，它将被完全视为“忽略”。</li></ul><p id="edd0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">重要提示:</strong>不能同时使用handle_unknown='ignore' <strong class="lk jd">和</strong>drop category参数(如drop: 'first ')。这是因为它们都产生全零的类别，因此冲突。</p><p id="6a4b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">下降</strong></p><p id="c54d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就像来自_dummies()的熊猫一样，你可以选择删除类别，尽管选项更广泛一些。</p><p id="f915" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以下是选项(根据文档):</p><ul class=""><li id="0aaf" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><strong class="lk jd">无</strong>:保留所有功能(默认)。</li><li id="1f34" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">‘第一’</strong>:在每一个功能里放第一个类别。如果只存在一个类别，该特征将被完全删除。</li><li id="187e" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">‘if _ binary’</strong>:将每个特征中的第一个类别，用两个类别进行拖放。具有1个或2个以上类别的特征保持不变。</li><li id="8f08" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><strong class="lk jd">数组</strong> : drop[i]是特征X[:，i]中应该被丢弃的类别。</li></ul><p id="115e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">重要提示:</strong>不能同时使用handle_unknown='ignore' <strong class="lk jd">和</strong>drop category参数(如drop: 'first ')。这是因为它们都产生全零的类别，因此冲突。</p><p id="e138" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="pv">【第一次】</em> </strong></p><p id="24a4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">每个类别的第一个条目将被删除(“sex_F”、“Medu_0”和“Mjob_at_home”)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pw os l"/></div></figure><p id="0aa5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"><em class="pv">【if _ binary】</em></strong></p><p id="3f2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只有恰好两个类别的特征会受到影响(在我们的例子中，只有‘sex _ F’被删除)。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pn os l"/></div></figure><p id="5fc6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> <em class="pv">【列阵】</em> </strong></p><p id="8223" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，您可以从每个要素中准确选择应该删除的类别。我们将删除“sex_M”、“Medu_3”和“Mjob_other”。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pt os l"/></div></figure><h1 id="872c" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">分类分类</h1><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/e6defddd923f484af9a852c68107c95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aq_K9xeBLdf9ZdXrDC4XVw.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">扬·安东宁·科拉尔在<a class="ae lh" href="https://unsplash.com/s/photos/sorting?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d192" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Keras方法是一个非常简单的方法，虽然它可以像其他方法一样用于任何事情，但是它只能处理数值。</p><p id="002d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，如果您有字符串类别，您必须首先转换它们，这是其他方法自动处理的事情。</p><pre class="ks kt ku kv gt ov ow ox oy aw oz bi"><span id="9725" class="ob mm it ow b gy pa pb l pc pd">tf.keras.utils.to_categorical(y, num_classes=None, dtype='float32')</span></pre><p id="2851" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/to_categorical" rel="noopener ugc nofollow" target="_blank">文档</a></p><p id="7900" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Keras to _ categorical()可能对一个标签的热编码最有用:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="py os l"/></div></figure><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><p id="d150" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面没有告诉我们太多，所以让我们挑出索引5处的转换，这样我们可以看到编码了什么:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pz os l"/></div></figure><h2 id="3514" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">反转</h2><p id="4c83" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">没有专门的反转方法，但是通常argmax应该允许我们反转编码。Argmax也可以从模型的输出中工作，其中的数字可能不是整数。</p><p id="5602" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">较小的示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa os l"/></div></figure><p id="780b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有数据:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="py os l"/></div></figure><h2 id="f558" class="ob mm it bd mn oc od dn mr oe of dp mv lr og oh mx lv oi oj mz lz ok ol nb iz bi translated">指定类别</h2><p id="e374" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">一个有用的特性是能够指定有多少独特的类别。默认情况下，类别的数量是数组中最大的数字+ 1。+1是考虑到零。</p><p id="792a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">值得注意的是，这是您可以指定的最小值。但是，可能有这样的情况，传递的数据不包含所有的类别，您仍然希望转换它(就像一小组测试标签)，在这种情况下，您应该指定类的数量。</p><p id="be27" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管该方法需要整数，但它可以按照下面的方式处理float数据类型。</p><p id="1907" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些是独特的类别:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pz os l"/></div></figure><p id="7f0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是唯一类的计数:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa os l"/></div></figure><p id="17f7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只有18个唯一的类，但是我们可以编码任意多的类，所以让我们编码30个类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pk os l"/></div></figure><p id="267d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后我们可以检查形状，看到我们有30个列/类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="qa os l"/></div></figure><p id="c8d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">…仍然可以顺利反转:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="py os l"/></div></figure><h1 id="8edc" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">摘要</h1><p id="b77d" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">概括来说:</p><p id="229d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">熊猫— get_dummies() </strong>:</p><ul class=""><li id="7b3f" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">在数据框架内创建一个热编码列，而不创建新矩阵。如果你喜欢用最少的努力把所有的东西都保存在一个熊猫的数据框架内，这可能是适合你的方法</li><li id="60bf" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">只有<strong class="lk jd">能自动</strong>将非数字列识别为分类数据吗</li><li id="f2b1" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">有一些有用的选项，比如稀疏矩阵和删除第一列</li><li id="c498" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">从熊猫1.5.0开始，内置了一个反转方法</li></ul><p id="169e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">Scikit-learn—OneHotEncoder():</strong></p><ul class=""><li id="4b71" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">设计用于管道，因此很容易集成到预处理工作流中</li><li id="548c" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">可以自动挑出一个热编码的类别，包括数字列</li><li id="32c0" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">drop columns(不仅仅是第一种，还有更广泛的选择)</li><li id="e891" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">生成稀疏矩阵</li><li id="1417" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">用于处理未来数据集中出现的类别的各种选项(handle_unknown)</li><li id="a619" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">您可以根据频率或最大类别数来限制编码返回的类别数量</li><li id="35c1" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">有许多帮助器方法和属性来跟踪您的编码和参数</li></ul><p id="a002" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">Keras—to _ categorial():</strong></p><ul class=""><li id="8781" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">一个非常简单的方法是只对数字数据进行热编码</li><li id="7483" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">必须首先将数据转换为有序数字类别</li><li id="3b8b" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">可能对标签最有用</li><li id="7813" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">没有内置的反转方法</li></ul><h1 id="a350" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">结论</h1><p id="ff09" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">总而言之，如果我必须推荐任何一种方法，那就是Scikit-Learn的<strong class="lk jd"> OneHotEncoder()。</strong></p><p id="c25f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可能会说这个方法太复杂了。然而，我认为这种方法使用起来非常简单，而且您最终会获得可追溯性和灵活性，这是其他任何方法都无法实现的。</p><p id="ba6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在考虑生产就绪代码时，将这种预处理方法与其他方法结合到处理管道中的能力以及handle_unknown等特性也是一个巨大的优势。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><p id="2f0a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你觉得这篇文章有趣或有用，记得关注我，或者<a class="ae lh" href="https://medium.com/@maclayton/subscribe" rel="noopener">注册我的简讯</a>获取更多类似的内容。</p><p id="8be7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你还没有，你也可以考虑订阅媒体。你的会员费不仅直接支持我，也支持你所阅读的其他作家。你还可以完全不受限制地访问媒体上的每个故事。</p><p id="3b03" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用我的推荐链接注册会给我一点回扣，对你的会员资格没有影响，所以如果你选择这样做，谢谢你。</p><div class="qb qc gp gr qd qe"><a href="https://medium.com/@maclayton/membership" rel="noopener follow" target="_blank"><div class="qf ab fo"><div class="qg ab qh cl cj qi"><h2 class="bd jd gy z fp qj fr fs qk fu fw jc bi translated">加入我的介绍链接媒体-迈克克莱顿</h2><div class="ql l"><h3 class="bd b gy z fp qj fr fs qk fu fw dk translated">阅读迈克·克莱顿(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="qm l"><p class="bd b dl z fp qj fr fs qk fu fw dk translated">medium.com</p></div></div><div class="qn l"><div class="qo l qp qq qr qn qs lb qe"/></div></div></a></div><h1 id="7abb" class="ml mm it bd mn mo nw mq mr ms nx mu mv ki ny kj mx kl nz km mz ko oa kp nb nc bi translated">参考</h1><p id="a458" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">[1] Aman Chauhan，<a class="ae lh" href="https://www.kaggle.com/datasets/whenamancodes/alcohol-effects-on-study" rel="noopener ugc nofollow" target="_blank">酒精对研究的影响</a> (2022)，Kaggle，许可:<a class="ae lh" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank">归属4.0国际(CC BY 4.0) </a></p><p id="fa02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[2] Paulo Cortez，<a class="ae lh" href="https://archive.ics.uci.edu/ml/datasets/student+performance" rel="noopener ugc nofollow" target="_blank">学生表现数据集</a> (2014)，UCI机器学习知识库</p><p id="0182" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[3] P. Cortez和A. Silva，<a class="ae lh" href="http://www3.dsi.uminho.pt/pcortez/student.pdf" rel="noopener ugc nofollow" target="_blank">使用数据挖掘预测中学生成绩</a> (2008)，A. Brito和J. Teixeira编辑。，第五届未来商业技术(FUBUTEC)会议论文集第5–12页，葡萄牙波尔图，2008年4月，EUROSIS，ISBN 978–9077381–39–7</p></div></div>    
</body>
</html>