<html>
<head>
<title>Python Pandas Tricks: 3 Best Methods To Join Datasets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python熊猫把戏:连接数据集的3种最佳方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-pandas-tricks-3-best-methods-4a909843f5bc#2022-05-17">https://towardsdatascience.com/python-pandas-tricks-3-best-methods-4a909843f5bc#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="191e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">计算机编程语言</h2><div class=""/><div class=""><h2 id="4df9" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">Python大师的merge、concat、join在你的咖啡时间！</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/6ede2746bbf5826641043792cb60e68a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lYR_5UijEE2BGe-x"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@miinyuii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Duy Pham </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4a3c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Python是数据分析的最佳工具包！</strong>🔋</p><p id="64e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">数据分析任务所需的数据通常来自多个来源。因此，学习整合这些数据的方法非常重要。</p><p id="b385" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我列出了使用Python pandas方法组合多个数据集的三种最佳且最省时的方法。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="17cc" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">merge()</strong>: To combine the datasets on common column or index or both.<br/><strong class="mf jd">concat()</strong>: To combine the datasets across rows or columns.<br/><strong class="mf jd">join()</strong>: To combine the datasets on key column or index.</span></pre><p id="caee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我把这篇文章写得很短，这样您就可以边喝咖啡边完成它，掌握最有用、最省时的Python技巧。</p><p id="79e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用下面的索引快速导航到您最喜欢的技巧。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="0798" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">· </strong><a class="ae lh" href="#1d6f" rel="noopener ugc nofollow"><strong class="mf jd">merge()</strong></a><strong class="mf jd"><br/>· </strong><a class="ae lh" href="#2a17" rel="noopener ugc nofollow"><strong class="mf jd">join()</strong></a><strong class="mf jd"><br/>· </strong><a class="ae lh" href="#a00b" rel="noopener ugc nofollow"><strong class="mf jd">concat()</strong></a></span></pre><blockquote class="mp mq mr"><p id="f7a1" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><em class="it">🚩</em>注意:我将使用我为练习创建的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_course_data.xlsx" rel="noopener ugc nofollow" target="_blank">虚拟课程数据集</a>。它可以在<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_course_data.xlsx" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到供您使用。我在整篇文章中使用熊猫。</p></blockquote><p id="695a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，我们开始吧…🚀</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="1fab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在开始之前，让我们使用下面的代码在dataframes中获取两个数据集— <strong class="lk jd"> <em class="ms"> df1 </em> </strong> ( <em class="ms">表示课程费用</em>)和<strong class="lk jd"> <em class="ms"> df2 </em> </strong> ( <em class="ms">表示课程折扣</em>)。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="e3d5" class="mj mk it mf b gy ml mm l mn mo">import pandas as pd<br/>df1 = pd.read_excel("Dummy_course_data.xlsx",<br/>                    sheet_name="Fees")<br/>df2 = pd.read_excel("Dummy_course_data.xlsx",<br/>                    sheet_name="Discounts")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/e01f443a64e7935acc5b9c8057dd8c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7G9iiFO5ktZc7HXGA8bow.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">示例数据集|按作者分类的图像</p></figure><p id="04b0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些是简单的7 x 3数据集，包含所有虚拟数据。</p><p id="81ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们使用pandas来探索结合这两个数据集的最佳方式。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="1d6f" class="ne mk it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated"><code class="fe nv nw nx mf b">merge</code></h1><p id="9ebb" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated"><code class="fe nv nw nx mf b">pandas.merge()</code>以数据库方式合并两个数据集，即数据帧在公共列或索引上连接🚦</p><p id="53e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果数据集与列上的列组合，DataFrame索引将被忽略。</p><p id="916d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要使用<code class="fe nv nw nx mf b"><strong class="lk jd"><em class="ms">merge()</em></strong></code>，你至少需要提供下面两个参数。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="0a6a" class="mj mk it mf b gy ml mm l mn mo">1. Left DataFrame<br/>2. Right DataFrame</span></pre><p id="f452" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，组合上述两个数据集，而不提及任何其他内容，例如，我们希望在哪些列上组合这两个数据集。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="87f7" class="mj mk it mf b gy ml mm l mn mo"><strong class="mf jd">pd.merge(df1,df2)</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi od"><img src="../Images/eed3dae9ac8d97510540e0d69d1fdf66.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*uqgSy8phTg8qWed0WZXPrw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫<code class="fe nv nw nx mf b">merge </code>默认设置|作者图片</p></figure><p id="b37e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nv nw nx mf b">pd.merge()</code>自动检测两个数据集之间的公共列，并在该列上组合它们。</p><p id="27f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下,<code class="fe nv nw nx mf b">pd.merge()</code>使用默认设置并返回一个最终数据集，该数据集只包含两个数据集的公共行。因此，这会导致内部连接。</p><p id="aa95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可能是合并两个数据集的最简单的方法。</p><p id="15f4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，<code class="fe nv nw nx mf b"><strong class="lk jd">merge()</strong></code>是定义合并行为的最灵活的选项。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f653a7097cfa229a04e203b53007c3b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*qUat6qz5nCPofPyfDaMsOw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫合并选项列表<code class="fe nv nw nx mf b"> </code> |作者图片</p></figure><p id="76c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然这个列表看起来很令人生畏，但是通过练习，你会掌握合并各种数据集。</p><p id="df63" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">目前，需要记住的重要选项是<code class="fe nv nw nx mf b"><strong class="lk jd">how</strong></code>，它定义了进行何种合并。此选项的其他可能值有— <code class="fe nv nw nx mf b">‘outer’ </code>、<code class="fe nv nw nx mf b">‘left’</code>、<code class="fe nv nw nx mf b">‘right’</code>。</p><p id="d8ac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我告诉你这是如何工作的。♻️</p><blockquote class="mp mq mr"><p id="0d32" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><strong class="lk jd"> how = 'outer' </strong></p></blockquote><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="574d" class="mj mk it mf b gy ml mm l mn mo">pd.merge(df1, df2, how='outer')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7648916b2257f945ec976e9ef6a1f955.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*0sH4HsgHO6Kb2bn8nzhcPQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><code class="fe nv nw nx mf b">pandas merge</code>外部连接|作者图片</p></figure><p id="6607" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个<code class="fe nv nw nx mf b">‘outer’</code>连接类似于SQL中的连接。它从两个数据集中返回匹配的行和不匹配的行。</p><p id="7d0f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一些单元格用<code class="fe nv nw nx mf b"><strong class="lk jd">NaN</strong></code>填充，因为这些列在两个数据集中没有匹配的记录。例如，对于课程<em class="ms">德语</em>、<em class="ms">信息技术</em>、<em class="ms">市场营销</em>，在<em class="ms"> df1 </em>中没有<em class="ms">费用_美元</em>值。因此，在合并后，<em class="ms"> Fee_USD </em>列将被这些课程的<code class="fe nv nw nx mf b">NaN</code>填充。</p><p id="09b6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于第二个数据集df2与df1在列Course和Country上有3行不同，合并后的最终输出包含10行。即<em class="ms"> df1 </em>的<em class="ms"> 7行</em>加上<em class="ms"> df2的<em class="ms"> 3行</em>。</em></p><p id="5593" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">✔️:在数据科学工作面试中经常会有这样的问题— <em class="ms">将数据集与外部连接组合后，输出中总共有多少行。上面提到的这一点可能是这个问题的最佳答案。</em></p><blockquote class="mp mq mr"><p id="f8be" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><strong class="lk jd">怎么= '左'</strong></p></blockquote><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="42fb" class="mj mk it mf b gy ml mm l mn mo">pd.merge(df1, df2, how='left')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/f31453707a790ecb63b1ac2e8408cc95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb7I32hHF0nZ9K4UYN1mHg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫<code class="fe nv nw nx mf b">merge </code>左加入|图片作者</p></figure><p id="9e8a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据定义，left join返回左侧数据帧中的所有行，并且只返回右侧数据帧中的匹配行。</p><p id="08b8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里发生了完全相同的情况，对于在<em class="ms"> Discount_USD </em>列中没有任何值的行，<code class="fe nv nw nx mf b">NaN</code>被替换。</p><p id="f276" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们看看使用<code class="fe nv nw nx mf b">right</code>连接的完全相反的结果。</p><blockquote class="mp mq mr"><p id="f82b" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><strong class="lk jd"> how = '右'</strong></p></blockquote><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="71c7" class="mj mk it mf b gy ml mm l mn mo">pd.merge(df1, df2, how='right')</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/b4159ce8e81caf0fbccb56318831e295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*344SfcB1Cm48QK_fmrNUdw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">熊猫<code class="fe nv nw nx mf b">merge </code>右加入|作者图片</p></figure><p id="80ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">右连接返回右数据帧即<em class="ms"> df2 </em>的所有行，并且只返回左数据帧即<em class="ms"> df1 </em>的匹配行</p><p id="8f29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe nv nw nx mf b">how = ‘left’</code>也可以得到相同的结果。你需要做的只是将<code class="fe nv nw nx mf b">pd.merge()</code>中提到的数据帧的顺序从<code class="fe nv nw nx mf b">df1, df2</code>改为<code class="fe nv nw nx mf b">df2, df1</code>。</p><p id="739a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最终输出中各列的✔️ ️The顺序将根据您在<code class="fe nv nw nx mf b">pd.merge()</code>中提到数据帧的顺序而改变</p><blockquote class="mp mq mr"><p id="5417" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><strong class="lk jd">左_开</strong>和<strong class="lk jd">右_开</strong></p></blockquote><p id="df9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想要合并两个具有不同列名的数据集，即列本身具有相似的值，但两个数据集中的列名不同，则必须使用此选项。</p><p id="f87f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以在<code class="fe nv nw nx mf b">left_on</code>中提及左侧数据集的列名，在<code class="fe nv nw nx mf b">right_on</code>中提及右侧数据集的列名。</p><p id="f3ec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在这里  进一步探索熊猫<code class="fe nv nw nx mf b">merge() </code> <a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.merge.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> <em class="ms">下的所有选项。🌍</em></strong></a></p><p id="abfc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在他的文章<a class="ae lh" rel="noopener" target="_blank" href="/why-and-how-to-use-merge-with-pandas-in-python-548600f7e738"> <strong class="lk jd">中，Admond Lee </strong></a>已经很好地解释了所有的熊猫<code class="fe nv nw nx mf b">merge()</code>用例为什么以及如何在Python中使用与熊猫的合并  <strong class="lk jd">。</strong></p><p id="f966" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有更简单的熊猫<code class="fe nv nw nx mf b">merge()</code>的实现，你可以在下面看到。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="2a17" class="ne mk it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated"><code class="fe nv nw nx mf b">Join</code></h1><p id="f5dd" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">与pandas模块中的函数<code class="fe nv nw nx mf b">merge()</code>不同，<code class="fe nv nw nx mf b">join()</code>是一个在数据帧上操作的实例方法。这使得我们可以灵活地只提及一个数据帧来与当前数据帧组合。</p><p id="79d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实上，<code class="fe nv nw nx mf b">pandas.DataFrame.join()</code>和<code class="fe nv nw nx mf b">pandas.DataFrame.merge()</code>被认为是访问<code class="fe nv nw nx mf b">pd.merge()</code>功能的便捷方式。因此它没有<code class="fe nv nw nx mf b">merge()</code>本身灵活，提供的选项也很少。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/3adfa8ddabff88084a9086874ed6c0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ufGd1KRKVujZRvePnVhpg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">作者图片</p></figure><p id="6b6c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在join中，只有<code class="fe nv nw nx mf b">‘other’</code>是必需的参数，它可以取单个或多个数据帧的名称。因此，您可以灵活地在单个语句中组合多个数据集。💪🏻</p><p id="56d1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">比如，我们用<code class="fe nv nw nx mf b"><strong class="lk jd">join()</strong></code>把<em class="ms"> df1 </em>和<em class="ms"> df2 </em>组合起来。由于这两个数据集具有相同的列名课程和国家，我们也应该使用<code class="fe nv nw nx mf b"><strong class="lk jd">lsuffix</strong></code>和<code class="fe nv nw nx mf b"><strong class="lk jd">rsuffix</strong></code>选项。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="a38f" class="mj mk it mf b gy ml mm l mn mo">df3 = df1.join(df2,<br/>               lsuffix = '_df1',<br/>               rsuffix = '_df2')<br/>df3</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ol"><img src="../Images/9f740a4ec71fe035cd2ecf14329036f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1jCT_ji_uadHsZR49YnXQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用pandas DataFrame <code class="fe nv nw nx mf b">join </code> |作者图片合并索引上的两个数据集</p></figure><p id="4140" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据定义，<code class="fe nv nw nx mf b"><em class="ms">join()</em> </code>在索引上组合两个数据帧(默认为<em class="ms">)这就是为什么输出包含来自两个数据帧的所有行&amp;列。</em></p><p id="77ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">✔️如果您想使用公共列— <em class="ms"> Country </em>连接两个数据框架，您需要将<em class="ms"> Country </em>设置为<em class="ms"> df1 </em>和<em class="ms"> df2 </em>中的索引。可以像下面这样做。</p><blockquote class="mp mq mr"><p id="faf9" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated">为了简单起见，我将<code class="fe nv nw nx mf b">df1</code>和<code class="fe nv nw nx mf b">df2</code>分别复制到<code class="fe nv nw nx mf b">df11</code>和<code class="fe nv nw nx mf b">df22</code>中。</p></blockquote><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="1951" class="mj mk it mf b gy ml mm l mn mo">df11 = df1.copy()<br/>df11.set_index('Course', inplace=True)</span><span id="56ee" class="mj mk it mf b gy om mm l mn mo">df22 = df2.copy()<br/>df22.set_index('Course', inplace=True)</span></pre><p id="5880" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码块将使列<em class="ms"> Course </em>成为两个数据集中的索引。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="0ab5" class="mj mk it mf b gy ml mm l mn mo">df4 = df11.join(df22,<br/>                lsuffix = '_df1',<br/>                rsuffix = '_df2',<br/>                on='Course')<br/>df4</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/27d1580d882841494bf74e5e321541df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNdbH4kq38MO2Etc2nFjbA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用pandas <code class="fe nv nw nx mf b">DataFrame join() </code> |作者图片在公共列上组合数据框架</p></figure><p id="4599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上所示，生成的数据帧将把<em class="ms">国家</em>作为其索引。</p><blockquote class="mp mq mr"><p id="372d" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><em class="it">🚩</em>注意:<code class="fe nv nw nx mf b">pandas.DataFrame.join()</code>默认返回“左”连接，而<code class="fe nv nw nx mf b">pandas.DataFrame.merge()</code>和<code class="fe nv nw nx mf b">pandas.merge()</code>默认返回“内”连接。</p></blockquote><blockquote class="oo"><p id="e752" class="op oq it bd or os ot ou ov ow ox md dk translated">在合并和加入❓❓之间感到困惑</p></blockquote><p id="9774" class="pw-post-body-paragraph li lj it lk b ll oy kd ln lo oz kg lq lr pa lt lu lv pb lx ly lz pc mb mc md im bi translated">看看<a class="ae lh" rel="noopener" target="_blank" href="/pandas-join-vs-merge-c365fd4fbf49#:~:text=We%20can%20use%20join%20and,join%20on%20for%20both%20dataframes."> <strong class="lk jd">熊猫加入vs .合并</strong> </a> <strong class="lk jd"> </strong>作者<a class="oi oj ep" href="https://medium.com/u/840a3210fbe7?source=post_page-----4a909843f5bc--------------------------------" rel="noopener" target="_blank">饶彤彤</a>他非常好地描述了这些工具之间的区别，并解释了何时使用什么。</p><p id="8a8b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">转到合并数据集的最后一种方法..</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="a00b" class="ne mk it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">串联</h1><p id="665e" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">Concat函数沿行或列连接数据集。因此，当在索引上对齐时，它只是将多个数据帧堆叠在一起。📚</p><p id="e149" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它还提供了一系列选项来提供更大的灵活性。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pd"><img src="../Images/7bd7f4957d9d178f1d8bb111a5aa9e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg3QhwZMfOaI1lflyZxacg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://pandas.pydata.org/docs/reference/api/pandas.concat.html" rel="noopener ugc nofollow" target="_blank">pandas.pydata.org提供的信息</a></p></figure><p id="fc5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只有<code class="fe nv nw nx mf b">‘objs’</code>是必需的参数，您可以传递要组合的数据帧列表，作为<code class="fe nv nw nx mf b">axis = 0</code>，数据帧将沿行组合，即它们将一个叠一个，如下所示。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="37e8" class="mj mk it mf b gy ml mm l mn mo">pd.concat([df1, df2])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pe"><img src="../Images/eae65b0399c6608dbfa983cdb40619d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SWySPK5C4jwIZHmwhV0Tw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用作者提供的【T2 |图片】合并两个数据集</p></figure><p id="2698" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与基于公共列中的值组合数据帧的<code class="fe nv nw nx mf b">pandas.merge()</code>不同，<code class="fe nv nw nx mf b">pandas.concat()</code>只是将它们垂直堆叠。数据帧中不存在的列用<code class="fe nv nw nx mf b">NaN</code>填充。</p><p id="7175" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">两个数据集也可以通过制作<code class="fe nv nw nx mf b">axis = 1</code>并排堆叠，如下所示。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="c620" class="mj mk it mf b gy ml mm l mn mo">pd.concat([df1,df2], axis=1)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/90265238973b99a310ec29a12ec369b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*4o8-xGjB1zkKhrHdzICxdQ.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用concat | Image by Author并排连接两个数据集</p></figure><p id="37b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单吧？？但是等等，</p><blockquote class="mp mq mr"><p id="9611" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated">我怎么知道哪个数据来自哪个数据框架❓</p></blockquote><p id="3c95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这时，分层索引开始出现，<code class="fe nv nw nx mf b">pandas.concat()</code>通过选项<code class="fe nv nw nx mf b">keys</code>为它提供了最佳解决方案。你可以如下使用它，</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="0db6" class="mj mk it mf b gy ml mm l mn mo">pd.concat([df1,df2], axis=1,<br/>          keys = ["df1_data","df2_data"])</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/d4bc603d04b5679e3a58fee884fe8e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*yKP-d6J1yMXtbEAwJgQGRg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用concat | Image by Author的分层索引</p></figure><p id="a444" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种数据标记实际上使得提取对应于特定数据帧的数据变得容易。✔️</p><blockquote class="mp mq mr"><p id="0567" class="li lj ms lk b ll lm kd ln lo lp kg lq mt ls lt lu mu lw lx ly mv ma mb mc md im bi translated"><em class="it">🚩</em>注意:键中标签的顺序必须与<code class="fe nv nw nx mf b">pandas.concat()</code>第一个参数中数据帧的写入顺序相匹配</p></blockquote><p id="c5dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">仅此而已！！😎</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="616f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望你喝着咖啡读完这篇文章，发现它超级有用，令人耳目一新。我使用Python已经有4年了，我发现这些组合数据集的技巧非常省时，而且在一段时间内非常有效</p><p id="5648" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以通过<a class="ae lh" href="https://medium.com/@17.rsuraj/membership" rel="noopener"> <strong class="lk jd">成为中级会员</strong> </a>来探索中级物品。相信我，你可以<strong class="lk jd">在Medium和每日有趣的Medium digest上获得无限的</strong>故事。当然，你的费用的一小部分会作为支持给我。🙂</p><p id="f608" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">别忘了在我的电子邮件列表 中注册<a class="ae lh" href="https://medium.com/subscribe/@17.rsuraj" rel="noopener"> <strong class="lk jd">来接收我文章的第一份拷贝。</strong></a></p><p id="613c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">感谢您的阅读！</strong></p></div></div>    
</body>
</html>