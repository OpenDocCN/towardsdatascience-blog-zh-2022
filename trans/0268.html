<html>
<head>
<title>Recurring Concerns Concerning Recursions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反复出现的关于复发的问题</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recurring-concerns-concerning-recursions-2f89ac5e5f87#2022-02-10">https://towardsdatascience.com/recurring-concerns-concerning-recursions-2f89ac5e5f87#2022-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="103a" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Python中时髦的编程</h2><div class=""/><div class=""><h2 id="e97f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">“跳出循环”</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/77541643704361e366f986b47e3beb31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wWIontt069vCuwjYxkJdgw.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">尼古拉斯·古雷威奇的《怪异的漩涡》。面板左侧的源。[经许可使用]</p></figure><p id="e751" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">如果你跳过了处理树遍历的CS课程，或者你不明白如何使用Dijkstra算法提取从A到B的最短路径，你可能已经搜索过递归了。我假设你已经阅读了前2个搜索结果中的内容。</p><p id="40b5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">所以，我将试着用我自己的话来解释如何轻松地处理递归，以及为什么你不应该这么做。之后我们会有一些分形的乐趣。</p><h1 id="0456" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">循环的黑暗面</h1><p id="264a" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">为了开始运行，我们可以把递归想象成一个循环。或者我们可以把循环想象成递归。不管怎样，他们都有一些相似之处。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/536ac5e9cce9199c092e6b1f884aa7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoCpVeJpIaQFAFNylw8buw.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">循环和递归的相似性[图片来自作者]</p></figure><p id="4ad0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">显然，在满足某个条件之前，会重复执行一些操作。有一个条件可以停止重复，然后会有一些行动。</p><p id="daac" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">递归函数通常调用自己作为重复动作的一部分，常规循环没有这种行为。尽管如此，许多常规循环可以写成递归，我很乐意演示:</p><h2 id="f5b3" class="my mb iq bd mc mz na dn mg nb nc dp mk ln nd ne mm lr nf ng mo lv nh ni mq iw bi translated">谦逊的重复</h2><p id="fdba" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">为了成功地创建一个简单的递归函数，我将遵循以下框架:</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="d723" class="my mb iq nk b gy no np l nq nr"><strong class="nk ja">recursive_function:</strong></span><span id="8cca" class="my mb iq nk b gy ns np l nq nr"><strong class="nk ja">    end_case:<br/>        do something before ending<br/>        end</strong></span><span id="c00b" class="my mb iq nk b gy ns np l nq nr"><strong class="nk ja">    normal_case:<br/>        do something before calling the function again<br/>        recursive_function</strong></span></pre><p id="5a4d" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，假设我们想重复某个动作X次。for循环在适当的位置自然流动:</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="81ca" class="my mb iq nk b gy no np l nq nr">for i in range(X):<br/>    repeated_action</span></pre><p id="04a0" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">和递归函数，遵循前面提到的框架:</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="361f" class="my mb iq nk b gy no np l nq nr">def recursive_iteration(X, counter=0):<br/>    <br/>    #end_case:<br/>    if counter == X-1:<br/>        return<br/>    <br/>    #normal_case:<br/>    repeated_action<br/>    recursive_iteration(X, counter+1)</span></pre><blockquote class="nt nu nv"><p id="1e2a" class="le lf nw lg b lh li ka lj lk ll kd lm nx lo lp lq ny ls lt lu nz lw lx ly lz ij bi translated">不那么光滑…等到我们开始增加它的实用性…</p></blockquote><h2 id="c043" class="my mb iq bd mc mz na dn mg nb nc dp mk ln nd ne mm lr nf ng mo lv nh ni mq iw bi translated">总和</h2><p id="b133" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">假设我们想要从0到x的所有整数的和。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/3c96accf6c1ce65c35419f6413731025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*3BrE1wh0sFiyetskYpSVCQ.jpeg"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">我向你呈现；从0到X的所有整数之和[图片由作者提供]</p></figure><p id="c766" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">令人钦佩的For循环:</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="0c90" class="my mb iq nk b gy no np l nq nr">sum = 0<br/>for counter in range(1,X+1):<br/>    sum+=counter</span></pre><p id="2e20" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">以及一个严格的递归:</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="1184" class="my mb iq nk b gy no np l nq nr">def recursive_sum(X, counter=1):<br/>        <br/>    #end_case:<br/>    if counter == X:<br/>        return counter<br/>    <br/>    #normal_case:<br/>    return counter + recursive_iteration(X, counter+1)</span></pre><h1 id="8c5f" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">将它分解</h1><p id="b10f" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">如果你还没有完全理解上面的代码发生了什么，这里有一个一步一步的视觉帮助，我希望它足够了:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ob"><img src="../Images/5d1ab012a05f91b95138c515167df526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QCuaWu_LbyAE4UoMlLq6iQ.gif"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">这个例子将从1到3的所有整数相加，但是您可以推断出原理</p></figure><blockquote class="nt nu nv"><p id="a2eb" class="le lf nw lg b lh li ka lj lk ll kd lm nx lo lp lq ny ls lt lu nz lw lx ly lz ij bi translated">哎呦，好像我用一些不同的名字制作了动画…</p></blockquote><h1 id="908e" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">递归还是循环？</h1><p id="f6aa" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">如果你在两者之间有明确的选择，选择循环。除了有时与使用递归相关的碍眼和头痛之外，另一个相当大的缺点是开销。做一个递归和一个循环来完成相同的任务，然后计时来揭示问题</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">仅仅因为递归函数很糟糕，循环函数不一定是最好的选择。在这里，sum函数远远胜过它</p></figure><h1 id="e932" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">递归用例</h1><p id="51b6" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">当常规循环不适合这项工作时，真正的乐趣就开始了，这就是递归的领域。在循环变得复杂和失败的地方，递归占主导地位。</p><p id="fda3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">一旦你能理解递归过程，你需要培养正确使用它们的意识。当我开始思考“这应该重复，但每一步都要放大”这样的问题时，我意识到递归的必要性。现在，我不会向您展示任何有用的东西，相反，我在文章的开头承诺了分形的乐趣，所以让我们开始吧。</p><h1 id="34db" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">分形娱乐时间</h1><p id="e0b4" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">如果你在哲学演讲(或在互联网上与陌生人争论)或内省中思考，你可能会注意到一些递归思维模式的出现。似乎递归被编织进了人类的大脑。自然界的一些例子表明，美源于几何规则，递归也不例外，尽管在自然界中它们大多以分形的形式出现。</p><p id="09ed" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了让这篇文章在几何上更吸引人，让我们试着解一个图形递归赋值。</p><h2 id="0ad5" class="my mb iq bd mc mz na dn mg nb nc dp mk ln nd ne mm lr nf ng mo lv nh ni mq iw bi translated">五个人</h2><p id="1c97" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">首先，让我介绍这五位。<br/> Five是一个2D数组，记为[[1，0，1]，[0，1，0]，[1，0，1]] <br/>为什么叫“the Five”？如果你把1想象成一个白色像素，把0想象成一个黑色像素，这看起来有点像骰子上的5(我猜可能有人在读这篇文章时从未见过骰子…)</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/83e6a7e5000a81c69e92baa22a571d21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JGjPlFSxKWs9KxF1krFt-A.png"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">[1，0，1]<br/>【0，1，0】<br/>【1，0，1】<br/>【图片，作者】</p></figure><p id="3334" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这很容易被硬编码，但是我们不要沉迷于这样的行为…</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="53ab" class="my mb iq nk b gy no np l nq nr">five = []<br/>for i in range(3):<br/>    row = []<br/>    for j in range(3):</span><span id="b901" class="my mb iq nk b gy ns np l nq nr">        # This is a method for generating checkerboard patterns, makes sure that the rows change the order of 1’s and 0's<br/>        if (j+i)%2 == 0:<br/>            row.append(1)<br/>        else:<br/>            row.append(0)</span><span id="92c8" class="my mb iq nk b gy ns np l nq nr">five.append(row)</span></pre><p id="3663" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">好了，现在我们已经定义并编码了五个。进入下一步…</p><h2 id="42a7" class="my mb iq bd mc mz na dn mg nb nc dp mk ln nd ne mm lr nf ng mo lv nh ni mq iw bi translated">五个组成五个</h2><p id="2483" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">下一个需要理解的概念是。如果我们用5代替1，用3×3零矩阵代替0，会怎么样？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/fc4dfef0cb5f436345b7ac3664b5d4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lVDlNAcDx4Vwc842nKsJRQ.gif"/></div><p class="la lb gj gh gi lc ld bd b be z dk translated">五个组成五个，第一次进化[作者动画]</p></figure><p id="5cec" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有很明显的简单方法可以达到这个形状，但是我希望你能推断出它的发展方向…因为再多的硬编码也帮不了你。</p><h2 id="c243" class="my mb iq bd mc mz na dn mg nb nc dp mk ln nd ne mm lr nf ng mo lv nh ni mq iw bi translated">由…制成的五个(五个由…制成的)</h2><blockquote class="nt nu nv"><p id="6047" class="le lf nw lg b lh li ka lj lk ll kd lm nx lo lp lq ny ls lt lu nz lw lx ly lz ij bi translated">我的朋友叫我分形五</p></blockquote><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oe"><img src="../Images/f2e606045ad4291de9e7fe7820fe7d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Olhv0U-HTHTIRm-jtJ6RAQ.png"/></div></div><p class="la lb gj gh gi lc ld bd b be z dk translated">请看分形五，五的最终进化[图片由作者提供]</p></figure><p id="c29c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">让我们想一个策略。这个问题可以借助我在上面<em class="nw">打出的递归框架来解决。<br/>在我们的<strong class="lg ja">正常情况</strong>中，我们希望函数做Five的形状，但是在递归的每一级都有不同的步长。<br/>例如，第一次迭代将整个图像(2D矩阵)纳入范围，并将其分成3×3块。为此，它跨越1/3的范围宽度和高度。<br/>每个块被带入第二次迭代，并定义该次迭代的范围。步幅保持1/3的范围，块进一步分割成3×3的块。<br/>该过程以递归方式重复，这是应该的。</em></p><p id="ad44" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这个过程需要在某个时候停止，所以我们引入了一个<strong class="lg ja">结束案例。<br/> </strong>在这个例子中，结束的情况是当范围是3x3像素时。显然，更深一层意味着进入亚像素领域，我妈妈总是说永远不要去那里。相反，当我们到达3x3 px范围时(步长为1)，我们将只画五个。</p><p id="9d06" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">要使它工作，我们需要将矩阵、范围和当前的x和y坐标(以知道在哪里画白色px)作为参数传递给函数。</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="9935" class="my mb iq nk b gy no np l nq nr">def rec(mat,scope,x,y):</span><span id="f83a" class="my mb iq nk b gy ns np l nq nr">    stride = scope/3</span><span id="5fd2" class="my mb iq nk b gy ns np l nq nr">#### End Case ################<br/>    if stride == 1/3:   # DO NOT go into the sub-pixel territory...<br/>        x,y = int(x),int(y)<br/>        mat[y,x] = 255 # Paint it white <br/>        return</span><span id="9cd0" class="my mb iq nk b gy ns np l nq nr">##### Normal Case ############<br/>    remember_x = x<br/>    for i in range(3):<br/>        for j in range(3):<br/>            if (j+i)%2 == 0:<br/>                rec(mat,stride,x,y) # Call the function again<br/>            x+= stride<br/>        y+= stride<br/>        x = remember_x</span><span id="2244" class="my mb iq nk b gy ns np l nq nr">    # The loops can be done as "in range(0,3*stride,stride)<br/>    # But this seemed more readable to me at the time</span><span id="30fe" class="my mb iq nk b gy ns np l nq nr">    # When all recursions are done, return the matrix for viewing<br/>    if scope == mat.shape[0]:<br/>        return mat</span></pre><p id="f413" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">为了让这个函数对用户更友好，我把它包装到了另一个函数中</p><pre class="kp kq kr ks gt nj nk nl nm aw nn bi"><span id="7fa5" class="my mb iq nk b gy no np l nq nr">def fractal_five(number_of_iterations):<br/>    dim = 3**number_of_iterations<br/>    mat = rec(np.zeros((dim,dim)),dim,0,0)<br/>    return mat</span></pre><p id="1f19" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这样，可以用一个参数调用该函数，并生成一个填充有分形五的正方形2d矩阵。将numpy作为np导入并使用它的ndarrays使得稍后在opencv中可视化结果变得容易。</p><p id="06c8" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当重新思考这个过程时，似乎反过来会快得多。从3x3像素开始，递归到图像的全部范围，但我认为这已经足够了。递归思维过程不仅对计算机来说计算量大，对你的大脑来说也是如此。一定要振作起来，享受有规律的、线性的思维流。</p><p id="92bd" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">免责声明:随意使用标签为[图片/作者动画]的所有内容</p></div></div>    
</body>
</html>