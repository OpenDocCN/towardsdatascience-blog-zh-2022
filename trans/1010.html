<html>
<head>
<title>Object Oriented Programming in Python — Inheritance and Subclass</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中的面向对象编程——继承和子类</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/object-oriented-programming-in-python-inheritance-and-subclass-9c62ad027278#2022-03-16">https://towardsdatascience.com/object-oriented-programming-in-python-inheritance-and-subclass-9c62ad027278#2022-03-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f30" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解继承的基本概念，并通过创建子类来应用它们。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/01025589414a7ce2340cbbbfee4481f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*doBY5x6hjCVefcRL"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@juliakadel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">朱莉娅·卡德尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文是 Python 中面向对象编程(OOP)系列的一部分。在这篇文章中，我将从我上一篇文章离开的地方开始讨论——<a class="ae kv" rel="noopener" target="_blank" href="/oop-in-python-understanding-a-class-bcc088e595c6">Python 中的 OOP 理解类</a>。</p><p id="412b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一篇文章中，我们学习了一个<em class="ls">类</em>的构建模块，并构建了我们的第一个<em class="ls">子类</em>。在这篇文章中，我将从解释子类<code class="fe lt lu lv lw b">NumListExt01</code>的构造开始，为了便于讨论，我在这里将其重命名为<code class="fe lt lu lv lw b">Customer01</code>。然后，我将回顾一下，更详细地解释一下<em class="ls">继承</em>的概念，然后再回到<em class="ls">子类</em>上，用一些额外的概念对其进行扩展。</p><h1 id="fa5e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">亚纲</h1><h2 id="f2b9" class="mp ly iq bd lz mq mr dn md ms mt dp mh lf mu mv mj lj mw mx ml ln my mz mn na bi translated">概述</h2><p id="7511" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">我们将从上一篇文章中创建的类和子类例子开始。为了便于解释，我将子类从<code class="fe lt lu lv lw b">NumListExt01</code>重命名为<code class="fe lt lu lv lw b">Customer01</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a28c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了提醒我们，<code class="fe lt lu lv lw b">Customer01</code>子类通过添加一个额外的方法- <code class="fe lt lu lv lw b">get_total()</code>扩展了超类<code class="fe lt lu lv lw b">NumList</code>。</p><h2 id="c77c" class="mp ly iq bd lz mq mr dn md ms mt dp mh lf mu mv mj lj mw mx ml ln my mz mn na bi translated">进入内脏</h2><p id="2f17" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">在进入<code class="fe lt lu lv lw b">Customer01</code>的内部之前，让我们创建一个<code class="fe lt lu lv lw b">Customer01</code>类的对象，应用这些方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><pre class="kg kh ki kj gt ni lw nj nk aw nl bi"><span id="d0d8" class="mp ly iq lw b gy nm nn l no np">Initial list of values of cust02: []<br/>Updated list after adding values to it: [2, 20, 44, 12]<br/>Updated list after removing value 12 is:  [2, 20, 44]<br/>Sum of all the elements of the current list is: 66</span></pre><p id="c3a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义<em class="ls">子类</em>的最低要求:</p><ul class=""><li id="c6c4" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><strong class="ky ir">超类作为参数:</strong>创建子类时，提供<em class="ls">超类</em>，当前类将在其上构建，name 作为参数。在我们的例子中，我们已经创建了<code class="fe lt lu lv lw b">Customer01</code>作为超类<code class="fe lt lu lv lw b">NumList</code>的子类。</li><li id="b1f7" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><strong class="ky ir">初始化超类</strong> : Python 需要显式调用超类构造函数(<code class="fe lt lu lv lw b">__init__()</code>)。调用超类构造函数可以确保超类的属性对于子类是正确可用的。</li></ul><p id="fb8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑暂停一下，看看如果你不调用超类的构造函数会发生什么，比如试着用<code class="fe lt lu lv lw b">pass</code>替换<code class="fe lt lu lv lw b">NumList.__init__(self)</code>。</p><p id="df46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了对<em class="ls">类</em>和<em class="ls">子类</em>的初步理解，现在我们将把注意力转移到理解<em class="ls">继承</em>的概念上。如果您对子类细节还有点不清楚，请不要担心，我们将再次回到<em class="ls">子类</em>来进一步讨论。</p><h1 id="8184" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">遗产</h1><h2 id="3581" class="mp ly iq bd lz mq mr dn md ms mt dp mh lf mu mv mj lj mw mx ml ln my mz mn na bi translated">现实生活中的继承</h2><p id="0c05" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">继承允许我们在现有的通用<em class="ls">类</em>的基础上构建，并通过定制我们认为合适的新<em class="ls">类</em>来扩展这些类的用途。这个概念可以用一个真实的例子来解释。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/85019f9dda5cc2cc8b87b720f4b366b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SxVRumwyOAU0cVyc.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图像由作者创建</p></figure><p id="9f97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">图片:</strong>继承的例子</p><p id="f87e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">超类</strong></p><p id="9dc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<em class="ls">车辆</em>是最通用的类别或<em class="ls">类</em>。我们可以把车辆定义为用某种方式移动并用来运送人或材料的东西。这个宽泛的定义让<em class="ls">车辆</em>成为了<em class="ls">超类</em>，它基本上包含了我们稍后将定义的所有车辆类型。</p><p id="3ef2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">子类</strong></p><p id="7316" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二层中，我们根据车辆行驶的路面类型来指定车辆。还要注意，基于我们想要指定的基础，这一层看起来可能完全不同。例如，我们可以根据其使用目的将车辆指定为两种类型——个人和商业。</p><p id="766e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些<em class="ls">陆地</em>、<em class="ls">水上</em>、<em class="ls">空中</em>、<em class="ls">太空</em>飞行器都是超类<em class="ls">飞行器</em>的<em class="ls">子类</em>。</p><p id="8b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些<em class="ls">子类</em>都包含它们的<em class="ls">超类</em>的属性——所有这些都是通过某种方式移动并用于运送人员或物资的车辆。但除此之外，它们都包含基于其操作表面的特定属性:</p><ul class=""><li id="f794" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><em class="ls">陆地车辆</em>有轮子，</li><li id="71de" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><em class="ls">水上交通工具</em>有螺旋桨等等。</li></ul><p id="6021" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更多子类</strong></p><p id="9280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="ls">子类</em>的第三层中，我们以<em class="ls">水上交通工具</em>为例，根据水上交通工具运行的级别进一步指定。我们称它们为— <em class="ls">水面</em>或<em class="ls">水下</em>运载工具。</p><p id="90e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些类继承了两个超类的属性— <em class="ls">车辆</em>和<em class="ls">水上车辆</em>。也就是说，水面和水下交通工具:</p><ul class=""><li id="a7a2" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">通过某种方式移动并用于运输——从<em class="ls"> Vehicles </em>超类继承的属性</li><li id="20a7" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">他们有某种推进器——继承自<em class="ls">水上交通工具</em>超类</li></ul><p id="7518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，它们还有自己的特性，</p><ul class=""><li id="1d66" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><em class="ls">水面车辆</em>具有漂浮能力</li><li id="ffaa" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><em class="ls">水下运载工具</em>具有下潜能力</li></ul><p id="3c2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，T21 遗产的一个关键属性很可能是清楚的，</p><blockquote class="of"><p id="8aea" class="og oh iq bd oi oj ok ol om on oo lr dk translated">我们越往下走，职业就变得越具体。</p></blockquote><p id="933e" class="pw-post-body-paragraph kw kx iq ky b kz oq jr lb lc or ju le lf os lh li lj ot ll lm ln ou lp lq lr ij bi translated">🛑从<em class="ls">车辆</em>等级的例子中选择第四等级，并思考哪些属性使它们更好、更具体地达到其目的。</p><h2 id="73f4" class="mp ly iq bd lz mq mr dn md ms mt dp mh lf mu mv mj lj mw mx ml ln my mz mn na bi translated">我们例子中的继承</h2><p id="9488" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated"><strong class="ky ir">新要求</strong></p><p id="c2a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们回到我们的编码示例，通过应用它们来理解继承概念。</p><p id="1d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了建立一个上下文，让我们假设我们的客户 01 带着一个新的需求回来了；和上一个相比有点复杂。他希望能够做两件事:</p><ul class=""><li id="63d8" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">将列表中的每一项视为所有项或值的总和的一部分。</li><li id="b8a3" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">获取最大值及其对应的分数值。</li></ul><p id="b5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看需求，我们可以看到这些功能是建立在先前创建的类<code class="fe lt lu lv lw b">NumList</code>和<code class="fe lt lu lv lw b">Customer01</code>已经提供的功能之上的:</p><ul class=""><li id="4d8f" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b">NumList</code>将是创建和更新数字列表的基础。</li><li id="5dde" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated"><code class="fe lt lu lv lw b">Customer01</code>将需要得到所有值的总和。</li></ul><p id="3b0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到类的这些属性之间的流动关系，我们可以将这些类放入一个很好的层次结构中:<code class="fe lt lu lv lw b">NumList</code>-&gt;-<code class="fe lt lu lv lw b">Customer01</code>-&gt;-<code class="fe lt lu lv lw b">CustReq01</code>(新类尚未创建)。</p><p id="ea15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不是说我们不能绕过<code class="fe lt lu lv lw b">Customer01</code>类，而是因为我们已经创建了它，让我们利用这个类并在它的基础上构建。此外，想想如果这是一个实际的商业应用程序，其中<code class="fe lt lu lv lw b">customer01</code>是一个用数百行代码定义的类。你不会想再造轮子的！</p><p id="6840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">新增子类:</strong> <code class="fe lt lu lv lw b"><strong class="ky ir">CustReq01</strong></code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><pre class="kg kh ki kj gt ni lw nj nk aw nl bi"><span id="04bf" class="mp ly iq lw b gy nm nn l no np">[2, 20]<br/>{2: 0.09090909090909091, 20: 0.9090909090909091}<br/>Larget value and it's fraction to total:  {20: 0.9090909090909091}<br/>Largest item and it's fraction to total (from variable):  {20: 0.9090909090909091}</span></pre><p id="71d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新的子类<code class="fe lt lu lv lw b">CustReq01</code>中，我们添加了两个方法来满足这两个需求。但是为了使这两个方法有用，我们还添加了两个<em class="ls">变量</em> - <code class="fe lt lu lv lw b">__frac_dict</code>和<code class="fe lt lu lv lw b">max_item</code>。此外，我们对超类的实例化与我们在第一个子类<code class="fe lt lu lv lw b">Customer01</code>中看到的不同。现在让我们来看一下这些新推出的特性和功能。</p><p id="8621" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">初始化超类</strong></p><blockquote class="ov ow ox"><p id="3839" class="kw kx ls ky b kz la jr lb lc ld ju le oy lg lh li oz lk ll lm pa lo lp lq lr ij bi translated"><em class="iq">初始化超类的两种方式:显式使用超类名，或者使用</em> <code class="fe lt lu lv lw b"><em class="iq">super()</em></code> <em class="iq">方法。</em></p></blockquote><ul class=""><li id="7963" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">在类中使用实际的超类名称作为:&lt; 【T1】 &gt;&lt; 【T2】 &gt; 【T3】 . We initialized  【T4】  this way in our first subclass.</li><li id="2181" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">Using a more general format as: &lt; 【T5】 &gt;&lt; 【T6】 &gt;&lt; 【T7】 &gt;. Doing this helps us avoid re-typing the <em class="ls">超类</em>而不是作为参数。</li></ul><p id="792c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">⚠️注意到<code class="fe lt lu lv lw b">super()</code>方法创建了一个上下文，在这个上下文中你不应该需要放<code class="fe lt lu lv lw b">self</code>参数。该方法调用<em class="ls">超类</em>，并使其所有属性对子类可用。</p><p id="b858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">私有变量与公共变量</strong></p><p id="1f6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe lt lu lv lw b">CustReq01</code>中，我们有两个<em class="ls">实例</em>变量:<code class="fe lt lu lv lw b">__frac_dict</code> -一个空字典，用于存储分数的未来值，以及<code class="fe lt lu lv lw b">max_item</code> -另一个空字典，用于存储最大值及其分数值。</p><p id="1e40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在上一篇文章中提到的，在变量或方法前面添加两个下划线会使其成为私有的，这意味着方法或变量不能从对象中直接访问。在<code class="fe lt lu lv lw b">CustReq01</code>的情况下，<code class="fe lt lu lv lw b">__frac_dict</code>被创建为私有变量。同样的原则也适用于方法。可以通过添加两个下划线作为前缀来创建私有方法。</p><blockquote class="ov ow ox"><p id="9466" class="kw kx ls ky b kz la jr lb lc ld ju le oy lg lh li oz lk ll lm pa lo lp lq lr ij bi translated"><em class="iq">私有变量/方法通常在这些属性被类中的一些内部方法使用的情况下创建。因此，将这些属性保留为私有属性可以提供某种保护，防止意外的复杂情况。</em></p></blockquote><p id="43a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<a class="ae kv" href="https://softwareengineering.stackexchange.com/questions/143736/why-do-we-need-private-variables" rel="noopener ugc nofollow" target="_blank">stack exchange<em class="ls">的</em></a>答案，了解私有财产的好处。</p><p id="68f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">练习</strong></p><p id="0f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试着思考这两个问题:</p><p id="6119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑试着运行<code class="fe lt lu lv lw b">x.max_item</code>和<code class="fe lt lu lv lw b">x.__frac_dict</code>。如果到目前为止您已经运行了本文中的所有代码，您能猜到您会在结果中看到什么吗？</p><p id="ee29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑还有，如果你试图在运行<code class="fe lt lu lv lw b">x.frac_max()</code>之前使用<code class="fe lt lu lv lw b">x.max_item</code>来获得最大值，会发生什么？你能猜到为什么你会得到你所得到的吗？</p><p id="2266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">使用先前在后面的方法中定义的方法</strong></p><p id="ce6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查方法<code class="fe lt lu lv lw b">frac_max()</code>如何利用之前在<code class="fe lt lu lv lw b">CustReq01</code>中定义的方法<code class="fe lt lu lv lw b">frac_list()</code>。我们使用变量也遵循同样的规则:&lt;<code class="fe lt lu lv lw b">self</code>&gt;&lt;<code class="fe lt lu lv lw b">.</code>&gt;&lt;<code class="fe lt lu lv lw b">method name</code>&gt;。</p><p id="e5ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，在使用<code class="fe lt lu lv lw b">frac_list()</code>方法时，我们不必提及<code class="fe lt lu lv lw b">self</code>参数。</p><h1 id="dbb4" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">下一步是什么</h1><p id="b7b9" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">在这篇文章中，我们试图理解，</p><ul class=""><li id="ec4c" class="nq nr iq ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated"><em class="ls">继承的概念</em></li><li id="d287" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">理解用于创建子类的语法</li><li id="9e8b" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">通过创建一个新的子类来应用我们所学的概念</li><li id="2ef2" class="nq nr iq ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">最后，我们谈了一点关于<em class="ls">实例变量</em></li></ul><p id="1c0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的几篇文章中，我们将更深入地挖掘概念<em class="ls">变量</em>和<em class="ls">方法</em>。我们将会看到不同类型的变量和方法，以及它们的用途如何彼此不同。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="30bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">更新</strong>:查看下一篇文章<a class="ae kv" rel="noopener" target="_blank" href="/object-oriented-programming-in-python-understanding-variable-e451cf581368">Python 面向对象编程——理解变量</a>。</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="1272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，试试 Python 系列中以前关于 OOP 的文章:</p><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/oop-in-python-understanding-a-class-bcc088e595c6"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ir gy z fp pq fr fs pr fu fw ip bi translated">Python 中的 OOP 理解一个类</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">理解 Python 类的基本组件。</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz kp pl"/></div></div></a></div><div class="pi pj gp gr pk pl"><a rel="noopener follow" target="_blank" href="/oop-in-python-understanding-a-class-bcc088e595c6"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd ir gy z fp pq fr fs pr fu fw ip bi translated">Python 中的 OOP 理解一个类</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">理解 Python 类的基本组件。</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">towardsdatascience.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz kp pl"/></div></div></a></div></div></div>    
</body>
</html>