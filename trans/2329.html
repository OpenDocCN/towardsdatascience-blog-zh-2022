<html>
<head>
<title>Modularise your Notebook into Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将你的笔记本改编成脚本</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modularise-your-notebook-into-scripts-5d5ccaf3f4f3#2022-05-23">https://towardsdatascience.com/modularise-your-notebook-into-scripts-5d5ccaf3f4f3#2022-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0de8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将您的代码从笔记本转换为可执行脚本的简单指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/95f72ac58cf4721a0925dc9b8816de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4K4bRuPOWN1nyFeGCf4lew.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@jstrippa?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">詹姆斯·哈里逊</a>在<a class="ae kv" href="https://unsplash.com/s/photos/python-code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">ello世界！在这篇文章中，我将介绍一个简单的指南，如何将你的笔记本变成可执行脚本。</p><p id="117e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之前<a class="ae kv" href="https://medium.com/@geoffreyhung" rel="noopener"> Geoffrey Hung </a>分享了一篇关于如何将你的<a class="ae kv" rel="noopener" target="_blank" href="/from-jupyter-notebook-to-sc-582978d3c0c"> Jupyter笔记本转换成脚本</a>的极其全面的文章。然而，在我寻求生产模型的过程中，我发现在将笔记本从<code class="fe mb mc md me b">.ipynb</code>升级到<code class="fe mb mc md me b">.py</code>并运行整个脚本管道的模块中存在一些缺口。</p><p id="5fa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在分析领域工作，您可能会发现自己在某个时间点在笔记本上编写python代码。您可能遇到过这种方法的问题，也可能没有，但是如果您正在寻找一种用脚本执行笔记本的方法，那么这篇文章就是为您准备的。</p><p id="081d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会关注用脚本编写代码的好处，也不会试图比较这两种方法，因为笔记本和脚本各有利弊。如果你想知道为什么你应该作出改变，这篇文章可能会提供更多的清晰度。</p><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/5-reasons-why-you-should-switch-from-jupyter-notebook-to-scripts-cb3535ba9c95"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">你应该从Jupyter笔记本转向脚本的5个理由</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">使用脚本帮助我认识到Jupyter笔记本的缺点</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="ms l mt mu mv mr mw kp mi"/></div></div></a></div><p id="d2b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经创建了一个演示库来对从<a class="ae kv" href="https://www.kaggle.com/datasets/arjunbhasin2013/ccdata" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获得的信用卡数据集执行聚类分析。我将在整篇文章中使用这个存储库来分享示例片段。</p><p id="86bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">目录:</strong></p><ol class=""><li id="8a65" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr nc nd ne nf bi translated">项目和代码结构</li><li id="cb78" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">抽象和重构</li><li id="e011" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr nc nd ne nf bi translated">执行管道</li></ol></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="2beb" class="ns nt iq bd nu nv nw dn nx ny nz dp oa lf ob oc od lj oe of og ln oh oi oj ok bi translated">项目和代码结构</h2><p id="0990" class="pw-post-body-paragraph kw kx iq ky b kz ol jr lb lc om ju le lf on lh li lj oo ll lm ln op lp lq lr ij bi translated">拥有适当的存储库结构是必不可少的。我们不需要一个巨大的笔记本，或者多个包含从数据提取到建模的整个流程的不同模型的笔记本，我们首先必须通过将它们分解成不同的目的来划分这种复杂性。</p><p id="edbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">典型的数据分析工作流程大致包括3个部分:提取、转换/预处理和分析/建模。这意味着你已经可以将笔记本分成至少3个独立的脚本——<code class="fe mb mc md me b">extraction.py</code>、<code class="fe mb mc md me b">preprocessing.py</code>和<code class="fe mb mc md me b">model.py</code>。</p><p id="ddf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的演示存储库中，<code class="fe mb mc md me b">extraction.py</code>缺失，因为数据集是从Kaggle获得的，所以提取脚本是不必要的。但是，如果您正在利用API、web抓取或从数据湖中转储数据，那么拥有一个提取脚本将会非常有用。根据您的团队采用的数据模型的类型，您可能会发现自己必须编写一系列查询来提取数据，并执行<code class="fe mb mc md me b">join</code>语句来将它们合并到一个单独的表或数据帧中。</p><p id="70b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目的典型结构可能如下所示。要查看项目结构，请执行以下操作:</p><pre class="kg kh ki kj gt oq me or os aw ot bi"><span id="291b" class="ns nt iq me b gy ou ov l ow ox">$ tree</span><span id="7d97" class="ns nt iq me b gy oy ov l ow ox">.<br/>├── LICENSE<br/>├── README.md<br/>├── config.yml<br/>├── data<br/>│   ├── CC_GENERAL.csv<br/>│   └── data_preprocessed.csv<br/>├── main.py<br/>├── notebooks<br/>│   ├── dbscan.ipynb<br/>│   ├── kmeans.ipynb<br/>│   └── preprocessing.ipynb<br/>├── requirements.txt<br/>└── src<br/>    ├── dbscan.py<br/>    ├── executor.py<br/>    ├── kmeans.py<br/>    ├── preprocessing.py<br/>    └── utility.py</span></pre><p id="0416" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目存储库中，我们将管道分解成它的关键组件。让我们来看看它们的每一个目的。</p><ul class=""><li id="9a9a" class="mx my iq ky b kz la lc ld lf mz lj na ln nb lr oz nd ne nf bi translated"><code class="fe mb mc md me b">/notebooks</code>:这个文件夹是一个游戏场，在这里你的原始代码是以一种扁平的结构编写的，以便更简单地显示输出和遍历代码块。</li><li id="2f96" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr oz nd ne nf bi translated">这个文件夹包含了你的脚本将要使用的各种数据文件。这里存储的一些流行的数据格式包括<code class="fe mb mc md me b">.csv</code>、<code class="fe mb mc md me b">.parquet</code>、<code class="fe mb mc md me b">.json</code>等。</li><li id="e6ef" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr oz nd ne nf bi translated">这个文件夹存储了你所有的可执行脚本。</li><li id="263b" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr oz nd ne nf bi translated"><code class="fe mb mc md me b">main.py</code>:运行整个管道的主脚本，代码从笔记本中抽象和重构。</li><li id="d733" class="mx my iq ky b kz ng lc nh lf ni lj nj ln nk lr oz nd ne nf bi translated"><code class="fe mb mc md me b">config.yml</code>:一个人类可读的文件，存储用于运行脚本的可配置参数</li></ul></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="2222" class="ns nt iq bd nu nv nw dn nx ny nz dp oa lf ob oc od lj oe of og ln oh oi oj ok bi translated">抽象和重构</h2><p id="ecd8" class="pw-post-body-paragraph kw kx iq ky b kz ol jr lb lc om ju le lf on lh li lj oo ll lm ln op lp lq lr ij bi translated">一旦你有了你的项目结构，下一步就是重构和抽象你的代码来降低复杂性。将代码抽象成函数和类(加上适当的变量命名)有助于区分复杂性，而不是编写迫使读者理解如何操作的代码。</p><p id="67c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的文章提供了一个如何重构你的笔记本的惊人总结。</p><div class="mf mg gp gr mh mi"><a href="https://www.thoughtworks.com/en-sg/insights/blog/coding-habits-data-scientists" rel="noopener  ugc nofollow" target="_blank"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">数据科学家的编码习惯</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">如果你尝试过机器学习或数据科学，你就会知道代码会很快变得混乱。通常情况下…</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">www.thoughtworks.com</p></div></div><div class="mr l"><div class="pa l mt mu mv mr mw kp mi"/></div></div></a></div><p id="f525" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">预处理</strong></p><p id="4e8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提取数据后，在将数据用于分析或模型之前，通常会对其进行清理。一些常见的预处理包括输入缺失值、去除异常值和转换数据等。</p><p id="cf27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示存储库中涉及的一些预处理包括移除异常值和输入缺失值。这些特定的任务可以被抽象成函数并存储在一个<code class="fe mb mc md me b">utility.py</code>脚本中，该脚本稍后可以被导入到<code class="fe mb mc md me b">preprocessing.py</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="5fad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，用中位数输入缺失值的函数被放在了<code class="fe mb mc md me b">utility.py</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="e86f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">型号</strong></p><p id="8172" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您必须对同一组预处理数据使用不同的模型，我们也可以创建<em class="pd">类</em>来创建一个模型实例。在演示存储库中，我研究了执行集群时的两种算法，每种模型都被分成可执行的脚本。例如，kmeans被抽象为<code class="fe mb mc md me b">kmeans.py</code>，而DBSCAn被抽象为<code class="fe mb mc md me b">dbscan.py</code>。</p><p id="ba35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们导入必要的包并为kmeans模型创建一个类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="b0b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要创建一个模型实例，我们可以简单地定义一个对象来初始化一个模型并存储kmeans模型实例。</p><pre class="kg kh ki kj gt oq me or os aw ot bi"><span id="b04a" class="ns nt iq me b gy ou ov l ow ox">kmeans = kmeans_model(df) # instantiate kmeans model</span><span id="5ed4" class="ns nt iq me b gy oy ov l ow ox">kmeans_models = kmeans.kmeans_model(min_clusters=1, max_clusters=10) # run multiple iterations of kmeans model</span></pre><p id="4e98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由Sadrach Pierre撰写的这篇文章对如何在构建模型时利用类进行了广泛的阐述。</p><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/using-classes-for-machine-learning-2ed6c0713305"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">使用类进行机器学习</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">使用面向对象编程来构建模型</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="pe l mt mu mv mr mw kp mi"/></div></div></a></div></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="6d43" class="ns nt iq bd nu nv nw dn nx ny nz dp oa lf ob oc od lj oe of og ln oh oi oj ok bi translated">执行管道</h2><p id="44ea" class="pw-post-body-paragraph kw kx iq ky b kz ol jr lb lc om ju le lf on lh li lj oo ll lm ln op lp lq lr ij bi translated">随着分析管道的各种关键组件被抽象成函数和类，并转换成模块化的脚本，我们现在可以简单地运行整个管道。这是使用两个脚本实现的— <code class="fe mb mc md me b">main.py</code>和<code class="fe mb mc md me b">executor.py</code>。</p><p id="b91f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">主</strong></p><p id="14c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主脚本<code class="fe mb mc md me b">main.py</code>将在执行时运行整个管道，接收已加载的必要配置。在演示存储库中，我利用一个配置文件来存储参数，并点击<a class="ae kv" href="https://click.palletsprojects.com/en/8.1.x/" rel="noopener ugc nofollow" target="_blank">与它交互。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="c4c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">执行者</strong></p><p id="314a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦加载了模型选择及其相应的参数，我们就可以解析这些模型输入，并使用执行脚本<code class="fe mb mc md me b">executor.py</code>来执行它。实例化模型、优化模型和拼接集群标签的步骤将在executor函数中展开。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="af18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要运行整个管道:</p><pre class="kg kh ki kj gt oq me or os aw ot bi"><span id="72c3" class="ns nt iq me b gy ou ov l ow ox"># execute entire pipeline with default model<br/>python3 main.py</span><span id="aad6" class="ns nt iq me b gy oy ov l ow ox"># execute entire pipeline using DBSCAN<br/>python3 main.py --model=dbscan</span><span id="24c1" class="ns nt iq me b gy oy ov l ow ox"># execute entire pipeline using another config file and DBSCAN<br/>python3 main.py another_config.yml --model=dbscan</span></pre></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="94ec" class="ns nt iq bd nu nv nw dn nx ny nz dp oa lf ob oc od lj oe of og ln oh oi oj ok bi translated">结论</h2><p id="d2d7" class="pw-post-body-paragraph kw kx iq ky b kz ol jr lb lc om ju le lf on lh li lj oo ll lm ln op lp lq lr ij bi translated">将它们放在一起，我们现在有了一个逻辑项目结构，每个模块脚本都执行其特定的目的，底层代码被抽象和重构。然后，可以使用存储模型输入参数的配置文件来执行管道。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="074b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请留下评论💬如果有更多要添加的，我会很高兴将它们编辑在一起！</p><p id="f028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！:)</p><h2 id="99c5" class="ns nt iq bd nu nv nw dn nx ny nz dp oa lf ob oc od lj oe of og ln oh oi oj ok bi translated">参考</h2><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/from-jupyter-notebook-to-sc-582978d3c0c"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">从朱庇特笔记本到剧本</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">不要玩玩具模型；准备好生产你的作品吧！</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="pf l mt mu mv mr mw kp mi"/></div></div></a></div><div class="mf mg gp gr mh mi"><a rel="noopener follow" target="_blank" href="/from-jupyter-notebook-to-deployment-a-straightforward-example-1838c203a437"><div class="mj ab fo"><div class="mk ab ml cl cj mm"><h2 class="bd ir gy z fp mn fr fs mo fu fw ip bi translated">从Jupyter笔记本到部署—一个简单的例子</h2><div class="mp l"><h3 class="bd b gy z fp mn fr fs mo fu fw dk translated">一步一步的例子，采用典型的机器学习研究代码，构建一个生产就绪的微服务。</h3></div><div class="mq l"><p class="bd b dl z fp mn fr fs mo fu fw dk translated">towardsdatascience.com</p></div></div><div class="mr l"><div class="pg l mt mu mv mr mw kp mi"/></div></div></a></div></div></div>    
</body>
</html>