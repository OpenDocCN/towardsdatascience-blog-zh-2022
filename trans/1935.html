<html>
<head>
<title>Clash of the minimum spanning tree algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最小生成树算法的冲突</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/clash-of-the-minimum-spanning-tree-algorithms-12568d21ca15#2022-05-03">https://towardsdatascience.com/clash-of-the-minimum-spanning-tree-algorithms-12568d21ca15#2022-05-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="ec28" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在Go中实现Boruvka、Kruskal和Prim算法</h2></div><p id="a644" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">假设你正在建设一个连接一个小城镇的电网。你所在的城镇有许多建筑——住宅、办公室、商店、学校、图书馆和其他需要电力的建筑，因此它们都需要成为电网的一部分。像许多城镇一样，这些建筑也不是一个挨着一个，事实上它们四处蔓延，有些稀疏，有些密集。连接这些建筑的最佳方式是什么，以减少能源损失并最具成本效益？</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lf"><img src="../Images/3b9f6996ab1816c049caf644b636d44d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*09-__8Bc9xZq8fkHAyW49Q.jpeg"/></div></div><p class="lr ls gk gi gj lt lu bd b be z dk translated">布尔季哈穆德的街道(<a class="ae lv" href="https://pixabay.com/photos/street-buildings-cables-ancient-3729096/" rel="noopener ugc nofollow" target="_blank">图片来自Pixabay </a></p></figure><p id="4b8f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">许多配电公司使用<a class="ae lv" href="https://en.wikipedia.org/wiki/Minimum_spanning_tree" rel="noopener ugc nofollow" target="_blank"> <em class="lw">最小生成树</em> </a>来模拟他们的电网。<em class="lw">生成树</em>是一个加权的、连通的和无向图的子集，它包括该图的所有节点。图中通常有不止一棵生成树。</p><p id="2b0a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">将生成树的所有边的权重相加，就得到生成树的权重或成本。<em class="lw">最小生成树</em> (MST)是成本最低的生成树。</p><p id="0ba9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">基本思想是在可能的电力线连接图中，将建筑物建模为节点，将电力线建模为边。边缘权重可以是铺设线路的成本或电力传输损耗，也可以是我们想要表示用电力线连接两栋建筑的成本的任何值。它甚至可以是通过包含多个参数的公式计算出的值。然而，最终我们把它们归结为一个数字。</p><p id="6bbd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">使用最小生成树算法，我们从该图中创建一个MST。这将为我们提供最具成本效益的电网来为城市服务。</p><p id="97ac" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这篇文章中，我将讨论3种经典的MST算法——Boruvka、Kruskal和Prim算法。我还将使用Go实现它们，并对它们进行基准测试。然而，你应该明白，虽然它们在今天作为软件算法被实现和使用，但是它们是在计算机还没有发明或者几乎没有的时候被创造出来的。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lx"><img src="../Images/900a8605d974738b627676edc2cf75e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reWZ4_NMEeEdJwz33U5n5w.jpeg"/></div></div><p class="lr ls gk gi gj lt lu bd b be z dk translated">CSIRAC照片由维多利亚博物馆<a class="ae lv" href="https://unsplash.com/@museumsvictoria?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae lv" href="https://unsplash.com/s/photos/early-computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</a>拍摄</p></figure><p id="0f7d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">第一个真正在计算机上运行的计算机程序是在1948年，而第一台商用计算机仅在1951年售出。这里的算法根本不是软件算法，它们基本上是数学算法，它们的创造者/发现者都是数学家。</p><h1 id="410b" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">最小生成树算法</h1><p id="0903" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">最小生成树是一个很好解决的问题。最早提到最小生成树算法的是捷克数学家Otakar Boruvka，他在1926年发表了一篇论文，题目是“T2对电力线网络经济建设问题解决方案的贡献”。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lf"><img src="../Images/54a11be1db546dd92f0b0dd99e722744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PZ10EAl9myKwz7n2SbYS6Q.jpeg"/></div></div><p class="lr ls gk gi gj lt lu bd b be z dk translated">捷克共和国南摩拉维亚的米库洛夫镇</p></figure><p id="c674" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这篇论文是西南<a class="ae lv" href="https://en.wikipedia.org/wiki/Moravia" rel="noopener ugc nofollow" target="_blank">摩拉维亚</a>(现在捷克共和国的一部分)电气化问题相关工作的一部分。如果这还不清楚的话，这是大约100年前，那时计算机还不存在。</p><h2 id="a67d" class="mv lz iu bd ma mw mx dn me my mz dp mi ks na nb mk kw nc nd mm la ne nf mo ng bi translated">博鲁夫卡算法</h2><p id="0cab" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">博鲁夫卡的算法优雅而简单。给定一个带节点和边的加权无向图G:</p><ol class=""><li id="6c01" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le nm nn no np bi translated">从G中所有节点的图M开始，但是没有边</li><li id="7b3c" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">找出每个节点连接到另一个节点的最小权重边，并在两个节点之间创建一条边。这导致了节点的集群，我们称之为子图</li><li id="d746" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">找出连接到另一个子图的每个子图的最小权重边，并在它们之间添加一条边。这将导致两个子图合并成一个子图。<br/> <em class="lw">(记住，子图的边本质上是连接一个子图中的节点和另一个子图中的另一个节点的边。将一个子图中的节点连接到同一子图中的另一个节点的边不是子图的边)。</em></li><li id="39d0" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">重复步骤3，直到只剩下1个子图</li></ol><p id="bd5d" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在算法的最后，M将是最小生成树。</p><h2 id="2b4b" class="mv lz iu bd ma mw mx dn me my mz dp mi ks na nb mk kw nc nd mm la ne nf mo ng bi translated">克鲁斯卡尔算法</h2><p id="dff2" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">约瑟夫·克鲁斯卡尔是美国数学家和计算机科学家。他来自一个拥有惊人的数学家和科学家的家庭——他的两个兄弟都是著名的数学家，其中一个是统计学家(<a class="ae lv" href="https://www.cs.umd.edu/users/gasarch/BLOGPAPERS/wkruskalleg.pdf" rel="noopener ugc nofollow" target="_blank">威廉·克鲁斯卡尔</a>)，他是克鲁斯卡尔-沃利斯单向方差分析的共同制定者，另一个(<a class="ae lv" href="http://www.nasonline.org/publications/biographical-memoirs/memoir-pdfs/kruskal-martin.pdf" rel="noopener ugc nofollow" target="_blank">马丁·克鲁斯卡尔</a>)是物理学家和天文学家，他发明了孤立子理论以及其他一些东西。马丁的儿子，约瑟夫的侄子是克莱德·克鲁斯卡尔，他是美国计算机科学家，是并行和分布式计算中读-修改-写概念的发明者之一。</p><p id="96f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">约瑟夫·克鲁斯卡尔本人相当多产。他最有影响力的工作是他对<a class="ae lv" href="https://www.statisticshowto.com/multidimensional-scaling/" rel="noopener ugc nofollow" target="_blank">多维尺度(MDS) </a>公式的贡献，它允许我们将一个数据集转换为另一个更低维度的数据集。这有助于我们将高维数据集可视化为2D数据集。其他以他名字命名的著作还有<a class="ae lv" href="https://en.wikipedia.org/wiki/Kruskal%27s_tree_theorem" rel="noopener ugc nofollow" target="_blank">克鲁斯卡尔树定理</a>、<a class="ae lv" href="https://en.wikipedia.org/wiki/Kruskal–Katona_theorem" rel="noopener ugc nofollow" target="_blank">克鲁斯卡尔-考托瑙定理</a>和<a class="ae lv" href="https://arxiv.org/pdf/0901.1796.pdf" rel="noopener ugc nofollow" target="_blank">克鲁斯卡尔秩</a>(或k秩)。</p><p id="9912" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是让我们回到克鲁斯卡尔的算法。1956年，当他28岁的时候(你28岁的时候在做什么？).</p><p id="a921" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">算法很简单。给定一个带节点和边的加权无向图G:</p><ol class=""><li id="a4f2" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le nm nn no np bi translated">从G中所有节点的图M开始，但是没有边</li><li id="a0e1" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">在列表L中，根据权重对所有边进行排序</li><li id="8f16" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">从L中取最小重量的边，加到m上。</li><li id="e7b1" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">检查这是否会创建一个循环图。如果有，去掉边缘，否则不要管它</li><li id="543a" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">重复步骤(3)和(4)，直到L为空</li></ol><h2 id="7e9c" class="mv lz iu bd ma mw mx dn me my mz dp mi ks na nb mk kw nc nd mm la ne nf mo ng bi translated">普里姆算法</h2><p id="ef88" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">Prim的算法有一个有趣的起源故事。该算法最早是由著名的捷克数学家(是的，另一个)<a class="ae lv" href="https://mathshistory.st-andrews.ac.uk/Biographies/Jarnik/" rel="noopener ugc nofollow" target="_blank"> Vojtech Jarnik </a>在1930年开发的，他也阅读了Boruvka的论文，并在同一份期刊上用他的算法写了一篇回应。不幸的是，Jarnik的回应不如Boruvka的论文那样知名或广为人知(Kruskal和Prim后来都引用了Boruvka的论文，但没有Jarnik的)。</p><p id="d39e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">1957年，<a class="ae lv" href="https://en.wikipedia.org/wiki/Robert_C._Prim" rel="noopener ugc nofollow" target="_blank">美国数学家和计算机科学家Robert Prim </a>独立提出了类似的算法。巧合的是，普里姆和克鲁斯卡尔都是贝尔实验室的同事，他们都为基本相同的问题提出了不同的算法。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj nv"><img src="../Images/92d9b9c95434d0c4f46be85bd6eab15b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lySOAuqRXHyB4x7XzFoEeQ.jpeg"/></div></div><p class="lr ls gk gi gj lt lu bd b be z dk translated">霍姆德尔的老贝尔实验室大楼</p></figure><p id="cdbd" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">甚至更晚些时候，Edsger Dijkstra(<a class="ae lv" href="https://go-recipes.dev/dijkstras-algorithm-in-go-e1129b2f5c9e" rel="noopener ugc nofollow" target="_blank">Dijkstra的算法名声，我在另一篇文章</a>中详细描述过)在1959年再次独立提出了它。</p><p id="77c7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">因此，这种算法现在有很多名字，包括普里姆算法、贾尼克算法、普里姆-贾尼克算法、普里姆-迪克斯特拉算法甚至DJP算法。在这篇文章中，我将使用Prim算法这个名字。</p><p id="1b6f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">尽管系谱复杂，算法本身相当简单，这也是Dijkstra想出它的原因。这是因为这些步骤与Dijkstra算法非常相似。</p><p id="b0ae" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">给定一个带节点和边的加权无向图G，步骤如下:</p><ol class=""><li id="5f15" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le nm nn no np bi translated">从一个空图M开始，图G中的一个任意节点作为当前节点</li><li id="f76d" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">找到图G中当前节点的所有边，并将其添加到最小堆中</li><li id="8ce6" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">弹出最小堆以获得最小权重的边。将边添加到图m。(在后面的迭代中，该边可能不是连接到当前节点的边)</li><li id="486b" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">使边节点成为当前节点，并将其添加到图M中</li><li id="07d1" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">重复步骤(2)到(4)，直到图G中的所有节点也在图M中</li></ol><p id="9dba" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可以看到为什么Dijkstra也想出了同样的算法。Dijkstra和Prim的算法都是从单个节点开始，使用最小堆添加最小权重的边。不同之处在于，Dijkstra的算法寻找从一个节点到另一个节点的最短路径，而Prim的算法寻找以最小的边总权重连接所有节点。</p><h1 id="6f42" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">在围棋中实现算法</h1><p id="2375" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">既然我们已经研究了这3种算法，让我们依次看看它们，看看它们是如何实现的。在所有3个算法中，我们将重复使用我之前关于Dijkstra算法的文章中的相同图形结构。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="735c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这还不够，但我们以后会添加更多的功能。我们也将使用这个简单的图作为最小生成树的基础。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div class="gi gj ny"><img src="../Images/c85a5a661067ef0a17112f2f56df2782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*3e4We5z7AR3v8aHsalWPqA.png"/></div><p class="lr ls gk gi gj lt lu bd b be z dk translated">亚历山大·德里切尔，CC BY-SA 3.0&lt;<a class="ae lv" href="https://creativecommons.org/licenses/by-sa/3.0" rel="noopener ugc nofollow" target="_blank">https://creativecommons.org/licenses/by-sa/3.0</a>&gt;，转自维基共享</p></figure><p id="2801" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一天结束时，最小生成树看起来像这样(突出显示的图表)。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj nz"><img src="../Images/1965233f2a11d44d2ffd0c1eca1e66ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgHccxS0y5u1BZkzigcbvg.png"/></div></div></figure><p id="249a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在我们开始任何算法之前，让我们看看这个图是如何创建的。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="723f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是我们将如何可视化图表。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="fdef" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当我们运行这个程序时，这就是将要显示的内容。</p><pre class="lg lh li lj gu oa ob oc od aw oe bi"><span id="61cd" class="mv lz iu ob b gz of og l oh oi">GRAPH<br/>-----<br/>A -&gt; [B(7) D(4)]<br/>B -&gt; [A(7) C(11) D(9) E(10)]<br/>C -&gt; [B(11) E(5)]<br/>D -&gt; [A(4) B(9) E(15) F(6)]<br/>E -&gt; [B(10) C(5) D(15) F(12) G(8)]<br/>F -&gt; [D(6) E(12) G(13)]<br/>G -&gt; [E(8) F(13)]</span></pre><p id="a7f9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">既然已经解决了，我们就从博鲁夫卡算法开始。</p><h1 id="4a44" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">围棋中的博鲁夫卡算法</h1><p id="38bc" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">让我们再来看看算法:</p><ol class=""><li id="ad37" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le nm nn no np bi translated">从G中所有节点的图M开始，但是没有边</li><li id="0d27" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">找出每个节点连接到另一个节点的最小权重边，并在两个节点之间创建一条边。这导致了节点的集群，我们称之为<em class="lw">子图</em></li><li id="81f6" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">找出连接到另一个子图的每个子图的最小权重边，并在它们之间添加一条边。这将导致两个子图合并成一个子图。<br/> <em class="lw">(记住子图的边本质上是连接一个子图中的节点和另一个子图中的另一个节点的边。将一个子图中的节点连接到同一子图中的另一个节点的边不是子图的边)。</em></li><li id="fd6c" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">重复步骤3，直到只剩下1个子图</li></ol><p id="b065" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是代码。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="9205" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">首先，我们创建<code class="fe oj ok ol ob b">mst</code>图，并从<code class="fe oj ok ol ob b">graph</code>复制节点。然后我们创建一部分<code class="fe oj ok ol ob b">Subgraph</code>结构。<code class="fe oj ok ol ob b">Subgraph</code>结构有一片<code class="fe oj ok ol ob b">Node</code>结构和一片<code class="fe oj ok ol ob b">NodePair</code>结构。记住，子图是节点和连接这些节点的边的集群。子图本身就是一棵最小生成树。在这个实现中，我们使用这个结构作为工具来帮助我们构建最终的MST。我们没有使用子图作为实际的MST本身。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="f426" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们知道什么是<code class="fe oj ok ol ob b">Node</code>结构，一个<code class="fe oj ok ol ob b">NodePair</code>结构仅仅是一个有<code class="fe oj ok ol ob b">Node</code>和<code class="fe oj ok ol ob b">Edge</code>的结构。这代表一对节点，有一条边连接两个节点(记住<code class="fe oj ok ol ob b">Edge</code>本身有一个节点和一个权重)。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="7960" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们为什么要这样做？在一个图中，我们用一个map来表示边，这个map将节点名作为键，将一部分<code class="fe oj ok ol ob b">Edge</code> structs作为值，但是我们不能在图之外表示它，所以我们需要使用其他的东西。</p><p id="bb04" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们初始化子图切片，MST中的每个节点也表示为一个子图。每个子图都有一些连接它和其他子图的边，这由一个<code class="fe oj ok ol ob b">NodePair</code>表示。</p><p id="f417" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一旦设置好了，我们就取第一个子图，并对它的所有节点对进行排序，以得到最小权重边，该边从这个子图的一个节点连接到另一个子图中的另一个节点。</p><p id="f482" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们将这条边添加到<code class="fe oj ok ol ob b">mst</code>图中，并组合这两个子图。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="7ee7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe oj ok ol ob b">combine</code>函数只是将两个子图结合在一起。首先，我们需要找到这两个子图。接下来，我们将第二子图的节点和节点对添加到第一个子图中。哪个子图被添加到哪个子图并不重要，因为在一天结束的时候，所有子图都被添加到了一起，成为一个子图。</p><p id="e254" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来是剔除从新的组合子图中的一个节点连接到同一子图中的另一个节点的边。我们使用<code class="fe oj ok ol ob b">in</code>函数来解决这个问题。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="2649" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一旦节点对被清理干净，我们就移除第二子图。</p><p id="5f6a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们重复这样做，直到只剩下1个子图。在这个时间点上，最后剩下的子图是MST，但是同时我们也已经建立了MST in out <code class="fe oj ok ol ob b">mst</code>图。</p><p id="0517" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们再次运行main函数，这次可视化mst图。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="1872" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是你应该看到的。</p><pre class="lg lh li lj gu oa ob oc od aw oe bi"><span id="f1cd" class="mv lz iu ob b gz of og l oh oi">GRAPH<br/>-----<br/>A -&gt; [B(7) D(4)]<br/>B -&gt; [A(7) C(11) D(9) E(10)]<br/>C -&gt; [B(11) E(5)]<br/>D -&gt; [A(4) B(9) E(15) F(6)]<br/>E -&gt; [B(10) C(5) D(15) F(12) G(8)]<br/>F -&gt; [D(6) E(12) G(13)]<br/>G -&gt; [E(8) F(13)]</span><span id="4e23" class="mv lz iu ob b gz om og l oh oi">BORUVSKA MINIMUM SPANNING TREE<br/>-----------------------------<br/>A -&gt; [D(4) B(7)]<br/>B -&gt; [A(7) E(10)]<br/>C -&gt; [E(5)]<br/>D -&gt; [A(4) F(6)]<br/>E -&gt; [B(10) C(5) G(8)]<br/>F -&gt; [D(6)]<br/>G -&gt; [E(8)]</span></pre><p id="aade" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">试着把这个和上面的图匹配一下，看看是否符合！</p><p id="fec6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来我们来看看克鲁斯卡尔的算法。</p><h1 id="c449" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">围棋中的克鲁斯卡尔算法</h1><p id="3177" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">这就是算法。给定一个带节点和边的加权无向图G:</p><ol class=""><li id="f5ff" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le nm nn no np bi translated">从G中所有节点的图M开始，但是没有边</li><li id="1ddd" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">在列表L中，根据权重对所有边进行排序</li><li id="d788" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">从L中取最小重量的边，加到m上。</li><li id="8c6f" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">检查这是否会创建一个循环图。如果有，去掉边缘，否则不要管它</li><li id="c075" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">重复步骤(3)和(4)，直到L为空</li></ol><p id="27c5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是代码。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="dc5c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">该算法使用了我们之前在Boruvka算法中看到的相同的<code class="fe oj ok ol ob b">NodePair</code>。我们还需要创建一个min堆，并向<code class="fe oj ok ol ob b">Graph</code>结构添加一些方法。让我们从min堆开始。</p><p id="119f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">Go标准库有一个打包的<code class="fe oj ok ol ob b">container/heap</code>，带有一个名为<code class="fe oj ok ol ob b">Interface</code>的接口，您可以用它来实现自己的堆。你需要做的是实现<code class="fe oj ok ol ob b">sort</code>包中的<code class="fe oj ok ol ob b">Interface</code>，这意味着你需要实现<code class="fe oj ok ol ob b">Len</code>、<code class="fe oj ok ol ob b">Less</code>和<code class="fe oj ok ol ob b">Swap</code>，此外还有两个名为<code class="fe oj ok ol ob b">Push</code>和<code class="fe oj ok ol ob b">Pop</code>的方法。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="b7c7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这些方法实现起来非常简单。方法<code class="fe oj ok ol ob b">Len</code>、<code class="fe oj ok ol ob b">Less</code>和<code class="fe oj ok ol ob b">Swap</code>非常简单，就像你如何实现对任何结构片的排序一样。<code class="fe oj ok ol ob b">Less</code>方法确定它是最小堆还是最大堆。</p><p id="d8e9" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe oj ok ol ob b">Push</code>方法只是简单地添加到堆中，而<code class="fe oj ok ol ob b">Pop</code>从堆中移除。您可能会注意到<code class="fe oj ok ol ob b">Push</code>和<code class="fe oj ok ol ob b">Pop</code>方法分别接受和返回<code class="fe oj ok ol ob b">any</code>。这是最近发布的Go泛型1.8中的新特性。这在<code class="fe oj ok ol ob b">Pop</code>中不太重要，但是对于<code class="fe oj ok ol ob b">Push</code>来说，变化只是在追加参数之前将参数声明为<code class="fe oj ok ol ob b">NodePair</code>。这与1.7和之前的版本没有什么不同，因为之前它是一个空接口(<code class="fe oj ok ol ob b">interface{}</code>)，你也需要做类型断言。</p><p id="f499" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">使用这个堆实现的一个常见错误是忘记使用<code class="fe oj ok ol ob b">heap.Init</code>初始化堆。您不能在创建堆后立即使用它，您需要在开始使用它之前运行它:</p><pre class="lg lh li lj gu oa ob oc od aw oe bi"><span id="1345" class="mv lz iu ob b gz of og l oh oi">h := &amp;Heap{}<br/>heap.Init(h)</span></pre><p id="3efb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">除了min堆，我们还需要增加一些方法:</p><ul class=""><li id="7933" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le on nn no np bi translated"><code class="fe oj ok ol ob b">HasEdge</code> —检查图形是否有特定的边</li><li id="8fc2" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le on nn no np bi translated"><code class="fe oj ok ol ob b">RemoveEdge</code> —从图形中删除给定的边</li><li id="4f90" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le on nn no np bi translated"><code class="fe oj ok ol ob b">IsCyclic</code> —检查图形是否循环</li></ul><p id="d469" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><code class="fe oj ok ol ob b">HasEdge</code>方法很简单。给定节点名称，我们遍历所有的边，如果边节点的名称和边权重检查通过，我们返回true。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="a543" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">移除边有点棘手，因为这是一个无向图，我们需要从节点的两端来看。然而，步骤是相同的，我们获得给定节点的所有边，并删除边节点名称匹配的边，只是我们需要在两边都这样做。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="3f76" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">检查一个图是否是循环的需要我们对图进行深度优先遍历。有几种方法可以实现这一点，但在这种实现中，我们需要一个堆栈。堆栈的元素是一个指向<code class="fe oj ok ol ob b">Node</code>的指针的2元素数组。</p><p id="c334" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">第一个元素是父节点，第二个是子节点。堆栈实现现在应该很熟悉了——推入和弹出堆栈只是简单地添加一个元素或从元素切片中移除一个元素。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="78f5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们从将一个元素推到父节点和子节点相同的堆栈开始遍历。在每次迭代中，我们弹出堆栈，如果子节点以前没有被访问过，我们将其标记为已访问，然后遍历子节点的边。如果边缘节点没有被访问过，我们将一个新元素推送到堆栈上，其中父节点是当前节点，子节点是边缘节点。如果边节点已经被访问过，这意味着图是循环的。</p><p id="46aa" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果我们遍历整个图而没有遇到边节点，这意味着该图不是循环的。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="d83c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在让我们运行这个算法，看看我们得到了什么。</p><pre class="lg lh li lj gu oa ob oc od aw oe bi"><span id="e422" class="mv lz iu ob b gz of og l oh oi">GRAPH<br/>-----<br/>A -&gt; [B(7) D(4)]<br/>B -&gt; [A(7) C(11) D(9) E(10)]<br/>C -&gt; [B(11) E(5)]<br/>D -&gt; [A(4) B(9) E(15) F(6)]<br/>E -&gt; [B(10) C(5) D(15) F(12) G(8)]<br/>F -&gt; [D(6) E(12) G(13)]<br/>G -&gt; [E(8) F(13)]</span><span id="ff5a" class="mv lz iu ob b gz om og l oh oi">BORUVSKA MINIMUM SPANNING TREE<br/>-----------------------------<br/>A -&gt; [D(4) B(7)]<br/>B -&gt; [A(7) E(10)]<br/>C -&gt; [E(5)]<br/>D -&gt; [A(4) F(6)]<br/>E -&gt; [B(10) C(5) G(8)]<br/>F -&gt; [D(6)]<br/>G -&gt; [E(8)]</span><span id="bba7" class="mv lz iu ob b gz om og l oh oi">KRUSKAL MINIMUM SPANNING TREE<br/>-----------------------------<br/>A -&gt; [D(4) B(7)]<br/>B -&gt; [A(7) E(10)]<br/>C -&gt; [E(5)]<br/>D -&gt; [A(4) F(6)]<br/>E -&gt; [C(5) G(8) B(10)]<br/>F -&gt; [D(6)]<br/>G -&gt; [E(8)]</span></pre><p id="fbd0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">你可能会觉得这个算法实现起来有点长，但是没有一个部分是困难的，事实上它们是非常常见的图形算法和数据结构。</p><p id="80b0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个三重奏的最后一个算法是Prim的算法。</p><h1 id="944d" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">围棋中的Prim算法</h1><p id="ce65" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">和以前一样，我们再看一下算法。给定一个带节点和边的加权无向图G:</p><ol class=""><li id="2a20" class="nh ni iu kl b km kn kp kq ks nj kw nk la nl le nm nn no np bi translated">从一个空图M开始，图G中的一个任意节点作为当前节点</li><li id="d4e3" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">找到图G中当前节点的所有边，并将其添加到最小堆中</li><li id="ea41" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">弹出最小堆以获得最小权重的边。将边添加到图m。(在后面的迭代中，该边可能不是连接到当前节点的边)</li><li id="385a" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">使边节点成为当前节点，并将其添加到图M中</li><li id="175a" class="nh ni iu kl b km nq kp nr ks ns kw nt la nu le nm nn no np bi translated">重复步骤(2)到(4)，直到图G中的所有节点也在图M中</li></ol><p id="7a2f" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是算法的代码。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="aeb1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您会注意到函数签名有点不同。不是只接受一个参数，图形，<code class="fe oj ok ol ob b">prim</code>函数接受图形和节点名。这是因为Prim需要从图中的一个节点开始。它可以是任何节点，所以我可以随机选择一个，但我选择了一个起始节点。</p><p id="8033" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">该算法还使用了像Kruskal算法中的最小节点对堆。我们从一个<code class="fe oj ok ol ob b">mst</code>图开始，然后添加开始节点。然后，我们获取开始节点的所有边，并使用它创建节点对，将每个节点对推入堆中。</p><p id="959a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然后，当堆不为空时，我们将弹出节点对，并检查MST是否已经有了边缘节点。如果没有，我们将边节点和边添加到<code class="fe oj ok ol ob b">mst</code>中。</p><p id="23e6" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们还将从边缘节点中取出所有的边缘，并在下一个周期将它们作为节点对推入堆中。这样，我们将遍历图中的所有节点和边..</p><p id="e895" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">检查图形是否有特定的节点需要我们为图形创建一个新的方法。这个方法很简单，不需要太多解释。我们简单地遍历图中的所有节点，如果找到节点，则返回true。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="3c4b" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">Prim的算法看起来是3个算法中最简单的，但那是因为我们已经实现了之前需要的函数和数据结构。</p><p id="84c8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">下面是运行main时的结果，包括Prim的算法。</p><pre class="lg lh li lj gu oa ob oc od aw oe bi"><span id="eccb" class="mv lz iu ob b gz of og l oh oi">GRAPH<br/>-----<br/>A -&gt; [B(7) D(4)]<br/>B -&gt; [A(7) C(11) D(9) E(10)]<br/>C -&gt; [B(11) E(5)]<br/>D -&gt; [A(4) B(9) E(15) F(6)]<br/>E -&gt; [B(10) C(5) D(15) F(12) G(8)]<br/>F -&gt; [D(6) E(12) G(13)]<br/>G -&gt; [E(8) F(13)]</span><span id="1074" class="mv lz iu ob b gz om og l oh oi">BORUVSKA MINIMUM SPANNING TREE<br/>-----------------------------<br/>A -&gt; [D(4) B(7)]<br/>B -&gt; [A(7) E(10)]<br/>C -&gt; [E(5)]<br/>D -&gt; [A(4) F(6)]<br/>E -&gt; [B(10) C(5) G(8)]<br/>F -&gt; [D(6)]<br/>G -&gt; [E(8)]</span><span id="1d7f" class="mv lz iu ob b gz om og l oh oi">KRUSKAL MINIMUM SPANNING TREE<br/>-----------------------------<br/>A -&gt; [D(4) B(7)]<br/>B -&gt; [A(7) E(10)]<br/>C -&gt; [E(5)]<br/>D -&gt; [A(4) F(6)]<br/>E -&gt; [C(5) G(8) B(10)]<br/>F -&gt; [D(6)]<br/>G -&gt; [E(8)]</span><span id="9d2d" class="mv lz iu ob b gz om og l oh oi">PRIM MINIMUM SPANNING TREE<br/>-------------------------<br/>A -&gt; [D(4) B(7)]<br/>B -&gt; [A(7) E(10)]<br/>C -&gt; [E(5)]<br/>D -&gt; [A(4) F(6)]<br/>E -&gt; [B(10) C(5) G(8)]<br/>F -&gt; [D(6)]<br/>G -&gt; [E(8)]</span></pre><h1 id="c16b" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">对3种算法进行基准测试</h1><p id="a66d" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">现在我们已经有了所有的3个，接下来要做的当然是对它们进行基准测试。</p><figure class="lg lh li lj gu lk"><div class="bz fq l di"><div class="nw nx l"/></div></figure><p id="1ad8" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是基准测试结果。</p><pre class="lg lh li lj gu oa ob oc od aw oe bi"><span id="af2b" class="mv lz iu ob b gz of og l oh oi">% go test -bench=. -benchmem<br/>goos: darwin<br/>goarch: amd64<br/>pkg: github.com/sausheong/gocookbook/graph<br/>cpu: VirtualApple @ 2.50GHz<br/>BenchmarkBoruvka-10       112311      10238 ns/op     4488 B/op      183 allocs/op<br/>BenchmarkKruskal-10        72430      16436 ns/op     4623 B/op      147 allocs/op<br/>BenchmarkPrim-10          220465       5326 ns/op     2120 B/op       81 allocs/op<br/>PASS<br/>ok   github.com/sausheong/gocookbook/graph 4.109s</span></pre><p id="c8bb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">可以看到，Prim的算法在5.3ms左右性能最好，比Kruskal的算法在16.4ms左右快3倍左右，Boruvka的算法在10.2ms，当然这些都是未优化的实现。</p><h1 id="68ae" class="ly lz iu bd ma mb mc md me mf mg mh mi ka mj kb mk kd ml ke mm kg mn kh mo mp bi translated">密码</h1><p id="bac2" class="pw-post-body-paragraph kj kk iu kl b km mq jv ko kp mr jy kr ks ms ku kv kw mt ky kz la mu lc ld le in bi translated">这里的所有代码都可以在这个库中找到。</p><div class="oo op gq gs oq or"><a href="https://github.com/sausheong/mst" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fp"><div class="ot ab ou cl cj ov"><h2 class="bd iv gz z fq ow fs ft ox fv fx it bi translated">GitHub - sausheong/mst:最小生成树算法的代码库</h2><div class="oy l"><h3 class="bd b gz z fq ow fs ft ox fv fx dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oz l"><p class="bd b dl z fq ow fs ft ox fv fx dk translated">github.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf lp or"/></div></div></a></div></div></div>    
</body>
</html>