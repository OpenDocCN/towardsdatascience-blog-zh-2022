<html>
<head>
<title>Iterable, Ordered, Mutable, and Hashable Python Objects Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了可迭代、有序、可变和可散列的 Python 对象</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/iterable-ordered-mutable-and-hashable-python-objects-explained-1254c9b9e421#2022-03-15">https://towardsdatascience.com/iterable-ordered-mutable-and-hashable-python-objects-explained-1254c9b9e421#2022-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="648c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">讨论这些术语的真正含义和暗示，它们的主要细微差别，以及一些有用的变通方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbcb202df71080a5182b41317ce9766b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFyK789ILPwYT3c0GBI-DA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://pixabay.com/photos/archive-boxes-shelf-folders-1850170/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="2ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可迭代、有序、可变和可散列(以及它们的反义词)是描述 Python 对象或数据类型的特征。尽管经常使用，这些术语经常被混淆或误解。在本文中，我们将讨论每个属性的真正含义和暗示，它们与什么数据类型相关，这些属性的主要细微差别，以及一些有用的解决方法。</p><h1 id="cb10" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可迭代的</h1><p id="2a05" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 中的 iterable 对象是这样一种对象，它可以通过循环来逐个提取其项目，或者对每个项目应用特定的操作并返回结果。可迭代对象大多是表示一组项目(列表、元组、集、冷冻集、字典、范围和迭代器)的复合对象，但字符串也是可迭代的。</p><p id="6791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于所有可迭代的数据类型，我们可以使用 For 循环来迭代对象:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ce2a" class="mx lw it mt b gy my mz l na nb">for i in (1, 2, 3):<br/>    print(i)</span><span id="3ebe" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:</strong><br/>1<br/>2<br/>3</span></pre><p id="5b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于 Python 字典，默认情况下对字典键执行迭代:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cd08" class="mx lw it mt b gy my mz l na nb">dct = {'a': 1, 'b': 2}<br/>print('Dictionary:', dct)</span><span id="ba21" class="mx lw it mt b gy nc mz l na nb">print('Iterating over the dictionary keys:')<br/>for i in dct:<br/>    print(i)</span><span id="4f57" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:</strong><br/>Dictionary: {'a': 1, 'b': 2}<br/>Iterating over the dictionary keys:<br/>a<br/>b</span></pre><p id="56fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要迭代字典值，我们必须在字典上使用<code class="fe nd ne nf mt b">values()</code>方法:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0510" class="mx lw it mt b gy my mz l na nb">print('Iterating over the dictionary values:')<br/>for i in dct.values():<br/>    print(i)</span><span id="e3ab" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>Iterating over the dictionary values:<br/>1<br/>2</span></pre><p id="6c4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果我们想要迭代字典键和值，我们应该使用<code class="fe nd ne nf mt b">items()</code>方法:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="abbf" class="mx lw it mt b gy my mz l na nb">print('Iterating over the dictionary keys and values:')<br/>for k, v in dct.items():<br/>    print(k, v)</span><span id="a863" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>Iterating over the dictionary keys and values:<br/>a 1<br/>b 2</span></pre><p id="61e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有可迭代的 Python 对象都有<code class="fe nd ne nf mt b">__iter__</code>属性。因此，检查 Python 对象是否可迭代的最简单方法是对其使用<code class="fe nd ne nf mt b">hasattr()</code>方法，检查<code class="fe nd ne nf mt b">__iter__</code>属性是否可用:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bec8" class="mx lw it mt b gy my mz l na nb">print(hasattr(3.14, '__iter__'))<br/>print(hasattr('pi', '__iter__'))</span><span id="8582" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>False<br/>True</span></pre><p id="4ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nd ne nf mt b">iter()</code>函数从任何可迭代的 Python 对象中获得迭代器对象:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2f2b" class="mx lw it mt b gy my mz l na nb">lst = [1, 2, 3]<br/>print(type(lst))</span><span id="e1c6" class="mx lw it mt b gy nc mz l na nb">iter_obj = iter(lst)<br/>print(type(iter_obj))</span><span id="6344" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>&lt;class 'list'&gt;<br/>&lt;class 'list_iterator'&gt;</span></pre><p id="920e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完全符合预期(有点赘述)，迭代器对象是可迭代的，所以我们可以对它进行迭代。<strong class="lb iu">然而</strong>与所有其他可迭代对象不同，迭代器对象会在迭代过程中一个接一个地丢失元素:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f24b" class="mx lw it mt b gy my mz l na nb">lst = [1, 2, 3]<br/>iter_obj = iter(lst)<br/>print('The iterator object length before iteration:')<br/>print(len(list(iter_obj)))</span><span id="b4a6" class="mx lw it mt b gy nc mz l na nb">for i in iter_obj:<br/>    pass<br/>print('The iterator object length after iteration:')<br/>print(len(list(iter_obj)))</span><span id="6ab5" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>The iterator object length before iteration:<br/>3<br/>The iterator object length after iteration:<br/>0</span></pre><p id="c497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，没有像其他可迭代数据类型的内置函数<code class="fe nd ne nf mt b">len()</code>那样直接检查迭代器对象长度的方法。因此，为了检查迭代器中的项数，我们首先必须将它转换成另一个可迭代对象，比如一个列表或元组，然后才在其上应用<code class="fe nd ne nf mt b">len()</code>函数:<code class="fe nd ne nf mt b">len(list(iter_obj))</code>。</p><h1 id="3a3a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有序与无序</h1><p id="b3a4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 中的有序对象是那些<em class="ng"> iterable </em>对象，其中的项目保持确定的顺序，除非我们有意更新这些对象(插入新项目、删除项目、排序项目)。有序对象是字符串、列表、元组、范围和字典(从 Python 3.7+开始)、无序集、冷冻集和字典(在 Python 3.7 之前的版本中)。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e4c3" class="mx lw it mt b gy my mz l na nb">lst = ['a', 'b', 'c', 'd']<br/>s = {'a', 'b', 'c', 'd'}<br/>print(lst)<br/>print(s)</span><span id="1340" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>['a', 'b', 'c', 'd']<br/>{'b', 'c', 'a', 'd'}</span></pre><p id="f388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于有序对象中的顺序被保留，我们可以通过索引或切片来访问和修改对象的项目:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cd52" class="mx lw it mt b gy my mz l na nb">lst = ['a', 'b', 'c', 'd']</span><span id="6825" class="mx lw it mt b gy nc mz l na nb"># Access the 1st item of the list.<br/>print(lst[0])</span><span id="9878" class="mx lw it mt b gy nc mz l na nb"># Access the 2nd and 3rd items of the list.<br/>print(lst[1:3])</span><span id="872d" class="mx lw it mt b gy nc mz l na nb"># Modify the 1st item.<br/>lst[0] = 'A'<br/>print(lst[0])</span><span id="c8c7" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>a<br/>['b', 'c']<br/>A</span></pre><p id="67f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从 Python 字典中提取特定的值，我们通常使用相应的键名称，而不是字典中的键索引:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="ce6b" class="mx lw it mt b gy my mz l na nb">dct = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}<br/>print(dct['b'])</span><span id="d3a0" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>2</span></pre><p id="11e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果出于某种原因，我们需要提取字典中已知位置的键的值(假设我们只知道<em class="ng">的位置，而不知道键本身)，或者字典中定义了位置范围的一部分键的一组值，我们在技术上仍然可以做到:</em></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0649" class="mx lw it mt b gy my mz l na nb">dct = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}</span><span id="cd6d" class="mx lw it mt b gy nc mz l na nb"># Access the value of the 1st key in the dictionary.<br/>print(list(dct.values())[0])</span><span id="f983" class="mx lw it mt b gy nc mz l na nb"># Access the values of the 2nd to 4th keys in the dictionary.<br/>print(list(dct.values())[1:4])</span><span id="d15a" class="mx lw it mt b gy nc mz l na nb"># Access the 2nd to 4th keys in the dictionary.<br/>print(list(dct.keys())[1:4])</span><span id="6e9d" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>1<br/>[2, 3, 4]<br/>['b', 'c', 'd']</span></pre><p id="2596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的解决方法不是很直接。但是，它有助于通过键或值来索引 Python 字典。</p><p id="311d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在无序对象中，我们不能访问单个项目:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="07f8" class="mx lw it mt b gy my mz l na nb">s = {'a', 'b', 'c', 'd'}<br/>print(s[0])</span><span id="e4ee" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/>---------------------------------------------------------------------------</strong><br/><strong class="mt iu">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="mt iu">~\AppData\Local\Temp/ipykernel_9980/849534030.py</strong> in &lt;module&gt;<br/>      1 s <strong class="mt iu">=</strong> <strong class="mt iu">{'a',</strong> <strong class="mt iu">'b',</strong> <strong class="mt iu">'c',</strong> <strong class="mt iu">'d'}</strong><br/><strong class="mt iu">----&gt; 2 </strong>print<strong class="mt iu">(</strong>s<strong class="mt iu">[0])</strong><br/><br/><strong class="mt iu">TypeError</strong>: 'set' object is not subscriptable</span></pre><p id="377a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们有一个包含其他复合对象的复合有序对象，我们可以更深入地挖掘并访问该对象项目的内部项目，如果它们也是有序的。例如，如果一个 Python 列表包含另一个 Python 列表，我们可以访问内部列表的项目:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cf10" class="mx lw it mt b gy my mz l na nb">lst_2 = [[1, 2, 3], {1, 2, 3}, 10]<br/>print(lst_2[0][2])</span><span id="dbf2" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>3</span></pre><p id="e792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不能访问列表中集合的项目，因为 Python 集合是无序的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="26ec" class="mx lw it mt b gy my mz l na nb">print(lst_2[1][2])</span><span id="ddac" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/>---------------------------------------------------------------------------</strong><br/><strong class="mt iu">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="mt iu">~\AppData\Local\Temp/ipykernel_9980/895995558.py</strong> in &lt;module&gt;<br/><strong class="mt iu">----&gt; 1 </strong>print<strong class="mt iu">(</strong>lst_2<strong class="mt iu">[1][2])</strong><br/><br/><strong class="mt iu">TypeError</strong>: 'set' object is not subscriptable</span></pre><h1 id="fe1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可变与不可变</h1><p id="66b3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Python 中的可变对象是那些可以被修改的对象。<strong class="lb iu">可变性并不一定意味着能够通过索引或切片来访问复合对象的单个项目。</strong>例如，一个 Python 集合是无序的和无索引的，然而，它是一个可变的数据类型，因为我们可以通过添加新的条目或从中删除条目来修改它。</p><p id="8679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Python tuple 是一种不可变的数据类型，但是我们可以通过索引和切片轻松地访问它的各个项(但是不能修改它们)。此外，还可以对 range 对象进行索引和切片，从中提取整数或更小的范围。</p><p id="6c97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，可变数据类型是列表、字典、集合和字节数组，而不可变数据类型是所有原始数据类型(字符串、整数、浮点、复杂、布尔、字节)、范围、元组和冻结集。</p><p id="8fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们探讨一个关于元组的有趣警告。作为不可变的数据类型，元组可以包含可变数据类型的项目，例如列表:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3f30" class="mx lw it mt b gy my mz l na nb">tpl = ([1, 2], 'a', 'b')<br/>print(tpl)</span><span id="c635" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>([1, 2], 'a', 'b')</span></pre><p id="3d73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的元组包含一个列表作为它的第一项。我们可以访问它，但不能为此项目重新分配其他值:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f5c9" class="mx lw it mt b gy my mz l na nb"># Access the 1st item of the tuple.<br/>print(tpl[0])</span><span id="076f" class="mx lw it mt b gy nc mz l na nb"># Try to re-assign a new value to the 1st item of the tuple.<br/>tpl[0] = 1</span><span id="4a92" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>[1, 2]</span><span id="3541" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">---------------------------------------------------------------------------</strong><br/><strong class="mt iu">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="mt iu">~\AppData\Local\Temp/ipykernel_9980/4141878083.py</strong> in &lt;module&gt;<br/>      3 <br/>      4 <strong class="mt iu"># Trying to modify the first item of the tuple</strong><br/><strong class="mt iu">----&gt; 5 </strong>tpl<strong class="mt iu">[0]</strong> <strong class="mt iu">=</strong> <strong class="mt iu">1</strong><br/><br/><strong class="mt iu">TypeError</strong>: 'tuple' object does not support item assignment</span></pre><p id="b6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，由于 Python 列表是可变的有序数据类型，我们既可以访问它的任何项，也可以修改它们:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="736d" class="mx lw it mt b gy my mz l na nb"># Access the 1st item of the list.<br/>print(tpl[0][0])</span><span id="2f2f" class="mx lw it mt b gy nc mz l na nb"># Modify the 1st item of the list.<br/>tpl[0][0] = 10</span><span id="8739" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>1</span></pre><p id="27b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果，我们的元组中的一个项目被改变了，并且元组本身看起来不同于最初的那个:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="6bc9" class="mx lw it mt b gy my mz l na nb">print(tpl)</span><span id="e31f" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>([10, 2], 'a', 'b')</span></pre><h1 id="acba" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可散列与不可散列</h1><p id="8345" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">可散列 Python 对象是任何具有散列值的对象，散列值是该对象的一个整数标识符，在其生命周期中不会改变。为了检查一个对象是否是可散列的，并找出它的散列值(如果它是可散列的)，我们在这个对象上使用了<code class="fe nd ne nf mt b">hash()</code>函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9aed" class="mx lw it mt b gy my mz l na nb">print(hash(3.14))</span><span id="71af" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>322818021289917443</span></pre><p id="1364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象不可修复，将抛出一个<code class="fe nd ne nf mt b">TypeError</code>:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7f1c" class="mx lw it mt b gy my mz l na nb">print(hash([1, 2]))</span><span id="ed5e" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/>---------------------------------------------------------------------------</strong><br/><strong class="mt iu">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="mt iu">~\AppData\Local\Temp/ipykernel_9980/3864786969.py</strong> in &lt;module&gt;<br/><strong class="mt iu">----&gt; 1 </strong>hash<strong class="mt iu">([1,</strong> <strong class="mt iu">2])</strong><br/><br/><strong class="mt iu">TypeError</strong>: unhashable type: 'list'</span></pre><p id="f563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ng">几乎</em>所有不可变的对象都是可散列的(我们很快会看到一个特殊的例外)，而不是所有可散列的对象都是不可变的。特别是，所有的原始数据类型(字符串、整数、浮点、复数、布尔、字节)、范围、冷冻集、函数和类，无论是内置的还是用户定义的，都是可散列的，而列表、字典、集合和字节数组是不可散列的。</p><p id="9007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个奇怪的例子是 Python 元组。因为它是不可变的数据类型，所以应该是可散列的。事实上，似乎是这样的:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="700e" class="mx lw it mt b gy my mz l na nb">print(hash((1, 2, 3)))</span><span id="d313" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>529344067295497451</span></pre><p id="79a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还要注意，如果我们将这个元组赋给一个变量，然后对该变量运行<code class="fe nd ne nf mt b">hash()</code>函数，我们将获得相同的哈希值:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="4f54" class="mx lw it mt b gy my mz l na nb">a_tuple = (1, 2, 3)<br/>print(hash(a_tuple))</span><span id="e1b0" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>529344067295497451</span></pre><p id="10ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个元组包含可变项，就像我们在上一节中看到的那样，会怎么样呢？</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="2f06" class="mx lw it mt b gy my mz l na nb">tpl = ([1, 2], 'a', 'b')<br/>print(hash(tpl))</span><span id="2e89" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/>---------------------------------------------------------------------------</strong><br/><strong class="mt iu">TypeError</strong>                                 Traceback (most recent call last)<br/><strong class="mt iu">~\AppData\Local\Temp/ipykernel_8088/3629296315.py</strong> in &lt;module&gt;<br/>      1 tpl <strong class="mt iu">=</strong> <strong class="mt iu">([1,</strong> <strong class="mt iu">2],</strong> <strong class="mt iu">'a',</strong> <strong class="mt iu">'b')</strong><br/><strong class="mt iu">----&gt; 2 </strong>print<strong class="mt iu">(</strong>hash<strong class="mt iu">(</strong>tpl<strong class="mt iu">))</strong><br/><br/><strong class="mt iu">TypeError</strong>: unhashable type: 'list'</span></pre><p id="0422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到 Python 元组可以是可散列的，也可以是不可散列的。只有当它们包含至少一个可变项时，它们才是不可取消的。</p><p id="0f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，即使是不可修复的元组，如上图所示，也有<code class="fe nd ne nf mt b">__hash__</code>属性:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8b02" class="mx lw it mt b gy my mz l na nb"># Check if a hashable tuple has the '__hash__' attribute.<br/>print(hasattr((1, 2, 3), '__hash__'))</span><span id="c6ec" class="mx lw it mt b gy nc mz l na nb"># Check if an unhashable tuple has the '__hash__' attribute.<br/>print(hasattr(([1, 2], 'a', 'b'), '__hash__'))</span><span id="6cbf" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>True<br/>True</span></pre><p id="14ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们前面提到过，并不是所有的可散列对象都是不可变的。这种情况的一个例子是可变但可散列的用户定义类。此外，类的所有实例都是可散列的，并且具有与类本身相同的散列值:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7b12" class="mx lw it mt b gy my mz l na nb">class MyClass:<br/>    pass</span><span id="25a5" class="mx lw it mt b gy nc mz l na nb">x = MyClass</span><span id="71de" class="mx lw it mt b gy nc mz l na nb">print(hash(MyClass))<br/>print(hash(x))</span><span id="7666" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>170740243488<br/>170740243488</span></pre><p id="1cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，当两个 Python 对象相等时，它们的哈希值也相等:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="be5c" class="mx lw it mt b gy my mz l na nb"># Check the equal objects and their hash values.<br/>print(True==1)<br/>print(hash(True)==hash(1))</span><span id="5fc4" class="mx lw it mt b gy nc mz l na nb"># Check the unequal objects and their hash values.<br/>print('god'=='dog')<br/>print(hash('god')==hash('dog'))</span><span id="a8ae" class="mx lw it mt b gy nc mz l na nb"><strong class="mt iu">Output:<br/></strong>True<br/>True<br/>False<br/>False</span></pre><h1 id="9c32" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="56a8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">总之，我们从多个方面详细探讨了经常使用但经常被误解的 Python 对象和数据类型特征，如可迭代、有序、可变、可散列以及它们的对立面，包括一些特殊情况和例外。</p><p id="0e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="3d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">你会发现这些文章也很有趣:</strong></p><div class="no np gp gr nq nr"><a rel="noopener follow" target="_blank" href="/16-underrated-pandas-series-methods-and-when-to-use-them-c696e17fbaa4"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">16 种被低估的熊猫系列方法以及何时使用它们</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Hasnans、pct_change、is_monotonic、repeat 以及许多其他</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">towardsdatascience.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://levelup.gitconnected.com/when-a-python-gotcha-leads-to-wrong-results-2447f379fdfe" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">当 Python 陷阱导致错误结果时</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">一个奇怪的难以调试的带有舍入数字的 Python 故障</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://medium.com/geekculture/creating-toyplots-in-python-49de0bb27ec1" rel="noopener follow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">在 Python 🧸中创建玩具图</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">高质量的极简交互式可视化，非常适合电子出版</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">medium.com</p></div></div><div class="oa l"><div class="oh l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>