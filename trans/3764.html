<html>
<head>
<title>Interview Question: Select a Random Line from a File (in Python)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试问题:从文件中随机选择一行(Python中)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/interview-question-select-a-random-line-from-a-file-in-python-4756eac40075#2022-08-22">https://towardsdatascience.com/interview-question-select-a-random-line-from-a-file-in-python-4756eac40075#2022-08-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c263" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个很酷很有用的算法解释和扩展</h2></div><p id="2f79" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">卡尔·m·卡迪和克里斯托弗·米克</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/9314162bb380abd2a3ac994409eaff5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Vo7DXhHh1QsW3kHRXVrSg.png"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">从文件中随机选择一行文本的python来源:【https://openai.com/dall-e-2/ T2】</p></figure><p id="bce5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我(卡尔)面试你在微软的工作，我可能会问你这个问题:</p><blockquote class="ls"><p id="5c57" class="lt lu iq bd lv lw lx ly lz ma mb la dk translated">如何从未知长度的文本文件中随机选择一行？</p></blockquote><p id="29f9" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我在微软研究院，在最初的反垃圾邮件团队，在一个办公室机器学习/数据科学小组，都问过这个问题。我们喜欢这个问题，因为它涉及概率、算法和系统问题。</p><p id="b794" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使已经从微软退休，我们仍然会思考随机线问题。例如，我们最近学习了<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>。这是一个Rust crate，它使用SIMD CPU指令来加速计算文件中的行数。正如我们稍后将描述的，我们对板条箱的学习间接导致了我们对随机线问题最喜欢的解决方案的改进。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="b877" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将这篇文章组织成一系列的问题和提示。如果你愿意，在看到我们的回答之前，你可以试着自己回答问题。</p><blockquote class="ms mt mu"><p id="14f8" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">在本文中，我们将用Python给出答案。Rust中的答案见本文的<a class="ae lr" rel="noopener" target="_blank" href="/interview-question-select-a-random-line-from-a-file-in-rust-c0a8cddcddfb"> Rust版。你可能也喜欢阅读这两个版本，作为比较两种语言的一种方式。</a></p></blockquote><p id="c97c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于白板面试，我们给了受访者以下建议:</p><ul class=""><li id="374c" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">请随意提出澄清性问题。(在本文的上下文中，您可以进一步阅读，看看我们是否提供了澄清。)</li><li id="1b8c" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">首先从正确的算法开始，即使它可能不是最佳的。如果我们想要一个更好的算法，我们会用后续问题来提示您。</li><li id="3f22" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">不要担心精确的语法。例如，我们不关心你是否记得产生随机数的确切方法。(在本文中，我们将用Python给出答案。)</li><li id="20eb" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">如果你卡住了，我们可以提供一些提示。(还是那句话，在这篇文章的上下文中，读远一点寻找提示。)</li></ul><p id="363a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从问题开始:</p><h2 id="937e" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:如何从未知长度的文本文件中随机选择一行？</h2><p id="67b0" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>我们首先要明确一个“随机线”的含义。我们的意思是文本文件中的每一行都有相等的机会被返回。换句话说，我们希望算法通过均匀分布在这些线中进行选择。</p><p id="ff97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个要求意味着你<strong class="kh ir">不能</strong>使用这个算法，我们称之为<code class="fe mh mi mj mk b">AlgoRandomSeek</code>:</p><ul class=""><li id="a239" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">向文件系统询问文件的长度。</li><li id="770f" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">随机选择一个文件位置并查找到该位置。</li><li id="3bfb" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">在位置附近返回一条线。</li></ul><p id="159a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">Sub Q:</strong><code class="fe mh mi mj mk b">AlgoRandomSeek</code>怎么了？</p><p id="cdde" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub A </strong>:虽然该算法可以返回文件中的任何行，但它返回较长行的概率高于较短行，因此不会通过均匀分布选择行。</p><blockquote class="ms mt mu"><p id="dd00" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:我们喜欢被要求澄清。它将“随机”的日常含义与统计学、数据科学、决策理论和机器学习中使用的技术含义区分开来。</p></blockquote><p id="5693" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示:</strong>如果你在用Python编程，需要快速(但正确地)解决随机线问题，你会怎么做？</p><p id="1589" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们向GitHub Copilot寻求解决方案，它给了我们这段代码。称之为<code class="fe mh mi mj mk b">AlgoReadAll</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5240" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这显然是正确和快速的。另外，它使用<code class="fe mh mi mj mk b">with open(file_name) as f:</code>在上下文管理器中打开文件，这是很好的实践。为了获得额外的好处，您可以提到代码在空文件上抛出一个异常。</p><p id="b767" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不利的一面是，这段代码将整个文件读入内存，因此不能处理大文件。另外(次要一点)，<code class="fe mh mi mj mk b">f.read().splitlines()</code>可以换成<code class="fe mh mi mj mk b">f.readlines()</code>。</p><blockquote class="ms mt mu"><p id="6e56" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:你可以用一行代码编写这个算法:<code class="fe mh mi mj mk b">random.choice(open(file_name).readlines())</code>。然而，我们不喜欢伤害可读性的单行解决方案。</p></blockquote><p id="a37d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们询问一个适用于大型文件的解决方案:</p><h2 id="2d02" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:使用很少的内存，如何从未知长度的文本文件中随机选择一行？</h2><p id="c5a5" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>首先要明确“小内存”。对于这个问题，假设您可以存储文件中的任何一行，或者几行，但不是所有的行。</p><p id="fd68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">AlgoTwoPass</code>用1解决问题。计算文件中的行数，2。随机选择一个行索引，3 .返回带有该索引的行。(在本文中，“索引0”是一个从0开始计数的索引。如果一个索引从1开始计数，我们称之为“index1”。)</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5d37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的机器上，这将输出:</p><p id="ab4b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">100,989 of 146,933: made in 1875 and the number of patents soon rapidly increased;</code></p><p id="a156" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mh mi mj mk b">AlgoTwoPass</code>正确。我还要给这段代码加分，因为:</p><ul class=""><li id="370b" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">使用带有显式种子的随机数生成器—机器学习和数据科学通常需要再现性，即使是来自随机性。</li><li id="3e46" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">【非常小】使用Python格式字符串，包括千位分隔符。</li><li id="9348" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">提到它在应用于空文件时返回<code class="fe mh mi mj mk b">None </code>。</li></ul><p id="805e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是必需的，但有趣的是这个更具功能性的实现:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="ms mt mu"><p id="7113" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白1: <strong class="kh ir">背景信息</strong>:这段代码使用了<a class="ae lr" href="https://docs.python.org/3/glossary.html#term-iterator" rel="noopener ugc nofollow" target="_blank"> Python迭代器</a>。当<code class="fe mh mi mj mk b">next()</code>应用于Python迭代器时，返回序列中的下一个值，或者，如果序列完成，抛出异常。<code class="fe mh mi mj mk b">itertools.islice</code>函数可以在不返回值的情况下在迭代器中向前跳转。表达式<code class="fe mh mi mj mk b">open(file_name)</code>返回一个对象，该对象是文件中各行的迭代器。<code class="fe mh mi mj mk b">enumerate()</code>函数接受一个迭代器并返回一个新的迭代器，这样每次调用新迭代器上的<code class="fe mh mi mj mk b">next()</code>都会返回一个从0开始的索引和一个来自原始迭代器的值。</p><p id="13db" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白2:我们不会因为某人用<code class="fe mh mi mj mk b">rng.randint</code>或<code class="fe mh mi mj mk b">itertools.islice</code>犯了一个一分的错误而惩罚他。然而，我们可能会问，如何测试代码来检查这样的错误。</p></blockquote><p id="833a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们要求一个更快的算法:</p><h2 id="1abf" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:在<em class="on">一次</em>中，你能从未知长度的文本文件中随机选择一行吗？</h2><p id="9178" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>经过提示，我们将通过一系列子问题开发一个算法。</p><p id="a6e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示:</strong>递归地想想这个。</p><p id="048d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub Q: </strong>把自己放在程序的位置上。如果我们向您保证文件只包含一行，您应该怎么做？</p><p id="c2bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果文件只包含一行，就输出它。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="7361" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子问:</strong>呜呜，我们骗了你。该文件可能只包含一行或两行，但没有其他数量的行。你该怎么办？</p><p id="a213" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub A: </strong>用概率0.5，替换我们要输出的结果，用第二行。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="c824" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">子问:</strong>对不起，我们又说谎了！该文件可能只包含一行、两行或三行。你该怎么办？每条线的入选概率是多少？这怎么能一概而论呢？</p><p id="7545" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用概率⅓，用第三行替换我们要输出的结果。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1bf8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每行的选择概率为:</p><ul class=""><li id="0de7" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">第一行:1 × × ⅔= ⅓</li><li id="6f08" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">第二行:× ⅔= ⅓</li><li id="8bc6" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">三线:⅓= ⅓</li></ul><p id="07ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，概率分布是均匀的。我们可以将其概括为<code class="fe mh mi mj mk b">AlgoOnePass</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><blockquote class="ms mt mu"><p id="d3d3" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated"><strong class="kh ir">先不说:</strong>我(Carl)回忆起一位受访者开始通过归纳法证明这个算法的正确性。我可以告诉他们很容易做到这一点，所以我阻止了他们，继续前进。他们获得了奖金。</p></blockquote><p id="b8e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">奖金Q: </strong>我们在面试中从来没有问过这个，但是你能递归地写<code class="fe mh mi mj mk b">AlgoOnePass</code>吗？</p><p id="d177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">奖金A: </strong>这里是<code class="fe mh mi mj mk b">AlgoOnePassRecurse</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="67d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python的可选参数可以很好地处理递归。可悲的是，如果递归超过几千次，Python就会崩溃。这段代码使用包<a class="ae lr" href="https://pypi.org/project/tail-recursive/" rel="noopener ugc nofollow" target="_blank">尾递归</a>来避免崩溃。然而，即使如此，这种递归代码的运行速度比迭代代码慢几百倍。</p><blockquote class="ms mt mu"><p id="b1ea" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:实际思考一下，一次通过比两次通过重要吗？往往不会。如果你能为一条随机的线等待20秒，你大概能等待20到40秒。另一方面，有些数据——“流数据”——不能被访问两次，所以<code class="fe mh mi mj mk b">AlgoOnePass</code>具有实用价值。</p></blockquote><p id="f5fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对<code class="fe mh mi mj mk b"><em class="mv">AlgoOnePass</em></code>的一个简单概括是选择多条随机线，而不仅仅是一条线，我们不会讨论这个。维基百科在其关于<a class="ae lr" href="https://en.wikipedia.org/wiki/Reservoir_sampling#Simple:_Algorithm_R" rel="noopener ugc nofollow" target="_blank">储层采样:简单算法R </a>的文章中描述了(或多或少)<code class="fe mh mi mj mk b"><em class="mv">AlgoOnePass</em></code>和这一概括。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="3c2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在采访中，这通常是我们说到“从文件中随机抽取一行”的地方。然而，我们最近了解到了锈箱<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>。这个<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>板条箱使用SIMD CPU指令来加速计算文件中的行数。这让我们再次玩起了这个问题。这导致了一种新的方法和一种改进的算法。新算法不使用<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>。然而，在返回一个随机行的特定情况下，它确实优于维基百科中描述的更一般的<a class="ae lr" href="https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L" rel="noopener ugc nofollow" target="_blank"> Optimal: Algorithm L </a>。</p><blockquote class="ms mt mu"><p id="38cc" class="kf kg mv kh b ki kj jr kk kl km ju kn mw kp kq kr mx kt ku kv my kx ky kz la ij bi translated">旁白:我们称之为“新算法”，但它可能早就被发现了。无论如何，我们希望你会对这个算法和它的发展感兴趣。</p></blockquote><p id="2ce2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和以前一样，我们将通过一系列问题和提示来展示新算法。然而，我们从未向受访者提出过这些问题。</p><h2 id="2676" class="nn no iq bd np nq nr dn ns nt nu dp nv ko nw nx ny ks nz oa ob kw oc od oe of bi translated">问:在一次传递中，你能从一个未知长度的文本文件中选择一个随机行，使得随机数发生器的调用比行数n少得多吗？</h2><p id="1e3e" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated"><strong class="kh ir">答:</strong>我们必须澄清“少很多”。我们的意思是对随机数生成器的调用次数小于O( <em class="mv"> n </em>)【参见<a class="ae lr" href="https://en.wikipedia.org/wiki/Big_O_notation" rel="noopener ugc nofollow" target="_blank">大O标注—维基百科</a>】。换句话说，将通话次数减少一次或一半是不够的。所需调用的随机数应该与log( <em class="mv"> n </em>)或sqrt( <em class="mv"> n </em>)成比例增长。</p><p id="e6d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">提示:</strong>首先修改<code class="fe mh mi mj mk b">AlgoOnePass</code>打印分配给<code class="fe mh mi mj mk b">result</code>的每一项的索引。称之为“保持指数”。比如说，对100万个项目运行代码。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="e468" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产出:</p><pre class="lc ld le lf gt oo mk op oq aw or bi"><span id="1236" class="nn no iq mk b gy os ot l ou ov">1 36 41 187 226 403 2,608 5,756 20,162 48,750 912,566 922,409</span></pre><p id="5d98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这表示当我们以随机种子0运行时，第一项(索引1)被保留为可能的结果。那么没有项目被保留到第36个项目，然后是第41个项目。如果迭代器包含922，409到1，000，000项，那么第922，409项将是最后一项，因此将被返回。</p><p id="c534" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">keep指数似乎大致呈指数增长。如果该猜想为真，那么keep索引数为O(log <em class="mv"> n </em>)，其中<em class="mv"> n </em>是迭代器中项的个数。</p><p id="7960" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子问题:我们可以直接随机生成keep索引序列吗？</p><p id="35af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> Sub A: </strong>是的！我们在一篇简短的在线技术论文中详细介绍了我们的解决方案[Meek &amp; Kadie，<a class="ae lr" href="https://cm1x.github.io/static/Attenuated_Geometric_Distribution.pdf" rel="noopener ugc nofollow" target="_blank">Streaming Random Selection Using the Attenuated Geometric Distribution</a>，2022]。我们称keep指数的分布为“衰减几何分布”。我们证明，如果<code class="fe mh mi mj mk b">index1</code>是一个keep索引号，那么我们可以生成下一个:</p><pre class="lc ld le lf gt oo mk op oq aw or bi"><span id="2239" class="nn no iq mk b gy os ot l ou ov">r = rng.random()<br/>index1 = index1 + max(ceil(r * index1 / (1.0 — r)),1)</span></pre><p id="0d08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe mh mi mj mk b">rng.random()</code>生成0 .0(含)到1.0(不含)之间的统一浮点值。奖金:<code class="fe mh mi mj mk b">max(…,1)</code>处理随机生成0.0的非常，非常不可能的情况。此外，回想一下我们的约定，即“index1”是从1而不是从0开始计数的索引。</p><p id="d005" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以利用这种洞察力来创建<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="0664" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用代码在0(包括)和100(不包括)之间挑选一个数字，100，000次，来获得一些信心。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="1e88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">输出图应该看起来一致。他们确实这样做了:</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ow"><img src="../Images/391933e09291266d5565be5154165258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROqWFwpsUNs6kETywdDqOQ.png"/></div></div></figure><p id="156b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个算法与<a class="ae lr" href="https://en.wikipedia.org/wiki/Reservoir_sampling#Optimal:_Algorithm_L" rel="noopener ugc nofollow" target="_blank"> Optimal: Algorithm L </a>(维基百科推荐)有两个重要的区别。</p><ul class=""><li id="e50b" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated"><code class="fe mh mi mj mk b">AlgoOnePassSkip</code>只能选择一个随机项，而算法L可以选择任意指定数量的随机项。</li><li id="c9f4" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">当只需要一个随机项时，<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>每个keep索引需要一个随机数，而算法L需要两个。</li></ul><p id="2f58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于我们只想要一个随机物品的特殊情况，<code class="fe mh mi mj mk b">AlgoOnePassSkip</code>使用的随机抽取数量是算法l的一半</p><h1 id="9835" class="ox no iq bd np oy oz pa ns pb pc pd nv jw pe jx ny jz pf ka ob kc pg kd oe ph bi translated">摘要</h1><p id="f33d" class="pw-post-body-paragraph kf kg iq kh b ki og jr kk kl oh ju kn ko oi kq kr ks oj ku kv kw ok ky kz la ij bi translated">我们已经看到了从未知长度的序列中随机选择一个项目的四种方法。在文本文件的上下文中，第一种解决方案要求文件适合内存。下一个解决方案使用较少的内存，但需要两次通过文件。然后，我们使用概率计算将此减少到一遍。这种一次通过的解决方案需要每行一个随机数。最后一个解决方案需要的随机数比直线少得多。它使用的随机数也是“最优”(更一般)算法的一半。</p><p id="1f8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的代码都没有使用系统级的方法，比如<code class="fe mh mi mj mk b"><a class="ae lr" href="https://lib.rs/crates/bytecount" rel="noopener ugc nofollow" target="_blank">bytecount</a></code>来加速文件的线性传递。添加系统级优化将是一个有趣的扩展。</p><p id="c934" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">请</em> <a class="ae lr" href="https://medium.com/@carlmkadie" rel="noopener"> <em class="mv">跟随卡尔上中</em> </a> <em class="mv">。我写的是Rust和Python的科学编程、机器学习和统计学。我倾向于每月写一篇文章。</em></p></div></div>    
</body>
</html>