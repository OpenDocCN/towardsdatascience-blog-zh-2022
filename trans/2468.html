<html>
<head>
<title>How to do Unit Testing in dbt</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在dbt中进行单元测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-do-unit-testing-in-dbt-cb5fb660fbd8#2022-05-30">https://towardsdatascience.com/how-to-do-unit-testing-in-dbt-cb5fb660fbd8#2022-05-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6710" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决测试数据管道的挑战</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4aac7f1e113b25526819f0ec83c8126.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FgzfqexiUw2kYI7a"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克劳迪奥·施瓦茨在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di">在</span>最近几年，我们已经看到了构建数据堆栈的技术和工具的巨大发展。现在，在没有大量投资的情况下，构建现代数据管道比以往任何时候都更容易。标准的现代数据堆栈包括但不限于:</p><ul class=""><li id="2d63" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">云优先数据仓库—一个高度可扩展的分布式云数据仓库，允许使用SQL转换万亿字节的数据。BigQuery、雪花、亚马逊红移目前市场领先。</li><li id="3b55" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">工作流程编排—以编程方式安排和监控数据转换的平台。数据仓库只是来自不同来源的集成数据的中央存储库。我们需要一个像Airflow和dbt这样的平台，将原始数据转换成对业务有意义的干净数据。与数据仓库不同，许多编排工具是开源的，基础设施由数据团队维护，因此工程师们提出了许多最佳实践，如如何构建CICD管道、执行测试、监控、警报等。本文就是其中的一篇，主要讨论dbt中的测试。</li><li id="0ec2" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">商业智能—一种工具，允许每个人通过创建仪表板来探索数据和自助服务他们的数据请求。示例工具有Tableau和Looker。员工应该能够利用该工具进行决策。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/2cac08792a61bd8de7db53d4c998927e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HU8CBJjC5RYZueih.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="mt mu ep" href="https://medium.com/u/755512a464bb?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">达尼洛·德罗巴克</a>从<a class="ae ky" href="https://medium.com/@danilo.drobac/the-modern-data-stack-4f0094017edb" rel="noopener">中</a>拍摄</p></figure><p id="ca96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如题，在本文中，我们将回答一个问题:如何在dbt中执行单元测试？在看到解决方案之前，让我们先了解一下dbt的背景，它的测试策略，以及为什么它对dbt是一个挑战？</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="c5ec" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">dbt</h2><p id="ffac" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated"><a class="ae ky" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>是一个基于SQL的数据转换工具，支持数据分析师和工程师转换、测试和记录云数据仓库中的数据。工程师利用领域专业知识创建可重用的数据模型。公司中的任何人都可以使用数据模型来帮助他们决策。</p><h2 id="51ea" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">dbt中的数据测试</h2><p id="739e" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">为了确保数据模型的正确性，我们需要应用不同类型的测试。dbt 中必备的一个<a class="ae ky" href="https://docs.getdbt.com/docs/building-a-dbt-project/tests" rel="noopener ugc nofollow" target="_blank">测试是<strong class="lb iu">数据测试</strong>。这是确保数据质量的一个完整步骤。工程师通常会对管道做出假设:源数据是有效的，模型是合理的，转换后的数据是准确的。但事实通常并非如此。应进行一系列测试以确保数据质量。由于源数据每天都在变化，这些测试应该是生产管道中运行时测试的一部分。根据严重程度，一些测试可能会堵塞管道，以免污染下游。这里我列出了一些常见的数据质量测试:</a></p><ul class=""><li id="943e" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">空值-检查不应有空值的列。</li><li id="3067" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">唯一性检查—几列的组合应该是唯一的，以避免重复。</li><li id="9824" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated"><a class="ae ky" href="https://docs.getdbt.com/reference/resource-properties/freshness" rel="noopener ugc nofollow" target="_blank">新鲜度检查</a> —模型是否包含最近的记录？</li><li id="dbfc" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">关系检查-源表中的所有必需数据是否都转换到了目标表中？</li><li id="4293" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi">…</li></ul><p id="0f17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="https://github.com/dbt-labs/dbt-utils#generic-tests" rel="noopener ugc nofollow" target="_blank"> dbt-utils </a>这样的一些dbt包提供了一系列现成的通用测试，可以满足大多数需求。为了更好地理解数据测试的作用，让我们把它形象化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f38bcb96e3a48d17e70d02ed2f0b7bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9CcHN5NPQCw9Ftee0dDgfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创作人<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="7338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水平路径是通过数据管道的数据流。每个环境中的数据可能不同，因此数据质量测试应该在生产流程中运行，以确保对源数据的假设总是有效的。</p><p id="1890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">够不够？</p><h2 id="9817" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">dbt中的单元测试</h2><p id="f1ff" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">数据测试可以发现数据质量问题。但是不能保证SQL代码的正确性。下面是一个SQL示例，它将<code class="fe ob oc od oe b">revenue</code>与<code class="fe ob oc od oe b">vat</code>表连接起来，以计算净预订和增值税金额。仅从数据测试很难知道公式或连接逻辑是否正确。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="52ec" class="nc nd it oe b gy oj ok l ol om">SELECT<br/>  date<br/>  , city<br/>  , SUM(amount_net_booking) as amount_net_booking<br/>  , SUM(amount_net_booking * (1 - 1/(1 + vat_rate))) as amount_vat  <br/>FROM revenue<br/>LEFT JOIN vat USING (city)<br/>GROUP BY 1,2</span></pre><p id="d2c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里错过的是测试SQL逻辑(也称为单元测试)的功能，就像测试常规应用程序一样。如果我构建一个应用程序，我会应用TDD(测试驱动设计)，这是一种常见的软件工程实践，可以帮助我们在正确性方面达到一个良好的信心水平。在推广到生产之前，它确保逻辑是正确的。</p><p id="3245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然dbt是一个强大的框架，但我们仍然从头开始编写一堆SQL代码来构建模型。只要是人类写的，都有可能出错。这和写一个Python，Java程序没什么区别。我们可以将dbt模型看作一个函数，其中输入是源表，输出是SQL的结果。<strong class="lb iu">dbt中的单元测试是这样一种测试，我们提供模拟输入，然后对照预期的模型检查结果。</strong>单元测试的一大优势是我们可以为所有类型的测试用例提供模拟输入，包括边缘用例。这对于涉及复杂业务逻辑的SQL代码尤其有用。如果是一个模型链，我们可以向第一个模型提供模拟输入，并断言最终模型和中间模型的结果。这个测试链被称为集成测试。</p><p id="c779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与数据测试不同，没有必要将单元测试集成到数据管道中，因为在提升到更高的环境后，代码不会被更改。我们不需要对逻辑做任何假设，因为我们已经完全控制了它。只要在下层环境下验证了逻辑，就应该信任它，发布代码。</p><h2 id="939e" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">数据管道中的数据测试与应用程序中的单元测试</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/67948c635501dfe0c4251489c8e657fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VinnzGGtCLKX3KN1_Am-og.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由创作<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">高</a></p></figure><p id="25b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然数据管道中的数据测试和常规应用程序中的单元测试是两个不同的概念，但它们有共同的领域。例如，当构建REST API接口时，应用程序从外部接收数据，这可能是不可靠的。它必须在处理数据之前验证数据(也称为执行数据质量检查)。尽管大多数软件工程师不认为这是一个标准测试，但这种类型的运行时验证非常类似于数据管道中的数据测试。</p><p id="40ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在另一种情况下，测试可以被认为是数据测试和单元测试，例如关系检查(例如字段<code class="fe ob oc od oe b">a</code>和<code class="fe ob oc od oe b">b</code>的和等于<code class="fe ob oc od oe b">c</code>)。作为一名工程师，理解测试的目标是很重要的，无论是测试动态的数据还是测试静态的逻辑。如果它是关于逻辑的，那么它应该是单元测试，并且只在CICD管道中执行一次。如果是关于数据的，那么由于数据的差异，它应该是生产流水线的一部分。数据测试的几个例子:</p><ul class=""><li id="7f79" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">源数据中有空值吗？</li><li id="b7fa" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">数据包含最近的日期吗？</li><li id="f2b1" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">来自源的每条记录都被转换到目的地了吗？</li><li id="5cb6" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">有没有超出可接受范围的数值？</li><li id="c1a4" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">代码中有重复的地方吗？</li></ul><p id="18e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试的几个例子:</p><ul class=""><li id="2334" class="me mf it lb b lc ld lf lg li mg lm mh lq mi lu mj mk ml mm bi translated">该模型计算公司的收入，计算是否正确？</li><li id="5ceb" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">该模型包含一些IF条件来计算一个字段，我是否遗漏了任何边缘情况？</li><li id="c33c" class="me mf it lb b lc mn lf mo li mp lm mq lq mr lu mj mk ml mm bi translated">该模型在几列上进行聚合，我是否遗漏了任何一列？</li></ul><p id="c7b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成熟的数据团队利用自动化数据质量检查和自动化逻辑测试，确保数据对公司具有最高的价值。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="3de2" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">dbt中单元测试的实现</h2><p id="30f6" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">为了演示单元测试如何在dbt中工作，我创建了下面的数据管道，它读取两个源表<code class="fe ob oc od oe b">transaction</code>和<code class="fe ob oc od oe b">vat</code>，然后将数据转换成最终的模型<code class="fe ob oc od oe b">revenue</code>。作为一名数据工程师，我不一定知道初始阶段的每个逻辑细节，所以我基于某种假设创建了这个模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/63cd75975ea6ef46174b228f05d8486d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K2dscx6VpqfSCZniT0Sd9w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">世系图(由<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">高</a>制作)</p></figure><p id="99ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于这是一个关键而复杂的模型，我想用几个预定义的场景来测试它，并为此创建模拟数据。模拟数据是我的dbt项目中的CSV文件，其中每个CSV文件代表一个源表。我们可以将CSV文件存储在<code class="fe ob oc od oe b">data</code>文件夹中，并利用<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.getdbt.com/docs/building-a-dbt-project/seeds" rel="noopener ugc nofollow" target="_blank">dbt seed</a></code>命令将数据加载到数据仓库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/eccd927bd614623a5f22f7c8d6247d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFzKG7UqpEcvVvHFt0k6gg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">文件夹结构(由<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><blockquote class="oq or os"><p id="4c84" class="kz la ot lb b lc ld ju le lf lg jx lh ou lj lk ll ov ln lo lp ow lr ls lt lu im bi translated">关于如何/由谁创建模拟数据的一些话。为了确保测试用例的完整性，编写代码的人不应该同时提供测试数据。在许多公司中，分析师或业务涉众是提供测试用例或测试数据的人。</p></blockquote><p id="2f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，模拟数据不应该与真正的源表混淆。最好将它存储在一个单独的模式中(例如unit_testing)。我们可以在<code class="fe ob oc od oe b">dbt_project.yml</code>文件中定义这个。<code class="fe ob oc od oe b">unit_testing/revenue</code>文件夹中的每个文件都将被加载到<code class="fe ob oc od oe b">unit_testing</code>模式中。<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.getdbt.com/reference/resource-configs/tags" rel="noopener ugc nofollow" target="_blank">tags</a></code>在选择车型时也发挥着重要作用。当运行<code class="fe ob oc od oe b">dbt build -s +tag:unit_testing</code>时，它将运行标签为<code class="fe ob oc od oe b">unit_testing</code>的所有种子/模型/测试/快照及其上游。</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="673b" class="nc nd it oe b gy oj ok l ol om">seeds:<br/>  unit_testing:<br/>    revenue:<br/>      schema: unit_testing<br/>      +tags:<br/>        - unit_testing</span></pre><p id="51a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于演示的目的，我的dbt模型比现实相对简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">收入模型(由高<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">创建</a></p></figure><p id="c7e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你发现问题了吗？</p><p id="3cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题出在源表。像往常一样，我使用<code class="fe ob oc od oe b">{{ source() }}</code>来引用实际的源表。但是我的模拟数据在一个单独的模式中，它们应该通过使用<code class="fe ob oc od oe b">ref</code>函数来引用，因为它们是种子。我要怎么切换信号源？为了解决这个问题，我创建了一个<strong class="lb iu">自定义宏，它能够根据环境或某种触发器来切换源表。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">select _表宏(由<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="f1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个宏有两个输入参数:<code class="fe ob oc od oe b">source_table</code> - &gt;表有真实数据，<code class="fe ob oc od oe b">test_table</code> - &gt;表有模拟数据。宏根据<code class="fe ob oc od oe b">dbt</code>命令中的变量返回表格。如果命令没有提供<code class="fe ob oc od oe b">unit_testing</code>变量或者值为<code class="fe ob oc od oe b">false</code>，则返回<code class="fe ob oc od oe b">source_table</code>，否则返回<code class="fe ob oc od oe b">test_table</code>。你可以根据自己的情况修改这个宏，比如基于<code class="fe ob oc od oe b"><a class="ae ky" href="https://docs.getdbt.com/reference/dbt-jinja-functions/target" rel="noopener ugc nofollow" target="_blank">target</a></code>而不是变量来切换表。</p><p id="4d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">dbt</code>使用模拟数据运行模型和测试的命令</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="6a96" class="nc nd it oe b gy oj ok l ol om">dbt build -s +tag:unit_testing --vars 'unit_testing: true'</span></pre><p id="a3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ob oc od oe b">dbt</code>使用真实数据运行模型的命令。(稍后将在此解释我们为什么需要<code class="fe ob oc od oe b">--exclude</code>标志)</p><pre class="kj kk kl km gt of oe og oh aw oi bi"><span id="5f84" class="nc nd it oe b gy oj ok l ol om">dbt build -s +tag:revenue --exclude tag:unit_testing</span></pre><p id="822b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新后的模型现在看起来像这样。我们使用变量<code class="fe ob oc od oe b">{{ import_* }}</code>来表示正确的源表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的收入模式(由高<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">创建</a></p></figure><p id="2059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们已经看到了如何选择正确的源表并在模拟输入上运行模型。接下来，我们将比较实际输出和预期的模拟输出。我们可以利用dbt-utils提供的<code class="fe ob oc od oe b"><a class="ae ky" href="https://github.com/dbt-labs/dbt-utils/tree/0.7.2/#equality-source" rel="noopener ugc nofollow" target="_blank">equality</a></code>测试来比较两个模型。在<code class="fe ob oc od oe b">compare_model</code>中，我们指的是预期输出模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="b714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，我们不应该在测试中忘记<code class="fe ob oc od oe b">tags: ['unit_testing']</code>。正如我们之前所说的，单元测试不应该作为生产流水线的一部分运行。在生产中运行这个<code class="fe ob oc od oe b">equality</code>测试实际上意味着我们将生产模型与永远不会工作的模拟输出进行比较。添加标签<code class="fe ob oc od oe b">unit_testing</code>和运行命令<code class="fe ob oc od oe b">dbt build -s +tag:revenue --exclude tag:unit_testing</code>可以确保在生产中跳过测试。</p><p id="6d11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，我希望你还在关注我:)让我们来看看不同的比较模型的方法。<code class="fe ob oc od oe b">dbt_utils.equality</code> test对模型进行精确匹配，但由于精度问题，在比较数字时会变得棘手。解决这个问题的一个方法是创建一个自定义宏，首先对数字列进行舍入，然后进行比较。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义宏比较模型(由<a class="mt mu ep" href="https://medium.com/u/2adc5a07e772?source=post_page-----cb5fb660fbd8--------------------------------" rel="noopener" target="_blank">高</a>创建)</p></figure><p id="b1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要有助于你发现不同之处，你就可以发挥创造力。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="02c3" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">我们完全安全吗？</h2><p id="382f" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">不幸的是，没有。单元测试给了我们用自定义场景测试逻辑的可能性。但问题是:<strong class="lb iu">这些场景是否涵盖了一切？</strong>大概不会。有两个问题:</p><p id="1a63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">很难提供涵盖所有排列的完美数据集——未知的已知</strong></p><p id="2f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">源数据经常是多种多样的，找出所有可能的组合并为每个组合创建测试数据非常耗时。其中一个策略是预先创建一个单独的层，过滤掉无效的数据并进行一些完整性检查。它在某种程度上限制了排列的数量，所以我们对将要发生的事情更有信心，可以创建相对有限的数据集。</p><p id="3051" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">甲骨文问题—(不)已知未知</strong></p><p id="1f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，这是一个哲学问题。每次测试都是实际输出和预期输出的比较。</p><blockquote class="oq or os"><p id="cbff" class="kz la ot lb b lc ld ju le lf lg jx lh ou lj lk ll ov ln lo lp ow lr ls lt lu im bi translated"><a class="ae ky" href="https://www.yld.io/blog/the-oracle-problem/" rel="noopener ugc nofollow" target="_blank"> Oracle问题</a>指难以确定预期产出的情况。基本上，人类从来没有足够的装备来测试他们的程序，因为现实总是比它在测试套件中的表现更复杂。</p></blockquote><p id="44bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，数据源是复杂的。有很多情况我们不知道如何处理。一个简单的策略是使用一种逻辑来处理所有未知的情况，并以此作为答案。想想<code class="fe ob oc od oe b">else</code>在一个if条件中的作用。</p><p id="359c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这还不够，那我们就只能忍受了。人类每天都在获取新的知识，程序也是如此。随着我们发现更多的问题，更多的未知将转化为已知，因此我们将能够捕捉越来越多的信息，并每天更好地了解这个世界。</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="cfbd" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">结论</h2><p id="5887" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">希望这篇文章对你有用。如果您确信并开始在您的数据管道中应用单元测试，那就太好了！如果您没有立即被说服，但是仍然希望从这篇文章中获得一些收获，那么它将是理解单元测试和数据测试在数据管道中的作用，因为您有一天会需要它。如果你对数据管道测试有任何想法，请在评论中告诉我们。干杯！</p></div><div class="ab cl mv mw hx mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="im in io ip iq"><h2 id="0702" class="nc nd it bd ne nf ng dn nh ni nj dp nk li nl nm nn lm no np nq lq nr ns nt nu bi translated">参考</h2><div class="oz pa gp gr pb pc"><a href="https://medium.com/slalom-build/the-challenge-of-testing-data-pipelines-4450744a84f1" rel="noopener follow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">测试数据管道的挑战</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">测试数据管道与测试传统软件系统有何不同。</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">medium.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq ks pc"/></div></div></a></div><div class="oz pa gp gr pb pc"><a href="https://github.com/EqualExperts/dbt-unit-testing" rel="noopener  ugc nofollow" target="_blank"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd iu gy z fp ph fr fs pi fu fw is bi translated">GitHub-equal experts/dbt-单元测试:这个dbt包包含支持单元测试的宏…</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">这个dbt包包含支持单元测试的宏，这些宏可以在dbt项目中重用。其中一个软件…</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">github.com</p></div></div><div class="pl l"><div class="pr l pn po pp pl pq ks pc"/></div></div></a></div></div></div>    
</body>
</html>