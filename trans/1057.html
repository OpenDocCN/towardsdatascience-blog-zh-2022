<html>
<head>
<title>How to do basic full-text searches in MongoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在 MongoDB 中进行基本的全文搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-do-basic-full-text-searches-in-mongodb-48b17242676#2022-03-20">https://towardsdatascience.com/how-to-do-basic-full-text-searches-in-mongodb-48b17242676#2022-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="682a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过 MongoDB 中的文本索引搜索您的文本数据</h2></div><p id="3931" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于 MongoDB 是一个面向文档的 NoSQL 数据库，所以在一些字段中存储纯文本是很常见的。为了搜索字符串字段，我们可以直接使用正则表达式操作符<code class="fe le lf lg lh b"><a class="ae li" href="https://docs.mongodb.com/manual/reference/operator/query/regex/" rel="noopener ugc nofollow" target="_blank">$regex</a></code>。然而，<code class="fe le lf lg lh b">$regex</code>只能用于简单的搜索查询，不能高效地使用索引。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/ba74212ca51ad81589cc4b284fa698a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zO0EOf7p5S7r8efi.jpg"/></div></div><p class="lv lw gj gh gi lx ly bd b be z dk translated">图片来自 Pixabay 的 DariuszSankowsk</p></figure><p id="e701" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在 MongoDB 中，有更好的方法来搜索字符串字段。一个经典的方法是创建一个<code class="fe le lf lg lh b">text</code>索引，并根据它进行搜索。尽管 MongoDB 现在支持一个<a class="ae li" href="https://lynn-kwong.medium.com/learn-powerful-full-text-searches-with-mongodb-atlas-search-e3fee4fcc324" rel="noopener">“高级”全文解决方案</a>，但是，它只有在您使用<a class="ae li" href="https://lynn-kwong.medium.com/how-to-use-mongodb-atlas-to-manage-your-server-and-data-d97a6e7663c5" rel="noopener"> Atlas </a>托管数据时才有效。由于在我们的工作中经常使用自我管理的 MongoDB 服务器，特别是对于一些小而简单的项目，因此值得学习和使用经典的文本搜索解决方案，它可以通过简单的查询显著提高您的搜索效率。正如后面将要演示的，大多数常见的搜索问题都可以通过使用<code class="fe le lf lg lh b">text</code>索引以及经典的 MongoDB 搜索和聚合查询来解决。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="e302" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行演示，我们将搜索存储在 MongoDB 数据库中的笔记本电脑列表。请下载<a class="ae li" href="https://gist.github.com/lynnkwong/86e314061919cccbc89aa7ee597ff61b" rel="noopener ugc nofollow" target="_blank">这个 JSON 文件</a>(由作者生成)包含一些虚构网店的笔记本电脑数据。请注意，数据是根据一些常见的笔记本电脑品牌随机生成的。它可以免费使用，不会有任何许可问题。然后使用以下命令导入数据:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4fb6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当上面的代码运行时，我们将在<code class="fe le lf lg lh b">products</code>数据库中拥有一个包含 200 个笔记本电脑数据文档的<code class="fe le lf lg lh b">laptops</code>集合。这些文件的内容如下:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3b64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在数据已经准备好了，我们可以开始创建一个<code class="fe le lf lg lh b">text</code>索引，并进行一些基本的全文搜索。</p><p id="3448" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我们将使用<code class="fe le lf lg lh b">mongosh</code>直接运行查询。如果您需要编写一些复杂的查询，您可能会发现一个<a class="ae li" href="https://lynn-kwong.medium.com/how-to-use-mongodb-with-graphical-ides-420597ede80e" rel="noopener"> MongoDB IDE </a>很有帮助，它提供了命令自动完成和错误突出显示。为了简单起见，我们将使用 Docker 容器附带的<code class="fe le lf lg lh b">mongosh</code>,因此我们不需要单独安装任何东西:</p><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="c714" class="mm mn it lh b gy mo mp l mq mr">$ <strong class="lh iu">docker exec -it mongo-server bash</strong></span><span id="b603" class="mm mn it lh b gy ms mp l mq mr">$ <strong class="lh iu">mongosh "mongodb://admin:pass@localhost:27017"</strong><br/>test&gt; <strong class="lh iu">use products</strong><br/>products &gt; <strong class="lh iu">show collections</strong><br/>laptops</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="b99a" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated"><strong class="ak">创建一个</strong> <code class="fe le lf lg lh b"><strong class="ak">text</strong></code> <strong class="ak">指标</strong></h2><p id="6a3d" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">在我们开始之前，有一些重要的事情我们应该记住，即<strong class="kk iu">对于一个集合</strong>只能有一个 <code class="fe le lf lg lh b"><strong class="kk iu">text</strong></code> <strong class="kk iu">索引。</strong></p><p id="44af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在<code class="fe le lf lg lh b">name</code>字段上创建一个<code class="fe le lf lg lh b">text</code>索引，这是通过集合的<code class="fe le lf lg lh b">createIndex()</code>方法完成的:</p><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="79a0" class="mm mn it lh b gy mo mp l mq mr">products&gt; db.laptops.<strong class="lh iu">createIndex( { name: "text" } )<br/></strong>name_text</span></pre><p id="96e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">name</code>是我们想要为其创建索引的字符串字段，而“<code class="fe le lf lg lh b">text</code>”值表示我们想要创建一个支持基本全文搜索的<code class="fe le lf lg lh b">text</code>索引。相比之下，要在 MongoDB 中创建一个<a class="ae li" href="https://medium.com/codex/how-to-use-indexes-properly-in-mongodb-ff4560dc67f5" rel="noopener">常规索引</a>，我们为一个字段指定 1 或-1，以指示该字段在索引中应该按升序还是降序排序。</p><p id="9a81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们开始搜索<code class="fe le lf lg lh b">text</code>索引之前，我们应该知道尽管一个集合只能有一个<code class="fe le lf lg lh b">text</code>索引，但是这个索引可以覆盖多个字段。让我们删除上面创建的<code class="fe le lf lg lh b">text</code>索引，并创建一个包含<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">attributes</code>字段的新索引。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6ab3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<code class="fe le lf lg lh b">text</code>索引可以有不同的名称，但是在一个集合中只能有一个<code class="fe le lf lg lh b">text</code>索引。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="b468" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated"><strong class="ak">使用</strong> <code class="fe le lf lg lh b"><strong class="ak">text</strong></code> <strong class="ak">索引</strong>的基本全文搜索</h2><p id="8719" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">现在让我们使用刚刚创建的<code class="fe le lf lg lh b">text</code>索引进行一些基本的全文搜索。我们将使用<code class="fe le lf lg lh b">$text</code>查询操作符来执行文本搜索。例如:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="433a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">$text</code>操作符使用接受字符串值的<code class="fe le lf lg lh b">$search</code>字段进行文本搜索。在底层，搜索字符串使用空格和标点符号作为分隔符。对于生成的令牌，它们中的每一个都被独立地搜索，并用一个逻辑<code class="fe le lf lg lh b">OR</code>操作符连接。此外，默认情况下，搜索不区分大小写。如果您想进行区分大小写的搜索，您可以为<code class="fe le lf lg lh b">$text</code>操作符指定<code class="fe le lf lg lh b"><a class="ae li" href="https://docs.mongodb.com/manual/reference/operator/query/text/#case-and-diacritic-insensitive-search" rel="noopener ugc nofollow" target="_blank">$caseSensitive</a></code>字段。</p><p id="6896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，使用上面的搜索查询，我们得到的文档包含“HP”或“ProBook ”,但不一定两者都包含。</p><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="b13b" class="mm mn it lh b gy mo mp l mq mr">[<br/>  { _id: 19, name: 'HP ZBook Model 19' },<br/>  { _id: 20, name: 'HP ZBook Model 20' },<br/>  { _id: 3, name: 'HP EliteBook Model 3' },<br/>  { _id: 18, name: 'HP ProBook Model 18' },<br/>  ...<br/>]</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="ecc6" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated">按文本分数排序</h2><p id="64c3" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">重要的是，使用<code class="fe le lf lg lh b">$text</code>操作符，会为每个文档分配一个分数，表明文档与搜索字符串的匹配程度。如果“HP”和“ProBook”都匹配某个文档，则该文档的得分高于只匹配“HP”或“ProBook”的文档。我们可以根据分数对文档进行排序，用<code class="fe le lf lg lh b">limit()</code>方法只能得到最上面的。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="9525" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可能看起来很奇怪，分数是用<code class="fe le lf lg lh b">{$meta: "textScore"}</code>表达式返回的。此外，乍一看可能更奇怪的是:</p><ul class=""><li id="bbbb" class="np nq it kk b kl km ko kp kr nr kv ns kz nt ld nu nv nw nx bi translated">给定的字段名称(<code class="fe le lf lg lh b">score</code>)并不重要。你可以给一个不同的名字，它仍然会工作。</li><li id="0932" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated">按分数排序始终是降序。这是有意义的，因为通常我们希望找到最相关的匹配。</li></ul><p id="1f93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这个查询，我们可以得到我们想要的最相关的结果:</p><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="ee20" class="mm mn it lh b gy mo mp l mq mr">[<br/>  { _id: 15, name: 'HP ProBook Model 15' },<br/>  { _id: 16, name: 'HP ProBook Model 16' },<br/>  { _id: 18, name: 'HP ProBook Model 18' }<br/>]</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="f307" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated">按短语搜索</h2><p id="5c62" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">如果我们只想找到完全包含“HP ProBook”的文档，我们可以通过短语进行搜索，只需将搜索字符串放在一对嵌套的引号中。我们可以交替使用单引号和双引号，或者用反斜杠对引号进行转义。以下查询将给出相同的结果:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="2ae3" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated">在搜索查询中使用否定</h2><p id="460a" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">我们还可以在我们的搜索查询中使用否定，这要求文档不匹配某些标记。让我们搜索“惠普”但不是“ProBook”的笔记本电脑:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="722a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在结果列表中，我们再也看不到“ProBook”了:</p><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="748c" class="mm mn it lh b gy mo mp l mq mr">[<br/>  { _id: 19, name: 'HP ZBook Model 19' },<br/>  { _id: 20, name: 'HP ZBook Model 20' },<br/>  { _id: 3, name: 'HP EliteBook Model 3' },<br/>  ...<br/>]</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="234c" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated">嵌套文档中的文本搜索</h2><p id="9479" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated">现在让我们用一个属性进行搜索，看看<code class="fe le lf lg lh b">text</code>索引是否同时覆盖了<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">attributes</code>字段:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="29ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，我们需要按分数排序，否则最高的结果可能不是你所期望的。这是因为“HP 1TB”不是一个短语。实际上，“HP”出现在<code class="fe le lf lg lh b">name</code>字段中，而“1TB”出现在<code class="fe le lf lg lh b">attributes.attribute_value</code>字段中。由于默认情况下使用了<code class="fe le lf lg lh b">OR</code>逻辑运算符，返回的文档将包含“HP”或“1TB ”,但不一定两者都包含。使用<code class="fe le lf lg lh b">sort()</code>和<code class="fe le lf lg lh b">limit()</code>方法，我们将返回最相关的结果，这些结果通常是我们想要的。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="b12f" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated">将$text 运算符与其他运算符结合使用</h2><p id="ffde" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated"><code class="fe le lf lg lh b">$text</code>操作符可以和常规的 MongoDB 操作符一起使用。例如，让我们找到价格低于 10000 SEK 的 HP ProBooks:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="b08f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们得到的结果:</p><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="a900" class="mm mn it lh b gy mo mp l mq mr">[<br/>  { _id: 13, name: 'HP ProBook Model 13', price: 9994 },<br/>  { _id: 9, name: 'HP ProBook Model 9', price: 9980 }<br/>]</span></pre><p id="b98b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是需要注意的是，搜索查询中应该只有一个<code class="fe le lf lg lh b">$text</code>操作符，否则只有最后一个有效。这是因为查询文档(Python 中的字典)不能有重复的键。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="d486" class="mm mn it bd mt mu mv dn mw mx my dp mz kr na nb nc kv nd ne nf kz ng nh ni nj bi translated">在聚合中使用$text 运算符</h2><p id="d8f8" class="pw-post-body-paragraph ki kj it kk b kl nk ju kn ko nl jx kq kr nm kt ku kv nn kx ky kz no lb lc ld im bi translated"><code class="fe le lf lg lh b">$text</code>操作符也可以用在聚合管道中。但是，有三个主要限制:</p><ul class=""><li id="7e64" class="np nq it kk b kl km ko kp kr nr kv ns kz nt ld nu nv nw nx bi translated"><code class="fe le lf lg lh b">$text</code>操作器只能在<code class="fe le lf lg lh b">$match</code>阶段使用。</li><li id="7ebb" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated">包含<code class="fe le lf lg lh b">$text</code>运算符的<code class="fe le lf lg lh b">$match</code>阶段必须是管道的第一个阶段。</li><li id="b7b6" class="np nq it kk b kl ny ko nz kr oa kv ob kz oc ld nu nv nw nx bi translated"><code class="fe le lf lg lh b">$text</code>操作符在<code class="fe le lf lg lh b">$match</code>阶段和整个流水线中只能出现一次。</li></ul><p id="8d49" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们为“HP ProBook”编写一个聚合管道来计算按 RAM 大小分组的笔记本电脑数量:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><pre class="lk ll lm ln gt mi lh mj mk aw ml bi"><span id="eb35" class="mm mn it lh b gy mo mp l mq mr">[<br/>  { _id: '16GB', count: 2 },<br/>  { _id: '8GB', count: 4 },<br/>  { _id: '4GB', count: 1 }<br/>]</span></pre><p id="b3d5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它显示了<code class="fe le lf lg lh b">$text</code>操作符就像聚合管道中的任何其他常规操作符一样工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="3c07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们介绍了 MongoDB 中使用<code class="fe le lf lg lh b">text</code>索引的经典文本搜索。由<code class="fe le lf lg lh b">text</code>索引和相应的<code class="fe le lf lg lh b">$text</code>操作符提供的全文搜索解决方案很简单，但也非常强大。对于大多数只需要通过简单条件进行搜索的小项目来说应该足够了。如果您想进行更高级的搜索，需要有多个字符串字段的索引，并使用复杂的<strong class="kk iu"> <em class="od">【应该(不)</em></strong>/<strong class="kk iu">/<em class="od">【必须(不)</em> </strong>条件，您可能想使用更高级的搜索引擎，如<a class="ae li" href="http://What is Elasticsearch and why is it so fast?" rel="noopener ugc nofollow" target="_blank"> Elasticsearch </a>，或“高级”<a class="ae li" href="https://betterprogramming.pub/learn-advanced-full-text-searches-with-mongodb-atlas-search-5e4b51719427" rel="noopener ugc nofollow" target="_blank"> Atlas Search </a>。</p></div></div>    
</body>
</html>