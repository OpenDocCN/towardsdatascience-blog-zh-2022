<html>
<head>
<title>Time Series Aggregations with Core PySpark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有核心PySpark的时序聚合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/neat-time-series-aggregations-with-core-pyspark-4a739953076a#2022-02-11">https://towardsdatascience.com/neat-time-series-aggregations-with-core-pyspark-4a739953076a#2022-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用核心PySpark的移动窗口聚合策略和使用Plotly的可视化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c4a5cad1b3832f4e70376eefab80d38b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*CgtmXbrTOKBKDifTYqrOyA.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://media.springernature.com/lw660/springer-cms/rest/v1/img/19125576/v3/4by3?as=jpg" rel="noopener ugc nofollow" target="_blank">https://media . springer nature . com/lw 660/springer-CMS/rest/v1/img/19125576/v3/4 by 3？as=jpg </a></p></figure><p id="2bbd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有<em class="lr"/><em class="lr">吨</em>的时间序列指标，其中许多指标有相同的预处理步骤和用例。为了限制冗余，我将关注三个不同用例的简洁指标:</p><ul class=""><li id="f463" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated"><strong class="kx iu">使用滚动Z值检测异常值</strong></li><li id="859f" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx iu">滚动相关矩阵</strong></li><li id="3701" class="ls lt it kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated"><strong class="kx iu">指数移动平均线趋势检测</strong></li></ul><p id="644c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在第一部分中，给出了滚动窗口和采样周期的定义。这些公式为如何开始创建这些移动窗口度量提供了有用的上下文。也可以随意跳到情节和代码:)</p><p id="a59c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如所有与数据有关的事情一样，有不止一种方式来<em class="lr">烘焙您的数据</em>。这里有一点关于我的背景和编程风格:我来自一个使用大量SQL的工作环境，我的聚合策略反映了这一点。因此，我没有使用PySpark表达式或内置库，也就是说，如果没有它们我也能完成任务。</p><p id="a5f2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本文中的代码在本地PySpark环境中进行了测试，并连接到S3数据源。<a class="ae ku" href="https://rohankotwani.medium.com/connecting-local-spark-to-a-s3-parquet-data-source-92bc89a3a505" rel="noopener">这里</a>是一篇关于如何在Windows 10上设置这个测试环境的简短教程文章。</p><p id="c69e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所有的方程式、图表和图形都是我创造的。所有的绘图代码都可以在这里找到<a class="ae ku" href="https://gist.github.com/freedomtowin/6f1ff6cbf2a76d08d8cb90685ec9075f" rel="noopener ugc nofollow" target="_blank">。我在所有的情节中使用了Plotly。</a></p><h1 id="0d2b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">移动窗口和采样周期</h1><p id="a4c9" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">时间序列指标通常受某个时间窗口的限制。可以有不同的粒度或采样周期来计算度量，即10分钟、1小时、1天等。我将使用的描述本文剩余部分中的度量的语法显示在等式(0)中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/000a179d3abcd40d2ea6ac0d3920e77d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ie8PchzFu4vdLJ3S.png"/></div></figure><p id="b2d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">P: (1xM)矩阵<br/> K:采样周期(10分钟、1小时等)<br/> M:回顾窗口的大小<br/> N:跨时间序列的当前整数索引<br/> n:跨时间序列的整数索引<br/> t:时间段内的整数索引</p><p id="724d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，如果采样周期(K)为10分钟:</p><blockquote class="ne nf ng"><p id="1e6e" class="kv kw lr kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated"><em class="it"> t=0，n=1，1 * K = 10分钟<br/> t=1，n=2，2 * K = 20分钟<br/> t=2，n=3，3 * K = 30分钟</em></p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/fec14e68a16f3610bc168b8c92e29650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt8KdzQMJAjNQvYZDRz2aw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/freedomtowin/6f1ff6cbf2a76d08d8cb90685ec9075f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/freedomtowin/6 f1 ff 6 CBF 2 a 76d 08d 8 CB 90685 EC 9075 f</a></p></figure><p id="83de" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">时间块<em class="lr"> t </em>代表一个大小为m的时间窗口。在聚合每个时间窗口后，时间索引N递增1。度量在<em class="lr"> t </em>上聚合，<em class="lr">T5】N跟踪每个窗口的全局时间索引。</em></p><h1 id="91d3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用滚动Z分数的异常值检测</h1><p id="a60d" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">滚动z分数阈值可用于检测时间序列中的大跳跃或间隙。这有许多潜在的应用，例如，为大的异常值创建警报系统。</p><p id="f85d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">z分数或标准分数表示平均值的标准偏差数。如果你是统计学新手，你可以在这里阅读更多关于这个指标的信息<a class="ae ku" href="https://en.wikipedia.org/wiki/Standard_score" rel="noopener ugc nofollow" target="_blank">。这个指标可以被认为是移动平均线附近的一个置信区间。</a></p><p id="9aac" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">将需要简单移动平均和简单移动标准差来创建z得分，分别如下面的等式(1)和(2)所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi np"><img src="../Images/019fe56e6b9afe293d050d1cbaa3c6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udHEk92kEc0K87tm4cVnyA.png"/></div></div></figure><p id="6393" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上面的公式显示了这两个指标是如何在M-1大小的滚动窗口t的时间步长N上定义的。最后一个时间步长M从聚合时间窗口中排除，因为目标是将当前时间序列值与前一个窗口的平均值和标准差进行比较。如果将当前时间步长包括在内，标准偏差可能会大大增加，该指标将无法检测时间序列中的大变化。</p><p id="7f94" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在我们执行这些滚动窗口计算之后，可以计算z得分上限和下限，分别如等式(3)和(4)所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nq"><img src="../Images/487b5546b5d10c13e6aa05c0c60c7d22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wpYCqsu8xvQpQN5kvIucA.png"/></div></div></figure><p id="f451" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这些等式中，z得分上限和下限分别设置为平均值上下的两个标准差。假设正态分布，<a class="ae ku" href="https://www.investopedia.com/terms/e/empirical-rule.asp#:~:text=The%20Empirical%20Rule%20states%20that,standard%20deviations%20from%20the%20mean." rel="noopener ugc nofollow" target="_blank">经验法则</a>表明我们期望99.7%的数据在标准偏差范围内。</p><p id="d9cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下图显示了ATVI每小时股价的10小时移动平均线的z值上限和下限。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/b02962559f576f375ff64be21b5dfcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mrD8W6WN4qUobKOU6AtlTg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/freedomtowin/6f1ff6cbf2a76d08d8cb90685ec9075f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/freedomtowin/6 f1 ff 6 CBF 2 a 76d 08d 8 CB 90685 EC 9075 f</a></p></figure><p id="698e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">阴影绿色区域表示移动平均线周围的置信区间，黄线表示时间序列，绿线表示时间序列的移动平均线。在某一点上，在置信区间之外有一个急剧的下降，这表明有一个大的异常值。标准偏差随后在N=130左右大幅增加。在时间序列跨越置信区间的点上，变化不是很显著。对于这个特定的时间序列，可以使用更大的z分数阈值。</p><blockquote class="ne nf ng"><p id="3209" class="kv kw lr kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">注意:数据集经过预处理，包含工作日上午9点到下午4点之间的每小时数据。为了便于绘图，这些值是相对于指数而不是时间绘制的。这消除了图中的一些不连续性。</p></blockquote><h2 id="4016" class="nr mh it bd mi ns nt dn mm nu nv dp mq le nw nx ms li ny nz mu lm oa ob mw oc bi translated">PySpark代码:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="e4a5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，创建一个分级索引来执行自连接，以便为每个时间序列(即股票符号)获得一个按时间排序的历史窗口。然后，对于视图(a)中的每个值，在视图(b)中聚合移动平均值和移动标准偏差。从这些度量中，可以计算出z得分阈值的上限和下限。</p><h1 id="ff82" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">滚动相关矩阵</h1><p id="dd43" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">滚动相关矩阵有助于将相关的时间序列组合在一起，帮助找到不同的、不相关的时间序列，或者检测相关模式的变化。我对你的挑战是在不使用内置PySpark函数的情况下创建这个；)</p><p id="af76" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">归一化协方差，或<a class="ae ku" href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient" rel="noopener ugc nofollow" target="_blank">皮尔逊相关系数</a>，描述了两个变量之间的相关性。该指标限制在-1和1之间，这是在时间序列对之间比较该指标时的一个有用属性。我们可以通过滚动时间窗口计算这种相关性。</p><p id="c64f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">滚动相关性也可以用指数移动平均函数来平滑。平滑滚动相关的另一个术语是“实现的相关”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi of"><img src="../Images/1795d6503da08d70a91bcf59875638a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xtB2L4iNL6ya18RnvftYBQ.png"/></div></div></figure><p id="474f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">其中，<em class="lr"> r </em>是我们的时间序列数据集中I列和j列的相关性，μ是简单移动平均值，σ是简单移动标准差。</p><p id="df93" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我将使用我可靠的股票数据集来绘制DoorDash的小时股价与其他股票(如ATVI、DIS、NVDA和WMT)的滚动相关性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/16baebcce060a068cda12b75fe16ff65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ihJ__9FCzzHtLPndxG77A.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/freedomtowin/6f1ff6cbf2a76d08d8cb90685ec9075f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/freedomtowin/6 f1 ff 6 CBF 2 a 76d 08d 8 CB 90685 EC 9075 f</a></p></figure><p id="7e40" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">与其他时间序列相比，DASH和NVDA之间的相关性在更长的时间段内似乎是一致的。同时持有这两只股票可能会增加投资组合的风险。</p><p id="87a7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:在上图中，当任一时间序列缺少当前时间步长n的数据时，就会出现缺失数据点。例如，DIS缺少2021年8月至2021年11月之间的数据。但是，关联窗口将跳过空值，过去14小时没有丢失的值将用于聚合。</p><h2 id="53a8" class="nr mh it bd mi ns nt dn mm nu nv dp mq le nw nx ms li ny nz mu lm oa ob mw oc bi translated">PySpark代码:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="c9bd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第一步是计算数据透视表，按时间分区，按时间序列id、股票代码分组。该数据透视表采用时间序列的平均值，<em class="lr"> close </em>，但是由于数据集被预处理为每小时一个值，因此最小值、最大值、第一个值或最后一个值也可以作为聚合。</p><blockquote class="ne nf ng"><p id="eae3" class="kv kw lr kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">对于每对时间序列，在计算滚动相关性之前，将删除任一时间序列中具有空值的行</p></blockquote><p id="45ef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下一步是创建不重复的时间序列对或组合。从每个组合中删除具有空值的行。最后，我们需要计算每对时间序列之间的相关性。幸运的是，PySpark中有一个内置函数可以计算两列之间的相关性。滚动相关性然后被左连接回数据透视表。</p><h1 id="b77a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用指数移动平均线进行趋势检测</h1><p id="e9ba" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">差分指数移动平均线可用于检测时间序列的<em class="lr">速度</em>或趋势。这种方法可以在差分时间序列上第二次应用，以检测<em class="lr">加速度</em>，或趋势的变化率。</p><p id="88ff" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">指数移动平均线(EMA)可以看作是一个过滤器，它更重视聚合窗口内的最新值。EMA有两个主要参数，即<em class="lr"> alpha </em>衰减率和窗口大小。时间窗口越大或者alpha越低，均线移动的越慢。换句话说，移动平均将比实际时间序列落后更多。</p><p id="2555" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本节使用的趋势检测方法通常称为<a class="ae ku" href="https://en.wikipedia.org/wiki/MACD" rel="noopener ugc nofollow" target="_blank"> MACD </a>。然而，我将用新的，在我看来更容易理解的术语来解释这个算法。</p><blockquote class="ne nf ng"><p id="7404" class="kv kw lr kx b ky kz ju la lb lc jx ld nh lf lg lh ni lj lk ll nj ln lo lp lq im bi translated">通常，α通常被选择为等于2/(1+M)，其中M是窗口大小。α的这个值对应于平均加权影响，或“质心”，对应于简单移动平均(SMA)的回顾窗口的中心。换句话说，对于高度自相关的信号(比如股票价格)，均线会落后于实际价格大约一半的时间。详情请见<a class="ae ku" href="https://people.duke.edu/~rnau/Notes_on_forecasting_with_moving_averages--Robert_Nau.pdf" rel="noopener ugc nofollow" target="_blank">Robert Nau的预测笔记</a>。</p></blockquote><p id="39a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">据我所知和谷歌搜索，如果不使用用户定义的函数或UDF，在PySpark中实现递归方法(如EMAs)是不可能的。幸运的是，有一个扩展的级数表示，可以用来计算核心PySpark中的EMAs。等式(6)以扩展的符号显示了指数移动平均公式(EMA)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi og"><img src="../Images/a04632aaf6b938722fe29be25be84e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g2n0wZ_AIqFqb1SoDoxhEQ.png"/></div></div></figure><p id="8531" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过取快速移动(时间窗较短)和慢速移动(时间窗较长)的均线之差，可以估算出<em class="lr">趋势</em>。直观上，这可以被认为是最近价格和以前价格之间的斜率或离散导数。这些均线之间的差异可以称为趋势的<em class="lr">速度</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi oh"><img src="../Images/99ce70d97d527eef066752de2a2f87b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsL5mc1af_Qb14hEaC54XA.png"/></div></div></figure><p id="ada9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">趋势变化的速度也可以用1)T4速度(T5)和2)均线(T8)来估计。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi np"><img src="../Images/e6c0bb2e9e565acbe3555e5f7f7ee437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zNEsr8X8VyWEKWgroGZeA.png"/></div></div></figure><p id="1441" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="lr">信号</em>和<em class="lr">速度</em>之差可以认为是趋势<em class="lr">的<em class="lr">加速度</em>。</em>速度和信号之间的收敛代表趋势方向的反转。这种背离代表着一种越来越强的趋势。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/a876df1112631ce5ff5738e9eaf31499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuWdwJdVXQxMkpmRvzjQqQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://gist.github.com/freedomtowin/6f1ff6cbf2a76d08d8cb90685ec9075f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/freedomtowin/6 f1 ff 6 CBF 2 a 76d 08d 8 CB 90685 EC 9075 f</a></p></figure><p id="9e3d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">顶部的图显示了时间序列(黄色)、慢速均线(蓝色)和快速均线(红色)。底部曲线显示了<em class="lr">加速度</em>(直方图)、趋势<em class="lr">速度</em>(红色)和信号(蓝色)。该图显示了短时间间隔内趋势的一致性。简单地说，可以设置<em class="lr">加速度</em>的某个<em class="lr">安全</em>阈值来检测强烈的上升和下降。</p><p id="d371" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:这个图看起来有点起伏，因为我选择K=3作为采样周期。</p><h2 id="dacb" class="nr mh it bd mi ns nt dn mm nu nv dp mq le nw nx ms li ny nz mu lm oa ob mw oc bi translated">PySpark代码:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><p id="2135" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">创建了一个单独的函数来计算大小为m的特定窗口的EMA。在该函数中，创建了一个分级指数来执行自连接，以便为每个分区(即股票符号)获得按时间排序的历史窗口。历史窗口的指数和当前指数之间的差异用于为EMA公式的扩展序列表示创建alpha权重，如等式8所示。最后，对于视图(a)中的每个值，汇总视图(b)中的EMA。</p><p id="11cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们可以用均线函数来计算快速移动的均线，慢速移动的均线，快慢均线之差(速度)，以及速度的均线(信号)。</p><h1 id="e2c5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="fcff" class="pw-post-body-paragraph kv kw it kx b ky my ju la lb mz jx ld le na lg lh li nb lk ll lm nc lo lp lq im bi translated">简而言之，本文展示了我如何在PySpark和SQL中聚合时间序列。我知道时间序列窗口和方程的正式定义使得这篇文章更难阅读。不过我喜欢彻底:)我也，大概，本来可以把这篇文章分成三篇。不过，希望PySpark和Plotly代码对一些新的数据科学家/工程师有用。</p><p id="ff42" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下是一些您可以尝试的数据挑战:</p><ol class=""><li id="226d" class="ls lt it kx b ky kz lb lc le lu li lv lm lw lq oi ly lz ma bi translated">在异常值检测算法中，使用指数移动平均代替简单移动平均。</li><li id="93f5" class="ls lt it kx b ky mb lb mc le md li me lm mf lq oi ly lz ma bi translated">编写自己的相关函数，而不是使用内置的PySpark相关函数。探索实施类似的指标，例如，<a class="ae ku" href="https://en.wikipedia.org/wiki/Cointegration#:~:text=Cointegration%20is%20a%20statistical%20property,k)%20of%20time%20series%20variables.&amp;text=Formally%2C%20if%20(X%2CY,Y%2C%20and%20Z%20are%20cointegrated." rel="noopener ugc nofollow" target="_blank">协整</a>。</li><li id="2494" class="ls lt it kx b ky mb lb mc le md li me lm mf lq oi ly lz ma bi translated">使用指数移动平均值创建平滑移动窗口相关矩阵。</li><li id="7d4b" class="ls lt it kx b ky mb lb mc le md li me lm mf lq oi ly lz ma bi translated">针对M1、M2和M3的多个参数，描述趋势检测方法的有效性。</li></ol><p id="0136" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是所有的乡亲。</p></div></div>    
</body>
</html>