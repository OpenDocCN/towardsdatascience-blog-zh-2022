<html>
<head>
<title>Coding Interview: Next Permutation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码面试:下一次置换</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coding-interview-next-permutation-1cd07dcb20db#2022-04-12">https://towardsdatascience.com/coding-interview-next-permutation-1cd07dcb20db#2022-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="055b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个在编码面试中经常出现的排列问题的教程。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/74d2dcc7e9b595f73c84dc55e2e26fa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q9mkG6SOgaRgVOpWepwleQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。下一个排列|图标由<a class="ae ky" href="https://www.flaticon.com/authors/jungsa" rel="noopener ugc nofollow" target="_blank"> JungSa </a></p></figure><p id="0130" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">排列(和组合)问题在代码面试中经常出现，并且由于有效解决问题所需的基础知识而具有挑战性。</p><p id="90ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博文中，我们将看到一些解决<em class="lv">下一个排列</em>问题的方法和技术，从基于蛮力的方法开始，以找到更有效的解决方案。</p><p id="86a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开始吧！</p><h1 id="6084" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">问题陈述</h1><p id="49aa" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们来看看问题的定义:</p><blockquote class="mt mu mv"><p id="6e23" class="kz la lv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">整数数组的下一个排列是其整数的下一个更大的排列。更正式的说法是，如果数组的所有排列都在一个容器中按照它们的字典顺序排序，那么该数组的下一个排列就是排序容器中它后面的排列。[ <a class="ae ky" href="https://leetcode.com/problems/next-permutation/" rel="noopener ugc nofollow" target="_blank"> 1 </a> ]</p></blockquote><p id="dcc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cabe" class="ne lx it na b gy nf ng l nh ni"><strong class="na iu">Case 1</strong><br/><strong class="na iu">Input</strong>: nums = [1,2,3]<br/><strong class="na iu">Output</strong>: [1,3,2]</span><span id="2194" class="ne lx it na b gy nj ng l nh ni"><strong class="na iu">Case 2</strong><br/><strong class="na iu">Input:</strong> nums = [3,2,1]<br/><strong class="na iu">Output:</strong> [1,2,3]</span><span id="75f9" class="ne lx it na b gy nj ng l nh ni"><strong class="na iu">Case 3<br/>Input</strong>: nums = [2,0,2,2]<br/><strong class="na iu">Output</strong>: [2,2,0,2]</span></pre><p id="cc72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，该问题需要以下排列作为输入，给定从给定排列开始的升序。如果没有更大的排列，则返回具有最小字典序值的排列。在图2中，我们看到了从按字典顺序排列的<code class="fe nk nl nm na b">[1,2,3]</code>生成的排列的表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/9652de0c1ed067f7678e65d38c358cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbd6Zxz6sD9J6nSrfnymrA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。从[1，2，3]开始的所有字典序排列的表示。作者用红色|图像表示输入的下一个排列。</p></figure><p id="bfea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦明确了问题的定义和范围，让我们继续解决方案，从基于蛮力的方法开始，然后应用一种技术来获得更有效的解决方案。让我们去吧！</p><h1 id="3699" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">方法1:暴力</h1><p id="0c4f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">强力方法的关键思想是生成所有排列，按字典顺序排序，并提取由<code class="fe nk nl nm na b">input</code>确定的下一个排列。在代码片段1中，我们可以看到暴力方法的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段1。下一个排列问题的强力解决方案</p></figure><p id="7861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一组<code class="fe nk nl nm na b">n</code>元素的排列数为<code class="fe nk nl nm na b">n!</code>，那么运行时复杂度为O(N！)和O(N)表示内存使用情况。值得一提的是，在代码片段1中展示的基于暴力的方法中，主要的运行时复杂度是O(N！).尽管实现最小堆的复杂度为O(N Log N ),并且寻找下一个排列的复杂度为O(N ),但是最终的主要复杂度为O(N！).</p><p id="6880" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个问题衍生出的一个对代码面试非常有用的重要话题是使用特定的递归技术(比如<code class="fe nk nl nm na b">backtracking</code>)生成排列，对此我将写一整篇博客。与此同时，您可以看看第10行的代码片段1，其中función <code class="fe nk nl nm na b">backtrack()</code>是以一种高效而优雅的方式为置换生成而定义的。</p><p id="1eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继续问题，不生成所有的排列，怎么找到下一个排列？好吧，让我们在下一节详细看看。</p><h1 id="c0d3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">方法2:诀窍</h1><p id="c63f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一个排列问题，乍一看，似乎有很高的复杂程度。然而，它比看起来要简单。事实上，在最简单的形式中，问题可以一次解决。“诀窍”是知道、推断或以这种方式找出解决问题的步骤。</p><p id="d7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤描述如下:<br/> 1。从后向前遍历数组<code class="fe nk nl nm na b">nums</code>，直到找到序列中的第一个非递增元素，比如说<code class="fe nk nl nm na b">nums[i-1]</code>。<br/> 2。如果索引<code class="fe nk nl nm na b">i-1</code>不为零，则找到并交换大于元素<code class="fe nk nl nm na b">nums[i-1]</code>的第一个元素。如果索引<code class="fe nk nl nm na b">i-1</code>是零，这意味着该序列是按降序排列的，因此它是可以形成的最大序列，因此，该过程通过返回相反的序列而结束。<br/> 3。从索引<code class="fe nk nl nm na b">i</code>开始的元素被反转。</p><p id="7a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在图3中，我们可以看到解决下一个排列问题时两种情况的可视化表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/9a2a257f96ec545545349d9daefe258a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGHFvw0diMDkFCFfiTkkZw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3。下一个排列示例。|图片作者</p></figure><p id="3582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码片段2中，我们可以看到有效解决下一个置换问题的函数的定义。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码片段2。下一个排列，最佳方法。</p></figure><p id="4ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nk nl nm na b">nums</code>数组最多被遍历两次，运行时复杂度是线性的O(N ),内存使用保持恒定O(1 ),因为不需要额外的内存来解决问题。</p><p id="c8c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，如果你在代码面试中遇到下一个排列问题，现在你有了一个解决它的选择。</p><h1 id="f618" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="7d40" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">排列和组合问题需要特定的技术来有效地解决它们(例如回溯)。然而，这个特殊的问题可以用另一种方法解决。解决这个问题变得有争议，因为它可以被视为“知道诀窍与否”，这是可以理解的，但这不是我们(那些在面试中解决这类问题的人)可以做出的决定。控制。</p><h1 id="a1a3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><p id="d18a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">[1]<a class="ae ky" href="https://leetcode.com/problems/next-permutation/" rel="noopener ugc nofollow" target="_blank">https://leetcode.com/problems/next-permutation/</a></p></div></div>    
</body>
</html>