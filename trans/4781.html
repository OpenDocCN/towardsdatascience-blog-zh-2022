<html>
<head>
<title>A Stepped Approach for Balancing and Augmenting Structured Data for Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">平衡和扩充用于分类的结构化数据的分步方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-stepped-approach-for-balancing-and-augmenting-structured-data-for-classification-b9602be5a050#2022-10-24">https://towardsdatascience.com/a-stepped-approach-for-balancing-and-augmenting-structured-data-for-classification-b9602be5a050#2022-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="68fc" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">阶级不平衡</h2><div class=""/><div class=""><h2 id="ab9a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">数据扩充从数据集生成模拟数据。我们拥有的数据越多，选择的学习者在分类或预测方面就越好。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f652dedf9a7128cedc1cab96ab2f15cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YIaPuT5KnS05mpHC8pI-7w.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">平衡各类岩石。由<a class="ae lh" href="https://unsplash.com/s/photos/balancing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae lh" href="https://unsplash.com/@karsten116?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Karsten Winegeart </a>拍摄</p></figure><p id="9703" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">结构化数据增强很少在理论方法中讨论，也很少出现在现实世界的生产系统中。当它发生时，它被称为类平衡或过采样。</p><p id="f1a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将展示一种简单的结构化数据扩充方法。在本文的后续文章中，我将演示一个分步过程，它避免了处于过采样技术(如SMOOT和ADASYN)核心的简单k均值聚类。</p><h1 id="1f20" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">Paso:数据分类平衡</h1><p id="2a5e" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">讨论将分为以下几个主要部分:</p><ul class=""><li id="2637" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated">首先，我们用Paso输入器加载一个不平衡的类数据集。</li><li id="ec10" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">其次，我将调查帕索提供的一些班级平衡方法。</li><li id="d32a" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">接下来，我将展示Paso中提供的一些结构化数据扩充来自于类平衡方法。</li><li id="533b" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">然后，我暗示这些方法可能不足以平衡结构化数据的增长。</li></ul><p id="f220" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">本文中所有示例的源代码也可以作为一个完整的<a class="ae lh" href="https://github.com/bcottman/paso/blob/master/lessons/lesson-3.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a> (ipynb)获得。</p><p id="0c5f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以通过以下方式启动Paso服务:</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="263f" class="nu mf it nq b gy nv nw l nx ny">from paso.base import Paso,Log,PasoError<br/>from loguru import logger</span><span id="31a0" class="nu mf it nq b gy nz nw l nx ny">session = Paso(parameters_filepath='../parameters/default-lesson.3.yaml').startup()</span></pre><h1 id="5759" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">数据集:yeast3</h1><p id="39d4" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">不平衡数据集是类分布不均匀的分类问题的一种情况。通常，它们由两类组成:多数(消极)类和少数(积极)类。</p><p id="829a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我选择了yeast3数据集，自20世纪90年代末以来，生物学家和机器学习科学家一直在研究它。可以参考参考文献中的引用来使用:[1，2]它从<a class="ae lh" href="https://sci2s.ugr.es/keel/imbalanced.php" rel="noopener ugc nofollow" target="_blank">https://sci2s.ugr.es/keel/imbalanced.php</a>下载。</p><p id="353c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将yeast3数据集加载到数据集dataframe中。要素类将包含类值。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">输入yeast3的设置代码</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/7baf4503e725c9e625d7002f0bb95736.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylYx84lS1jtM7sKkiue1xA.png"/></div></div></figure><p id="93dc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该数据集的特征是:</p><p id="b10a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">类:</strong>预测或依赖或目标特征。第0类与第1类的比例为8:1。</p><p id="7098" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Mcg </strong> : McGeoch的信号序列识别方法。</p><p id="ddf9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Gvh </strong>:冯·海涅的信号序列识别方法。</p><p id="6368" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">Alm</strong>:ALOM跨膜区预测程序得分。</p><p id="c8ab" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Mit </strong>:线粒体和非线粒体蛋白N端区域(20个残基长)氨基酸含量的判别分析得分。</p><p id="c60a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Erl </strong>:存在“HDEL”子串(被认为是内质网腔内滞留的信号)。二元属性。</p><p id="103e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">Pox</strong>:C端的过氧化物酶体靶向信号。</p><p id="163a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Vac </strong>:液泡蛋白和胞外蛋白的氨基酸含量判别分析得分。</p><p id="8de4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd"> Nuc </strong>:细胞核蛋白和非细胞核蛋白核定位信号的判别分析得分。</p><p id="433a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这些特征是酵母菌株的不同类型的测量。如果您不知道它们的意思，请不要担心，因为这对本文并不重要。</p><h2 id="de09" class="nu mf it bd mg od oe dn mk of og dp mo lr oh oi mq lv oj ok ms lz ol om mu iz bi translated">描述文件</h2><p id="24ca" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我将使用一个描述文件，而不是使用代码中的关键字参数。描述的一个有效定义(来自维基百科)是:</p><p id="a00b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">"显示主题领域或领域中概念和类别之间的关系."</p><p id="d896" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使用描述文件是因为:</p><ul class=""><li id="19c6" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated">对象(数据集、模型等)的描述。)改而不改代码；</li><li id="4fdd" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">描述文件和Python的解析性能大致相同，因为两者都使用动态类型。对于静态类型语言来说，性能问题可能不是问题。然而，在所有情况下，与类实例执行的操作相比，对象的元数据解析计算是微不足道的。</li><li id="c6e7" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated">描述文件是独立于语言的。它被格式化为YAML文件，但也格式化为JSON或XML文件。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi on"><img src="../Images/1a2396a12f2f9a0ec40e5daf419853db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFuPGbHeT_x9xEv3Rte0lQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">学习者随机森林的描述文件</p></figure><p id="458f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">描述文件由键值对的层次结构组成。在以后的文章中，我将详细介绍描述文件——在<a class="ae lh" href="https://github.com/bcottman/paso/tree/master/descriptions" rel="noopener ugc nofollow" target="_blank">https://github.com/bcottman/paso/tree/master/descriptions</a>查看不同的描述文件。</p><h1 id="8474" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">平衡前先拆分。</h1><p id="3794" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在训练学习者之前，我们必须只平衡我们将要训练的数据集。我们想知道平衡数据对学习者的影响，同时不要用增加的数据破坏我们的验证数据集。</p><p id="b715" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">验证从初始训练数据集中提取，希望它是测试数据集从训练集剩余部分提取的过去和未来数据的样本。在这种情况下，我们的验证集被引用为asX_test，y_test。涵盖原始数据集的训练、有效和测试的另一种情况是将初始数据集拆分为训练和验证数据集。然后再分乘一列火车，进行训练和测试。只要第二次分割也在训练数据集中，顺序就无关紧要。这里，训练集将是70%，验证(测试)集将是原始数据集的30%。</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="0b8b" class="nu mf it nq b gy nv nw l nx ny">X, y = DataFrame_to_Xy(dataset, inputer.target)<br/>splitter = Splitters(description_filepath=splitter_file)<br/>X_train,X_test, y_train, y_test = splitter.transform(X, y,random_state=11)<br/>train = X_train.copy()<br/>Xy_to_DataFrame(train, y_train, inputer.target)<br/>train.groupby([inputer.target]).count()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oc"><img src="../Images/cdf616750a3c05f69872efbe1fca8a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kG2P3_qbKFZ0idAQE3hnQ.png"/></div></div></figure><h1 id="c516" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">随机森林学习者</h1><p id="f8dd" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在我们平衡类之前，让我们在<code class="fe oo op oq nq b">yeast3</code>数据集上运行具有通用分类超参数的随机森林学习器(如上面随机森林的描述文件所示)。</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="ef74" class="nu mf it nq b gy nv nw l nx ny">from paso.learners.learners import Learners<br/>learner = Learners(description_filepath=learner_file)<br/>learner.train(X_train,y_train)<br/>learner.cross_validate(X_train,y_train,description_filepath=cv_file)learner.evaluate(X_test, y_test)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/5405d8bf56a1405d96c3ba5730b1a7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-yaOER8pDyagJTEyjHPIFw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用RandomForest的yeast3指标</p></figure><p id="26a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面显示了与<code class="fe oo op oq nq b">0.8207.</code>的<code class="fe oo op oq nq b">f1</code>相当好的拟合，当我们通过过采样平衡类1和类0时会发生什么？</p><h1 id="ba1f" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">处理不平衡的班级</h1><p id="e191" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">对于不平衡的类数据，没有必要平衡类。在现实世界中，数据集是实际人口的样本。然而，这种不平衡可能不能准确地代表潜在人口。</p><p id="7855" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，平衡可能不会影响底层类的表示，从而更好地适应数据。</p><p id="1c96" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">也就是说，如果不平衡程度相对较低，应该不会对您的模型性能产生任何重大影响。</p><p id="c85e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在不同的不平衡水平下，采样技术表现不同。</p><p id="8918" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">目前有四种不同类型的方法来实现阶级平衡:</p><ol class=""><li id="fb50" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md os nh ni nj bi translated"><strong class="lk jd">权重</strong> <strong class="lk jd">赋值</strong>:这些不同的方法对少数类赋予较高的权重，对多数类赋予较低的权重。没有事实信息添加到数据集中。相反，这是由不同的阶层调节的。极度<strong class="lk jd">欠采样</strong>或<strong class="lk jd">过采样</strong>会产生最差的数据拟合。</li><li id="0352" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md os nh ni nj bi translated"><strong class="lk jd">离群点</strong> <strong class="lk jd">剔除</strong>:聚类分析后，剔除离质心最远且在聚类之外的数据点。数据点消除应在人工监督下完成(即手动)。例如，年薪2，000，000美元可能是潜在分布的实际数据点，而50米长的蜘蛛可能是错误的。有些人会认为不应该删除整行；相反，虚假值被更敏感的东西取代，比如中值或平均值。在任何情况下，淘汰都会导致信息含量降低。</li><li id="5c08" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md os nh ni nj bi translated"><strong class="lk jd">欠采样</strong>:多数类成员通过不同的采样策略减少。欠采样通常是最糟糕的方法之一，因为数据集中的数据量减少了。同样，随着数据的减少，大多数模型更适合的信息丢失。当训练数据集(带有欠采样)从来没有比验证或测试数据集更好的损失度量时，您还必须小心欠拟合。</li><li id="f3ac" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md os nh ni nj bi translated"><strong class="lk jd">过采样</strong>:少数类成员通过不同的合成数据生成策略增加。SMOTE(合成少数过采样技术)和ADASYN(自适应合成)是过采样领域最著名的技术。随着样本数量的增加，过采样通常是最佳方法之一。随着数据的增加，所有的模型都更加适合。但是，如果您小心过度拟合，那将是最好的。当训练数据集(具有过采样)具有比验证或测试数据集更好的损失度量时，会发生过度拟合。</li></ol><p id="ae8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ot">警告:<br/>只有SMOTEC可以平衡具有分类特征的数据集。所有其他人将只接受具有连续特征的数据集。</em></p><p id="5b4a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">给定的过采样技术有:</p><ul class=""><li id="feab" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated"><code class="fe oo op oq nq b">RandomeOverSample</code></li><li id="b642" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">SMOTE</code></li><li id="b287" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">ADASYN</code></li><li id="53dd" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">BorderLineSMOTE</code></li><li id="69f7" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">SVSMOTE</code></li><li id="f42f" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">SMOTENC</code></li></ul><blockquote class="ou ov ow"><p id="621c" class="li lj ot lk b ll lm kd ln lo lp kg lq ox ls lt lu oy lw lx ly oz ma mb mc md im bi translated"><code class="fe oo op oq nq b"><a class="ae lh" href="https://imbalanced-learn.readthedocs.io/en/stable/generated/imblearn.over_sampling.ADASYN.html#imblearn.over_sampling.ADASYN" rel="noopener ugc nofollow" target="_blank"><em class="it">ADASYN</em></a></code>着重于生成与使用k-最近邻分类器错误分类的原始样本相邻的样本，而<code class="fe oo op oq nq b"><a class="ae lh" href="https://imbalanced-learn.readthedocs.io/en/stable/generated/imblearn.over_sampling.SMOTE.html#imblearn.over_sampling.SMOTE" rel="noopener ugc nofollow" target="_blank"><em class="it">SMOTE</em></a></code>的基本实现不会对使用最近邻规则分类的简单和困难样本进行任何区分。因此，在训练期间发现的决策函数在算法之间将是不同的。然而，由于距质心的距离度量，类簇需要是圆形的，以使任一方法都工作良好。</p></blockquote><p id="5e2f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">给定的欠采样技术有:</p><ul class=""><li id="b788" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated"><code class="fe oo op oq nq b">RandomUnderSample</code></li><li id="597f" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">ClusterCentroids</code></li><li id="d63e" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">SMOTE</code>的各种版本</li><li id="5aa5" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">ADASYN</code></li></ul><p id="77dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">异常值消除(导致欠采样)技术有:</p><ul class=""><li id="6556" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated"><code class="fe oo op oq nq b">NearMiss</code></li><li id="2cf9" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">EditedNearestNeighbour</code></li><li id="3d4c" class="nb nc it lk b ll nk lo nl lr nm lv nn lz no md ng nh ni nj bi translated"><code class="fe oo op oq nq b">CondensedNearestNeighbour</code></li></ul><p id="bc15" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在广泛的<a class="ae lh" href="https://imbalanced-learn.readthedocs.io/en/stable/user_guide.html" rel="noopener ugc nofollow" target="_blank">不平衡-sklearn文档</a>中详细阅读这些类平衡技术和例子。</p><p id="f484" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有可用的类别平衡策略如下所示:</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="1c2d" class="nu mf it nq b gy nv nw l nx ny">from paso.pre.cleaners import Balancers<br/>class_balancer = Balancers(description_filepath=balancer_file)<br/>o.classBalancers()</span></pre><p id="0104" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将使用<code class="fe oo op oq nq b">SMOTE</code>对少数类进行过采样。我推荐阅读，</p><div class="pa pb gp gr pc pd"><a rel="noopener follow" target="_blank" href="/handling-imbalanced-datasets-in-machine-learning-7a0e84220f28"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jd gy z fp pi fr fs pj fu fw jc bi translated">机器学习中不平衡数据集的处理</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">面对不平衡的班级问题，应该做什么，不应该做什么？</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">towardsdatascience.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr lb pd"/></div></div></a></div><p id="cfcc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">了解更多关于如何平衡类不平衡数据集的详细信息。</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="d90c" class="nu mf it nq b gy nv nw l nx ny">balancer = Balancers(description_filepath=balancer_file)<br/>X_train,y_train = balancer.transform(X_train,y_train)<br/>train = X_train.copy()<br/>Xy_to_DataFrame(train, y_train, inputer.target)<br/>train.groupby([inputer.target]).count()</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ps"><img src="../Images/688259ddf24f41332777846e4a0e1948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MWi_7cgxVAjk2AstG94z1A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SMOOT类平衡后的yeast3数据集</p></figure><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="0278" class="nu mf it nq b gy nv nw l nx ny">from paso.learners.learners import Learners<br/>learner = Learners(description_filepath=learner_file)<br/>learner.train(X_train,y_train)<br/>learner.cross_validate(X_train,y_train,description_filepath=cv_file)learner.evaluate(X_test, y_test)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pt"><img src="../Images/a05464b32decf2f9ad89ce3a47c8f787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyodlxxP_ceM-PpSOAjP3w.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用RandomForest的类平衡yeast3的度量</p></figure><p id="a3f9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，由于类平衡了前少数的假阳性，类1从21减少到15(好)(如混淆矩阵所示)。以前的多数类将假阳性从6增加到9(坏)。更重要的是，<code class="fe oo op oq nq b">f1</code>增加到了<code class="fe oo op oq nq b">0.8356</code>，而<code class="fe oo op oq nq b">logloss </code>减少到了<code class="fe oo op oq nq b">0.1346.</code>，看来<code class="fe oo op oq nq b">SMOTE</code>类平衡帮助我们适应了<code class="fe oo op oq nq b">yeast3</code>数据集。</p><h1 id="a980" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">扩充<code class="fe oo op oq nq b">yeast3 </code>数据集</h1><p id="6602" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">现在，我们可以使用SMOTE通过类不平衡方法生成的合成数据进行扩充(增加100%的数据量)。结果类似于图像扩充，因为我们通过使用合成数据增加<code class="fe oo op oq nq b">yeast3</code>数据集的行数来完成结构化数据扩充。</p><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="90c0" class="nu mf it nq b gy nv nw l nx ny">from paso.pre.cleaners import Augmenters<br/>augmenter = Augmenters(description_filepath=balancer_file)<br/>ratio = 1.0<br/>X_augment,y_augment = augmenter.transform(X_train,y_train,ratio=ratio, verbose=True)<br/>_, _, occurCount = np.unique(<br/>    y_augment, return_index=True, return_counts=True<br/>)<br/>occurCount</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pu"><img src="../Images/b8f316bc7d5c44a0cf7b87ca0e08cd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlG6yRCkRtHlnCnRkRx-ug.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">使用来自yeast3的每个类簇的合成数据，将行数增加100%。</p></figure><pre class="ks kt ku kv gt np nq nr ns aw nt bi"><span id="9cc0" class="nu mf it nq b gy nv nw l nx ny">learner = Learners(description_filepath=learner_file,target=inputer.target)<br/>learner.train(X_augment,y_augment )<br/>learner.cross_validate(X_augment,y_augment ,description_filepath=cv_file)<br/>learner.evaluate(X_test, y_test)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pv"><img src="../Images/98467d7e312ec9d959c5cab2e0c14707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rtkVa_A7Yp73diLDwh5xqA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">年增长100% 3</p></figure><p id="fd74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用SMOTE的聚类采样对数据进行过采样最多也就是模棱两可。<code class="fe oo op oq nq b">logloss</code>和<code class="fe oo op oq nq b">f1</code>都增加了！这表明<code class="fe oo op oq nq b">yeast3</code>的簇不是<code class="fe oo op oq nq b">SMOTE.</code>所要求的圆形。接下来，我将使用<code class="fe oo op oq nq b">SMOTE </code>进一步增加数据集三次，每次都使数据集行数加倍。绘制<code class="fe oo op oq nq b">logloss </code>与行数和<code class="fe oo op oq nq b">f1</code>的关系图显示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pw"><img src="../Images/dd1a3179b0fdf1f6ba02b4eb0e981d48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tAKBV4Tj8LcumfvyR5ulBA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集:yeast3。logloss作为SMOTE数据生成的函数。</p></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi px"><img src="../Images/6665c7b4c18978a4df3b4f81f6825e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MF6irgYzhGSVvxReL5-3Lg.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">数据集:yeast3。f1作为SMOTE数据生成的函数。</p></figure><h1 id="1ae1" class="me mf it bd mg mh mi mj mk ml mm mn mo ki mp kj mq kl mr km ms ko mt kp mu mv bi translated">结论和总结</h1><p id="731a" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我不能说SMOTE不会生成好的伪数据。为此，我们需要为每次增强优化学习者的超参数，使用PCA和聚类分析查看数据的形状，尝试不同的学习者，以及尝试除SMOTE之外的不同数据增强器。我将在本文的第2部分做这件事。</p><p id="4e04" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们引入了paso的<strong class="lk jd"> </strong>数据<strong class="lk jd"> </strong>输入类、Inputer和Spitter类来将数据分成训练、有效和测试数据集。我还略微浏览了描述文件，这些文件捕获了我们希望某个类执行的操作的描述。我说过，通过偶然的争论，描述文件比编码的关键字争论更好。是的，我们从描述文件中获得了一些语言独立性。最后，我对学习者的使用和那些学习者的交叉验证做了一个小小的尝试。</p><p id="8b57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我把重点放在了这篇文章的主题上，平衡器和增强器。我们看到了如何扩充结构化数据。平衡提高了学习者的预测能力，但在这个最小的研究中，我们未能显示使用SMOTE进一步增加数据会提高预测能力。</p><p id="2303" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你有一个服务或功能或看到一个错误，离开帕索项目一个<a class="ae lh" href="https://github.com/bcottman/paso/issues" rel="noopener ugc nofollow" target="_blank">注意</a>。</p></div><div class="ab cl py pz hx qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="im in io ip iq"><p id="1ed7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">考虑成为一个月5美元的中等会员。你将可以无限制地访问我的文章和数以千计的其他作者关于投资、数据科学、编程、人际关系、幽默、健康、生活方式等等的文章。</p><p id="8413" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">用我的推荐链接加入媒体。</p><div class="pa pb gp gr pc pd"><a href="https://dr-bruce-cottman.medium.com/membership" rel="noopener follow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd jd gy z fp pi fr fs pj fu fw jc bi translated">通过我的推荐链接加入Medium—Bruce h . Cottman博士</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">阅读Bruce H. Cottman博士(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接…</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">dr-bruce-cottman.medium.com</p></div></div><div class="pm l"><div class="qf l po pp pq pm pr lb pd"/></div></div></a></div><p id="393f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一个媒体会员，你的会员费的一部分给了你阅读的作家，你可以完全接触到每一个故事。</p></div><div class="ab cl py pz hx qa" role="separator"><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd qe"/><span class="qb bw bk qc qd"/></div><div class="im in io ip iq"><p id="4b95" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">继续高效地编码！继续开心吧！</p><p id="eb6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[1]阿尔卡拉-费德斯、桑切斯、加西亚、德尔赫苏斯、本图拉、加雷尔、奥特罗、罗梅罗、巴卡迪特、里瓦斯、费尔南德斯、埃雷拉。</p><p id="38be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">[2] KEEL:一个评估数据挖掘问题进化算法的软件工具。软计算13:3(2009)307–318，<a class="ae lh" href="http://dx.doi.org/10.1007/s00500-008-0323-y" rel="noopener ugc nofollow" target="_blank">doi:10.1007/s 00500–008–0323-y</a>。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/5f3c1011fa9a8df46b0a5ab4bd03b6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:44/0*J--_kXKEJnr8Gtxi.gif"/></div></figure><ul class=""><li id="e85c" class="nb nc it lk b ll lm lo lp lr nd lv ne lz nf md ng nh ni nj bi translated">J.阿尔卡拉-Fdez、A. Fernandez、J. Luengo、J. Derrac、S. García、L. Sánchez、F. Herrera。KEEL数据挖掘软件工具:数据集存储库、集成算法和实验分析框架。多值逻辑和软计算杂志17:2–3(2011)255–287。</li></ul><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qh"><img src="../Images/61d6bfa9a36d1e72cf8c707c71f65b46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UcgmjntGx_ypwwNC.png"/></div></figure></div></div>    
</body>
</html>