<html>
<head>
<title>25 Numpy Treasures Buried in the Docs Waiting to Be Found</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">埋藏在文件中等待被发现的25件宝贝</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/25-numpy-treasures-buried-in-the-docs-waiting-to-be-found-60d8e17931cd#2022-08-11">https://towardsdatascience.com/25-numpy-treasures-buried-in-the-docs-waiting-to-be-found-60d8e17931cd#2022-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e33b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在NumPy致富</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e56cb2d1e54145b1ee97843757297224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_bY3AYzIRcOStK0B1Y-m-w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ashin_k_suresh?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">陈信宏·K·苏雷什</a>在<a class="ae ky" href="https://unsplash.com/s/photos/treasures?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="fbe3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">动机</h1><p id="a3d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">每个数据科学家都钦佩某个人。对一些人来说，可能是那些创造了杀手级数据可视化的人；对其他人来说，就是任何回答他们StackOverflow问题的人。对我来说，是那些像忍者一样使用NumPy的人。</p><p id="c5a9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我不知道。我一直认为，在罕见的极端情况下，能够使用深埋在文档中的被遗忘很久的函数，说明了一个程序员的技能。为一个特定的任务重新发明轮子是具有挑战性的，但这并不总是你想要的。</p><p id="7101" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个月，是时候扭转乾坤，成为一名忍者了。一路上我都在说“为什么我不把别人也做了呢？”。因此，我在这里列出了一些最酷但罕见的NumPy函数，当使用它们时，肯定会让任何阅读您的代码的人大吃一惊。</p><div class="ms mt gp gr mu mv"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">通过我的推荐链接加入Medium-BEXGBoost</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><p id="2b29" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="ms mt gp gr mu mv"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">alphasignal.ai</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ks mv"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="da45" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣.np.full_like</h1><p id="ede2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我打赌你用过像<code class="fe nx ny nz oa b">ones_like</code>或<code class="fe nx ny nz oa b">zeros_like</code>这样的标准NumPy函数。嗯，<code class="fe nx ny nz oa b">full_like</code>和这两个完全一样，除了你可以创建一个和另一个形状一样的矩阵，填充一些自定义值。</p><h2 id="3b17" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="bbed" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里，我们正在创建一个<code class="fe nx ny nz oa b">pi</code>的矩阵，形状为<code class="fe nx ny nz oa b">array</code>。</p><h2 id="d117" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.full_like.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="c75b" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">2️⃣.日志空间</h1><p id="f2a4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我相信你经常使用<code class="fe nx ny nz oa b">linspace</code>。它可以在一个间隔内创建自定义数量的线性间隔数据点。它的表亲<code class="fe nx ny nz oa b">logspace</code>更进一步。它可以在对数标度上生成均匀分布的自定义点数。您可以选择任何数字作为基数，只要它不是零:</p><h2 id="3abc" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="336b" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.logspace.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="c856" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">3️⃣.网络网格</h1><p id="0712" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是你只能在文档中看到的功能之一。我以为它暂时不会公开使用，因为我很难理解它。像往常一样，斯达克弗洛来拯救我们了。根据这个<a class="ae ky" href="https://stackoverflow.com/questions/36013063/what-is-the-purpose-of-meshgrid-in-python-numpy" rel="noopener ugc nofollow" target="_blank">线程</a>，您可以使用<code class="fe nx ny nz oa b">meshgrid</code>从给定的X和Y数组创建每个可能的坐标对。这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="c3e8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将有16个唯一的坐标对，结果数组中每个索引到索引元素对一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/33e57ad8d559e875357171567f75defd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*TZ-H32SM4a6bGXoe2W2_Kw.png"/></div></figure><p id="c99f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，<code class="fe nx ny nz oa b">meshgrid</code>通常用于更复杂的任务，如果使用循环的话，将会花费很长时间。绘制3D正弦函数的等值线图就是一个例子:</p><h2 id="f463" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/3dc5d2761fccc2d1e58f6a4dcdd37bc5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*WxXvQuko3vvK0ih3zmWbpw.png"/></div></figure><h2 id="7cbb" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e7f6" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">4️⃣.triu/tril</h1><p id="ea34" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">类似于<code class="fe nx ny nz oa b">ones_like</code>或<code class="fe nx ny nz oa b">zeros_like</code>，这两个函数返回高于或低于某个矩阵对角线的零。例如，我们可以使用<code class="fe nx ny nz oa b">triu</code>函数在主对角线上方创建一个具有真值的布尔掩码，并在绘制关联热图时使用该掩码。</p><h2 id="352a" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/ffe80e9c05b91eb0dc5428fa31c87f2e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*NOMVnTFGsoRKuDr0KZ8vdw.png"/></div></figure><p id="4b4a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如你所见，用<code class="fe nx ny nz oa b">triu</code>创建的蒙版可用于相关矩阵，以去掉不必要的上三角和对角线。这使得热图更加紧凑，可读性更好，没有杂乱无章。</p><h2 id="e8fa" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.triu.html" rel="noopener ugc nofollow" target="_blank">链接</a> — <code class="fe nx ny nz oa b">np.triu</code></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="48bb" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">5️⃣.拉威尔/拉平</h1><p id="83f1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">NumPy是关于高维矩阵和n数组的。有时候，你只是想把这些阵列粉碎成1D。这是您可以使用<code class="fe nx ny nz oa b">ravel</code>或<code class="fe nx ny nz oa b">flatten</code>的地方:</p><h2 id="ea62" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="04e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">他们看起来一样吗？不完全是。<code class="fe nx ny nz oa b">flatten</code>总是返回一个1D副本，而<code class="fe nx ny nz oa b">ravel</code>试图生成原始数组的1D视图。所以，要小心，因为修改从<code class="fe nx ny nz oa b">ravel</code>返回的数组可能会改变原始数组。要了解更多关于它们区别的信息，请查看<a class="ae ky" href="https://stackoverflow.com/questions/28930465/what-is-the-difference-between-flatten-and-ravel-functions-in-numpy" rel="noopener ugc nofollow" target="_blank">这个</a> StackOverflow线程。</p><h2 id="b6e0" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.ravel.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="a129" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">6️⃣.np.vstack / np.hstack</h1><p id="638f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Kaggle上，这两个函数是经常使用的。通常，人们对来自不同模型的测试集有多种预测，他们希望以某种方式集成这些预测。为了便于使用，必须将它们组合成一个矩阵。</p><h2 id="2e88" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f1ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">记住，在将每个阵列与这些阵列堆叠在一起之前，要对它们进行整形，因为默认情况下它们需要2D阵列。这就是我们使用<code class="fe nx ny nz oa b">reshape</code>函数的原因。这里，<code class="fe nx ny nz oa b">reshape(-1, 1)</code>表示将数组转换成一个尽可能多行的单列。</p><p id="26bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类似地，<code class="fe nx ny nz oa b">reshape(1, -1)</code>将数组转换为尽可能多列的单行向量。</p><h2 id="0298" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.hstack.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="d7f6" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">7️⃣.np.r_ / np.c_</h1><p id="756b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您像我一样懒惰，不想在所有的数组上调用<code class="fe nx ny nz oa b">reshape</code>，有一个更好的解决方案。<code class="fe nx ny nz oa b">np.r_</code>和<code class="fe nx ny nz oa b">np.c_</code>运算符(不是函数！)允许将数组分别堆叠为行和列。</p><p id="7380" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面，我们用100个概率模拟一个预测数组。为了将它们堆叠起来，我们用括号符号调用<code class="fe nx ny nz oa b">np.r_</code>(就像<code class="fe nx ny nz oa b">pandas.DataFrame.loc</code>)。</p><h2 id="8d88" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="038b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类似地，<code class="fe nx ny nz oa b">np.c_</code>将数组堆叠在一起，创建一个矩阵。然而，它们的功能并不局限于简单的水平和垂直堆栈。他们比那更强大。要了解更多信息，我建议您阅读文档。</p><h2 id="af16" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.r_.html" rel="noopener ugc nofollow" target="_blank">链接</a> — <code class="fe nx ny nz oa b">np.r_</code></h2><h2 id="40b4" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.c_.html" rel="noopener ugc nofollow" target="_blank">链接</a> — <code class="fe nx ny nz oa b">np.c_</code></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="6d19" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">8️⃣.np .信息</h1><p id="e9eb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">NumPy是如此的<em class="oq">广阔而深邃。你很可能没有时间和耐心去学习它的API的每一个函数和类。面对未知函数怎么办？好吧，不要跑去找文档，因为你有更好的选择。</em></p><p id="7640" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nx ny nz oa b">info</code>函数可以打印NumPy API中任意名称的docstring。这里是用在<code class="fe nx ny nz oa b">info</code>上的<code class="fe nx ny nz oa b">info</code>:</p><h2 id="beef" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="6086" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.info.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8431" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">9️⃣.np .哪里</h1><p id="23ca" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">顾名思义，这个函数返回一个数组的所有索引<code class="fe nx ny nz oa b">where</code>某些条件为真:</p><h2 id="c6b8" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="fd02" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当在稀疏数组中搜索非零元素时，它特别有用，甚至可以在Pandas数据帧上使用，以便根据条件进行更快的索引检索。</p><h2 id="9048" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.where.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e2c5" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣0️⃣.所有/任何</h1><p id="6d14" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当与<code class="fe nx ny nz oa b">assert</code>语句一起使用时，这两个函数在数据清理过程中会很方便。</p><p id="3857" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nx ny nz oa b">np.all</code>仅当数组中的所有元素都符合特定条件时才返回True:</p><h2 id="22d8" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3a46" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因为我们创建了两个填充了随机数的数组，所以不可能每个元素都相等。但是，如果这些数字是整数，则更有可能至少有两个数字彼此相等:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2964" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，如果数组中至少有一个元素满足特定条件，<code class="fe nx ny nz oa b">any</code>将返回True。</p><h2 id="0b12" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.all.html" rel="noopener ugc nofollow" target="_blank">链接</a> — <code class="fe nx ny nz oa b">np.all</code></h2><h2 id="e611" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.any.html" rel="noopener ugc nofollow" target="_blank">链接</a>——<code class="fe nx ny nz oa b">np.any</code></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="30ac" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣1️⃣.np.allclose</h1><p id="e331" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您想检查两个长度相等的数组是否是彼此的副本，一个简单的<code class="fe nx ny nz oa b">==</code>操作符是不够的。有时候，你可能想比较浮点数组，但是它们的长小数位数很难比较。在这种情况下，您可以使用<code class="fe nx ny nz oa b">allclose</code>,如果一个数组的所有元素在一定的容差范围内相互靠近，它将返回True。</p><h2 id="04b0" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="b988" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，只有当差值(<code class="fe nx ny nz oa b">&lt;</code>)小于<code class="fe nx ny nz oa b">rtol</code>，而不是<code class="fe nx ny nz oa b">&lt;=</code>时，该函数才返回True！</p><h2 id="d355" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="109c" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣2️⃣.np.argsort</h1><p id="3afc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然<code class="fe nx ny nz oa b">np.sort</code>返回一个数组的排序副本，但这并不总是您想要的。有时，您需要对数组进行排序的索引，以便针对不同的目的多次使用相同的索引。这就是<code class="fe nx ny nz oa b">argsort</code>派上用场的地方:</p><h2 id="0d36" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6d6f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它来自于以<code class="fe nx ny nz oa b">arg</code>开头的一系列函数，这些函数总是从某个函数的结果返回一个或多个索引。例如，<code class="fe nx ny nz oa b">argmax</code>查找数组中的最大值并返回其索引。</p><h2 id="7bb9" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.argsort.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="e388" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣3️⃣.np.isneginf / np.isposinf</h1><p id="be82" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这两个布尔函数检查数组中的元素是负无穷大还是正无穷大。不幸的是，计算机或NumPy不理解无穷大的概念(好吧，谁理解呢？).它们只能将无穷大表示为某个非常大或非常小的数字，它们可以放入一个比特位中(我希望我说得没错)。</p><p id="b224" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这就是为什么当你打印出<code class="fe nx ny nz oa b">np.inf</code>的类型时，它会返回<code class="fe nx ny nz oa b">float</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="298e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着无穷大的值可以很容易地溜进一个数组，破坏你在浮点数上使用的操作。你需要一个特殊的功能来找到这些鬼鬼祟祟的小…</p><h2 id="47c7" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="2b6f" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.isneginf.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8161" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣4️⃣.np.polyfit</h1><p id="a741" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你想执行一个传统的线性回归，你不一定需要Sklearn。NumPy为您提供:</p><h2 id="0d85" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="26a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nx ny nz oa b">polyfit</code>可以获取两个向量，对它们应用线性回归，并返回一个斜率和一个截距。你只需要用<code class="fe nx ny nz oa b">deg</code>指定次数，因为这个函数可以用来逼近任意次多项式的根。</p><p id="0be5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">用Sklearn再次检查发现用<code class="fe nx ny nz oa b">polyfit</code>找到的斜率和截距与Sklearn的<code class="fe nx ny nz oa b">LinearRegression</code>模型相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="22a4" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.polyfit.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="5072" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣5️⃣.概率分布</h1><p id="65b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">NumPy的<code class="fe nx ny nz oa b">random</code>模块有很多伪随机数发生器可供选择。除了我最喜欢的<code class="fe nx ny nz oa b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.sample.html" rel="noopener ugc nofollow" target="_blank">sample</a> </code>和<code class="fe nx ny nz oa b"><a class="ae ky" href="https://numpy.org/doc/stable/reference/random/generated/numpy.random.choice.html" rel="noopener ugc nofollow" target="_blank">choice</a></code>之外，还有模拟伪完美概率分布的函数。</p><p id="e7b6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，<code class="fe nx ny nz oa b">binomial</code>、<code class="fe nx ny nz oa b">gamma</code>、<code class="fe nx ny nz oa b">normal</code>和<code class="fe nx ny nz oa b">tweedie</code>函数从各自的分布中提取自定义数量的数据点。</p><p id="7e5f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您需要估算数据中要素的分布时，您可能会发现它们非常有用。例如，下面，我们检查钻石价格是否遵循正态分布。</p><h2 id="0abe" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/1c0108136fa1f5d6161019c6ca6f0bd1.png" data-original-src="https://miro.medium.com/v2/format:webp/1*PvM4JZc5Oy32FQ7lmxazwQ.png"/></div></figure><p id="faba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这可以通过在完美的正态分布上绘制钻石价格的KDE来实现，以使差异可见。</p><h2 id="9856" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/1.16/reference/routines.random.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="d467" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣6️⃣.np.rint</h1><p id="0dcb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您想将数组中的每个元素四舍五入到最接近的整数，那么<code class="fe nx ny nz oa b">rint</code>是一个很棒的小函数。当您想要在二进制分类中将类概率转换为类标签时，可以开始使用它。你不必调用你的模型的<code class="fe nx ny nz oa b">predict</code>方法，浪费你的时间:</p><h2 id="33c1" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="617b" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.rint.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="3163" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣7️⃣.nan mean/nan *</h1><p id="4151" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您知道吗，如果至少有一个元素是<code class="fe nx ny nz oa b">NaN</code>，纯NumPy数组上的算术运算就会失败。</p><h2 id="f0d8" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="505b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要在不修改原始数组的情况下解决这个问题，您可以使用一系列的<code class="fe nx ny nz oa b">nan</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="0303" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以上是忽略缺失值的算术平均值函数的示例。许多其他人也以同样的方式工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2942" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是如果你只处理Pandas数据帧或系列，你最好忘记这些，因为它们默认忽略nan。</p><pre class="kj kk kl km gt or oa os ot aw ou bi"><span id="a861" class="ob la it oa b gy ov ow l ox oy">&gt;&gt;&gt; pd.Series(a).mean()</span><span id="7f67" class="ob la it oa b gy oz ow l ox oy">22.0</span></pre><h2 id="5af6" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.nanmean.html" rel="noopener ugc nofollow" target="_blank">链接</a>——<code class="fe nx ny nz oa b">np.nanmean</code></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="8ae7" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣8️⃣.np .剪辑</h1><p id="c8fc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当您想要对数组的值施加严格的限制时,<code class="fe nx ny nz oa b">clip</code>非常有用。下面，我们将剪切任何超出10和70这两个硬限制的值:</p><h2 id="caa5" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="9ea9" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.clip.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="7794" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">1️⃣9️⃣.计数非零</h1><p id="bf86" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用稀疏数组是很常见的。通常，它们是对具有高基数的分类要素或仅仅许多二进制列进行一次性编码的结果。</p><p id="fff7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以使用<code class="fe nx ny nz oa b">count_nonzero</code>检查任何数组中非零元素的数量:</p><h2 id="8fae" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4079" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在100k个随机整数中，有~1000个是零。</p><h2 id="8354" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.count_nonzero.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="9efa" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">2️⃣0️⃣.np.array _斯普利特</h1><p id="f845" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">列表中的最后一个函数是<code class="fe nx ny nz oa b">array_split</code>。我想你可以从名字中猜出它的作用——它可以用来将N个数组或数据帧分成N个桶。此外，当您想要将数组分割成大小不等的块时(如<code class="fe nx ny nz oa b">vsplit</code>),它不会引发错误:</p><h2 id="23b0" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">💻演示</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="28a7" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">📚文档:<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.array_split.html" rel="noopener ugc nofollow" target="_blank">链接</a></h2></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h1 id="9ed8" class="kz la it bd lb lc ns le lf lg nt li lj jz nu ka ll kc nv kd ln kf nw kg lp lq bi translated">摘要</h1><p id="7779" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">好吧，我在介绍中撒了点谎。我并不真正钦佩那些很好地使用NumPy的人。其实我很佩服任何比我更会用某个库或者工具的人。所以，我写的每一篇文章都是我试图推动自己，看看使用更有经验的人如此精心利用的东西是什么感觉。</p><div class="ms mt gp gr mu mv"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">通过我的推荐链接加入Medium。</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。你可以给我买一个coffee☕，用你的…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="ne l"><div class="pa l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a href="https://ibexorigin.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">每当Bex T .发布时收到电子邮件。</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">每当Bex T .发布时收到电子邮件。注册后，如果您还没有中型帐户，您将创建一个…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="ne l"><div class="pb l ng nh ni ne nj ks mv"/></div></div></a></div></div><div class="ab cl nl nm hx nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="im in io ip iq"><h2 id="2fca" class="ob la it bd lb oc od dn lf oe of dp lj ma og oh ll me oi oj ln mi ok ol lp om bi translated">在你离开之前——我的读者喜欢这些。你为什么不去看看？</h2><div class="ms mt gp gr mu mv"><a href="https://ibexorigin.medium.com/28-subtle-weekly-machine-learning-tricks-and-gem-resources-5-177f95be31c4" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">28个微妙的每周机器学习技巧和宝石资源，第5位</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">8月8日至14日发行</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="ne l"><div class="pc l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/20-python-gems-buried-in-the-installation-waiting-to-be-found-96034cad4d15"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">20个Python Gem库埋藏在装置中等待被发现</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">前所未有地了解Python的标准库</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="pd l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/comprehensive-tutorial-on-using-confusion-matrix-in-classification-92be4d70ea18"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">关于在分类中使用混淆矩阵的综合教程</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">学习使用混淆矩阵，根据问题的重要性来控制模型输出</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="pe l ng nh ni ne nj ks mv"/></div></div></a></div><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/one-stop-tutorial-on-all-cross-validation-techniques-you-can-should-use-7e1645fb703c"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">你可以(应该)使用的所有交叉验证技术的一站式教程</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">作为一名数据科学家，你需要知道的所有简历程序，解释如下</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="pf l ng nh ni ne nj ks mv"/></div></div></a></div></div></div>    
</body>
</html>