<html>
<head>
<title>Exploring Best Test Size, Number of Folds, and Repeated Hold-Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索最佳测试尺寸、折叠次数和重复坚持时间</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/exploring-best-test-size-number-of-folds-and-repeated-hold-out-bbf773f370b6#2022-09-09">https://towardsdatascience.com/exploring-best-test-size-number-of-folds-and-repeated-hold-out-bbf773f370b6#2022-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">研究保证、支持和平均准确性的收益；发现偏见</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6dfa1571f9152f4590396fc5420eacab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YgjeE9ibvnWvamvg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Elena Mozhvilo 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">虽然人们说10%到30%是一个好的测试规模，但这是非常依赖于问题的。一个好的起点是我所说的<em class="me">保证精度</em>——精度减去两个标准偏差。使用一个代表性的，但不是微调的虚拟模型，可以模拟许多不同测试规模的随机种子。取你尝试的每个测试尺寸的平均值和标准偏差，然后选择一个最大化保证精度的尺寸。你甚至可以不看实际精度就做。当使用来自sklearn的默认PCA逻辑回归对来自<a class="ae ky" href="https://archive.ics.uci.edu/ml/datasets/heart+disease" rel="noopener ugc nofollow" target="_blank"> UCI心脏病数据集</a>的处理过的Cleveland数据进行此操作时，我发现最佳测试大小为49%。对于那些内心强大的人，也可以使用<em class="me">支持的精度</em>，即平均值减去一个标准差。这给出了38%。</p><p id="d671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出现的下一个问题是交叉验证(cv)使用多少折叠。为了简单起见，让我们讨论一下交叉验证，以优化最终的准确性。毕竟，超参数的影响可能是特定于模型的，而精度是一个更通用的度量。</p><p id="ef19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的保证准确性的想法也可以用于计算使用多少折叠——但它需要更多的步骤。首先，我们将不得不放弃k-fold交叉验证的想法，并与反复坚持合作。原因是从统计学上来说，构建J个相同采样的随机模型比k倍交叉验证更容易建模。仍然有两种情况，其中k-fold交叉验证很容易理解，我们基本上可以从精心选择的图中读取我们需要的所有信息——但要达到这一点，我们首先必须理解重复坚持。</p><p id="2bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用相同的数据构建多个模型并对其中一些数据进行测试时，相关性就会成为一个问题，因此模型的单个精度的标准偏差不再等于总精度的误差。事实上，修正可以超过4倍！看看下面代码中的实现，或者你可以查看我的博客文章中的细节。</p><p id="5131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> B </span> ut，当该说的都说了，该做的都做了，你又得到一个保证精度的图，它是模型数量J和测试规模的函数。对每个J的后者进行最大化，我们获得了UCI心脏病数据集的如下图(参见文章末尾的Github链接):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/4a5a3cf46d0db71cc42cf66cfd068457.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Ln-H8ueXc8FxeX-1QBYRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">与仅运行一个模型相比，重复维持的最佳测试规模是模型数量的函数，并具有预期的精度增益。虽然当测试规模改变时，平均精度不连续地改变，但是保证/支持的精度是连续的。图片作者。</p></figure><p id="04c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是保证和支持精度的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mg mh l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">means_2000、stds_2000和test_size _ 2000是使用test _ size _ 2000中指定的test _ size对train_test_split的2000个随机种子进行默认逻辑回归的平均值和标准偏差列表。</p></figure><p id="a4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Nadeau和Bengio  (NB)在2003年<a class="ae ky" href="https://link.springer.com/content/pdf/10.1023/A:1024068626366.pdf" rel="noopener ugc nofollow" target="_blank">使用简化假设(我们只需对J &lt; 5做一个小的改变)发现了重复坚持的J模型的方差与总精度的方差之间的这种关系。我们发现他们的假设被违反了，但仍然很有意义。</a></p><p id="ca26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> N </span> ow，回k倍互相关。我们不知道这里的保证精度，除了一个简单的情况:2倍cv。2-fold cv在其训练集或测试集之间没有相关性，因此模型精度的标准偏差与总精度的标准偏差相同。事实证明，2倍cv的保证精度比最优(测试规模选定)2倍重复保持高0.2%。在2倍cv之后，我们能做的最好的事情是绘制不同选择策略的平均准确度:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mi"><img src="../Images/42313dc0b2c3f83d6c363e6ec22fe5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vm_8CQG_0b2XDCMXRLcQjw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该图显示了四种不同选择类型的平均准确度。对于k倍cv，我们平均10*(测试集大小)个随机种子，而对于保留，我们使用上面的关系找到最佳测试大小。图片作者。</p></figure><p id="80cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比较绿色和蓝色曲线，我们可以看到，对于2倍，重复保持更好，因为它的测试规模更小(见上图)，在中间区域，分层k倍cv略好，因为它可以承受更大的训练集。对于超过50个模型/折叠，重复保持也是更好的，因为它能够保持更大的测试规模:事实上，我们确实预计一些测试集偏差会出现在300个折叠中——留一个cv (LOOCV)。原因是它是N=300次单次观察的简单平均值。因此，我们预计模型的真实精确度会有一个平均值误差，在这种情况下是2.1%，比观察到的误差大四倍。因此，我们可以说，k-fold交叉验证在大量折叠的测试集中易受偏倚的影响，而重复排除能够用任意数量的模型将测试规模保持在5%,因此受偏倚的影响较小。这种偏差预计会随着测试规模的增加而迅速减少，因为随着测试规模的增加，可能的模型数量以及测试数据点的数量都会增加。事实上，它一直持续到6个测试数据点——或50倍——是强相关性的一个指标。现在让我们转向反复的坚持，这一切将变得更加清楚:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/41829e32ee909b223b8fb89820c276a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltU_IcC6vnyKgPb0JT7seQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重复保持的平均准确度，最佳拟合线显示了低测试规模的偏差和方差。插图显示了预测的NB误差。对于小于5%的测试规模，我们尝试使用20，000个模型而不是2，000个模型(绿色)，只对图形进行了微小的更改。图片作者。</p></figure><p id="57b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated">该图显示了重复保持的平均准确度。好的一面是，我们可以清楚地看到偏差是最佳拟合线的残余。在LOOCV和LTOCV(留二法CV)中存在偏差，我们看到它持续到大约10%的测试规模。在偏倚之上，我们看到方差从1%的测试规模(三个测试点)开始出现，直到大约10%的测试规模(30个测试点)，在与偏倚相同的点消失。当你建立更多的模型时，这些振荡似乎不会以明显的速率衰减，如绿色所示。NB算法不包括这些特征，所以我们使用滚动窗口并排除测试大小&lt; 5%。我们还看到，LOOCV在10%的测试规模上没有产生任何改进，这与<a class="ae ky" href="https://stats.stackexchange.com/questions/61783/bias-and-variance-in-leave-one-out-vs-k-fold-cross-validation" rel="noopener ugc nofollow" target="_blank">之前的分析</a>很好地吻合，该分析发现10次折叠已经产生了最佳结果。然而，我们确实看到了一个小的改进，测试规模约为5%，这是我们在前面的图中利用的。</p><p id="8033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道，当所有点都在线时，NB误差为2%的原因是这是预期的训练集偏差，因此它不会在模型中显示为方差。它量化了我们在所有数据中异常幸运或不幸的机会。除此之外，我们还试图用许多随机种子来估计任何一个模型的较少训练数据的影响。当你对更少的模型取平均值时，线周围的方差确实增加了很多。</p><p id="f1fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> L </span>看第二个图，我们看到重复的保持(绿色)是k倍cv(蓝色)在3到35倍之间的良好指标(下限)。因此，从第一幅图可以看出，如果我们想要保持在最佳保证精度增益(3.34%)的1%以内，我们需要20倍。如果我们希望保持在0.5%以内，我们需要使用测试规模为5%和70个模型的重复坚持。对于支持的精度，我们希望使用6到16倍之间的k倍cv，因此如果我们希望保持在最佳可能精度增益的1%以内(2.39%)，我们需要使用9倍，如果我们希望保持在0.5%以内，我们需要使用测试大小为5%和31个模型的重复保持。</p><p id="9b54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推广到其他数据集，我们展示了如何使用重复保持作为代理来研究通过增加折叠次数可实现的准确性增益，以及在哪个点切换到重复保持以及为什么。LOOCV的测试集偏差可以通过寻找其平均值的误差来估计。这将是真实偏差的一个数量级估计(在这种情况下，相差75%)。</p><p id="368b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是我的Github 上的<a class="ae ky" href="https://github.com/alexlewisroberts/test_size_study" rel="noopener ugc nofollow" target="_blank">代码的链接。</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="eae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">【1】</strong>:Dua，d .和Graff，C. (2019) <em class="me">。</em>http://archive.ics.uci.edu/ml<a class="ae ky" href="http://archive.ics.uci.edu/ml" rel="noopener ugc nofollow" target="_blank">UCI机器学习知识库</a>。加州欧文:加州大学信息与计算机科学学院。</p></div></div>    
</body>
</html>