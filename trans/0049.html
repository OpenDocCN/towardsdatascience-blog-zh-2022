<html>
<head>
<title>Getting Started with Streamlit for NLP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NLP 的 Streamlit 入门</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/getting-started-with-streamlit-for-nlp-75fe463821ec#2022-02-02">https://towardsdatascience.com/getting-started-with-streamlit-for-nlp-75fe463821ec#2022-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3681" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松构建生产就绪的 NLP 应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/58e221432f5d6b91717d6ada6234e9fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3zqK1UFWVVs3GSw4-_XMjw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景由<a class="ae ky" href="https://unsplash.com/@fakurian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fakurian 设计</a>于<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上，由作者编辑。</p></figure><p id="d247" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Streamlit 已经证明了自己是一个非常受欢迎的工具，可以快速组装高质量的面向 ML 的 web 应用程序。最近，它在生产环境中被越来越大的组织广泛采用。</p><p id="525b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都意味着现在是利用 Streamlit 获取经验的最佳时机。幸运的是，Streamlit 的基础非常容易学习，对于大多数工具来说，这将比您需要的更多！</p><p id="a95f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将通过构建一个通用知识问答界面来介绍 Streamlit。我们将了解关键的 Streamlit 组件，如<code class="fe lv lw lx ly b">write</code>、<code class="fe lv lw lx ly b">text_input</code>、<code class="fe lv lw lx ly b">container</code>。如何使用 Bootstrap 之类的外部库快速创建新的 app 组件？并使用缓存来加速我们的应用程序。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a55b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">简化设置</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="f6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始时，我们需要打开一个终端窗口并编写<code class="fe lv lw lx ly b">pip install streamlit</code>。我们可以检查所有安装了<code class="fe lv lw lx ly b">streamlit hello</code>的东西，它应该显示这样一条信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d1f4495858c43dc48b482d70581bc96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMxUz3Wl7GhT2keADXs1bw.png"/></div></div></figure><p id="6d9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在(希望)打开一个新的浏览器窗口之前。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/adb7f7713f52a69d117259a0d2daa5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6GBpPcakeXbEBA_ACwaMg.png"/></div></div></figure><p id="d96c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经做到这一步，Streamlit 现在已经成功安装，我们可以继续使用 Streamlit 构建一些东西。</p><h1 id="73a7" class="mg mh it bd mi mj nc ml mm mn nd mp mq jz ne ka ms kc nf kd mu kf ng kg mw mx bi translated">智能搜索框</h1><p id="f242" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们将建立一个智能语义搜索工具，由句子转换器和松果的矢量数据库在幕后驱动。</p><p id="a7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在初始化这两个组件之前，我们将创建一个搜索组件的“模型”。首先，我们为我们的应用程序创建一个新目录，并添加一个包含我们应用程序核心的文件<code class="fe lv lw lx ly b">app.py</code>。</p><p id="bebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">app.py</code>中，我们可以添加标题、描述和搜索栏。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><p id="eb61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解这是怎么回事，我们打开一个终端窗口，导航到包含<code class="fe lv lw lx ly b">app.py</code>的目录，然后编写<code class="fe lv lw lx ly b">streamlit run app.py</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/dd004ebe9a25d210497285bcf390ecd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_w6kW7C4Cfg-7JwCwOIxbA.png"/></div></div></figure><p id="2e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在浏览器中输入上述地址之一，我们应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/96803195201ab6e02509c2db22c1e8fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yww0AWKn_Cwyo6Wa_Y4oWQ.png"/></div></div></figure><p id="4571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超级简单，我们在这里所做的就是以 markdown 格式写一个标题和段落文本，然后 Streamlit 将它转换成一个格式良好的网页。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="622b" class="nt mh it ly b gy nu nv l nw nx"># Q&amp;A App</span><span id="e6f0" class="nt mh it ly b gy ny nv l nw nx">Ask me a question!</span></pre><p id="092a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要一个输入框，这样我们的用户可以问一个问题。和以前一样，这是超级容易做到的。</p><p id="6083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用文本输入框 Streamlit 组件<code class="fe lv lw lx ly b">st.text_input</code>。我们将文本输入提示设置为<code class="fe lv lw lx ly b">"Search!"</code>，默认值为空字符串<code class="fe lv lw lx ly b">""</code>。</p><p id="363f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在输入框中输入的任何内容都将存储在<code class="fe lv lw lx ly b">query</code>变量中。因此，我们可以通过再次使用<code class="fe lv lw lx ly b">st.write</code>并写入<code class="fe lv lw lx ly b">query</code>的内容来检查这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/b85c190384e6a3ce16b8b0f49100d7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2vAasIAqkXagIl-8RQqX2g.png"/></div></div></figure><p id="2c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们输入新的内容并按下<em class="nz"> Enter </em>时，<code class="fe lv lw lx ly b">Query = '&lt;something&gt;'</code>就会用我们的新查询进行更新。这个更新过程表明了 Streamlit 的执行逻辑。当 Streamlit 发现应用程序中的某些内容发生变化时，会从头到尾重新运行完整的脚本。</p><p id="b313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们向我们的应用程序添加任何东西之前，我们将删除<code class="fe lv lw lx ly b">Query = '&lt;something&gt;'</code>行，并添加 Q &amp;检索器和松果矢量数据库组件。</p><h1 id="341e" class="mg mh it bd mi mj nc ml mm mn nd mp mq jz ne ka ms kc nf kd mu kf ng kg mw mx bi translated">聪明的部分</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经准备好了大部分的 Streamlit 接口。那么，让我们来看看应用程序的 NLP 组件。</p><p id="5c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是给定一个文本数据语料库(在这种情况下，我们使用维基百科文章)，我们希望能够提出一个问题，并返回一段相关的文本(一个<em class="nz">上下文</em>)。</p><p id="f3c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NLP 部分是利用一种自然语言问答的风格，叫做<a class="ae ky" href="https://www.pinecone.io/learn/question-answering/" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="nz">O</em></strong><em class="nz">pen</em><strong class="lb iu"><em class="nz">D</em></strong><em class="nz">domain</em><strong class="lb iu"><em class="nz">Q</em></strong><em class="nz">uestion-</em><strong class="lb iu"><em class="nz">A</em></strong><em class="nz">nswering</em>(ODQA)</a>。一个完整的实现需要三个组件；向量数据库、检索器和阅读器。</p><p id="1c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们当前的范围，我们将重点关注前两个组件:</p><ul class=""><li id="182b" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><strong class="lb iu"> MPNet 检索器模型</strong>，它将把我们现有的段落(上下文)<em class="nz">和</em>查询编码成向量。</li><li id="2990" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><strong class="lb iu">松果向量数据库</strong>，它存储我们的上下文向量，并允许在给定查询向量的情况下搜索这些向量。</li></ul><p id="2126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要创建上下文向量，并将它们推送到向量数据库中。我们不会深入细节，但是可以在这里找到代码<a class="ae ky" href="https://gist.github.com/jamescalam/c39fe139b84c0ab860543be4b44dd120" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="e9cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此代码中，我们:</p><ol class=""><li id="af2d" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu oo og oh oi bi translated">使用 HuggingFace <em class="nz">数据集</em>从 SQuAD v2 数据集下载我们的上下文。</li><li id="e55c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu oo og oh oi bi translated">使用<code class="fe lv lw lx ly b">pinecone/mpnet-retriever-squad2</code>检索器模型对它们进行编码以创建<em class="nz">上下文向量</em>。</li><li id="b5d7" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu oo og oh oi bi translated">通过<code class="fe lv lw lx ly b">upsert</code>将上下文向量推送到松果向量数据库(这需要<a class="ae ky" href="https://app.pinecone.io" rel="noopener ugc nofollow" target="_blank">一个免费的 API 密钥</a>)。</li></ol><p id="219c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们继续在应用程序中集成检索功能。代码与上面类似，但是这次我们不是下载上下文，也不是初始化一个新的向量数据库索引。</p><p id="9b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们需要做的就是初始化检索器，并初始化到<code class="fe lv lw lx ly b">qa-index</code>松果索引的连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><p id="4ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现了 ODQA 管道的前两个组件后，我们的<code class="fe lv lw lx ly b">app.py</code>脚本如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><p id="e2e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的浏览器，我们现在应该能够问一个问题并返回五个相关段落或<em class="nz">上下文</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/f0cd0b62e6fce1b65e93475c0b9054b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*doXtomam3pTombWspROQ5g.png"/></div></div></figure><p id="95db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们应用的核心。让我们继续改进它的性能以及如何显示结果。</p><h1 id="ae45" class="mg mh it bd mi mj nc ml mm mn nd mp mq jz ne ka ms kc nf kd mu kf ng kg mw mx bi translated">表演</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将句子转换器和松果组件添加到应用程序中时，整个应用程序变慢了。这样做的原因是，正如我们前面提到的，每当<em class="nz">发生任何变化</em>时，Streamlit 都会重新加载整个脚本。</p><p id="0c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Streamlit 通过在应用程序重新加载之间缓存应用程序的部分内容，提供了避免重新加载应用程序的方法。</p><p id="fce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要做到这一点，我们需要将我们想要缓存的进程放在函数内部。然后我们用<code class="fe lv lw lx ly b">@st.experimental_singleton</code>来修饰这些函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><p id="e9df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们第一次加载我们的应用程序时，可能需要一些时间来加载检索器模型并初始化我们与松果的连接。但是一旦我们开始搜索，Streamlit 就再也不会重新加载这些组件，使得搜索速度快得令人难以置信。</p><h1 id="a80e" class="mg mh it bd mi mj nc ml mm mn nd mp mq jz ne ka ms kc nf kd mu kf ng kg mw mx bi translated">让结果看起来不错</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让我们的结果看起来更好，我们将使用来自 Bootstrap 框架的预构建组件。这些非常容易使用，我们所做的就是找到我们想要使用的组件，例如<a class="ae ky" href="https://getbootstrap.com/docs/5.1/components/card/" rel="noopener ugc nofollow" target="_blank">这些卡</a>，然后将 HTML 代码复制到我们的应用程序中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/b71ae4a1bd7379ca5696d330d5abc730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCGph_0gpiEw3d9o1a0Kgw.png"/></div></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><p id="4126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用 Python 变量替换了代码的相关部分，添加了返回的上下文、标题和 ID。这些是在我们迭代松果调用返回的每个结果时生成的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/568a5184fc706b8433ddd65972bebc3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0oyqUF6nGGmeTsbN3_yAg.png"/></div></div></figure><p id="9444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的卡看起来不像我们看到的引导卡。这是因为我们没有设置任何引导 CSS 样式。如果我们回头看卡片 HTML，我们可以看到几个<code class="fe lv lw lx ly b">class="something"</code>参数。这些控件控制卡片的外观，但是它们依赖于一个外部 CSS 文件。</p><p id="e303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将这些引导 CSS 类添加到我们的应用程序中，我们需要做的就是在脚本的顶部添加一行 HTML 代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm mz l"/></div></figure><p id="4ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一行拉入一个<code class="fe lv lw lx ly b">bootstrap.min.css</code>文件，允许我们使用所有的引导 CSS 类。如果我们回到我们的浏览器窗口，我们会看到我们光滑的新卡片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/d2df5fb31aa119026512a8c847690193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XacCT7--Gz9KGQx3yfCHvQ.png"/></div></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="d419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此基础上，我们使用 Streamlit、句子转换器和 Pinecone 设计了一个开放领域 QA web 应用程序的核心组件。</p><p id="8725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，对于这种支持 ML 的 web 应用，我们还可以做更多的<em class="nz"/>——这是我们很快就会探索的事情。</p><p id="1240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，你可以通过<a class="ae ky" href="https://jamescalam.medium.com/subscribe" rel="noopener">这个链接</a>获得最新的文章。我还在 YouTube 上上传 ML 和 NLP 的每周视频。</p><p id="9670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="fee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🎁<a class="ae ky" href="https://www.pinecone.io/learn/nlp" rel="noopener ugc nofollow" target="_blank">面向语义搜索的 NLP 免费课程</a></p><p id="7cf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🤖<a class="ae ky" href="https://bit.ly/nlp-transformers" rel="noopener ugc nofollow" target="_blank">带变形金刚课程的 NLP 70%折扣</a></p><p id="24da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/jamescalam/dhivehi_nlp/blob/main/examples/00_create_dv_base/01_tokenizer_components.ipynb" rel="noopener ugc nofollow" target="_blank">文章笔记本脚本</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="12ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">*所有图片均由作者提供，除非另有说明</em></p></div></div>    
</body>
</html>