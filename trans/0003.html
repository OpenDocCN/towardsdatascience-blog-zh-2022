<html>
<head>
<title>Ace the System Design Interview — Distributed ID Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ace系统设计访谈—分布式ID生成器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ace-the-system-design-interview-distributed-id-generator-c65c6b568027#2022-02-01">https://towardsdatascience.com/ace-the-system-design-interview-distributed-id-generator-c65c6b568027#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="0c9a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">1.介绍</h1><p id="34f2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当你上传一张图片到Instagram或在你最喜欢的经纪应用上进行交易时，后端系统会给新创建的对象分配一个唯一的ID (UID)。这个ID通常在一些数据库表中用作主键，可以用来有效地检索对象。我想你知道我要去哪里——我们如何生成uid？</p><p id="f9a1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你肯定知道SQL中的自动递增主键。依赖这个特性的问题是显而易见的——它只能在单机数据库上工作，因为它涉及到锁定，因此不可伸缩。如果我需要Slack、AWS、Youtube等应用每秒数百万uid怎么办？在这篇文章中，我想和你分享我设计的大型UID生成器。</p><h2 id="4ff7" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">1.1要求</h2><p id="fe55" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当谈到UID生成时，区分这两种类型的UID是至关重要的。首先，是没有明显语义的随机UID。第二，是顺序UID，它包含排序等固有信息。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ma"><img src="../Images/e01f7b3d378146d57601b0b65a56dc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOczlaTT58JresLG0pvllQ.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图一。两种类型的UID，按作者分类</p></figure><p id="85dc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">随机UID过滤不出有意义的信息，因此把它交给人类更安全(客户和人类是不同的！客户端是代码，它会尝试猜测其他人的URL)。给定一个随机的UID，很难猜测其他对象的ID，因此提供了一些隐私。Youtube上的视频或TinyUrl上的链接就是这样编码的。例如，如果我创建了一个tinyUrl并得到<em class="mq">tinyurl.com/2p8u9m2d,</em>，我很难猜出其他新创建的Url(事实上，【tinyurl.com/2p8u9m3d】或【tinyurl.com/2p8u9m2c】<em class="mq">并不存在</em>)。</p><p id="31e0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">顺序UID有它自己的优点。它的固有含义是帮助应用程序组织数据。例如，在Instagram的Slack/images中，为聊天消息提供连续的uid是有意义的，因为我们希望保留项目排序。此外，如果uid不暴露给人类，那么即使不使用固有的顺序，使用顺序uid也完全没问题。</p><p id="aa54" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在本文中，我将关注顺序uid，因为大多数百万WPS级别的应用程序不会向人类发布uid。下面是系统的<strong class="kn ir">核心功能需求:</strong></p><ul class=""><li id="eb68" class="mr ms iq kn b ko lj ks lk kw mt la mu le mv li mw mx my mz bi translated">每秒能够生成一千万个顺序uid</li><li id="010a" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li mw mx my mz bi translated">uid必须保留一定程度的订购信息</li><li id="4f7f" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li mw mx my mz bi translated">能够根据消耗量调整发电率</li></ul><p id="581c" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">不用说，系统应该是可伸缩的和高度可用的。</p><h1 id="fab3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">2.高层设计</h1><p id="098e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通常在系统设计面试中，我会从访问模式和数据库模式开始。然而，我们的系统不需要任何数据库支持，稍后我会向您展示这一点。整个系统几乎是无状态的；如果一个生成器崩溃，可以重启另一个并重新开始。</p><h2 id="b743" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">2.1 API设计</h2><p id="ff82" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们的UID生成器只有一个目的——为任何需要的人提供新的UID。因此，它只需要以下面向客户端的RPC接口:</p><pre class="mb mc md me gt nf ng nh ni aw nj bi"><span id="6ccf" class="lo jo iq ng b gy nk nl l nm nn">get_uid_batch(batch_size: int) -&gt; List[int64]</span></pre><p id="17bb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了最小化通信开销，客户端每隔大约100毫秒获取一批uid，并将uid缓存在内存中。如果客户端崩溃，本地uid就会丢失，这完全没问题，因为我们有很多东西可以浪费。</p><h2 id="0455" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">2.2高层架构</h2><ol class=""><li id="6bcf" class="mr ms iq kn b ko kp ks kt kw no la np le nq li nr mx my mz bi translated">由于应用程序的任务是每秒生成数百万个uid，我们需要许多计算机并发工作来满足需求。</li><li id="3338" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">我们需要某种监视节点健康和工作负载的集群管理器。如果供不应求，经理会增加更多的工人。</li></ol><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ns"><img src="../Images/22a315297c5d7b5b52c60ae6d7e9d326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6j7DkfE2K7gZ86_xvGZvQ.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图二。建筑，作者的形象</p></figure><h2 id="9d39" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">2.3控制逻辑</h2><ol class=""><li id="2c7e" class="mr ms iq kn b ko kp ks kt kw no la np le nq li nr mx my mz bi translated">启动ZooKeeper服务和集群管理器。在实践中，监管者可以被软件的内置功能所取代，例如自动缩放容器的Kubernetes。</li><li id="2962" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">默认情况下，集群管理器创建N个工作线程。</li><li id="64d0" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">当创建工作者时，它向ZooKeeper注册并获得唯一的工作者ID(简单的整数，例如，从0到256)。</li><li id="d46c" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">每只工蚁都对应着动物园管理员的一个短命节点。当一个工人死了，它的znode会被删除，ZooKeeper会通知主管。</li><li id="a698" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">所有工作线程定期将它们的CPU负载发送给集群管理器。经理删除/添加工人以最好地满足消耗率。</li></ol><h1 id="0ac1" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">3.细节</h1><h2 id="29d9" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">3.1流体分解</h2><p id="6ce9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">到目前为止，我们的讨论主要集中在高级特性上，比如API和架构。在这一部分，我们需要最终确定UID格式。应该是多长时间？它捕捉到了什么信息？</p><p id="1bc1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">流体长度</strong></p><p id="9c64" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">UID长度由应用程序及其存储需求决定。我们假设外部服务每秒消耗高达1000万个uid。让我们来看看排出不同长度的uid需要多长时间:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nt"><img src="../Images/49c23c768cbd37949818ad2f74aeaf79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svzvHycAVPqWY-d0EMA8_g.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图3。UID耗尽日期，按作者列出的数字</p></figure><p id="a3e6" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">显然，我们至少需要56位，以便应用程序在其生命周期内不会用完新的uid。</p><p id="3490" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir"> UID时间戳</strong></p><p id="85de" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们希望UID是可排序的，所以它的一部分必须是某种时间戳。对于我们的应用程序，将时间戳保持在毫秒粒度就足够了。UNIX时间戳是一个很好的起点。但是，它有64位，对于我们的应用程序来说太长了。为了解决这个问题，我们可以建立一个自定义的纪元(而不是UNIX时间戳使用的纪元，1970/1/1 0:0:0 ),并计算经过的毫秒数。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nu"><img src="../Images/76a253867bce41aa0aff329771171087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPuC_KvrSsM_LUnnf5qsnw.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图4。作者如何使用纪元图</p></figure><p id="7db2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">那么，应该用多少位来存储时间戳呢？图5显示了不同时间戳大小的溢出时间:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nv"><img src="../Images/906735b70a0ee3d2e85b896755107be1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_UmeLnH6FDEVJ53ReK5Zg.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图5。不同时间戳大小的溢出时间，按作者分类</p></figure><p id="a0a3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">假设项目寿命是20年，我们用40位是安全的。</p><p id="9b2a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir"> UID附加信息</strong></p><p id="3191" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">很容易让人停下来完成我们的UID设计。然而，无论时间戳有多精确，都无法防止UID冲突。两台计算机可能会生成两个具有相同时间戳的uid。为了区分同时生成的uid，我们必须加入新的信息。以下是我的建议，基于实践中使用的流行设计(<a class="ae nw" href="https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake" rel="noopener ugc nofollow" target="_blank"> Twitter雪花</a>):</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nx"><img src="../Images/e62b53b349fdfe093ce58db5ff44d84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-DFbX24NedQhkw7h0KVgQw.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图6。UID分解，按作者分类</p></figure><ol class=""><li id="e27f" class="mr ms iq kn b ko lj ks lk kw mt la mu le mv li nr mx my mz bi translated">工人ID:我们可以使用分配给每台计算机的唯一工人ID进行区分。位数由集群中的最大工作线程数决定。</li><li id="a171" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">线程ID:为了最大化吞吐量，多线程被用来利用现代多核CPU机器提供的并行性。为什么不是进程ID？进程间通信的开销更大，我们希望将所有生成的ID放入一个共享的内存缓冲区，RPC线程可以访问这个缓冲区。</li><li id="5614" class="mr ms iq kn b ko na ks nb kw nc la nd le ne li nr mx my mz bi translated">本地计数器:即使在20岁的计算机上，单线程也可以在一毫秒内生成两个时间戳。因此，我们需要一个本地计数器来进一步区分两个uid。当计数器满时，线程会在当前毫秒内休眠。</li></ol><p id="3497" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我在我的笔记本电脑上做了一个简单的实验，一台2019款的六核MacBook pro。这是我实现的吞吐量(这里是<a class="ae nw" href="https://gist.github.com/29d9522b80f034887ed0485dd94d489e.git" rel="noopener ugc nofollow" target="_blank">代码</a>):</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi ny"><img src="../Images/a5cfb1131c1db8f21fd7b1ea5b351c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UzZ_LgXzsMZO-Fngep7eA.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图7。单机吞吐量，按作者列出的数字</p></figure><p id="fd71" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在不运行RPC服务器和其他沉重的东西的情况下，我的笔记本电脑可以达到大约每百万秒40K UIDs。理想沙箱中的吞吐量惊人地高，我假设在实践中性能只会下降。根据有根据的猜测，假设一台计算机可以生成5K UIDs。要实现1000万uid/s，我们需要大约两台计算机。当然，实际上，我们可能需要更多。</p><p id="c8d3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在，将所有东西放在一起，峰值性能(对于我的笔记本电脑)是用13个线程(4位)实现的，每个线程有12位本地计数器。不包括工人ID，我们的uid中至少需要56位。因此，使用64位uid是个好主意。</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi nz"><img src="../Images/4457f259babae4871c02d9f1af6746a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-C_nBTbEZaxcvxTr2cQ_nQ.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图8。UID细分，按作者分类</p></figure><h2 id="765b" class="lo jo iq bd jp lp lq dn jt lr ls dp jx kw lt lu kb la lv lw kf le lx ly kj lz bi translated">3.2为什么不排队</h2><p id="4aab" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有些人可能想知道使用专用队列将外部服务从ID生成系统中分离出来是否是个好主意。一种可能的架构如下所示:</p><figure class="mb mc md me gt mf gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi oa"><img src="../Images/5b0c065ee24d2775944202de98ba2035.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5TpMQr5GXCUG1flSTjr3g.png"/></div></div><p class="mm mn gj gh gi mo mp bd b be z dk translated">图9。带有队列接口的替代架构，由作者绘制</p></figure><p id="410b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">像Kafka这样的中间件服务提供了很好的特性，比如解耦、缓冲、重试和简单的接口。然而，在这个应用程序中不需要这些特性。我们不需要缓冲多余的uid，因为它们可以被丢弃。系统有我能想象到的最简单的RPC界面，这让卡夫卡的界面看起来像火箭科学。有了卡夫卡，消费者的数量受到分区数量的限制，不方便。</p><p id="77a4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在所有反对队列的理由中，这是让我相信RPC更好的最重要的理由。一些队列没有披露缓冲的消息数量，这使得我们的服务无法在需求上升/下降时增加/减少容量。使用RPC，集群管理器可以更容易地监控整体工作负载。如果没有人使用uid，一些工人将被解雇以节省资金。</p><h1 id="2112" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">4.摘要</h1><p id="579a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这篇文章中，我们设计了一个具有惊人吞吐量的分布式顺序UID生成器。我们深入研究了各种方法之间的技术权衡。在面试中，没有最佳答案。所有的解决方案都有优点和缺点；我们的工作是评估他们中的每一个，并根据面试官给定的限制做出最合理的权衡。</p><p id="f99f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">另外，祝所有庆祝农历新年的人虎年快乐！</p></div></div>    
</body>
</html>