<html>
<head>
<title>Python 3.14 Will be Faster than C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.14将比C++更快</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-3-14-will-be-faster-than-c-a97edd01d65d#2022-09-10">https://towardsdatascience.com/python-3-14-will-be-faster-than-c-a97edd01d65d#2022-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="65de" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">令人印象深刻的新Python 3.11基准测试</h2></div><p id="5fe5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python是数据科学(DS)和机器学习(ML)中使用最多的脚本语言之一。根据编程语言的流行程度，Python是谷歌上搜索次数最多的语言。除了是一个伟大的<em class="lf">胶水</em>语言连接各种DS/ML解决方案在一起，它有许多库，几乎可以做任何与数据有关的事情。</p><p id="a582" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大约一个月后，我们将迎来全新的Python年度版本:版本3.11。我对这个新版本感到非常兴奋，因为这个版本的主要特点是速度显著提高。</p><p id="05e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在LinkedIn上，我已经看到了一些人测试新版本的帖子，他们的结果令人震惊。但是感受Python 3.11到底有多快的最好方法是自己运行测试。</p><p id="cd60" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将分享我对Python 3.11的逐步分析。所有代码都可以在<a class="ae le" href="https://github.com/dennisbakhuis/python3.11_speedtest" rel="noopener ugc nofollow" target="_blank">我的github页面</a>上找到。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/dbcb873e44d42d1ea7486230119ea27f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjHaXLsnx8KkRJdlZgJ9oQ.jpeg"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@spencerdavis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">斯潘塞·戴维斯</a>在<a class="ae le" href="https://unsplash.com/s/photos/formula-1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6264" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对编程语言进行基准测试一点也不简单。当你读到<em class="lf"> x </em>比<em class="lf"> y </em>快时，你永远要对这个结果半信半疑。一种算法的实现可能在<em class="lf"> x </em>上更好，而另一种在<em class="lf"> y </em>上更好。对于我们的基准测试来说，这要简单一些，因为我们是在用Python来测试Python，但是我们可能已经从语言中选择了一些元素，这些元素只受到了很小的影响。考虑到这一点，我想介绍我用来进行基准测试的算法:使用蒙特卡罗方法估计圆周率。</p><p id="d2cc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个算法的想法很简单，但是当a在大学的数学课上第一次看到它时，我大吃一惊。我们有一个大小为2r的正方形，在这个正方形中我们拟合了一个半径为r的圆<em class="lf">T21。现在我们拿一个在平面上产生数字的随机数发生器:<em class="lf"> &lt; -r，r &gt;，&lt; -r，r &gt; </em>。圆上的点与正方形上的点之比(即所有点)是面积比的近似值，我们可以用它来近似圆周率。这在等式中更清楚一点:</em></p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lw"><img src="../Images/33741e7de8d2f6303099e5b098a5df77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DNc5qRdINH8YQ3quN8RxQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图1:蒙特卡罗方法估算圆周率的推导。两个面积之比是Pi/4，因此，Pi大约是N_circle / N_all的4倍。(图片由作者提供)。</p></figure><p id="e2fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Python中，我从测试脚本中分离出实际的估计，这样我可以重复测试并取平均值。这里没有显示，但是我已经使用<a class="ae le" href="https://docs.python.org/3/library/argparse.html" rel="noopener ugc nofollow" target="_blank"> <em class="lf"> Argparse </em> </a>对脚本进行了参数化，这是一个从命令行界面(CLI)解析参数的标准库。Python代码如下所示:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="0876" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个脚本已经准备好运行了，但是我们想用它来测试Python的各种版本，而不仅仅是当前安装(或激活)的版本。测试多个版本的Python最简单的方法是使用Docker。Python维护<a class="ae le" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank">许多docker图片</a>。当然是所有受支持的版本，但也包括一些已停产(EOL)的版本，如2.7或3.2。它也有候选版本的图像，例如版本3.11。要使用Docker，您需要安装它。在Linux和Mac上相对容易，在Windows上我不太确定，但可能也不难。我建议只安装docker命令行界面，桌面对我来说太臃肿了。要在容器化Python环境中运行本地脚本，请运行:</p><pre class="lh li lj lk gt lz ma mb mc aw md bi"><span id="c75c" class="me mf it ma b gy mg mh l mi mj">docker run -it --rm \<br/>  -v $PWD/your_script.py:/your_script.py \<br/>  python:3.11-rc-slim \<br/>  python /yourscript.py</span></pre><p id="4d99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了自动化各种版本的测试，我们当然也会使用Python。这个脚本将简单地启动一个<a class="ae le" href="https://docs.python.org/3/library/subprocess.html?highlight=subprocess#module-subprocess" rel="noopener ugc nofollow" target="_blank"> <em class="lf">子流程</em> </a>来启动一个具有特定Python版本的容器，然后收集结果。没什么特别的:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4ce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当运行这些测试时，机器与机器之间的绝对数量不同，这取决于处理器(它是CPU密集型的)。以下是最近7个主要Python版本的结果:</p><pre class="lh li lj lk gt lz ma mb mc aw md bi"><span id="3695" class="me mf it ma b gy mg mh l mi mj">The new Python 3.11 took 6.4605 seconds per run.</span><span id="1219" class="me mf it ma b gy mk mh l mi mj">Python 3.5 took 11.3014 seconds.(Python 3.11 is 74.9% faster)<br/>Python 3.6 took 11.4332 seconds.(Python 3.11 is 77.0% faster)<br/>Python 3.7 took 10.7465 seconds.(Python 3.11 is 66.3% faster)<br/>Python 3.8 took 10.6904 seconds.(Python 3.11 is 65.5% faster)<br/>Python 3.9 took 10.9537 seconds.(Python 3.11 is 69.5% faster)<br/>Python 3.10 took 8.8467 seconds.(Python 3.11 is 36.9% faster)</span></pre><p id="bcf7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python 3.11的基准测试平均耗时6.46秒。与之前的版本(3.10)相比，这几乎快了37%。相当令人印象深刻！3.9版和3.10版之间的差异大致相同，这使得3.11版的速度几乎快了70%。我在图2中画出了所有的时间。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ml"><img src="../Images/16b62d531c8edf0fa01125d93b8711e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQmcTQE09hyHYpgg6_hKlA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图2:所有测试的Python版本的平均循环时间。(图片由作者提供)。</p></figure><p id="71b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当谈到速度时，我们总是听到有人说:如果你想要速度，为什么不用c呢？</p><blockquote class="mm mn mo"><p id="fed8" class="ki kj lf kk b kl km ju kn ko kp jx kq mp ks kt ku mq kw kx ky mr la lb lc ld im bi translated">c比Python快多了！—那个人</p></blockquote><p id="eeef" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然我的C很生疏，但我想我还是要试一试。我使用GNU C++因为它有一个很好的时间测量库(chrono)。找到下面的代码:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="6d1e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">众所周知，C++是一种编译语言，因此，我们需要在使用它之前编译源代码。当您安装了典型的<code class="fe ms mt mu ma b">build-essentials</code>时，您可以键入:</p><pre class="lh li lj lk gt lz ma mb mc aw md bi"><span id="eaff" class="me mf it ma b gy mg mh l mi mj">g++ -o pi_estimate pi_estimate.c</span></pre><p id="3d42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编译完成后，只需运行构建可执行文件。输出应该是这样的:</p><pre class="lh li lj lk gt lz ma mb mc aw md bi"><span id="a03e" class="me mf it ma b gy mg mh l mi mj">Pi is approximately 3.14227 and took 0.25728 seconds to calculate.<br/>Pi is approximately 3.14164 and took 0.25558 seconds to calculate.<br/>Pi is approximately 3.1423 and took 0.25740 seconds to calculate.<br/>Pi is approximately 3.14108 and took 0.25737 seconds to calculate.<br/>Pi is approximately 3.14261 and took 0.25664 seconds to calculate.</span><span id="ba13" class="me mf it ma b gy mk mh l mi mj">Each loop took on average 0.25685 seconds to calculate.</span></pre><p id="c6fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不得不同意<em class="lf">那个家伙</em>真的(读:真的)快。只花了0.257秒就完成了我们之前用Python编程的同样的循环。让我们将它作为一条线添加到之前的图中，如图3所示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ml"><img src="../Images/75938a3537ad3075ee6b815278e86c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-daL0GhwOZQ600d0in6Hw.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图3: Python版本与用C++编译的相同基准的比较。(图片由作者提供)。</p></figure><p id="a7e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在欣赏了前面的图一段时间后，我们清楚地看到Python获得了动力。自3.9版本以来，Python的速度提高了约35%。Python开发者提到接下来的几个版本将会有显著的速度提升，因此，我们可以假设这个速度将会保持(<em class="lf">是的</em>，超级安全的假设)。</p><p id="090b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在的问题是，在这种势头不变的情况下，Python什么时候会超越C++的时代。为此，我们当然可以使用外推法来预测下一个Python版本的循环时间。这些可以在图4中看到。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi mv"><img src="../Images/7d92cb4f9db4d92974804690e51750f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieMH6ipGpq72fWnMiKweHA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图4:外推Python速度-&gt; Python 3.14将在速度上超越C++。太神奇了！(图片由作者提供)。</p></figure><p id="8e41" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">结果真是惊艳！保持这个速度，Python 3.14会比C++更快。确切地说，循环时间将是<em class="lf"> -0.232 </em>秒，所以它将在您想要进行计算之前完成。时空连续体中似乎有一个洞，但这些计算是坚如磐石的。因此，我认为我们可能不得不质疑爱因斯坦和他的朋友们的工作。</p><h2 id="e8bf" class="me mf it bd mw mx my dn mz na nb dp nc kr nd ne nf kv ng nh ni kz nj nk nl nm bi translated">放弃</h2><p id="e5a3" class="pw-post-body-paragraph ki kj it kk b kl nn ju kn ko no jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">虽然Python 3.5的这些基准测试..Python 3.11是有效的，这种推断当然是开玩笑的。XKCD 样式的数字是对这一点的额外提醒；-).</p><p id="42b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想在各种Python版本上运行这些测试或您自己的测试，请在<a class="ae le" href="https://github.com/dennisbakhuis/python3.11_speedtest" rel="noopener ugc nofollow" target="_blank"> my Github页面</a>上下载代码。</p><p id="7052" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您有任何意见，请告诉我！在LinkedIn 上随意连接。</p></div></div>    
</body>
</html>