<html>
<head>
<title>5 Practical SQL Examples to Master SQL GROUP BY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握SQL的5个实用SQL示例</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/5-practical-sql-examples-to-master-sql-group-by-7877ddf03ba8#2022-08-04">https://towardsdatascience.com/5-practical-sql-examples-to-master-sql-group-by-7877ddf03ba8#2022-08-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="76b7" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">数据科学</h2><div class=""/><div class=""><h2 id="c528" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">在不到10分钟的时间内，通过使用案例轻松完成复杂的SQL分组</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c70256f95b48543261705580377cf8b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LIhbN6NeOhOYxa39YU53NA.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@mariahhewines?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Mariah Hewines </a>在<a class="ae lh" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d543" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">SQL中的GROUP BY，解释</strong></p><p id="3e0b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">SQL——结构化查询语言——是从关系数据库中提取数据并进行转换的广泛使用的工具。</p><p id="bebd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有数据聚合，数据转换是不完整的，数据聚合是SQL中的一个重要概念。如果没有GROUP BY，数据聚合是不可能的！因此，掌握GROUP BY以轻松执行所有类型的数据转换和聚合非常重要。</p><p id="3a54" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在SQL中，GROUP BY用于数据聚合，使用聚合函数。如<code class="fe me mf mg mh b">SUM()</code>、<code class="fe me mf mg mh b">MIN()</code>、<code class="fe me mf mg mh b">MAX()</code>、<code class="fe me mf mg mh b">AVG()</code>、<code class="fe me mf mg mh b">COUNT()</code>。</p><blockquote class="mi mj mk"><p id="e423" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated"><strong class="lk jd">但是，为什么聚合函数与GROUP BY一起使用？</strong></p></blockquote><p id="f346" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在SQL中，GROUP BY子句用于将行组合在一起。因此，当您在列上使用聚合函数时，结果描述了特定行组的数据。</p><p id="00e3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这篇文章中，我解释了在SQL查询中使用GROUP BY 子句的5个例子，这将帮助你毫不费力地使用<code class="fe me mf mg mh b"><strong class="lk jd">GROUP BY</strong></code>。</p><p id="3dbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我把这篇文章写得很短，这样您就可以快速地完成它，并掌握SQL中的一个重要概念。</p><p id="6830" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用此索引快速导航到您最喜欢的部分。</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="bbb3" class="mt mu it mh b gy mv mw l mx my"><strong class="mh jd">· </strong><a class="ae lh" href="#4778" rel="noopener ugc nofollow"><strong class="mh jd">GROUP BY with Aggregate Functions</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#23c7" rel="noopener ugc nofollow"><strong class="mh jd">GROUP BY without Aggregate Functions</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#0ecc" rel="noopener ugc nofollow"><strong class="mh jd">GROUP BY with HAVING</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#eeb2" rel="noopener ugc nofollow"><strong class="mh jd">GROUP BY with ORDER BY</strong></a><strong class="mh jd"><br/>· </strong><a class="ae lh" href="#139a" rel="noopener ugc nofollow"><strong class="mh jd">GROUP BY with WHERE, HAVING and ORDER BY</strong></a></span></pre><blockquote class="mi mj mk"><p id="23b9" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated"><em class="it">📍</em>注意:我正在使用SQLite DB浏览器和一个自己创建的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank">销售数据</a>使用<a class="ae lh" rel="noopener" target="_blank" href="/faker-an-amazing-and-insanely-useful-python-library-b313a60bdabf"> <strong class="lk jd"> Faker </strong> </a>创建。可以在我的<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/TowardsDataScience/Dummy_Sales_Data_v1.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> Github </strong> </a> repo上<a class="ae lh" href="https://github.com/17rsuraj/data-curious/blob/master/LICENSE.md" rel="noopener ugc nofollow" target="_blank"> <strong class="lk jd"> MIT License </strong> </a>下免费获得！</p></blockquote><p id="e6c6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是一个简单的9999 x 11数据集，如下所示。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi mz"><img src="../Images/33fb5425a7debca9403160a38042bf40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k4v-KbpwlLtWfbcG2M4U0g.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">虚拟销售数据集|作者图片</p></figure><p id="6eec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，我们开始吧…</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="3738" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在继续之前，请记住下面的一条分组规则..</p><p id="cc8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当您在SQL查询中使用<code class="fe me mf mg mh b">GROUP BY</code>时，那么<code class="fe me mf mg mh b">SELECT</code>语句中的每一列必须要么出现在<code class="fe me mf mg mh b">GROUP BY</code>子句中，要么作为参数出现在聚合函数中。</p><p id="df66" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们从最简单的用例开始。</p><h1 id="4778" class="nh mu it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">使用聚合函数进行分组</h1><p id="60e7" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">这是最常用的场景，您可以在一个或多个列上应用聚合函数。如上所述，<code class="fe me mf mg mh b">GROUP BY</code>只是将在指定的列中具有相似值的行组合在一起。</p><p id="4d62" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">举个例子，假设你想得到每个产品类别的单价的统计摘要。这个例子具体解释了如何使用所有的集合函数。</p><p id="5cbe" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用以下查询获得这样的统计摘要—</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="7764" class="mt mu it mh b gy mv mw l mx my">SELECT Product_Category,<br/>       MIN(UnitPrice) AS Lowest_UnitPrice,<br/>       MAX(UnitPrice) AS Highest_UnitPrice,<br/>       SUM(UnitPrice) AS Total_UnitPrice,<br/>       AVG(UnitPrice) AS Average_UnitPrice<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">GROUP BY Product_Category</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi od"><img src="../Images/df1e342a065e9fe8fcc27556ac6d701c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8lz6ko2LEbpVLeOYFUpHw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SQL | Image中的数据聚合(按作者)</p></figure><p id="fb60" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如您在上面的查询中看到的，您使用了两列— <em class="ml"> Product_Category </em>和<em class="ml">unit price</em>——后者总是在聚合函数中使用。因此，<code class="fe me mf mg mh b">GROUP BY</code>子句只包含剩下的一列。</p><p id="fef5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以注意到，<em class="ml"> Product_Category </em>中的第一条记录是<code class="fe me mf mg mh b"><strong class="lk jd">NULL</strong></code>，这意味着<code class="fe me mf mg mh b">GROUP BY</code>将<em class="ml"> Product_Category </em>中的所有<code class="fe me mf mg mh b">NULL</code>值合并到一个组中。这符合微软 指定的SQL标准</p><blockquote class="oe"><p id="7c7e" class="of og it bd oh oi oj ok ol om on md dk translated">如果分组列包含空值，则所有空值都被视为相等，并将它们收集到一个组中</p></blockquote><p id="f7b2" class="pw-post-body-paragraph li lj it lk b ll oo kd ln lo op kg lq lr oq lt lu lv or lx ly lz os mb mc md im bi translated">此外，默认情况下，结果表按照<code class="fe me mf mg mh b">GROUP BY</code>中列的升序排序，其中<code class="fe me mf mg mh b">NULL</code>(如果存在)位于顶部。如果您不想让NULL成为结果表的一部分，您可以随时使用<code class="fe me mf mg mh b"><strong class="lk jd">COALESCE</strong></code>函数并给<code class="fe me mf mg mh b">NULL</code>一个有意义的名称，如下所示。</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="e9c1" class="mt mu it mh b gy mv mw l mx my">SELECT <strong class="mh jd">COALESCE(Product_Category,'Undefined_Category') AS Product_Category</strong>,<br/>       MIN(UnitPrice) AS Lowest_UnitPrice,<br/>       MAX(UnitPrice) AS Highest_UnitPrice,<br/>       SUM(UnitPrice) AS Total_UnitPrice,<br/>       AVG(UnitPrice) AS Average_UnitPrice<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">GROUP BY Product_Category</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ot"><img src="../Images/0fd04c2aa99a2360c03c22ce3ae06437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42GecWvl7KcoNmI3kRVdzA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SQL GROUP BY | Image by Author中的空值</p></figure><p id="cf5b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">🚩这里需要注意的重要一点是—</p><blockquote class="mi mj mk"><p id="a811" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">尽管<code class="fe me mf mg mh b">COALESCE</code>应用于Product_Category列，但您实际上并没有从该列中聚合值。所以，它一定是GROUP BY的一部分。</p></blockquote><p id="826d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这样，您可以在<code class="fe me mf mg mh b">SELECT</code>语句中添加您需要的任意多的列，在一些或所有列上应用聚合函数，并在<code class="fe me mf mg mh b">GROUP BY</code>子句中提及剩余的列名，以获得想要的结果。</p><p id="9670" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯，这是关于使用<code class="fe me mf mg mh b">GROUP BY</code>和聚合函数。但是，您也可以在没有聚合函数的情况下使用该子句，下面将进一步解释。</p><h1 id="23c7" class="nh mu it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">不带聚合函数的GROUP BY</h1><p id="15a6" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">尽管大多数情况下<code class="fe me mf mg mh b">GROUP BY</code>与聚合函数一起使用，但它仍然可以在没有聚合函数的情况下使用——用<strong class="lk jd">来查找唯一记录</strong>。</p><p id="a470" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，假设您想要检索<em class="ml"> Sales_Manager </em>和<em class="ml"> Product_Category </em>的所有唯一组合。使用GROUP BY，这非常简单。您所需要做的就是，在<code class="fe me mf mg mh b">SELECT</code>中提及您在<code class="fe me mf mg mh b">GROUP BY</code>中提及的所有列名，如下所示。</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="a570" class="mt mu it mh b gy mv mw l mx my"><strong class="mh jd">SELECT Product_Category,<br/>       Sales_Manager</strong><br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">GROUP BY Product_Category,<br/>         Sales_Manager</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/49a167a9f632c197a38c3b40f68a7aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*0AgM4l3WafN6Ud4McM6SVw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">不带聚合函数的SQL GROUP BY按作者排序的图像</p></figure><p id="dc7c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这一点上，有些人可能会说，在列名之前使用<code class="fe me mf mg mh b"><strong class="lk jd">DISTINCT</strong></code>关键字可以获得相同的结果。</p><p id="22af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，这里有两个主要原因，为什么你应该选择<code class="fe me mf mg mh b">GROUP BY</code>而不是<code class="fe me mf mg mh b">DISTINCT</code>来获得唯一的记录。</p><ol class=""><li id="8b91" class="ov ow it lk b ll lm lo lp lr ox lv oy lz oz md pa pb pc pd bi translated">默认情况下，GROUP BY子句获得的结果按升序排序。因此，您不需要单独对记录进行排序。</li><li id="b16d" class="ov ow it lk b ll pe lo pf lr pg lv ph lz pi md pa pb pc pd bi translated">当您处理具有数百万行的数据集并且您的SQL查询包含连接时，DISTINCT的开销可能会很大</li></ol><p id="6ea9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，使用GROUP BY可以有效地从数据库中获得唯一的记录，即使您在查询中使用多个连接。</p><p id="9dad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以在我以前的一篇文章中读到另一个有趣的<code class="fe me mf mg mh b">GROUP BY</code>子句用例——</p><div class="pj pk gp gr pl pm"><a rel="noopener follow" target="_blank" href="/3-ultimate-ways-to-find-unique-records-in-sql-6ddf8ae567b0"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd jd gy z fp pr fr fs ps fu fw jc bi translated">在SQL中查找唯一记录的3种终极方法</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">停止使用DISTINCT！开始使用这些快速的替代方法来避免混淆！</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">towardsdatascience.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa lb pm"/></div></div></a></div><p id="cd59" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，让我们进一步了解如何以有效的方式限制GROUP BY子句获得的输出。</p><h1 id="0ecc" class="nh mu it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">用HAVING分组</h1><p id="e7d1" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">在SQL中，<code class="fe me mf mg mh b">HAVING</code>的工作逻辑与<code class="fe me mf mg mh b">WHERE</code>子句相同，唯一的区别是它过滤一组记录，而不是每隔一条记录过滤一次。</p><p id="abb9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，假设您想要获得具有<em class="ml">产品类别、销售经理</em> &amp; <em class="ml">运输成本</em>的唯一记录，其中运输成本大于<em class="ml"> 34 </em>。</p><p id="a312" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这可以通过使用下面给出的<code class="fe me mf mg mh b">WHERE</code>和<code class="fe me mf mg mh b">HAVING</code>条款来实现。</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="43c4" class="mt mu it mh b gy mv mw l mx my"><strong class="mh jd"><em class="ml">-- WHERE clause</em></strong></span><span id="8cb4" class="mt mu it mh b gy qb mw l mx my">SELECT Product_Category,<br/>       Sales_Manager,<br/>       Shipping_Cost<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">WHERE</strong> <strong class="mh jd">Shipping_Cost &gt;= 34</strong><br/><strong class="mh jd">GROUP BY</strong> Product_Category,<br/>         Sales_Manager,<br/>         Shipping_Cost</span><span id="1cef" class="mt mu it mh b gy qb mw l mx my"><strong class="mh jd"><em class="ml">-- HAVING clause</em></strong></span><span id="add6" class="mt mu it mh b gy qb mw l mx my">SELECT Product_Category,<br/>       Sales_Manager,<br/>       Shipping_Cost<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">GROUP BY</strong> Product_Category,<br/>         Sales_Manager,<br/>         Shipping_Cost<br/><strong class="mh jd">HAVING Shipping_Cost &gt;= 34</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/28d8729e399278f438c95ebe27cf7b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*4O5zLq1H_YHitONF0zBbhg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按WHERE和HAVING in GROUP BY | Image by Author输出相同</p></figure><p id="d05d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">尽管上述两个查询生成相同的输出，但逻辑完全不同。<code class="fe me mf mg mh b">WHERE</code>子句在<code class="fe me mf mg mh b">GROUP BY</code>之前执行，所以本质上它扫描给定条件的整个数据集。</p><p id="a7bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，<code class="fe me mf mg mh b">HAVING</code>是在<code class="fe me mf mg mh b">GROUP BY</code>之后执行的，所以它扫描的记录数量相对较少，因为行已经被分组在一起。所以<code class="fe me mf mg mh b">HAVING</code>是一个节省时间的地方。</p><p id="e22e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好吧，假设你不太关心效率。但是，现在您想要总运费超过6000的所有<em class="ml">产品类别</em>和<em class="ml">销售经理</em>。而这正是<code class="fe me mf mg mh b">HAVING</code>派上用场的时候。</p><p id="1439" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里，要过滤这里的记录，您需要使用条件<code class="fe me mf mg mh b">SUM(Shipping_Cost) &gt; 6000</code>，并且您不能在<code class="fe me mf mg mh b">WHERE</code>子句中使用任何聚合函数。</p><p id="1262" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，你可以像下面这样使用<code class="fe me mf mg mh b">HAVING</code></p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="772b" class="mt mu it mh b gy mv mw l mx my">SELECT Product_Category,<br/>       Sales_Manager,<br/>       SUM(Shipping_Cost) AS Total_Cost<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">GROUP BY</strong> Product_Category,<br/>         Sales_Manager<br/><strong class="mh jd">HAVING SUM(Shipping_Cost) &gt; 6000</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/a44915b1ae1446a94dd250c4461471e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*Ti1wbys4CuX8Q52YAnGzMg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SQL GROUP BY have | Image BY Author</p></figure><p id="58f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于您在<em class="ml"> Shipping_Cost </em>上使用了聚合，所以在<code class="fe me mf mg mh b">GROUP BY</code>中不需要提及。从逻辑上讲，所有的行根据产品类别和销售经理分组，然后<code class="fe me mf mg mh b">HAVING</code>在所有这些组中扫描给定的条件。</p><p id="9e69" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，<code class="fe me mf mg mh b">HAVING</code>与<code class="fe me mf mg mh b">GROUP BY</code>结合使用是一种<strong class="lk jd">优化的</strong>方式，用于根据条件过滤行。</p><blockquote class="mi mj mk"><p id="c0a0" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">🚩注意:由于HAVING在SELECT之前执行，因此不能在HAVING子句的条件中使用列别名。</p></blockquote><p id="1c64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，尽管<code class="fe me mf mg mh b">GROUP BY</code>按照升序或字母顺序排列记录，但有时您可能希望按照聚合列来排列记录。这时<code class="fe me mf mg mh b">ORDER BY</code>跳了进来。</p><h1 id="eeb2" class="nh mu it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">分组依据和排序依据</h1><p id="b7c6" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">在SQL中，<code class="fe me mf mg mh b">ORDER BY</code>用于对结果进行排序，默认情况下，它以升序对结果进行排序。然而，要以降序获得结果，只需在<code class="fe me mf mg mh b">ORDER BY</code>子句中的列名之后添加关键字<code class="fe me mf mg mh b">DESC</code>。</p><p id="b950" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们继续上面的例子。你可以看到最后一个结果是按字母升序排列的，首先是列<em class="ml">产品类别</em>，然后是<em class="ml">销售经理</em>。但是，最后一列中的值<em class="ml"> Total_Cost </em>没有排序。</p><p id="2932" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如下所述，这可以通过使用<code class="fe me mf mg mh b">ORDER BY</code>子句来具体实现。</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="99c4" class="mt mu it mh b gy mv mw l mx my">SELECT Product_Category,<br/>       Sales_Manager,<br/>       <strong class="mh jd">SUM(Shipping_Cost) AS</strong> <strong class="mh jd">Total_Cost</strong><br/>FROM Dummy_Sales_Data_v1<br/>GROUP BY Product_Category,<br/>         Sales_Manager<br/><strong class="mh jd">ORDER BY Total_Cost DESC</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/73ee54461bda006d14da8222d8d1c5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*WNggMVOxDRbcQ5Bb8HapLA.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SQL中的降序排序|按作者排序图像</p></figure><p id="7c6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">显然，最后一列现在是按降序排列的。此外，您可以看到，现在前两列中的值没有特定的顺序。这是因为，你只把它们包含在<code class="fe me mf mg mh b">GROUP BY</code>中，而没有包含在<code class="fe me mf mg mh b">ORDER BY</code>子句中。</p><p id="8f01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个问题可以通过在<code class="fe me mf mg mh b">ORDER BY</code>条款中提及它们来解决，如下—</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="a6fb" class="mt mu it mh b gy mv mw l mx my">SELECT Product_Category,<br/>       Sales_Manager,<br/>       SUM(Shipping_Cost) AS Total_Cost<br/>FROM Dummy_Sales_Data_v1<br/>GROUP BY Product_Category,<br/>         Sales_Manager<br/><strong class="mh jd">ORDER BY Product_Category,<br/>         Sales_Manager,<br/>         Total_Cost DESC</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/07151975ed4e359805743589a4a0804a.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*Xu82ogTTogqRSJLu6Klxpg.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">按SQL中的多列排序|按作者排序图像</p></figure><p id="7c35" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，前两列按升序排列，只有最后一列— <em class="ml"> Total_Cost </em> —按降序排列。这是因为关键字<code class="fe me mf mg mh b">DESC</code>只在这个列名之后使用。</p><blockquote class="mi mj mk"><p id="1671" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">🚩这给了你一个重要的学习收获—</p></blockquote><p id="0577" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以按不同顺序排列多列SQL结果数据集，即按升序排列一些列，其余按降序排列。但是，请注意列名在<code class="fe me mf mg mh b">ORDER BY</code>中的顺序，因为它会改变结果集。</p><p id="c967" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这种情况下，理解GROUP BY是如何工作的很重要。你有没有问自己一个问题—</p><blockquote class="mi mj mk"><p id="278d" class="li lj ml lk b ll lm kd ln lo lp kg lq mm ls lt lu mn lw lx ly mo ma mb mc md im bi translated">为什么在降序order❓中看不到<code class="fe me mf mg mh b">Total_Cost</code>列中的所有值</p></blockquote><p id="9e8a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为在<code class="fe me mf mg mh b">GROUP BY</code>中只提到了前两列。仅根据这两列中的值对所有记录进行分组，并通过合计<em class="ml"> Shipping_Cost </em>列中的值来计算总成本。</p><p id="4ae4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，最终结果中的总成本值是基于这些组而不是整个表进行排列的。</p><p id="2526" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">接下来，让我们探索一个示例，它将进一步帮助您理解过滤记录之间的区别以及何时将<code class="fe me mf mg mh b">WHERE</code>和<code class="fe me mf mg mh b">HAVING</code>与<code class="fe me mf mg mh b">GROUP BY</code>结合使用。</p><h1 id="139a" class="nh mu it bd ni nj nk nl nm nn no np nq ki nr kj ns kl nt km nu ko nv kp nw nx bi translated">GROUP BY with WHERE，HAVING和ORDER BY</h1><p id="8c73" class="pw-post-body-paragraph li lj it lk b ll ny kd ln lo nz kg lq lr oa lt lu lv ob lx ly lz oc mb mc md im bi translated">到目前为止，您已经阅读了本文中的所有概念，让我们直接从一个示例开始。</p><p id="4b4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您想要获取所有未交付给客户的订单的销售经理和产品类别的列表。同时，您希望只显示那些在运输特定产品类别的产品上花费超过1600美元的销售经理。</p><p id="44da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，你可以通过以下三个步骤来解决这个问题</p><ol class=""><li id="c40a" class="ov ow it lk b ll lm lo lp lr ox lv oy lz oz md pa pb pc pd bi translated">使用条件<code class="fe me mf mg mh b">Status = ‘Not Delivered’</code>过滤所有记录。因为这是一个非聚合列，所以可以使用WHERE。</li><li id="b700" class="ov ow it lk b ll pe lo pf lr pg lv ph lz pi md pa pb pc pd bi translated">使用条件<code class="fe me mf mg mh b">SUM(Shipping_Cost) &gt; 1600</code>根据总运费过滤记录。因为这是一个聚合列，所以应该使用HAVING。</li><li id="21ef" class="ov ow it lk b ll pe lo pf lr pg lv ph lz pi md pa pb pc pd bi translated">为了计算总运费，您需要使用<code class="fe me mf mg mh b">GROUP BY</code>按照销售经理和产品类别对记录进行分组</li></ol><p id="b17f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您正在跟进，您的查询应该看起来像这样—</p><pre class="ks kt ku kv gt mp mh mq mr aw ms bi"><span id="bb94" class="mt mu it mh b gy mv mw l mx my">SELECT Sales_Manager,<br/>       Product_Category,<br/>       SUM(Shipping_Cost) AS Total_Cost<br/>FROM Dummy_Sales_Data_v1<br/><strong class="mh jd">WHERE Status = 'Not Delivered'</strong><br/>GROUP BY Sales_Manager,<br/>         Product_Category<br/><strong class="mh jd">HAVING SUM(Shipping_Cost) &gt; 1600</strong></span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/b44812a4716469c11b95acec334a9fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*EIFrvad0JO66LzMvRk4E3w.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">SQL GROUP BY with WHERE and HAVING | Image BY Author</p></figure><p id="418d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">它给出了满足示例中提到的条件的销售经理和产品类别的所有唯一组合。</p><p id="9870" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以注意到，前两列是按升序排列的。此外，用红色圈出的两行显示了同一销售经理的产品类别的升序。这是证据，默认情况下，<code class="fe me mf mg mh b">GROUP BY </code>按升序排列记录。</p><p id="adda" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这就是分组依据！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="c1b5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">希望你很快看完这篇文章，觉得耳目一新，很有用。</p><p id="8d5c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在过去的3年里，我一直在使用SQL，我发现这些替代方法非常省时，而且功能强大，尤其是在处理大型数据集时。在实际项目中，对这些概念的深刻理解是非常重要的。</p><blockquote class="oe"><p id="1ade" class="of og it bd oh oi oj ok ol om on md dk translated"><em class="qg">有兴趣阅读更多介质上的故事？？</em></p></blockquote><p id="f3ac" class="pw-post-body-paragraph li lj it lk b ll oo kd ln lo op kg lq lr oq lt lu lv or lx ly lz os mb mc md im bi translated">💡考虑<a class="ae lh" href="https://medium.com/@17.rsuraj/membership" rel="noopener"> <strong class="lk jd">成为媒体会员</strong> </a>到<strong class="lk jd">访问媒体上无限的</strong>故事和每日有趣的媒体文摘。我会得到你的费用的一小部分，没有额外的费用给你。</p><p id="8829" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">💡不要忘记<a class="ae lh" href="https://medium.com/subscribe/@17.rsuraj" rel="noopener"> <strong class="lk jd">注册我的电子邮件列表</strong> </a>来接收我的文章的第一份副本。</p><p id="0535" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">感谢您的阅读！</strong></p></div></div>    
</body>
</html>