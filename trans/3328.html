<html>
<head>
<title>Async for Data Scientists — Don’t Block the Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向数据科学家的异步—不要阻塞事件循环</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/async-for-data-scientists-dont-block-the-event-loop-ab245e28ee01#2022-07-25">https://towardsdatascience.com/async-for-data-scientists-dont-block-the-event-loop-ab245e28ee01#2022-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="19e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">CPU密集型任务或非异步I/O库可能会阻塞程序的事件循环。了解如何在Python中避免这种情况。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17a2dd8dea81fdc245fadca9d7856e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ywCBudJ7l4ChL9qNHb4U6w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="3f57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">异步编程已经成为API设计和大多数服务的标准范例。数据科学家的技能范围也发生了变化。今天不足以创建好的模型或可视化；在大多数情况下，通过API或其他服务部署它们也是必要的。如果您还没有在部署中处理过异步编程，那么您很快就会了。</p><p id="c190" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">明确一下，这个故事不是另一个异步教程。相反，一些关于数据科学家在将工具与异步框架接口时可能面临的常见障碍的见解。也就是说，用CPU密集型任务或非异步I/O库阻塞事件循环。</p><p id="6dd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事将探讨事件循环是如何被阻塞的，以及我们有哪些资源来防止它。</p><p id="de05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python中有许多处理异步编程的好库，但是<em class="lu"> Asyncio </em>必须是Python中包含的标准库；例如，看看三重奏。因此，在这个故事中，我们将关注Asyncio。</p><h2 id="81d1" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">故事结构</h2><ul class=""><li id="c94b" class="mo mp it la b lb mq le mr lh ms ll mt lp mu lt mv mw mx my bi translated">事件循环</li><li id="ba81" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">测试设置</li><li id="5a83" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">天真地调用阻塞函数</li><li id="f9a1" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">Asyncio默认执行者</li><li id="6169" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">并发.未来线程池</li><li id="8040" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">并发.未来进程池</li><li id="b4bf" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">受I/O限制的基准测试</li><li id="6074" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">受CPU限制的基准测试</li><li id="284b" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">这个故事的寓意</li></ul><h2 id="d589" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">事件循环</h2><p id="e475" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">无论您使用的是<em class="lu"> Asyncio </em>模块还是任何其他异步库，它们都使用底层的事件循环。事件循环是一个调度器，负责在程序的生命周期内执行所有的协同程序(异步函数)。</p><p id="6e63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种并发模型本质上是一个单独的<code class="fe nh ni nj nk b">while</code>(循环),它采用协程并巧妙地运行它们。一旦一个协同程序正在执行，<code class="fe nh ni nj nk b">await</code> ( <code class="fe nh ni nj nk b">yield</code>)关键字将控制权交还给事件循环，以运行其他协同程序。因此，当事件循环等待一个I/O响应，一个<em class="lu">未来</em>完成，或者只是一个异步睡眠时，它可以运行其他协程。事件循环跟踪应该返回给每个协程的内容，并在循环的未来迭代中将其返回给相应的协程。</p><p id="12b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们知道了事件循环是如何工作的，让我们想想当我们在事件循环中运行CPU密集型任务时会发生什么。这正是讨论与数据科学家相关的地方。如果我们在事件循环中运行一个受CPU限制的任务，这个循环将运行这个任务直到它完成，就像你曾经使用过的任何顺序的和普通的<code class="fe nh ni nj nk b">while</code>循环一样。这在异步编程中是一个大问题，因为所有其他任务都必须等到我们的CPU密集型任务完成之后。</p><p id="63bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于事件循环，有三条规则:</p><ul class=""><li id="1acc" class="mo mp it la b lb lc le lf lh nl ll nm lp nn lt mv mw mx my bi translated">您不能阻止事件循环</li><li id="9d71" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">您不能阻止事件循环</li><li id="f95d" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">您不能阻止事件循环</li></ul><p id="ad61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，阻塞事件循环听起来可能没那么糟糕。但是想想这个场景。您负责编写一个模块，该模块将在一个公开API的大型应用程序(服务)中提供数据分析。API是在异步框架中编写的。如果您将CPU绑定的函数包装在协程中，您可能会导致整个应用程序瘫痪。所有其他任务，如客户端处理，都将停止，直到CPU密集型任务完成。</p><p id="4bb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下部分将回顾运行事件循环阻塞任务的方法，并研究它们的性能。</p><h2 id="8012" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">测试设置</h2><p id="e312" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我们从两个函数开始事件循环阻塞测试:</p><ul class=""><li id="75bc" class="mo mp it la b lb lc le lf lh nl ll nm lp nn lt mv mw mx my bi translated">执行CPU相关任务的函数:使用NumPy的矩阵乘法</li><li id="8f80" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">休眠线程的函数，即一些非异步I/O(例如，非异步数据库库)；是的，<code class="fe nh ni nj nk b">time.sleep</code>将阻塞事件循环</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="28ff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们用一个每边有7，000个元素的正方形矩阵来计时(在事件循环之外)我们的CPU限制函数，这样我们就知道会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="nq nr ns"><p id="919f" class="ky kz lu la b lb lc ju ld le lf jx lg nt li lj lk nu lm ln lo nv lq lr ls lt im bi translated">每圈9.97秒±2.07秒(平均标准偏差。戴夫。7次运行，每次1个循环)</p></blockquote><p id="6b52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们创建一个模拟周期性I/O任务的函数。这个函数为<code class="fe nh ni nj nk b">durarion_secs</code>运行一个循环，并在任务开始前(<code class="fe nh ni nj nk b">asyncio.sleep</code>为<code class="fe nh ni nj nk b">sleep_secs</code>)和任务完成后将当前时间戳附加到一个列表(<code class="fe nh ni nj nk b">time_log</code>)中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7eca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数的时间日志将是我们评估其他进程是否阻塞事件循环的数据。此外，我们格式化时间日志，以便只保留任务执行前和执行后的时间差。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="686d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用1毫秒的睡眠，这是没有任何其他函数在事件循环中运行时<code class="fe nh ni nj nk b">time_log</code>的样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/bf7f1d2593b77e6098ca18862ed11be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dW9hF_-zvzIEQ2ft2FYz9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><h2 id="ee9c" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">天真地调用阻塞函数</h2><p id="8393" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">天真地说，创建异步库的第一种方法是将我们的阻塞函数包装在一个协程中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1abb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试这种方法，我们将我们的函数、CPU绑定函数和线程阻塞函数(<code class="fe nh ni nj nk b">time.sleep</code>)封装在一个循环中，该循环定期执行函数并追加到一个<code class="fe nh ni nj nk b">time_log</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="262a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们同时运行所有任务，即<code class="fe nh ni nj nk b">dummy_io_stuff</code>，CPU密集型和线程休眠功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="64ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:在这段代码中，我在协程外部运行<code class="fe nh ni nj nk b">await coroutine</code>，因为我使用的是Jupyter笔记本，但是规则是<code class="fe nh ni nj nk b">await</code>只能在协程内部使用(<code class="fe nh ni nj nk b">async def</code>)。</p><p id="3bf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是格式化时间日志的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/91098ffdfc7652f67217c7f21ba84059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rR9BexCkB4dP81dxUdFqhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><p id="5a31" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从I/O时间日志(第一个子图)中可以看出，事件循环被阻塞了。我们期望平均一毫秒，并且在大多数迭代中花费的时间超过5秒。</p><p id="f2d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外两个图显示，在测试过程中，其他任务并没有一直执行，而是竞争资源并相互阻塞。</p><h2 id="ff42" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">Asyncio默认执行者</h2><p id="3b95" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">避免事件循环阻塞的解决方案是在别处执行阻塞代码。我们可以使用线程或其他进程来实现这一点。<em class="lu"> Asyncio </em>有一个非常方便的循环方法，<code class="fe nh ni nj nk b">run_in_executor</code>。这个方法使用了<code class="fe nh ni nj nk b">concurrent.futures</code>线程和多重处理接口。运行阻塞函数的默认方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7e5b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nh ni nj nk b">run_in_executor</code>的第一个参数设置为<code class="fe nh ni nj nk b">None</code>(默认执行程序)，第二个参数是我们要在执行程序中运行的函数，后面的参数是函数的参数。这个默认的执行者是来自<code class="fe nh ni nj nk b">concurrent.futures</code>的<code class="fe nh ni nj nk b">ThreadPoolExecutor</code>。</p><p id="f641" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">包装我们的函数，类似于上一节，并同时运行任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cfa1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">格式化时间日志的结果是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/6fca96e58c865323758b586c6134cf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3ZCjS94LrcboFsiQ3mXcQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><p id="b06a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，在事件循环中仍然有一些小故障(第一个图)，但是I/O时间日志显示了接近1毫秒的时间差。根据阻塞任务本身，它们确实是并发执行的。</p><h2 id="f853" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">并发.未来线程池</h2><p id="02df" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我们可以通过显式定义并将其传递给<code class="fe nh ni nj nk b">run_in_executor</code>方法来自定义上一节中的<code class="fe nh ni nj nk b">ThreadPoolExecutor</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="112e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用只有一个工人的<code class="fe nh ni nj nk b">ThreadPoolExecutor</code>,我们包装我们的阻塞函数来周期性地执行它们并保持时间日志，类似于前面的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e610" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时运行我们的任务并绘制格式化的时间日志:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/993044414e7fd50950cef60a491f05cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6QK1-wst7WiVaQck_5RgfA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><p id="26b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到的结果类似于上一节中获得的结果；当然，这是意料之中的；都用<code class="fe nh ni nj nk b">ThreadPoolExecutor</code>。</p><p id="c898" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据需要调整线程池中的线程数量。测试最佳数量是多少。对于某些用例来说，线程数量越多并不总是越好，因为它会带来一些开销。</p><p id="d841" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">线程池执行器在处理非异步编写的I/O库时大放异彩。Python中的许多数据库库还不支持异步。在异步程序中使用它们会阻塞事件循环；相反，使用线程池执行器来包装它们。</p><h2 id="a2e6" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">并发.未来进程池</h2><p id="ae97" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">最后，我们可以使用一个单独的进程来运行我们的阻塞代码。我们通过将一个来自<code class="fe nh ni nj nk b">concurrent futures</code>的<code class="fe nh ni nj nk b">ProcessPoolExecutor</code>实例传递给<code class="fe nh ni nj nk b">run_in_executor</code>方法来实现这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7ca8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们再次为测试创建周期性包装器，现在使用单独的过程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="28ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行测试并绘制结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/c895fdcbc9410905e4f6a53732ce6244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3vr8TXerz4Fwok45B8Blpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><p id="cab8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们看到I/O中的故障</p><p id="38aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间日志不像前面的案例那样重要。阻塞进程也同时执行。</p><p id="c558" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在某些情况下，多处理可能是一个很好的解决方案，特别是对于CPU受限的任务(不是线程休眠任务)来说，这需要更长的时间。创建多个新流程和移动数据成本高昂。也就是说，确定你愿意为多重处理付出代价。</p><h2 id="e87e" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">受I/O限制的基准测试</h2><p id="0252" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">下图显示了I/O虚拟协程(任务完成之前和之后)的时间日志时间差(越少越好),使用了前面章节中概述的四种方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/f09d0037d1e5c8379ac3898f890aca7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WeTBzrWHOqVDru6usYvVIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><p id="13db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在所有情况下，我们希望这些差异接近1毫秒，因为这是理论值。有些不一致是可以接受的，但超过4秒的差异是不可接受的，就像我们阻塞事件循环一样。线程池的结果(默认的执行器和只有一个工作线程的线程池)没有明显的不同。然而，ProcessPool的结果清楚地表明，这个执行器对事件循环的破坏最小。</p><h2 id="c714" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">受CPU限制的基准测试</h2><p id="6fe7" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">下图显示了对于前面讨论的所有方法，完成CPU限制的任务所花费的时间(越少越好):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/798354f2d2e6c2a40c51894b9c2ca369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ufKPViK27a-AOyJhVQOnrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轴尺寸以秒为单位[图片由作者提供]。</p></figure><p id="e853" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，天真地调用我们的阻塞函数会产生最好的结果。有道理；执行CPU密集型任务的代价是阻塞所有其他任务。关于其他三个执行人，他们的结果不相上下；进程池花费的时间稍长。将数据从主进程移动到分支进程需要一些时间。</p><p id="b36c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在任何情况下，我们都可以说使用一个执行器不会导致严重的性能损失，并且事件循环不会被严重阻塞。进行性能测试以选择正确的执行器(和配置)。但是，从默认的执行程序开始并将其作为基准并不是一个坏主意。</p><h2 id="7162" class="lv lw it bd lx ly lz dn ma mb mc dp md lh me mf mg ll mh mi mj lp mk ml mm mn bi translated">这个故事的寓意</h2><p id="22ef" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">到目前为止，我们已经知道，阻塞事件循环是我们在进行异步编程时必须避免的关键事情。如果你设法保持事件循环没有障碍，一切都会好的；你的MLOps和DevOps队友会感谢你的。</p><p id="952c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个故事的三个关键要点是:</p><ul class=""><li id="6c91" class="mo mp it la b lb lc le lf lh nl ll nm lp nn lt mv mw mx my bi translated">不要盲目地从协程(异步定义)中调用常规函数，因为它们可能会阻塞事件循环</li><li id="b979" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">将线程池执行器用于非异步I/O(非异步数据库库)或少量CPU限制的计算</li><li id="787e" class="mo mp it la b lb mz le na lh nb ll nc lp nd lt mv mw mx my bi translated">使用ProcesPool执行程序执行密集的CPU密集型任务；请记住，创建流程和移动数据是非常昂贵的，因此必须物有所值</li></ul></div></div>    
</body>
</html>