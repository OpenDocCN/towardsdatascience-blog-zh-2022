<html>
<head>
<title>Modeling Marketing Mix with Constrained Coefficients</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用约束系数模拟营销组合</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/modeling-marketing-mix-with-constrained-coefficients-234b23190ee2#2022-06-22">https://towardsdatascience.com/modeling-marketing-mix-with-constrained-coefficients-234b23190ee2#2022-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="abcd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何拟合一个SciPy线性回归并使用RPy2接口从Python调用R岭回归</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/afbc345359746b2dbe1558efee6a70ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qU-EM3WlFZQYuIyt"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">威尔·弗朗西斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e41c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di"> T </span>营销组合建模(MMM)中最常用的方法是使用多元线性回归，该方法在因变量(如销售额或收入)和自变量(包括媒体广告渠道，如电视、印刷品)以及其他变量(如趋势、季节性、假期)之间建立线性关系。营销人员可能会问的一个问题是每个媒体渠道对结果有什么影响。线性回归估计每个独立变量的系数和截距，提供以下指示:</p><ul class=""><li id="7bcd" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">截距表示媒体广告支出为零时的平均结果</li><li id="0ac6" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">系数显示自变量单位变化时结果的变化幅度，以及</li><li id="ca0e" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">变化方向:系数可以是正的、负的或零</li></ul><p id="0dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，营销组合中的假设是媒体广告渠道应该具有非负面效应。也就是说，随着广告支出的每一个单位的增加，销售或收入应该增加，减缓，或者至少保持为零(饱和效应)。这意味着媒体通道的结果系数应该是正的。</p><p id="357c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么如何约束系数呢？</p><p id="3642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的上一篇文章中，我使用了基于树的算法，而不是线性回归，所以根本不存在系数的问题</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/improving-marketing-mix-modeling-using-machine-learning-approaches-25ea4cd6994b"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">使用机器学习方法改进营销组合建模</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">使用基于树的集合构建MMM模型，并使用SHAP解释媒体通道性能</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><p id="6052" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我在下一篇文章中所做的，我们可以在贝叶斯环境中定义媒体通道系数的正先验</p><div class="mp mq gp gr mr ms"><a rel="noopener follow" target="_blank" href="/modeling-marketing-mix-using-pymc3-ba18dd9e6e68"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">使用PyMC3建模营销组合</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">实验先验，数据规范化，并比较贝叶斯建模与罗宾，脸书的开源MMM…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">towardsdatascience.com</p></div></div><div class="nb l"><div class="nh l nd ne nf nb ng kp ms"/></div></div></a></div><p id="a269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我展示了约束系数的两种方法:</p><ul class=""><li id="a422" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">通过使用Python SciPy包中的非线性最小二乘法<a class="ae kv" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html" rel="noopener ugc nofollow" target="_blank"> <em class="ni"> curve_fit </em> </a>函数拟合线性回归，作为一般解决方案</li><li id="58c8" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">通过使用Ridge，使用用Python包装的R <a class="ae kv" href="https://github.com/cran/glmnet" rel="noopener ugc nofollow" target="_blank"> glmnet </a>包和<a class="ae kv" href="https://github.com/rpy2/rpy2" rel="noopener ugc nofollow" target="_blank"> RPy2 </a>进行正则化回归</li></ul></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="5bd5" class="nq nr iq bd ns nt nu nv nw nx ny nz oa jw ob jx oc jz od ka oe kc of kd og oh bi translated">数据</h1><p id="1318" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">我继续使用由<a class="ae kv" href="https://github.com/facebookexperimental/Robyn" rel="noopener ugc nofollow" target="_blank"> Robyn </a>在麻省理工学院许可下提供的数据集，正如在我以前的文章中一样，用于实际和重要的例子，并通过应用Prophet来分解趋势、季节性和假日，遵循相同的数据准备步骤。</p><p id="1e58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该数据集包含208周的收入(从2015年11月23日到2019年11月11日),包括:</p><ul class=""><li id="7538" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">5个媒体消费渠道:<strong class="ky ir">电视、网络、印刷品、facebook、搜索</strong></li><li id="534a" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">2个也有曝光信息(印象，点击)的媒体渠道:facebook_I，search_clicks_P(本文未使用)</li><li id="0c67" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">有机媒体无花费:<strong class="ky ir">简讯</strong></li><li id="23e5" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">控制变量:<strong class="ky ir">事件，节假日</strong>，竞争对手销售(<strong class="ky ir">竞争对手_销售_B) </strong></li></ul></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="8f70" class="nq nr iq bd ns nt nu nv nw nx ny nz oa jw ob jx oc jz od ka oe kc of kd og oh bi translated">无约束系数线性回归</h1><p id="e6f9" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">让我们首先定义我们的自变量和因变量:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="c659" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">target </strong>= "revenue"<br/><strong class="oo ir">media_channels </strong>= ["tv_S", "ooh_S", "print_S", "facebook_S", "search_S"]<br/><strong class="oo ir">organic_channels </strong>= ["newsletter"]<br/><strong class="oo ir">control_features </strong>= ["trend", "season", "holiday", "competitor_sales_B", "events"]<br/><strong class="oo ir">features </strong>= control_features + media_channels + organic_channels</span></pre><p id="531f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们总共有11个独立变量，其中5个是媒体支出渠道，1个是有机渠道，5个是控制变量。让我们使用<a class="ae kv" href="https://www.statsmodels.org/dev/generated/statsmodels.regression.linear_model.OLS.html" rel="noopener ugc nofollow" target="_blank"> statsmodels </a>软件包应用一个经典的多元线性回归，然后检查使用<em class="ni"> curve_fit </em>的曲线拟合是否对无约束线性回归给出相同的结果</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="9d42" class="os nr iq oo b gy ot ou l ov ow">from statsmodels.regression import linear_model <br/>from statsmodels import tools</span><span id="c1a4" class="os nr iq oo b gy ox ou l ov ow">data_with_intercept = tools.add_constant(final_data[features])<br/>ols = <strong class="oo ir">linear_model.OLS</strong>(endog = data[target], <br/>                       exog = data_with_intercept)<br/>ols_res = ols.fit()<br/>print(ols_res.summary())<br/>print(ols_res.params)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/2b1189829330fbfe9e465586ac1db644.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*dDLkPs1b6pYdJ8rIHaga8A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">OLS系数</p></figure><p id="8f6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni"> curve_fit </em>函数的文档表明它需要一个模型函数:</p><blockquote class="oz pa pb"><p id="d220" class="kw kx ni ky b kz la jr lb lc ld ju le pc lg lh li pd lk ll lm pe lo lp lq lr ij bi translated">它必须将自变量作为第一个参数，并将参数作为单独的剩余参数</p></blockquote><p id="449e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模型函数将我们的线性关系描述为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pf"><img src="../Images/aceb88027290efb279d1c25c26ac1d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3fN8aOsEiiLQ9ekAD0Brg.png"/></div></div></figure><p id="fba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模型函数应该采用我们定义的尽可能多的参数，并且没有办法使这个函数适应不同数量的参数。因为我们有11个系数加上1个截距，所以我们必须提供12个参数:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="ce52" class="os nr iq oo b gy ot ou l ov ow">def linear_function(data, a, b1, b2, b3, b4, <br/>                          b5, b6, b7, b8, b9, b10, b11):<br/>    return a + b1 * data[:, 0]\<br/>             + b2 * data[:, 1]\<br/>             + b3 * data[:, 2]\<br/>             + b4 * data[:, 3]\<br/>             + b5 * data[:, 4]\<br/>             + b6 * data[:, 5]\<br/>             + b7 * data[:, 6]\<br/>             + b8 * data[:, 7]\<br/>             + b9 * data[:, 8]\<br/>             + b10 * data[:, 9]\<br/>             + b11 * data[:, 10]</span></pre><p id="e758" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<em class="ni"> curve_fit </em>,提供模型函数，自变量为NumPy矩阵，目标变量为NumPy数组，明确设置方法为“lm ”,使用线性最小二乘优化</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="2af2" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">curve_fit_coefs</strong>, _ = <strong class="oo ir">curve_fit</strong>(<strong class="oo ir">f</strong> = linear_function, <br/>                                   <strong class="oo ir">method </strong>= "lm", <br/>                                  <strong class="oo ir">xdata</strong>=final_data[features].values, <br/>                                  <strong class="oo ir">ydata </strong>= final_data[target].values)</span><span id="1b8b" class="os nr iq oo b gy ox ou l ov ow">#print coefficients<br/>pd.DataFrame(curve_fit_coefs, index=["const"] + features, columns=["coefficient"])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/225d74bb87862d43461995cd72d41585.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*d4NxCEB2DWgVtdEv6npeIQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">曲线拟合系数</p></figure><p id="f46f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们看到，在两种情况下，我们得到了相同的系数。intercept (const)和<em class="ni"> search_S </em>媒体通道为负。让我们将截距和所有媒体通道约束为非负。Robyn的Github上有一些有趣的讨论，关于截距应该是非负的还是无约束的。检查<a class="ae kv" href="https://github.com/facebookexperimental/Robyn/issues/256" rel="noopener ugc nofollow" target="_blank">这根线</a>。</p><h1 id="701e" class="nq nr iq bd ns nt ph nv nw nx pi nz oa jw pj jx oc jz pk ka oe kc pl kd og oh bi translated">带约束系数的线性回归</h1><p id="0a30" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">首先，我们需要定义一个助手函数来快速生成约束，其格式为<em class="ni"> curve_fit </em>接受<em class="ni">的格式:一个长度等于参数数量</em>的数组</p><blockquote class="oz pa pb"><p id="81f1" class="kw kx ni ky b kz la jr lb lc ld ju le pc lg lh li pd lk ll lm pe lo lp lq lr ij bi translated"><strong class="ky ir">界限:<em class="iq">数组_like的二元组，可选:</em> </strong>参数的上下界限。默认为无限制。元组的每个元素必须是一个长度等于参数数量的<strong class="ky ir">数组，或者是一个标量(在这种情况下，所有参数的界限都相同)。使用带有适当符号的<code class="fe pm pn po oo b">np.inf</code>禁用所有或部分参数的界限。</strong></p></blockquote><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="7b5d" class="os nr iq oo b gy ot ou l ov ow">def <strong class="oo ir">prepare_bounds</strong>(<strong class="oo ir">intercept_value</strong>, <br/>                   <strong class="oo ir">control_length</strong>, <br/>                   <strong class="oo ir">media_length</strong>, <br/>                   <strong class="oo ir">control_value</strong>, <br/>                   <strong class="oo ir">media_value</strong>):<br/>    lower_bounds_array = []<br/>    lower_bounds_array.append(intercept_value)</span><span id="9481" class="os nr iq oo b gy ox ou l ov ow">    for i in range(control_length):<br/>        lower_bounds_array.append(control_value)</span><span id="f4b7" class="os nr iq oo b gy ox ou l ov ow">    for i in range(media_length):<br/>        lower_bounds_array.append(media_value)<br/>        <br/>    return lower_bounds_array</span></pre><p id="7d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们准备约束条件:</p><ul class=""><li id="41b8" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">截取和媒体通道的下限是0，控制变量的下限是-无穷大。</li><li id="71e1" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">所有变量的上限都是无穷大。</li></ul><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="6360" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">lower_bounds_array </strong>= \<br/>    <strong class="oo ir">prepare_bounds</strong>(<strong class="oo ir">intercept_value </strong>= 0, <br/>                   <strong class="oo ir">control_length </strong>= len(control_features), <br/>                   <strong class="oo ir">media_length </strong>= len(media_channels) + len(organic_channels), <br/>                   <strong class="oo ir">control_value </strong>= -np.inf, <br/>                   <strong class="oo ir">media_value </strong>= 0)<br/><strong class="oo ir">upper_bounds_array </strong>= \<br/>    <strong class="oo ir">prepare_bounds</strong>(<strong class="oo ir">intercept_value </strong>= np.inf, <br/>                   <strong class="oo ir">control_length </strong>= len(control_features), <br/>                   <strong class="oo ir">media_length </strong>= len(media_channels) + len(organic_channels), <br/>                   <strong class="oo ir">control_value </strong>= np.inf, <br/>                   <strong class="oo ir">media_value </strong>= np.inf)</span></pre><p id="cf60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下限是:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="388b" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">lower_bounds_array</strong><br/>#[0, -inf, -inf, -inf, -inf, -inf, 0, 0, 0, 0, 0, 0]</span></pre><p id="5f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上限是:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="971c" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">upper_bounds_array</strong><br/>#[inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf, inf]</span></pre><p id="5027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们应用带约束的<em class="ni">曲线拟合</em></p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="83ec" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">curve_fit_bounded_coefs</strong>, _ = \<br/>    <strong class="oo ir">curve_fit</strong>(<strong class="oo ir">f</strong> = linear_function,<br/>          <strong class="oo ir">xdata</strong>=final_data[features].values, <br/>          <strong class="oo ir">ydata </strong>= final_data[target].values,<br/>          <strong class="oo ir">bounds </strong>= (tuple(lower_bounds_array), <br/>                    tuple(upper_bounds_array)))</span><span id="d377" class="os nr iq oo b gy ox ou l ov ow">#print coefficients<br/>pd.DataFrame(<strong class="oo ir">curve_fit_bounded_coefs</strong>, index = ["const"] + features, columns = ["coefficient"])</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/5eea3b4ac79ca9d25ebf6f35913140b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*jbwmxTiXqFjwY87hC8hQig.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SciPy曲线拟合约束系数</p></figure><p id="886f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次模型的所有参数都是正的。</p><p id="e809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种解决方案有几个缺点:</p><ul class=""><li id="bc14" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">模型函数需要预先定义参数的确切数量，这使得当我们想要试验不同数量的参数时很困难</li><li id="c902" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">经典的线性回归容易过度拟合，不适合相关或冗余变量，也不适合推广。在营销组合建模中，变量相互关联或数据有限时，通常需要更好的建模方法，如岭回归。岭回归已用于现实生活中，通过使用正则化技术(通过降低系数的大小来惩罚系数)来克服过拟合和多重共线性的挑战。惩罚的程度由lambda参数控制。</li></ul><h1 id="cdb2" class="nq nr iq bd ns nt ph nv nw nx pi nz oa jw pj jx oc jz pk ka oe kc pl kd og oh bi translated">基于R-glm net的约束系数岭回归</h1><p id="73a1" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">为什么我决定在Python中使用R glmnet？我简直找不到任何更好的解决办法。我可以用Python找到glmnet包装器，但是由于Fortran的依赖性，我不能在我的Windows机器上编译它们。此外，glmnet自带了两个方便的函数:<a class="ae kv" href="https://glmnet.stanford.edu/reference/cv.glmnet.html" rel="noopener ugc nofollow" target="_blank"><em class="ni">cv . glm net</em></a><em class="ni"/>执行交叉验证并确定最佳lambda参数，以及<a class="ae kv" href="https://glmnet.stanford.edu/reference/glmnet.html" rel="noopener ugc nofollow" target="_blank"> glmnet </a>函数构建最终模型。这两个函数都执行数据标准化，并允许控制系数的符号和截距。我只需要弄清楚如何从Python中调用R代码。幸运的是，有一个<a class="ae kv" href="https://github.com/rpy2/rpy2" rel="noopener ugc nofollow" target="_blank"> RPy2 </a>包，R语言的Python接口，正是为了这个:</p><blockquote class="oz pa pb"><p id="f45e" class="kw kx ni ky b kz la jr lb lc ld ju le pc lg lh li pd lk ll lm pe lo lp lq lr ij bi translated">rpy2正在运行一个嵌入式R，使用R自己的C-API通过以下任一方式从Python提供对它的访问:</p><p id="b3c7" class="kw kx ni ky b kz la jr lb lc ld ju le pc lg lh li pd lk ll lm pe lo lp lq lr ij bi translated">一个高级接口，使R函数像Python函数一样成为对象，并提供到numpy和pandas数据结构的无缝转换</p><p id="44ef" class="kw kx ni ky b kz la jr lb lc ld ju le pc lg lh li pd lk ll lm pe lo lp lq lr ij bi translated">更接近C-API的底层接口</p></blockquote><h2 id="bca5" class="os nr iq bd ns pq pr dn nw ps pt dp oa lf pu pv oc lj pw px oe ln py pz og qa bi translated">安装R和RPy2</h2><p id="8b94" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">当然你要装R。然后安装RPy2:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="666b" class="os nr iq oo b gy ot ou l ov ow">pip install rpy2</span></pre><p id="92fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过导入RPy2，检查RPy2是否识别您的R安装:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="e6bd" class="os nr iq oo b gy ot ou l ov ow">from rpy2 import robjects as ro<br/>from rpy2.robjects import pandas2ri<br/>from rpy2.robjects.packages import importr<br/>import rpy2.situation<br/>base = importr("base")<br/>glm = importr("glmnet")</span></pre><p id="5faa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果导入顺利，获得一些关于R安装信息:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="d919" class="os nr iq oo b gy ot ou l ov ow">for row in rpy2.situation.iter_info():<br/>    print(row)</span></pre><p id="9675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果在导入过程中出现一些错误，您可以尝试以下步骤:</p><ul class=""><li id="c991" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">检查<strong class="ky ir"> etc/Rprofile </strong>文件是否没有加载任何库</li><li id="7ca1" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">用R安装的路径创建一个<strong class="ky ir"> R_HOME </strong>环境</li></ul><h2 id="c6eb" class="os nr iq bd ns pq pr dn nw ps pt dp oa lf pu pv oc lj pw px oe ln py pz og qa bi translated">包装glmnet包装</h2><p id="457d" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">包装过程包括三个步骤</p><ul class=""><li id="16b4" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">用R编写一个函数，调用岭回归并返回我们感兴趣的输出</li><li id="959f" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">为Pandas DataFrames、Boolean和Float类型编写Python-R类型转换器</li><li id="de85" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">在一个准备数据类型、调用R代码并返回结果的Python函数中组合所有内容</li></ul><p id="ce15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤1:编写R代码:在R中拟合岭回归</strong></p><p id="059b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RPy2提供了<strong class="ky ir"><em class="ni">rpy 2 . R objects . R</em></strong>函数，该函数接受任意字符串并将其计算为R代码:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="3c3c" class="os nr iq oo b gy ot ou l ov ow"><strong class="oo ir">run_glmnet_in_r </strong>= \<br/>    <strong class="oo ir">ro.r</strong>("""<br/>    <br/>#pure R code<br/><em class="ni">function(x_train, <br/>         y_train, <br/>         x_test, <br/>         lambda, <br/>         is_intercept, <br/>         lower_limits, <br/>         upper_limits, <br/>         alpha = 0){ <br/>     mod = glmnet(x_train,<br/>                  y_train,<br/>                  family = 'gaussian',<br/>                  alpha = alpha,<br/>                  lambda = lambda, <br/>                  intercept = is_intercept,<br/>                  lower.limits = lower_limits,<br/>                  upper.limits = upper_limits,<br/>                  type_measure = 'mse')</em></span><span id="df03" class="os nr iq oo b gy ox ou l ov ow"><em class="ni">coefs = as.data.frame(as.matrix(coef(mod)))<br/>names(coefs)[1] = "value"<br/>y_pred = predict(mod, s = lambda, newx = x_test)<br/>return (list(coefs = coefs, y_pred = y_pred))</em><br/>}</span><span id="feea" class="os nr iq oo b gy ox ou l ov ow">""")</span></pre><p id="70ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我定义了一个适合岭回归的纯R函数，期望8个参数:</p><ul class=""><li id="69ab" class="mb mc iq ky b kz la lc ld lf md lj me ln mf lr mg mh mi mj bi translated">x_train —训练集</li><li id="aead" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">y_train —响应/目标变量</li><li id="3d83" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">x_test —我们从拟合模型中获得其预测的测试集</li><li id="ac3a" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">λ—我们从<em class="ni"> cv.glmnet </em>得到的λ值</li><li id="df74" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">is _ intercept我们希望截距是拟合的(无约束的)还是设置为0</li><li id="c2b2" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">下限，上限-每个变量的下限/上限向量</li><li id="0786" class="mb mc iq ky b kz mk lc ml lf mm lj mn ln mo lr mg mh mi mj bi translated">alpha-glm net适合由alpha控制的脊、套索或弹性网回归。当α0-岭回归拟合时。</li></ul><p id="edcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回的是系数和测试集预测的列表。</p><p id="4d97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤2:为Pandas数据帧、布尔和浮点类型编写Python-R类型转换器</strong></p><p id="a27f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码将Pandas数据帧转换为R数据帧:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="a3b1" class="os nr iq oo b gy ot ou l ov ow">with ro.conversion.localconverter(<strong class="oo ir">ro.default_converter</strong> + <strong class="oo ir">pandas2ri.converter</strong>):<br/>        r_df = <strong class="oo ir">ro.conversion.py2rpy</strong>(x_train)</span></pre><p id="451a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，glmnet期望矩阵作为输入。我必须编写自己的转换器，将R数据帧转换成矩阵:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="43ad" class="os nr iq oo b gy ot ou l ov ow">data_frame_to_r_matrix = <strong class="oo ir">ro.r</strong>('<em class="ni">function(x) as.matrix(x)</em>')</span></pre><p id="fd8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用RPy2转换目标值、下限和上限的向量:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="f4cc" class="os nr iq oo b gy ot ou l ov ow">r_y_train = <strong class="oo ir">ro.vectors.FloatVector</strong>(y_train)<br/>    <br/>r_lower_limits = <strong class="oo ir">ro.vectors.FloatVector</strong>(lower_limits)<br/>r_upper_limits = <strong class="oo ir">ro.vectors.FloatVector</strong>(upper_limits)</span></pre><p id="05d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">lambda的浮点标量值被转换为单值向量:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="13ee" class="os nr iq oo b gy ot ou l ov ow">lambda_best_float = <strong class="oo ir">ro.vectors.FloatVector</strong>([lambda_best])</span></pre><p id="010b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">布尔变量<em class="ni"> is_intercept </em>被类似地转换:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="ec01" class="os nr iq oo b gy ot ou l ov ow">is_intercept_bool = <strong class="oo ir">ro.vectors.BoolVector</strong>([is_intercept])</span></pre><p id="7c04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从R列表到Python字典的转换需要一个定制的解决方案:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="6896" class="os nr iq oo b gy ot ou l ov ow">def <strong class="oo ir">convert_r_list_into_dictionary</strong>(r_list):<br/>    py_dict = {}<br/>    #for name in coefs.names:<br/>    keys = r_list.names<br/>    for i in range(len(keys)):<br/>        if isinstance(r_list[i], ro.vectors.DataFrame):<br/>            with ro.conversion.localconverter(ro.default_converter + pandas2ri.converter):<br/>                py_dict[keys[i]]=r_list[i]<br/>        elif isinstance(r_list[i], ro.vectors.FloatVector):<br/>            array = np.array(r_list[i])<br/>            if len(array) == 1:<br/>                array = array[0]<br/>            py_dict[keys[i]] = array<br/>        else:<br/>            py_dict[keys[i]] = r_list[i]<br/>    return py_dict</span></pre><p id="8d07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">步骤3:将所有步骤组合到一个Python函数中，该函数准备数据类型，调用R代码并返回结果</strong></p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="6c18" class="os nr iq oo b gy ot ou l ov ow">def <strong class="oo ir">run_glmnet</strong>(x_train, <br/>               y_train, <br/>               x_test, <br/>               lambda_best, <br/>               is_intercept, <br/>               lower_limits, <br/>               upper_limits, <br/>               alpha = 0):<br/>    #type conversions<br/>    with ro.conversion.localconverter(ro.default_converter + pandas2ri.converter):<br/>        r_df = ro.conversion.py2rpy(x_train)<br/>        r_test_df = ro.conversion.py2rpy(x_test)<br/>        <br/>    r_x_train = data_frame_to_r_matrix(r_df)<br/>    r_x_test = data_frame_to_r_matrix(r_test_df)<br/>    <br/>    r_y_train = ro.vectors.FloatVector(y_train)<br/>    <br/>    r_lower_limits = ro.vectors.FloatVector(lower_limits)<br/>    r_upper_limits = ro.vectors.FloatVector(upper_limits)<br/>    <br/>    lambda_best_float = ro.vectors.FloatVector([lambda_best])<br/>    <br/>    is_intercept_bool = ro.vectors.BoolVector([is_intercept])<br/>    <br/>    #call glmnet<br/>    mod = run_glmnet_in_r(r_x_train, <br/>                          r_y_train, <br/>                          r_x_test, <br/>                          lambda_best_float, <br/>                          is_intercept_bool, <br/>                          r_lower_limits, <br/>                          r_upper_limits, <br/>                          alpha)<br/>    </span><span id="3415" class="os nr iq oo b gy ox ou l ov ow">    #prepare the results<br/>    mod = convert_r_list_into_dictionary(mod)<br/>    <br/>    mod["coefs"] = mod["coefs"].reset_index()<br/>    <br/>    return mod</span></pre><p id="e3e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">拟合岭回归</strong></p><p id="adea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们定义下限和上限:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="a8ca" class="os nr iq oo b gy ot ou l ov ow"># Set lower and upper bounds for feature coefficients<br/><strong class="oo ir">lower_limits </strong>= np.array([-np.inf for _ in range(len(control_features))] + [0 for _ in range(len(media_channels) + len(organic_channels))])<br/><strong class="oo ir">upper_limits </strong>= np.array([np.inf for _ in range(len(control_features))] + [np.inf for _ in range(len(media_channels) + len(organic_channels))])</span><span id="a347" class="os nr iq oo b gy ox ou l ov ow">print(lower_limits)<br/>print(upper_limits)</span><span id="9f58" class="os nr iq oo b gy ox ou l ov ow">#[-inf -inf -inf -inf -inf   0.   0.   0.   0.   0.   0.]<br/>#[inf inf inf inf inf inf inf inf inf inf inf]</span></pre><p id="e443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次我们只为变量定义约束。截距由函数参数明确控制。</p><p id="3173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们交叉验证以找到最佳的lambda参数:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="f76f" class="os nr iq oo b gy ot ou l ov ow">cv_glmnet = <strong class="oo ir">run_cv_glmnet</strong>(<strong class="oo ir">x_train </strong>= final_data[features], <br/>                          <strong class="oo ir">y_train </strong>= final_data[target], <br/>                          <strong class="oo ir">is_intercept </strong>= True, <br/>                          <strong class="oo ir">lower_limits </strong>= lower_limits , <br/>                          <strong class="oo ir">upper_limits </strong>= upper_limits)</span><span id="0c05" class="os nr iq oo b gy ox ou l ov ow">print(<strong class="oo ir">cv_glmnet["lambda_best"]</strong>)<br/>#166018.4312548283</span></pre><p id="7f97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用找到的λ拟合岭回归:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="0a55" class="os nr iq oo b gy ot ou l ov ow">results = <strong class="oo ir">run_glmnet</strong>(<strong class="oo ir">x_train </strong>= final_data[features], <br/>                     <strong class="oo ir">y_train </strong>= final_data[target], <br/>                     <strong class="oo ir">x_test </strong>= final_data[features], <br/>                     <strong class="oo ir">lambda_best </strong>= <strong class="oo ir">cv_glmnet["lambda_best"]</strong>, <br/>                     <strong class="oo ir">is_intercept </strong>= True, <br/>                     <strong class="oo ir">lower_limits </strong>= lower_limits, <br/>                     <strong class="oo ir">upper_limits </strong>= upper_limits)</span><span id="c27a" class="os nr iq oo b gy ox ou l ov ow">results.keys()<br/>#dict_keys(['coefs', 'y_pred'])</span></pre><p id="d63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终系数为:</p><pre class="kg kh ki kj gt on oo op oq aw or bi"><span id="d76e" class="os nr iq oo b gy ot ou l ov ow">results["coefs"]</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/7cfd5028d42b6d7de2c4b06704b3d47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*a5Gcw7A6jqFborNzAem3Jw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">岭系数</p></figure><h1 id="20d7" class="nq nr iq bd ns nt ph nv nw nx pi nz oa jw pj jx oc jz pk ka oe kc pl kd og oh bi translated">结论</h1><p id="7cdc" class="pw-post-body-paragraph kw kx iq ky b kz oi jr lb lc oj ju le lf ok lh li lj ol ll lm ln om lp lq lr ij bi translated">在某些情况下，按照营销组合建模中的业务逻辑，我们希望强制线性回归找到一个具有正系数的解决方案。然而，并不是所有的统计软件包都支持这种功能，因此需要一些变通方法。</p><p id="1ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我展示了两种约束系数的方法:使用SciPy非线性最小二乘优化函数<em class="ni"> curve_fit </em>和R glmnet软件包中的岭回归。后一种方法需要使用RPy2接口包装R代码，并允许从Python调用任意R函数。</p><p id="e029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码可以从我的<a class="ae kv" href="https://github.com/slavakx/medium_posts" rel="noopener ugc nofollow" target="_blank"> Github repo </a>下载</p><p id="0cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>