<html>
<head>
<title>Automated mapping of sea surface temperature with shell scripting, R and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用shell脚本、R和Python自动绘制海面温度图</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/automated-mapping-of-sea-surface-temperature-with-shell-scripting-r-and-python-763339432449#2022-07-20">https://towardsdatascience.com/automated-mapping-of-sea-surface-temperature-with-shell-scripting-r-and-python-763339432449#2022-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/19f0ce607a0788cf52e4ecac7506e83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAvkCT_NrYv-YR9uKHmmpA.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">新西兰海面温度。资料来源:JPL MUR措施项目。2015.GHRSST级MUR全球基金会海面温度分析。版本。4.1.阿宝。美国加利福尼亚州DAAC。数据集于【2022年7月16日】在<a class="ae kc" href="https://doi.org/10.5067/GHGMR-4FJ04" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.5067/GHGMR-4FJ04</a>通过NOAA erd DAP<a class="ae kc" href="https://upwell.pfeg.noaa.gov/erddap/griddap/nasa_jpl_28d8_bd66_24b1.html" rel="noopener ugc nofollow" target="_blank">https://up well . pfeg . NOAA . gov/erd DAP/griddap/NASA _ JPL _ 28d 8 _ bd66 _ 24 B1 . html</a>访问</p></figure><p id="dd97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多方法来绘制海洋表面温度，或SST，它是由一系列卫星传感器产生的，并在多个不同的平台上提供服务。很难决定使用哪种方法，或者从大量选项中选择哪种产品。</p><p id="c174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">20世纪80年代初，当我还是一名海洋学研究生时，如果你想要SST数据，你必须向美国国家航空航天局(NASA)提出请求，他们会寄给你一包CD，里面载有多个文件中的数据。那些日子早已过去。最新的趋势是完全避免下载数据。现在，您可以从基于云的服务器中选择并子集化<a class="ae kc" href="https://www.frontiersin.org/articles/10.3389/fclim.2021.782909/full" rel="noopener ugc nofollow" target="_blank">分析就绪的云优化(ARCO)数据</a>，使用笔记本电脑上的代码在计算机上使用多个处理器远程处理数据，在相同的远程机器上可视化数据，并下载成品(参见<a class="ae kc" href="https://tinyurl.com/2p8s6y9u" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/2p8s6y9u</a>和<a class="ae kc" href="https://tinyurl.com/yc2jne6d" rel="noopener ugc nofollow" target="_blank">https://tinyurl.com/yc2jne6d</a>)。这些方法非常强大，但是它们需要更多的专业知识来实现。</p><p id="5dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我将展示一种方法，它仍然可以下载NetCDF格式的数据并在本地处理地图。这不是一种分析就绪的云优化方法，但对于许多不涉及处理万亿字节数据的目的来说，这仍然是非常足够和快速的。它确实需要一个快速的互联网连接，一个数据下载不会超过你的配额的数据计划，以及一台具有足够处理能力的计算机。</p><p id="a0ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初的问题是使用哪个SST数据集，以及在哪里方便地获得它。为了便于说明，我选择了一个由几个卫星传感器合并而成的无间隙产品，该产品已经映射到准备投影的坐标上。高分辨率海洋表面温度<a class="ae kc" href="https://www.ghrsst.org" rel="noopener ugc nofollow" target="_blank">组</a>版本4多尺度超高分辨率，或<a class="ae kc" href="https://podaac.jpl.nasa.gov/dataset/MUR-JPL-L4-GLOB-v4.1" rel="noopener ugc nofollow" target="_blank"> GHRSST-MUR </a>产品，是一个近实时(1天延迟)、4级(映射)、无间隙产品，由几个辐射计和光谱辐射计以及<em class="lb">原位</em>数据合并而成。它提供了0.01度分辨率的几乎全球无云SST覆盖(<a class="ae kc" href="https://www.sciencedirect.com/science/article/abs/pii/S0034425717303462?via%3Dihub" rel="noopener ugc nofollow" target="_blank"> Chin et al. 2017 </a>)。</p><p id="e7d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些数据在<a class="ae kc" href="https://podaac.jpl.nasa.gov/dataset/MUR-JPL-L4-GLOB-v4.1" rel="noopener ugc nofollow" target="_blank"> NASA喷气推进实验室物理海洋学分布式活动档案中心(DAAC </a>)上以NetCDF-4文件格式提供，或者在<a class="ae kc" href="https://registry.opendata.aws/mur/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务器上以</a>ARCO Zarr格式提供。要访问NetCDF数据，使用国家海洋大气管理局<a class="ae kc" href="https://upwell.pfeg.noaa.gov/erddap/index.html" rel="noopener ugc nofollow" target="_blank">环境研究处数据访问程序</a> (NOAA-ERDDAP)更方便。在ERDDAP上，可以使用<a class="ae kc" href="https://upwell.pfeg.noaa.gov/erddap/griddap/nasa_jpl_28d8_bd66_24b1.html" rel="noopener ugc nofollow" target="_blank"> ERDDAP图形用户界面(GUI </a>)访问GHRSST-MUR最终产品并对其进行子集划分，但更好的选择是使用内置于ERDDAP 中的<a class="ae kc" href="https://coastwatch.pfeg.noaa.gov/erddap/tabledap/documentation.html" rel="noopener ugc nofollow" target="_blank"> OPenDAP类工具来访问所需格式的数据集子集。ERDDAP GUI有助于获得正确格式的所需URL。</a></p><p id="7cc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ERDDAP提供了许多使用类似OPenDAP的工具从不同的分析程序(如R、Python或Matlab)中获取所需数据的例子。我发现使用R通过ERDDAP访问和下载数据是最简单的，但是我更喜欢用Python绘制SST图。我使用一个bash shell脚本将所有东西放在一起，并自动完成下载数据和创建地图的过程。</p><p id="33f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一些技巧可以让自动化工作。(1)修改外壳环境，以允许从外壳脚本激活Python脚本所需的Conda环境。(2)使用shell脚本运行R脚本、thels Python脚本，并为执行设置计时器。</p><h2 id="76a7" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">使用外壳脚本控制代码执行时间和顺序</h2><p id="5566" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我在电脑上一个名为“geo_env”的项目环境中运行Python代码，在运行脚本之前需要激活这个项目环境。我使用Conda包管理器安装了Python，因此为了从运行在Linux上的shell脚本中激活环境，有必要修改~/。bashrc通过NOAA erd DAP<a class="ae kc" href="https://upwell.pfeg.noaa.gov/erddap/griddap/nasa_jpl_28d8_bd66_24b1.html" rel="noopener ugc nofollow" target="_blank">https://up well . pfeg . NOAA . gov/erd DAP/griddap/NASA _ JPL _ 28d 8 _ bd66 _ 24 B1 . html</a>在“#&lt;&lt;&lt; conda initialize &lt;&lt;&lt; “, shown below:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ff9e" class="lc ld iq mf b gy mj mk l ml mm"># &gt;&gt;&gt; conda initialize &gt;&gt;&gt;<br/># !! Contents within this block are managed by 'conda init' !!<br/>__conda_setup="$('/home/smcc/anaconda3/bin/conda' 'shell.bash' 'hook' 2&gt; /dev/null)"<br/>if [ $? -eq 0 ]; then<br/>    eval "$__conda_setup"<br/>else<br/>    if [ -f "/home/smcc/anaconda3/etc/profile.d/conda.sh" ]; then<br/>        . "/home/smcc/anaconda3/etc/profile.d/conda.sh"<br/>    else<br/>        export PATH="/home/smcc/anaconda3/bin:$PATH"<br/>    fi<br/>fi<br/>unset __conda_setup<br/># &lt;&lt;&lt; conda initialize &lt;&lt;&lt;</span><span id="7575" class="lc ld iq mf b gy mn mk l ml mm"># edit to permit conda activate to work in a shell script<br/>export -f conda<br/>export -f __conda_activate<br/>export -f __conda_reactivate<br/>export -f __conda_hashr<br/>export -f __conda_exe<br/># end smcc edit</span></pre><p id="6fc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Activation of the project environment from the shell script can then be done using the following command:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f614" class="lc ld iq mf b gy mj mk l ml mm">conda activate geo_env</span></pre><p id="152a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">To run the shell script every day, or at whatever interval you choose, needs a timed job execution. You can use a cron job, but I prefer to use “at” to run the script once without cron and then call “at” recursively to reset the job each time the shell script runs. This command sets the run time for the shell script to noon each day:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="90ee" class="lc ld iq mf b gy mj mk l ml mm">at -f "./shell/download_latest_GHRSST_data_from_ERDdap.sh" 12:00 + 24 hours</span></pre><p id="a7a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">You can check the timing of the next run using:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4018" class="lc ld iq mf b gy mj mk l ml mm">at -l</span></pre><p id="e9f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Here is the full shell script:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f3e0" class="lc ld iq mf b gy mj mk l ml mm">#!/bin/bash<br/>############################################ download_latest_GHRSST_data_from_ERDdap.sh<br/>###########################################<br/># activate the conda environment for python<br/># NOTE: ~/.bashrc was modified so conda activate will work in a shell script<br/>conda activate geo_env</span><span id="4274" class="lc ld iq mf b gy mn mk l ml mm">##########################################<br/># Download the latest GHRSST data for each of the regions<br/># from ERDDAP.<br/># NOTE: Edit the R script to add more regions<br/>##########################################<br/>Rscript "../R/download_GHRSST_MUR-JPL-L4-GLOB-v4.1_daily.R"</span><span id="1600" class="lc ld iq mf b gy mn mk l ml mm">##########################################<br/># Process the downloaded data and draw maps<br/>###########################################<br/>python "../python/batch_process_sst_and_plots.py"</span><span id="facc" class="lc ld iq mf b gy mn mk l ml mm">##########################################<br/># Use "at" to run the script ONE TIME without cron# and then call "at" recursively to reset the job each time<br/># the shell script runs.<br/># NOTE: before resetting the at commands, use<br/># atq | cut -f 1 | xargs atrm# to remove all previous jobs<br/># (which can be shown with: at -l)<br/>########################################<br/>at -f "../shell/download_latest_GHRSST_data_from_ERDdap.sh" 12:00 + 24 hours</span></pre><h2 id="7027" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Download the data from ERDDAP with R</h2><p id="3162" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">Downloading the data is straightforward with a simple R script:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5b50" class="lc ld iq mf b gy mj mk l ml mm">#####################################################<br/># download GHRSST, MUR-JPL-L4-GLOB-v4.1 daily<br/>#####################################################<br/><em class="lb">setwd</em>("/mnt/data/dynamic_data/projects/projects2022/GHRSST_and_anomalies/R")<br/>start_date = <em class="lb">paste</em>(<em class="lb">Sys.Date</em>()-2, "T12:00:00Z", sep='') # just one day<br/>end_date = <em class="lb">paste</em>(<em class="lb">Sys.Date</em>()-2, "T12:00:00Z", sep='') # today minus 2 days</span><span id="edfc" class="lc ld iq mf b gy mn mk l ml mm">#####################################################<br/># New Zealand <br/>url &lt;- paste("https://upwell.pfeg.noaa.gov/erddap/griddap/nasa_jpl_dde5_3be1_897b.nc?analysed_sst%5B(",start_date,"):(",end_date,")%5D%5B(-49.0):(-31.0)%5D%5B(160.5):(179.5)%5D&amp;.draw=surface&amp;.vars=longitude%7Clatitude%7Canalysed_sst&amp;.colorBar=KT_thermal%7CD%7CLinear%7C15%7C18%7C6&amp;.land=over&amp;.bgColor=0xffccccff", sep="")</span><span id="1044" class="lc ld iq mf b gy mn mk l ml mm"># filename &lt;-"../data/latest_MUR_SST_New_Zealand.nc"<br/>download.file(url, filename)<br/># end New Zealand</span><span id="f288" class="lc ld iq mf b gy mn mk l ml mm">#####################################################<br/># California<br/>url &lt;-<em class="lb">paste</em>("https://upwell.pfeg.noaa.gov/erddap/griddap/nasa_jpl_dde5_3be1_897b.nc?analysed_sst%5B(",start_date,"):(",end_date,")%5D%5B(30.0):(45.0)%5D%5B(-130.0):(-115.0)%5D&amp;.draw=surface&amp;.vars=longitude%7Clatitude%7Canalysed_sst&amp;.colorBar=KT_thermal%7CD%7CLinear%7C15%7C18%7C6&amp;.land=over&amp;.bgColor=0xffccccff", sep="")</span><span id="01d0" class="lc ld iq mf b gy mn mk l ml mm">filename &lt;-"../data/latest_MUR_SST_SoCal.nc"<br/>download.file(url, filename)<br/># end California</span></pre><p id="c0ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">I’ve just used New Zealand and California for this example. More regions can be added by modifying the coordinates in additional URL commands. I find it convenient to use the ERDDAP GUI to generate the URL used in the R script.</p><h2 id="c374" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Plotting the maps with Python</h2><p id="fb66" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">I use a simple python script to define the regions of interest and then plot them.</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3f0a" class="lc ld iq mf b gy mj mk l ml mm"># batch_process_sst_and_plots.py<br/>################################################################<br/># All regions are processed in a loop<br/>#################################################################</span><span id="ee72" class="lc ld iq mf b gy mn mk l ml mm"># define regions to process</span><span id="5ee8" class="lc ld iq mf b gy mn mk l ml mm"># region_list =["New_Zealand_Northland","New_Zealand_Taranaki","New_Zealand_East_Cape","Australia_QLD_Brisbane","Australia_QLD_central","Australia_QLD_northern","Australia_NSW_Sydney","Australia_Tasmania","Costa_Rica","Baja_Sur","California","Gulf_of_Maine","US_Central_Bight","Florida"]</span><span id="0a6d" class="lc ld iq mf b gy mn mk l ml mm"># to process one or more only ...<br/>region_list = ["New_Zealand", "California"]</span><span id="a617" class="lc ld iq mf b gy mn mk l ml mm">for region in region_list:<br/>    import plot_SST_map<br/>    plot_SST_map.plot_map(region)</span></pre><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/63e1895788b1c52fdec9c2922e2ea729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLGfV3_9TK3HRtpqPqAS9w.png"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Sea surface Temperature off California. Source: JPL MUR MEaSUREs Project. 2015. GHRSST Level 4 MUR Global Foundation Sea Surface Temperature Analysis. Ver. 4.1. PO.DAAC, CA, USA. Dataset accessed [17 July 2022] at <a class="ae kc" href="https://doi.org/10.5067/GHGMR-4FJ04" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.5067/GHGMR-4FJ04</a>之后添加编辑</p></figure><p id="34a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是绘图脚本:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5f4b" class="lc ld iq mf b gy mj mk l ml mm"><em class="lb">def</em> plot_map(region):<br/>#########################################################<br/># Import packages:<br/>#########################################################<br/>import matplotlib.pyplot as plt<br/>import matplotlib.ticker as mticker<br/>from matplotlib.pyplot import tick_params<br/># from matplotlib.font_manager import get_fontconfig_fonts<br/>from datetime import datetime<br/>import cartopy.crs as ccrs<br/>import cartopy.feature as cfeature<br/>import cmocean as cmo<br/>import numpy as np<br/>import pandas as pd<br/>import xarray as xr<br/>import os<br/>from pyproj import transform</span><span id="37a6" class="lc ld iq mf b gy mn mk l ml mm">########################################################<br/># Load data<br/># Open a netCDF data file using xarray<br/>########################################################<br/>f = "latest_MUR_SST_" + region + ".nc"<br/>datadir = ("/mnt/data/dynamic_data/projects/projects2022/GHRSST_and_anomalies/data")<br/>d = datadir + "/" + f<br/># open netcdf file as an xarray dataset<br/>ds = xr.open_dataset(d)<br/># open single variables in the xarray dataset<br/># sst_3d = ds["analysed_sst"] + 273.15<br/>sst_3d = ds["analysed_sst"]<br/>#reduce dimensions to 2d<br/>sst = sst_3d.squeeze()</span><span id="bdb3" class="lc ld iq mf b gy mn mk l ml mm"># Generate figure (set its size (width, height) in inches).<br/>fig = plt.figure(figsize=(5, 8))<br/>ax = plt.subplot(1, 1, 1, projection=ccrs.PlateCarree())<br/>ax.coastlines(linewidths=0.5)<br/>ax.add_feature(cfeature.LAND, facecolor="lightgray")<br/>ax.add_feature(cfeature.BORDERS)<br/>ax.add_feature(cfeature.RIVERS)</span><span id="503d" class="lc ld iq mf b gy mn mk l ml mm"># get the min, max for SST, convert to a scalar, and round off<br/>varmin = sst.min()<br/>sstmin = <em class="lb">int</em>(<em class="lb">round</em>(varmin.item(),0))<br/>varmax = sst.max()<br/>sstmax = <em class="lb">int</em>(<em class="lb">round</em>(varmax.item(),0))<br/>sst_int = <em class="lb">int</em>(sstmax - sstmin)<br/>if sst_int &gt;=6:<br/>    contour_levels = np.array(<em class="lb">range</em>(sstmin,sstmax,2))<br/>elif sst_int &lt;6:<br/>    contour_levels = np.array(<em class="lb">range</em>(sstmin,sstmax,1))</span><span id="4199" class="lc ld iq mf b gy mn mk l ml mm">################################################<br/># Plot data<br/>###############################################<br/>pt_sst = sst.plot.contourf(ax=ax,<br/>    transform=ccrs.PlateCarree(),<br/>    levels=contour_levels,<br/>    cmap=cmo.cm.ice,<br/>    add_colorbar=<em class="lb">False</em>,<br/>    zorder=0,<br/>)</span><span id="d02c" class="lc ld iq mf b gy mn mk l ml mm"># color bar ################<br/>from mpl_toolkits.axes_grid1.inset_locator import inset_axes</span><span id="78bd" class="lc ld iq mf b gy mn mk l ml mm">cax = inset_axes(ax,<br/>    width="80%",  # width = 80% of parent_bbox width<br/>    height="5%",  # height : 5%<br/>    loc='upper right',<br/>)</span><span id="22f4" class="lc ld iq mf b gy mn mk l ml mm"># axins1.gridlines(draw_labels=False)<br/>    cbar = plt.colorbar(pt_sst,<br/>    cax=cax,<br/>    orientation="horizontal",<br/>    extendrect=<em class="lb">True</em>,<br/>)</span><span id="6ce8" class="lc ld iq mf b gy mn mk l ml mm">cbar.ax.tick_params(labelsize=7, colors='salmon')<br/>gl = ax.gridlines(draw_labels=<em class="lb">True</em>,<br/>    dms=<em class="lb">True</em>,<br/>    x_inline=<em class="lb">False</em>,<br/>    y_inline=<em class="lb">False</em>,<br/>    linewidth=0.25,<br/>    color="black",<br/>    alpha=0.25,<br/>)</span><span id="ce05" class="lc ld iq mf b gy mn mk l ml mm"># Manipulate latitude and longitude gridline numbers and spacing</span><span id="2f34" class="lc ld iq mf b gy mn mk l ml mm">gl.top_labels = <em class="lb">False<br/></em>gl.right_labels = <em class="lb">False<br/></em>if region == "New_Zealand":<br/>    gl.xlocator = mticker.FixedLocator([163, 167, 171, 175, 179])<br/>    gl.ylocator = mticker.FixedLocator([-48, -46, -44, -42, -40, <br/>    38, -36, -34, -32])<br/>elif region == "California":<br/>    gl.xlocator = mticker.FixedLocator([-130, -128, -126, <br/>    -124, -122, -120, -118, -116])<br/>    gl.ylocator = mticker.FixedLocator([31, 33, 35, 37, 39, 41, 43])<br/>    gl.xlabel_style = {"rotation": 0, "size": 12}<br/>    gl.ylabel_style = {"rotation": 0, "size": 12}</span><span id="51c4" class="lc ld iq mf b gy mn mk l ml mm">########################################################<br/># Save the plot<br/>########################################################</span><span id="6d97" class="lc ld iq mf b gy mn mk l ml mm"># tidy by removing any previous file<br/>os.system("rm /mnt/data/dynamic_data/projects/projects2022/GHRSST_and_anomalies/figures/latest_MUR_SST_"+region+".png")</span><span id="4a63" class="lc ld iq mf b gy mn mk l ml mm">plt.savefig("/mnt/data/dynamic_data/projects/projects2022/GHRSST_and_anomalies/figures/latest_MUR_SST_"+region+".png",<br/>    format="png",<br/>    bbox_inches='tight',<br/>    pad_inches=0,<br/>    dpi=300<br/>    )</span></pre><p id="bb93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文只是展示了一个利用这些SST数据可以做什么的例子，即制作感兴趣区域海洋表面温度的每日地图。结合几个互补的工具，比如shell脚本、R和Python，可以使这个任务变得更容易。使用像<a class="ae kc" href="https://code.visualstudio.com/docs/?dv=linux64_deb#first-steps" rel="noopener ugc nofollow" target="_blank"> VS Code </a>这样的IDE，可以在同一个项目中编辑和调试R和Python，有助于将这两种语言结合起来达到更好的效果。</p><h2 id="e1f1" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">开源代码库</h2><p id="1c06" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">本文的代码可以在一个<a class="ae kc" href="https://github.com/smcclatchie/medium-GHRSST" rel="noopener ugc nofollow" target="_blank"> Github存储库中找到。</a></p><h2 id="b8ec" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">参考</h2><p id="0347" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">陈，T.M .，j .瓦兹奎-库沃，和E.M .阿姆斯壮。2017.全球海表温度的多尺度高分辨率分析，环境遥感，200。https://doi.org/10.1016/j.rse.2017.07.029<a class="ae kc" href="https://www.sciencedirect.com/science/article/abs/pii/S0034425717303462?via%3Dihub" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>