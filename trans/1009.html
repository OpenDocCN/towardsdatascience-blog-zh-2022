<html>
<head>
<title>Machine Learning Pipeline with Ploomber, PyCaret and MLFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 Ploomber、PyCaret 和 MLFlow 的机器学习管道</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/machine-learning-pipeline-with-ploomber-pycaret-and-mlflow-db6e76ee8a10#2022-03-16">https://towardsdatascience.com/machine-learning-pipeline-with-ploomber-pycaret-and-mlflow-db6e76ee8a10#2022-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ec5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于训练和推理的端到端机器学习管道</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9c6e12262a2b15596e6eafe1457c029e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o5VD-PBQTHM3EUaU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mbenna?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·本纳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="eeb3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="59e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">机器学习流水线由自动化机器学习工作流的一系列步骤组成。机器学习管道中的常见步骤包括数据收集、数据清洗、特征工程、模型训练、模型评估。在本文中，我们将研究如何使用 Ploomber、Pycaret 和 MLFlow 创建机器学习管道，用于模型训练和批量推理。让我们来看看这些工具各自的功能。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="5d6b" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu">目录</strong></p><ul class=""><li id="9e6b" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#eeb3" rel="noopener">简介</a></li><li id="c541" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#4a8f" rel="noopener">机器学习管道</a> <br/> - <a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#11b5" rel="noopener">设置环境</a> <br/> - <a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#33f0" rel="noopener"> MLFlow 服务器</a> <br/> - <a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#e6a6" rel="noopener">训练管道</a> <br/> - <a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#6c59" rel="noopener">运行训练管道</a> <br/> - <a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#07ac" rel="noopener">服务管道</a> <br/> - <a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#4614" rel="noopener">批量推理</a></li><li id="8c26" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/p/db6e76ee8a10/#c42a" rel="noopener">结论</a></li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="1160" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu">砰然一声</strong></p><p id="2094" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">Ploomber[1]是一个开源框架，用于使用 python 脚本、函数或 Jupyter 笔记本的集合来构建模块化的数据管道。假设我们有多台 Jupyter 笔记本，每台都有不同的用途，例如数据清理、特征工程、模型训练和模型评估。Ploomber 帮助根据用户定义的<code class="fe nn no np nq b">pipeline.yaml</code>文件将所有这些笔记本连接成一系列步骤。下面显示了一个 Ploomber 管道的例子。<code class="fe nn no np nq b">visualize</code>和<code class="fe nn no np nq b">train</code>任务依赖于<code class="fe nn no np nq b">clean</code>任务。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/02a8ad1a4cdaacfc7b24468395d806fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/0*sQAu2gQCGSiPxySI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道插图。作者图片</p></figure><p id="33b3" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">这就是对应的<code class="fe nn no np nq b">pipeline.yaml</code>。<code class="fe nn no np nq b">product</code>是任务的输出，可以作为后续任务的输入(<code class="fe nn no np nq b">upstream</code>)。例如，<code class="fe nn no np nq b">visualize</code>任务依赖于<code class="fe nn no np nq b">clean</code>任务的产品，因此<code class="fe nn no np nq b">clean</code>任务是<code class="fe nn no np nq b">visualize</code>任务的<code class="fe nn no np nq b">upsteam</code>。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="5984" class="nw la it nq b gy nx ny l nz oa"># pipeline.yaml</span><span id="81d0" class="nw la it nq b gy ob ny l nz oa">tasks:<br/>  - source: tasks/clean_data.ipynb<br/>    name: clean<br/>    product:<br/>      nb: products/clean_train_data.ipynb<br/>      data: products/cleaned_train_data.csv<br/>		...</span><span id="a0dd" class="nw la it nq b gy ob ny l nz oa">  - source: tasks/visualize_data.ipynb<br/>    name: visualize<br/>    upstream: ['clean']<br/>    product:<br/>      nb: products/visualize_data.ipynb<br/>		...</span><span id="7338" class="nw la it nq b gy ob ny l nz oa">  - source: tasks/train_model.ipynb<br/>    name: train<br/>    upstream: ['clean']<br/>    product:<br/>      nb: products/train_model.ipynb<br/>		...</span></pre><p id="93e2" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> MLFlow </strong></p><p id="a891" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">MLFlow[2]是一个管理 ML 生命周期的开源平台，包括实验、可复制性、部署和中央模型注册。MLFlow 提供 4 种不同的组件:</p><ol class=""><li id="5893" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm oc nf ng nh bi translated"><strong class="lt iu"> MLFlow Tracking: </strong>记录和查询实验:代码、数据、配置和结果</li><li id="e800" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated"><strong class="lt iu"> MLFlow 项目:</strong>将数据科学代码打包成可在任何平台上运行的格式</li><li id="a346" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated"><strong class="lt iu"> MLFlow 模型:</strong>在不同的服务环境中部署机器学习模型</li><li id="9102" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated"><strong class="lt iu">模型注册:</strong>在中央存储库中存储、注释、发现和管理模型</li></ol><p id="c548" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们将使用 MLFlow 跟踪功能来记录机器学习实验的参数、结果和工件。它允许在本地或远程跟踪服务器上记录实验，用户可以从图形用户界面查看实验。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5b6dcd85e3ef4c1ce5243eaa4bf9fcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tg40KEdu8IjUWB69"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MLFlow UI。图片作者。</p></figure><p id="9244" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu"> PyCaret </strong></p><p id="5f47" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">PyCaret[3]是一个用 python 编写的开源、低代码自动机器学习(AutoML)库。PyCaret 通过自动化数据预处理、超参数优化、叠加、混合和模型评估等步骤，帮助简化模型训练过程。PyCaret 与 MLFlow 集成，并自动将运行的参数、指标和工件记录到 MLFlow 服务器上。</p><h1 id="4a8f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">机器学习管道</h1><p id="d801" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经了解了每个工具的作用，如果你还没有猜到，我们将使用 Pandas 清理数据，使用 PyCaret 训练模型，使用 MLFlow 记录我们的实验，整个管道将由 Ploomber 协调。</p><p id="8414" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">让我们来看一个例子。我们将使用美国国家糖尿病、消化和肾脏疾病研究所的 Pima 印度糖尿病数据集[4]。数据集的目的是基于数据集中包含的某些诊断测量结果，诊断性地预测患者是否患有糖尿病。从一个较大的数据库中选择这些实例有几个限制。特别是，这里的所有患者都是至少 21 岁的皮马印第安血统的女性。数据集由几个医学预测变量和一个二元目标变量<code class="fe nn no np nq b">Outcome</code>组成。预测变量包括患者的怀孕次数、身体质量指数、胰岛素水平、年龄等。我们将数据分成两组，分别命名为<code class="fe nn no np nq b">diabetes_train.csv</code>和<code class="fe nn no np nq b">diabetes_test.csv</code>，用于开发我们的训练管道和测试服务管道。</p><h2 id="11b5" class="nw la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">设置环境</h2><p id="2f09" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">此示例需要一个 IDE(例如，VSCode、Jupyter Notebook 等)和命令行界面。我使用的是 Windows 11、VSCode 和 VSCode 中的终端，但是你可以自由使用任何你选择的操作系统、IDE 和命令行界面。</p><p id="46c0" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu">康达环境</strong></p><p id="88a6" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">确保您的机器上安装了 miniconda3。从命令行界面创建 python 3.7 conda 环境。环境名是任意的，我将其命名为<code class="fe nn no np nq b">general</code>。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="9a57" class="nw la it nq b gy nx ny l nz oa">#command line <br/>conda create -n general python=3.7</span></pre><p id="06cc" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">激活康达环境。我们将在这种环境下进行所有的开发工作。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="14e9" class="nw la it nq b gy nx ny l nz oa">#command line<br/>conda activate general</span></pre><p id="77fc" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">安装必要的软件包</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="b43e" class="nw la it nq b gy nx ny l nz oa">#command line<br/>pip install ploomber<br/>pip install pycaret<br/>pip install mlflow<br/>pip install pandas</span></pre><p id="b3a7" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu">项目目录结构</strong></p><p id="5957" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">让我们设置项目目录结构。Ploomber 提供命令行来创建一个准系统项目目录结构。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="38bb" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber scaffold sample-ml --empty</span></pre><p id="92ac" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">Ploomber 用一个空的<code class="fe nn no np nq b">pipeline.yaml</code>文件创建了一个名为<code class="fe nn no np nq b">sample-ml</code>的新文件夹。让我们修改项目目录结构，以更好地满足我们的需求。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="3dbe" class="nw la it nq b gy nx ny l nz oa"># command line<br/>cd sample-ml<br/>mkdir tasks # add folder<br/>mkdir mlflow # add folder<br/>mkdir input_data # add folder<br/>rmdir /s exploratory # remove folder created by ploomber</span></pre><p id="0510" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">这是修改后目录的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ba6a9c866068656c3d2b8bcb80361ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/0*VtsN6dowA3VYlZvx"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="bcd6" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe nn no np nq b">tasks</code>:包含要执行的 Jupyter 笔记本</li><li id="6dfe" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">products</code>:存储已执行的 Jupyter 笔记本、中间和最终输出</li><li id="9fdc" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">mlflow</code>:存储使用 MLFlow 记录的参数、结果和工件</li><li id="1005" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">input_data</code>:存储原始数据</li></ul><h2 id="33f0" class="nw la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">MLFlow 服务器</h2><p id="79d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们在本地主机上启动一个 MLFlow 跟踪服务器来记录实验。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="a82e" class="nw la it nq b gy nx ny l nz oa">#command line<br/>cd sample-ml/mlflow<br/>mlflow server --backend-store-uri sqlite:///expt.db --default-artifact-root "file:\\My Drive\\Data-Science\\Projects\\ploomber\\sample-ml\\mlflow\\ml-artifacts"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0f4f7f31a5c83d543d466290ddb9415c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BMAtg22JM6bsk_3e"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><ul class=""><li id="d457" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe nn no np nq b">backend-store-uri</code>:将实验和运行数据保存到的 URI。为此，我们使用了 SQLite 数据库。</li><li id="b2c7" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">default-artifact-root</code>:为任何新创建的实验存储工件的目录</li></ul><p id="3dcb" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">MLFlow 服务器可以通过<a class="ae ky" href="http://127.0.0.1:5000" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000 </a>访问。</p><h2 id="e6a6" class="nw la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">培训渠道</h2><p id="6b6e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">定义 pipeline.yaml </strong></p><p id="129d" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">Ploomber 管道是一个包含任务和任务间关系的<code class="fe nn no np nq b">.yaml</code>文件。让我们在<code class="fe nn no np nq b">pipeline.yaml</code>文件中定义我们的培训管道。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="c3a5" class="nw la it nq b gy nx ny l nz oa"># pipeline.yaml<br/>meta:<br/>  extract_upstream: False</span><span id="dab5" class="nw la it nq b gy ob ny l nz oa">tasks:<br/>  - source: tasks/clean_data.ipynb<br/>    name: clean<br/>    product:<br/>      nb: products/clean_train_data.ipynb<br/>      data: products/cleaned_train_data.csv<br/>    params:<br/>      input_path: '{{root}}\\input_data\\diabetes_train.csv'</span><span id="c880" class="nw la it nq b gy ob ny l nz oa">  - source: tasks/visualize_data.ipynb<br/>    name: visualize<br/>    upstream: ['clean']<br/>    product:<br/>      nb: products/visualize_data.ipynb</span><span id="8c0d" class="nw la it nq b gy ob ny l nz oa">  - source: tasks/train_model.ipynb<br/>    name: train<br/>    upstream: ['clean']<br/>    product:<br/>      nb: products/train_model.ipynb<br/>      config: products/config.pkl<br/>    params:<br/>      mlflow_tracking_uri: &lt;http://127.0.0.1:5000&gt;<br/>      experiment_name: 'diabetes-expt'<br/>      train_size: 0.8<br/>      fix_imbalance: True<br/>      numeric_imputation: median<br/>      include_models: ['rf', 'lightgbm', 'lr']</span></pre><p id="4e6c" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们在管道中定义了 3 个任务，分别名为<code class="fe nn no np nq b">clean</code>、<code class="fe nn no np nq b">visualize</code>和<code class="fe nn no np nq b">train</code>。对于每项任务，我们定义了以下内容:</p><ul class=""><li id="c598" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe nn no np nq b">source</code>:我们打算运行的 Jupyter 笔记本(<code class="fe nn no np nq b">.ipynb</code>)或 python 脚本(<code class="fe nn no np nq b">.py</code>)的路径</li><li id="ae3c" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">name</code>:任务名称</li><li id="bdfe" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">upstream</code>:上游任务名称。这就告诉了我们笔记本之间的依赖关系。例如，<code class="fe nn no np nq b">visualize</code>任务将<code class="fe nn no np nq b">clean</code>任务作为其上游，表示<code class="fe nn no np nq b">visualize</code>任务需要来自<code class="fe nn no np nq b">clean</code>任务的输出。</li><li id="4a0b" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">product</code>:任务生成的输出(如果有)。每台笔记本可以有多种产品。例如，在<code class="fe nn no np nq b">clean_data.ipynb</code>中我们有两个产品:(1) <code class="fe nn no np nq b">nb</code>:被执行的<code class="fe nn no np nq b">clean_data.ipynb</code>的副本的路径。该笔记本副本将包含 Jupyter 笔记本单元的输出。(2) <code class="fe nn no np nq b">data</code>:由<code class="fe nn no np nq b">clean_data.ipynb</code>输出的中间数据的路径</li><li id="9cb3" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">params</code>是执行时传递给 Jupyter 笔记本的参数</li></ul><p id="6a44" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><code class="fe nn no np nq b">{{root}}</code>占位符是指<code class="fe nn no np nq b">pipeline.yaml</code>文件所在的目录路径。</p><p id="fc62" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu">创建笔记本</strong></p><p id="0dcd" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">现在我们已经定义了管道，让我们为 3 个任务创建 Jupyter 笔记本。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="94c0" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber scaffold</span></pre><p id="f1f7" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们再次使用了<code class="fe nn no np nq b">ploomber scaffold</code>，但是 Ploomber 没有使用空的<code class="fe nn no np nq b">pipeline.yaml</code>文件创建项目目录结构，而是读取现有的<code class="fe nn no np nq b">pipeline.yaml</code>文件并创建缺失的 Jupyter 笔记本。现在在<code class="fe nn no np nq b">tasks</code>文件夹中有 3 个新的 Jupyter 笔记本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/bd4380e3bd74b1313208243e6e0377ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/0*4Nwl_Q3VV7laUBy3"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0009" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">下图显示了 Ploomber 创建的<code class="fe nn no np nq b">clean_data.ipynb</code>笔记本。<code class="fe nn no np nq b">upstream</code>和<code class="fe nn no np nq b">product</code>变量当前设置为<code class="fe nn no np nq b">None</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4aafda4886ecd401dec1102e3d637071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NwE4x_ehfSjm89nI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="3d19" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们之前已经在<code class="fe nn no np nq b">pipeline.yaml</code>中定义了<code class="fe nn no np nq b">upstream</code>和<code class="fe nn no np nq b">product</code>信息。让我们使用细胞注射将信息转移到 Jupyter 笔记本中。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="90da" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber nb --inject</span></pre><p id="4ed0" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">Ploomber 基于带有单元注入的<code class="fe nn no np nq b">pipeline.yaml</code>文件，帮助填充每个笔记本的输入(即上游)和输出(即产品)路径。一个新的“参数”单元格被注入到笔记本中，其中包含我们之前定义的<code class="fe nn no np nq b">product</code>和<code class="fe nn no np nq b">upstream</code>信息。前 3 个单元格没有用，我们可以删除它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/8e37bc2e92b24636452c85a146a10e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7lxzjixS0Gh7d--Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="5d0a" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">现在我们已经设置了参数，让我们进入每个笔记本的实际代码。</p><p id="4324" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><code class="fe nn no np nq b"><strong class="lt iu">clean_data.ipynb</strong></code></p><p id="4bf1" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">本笔记本包含基本的清洁步骤。为了简化示例，我们在本笔记本中只有一个数据清理步骤。我们在选定的列中找到“0”值，并用“NaN”替换它。缺少的值将由 PyCaret 中的数据转换管道处理。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="65f9" class="nw la it nq b gy nx ny l nz oa">import pandas as pd<br/>import numpy as np</span><span id="2106" class="nw la it nq b gy ob ny l nz oa">df = pd.read_csv(input_path, sep = ',')</span><span id="ebcc" class="nw la it nq b gy ob ny l nz oa"># replace zeros in the following columns with NaN<br/>df[['Glucose','BloodPressure','SkinThickness','Insulin','BMI']] = df[['Glucose','BloodPressure','SkinThickness','Insulin','BMI']].replace(0,np.NaN)</span><span id="3c37" class="nw la it nq b gy ob ny l nz oa">df.to_csv(product['data'], index = False)</span></pre><p id="c5fc" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">这是笔记本现在的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/6cc46d8aa8dfdac8206f59226add8827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2w7cA6-ZxpLW1F59"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b485" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们使用注入参数单元中的<code class="fe nn no np nq b">input_path</code>和<code class="fe nn no np nq b">product</code>来分别确定原始输入数据和干净训练数据的路径。</p><p id="fa7e" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><code class="fe nn no np nq b"><strong class="lt iu">train.ipynb</strong></code></p><p id="ae10" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">此笔记本使用 PyCaret 训练模型，并将参数、结果和工件记录到 MLFlow 服务器。这是笔记本注射细胞后的样子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/f8944f7ea235ba14a169a988683e938b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HLJEYhHYbJgsY32k"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ce5a" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们在后续单元格中执行以下步骤:</p><ol class=""><li id="fe8d" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm oc nf ng nh bi translated">导入包</li><li id="f699" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">设置 MLFlow 跟踪 URI</li><li id="b1df" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">读取<code class="fe nn no np nq b">clean_data.ipynb</code>输出的清除数据</li><li id="565a" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">为培训设置 PyCaret</li><li id="0865" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">保存 PyCaret 安装配置</li><li id="e819" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">培训、调整和最终确定模型</li></ol><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="cfa7" class="nw la it nq b gy nx ny l nz oa">from pycaret.classification import *<br/>import pandas as pd<br/>import mlflow</span><span id="3256" class="nw la it nq b gy ob ny l nz oa"># set the mlflow tracking uri<br/>mlflow.set_tracking_uri(mlflow_tracking_uri)</span><span id="441c" class="nw la it nq b gy ob ny l nz oa"># read the cleaned data<br/>df = pd.read_csv(upstream['clean']['data'])</span><span id="acc6" class="nw la it nq b gy ob ny l nz oa"># setup pycaret</span><span id="a391" class="nw la it nq b gy ob ny l nz oa">numeric_features = ['Pregnancies', 'Glucose', 'BloodPressure', 'SkinThickness', 'Insulin', 'BMI', 'DiabetesPedigreeFunction', 'Age']</span><span id="9d21" class="nw la it nq b gy ob ny l nz oa">clf = setup(data=df,<br/>            target='Outcome',<br/>            train_size = train_size,<br/>            fold_shuffle = fold_shuffle,<br/>            fold = fold,<br/>            html = False,<br/>            silent = True,<br/>            numeric_features = numeric_features,<br/>            experiment_name = experiment_name,<br/>            log_experiment = True,<br/>            fix_imbalance = fix_imbalance,<br/>            numeric_imputation = numeric_imputation,<br/>            session_id=1)</span><span id="5dae" class="nw la it nq b gy ob ny l nz oa"># save setup configuration<br/>save_config(product['config'])<br/>mlflow.log_artifact(product['config'])</span></pre><p id="5653" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">下面是 PyCaret <code class="fe nn no np nq b">setup</code>中使用的参数的简要说明:</p><ul class=""><li id="06d3" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe nn no np nq b">data</code>:训练数据框</li><li id="8b85" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">target</code>:目标变量的列名</li><li id="06ce" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">train_size</code>定义了用于训练的训练数据帧的比率。其余的将用作维持集。</li><li id="c63b" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">shuffle_fold</code>:设置为真，进行交叉验证时混洗数据</li><li id="4bb7" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">html</code>:设置为假，防止监视器运行时显示</li><li id="beca" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">silent</code>:设置为真，跳过输入数据类型的确认</li><li id="389e" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">experiment_name</code> : MLFlow 实验名称</li><li id="476b" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">log_experiment</code>:设置为 True，将度量、参数和工件记录到 MLFlow 服务器</li><li id="9d1e" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">fix_imbalance</code>:设置为 True，平衡目标类的分布。默认情况下，应用 SMOTE 为少数类创建合成数据点</li><li id="d5b1" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">numeric_imputation</code>:数值的插补方法，如平均值、中值或零</li><li id="f1fa" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">session_id</code>:控制实验的随机性。用于生成可重复的实验</li></ul><p id="8cd9" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">PyCaret 的<code class="fe nn no np nq b">compare_models</code>函数使用交叉验证来训练和评估模型库中所有可用估计器的性能，并输出一个带有平均交叉验证分数的分数网格。这些估计器在它们的默认超参数上被训练，在这个阶段没有超参数调整。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/f322236a759af2833e2d5f85a8447acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dOtq_z1rMQ8JHdmR"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="dc60" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">参数:</p><ul class=""><li id="0e48" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe nn no np nq b">include_models</code>:训练和评估模型的选择列表。请注意，我们已经使用细胞注射将此参数从<code class="fe nn no np nq b">pipeline.yaml</code>传递到笔记本中。</li><li id="92e9" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">sort</code>:根据选择的指标对输出结果进行排序</li><li id="25c7" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">n_select</code>:选择要返回的前 n 个型号</li></ul><p id="77ba" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">我们将<code class="fe nn no np nq b">n_select</code>定义为 1，因此只选择基于 AUC 的最佳模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/ee234200e72c21fb2d68c29bfa69b470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/0*mQUlkrh0tAVfvnI9"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="116b" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">接下来，我们使用<code class="fe nn no np nq b">tune_model</code>对逻辑回归模型进行超参数调整，选择基于 AUC 的最佳表现模型，并最终确定模型。Pycaret 的<code class="fe nn no np nq b">finalize_model</code>函数在包括维持集在内的整个数据集上训练给定的估计器。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="6ae6" class="nw la it nq b gy nx ny l nz oa">final_model = finalize_model(tune_model(best, choose_better = True, optimize = 'AUC'))</span></pre><p id="95ad" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><code class="fe nn no np nq b"><strong class="lt iu">visualize.ipynb</strong></code></p><p id="8907" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">在本笔记本中，我们使用 pandas-profiling[5]对清理后的数据进行基本的探索性描述性分析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/73e1629feb0c49dfe517b9656129f952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7yvb89yvRcHaLBPN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c083" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">在执行 Ploomber 管道之后，我们可以在由 product[' nb ']【T16]给出的文件路径中查看已执行的笔记本，其中填充了 pandas 分析结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/8c168394c913e14029aa64139493fe59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7eoQ5FKjbKe0ara4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1cdf" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><strong class="lt iu">可视化管道</strong></p><p id="d13a" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">让我们想象一下管道的样子。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="c518" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber plot</span></pre><p id="a805" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">此功能对于检查复杂的管线非常有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/ca7b39979363a974dff0e72fa7d9f76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/0*ffccUKG2s9oKGay1"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="6c59" class="nw la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">运行培训管道</h2><p id="e0ac" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们执行培训管道。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="1502" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber build</span><span id="769f" class="nw la it nq b gy ob ny l nz oa">#OR<br/>ploomber build -e pipeline.yaml</span></pre><p id="9890" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">默认情况下，Ploomber 寻找<code class="fe nn no np nq b">pipeline.yaml</code>文件作为入口点，因此显式定义入口点是可选的。这是成功运行后的终端输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/71a45bf82977fae1f5df35b3280c5d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/0*zEXAxyRP_ZTihuUX"/></div></figure><p id="47de" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">PyCaret 自动将结果记录到 MLFlow 中，并可在<code class="fe nn no np nq b">http://127.0.0.1:5000</code>通过 MLFlow UI 查看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f478ff90b6daa66e29aec06b2a2f0daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zxAAIkmpqX2DSndO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4a1e" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">请注意，本文的目的是演示 Ploomber、Pycaret 和 MLFlow 的使用，因此我们不会花费额外的精力来获得更好的模型结果。让我们选择使用 PyCaret 的<code class="fe nn no np nq b">finalize_model</code>训练的模型。记下<code class="fe nn no np nq b">model.pkl</code>文件的路径，我们稍后将需要这个文件用于服务管道。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/c343bfb13419909b666601ccdaaad749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eXsUxIq2TDvGBrNU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h2 id="07ac" class="nw la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">服务管道</h2><p id="0beb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">服务管道用于对新的未知数据进行预测。为了避免训练-服务-偏斜，看不见的数据应该经过与训练数据相同的数据处理步骤。我们可以通过修改<code class="fe nn no np nq b">upstream</code>和<code class="fe nn no np nq b">product</code>来重复使用<code class="fe nn no np nq b">clean_data.ipynb</code>笔记本。我们还需要另一个笔记本<code class="fe nn no np nq b">serve_model.ipynb</code>来对看不见的数据进行预测。</p><p id="4607" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">为服务管道创建<code class="fe nn no np nq b">pipeline.serve.yaml</code>。</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="dc5f" class="nw la it nq b gy nx ny l nz oa"># pipeline.serve.yaml</span><span id="0092" class="nw la it nq b gy ob ny l nz oa">meta:<br/>  extract_upstream: False</span><span id="16d5" class="nw la it nq b gy ob ny l nz oa">tasks:<br/>  - source: tasks/clean_data.ipynb<br/>    name: clean<br/>    product:<br/>      nb: products/clean_serve_data.ipynb<br/>      data: products/cleaned_serve_data.csv<br/>    params:<br/>      input_path: '{{root}}\\input_data\\diabetes_test.csv'</span><span id="6b68" class="nw la it nq b gy ob ny l nz oa">  - source: tasks/serve_model.ipynb<br/>    name: serve<br/>    upstream: ['clean']<br/>    product:<br/>      nb: products/serve_model.ipynb<br/>      data: products/predict_data.csv<br/>    params:<br/>      model_path: '{{root}}\\mlflow\\ml-artifacts\\1\\fb5528b6883748e9a200c43465126517\\artifacts\\model\\model'</span></pre><p id="a804" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">类似于我们在培训管道中创建笔记本的方式，从我们使用的<code class="fe nn no np nq b">pipeline.serve.yaml</code>中创建笔记本</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="8e29" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber scaffold -e pipeline.serve.yaml</span></pre><p id="e0c5" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">记得说明入口点，否则将使用默认的<code class="fe nn no np nq b">pipeline.yaml</code>入口点。接下来，我们使用以下方法将参数注入笔记本</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="c9ff" class="nw la it nq b gy nx ny l nz oa">ploomber nb --inject -e pipeline.serve.yaml</span></pre><p id="9c96" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">除了上述细胞注射命令引起的参数变化外，<code class="fe nn no np nq b">clean_data.ipynb</code>不需要进一步的代码变化。</p><p id="14df" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated"><code class="fe nn no np nq b"><strong class="lt iu">serve_model.ipynb</strong></code></p><p id="0519" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">笔记本电脑执行以下操作:</p><ol class=""><li id="6532" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm oc nf ng nh bi translated">加载已清理的不可见数据</li><li id="5110" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">从 MLFlow 加载模型</li><li id="2b4a" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">对已清理的不可见数据运行预测</li><li id="141a" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm oc nf ng nh bi translated">将预测保存到 csv 文件中</li></ol><p id="0914" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">单元注入创建了一个包含所需参数的附加单元</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/d25f21d28cff6c0da9ab5a677517b25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UFowHRRxf5gp6AUm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="d7df" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">下面是主要的服务代码</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="71ad" class="nw la it nq b gy nx ny l nz oa"># import packages<br/>import pandas as pd<br/>import mlflow<br/>from pycaret.classification import *</span><span id="c089" class="nw la it nq b gy ob ny l nz oa"># load data<br/>df = pd.read_csv(upstream['clean']['data'])</span><span id="c261" class="nw la it nq b gy ob ny l nz oa"># load model<br/>loaded_model = load_model(model_path)</span><span id="293f" class="nw la it nq b gy ob ny l nz oa"># predict<br/>df_result = predict_model(loaded_model, data = df, raw_score=True)</span><span id="d302" class="nw la it nq b gy ob ny l nz oa"># save results<br/>df_result.to_csv(product['data'], index = False)</span></pre><h2 id="4614" class="nw la it bd lb oe of dn lf og oh dp lj ma oi oj ll me ok ol ln mi om on lp oo bi translated">批量推断</h2><p id="6810" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用服务管道对新数据集运行批量推断</p><pre class="kj kk kl km gt ns nq nt nu aw nv bi"><span id="7b06" class="nw la it nq b gy nx ny l nz oa"># command line<br/>ploomber build -e pipeline.serve.yaml</span></pre><p id="130c" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">在每个<code class="fe nn no np nq b">ploomber build</code>期间，Ploomber 会复制一份已执行的笔记本，并将其存储为产品。我们可以在<code class="fe nn no np nq b">products/serve_model.ipynb</code>中查看笔记本及其电池输出。我们来看看<code class="fe nn no np nq b">df_result</code> DataFrame。<code class="fe nn no np nq b">Label</code>、<code class="fe nn no np nq b">Score_0</code>和<code class="fe nn no np nq b">Score_1</code>列是 PyCaret 附加到输入数据帧的预测结果。</p><ul class=""><li id="ff70" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><code class="fe nn no np nq b">Label</code>:预测类，0 或 1</li><li id="05ab" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">Score_0</code>:类 0 的概率</li><li id="177a" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><code class="fe nn no np nq b">Score_1</code>:第一类的概率</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/e385ce27b46a2e7730b7a340740795a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ag4664bLVIUgOpzD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="c42a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="fc87" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，我们研究了如何集成三个开源包——Ploomber、Pycaret 和 MLFlow，以构建机器学习训练和批量推理管道。Ploomber 使我们能够将管道构建为代码，这省去了直接在笔记本中编辑参数的麻烦，并允许使用 Git 对管道进行版本控制。PyCaret 通过简化预处理、训练和评估过程实现了快速实验，而 MLFlow 跟踪则确保了我们机器学习实验的高重现性。这些工具还有很多，请在下面的参考资料部分查看它们各自的文档。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><ul class=""><li id="8af4" class="mz na it lt b lu mu lx mv ma nb me nc mi nd mm ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/@edwin.tan/membership" rel="noopener">加入灵媒</a>阅读更多这样的故事</li><li id="306c" class="mz na it lt b lu ni lx nj ma nk me nl mi nm mm ne nf ng nh bi translated"><a class="ae ky" href="https://medium.com/@edwin.tan" rel="noopener">关注我</a>获取更多类似的帖子</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6ad8" class="kz la it bd lb lc pf le lf lg pg li lj jz ph ka ll kc pi kd ln kf pj kg lp lq bi translated">参考</h1><p id="c964" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">[1] <a class="ae ky" href="https://docs.ploomber.io/en/latest/get-started/basic-concepts.html" rel="noopener ugc nofollow" target="_blank">爆炸头</a></p><p id="0c38" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">[2] <a class="ae ky" href="https://mlflow.org/" rel="noopener ugc nofollow" target="_blank"> MLFlow </a></p><p id="a9d9" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">[3] <a class="ae ky" href="https://pycaret.gitbook.io/docs/" rel="noopener ugc nofollow" target="_blank"> PyCaret </a></p><p id="f21d" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">[4] <a class="ae ky" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank">皮马印第安人糖尿病数据集</a>，特许 CC0 公共领域</p><p id="fda4" class="pw-post-body-paragraph lr ls it lt b lu mu ju lw lx mv jx lz ma mw mc md me mx mg mh mi my mk ml mm im bi translated">[5] <a class="ae ky" href="https://github.com/ydataai/pandas-profiling" rel="noopener ugc nofollow" target="_blank">熊猫简介</a></p></div></div>    
</body>
</html>