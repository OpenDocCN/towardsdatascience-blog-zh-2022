<html>
<head>
<title>Don’t Use Python’s List Multiplication ([n] * N)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要用Python的列表乘法([n] * N)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dont-use-python-s-list-multiplication-n-n-450c68d673a3#2022-05-07">https://towardsdatascience.com/dont-use-python-s-list-multiplication-n-n-450c68d673a3#2022-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="8ec2" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">意见</h2><div class=""/><div class=""><h2 id="f755" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">这是个陷阱</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/78d70d810958a0e73d71eb44a43f0f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W4ILb6ckXnkWEUtQtSczjQ.jpeg"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae lh" href="https://www.pexels.com/photo/abstract-arachnid-art-black-and-white-206901/" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</p></figure><p id="09e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">无论您是新手还是有经验的Python程序员，都有可能使用过列表乘法和/或在那些“很酷的Python特性”风格的文章中读到过它。</p><p id="8f2d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是因为它无疑是那些旨在使您的Python生活更容易的很酷的特性之一。</p><p id="cac2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">列表乘法的好处是它抽象了初始化列表的过程。</p><p id="16cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">不使用迭代方法或列表理解:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="d586" class="mj mk it mf b gy ml mm l mn mo"># Iterative approach<br/>my_list = []<br/>for _ in range(N):<br/>    my_list.append(n)</span><span id="c38a" class="mj mk it mf b gy mp mm l mn mo"># List comprehension<br/>my_list = [n for _in range(N)]</span></pre><p id="0384" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以通过以下方式获得相同的结果:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="063f" class="mj mk it mf b gy ml mm l mn mo">my_list = [n] * N</span></pre><p id="3bec" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你看，我是按照以下顺序学习编程语言的:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="e062" class="mj mk it mf b gy ml mm l mn mo">C -&gt; C++ -&gt; MATLAB -&gt; R -&gt; Python.</span></pre><p id="7ac9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Python之前，我使用过的任何其他编程语言都无法提供如此的简洁和直观。</p><p id="ac57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，随着我开始编写越来越复杂的代码，列表乘法开始让我心烦。</p><p id="95a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我记得有一次我花了整整一个下午调试代码，结果发现问题源于使用<code class="fe mq mr ms mf b">*</code>操作符创建不正确的列表。</p><p id="7818" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我觉得有必要讨论一下这个问题，因为我知道一个事实，一些开发人员仍然没有注意到star操作符在列表创建方面的权衡。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="82ac" class="mj mk it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">列表乘法有什么问题</h2><p id="01a2" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">让我们考虑下面的代码:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="b795" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; my_list = [0] * 3<br/>&gt;&gt;&gt; my_list[0] = 1<br/>&gt;&gt;&gt; my_list<br/>[1, 0, 0]</span></pre><p id="d756" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是你所期望的。到目前为止，一切顺利。</p><p id="6966" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，让我们尝试使用相同的方法创建一个2D阵列:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="92fd" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; my_list = [[0] * 3] * 5<br/>&gt;&gt;&gt; my_list[0][0] = 1<br/>&gt;&gt;&gt; my_list<br/>[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]</span></pre><p id="94a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">嗯！这可能不是你想要的。</p><p id="b488" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过初始化一个3D数组来进一步推动它怎么样:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="151d" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; my_list = [[[0] * 3] * 5] * 2<br/>&gt;&gt;&gt; my_list[0][0][0] = 1<br/>&gt;&gt;&gt; my_list<br/>[[[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]], [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]]]</span></pre><p id="3b38" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">预期的输出是更新子列表<code class="fe mq mr ms mf b">[0, 0, 0]</code>的第一个值。然而，似乎这个更新在所有的子列表中都被复制了。</p><p id="3d5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，为什么会这样呢？</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="3f30" class="mj mk it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">列表乘法是如何工作的？</h2><p id="4b84" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">为了理解前面的行为，有必要重温一下Python的<a class="ae lh" href="https://docs.python.org/3/faq/programming.html#faq-multidimensional-list" rel="noopener ugc nofollow" target="_blank"> FAQ </a>，其中写道:</p><blockquote class="nv nw nx"><p id="a674" class="li lj ny lk b ll lm kd ln lo lp kg lq nz ls lt lu oa lw lx ly ob ma mb mc md im bi translated">原因是用<code class="fe mq mr ms mf b">*</code>复制一个列表不会创建副本，它只会创建对已有对象的引用</p></blockquote><p id="a2e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们将其转化为代码，以便更好地理解Python在幕后是如何操作的:</p><ul class=""><li id="6e9d" class="oc od it lk b ll lm lo lp lr oe lv of lz og md oh oi oj ok bi translated"><strong class="lk jd">列表乘法:</strong></li></ul><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="cc4a" class="mj mk it mf b gy ml mm l mn mo">my_list = [[0] * 5] * 5<br/>for i in range(5):<br/>    print(id(my_list[i]))</span></pre><p id="07ce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="0696" class="mj mk it mf b gy ml mm l mn mo">2743091947456<br/>2743091947456<br/>2743091947456<br/>2743091947456<br/>2743091947456</span></pre><ul class=""><li id="9a30" class="oc od it lk b ll lm lo lp lr oe lv of lz og md oh oi oj ok bi translated"><strong class="lk jd">使用for循环</strong></li></ul><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="20f2" class="mj mk it mf b gy ml mm l mn mo">my_list = []<br/>for _ in range(5):<br/>    my_list.append([0] * 5)</span><span id="16bf" class="mj mk it mf b gy mp mm l mn mo">for i in range(5):<br/>    print(id(my_list[i]))</span><span id="1b80" class="mj mk it mf b gy mp mm l mn mo">print(my_list)</span></pre><p id="3bcf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">输出:</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="2166" class="mj mk it mf b gy ml mm l mn mo">2743091947456<br/>2743095534208<br/>2743095532416<br/>2743095534336<br/>2743095532288</span></pre><ul class=""><li id="5b95" class="oc od it lk b ll lm lo lp lr oe lv of lz og md oh oi oj ok bi translated"><strong class="lk jd">释义</strong></li></ul><p id="b80f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">与<code class="fe mq mr ms mf b">for</code>循环不同，通过操作符<code class="fe mq mr ms mf b">*</code>复制的所有列表都指向同一个内存地址。这意味着影响一个嵌套列表的任何改变都会影响所有其他列表，这显然违背了我们的初衷。</p><p id="d955" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在的问题是:</p><ul class=""><li id="fa12" class="oc od it lk b ll lm lo lp lr oe lv of lz og md oh oi oj ok bi translated">为什么第一个例子<code class="fe mq mr ms mf b">([n] * N)</code>工作得很好，尽管列表中的所有元素都引用同一个对象？</li></ul><p id="38ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实证明，这种行为背后的原因(如Python的<a class="ae lh" href="https://en.wikibooks.org/wiki/Python_Programming/Lists#List_creation_shortcuts" rel="noopener ugc nofollow" target="_blank"> wikibook </a>中所述)是列表是可变项，而<code class="fe mq mr ms mf b">int, str</code>等是不可变的。看看这个:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/0a0b239de8335ecf3a85b5e9613e3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*-Rew-pDsLW5iFb4AUdzw2Q.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://community.insaid.co/hc/en-us/community/posts/360016423234-Mutable-vs-Immutable-in-Python-numpy-Pandas" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><p id="ce0d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因为不可变的对象不能被改变，所以当你更新列表中的一个条目时，Python会创建一个新的(不同的)对象引用。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="1a31" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; my_list = [0] * 3<br/>&gt;&gt;&gt; id(my_list[0])<br/>1271862264016<br/>&gt;&gt;&gt; my_list[0] = 1<br/>&gt;&gt;&gt; id(my_list[0])<br/>1271862264048</span></pre></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="9b4d" class="mj mk it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">工作区</h2><p id="e51c" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">解决这个问题的一个快速简单的方法是使用列表理解。当然，这是在标准的<code class="fe mq mr ms mf b">for</code>循环之外的。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="a10a" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; my_list = [[0] * 3 for _ in range(5)]<br/>&gt;&gt;&gt; my_list[0][0] = 1<br/>&gt;&gt;&gt; my_list<br/>[[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]</span></pre><p id="9cbf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，我们可以看到不同的内存地址被分配给每个列表。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="338d" class="mj mk it mf b gy ml mm l mn mo">&gt;&gt;&gt; my_list = [[0] * 3 for _ in range(5)]<br/>&gt;&gt;&gt; [id(l) for l in my_list]<br/>[1271867906112, 1271864321536, 1271864322048, 1271864326912, 1271864322560]</span></pre><p id="c9e5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">更重要的是，这种方法适用于所有场景。</p><p id="65a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，你为什么不坚持下去，为了安全起见，而不是在使用列表乘法之前必须三思呢？</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h2 id="37ad" class="mj mk it bd na nb nc dn nd ne nf dp ng lr nh ni nj lv nk nl nm lz nn no np iz bi translated">结论</h2><p id="8741" class="pw-post-body-paragraph li lj it lk b ll nq kd ln lo nr kg lq lr ns lt lu lv nt lx ly lz nu mb mc md im bi translated">我不是Pythonic句法糖的超级粉丝。</p><p id="d9cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">是的，我同意这有助于代码简洁明了。</p><p id="cedf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而<code class="fe mq mr ms mf b">conciseness == readability</code>在软件行业是什么时候？</p><p id="08c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">事实上，我用Python编写的代码越多，我就越倾向于使用Python标准语法和放弃快捷方式。</p><p id="a721" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">说到底，重要的是<em class="ny">性能</em>、<em class="ny">可维护性</em>，以及<em class="ny">可读性</em>。而不是你有多少行代码。</p><p id="0c23" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你不能没有捷径，至少读一读你正在使用的语法糖的好的、坏的和丑陋的。在这种情况下，可能需要对软件工程概念(即数据结构、内存分配……)有一定的理解。</p><p id="0b58" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ny">快乐编码！</em></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><p id="c9a8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ny">如果你觉得这个有用，可以考虑成为</em> <a class="ae lh" href="https://ayarmohammed96.medium.com/membership" rel="noopener"> <em class="ny">高级</em> </a> <em class="ny">会员。如果用这个</em> <a class="ae lh" href="https://ayarmohammed96.medium.com/membership" rel="noopener"> <em class="ny">链接</em> </a> <em class="ny">，我会得到一个小切。</em></p><div class="om on gp gr oo op"><a href="https://ayarmohammed96.medium.com/membership" rel="noopener follow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd jd gy z fp ou fr fs ov fu fw jc bi translated">通过我的推荐链接加入媒体-穆罕默德·阿亚尔</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">ayarmohammed96.medium.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd lb op"/></div></div></a></div></div></div>    
</body>
</html>