<html>
<head>
<title>What to Expect in Python 3.11</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 3.11有什么值得期待的</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-3-11-f62708eed569#2022-04-06">https://towardsdatascience.com/python-3-11-f62708eed569#2022-04-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="c9e5" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">探索Python 3.11中的新增内容和更新，以及如何尽早获得3.11 Alpha版本</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/c39087c39630340e645006c36730f128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UYcp2CWlau25j8KdOo_cCg.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kz" href="https://unsplash.com/s/photos/python-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h2 id="a5a1" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">介绍</h2><p id="26a7" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Python最新版本3.11预计将于2022年10月发布，尽管alpha版本(<code class="fe mp mq mr ms b">3.11.0a6</code>)已经发布。</p><p id="1305" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">今天，我们将讨论最新版本预计将提供的更新和新增功能，并展示如何安装3.11 Alpha版本，以便在正式发布之前习惯新功能。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="f29c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何安装Python 3.11 Alpha</h2><p id="2b8b" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在新Python版本的最终发布之前，新特性已经实现并测试了大约五个月。因此，alpha阶段预计将于2022年5月结束。</p><p id="b23f" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">一个新的alpha版本将(大约)每月发布一次，这样核心开发人员就可以提前访问并在需要时进行调整。在撰写本文时，第六个alpha版本已经发布(即<code class="fe mp mq mr ms b">3.11.0a6</code> )—如果您想确保最新的alpha版本可用，您可以简单地参考<a class="ae kz" href="https://docs.python.org/3.11/whatsnew/3.11.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="6922" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">下面你可以找到关于如何在你的本地机器上安装Python 3.11 alpha版本的所有相关信息，以便试验和习惯新特性，或者甚至向社区提供一些反馈。</p><p id="1955" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><strong class="ly iv">对接</strong>安装<strong class="ly iv">安装</strong></p><p id="a1d3" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">如果你想通过Docker安装Python 3.11 alpha版本，那么你首先需要拉<code class="fe mp mq mr ms b"><a class="ae kz" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank">python:3.11-rc-slim</a></code>镜像</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="d79f" class="la lb iu ms b gz nj nk l nl nm">$ docker pull python:3.11-rc-slim</span></pre><p id="bdc4" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">最后运行它</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="0b44" class="la lb iu ms b gz nj nk l nl nm">$ docker run -it --rm python:3.11-rc-slim</span></pre><p id="5fed" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><strong class="ly iv"> Ubuntu安装</strong></p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="71b7" class="la lb iu ms b gz nj nk l nl nm">$ <!-- -->sudo apt update &amp;&amp; sudo apt upgrade -y<br/>$ sudo apt install software-properties-common -y<br/>$ sudo add-apt-repository ppa:deadsnakes/ppa -y<br/>$ sudo add-apt-repository ppa:deadsnakes/nightly -y<br/>$ <!-- -->sudo apt update<br/>$ sudo apt install python3.11</span></pre><p id="d6f5" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">现在应该已经安装了Python 3.11 alpha，但是您可能还需要安装一些额外的组件(例如，如果您希望能够创建一个虚拟环境):</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="6568" class="la lb iu ms b gz nj nk l nl nm">$ sudo apt install python3.11-dev<br/>$ sudo apt install python3.11-venv<br/>$ sudo apt install python3.11-distutils<br/>$ <!-- -->sudo apt install python3.11-lib2to3<br/>$ sudo apt install python3.11-gdbm<br/>$ sudo apt install python3.11-tk</span></pre><p id="a29d" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><strong class="ly iv"> OSX安装</strong></p><p id="3e45" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">对于Mac用户来说，<code class="fe mp mq mr ms b">.pkg</code>安装可以在<a class="ae kz" href="https://www.python.org/downloads/macos/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中找到。可用的最新alpha版本将在预发布部分的右侧列出。</p><p id="58f2" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><strong class="ly iv"> Windows安装</strong></p><p id="3595" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">为了在你的Windows机器上安装Python Alpha版本，你可以使用<code class="fe mp mq mr ms b"><a class="ae kz" href="https://pyenv-win.github.io/pyenv-win/" rel="noopener ugc nofollow" target="_blank">pyenv-win</a></code>。</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="3935" class="la lb iu ms b gz nj nk l nl nm">C:\&gt; pyenv update<br/>C:\&gt; pyenv install 3.11.0a6</span></pre><p id="1c06" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">安装完成后，您可以继续使用您在上一步中指定的Python Alpha版本创建和激活虚拟环境:</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="7450" class="la lb iu ms b gz nj nk l nl nm">C:\&gt; pyenv local 3.11.0a6<br/>C:\&gt; python -m venv myenv<br/>C:\&gt; myenv\Scripts\activate.bat</span></pre></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="f152" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">更好的错误消息</h2><p id="f8bf" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">第一个主要更新与标准输出中出现错误时的回溯相关。更准确地说，Python 3.11预计在报告的回溯中有一个<strong class="ly iv">增强的错误位置。</strong></p><p id="33da" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">以前的Python版本的解释器只会指向导致错误的特定行。由于不清楚是哪个表达式或对象触发了所报告的错误，这一点相当模糊。</p><p id="d201" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">例如，假设在我们名为<code class="fe mp mq mr ms b">test.py</code>的脚本中，我们通过传递两个参数，即<code class="fe mp mq mr ms b">a</code>和<code class="fe mp mq mr ms b">b</code>，调用了<code class="fe mp mq mr ms b">my_test_function()</code>方法，其中后者是<code class="fe mp mq mr ms b">None</code>。现在，如果我们试图在<code class="fe mp mq mr ms b">None</code>对象上使用一个属性，我们将以<code class="fe mp mq mr ms b">AttributeError</code>结束。</p><p id="5b16" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">通过增强的错误定位，回溯将指向特定的函数调用以及导致<code class="fe mp mq mr ms b">AttributeError</code>的特定表达式，如下所示。</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="4e85" class="la lb iu ms b gz nj nk l nl nm">Traceback (most recent call last):<br/>  File "test.py", line 15, <strong class="ms iv">in</strong> &lt;module&gt;<br/>    print(my_test_function(a, b))<br/>          ^^^^^^^^^^^^^^^^^^^^^^^<br/>  File "test.py", line 3, <strong class="ms iv">in</strong> my_test_function<br/>    <strong class="ms iv">return</strong> abs(param1.x - param2.x) + abs(param1.y - param2.y)<br/>                          ^^^^^^^^<br/><strong class="ms iv">AttributeError</strong>: 'NoneType' object has no attribute 'x'</span></pre><p id="b56a" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">这在处理<strong class="ly iv">深度嵌套对象</strong>时也非常有用，比如字典。举个例子，</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="1abf" class="la lb iu ms b gz nj nk l nl nm">Traceback (most recent call last):<br/>  File "test.py", line 37, <strong class="ms iv">in</strong> &lt;module&gt;<br/>    extract_msg('my_key')<br/>    ^^^^^^^^^^^^^^^^^^^^^<br/>  File "test.py", line 18, <strong class="ms iv">in</strong> extract_msg<br/>    <strong class="ms iv">return</strong> extract_counts(x)<br/>           ^^^^^^^^^^^^^^^^<br/>  File "test.py", line 24, <strong class="ms iv">in</strong> extract_counts<br/>    <strong class="ms iv">return</strong> query_nums(x)<br/>           ^^^^^^^^^^^^^<br/>  File "test.py", line 32, <strong class="ms iv">in</strong> query_nums<br/>    <strong class="ms iv">return </strong>response['a']['b']['c']['nums']<br/>                   ~~~~~~~~~~~~~~~^^^^^^^^<br/><strong class="ms iv">TypeError</strong>: 'NoneType' object <strong class="ms iv">is</strong> <strong class="ms iv">not</strong> subscriptable</span></pre><p id="cd99" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">此外，在处理复杂的数学表达式时，这也很有帮助。假设我们试图将一个数除以0。新的误差符号将指向我们试图执行这个无效除法的精确位置。</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="f38b" class="la lb iu ms b gz nj nk l nl nm">Traceback (most recent call last):<br/>  File "test.py", line 54, <strong class="ms iv">in</strong> &lt;module&gt;<br/>    print((x / y / z) * (a / b))<br/>           ~~~~~~~~^<br/><strong class="ms iv">ZeroDivisionError</strong>: division by zero</span></pre><p id="4e97" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">有关此更新的更多详细信息，您可以参考<a class="ae kz" href="https://peps.python.org/pep-0657/" rel="noopener ugc nofollow" target="_blank"> <strong class="ly iv"> PEP-657 </strong> </a>。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="007c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用except*进行多重异常处理</h2><p id="c53f" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Python 3.11中另一个有趣的语言扩展与多重异常处理相关。这个特性将允许程序同时引发和处理多个异常(甚至是不相关的)。</p><p id="965c" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">这个功能是由一个新的标准异常类型<code class="fe mp mq mr ms b">ExceptionGroup</code>提供的，它对应于一组正在一起传播的异常。新的<code class="fe mp mq mr ms b">ExceptionGroup</code>将使用新的<code class="fe mp mq mr ms b">except*</code>语法来处理。<code class="fe mp mq mr ms b">*</code>符号表示每个<code class="fe mp mq mr ms b">except*</code>子句可以处理多个异常。</p><p id="e2f3" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">例如，为了引发多个异常，您可以创建一个<code class="fe mp mq mr ms b">ExceptionGroup</code>的实例:</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="b873" class="la lb iu ms b gz nj nk l nl nm">raise ExceptionGroup('Example Exception Group', (<br/>    TypeError('Example TypeError'),<br/>    ValueError('Example ValueError'),<br/>    KeyError('Example KeyError'),<br/>    AttributeError('Example AttributeError')<br/>))</span></pre><p id="5dc3" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">最后使用<code class="fe mp mq mr ms b">except*</code>在一个子句中处理来自<code class="fe mp mq mr ms b">ExceptionGroup</code>的单个或多个异常，如下所示:</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="fe07" class="la lb iu ms b gz nj nk l nl nm">try:<br/>    raise ExceptionGroup('Example ExceptionGroup', (<br/>        TypeError('Example TypeError'),<br/>        ValueError('Example ValueError'),<br/>        KeyError('Example KeyError'),<br/>        AttributeError('Example AttributeError')<br/>    ))<br/>except* TypeError:<br/>    ...<br/>except* ValueError as e:<br/>    ...<br/>except* (KeyError, AttributeError) as e:<br/>    ...</span></pre><p id="4161" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">有关此次更新背后的更多细节和理由，您可以参考<a class="ae kz" href="https://peps.python.org/pep-0654/" rel="noopener ugc nofollow" target="_blank"> <strong class="ly iv"> PEP-654 </strong> </a> <strong class="ly iv">。</strong></p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="63cb" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">名为Self的新打字功能</h2><p id="9011" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Python 3.11还将实现一种更直观的方式来注释返回类实例的方法。</p><p id="1ae8" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">到目前为止，我们可以通过<a class="ae kz" href="https://peps.python.org/pep-0484/" rel="noopener ugc nofollow" target="_blank"> PEP-484 </a>中描述的<code class="fe mp mq mr ms b">TypeVar</code>方法实现相同的行为，但这个新功能肯定更简单，也更直观。</p><p id="1413" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">例如，假设我们有一个<code class="fe mp mq mr ms b">Person</code>类，它有一个名为<code class="fe mp mq mr ms b">update_name</code>的实例方法，该方法返回一个<code class="fe mp mq mr ms b">Person</code>类的实例。使用<code class="fe mp mq mr ms b">TypeVar</code>符号，类型提示将如下所示。</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="9e98" class="la lb iu ms b gz nj nk l nl nm">from typing import TypeVar</span><span id="c752" class="la lb iu ms b gz nn nk l nl nm">TPerson = TypeVar('TPerson', bound='Person')</span><span id="9438" class="la lb iu ms b gz nn nk l nl nm"><br/>class Person:<br/>    def update_name(self: TPerson, name: str) -&gt; TPerson:<br/>        self.name = name<br/>        return self</span></pre><p id="172f" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">这种旧的符号非常不直观，而且不必要地冗长。随着Python 3.11中的新增加，这被简化为</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="9a9b" class="la lb iu ms b gz nj nk l nl nm">from typing import Self</span><span id="57cd" class="la lb iu ms b gz nn nk l nl nm">class Person:<br/>    def update_name(self, name: str) -&gt; Self:<br/>        self.name = name<br/>        return self</span></pre><p id="3ce6" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">更干净，更直观，对吧？</p><p id="9909" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">有关此次更新的更多详情，您可以参考<a class="ae kz" href="https://peps.python.org/pep-0673/" rel="noopener ugc nofollow" target="_blank"> <strong class="ly iv"> PEP-673 </strong> </a> <strong class="ly iv">。</strong></p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="21b9" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一个解析TOML文件的新模块</h2><p id="828e" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">Python 3.11将带来一个名为<code class="fe mp mq mr ms b"><a class="ae kz" href="https://docs.python.org/3.11/library/tomllib.html#module-tomllib" rel="noopener ugc nofollow" target="_blank">tomllib</a></code>的全新模块，添加它是为了方便TOML解析。注意，该模块不支持编写TOML(至少暂时不支持)。</p><p id="7aae" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><code class="fe mp mq mr ms b">tomllib</code>可用于从文件中加载TOML</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="77b6" class="la lb iu ms b gz nj nk l nl nm">import tomllib<strong class="ms iv"><br/></strong><br/>with open('settings.toml', 'rb') as f:<br/>    data = tomllib.load(f)</span></pre><p id="6cdc" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">或字符串:</p><pre class="kk kl km kn gu nf ms ng nh aw ni bi"><span id="675f" class="la lb iu ms b gz nj nk l nl nm">import tomllib<strong class="ms iv"><br/></strong><br/>settings = """<br/>python-version = "3.11.0"<br/>python-implementation = "CPython"<br/>"""<br/><br/>data = tomllib.loads(settings)</span></pre><p id="7462" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">有关这一新增内容的更多详情，您可以参考<a class="ae kz" href="https://bugs.python.org/issue40059" rel="noopener ugc nofollow" target="_blank"> bpo-40050 </a>。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="d08c" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一些单元测试函数现在已被弃用</h2><p id="f5d9" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">除了新的增加和更新，Python 3.11预计还会有一些函数被弃用。其中一些包括<code class="fe mp mq mr ms b">unittest</code>模块中的三个函数。这些是</p><ul class=""><li id="5bf5" class="no np iu ly b lz mt mc mu lj nq ln nr lr ns mo nt nu nv nw bi translated"><code class="fe mp mq mr ms b">unittest.findTestCases()</code></li><li id="16e8" class="no np iu ly b lz nx mc ny lj nz ln oa lr ob mo nt nu nv nw bi translated"><code class="fe mp mq mr ms b">unittest.makeSuite()</code></li><li id="066e" class="no np iu ly b lz nx mc ny lj nz ln oa lr ob mo nt nu nv nw bi translated"><code class="fe mp mq mr ms b">unittest.getTestCaseNames()</code></li></ul><p id="a827" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">并且<strong class="ly iv">计划在Python 3.13 </strong>中移除。相反，用户现在应该使用<code class="fe mp mq mr ms b"><a class="ae kz" href="https://docs.python.org/3.11/library/unittest.html#unittest.TestLoader" rel="noopener ugc nofollow" target="_blank">TestLoader</a></code>模块中的相应方法。</p><ul class=""><li id="d1ac" class="no np iu ly b lz mt mc mu lj nq ln nr lr ns mo nt nu nv nw bi translated"><code class="fe mp mq mr ms b"><a class="ae kz" href="https://docs.python.org/3.11/library/unittest.html#unittest.TestLoader.loadTestsFromModule" rel="noopener ugc nofollow" target="_blank">unittest.TestLoader.loadTestsFromModule()</a></code></li><li id="2342" class="no np iu ly b lz nx mc ny lj nz ln oa lr ob mo nt nu nv nw bi translated"><code class="fe mp mq mr ms b"><a class="ae kz" href="https://docs.python.org/3.11/library/unittest.html#unittest.TestLoader.loadTestsFromTestCase" rel="noopener ugc nofollow" target="_blank">unittest.TestLoader.loadTestsFromTestCase()</a></code></li><li id="35c1" class="no np iu ly b lz nx mc ny lj nz ln oa lr ob mo nt nu nv nw bi translated"><code class="fe mp mq mr ms b"><a class="ae kz" href="https://docs.python.org/3.11/library/unittest.html#unittest.TestLoader.getTestCaseNames" rel="noopener ugc nofollow" target="_blank">unittest.TestLoader.getTestCaseNames()</a></code></li></ul><p id="cfa0" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">有关这一新增内容的更多详情，您可以参考<a class="ae kz" href="https://bugs.python.org/issue5846" rel="noopener ugc nofollow" target="_blank"> bpo-5846 </a>。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="1cd4" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">CPython性能优化</h2><p id="6788" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">与以前的版本相比，3.11版本中的CPython解释器有望得到更好的优化和更快的速度。</p><p id="daea" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">有关具体操作的性能提升的更多详细信息，您可以参考下面分享的推文中发布的表格。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oc od l"/></div></figure><p id="7f24" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">你也可以在<a class="ae kz" href="https://github.com/tonybaloney/anti-patterns/blob/master/suite.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到描述这些操作的原始代码。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><h2 id="78f3" class="la lb iu bd lc ld le dn lf lg lh dp li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最后的想法</h2><p id="c406" class="pw-post-body-paragraph lw lx iu ly b lz ma jv mb mc md jy me lj mf mg mh ln mi mj mk lr ml mm mn mo in bi translated">在今天的文章中，我们讨论了令人兴奋的新增内容和更新，预计将于10月初发布Python 3.11版本。</p><p id="40b6" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">总而言之，在Python 3.11中，我们期望通过回溯中更细粒度的错误位置看到更直观的错误消息。此外，我们还探索了称为<code class="fe mp mq mr ms b">ExceptionGroup</code>的新标准异常类型，它可用于传播多个异常，以及用于在单个子句中处理多个异常的新<code class="fe mp mq mr ms b">except*</code>子句。</p><p id="d13e" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">此外，我们讨论了名为<code class="fe mp mq mr ms b">Self</code>的新类型特性，它提供了一种更直观的方式来注释返回类实例的方法。我们还展示了如何使用新添加的模块<code class="fe mp mq mr ms b">tomllib</code>从文件和字符串中解析TOML。</p><p id="d867" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">此外，我们还讨论了在Python 3.11中被弃用并在3.13中被删除的<code class="fe mp mq mr ms b">unittest</code>函数，以及CPython解释器中一些重要的性能优化，预计与以前的版本相比会明显更快。</p><p id="ef2e" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">最后，我们还展示了如何安装最新的可用alpha版本，以防您想要试验新特性，习惯它们，或者甚至向社区和正在积极开发该版本的核心开发人员提供一些反馈。</p><p id="dc07" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated">要更全面地了解3.11版本，你可以阅读<a class="ae kz" href="https://docs.python.org/3.11/whatsnew/3.11.html#what-s-new-in-python-3-11" rel="noopener ugc nofollow" target="_blank">官方文档</a>的相应章节。在本文中，我们讨论了一小部分即将到来的更新。更多的反对意见，模块更新和补充可以在上面的链接中找到。</p></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="1b77" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><a class="ae kz" href="https://gmyrianthous.medium.com/membership" rel="noopener"> <strong class="ly iv">成为会员</strong> </a> <strong class="ly iv">阅读介质上的每一个故事。你的会员费直接支持我和你看的其他作家。你也可以在媒体上看到所有的故事。</strong></p><div class="oe of gq gs og oh"><a href="https://gmyrianthous.medium.com/membership" rel="noopener follow" target="_blank"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd iv gz z fq om fs ft on fv fx it bi translated">通过我的推荐链接加入Medium-Giorgos Myrianthous</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">gmyrianthous.medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kt oh"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><p id="676e" class="pw-post-body-paragraph lw lx iu ly b lz mt jv mb mc mu jy me lj mv mg mh ln mw mj mk lr mx mm mn mo in bi translated"><strong class="ly iv">相关文章您可能也喜欢</strong></p><div class="oe of gq gs og oh"><a rel="noopener follow" target="_blank" href="/requirements-vs-setuptools-python-ae3ee66e28af"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd iv gz z fq om fs ft on fv fx it bi translated">Python中的requirements.txt与setup.py</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">了解Python中requirements.txt、setup.py和setup.cfg在开发和分发时的用途…</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov kt oh"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oh"><a rel="noopener follow" target="_blank" href="/pycache-python-991424aabad8"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd iv gz z fq om fs ft on fv fx it bi translated">Python中__pycache__是什么？</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">了解运行Python代码时创建的__pycache__文件夹</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov kt oh"/></div></div></a></div></div><div class="ab cl my mz hy na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="in io ip iq ir"><div class="kk kl km kn gu oh"><a rel="noopener follow" target="_blank" href="/python-iterables-vs-iterators-688907fd755f"><div class="oi ab fp"><div class="oj ab ok cl cj ol"><h2 class="bd iv gz z fq om fs ft on fv fx it bi translated">Python中的Iterables vs迭代器</h2><div class="oo l"><h3 class="bd b gz z fq om fs ft on fv fx dk translated">理解Python中Iterables和迭代器的区别</h3></div><div class="op l"><p class="bd b dl z fq om fs ft on fv fx dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="oy l os ot ou oq ov kt oh"/></div></div></a></div></div></div>    
</body>
</html>