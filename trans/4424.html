<html>
<head>
<title>3 Data Structures for Faster Python Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更快的Python列表的3种数据结构</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-data-structures-for-faster-python-lists-f29a7e9c2f92#2022-09-30">https://towardsdatascience.com/3-data-structures-for-faster-python-lists-f29a7e9c2f92#2022-09-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="13cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">明智地选择你的清单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6a59407832e727f3b31ba3de4f8b13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TS2PTluJIPfcvx_v"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="1429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都知道列表是条目的集合，但是也存在其他类似列表的数据结构，可以根据您打算如何使用列表来优化您的Python代码。</p><p id="3935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认的Python列表确实有它的魅力——它简单、易于理解和使用。然而，在LeetCode上花了一些时间后，我意识到在某些情况下它可能不是最好的数据结构。例如在这个<a class="ae ky" href="https://leetcode.com/problems/numbers-with-same-consecutive-differences/" rel="noopener ugc nofollow" target="_blank"> LeetCode challenge </a>中，保持相同的逻辑但是简单地使用另一个数据结构将我的提交运行时间从<a class="ae ky" href="https://leetcode.com/submissions/detail/790170154/" rel="noopener ugc nofollow" target="_blank">99毫秒</a>减少到了<a class="ae ky" href="https://leetcode.com/submissions/detail/790183509/" rel="noopener ugc nofollow" target="_blank">33毫秒</a>！这可能看起来不算多，但是想象一下如果它被扩展，可以节省多少时间。我还必须补充一点，运行时间可能是随机的，匆忙得出它总能提供3倍加速的结论是不正确的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/cbf84b8709cca427d6b8e511750f0a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdRhfuokyb1d5xbe2AHupg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:使用列表的提交运行时(下图)与heapq(上图)——作者图片</p></figure><p id="a445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将介绍另一种类似列表的数据结构，何时使用它们，以及如何通过Python示例应用它们。</p><h1 id="bde9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">目录</h1><ul class=""><li id="2622" class="mp mq it lb b lc mr lf ms li mt lm mu lq mv lu mw mx my mz bi translated"><a class="ae ky" href="https://medium.com/p/f29a7e9c2f92/#e9a2" rel="noopener">维护优先级列表</a></li><li id="81a4" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated"><a class="ae ky" href="https://medium.com/p/f29a7e9c2f92/#cda4" rel="noopener">维护排序列表</a></li><li id="aae7" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated"><a class="ae ky" href="https://medium.com/p/f29a7e9c2f92/#490f" rel="noopener">维护列表中的顺序和容量</a></li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="e9a2" class="lx ly it bd lz ma nm mc md me nn mg mh jz no ka mj kc np kd ml kf nq kg mn mo bi translated">维护优先级列表</h1><blockquote class="nr ns nt"><p id="fe69" class="kz la lv lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">使用<code class="fe nx ny nz oa b"><strong class="lb iu">heapq</strong></code>更快地检索列表中最小和最大的项目(以及更多)</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/b53e1a10e4c387beaf05f1e0d33f32f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*y_quGw7HluRR5z4a6bAajw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2: <a class="ae ky" href="https://en.wikipedia.org/wiki/Heap_(data_structure)" rel="noopener ugc nofollow" target="_blank">堆</a>队列结构——作者图片</p></figure><p id="26ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">heapq</strong></code>使用堆队列算法，二叉树的设计使得任何子节点的值都大于父节点的值。这导致最小的元素位于树的根节点，任何新项目的插入都将通过“洗牌”找到它在树中的位置。在理解了二叉树是如何设计的之后，重要的是要注意这并不能保证一个<em class="lv">精确的</em>排序列表，而仅仅是一个排序的二叉树，类似于图2。堆队列也称为优先级队列，因为优先级被给予树顶部的项目，并且移除该项目很容易“洗牌”或重新排列剩余节点的优先级。</p><p id="6768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行高层次的比较，在通常的Python列表中，条目是按顺序添加的，比如<code class="fe nx ny nz oa b">appends</code>在列表的后面添加一个新条目，而<code class="fe nx ny nz oa b">pop</code>移除并返回列表中的最后一个条目。在堆队列结构中，<code class="fe nx ny nz oa b">heappop</code>移除并返回列表中最小的<em class="lv">项，<code class="fe nx ny nz oa b">heappush</code>向列表中添加新项，同时保持已排序的二叉树结构。</em></p><p id="c12d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">何时使用<code class="fe nx ny nz oa b"><strong class="lb iu">heapq</strong></code>，</p><ul class=""><li id="2282" class="mp mq it lb b lc ld lf lg li oc lm od lq oe lu mw mx my mz bi translated">用于检索和删除列表中最小的项目</li><li id="a138" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于检索列表中最小和最大项目的编号</li><li id="68a2" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于在添加新项目或合并两个堆后保留排序的二叉树</li></ul><p id="8c02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe nx ny nz oa b"><strong class="lb iu">heapq</strong></code>，我们可以将一个空的或填充的列表转换成一个堆，</p><pre class="kj kk kl km gt of oa og bn oh oi bi"><span id="07bf" class="oj ly it oa b be ok ol l om on">import heapq<br/><br/>heap = [5, 2, 4, 7, 6]<br/><br/>heapq.heapify(heap)<br/># heap = [2, 5, 4, 7, 6] -&gt; sorted binary tree<br/>#      2<br/>#   5     4<br/>#  7  6</span></pre><p id="bdeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了转换堆，可以这样进行对堆的项目的检索和添加，</p><pre class="kj kk kl km gt of oa og bn oh oi bi"><span id="95c2" class="oj ly it oa b be ok ol l om on"># Pop (retrieve and remove) smallest item<br/>smallest_item = heapq.heappop(heap)   # smallest_item = 2<br/><br/># Retrieve n-number of smallest and largest item<br/>smallest2 = heapq.nsmallest(2, heap)  # smallest2 = [4, 5]<br/>largest2 = heapq.nlargest(2, heap)    # largest2 = [6, 7]<br/><br/># Push (add) new item<br/>heapq.heappush(heap, 3)<br/><br/># Push then Pop<br/>smallest_item_after_add = heapq.heappushpop(heap, 1)<br/># smallest_item_after_add = 1, heap = [3, 4, 6, 7, 5]<br/><br/># Pop then Push<br/>smallest_item_before_add = heapq.heapreplace(heap, 1)<br/># smallest_item_before_add = 3, heap = [1, 4, 6, 7, 5]</span></pre><p id="3f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，可以使用一个<code class="fe nx ny nz oa b">merge</code>方法来合并多个堆，并保留排序后的二叉树结构。请注意，<code class="fe nx ny nz oa b">merge</code>的输入应该是一个堆(遵循排序二叉树结构的列表),而不是任何列表！</p><pre class="kj kk kl km gt of oa og bn oh oi bi"><span id="dc0b" class="oj ly it oa b be ok ol l om on"># Merge two lists<br/>heap1 = [1, 3, 5, 7]<br/>heap2 = [2, 4, 6, 8]<br/>merged_heap = heapq.merge(*[heap1, heap2])<br/># list(merged_heap) = [1, 2, 3, 4, 5, 6, 7, 8]</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="cda4" class="lx ly it bd lz ma nm mc md me nn mg mh jz no ka mj kc np kd ml kf nq kg mn mo bi translated">维护排序列表</h1><blockquote class="nr ns nt"><p id="7753" class="kz la lv lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">使用<code class="fe nx ny nz oa b"><strong class="lb iu"><em class="it">bisect</em></strong></code>检索列表中最接近的值(以及更多)</p></blockquote><p id="7a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">bisect</strong></code>与其说是一个数据结构，不如说是一个二分法，帮助你定位和/或插入条目到一个保持顺序的排序列表中。</p><p id="b75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单介绍一下，Python使用了平均时间复杂度为<code class="fe nx ny nz oa b">O(nlogn)</code>的<a class="ae ky" href="https://en.wikipedia.org/wiki/Timsort" rel="noopener ugc nofollow" target="_blank"> Timsort </a>排序算法。这种排序算法很快，但是，在你的列表上连续调用<code class="fe nx ny nz oa b">sort()</code>可能并不可取，最好还是维护一个排序后的列表。</p><p id="eb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，二分法只适用于已经排序的列表，而不适用于未排序的列表！将项目插入到(排序的)列表中可以如下完成，</p><pre class="kj kk kl km gt of oa og bn oh oi bi"><span id="acba" class="oj ly it oa b be ok ol l om on">import bisect<br/><br/>a = [1, 2, 2, 2, 6, 7]<br/><br/># Insert item to preserve sorted list (in-place)<br/>bisect.insort(a, 5)<br/># a = [1, 2, 2, 2, 5, 6, 7]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/00b875e57d861a4d64e04b6e460b8463.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*07eZjkQ22EpT1bD0oOCn6g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3:检索应该插入条目的索引—按作者排序的图片</p></figure><p id="64f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<code class="fe nx ny nz oa b">bisect</code>中发现的另一个有用的特性是，它可以返回应该插入条目的列表索引。在图3中，<code class="fe nx ny nz oa b"><strong class="lb iu">bisect.bisect</strong>(list, 4)</code>方法将返回索引4，其中数字<code class="fe nx ny nz oa b">4</code>应该被插入到排序列表中。如果值已经存在，我们可以使用<code class="fe nx ny nz oa b"><strong class="lb iu">bisect.bisect_left</strong>(list, 7)</code>或<code class="fe nx ny nz oa b"><strong class="lb iu">bisect.bisect_right</strong>(list, 7)</code>来指示数字<code class="fe nx ny nz oa b">7</code>是应该插入到现有值的左边还是右边，并相应地返回索引。默认情况下，<code class="fe nx ny nz oa b"><strong class="lb iu">bisect</strong>()</code>实现<code class="fe nx ny nz oa b"><strong class="lb iu">bisect_right</strong>()</code>。</p><p id="eb37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nx ny nz oa b"><strong class="lb iu">bisect</strong>()</code>检索索引也是在列表中找到与您要‘插入’的值最接近的条目的一种快捷方式。例如，如果我想找到大于或等于4的最小数字，我可以使用<code class="fe nx ny nz oa b"><strong class="lb iu">bisect_left</strong>()</code>来获取索引并相应地检索值。</p><p id="8f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">何时使用<code class="fe nx ny nz oa b"><strong class="lb iu">bisect</strong></code>，</p><ul class=""><li id="ec7c" class="mp mq it lb b lc ld lf lg li oc lm od lq oe lu mw mx my mz bi translated">用于向保持列表顺序的排序列表添加项目</li><li id="363e" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">为了检索索引，插入一个保持列表顺序的值</li><li id="74de" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于检索排序列表中大于<code class="fe nx ny nz oa b">x</code>的最小值</li><li id="832e" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于检索排序列表中小于<code class="fe nx ny nz oa b">x</code>的最大值</li></ul></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="490f" class="lx ly it bd lz ma nm mc md me nn mg mh jz no ka mj kc np kd ml kf nq kg mn mo bi translated">维护列表中的顺序和容量</h1><blockquote class="nr ns nt"><p id="a4fc" class="kz la lv lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">使用<code class="fe nx ny nz oa b"><strong class="lb iu"><em class="it">deque</em></strong></code>实现类似队列的列表</p></blockquote><p id="0e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz oa b"><strong class="lb iu">deque</strong></code>代表双端队列，允许快速添加和删除列表前面和后面的项目，这使得表示队列结构变得容易。当列表达到最大容量时，也可以实现列表的容量，以在后面添加项目时移除前面的项目，反之亦然。</p><p id="0963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于比较，<code class="fe nx ny nz oa b"><strong class="lb iu">deque</strong></code>提供了与普通Python列表中的<code class="fe nx ny nz oa b">O(n)</code>时间复杂度相比的<code class="fe nx ny nz oa b">O(1)</code>条目添加和移除的时间复杂度。</p><p id="01c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常的列表操作，如<code class="fe nx ny nz oa b">index</code>、<code class="fe nx ny nz oa b">count</code>、<code class="fe nx ny nz oa b">extend</code>、<code class="fe nx ny nz oa b">reverse</code>、<code class="fe nx ny nz oa b">remove,</code>等。还在<code class="fe nx ny nz oa b"><strong class="lb iu">deque</strong></code>上班。</p><p id="eaf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">何时使用<code class="fe nx ny nz oa b"><strong class="lb iu">deque</strong></code>，</p><ul class=""><li id="9ccd" class="mp mq it lb b lc ld lf lg li oc lm od lq oe lu mw mx my mz bi translated">用于将项目添加到列表的前面和/或后面</li><li id="fbdb" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于从列表的前面和/或后面移除项目</li><li id="4528" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于将项目从队列的后面移到前面，反之亦然(循环队列)</li><li id="9f79" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">用于实施列表容量</li></ul><p id="87fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一些如何使用<code class="fe nx ny nz oa b"><strong class="lb iu">deque</strong></code>的例子，</p><pre class="kj kk kl km gt of oa og bn oh oi bi"><span id="8824" class="oj ly it oa b be ok ol l om on">from collections import deque<br/><br/>d = deque([1, 2, 3, 4], maxlen=10)<br/><br/># Adding item(s)<br/>d.append(5)<br/>d.extend([6, 7])<br/>d.appendleft(0)<br/>d.extendleft([-1, -2])<br/># d = [-2, -1, 0, 1, 2, 3, 4, 5, 6, 7]<br/><br/># Removing items<br/>first_item = d.popleft()<br/>last_item = d.pop()<br/># d = [-1, 0, 1, 2, 3, 4, 5, 6]<br/><br/># Shift items from back to the front<br/>d.rotate(3)<br/># d = [4, 5, 6, -1, 0, 1, 2, 3]</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="88eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你已经理解了更多类似列表的数据结构和算法，下次可以使用它们来加速你的代码！你也可以挑战自己，尝试手工实现这些数据结构，比如这个<a class="ae ky" href="https://leetcode.com/problems/design-circular-queue/" rel="noopener ugc nofollow" target="_blank"> LeetCode challenge </a>设计一个<code class="fe nx ny nz oa b"><strong class="lb iu">deque</strong></code>数据结构。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><h1 id="468a" class="lx ly it bd lz ma nm mc md me nn mg mh jz no ka mj kc np kd ml kf nq kg mn mo bi translated">相关链接</h1><ul class=""><li id="e4b2" class="mp mq it lb b lc mr lf ms li mt lm mu lq mv lu mw mx my mz bi translated"><code class="fe nx ny nz oa b">heapq</code>文档:<a class="ae ky" href="https://docs.python.org/3/library/heapq.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/heapq.html</a></li><li id="c2bf" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated"><code class="fe nx ny nz oa b">bisect</code>文档:<a class="ae ky" href="https://docs.python.org/3/library/bisect.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/bisect.html</a></li><li id="266e" class="mp mq it lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated"><code class="fe nx ny nz oa b">deque</code>文档:<a class="ae ky" href="https://docs.python.org/3/library/collections.html" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/3/library/collections.html</a></li></ul></div></div>    
</body>
</html>