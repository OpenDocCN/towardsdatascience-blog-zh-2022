<html>
<head>
<title>Implementing a File Watcher in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现文件监视器</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/implementing-a-file-watcher-in-python-73f8356a425d#2022-06-04">https://towardsdatascience.com/implementing-a-file-watcher-in-python-73f8356a425d#2022-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e91d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过文件到达进行基于事件的处理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ee5cf0d72079eb78479bf2a4cc0f0fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VmEOhnYYOg_g0j66"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7efb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇博客中，我们将从头开始构建一个所谓的“文件监视器”。文件监视器是一个进程，它监视特定目录中任何文件的到达。文件监视器在任何文件到达时，将触发后续过程。</p><p id="eb79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，想象一下，一个日常流程需要来自另一个部门的文件到达。除非有文件监视器，否则在手动开始相关的日常进程之前，需要有人手动监视所述文件的到达。</p><p id="a360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，文件监视器提供文件的创建、修改、删除、存在和重命名的功能。他们也经常通过<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filesystemwatcher?view=net-6.0" rel="noopener ugc nofollow" target="_blank">本地操作系统事件</a>这样做。然而，这些通常不能支持共享驱动器。</p><p id="0c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于我们的目的，我们将构建一个非常简单的东西，它适用于所有情况，只包括新的文件到达用例。</p><h1 id="fa16" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基本面</h1><p id="b855" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最终，构建一个简单的文件监视器是一个非常简单的过程。我们将轮询一个目录的更改，而不是注册到本机操作系统事件。整个事情可以用三个简单的函数来解决:</p><ol class=""><li id="967c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">返回在目录中找到的文件列表的函数</li><li id="00ae" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">突出显示两个列表之间差异的函数</li><li id="a313" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">持续轮询的功能</li></ol><p id="a0eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们来介绍一下这三个函数。</p><h2 id="a295" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">目录中的文件:</h2><p id="0037" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先要做的是构建一个返回目录中所有文件的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8066" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行这个函数，会返回一个文件列表，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/04e0093170aaf1e8b328d4a41f251f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1V8kSMggZECuhOG-ceSU4w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回在预先指定的目录中找到的文件列表</p></figure><h2 id="55eb" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">两个列表之间的差异:</h2><p id="cc3c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">接下来，我们希望能够比较两个列表并返回差异。这样，我们可以比较两次轮询之间的列表，从而确定是否出现了新文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="585c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是它的外观示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/ed9862d5171fba7f04315f88417afb10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sPZHtPNZi8YuxKBjKzhsKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较两个列表并返回差异</p></figure><h2 id="8b0d" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">定期检查差异:</h2><p id="e668" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，我们需要一个轮询功能来将整个事情联系在一起。带有睡眠计时器的无限循环可以解决这个问题。</p><p id="faa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们创建了一个无限循环(<em class="nw">而True </em>)，在每个循环中，我们获取当前文件的快照，并将它们与前一个循环进行比较，以确定是否出现了任何新文件。</p><p id="6513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数接受两个输入:</p><ol class=""><li id="6ea6" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">my_dir:要监控的目录</li><li id="cc2a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">pollTime:检查更改之间的时间(秒)</li></ol><p id="9176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用我们之前的listComparison函数，我们可以跟踪新文件出现的时间，此时我们可以调用一个新函数doThingsWithNewFiles，传递新文件的列表来做一些事情。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，伙计们，在不到50行的代码中，我们编写了自己的可读的FileWatcher代码。</p><h1 id="6c33" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Jupyter笔记本</h1><p id="933a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面我把所有的东西放在一个Jupyter笔记本里，你可以在你自己的项目中使用</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="c0cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="e7b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我希望您会发现这很有用，并且对一些简单的用例有所帮助。你对如何扩展和构建它有什么想法或主意吗？让我知道！</p></div></div>    
</body>
</html>