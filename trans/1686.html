<html>
<head>
<title>itertools and functools : Two Python Lone Soldiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">itertools和functools:两个Python独行侠</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/itertools-and-functools-two-python-lone-soldiers-7d3400495c89#2022-04-21">https://towardsdatascience.com/itertools-and-functools-two-python-lone-soldiers-7d3400495c89#2022-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e78f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python很酷的一点是它对函数式编程的支持，函数式编程声明处理步骤是通过函数来完成的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1908479be27f80dac709911d1c75810a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5SdsK1VjnqKaS6gaaHUqg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="96f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Python附带了成熟的包，从而增强了它的多范式制胜牌，其中一些(如果不是全部的话)最初是用c实现的。实际上，您可以在Github Python项目的CPython repo中的<a class="ae ky" href="https://github.com/python/cpython/tree/main/Lib" rel="noopener ugc nofollow" target="_blank"> Lib </a> / <a class="ae ky" href="https://github.com/python/cpython/tree/main/Modules" rel="noopener ugc nofollow" target="_blank"> Modules </a>文件夹中阅读这些实现。</p><p id="1551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论Python为我们提供的两个函数式编程模块，用于执行各种基于函数的计算:<code class="fe lv lw lx ly b">itertools and functools</code>。</p><p id="0a4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会复制你在官方文档中发现的相同模式。我只是想提到一些你在互联网上不常遇到的功能，但不知何故在我最需要的时候设法在那里拯救了我。</p><p id="a27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带着我对他们的感激之情，让我们开始吧。</p><h1 id="e943" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">1.Itertools</h1><p id="196f" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">简单地说，<code class="fe lv lw lx ly b">itertools</code>允许高效的循环。</p><blockquote class="mw mx my"><p id="302f" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated">该模块标准化了一组快速、内存高效的核心工具，这些工具可以单独使用，也可以组合使用。它们一起形成了一个“迭代器代数”,使得用纯Python简洁高效地构造专用工具成为可能。</p></blockquote><h2 id="a609" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.1.循环</h2><p id="5ed6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我记得我在哈斯克尔身上看到过类似的东西。很明显，需要用Python实现一个类似的构件。<br/>无论何时你想运行一个无限循环的循环，这个循环会在一个异常或特定的条件下停止，这就是你要做的。<br/>简单有效:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="4afc" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt; from itertools import cycle<br/>&gt;&gt; for el in cycle(range(10)): print(el, end="")<br/>&gt;&gt; 0123456789012345 ...<br/>&gt;&gt; ..</span></pre><p id="71d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，如果你不中断地运行你的循环，你的内存缓冲区会发生一些事情。不知道，没试过。</p><h2 id="cb0f" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.2.积聚</h2><p id="a44a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果您想用尽可能少的代码行设计某种累加器:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="af71" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt; from itertools import accumulate<br/>&gt;&gt; list(accumulate(range(10)))<br/>&gt;&gt; [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]<br/>&gt;&gt; ...</span></pre><p id="0575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，累加器中的每个元素都等于所有先前元素的总和，包括它自己。</p><p id="138e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，我会自豪地用至少6行代码来实现纯内置函数。然而，由于几乎每个数据帧聚合中都需要一个合适的累加器，您可能会喜欢它的工作方式。</p><h2 id="703d" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.3.分组依据</h2><p id="4fea" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">实际上，在我的几个项目中，我用它获得了很多乐趣。这里有一个例子:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="5b8d" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; from itertools import groupby<br/>&gt;&gt;&gt; data = 'AAAABBBCCDAABBB'<br/>&gt;&gt;&gt; for k, v in groupby(data):<br/>...   print(k, len(list(v)))<br/>... <br/>A 4<br/>B 3<br/>C 2<br/>D 1<br/>A 2<br/>B 3</span></pre><p id="c0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的操作与<code class="fe lv lw lx ly b">numpy.unique</code>函数大致相似，但功能更多。<br/>每次key函数值发生变化，都会创建一个break或一个新组。这与<code class="fe lv lw lx ly b">SQL</code>的<code class="fe lv lw lx ly b">GROUP BY</code>形成对比，后者将相似的数据分组，而不考虑顺序。所以在将数据传递给<code class="fe lv lw lx ly b">itertools.groupby</code>之前，首先对数据进行排序是很重要的。</p><h2 id="a2ae" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.4.成对地</h2><p id="c457" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">当你在一个iterable上循环时，你对单独处理每个元素不感兴趣。<code class="fe lv lw lx ly b"><strong class="lb iu">Python 3.10</strong></code>为更有趣的用例提供了一个新特性。<br/>这里有一个成对的例子:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="b58a" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; from itertools import pairwise<br/>&gt;&gt;&gt; list(pairwise('ABCDEFG'))<br/>... ['AB','BC','CD','DE','EF','FG']</span></pre><p id="8036" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有额外程度的执行迭代总是一种特权和奢侈。通过两个元素的连续块来迭代你的列表允许更多的递增或递减处理。</p><h2 id="12ba" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.5.星图</h2><p id="d5f9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">如果你曾经使用过map来操作一个iterable，你可以把starmap看作是一个map操作符，它扩展到了更小的iterable。让我们看一个小例子:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="c8db" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; from itertools import starmap<br/>&gt;&gt;&gt; v = starmap(sum, [[range(5)], [range(5, 10)], [range(10, 15)]])<br/>&gt;&gt;&gt; list(v)<br/>[10, 35, 60]<br/>&gt;&gt;&gt; ...</span></pre><p id="bd9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，<code class="fe lv lw lx ly b">sum</code>应用于每组参数，并生成一个具有相同编号的结果列表。将每个iterable看作一个参数而不是一个简单的输入是很重要的，这就是为什么每个iterable都被放在括号中，否则就会出现错误。</p><p id="ae97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何时候你都想拥有一个函数，它可以根据不同的数据组获取参数，<code class="fe lv lw lx ly b"><strong class="lb iu">starmap</strong></code>可能会非常有效，非常有表现力。</p><h2 id="15c2" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.6.zip_longest</h2><p id="aa38" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Haskell中也使用了<code class="fe lv lw lx ly b">zip</code>。对于并行迭代是相当有用的。<br/>然而，它期望每个可迭代参数的长度相同。<br/>如果你试着滑过两个不同长度的物体，<code class="fe lv lw lx ly b">zip</code>会把长的物体超出的部分剪掉。<br/> <code class="fe lv lw lx ly b">zip_longest</code>将较短的可重复项填充到与较长的可重复项相同的长度:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="296f" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; from itertools import zip_longest<br/>&gt;&gt;&gt; list(zip_longest('ABCD', 'xy', fillvalue='-')) <br/>... [('A', 'x'), ('B', 'y'), ('C', '-'), ('D', '-')]</span></pre><p id="9356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你最初有一个长度不匹配的时候，这是很实际的。然后，您可以轻松地循环两个或更多的可迭代对象，并确保这将在运行时保持不变。</p><h2 id="eb87" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">1.7.产品</h2><p id="0291" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">假设您有一个矩阵等待更新，您必须先遍历行，然后遍历列(反之亦然)。<br/>你会怎么做:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="5705" class="nd ma it ly b gy nt nu l nv nw">for i in ncolumns: <br/>    for j in nrows :<br/>        ...</span></pre><p id="d86c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一种更酷的方法可以用<code class="fe lv lw lx ly b">itertools</code>中一个叫做<code class="fe lv lw lx ly b">product</code>的特性来复合这两个循环:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="296d" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; from itertools import product<br/>&gt;&gt;&gt; for i,j in product([0,1], [10,11]):<br/>...   print(i,j)<br/>... <br/>0 10<br/>0 11<br/>1 10<br/>1 11</span></pre><p id="189e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><strong class="lb iu">product</strong></code>沿可迭代对象执行笛卡尔乘积，在矩阵的情况下，您可以替换嵌套循环，如下所示:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="f8b1" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; for i, j in product(ncolumns, nrows):<br/>    ...</span></pre><p id="256e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不利的一面是，这消除了在两个循环之间初始化中间变量或临时变量的可能性。归根结底，这取决于你想要实现什么。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="4496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是我能想到的让我的一天更轻松、更酷的每一件事情。我不会在这方面做更多的阐述，因为这个库永远不会出其不意，特别是<a class="ae ky" href="https://docs.python.org/3/library/itertools.html#itertools-recipes" rel="noopener ugc nofollow" target="_blank"> itertools recipes </a>:它们是由作者编写的，以充分利用之前看到的函数，这些函数充当了矢量化和高度优化的构建块。在菜谱中，您实际上看到了这些函数在多大程度上有潜力创建更强大的工具，并具有与底层工具集相同的高性能。那里正在发生一些非常有趣的事情，你最好马上去看看...</p><h1 id="f5b0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">2 .功能工具</h1><p id="e1a6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">最简单地说，<code class="fe lv lw lx ly b">functools</code>是高阶函数的模块:它们将函数作为参数和输出。装饰器、属性、缓存都是高阶函数的例子，它们作为注释放置在函数定义之上。让我们看一些其他的例子。</p><h2 id="0efc" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">2.1.部分的</h2><p id="22ab" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">因此，您需要在您的程序中实现一个将被视为一等公民的函数。问题是，它接受了太多的参数，因此在调用时会导致异常。<br/> <code class="fe lv lw lx ly b">partial</code>是<code class="fe lv lw lx ly b">functools</code>中的一个特性，允许通过给至少一个参数赋值来冻结一部分参数。</p><p id="42f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑下一组数组和权重:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="b3eb" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; import numpy as np<br/>&gt;&gt;&gt; x1 = np.array([1,2,1])<br/>&gt;&gt;&gt; w1 = np.array([.2, .3, .2])<br/>&gt;&gt;&gt; n1 = 3<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; x2 = np.array([2,1,2])<br/>&gt;&gt;&gt; w2 = np.array([.1, .1, .05])<br/>&gt;&gt;&gt; n2 = 3<br/>&gt;&gt;&gt;</span></pre><p id="feed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后让我们考虑这个函数，它计算这些数组的加权平均值:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="a30c" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; def weighted_means(x1, w1, n1, x2, w2, n2): <br/>...   return np.dot(x1,w1)/n1 , np.dot(x2,w2)/n2</span></pre><p id="6c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将该功能付诸实施:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="3af8" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; weighted_means(x1, w1, n1, x2, w2, n2)<br/>... (0.3333333333333333, 0.13333333333333333)</span></pre><p id="8c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想通过冻结<code class="fe lv lw lx ly b">x2, w2 and n2</code>来减少变量参数的数量，这样做:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="8713" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; from functools import partial<br/>&gt;&gt;&gt; reduced_weighted_means = partial(weighted_means, x2 = x2 , w2 = w2 , n2 = n2)</span></pre><p id="20f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您可以使用参数数量减少的新reduced函数:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="ea40" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; reduced_weighted_means(x1, w1, n1)<br/>... (0.3333333333333333, 0.13333333333333333)</span></pre><p id="7fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，这是和以前一样的结果，表明该函数的工作方式就好像固定参数是静态输入的一样。当函数在与参数多样性相关的特定约束下使用时，这似乎是一个完美的变通方法。</p><h2 id="b6cb" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">2.2.部分方法</h2><p id="2e15" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated"><code class="fe lv lw lx ly b">partialmethod</code>是partial的外推，只是它被用作类方法。让我们用一个例子来说明这一点(我承认这是一个非常愚蠢的例子):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ab27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="1c55" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; mn = ModelName('clustering')<br/>&gt;&gt;&gt; mn.set_cls()<br/>&gt;&gt;&gt; print(mn.algorithm)<br/>&gt;&gt;&gt; 'classification'<br/>&gt;&gt;&gt;<br/>&gt;&gt;&gt; mn.set_regr()<br/>&gt;&gt;&gt; print(mn.algorithm)<br/>&gt;&gt;&gt; 'regression'</span></pre><p id="8fd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类用于存储字符串，并将setter角色委托给两个partialmethod。<code class="fe lv lw lx ly b">set_cls</code>和<code class="fe lv lw lx ly b">set_regr</code>的工作方式就好像它们是正确定义的方法，并将<code class="fe lv lw lx ly b">algorithm</code>分别设置为不同的值。一个小提示:定义了<code class="fe lv lw lx ly b">algorithm</code>属性后，应该没有<code class="fe lv lw lx ly b">algorithm.setter</code>。</p><h2 id="8bd3" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">2.3.单一调度</h2><p id="f896" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">假设您定义了一个执行一些指令的简单函数，然后决定使它更加通用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，通过使用现在用作装饰器的<code class="fe lv lw lx ly b">zen_of_python</code>的<code class="fe lv lw lx ly b">register()</code>属性，用额外的实现重载该函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="549e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以根据参数的类型确定不同的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="5e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意泛型函数在接受不同类型的参数时的行为:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="ba6c" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; zen_of_python('hello')<br/>... Beautiful is better than ugly.</span><span id="f122" class="nd ma it ly b gy og nu l nv nw">&gt;&gt;&gt; zen_of_python(1)<br/>... There should be one-- and preferably only one --obvious way to do it.</span><span id="f9e4" class="nd ma it ly b gy og nu l nv nw">&gt;&gt;&gt; zen_of_python(1.0)<br/>... Readability counts.</span><span id="6e67" class="nd ma it ly b gy og nu l nv nw">&gt;&gt;&gt; zen_of_python([1, 2, "a"])<br/>... Namespaces are one honking great idea -- let's do more of those!</span></pre><p id="6f03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果与我们的实现一致。然而，由于通用函数还不知道<code class="fe lv lw lx ly b">dict</code>类型的适当实现，它将跳转到默认实现:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="7891" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; zen_of_python(dict())<br/>... Beautiful is better than ugly.</span></pre><p id="329a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这东西很酷。我知道。</p><h2 id="0df6" class="nd ma it bd mb ne nf dn mf ng nh dp mj li ni nj ml lm nk nl mn lq nm nn mp no bi translated">2.4.singledispatchmethod方法</h2><p id="4613" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们的最后一位客人:<code class="fe lv lw lx ly b">singledispatchmethod</code>它可以在类定义中使用。<br/>举个例子也许？<br/>假设您有一个基于您输入的参数类型输出字符串的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="e7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以一个小演示结束:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="2fa5" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; gen = Generic()</span><span id="77ef" class="nd ma it ly b gy og nu l nv nw">&gt;&gt;&gt; gen.generic_method(1)<br/>...'First case'</span><span id="123e" class="nd ma it ly b gy og nu l nv nw">&gt;&gt;&gt; gen.generic_method(1.0)<br/>&gt;&gt;&gt; 'Second case'</span><span id="72ca" class="nd ma it ly b gy og nu l nv nw">&gt;&gt;&gt; gen.generic_method([1,2,3])<br/>&gt;&gt;&gt; 'Third case'</span></pre><p id="f93d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试试<code class="fe lv lw lx ly b">dict</code>式:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="922b" class="nd ma it ly b gy nt nu l nv nw">&gt;&gt;&gt; gen.generic_method(dict(a=1, b=2))<br/>Traceback (most recent call last):<br/>    ...<br/>  NotImplementedError: Never heard of this type ..</span></pre><p id="b2f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在泛型类上声明了另一个类型，你会遇到一个错误。如果你想让它消失，你应该添加一个小而温和的功能来照顾它。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="a8fc" class="lz ma it bd mb mc oh me mf mg oi mi mj jz oj ka ml kc ok kd mn kf ol kg mp mq bi translated">参考</h1><p id="8e2d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">正式文档— <a class="ae ky" href="https://docs.python.org/3/library/itertools.html" rel="noopener ugc nofollow" target="_blank"> itertools </a>和<a class="ae ky" href="https://docs.python.org/3/library/functools.html" rel="noopener ugc nofollow" target="_blank"> functools </a></p></div></div>    
</body>
</html>