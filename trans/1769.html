<html>
<head>
<title>Probably The Easiest Way To Animate Your Python Plots</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这可能是制作Python图动画的最简单的方法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/probably-the-easiest-way-to-animate-your-python-plots-f5194ebed75f#2022-04-26">https://towardsdatascience.com/probably-the-easiest-way-to-animate-your-python-plots-f5194ebed75f#2022-04-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/511933257c9412312e6661509ce4b34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3J_fhsogukvSd5XOGiRdwA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/u_w8477gyh9u-26845752/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7141482" rel="noopener ugc nofollow" target="_blank"> u_w8477gyh9u </a>来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7141482" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><div class=""/><div class=""><h2 id="5c9d" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">生成绘图帧，并将其合并为GIF</h2></div><p id="a153" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可视化一直是Python在数据科学和数据分析中的重要用途。有时，我们想让我们的情节移动，以获得更高级的展示和见解。然而，大多数动画可视化库需要一些额外的努力来学习，如<code class="fe lu lv lw lx b">matplotlib.animation</code>。当我们只是想快速简单地生成一些动画图形时，这可能不是最好的方法。</p><p id="e390" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍一种可扩展性相对较差但更容易的方法来制作Python绘图动画，这就是使用ImageIO库。这个库通常用于在Python中操作图像，以及组合多个图像来生成gif。它非常容易使用。</p><p id="6de0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们可以使用ImageIO库之前，我们需要使用<code class="fe lu lv lw lx b">pip</code>安装它，如下所示。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="381c" class="mg mh jj lx b gy mi mj l mk ml">pip install imageio</span></pre><h1 id="ef22" class="mm mh jj bd mn mo mp mq mr ms mt mu mv kp mw kq mx ks my kt mz kv na kw nb nc bi translated">1.折线图的一个例子</h1><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/487e15873f0f49440f6fe765f5591ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pd7injNel-rIb79u41getA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1853262" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/pexels-2286921/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1853262" rel="noopener ugc nofollow" target="_blank">像素</a>图像</p></figure><p id="9429" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从这个演示的基本折线图开始。为了简化它，我想用50个整数生成一个NumPy数组。然后，这些整数可以绘制成折线图。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="1523" class="mg mh jj lx b gy mi mj l mk ml">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import imageio</span><span id="ede5" class="mg mh jj lx b gy nd mj l mk ml">np.random.seed(0)<br/>SIZE = 50<br/>y = np.random.randint(-5, 5, SIZE)<br/>plt.plot(y)<br/>plt.ylim(-10, 10)</span><span id="70fe" class="mg mh jj lx b gy nd mj l mk ml">plt.show()</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ne"><img src="../Images/f12d59b21449a8647ce40081f51f1699.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uJTbFlQ__TUsTysnk3YnAg.png"/></div></div></figure><p id="3b5d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我设置了随机种子，这样如果你愿意的话，你可以复制出和我完全一样的结果。<code class="fe lu lv lw lx b">SIZE</code>被定义为一个常量，因此您可以根据自己的喜好对其进行更改。</p><p id="7361" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整数在[-5，5]范围内生成。此外，为了使图表更容易阅读，我想添加<code class="fe lu lv lw lx b">ylim(-10, 10)</code>，这样所有的点都在图表的中间部分。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nf"><img src="../Images/d5b486ea1404969f450c46341594dce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0o0xbu-XYvT7BZ8C31fTGg.png"/></div></div></figure><p id="d80f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了这个静态的基本折线图。比方说，我们希望通过逐个绘制点来制作折线图。最好是把结果做成GIF格式，这样我们就可以把它嵌入到任何我们想嵌入的地方。</p><p id="b142" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，合适的方法是使用<code class="fe lu lv lw lx b">matplotlib.animation</code>模块。然而，我将介绍的快速简单的方法是将帧生成为单独的PNG图像。然后，我们可以使用ImageIO将它们组合成一个GIF。</p><h2 id="04a6" class="mg mh jj bd mn ng nh dn mr ni nj dp mv lh nk nl mx ll nm nn mz lp no np nb nq bi translated">1.1生成帧</h2><p id="8040" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">事实上，生成帧并不十分困难。这个想法是用2点，3点，…和50点来绘制折线图。每个图都应该保存到单独的图像中。</p><p id="55c0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下所示</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="b2a7" class="mg mh jj lx b gy mi mj l mk ml">for i in range(2, SIZE+1):<br/>    plt.plot(y[0:i])<br/>    plt.ylim(-10, 10)<br/>    plt.savefig(f'line-{i}.png')<br/>    plt.close()</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/cc4bbd58ac17ad44a610520f021c1c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*gy-Wv-E9nrCSByoLTx0fLg.png"/></div></figure><p id="72be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">for循环从2个点开始，因为单个点无法生成有效的折线图。它将在<code class="fe lu lv lw lx b">SIZE+1</code>处停止，这样<code class="fe lu lv lw lx b">range()</code>将在精确的点数处终止。换句话说，在我们的例子中，最后一个<code class="fe lu lv lw lx b">i</code>是50。</p><p id="0ac5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在每一帧中定义<code class="fe lu lv lw lx b">ylim</code>很重要。否则，y轴将被自动确定，因此它在帧中是不同的。</p><p id="636b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">配置绘图后，我们可以用预定义的文件名模式将图形保存为PNG图像。稍后将使用这个文件名模式来填充这些帧。最后，我们需要通过调用<code class="fe lu lv lw lx b">plt.close()</code>来结束这个情节。这样，下一个循环中的下一帧才能正确生成。</p><p id="96b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行这段代码后，当前工作目录下将生成49个PNG文件。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nx"><img src="../Images/ff25e4ccee3e5bfbee73fe0ec387d8be.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*7cIfbk7yjCLp8x8uV6Mfxw.png"/></div></div></figure><h2 id="a7cb" class="mg mh jj bd mn ng nh dn mr ni nj dp mv lh nk nl mx ll nm nn mz lp no np nb nq bi translated">1.2生成GIF</h2><p id="4c1e" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">下一步是将它们组合成一个GIF。ImageIO库提供了一个“编写器”,我们可以很容易地将图像附加到框架中。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="64eb" class="mg mh jj lx b gy mi mj l mk ml">with imageio.get_writer('line.gif', mode='i') as writer:<br/>    for i in range(2, SIZE+1):<br/>        image = imageio.imread(f'line-{i}.png')<br/>        writer.append_data(image)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ny"><img src="../Images/03a604fd2586192fc5e86f9b14fa013a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trYa3nqoVkL-RmR_Y_Z4xA.png"/></div></div></figure><p id="c897" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以使用with语句，这样就不需要担心流的关闭。GIF文件的名称将被称为<code class="fe lu lv lw lx b">line.gif</code>。标志<code class="fe lu lv lw lx b">mode='i'</code>是一个提示，告诉ImageIO输入将是图像。</p><p id="a70f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们可以进行另一个for循环来获取索引。因此，我们可以使用索引来获取帧的文件名。一旦我们有了文件名，只需将它附加到当前的writer。</p><p id="e9fe" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们运行上面的代码之后，GIF文件<code class="fe lu lv lw lx b">line.gif</code>应该已经生成了。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d878054df3b69c8b46227c1e0048ffd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*GWGN2IVVnOlMrNLbviJmqw.png"/></div></figure><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/cc350f25f4c1aded14efc9672ff027b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*LucfQTuiKk48UPlwCbKjlQ.gif"/></div></figure><p id="f8e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顺便说一句，如果框架不再有用，我们可以使用下面的代码删除它们。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="999a" class="mg mh jj lx b gy mi mj l mk ml">import os</span><span id="693a" class="mg mh jj lx b gy nd mj l mk ml">for i in range(2, SIZE+1):<br/>    os.remove(f'line-{i}.png')</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/5c0bd9189977ceeb8f454f45f8f8b21d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*hXlIRmAsMomYG9gYufC6Vw.png"/></div></figure><h2 id="c449" class="mg mh jj bd mn ng nh dn mr ni nj dp mv lh nk nl mx ll nm nn mz lp no np nb nq bi translated">1.3一个小小的改进</h2><p id="b1bd" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">上面显示的GIF可能并不完美。具体来说，x轴也随着帧移动。这可能取决于我们想要实现的目标，但假设我们想要固定GIF中的x轴，我们肯定可以做到。</p><p id="86f5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子还表明，这里介绍的方法非常灵活。基本上，当我们想要在我们的动画图表中有一些特性时，我们不依赖于库的任何API，而是依赖于帧是如何生成的。</p><p id="cd68" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们只需要在原始代码中添加<code class="fe lu lv lw lx b">xlim()</code>配置，就可以生成x轴固定的帧。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="f389" class="mg mh jj lx b gy mi mj l mk ml">for i in range(2, SIZE+1):<br/>    plt.plot(y[0:i])<br/>    plt.ylim(-10, 10)<br/>    plt.xlim(0, 50)<br/>    plt.savefig(f'line-{i}.png')<br/>    plt.close()</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/87c014ca3f376923cd04a8fc048418a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*E35pOxlo_ZXUBTq3W5hWag.png"/></div></figure><p id="7efd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，用于生成GIF的ImageIO代码甚至不需要更改，因为我们已经更新了帧的内容，但是图像的数量仍然相同。</p><p id="0e97" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，新的GIF看起来如下。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6af5ef38c95ec18bdbfdc885fd6cfa48.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*uM6ezxeiTfnfg9deSqwWaw.gif"/></div></figure><h1 id="073e" class="mm mh jj bd mn mo mp mq mr ms mt mu mv kp mw kq mx ks my kt mz kv na kw nb nc bi translated">2.条形图的一个更好的例子</h1><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/cb11cb868fa4a487731887c9d4e110bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1gH-VteWQRIBk9qP9sItg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3809537" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/theocrazzolara-10197635/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3809537" rel="noopener ugc nofollow" target="_blank">西奥·克雷佐拉拉</a></p></figure><p id="0796" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法已在上面的折线图示例中得到了很好的介绍。然而，我只是想说明该方法有更大的潜力。这一次，让我们制作一个条形图。</p><p id="d777" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在演示开始之前，我们需要定义一个x轴和一个y轴列表。我们之所以需要一个y轴值的列表，是因为我们想让GIF显示多个帧，每个帧都是一个条形图。换句话说，它们的x轴相同，但y值不同。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="2796" class="mg mh jj lx b gy mi mj l mk ml">x_axis = [1, 2, 3]<br/>y_axis_list = [<br/>    [0, 0, 0],<br/>    [1, 2, 3],<br/>    [3, 2, 1],<br/>    [5, 5, 5],<br/>    [7, 7, 7],<br/>    [9, 2, 9],<br/>    [2, 9, 2],<br/>    [1, 1, 1],<br/>    [9, 9, 9],<br/>    [0, 0, 0]<br/>]</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/c2c9ab227cfd211ae51d09d351eb2ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*o2NOFIgSZXEGKKHT1OvkUw.png"/></div></figure><p id="7840" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码只是一个例子。没有模式，只是编出来的:)</p><h2 id="30f6" class="mg mh jj bd mn ng nh dn mr ni nj dp mv lh nk nl mx ll nm nn mz lp no np nb nq bi translated">2.1生成条形图GIF</h2><p id="4852" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">然后，让我们生成框架条形图。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="6e2f" class="mg mh jj lx b gy mi mj l mk ml">png_files = []</span><span id="fc7e" class="mg mh jj lx b gy nd mj l mk ml">for i, y_axis in enumerate(y_axis_list):<br/>    # Create Plot<br/>    plt.bar(x_axis, y_axis)<br/>    plt.ylim(0,10)</span><span id="7992" class="mg mh jj lx b gy nd mj l mk ml">    # Create PNG file<br/>    filename = f'bar-{i}.png'<br/>    png_files.append(filename)</span><span id="8912" class="mg mh jj lx b gy nd mj l mk ml">    # Save Figure<br/>    plt.savefig(filename)<br/>    plt.close()</span><span id="58d1" class="mg mh jj lx b gy nd mj l mk ml">with imageio.get_writer('bar.gif', mode='i') as writer:<br/>    for filename in png_files:<br/>        image = imageio.imread(filename)<br/>        writer.append_data(image)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oe"><img src="../Images/7737c60d9e93833dd78f415c213baba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1D1qrmrli7C52x_wqhEBA.png"/></div></div></figure><p id="65d1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这次我不想被for循环中的<code class="fe lu lv lw lx b">range()</code>方法所困扰。我们可以定义一个列表<code class="fe lu lv lw lx b">png_files</code>来包含所有帧的文件名。因此，稍后，当我们想要从PNG图像生成GIF时，我们只需要从这个列表中获取文件名。</p><p id="78c3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成GIF的代码与前面的例子没有什么不同。这也说明该方法相当通用。</p><p id="b857" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的GIF如下。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/1eb1dabe0105d38ab3a8e23ba0af388c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*HeDwhX_fHGms2esEbyjP2g.gif"/></div></figure><p id="3141" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，可以，但不理想。其实根本看不懂。</p><h2 id="61f9" class="mg mh jj bd mn ng nh dn mr ni nj dp mv lh nk nl mx ll nm nn mz lp no np nb nq bi translated">2.2生成平滑过渡的GIF</h2><p id="22a0" class="pw-post-body-paragraph ky kz jj la b lb nr kk ld le ns kn lg lh nt lj lk ll nu ln lo lp nv lr ls lt im bi translated">从动画的角度思考。好看的动画无非就是FPS多，过渡流畅。基本思想是在两个状态之间添加更多的过渡帧。</p><p id="5dde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们可以做到以下几点。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="dda0" class="mg mh jj lx b gy mi mj l mk ml">smooth_coef = 10<br/>png_files = []</span><span id="79a7" class="mg mh jj lx b gy nd mj l mk ml">for i in range(0, len(y_axis_list)-1):<br/>    # Get Current &amp; Next Frame<br/>    y_axis_curr = y_axis_list[i]<br/>    y_axis_next = y_axis_list[i+1]</span><span id="86dc" class="mg mh jj lx b gy nd mj l mk ml"># Generate Middle Frames<br/>    y_diff = np.array(y_axis_next) - np.array(y_axis_curr)<br/>    for j in range(0, smooth_coef+1):<br/>        y_axis = (y_axis_curr + (y_diff / smooth_coef) * j)<br/>        # Create Plot<br/>        plt.bar(x_axis, y_axis)<br/>        plt.ylim(0,10)  <br/>        # Create PNG file<br/>        filename = f'bar-{i}-{j}.png'<br/>        png_files.append(filename)<br/>        # Stretch the last frame<br/>        if j == smooth_coef:<br/>            for _ in range(5):<br/>                png_files.append(filename)<br/>        # Save Figure<br/>        plt.savefig(filename)<br/>        plt.close()</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi of"><img src="../Images/1c9b2f18c148e593bf3aec84bc834426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ATcYJiFDAU5CGWX6f35ozQ.png"/></div></div></figure><p id="861a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我来解释一下。<code class="fe lu lv lw lx b">smooth_coef</code>代表“平滑系数”。这意味着我们要在每两个主帧之间添加10个过渡帧。主帧正好是演示数据集中的y轴。</p><p id="58f3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在for循环中，我们将获得当前的y轴和下一个。之后，我们可以用下一个y值减去当前值。所以，结果将是这两个主要框架之间的“差异”。那么，如果我们让“差”除以平滑系数，就会得到阶梯式的差。总之，我们可以计算每个过渡帧之间的差异。所有过渡帧相加将把当前帧变成下一帧。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="0252" class="mg mh jj lx b gy mi mj l mk ml">y_axis = (y_axis_curr + (y_diff / smooth_coef) * j)</span></pre><p id="891b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个技巧是让GIF在关键帧处“停留”一会儿，这样我们可以看得更久一点。这可以通过在特定时间重复文件名来实现，这样帧就会重复。在生成的GIF中，我们将多次看到该帧，这也意味着更长的时间。</p><p id="957e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看结果。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/41196231536de5ec4652aef8670bd9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*Rh78_VWl8E_ZJMzTJCeweg.gif"/></div></figure><p id="dcde" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那就好多了！</p><h1 id="88c6" class="mm mh jj bd mn mo mp mq mr ms mt mu mv kp mw kq mx ks my kt mz kv na kw nb nc bi translated">3.该方法是通用的</h1><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/96cd037f1886072c4553c437d4aae86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nq1UVs1sigl0n1I4-dingg.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片由<a class="ae jg" href="https://pixabay.com/users/julius_silver-4371822/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3021072" rel="noopener ugc nofollow" target="_blank"> Julius Silver </a>从<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3021072" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="469a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同于任何特定的绘图库，如<code class="fe lu lv lw lx b">matplotlib.animation</code>，ImageIO-GIF方法更加通用。也就是说，我们甚至不受使用什么库的限制。只要图形可以保存成图像文件，我们就可以用这种方法让它移动。</p><p id="564c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个简单的例子。我们可以使用Seaborn来生成条形图。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="903c" class="mg mh jj lx b gy mi mj l mk ml">import seaborn as sns</span><span id="1d45" class="mg mh jj lx b gy nd mj l mk ml">sns.set_style('darkgrid')</span></pre><p id="06ea" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Seaborn模块被导入，样式被设置。然后，我们需要修改的代码部分如下。</p><pre class="ly lz ma mb gt mc lx md me aw mf bi"><span id="5350" class="mg mh jj lx b gy mi mj l mk ml">sns.barplot(x_axis, y_axis)</span></pre><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi og"><img src="../Images/bb81e0909103a7503efeaa8bd5a4b25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6slhsglR3YuoONrCMCqEvg.png"/></div></div></figure><p id="628a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的GIF如下所示。</p><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/99e6b512c4567431fc1c34745feb23e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*vhm6NzV-UOsa9PLVWs11Tg.gif"/></div></figure><h1 id="be43" class="mm mh jj bd mn mo mp mq mr ms mt mu mv kp mw kq mx ks my kt mz kv na kw nb nc bi translated">摘要</h1><figure class="ly lz ma mb gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/86ab6d258f56bd6d605cf5d020e07072.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZYHV8mdoyqPBTv1tMx10A.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7139263" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae jg" href="https://pixabay.com/users/miguelbarrera3-17639641/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7139263" rel="noopener ugc nofollow" target="_blank"> Miguel Barrera </a></p></figure><p id="d54f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我介绍了一种不使用任何专门构建的绘图动画库将Python可视化制作成GIF的方法。这个想法是逐帧生成图像文件的情节。然后，可以使用ImageIO模块将这些图像文件组合成一个GIF。</p><p id="755f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法也非常通用。我们不需要学习任何特定动画风格的API或方法。我们需要做的就是生成不同的帧来达到要求。此外，它甚至不局限于任何可视化库，因为它依赖于作为帧生成的图像。</p><p id="b7ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，这种方法可能不是绘图的常规方法。其中一个问题可能是可扩展性，因为我们需要生成许多单独的文件作为帧，然后才能获得GIF。</p><div class="is it gp gr iu oh"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd jk gy z fp om fr fs on fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">medium.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ja oh"/></div></div></a></div><p id="30be" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p></div></div>    
</body>
</html>