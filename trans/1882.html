<html>
<head>
<title>Running dbt using Gitlab CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gitlab CI/CD运行dbt</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/running-dbt-using-gitlab-ci-cd-8a2ef0f05af0#2022-05-02">https://towardsdatascience.com/running-dbt-using-gitlab-ci-cd-8a2ef0f05af0#2022-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ebda" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">免费部署、运行和安排dbt的最简单方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3c8db1ede9629a99f83718b2bfd6a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORaj_P2LDe7FldmL-4682A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@samthewam24?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Samuel Sianipar </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="305e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我第一次实现<a class="ae kv" href="https://www.getdbt.com/" rel="noopener ugc nofollow" target="_blank"> dbt </a>是在<a class="ae kv" href="https://www.sirena.app/en-us/" rel="noopener ugc nofollow" target="_blank"> Sirena </a>管理数据团队的时候，我立刻成为了它的超级粉丝。我们用它来运行我们所有的转换，并在我们的数据仓库中创建我们的模型(<a class="ae kv" href="https://www.snowflake.com/" rel="noopener ugc nofollow" target="_blank">雪花</a>)。能够将维度建模应用于我们的数据，尤其是有大量非结构化数据来源的数据，确实是一个游戏规则的改变者。更好的是，我们所有的模型和业务逻辑都受版本控制，变化完全可见，协作极其容易。不过，我最喜欢的部分可能是它在原始数据和业务实体之间创建的抽象层。例如，我们可以创建一个<code class="fe ls lt lu lv b">dim_customers</code>模型，并从生成模型的原始数据中完全提取出我们公司客户的唯一真实来源。对于我们的利益相关者来说，他们在BI工具中使用的表格是来自我们的CRM、产品数据库、ERP还是客户成功软件并不重要。重要的是，在这张表中，他们可以找到我们客户的所有信息，这对他们来说是完全透明的。如果我们的数据源上游发生了变化，我们作为一个数据团队可以通过这个抽象层修复这些变化。更令人惊讶的是，希望没有人必须处理这一点，它允许我们在数据源中进行巨大的更改(例如CRM迁移或同时运行多个CRM)，同时最小化对我们的BI层的影响(是的，我有一些战斗伤疤)。哦，还有，所有这一切都得益于SQL的简单性。太神奇了。</p><p id="8581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我提到的，我们对dbt项目进行版本控制，为此我们使用了Gitlab。当我看到Gitlab数据团队的视频<a class="ae kv" href="https://www.youtube.com/watch?v=-XBIIY2pFpc&amp;t=1301s" rel="noopener ugc nofollow" target="_blank">解释他们如何使用Gitlab CI运行dbt时，这变得非常有趣。同时，Gitlab作为一家开源公司，让他们的dbt项目</a><a class="ae kv" href="https://gitlab.com/gitlab-data" rel="noopener ugc nofollow" target="_blank">的所有代码完全可用</a>。我建议你在那里花一点时间，很多有用的东西。</p><p id="2713" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将详细介绍如何使用<a class="ae kv" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> Gitlab的CI/CD </a>来“部署”您的dbt项目。注意，使用<a class="ae kv" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> Github动作</a>可以实现类似的工作流程。</p><h1 id="4f8a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">入门指南</h1><p id="1b8b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Gitlab 的<a class="ae kv" href="https://docs.gitlab.com/ee/ci/" rel="noopener ugc nofollow" target="_blank"> CI/CD工具非常容易使用，你需要做的就是在你的库的根目录下创建一个名为<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>的文件。这个</a><a class="ae kv" href="https://docs.gitlab.com/ee/ci/yaml/index.html" rel="noopener ugc nofollow" target="_blank">文件基本上是Gitlab应该如何执行管道的配方</a>。在本帖中，我们将回顾我们可以实现的最简单的工作流，重点是在生产中运行dbt模型。我将在后面的文章中讨论如何进行实际的CI/CD(包括测试)、生成文档和存储元数据。现在，我们的目标是能够每天运行<code class="fe ls lt lu lv b">dbt build</code>，这样我们所有的模型都是最新的。</p><p id="a127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个使用Gitlab的CI/CD运行dbt的最简单设置之一的<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>文件示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9e74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先定义希望在管道中运行的阶段。在这种情况下，我们将只有一个阶段称为<code class="fe ls lt lu lv b">deploy-production</code>。如果我们现在忽略<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>文件的中间部分，直接跳到底部，我们可以看到我们定义了这个阶段实际做什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们将<code class="fe ls lt lu lv b">when</code>参数(<a class="ae kv" href="https://docs.gitlab.com/ee/ci/yaml/index.html#when" rel="noopener ugc nofollow" target="_blank"> docs </a>)定义为只有<code class="fe ls lt lu lv b">manual</code>，这个阶段只有在通过Gitlab的UI触发后才会运行。除此之外，stage还定义了一个名为<code class="fe ls lt lu lv b">TARGET_NAME</code>的变量，其值为<code class="fe ls lt lu lv b">postgres</code>(稍后会详细介绍)。当谈到这个阶段实际上做什么时，它只是扩展了<code class="fe ls lt lu lv b">.deploy</code>中的定义。同时，<code class="fe ls lt lu lv b">.deploy</code>由<code class="fe ls lt lu lv b">dbt_jobs</code>的定义延伸而来，也就是<code class="fe ls lt lu lv b">.dbt_run</code>。这由下面一行指定:<code class="fe ls lt lu lv b">&lt;&lt;: *dbt_jobs</code>，它实际上插入了<code class="fe ls lt lu lv b">dbt_jobs</code>定义。</p><p id="129d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看<code class="fe ls lt lu lv b">.dbt_run</code>,我们看到我们定义了运行所有内容的映像，在本例中是<code class="fe ls lt lu lv b">python:3.8.1-slim-buster</code> Docker映像(<a class="ae kv" href="https://docs.gitlab.com/ee/ci/yaml/index.html#image" rel="noopener ugc nofollow" target="_blank"> docs </a>)。之后，我们运行一些脚本来安装依赖项，并定义一个名为<code class="fe ls lt lu lv b">CI_PROFILE_TARGET</code>的变量。为此，我们使用之前定义的<code class="fe ls lt lu lv b">TARGET_NAME</code>变量。在这种情况下，<code class="fe ls lt lu lv b">CI_PROFILE_TARGET</code>变量看起来会像<code class="fe ls lt lu lv b">--profiles-dir . --target postgres</code>。你大概可以看到这是怎么回事。我们可以在运行dbt命令时使用这个变量来指定到我们的<code class="fe ls lt lu lv b">profiles.yml</code>的路径和我们想要使用的目标。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="81ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就<code class="fe ls lt lu lv b">profiles.yml</code>而言，我们可以使用与<a class="ae kv" href="https://juangesino.medium.com/setup-dbt-using-docker-7b39df6c6af4" rel="noopener">相似的设置，使用docker </a>运行dbt，从env变量获取数据仓库凭证。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="5a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<a class="ae kv" href="https://docs.gitlab.com/ee/ci/variables/" rel="noopener ugc nofollow" target="_blank"> Gitlab的CI/CD变量</a>设置这些变量非常容易:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mv"><img src="../Images/b51ec930bec92774054c9fca9a0b260d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PaOieXVEzb4Mvl1xx2wkkg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Gitlab中添加CI/CD变量(图片由作者提供)</p></figure><p id="30a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们终于可以看一看<code class="fe ls lt lu lv b">.deploy</code>了。由于添加了0.21.0 中引入的<code class="fe ls lt lu lv b">dbt build</code> <a class="ae kv" href="https://docs.getdbt.com/reference/commands/build" rel="noopener ugc nofollow" target="_blank">命令，我们可以简单地安装依赖项，然后运行<code class="fe ls lt lu lv b">dbt build</code>命令，该命令将根据我们的dbt DAG按照运行模型、测试、快照和种子的顺序来处理它们。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="bc4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，如果我们将代码推送到Gitlab，我们应该会看到一个新的管道被创建，我们可以手动触发它(记住，因为有了<code class="fe ls lt lu lv b">when: manual</code>配置)。一旦我们这样做了，我们的dbt项目就会运行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/a1fe7db4e609f7bcbf1ea9cbe4061c13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vERznOfIL1wzbe0d1oh1PQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Gitlab中检查CI/CD管道(图片由作者提供)</p></figure><h1 id="ebd3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">安排dbt每天运行</h1><p id="9c8f" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">使用这个设置，至少有两种方法可以安排dbt每天运行。第一种方法是使用Gitlab内置的<a class="ae kv" href="https://gitlab.com/help/ci/pipelines/schedules" rel="noopener ugc nofollow" target="_blank">流水线调度</a>，第二种方法是使用<a class="ae kv" href="https://docs.gitlab.com/ee/ci/triggers/" rel="noopener ugc nofollow" target="_blank"> Gitlab的API </a>触发流水线。</p><h2 id="395e" class="mx lx iq bd ly my mz dn mc na nb dp mg lf nc nd mi lj ne nf mk ln ng nh mm ni bi translated">流水线调度</h2><p id="8f2b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这可能是最简单、最直接的方法。在Gitlab的CI/CD部分下，有一个用于创建管道计划的部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/c9afe30dfabc1158e963d7e4af215112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1S_WiwecTVoF0-IUxmmBg.png"/></div></div></figure><p id="425f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以按照说明每天运行管道，或者以任何频率运行您的dbt模型。</p><h2 id="b301" class="mx lx iq bd ly my mz dn mc na nb dp mg lf nc nd mi lj ne nf mk ln ng nh mm ni bi translated">通过API触发管道</h2><p id="70ee" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">安排管道的另一种方式是使用您当前正在使用的任何编排工具，例如<a class="ae kv" href="https://airflow.apache.org/" rel="noopener ugc nofollow" target="_blank">气流</a>或<a class="ae kv" href="https://dagster.io/" rel="noopener ugc nofollow" target="_blank"> Dagster </a>。这还有一个额外的好处，就是可以与数据管道的其余部分集成在一起。使用它，您可以在数据加载到仓库后触发dbt构建。</p><p id="a47d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在这里找到用于触发管道<a class="ae kv" href="https://docs.gitlab.com/ee/ci/triggers/" rel="noopener ugc nofollow" target="_blank">的API文档，但是基本上您需要做的就是</a><a class="ae kv" href="https://docs.gitlab.com/ee/ci/triggers/#create-a-trigger-token" rel="noopener ugc nofollow" target="_blank">创建一个触发令牌</a>，并在对URL: <code class="fe ls lt lu lv b">https://gitlab.example.com/api/v4/projects/&lt;project_id&gt;/trigger/pipeline</code>的<code class="fe ls lt lu lv b">POST</code>请求中使用它。这种方法的一个惊人的特性是，您可以将变量传递给管道。这意味着，当数据管道的不同部分已经加载时，您可以触发dbt的构建。</p><p id="02ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是如何使用Python触发管道的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a3cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，要做到这一点，您需要移除<code class="fe ls lt lu lv b">when: manual</code>条件。</p><h1 id="af39" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">进一步的改进</h1><p id="3ff3" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">希望这篇文章向您展示了如何将Gitlab CI/CD(或Github Actions)与dbt结合使用。然而，我希望这能成为灵感，因为有很多方法可以利用这一点。例如，在<a class="ae kv" href="https://www.sirena.app/en-us/" rel="noopener ugc nofollow" target="_blank"> Sirena </a>和<a class="ae kv" href="https://www.zenvia.com/" rel="noopener ugc nofollow" target="_blank"> Zenvia </a>中，我们使用此工作流来利用雪花零拷贝克隆进行实际的CI/CD。每当一个合并请求(或拉请求)被创建时，它将触发一个管道来克隆我们的雪花数据库，并在其上运行代码更改和测试。这给了我们很大的信心，我们的改变不会引入任何问题。我们使用这个工作流实现的另一件事是存储元数据并生成dbt文档来记录我们的数据仓库。如果这一切听起来很有趣，请考虑<a class="ae kv" href="https://juangesino.medium.com/" rel="noopener">在媒体上关注我</a>，因为我将在未来创造更多关于这方面的内容。</p></div></div>    
</body>
</html>