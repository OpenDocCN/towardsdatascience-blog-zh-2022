<html>
<head>
<title>Easily Employ A Theta Model For Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松采用时间序列的Theta模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/easily-employ-a-theta-model-for-time-series-b94465099a00#2022-07-15">https://towardsdatascience.com/easily-employ-a-theta-model-for-time-series-b94465099a00#2022-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bb7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">M4竞赛中的最佳基准模型使用Python轻松训练、调整和测试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f0ebd7cd466f2aefa771800ae1de5f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lk8F3NqyM_wshQDThQkQ5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1169" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与ARIMA等经典技术相比，Theta不太为人所知，它是一种时间序列模型，可以产生准确的结果，并且易于理解和应用。如果你是时间序列从业者和预测者，这是一个很好的工具。</p><p id="0946" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它的工作原理是从潜在的时间序列中提取两条“θ线”。第一条线是时间序列的线性趋势，可以通过对使用时间趋势作为输入的数据运行简单的线性回归来提取。这条θ线可以非常简单地通过无限期地继续其线性趋势而推断出未来。</p><p id="28d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二条θ线可以看作是级数的曲率。它是系列的第二个差值乘以一个因子，默认情况下为2。小于1的值抑制曲率并强调长期趋势，大于1的值强调曲率并强调短期趋势。通过使用指数平滑向前外推第二条θ线。</p><p id="47fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这两条θ线然后在加法或乘法过程中结合。为了说明季节性，在提取theta线之前，该模型还使用乘法或加法季节性分解方法对数据进行去季节性处理。在θ线合并后，这种季节性会重新应用到预测数据中。</p><p id="3294" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提出这种方法的论文还提到，进一步的研究可能包括提取两条以上的θ线，但据我所知，没有这样的模型发现任何有前途的东西，但思考起来很有趣(Assimakopoulos &amp; Nikolopoulos，2000)。</p><p id="8ccb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很简单吧？让我们看看如何使用Python来实现它。</p><h1 id="879b" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">Python应用程序</h1><h2 id="2b45" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">飞镖游戏</h2><p id="127d" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">Darts是一个用户友好的时间序列包，它使用了一个名为FourTheta的Theta模型的实现，这是上面解释的思想的衍生物，可以对第一条theta线应用指数变换(而不是使用简单的线性趋势)。这款衍生车型是2020年M4竞赛中表现最佳的基准车型。</p><p id="72dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装省道:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="501f" class="mm lv it ne b gy ni nj l nk nl">pip install darts</span></pre><p id="5971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个链接到darts中的模型文档。</p><h2 id="f401" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">规模预测</h2><p id="3910" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated"><a class="ae nm" href="https://github.com/mikekeith52/scalecast" rel="noopener ugc nofollow" target="_blank"> Scalecast </a>将darts的theta模型移植到一个通用的时间序列框架中，该框架易于实施，并可与其他几种经典的时间序列方法、scikit-learn的机器学习模型以及其他技术进行比较。我将演示theta模型的scalecast实现，因为我是scalecast的作者，并且希望展示这个框架如何能够非常容易地为任何用户实现。也就是说，如果你想直接使用darts的模型，它也提供了一个用户友好和舒适的框架。</p><p id="75b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要安装scalecast:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="f4f0" class="mm lv it ne b gy ni nj l nk nl">pip install scalecast</span></pre><p id="7b7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到本文<a class="ae nm" href="https://github.com/mikekeith52/scalecast-examples/blob/main/theta/theta.ipynb" rel="noopener ugc nofollow" target="_blank">中使用的完整笔记本。</a>数据来自M4竞赛的<a class="ae nm" href="https://github.com/Mcompetitions/M4-methods/issues/16" rel="noopener ugc nofollow" target="_blank">开放访问</a>，可在<a class="ae nm" href="https://github.com/Mcompetitions/M4-methods/tree/master/Dataset" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。我们将使用H7每小时时间序列。</p><h2 id="b476" class="mm lv it bd lw mn mo dn ma mp mq dp me lh mr ms mg ll mt mu mi lp mv mw mk mx bi translated">代码实现</h2><p id="d60c" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在代码中应用这个模型非常简单。我们首先将数据加载到预测器对象:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="ea85" class="mm lv it ne b gy ni nj l nk nl">train <strong class="ne iu">=</strong> pd<strong class="ne iu">.</strong>read_csv('Hourly-train.csv',index_col<strong class="ne iu">=</strong>0)<br/>y <strong class="ne iu">=</strong> train<strong class="ne iu">.</strong>loc['H7']<strong class="ne iu">.</strong>to_list()<br/>current_dates <strong class="ne iu">=</strong> pd<strong class="ne iu">.</strong>date_range(<br/>    start<strong class="ne iu">=</strong>'2015-01-07 12:00',<br/>    freq<strong class="ne iu">=</strong>'H',<br/>    periods<strong class="ne iu">=</strong>len(y)<br/>)<strong class="ne iu">.</strong>to_list()<br/>f <strong class="ne iu">=</strong> Forecaster(y<strong class="ne iu">=</strong>y,current_dates<strong class="ne iu">=</strong>current_dates)</span></pre><p id="a469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以绘制这个系列，以便更好地了解我们在做什么:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="628f" class="mm lv it ne b gy ni nj l nk nl">f<strong class="ne iu">.</strong>plot()<br/>plt<strong class="ne iu">.</strong>show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/e97088a427ca9fcbe2c446110c5547ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pCEiTc9b3WkhussJ-yb_ig.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="da19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们留出25%的数据进行测试，并预测未来的48个时间段:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6dc0" class="mm lv it ne b gy ni nj l nk nl">f<strong class="ne iu">.</strong>set_test_length(.25)<br/>f<strong class="ne iu">.</strong>generate_future_dates(48)</span></pre><p id="0a13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以指定一个超参数网格来找到调优该模型的最佳方式。这个网格在大多数情况下都能找到一个很好的模型，但是你也可以考虑给它增加更多的θ值。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4b72" class="mm lv it ne b gy ni nj l nk nl">from<strong class="ne iu"> </strong>darts.utils.utils import (<br/>    SeasonalityMode, <br/>    TrendMode, <br/>    ModelMode<br/>)</span><span id="8000" class="mm lv it ne b gy no nj l nk nl">theta_grid <strong class="ne iu">=</strong> {<br/>    'theta':[0.5,1,1.5,2,2.5,3],<br/>    'model_mode':[<br/>        ModelMode<strong class="ne iu">.</strong>ADDITIVE,<br/>        ModelMode<strong class="ne iu">.</strong>MULTIPLICATIVE<br/>    ],<br/>    'season_mode':[<br/>        SeasonalityMode<strong class="ne iu">.</strong>MULTIPLICATIVE,<br/>        SeasonalityMode<strong class="ne iu">.</strong>ADDITIVE<br/>    ],<br/>    'trend_mode':[<br/>        TrendMode<strong class="ne iu">.</strong>EXPONENTIAL,<br/>        TrendMode<strong class="ne iu">.</strong>LINEAR<br/>    ],<br/>}</span></pre><p id="3b13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们使用三重时间序列交叉验证来寻找最佳的超参数组合。这将基于我们的训练集创建3个数据段，其中每个验证集的长度为131个观察值，并且具有所有上述超参数组合的模型根据每个验证集之前的数据进行训练。基于哪个模型返回所有褶皱的最佳平均MAPE值来选择最终模型。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="424b" class="mm lv it ne b gy ni nj l nk nl">f<strong class="ne iu">.</strong>set_validation_metric('mape')<br/>f<strong class="ne iu">.</strong>set_estimator('theta')<br/>f<strong class="ne iu">.</strong>ingest_grid(theta_grid)<br/>f<strong class="ne iu">.</strong>cross_validate(k<strong class="ne iu">=</strong>3)</span></pre><p id="9389" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从交叉验证中选择的最佳参数是:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="be34" class="mm lv it ne b gy ni nj l nk nl">&gt;&gt;&gt; f<strong class="ne iu">.</strong>best_params<br/>{'theta': 1,<br/> 'model_mode': &lt;ModelMode.ADDITIVE: 'additive'&gt;,<br/> 'season_mode': &lt;SeasonalityMode.MULTIPLICATIVE: 'multiplicative'&gt;,<br/> 'trend_mode': &lt;TrendMode.EXPONENTIAL: 'exponential'&gt;}</span></pre><p id="8976" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们使用选择的模型预测我们的测试集和48期预测范围:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4d2c" class="mm lv it ne b gy ni nj l nk nl">f<strong class="ne iu">.</strong>auto_forecast()</span></pre><p id="2ad0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在可以看到可视化的测试结果:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3f32" class="mm lv it ne b gy ni nj l nk nl">f<strong class="ne iu">.</strong>plot_test_set(ci<strong class="ne iu">=</strong>True)<br/>plt<strong class="ne iu">.</strong>show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/9f97cc0af1ba2ce6824781c069674b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M34KDfv6kKnSDpZePi9g6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="abbf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以及预测结果:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4c6d" class="mm lv it ne b gy ni nj l nk nl">f<strong class="ne iu">.</strong>plot(ci<strong class="ne iu">=</strong>True)<br/>plt<strong class="ne iu">.</strong>show()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/957effff9ef96a2aad44e9a3520bd6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gud2HDpRH1ypjBnck30skA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c977" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这返回了5.5%的测试集MAPE结果。交叉验证过程中的平均验证MAPE为7.5%。验证MAPE稍微差一点是有道理的，因为它在每次验证迭代中要学习的训练集更少。</p><p id="f363" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设一段时间过去了，我们现在有一些新的数据要引入到这个模型中，我们可以衡量它在48期预测中的表现。让我们看看效果如何。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="72a7" class="mm lv it ne b gy ni nj l nk nl">test = pd.read_csv('Hourly-test.csv',index_col=0)<br/>y_test = test.loc['H7'].to_list()<br/>future_dates = pd.date_range(<br/>    start=max(current_dates) + pd.Timedelta(hours=1),<br/>    freq='H',<br/>    periods=len(y_test),<br/>).to_list()</span><span id="2b78" class="mm lv it ne b gy no nj l nk nl">fcst = f.export('lvl_fcsts')<br/>mape = np.mean(<br/>   [np.abs((f - a) / a) for f, a in zip(fcst['theta'],y_test)]<br/>)</span></pre><p id="06f6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这返回了6%的值，正好在我们的测试集和验证度量之间，这正是我们所期望的！</p><h1 id="4f67" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="15b2" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">theta模型是时间序列分析师的强大工具，概念简单，易于调整，易于评估。希望你觉得这个教程有用！如果是的话，请考虑以后使用scalecast，为其成长做点贡献！</p><div class="nq nr gp gr ns nt"><a href="https://github.com/mikekeith52/scalecast" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">GitHub - mikekeith52/scalecast:从业者的预测库</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">Scalecast是一个轻量级的建模过程、包装器和结果容器，旨在为那些正在寻找…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div><h1 id="653d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">参考</h1><p id="40c3" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">动词 （verb的缩写）Assimakopoulos，K. Nikolopoulos，theta模型:预测的分解方法，国际预测杂志，第16卷，2000年第4期，第521-530页，ISSN 0169-2070，<a class="ae nm" href="https://doi.org/10.1016/S0169-2070(00)00066-2." rel="noopener ugc nofollow" target="_blank">https://doi . org/10.1016/s 0169-2070(00)00066-2。</a><br/>(<a class="ae nm" href="https://www.sciencedirect.com/science/article/pii/S0169207000000662" rel="noopener ugc nofollow" target="_blank">https://www . science direct . com/science/article/pii/s 0169207000000662</a>)</p></div></div>    
</body>
</html>