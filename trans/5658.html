<html>
<head>
<title>Tips and Tricks for Loading Large CSV Files into Pandas DataFrames — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将大型 CSV 文件加载到 Pandas 数据帧的提示和技巧—第 2 部分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/tips-and-tricks-for-loading-large-csv-files-into-pandas-dataframes-part-2-5fc02fc4e3ab#2022-12-22">https://towardsdatascience.com/tips-and-tricks-for-loading-large-csv-files-into-pandas-dataframes-part-2-5fc02fc4e3ab#2022-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="27eb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何有选择地将 CSV 文件的一部分加载到数据帧中，同时减少其内存占用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed7943d498f3b0190f994ef63877d143.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mhqiN1yJ-Isa6LEp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="a63f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的上一篇文章——<strong class="lb iu">将大型 csv 文件加载到 Pandas DataFrames 的提示和技巧——第 1 部分</strong>(<a class="ae ky" rel="noopener" target="_blank" href="/tips-and-tricks-for-loading-large-csv-files-into-pandas-dataframes-part-1-fac6e351fe79">https://towards data science . com/Tips-and-Tricks-for-load-Large-CSV-Files-into-Pandas-data frames-Part-1-fac 6 e 351 Fe 79</a>)中，我分享了一些如何将大型 CSV 文件中的特定列和行加载到 Pandas DataFrames 中的技巧。在本文中，我想继续叙述，但这一次我想把重点放在非常大的数据集上，这些数据集要么太大，无法一次性加载所有内容，要么加载时间太长，以至于无法实际处理这些数据集。一旦您成功加载了数据集，我还将向您展示如何优化数据帧的内存占用，从而使您更容易执行数据分析。</p><h1 id="c465" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们的数据集</h1><p id="6a6c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于本文中的例子，我使用的是来自 https://www.kaggle.com/datasets/dilwong/flightprices<a class="ae ky" href="https://www.kaggle.com/datasets/dilwong/flightprices" rel="noopener ugc nofollow" target="_blank">的<strong class="lb iu">航班价格</strong>数据集。数据集中的每一行都是 2022 年 4 月 16 日至 2022 年 10 月 5 日之间 Expedia 上的可购买机票，往返于以下机场:ATL、DFW、DEN、ORD、LAX、CLT、MIA、JFK、EWR、SFO、DTW、BOS、PHL、LGA、IAD、OAK。</a></p><blockquote class="ms mt mu"><p id="ed53" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">许可证类型:归属 4.0 国际版(CC BY 4.0)</p></blockquote><p id="3b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择这个数据集的主要原因是它非常大——31GB，包含 8200 多万行和 27 列。因此，对于那些机器内存有限的人来说，这应该是一个很好的现实挑战。</p><h1 id="4d51" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将整个 CSV 文件加载到数据帧中</h1><p id="189e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想尝试的第一件事是将 CSV 文件正常加载到数据帧中。我想对加载过程计时，看看加载这样一个文件需要多长时间:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="4d09" class="ne lw it na b be nf ng l nh ni">import time<br/>import pandas as pd<br/><br/>start = time.time()<br/><br/>df = pd.read_csv('itineraries.csv')<br/><br/>print(time.time() - start, 'seconds')</span></pre><p id="e7eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我等了又等。最终，将整个 CSV 文件加载到 Pandas 数据帧需要 1164 秒(接近 20 分钟)。</p><blockquote class="ms mt mu"><p id="2d42" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">作为参考，我的机器是 32GB 内存的 Mac Studio。上面的代码片段甚至无法在我的 8GB 内存的老式 M1 Mac Mini 上运行(内核在试图加载 CSV 文件时死亡)。</p></blockquote><p id="e796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看数据框:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="8e43" class="ne lw it na b be nf ng l nh ni">display(df)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/0cba5d7391aab957939cc42ad3318385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qwja5h02DBNYGbgi27qm4g.png"/></div></div></figure><p id="bf8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据帧有 82，138，753 (&gt; 8，200 万)行和 27 列。要查看数据帧使用了多少内存，使用<code class="fe nk nl nm na b">info()</code>函数并将<code class="fe nk nl nm na b">memory_usage</code>参数设置为<code class="fe nk nl nm na b">deep</code>:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="4514" class="ne lw it na b be nf ng l nh ni">display(df.info(memory_usage='deep'))</span></pre><p id="44a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从下面的结果中，您可以看到 dataframe 的内存占用为 110.5 GB！</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="d0a9" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>RangeIndex: 82138753 entries, 0 to 82138752<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype  <br/>---  ------                             -----  <br/> 0   legId                              object <br/> 1   searchDate                         object <br/> 2   flightDate                         object <br/> 3   startingAirport                    object <br/> 4   destinationAirport                 object <br/> 5   fareBasisCode                      object <br/> 6   travelDuration                     object <br/> 7   elapsedDays                        int64  <br/> 8   isBasicEconomy                     bool   <br/> 9   isRefundable                       bool   <br/> 10  isNonStop                          bool   <br/> 11  baseFare                           float64<br/> 12  totalFare                          float64<br/> 13  seatsRemaining                     int64  <br/> 14  totalTravelDistance                float64<br/> 15  segmentsDepartureTimeEpochSeconds  object <br/> 16  segmentsDepartureTimeRaw           object <br/> 17  segmentsArrivalTimeEpochSeconds    object <br/> 18  segmentsArrivalTimeRaw             object <br/> 19  segmentsArrivalAirportCode         object <br/> 20  segmentsDepartureAirportCode       object <br/> 21  segmentsAirlineName                object <br/> 22  segmentsAirlineCode                object <br/> 23  segmentsEquipmentDescription       object <br/> 24  segmentsDurationInSeconds          object <br/> 25  segmentsDistance                   object <br/> 26  segmentsCabinCode                  object <br/>dtypes: bool(3), float64(3), int64(2), object(19)<br/><strong class="na iu">memory usage: 110.5 GB</strong></span></pre><h1 id="2b1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">按块加载数据帧</h1><p id="7075" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">显然，加载如此大的 CSV 文件是一件费时费力的事情(如果一开始就有可能的话)。因此，必须有更好的方法来优化流程。</p><p id="70f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问自己的第一个问题是:您真的需要 CSV 文件中的所有行和列吗？例如，您可能只需要起始机场为 ATL 的所有行，而忽略其余的行。但是，将整个 CSV 文件加载到一个数据帧中，只删除所有不需要的行，这种做法是不可取的，因为您的计算机可能甚至没有足够的内存来容纳整个数据帧。这就是<em class="mv">分块</em>有用的地方。</p><p id="5da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分块允许您以较小的块(因此得名)加载数据帧，而不是一次性加载所有数据帧。每个块都是您正在加载的整个数据帧的子集，每个块的大小可以根据您的需要进行定制。当加载每个块时，您有机会过滤数据帧中的行或列，并仅保留那些您需要进行进一步分析的行或列。</p><p id="7691" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要对数据帧进行分块，使用<code class="fe nk nl nm na b">read_csv()</code>函数中的<code class="fe nk nl nm na b">chunksize</code>参数:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="9fc2" class="ne lw it na b be nf ng l nh ni">import time<br/>import pandas as pd<br/><br/>start = time.time()<br/>chunks = pd.read_csv('itineraries.csv', chunksize=100000)<br/>print(time.time() - start, ' seconds')<br/><br/># result is a TextFileReader object<br/>chunks</span></pre><p id="6985" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，当您运行它时，控件几乎立即返回，输出显示<code class="fe nk nl nm na b">chunks</code>变量的类型是<code class="fe nk nl nm na b">pandas.io.parsers.readers.TextFileReader</code>。</p><p id="ded1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe nk nl nm na b">chunks</code>想象成一个指向 CSV 文件中第一行的文件指针，它准备开始读取前 100，000 行(如<code class="fe nk nl nm na b">chunksize</code>参数中所指定的)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/97b35e170734c759f1e0e4bbb9e736da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6LtrmudVyd3W2J3-qUXlw.png"/></div></div></figure><p id="0452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，<code class="fe nk nl nm na b">chunks</code>是一个<em class="mv"> iterable </em>，您可以遍历它将 CSV 文件中的所有行加载到一个 dataframe 中，一次 100，000 行。</p><p id="6e74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了查看如何遍历<code class="fe nk nl nm na b">chunks</code>变量，让我们定义一个名为<code class="fe nk nl nm na b">process_chunk()</code>的函数，其中我将只获取<code class="fe nk nl nm na b">startingAirport</code>列的值为“<strong class="lb iu"> ATL </strong>”的所有行:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="60ba" class="ne lw it na b be nf ng l nh ni">def process_chunk(df):<br/>    df = df.query('startingAirport == "ATL"') <br/>    print(df.shape)<br/>    return df</span></pre><blockquote class="ms mt mu"><p id="c35b" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">如果您愿意，也可以在此函数中过滤列。</p></blockquote><p id="a867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段显示了如何使用<code class="fe nk nl nm na b">chunks</code> iterable 加载整个 CSV 文件:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="a203" class="ne lw it na b be nf ng l nh ni">chunk_list = []                # used for storing dataframes<br/>for chunk in chunks:           # each chunk is a dataframe    <br/>    # perform data filtering <br/>    filtered_chunk = process_chunk(chunk)<br/>    <br/>    # Once the data filtering is done, append the filtered chunk to list<br/>    chunk_list.append(filtered_chunk)</span></pre><p id="24b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe nk nl nm na b">chunks</code>变量的每次迭代，<code class="fe nk nl nm na b">chunk</code>迭代器将包含一个包含 100，000 行的数据帧。然后数据帧被传入<code class="fe nk nl nm na b">process_chunk()</code>，在那里进行过滤。当过滤后的数据帧返回时，它被附加到一个名为<code class="fe nk nl nm na b">chunk_list</code>的列表中。</p><p id="680b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要组合列表中的所有数据帧，使用<code class="fe nk nl nm na b">concat()</code>函数:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="c590" class="ne lw it na b be nf ng l nh ni"># concat all the dfs in the list into a single dataframe <br/>df_concat = pd.concat(chunk_list)</span></pre><p id="f97c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们打印出加载的最终数据帧:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="c424" class="ne lw it na b be nf ng l nh ni">display(df_concat)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/04ab50177a63e42d2c06134013068674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QvtwVUaifVZ9MQuCIBiuvw.png"/></div></div></figure><p id="7f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到最终的数据帧包含 5，312，028 行。</p><blockquote class="nq"><p id="8a27" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">通过使用分块，您现在可以有选择地将 CSV 的一部分加载到数据帧中，而不是尝试从整个 CSV 文件中加载所有内容。</p></blockquote><h1 id="70cd" class="lv lw it bd lx ly lz ma mb mc md me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">检查数据帧的内存占用</h1><p id="c875" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们的数据帧现在有 500 万行，而不是原来的 8200 万行，这是一个更易于管理的大小。让我们看看它使用了多少内存:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="dc54" class="ne lw it na b be nf ng l nh ni">df_concat.info()</span></pre><p id="2c30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意输出的最后一行:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="6433" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5312028 entries, 0 to 82137143<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype  <br/>---  ------                             -----  <br/> 0   legId                              object <br/> 1   searchDate                         object <br/> 2   flightDate                         object <br/> 3   startingAirport                    object <br/> 4   destinationAirport                 object <br/> 5   fareBasisCode                      object <br/> 6   travelDuration                     object <br/> 7   elapsedDays                        int64  <br/> 8   isBasicEconomy                     bool   <br/> 9   isRefundable                       bool   <br/> 10  isNonStop                          bool   <br/> 11  baseFare                           float64<br/> 12  totalFare                          float64<br/> 13  seatsRemaining                     int64  <br/> 14  totalTravelDistance                float64<br/> 15  segmentsDepartureTimeEpochSeconds  object <br/> 16  segmentsDepartureTimeRaw           object <br/> 17  segmentsArrivalTimeEpochSeconds    object <br/> 18  segmentsArrivalTimeRaw             object <br/> 19  segmentsArrivalAirportCode         object <br/> 20  segmentsDepartureAirportCode       object <br/> 21  segmentsAirlineName                object <br/> 22  segmentsAirlineCode                object <br/> 23  segmentsEquipmentDescription       object <br/> 24  segmentsDurationInSeconds          object <br/> 25  segmentsDistance                   object <br/> 26  segmentsCabinCode                  object <br/>dtypes: bool(3), float64(3), int64(2), object(19)<br/><strong class="na iu">memory usage: 1.0+ GB</strong></span></pre><p id="63ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1+ GB 的内存使用量只是一个估计。要查看完整的内存使用情况，您需要将<code class="fe nk nl nm na b">memory_usage</code>参数设置为<code class="fe nk nl nm na b">deep</code>:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="550f" class="ne lw it na b be nf ng l nh ni">df_concat.info(memory_usage='deep')</span></pre><p id="132c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果现在显示实际内存占用为 7.1 GB:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="b46a" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5312028 entries, 0 to 82137143<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype  <br/>---  ------                             -----  <br/> 0   legId                              object <br/> 1   searchDate                         object <br/> 2   flightDate                         object <br/> 3   startingAirport                    object <br/> 4   destinationAirport                 object <br/> 5   fareBasisCode                      object <br/> 6   travelDuration                     object <br/> 7   elapsedDays                        int64  <br/> 8   isBasicEconomy                     bool   <br/> 9   isRefundable                       bool   <br/> 10  isNonStop                          bool   <br/> 11  baseFare                           float64<br/> 12  totalFare                          float64<br/> 13  seatsRemaining                     int64  <br/> 14  totalTravelDistance                float64<br/> 15  segmentsDepartureTimeEpochSeconds  object <br/> 16  segmentsDepartureTimeRaw           object <br/> 17  segmentsArrivalTimeEpochSeconds    object <br/> 18  segmentsArrivalTimeRaw             object <br/> 19  segmentsArrivalAirportCode         object <br/> 20  segmentsDepartureAirportCode       object <br/> 21  segmentsAirlineName                object <br/> 22  segmentsAirlineCode                object <br/> 23  segmentsEquipmentDescription       object <br/> 24  segmentsDurationInSeconds          object <br/> 25  segmentsDistance                   object <br/> 26  segmentsCabinCode                  object <br/>dtypes: bool(3), float64(3), int64(2), object(19)<br/><strong class="na iu">memory usage: 7.1 GB</strong></span></pre><p id="397e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么会有巨大的差异？为了理解为什么，让我们使用<code class="fe nk nl nm na b">memory_usage()</code>函数来看看每一列使用了多少内存:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="2d1c" class="ne lw it na b be nf ng l nh ni">df_concat.memory_usage()</span></pre><p id="c37d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，似乎所有的列(除了三个<code class="fe nk nl nm na b">bool</code>列——<strong class="lb iu">是基础经济</strong>、<strong class="lb iu">是可归还的</strong>和<strong class="lb iu">是不停止的</strong>)都使用相同数量的内存:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="5c19" class="ne lw it na b be nf ng l nn ni">Index                                42496224<br/>legId                                42496224<br/>searchDate                           42496224<br/>flightDate                           42496224<br/>startingAirport                      42496224<br/>destinationAirport                   42496224<br/>fareBasisCode                        42496224<br/>travelDuration                       42496224<br/>elapsedDays                          42496224<br/>isBasicEconomy                        5312028<br/>isRefundable                          5312028<br/>isNonStop                             5312028<br/>baseFare                             42496224<br/>totalFare                            42496224<br/>seatsRemaining                       42496224<br/>totalTravelDistance                  42496224<br/>segmentsDepartureTimeEpochSeconds    42496224<br/>segmentsDepartureTimeRaw             42496224<br/>segmentsArrivalTimeEpochSeconds      42496224<br/>segmentsArrivalTimeRaw               42496224<br/>segmentsArrivalAirportCode           42496224<br/>segmentsDepartureAirportCode         42496224<br/>segmentsAirlineName                  42496224<br/>segmentsAirlineCode                  42496224<br/>segmentsEquipmentDescription         42496224<br/>segmentsDurationInSeconds            42496224<br/>segmentsDistance                     42496224<br/>segmentsCabinCode                    42496224<br/>dtype: int64</span></pre><p id="6dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过一些简单的计算，可以看到所有这些列(除了三个<code class="fe nk nl nm na b">bool</code>列)中的每一行都使用了 8 个字节(42496224 字节/ 5312028 行)。为什么会这样呢？对于类型为<code class="fe nk nl nm na b">int64</code>和<code class="fe nk nl nm na b">float64</code>的列，这是合理的，因为 64 位等于 8 个字节。例如，<strong class="lb iu">elapseday</strong>列的每个值将占用 8 个字节(<code class="fe nk nl nm na b">int64</code>):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/5ec99a0971b9feb259b8409e3dac824e.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*4khuUSZ2NLdWLmm9NOCYZg.png"/></div></div></figure><p id="ca38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那些<code class="fe nk nl nm na b">object</code>栏目怎么样？在内部，对象列将它们的值分别存储在其他内存位置。所以为一个<code class="fe nk nl nm na b">object</code>列存储的实际值实际上是存储<code class="fe nk nl nm na b">object</code>值的位置的内存地址。下面是一个<strong class="lb iu">搜索日期</strong>列的示例，它属于<code class="fe nk nl nm na b">object</code>类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/ba876c762497140d18148db34b7aefa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*mJh8P2Cjq7nSXUF7hlwlJw.png"/></div></figure><p id="0846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了准确地找出一个<code class="fe nk nl nm na b">object</code>列使用了多少存储，您需要将<code class="fe nk nl nm na b">memory_usage()</code>函数中的<code class="fe nk nl nm na b">deep</code>参数设置为<code class="fe nk nl nm na b">True</code>:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="ecbe" class="ne lw it na b be nf ng l nh ni">df_concat.memory_usage(deep=True)</span></pre><p id="02bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出现在更准确地显示了每一列使用了多少内存:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="c3eb" class="ne lw it na b be nf ng l nn ni">Index                                 42496224<br/>legId                                472770492<br/>searchDate                           355905876<br/>flightDate                           355905876<br/>startingAirport                      318721680<br/>destinationAirport                   318721680<br/>fareBasisCode                        343071603<br/>travelDuration                       339818490<br/>elapsedDays                           42496224<br/>isBasicEconomy                         5312028<br/>isRefundable                           5312028<br/>isNonStop                              5312028<br/>baseFare                              42496224<br/>totalFare                             42496224<br/>seatsRemaining                        42496224<br/>totalTravelDistance                   42496224<br/>segmentsDepartureTimeEpochSeconds    403417584<br/>segmentsDepartureTimeRaw             579572987<br/>segmentsArrivalTimeEpochSeconds      403417584<br/>segmentsArrivalTimeRaw               579572987<br/>segmentsArrivalAirportCode           338518225<br/>segmentsDepartureAirportCode         338518225<br/>segmentsAirlineName                  410952127<br/>segmentsAirlineCode                  329246888<br/>segmentsEquipmentDescription         438243766<br/>segmentsDurationInSeconds            350013948<br/>segmentsDistance                     341426543<br/>segmentsCabinCode                    357085873<br/>dtype: int64</span></pre><p id="5de5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<strong class="lb iu"> searchDate </strong>列中的每个值使用<strong class="lb iu"> 67 </strong>字节(355905876 字节/ 5312028 行)，<strong class="lb iu"> startingAirport </strong>列中的每个值使用<strong class="lb iu"> 60 </strong>字节(318721680 字节/ 5312028 行)。</p><h1 id="013c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">转换类型</h1><p id="bd3c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从上一节可以看出，两列使用的内存— <strong class="lb iu"> searchDate </strong>和<strong class="lb iu"> flightDate </strong>，每个值(这是一个日期)在存储为<code class="fe nk nl nm na b">object</code>类型时占用 67 个字节。由于这些列包含日期，将它们存储为<code class="fe nk nl nm na b">object</code>类型是低效的，因为以后操作它们会很困难。与其这样，不如把它们转换成<code class="fe nk nl nm na b">datetime64</code>型。这样做还可以节省内存，因为它们现在每个只占用 8 个字节。</p><p id="4135" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将这些列转换成<code class="fe nk nl nm na b">datetime64</code>类型:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="73fd" class="ne lw it na b be nf ng l nh ni">df_concat["searchDate"] = df_concat["searchDate"].astype('datetime64')<br/>df_concat["flightDate"] = df_concat["flightDate"].astype('datetime64')</span></pre><p id="100d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以检查每一列的内存使用情况:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="0910" class="ne lw it na b be nf ng l nh ni">df_concat.memory_usage(deep=True)</span></pre><p id="273c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以看到两列的内存使用都减少到了 42496224 字节。每个值按预期占用 8 个字节(42496224 个字节/ 5312028 行):</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="bee2" class="ne lw it na b be nf ng l nn ni">Index                                 42496224<br/>legId                                472770492<br/><strong class="na iu">searchDate                            42496224<br/>flightDate                            42496224<br/></strong>startingAirport                      318721680<br/>destinationAirport                   318721680<br/>fareBasisCode                        343071603<br/>travelDuration                       339818490<br/>elapsedDays                           42496224<br/>isBasicEconomy                         5312028<br/>isRefundable                           5312028<br/>isNonStop                              5312028<br/>baseFare                              42496224<br/>totalFare                             42496224<br/>seatsRemaining                        42496224<br/>totalTravelDistance                   42496224<br/>segmentsDepartureTimeEpochSeconds    403417584<br/>segmentsDepartureTimeRaw             579572987<br/>segmentsArrivalTimeEpochSeconds      403417584<br/>segmentsArrivalTimeRaw               579572987<br/>segmentsArrivalAirportCode           338518225<br/>segmentsDepartureAirportCode         338518225<br/>segmentsAirlineName                  410952127<br/>segmentsAirlineCode                  329246888<br/>segmentsEquipmentDescription         438243766<br/>segmentsDurationInSeconds            350013948<br/>segmentsDistance                     341426543<br/>segmentsCabinCode                    357085873<br/>dtype: int64</span></pre><p id="d5c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在想知道数据帧的内存占用量:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="d653" class="ne lw it na b be nf ng l nh ni">df_concat.info(memory_usage='deep')</span></pre><p id="a1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它现在已从 7.1 GB 减少到 6.5 GB:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="fc05" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5312028 entries, 0 to 82137143<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype         <br/>---  ------                             -----         <br/> 0   legId                              object        <br/><strong class="na iu"> 1   searchDate                         datetime64[ns]<br/> 2   flightDate                         datetime64[ns]</strong><br/> 3   startingAirport                    object        <br/> 4   destinationAirport                 object        <br/> 5   fareBasisCode                      object        <br/> 6   travelDuration                     object        <br/> 7   elapsedDays                        int64         <br/> 8   isBasicEconomy                     bool          <br/> 9   isRefundable                       bool          <br/> 10  isNonStop                          bool          <br/> 11  baseFare                           float64       <br/> 12  totalFare                          float64       <br/> 13  seatsRemaining                     int64         <br/> 14  totalTravelDistance                float64       <br/> 15  segmentsDepartureTimeEpochSeconds  object        <br/> 16  segmentsDepartureTimeRaw           object        <br/> 17  segmentsArrivalTimeEpochSeconds    object        <br/> 18  segmentsArrivalTimeRaw             object        <br/> 19  segmentsArrivalAirportCode         object        <br/> 20  segmentsDepartureAirportCode       object        <br/> 21  segmentsAirlineName                object        <br/> 22  segmentsAirlineCode                object        <br/> 23  segmentsEquipmentDescription       object        <br/> 24  segmentsDurationInSeconds          object        <br/> 25  segmentsDistance                   object        <br/> 26  segmentsCabinCode                  object        <br/>dtypes: bool(3), datetime64[ns](2), float64(3), int64(2), object(17)<br/><strong class="na iu">memory usage: 6.5 GB</strong></span></pre><blockquote class="nq"><p id="98b8" class="nr ns it bd nt nu of og oh oi oj lu dk translated">将与日期相关的列转换为<code class="fe nk nl nm na b">datetime64</code>类型不仅可以节省内存，还可以更容易地执行数据分析。</p></blockquote><h1 id="3c5b" class="lv lw it bd lx ly lz ma mb mc md me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">向下浇铸的柱子</h1><p id="ba4e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以对 dateframe 进行的下一个改进是向下转换所有的数字字段。考虑一下<strong class="lb iu">座位保留</strong>栏。如果您检查该列中的值范围(最小和最大)，您将看到最小值为 0，最大值为 10:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="b71b" class="ne lw it na b be nf ng l nh ni">df_concat['seatsRemaining'].min() # 0 <br/>df_concat['seatsRemaining'].max() # 10</span></pre><p id="f7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一个<code class="fe nk nl nm na b">int64</code>类型被用来存储这个列。一个<code class="fe nk nl nm na b">int64</code>列可以存储从-(2⁶-1)到 2⁶的值。显然，这种数据类型对于该列来说是一种大材小用，因为它只存储非负值，并且最大值不超过 10。这同样适用于其他列，例如<strong class="lb iu">基本费用</strong>、<strong class="lb iu">总费用</strong>，以及<strong class="lb iu">总行程距离</strong>。为了减少这种内存浪费，我们需要将这种列使用的类型向下转换为仅足以保存它们的值的类型。例如，<strong class="lb iu"> seatsRemaining </strong>列可以很好地处理<code class="fe nk nl nm na b">uint8</code>数据类型，它可以保存从 0 到(2⁸-1)或 0 到 255 的值。</p><p id="3ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试向下转换所有的数字列(整数和浮点)。</p><p id="c50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，定义一个名为<code class="fe nk nl nm na b">memory_usage()</code>的函数来接收 Pandas 数据帧或序列，并返回其总内存使用量:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="7f48" class="ne lw it na b be nf ng l nh ni">def mem_usage(obj):<br/>    if isinstance(obj, pd.DataFrame):<br/>        usage_b = obj.memory_usage(deep=True).sum()<br/>    else: # we assume if not a df then it's a series<br/>        usage_b = obj.memory_usage(deep=True)<br/><br/>    usage_mb = usage_b / 1024 ** 2     # bytes to megabytes    <br/>    return "{:03.2f} MB".format(usage_mb)</span></pre><p id="1694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，定义一个名为<code class="fe nk nl nm na b">downcast_type()</code>的函数来接收一个数据帧，并将一种类型的列转换为一种新的类型:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="8b7c" class="ne lw it na b be nf ng l nh ni">def downcast_type(df, old_type, new_type):<br/>    # get all the columns with the specified type – old_type<br/>    df_oldtype = df.select_dtypes(include=[old_type])<br/><br/>    # convert all the columns from old_type to new_type<br/>    df_newtype = df_oldtype.apply(pd.to_numeric, downcast=new_type)<br/> <br/>    # print out the memory usage of old_type and new_type<br/>    print(f'{old_type} memory usage: {mem_usage(df_oldtype)}')<br/>    print(f'{new_type} memory usage: {mem_usage(df_newtype)}')<br/><br/>    return df_newtype</span></pre><p id="263f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">apply()</code>函数中的<code class="fe nk nl nm na b">downcast</code>参数根据以下规则将结果数据向下转换为可能的最小数字数据类型:</p><ul class=""><li id="55dd" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated"><code class="fe nk nl nm na b">integer</code>或<code class="fe nk nl nm na b">signed</code>’:最小有符号整数类型(min。:np.int8)</li><li id="b31c" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nk nl nm na b">unsigned</code>':最小的无符号整型数据类型(min。:np.uint8)</li><li id="84b1" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated"><code class="fe nk nl nm na b">float</code>':最小浮点数据类型(min。:np.float32)</li></ul><blockquote class="ms mt mu"><p id="5aab" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated"><strong class="lb iu">来源</strong>:<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.to_numeric.html" rel="noopener ugc nofollow" target="_blank">https://pandas . pydata . org/docs/reference/API/pandas . to _ numeric . html</a></p></blockquote><p id="6889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试将所有整数列向下转换为无符号的:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="0c87" class="ne lw it na b be nf ng l nh ni">df_converted_int = downcast_type(df_concat, "int", "unsigned")</span></pre><blockquote class="ms mt mu"><p id="df71" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">对于 Windows，将上述语句中的“<code class="fe nk nl nm na b">int</code>”替换为“<code class="fe nk nl nm na b">int64</code>”</p></blockquote><p id="8ec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将看到以下输出:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="b86e" class="ne lw it na b be nf ng l nn ni">int memory usage: 121.58 MB<br/>unsigned memory usage: 50.66 MB</span></pre><p id="904b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着数据帧中所有整数列的内存已从 121.58 MB 减少到 50.66 MB。</p><p id="8952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们也向下转换所有浮点列:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="5a75" class="ne lw it na b be nf ng l nh ni">df_converted_float = downcast_type(df_concat, "float", "float")</span></pre><p id="b0fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出显示了这些浮点列的内存使用量的减少:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="f745" class="ne lw it na b be nf ng l nn ni">float memory usage: 162.11 MB<br/>float memory usage: 101.32 MB</span></pre><p id="5de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我现在将在<code class="fe nk nl nm na b">df_concat</code>中创建一个 dataframe 的副本，然后替换所有已经向下转换的列:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="6cd0" class="ne lw it na b be nf ng l nh ni"># make a copy of the dataframe and replace the columns with the downcasted types<br/>optimized_df = df_concat.copy()<br/>optimized_df[df_converted_int.columns] = df_converted_int<br/>optimized_df[df_converted_float.columns] = df_converted_float</span></pre><p id="32c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以检查类型已向下转换的各种列:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="f6be" class="ne lw it na b be nf ng l nh ni">optimized_df.info(memory_usage='deep')</span></pre><p id="081a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下粗体输出显示了已向下转换的列:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="1c37" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5312028 entries, 0 to 82137143<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype         <br/>---  ------                             -----         <br/> 0   legId                              object        <br/> 1   searchDate                         datetime64[ns]<br/> 2   flightDate                         datetime64[ns]<br/> 3   startingAirport                    object        <br/> 4   destinationAirport                 object        <br/> 5   fareBasisCode                      object        <br/> 6   travelDuration                     object        <br/><strong class="na iu"> 7   elapsedDays                        uint8        </strong> <br/> 8   isBasicEconomy                     bool          <br/> 9   isRefundable                       bool          <br/> 10  isNonStop                          bool          <br/><strong class="na iu"> 11  baseFare                           float32       <br/> 12  totalFare                          float32       <br/> 13  seatsRemaining                     uint8   </strong>      <br/><strong class="na iu"> 14  totalTravelDistance                float32       </strong><br/> 15  segmentsDepartureTimeEpochSeconds  object        <br/> 16  segmentsDepartureTimeRaw           object        <br/> 17  segmentsArrivalTimeEpochSeconds    object        <br/> 18  segmentsArrivalTimeRaw             object        <br/> 19  segmentsArrivalAirportCode         object        <br/> 20  segmentsDepartureAirportCode       object        <br/> 21  segmentsAirlineName                object        <br/> 22  segmentsAirlineCode                object        <br/> 23  segmentsEquipmentDescription       object        <br/> 24  segmentsDurationInSeconds          object        <br/> 25  segmentsDistance                   object        <br/> 26  segmentsCabinCode                  object        <br/>dtypes: bool(3), datetime64[ns](2), float32(3), object(17), uint8(2)<br/><strong class="na iu">memory usage: 6.4 GB</strong></span></pre><p id="d37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存占用进一步减少到 6.4 GB。</p><blockquote class="nq"><p id="8755" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">向下转换通过自动检查每一列中的值的范围并将该列转换为足以容纳现有值的数据类型来帮助您节省内存。</p></blockquote><h1 id="ecea" class="lv lw it bd lx ly lz ma mb mc md me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">将对象类型转换为类别</h1><p id="4769" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">数据帧的内存占用仍然相对较大。真正的罪魁祸首是我们前面看到的那些类型为<code class="fe nk nl nm na b">object</code>的列。</p><p id="7af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们找到所有这些<code class="fe nk nl nm na b">object</code>列，并更详细地检查它们:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="ce4a" class="ne lw it na b be nf ng l nh ni"># get all the columns with the Object type<br/>df_obj = optimized_df.select_dtypes(include=['object']).copy()<br/>df_unique_objs = df_obj.describe()<br/><br/>print(df_unique_objs)</span></pre><p id="ef48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是输出结果:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="6e66" class="ne lw it na b be nf ng l nn ni">                                   legId startingAirport destinationAirport  \<br/>count                            5312028         <strong class="na iu">5312028</strong>            <strong class="na iu">5312028</strong>   <br/>unique                            362460               <strong class="na iu">1</strong>                 <strong class="na iu">15</strong>   <br/>top     3c18dd8a485f8f15b31e68982f53db00             ATL                LAX   <br/>freq                                  60         5312028             709809   <br/><br/>       fareBasisCode travelDuration segmentsDepartureTimeEpochSeconds  \<br/>count        5312028        5312028                           5312028   <br/>unique          6035           1480                            320710   <br/>top         KAUOA0MQ        PT2H15M                        1663672500   <br/>freq          107336          79204                               377   <br/><br/>             segmentsDepartureTimeRaw segmentsArrivalTimeEpochSeconds  \<br/>count                         5312028                         5312028   <br/>unique                         321658                          344387   <br/>top     2022-09-20T07:15:00.000-04:00                      1661900340   <br/>freq                              377                             237   <br/><br/>               segmentsArrivalTimeRaw segmentsArrivalAirportCode  \<br/>count                         5312028                    5312028   <br/>unique                         348155                       1439   <br/>top     2022-08-30T18:59:00.000-04:00                        LGA   <br/>freq                              237                     192573   <br/><br/>       segmentsDepartureAirportCode segmentsAirlineName segmentsAirlineCode  \<br/>count                       5312028             5312028             5312028   <br/>unique                          637                  59                  59   <br/>top                             ATL               Delta                  DL   <br/>freq                        1754883             1031841             1031841   <br/><br/>       segmentsEquipmentDescription segmentsDurationInSeconds  \<br/>count                       5155578                   5312028   <br/>unique                         2514                     24456   <br/>top                     Airbus A321                      8100   <br/>freq                         427699                     79204   <br/><br/>       segmentsDistance segmentsCabinCode  <br/>count           5312028           5312028  <br/>unique             1352                34  <br/>top          None||None      coach||coach  <br/>freq             556848           3168404  </span></pre><p id="6a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做是为了查看每个<code class="fe nk nl nm na b">object</code>列中唯一值的数量。例如，考虑只有 1 个唯一值的<strong class="lb iu"> startingAirport </strong>列(这是 ATL)。</p><blockquote class="ms mt mu"><p id="9bd9" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">你甚至可能会争辩说，我们可以完全删除这个<strong class="lb iu">开始机场</strong>专栏！但是为了清楚起见，我将保留这个专栏。</p></blockquote><p id="bfb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，在 dataframe 中存储字符串"<strong class="lb iu"> ATL" </strong> 5312028 次并不是一个非常明智的选择。同样，对于<strong class="lb iu"> destinationAirport </strong>列，只有 15 个唯一值，因此该列中存储了大量重复值。</p><p id="5fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其存储所有这些重复值，不如将像<strong class="lb iu"> startingAirport </strong>和<strong class="lb iu"> destinationAirport </strong>这样的列转换为<code class="fe nk nl nm na b">category</code>数据类型。在<code class="fe nk nl nm na b">category</code>数据类型中，列中的唯一值存储在单独的引用表中，值的索引存储在该列中。下图说明了这一概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d85fba5be687781ee12da28d833c5bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*Q29j0S_yHeD7T182t_5Z8w.png"/></div></figure><p id="a437" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将<code class="fe nk nl nm na b">object</code>列转换为<code class="fe nk nl nm na b">category</code>类型，可以<em class="mv">节省大量的</em>内存。然而，有一个警告。如果一个列包含许多唯一值，那么将它转换成一个<code class="fe nk nl nm na b">category</code>字段不会节省任何内存——事实上它会使用更多的内存。因此，我想计算每个<code class="fe nk nl nm na b">object</code>列的唯一值的百分比:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="6a7e" class="ne lw it na b be nf ng l nh ni">df_unique_objs.iloc[1,:] / df_unique_objs.iloc[0,:] * 100</span></pre><p id="e1b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一列中超过 50%的值是唯一的，继续使用<code class="fe nk nl nm na b">object</code>类型比将它们转换为<code class="fe nk nl nm na b">category</code>类型更可行。以下输出显示没有一个<code class="fe nk nl nm na b">object</code>列具有超过 50%的唯一性:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="8222" class="ne lw it na b be nf ng l nn ni">legId                                6.823383<br/>startingAirport                      0.000019<br/>destinationAirport                   0.000282<br/>fareBasisCode                         0.11361<br/>travelDuration                       0.027861<br/>segmentsDepartureTimeEpochSeconds    6.037431<br/>segmentsDepartureTimeRaw             6.055277<br/>segmentsArrivalTimeEpochSeconds      6.483155<br/>segmentsArrivalTimeRaw               6.554088<br/>segmentsArrivalAirportCode           0.027089<br/>segmentsDepartureAirportCode         0.011992<br/>segmentsAirlineName                  0.001111<br/>segmentsAirlineCode                  0.001111<br/>segmentsEquipmentDescription         0.048763<br/>segmentsDurationInSeconds            0.460389<br/>segmentsDistance                     0.025452<br/>segmentsCabinCode                     0.00064<br/>dtype: object</span></pre><p id="2c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以将<code class="fe nk nl nm na b">object</code>列转换为<code class="fe nk nl nm na b">category</code>数据类型:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="cac4" class="ne lw it na b be nf ng l nh ni">df_obj_cat = df_obj.astype('category')</span></pre><p id="04a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦列被转换，将其分配回<code class="fe nk nl nm na b">optimized_df</code>数据帧:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="6c78" class="ne lw it na b be nf ng l nh ni">optimized_df[df_obj_cat.columns] = df_obj_cat</span></pre><p id="c77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以检查每一列的内存使用情况:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="8dc5" class="ne lw it na b be nf ng l nh ni">optimized_df.memory_usage(deep=True)</span></pre><p id="184c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以直接看到，以前的各种- <code class="fe nk nl nm na b">object</code>列现在使用的内存要少得多:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="59f6" class="ne lw it na b be nf ng l nn ni">Index                                42496224<br/>legId                                61961236<br/>searchDate                           42496224<br/>flightDate                           42496224<br/><strong class="na iu">startingAirport                       5312196<br/>destinationAirport                    5313484<br/>fareBasisCode                        11147023<br/>travelDuration                       10752574</strong><br/>elapsedDays                           5312028<br/>isBasicEconomy                        5312028<br/>isRefundable                          5312028<br/>isNonStop                             5312028<br/>baseFare                             21248112<br/>totalFare                            21248112<br/>seatsRemaining                        5312028<br/>totalTravelDistance                  21248112<br/><strong class="na iu">segmentsDepartureTimeEpochSeconds    55265918<br/>segmentsDepartureTimeRaw             67923918<br/>segmentsArrivalTimeEpochSeconds      57071505<br/>segmentsArrivalTimeRaw               70785925<br/>segmentsArrivalAirportCode           10755425<br/>segmentsDepartureAirportCode         10684758<br/>segmentsAirlineName                   5319331<br/>segmentsAirlineCode                   5318025<br/>segmentsEquipmentDescription         10949169<br/>segmentsDurationInSeconds            12869511<br/>segmentsDistance                     10750114<br/>segmentsCabinCode                     5315719</strong><br/>dtype: int64</span></pre><p id="68c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<strong class="lb iu"> startingAirport </strong>列的每个值现在平均使用大约 1 个字节(5312196 字节/ 5312028 行)。</p><p id="ab35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下优化数据帧的最终占用空间:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="2018" class="ne lw it na b be nf ng l nh ni">optimized_df.info(memory_usage='deep')</span></pre><p id="9163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的数据帧的最终内存占用是 605.9 MB，而它的初始大小是 7.1 GB！</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="5bc5" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5312028 entries, 0 to 82137143<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype         <br/>---  ------                             -----         <br/> 0   legId                              category      <br/> 1   searchDate                         datetime64[ns]<br/> 2   flightDate                         datetime64[ns]<br/> 3   startingAirport                    category      <br/> 4   destinationAirport                 category      <br/> 5   fareBasisCode                      category      <br/> 6   travelDuration                     category      <br/> 7   elapsedDays                        uint8         <br/> 8   isBasicEconomy                     bool          <br/> 9   isRefundable                       bool          <br/> 10  isNonStop                          bool          <br/> 11  baseFare                           float32       <br/> 12  totalFare                          float32       <br/> 13  seatsRemaining                     uint8         <br/> 14  totalTravelDistance                float32       <br/> 15  segmentsDepartureTimeEpochSeconds  category      <br/> 16  segmentsDepartureTimeRaw           category      <br/> 17  segmentsArrivalTimeEpochSeconds    category      <br/> 18  segmentsArrivalTimeRaw             category      <br/> 19  segmentsArrivalAirportCode         category      <br/> 20  segmentsDepartureAirportCode       category      <br/> 21  segmentsAirlineName                category      <br/> 22  segmentsAirlineCode                category      <br/> 23  segmentsEquipmentDescription       category      <br/> 24  segmentsDurationInSeconds          category      <br/> 25  segmentsDistance                   category      <br/> 26  segmentsCabinCode                  category      <br/>dtypes: bool(3), category(17), datetime64[ns](2), float32(3), uint8(2)<br/><strong class="na iu">memory usage: 605.9 MB</strong></span></pre><p id="8b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着数据帧的内存占用大大减少，现在对数据帧执行数据分析应该会更加容易和快速。</p><blockquote class="nq"><p id="78d0" class="nr ns it bd nt nu nv nw nx ny nz lu dk translated">将对象列转换为类别类型通常会节省大量内存。</p></blockquote><h1 id="3cbf" class="lv lw it bd lx ly lz ma mb mc md me mf jz oa ka mh kc ob kd mj kf oc kg ml mm bi translated">持久化优化的数据帧</h1><p id="90f3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果您费尽心思过滤数据帧并优化其内存占用，那么您最不想做的事情就是使用 CSV 格式将数据帧保存回存储器！如果您这样做，下次您将 CSV 加载回数据帧时，您辛苦执行的所有优化都将付诸东流。更聪明的方法是通过<code class="fe nk nl nm na b">to_pickle()</code>函数使用 Pickle 保存它:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="07e9" class="ne lw it na b be nf ng l nh ni">optimized_df.to_pickle('optimized_df.pkl')</span></pre><blockquote class="ms mt mu"><p id="48b8" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">Pickle 使用二进制模式将您的数据帧序列化到存储中，不像另存为 CSV 那样将数据保存为纯文本。</p></blockquote><p id="2988" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要验证所有优化都没有浪费，请加载回 pickle 文件，并验证新加载的数据帧的数据类型:</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="221a" class="ne lw it na b be nf ng l nh ni">df = pd.read_pickle('optimized_df.pkl')<br/>df.info(memory_usage='deep')</span></pre><p id="f570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将意识到，现在产生的内存占用比以前更小(605.9 MB):</p><pre class="kj kk kl km gt mz na nb bn nc nd bi"><span id="7047" class="ne lw it na b be nf ng l nn ni">&lt;class 'pandas.core.frame.DataFrame'&gt;<br/>Int64Index: 5312028 entries, 0 to 82137143<br/>Data columns (total 27 columns):<br/> #   Column                             Dtype         <br/>---  ------                             -----         <br/> 0   legId                              category      <br/> 1   searchDate                         datetime64[ns]<br/> 2   flightDate                         datetime64[ns]<br/> 3   startingAirport                    category      <br/> 4   destinationAirport                 category      <br/> 5   fareBasisCode                      category      <br/> 6   travelDuration                     category      <br/> 7   elapsedDays                        uint8         <br/> 8   isBasicEconomy                     bool          <br/> 9   isRefundable                       bool          <br/> 10  isNonStop                          bool          <br/> 11  baseFare                           float32       <br/> 12  totalFare                          float32       <br/> 13  seatsRemaining                     uint8         <br/> 14  totalTravelDistance                float32       <br/> 15  segmentsDepartureTimeEpochSeconds  category      <br/> 16  segmentsDepartureTimeRaw           category      <br/> 17  segmentsArrivalTimeEpochSeconds    category      <br/> 18  segmentsArrivalTimeRaw             category      <br/> 19  segmentsArrivalAirportCode         category      <br/> 20  segmentsDepartureAirportCode       category      <br/> 21  segmentsAirlineName                category      <br/> 22  segmentsAirlineCode                category      <br/> 23  segmentsEquipmentDescription       category      <br/> 24  segmentsDurationInSeconds          category      <br/> 25  segmentsDistance                   category      <br/> 26  segmentsCabinCode                  category      <br/>dtypes: bool(3), category(17), datetime64[ns](2), float32(3), uint8(2)<br/><strong class="na iu">memory usage: 564.7 MB</strong></span></pre><p id="0ef6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您比较每一列的内存使用情况(见下文)，请注意所有的<code class="fe nk nl nm na b">category</code>列现在使用的内存(从 pickle 文件重新加载后)比以前少得多。这很可能是由于 category 列从 pickle 文件直接加载时在内存中的加载和组织方式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/bd5b3a51471156fca05c019892a04d7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Hm1ewW7vXpbjNCvTYf69A.png"/></div></div></figure><h2 id="49fc" class="pa lw it bd lx pb pc dn mb pd pe dp mf li pf pg mh lm ph pi mj lq pj pk ml pl bi translated">如果你喜欢阅读我的文章，并且认为它对你的职业/学习有所帮助，请考虑注册成为一名灵媒会员。每月 5 美元，你可以无限制地访问 Medium 上的所有文章(包括我的)。如果你使用下面的链接注册，我会赚一小笔佣金(不需要你额外付费)。你的支持意味着我将能够投入更多的时间来写这样的文章。</h2><div class="pu pv gp gr pw px"><a href="https://weimenglee.medium.com/membership" rel="noopener follow" target="_blank"><div class="py ab fo"><div class="pz ab qa cl cj qb"><h2 class="bd iu gy z fp qc fr fs qd fu fw is bi translated">加入媒介与我的介绍链接-李伟孟</h2><div class="qe l"><h3 class="bd b gy z fp qc fr fs qd fu fw dk translated">阅读李维孟(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="qf l"><p class="bd b dl z fp qc fr fs qd fu fw dk translated">weimenglee.medium.com</p></div></div><div class="qg l"><div class="qh l qi qj qk qg ql ks px"/></div></div></a></div><h1 id="0f86" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">总结</strong></h1><p id="70d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我介绍了一些技术，您可以在处理非常大的 CSV 数据文件时使用这些技术。具体来说，您了解到可以使用分块来按部分加载数据帧，而不是将整个 CSV 文件加载到数据帧中。这使您可以灵活地有选择地加载分析所需的行和列。此外，有几种技术可以用来减少数据帧的内存占用。通常，使用以下步骤来减少内存使用:</p><ul class=""><li id="e12b" class="ok ol it lb b lc ld lf lg li om lm on lq oo lu op oq or os bi translated">将与日期相关的列转换为<code class="fe nk nl nm na b">datetime64</code>类型</li><li id="e2bb" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">将所有数值类型向下转换为宽度足以容纳这些列中的值的类型</li><li id="5818" class="ok ol it lb b lc ot lf ou li ov lm ow lq ox lu op oq or os bi translated">如果可行，将所有的<code class="fe nk nl nm na b">object</code>列转换为<code class="fe nk nl nm na b">category</code>类型</li></ul><p id="1c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这三个简单的技巧将会大大节省数据帧的内存使用。在自己的数据集上尝试一下，你会大吃一惊的！</p></div></div>    
</body>
</html>