<html>
<head>
<title>In-depth Tutorial to Advanced Missing Data Imputation Methods with Sklearn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sklearn高级缺失数据插补方法的深入教程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/advanced-missing-data-imputation-methods-with-sklearn-d9875cbcc6eb#2022-06-04">https://towardsdatascience.com/advanced-missing-data-imputation-methods-with-sklearn-d9875cbcc6eb#2022-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ef87" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学会利用强大的基于模型的插补技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c8187e0023b9ae39d559e6c141928424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VvFb-MJveJts1nPwRzQ7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/photo/close-up-photo-of-painting-3219951/" rel="noopener ugc nofollow" target="_blank">安妮·伦凯</a>拍摄</p></figure><h2 id="3c1d" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h2><p id="51b5" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">尽管有大量的MOOCs和其他在线资源，但在处理某些数据问题方面仍然存在技能差距。一个例子是正确处理现实世界数据集中的缺失数据。新手往往对这个问题掉以轻心，也不怪他们。尽管这是一个如此紧迫的问题，但丢失数据问题的复杂性被大大低估了，因为存在小的、易于使用的玩具数据集。</p><p id="70f9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">因此，许多初学数据的科学家不会超越简单的均值、中值或众数插补。虽然这些方法对于简单的数据集来说可能足够了，但是对于处理大型数据集中的缺失数据来说，它们并不是一个合适的解决方案。</p><p id="3a03" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">像数据科学工作流程的任何其他阶段一样，缺失数据插补是一个迭代过程。你应该能够使用多种方法并有效地比较它们的结果。虽然基本技术可能表现良好，但这种情况很少发生，因此您需要一些备份策略。</p><p id="7897" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">本教程将介绍Sklearn中两个更健壮的基于模型的插补算法— <code class="fe mt mu mv mw b">KNNImputer</code>和<code class="fe mt mu mv mw b">IterativeImputer</code>。您将学习它们的基本用法，调整它们的参数，最后，看看如何直观地测量它们的效果。</p><div class="mx my gp gr mz na"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">通过我的推荐链接加入Medium-BEXGBoost</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">获得独家访问我的所有⚡premium⚡内容和所有媒体没有限制。支持我的工作，给我买一个…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no ks na"/></div></div></a></div><p id="4e1b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">获得由强大的AI-Alpha信号选择和总结的最佳和最新的ML和AI论文:</p><div class="mx my gp gr mz na"><a href="https://alphasignal.ai/?referrer=Bex" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">阿尔法信号|机器学习的极品。艾总结的。</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">留在循环中，不用花无数时间浏览下一个突破；我们的算法识别…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">alphasignal.ai</p></div></div><div class="nj l"><div class="np l nl nm nn nj no ks na"/></div></div></a></div></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="30e5" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">识别缺失的类型</h2><p id="4fd5" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">实施有效插补策略的第一步是确定值缺失的原因。尽管每个案例都是独一无二的，但失踪可以分为三大类:</p><ul class=""><li id="67b3" class="nx ny it lx b ly mo mb mp li nz lm oa lq ob mn oc od oe of bi translated"><strong class="lx iu">完全随机缺失(MCAR) </strong>:这是一个真实的数据随机缺失案例。例如数据输入中的突然错误、暂时的传感器故障或与任何外部因素无关的一般丢失数据。丢失的数量很少。</li><li id="fcb0" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn oc od oe of bi translated"><strong class="lx iu">随机失踪(MAR) </strong>:这是一个更广泛的MCAR案例。尽管乍一看，丢失的数据似乎是随机的，但它将与<em class="ol">其他观察到的特征</em>有一些系统的关系——例如——在计划的维护中断期间，观察设备中丢失的数据。空值的数量可能会有所不同。</li><li id="8ef6" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn oc od oe of bi translated"><strong class="lx iu">非随机缺失(MNAR) </strong>:缺失值可能大量存在，缺失的原因与我们无法控制或了解的因素有关。</li></ul><blockquote class="om"><p id="8bb0" class="on oo it bd op oq or os ot ou ov mn dk translated">确定你的问题属于哪一类可以帮助你缩小解决方案的范围。</p></blockquote><p id="6a04" class="pw-post-body-paragraph lv lw it lx b ly ow ju ma mb ox jx md li oy mf mg lm oz mi mj lq pa ml mm mn im bi translated">让我们使用<a class="ae ky" href="https://www.kaggle.com/uciml/pima-indians-diabetes-database" rel="noopener ugc nofollow" target="_blank">糖尿病数据集</a>进一步探究这些缺失类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/bcceb6cc3be9e1ce7700143f7e2a58f0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*92aR8m-uka416ZnjNl1vkQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="9af5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有五个要素具有不同比例的缺失值。识别缺失类型的第一步是绘制缺失矩阵。这个特殊的情节可以通过<code class="fe mt mu mv mw b">missingno</code>包获得，我们可以将它作为<code class="fe mt mu mv mw b">msno</code>导入:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/9636d1f52fa6964e55640bb41438a85f.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ZQHIHwLxbZXnRcRxmy2GpA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8471" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该矩阵显示了空值是如何分散在数据集中的。白色的线段或线条表示缺失值所在的位置。葡萄糖、身体质量指数和血压列可被视为MCAR，原因有二:</p><ul class=""><li id="68f8" class="nx ny it lx b ly mo mb mp li nz lm oa lq ob mn oc od oe of bi translated">缺失值的比例很小。</li><li id="4017" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn oc od oe of bi translated">缺失值完全随机分布在数据集中。</li></ul><p id="1037" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">但是，胰岛素和SkinFoldThickness列有异常多的缺失数据点。那么，他们的失踪有什么关系吗？</p><p id="b9d3" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">为了回答这个问题，MSNO提供了一个缺失率热图，显示了缺失率之间的相互关系:</p><pre class="kj kk kl km gt pe mw pf pg aw ph bi"><span id="dc27" class="kz la it mw b gy pi pj l pk pl">&gt;&gt;&gt; msno.heatmap(diabetes);</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/ea25e0f5a53c85a77967e58583733b02.png" data-original-src="https://miro.medium.com/v2/format:webp/1*teW66RTPlTpcBbhT9xQvUg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="f585" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">从图中我们可以看到皮肤厚度和胰岛素之间有很强的相关性。我们可以通过对任一列进行排序来确认这一点:</p><pre class="kj kk kl km gt pe mw pf pg aw ph bi"><span id="dbc7" class="kz la it mw b gy pi pj l pk pl">&gt;&gt;&gt; msno.matrix(diabetes.sort_values("Insulin"));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/e82b53dd7f60b9e7a02b8f438419c668.png" data-original-src="https://miro.medium.com/v2/format:webp/1*9zTZBzMYB8M_9h4yZFRB4g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4cde" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">该图显示，如果SkinThickness中的数据点缺失，我们可以猜测它也从胰岛素列中缺失，反之亦然。由于这种联系，我们可以有把握地说两列中缺失的数据不是随机缺失的(MNAR)。</p><p id="c894" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们还可以看到血压和皮肤厚度之间的弱相关性，这表明血压并非完全随机缺失(MCAR)，而是与皮肤厚度的缺失值有一定关系。换句话说，就是随机缺失(MAR)。</p><p id="da29" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">你可能需要一段时间来理解这些思念的类型。要更深入地了解，你可以参考我写的另一篇文章，专门讨论想念类型和MSNO套餐:</p><div class="mx my gp gr mz na"><a href="https://towardsdev.com/how-to-identify-missingness-types-with-missingno-61cfe0449ad9" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">如何用缺失号识别缺失类型</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">编辑描述</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdev.com</p></div></div><div class="nj l"><div class="pm l nl nm nn nj no ks na"/></div></div></a></div></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="5966" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用KNNImputer输入</h2><p id="08e4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在，让我们来介绍一些插补方法。</p><p id="4609" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">除了基本的<code class="fe mt mu mv mw b">SimpleImputer</code>，Sklearn还提供了<code class="fe mt mu mv mw b">KNNImputer</code>类，它使用K-Nearest-Neighbors算法来估算数值。如果您不熟悉它，我推荐您阅读我关于它的另一篇文章:</p><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/intro-to-scikit-learns-k-nearest-neighbors-classifier-and-regressor-4228d8d1cba6"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">Scikit-learn的k近邻分类器和回归器简介</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">编辑描述</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="pn l nl nm nn nj no ks na"/></div></div></a></div><p id="69a5" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">作为参考，下面是一篇文章的节选，简要介绍了KNN算法的工作原理:</p><p id="ceb9" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">“假设您有一个包含两个类别的变量，此处显示了这两个类别:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/a2a65439c65679cf403d5bf7bf1fb131.png" data-original-src="https://miro.medium.com/v2/format:webp/1*JqrKyEMyy9dUcGmX_pJR3A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd po">图片由维基百科</strong></p></figure><p id="c8a2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">给定一个新的未知样本，如何判断它属于哪一组？当然，你会看周围的点。但是结果真的取决于你看得多远。如果您查看最近的三个数据点(实心圆内)，绿点将属于红色三角形。如果你看得更远，(虚线圆圈内)点将被归类为蓝色方块。</p><p id="9c37" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">KNN也是如此。根据k的值，该算法通过分类中最近的k个邻居的多数投票对新样本进行分类。对于预测新样本的实际数值的回归，该算法取最近的k个邻居的平均值。"</p><p id="7261" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">KNNImputer是KNN算法的一个略微修改的版本，它试图通过平均其<em class="ol"> k </em>最近邻居之间的距离来预测<em class="ol">数值</em>的无效值。对于已经使用Sklearn一段时间的人来说，它的Sklearn实现应该不成问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="a83b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">有了这个估算器，问题就是为<em class="ol"> k </em>选择正确的值。由于您无法使用GridSearch对其进行调优，因此我们可以采用可视化方法进行比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/9d25e8f7489212d4e787f6e81be28f7b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*MdRXGAD1JyoyX6QfVtA9AQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9b7b" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在第5行中，我们绘制了缺失值的原始皮肤厚度分布。然后，在第6–9行，我们用不同的k值估算相同的分布，并在原始分布的顶部绘制。估算分布越接近原始分布，估算就越好。在这里，似乎k=2是最佳选择。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="1e7c" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用迭代估算器估算</h2><p id="a07b" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">另一种更健壮但计算成本更高的技术是使用<code class="fe mt mu mv mw b">IterativeImputer</code>。它采用任意的Sklearn估计量，并尝试通过将其他要素建模为具有缺失值的要素的函数来估算缺失值。以下是对其功能的更详细的逐步说明:</p><ol class=""><li id="5305" class="nx ny it lx b ly mo mb mp li nz lm oa lq ob mn pp od oe of bi translated">回归量被传递给转换器。</li><li id="c03e" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn pp od oe of bi translated">选择具有缺失值的第一个特征(<em class="ol"> feature_1 </em>)。</li><li id="4251" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn pp od oe of bi translated">数据被分成训练集/测试集，其中训练集包含<em class="ol"> feature_1，</em>的所有已知值，测试集包含缺失样本。</li><li id="f857" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn pp od oe of bi translated">回归变量适合所有其他变量作为输入，而<em class="ol"> feature_1 </em>作为输出。</li><li id="2fc3" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn pp od oe of bi translated">回归预测器预测缺失值。</li><li id="9060" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn pp od oe of bi translated">转换器继续这个过程，直到所有的特征都被输入。</li><li id="b839" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn pp od oe of bi translated">步骤1-6被称为一轮迭代，这些步骤按照<code class="fe mt mu mv mw b">max_iter</code> transformer参数的规定执行多次。</li></ol><p id="5fcb" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">这意味着<code class="fe mt mu mv mw b">IterativeImputer</code> (II)预测单个缺失样本的可能值不是一个而是<em class="ol"> max_iter </em>个。这样做的好处是将每个缺失数据点视为一个随机变量，并将缺失值带来的固有不确定性联系起来。这也被称为<strong class="lx iu">多重插补，</strong>，它是大多数其他插补技术的基础(是的，还有很多其他技术)。</p><p id="395a" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当所有迭代完成后，II只返回预测的最后结果，因为通过每次迭代，预测都会得到改善。该算法还有一个早期停止功能，如果两轮之间没有明显的差异，它可以终止迭代。</p><p id="c2ec" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">根据Sklearn的说法，IterativeImputer的这种实现受到了更流行的R MICE包(通过链式方程进行多元插补)的启发。让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><blockquote class="pq pr ps"><p id="7e0b" class="lv lw ol lx b ly mo ju ma mb mp jx md pt mq mf mg pu mr mi mj pv ms ml mm mn im bi translated"><code class="fe mt mu mv mw b"><em class="it">IterativeImputer</em></code>仍然是一个实验性的特性，所以不要忘记包含上面代码片段的第二行。</p></blockquote><p id="2b59" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">当<code class="fe mt mu mv mw b">estimator</code>设置为无时，算法会自行选择。但是，在阅读了Sklearn关于<code class="fe mt mu mv mw b">IterativeImputer</code>的官方指南<a class="ae ky" href="https://scikit-learn.org/stable/auto_examples/impute/plot_iterative_imputer_variants_comparison.html#sphx-glr-auto-examples-impute-plot-iterative-imputer-variants-comparison-py" rel="noopener ugc nofollow" target="_blank">之后，我了解到<code class="fe mt mu mv mw b">BayesianRidge</code>和<code class="fe mt mu mv mw b">ExtraTreeRegressor</code>产生了最好的结果。</a></p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="dd63" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不同技术的性能比较</h2><p id="d2c4" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">现在是检验估算效果的时候了。为了实现这一点，我们将预测患者是否患有糖尿病(<em class="ol">结果</em>)，因此这是一项二元分类任务。让我们构建功能/目标阵列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><p id="9388" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们将使用交叉验证来测试<code class="fe mt mu mv mw b">KNNImputer</code>和<code class="fe mt mu mv mw b">IterativeImputer</code>。对于估算器，我们将使用推荐的<code class="fe mt mu mv mw b">BayesianRidge</code>和<code class="fe mt mu mv mw b">ExtraTreesRegressor</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pb pc l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl pd"><img src="../Images/a82911f80917502dc0846e37374aac18.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dmxULNSymPlDgqHtmM-RvA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1430" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">我们可以从最终的结果中看到，在RandomForests上训练时，具有七个邻居的KNNImputer是数据集的最佳选择。尽管我提到过<code class="fe mt mu mv mw b">IterativeImputer</code>会更健壮，但你永远无法确定。也许，我们可以通过调整它的参数来获得更好的性能。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h2 id="e960" class="kz la it bd lb lc ld dn le lf lg dp lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h2><p id="af78" class="pw-post-body-paragraph lv lw it lx b ly lz ju ma mb mc jx md li me mf mg lm mh mi mj lq mk ml mm mn im bi translated">数据缺失是一个应该重视的问题。如果你连先决数据问题都解决不了，那么花几个小时学习复杂的ML算法是没有意义的。请记住，模型的好坏取决于对其进行训练的数据。这意味着您必须尽最大努力处理缺失的数据点，因为它们在现实世界的数据集中无处不在。</p><p id="9727" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">在本文中，您学习了如何使用两种基于模型的技术来处理缺失:<code class="fe mt mu mv mw b">KNNImputer</code>和<code class="fe mt mu mv mw b">IterativeImputer</code>。以下是它们的文档链接、官方的Sklearn使用指南以及有助于您理解的相关资源:</p><ul class=""><li id="cffe" class="nx ny it lx b ly mo mb mp li nz lm oa lq ob mn oc od oe of bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">缺失值插补，Sklearn指南</a></li><li id="428f" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn oc od oe of bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html" rel="noopener ugc nofollow" target="_blank">迭代输入文档</a></li><li id="04cc" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn oc od oe of bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.KNNImputer.html" rel="noopener ugc nofollow" target="_blank"> KNNImputer文档</a></li><li id="c758" class="nx ny it lx b ly og mb oh li oi lm oj lq ok mn oc od oe of bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/auto_examples/impute/plot_iterative_imputer_variants_comparison.html#sphx-glr-auto-examples-impute-plot-iterative-imputer-variants-comparison-py" rel="noopener ugc nofollow" target="_blank">用迭代输入器的变量输入缺失值</a></li></ul><p id="3ce2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated">感谢阅读！</p><div class="mx my gp gr mz na"><a href="https://ibexorigin.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">通过我的推荐链接加入Medium-Bex t。</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nj l"><div class="pw l nl nm nn nj no ks na"/></div></div></a></div><div class="mx my gp gr mz na"><a href="https://ibexorigin.medium.com/subscribe" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">每当Bex T .发布时收到电子邮件。</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">每当Bex T .发布时收到电子邮件。注册后，如果您还没有中型帐户，您将创建一个…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nj l"><div class="px l nl nm nn nj no ks na"/></div></div></a></div></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="7dc2" class="pw-post-body-paragraph lv lw it lx b ly mo ju ma mb mp jx md li mq mf mg lm mr mi mj lq ms ml mm mn im bi translated"><strong class="lx iu">我的更多故事:</strong></p><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/10-minute-effortless-sql-tutorial-for-die-hard-pandas-lovers-a64c36733fd0"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">10分钟轻松的SQL教程，适合铁杆熊猫爱好者</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">曾几何时，情况正好相反</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="py l nl nm nn nj no ks na"/></div></div></a></div><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/how-to-create-slick-math-animations-like-3blue1brown-in-python-457f74701f68"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">如何用Python创建像3Blue1Brown这样流畅的数学动画</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">学习将你对数学和编程的热爱结合起来的最佳方式</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="pz l nl nm nn nj no ks na"/></div></div></a></div><div class="mx my gp gr mz na"><a rel="noopener follow" target="_blank" href="/matplotlib-vs-plotly-lets-decide-once-and-for-all-dc3eca9aa011"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">Matplotlib vs. Plotly:让我们决定一劳永逸</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">从7个关键方面进行深入快速的比较</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">towardsdatascience.com</p></div></div><div class="nj l"><div class="qa l nl nm nn nj no ks na"/></div></div></a></div><div class="mx my gp gr mz na"><a href="https://ibexorigin.medium.com/yes-these-unbelievable-masterpieces-are-created-with-matplotlib-b62e0ff2d1a8" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">是的，这些令人难以置信的杰作是用Matplotlib创作的</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">它们让我的作品看起来像孩子画的树</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">ibexorigin.medium.com</p></div></div><div class="nj l"><div class="qb l nl nm nn nj no ks na"/></div></div></a></div></div></div>    
</body>
</html>