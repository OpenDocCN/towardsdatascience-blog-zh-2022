<html>
<head>
<title>Fugue and DuckDB: Fast SQL Code in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fugue 和 duck db:Python 中的快速 SQL 代码</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/fugue-and-duckdb-fast-sql-code-in-python-e2e2dfc0f8eb#2022-03-07">https://towardsdatascience.com/fugue-and-duckdb-fast-sql-code-in-python-e2e2dfc0f8eb#2022-03-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf2e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用 Python 和 DuckDB 优化您的 SQL 代码</h2></div><h1 id="ef19" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">动机</h1><p id="814c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为一名数据科学家，您可能对 Pandas 和 SQL 都很熟悉。然而，可能有一些查询和转换，您会觉得用 SQL 而不是 Python 来做比较舒服。</p><p id="a13f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果你能使用 SQL 查询熊猫数据帧，那不是很好吗…</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mb"><img src="../Images/a83c89df2fc9e3b3596b48936851348e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t76iHEV7wTwqXDDpUSXtXg.png"/></div></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="7e2c" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">…同时在处理大量数据时还能<strong class="lc iu">加速您的代码</strong>？</p><p id="66e4" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这时候 Fugue + DuckDB 就派上用场了。</p><p id="65e0" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在上一篇文章中，我展示了如何使用 pandas 引擎通过 SQL 查询 pandas 数据帧。</p><div class="mr ms gp gr mt mu"><a rel="noopener follow" target="_blank" href="/introducing-fuguesql-sql-for-pandas-spark-and-dask-dataframes-63d461a16b27"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">介绍 FugueSQL —用于 Pandas、Spark 和 Dask 数据帧的 SQL</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">用于数据科学和分析的端到端 SQL 界面</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ml mu"/></div></div></a></div><p id="6e7d" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在本文中，我将向您展示如何使用 DuckDB 引擎来加速您的查询。</p><h1 id="3e42" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为什么是赋格和 DuckDB？</h1><p id="540c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><a class="ae nj" href="https://fugue-tutorials.readthedocs.io/tutorials/fugue_sql/index.html" rel="noopener ugc nofollow" target="_blank"> Fugue </a>是一个 Python 库，允许用户组合 Python 代码和 SQL 命令。这使得用户可以在 Jupyter 笔记本或 Python 脚本中灵活地切换 Python 和 SQL。</p><p id="0c06" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">默认情况下，Fugue 会将您的 SQL 代码映射到 pandas。但是，当数据大小超过几个 GB 时，使用 pandas 并不理想，因为它:</p><ul class=""><li id="9bf4" class="nk nl it lc b ld lw lg lx lj nm ln nn lr no lv np nq nr ns bi translated">一次只允许您使用一个内核</li><li id="5ae4" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">创建大量数据的中间副本,这会增加内存使用</li></ul><p id="4a67" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">Fugue 还允许您使用 Spark 或 Dask 来扩展 SQL 代码。但是，较小的组织可能没有可以向其移植工作负载的集群。</p><h2 id="663c" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">DuckDB 简介</h2><p id="82b6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">DuckDB 是一个进程内 SQL OLAP 数据库管理系统。在本地机器上，即使是千兆字节的数据，速度也非常快。</p><p id="9f35" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">因此，FugueSQL 和 DuckDB 的结合允许你<strong class="lc iu">使用 SQL 和 Python </strong>和<strong class="lc iu">无缝地加速你的代码</strong>。</p><p id="2a88" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">要使用 DuckDB 引擎安装 FugueSQL，请键入:</p><pre class="mc md me mf gt ok ol om on aw oo bi"><span id="d648" class="ny kj it ol b gy op oq l or os">pip install -U fugue[duckdb,sql] </span></pre><h1 id="1a21" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">建立</h1><p id="7c20" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，我们为赋格导入一些设置函数。这将让我们使用 Jupyter 笔记本中的<code class="fe ot ou ov ol b">%%fsql</code>细胞魔法。我们还导入了 DuckDB 引擎。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="a8e0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">加载数据</h1><p id="e1dc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本文将使用币安加密小猫数据集。这可以通过知识共享许可从<a class="ae nj" href="https://www.kaggle.com/binance/binance-crypto-klines" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载。</p><p id="f580" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">文件夹<code class="fe ot ou ov ol b">crypto-binance</code>包含 1000 多个不同的文件，总内存超过 5GB。我<a class="ae nj" href="https://github.com/khuyentran1401/Data-science/blob/master/productive_tools/Fugue_and_Duckdb/preprocessing.ipynb" rel="noopener ugc nofollow" target="_blank">合并了这些文件</a>并将新文件保存为<code class="fe ot ou ov ol b">raw.parquet</code>。</p><p id="824b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">下载完<a class="ae nj" href="https://drive.google.com/uc?id=1gM9gKrrck0KHlhiKbjuyV13UKfa4SYCg" rel="noopener ugc nofollow" target="_blank">加工文件</a>后，一个文件名<code class="fe ot ou ov ol b">raw.parquet</code>会保存在你的本地机器上。从获取新文件的位置开始:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="3336" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在我们来比较一下熊猫和 DuckDB 的加载速度。</p><h2 id="8ac9" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">熊猫</h2><p id="e235" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从使用 pandas 加载数据开始:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6b5a5b26953f19181b262ee2545e42d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*3YvBgee5UO4GUdXwLU4nJw.png"/></div></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8bf6df7c2bf77de8914004711c1a1b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*5QuOqrOr0TtRvS-p3QGt8A.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="17eb" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">请注意，加载数据花费了我们 10.5 秒。这太慢了。让我们看看是否可以通过使用 FugueSQL 和 DuckDB 来加快这个过程。</p><h2 id="22f1" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">赋格+ DuckDB</h2><p id="170b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要在 Jupyter 笔记本单元格中使用 DuckDB 作为引擎编写 SQL，只需在单元格的开头添加<code class="fe ot ou ov ol b">%%fsql duck</code>:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/71e62eb9f811c4b721cfbdcec6fc247d.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*jA0-6xuj2eQeTr_Y0Bx_zw.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="ba5b" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在上面的代码中，</p><ul class=""><li id="62f6" class="nk nl it lc b ld lw lg lx lj nm ln nn lr no lv np nq nr ns bi translated"><code class="fe ot ou ov ol b">PRINT</code>允许我们打印输出</li><li id="1945" class="nk nl it lc b ld nt lg nu lj nv ln nw lr nx lv np nq nr ns bi translated">双括号<code class="fe ot ou ov ol b">{{}}</code>允许我们在 SQL 中使用 Python 变量。</li></ul><p id="d6d3" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">上面的代码在 303 毫秒内加载数据！使用 DuckDB 作为引擎比使用 pandas 作为引擎快 34 倍以上。</p><h1 id="7215" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">处理</h1><p id="8b7f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们来对比一下熊猫和 DuckDB +神游的数据处理速度。</p><h2 id="4053" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">熊猫</h2><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/d3c783a2ef3ed8ee5fc4ac7691a777f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*0VP2ed0r9MTz0IXsVdcJRg.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><h2 id="d4ca" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">赋格+ DuckDB</h2><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/2c987229e9f8756db40986ce0bcbe970.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*T66w-qNIROjFyOXqP1S6-A.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="0b30" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated"><strong class="lc iu"> <em class="pd">注意</em> </strong> <em class="pd">:类似于 SQL 临时表，FugueSQL 允许多个</em> <code class="fe ot ou ov ol b"><em class="pd">SELECT</em></code> <em class="pd">语句。这使得代码可以自顶向下阅读，并消除了样板代码。如果未指定</em> <code class="fe ot ou ov ol b"><em class="pd">FROM</em></code> <em class="pd">，SQL 语句将使用堆栈中的最后一个数据帧。</em></p><h2 id="f4dc" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">观察</h2><p id="bb55" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以看到用 Fugue + DuckDB 比用熊猫快了差不多 4 倍。用 SQL 编写上面的处理代码也比用 pandas 稍微容易一些。</p><h1 id="c9fd" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为什么 DuckDB 快了这么多？</h1><p id="5b18" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">DuckDB 更快，因为它使用了惰性求值。</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/1b791c440b2f3e48c2e1d514adf53c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*fny1JBOEjwzX9mw0bdFelQ.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="db6e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">例如，在上面的代码中，<code class="fe ot ou ov ol b">PRINT</code>语句默认返回 10 条记录。DuckDB 知道最终结果只需要 10 条记录，所以它<strong class="lc iu">只获取那些记录</strong>。</p><p id="42ea" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">另一方面，熊猫被急切地处决了。这意味着只有在<strong class="lc iu">整个文件加载到</strong>后，获取前 10 行的操作才会运行。</p><h1 id="1d5d" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">但是为什么神游呢？</h1><p id="c80c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">DuckDB 有自己的<a class="ae nj" href="https://duckdb.org/docs/api/python" rel="noopener ugc nofollow" target="_blank"> Python API </a>，为什么要用 Fugue 搭配 DuckDB？</p><p id="939a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">这是因为 Fugue 提供了自定义函数，允许您轻松地与 Python 对象进行交互。在接下来的部分中，我们将学习如何使用这些自定义函数来改进您的 SQL 代码。</p><h1 id="6ec4" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">使用赋格数据帧</h1><p id="b2d6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在上面的代码中，这一行</p><pre class="mc md me mf gt ok ol om on aw oo bi"><span id="fc87" class="ny kj it ol b gy op oq l or os">YIELD DATAFRAME AS top_symbols</span></pre><p id="962a" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">…输出赋格数据帧并保存为<code class="fe ot ou ov ol b">top_symbols</code>。</p><p id="56a9" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">你可以很容易地把<code class="fe ot ou ov ol b">top_symbols</code>变成熊猫的数据帧:</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ow ox l"/></div></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/c939e5e2532fbcdd135b2997cbbea5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:382/format:webp/1*gKXqgyqTL3bNljJqjo23_Q.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="099e" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">…或者在另一个 SQL 查询中使用<code class="fe ot ou ov ol b">top_symbols</code>:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/e5f7876286e59a9644ba96c300faa0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*yz80k3By--5YPt7FQv6V7w.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><h1 id="0551" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">为中间输出指定名称</h1><p id="7e97" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有时，您可能希望为中间输出指定名称，以便它们可以被同一个 SQL 查询中的其他流程使用。神游允许你使用<code class="fe ot ou ov ol b">=</code>给你的中间输出命名:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/5af0cbfc906572ff2641097882d7d1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*4XABCTqXaB77Z1AtvlGwPw.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="9ff6" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">在上面的代码中，我将中间输出保存到<code class="fe ot ou ov ol b">src</code>，然后将<code class="fe ot ou ov ol b">src</code>与<code class="fe ot ou ov ol b">top_symbols</code>连接起来。</p><h1 id="f97b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">Python 扩展</h1><p id="7b01" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">同时使用 Fugue 和 DuckDB 还允许您通过扩展在 SQL 代码中使用 Python 逻辑。让我们来看看这些扩展。</p><h2 id="f11a" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">输出</h2><p id="b89a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">SQL 不允许您绘制输出。然而，我们可以用 Python 创建一个绘图函数，然后在我们的 SQL 代码中使用它。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="d383" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">要使用上面的<code class="fe ot ou ov ol b">plot_by</code>功能，只需在<code class="fe ot ou ov ol b">plot_by</code>旁边添加<code class="fe ot ou ov ol b">OUPUT USING</code>:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/ad580a8109870563c0088f37c2cc0673.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*NzCl5KEcXMn7Aw962fZZOA.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/aa953bf288de1b4a97342071e3a2c85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*5rgab6CRuo73GG9zdQGCdA.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><h2 id="8653" class="ny kj it bd kk nz oa dn ko ob oc dp ks lj od oe ku ln of og kw lr oh oi ky oj bi translated">改变</h2><p id="8770" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">有些函数用 Python 比用 SQL 更容易编写。如果您想使用 Python 转换 SQL 查询的输出，请使用<code class="fe ot ou ov ol b">TRANSFORM</code>。</p><p id="0e72" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">要了解这个扩展是如何工作的，首先创建一个名为<code class="fe ot ou ov ol b">macd</code>的函数。该函数使用<a class="ae nj" href="https://github.com/twopirllc/pandas-ta" rel="noopener ugc nofollow" target="_blank"> pandas-ta </a>来获取时间序列的某个趋势。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="9fcd" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我们还将模式提示作为注释(<code class="fe ot ou ov ol b"># schema: *,macd:double</code>)添加到函数<code class="fe ot ou ov ol b">macd</code>之上，以便 Fugue 可以读取这个模式提示并应用该模式。</p><p id="ef23" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">现在我们可以使用这个函数来转换查询中的数据:</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/06181fb498b9a732f394df17008db124.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*qjocBGLqJZ2JVktfuqPJSA.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5fdd27cf567b38798b01ba416dc99d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*g3vuaK6KWh2gWJJ6s9yhjw.png"/></div><p class="mn mo gj gh gi mp mq bd b be z dk translated">作者图片</p></figure><p id="7f8f" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">酷！我们刚刚使用 Python 函数转换了 SQL 输出。</p><p id="05b8" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">点击了解更多关于赋格<a class="ae nj" rel="noopener" target="_blank" href="/introducing-fuguesql-sql-for-pandas-spark-and-dask-dataframes-63d461a16b27#78e1">中<code class="fe ot ou ov ol b">TRANSFORM</code>和<code class="fe ot ou ov ol b">PREPARTITION</code>的信息。</a></p><h1 id="1aa5" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">神游+生产中的 DuckDB</h1><p id="2ebc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">要将 FugueSQL 从 Jupyter 笔记本中取出并放入 Python 脚本中，我们需要做的就是将 FugueSQL 查询包装在一个<code class="fe ot ou ov ol b">fsql</code>类中。然后我们可以调用<code class="fe ot ou ov ol b">.run()</code>方法并选择一个执行引擎作为<code class="fe ot ou ov ol b">"duck"</code>。</p><figure class="mc md me mf gt mg"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h1 id="d8f0" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">结论</h1><p id="344a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">恭喜你！您刚刚学习了将 FugueSQL 和 DuckDB 一起用作后端，以充分利用本地执行。由于 DuckDB 提供的惰性评估，我们可以在将数据提交给 Pandas 进行进一步分析之前快速预聚合数据，这在 SQL 中是很难做到的。</p><p id="debe" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">使用 Fugue 作为界面还可以让我们无缝地使用 DuckDB 的优势。</p><p id="b190" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">随意发挥，并在这里叉这篇文章的源代码:</p><div class="mr ms gp gr mt mu"><a href="https://github.com/khuyentran1401/Data-science/blob/master/productive_tools/Fugue_and_Duckdb/Fugue_and_Duckdb.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">数据科学/Fugue _ and _ duck db . ipynb at master khuyentran 1401/数据科学</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">收集有用的数据科学主题以及代码和文章-Data-science/Fugue _ and _ duck db . ipynb at master…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">github.com</p></div></div><div class="nd l"><div class="pl l nf ng nh nd ni ml mu"/></div></div></a></div></div><div class="ab cl pm pn hx po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="im in io ip iq"><p id="9090" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">我喜欢写一些基本的数据科学概念，并尝试不同的数据科学工具。你可以通过<a class="ae nj" href="https://www.linkedin.com/in/khuyen-tran-1401/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae nj" href="https://twitter.com/KhuyenTran16" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我联系。</p><p id="6258" class="pw-post-body-paragraph la lb it lc b ld lw ju lf lg lx jx li lj ly ll lm ln lz lp lq lr ma lt lu lv im bi translated">如果你想查看我写的所有文章的代码，请点击这里。在 Medium 上关注我，了解我的最新数据科学文章，例如:</p><div class="mr ms gp gr mt mu"><a rel="noopener follow" target="_blank" href="/write-clean-python-code-using-pipes-1239a0f3abf5"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">使用管道编写干净的 Python 代码</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">一种简洁明了的处理迭代的方法</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="pt l nf ng nh nd ni ml mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a rel="noopener follow" target="_blank" href="/introducing-fuguesql-sql-for-pandas-spark-and-dask-dataframes-63d461a16b27"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">介绍 FugueSQL —用于 Pandas、Spark 和 Dask 数据帧的 SQL</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">用于数据科学和分析的端到端 SQL 界面</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ml mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a rel="noopener follow" target="_blank" href="/3-tools-to-track-and-visualize-the-execution-of-your-python-code-666a153e435e"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">3 个跟踪和可视化 Python 代码执行的工具</h2><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="pu l nf ng nh nd ni ml mu"/></div></div></a></div><div class="mr ms gp gr mt mu"><a rel="noopener follow" target="_blank" href="/bentoml-create-an-ml-powered-prediction-service-in-minutes-23d135d6ca76"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd iu gy z fp mz fr fs na fu fw is bi translated">BentoML:在几分钟内创建一个 ML 驱动的预测服务</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">用 Python 封装和部署您的 ML 模型</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">towardsdatascience.com</p></div></div><div class="nd l"><div class="pv l nf ng nh nd ni ml mu"/></div></div></a></div><h1 id="64a7" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">参考</h1><p id="6d30" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">币安加密线。2018–01–16.币安。<br/> CC0:公共领域。从 https://www.kaggle.com/binance/binance-crypto-klines<a class="ae nj" href="https://www.kaggle.com/binance/binance-crypto-klines" rel="noopener ugc nofollow" target="_blank">检索到 2022–03–01</a></p></div></div>    
</body>
</html>