<html>
<head>
<title>4 Things to Do When Applying Cross-Validation with Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对时间序列应用交叉验证时要做的 4 件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/4-things-to-do-when-applying-cross-validation-with-time-series-c6a5674ebf3a#2022-12-08">https://towardsdatascience.com/4-things-to-do-when-applying-cross-validation-with-time-series-c6a5674ebf3a#2022-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="42d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">获得更好的预测性能估计的一些实用建议</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fadb963845a8fde56cabb68112c7fcfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hfxdSdl1MfbWG9eq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@thoughtcatalog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章是关于使用交叉验证评估预测模型的。您将学习一些应用时间序列交叉验证的良好实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="9f9b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">交叉验证入门</h2><p id="6749" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你不应该使用相同的数据来训练和测试一个模型。</p><p id="daca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是为什么呢？</p><p id="d716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个模型学习尽可能多的模式。一些模式抓住了过去和未来观察之间的真实关系。但是，该模型也学习训练集中的固有噪声。在未来的观测中不能很好概括的侥幸模式。</p><p id="d419" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在相同的数据上训练和测试模型会产生乐观的结果。我们从 1931 年就知道了(<strong class="lb iu">！！</strong>)【1】。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/0a8ac475a3a7f9452147606e0e5be855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ohwOsfX0kAO4qOPUV6Vofw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1:过度拟合训练数据的预测模型的示例应用。预测(蓝色)与训练数据(黑色)非常匹配，但与验证数据(红色)不匹配。图片作者。</p></figure><p id="2a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交叉验证就是为了解决这个问题而开发的。</p><p id="17a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交叉验证是多次拆分数据的过程。在每次拆分时，部分数据用于训练模型(训练集)。剩下的部分(验证集)用于评估模型的性能。</p><p id="adf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交叉验证背后的想法是复制一个现实的场景。训练数据充当可用于创建模型的数据。验证集充当您在部署该模型后会遇到的数据。</p><p id="9e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，交叉验证的目标是提供一个可靠的性能评估。评估模型在部署后的表现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c28" class="nb md it bd me nc nd ne mh nf ng nh mk jz ni ka mn kc nj kd mq kf nk kg mt nl bi translated">时间序列的交叉验证</h1><h2 id="bfba" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">k 倍交叉验证</h2><p id="4a98" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有许多方法可以对数据集进行交叉验证。K-fold 交叉验证是最流行的方法之一。它的工作原理是将数据随机分成 K 份。每个折叠包含相同数量的观察值。然后，每个文件夹被迭代地用于验证。最后，将模型在所有折叠中的性能进行平均，以估计其性能。如果你测试几个模型，你选择一个平均性能最好的。</p><p id="edc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图说明了 5 重交叉验证的分割标准。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/7854ee8428fbbb5bd962fc5151e82ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ViSc20eOrSpbnOstjJ11nw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 1: K 倍交叉验证(K=5)数据分区。图片作者。</p></figure><p id="1c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">K-fold 交叉验证可以以不同的方式扩展。</p><ul class=""><li id="3722" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">您可以多次重复该过程，以获得更可靠的结果。这被称为<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.RepeatedKFold.html" rel="noopener ugc nofollow" target="_blank">重复 K 倍交叉验证</a>；</li><li id="6bc0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.StratifiedKFold.html" rel="noopener ugc nofollow" target="_blank">分层 K 折叠交叉验证</a>确保每个折叠保持原始类别分布；</li><li id="822f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">您可以使用<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.GroupKFold.html" rel="noopener ugc nofollow" target="_blank">组 K 折叠交叉验证</a>来跨不同折叠拆分不同的组。</li></ul><p id="07c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">k 倍交叉验证之所以有吸引力，有两个主要原因。一个是它的简单分裂启发式。另一个是它的数据效率。在某些时候，所有可用的观察结果都用于训练和测试。</p><h2 id="9065" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">为什么 K 重交叉验证不适用于时间序列</h2><p id="643b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">交叉验证是在假设观察是独立的情况下进行的。但是，对于时间序列来说，这是不正确的。</p><p id="33b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间序列是有序序列。每个观察都多少取决于之前发生的事情。这种依赖性通过诸如自相关的统计来量化。</p><h2 id="4e2b" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">实用建议</h2><p id="39af" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">那么，我们应该如何评估预测模型呢？</p><p id="7253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个故事的其余部分提供了四个实用的建议来做到这一点。</p><h2 id="fb44" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.保留时间顺序</h2><p id="88c3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">保持观察值的顺序是获得可靠估计值的关键。可以说，这是对时间序列应用交叉验证的黄金法则。</p><p id="0d28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你打乱观察会发生什么？该模型从未来中学习过去未曾暴露的细微差别。这导致了乐观的估计。</p><h2 id="054a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.在培训和验证之间制造差距</h2><p id="aacf" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">训练集和验证集通常是连续的(见图 2)。因此，验证集的初始部分与训练集的最后部分高度相关。</p><p id="8f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，删除验证集附近的训练观察值是个好主意。这增加了培训和验证之间的独立性。这个过程也称为清洗。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/a09f9fca6bfb5777abe6ee20e8acfc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XZPdh0362RO9UUw1Irpb-w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 2:连续的训练/验证分割(上图)和有间隙的训练/验证分割(下图)。图片作者。</p></figure><h2 id="518d" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.创建几个拆分</h2><p id="9a6c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对所有类型的数据(包括时间序列)进行多次分割通常是一种好的做法。</p><p id="4884" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于所选原点的特殊性，单个分割可能会有偏差。许多分割将涵盖时间序列的不同部分。例如，不同趋势或季节性模式。</p><p id="73cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果你的时间序列很大(比如说，成千上万次观察)，那么多次分割就不那么重要了。</p><h1 id="0031" class="nb md it bd me nc oc ne mh nf od nh mk jz oe ka mn kc of kd mq kf og kg mt nl bi translated">时间序列</h1><p id="cb75" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">那么，哪种方法遵循这些准则呢？</p><p id="353c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个例子是 TimeSeriesSplits，scikit-learn 中提供的一个方法<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.TimeSeriesSplit.html" rel="noopener ugc nofollow" target="_blank">。这种方法有不同的名称。这些方法包括时序交叉验证、前推验证或块中的前序验证。</a></p><p id="4efc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法是将时间序列分割成 K 个连续的块。然后，每个块用于首先测试一个模型，然后重新训练它。</p><p id="b107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个图表可以帮助你想象这个过程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/fdb32af3a25cc2eba3b6e8b9f7dc29b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6GlQEF9Wk2vlbFetQRsYg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 3:时间序列分成 5 个部分。图片作者。</p></figure><p id="7748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，训练集和验证集之间存在差距:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/93e749b1c1bd5c3b886aebb08f655192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRvpd84up9PU99697Qlpmw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图 5:时间序列分成 5 个部分，在训练和验证之间有一个间隔。图片作者。</p></figure><p id="a80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TimeSeriesSplits 实现与其他<em class="oj"> scikit-learn </em>函数兼容，例如 GridSearchCV。下面是一个优化随机森林的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h1 id="6ed6" class="nb md it bd me nc oc ne mh nf od nh mk jz oe ka mn kc of kd mq kf og kg mt nl bi translated">多个时间序列或组</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/4f049f012db1ceff0fdf1e2577724eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*odTVpblOr6usw0pg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/es/@jccards?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马雷克·斯图津斯基</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="ff6a" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.将每个时间序列放在不同的文件夹中</h2><p id="1186" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时你不得不处理许多时间序列，而不仅仅是一个。例如，不同零售产品的每日销售额。每个产品代表一个时间序列。</p><p id="a8d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，数据集中的时间序列在某种程度上是相互关联的。因此，您可能希望将每个系列保存在特定文件夹中，以防止信息泄漏。这导致训练集和验证集之间更大的独立性。</p><p id="06a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些情况下可以使用<a class="ae ky" href="http://rasbt.github.io/mlxtend/user_guide/evaluate/GroupTimeSeriesSplit/" rel="noopener ugc nofollow" target="_blank"> GroupTimeSeriesSplit 方法</a>。</p><h1 id="ae2e" class="nb md it bd me nc oc ne mh nf od nh mk jz oe ka mn kc of kd mq kf og kg mt nl bi translated">外卖</h1><p id="a6a9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本文中，您了解了在对时间序列应用交叉验证时要考虑的四个方面。</p><ol class=""><li id="57fa" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu on nt nu nv bi translated">保持观察的时间顺序；</li><li id="fa3f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu on nt nu nv bi translated">在培训和验证之间制造差距；</li><li id="9d3b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu on nt nu nv bi translated">制造许多裂缝或褶皱；</li><li id="1cb4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu on nt nu nv bi translated">对于有许多时间序列的数据集，将每个时间序列放在不同的文件夹中。</li></ol><p id="2e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，下一个故事再见！</p><h2 id="cb98" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">进一步阅读</h2><p id="cef5" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">[1]拉尔森，S. C. (1931 年)。多重相关系数的收缩。伊迪克。心理学。, 22:45–55.</p><p id="fc39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">[2]阿洛、西尔万和阿兰·塞利塞。“模型选择交叉验证程序的调查。”<em class="oj">统计调查</em>4(2010):40–79。</p></div></div>    
</body>
</html>