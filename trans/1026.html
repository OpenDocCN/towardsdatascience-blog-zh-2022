<html>
<head>
<title>20 Very Commonly Used Functions of PySpark RDD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PySpark RDD 的 20 个非常常用的功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/20-very-commonly-used-functions-of-pyspark-rdd-90b8271c25b2#2022-03-17">https://towardsdatascience.com/20-very-commonly-used-functions-of-pyspark-rdd-90b8271c25b2#2022-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8f48266872aad10329d17792ec440ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r3Qsch-QPMlqjQSN"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@flashdantz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">闪光灯 Dantz </a>拍摄</p></figure><div class=""/><div class=""><h2 id="882b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">每个功能都用清晰的例子演示</h2></div><p id="05c9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Apache Spark 在大数据分析领域非常受欢迎。它使用分布式处理系统。PySpark 是 Python 中 Apache Spark 的接口。当你有一个万亿字节大小的巨大数据集时，常规的 python 代码会非常慢。但是 PySpark 算法要快得多。因为它将数据集分成更小的部分，将数据集分布到不同的处理器中，在每个处理器中分别执行操作，然后将它们重新组合在一起，得到总输出。</p><p id="37b5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是 PySpark 如何更快工作的高级概述。本文将重点介绍 PySpark 中一些非常常用的函数。</p><p id="d7b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果是初学者，可以用 google-colab 笔记本练习一下。您只需使用以下简单的命令行进行安装:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="deb5" class="md me jj lz b gy mf mg l mh mi">pip install pyspark</span></pre><p id="3a8c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只需几分钟即可完成安装，笔记本电脑将准备好 PySpark 代码。</p><p id="2e22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，需要创建一个 SparkContext，这是 Spark 功能的主要入口点。它代表与火花簇的连接。我在这里创建了一个 SparkContext:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f3aa" class="md me jj lz b gy mf mg l mh mi">from pyspark import SparkContext<br/>sc = SparkContext.getOrCreate()</span></pre><p id="09fd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将从最基本的函数开始，向更便于分析的函数发展。</p><blockquote class="mj mk ml"><p id="bbbc" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">sc.parallelize()</p></blockquote><p id="1a3c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我使用并行化方法，用这个 SparkContext 创建了一个非常简单的 RDD 对象。并行化方法创建一个并行化的集合，允许数据的分布。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8cfd" class="md me jj lz b gy mf mg l mh mi">rdd_small = sc.parallelize([3, 1, 12, 6, 8, 10, 14, 19])</span></pre><p id="7f63" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您不能像在笔记本中打印常规列表或数组一样打印 RDD 对象。</p><blockquote class="mj mk ml"><p id="7dc1" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。收集()</p></blockquote><p id="fa48" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您简单地键入 rdd_small 并在笔记本中运行，输出将如下所示:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4495" class="md me jj lz b gy mf mg l mh mi">rdd_small</span></pre><p id="be81" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f285" class="md me jj lz b gy mf mg l mh mi">ParallelCollectionRDD[1] at readRDDFromFile at PythonRDD.scala:274</span></pre><p id="bbe5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以，它是一个 parallelCollectionRDD。因为这些数据在分布式系统中。你必须把它们收集到一起，才能作为一个列表使用。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c65e" class="md me jj lz b gy mf mg l mh mi">rdd_small.collect()</span></pre><p id="9878" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9a93" class="md me jj lz b gy mf mg l mh mi">[3, 1, 12, 6, 8, 10, 14, 19]</span></pre><p id="dfcf" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当数据集太大时，收集整个 RDD 对象可能并不总是有意义。您可能希望只获取数据的第一个元素或前几个元素来检查数据结构、类型或数据质量。</p><p id="3197" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我做了一个更大的 RDD 物体:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7292" class="md me jj lz b gy mf mg l mh mi">rdd_set = sc.parallelize([[2, 12, 5, 19, 21],</span><span id="72a8" class="md me jj lz b gy mq mg l mh mi">                          [10, 19, 5, 21, 8],</span><span id="9b11" class="md me jj lz b gy mq mg l mh mi">                          [34, 21, 14, 8, 10],</span><span id="ac12" class="md me jj lz b gy mq mg l mh mi">                          [110, 89, 90, 134, 24],</span><span id="8c73" class="md me jj lz b gy mq mg l mh mi">                          [23, 119, 234, 34, 56]])</span></pre><blockquote class="mj mk ml"><p id="318e" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。首先()</p></blockquote><p id="3a7f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅获取 RDD 对象的第一个元素:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="00ee" class="md me jj lz b gy mf mg l mh mi">rdd_set.first()</span></pre><p id="8a27" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="30c8" class="md me jj lz b gy mf mg l mh mi">[2, 12, 5, 19, 21]</span></pre><blockquote class="mj mk ml"><p id="6468" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。采取()</p></blockquote><p id="4a87" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里我取前三个元素:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="00fb" class="md me jj lz b gy mf mg l mh mi">rdd_set.take(3)</span></pre><p id="d95e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5550" class="md me jj lz b gy mf mg l mh mi">[[2, 12, 5, 19, 21], [10, 19, 5, 21, 8], [34, 21, 14, 8, 10]]</span></pre><p id="149d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得到前三个元素作为输出。</p><blockquote class="mj mk ml"><p id="f9d1" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。文本文件()</p></blockquote><p id="94ec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此时，我想引入一个文本文件来演示几个不同的功能。</p><p id="db46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我从美国的<a class="ae jg" href="https://en.wikipedia.org/wiki/United_States" rel="noopener ugc nofollow" target="_blank">维基百科页面复制了一些文本，用一个简单的记事本制作了一个文本文件。该文件保存为 usa.txt。您可以通过以下链接下载该文本文件:</a></p><div class="is it gp gr iu mr"><a href="https://github.com/rashida048/Big-Data-Anlytics-Pyspark/blob/main/usa.txt" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">大数据分析中心-Pyspark/USA . txt at main rashida 048/大数据分析中心-py spark</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">此文件包含双向 Unicode 文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf ja mr"/></div></div></a></div><p id="04d0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是如何使用文本文件创建 RDD:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="32d9" class="md me jj lz b gy mf mg l mh mi">lines = sc.textFile("usa.txt")</span></pre><p id="dd30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们使用。再次使用()函数查看文件的前 4 个元素:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="132a" class="md me jj lz b gy mf mg l mh mi">lines.take(2)</span></pre><p id="c0f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ccbb" class="md me jj lz b gy mf mg l mh mi">["The United States of America (U.S.A. or USA), commonly known as the United States (U.S. or US) or America, is a country primarily located in North America. It consists of 50 states, a federal district, five major unincorporated territories, 326 Indian reservations, and nine minor outlying islands.[h] At nearly 3.8 million square miles (9.8 million square kilometers), it is the world's third- or fourth-largest country by geographic area.[c] The United States shares land borders with Canada to the north and Mexico to the south as well as maritime borders with the Bahamas, Cuba, Russia, and other countries.[i] With a population of more than 331 million people,[j] it is the third most populous country in the world. The national capital is Washington, D.C., and the most populous city and financial center is New York City.",  '']</span></pre><blockquote class="mj mk ml"><p id="02d1" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。平面地图()</p></blockquote><p id="3bdc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将文本内容分开进行分析是一种常见的做法。下面是使用 flatMap 函数按空间分割文本数据并生成一个大的字符串列表:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9ec6" class="md me jj lz b gy mf mg l mh mi">words = lines.flatMap(lambda x: x.split(' '))</span><span id="a038" class="md me jj lz b gy mq mg l mh mi">words.take(10)</span></pre><p id="d0c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5ecf" class="md me jj lz b gy mf mg l mh mi">['The',  'United',  'States',  'of',  'America',  '(U.S.A.',  'or',  'USA),',  'commonly',  'known']</span></pre><p id="1314" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">前 10 个元素现在看起来像这样。</p><blockquote class="mj mk ml"><p id="a601" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。地图()</p></blockquote><p id="4c4f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果要对 RDD 的每个元素应用某种变换或使用某个条件，该映射会很有用。在这种情况下，每个元素意味着每个单词。在这里，我将使每个单词小写，并将通过在每个单词上加 1 来将每个单词转换为一个元组。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="59d8" class="md me jj lz b gy mf mg l mh mi">wordsAsTuples = words.map(lambda x: (x.lower(), 1))</span><span id="7243" class="md me jj lz b gy mq mg l mh mi">wordsAsTuples.take(4)</span></pre><p id="0f1c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0871" class="md me jj lz b gy mf mg l mh mi">[('the', 1), ('united', 1), ('states', 1), ('of', 1)]</span></pre><p id="7aa7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是对发生的事情的一点解释。lambda 表达式中的“x”表示 RDD 的每个元素。你对 x 做的任何事情都适用于 RDD 中的每一个元素。</p><p id="1981" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，我们将“x”转换为(x，1)。所以，每个单词都是(word，1)。仔细查看输出。</p><blockquote class="mj mk ml"><p id="91ad" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。reduceByKey</p></blockquote><p id="90f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有一个键-值对，并且您希望将同一个键的所有值相加，那么这个函数非常有用。例如，在上面的 wordsAsTuples 中，我们有键-值对，其中键是单词，值是 1。通常，元组的第一个元素被认为是键，第二个元素是值。</p><p id="88eb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在 wordsAsTuples 上使用 reduceByKey，它会将我们为同一个键添加的 1 相加(这意味着相同的单词)。如果我们有 4 个“the”，它将加上 4 个 1，并将使它(' the '，4)</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8e29" class="md me jj lz b gy mf mg l mh mi">counts = wordsAsTuples.reduceByKey(lambda x, y: x+y)<br/>counts.take(3)</span></pre><p id="fa99" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="52bc" class="md me jj lz b gy mf mg l mh mi">[('united', 14), ('of', 20), ('america', 1)]</span></pre><p id="5546" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，在我们的文本数据中,“united”出现了 14 次,“of”出现了 20 次,“america”只出现了一次。</p><blockquote class="mj mk ml"><p id="d851" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。顶部()</p></blockquote><p id="5de0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">返回指定的顶部元素。在这个例子之后，我将进一步解释:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="98b1" class="md me jj lz b gy mf mg l mh mi">counts.top(20, lambda x: x[1])</span></pre><p id="6f22" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="16c5" class="md me jj lz b gy mf mg l mh mi">[('the', 55),  <br/>('and', 24),  <br/>('of', 20),  <br/>('united', 14),  <br/>('is', 13),  <br/>('in', 13),  <br/>('a', 13),  <br/>('states', 12),  <br/>('it', 9),  <br/>('to', 7),  <br/>('as', 6),  <br/>("world's", 6),  <br/>('by', 6),  <br/>('world', 5),  <br/>('with', 5),  <br/>('american', 5),  <br/>('war', 5),  <br/>('or', 4),  <br/>('north', 4),  <br/>('its', 4)]</span></pre><p id="e9e3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里发生了什么？在这个命令中，我们说我们想要前 20 个元素。然后 x[1]被指定为 lambda 表达式中的一个条件。在类似(' the '，55)的元组中，' the '是 x[0]，55 是 x[1]。在 lambda 中，指定 x[1]意味着我们想要基于每个元素的 x[1]的前 20 个元素。因此，它根据文本文件中的出现次数返回前 20 个单词。</p><p id="6d56" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果使用 x[0]作为 lambda 的条件，它将根据字母顺序返回前 20 名，因为 x[0]是一个字符串。请随意尝试。</p><blockquote class="mj mk ml"><p id="46b6" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。过滤器()</p></blockquote><p id="459a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的前 20 个单词中，大部分单词都不是很显著。像“to”、“The”、“with”、“in”这样的词不能提供对文本的任何洞察。在处理文本数据时，通常会忽略那些无关紧要的单词。尽管这并不总是一个好主意。</p><p id="c3ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们能排除一些无关紧要的词，我们可能会看到一些更有意义的词出现在前 20 名中。</p><p id="115a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是我在选择前 20 个单词之前想从文本中排除的单词列表:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9b06" class="md me jj lz b gy mf mg l mh mi">stop = ['', 'the', 'and', 'of', 'is', 'in', 'a', 'it', 'to', 'as', 'by', 'with', 'or', 'its', 'from', 'at']</span></pre><p id="cf08" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们将过滤掉那些单词:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="9e3e" class="md me jj lz b gy mf mg l mh mi">words_short = counts.filter(lambda x: x[0] not in stop)</span></pre><p id="c946" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个新 RDD 单词 _short 没有我们在‘stop’中列出的那些单词。</p><p id="71ed" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是现在最热门的 20 个单词:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="877c" class="md me jj lz b gy mf mg l mh mi">words_short.top(20, lambda x: x[1])</span></pre><p id="6dac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e39a" class="md me jj lz b gy mf mg l mh mi">[('united', 14),<br/> ('states', 12),<br/> ("world's", 6),<br/> ('world', 5),<br/> ('american', 5),<br/> ('war', 5),<br/> ('north', 4),<br/> ('country', 3),<br/> ('population', 3),<br/> ('new', 3),<br/> ('established', 3),<br/> ('war,', 3),<br/> ('million', 3),<br/> ('military', 3),<br/> ('international', 3),<br/> ('largest', 3),<br/> ('america,', 2),<br/> ('states,', 2),<br/> ('square', 2),<br/> ('other', 2)]</span></pre><p id="7306" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在“禁止”列表中没有这些词。</p><blockquote class="mj mk ml"><p id="725f" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。sortByKey()</p></blockquote><p id="fda4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以用这个对整个 RDD 进行排序。sortByKey()函数。顾名思义，它通过键对 RDD 进行排序。在“计数”RDD 中，关键字是字符串。所以，它会按字母顺序排序。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2ff7" class="md me jj lz b gy mf mg l mh mi">counts.sortByKey().take(10)</span></pre><p id="f73c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b3d1" class="md me jj lz b gy mf mg l mh mi">[('', 3),  <br/>('(1775–1783),', 1),  <br/>('(9.8', 1),  <br/>('(u.s.', 1),  <br/>('(u.s.a.', 1),  <br/>('12,000', 1),  <br/>('16th', 1),  <br/>('1848,', 1),  <br/>('18th', 1),  <br/>('1969', 1)]</span></pre><p id="5025" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，空字符串先出现，然后是数字字符串。因为数字键在字母顺序中排在字母之前。</p><p id="9919" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，排序以升序给出结果。但是如果在 sortByKey 函数中传递 False，它会按降序排序。这里我们按降序排序，取前 10 个元素:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="70c5" class="md me jj lz b gy mf mg l mh mi">counts.sortByKey(False).take(10)</span></pre><p id="7106" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="d76e" class="md me jj lz b gy mf mg l mh mi">[('york', 1),  <br/>('years', 1),  <br/>('world.', 1),  <br/>('world,', 1),  <br/>("world's", 6),  <br/>('world', 5),  <br/>('with', 5),  <br/>('which', 1),  <br/>('when', 1),  <br/>('west.', 1)]</span></pre><p id="04a4" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">中排序之前应用函数或条件也是可能的。sortByKey 函数。这里有一个 RDD:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6c3b" class="md me jj lz b gy mf mg l mh mi">r1 = [('a', 1), ('B', 2), ('c', 3), ('D', 4), ('e', 5)]</span></pre><p id="1e29" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 RDD r1 中，一些键是小写的，一些键是大写的。如果我们按键排序，默认情况下大写字母会先出现，然后是小写字母。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="bd73" class="md me jj lz b gy mf mg l mh mi">r1.sortByKey().collect()</span></pre><p id="847d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="69ec" class="md me jj lz b gy mf mg l mh mi">[('B', 2), ('D', 4), ('a', 1), ('c', 3), ('e', 5)]</span></pre><p id="a286" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们希望避免使用大小写部分，并且希望函数在排序时不区分大小写，我们可以在。sortByKey 函数。这里有一个例子:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7fc4" class="md me jj lz b gy mf mg l mh mi">r1.sortByKey(True, keyfunc=lambda k: k.upper()).collect()</span></pre><p id="9494" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6dbf" class="md me jj lz b gy mf mg l mh mi">[('a', 1), ('B', 2), ('c', 3), ('D', 4), ('e', 5)]</span></pre><p id="49af" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的 lambda 表达式中，我们要求函数将所有键都视为大写，然后进行排序。它只将所有键视为大写字母，但不返回大写字母的键。</p><blockquote class="mj mk ml"><p id="0ba8" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。groupByKey()</p></blockquote><p id="ba59" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个函数 groupByKey()根据键对所有值进行分组，并对它们进行聚合。<strong class="la jk">提醒一下，默认情况下，元组中的第一个元素是键，第二个元素是值。</strong>在进一步讨论之前，我们先看一个例子:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5a95" class="md me jj lz b gy mf mg l mh mi">numbers_only = wordsAsTuples.groupByKey().map(lambda x: sum(x[1]))<br/>numbers_only.take(10)</span></pre><p id="0f05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ca24" class="md me jj lz b gy mf mg l mh mi">[14, 20, 1, 1, 1, 6, 2, 13, 3, 1]</span></pre><p id="749b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，关键词就是单词。假设“the”是一个键，当我们使用 groupByKey()时，它将这个键“the”的所有值分组，并按照指定的方式聚合它们。这里我使用 sum()作为聚合函数。所以，它总结了所有的值。我们得到了每个单词的出现次数。<strong class="la jk">但是这一次我们只得到出现次数的列表。</strong></p><blockquote class="mj mk ml"><p id="d739" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。减少()</p></blockquote><p id="95c6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它用于减少 RDD 元素。减少数量 _ 只有我们从上一个例子中得到的:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5ef2" class="md me jj lz b gy mf mg l mh mi">total_words = numbers_only.reduce(lambda x, y: x+y)<br/>total_words</span></pre><p id="161e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="139d" class="md me jj lz b gy mf mg l mh mi">575</span></pre><p id="bc25" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们得了 575 分。这意味着文本文件中总共有 575 个单词。</p><blockquote class="mj mk ml"><p id="73d6" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。地图值()</p></blockquote><p id="c743" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以用来对键值对的值进行某种转换。它返回键和转换后的值。下面是一个例子，其中键是字符串，值是整数。我将这些值除以 2:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="017d" class="md me jj lz b gy mf mg l mh mi">rdd_1 = sc.parallelize([("a", 3), ("n", 10), ("s", 5), ("l", 12)])</span><span id="533c" class="md me jj lz b gy mq mg l mh mi">rdd_1.mapValues(lambda x: x/2).collect()</span></pre><p id="f205" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fae5" class="md me jj lz b gy mf mg l mh mi">[('a', 1.5), ('n', 5.0), ('s', 2.5), ('l', 6.0)]</span></pre><p id="30b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，lambda 表达式中的“x”表示值。所以，无论你对 x 做什么，都适用于 RDD 中的所有值。</p><p id="ca02" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">再举一个例子会有助于更好地理解它。在本例中，使用了不同的 RDD，其中键是字符串，值是整数列表。我们将在列表中使用聚合函数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6bb0" class="md me jj lz b gy mf mg l mh mi">rdd_map = sc.parallelize([("a", [1, 2, 3, 4]), ("b", [10, 2, 8, 1])])</span><span id="d1e2" class="md me jj lz b gy mq mg l mh mi">rdd_map.mapValues(lambda x: sum(x)).collect()</span></pre><p id="e885" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="fb06" class="md me jj lz b gy mf mg l mh mi">[('a', 10), ('b', 21)]</span></pre><p id="4deb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看看这里的输出。每个值都是值列表中整数的总和。</p><blockquote class="mj mk ml"><p id="3afd" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。countByValue()</p></blockquote><p id="76f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以字典格式返回 RDD 中每个元素的出现次数。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="80c0" class="md me jj lz b gy mf mg l mh mi">sc.parallelize([1, 2, 1, 3, 2, 4, 1, 4, 4]).countByValue()</span></pre><p id="7b54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0ef9" class="md me jj lz b gy mf mg l mh mi">defaultdict(int, {1: 3, 2: 2, 3: 1, 4: 3})</span></pre><p id="1435" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出显示了一个字典，其中键是 RDD 的不同元素，值是这些不同值的出现次数。</p><blockquote class="mj mk ml"><p id="539b" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。getNumPartitions()</p></blockquote><p id="5409" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">RDD 对象存储为元素簇。换句话说，一个 RDD 对象被分成许多分区。我们不做这些划分。这就是 RDDs 的本质。这是默认发生的。</p><p id="b9d2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">集群可以为所有分区同时运行一个任务。顾名思义，这个功能。getNumPartitions()告诉你有多少分区。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a15f" class="md me jj lz b gy mf mg l mh mi">data = sc.parallelize([("p",5),("q",0),("r", 10),("q",3)])</span><span id="eded" class="md me jj lz b gy mq mg l mh mi">data.getNumPartitions()</span></pre><p id="9ed8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="861e" class="md me jj lz b gy mf mg l mh mi">2</span></pre><p id="1e3d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“数据”对象中有两个分区。</p><p id="5ba5" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用. glom()函数来查看它们是如何划分的:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c9f4" class="md me jj lz b gy mf mg l mh mi">data.glom().collect()</span></pre><p id="fd6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4b7b" class="md me jj lz b gy mf mg l mh mi">[[('a', 1), ('b', 2)], [('a', 2), ('b', 3)]]</span></pre><p id="30ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它显示了两个元素列表。因为有两个分区。</p><blockquote class="mj mk ml"><p id="93fe" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">联盟</p></blockquote><p id="8e08" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用 union 合并两个 rdd。例如，这里我制作了两个 rdd“rd1”和“rd2”。然后，我使用 union 将它们连接在一起，创建“rd3”。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c806" class="md me jj lz b gy mf mg l mh mi">rd1 = sc.parallelize([2, 4, 7, 9])</span><span id="b45e" class="md me jj lz b gy mq mg l mh mi">rd2 = sc.parallelize([1, 4, 5, 8, 9])</span><span id="4aec" class="md me jj lz b gy mq mg l mh mi">rd3 = rd1.union(rd2)</span><span id="b624" class="md me jj lz b gy mq mg l mh mi">rd3.collect()</span></pre><p id="28b3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7931" class="md me jj lz b gy mf mg l mh mi">[2, 4, 7, 9, 1, 4, 5, 8, 9]</span></pre><p id="f203" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新形成的 RDD“rd3”包括“rd1”和“rd2”的所有元素。</p><blockquote class="mj mk ml"><p id="a978" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。独特()</p></blockquote><p id="93d7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它返回 RDD 的独特元素。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="af38" class="md me jj lz b gy mf mg l mh mi">rd4 = sc.parallelize([1, 4, 2, 1, 5, 4])</span><span id="d982" class="md me jj lz b gy mq mg l mh mi">rd4.distinct().collect()</span></pre><p id="3fd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2637" class="md me jj lz b gy mf mg l mh mi">[4, 2, 1, 5]</span></pre><p id="2691" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只有“rd4”的独特元素。</p><blockquote class="mj mk ml"><p id="a689" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">。zip()</p></blockquote><p id="95cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们在两个 rdd 上使用 zip 时，它们使用两个 rdd 的元素创建元组。一个例子将清楚地证明这一点:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="1acb" class="md me jj lz b gy mf mg l mh mi">rd11 = sc.parallelize(["a", "b", "c", "d", "e"])</span><span id="76e3" class="md me jj lz b gy mq mg l mh mi">rdda = sc.parallelize([1, 2, 3, 4, 5])</span><span id="8ae2" class="md me jj lz b gy mq mg l mh mi">rda_11 = rdda.zip(rd11)<br/>rda_11.collect()</span></pre><p id="c334" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="96ea" class="md me jj lz b gy mf mg l mh mi">[(1, 'a'), (2, 'b'), (3, 'c'), (4, 'd'), (5, 'e')]</span></pre><p id="2ffc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在 zip 操作中，我们首先提到了“rdda”。因此，在输出中，“rdda”元素排在第一位。</p><blockquote class="mj mk ml"><p id="d662" class="ky kz mm la b lb lc kk ld le lf kn lg mn li lj lk mo lm ln lo mp lq lr ls lt im bi translated">连接</p></blockquote><p id="8b15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文最后要做的是连接。这个名字已经告诉你它连接了两个 rdd。让我们再做一个类似‘RDA _ 11’的 RDD，然后我们就加入。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="b21c" class="md me jj lz b gy mf mg l mh mi">rddb = sc.parallelize([1, 3, 4, 6])</span><span id="fbc4" class="md me jj lz b gy mq mg l mh mi">rd22 = sc.parallelize(["apple", "ball", "cal", "dog"])<br/>rdb_22 = rddb.zip(rd22)</span><span id="9d42" class="md me jj lz b gy mq mg l mh mi">rdb_22.collect()</span></pre><p id="2003" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="f1c2" class="md me jj lz b gy mf mg l mh mi">[(1, 'apple'), (3, 'ball'), (4, 'cal'), (6, 'dog')]</span></pre><p id="c91d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们现在有‘RDB _ 22’。让我们将上一个示例中的“rdda_11”和“rdb_22”连接在一起:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="a0ee" class="md me jj lz b gy mf mg l mh mi">rda_11.join(rdb_22).collect()</span></pre><p id="6189" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="66e5" class="md me jj lz b gy mf mg l mh mi">[(4, ('d', 'cal')), (1, ('a', 'apple')), (3, ('c', 'ball'))]</span></pre><p id="3e19" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，join 操作连接键上的两个 rdd。再次提醒，每个元组的第一个元素被认为是键。</p><p id="c3cb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在基本的连接操作中，只有两个 rdd 中的公共键元素连接在一起。</p><p id="3c46" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有其他种类的连接。以下是左外部联接的一个示例:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="0127" class="md me jj lz b gy mf mg l mh mi">rda_11.leftOuterJoin(rdb_22).collect()</span></pre><p id="9ebc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="446b" class="md me jj lz b gy mf mg l mh mi">[(4, ('d', 'cal')),  <br/>(1, ('a', 'apple')),  <br/>(5, ('e', None)),  <br/>(2, ('b', None)),  <br/>(3, ('c', 'ball'))]</span></pre><p id="5070" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为这是左外部连接，所以左边提到的 RDD，在这种情况下，“rda_11”将带来它的所有元素。但是元素的顺序可能和‘RDA _ 11’不一样。右侧的 RDD 只会带来与左侧的 RDD 相同的元素。</p><p id="0ef1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一个右外部联接的作用正好相反:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="3225" class="md me jj lz b gy mf mg l mh mi">rda_11.rightOuterJoin(rdb_22).collect()</span></pre><p id="4660" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="8539" class="md me jj lz b gy mf mg l mh mi">[(4, ('d', 'cal')),  <br/>(1, ('a', 'apple')),  <br/>(6, (None, 'dog')),  <br/>(3, ('c', 'ball'))]</span></pre><p id="931f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，有一个完整的外部连接，它从两个 rdd 返回每个元素。</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="4d7c" class="md me jj lz b gy mf mg l mh mi">rda_11.fullOuterJoin(rdb_22).collect()</span></pre><p id="da6a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="e13e" class="md me jj lz b gy mf mg l mh mi">[(4, ('d', 'cal')),<br/> (1, ('a', 'apple')),<br/> (5, ('e', None)),<br/> (2, ('b', None)),<br/> (6, (None, 'dog')),<br/> (3, ('c', 'ball'))]</span></pre><p id="626b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这包含了来自两个 rdd 的所有密钥。</p><h2 id="540a" class="md me jj bd ng nh ni dn nj nk nl dp nm lh nn no np ll nq nr ns lp nt nu nv nw bi translated">结论</h2><p id="fce2" class="pw-post-body-paragraph ky kz jj la b lb nx kk ld le ny kn lg lh nz lj lk ll oa ln lo lp ob lr ls lt im bi translated">我想列出最常用和最简单的 RDD 操作，它们可以处理很多任务。还有很多 RDD 行动。稍后我可能会拿出更多的。希望这是有帮助的。</p><p id="6c30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随时在<a class="ae jg" href="https://twitter.com/rashida048" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae jg" href="https://www.facebook.com/Regenerative-149425692134498" rel="noopener ugc nofollow" target="_blank">脸书页面</a>上关注我，并查看我的<a class="ae jg" href="https://www.youtube.com/channel/UCzJgOvsJJPCXWytXWuVSeXw" rel="noopener ugc nofollow" target="_blank"> YouTube 频道</a>。</p><h2 id="0e60" class="md me jj bd ng nh ni dn nj nk nl dp nm lh nn no np ll nq nr ns lp nt nu nv nw bi translated">更多阅读</h2><div class="is it gp gr iu mr"><a rel="noopener follow" target="_blank" href="/regression-in-tensorflow-using-both-sequential-and-function-apis-314e74b537ca"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">TensorFlow 中使用顺序 API 和函数 API 的回归</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">演示几种不同类型的模型结构</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="oc l nc nd ne na nf ja mr"/></div></div></a></div><div class="is it gp gr iu mr"><a rel="noopener follow" target="_blank" href="/simple-explanation-on-how-decision-tree-algorithm-makes-decisions-34f56be344e9"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">浅谈决策树算法如何决策</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">决策树算法背后的直觉</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="od l nc nd ne na nf ja mr"/></div></div></a></div><div class="is it gp gr iu mr"><a href="https://pub.towardsai.net/data-analysis-91a38207c92b" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">数据分析</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">Python 中数据科学家/分析师日常工作中的常见数据清理任务</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">pub.towardsai.net</p></div></div><div class="na l"><div class="oe l nc nd ne na nf ja mr"/></div></div></a></div><div class="is it gp gr iu mr"><a rel="noopener follow" target="_blank" href="/understanding-regularization-in-plain-language-l1-and-l2-regularization-2991b9c54e9a"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">用通俗的语言理解正则化:L1 和 L2 正则化</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">在数据科学访谈中经常被问到</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="of l nc nd ne na nf ja mr"/></div></div></a></div><div class="is it gp gr iu mr"><a rel="noopener follow" target="_blank" href="/exploratory-data-analysis-with-some-cool-visualizations-in-pythons-matplotlib-and-seaborn-library-99dde20d98bf"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd jk gy z fp mw fr fs mx fu fw ji bi translated">利用 Python 的 Matplotlib 和 Seaborn 中的高级可视化进行探索性数据分析…</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">探索国际足联数据集</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">towardsdatascience.com</p></div></div><div class="na l"><div class="og l nc nd ne na nf ja mr"/></div></div></a></div></div></div>    
</body>
</html>