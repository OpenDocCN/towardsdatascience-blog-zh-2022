<html>
<head>
<title>Upcoming Python Features Brought to You by Python Enhancement Proposals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 增强提案为您带来的即将到来的 Python 特性</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/upcoming-python-features-brought-to-you-by-python-enhancement-proposals-57516c5558d9#2022-02-14">https://towardsdatascience.com/upcoming-python-features-brought-to-you-by-python-enhancement-proposals-57516c5558d9#2022-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="20ee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看最近的 Python 增强提案(pep)以及它们可能带来的所有令人兴奋的新特性、变化和改进</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/058c82ba79170bfc40ee57b69454c43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4a51FI9UpbntbJk9BqUPyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sunx?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张丽</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f44e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何新特性、变化或改进进入 Python 之前，需要有一个<em class="lv"> Python 增强提议</em>，也称为 PEP，概述提议的变化。这些 pep 是获取关于即将发布的 Python 版本中可能包含的最新信息的好方法。因此，在这篇文章中，我们将回顾所有将在不久的将来带来一些令人兴奋的新 Python 特性的提案！</p><h1 id="6a96" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">语法变化</h1><p id="b682" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">所有这些提议都可以分成几类，第一类是语法改变提议，它肯定会带来有趣的特性。</p><p id="548b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类别中的第一个是<a class="ae ky" href="https://www.python.org/dev/peps/pep-0671/" rel="noopener ugc nofollow" target="_blank"> PEP 671 </a>，它提出了后期绑定函数参数默认值的语法。那是什么意思呢？</p><p id="c4d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python 中的函数可以将其他函数作为参数。然而，没有好的方法来设置这些参数的默认值。通常使用<code class="fe mt mu mv mw b">None</code>或 sentinel 值(全局常量)作为默认值，这有缺点，包括不能在参数上使用<code class="fe mt mu mv mw b">help(function)</code>。这个 PEP 描述了使用<code class="fe mt mu mv mw b">=&gt;</code> ( <code class="fe mt mu mv mw b">param=&gt;func()</code>)符号指定函数作为默认参数的新语法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="91bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我来说，这种改变看起来合理且有用，但我认为我们应该小心添加太多新的语法符号/改变。像这样的小改进是否保证了另一个赋值操作符是有问题的。</p><p id="c5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个语法改变提议是<a class="ae ky" href="https://python.org/dev/peps/pep-0654/" rel="noopener ugc nofollow" target="_blank"> PEP 654 </a>，它提议将<code class="fe mt mu mv mw b">except*</code>作为引发异常组的新语法。这种方法的基本原理是 Python 解释器一次只能传播一个异常，但是当栈展开时，有时需要传播多个不相关的异常。一种这样的情况是来自并发任务的<code class="fe mt mu mv mw b">asyncio</code>的并发错误或在执行重试逻辑时引发的多个不同异常，例如，当连接到某个远程主机时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是使用这个新特性的一个非常简单的例子。如果你看一看 PEP 中的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0654/#id38" rel="noopener ugc nofollow" target="_blank">处理异常组</a>的例子，你会发现使用它的很多方法，包括递归匹配和链接。</p><h1 id="7cfe" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">打字</h1><p id="1807" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下一个类别——在最近的 Python 版本中大量出现——是类型/类型注释。</p><p id="dacb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<a class="ae ky" href="https://www.python.org/dev/peps/pep-0673/" rel="noopener ugc nofollow" target="_blank"> PEP 673 </a>开始——它不需要对 Python 的<code class="fe mt mu mv mw b">typing</code>模块有广泛的了解(通常情况下就是这样)。让我们用一个例子来解释一下:假设你有一个方法为<code class="fe mt mu mv mw b">set_name</code>的类<code class="fe mt mu mv mw b">Person</code>，它返回<code class="fe mt mu mv mw b">self</code>——类型为<code class="fe mt mu mv mw b">Person</code>的实例。如果你用同样的<code class="fe mt mu mv mw b">set_name</code>方法创建子类<code class="fe mt mu mv mw b">Employee</code>，你会期望它返回类型<code class="fe mt mu mv mw b">Employee</code>的实例，而不是<code class="fe mt mu mv mw b">Person</code>。然而，这并不是类型检查目前的工作方式——在 Python 3.10 中，类型检查器推断子类中的返回类型是基类的类型。该 PEP 通过允许我们使用带有以下语法的<em class="lv">“Self Type”</em>来帮助类型检查器正确推断类型，从而解决了这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="bf66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您遇到了这个问题，那么您可以期待很快使用这个特性，因为这个 PEP 已经被接受，并将作为 Python 3.11 版本的一部分来实现。</p><p id="7e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个类型变化出现在<a class="ae ky" href="https://www.python.org/dev/peps/pep-0675/" rel="noopener ugc nofollow" target="_blank"> PEP 675 </a>中，标题为<em class="lv">任意文字字符串</em>。</p><p id="3fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">引入这个 PEP 源于这样一个事实，即当前不可能指定函数参数的类型可以是一个<em class="lv">任意文字</em>字符串(只能使用特定的文字字符串，例如<code class="fe mt mu mv mw b">Literal["foo"]</code>)。您可能想知道为什么这甚至是一个问题，为什么有人需要指定参数应该是<em class="lv">文字字符串</em>，而不是<em class="lv"> f 字符串</em>(或其他插入的字符串)。这主要是安全问题——要求参数是字面量<em class="lv">有助于避免注入攻击，无论是 SQL/命令注入还是 XSS。PEP 的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0675/#appendix-a-other-uses" rel="noopener ugc nofollow" target="_blank">附录</a>中显示了一些例子。实现这一点将有助于像<code class="fe mt mu mv mw b">sqlite</code>这样的库在字符串插值被用在不该用的地方时向用户提供警告，所以让我们期待这一点很快被接受。</em></p><h1 id="b9af" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">排除故障</h1><p id="78d9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">接下来是 pep，帮助我们更有效地调试代码。从标题为<em class="lv">CPython</em>的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0669/" rel="noopener ugc nofollow" target="_blank"> PEP 669 </a>开始。这个 PEP 建议为 CPython 实现低成本监控，在运行调试器或分析器时不会影响 Python 程序的性能。考虑到在进行基本调试时不会有很大的性能损失，这不会对 Python 的最终用户产生很大的影响。然而，这在某些特殊情况下非常有用，例如:</p><ul class=""><li id="91b8" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">调试只能在生产环境中重现的问题，而不会影响应用程序性能。</li><li id="833d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">调试竞争条件，计时会影响问题是否会发生。</li><li id="38c5" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">运行基准测试时进行调试。</li></ul><p id="de72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人可能不会从中受益太多，但我相信试图提高 Python 本身性能的人肯定会喜欢这种变化，因为这将使调试和测试性能问题/改进变得更容易。</p><p id="ccec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个是<a class="ae ky" href="https://www.python.org/dev/peps/pep-0678/" rel="noopener ugc nofollow" target="_blank"> PEP 678 </a>，它建议将<code class="fe mt mu mv mw b">__note__</code>属性添加到<code class="fe mt mu mv mw b">BaseException</code>类中。该属性将用于保存附加的调试信息，这些信息可以作为回溯的一部分显示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上例所示，这在重新引发异常时特别有用。正如 PEP 所描述的，这对于有重试逻辑的库也是有用的，为每次失败的尝试增加额外的信息。类似地，测试库可以利用这一点向失败的断言添加更多的上下文，比如变量名和值。</p><p id="bcb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个与调试相关的提议是<a class="ae ky" href="https://www.python.org/dev/peps/pep-0657/" rel="noopener ugc nofollow" target="_blank"> PEP 657 </a>，它想给 Python 程序的每个字节码指令添加额外的数据。该数据可用于生成更好的追溯信息。它还建议应该公开 API，这将允许其他工具(如分析器或静态分析工具)使用这些数据。</p><p id="bfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来可能没什么意思，但实际上——在我看来——这是这里介绍的最有用的激励。这个 PEP 的最大好处肯定是拥有更好的回溯信息，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="838b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我认为这对于回溯可读性和调试来说是一个惊人的改进，我真的很高兴这是作为 Python 3.11 的一部分实现的，所以我们很快就会使用它。</p><h1 id="f28b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">生活质量改变</h1><p id="461f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后一个主题是致力于带来某些<em class="lv"/>“生活质量”改善的 pep。其中之一是<a class="ae ky" href="https://www.python.org/dev/peps/pep-0680/" rel="noopener ugc nofollow" target="_blank"> PEP 680 </a>，它提议在 Python 的标准库中添加对解析 TOML 格式的支持。</p><p id="7352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，TOML 作为一种格式被许多 Python 工具使用，包括构建工具。这给他们制造了一个自举问题。此外，许多流行的工具如<code class="fe mt mu mv mw b">flake8</code>不包含 TOML 支持，理由是它在标准库中缺乏支持。这个 PEP 提议在标准库的基础上增加 TOML 支持，这个标准库已经被像<code class="fe mt mu mv mw b">pip</code>或者<code class="fe mt mu mv mw b">pytest</code>这样的包使用。</p><p id="27a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我个人喜欢这个提议，我认为在标准库中包含通用/流行格式的库是有意义的，特别是当它们对 Python 的工具和生态系统如此重要的时候。问题是，我们什么时候能在 Python 标准库中看到 YAML 支持？</p><p id="1924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一点，就是<a class="ae ky" href="https://www.python.org/dev/peps/pep-0661/" rel="noopener ugc nofollow" target="_blank"> PEP 661 </a>，与所谓的<a class="ae ky" href="https://python-patterns.guide/python/sentinel-object/#sentinel-value" rel="noopener ugc nofollow" target="_blank"> <em class="lv">【哨兵值】</em> </a>有关。在 Python 中没有创建这种值的标准方法。通常用<code class="fe mt mu mv mw b">_something = object()</code>(普通习语)来完成，如前面的 PEP 671 所示。本 PEP 提出了标准库哨兵值的规范/实施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了新的解决方案可读性更好之外，这也有助于类型注释，因为它将为所有 sentinels 提供不同的类型。</p><h1 id="0d44" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结束语</h1><p id="5cd7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">从上面提出的建议来看，很明显，很多好东西正在向 Python 走来。然而，并不是所有的这些特性都会被纳入 Python(至少在目前的状态下不会)，所以一定要关注这些提议，看看它们会走向何方。为了及时了解上述 PEP 以及任何新添加的内容，您可以偶尔浏览一下<a class="ae ky" href="https://www.python.org/dev/peps/#numerical-index" rel="noopener ugc nofollow" target="_blank">索引</a>，或者通过订阅<a class="ae ky" href="https://www.python.org/dev/peps/peps.rss/" rel="noopener ugc nofollow" target="_blank"> PEP RSS feed </a>获得关于每个新添加内容的通知。</p><p id="7188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我只包括了一些对该语言提出一些新功能/变化的 pep，然而还有其他一些指定最佳实践、过程或烤箱 Python 的<a class="ae ky" href="https://www.python.org/dev/peps/pep-0664/" rel="noopener ugc nofollow" target="_blank">发布时间表</a>，所以如果你对这些主题感兴趣，请确保查看上述索引。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="cfb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">本文最初发布于</em><a class="ae ky" href="https://martinheinz.dev/blog/67?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_67" rel="noopener ugc nofollow" target="_blank"><em class="lv">martinheinz . dev</em></a></p><div class="nu nv gp gr nw nx"><a href="https://python.plainenglish.io/creating-beautiful-tracebacks-with-pythons-exception-hooks-c8a79e13558d" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用 Python 的异常钩子创建漂亮的回溯</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用 Python 的自定义异常创建的漂亮的回溯消息，调试可以成为一种愉快的体验…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">python .平原英语. io</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/profiling-and-analyzing-performance-of-python-programs-3bf3b41acd16"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">剖析和分析 Python 程序的性能</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">快速找到 Python 程序中的所有瓶颈并修复它们的工具和技术</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="om l oi oj ok og ol ks nx"/></div></div></a></div><div class="nu nv gp gr nw nx"><a rel="noopener follow" target="_blank" href="/exploring-google-analytics-realtime-data-with-python-8625849c7d7a"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">用 Python 探索 Google Analytics 实时数据</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">使用 REST API 和 Python 充分利用所有 Google Analytics 特性和数据</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">towardsdatascience.com</p></div></div><div class="og l"><div class="on l oi oj ok og ol ks nx"/></div></div></a></div></div></div>    
</body>
</html>