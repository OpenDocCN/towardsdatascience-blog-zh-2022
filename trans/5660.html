<html>
<head>
<title>How to Properly Test Your Data Models</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何正确测试您的数据模型</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-properly-test-your-data-models-c18b29fcbb61#2022-12-22">https://towardsdatascience.com/how-to-properly-test-your-data-models-c18b29fcbb61#2022-12-22</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="d9ff" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">在表和列中测试的位置和内容</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/f1e9a5dadad9ab9b2c114c97279ef97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RK5S3BIODpLmc5Lg4kY3LQ.jpeg"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">戴维·特拉维斯在<a class="ae la" href="https://unsplash.com/s/photos/testing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e9c9" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">测试是工程世界中最重要的实践之一。在软件工程中，测试可以防止错误进入生产。在数据工程中，测试确保数据被正确地捕获和移动。在分析工程中，它确保您的数据是高质量的，并随时可供业务团队使用。</p><p id="9000" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">测试数据模型可以在问题出现在下游模型之前捕捉到数据中的问题。如果没有测试，问题可能几天、几周甚至几个月都不会被发现。我遇到过这样的情况，由于令牌过期，网站后端没有收集数据，导致两周的数据丢失。我也有过由于数据源的模式或数据类型改变而过时的表，导致涉众使用陈旧的数据。测试是确保您对数据保持主动而非被动的唯一方法之一。</p><p id="d41f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">作为一项关键的数据治理实践，测试可用于维护高标准，以控制对数据的访问并掩盖客户 PII 信息。这有助于保持数据仓库中的数据安全和准确。</p><p id="d8d8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">从数据质量的角度来看，源代码和模型级别的测试是覆盖所有基础的关键。当这些测试失败时，设置通知数据集所有者(或任何负责数据质量的人)的警报也很重要。在本文中，我们将讨论好的测试的三个组成部分，以及您想要测试的源和模型的具体属性。</p><h1 id="55a8" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">源头测试</h1><p id="39d9" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在源处进行测试，意味着数据加载到数据仓库的第一点，对于创建一个强大的测试环境是必不可少的。您总是希望测试直接从外部源或摄取工具加载的数据，因为这是您可以捕捉任何问题的最早点。</p><p id="befc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在第一个数据加载步骤中捕获问题将允许您在问题影响下游数据模型或仪表板之前修复它们。这就像你的水龙头漏水一样——你会想在几滴水后发现它，而不是整个厨房都被淹了。在源代码中进行测试将有助于您做到这一点。</p><p id="afc7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，通过测试，你可以看到不同的属性。有些是在表级别，测试将表的特征作为一个整体来看。其他的是列级的，它们查看某一列中的值。让我们逐一讨论一下。</p><h1 id="2c8b" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">在表级别测试什么</h1><p id="e4fb" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">您应该在表级别跟踪的两个主要指标是<strong class="ld iw">列数</strong>和<strong class="ld iw">新鲜度</strong>。</p><h2 id="abb6" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">列数</h2><p id="eb4e" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">虽然列数是非常基本的，但是加载您期望看到的所有列是很重要的。如果您发现缺少一列，这可能表明您的摄取管道中存在问题，或者外部数据源的模式发生了变化。被提醒丢失的列将允许您在引用丢失的列的下游模型中断之前调查<em class="ng">为什么</em>它会丢失。</p><p id="c614" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">为了使用 SQL 查找表中的列数，您可以在雪花中运行以下查询:</p><pre class="kl km kn ko gt nh ni nj bn nk nl bi"><span id="bcb4" class="nm ly iv ni b be nn no l np nq">SELECT COUNT(column_name) AS number_of_columns FROM information_schema.columns WHERE table_name='ad_campaigns'</span></pre><p id="67d6" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这将返回表“ad_campaigns”中的列数。您可以使用类似这样的查询来比较实际的列数和预期的列数，并确保数量是相同的。</p><h2 id="b013" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">新鲜</h2><p id="7425" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">至于<strong class="ld iw">新鲜度</strong>，这是指表中的数据有多新。如果每天都接收数据，则最新的数据行应该在不超过 24 小时之前接收。如果每周获取数据，则最新的数据行应该在不超过七天前获取。虽然新鲜度取决于组织的需求，但最重要的是桌子的新鲜度符合您的期望。</p><p id="6db0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">检查新鲜度最简单的方法是查看最能代表表中一行数据创建时间的时间戳列。例如，对于事件表，这将是<code class="fe nr ns nt ni b">event_created_at</code>。对于我们在上面的例子中使用的“ad_campaigns”表，它应该是<code class="fe nr ns nt ni b">campaign_created_at</code>。确保这是时间戳列，而不是日期！</p><p id="d4e2" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在，您可以通过查看时间戳列中的最新值来了解表有多新。您可以使用以下 SQL 查询来找到它:</p><pre class="kl km kn ko gt nh ni nj bn nk nl bi"><span id="bad7" class="nm ly iv ni b be nn no l np nq">SELECT TOP campaign_created_at FROM ad_campaigns ORDER BY campaign_created_at DESC</span></pre><p id="7a2f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后，您可以使用该值来确定该时间和当前时间之间的差异，并将其与您可接受的阈值进行比较。</p><h1 id="51ac" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">在列级测试什么</h1><p id="82df" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">根据列的用途，您应该测试列的几个关键属性。首先，总是测试表中主键的<strong class="ld iw">唯一性。主键应该是表中行的唯一标识符。如果它们在一个表中不是唯一的，您可能会遇到意外的重复行或更深层次的问题。</strong></p><p id="5aae" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">检查这一点的一个简单方法是使用一个简单的计数函数。</p><pre class="kl km kn ko gt nh ni nj bn nk nl bi"><span id="0176" class="nm ly iv ni b be nn no l np nq">SELECT COUNT(campaign_id) FROM ad_campaigns</span></pre><p id="de62" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">现在找出不同活动 id 的数量。</p><pre class="kl km kn ko gt nh ni nj bn nk nl bi"><span id="0450" class="nm ly iv ni b be nn no l np nq">SELECT COUNT(DISTINCT campaign_id) FROM ad_campaigns</span></pre><p id="7201" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果没有重复，计数应该相等。</p><h2 id="eb01" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">空值</h2><p id="358a" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">接下来，您需要测试空值。虽然空值不一定是一件坏事，但是当您需要一个值时，它们就是一件坏事。测试空值将防止您的下游模型产生不正确的结果。NULLs 因搞乱聚合而臭名昭著，所以最好从源头上解决这个问题。</p><p id="968a" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">像这样的简单 SQL 查询将为您提供特定列的空值数量:</p><pre class="kl km kn ko gt nh ni nj bn nk nl bi"><span id="3c5a" class="nm ly iv ni b be nn no l np nq">SELECT COUNT(ad_id) FROM ad_campaigns WHERE ad_id IS NULL</span></pre><h2 id="d6cb" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">公认的价值观</h2><p id="88de" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">当值应该映射回映射表中的值时，测试列的可接受值特别有用。例如，“ad_campaigns”表中有一个名为<code class="fe nr ns nt ni b">campaign_type_id</code>的列。然后，这个列映射到一个“campaign_types”表，该表有两列:<code class="fe nr ns nt ni b">campaign_type_id</code>和<code class="fe nr ns nt ni b">campaign_type_name</code>。“ad_campaigns”表中的<code class="fe nr ns nt ni b">campaign_type_id</code>列中出现的每个值都必须出现在“campaign_types”表中。</p><p id="d042" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">您可以指定该列只接受 1–5 的值，因为这些值是对应映射表中唯一存在的值。如果测试发现<code class="fe nr ns nt ni b">campaign_type_id</code>为 6，你就会被提醒去调查。虽然这些问题最初可能不会影响数据质量，但您将开始看到未考虑的值，从而导致数据不正确。</p><h2 id="d42e" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">数据类型</h2><p id="816c" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">最后，检查列的数据类型是否正确。如果列不是预期的数据类型，下游的计算或转换可能会出错。为了对列执行特定的功能，列通常需要某种数据类型。</p><p id="2b47" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我还遇到过时间戳列与我预期的时间戳类型不同的问题。令人惊讶的是，这导致了我的 SQL 代码中的比较语句的差异。现在，我总是编写测试来检查列是否是正确的时间戳类型。</p><h1 id="e988" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">测试中间和核心数据模型</h1><p id="7d5a" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">中间和核心数据模型是转换源数据的模型。重要的是，不仅要测试源代码，还要测试每个模型。这将帮助您查明错误发生的确切位置。</p><p id="1387" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我经常看到人们在他们的中间模型中省略测试，而只在最终模型中包含它们。这可能会有问题，因为您不知道模型失败的确切时间。在中间模型中添加测试将允许您识别在错误之前通过的最后一个模型，消除了在过程中检查先前模型的需要。</p><p id="716c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">对于分析工程师来说，调试已经是一个巨大的痛苦。测试尽可能小的代码片段将有助于减少调试的麻烦。</p><p id="f1dd" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">对于中间数据模型和核心数据模型，您将希望测试许多与您在源数据中测试的属性相同的属性。在表级别，您应该测试列数和新鲜度。在列级别，测试主键、空值、可接受值和数据类型的唯一性是一个好主意。</p><h2 id="a40c" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">主键的唯一性</h2><p id="940e" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">由于经常使用连接，测试主键的唯一性对于中间和核心模型尤为重要。当在模型的 SQL 代码中使用不正确的连接时，通常会导致创建重复的行。唯一性测试将帮助您发现何时使用了错误的连接，允许您在继续构建模型之前修复它。</p><h2 id="8249" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">行数和列数</h2><p id="2131" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">如前所述，确保模型中使用正确连接的另一种方法是计算表中的行数和列数。为了更进一步，将这些数字与模型的源表中的数字进行比较。比较模型和源之间的行数将有助于您更好地理解数据是如何转换的。</p><p id="189c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">行之间应该有一对一的关系吗？或者，当连接源表时，是否意味着要创建更多的行？问自己这些问题将有助于你更好地理解你的模型及其目的。这也确保了你测试的质量是正确的。</p><h1 id="e572" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">发信号</h1><p id="b3d0" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">如果测试失败时没有人提醒你，测试有什么用？您可以实现任意多的测试，但是如果您没有收到测试失败的通知，您就必须每天手动检查您的模型，不管是否有问题。当决定在您的数据模型上使用的测试类型时，确保您使用那些具有强大警报功能的测试。</p><p id="025c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">我强烈建议寻找具有警告功能的测试。您希望确保您可以设置警报，以便在测试失败时通知正确的人。您还应该确保可以设置提醒，在您最常查看留言的媒体上通知您。</p><p id="7167" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你的团队在哪里来回沟通？你最常看的是什么？</p><p id="fa2c" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">就我个人而言，我总是通过 Slack 和我的团队交流。这是工作日联系我的最佳地点，因此也是发送我的测试警报的最佳地点。</p><p id="67f3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">理想情况下，您应该尽可能减少与任何类型的数据质量计划之间的摩擦。你不希望每天都要记得检查产品的用户界面，以确保一切都按预期运行。如果您没有收到警报，您应该能够假设一切都正常工作。</p><p id="472b" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">设置警报以通知负责数据质量的人员或拥有特定数据资产的人员也很重要。确保使用该资产最多的团队看到这一点，以便他们可以相应地进行规划。发送给与特定资产没有关联的人的警报基本上是无用的。</p><p id="15b8" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">例如，如果由于销售团队向数据集添加了新列而导致 Salesforce 集成失败，并且现在您的数据集不符合您在测试中定义的预期，则应通知销售团队解决此问题。</p><p id="f12d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">在这种情况下，您将通知数据集的所有者—拥有最多业务上下文的人。您还可以选择通知分析工程师或任何拥有数据质量的人来修复数据集中的问题。我建议两个都报警！</p><p id="1551" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">有许多平台可以让你创建提醒，添加描述和标签，以保持它们井井有条。我个人使用<a class="ae la" href="https://www.y42.com/?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=data_testing_article" rel="noopener ugc nofollow" target="_blank"> Y42 </a>从一些不同类型的触发器中进行选择，并为您希望得到的警报设置一个规则策略。诸如此类的广泛功能是创建主动数据质量环境的关键。</p><h1 id="5cb4" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">通过数据测试确保数据质量</h1><p id="8ebf" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">当您正确地测试您的源和模型时，当您在上游进行代码更改时，您可以确信下游的数据模型和仪表板是最新的和准确的。这使得团队对他们创造的价值充满信心，并且不害怕做出改变。你知道如果你做了一个错误的改变，你的测试将会失败，并提醒你有一个问题需要解决。</p><p id="d05f" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">请记住，您需要测试所有不同类型属性的数据，以便清楚地了解数据，并确保数据符合您的预期。正确的测试包括测试列的唯一性、空值、数据类型和可接受值，以及表的新鲜度和计数。实现这些测试是创建高质量数据环境的下一个最佳步骤。</p><p id="f393" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">看看我的第一本电子书，<a class="ae la" href="https://madisonmae.gumroad.com/l/learnanalyticsengineering" rel="noopener ugc nofollow" target="_blank">分析工程基础知识</a>，一本全方位的分析工程入门指南。</p></div></div>    
</body>
</html>