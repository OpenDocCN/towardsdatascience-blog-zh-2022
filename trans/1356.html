<html>
<head>
<title>Python and the Truth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python和真相</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-and-the-truth-90cf08380246#2022-04-04">https://towardsdatascience.com/python-and-the-truth-90cf08380246#2022-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ad6c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及类型对它的反应</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/db5944ad6bcac3ba3134dc2678e191f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhDKcrT7AY1-E_EfFiT77A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马库斯·温克勒的照片，Unspash。</p></figure><p id="2a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一段代码的逻辑流程可以想象成一棵树的树枝。条件帮助开发人员处理特定的情况，一般来说，它们以特性和验证的形式增加了新的分支。</p><p id="845b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">布尔值</strong>给数据结构带来意义。任何数字或字符串本身都不是正确或错误的，直到我们将其与我们的<strong class="ky ir">规则</strong>和期望进行比较。</p><p id="5f40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我的杯子空了，我会倒更多的咖啡；但是如果我没有足够的咖啡，我需要去商店。如果是星期天，商店关门，零咖啡，我会难过。</p><p id="d6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">人们已经将他们的大部分日常事务和互动建立在一套隐含应用的规则之上，这些规则基于<strong class="ky ir">值</strong>和<strong class="ky ir">状态</strong>。例如，如果我的咖啡少于7粒，我就不能准备更多的咖啡，如果杯子的状态是<code class="fe lt lu lv lw b">Empty</code>，我会把它装满。</p><p id="c940" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，Python为对象赋予了真值，即使没有构建条件表达式。在本帖中，我们将探索真值背后的定义，如何操作它们并避免讨厌的错误，以及如何调整自定义类的真值。</p><h1 id="5c33" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">真实与虚假</h1><p id="0dd9" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Python对象根据它们的值或状态持有一个<code class="fe lt lu lv lw b">True</code>或<code class="fe lt lu lv lw b">False</code>表示。默认情况下，所有值都是<code class="fe lt lu lv lw b">True</code>减去一个特定的集合。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="beaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意我们是如何将任何类型直接转换成<code class="fe lt lu lv lw b">bool</code>的。如果结果是<code class="fe lt lu lv lw b">True</code>，否则我们就说这个值是<em class="ls">真、</em>或<em class="ls">假。访问值的真实性允许我们在条件或布尔运算中直接使用它们，而无需添加任何比较。</em></p><p id="6926" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这个逻辑是如何用Python编程的呢？如果你从来没有这样做过，我建议你读一些标准类型的<code class="fe lt lu lv lw b">help</code>，比如<code class="fe lt lu lv lw b">str</code>或者<code class="fe lt lu lv lw b">int</code>。如果我们分析这两个，我们会发现一些有趣的定义:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="df92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，如果<code class="fe lt lu lv lw b">int</code>值不等于0，则它们是<code class="fe lt lu lv lw b">True</code>，如果所有<code class="fe lt lu lv lw b">str</code>的长度不等于0，则它们都是<code class="fe lt lu lv lw b">True</code>，即使没有实现<code class="fe lt lu lv lw b">__bool__</code>。如果我们看一下<code class="fe lt lu lv lw b">object</code>的Python <a class="ae kv" href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noopener ugc nofollow" target="_blank">文档</a>，我们会看到对这种行为的解释:</p><blockquote class="mw mx my"><p id="8dbc" class="kw kx ls ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">object.<strong class="ky ir">__bool__</strong></code> ( <em class="iq">自我</em>)</p><p id="f94b" class="kw kx ls ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">被调用来实现真值测试和内置操作<code class="fe lt lu lv lw b">bool()</code>；应返回<code class="fe lt lu lv lw b">False</code>或<code class="fe lt lu lv lw b">True</code>。当这个方法没有被定义时，调用<code class="fe lt lu lv lw b"><a class="ae kv" href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="noopener ugc nofollow" target="_blank">__len__()</a></code>，如果它被定义，并且如果它的结果是非零的，对象被认为是真的。如果一个类既没有定义<code class="fe lt lu lv lw b"><a class="ae kv" href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="noopener ugc nofollow" target="_blank">__len__()</a></code>也没有定义<code class="fe lt lu lv lw b"><a class="ae kv" href="https://docs.python.org/3/reference/datamodel.html#object.__bool__" rel="noopener ugc nofollow" target="_blank">__bool__()</a></code>，那么它的所有实例都被认为是真的。</p></blockquote><p id="c42e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个定义，我们可以快速扩展任何序列或迭代器对象的答案，甚至将其应用于我们的自定义类。</p><h1 id="3c4a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">如果你是认真的，请不要勾选</h1><p id="91ce" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们在上面的例子中忽略的一个独特的对象是<code class="fe lt lu lv lw b">None</code>。通过添加类型提示，在阅读代码和对缺失值进行干净的异常管理时，使用<code class="fe lt lu lv lw b">Optional</code> s是一个巨大的帮助。</p><p id="9da4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果我们在检查这种特定情况时没有注意，我们可能会隐藏一些难以调试的问题。拥有一个缺失值<code class="fe lt lu lv lw b">None</code>和拥有一个真值为<code class="fe lt lu lv lw b">False</code>的值是不同的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe lt lu lv lw b">None</code>的<code class="fe lt lu lv lw b">bool</code>值为<code class="fe lt lu lv lw b">False</code>，第一个场景将捕捉到缺失的<code class="fe lt lu lv lw b">count</code>和<code class="fe lt lu lv lw b">count == 0</code>。而第二个将只为<code class="fe lt lu lv lw b">None</code>显式执行。</p><p id="0914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有好坏之分，但是你必须考虑什么对你的商业逻辑有意义。</p><h1 id="51ce" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">玩弄真相</h1><p id="1ecd" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">了解Python如何将<code class="fe lt lu lv lw b">True</code>或<code class="fe lt lu lv lw b">False</code>赋给它的类型允许我们在我们的类中复制行为，这可以方便地使代码更简单和更有表现力。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="84b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了一个相对简单的定义，我们可以重用一个整数的真值，我们可以顺利地识别空咖啡杯。</p><h1 id="6a20" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">布尔运算符</h1><p id="c40c" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">此外，理解值的真实度 <strong class="ky ir"> <em class="ls"> </em> </strong>使用布尔运算符打开了一扇令人兴奋的门。它们不仅可以应用于<code class="fe lt lu lv lw b">if</code>和<code class="fe lt lu lv lw b">while</code>条件，还可以基于现有对象的真实性定义新的变量。我们将根据这份<a class="ae kv" href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" rel="noopener ugc nofollow" target="_blank">文档</a>来完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="0dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们如何应用<code class="fe lt lu lv lw b">or</code>和<code class="fe lt lu lv lw b">and</code>操作符来获得有趣的结果，特别是在表达式求值方面。根据第一个论点的真实性，第二个论点可能会也可能不会被评估。这被称为<strong class="ky ir">短路</strong>，它允许我们仅在需要或需要满足特定条件时延迟特定的执行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1928" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们正在开发一个银行应用程序。查询账户资金，需要告知密码；否则，可能会发生异常。</p><p id="3cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过短路条件，只有在正确告知密码的情况下，<code class="fe lt lu lv lw b">get_funds()</code>才会被(安全地)执行。否则，函数不会被求值，因为结果布尔表达式已经是<code class="fe lt lu lv lw b">False</code>。</p><h1 id="217b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">结论</h1><p id="a47a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">Python的灵活性有时是有代价的。例如，不知道特定行为的开发人员可能会用小的实现细节来掩盖实际的程序逻辑。解药？好奇心和测试。</p><p id="1d08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们看到了Python如何将对象转换成<code class="fe lt lu lv lw b">bool</code>，这在条件和布尔运算中是一个强大的工具。我们还将这些定义应用于一个定制类，同时学习关注逻辑的细节。</p><p id="2eee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，这是Python 的<a class="ae kv" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">禅仍然正确的又一个例子:“显式比隐式好”。认真检查<code class="fe lt lu lv lw b">None</code>！</a></p></div></div>    
</body>
</html>