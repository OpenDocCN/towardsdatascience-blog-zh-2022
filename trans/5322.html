<html>
<head>
<title>Perfect, Infinite-Precision, Game Physics in Python (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中完美的、无限精确的游戏物理学(第 3 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/perfect-infinite-precision-game-physics-in-python-part-3-9ea9043e3969#2022-11-29">https://towardsdatascience.com/perfect-infinite-precision-game-physics-in-python-part-3-9ea9043e3969#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8b0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用 Python SymPy 将数学和物理转化为编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae4366427db50fc31720671c12c0a3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khDpWG09i47dhqYIOE3s-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个平衡数学方程的 Python 来源:<a class="ae kv" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">https://openai.com/dall-e-2/</a></p></figure><blockquote class="kw kx ky"><p id="f451" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是向您展示如何用 Python 编写一个完美的物理引擎的四篇文章中的第三篇。这是我将所有物理、数学、甚至哲学转化为编程的宏伟目标中的一小步。<a class="ae kv" href="https://github.com/CarlKCarlK/perfect-physics" rel="noopener ugc nofollow" target="_blank">所有代码都可以在 GitHub </a>上获得。</p></blockquote><p id="9942" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这篇文章是关于让计算机为我们做数学。不仅仅是数值计算，还有代数和微积分相关的操作。这很有用，因为:</p><ul class=""><li id="d1f8" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">我——也许还有你——不记得我高中和大学的所有数学知识了。</li><li id="2a44" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">在学校，老师只给我们能解决的问题。我想解决我解决不了的问题。</li></ul></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="6176" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">回想一下，在本系列的<a class="ae kv" rel="noopener" target="_blank" href="/perfect-infinite-precision-game-physics-in-python-part-1-698211c08d95">第 1 部分</a>和<a class="ae kv" href="https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-2-360cc445a197" rel="noopener">第 2 部分</a>中，我们开发了顶级的完美物理引擎。它使用像<code class="fe mu mv mw mx b">175–9*sqrt(3)/2</code>这样的表达式来精确地表示时间、位置和速度，也就是说，没有近似值。我们将该引擎应用于牛顿的摇篮、一个网球和篮球下落以及一次台球休息。这些模拟产生了令我惊讶的关于物理甚至哲学的发现。</p><p id="a5e2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在第三部分中，我们将使用计算机从基本物理定律中推导出所需的表达式。我们将分五步完成这项工作:</p><ol class=""><li id="ae8d" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv my mf mg mh bi translated">模拟两个运动的圆圈。使用 SymPy 精确地找到两个移动的圆何时“刚好接触”。理解为什么 SymPy 返回多个答案。</li><li id="af77" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv my mf mg mh bi translated">模拟一个圆和一面墙。找到他们接触的时间。加一个关于角度的“秘密”第六方程(但不要用角度)。</li><li id="aa0d" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv my mf mg mh bi translated">尝试用动量和能量守恒来模拟圈与圈之间的碰撞。你不能。加一个关于角度的“秘密”第四方程(但不要用角度)。</li><li id="77cd" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv my mf mg mh bi translated">假设墙的质量无限大。从墙上反弹回来的圆违反了动量守恒。用限制来解决这个问题。</li><li id="0ee3" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv my mf mg mh bi translated">两个物体可以相互接触，也可以相互远离。用极限来找这些。将它们从碰撞对象列表中移除。</li></ol><p id="2782" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们从两个圆圈开始。</p><h1 id="0d22" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">第一步:模拟两个移动的圆圈。使用 SymPy 精确地找到两个移动的圆何时“刚好接触”。理解为什么 SymPy 返回多个答案。</h1><p id="5920" class="pw-post-body-paragraph kz la iq lc b ld nr jr lf lg ns ju li lw nt ll lm lx nu lp lq ly nv lt lu lv ij bi translated">我们将把世界建模为在无限二维平面上运动的圆圈。圆圈匀速运动，直到它们碰撞。圆圈可能会相互碰撞或撞到墙上。墙是(无限长的)线。</p><p id="1c10" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要回答的第一个问题是，两个移动的圆何时(如果有的话)会开始接触。为了回答这个问题，我们将设计一组方程式。然后我们会让计算机解方程并给我们答案。</p><p id="2dbe" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了设计我们的第一个方程，考虑两个圆，<em class="lb"> a </em>和<em class="lb"> b </em>。每个都有一个位置(<em class="lb"> x </em>，<em class="lb"> y </em>)，一个速度(<em class="lb"> vx </em>，<em class="lb"> vy </em>)，一个半径，<em class="lb"> r </em>。你能预测一个圆在任意时间<em class="lb"> t 的未来位置(<em class="lb"> x '，y' </em>)吗？</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/990dd93f49aa84f4af1fa1545ac154d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*roZBQvIlAmtSpHgi.png"/></div></figure><p id="a234" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的第一个等式表示圆<em class="lb"> a </em>在时间<em class="lb"> t </em>的<em class="lb"> x </em>位置是其当前<em class="lb"> x </em>位置加上其<em class="lb"> vx </em>速度乘以时间<em class="lb">t</em>的数学表达式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/5e11c9bf2c9ea7897da65901ccc59968.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*YVQ4XDaov9AqcdZ_K8OmHQ.png"/></div></figure><p id="ddb1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">等式 2 将告诉我们圆圈<em class="lb"> a </em>在未来的<em class="lb"> y </em>位置。等式 3 和 4 会告诉我们<em class="lb"> b </em>的<em class="lb"> x </em>和<em class="lb"> y </em>的未来位置。</p><p id="f70e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">作为将数学转化为编程的第一步，我们将用 Python 的<a class="ae kv" href="https://www.sympy.org/en/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> SymPy </strong>包</a>写出这四个方程。SymPy 是一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Computer_algebra_system" rel="noopener ugc nofollow" target="_blank">计算机代数系统</a>，类似于 Mathematica 和 Maple。然而，与这些系统不同，SymPy 是免费的，可以在 Python 中获得。</p><blockquote class="kw kx ky"><p id="adb7" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">旁白#1:不要混淆 S <strong class="lc ir"> y </strong> mPy(一个用于符号数学的 Python 包)和 S <strong class="lc ir"> i </strong> mPy(一个用于模拟的 Python 包)。</p><p id="f657" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">旁白#2:计算机代数系统将表达式表示为嵌套的计算机对象。这种“符号”表示使一些事情对计算机来说变得容易——例如，处理分数或对其他表达式求导。即使有了符号表示，一些任务对计算机来说仍然是困难的——例如，求积分或解非线性方程组。这与人们容易和困难的事情相一致。我喜欢使用计算机代数系统，因为在大多数任务中，无论简单还是困难，它们都比我强。</p></blockquote><p id="84ae" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">以下是我们在 Python &amp; SymPy 中的四个方程:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="9979" class="oc na iq mx b be od oe l of og">from sympy import symbols, Eq<br/><br/># define symbols<br/>t = symbols("t")<br/>a_x, a_y, a_vx, a_vy, a_r, aprime_x, aprime_y = symbols("a_x, a_y, a_vx, a_vy, a_r, a'_x, a'_y")<br/>b_x, b_y, b_vx, b_vy, b_r, bprime_x, bprime_y = symbols("b_x, b_y, b_vx, b_vy, b_r, b'_x, b'_y")<br/><br/># define equations<br/>eq1 = Eq(aprime_x, a_x + a_vx * t)<br/>eq2 = Eq(aprime_y, a_y + a_vy * t)<br/>eq3 = Eq(bprime_x, b_x + b_vx * t)<br/>eq4 = Eq(bprime_y, b_y + b_vy * t)p</span></pre><p id="a0e7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们仍然需要设计两个圆“刚好接触”的概念。我们用第五个方程来计算。它说，当两个圆的圆心距离等于半径之和时，这两个圆刚好接触。(我们通过对两边求平方来避免使用<code class="fe mu mv mw mx b">sqrt</code>函数。)在数学符号中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/3ec57cb08af7410a4099f11ef91e2de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*YV0x5SLecXaevApCd7SNLA.png"/></div></figure><p id="fb5c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在 Python 和 SymPy 中:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="a3fd" class="oc na iq mx b be od oe l of og">eq5 = Eq((aprime_x - bprime_x) ** 2 + (aprime_y - bprime_y) ** 2,<br/>         (a_r + b_r)**2)</span></pre><p id="e4c8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果我们给前四个方程关于两个圆和一个时间的信息，它们会告诉我们当时圆的位置。方程五可以告诉我们，两个圆在那个时候刚好接触。</p><p id="f5cc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">换句话说，给定一个时间，这些方程可以回答“这两个圆在时间<em class="lb"> t </em>刚好接触吗？”但这不是我们想要的。我们想把里面翻出来，回答这个问题“这两个圆什么时候会接触？”</p><p id="0857" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">要回答感兴趣的问题，数学告诉我们只要“求解”方程。可悲的是，套用芭比的话，“数学(求解包含正方形的方程)很难。”幸运的是，数学对 SymPy 来说并不难:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="7a3d" class="oc na iq mx b be od oe l of og">from sympy import nonlinsolve<br/>from perfectphysics import savecc_all_solutions = nonlinsolve([eq1, eq2, eq3, eq4, eq5], t, aprime_x, aprime_y, bprime_x, bprime_y)<br/>cc_time_solutions = [t for t, aprime_x, ap_y, bp_x, bp_y in cc_all_solutions]<br/>save(cc_time_solutions, "cc_time_solutions.sympy")<br/>cc_time_solutions[0]</span></pre><p id="3171" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在大约 30 秒的时间里，SymPy 找到了两个一般性的，象征性的解决方案。这里只是第一个解决方案的一点，<code class="fe mu mv mw mx b">cc_time_solutions[0]</code>用数学符号表示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/28927f9bd7ae258f88def68bc3219144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t68htnRWEFwPrXRNGL1iBA.png"/></div></figure><p id="bea8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在我们看来这很复杂。然而，这对计算机来说并不复杂。</p><p id="c779" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为什么有两种解决方案？评估它们可以帮助我们理解。考虑这种情况:两个半径为 1 的圆，蓝球以速度 2 移动:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="c523" class="oc na iq mx b be od oe l of og">from perfect_physics import Circle, plot<br/>a = Circle(x=0,y=0,r=1,vx=2,vy=0)<br/>b = Circle(x=4,y=0,r=1,vx=0,vy=0)<br/>plot([a, b], colors=["tab:blue","tab:red"], xlim=(-2,8), ylim=(-2,2), figsize=(4,2), font_scale=1)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/352b35d166ca974cde44cf526d45a6ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*tAMX-CatFtxDqbW9.png"/></div></figure><p id="da4b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们使用 SymPy <code class="fe mu mv mw mx b">.subs</code>(替换)方法找到圆 a 和<code class="fe mu mv mw mx b">b</code>刚好接触的两个时间。我们也在这些时候画出圆圈。</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="7806" class="oc na iq mx b be od oe l of og">from perfect_physics import load<br/>cc_time_solutions = load("cc_time_solutions.sympy")<br/>times = [time_solution.subs([("a_x", a.x), ("a_y", a.y), ("a_r", a.r), ("a_vx", a.vx), ("a_vy", a.vy),<br/>                             ("b_x", b.x), ("b_y", b.y), ("b_r", b.r), ("b_vx", b.vx), ("b_vy", b.vy)])<br/>         for time_solution in cc_time_solutions]<br/>print(times)<br/>for time in times:<br/>    plot([a.tick_clone(time), b.tick_clone(time)], clock=time,<br/>    colors=["tab:blue","tab:red"], xlim=(-2,8), ylim=(-2,2), figsize=(4,2), font_scale=1)</span></pre><p id="a891" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">Python 打印<code class="fe mu mv mw mx b">[3, 1]</code>并绘图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/d28296922c01d5e2455caff7a7a0317b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8E1LQGwBuo_VU6VoyOuktg.png"/></div></div></figure><p id="28ad" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">换句话说，在时间 3(忽略碰撞)，蓝色圆圈将刚好接触红色圆圈。同样，在时间 1。如果我们想知道下一次碰撞之前的时间，我们只需要取较小的时间，对吗？</p><p id="40aa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">可悲的是，更小的时间可能也不对。考虑这种情况，其中圆圈彼此远离。他们什么时候会触碰？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/25cf8e91c960d8ce950526a4a5aaa57c.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/0*gmAUhv2VNoOc_dKa.png"/></div></figure><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="0934" class="oc na iq mx b be od oe l of og">a = Circle(x=2,y=2,r=1,vx=1,vy=1)<br/>b = Circle(x=0,y=0,r=1,vx=0,vy=0)<br/>plot([a, b], colors=["tab:blue","tab:red"], xlim=(-2,4), ylim=(-2,4), figsize=(3,3), font_scale=1)<br/>times = [time_solution.subs([("a_x", a.x), ("a_y", a.y), ("a_r", a.r), ("a_vx", a.vx), ("a_vy", a.vy),<br/>                             ("b_x", b.x), ("b_y", b.y), ("b_r", b.r), ("b_vx", b.vx), ("b_vy", b.vy)])<br/>         for time_solution in cc_time_solutions]<br/>print(times)</span></pre><p id="7a24" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">Python 回答<code class="fe mu mv mw mx b">[-2 + sqrt(2), -2 — sqrt(2)]</code>。(注意，它的回答是无限精确的，而不是像<code class="fe mu mv mw mx b">[-0.59, -3.41]</code>这样的近似值)。这些时间是负的，意味着圆圈将只接触过去。我们不关心过去的碰撞，所以我们忽略负时间。</p><p id="42f8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">总结一下:答案会给我们两次，我们保留最小的，非负的时间，对吗？没有。我们还必须提防另外两种复杂情况。第一，当圆圈静止或以相同速度一起运动时，时间将是<code class="fe mu mv mw mx b">[nan, nan]</code>，即浮点“不是一个数”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/1962589061569d1157c99c649a8da0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*vNqdl1Lzzp9nk9k61hVbtw.png"/></div></figure><p id="efc3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">第二，当圆圈移动时，它们的路径永远不会相交，时间将类似于<code class="fe mu mv mw mx b">[2 + sqrt(2)*I, 2 — sqrt(2)*I]</code>，包含<a class="ae kv" href="https://en.wikipedia.org/wiki/Imaginary_number" rel="noopener ugc nofollow" target="_blank">虚数</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/7db6c80daac1bc044395d5538883d1b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/0*LFi4lKbgDpbK9SMb.png"/></div></figure><p id="3bbd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">最后，我们的程序是用 SymPy 得到两次，然后:</p><ul class=""><li id="4c5a" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">过滤掉包含虚数的答案</li><li id="b016" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">筛选出<code class="fe mu mv mw mx b">nan</code>个答案</li><li id="8c50" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">过滤掉否定的答案</li><li id="ea58" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">保留最小的剩余答案(如果有)</li></ul><p id="6f55" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个结果会是我们期望的下一次碰撞的无限精确时间吗？差不多了。当它说它们将在时间零点接触时，这两个圆可能会彼此远离。这种情况不算碰撞。我们将在步骤 5 中研究这个问题。</p><p id="da25" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">注意，如果我们可以处理两个圆，我们可以处理任意数量的圆。我们只需要查看所有的圆对，并返回最小的时间(如果有的话)。</p><p id="cf61" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我认为我们在这一步所做的非常酷。我们只需要设计出五个简单的方程式，关于圆圈在时间中前进并检测距离。Python SymPy 包随后为我们做了困难的计算。它创建了一个函数，精确地告诉我们<em class="lb">何时(如果有的话)圆会接触。</em></p><p id="b15d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在第三步中，我们将看到触摸如何改变每个圆圈的速度。然而，接下来，让我们与 SymPy 合作，找出圆何时会碰壁。</p><h1 id="8618" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">第二步:建立一个圆形和一面墙的模型。找到他们接触的时间。加一个关于角度的“秘密”第六方程(但不要用角度)。</h1><p id="4a25" class="pw-post-body-paragraph kz la iq lc b ld nr jr lf lg ns ju li lw nt ll lm lx nu lp lq ly nv lt lu lv ij bi translated">假设我们有圆<em class="lb"> a </em>和墙<em class="lb"> w </em>。和之前一样，圆有位置(<em class="lb"> x </em>，<em class="lb"> y </em>)，速度(<em class="lb"> vx </em>，<em class="lb"> vy </em>)，半径，<em class="lb"> r </em>。这堵墙是一条(无限长的)线。我们沿着墙指定任意两个不同的点，<em class="lb"> (x0，y0) </em>和<em class="lb"> (x1，y1) </em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/8ced72d52a4a847638f105a1ca4cfad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/0*bysV6ejy6kHvNxlp.png"/></div></div></figure><p id="7d20" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了找到圆和墙刚好接触的时间，我们再次模拟圆在时间<em class="lb"> t </em>的位置(<em class="lb">x’，y’</em>)。</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="f6f9" class="oc na iq mx b be od oe l of og">from sympy import symbols, Eq<br/>t = symbols("t")<br/>a_x, a_y, a_vx, a_vy, a_r, aprime_x, aprime_y = symbols("a_x, a_y, a_vx, a_vy, a_r, a'_x, a'_y")<br/>eq1 = Eq(aprime_x, a_x + a_vx * t)<br/>eq2 = Eq(aprime_y, a_y + a_vy * t)</span></pre><p id="fa9e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来，我们在墙上的圆和墙接触的地方建模。称此点为<em class="lb"> (x2，y2)。</em>在壁定义点<em class="lb"> (x0，y0) </em>和<em class="lb"> (x1，y1) </em>之间会有一个比例<em class="lb"> p </em>。例如，如果<em class="lb"> p </em>是 1/2，则<em class="lb"> (x2，y2) </em>是两个壁定义点的中点。此外，通过让<em class="lb"> p </em>的范围小于 0 且大于 1，我们可以将<em class="lb"> (x2，y2) </em>移动到沿墙的任何位置:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="6c5d" class="oc na iq mx b be od oe l of og">p = symbols("p")<br/>x0, y0, x1, y1, x2, y2 = symbols("x_0, y_0, x_1, y_1, x_2, y_2")<br/>eq3 = Eq(x2, x0 + (x1-x0) * p)<br/>eq4 = Eq(y2, y0 + (y1-y0) * p)</span></pre><p id="1484" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当圆的中心点<em class="lb">(x’，y’)</em>与其接触的墙壁上的位置<em class="lb"> (x2，y2) </em>之间的距离等于圆的半径时，圆将接触墙壁。换句话说:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="6127" class="oc na iq mx b be od oe l of og">eq5 = Eq((x2-aprime_x)**2 + (y2-aprime_y)**2, a_r**2)</span></pre><p id="34af" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">然而，当我们要求 SymPy 求解并应用这五个方程时，它给出了这样奇怪的解:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/38af1f708a899077ef9107dbada22986.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*rDt-dpIa3Gczz20J.png"/></div></figure><p id="8998" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">SymPy 认为这解决了我们的方程，因为圆的中心<em class="lb">离墙上的某个点</em>有一个半径(两个红点)。然而，这不是我们想要的解决方案，因为圆与墙重叠。</p><p id="ea0b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">第六个方程可以解决这个问题。要求墙壁和白线之间的角度α为 90 度(见上图)。我们可以用<em class="lb">斜率</em>来说这个，不需要明确的角度或者三角函数。墙的坡度是<code class="fe mu mv mw mx b">(y1-y0)/(x1-x0)</code>。图中白线的斜率为<code class="fe mu mv mw mx b">(aprime_y-y2)/(aprime_x-x2)</code>。当一条直线的斜率是另一条直线的负倒数时，两条直线相交于 90 度。在 SymPy 中，我们说:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="1564" class="oc na iq mx b be od oe l of og">slope_0 = (y1-y0)/(x1-x0)<br/>slope_1 = (aprime_y-y2)/(aprime_x-x2)<br/>eq6 = Eq(slope_0, -1/slope_1)</span></pre><p id="8a09" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们要求 SymPy 像这样为我们解决这个问题:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="aa76" class="oc na iq mx b be od oe l of og">from sympy import nonlinsolve<br/>from perfect_physics import save<br/>cw_all_solutions = nonlinsolve([eq1, eq2, eq3, eq4, eq5, eq6], t, p, aprime_x, aprime_y, x2, y2)<br/>cw_time_solutions = [t for t, p, aprime_x, aprime_y, x2, y2 in cw_all_solutions]<br/>save(cw_time_solutions, "cw_time_solutions.sympy")</span></pre><p id="bd0c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">工作 7 分钟后(比我强吧！)，它返回两个解。下面是用数学符号表示的第一个解(比上次更易读):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f971bfef39bcd9289e416ccd2d77d824.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*TglegudS4y7Vf_WRibPjJw.png"/></div></figure><p id="423d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当我们将这些解决方案应用于上述情况时，Python 返回时间跨度<code class="fe mu mv mw mx b">[2, 3]</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/0f4d9feeab76f5e583ab150a0ca5dc36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xDr5Qy0TaZK-oJ3z.png"/></div></figure><p id="e8d4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><em class="lb">先不说:解表达式看起来像是来自</em> <a class="ae kv" href="https://en.wikipedia.org/wiki/Quadratic_equation" rel="noopener ugc nofollow" target="_blank"> <em class="lb">二次方程</em> </a> <em class="lb">的东西。这表明一个优秀的应用数学家可以手动解决这个问题。对他们有好处。然而，我很乐意通过计算机解决这个问题。</em></p><p id="e1dc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们将应用与步骤 1 中相同的规则，过滤掉负面的、复杂的、<code class="fe mu mv mw mx b">nan</code>，并保留最小的时间(如果有的话)。当一个圆圈蹭到一堵墙时，我们可能会遇到一个新问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/d4c4329fe0d6f9ecf3359a5d8f21fe95.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/0*Y93APK7Hx384Xgd0.png"/></div></figure><p id="e7c5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个世界将会回归<code class="fe mu mv mw mx b">[nan, zoo]</code>。其中<code class="fe mu mv mw mx b">zoo</code>是复数无穷大的 SymPy 符号。我们会把它过滤掉，因为我们不关心掠射碰撞。</p><p id="e7e8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们将这个结果添加到步骤 1 的结果中。我们现在可以找到一个圆与一个圆或一面墙之间下一次“接触”的精确的、无限精确的时间。</p><p id="2cf9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来，让我们弄清楚圆圈-圆圈触摸是如何改变圆圈的速度和方向的。</p><h1 id="24ed" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">第三步:尝试用动量和能量守恒来模拟圈与圈之间的碰撞。你不能。加一个关于角度的“秘密”第四方程(但不要用角度)。</h1><p id="0770" class="pw-post-body-paragraph kz la iq lc b ld nr jr lf lg ns ju li lw nt ll lm lx nu lp lq ly nv lt lu lv ij bi translated">我第一次尝试模拟两个圆之间的碰撞时，我以为我只需要两条定律:动量守恒和能量守恒。我错了。我们来看看为什么。</p><p id="9ee1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">能量守恒说，碰撞前后的能量应该是一样的。对于我们的世界，唯一的能量类型是动能，所以<em class="lb"> E= mv /2 </em>，其中<em class="lb"> m </em>是质量，而<em class="lb"> v </em>是速度。我们假设碰撞是弹性的，也就是说，没有能量转化为热量、声音等。在数学符号中，这变成:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/6a2eef13fb3b91841184108e4c508c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*86pf1dJYJmfbQ7qo_4UkEw.png"/></div></figure><p id="d3fd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">其中圆<em class="lb"> a </em>的质量为<em class="lb"> aₘ </em>，碰撞前的速度为<em class="lb">(aᵥᵧaᵥₓ)</em>，碰撞后的速度为<em class="lb">(âᵥᵧâᵥₓ)</em>。圆圈<em class="lb"> b </em>也是如此。</p><p id="da7b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在 SymPy 中，我们写道:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="ad66" class="oc na iq mx b be od oe l of og">from sympy import symbols, Eq<br/>a_x, a_y, a_vx, a_vy, a_r, a_m, ahat_vx, ahat_vy = symbols("a_x, a_y, a_vx, a_vy, a_r, a_m, ahat_vx, ahat_vy")<br/>b_x, b_y, b_vx, b_vy, b_r, b_m, bhat_vx, bhat_vy = symbols("b_x, b_y, b_vx, b_vy, b_r, b_m, bhat_vx, bhat_vy")<br/>energy_before = a_m * (a_vx**2 + a_vy**2) / 2 + b_m * (b_vx**2 + b_vy**2) / 2<br/>energy_after = a_m * (ahat_vx**2 + ahat_vy**2) / 2 + b_m * (bhat_vx**2 + bhat_vy**2) / 2<br/>eq1 = Eq(energy_before, energy_after)</span></pre><p id="977e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">动量守恒给了我们另外两个方程，一个是关于<em class="lb"> x </em>维度的，一个是关于<em class="lb"> y </em>维度的。动量是质量乘以速度，所以:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="8a2b" class="oc na iq mx b be od oe l of og">eq2 = Eq(a_m * a_vx + b_m * b_vx, a_m * ahat_vx + b_m * bhat_vx)<br/>eq3 = Eq(a_m * a_vy + b_m * b_vy, a_m * ahat_vy + b_m * bhat_vy)</span></pre><p id="b9a9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在有三个方程，希望 SymPy 给我们四个未知数的解，即碰撞后速度:<em class="lb"> âᵥₓ，âᵥᵧ，b </em> ̂ <em class="lb"> ᵥₓ，b </em> ̂ <em class="lb"> ᵥᵧ.</em>那不行。我们需要和未知数一样多的方程。</p><p id="7398" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我第一次注意到这个丢失的等式时，它难倒了我。我想不出任何其他适用的物理定律。我终于想通了第四个缺失的“定律”:</p><blockquote class="oq"><p id="f97c" class="or os iq bd ot ou ov ow ox oy oz lv dk translated"><em class="pa">当圆碰撞时，它们的速度与碰撞方向成 90°不变。</em></p></blockquote><p id="dc02" class="pw-post-body-paragraph kz la iq lc b ld pb jr lf lg pc ju li lw pd ll lm lx pe lp lq ly pf lt lu lv ij bi translated">考虑这种情况:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="7199" class="oc na iq mx b be od oe l of og">from perfect_physics import Circle, plot<br/>a = Circle(x=0, y=0, r=1, vx=1, vy=2, m=1)<br/>b = Circle(x=2, y=0, r=1, vx=0, vy=0, m=1)<br/>plot([a, b], colors=["tab:red", "tab:blue"], xlim=(-2, 4), ylim=(-2, 2), figsize=(4, 2), font_scale=1)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/718a9bc35b128215b95ab5feba63dd74.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*0UNxs0tG5hTWWBWv0re6yg.png"/></div></figure><p id="665b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">“撞击方向”是从一个中心到另一个中心的方向，这里是水平方向。圆 a 与水平面成 90°的速度为<em class="lb"> aᵥᵧ </em>为 2。所以，我们期望这个方向的后碰撞速度，<em class="lb"> âᵥᵧ </em>也是 2。</p><p id="0710" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但是如果圆心不水平也不垂直呢？考虑这种情况:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="1a38" class="oc na iq mx b be od oe l of og">from sympy import sqrt<br/>from perfect_physics import Circle, plot<br/>a = Circle(x=0, y=0, r=1, vx=1, vy=0, m=1)<br/>b = Circle(x=sqrt(2), y=sqrt(2), r=1, vx=0, vy=0, m=1)<br/>plot([a, b], colors=["tab:red", "tab:blue"], xlim=(-2, 4), ylim=(-2, 3), figsize=(4, 2), font_scale=1)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/7be856d84b488b2203690ac0d8af392f.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/0*8EGfEv4cs86YoZNm.png"/></div></figure><p id="eada" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们可以用正弦和余弦函数从撞击方向求出速度 90。然而，用单位向量来做可以让我们避免引入这些函数。我们想要一个向量<em class="lb"> &lt; ux，uv &gt; </em>，它有一个单位长，并且从圆心之间的直线延伸 90 度。我们可以通过除以<em class="lb"> d </em>得到长度为 1，即中心之间的距离。我们可以用第二步中使用的-1/斜率得到我们想要的方向。具体来说，这表示撞击方向的速度 90 不变:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="76bd" class="oc na iq mx b be od oe l of og">from sympy import sqrt<br/>d = sqrt((b_x-a_x)**2 + (b_y-a_y)**2)<br/>ux = -(b_y-a_y)/d<br/>uy = (b_x-a_x)/d<br/>eq4 = Eq((b_vx - a_vx) * ux + (b_vy - a_vy) * uy, (bhat_vx-ahat_vx) * ux + (bhat_vy-ahat_vy) * uy)</span></pre><p id="c2a3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们已经很好地解决了我们的方程:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="d68f" class="oc na iq mx b be od oe l of og">from sympy import nonlinsolve<br/>from perfect_physics import save<br/>cc_velocity_solutions = nonlinsolve([eq1, eq2, eq3, eq4], ahat_vx, ahat_vy, bhat_vx, bhat_vy)<br/>cc_velocity_solutions = list(cc_velocity_solutions)<br/>save(cc_velocity_solutions[1], "cc_velocity_solution.sympy")</span></pre><p id="9a80" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">2 或 3 分钟后，它返回两个解决方案。令人惊讶的是，第一个解说后速度等于前速度。换句话说，这是当两个圈互相错过时的解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/ceae26b9dda4b3bf6d8c84f92dc85914.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*PxkACXzwWTnLt4YdKmGwsw.png"/></div></figure><p id="02cf" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">第二个解，我们关心的解，是长的。这里就不展示了。</p><p id="1768" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们用上面的两个例子来解决这个问题。在第一个例子中，之前的速度是<code class="fe mu mv mw mx b">a.vx=1, a.vy=2, b.vx=0, b.vy=0</code>。他们成为<code class="fe mu mv mw mx b">a.vx=0, a.vy=2, b.vx=1, b.vy=0</code>之后。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/4a494a4e98847ae6428449724562ae9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*ISkLA28pyRTX6Ebsys11jQ.png"/></div></figure><p id="4154" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在第二个例子中，之前的速度是<code class="fe mu mv mw mx b">a.vx=1, a.vy=0, b.vx=0, b.vy=0</code>。他们成为<code class="fe mu mv mw mx b">a.vx=1/2, a.vy=-1/2, b.vx=1/2, b.vy=1/2</code>后。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/65873186cba67d59050387cc5a93e9a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/0*6jW8LvCBss8xAEGr.png"/></div></figure><p id="23b4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">酷！所以，我们现在可以预测圆是如何相互弹开的。我们以后会看到，这个解适用于不同质量和不同半径的圆。</p><p id="227e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来，我们试着将这些守恒定律应用到从墙上反弹回来的圆上。令人惊讶的是，反弹似乎违反了“动量守恒”。</p><h1 id="7c87" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">第四步:假设墙的质量无限大。从墙上反弹回来的圆违反了动量守恒。用限制来解决这个问题。</h1><p id="acf3" class="pw-post-body-paragraph kz la iq lc b ld nr jr lf lg ns ju li lw nt ll lm lx nu lp lq ly nv lt lu lv ij bi translated">对于一个从墙上弹回的球，我们可以作弊。你可能还记得学校里的答案，那就是“入射角等于反射角”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/ac7ea629fe9050de59bf329e57efea7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*jnezsMuPXFC88czT.png"/></div></figure><p id="60f9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">但是这怎么可能是对的呢？反弹前圆的<em class="lb">y</em>-动量(即质量乘以<em class="lb">y</em>-速度)为-1。反弹后是 1。这违反了动量守恒。包括墙的动量没有帮助，因为它的质量是无限的，它的速度是 0，给了我们一个未定义的动量。</p><p id="c1ae" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">也许我们可以把墙建模成大圆，然后使用第三步的解决方案。这里我们给大圆半径 20，质量 1000。</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="898f" class="oc na iq mx b be od oe l of og">a = Circle(x=0, y=1, r=1, vx=1, vy=-1, m=1)<br/>b = Circle(x=0, y=-20, r=20, vx=0, vy=0, m=1000)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/beedee27dc1e0944a7fc844ba27cc5a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*H7wjAuC4B-sYtta4.png"/></div></figure><p id="d013" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这几乎行得通。后速度为<code class="fe mu mv mw mx b">a.vx=1, a.vy=999/1001, b.vx=0, b.vy=-2/1001</code>。如果我们把无穷大作为大圆的质量和/或半径。可悲的是，结果是未定义的值。</p><p id="bea6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">让我们看看能否从守恒定律入手，找到正确的答案。我们假设墙的质量有限，速度为 0。我们放入能量守恒(方程 1)，动量守恒(方程 2，方程 3)，圆周沿壁的相对速度不应该改变。</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="e935" class="oc na iq mx b be od oe l of og">from sympy import symbols, Eq, sqrt<br/>a_x, a_y, a_vx, a_vy, a_r, a_m, ahat_vx, ahat_vy = symbols("a_x, a_y, a_vx, a_vy, a_r, a_m, ahat_vx, ahat_vy")<br/>w_x0, w_y0, w_x1, w_y1, w_m, what_vx, what_vy = symbols("w_x0, w_y0, w_x1, w_y1, w_m, what_vx, what_vy")<br/>energy_before = a_m * (a_vx**2 + a_vy**2) / 2 + w_m * 0<br/>energy_after = a_m * (ahat_vx**2 + ahat_vy**2) / 2 + w_m * (what_vx**2 + what_vy**2) / 2<br/>eq1 = Eq(energy_before, energy_after)<br/>eq2 = Eq(a_m * a_vx + w_m * 0, a_m * ahat_vx + w_m * what_vx)<br/>eq3 = Eq(a_m * a_vy + w_m * 0, a_m * ahat_vy + w_m * what_vy)<br/>d = sqrt((w_x1-w_x0)**2 + (w_y1-w_y0)**2)<br/>ux = (w_x1-w_x0)/d<br/>uy = (w_y1-w_y0)/d<br/>eq4 = Eq(a_vx * ux + a_vy * uy, (ahat_vx-what_vx) * ux + (ahat_vy-what_vy) * uy)</span></pre><p id="ee33" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们再次应用<code class="fe mu mv mw mx b">nonlinsolve</code>,得到一个没有命中(忽略)的结果和一个命中的结果。我们的下一步是新的。当墙的质量趋于无穷大时，我们用 SymPy 来取极限。</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="7fb6" class="oc na iq mx b be od oe l of og">from sympy import nonlinsolve, limit, oo, Tuple<br/>from perfect_physics import save<br/>no_hit, cw_velocity_solution = nonlinsolve(<br/>    [eq1, eq2, eq3, eq4], ahat_vx, ahat_vy, what_vx, what_vy<br/>)<br/>a_vx_limit, a_vy_limit, w_vx_limit, w_vy_limit = [<br/>    limit(velocity, w_m, oo) for velocity in cw_velocity_solution<br/>]<br/>assert w_vx_limit == 0 and w_vy_limit == 0<br/>cw_velocity_limits = Tuple(a_vx_limit, a_vy_limit)<br/>save(cw_velocity_limits, "cw_velocity_limits.sympy")</span></pre><p id="dfee" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">结果是在<code class="fe mu mv mw mx b">vx</code>和<code class="fe mu mv mw mx b">vy</code>之后出现了圆圈和墙壁。正如所希望的，墙的速度为零。我们保存了圆的后速度公式。</p><p id="98ff" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当我们应用这个公式时，我们得到了“入射角等于反射角”的预期结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/641707edfb8a3ea0a6ae60d1a7ba1ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*kSJGenrDoAyYLjqR.png"/></div></figure><p id="2ea1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">和</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/cc103a4db11549646651759a2bf0d1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/0*DBU4z0FR2aBamf6G.png"/></div></figure><p id="386c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">那么，我们现在准备好解决物理作业问题，创作动画，制作游戏了吗？不完全是。我忽略了一个问题:两个物体接触并不总是意味着它们在碰撞。我们接下来会看到这一点。</p><h1 id="4fc1" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">第五步:两个物体可以相互接触，也可以相互远离。用极限来找这些。将它们从碰撞对象列表中移除。</h1><p id="a32f" class="pw-post-body-paragraph kz la iq lc b ld nr jr lf lg ns ju li lw nt ll lm lx nu lp lq ly nv lt lu lv ij bi translated">我们如何检测两个圆是否在相向运动？我原本以为我们可以只检查他们的相对速度。然而，在这两种情况下，红圈的相对速度是相同的。在第一种情况下，它们朝着彼此移动，而在第二种情况下，它们没有。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/71458cbff7939eb2e0bd52c3c8b29952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fsDWbVpmilPr8gSz.png"/></div></figure><p id="1ccb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">一个更好的方法是看这些中心是否越来越靠近。但是什么时候？他们开始时可能会靠得更近，但后来会彼此远离。我们可以问一下他们在零点是否越来越接近了吗？这是行不通的，因为在任何时刻，他们的距离都是不变的。</p><p id="79f3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">解决方法是再次使用限制。我们将测试在时间零点之后的瞬间，它们是否越来越近。</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="3aa2" class="oc na iq mx b be od oe l of og">from sympy import symbols, limit, sqrt<br/>from perfect_physics import save<br/>a_x, a_y, a_vx, a_vy, b_x, b_y, b_vx, b_vy, t = symbols("a_x, a_y, a_vx, a_vy, b_x, b_y, b_vx, b_vy, t")<br/>d0 = sqrt((a_x - b_x) ** 2 + (a_y - b_y) ** 2)<br/>d1 = sqrt((a_x + t * a_vx - (b_x + t * b_vx)) ** 2 + (a_y + t * a_vy - (b_y + t * b_vy)) ** 2)<br/>speed_toward = (d0 - d1) / t<br/>instant_speed = limit(speed_toward, t, 0)<br/>save(instant_speed, "instant_speed.sympy")</span></pre><p id="a17a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在上面的第一个示例中，应用结果公式返回 1。在第二个示例中，它返回-1。两种结果都在意料之中。</p><p id="a4ca" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了观察一个圆是否正在向一面墙移动，我们找到了<em class="lb"> (x₂，y₂) </em>，圆的中心可能会碰到墙上的点。这需要四个可以用 SymPy <code class="fe mu mv mw mx b">linsolve</code>求解的方程。然后，我们使用刚刚发现的<code class="fe mu mv mw mx b">instant_speed</code>公式，来查看圆朝着或远离该点的速度:</p><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="169b" class="oc na iq mx b be od oe l of og">from sympy import symbols, linsolve, Eq, simplify<br/>from perfect_physics import load, save<br/>a_x, a_y, a_vx, a_vy, t = symbols("a_x, a_y, a_vx, a_vy, t")<br/>x0, y0, x1, y1, x2, y2, p = symbols("x_0, y_0, x_1, y_1, x_2, y_2, p")<br/>eq1 = Eq(x2, a_x + a_vx * t)<br/>eq2 = Eq(y2, a_y + a_vy * t)<br/>eq3 = Eq(x2, x0 + (x1-x0) * p)<br/>eq4 = Eq(y2, y0 + (y1-y0) * p)<br/>x2_formula, y2_formula, _, _ = list(linsolve([eq1, eq2, eq3, eq4], (x2, y2, p, t)))[0]<br/>instant_speed = load("instant_speed.sympy")<br/>instant_speed_wall = simplify(instant_speed.subs({"b_x": x2_formula, "b_y": y2_formula, "b_vx": 0, "b_vy": 0}))<br/>save(instant_speed_wall, "instant_speed_wall.sympy")</span></pre><p id="d6a2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">例如，在这种情况下，我们发现圆圈以速度<code class="fe mu mv mw mx b">sqrt(5)</code>向墙移动。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/4f13510216e6667eaaf0de5c4d80fb95.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/0*Ke9Zw80vOKa5Gvue.png"/></div></figure><pre class="kg kh ki kj gt ny mx nz bn oa ob bi"><span id="c01c" class="oc na iq mx b be od oe l of og">from sympy import sqrt<br/>from perfect_physics import Circle, Wall, plot, load<br/>a = Circle(x=-sqrt(2) / 2, y=sqrt(2) / 2, r=1, vx=2, vy=1)<br/>w = Wall(x0=-1, y0=-1, x1=1, y1=1)<br/>plot(circle_list=[a], wall_list=[w], xlim=(-3, 3), ylim=(-2, 3), figsize=(4, 2), font_scale=1)<br/>instant_speed_wall = load("instant_speed_wall.sympy")<br/>instant_speed_wall.subs({"a_x": a.x, "a_y": a.y, "a_vx": a.vx, "a_vy": a.vy,<br/>                         "x_0": w.x0, "y_0": w.y0, "x_1": w.x1, "y_1": w.y1})</span></pre><p id="fe94" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在已经拥有了制造无限精确的物理引擎所需的一切。</p><h1 id="347f" class="mz na iq bd nb nc nd ne nf ng nh ni nj jw nk jx nl jz nm ka nn kc no kd np nq bi translated">总结第三部分</h1><p id="0c81" class="pw-post-body-paragraph kz la iq lc b ld nr jr lf lg ns ju li lw nt ll lm lx nu lp lq ly nv lt lu lv ij bi translated">在这一部分中，我们已经看到了如何使用 Python SymPy 包来查找为圆形和墙壁的 2d 世界创建完美的物理引擎所需的低级表达式。我们找到了两个物体接触的时间表达式。当它们接触时，我们找到了它们新速度的表达式。</p><p id="3478" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">通过查看细节，我们看到:</p><ul class=""><li id="c640" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">工程方程相对容易，但手动求解非线性方程组会很困难。令人高兴的是，计算机为我们做了这项艰苦的工作。</li><li id="3778" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">能量和动量守恒不足以预测碰撞后的速度。我们需要第四个方程，说明碰撞产生的速度 90 不变。</li><li id="dfa3" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">我们的方程经常给出奇怪的答案。我们看到了<code class="fe mu mv mw mx b">nan</code>，负时间跨度，复数，复数无穷的答案。我们解读这些奇怪的答案，然后处理它们。例如，负的时间跨度意味着碰撞发生在过去，因此可以忽略。</li><li id="7fc3" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">两次我们需要 90 度角。在这两种情况下，我们避免引入正弦、余弦等。通过使用斜率和单位向量。</li><li id="75c9" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">曾经我们需要一个无限小的时间，曾经我们需要一个无限大的质量。在这两种情况下，SymPy <code class="fe mu mv mw mx b">limit </code>函数让我们使用我们需要的极端时间和质量。</li></ul><p id="e089" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在已经创建了低级表达式，为高级层提供了基础。我们在<a class="ae kv" rel="noopener" target="_blank" href="/perfect-infinite-precision-game-physics-in-python-part-1-698211c08d95"> Part 1 </a>和<a class="ae kv" href="https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-2-360cc445a197" rel="noopener"> Part 2 </a>中看到了高层。当我们把这两层放在一起，我们得到了一个完美的物理引擎。然而，这将是痛苦而缓慢的。在第 4 部分的<a class="ae kv" rel="noopener" target="_blank" href="/perfect-infinite-precision-game-physics-in-python-part-4-9cdd609b3e6c#19f5-510d38fe7d32">中，我们将加速引擎一点(但还不够)并讨论其他限制。</a></p><p id="0ac3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果你有想让我运行的模拟的想法，请发给我。它们可能成为第五部分的基础。</p><p id="da29" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">你可以从<a class="ae kv" href="https://github.com/CarlKCarlK/perfect-physics" rel="noopener ugc nofollow" target="_blank">CarlKCarlK/perfect-physics(github.com)</a>下载这段代码。让我知道如果有兴趣，我会创建一个更好的安装程序。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="4985" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">跟随<a class="ae kv" href="https://medium.com/@carlmkadie" rel="noopener">卡尔·m·卡迪— Medium </a>获得下一部分的通知。所有部分都将免费阅读。最后，在 YouTube 上，我有旧的(近似的)<a class="ae kv" href="https://www.youtube.com/playlist?list=PLyBBVRUm1CyScgmzqpLGiKqwM-BxaiCnE" rel="noopener ugc nofollow" target="_blank">物理模拟</a>和一些<a class="ae kv" href="https://www.youtube.com/playlist?list=PLyBBVRUm1CyRr8tgjNdarj7cq55YFHhbf" rel="noopener ugc nofollow" target="_blank">试图幽默的自然视频</a>。</p></div></div>    
</body>
</html>