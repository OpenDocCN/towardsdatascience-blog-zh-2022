<html>
<head>
<title>I Have Been Using Pandas for 3 Years — Here are the 8 Functions I Use the Most</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我使用熊猫已经3年了——以下是我最常用的8个功能</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/i-have-been-using-pandas-for-3-years-here-are-the-8-functions-i-use-the-most-4e54f4db5656#2022-02-02">https://towardsdatascience.com/i-have-been-using-pandas-for-3-years-here-are-the-8-functions-i-use-the-most-4e54f4db5656#2022-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3710" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e88835c9759c55cd8c67566cbb4265b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8fRPLGLwNjsAdBputQp_7w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jay_zhang?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">张杰</a>在<a class="ae ky" href="https://unsplash.com/s/photos/computer-keyboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="ac5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pandas是数据科学生态系统中使用最频繁的库之一。它有许多功能，可以帮助我们完成几乎所有的数据分析、操作和处理任务。</p><p id="e56d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经使用熊猫大约3年了，我不记得我需要其他工具来解决任何问题。因此，我强烈推荐有抱负的数据科学家学习熊猫。</p><p id="1bb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然熊猫有很多功能，但其中有一小部分是你最需要的。在这篇文章中，我将分享我最常用的8个功能。</p><p id="af97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们需要一个数据集来处理。我准备了一个销售数据集样本，你可以从我的GitHub <a class="ae ky" href="https://github.com/SonerYldrm/datasets" rel="noopener ugc nofollow" target="_blank">页面</a>下载。我们将使用名为“sample-sales-data.csv”的文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><ul class=""><li id="2e78" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener" target="_blank" href="/r-versions-of-the-most-frequently-used-pandas-functions-f658cbcabaf7">这些函数的R版本</a></li><li id="8b24" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://sonery.medium.com/sql-versions-of-the-most-frequently-used-pandas-functions-bb6399f87461" rel="noopener">这些函数的SQL版本</a></li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ebc4" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.阅读_csv</h1><p id="11f2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">它用于通过从csv文件中读取数据来创建熊猫数据帧。DataFrame是Pandas的二维数据结构，由标记的行和列组成。</p><p id="188d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用read_csv函数非常简单。我们只需给它csv文件的路径，我们就完成了。然而，这个函数有几个参数提供额外的功能。</p><p id="8625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们首先通过只提供路径来使用它。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="cba5" class="ns mr it no b gy nt nu l nv nw">import pandas as pd</span><span id="a1fe" class="ns mr it no b gy nx nu l nv nw">df = pd.read_csv("Data/sample-sales-data.csv")</span><span id="8b89" class="ns mr it no b gy nx nu l nv nw">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/39a5edbb660d14b53fb96bc4b05ec3dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjpwkO3i1hsKoTVt1lYleg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><p id="c95e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">head方法显示数据帧的前5行。</p><p id="bdee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看几个使read_csv函数更有用的参数。</p><ul class=""><li id="6128" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">给定列名，parse_dates参数将数据类型转换为datetime64[ns],这是适用于日期的数据类型。</li></ul><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="c631" class="ns mr it no b gy nt nu l nv nw">df = pd.read_csv("Data/sample-sales-data.csv", <br/>                  parse_dates=["sales_date"])</span><span id="20e0" class="ns mr it no b gy nx nu l nv nw">df.dtypes</span><span id="9ff3" class="ns mr it no b gy nx nu l nv nw"># output<br/>store                  int64<br/>product                int64<br/>sales_date    datetime64[ns]<br/>sales_qty              int64<br/>sales_rev            float64<br/>dtype: object</span></pre><p id="503d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dtypes方法返回每一列的数据类型。</p><ul class=""><li id="c1bb" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">usecols参数允许读取列的子集，这在有几列而我们只需要其中的一部分时特别有用。</li></ul><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b48b" class="ns mr it no b gy nt nu l nv nw">df = pd.read_csv("Data/sample-sales-data.csv", <br/>                 usecols=["store","product","sales_qty"])</span><span id="37d7" class="ns mr it no b gy nx nu l nv nw">df.head()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/3e7aa697cb60067f3df24d13b82f2ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*YDIVG6k00coPJ1aJGT3m_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">df(作者图片)</p></figure><ul class=""><li id="585f" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">nrows参数用于读取文件的前n行。当我们有一个非常大的数据集，并且只需要探索它的一小部分时，它就派上了用场。</li></ul><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="5bf3" class="ns mr it no b gy nt nu l nv nw">df = pd.read_csv("Data/sample-sales-data.csv", nrows=100)</span><span id="0485" class="ns mr it no b gy nx nu l nv nw">df.shape</span><span id="87c5" class="ns mr it no b gy nx nu l nv nw"># output<br/>(100, 5)</span></pre><p id="69e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">shape方法返回一个显示行数和列数的元组。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="044d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.值计数</h1><p id="325d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">value_counts函数对于检查分类列中值的分布非常有用。它返回列中的唯一值及其出现的次数。</p><p id="35e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个例子。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="075d" class="ns mr it no b gy nt nu l nv nw">df["store"].value_counts()</span><span id="ad5b" class="ns mr it no b gy nx nu l nv nw"># output<br/>3    29<br/>4    22<br/>2    19<br/>5    16<br/>6     8<br/>1     6<br/>Name: store, dtype: int64</span></pre><p id="4d92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">商店列中有6个不同的商店号，最常见的是3，有29个观察值(即行)。</p><p id="ffa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用normalize参数来检查百分比份额的分布。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="6af3" class="ns mr it no b gy nt nu l nv nw">df["store"].value_counts(normalize=True)</span><span id="d483" class="ns mr it no b gy nx nu l nv nw"># output<br/>3    0.29<br/>4    0.22<br/>2    0.19<br/>5    0.16<br/>6    0.08<br/>1    0.06<br/>Name: store, dtype: float64</span></pre><p id="caf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">29%的行属于3号商店。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5cd6" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.astype</h1><p id="d6a1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">用正确的数据类型存储数据至关重要，因为:</p><ul class=""><li id="6c48" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">有些函数只适用于特定的数据类型</li><li id="3ad4" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">一些函数使用合适的数据类型会更有效</li></ul><p id="aac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在Pandas的dt访问器下有许多有用的方法，但是它们只能用于datetime数据类型。</p><p id="5c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">astype函数转换列的数据类型。这里有一个例子。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="b16d" class="ns mr it no b gy nt nu l nv nw">df["sales_date"] = df["sales_date"].astype("datetime64[ns]")</span><span id="ab1e" class="ns mr it no b gy nx nu l nv nw">df.dtypes</span><span id="1b28" class="ns mr it no b gy nx nu l nv nw"># output<br/>store                  int64<br/>product                int64<br/>sales_date    datetime64[ns]<br/>sales_qty              int64<br/>sales_rev            float64<br/>dtype: object</span></pre><p id="0436" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用字典在一次操作中改变多个列的数据类型。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="f3d0" class="ns mr it no b gy nt nu l nv nw">df = df.astype({"store":"category","sales_qty":"float"})</span><span id="1981" class="ns mr it no b gy nx nu l nv nw">df.dtypes</span><span id="23ee" class="ns mr it no b gy nx nu l nv nw"># output<br/>store               category<br/>product                int64<br/>sales_date    datetime64[ns]<br/>sales_qty            float64<br/>sales_rev            float64<br/>dtype: object</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2068" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.isna</h1><p id="c0cf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们经常需要处理丢失的值，这些值仅仅表示我们没有的数据。</p><p id="ea96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个带有一些缺失值的样本数据帧。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="0128" class="ns mr it no b gy nt nu l nv nw">import numpy as np<br/>import pandas as pd</span><span id="6de1" class="ns mr it no b gy nx nu l nv nw">customer = pd.DataFrame({<br/>    "id": [11001, 11102, 11005, 11107, 11010],<br/>    "name": ["John","Jane","Matt","Ashley","Emily"],<br/>    "salary": [75000, 72000, np.nan, 76000, np.nan],<br/>    "city": ["Houston","Dallas","San Antonio","Houston", np.nan],<br/>    "start_date": ["2020-10-01","2021-11-10","2019-05-20",<br/>                   "2019-07-19", np.nan]<br/>})</span><span id="448f" class="ns mr it no b gy nx nu l nv nw">customer</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/3f5e0a200784cd41bb8c755d671a0290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Izd-tKFJ9X3af5Kn94fxQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户(图片由作者提供)</p></figure><p id="105d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们不知道id为11005的客户的工资信息。对于最后一行的客户，我们只有姓名。</p><p id="9526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有一个大的数据集时，我们不能直观地检查或计算缺失值。isna函数检查每个单元格，并为缺失值返回True。然后，我们可以使用sum函数来获得每一列或每一行中缺失值的数量。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7be8" class="ns mr it no b gy nt nu l nv nw">customer.isna().sum()</span><span id="f288" class="ns mr it no b gy nx nu l nv nw"># output<br/>id            0<br/>name          0<br/>salary        2<br/>city          1<br/>start_date    1<br/>dtype: int64</span><span id="762a" class="ns mr it no b gy nx nu l nv nw"><br/>customer.isna().sum(axis=1) # for rows</span><span id="ee8b" class="ns mr it no b gy nx nu l nv nw"># output<br/>0    0<br/>1    0<br/>2    1<br/>3    0<br/>4    3<br/>dtype: int64</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="acf5" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.德罗普纳</h1><p id="25cc" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们基本上有两个选项来处理缺失值:drop或fill。</p><p id="e8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择哪个选项取决于缺失值的数量、数据集的大小和我们的任务。例如，我们可以删除最后一行，因为我们对这个客户了解不多。</p><p id="9d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">dropna函数用于删除缺少值的行或列。以下3个参数定义了该功能的运行方式:</p><ul class=""><li id="b393" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">轴:0代表行，1代表列</li><li id="2cca" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">如何:any用于删除带有任何缺失值的行或列，all用于删除带有所有缺失值的行或列</li><li id="8a0b" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">thresh:为一行或一列的非缺失值数量设置一个阈值，使其不被丢弃。</li></ul><p id="a7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们删除任何没有至少3个非缺失值的行。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="53f0" class="ns mr it no b gy nt nu l nv nw">customer.dropna(axis=0, thresh=3, inplace=True)</span><span id="d3d8" class="ns mr it no b gy nx nu l nv nw">customer</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/6f146ff6e48d91cd567586c558f517f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*iOVDvhPUE7Piw7G0zOEr_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户(图片由作者提供)</p></figure><p id="a252" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一行已被删除，因为它只有2个非缺失值，小于我们的阈值3。</p><p id="14db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">inplace参数用于保存更改。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b5ad" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">6.菲尔娜</h1><p id="9949" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">处理缺失值的另一个选择是用合适的值替换它们，这可以用fillna函数来完成。</p><p id="35e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以用salary列的平均值替换该列中缺少的值。</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="1b67" class="ns mr it no b gy nt nu l nv nw">customer["salary"].fillna(customer["salary"].mean(), inplace=True)</span><span id="88d5" class="ns mr it no b gy nx nu l nv nw">customer</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/5ee83ff4793f0cedda13af5d22003e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQy7un8hU6wavvkOrcGZYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户(图片由作者提供)</p></figure><p id="8bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">fillna函数提供了一种用上一个或下一个值填充缺失值的简单方法。当我们有顺序数据时，它特别有用。我们可以通过使用带有以下选项的方法参数来实现这一点:</p><ul class=""><li id="8024" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">bfill:使用下一个值替换丢失的值</li><li id="5bcb" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">ffill:使用以前的值替换丢失的值</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a960" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">7.分组依据</h1><p id="4202" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">groupby函数对于数据分析来说非常方便。它允许根据列中的不同值对行进行分组。然后，我们可以为每个组计算一个大范围的聚合。</p><p id="7cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在我们的销售数据集中，我们可以计算每个商店的总销售量，如下所示:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="52fc" class="ns mr it no b gy nt nu l nv nw">df.groupby("store")["sales_qty"].sum()</span><span id="8936" class="ns mr it no b gy nx nu l nv nw"># output<br/>store<br/>1     140436<br/>2      89710<br/>3      71309<br/>4      45068<br/>5      69614<br/>6      23598<br/>Name: sales_qty, dtype: int64</span></pre><p id="2449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用命名聚合，如下所示:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="fd95" class="ns mr it no b gy nt nu l nv nw">df.groupby("store").agg(<br/>    total_sales = ("sales_qty","sum")<br/>)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/0b407e781820bd6265cce18d19f9ef77.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*C_rvtQqPw_2Ny_Et0XU8_A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(图片由作者提供)</p></figure><p id="254f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使groupby函数更有用，我们还可以执行其他几种聚合。</p><p id="bd21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多，这里有一篇我以前写的关于groupby函数的文章:</p><div class="oe of gp gr og oh"><a rel="noopener follow" target="_blank" href="/11-examples-to-master-pandas-groupby-function-86e0de574f38"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">掌握熊猫分组功能的11个例子</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">在EDA过程中使用的最佳函数。</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">towardsdatascience.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa4d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">8.独一无二的</h1><p id="7585" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这两个功能非常相似，所以我想一起解释一下。</p><ul class=""><li id="f2e1" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">unique返回不同的值</li><li id="6280" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">nunique返回不同值的数量</li></ul><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="8046" class="ns mr it no b gy nt nu l nv nw">df["store"].nunique()</span><span id="e441" class="ns mr it no b gy nx nu l nv nw"># output<br/>6</span><span id="270c" class="ns mr it no b gy nx nu l nv nw">df["store"].unique()</span><span id="c1c0" class="ns mr it no b gy nx nu l nv nw"># output<br/>array([1, 2, 3, 4, 5, 6], dtype=int64)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">熊猫有更多的功能来简化和加快数据科学家和分析师的工作。我们只介绍了其中的8种，但我相信这些是你会用得最多的。</p><p id="da00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ow">你可以成为</em> <a class="ae ky" href="https://sonery.medium.com/membership" rel="noopener"> <em class="ow">媒介会员</em> </a> <em class="ow">解锁我的全部写作权限，外加其余媒介。如果你已经是了，别忘了订阅</em><a class="ae ky" href="https://sonery.medium.com/subscribe" rel="noopener"><em class="ow"/></a><em class="ow">如果你想在我发表新文章时收到电子邮件。</em></p><div class="oe of gp gr og oh"><a href="https://sonery.medium.com/membership" rel="noopener follow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">通过我的推荐链接加入Medium-Soner yl DRM</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">sonery.medium.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov ks oh"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。如果您有任何反馈，请告诉我。</p></div></div>    
</body>
</html>