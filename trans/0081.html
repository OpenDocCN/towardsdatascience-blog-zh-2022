<html>
<head>
<title>Using POTATO for interpretable information extraction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用马铃薯提取可解释信息</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/using-potato-for-interpretable-information-extraction-f2081a717eb7#2022-02-03">https://towardsdatascience.com/using-potato-for-interpretable-information-extraction-f2081a717eb7#2022-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/c22c116ca313c506436806e399634e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*5qGUfMmvwdw3shuDxYpg9w.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><h1 id="93b0" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">关于</h1><p id="2181" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">本文是对<strong class="ky ir">土豆</strong>库的介绍。POTATO是一个独立于语言的人在回路XAI(可解释的人工智能)框架，用于提取和评估自然语言处理(NLP)中任何分类问题的可解释图特征。</p><p id="8303" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该文章包括:</p><ul class=""><li id="3163" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">基于规则的文本分类方法简介</li><li id="09ee" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">马铃薯图形模式定义简介</li><li id="b8f7" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">自动学习模式</li><li id="f4c8" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">人在回路(HITL)框架</li></ul><h1 id="7f9d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">介绍</h1><p id="0667" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">目前，文本处理任务(和许多其他领域一样)由机器学习模型主导。但随着这些模型的参数呈指数增长，可解释性降低了。</p><p id="3b8c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">其中可解释的模型具有以下特征[1]:</p><ul class=""><li id="8bc1" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="ky ir">公平性</strong>——<strong class="ky ir">T5】无偏预测</strong></li><li id="17ad" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir">隐私</strong> —更少的信息泄露</li><li id="c685" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir">可靠性</strong> — <strong class="ky ir"> </strong>输入的微小变化不会严重影响输出</li><li id="13ff" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">信任、可审计性——我们知道是什么导致了这些预测</li><li id="e1f6" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir">可调试</strong> —如果生产中出现错误，我们可以更改型号</li></ul><p id="09aa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最近的NLP解决方案在公共基准上取得了最先进的结果，这些解决方案依赖于具有数百万参数的深度学习(DL)模型(例如BERT [2])。这些模型需要大量的训练数据，很难解释它们的决策[3]。此外，深度学习模型带来了从数据集学习非预期偏差的风险[4]。基于规则的系统可以提供准确和透明的解决方案，但构建和维护起来可能会很费时费力。POTATO是一个快速原型框架，支持创建基于规则的文本分类器。在POTATO中，我们不是使用机器学习模型来直接学习任务，而是学习规则系统。使用这种方法，最终模型保持完全透明。</p><h2 id="39fe" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">基于规则的系统</h2><p id="901f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="ky ir">优点</strong></p><ul class=""><li id="de63" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">基于规则的系统通过设计是可以解释和说明的</li><li id="ab3e" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">在“真实世界”的应用中很受欢迎，并且不需要大量的前期投资(不需要GPU)</li><li id="3ad4" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">完全可定制，可调试</li></ul><p id="7211" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">缺点</strong></p><ul class=""><li id="c7f2" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">难以维护</li><li id="35ba" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">基准测试的性能较差(基准测试主要由DL方法决定)</li><li id="09d3" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">需要领域专业知识</li><li id="da24" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">维护和开发非常耗时</li></ul><p id="af70" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在POTATO中，我们试图通过结合机器学习和规则系统来解决基于规则的模型的一些缺点:学习规则！</p><p id="90d1" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">为了演示规则系统，我们将使用来自<a class="ae mz" href="https://github.com/sahitya0000/Relation-Classification" rel="noopener ugc nofollow" target="_blank"> Semeval 2010关系提取</a>数据集的一个例子。关系抽取是从文本中抽取实体间语义关系的任务。通常在两个实体之间定义。关系具有语义类别(例如，<em class="na">目的地、成分、被使用、被建立等)..</em>)，任务是将关系分类到正确的类别中。</p><p id="e556" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将只使用<strong class="ky ir">实体-目的地</strong>标签。该类的一个示例:</p><ul class=""><li id="d1e7" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">钻石<strong class="ky ir">戒指(entity1) </strong>被丢进不给糖就捣蛋的人的<strong class="ky ir">袋子(entity2) </strong>。</li></ul><p id="9dda" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要定义规则，我们可以只使用一个简单的正则表达式:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5ae1" class="mn jz iq ng b gy nk nl l nm nn">r”entity1 .* dropped into .* entity2"</span></pre><p id="73e8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是只使用正则表达式是一种幼稚的方法，因为我们对文本的结构一无所知(标记、语法类别等)..).我们可以使用更高级的python包，比如spaCy的TokenMatcher或Holmes Extractor。有了它们，我们将能够定义一个更复杂的规则，将词性(POS)标签(单词的语法类别)考虑在内:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="e6f3" class="mn jz iq ng b gy nk nl l nm nn">pattern = [{‘POS’: ‘VERB’},</span><span id="db2c" class="mn jz iq ng b gy no nl l nm nn">{‘LOWER’: ‘into’},</span><span id="27bb" class="mn jz iq ng b gy no nl l nm nn">{‘TEXT’: {‘REGEX’: ‘.*’}},</span><span id="7ac8" class="mn jz iq ng b gy no nl l nm nn">{‘LOWER’: ‘entity2’}]</span></pre><p id="2e21" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是我们可以在图表上写规则，而不是在文本的符号上写规则，这可以利用文本的潜在图表结构。在POTATO中，我们使用<a class="ae mz" href="https://networkx.org/" rel="noopener ugc nofollow" target="_blank"> networkx </a> python包来表示图形。有了networkx，我们为图形表示提供了统一的接口，用户可以在任意图形上书写图形模式。在土豆中，目前我们支持三种类型的图形:<em class="na">AMR</em>【5】，<em class="na"> UD </em>(使用节包【6】)和<em class="na">4 lang</em>【7】。在图1和图2中可以看到一个示例模式，我们可以看到上面定义的示例的<em class="na"> 4lang </em>图(<em class="na">钻石</em> <strong class="ky ir"> <em class="na">戒指</em> </strong> <em class="na">被放入不给糖就捣蛋的人的</em> <strong class="ky ir"> <em class="na">袋子</em> </strong>)和应用的模式。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/b9d786d6bbdc5d6cf316529cc8eb6f10.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*KKAkb6QmQCIuwUWSIF0o9g.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图1:图形上定义的模式示例，ANY节点意味着我们匹配该节点中的任何字符串(图片由作者提供)</p></figure><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/12008a739690c966f87e54fde0621d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*PDutf4RbapqloQgHnfoCiw.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图2:从文本和应用特征构建的4lang [7]语义图(图片由作者提供)</p></figure><p id="497a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">与简单的正则表达式模式相反，这种模式也与以下示例相匹配:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="f1d3" class="mn jz iq ng b gy nk nl l nm nn">The man placed the <strong class="ng ir">entity1 </strong>into the <strong class="ng ir">entity2</strong>.<br/>Industries have pushed <strong class="ng ir">entity1 </strong>into fragile marine <strong class="ng ir">entity2</strong>.<br/>I am putting the <strong class="ng ir">entity1 </strong>into a MySQL <strong class="ng ir">entity2</strong>.<br/>The <strong class="ng ir">entity1 </strong>were released into the <strong class="ng ir">entity2</strong>.</span></pre></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="449f" class="jy jz iq bd ka kb ny kd ke kf nz kh ki kj oa kl km kn ob kp kq kr oc kt ku kv bi translated">使用和设置</h1><p id="8e85" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">POTATO是一个用python编写的人在回路的XAI框架，它提供:</p><ul class=""><li id="efec" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">用于多个图形库(4lang、stanza、AMR)的统一networkx接口</li><li id="dced" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">一个python包，用于<strong class="ky ir">学习和评估作为规则的可解释图形特征</strong></li><li id="6062" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">内置于<a class="ae mz" href="https://streamlit.io" rel="noopener ugc nofollow" target="_blank">的人在回路(HITL) UI框架简化了</a></li><li id="4c60" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">REST-API在生产模式下使用提取的特性进行推理</li></ul><p id="4f8a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们所有的组件都是在MIT许可下开源的，可以用pip安装。</p><p id="b1e5" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该工具严重依赖于<a class="ae mz" href="https://github.com/recski/tuw-nlp" rel="noopener ugc nofollow" target="_blank"> tuw-nlp </a>库来构建图表和匹配特征。您可以使用pip安装tuw-nlp:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="970d" class="mn jz iq ng b gy nk nl l nm nn">pip install <strong class="ng ir">tuw-nlp</strong></span></pre><p id="9fc4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后按照<a class="ae mz" href="https://github.com/recski/tuw-nlp" rel="noopener ugc nofollow" target="_blank">指令</a>安装软件包。</p><p id="aecf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后从pip安装POTATO:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5bca" class="mn jz iq ng b gy nk nl l nm nn">pip install <strong class="ng ir">xpotato</strong></span></pre><p id="c905" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">土豆的第一个进口包装:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="83b7" class="mn jz iq ng b gy nk nl l nm nn"><strong class="ng ir">from </strong>xpotato.dataset.dataset <strong class="ng ir">import </strong>Dataset<br/><strong class="ng ir">from</strong> xpotato.models.trainer <strong class="ng ir">import </strong>GraphTrainer</span></pre><p id="0be6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将从Semeval数据集[8]中手动选取几个句子来展示POTATO的能力。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="od oe l"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">表1:来自<a class="ae mz" href="https://github.com/sahitya0000/Relation-Classification" rel="noopener ugc nofollow" target="_blank"> Semeval 2010关系抽取</a>数据集的例句[8]</p></figure><p id="5e12" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><strong class="ky ir">注意，我们用<em class="na"> XXX </em>和<em class="na"> YYY </em>替换了有问题的两个实体。</strong></p><p id="db6e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，下一步是初始化数据集并提供标签编码。然后将句子解析成图形，为此我们可以使用<em class="na"> parse_graphs() </em>方法(也需要选择图形格式)。目前我们提供三种类型的图形:<em class="na"> ud </em>、<em class="na"> fourlang </em>、<em class="na"> amr </em>。您还需要提供想要解析的语言。目前我们支持<em class="na">英语(en) </em>和<em class="na">德语(de) </em>。</p><p id="1bcd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将使用表1中的例子(我们将引用在第一列中指定了id的样本)。用python初始化的例子可以用下面的代码完成:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="od oe l"/></div></figure><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="3c34" class="mn jz iq ng b gy nk nl l nm nn">dataset = Dataset(sentences, label_vocab={"Other":0, "Entity-Destination(e1,e2)": 1})<br/>dataset.set_graphs(dataset.parse_graphs(graph_format="fourlang"))</span></pre><p id="0615" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">检查数据集:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c1db" class="mn jz iq ng b gy nk nl l nm nn">df = dataset.to_dataframe()</span></pre><p id="7caa" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以检查任何被解析的图形</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ea90" class="mn jz iq ng b gy nk nl l nm nn"><strong class="ng ir">from </strong>xpotato.models.utils <strong class="ng ir">import</strong> to_dot<br/><strong class="ng ir">from </strong>graphviz <strong class="ng ir">import </strong>Source</span><span id="f24a" class="mn jz iq ng b gy no nl l nm nn">Source(to_dot(dataset.graphs[0]))</span></pre><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/b54c42b39e2734e8327a365ad1061ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*kBeUPayuru7vEHmx6uBK2w.png"/></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">作者图片</p></figure><h1 id="25f3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用土豆写规则</h1><p id="334c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果数据集准备好了，图形也解析好了，我们就可以编写规则来匹配标签。我们可以手动编写规则，也可以自动提取规则(POTATO也提供了一个两者都做的前端)。</p><p id="479e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最简单的规则就是图中的一个节点(本例中是从<em class="na">到</em>):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="def9" class="mn jz iq ng b gy nk nl l nm nn"># The syntax of the rules<br/># List[List[rules that we want to match]<br/># List[rules that shouldn't be in the matched graphs]<br/># Label of the rule<br/>rule_to_match = [[["(u_1 / into)"], [], "Entity-Destination(e1,e2)"]]</span></pre><p id="6a7d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">初始化规则匹配器:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="d5fd" class="mn jz iq ng b gy nk nl l nm nn"><strong class="ng ir">from </strong>xpotato.graph_extractor.extract <strong class="ng ir">import </strong>FeatureEvaluator<br/>evaluator = FeatureEvaluator()</span></pre><p id="d9bc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">匹配数据集中的规则:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="cd69" class="mn jz iq ng b gy nk nl l nm nn"><em class="na"># The function will return a dataframe with the matched instances:<br/></em>evaluator.match_features(df, rule_to_match)</span></pre><p id="401b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该函数将返回带有匹配示例的数据帧。该规则将匹配任何包含节点<em class="na">到</em>的句子。在我们的例子中，我们将匹配表1中编号为<em class="na"> 0、1、2、3、4、5、6、9、14 </em>的例子(例如，<em class="na">科学家将XXX倒入品脱YYY中。)</em></p><p id="5fdd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们工具的核心特性之一是我们也能够匹配子图。为了描述一个图形，我们使用<a class="ae mz" href="https://github.com/goodmami/penman" rel="noopener ugc nofollow" target="_blank">彭曼</a>符号。</p><p id="a8be" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">例如，字符串<em class="na"> (u_1 / into :1 (u_3 / pour)) </em>将描述一个具有两个节点(<em class="na">“into”</em>和<em class="na">“pour”</em>)以及它们之间带有标签“1”的单个有向边的图。用字符串<em class="na">(u _ 1/into:1(u _ 2/pour):2(u _ 3/YYY))</em>描述一个子图，当我们只有单个节点作为特征时，只会返回3个例子而不是9个。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1ca9" class="mn jz iq ng b gy nk nl l nm nn"><em class="na">#match a simple graph feature<br/></em>evaluator.match_features(df, [[[“(u_1 / into :1 (u_2 / pour) :2 (u_3 / YYY))”], [], “Entity-Destination(e1,e2)”]])</span></pre><p id="4df9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="na">此功能将在示例0、1、9上匹配。</em></p><p id="7577" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以添加我们不想匹配的否定特征(这不会匹配存在‘pour’的第一行):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="862e" class="mn jz iq ng b gy nk nl l nm nn"><em class="na"># match a simple graph feature with a negated feature. <br/>#The negated features go into the second parameter.<br/></em>evaluator.match_features(df, [[[“(u_1 / into :2 (u_3 / YYY))”], [“(u_2 / pour)”], “Entity-Destination(e1,e2)”]])</span></pre><p id="8a58" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="na">匹配例2、3、5、6。</em></p><p id="535c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果我们不想指定节点，regex也可以用来代替节点和边名:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="b559" class="mn jz iq ng b gy nk nl l nm nn"><em class="na"># regex can be used to match any node (this will match instances <br/># where ‘into’ is connected to any node with ‘1’ edge)<br/></em>evaluator.match_features(df, [[[“(u_1 / into :1 (u_2 / .*) :2 (u_3 / YYY))”], [], “Entity-Destination(e1,e2)”]])</span></pre><p id="c292" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还可以从训练数据中<em class="na">提炼</em>正则表达式规则，这将自动替换正则表达式。* '具有高精度的节点。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="a0d6" class="mn jz iq ng b gy nk nl l nm nn">evaluator.train_feature("Entity-Destination(e1,e2)", "(u_1 / into :1 (u_2 / .*) :2 (u_3 / YYY))", df)</span></pre><p id="9140" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="na">这个返回</em><strong class="ky ir"><em class="na">(u _ 1/into:1(u _ 2/push | pour):2(u _ 3/YYY))</em></strong><em class="na">【替换掉了】。* "用</em> <strong class="ky ir"> <em class="na">推</em></strong><em class="na"/><strong class="ky ir"><em class="na">倒</em> </strong> <em class="na"> ) </em></p><h1 id="6799" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">人在回路规则学习</h1><p id="8581" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">土豆的想法是:</p><ul class=""><li id="a48c" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">使用子图作为训练简单分类器(LogReg，Random Forest等)的特征。)</li><li id="0c0a" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">仅生成特定边数的子图(以避免大量特征)</li><li id="d015" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">基于功能重要性向用户建议规则</li><li id="5196" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">通过UI，用户可以接受、拒绝、编辑、组合模式</li><li id="24fe" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">子图可以将正则表达式作为节点或边标签</li><li id="f694" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">可以细化未指定的子图</li></ul><p id="abee" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要从已标记的数据集中自动提取规则，请使用图表要素训练数据集，并根据相关性对其进行排序:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ecf3" class="mn jz iq ng b gy nk nl l nm nn"><strong class="ng ir">from </strong>sklearn.model_selection <strong class="ng ir">import </strong>train_test_split</span><span id="2de2" class="mn jz iq ng b gy no nl l nm nn">train, val = train_test_split(df, test_size=0.2, random_state=1234)</span><span id="4c7b" class="mn jz iq ng b gy no nl l nm nn">trainer = GraphTrainer(train)</span><span id="8da2" class="mn jz iq ng b gy no nl l nm nn">features = trainer.prepare_and_train(min_edge=1)</span></pre><p id="395d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">特征变量将包含自动提取的规则:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="be7b" class="mn jz iq ng b gy nk nl l nm nn">(u_15 / into :1 (u_26 / push))<br/>(u_15 / into :1 (u_19 / pour :2 (u_0 / xxx)))<br/>(u_15 / into :1 (u_19 / pour))<br/>(u_19 / pour :2 (u_0 / xxx))<br/>(u_15 / into :2 (u_3 / yyy))</span></pre><h2 id="f931" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">用户界面</h2><p id="3d97" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">除了前面介绍的后端，POTATO还提供了一个HITL用户界面，允许用户从数据集中提取规则。为了启动HITL用户界面，我们需要加载一个数据集，作为一组带标签或不带标签的图形。除了我们预定义的格式(<em class="na"> ud，4lang，amr </em>)之外，任何有向图都可以加载。建议和评估规则需要基础事实标签(使用上一节描述的特征学习方法)，如果这些不可用，可以在<em class="na">高级</em>模式下启动UI，使用规则引导和注释标签。一旦加载了数据集，就可以启动HITL前端，用户将看到图3所示的界面，该界面是使用<a class="ae mz" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"> streamlit </a>库构建的。</p><p id="335f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">图3所示的前端提供:</p><ul class=""><li id="94cd" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated"><strong class="ky ir"> 1 — </strong>数据集浏览器，允许用户查看数据集所有行的文本、图形和标签。查看器使用<a class="ae mz" href="https://graphviz.org/" rel="noopener ugc nofollow" target="_blank"> graphviz </a>库呈现图形，并且还提供PENMAN符号，用户可以复制该符号来快速编辑规则。</li><li id="cb7b" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir"> 2 — </strong>用户可以选择要处理的类(如果处理多标签分类，则为数不多)。</li><li id="8485" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir"> 3 — </strong>为每个类构建的规则列表保存在一个列表中，它们可以被修改、删除或添加新的特性。</li><li id="055c" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir"> 4 — </strong>可以在训练和验证数据集上查看和评估规则。</li><li id="5033" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir"> 5 — </strong>可以通过查看真阳性、假阳性或假阴性示例来分析每个规则的预测。</li><li id="e155" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated"><strong class="ky ir"> 6 — </strong>按钮suggest new rules返回一个建议图表的列表以及它们在训练数据上的表现，允许用户选择那些应该添加到规则列表中的图表，这个界面如图4所示。对于包含正则表达式的规则，<em class="na"> Refine </em>按钮将用高精度标签的析取来替换正则表达式。这个函数是使用上一节描述的方法实现的。</li></ul><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi og"><img src="../Images/9c36ba7d4f7394254816675ebae1c958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skjFNXrpu8QbCA2-gVUN_A.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图3:土豆的主页面允许用户<strong class="bd ol"> 1 </strong>浏览数据集并查看处理后的图形，<strong class="bd ol"> 2 </strong>选择您想要在其上构建基于规则的系统的类，<strong class="bd ol"> 3 </strong>修改、删除、添加新规则并获得建议，<strong class="bd ol"> 4 </strong>查看所选规则的结果，<strong class="bd ol"> 5 </strong>查看每个规则的示例预测(图片由作者提供)</p></figure><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="oh oi di oj bf ok"><div class="gh gi om"><img src="../Images/7f880db3e8d48513d569d1cd29a1456e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAjwSzVJl7O0GEQ4k0vriw.png"/></div></div><p class="ju jv gj gh gi jw jx bd b be z dk translated">图POTATO建议的模式，按精度排序(图片由作者提供)</p></figure><p id="5206" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如上所述，前端是一个streamlit应用程序，我们可以从训练和验证数据集开始。首先用下面的代码保存它们:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="45cc" class="mn jz iq ng b gy nk nl l nm nn">train.to_pickle(“train_dataset.pickle”)<br/>train.to_pickle(“val_dataset.pickle”)</span></pre><p id="3200" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，可以通过一行命令行启动streamlit应用程序:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="3bb8" class="mn jz iq ng b gy nk nl l nm nn">streamlit run frontend/app.py -- -t train_dataset.<!-- -->pickle<!-- --> -v val_dataset.<!-- -->pickle</span></pre><p id="50a9" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">每个类的规则都以JSON格式自动保存到磁盘上，这个文件可以被加载用于进一步的编辑或推理。</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="8935" class="mn jz iq ng b gy nk nl l nm nn">streamlit run frontend/app.py -- -t notebooks/train_dataset -v notebooks/val_dataset -hr features.json</span></pre><h2 id="eec8" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">高级模式</h2><p id="a78f" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果标签没有提供或者只是部分提供，前端也可以在<em class="na">高级</em>模式下启动，用户可以在开始<em class="na">注释</em>几个例子，然后系统根据提供的例子逐渐提供规则。</p><p id="7d5c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，可以启动前端:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="1d7f" class="mn jz iq ng b gy nk nl l nm nn">streamlit run frontend/app.py -- -t unsupervised_dataset -m advanced</span></pre><h2 id="4a35" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">评价</h2><p id="48cb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您已经准备好了特性，并且想要在测试集上评估它们，您可以运行:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="9cad" class="mn jz iq ng b gy nk nl l nm nn">python scripts/evaluate.py -d test_dataset.pickle -f features.json</span></pre><p id="d90d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">结果将是一个带有标签和匹配规则的<em class="na"> csv </em>文件。</p><h2 id="bc24" class="mn jz iq bd ka mo mp dn ke mq mr dp ki lh ms mt km ll mu mv kq lp mw mx ku my bi translated">服务</h2><p id="f1f2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您已经准备好提取的特性，并希望在生产中使用我们的包进行推理(为句子生成预测)，我们还提供了一个构建在POTATO上的REST API(基于<a class="ae mz" href="https://github.com/tiangolo/fastapi" rel="noopener ugc nofollow" target="_blank"> fastapi </a>)。</p><p id="c6b3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先安装FastAPI和<a class="ae mz" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a></p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="03bb" class="mn jz iq ng b gy nk nl l nm nn">pip install fastapi<br/>pip install "uvicorn[standard]"</span></pre><p id="9146" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">要启动服务，您需要为服务设置<em class="na">语言</em>、<em class="na">图形_类型</em>和<em class="na">特性</em>。这可以通过环境变量来完成。</p><p id="cae2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">示例:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ed49" class="mn jz iq ng b gy nk nl l nm nn">export FEATURE_PATH=/home/adaamko/projects/POTATO/features/semeval/test_features.json<br/>export GRAPH_FORMAT=ud<br/>export LANG=en</span></pre><p id="a592" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，启动REST API:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="284a" class="mn jz iq ng b gy nk nl l nm nn">python services/main.py</span></pre><p id="c561" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">它将在端口<em class="na"> 8000 </em>上启动运行在<em class="na"> localhost </em>上的服务(它还将初始化正确的模型)。</p><p id="d105" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，您可以使用任何客户端发出post请求:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ef5a" class="mn jz iq ng b gy nk nl l nm nn">curl -X POST localhost:8000 -H 'Content-Type: application/json' -d '{"text":"The suspect pushed the XXX into a deep YYY.\nSparky Anderson is making progress in his XXX from YYY and could return to managing the Detroit Tigers within a week."}'</span></pre><p id="de09" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">答案将是一个带有预测标签的列表(如果没有匹配的规则，它将返回“无”):</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="6865" class="mn jz iq ng b gy nk nl l nm nn">["Entity-Destination(e1,e2)","NONE"]</span></pre><p id="6217" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">streamlit前端也有一个<em class="na">推理</em>模式，可以使用实现的规则系统进行推理。可以从以下方面入手:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="4947" class="mn jz iq ng b gy nk nl l nm nn">streamlit run frontend/app.py -- -hr features/semeval/test_features.json -m inference</span></pre></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="7b49" class="jy jz iq bd ka kb ny kd ke kf nz kh ki kj oa kl km kn ob kp kq kr oc kt ku kv bi translated">结论</h1><p id="bf63" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">POTATO能够快速构建基于规则的系统，并为NLP任务的深度学习模型提供透明、可解释和可审计的替代解决方案。如果你想阅读更多关于这个框架的内容，或者想尝试一下，你可以查看以下资源:</p><ul class=""><li id="09cd" class="lz ma iq ky b kz lu ld lv lh mb ll mc lp md lt me mf mg mh bi translated">你可以查看我们题为<a class="ae mz" href="https://arxiv.org/pdf/2201.13230.pdf" rel="noopener ugc nofollow" target="_blank">土豆:可解释的信息提取框架</a>的论文</li><li id="b857" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">该框架的代码可以在GitHub上获得，使用麻省理工学院的许可:<a class="ae mz" href="https://github.com/adaamko/POTATO" rel="noopener ugc nofollow" target="_blank">https://github.com/adaamko/POTATO</a>，你也可以查看知识库，获得更多的例子和多个任务的预建规则系统</li><li id="b3e6" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">关于这个框架的研讨会的幻灯片也可以得到</li><li id="fefe" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">查看我们关于该工具的快速演示(约2分钟)视频:<a class="ae mz" href="https://youtu.be/PkQ71wUSeNU" rel="noopener ugc nofollow" target="_blank">https://youtu.be/PkQ71wUSeNU</a></li><li id="4f18" class="lz ma iq ky b kz mi ld mj lh mk ll ml lp mm lt me mf mg mh bi translated">更长的版本有详细的方法描述和背景研究(约1小时):<a class="ae mz" href="https://youtu.be/6R_V1WfIjsU" rel="noopener ugc nofollow" target="_blank">https://youtu.be/6R_V1WfIjsU</a></li></ul><h1 id="d068" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">参考</h1><p id="d119" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">[1] Doshivelez等人，迈向可解释机器学习的严格科学，(2019)</p><p id="9948" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[2] Devlin等人，<a class="ae mz" href="https://aclanthology.org/N19-1423" rel="noopener ugc nofollow" target="_blank">用于语言理解的深度双向转换器的预训练</a>，(2019)</p><p id="73c4" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[3] Serrano等人，<a class="ae mz" href="https://aclanthology.org/P19-1282" rel="noopener ugc nofollow" target="_blank">注意是可解释的吗？</a>，(2019)</p><p id="9434" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[4] Bender等人，<a class="ae mz" href="https://doi.org/10.1145/3442188.3445922," rel="noopener ugc nofollow" target="_blank">论随机鹦鹉的危险:语言模型会不会太大？</a>(2021)</p><p id="88be" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[5]巴纳雷斯库等，【Sembanking的抽象意义表示，(2013)</p><p id="f11a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[6]齐等，<a class="ae mz" href="https://www.aclweb.org/anthology/2020.acl-demos.14" rel="noopener ugc nofollow" target="_blank"> Stanza:面向多种人类语言的Python自然语言处理工具包</a>，(2020)</p><p id="1d0e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[7]科尔奈等著，<a class="ae mz" href="http://kornai.com/Drafts/sem.pdf" rel="noopener ugc nofollow" target="_blank">语义学</a> (2019)</p><p id="a65a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">[8] Hendrix等，<a class="ae mz" href="https://aclanthology.org/S10-1006.pdf" rel="noopener ugc nofollow" target="_blank"> SemEval-2010任务8:名词对之间语义关系的多向分类</a> (2010)</p></div></div>    
</body>
</html>