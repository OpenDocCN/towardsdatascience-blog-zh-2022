<html>
<head>
<title>Algorithms Explained #1: Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释#1:递归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-explained-1-recursion-f101500f9316#2022-10-10">https://towardsdatascience.com/algorithms-explained-1-recursion-f101500f9316#2022-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Python中的示例了解何时以及如何使用递归解决方案</h2></div><p id="9300" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是用Python示例解释算法系列的第一篇文章。这是为有抱负的数据科学家和软件工程师或那些希望在准备编码面试中复习算法的人准备的。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/71344856e420104f105d787a41e6d1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8piunk2N1PpFCCC6qT3eg.jpeg"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">图片由<a class="ae lv" href="https://pixabay.com/users/geralt-9301/" rel="noopener ugc nofollow" target="_blank"> Gerd Altmann </a>从<a class="ae lv" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="2e9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在学习数据结构和算法时，递归是编程中的一个基本概念。在本文中，我将解释什么是递归，何时使用递归，并浏览一些用Python 3编写的例子。</p><h2 id="6452" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">什么是递归？</h2><p id="a59b" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">递归是指函数或方法调用自身，它对于分治范式是必不可少的，其思想是将较大的问题分成较小的子问题，子问题是原始问题的某个常数部分。递归的工作方式是通过单独解决较小的子问题，然后将结果聚集起来返回最终的解决方案。</p><h2 id="705f" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">什么时候使用递归？</h2><p id="43f3" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">递归经常用于本质上是递归的问题。这包括具有父子关系的图、树和数据结构。递归问题的一些典型例子是计算第n个斐波那契数，计算一个数的阶乘，以及将十进制数转换成二进制数。</p><h2 id="6e41" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">为什么我应该使用递归？</h2><p id="130b" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">正确使用时，递归解决方案通常会产生更清晰、更易读的代码。当求解本质上是递归的解时，它更直观，我们将在后面的例子中看到。但是，请记住，递归解决方案的内存效率可能较低，如果您的计算机内存耗尽，或者您的函数在到达基本情况之前堆栈过深，将会导致堆栈溢出错误。</p><h2 id="86a0" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">我如何构造一个递归算法？</h2><p id="270d" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">要编写递归算法，首先需要将问题分成两部分，第一部分是基本情况，第二部分是递归步骤:</p><ol class=""><li id="b768" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu">基本情况:</strong>基本情况是指停止调用递归函数需要满足的条件。这是终止递归函数并返回结果之前的结束状态或最后一个待评估的事例。如果没有基本情况，你的递归函数将会无限循环下去，永远不会终止！</li><li id="0f90" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">递归步骤:</strong>这是递归调用同一个函数的代码部分，使用每次递归调用都更新的输入来计算结果。每一次迭代都应该让你更接近基本情况。</li></ol><h2 id="f893" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">示例1:使用递归确定第n个斐波那契数列</h2><p id="ff3c" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">在斐波纳契数列中，数列的第一项和第二项分别是0和1。要计算位置n的数字，可以取前面两项的和，即位置(n-1)的数字+位置(n-2)的数字。斐波纳契数列F可以用数学方法表示如下:</p><ul class=""><li id="8f73" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld ni na nb nc bi translated">F(1) = 0</li><li id="b64c" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">F(2) = 1</li><li id="bbb9" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld ni na nb nc bi translated">F(n) = F(n-1) + F(n-2)</li></ul><p id="f84c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将定义一个函数<code class="fe nj nk nl nm b">fibonacci()</code>,它将一个数字n作为参数，并返回斐波那契数列中位置n处的数字。这个问题可以用多种方法解决，但在递归解决方案中，我们可以将问题分解为以下两个部分:</p><ol class=""><li id="0dc6" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu">基本情况:</strong>如果n为1，则返回0，因为斐波那契数列的第一项为0。如果n是2，则返回1，因为数列的第二项是1。</li><li id="c55c" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">递归步骤:</strong>对于n的所有其他值，我们可以通过将前面两项相加来计算位置n处的数字:fibonacci(n-1) + fibonacci(n-2)。</li></ol><p id="de9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是计算斐波纳契数列中第n个数字的递归解决方案的Python实现:</p><pre class="lg lh li lj gt nn nm no np aw nq bi"><span id="1c1f" class="lw lx it nm b gy nr ns l nt nu">def fibonacci(n):<br/>   if n == 1:<br/>      return 0<br/>   if n == 2:<br/>      return 1<br/>   return fibonacci(n-1) + fibonacci(n-2)</span></pre><h2 id="69fa" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">例2:计算第n个阶乘</h2><p id="e00f" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">第n个数的阶乘是从1到n的所有整数的乘积，比如5的阶乘就是<code class="fe nj nk nl nm b">5! = 1 * 2 * 3 * 4 * 5 = 120</code>。注意0的阶乘是1，负数的阶乘是未定义的。</p><p id="74cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将定义一个函数<code class="fe nj nk nl nm b">factorial()</code>，它将一个数字<em class="le"> n </em>作为参数，并返回<em class="le"> n </em>的阶乘。为了用递归解决这个问题，我们必须把它分解成以下两种情况:</p><ol class=""><li id="7a0e" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu">基本情况:</strong>如果n = 0或1，返回1。如果n &lt; 0，返回错误，因为负数的阶乘未定义。</li><li id="b2ac" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">递归步骤:</strong>用前一项的结果乘以n，即<code class="fe nj nk nl nm b">n * factorial(n-1)</code>。</li></ol><p id="7542" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是计算第n个阶乘的递归解决方案的Python实现:</p><pre class="lg lh li lj gt nn nm no np aw nq bi"><span id="0dea" class="lw lx it nm b gy nr ns l nt nu">def factorial(n):<br/>   if (n == 0 or n == 1):<br/>      return 1<br/>   if n &lt; 0:<br/>      raise Exception("n must be positive. The factorial of a negative number is undefined.")<br/>   return n * factorial(n - 1)</span></pre><h2 id="2938" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">示例3:将十进制整数显示为二进制</h2><p id="8ff4" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">在日常生活中，最常用的数字系统是十进制数，它的基数是10。对于数字系统，通常使用二进制数字系统，其基数为2。</p><p id="9583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将十进制数转换为二进制数的一种方法是将该数除以2，并记录下每一步的余数，然后以相反的顺序(从下到上)写出余数，这就是整数的二进制等效值。例如，二进制的十进制数36是:</p><p id="c9f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">36/2 = 18<strong class="kk iu">r0</strong>→18/2 = 9<strong class="kk iu">r0</strong>→9/2 = 4<strong class="kk iu">R1</strong>→4/2 = 2<strong class="kk iu">r0</strong>→2/2 = 1<strong class="kk iu">r0</strong>→1/2 = 0<strong class="kk iu">R1</strong></p><p id="2b57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以相反的顺序收集余数，我们得到100100作为十进制数36的二进制数。</p><p id="59b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将定义一个函数<code class="fe nj nk nl nm b">convert_to_binary()</code>，它接受十进制数<em class="le"> n </em>，并以整数列表的形式返回二进制数。为了递归地解决这个问题，我们可以把它分成两部分:</p><ol class=""><li id="52f0" class="mu mv it kk b kl km ko kp kr mw kv mx kz my ld mz na nb nc bi translated"><strong class="kk iu">基础案例:</strong>如果n等于0，返回一个整数为0的列表。如果n等于1，则返回一个整数为1的列表。</li><li id="f986" class="mu mv it kk b kl nd ko ne kr nf kv ng kz nh ld mz na nb nc bi translated"><strong class="kk iu">递归步骤:</strong>对商(数字<em class="le"> n </em>除以2)调用函数<code class="fe nj nk nl nm b">convert_to_binary()</code>，并跟踪该操作的余数。</li></ol><p id="4371" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是将十进制数转换为二进制数的递归函数的Python实现:</p><pre class="lg lh li lj gt nn nm no np aw nq bi"><span id="230b" class="lw lx it nm b gy nr ns l nt nu">def convert_to_binary(n):<br/>   if n == 0:<br/>      return [0]<br/>   elif n == 1: <br/>      return [1] <br/>   remainders = convert_to_binary(n // 2)<br/>   remainders.extend([n % 2])<br/>   return remainders</span></pre><h2 id="84c0" class="lw lx it bd ly lz ma dn mb mc md dp me kr mf mg mh kv mi mj mk kz ml mm mn mo bi translated">结论</h2><p id="9601" class="pw-post-body-paragraph ki kj it kk b kl mp ju kn ko mq jx kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">递归是一个基本的编程概念，在编码面试中很流行。递归的一些常见用例是具有父子关系的数据结构。编写递归解决方案的关键是首先定义基本情况，然后考虑递归步骤。递归通常会产生更简洁的代码，但它可能没有内存效率高。</p><p id="484e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更多请看本算法讲解系列:<a class="ae lv" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>(本期文章)<a class="ae lv" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>，<a class="ae lv" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>，<a class="ae lv" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>，<a class="ae lv" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>，<a class="ae lv" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>。</p></div></div>    
</body>
</html>