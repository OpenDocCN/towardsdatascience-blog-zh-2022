<html>
<head>
<title>Python Libraries for Mesh, Point Cloud, and Data Visualization (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于网格、点云和数据可视化的Python库(第1部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-libraries-for-mesh-and-point-cloud-visualization-part-1-daa2af36de30#2022-04-26">https://towardsdatascience.com/python-libraries-for-mesh-and-point-cloud-visualization-part-1-daa2af36de30#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5302" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">八个最好的Python库，用于惊人的3D可视化、绘图和动画</h2></div><blockquote class="kf kg kh"><p id="4e8f" class="ki kj kk kl b km kn jr ko kp kq ju kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">关于用Python创建令人惊叹的3D可视化、绘图和动画的最佳库的教程。谁说你需要C++知识来创建快速响应的点云、网格或数据集可视化？本实践教程将为您提供纲要和代码片段，帮助您启动并运行这8个库— <a class="ae lf" href="http://www.open3d.org/" rel="noopener ugc nofollow" target="_blank"> Open3D </a>、<a class="ae lf" href="https://trimsh.org/index.html" rel="noopener ugc nofollow" target="_blank"> Trimesh </a>、<a class="ae lf" href="https://vedo.embl.es/" rel="noopener ugc nofollow" target="_blank"> Vedo </a> (V3do)、<a class="ae lf" href="https://github.com/mmatl/pyrender" rel="noopener ugc nofollow" target="_blank"> Pyrender </a>、<a class="ae lf" href="https://plotoptix.rnd.team/" rel="noopener ugc nofollow" target="_blank"> PlotOptiX </a>、<a class="ae lf" href="https://polyscope.run/py/" rel="noopener ugc nofollow" target="_blank"> Polyscope </a>、<a class="ae lf" href="https://docs.pyvista.org/" rel="noopener ugc nofollow" target="_blank"> PyVista </a>和<a class="ae lf" href="https://simple-3dviz.com/" rel="noopener ugc nofollow" target="_blank"> Simple-3dviz </a>。这是第1部分，详细介绍了Open3D、Trimesh、PyVista和Vedo(V3do)。</p></blockquote><div class="lg lh li lj gt ab cb"><figure class="lk ll lm ln lo lp lq paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/c8c4ee49be70340f2b62d65a7e8a50b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*Lm_Xbh29DbvjJ3x_yv4GlQ.gif"/></div></figure><figure class="lk ll lm ln lo lp lq paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/61da07ddf21743779acd6aa781e41d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*TTIrEj8nC67DF_zFgQ70-w.gif"/></div></figure><figure class="lk ll lm ln lo lp lq paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><img src="../Images/6dca37e5a35fa0b555895c3290832e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/1*rWsjyb-k9ietkdrq7Z4vvg.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk mb di mc md translated">PyVista(左)、Trimesh(中)和Vedo(右)的输出示例|图片由作者提供</p></figure></div><p id="3c1e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi mh translated">这是针对3D工作和可视化的Python库的计划教程的第1部分。在本部分中，我们将介绍前4个可视化库——open 3d、Trimesh、PyVista和Vedo，而第2部分将重点介绍Pyrender、PlotOptiX、Polyscope和Simple-3dviz。如果您对用于分析和处理网格、点云或数据集的库感兴趣，我还将在后面的文章中介绍广泛使用的任务库，如体素化、特征提取、距离计算、表面生成和网格划分等。在前两篇文章中，我们将主要关注可视化和动画。</p><figure class="lg lh li lj gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mq"><img src="../Images/80de4264e1aa627def1edb5228be60fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ceyarlx0Z4QAF9tTV1L1RQ.gif"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">作者使用PyVista | Image以3D方式显示不同月份的天气(温度/湿度)数据</p></figure><p id="685c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">很长一段时间，人们需要使用Matplotlib来可视化Python中的3D内容。使用它的好处是，如果您安装了Python，那么您很可能拥有使用Matplotlib在3D中可视化数据所需的一切。坏的方面是它不支持GPU硬件加速，这意味着一旦你在3D中通过了一定数量的点或面，事情往往会变得缓慢和无反应。这导致许多人使用<a class="ae lf" href="https://pointclouds.org/" rel="noopener ugc nofollow" target="_blank">点云库</a> ( <strong class="kl ir"> PCL </strong>)作为网格和点云可视化和分析的一揽子解决方案。PCL仍然是最好的3D分析库之一，它是用C++构建的这一事实保证了它的通用性和响应性。两个主要问题阻止了它的完善Python包装器只包含主PCL库的一小部分功能，在Windows上运行它是一项令人沮丧的工作，有大量的编译错误、缺失或损坏的功能，以及不太理想的教程。简而言之——如果你在Linux中工作，并且不害怕C++，那么PCL就是你要走的路。但是其他人呢？</p><p id="b2c6" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">近年来，越来越多的Python库开始涌现，试图填补这一空白。其中一些库(如Open3D、Trimesh和Vedo)非常健壮，包含许多不同的功能，用于分析、生成和处理网格和点云。其他如Simple-3dviz、Polyscope和Pyrender则更倾向于创建快速而漂亮的可视化和动画。对于本文，我选择了8个库，它们提供了不同级别的可视化和许多附加选项——从内置的手动控件到大量的照明和动画选项以及光线跟踪视觉效果。所有的代码都可以在GitHub库<a class="ae lf" href="https://github.com/IvanNik17/python-3d-analysis-libraries" rel="noopener ugc nofollow" target="_blank">这里</a>获得。下图展示了一些可视化的可能性，以及提取的特征。</p><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c73de97ff278aac80686444790ce1b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/1*BWePs_9Q7vwxY33Xh6jJ7g.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">一些可能的可视化选项和提取特征的示例。这些是作者用PyVista | Image做的</p></figure><p id="8342" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">这篇文章远不是所有可用库的详尽列表，值得注意的是，缺少了像<a class="ae lf" href="https://github.com/daavoo/pyntcloud" rel="noopener ugc nofollow" target="_blank"> pyntcloud </a>、<a class="ae lf" href="https://vpython.org/" rel="noopener ugc nofollow" target="_blank"> vpython </a>、<a class="ae lf" href="https://docs.enthought.com/mayavi/mayavi/index.html" rel="noopener ugc nofollow" target="_blank"> Mayavi、</a>和其他库所基于的base <a class="ae lf" href="https://vtk.org/" rel="noopener ugc nofollow" target="_blank"> VTK </a>这样的库。我选择跳过这些库，因为它们的安装相对复杂，或者因为它们对大型点云和网格的可视化能力不够理想。但是我计划将它们包含在下一篇探索3D分析和操作的文章中。</p><p id="553d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">此外，还有Python包装库，用于直接通过Python使用广为人知的可视化和操作应用程序，如<a class="ae lf" href="https://www.danielgm.net/cc/" rel="noopener ugc nofollow" target="_blank"> CloudCompare </a>和<a class="ae lf" href="https://www.meshlab.net/" rel="noopener ugc nofollow" target="_blank"> Meshlab </a>。<a class="ae lf" href="https://github.com/CloudCompare/CloudComPy" rel="noopener ugc nofollow" target="_blank"> CloudComPy </a>和<a class="ae lf" href="https://github.com/cnr-isti-vclab/PyMeshLab" rel="noopener ugc nofollow" target="_blank"> PyMeshLab </a>创建直接连接到Python的接口，绕过使用GUI甚至打开应用程序的必要性。我们将在后面的文章中更详细地讨论这些包装器库。</p><p id="d624" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">让我们直接进入每一个库——研究如何安装它们，进行初始设置，最后编写一些简单的可视化代码。为了展示网格和点云以及数据集的可视化可能性，我提供了两者。首先，一个天使雕像出现在<strong class="kl ir">中。obj </strong>格式<a class="ae lf" href="https://github.com/IvanNik17/python-3d-analysis-libraries/tree/main/mesh" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir">这里</strong> </a>和点云在<strong class="kl ir">。txt </strong>格式<a class="ae lf" href="https://github.com/IvanNik17/python-3d-analysis-libraries/tree/main/point_cloud" rel="noopener ugc nofollow" target="_blank">T10】此处T12】。该物体已在许多文章[1]、[2]、[3]中介绍，也可作为大型摄影测量数据集[4]、[5]的一部分下载。第二，在<strong class="kl ir">中包含天气数据的时间序列数据集。csv </strong>格式</a><a class="ae lf" href="https://github.com/IvanNik17/python-3d-analysis-libraries/tree/main/dataset" rel="noopener ugc nofollow" target="_blank"> <strong class="kl ir">此处</strong> </a>。气象元数据被用作检测监控录像中长期异常的研究的一部分[6]。这些数据是使用<a class="ae lf" href="https://confluence.govcloud.dk/display/FDAPI" rel="noopener ugc nofollow" target="_blank">丹麦气象研究所(DMI) </a>提供的开源API提取的，并且<a class="ae lf" href="https://www.dmi.dk/friedata/guides-til-frie-data/vilkar-for-brug-af-data/" rel="noopener ugc nofollow" target="_blank">可以在商业和非商业、公共和私人项目中免费使用</a>。为了使用数据集，熊猫是必需的。它默认出现在Anaconda安装中，可以通过调用<code class="fe ms mt mu mv b">conda install pandas</code>轻松安装。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="8a8b" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">使用Open3D进行可视化</h1><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/760f225d141b1281a2b4482e2f5b1017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/1*RlHReMjUNHCor-F7eizkaQ.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">Open3D结果|作者图片</p></figure><p id="e957" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi mh translated">Python中发展最快的3D处理库之一。它构建于C++之上，但公开了C++和Python的所有功能，使其快速、灵活且健壮。该库的目标是3D处理，就像OpenCV是计算机视觉一样——一站式解决方案，包含您需要的一切，并可以轻松连接到其他库。例如PyTorch和Tensorflow，用于通过名为<a class="ae lf" href="http://www.open3d.org/docs/release/open3d_ml.html" rel="noopener ugc nofollow" target="_blank"> Open3D-ML </a>的扩展来构建深度学习网络，以处理点云、体素和深度图。</p><p id="c5f5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">安装非常简单，提供了下载选择器来定制您的安装首选项。该库也可以在Linux、Mac和Windows上开箱即用，并支持从3.6开始的Python版本。</p><p id="d4c9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">如果您正在使用Anaconda，我们可以首先创建一个新环境<code class="fe ms mt mu mv b">open3d_env</code>，然后安装Open3D。在我的例子中，我直接指定我希望在新环境中使用Python 3.8，但是您可以选择任何支持的版本。</p><pre class="lg lh li lj gt nw mv nx ny aw nz bi"><span id="e3ef" class="oa ne iq mv b gy ob oc l od oe">conda create -n open3d_env python=3.8<br/>conda activate open3d_env<br/>pip install open3d</span></pre><p id="0780" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦安装完毕，我们可以通过导入它<code class="fe ms mt mu mv b">import open3d as o3d</code>并调用<code class="fe ms mt mu mv b">print(o3d.__version__)</code>来检查一切是否正常。如果没有错误，我们就可以开始了！</p><p id="fe20" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">Open3d的io模块包含加载网格<code class="fe ms mt mu mv b">o3d.io.read_triangle_mesh</code>和点云<code class="fe ms mt mu mv b">o3d.io.read_point_cloud</code>的便捷函数。如果网格有纹理和材质，那么加载它们的更简单的方法是在调用读取网格时通过设置标志<code class="fe ms mt mu mv b">enable_post_processing = True</code>来启用网格后处理。在我们的例子中，读取天使雕像网格的代码是:</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9f85" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">在我们的例子中，我也调用numpy，因为默认情况下，Open3D结构不能被查看和打印，但是它们可以很容易地转换成numpy数组，如上面的代码所示。可以轻松访问导入网格的所有信息。</p><p id="1c9c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">为了可视化导入的网格，我们需要首先创建一个<code class="fe ms mt mu mv b">Visualizer()</code>对象，它将包含所有的3D对象、灯光和摄像机，并将监听键盘、鼠标和动画回调。下面的代码设置场景，创建一个窗口，并导入所有的3D对象。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="08c4" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">我们可以使用<code class="fe ms mt mu mv b">create_window</code>函数在visualizer中创建一个新窗口，它接受名称、宽度、高度以及在屏幕上的位置的输入。然后我们可以通过调用<code class="fe ms mt mu mv b">add_geometry</code>方法将任何3D几何图形添加到可视化工具中。在我们的例子中，我们还通过调用<code class="fe ms mt mu mv b">create_sphere</code>创建了一个原始对象——围绕天使雕像的球体。我们还可以创建其他基本体，如立方体、圆柱体、圆环体等。我们可以通过调用<code class="fe ms mt mu mv b">compute_vertex_normals()</code>或<code class="fe ms mt mu mv b">compute_triangle_normals()</code>来计算特定3D对象的法线。最后，我们可以通过直接在对象上调用<code class="fe ms mt mu mv b">translate()</code>方法来翻译对象。</p><p id="a11e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">接下来，我们设置希望在更新周期中运行的任何回调函数。在我们的例子中，我们想要创建一个动画，所以我们调用<code class="fe ms mt mu mv b">register_animation_callback(rotate_around)</code>，其中rotate_around是函数的名称。键盘和鼠标回调也可以做同样的事情。该函数如下所示。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c60c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">在这个函数中，我们首先通过调用<code class="fe ms mt mu mv b">get_rotation_matrix_from_xyz</code>为天使网格和球体创建旋转矩阵，并给它每个方向所需的旋转值，用弧度指定。然后，我们在每个网格上调用<code class="fe ms mt mu mv b">rotate</code>方法，创建3D旋转矩阵和一个中心，这是它们将绕其旋转的枢轴。最后，为了能够可视化这些变化，我们为每个网格调用<code class="fe ms mt mu mv b">update_geometry()</code>方法，并调用<code class="fe ms mt mu mv b">update_renderer()</code>来更新整个可视化器。完整的代码如下所示。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="85f5" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">Open3D主要针对网格和3D点云的分析和操作，但我们也可以在3D中可视化多维数据。我们可以通过首先从天气数据集中提取感兴趣的列来证明这一点。出于我们的目的，我们将查看“温度”和“湿度”列。由于数据包含时间戳，我们使用这些时间戳来提取每个天气读数的月份。我们最后将这三列转换成一个numpy数组，因为Open3D可以将数组转换成点云对象。代码如下。</p><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/9649049c8440d04265aaed8d64f4851c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*YcciNmQy24XS5Gf3bMedUg.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">按月计算的温度和湿度|图片由作者提供</p></figure><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8899" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦我们有了数据，我们可以通过在Open3D中初始化一个点云来可视化它。为了更好地观察这些点，我们也可以通过调用<code class="fe ms mt mu mv b">get_view_control()</code>来旋转摄像机。下面给出了可视化的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="b351" class="nd ne iq bd nf ng oi ni nj nk oj nm nn jw ok jx np jz ol ka nr kc om kd nt nu bi translated">使用Trimesh进行可视化</h1><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/89fbc4af15cc99631b5a9accc05e867f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/1*TTIrEj8nC67DF_zFgQ70-w.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">Trimesh结果|作者图片</p></figure><p id="ada3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi mh translated">是一个纯粹基于Python的库，用于网格和点云的加载、分析和可视化。它广泛用于在统计分析和机器学习之前对3D资产进行预处理。以及像Cura这样的3D打印应用的一部分。它也是我们将要讨论的其他库的基础，比如Pyrender和Vedo。</p><p id="8795" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">Trimesh在基础库中不包含可视化部分，但使用可选的<a class="ae lf" href="http://pyglet.org/" rel="noopener ugc nofollow" target="_blank"> pyglet </a>游戏和交互式应用程序库作为基础。它在其基础上实现了可视化、回调和操作特性，并包含了大量开箱即用的内置可视化交互。它还可以在Linux、Mac和Windows上运行，没有任何问题或解决方法。它也可以用于Python 2和Python 3。</p><p id="cdee" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">对于安装，唯一需要的必备库是numpy。同样，我们使用Anaconda环境来创建一个环境，并在其中安装所有东西。同样，我们安装pyglet来可视化网格。如果只需要分析和操纵网格，可以跳过最后一行。</p><pre class="lg lh li lj gt nw mv nx ny aw nz bi"><span id="8a24" class="oa ne iq mv b gy ob oc l od oe">conda create -n trimesh_env python=3.8<br/>conda activate trimesh_env<br/>conda install numpy<br/>pip install trimesh</span><span id="8555" class="oa ne iq mv b gy on oc l od oe">pip install pyglet</span></pre><p id="dc5d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦所有东西都安装好了，我们就可以通过调用<code class="fe ms mt mu mv b">import trimesh</code>来检查所有东西是否工作。如果我们想要从trimesh获取所有消息到控制台，那么我们需要调用<code class="fe ms mt mu mv b">trimesh.util.attach_to_log()</code>,在调用trimesh函数之后会打印出一个详细的输出。这在调试阶段非常有用。</p><p id="672e" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">加载网格是通过调用<code class="fe ms mt mu mv b">trimesh.load()</code>方法来完成的，带有可选的file_type输入，其中可以明确说明具体的网格类型。一旦网格被加载，就可以直接提取很多信息——例如，它是否防水<code class="fe ms mt mu mv b">mesh.is_watertight</code>，它的凸包<code class="fe ms mt mu mv b">mesh.convex_hull</code>，体积<code class="fe ms mt mu mv b">mesh.volume</code>等。如果网格由多个对象组成，可以通过调用<code class="fe ms mt mu mv b">mesh.split()</code>将它们分割成多个网格。下面给出了加载3D网格、创建球体图元和设置场景的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="70c9" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">通过调用<code class="fe ms mt mu mv b">trimesh.primitives</code>，我们可以访问不同的图元，如盒子、胶囊和挤压，以及从点和面的数组构建网格。在我们的例子中，我们创建一个球体并给它一个半径。我们设置了一个包含天使网格和球体的场景。作为场景的一部分，每个节点都是独立的节点。最后，我们显示场景并指定一个名为rotate_objects的回调函数。每次场景更新时都会调用该函数。它在下面的代码中给出。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d80d" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">由于Trimesh不包含自动更新的转换函数，我们需要<code class="fe ms mt mu mv b">import time</code>并使用time.time()来获得一个增量时间变化，我们可以用它来更新旋转。我们首先使用numpy创建一个空的齐次变换矩阵来改变球体的位置。我们只需要改变矩阵的平移部分，我们使用的想法是，如果我们使用正弦和余弦函数改变X和Z位置，我们将实现圆周运动。</p><p id="4bd1" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">我们使用内置函数从Trimesh <code class="fe ms mt mu mv b">trimesh.tranformations.rotation_matrix()</code>生成一个旋转矩阵，它使用角度和轴作为输入并返回一个旋转矩阵。我们选择代表网格和球体的节点，方法是根据它们添加到场景中的时间来选择它们。如果我们有多个对象，我们可以根据它们在场景中的名称来获取它们，或者在字典中保存一个引用，指示哪个对象包含哪个节点。我们最后从场景中调用update函数，并给它我们想要更新的节点，以及转换矩阵。完整的代码可以在下面看到。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="f576" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">Trimesh与Open3D一样，是针对网格和点云的分析和操作，但其渲染潜力可以用于统计可视化。我们将通过创建一个3D柱形图来演示这一点，该柱形图用于可视化气象数据集中每个月的平均“温度”数据。为此，我们首先使用Pandas的<code class="fe ms mt mu mv b">groupby</code>函数计算每月的平均温度，并根据日期-时间列的月频率对数据进行分组。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/74ad97a19423b603107d2f3f64fedf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*tE19d5RyoLde8q8wHe3qCQ.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">各月平均气温|图片由作者提供</p></figure><p id="c87c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦我们提取了每月的平均温度读数，我们就使用trimesh圆柱体对象来表示读数。这种表现形式既有圆柱体的高度，也有从红色到蓝色的颜色梯度，红色代表最高温度，蓝色代表最低温度。为了生成色图，我们使用<code class="fe ms mt mu mv b">trimesh.visual.interpolate()</code>函数来生成标准化的颜色值。由于trimesh中的圆柱体从它们的中心开始缩放，我们也基于平均温度将它们向下移动，因此我们得到底部对齐的柱形图。下面给出了可视化的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="bee3" class="nd ne iq bd nf ng oi ni nj nk oj nm nn jw ok jx np jz ol ka nr kc om kd nt nu bi translated">使用PyVista进行可视化</h1><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/fd9f7fbba5a7a631ebcf7a4c2003a6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/1*Lm_Xbh29DbvjJ3x_yv4GlQ.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">PyVista结果|作者图片</p></figure><p id="3ea7" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi mh translated"><span class="l mi mj mk bm ml mm mn mo mp di"> P </span> <a class="ae lf" href="https://docs.pyvista.org/index.html" rel="noopener ugc nofollow" target="_blank"> yVista </a>是一个强大的功能齐全的绘图和网格分析库，它建立在可视化工具包(VTK)之上。它简化了VTK接口，使得对不同函数的调用更容易、更pythonic化。它可以用于点云和网格，它使用OpenGL，使其易于创建平滑的可视化和动画。该库有大量的示例和教程，从简单的可视化到复杂的分析和转换工具，如切片、重采样、点云表面重建、网格平滑、光线跟踪、体素化等。</p><p id="ad77" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">该库运行在Linux、Mac和Windows上，需要Python 3.7+。因为它是建立在VTK之上的，所以它要求至少与numpy一起安装。安装非常简单，可以通过pip或Anaconda完成。对于我们的用例，我们再次创建一个anaconda环境，并使用Anaconda来安装库。这还会安装所有依赖项。</p><pre class="lg lh li lj gt nw mv nx ny aw nz bi"><span id="71fd" class="oa ne iq mv b gy ob oc l od oe">conda create -n pyvista_env python=3.8<br/>conda activate pyvista_env<br/>conda install numpy<br/>conda install -c conda-forge pyvista</span></pre><p id="f0c2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦安装了库，可以通过首先导入它<code class="fe ms mt mu mv b">import pyvista as pv</code>然后调用<code class="fe ms mt mu mv b">pv.demos.plot_wave()</code>来测试它。如果带有正弦波的绘图窗口开始，那么库已经成功安装。</p><p id="b2df" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">通过连接到<a class="ae lf" href="https://github.com/nschloe/meshio" rel="noopener ugc nofollow" target="_blank"> meshio </a>可以很容易地导入网格和点云。为了导入它们，我们可以调用<code class="fe ms mt mu mv b">pyvista.read()</code>，为了加载网格的纹理，我们可以调用<code class="fe ms mt mu mv b">pyvista.read_texture()</code>。一旦网格被加载，额外的信息可以从中提取，如边，网格质量，顶点之间的距离等。它也可以很容易地重新采样。</p><p id="a2d2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">这里我们需要提到的重要一点是，如果我们想要使用PyVista实现动画或实现键盘、鼠标或UI交互的非阻塞可视化，我们需要安装<a class="ae lf" href="https://qtdocs.pyvista.org/" rel="noopener ugc nofollow" target="_blank"> pyvistaqt </a>，它用qt功能扩展了PyVista。可以通过调用以下命令轻松安装附加库:</p><p id="ee8c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated"><code class="fe ms mt mu mv b">conda install -c conda-forge pyvistaqt</code></p><p id="f2e2" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">完成后，我们可以通过<code class="fe ms mt mu mv b">from pyvistaqt import BackgroundPlotter</code>导入，使用后台绘图仪结构创建非阻塞图。如果你不需要非阻塞可视化，那么直接调用<code class="fe ms mt mu mv b">pyvista.Plotter</code>并使用它就足够了。下面给出了加载天使网格和纹理、创建背景绘图仪、旋转球体和光源的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cee3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦我们创建了<code class="fe ms mt mu mv b">BackgroundPlotter</code>，我们就可以设置它的大小、背景等。我们改变camera_position，使其停留在<em class="kk"> xy </em>轴。这也可以通过在X、Y、Z以及旋转或向上方向上设置一组摄像机位置来实现。我们还设置了相机的剪辑范围，因为有时对象会被缺省值剪辑。我们通过给它一个半径和中心位置来创建一个球体。其他图元也可以用同样的方法创建——圆柱体、箭头、平面、长方体、圆锥体、圆盘等。最后，我们通过调用<code class="fe ms mt mu mv b">pyvista.Light</code>创建一个点光源，默认是创建一个点光源，但是我们可以隐式地创建平行光、聚光灯等。我们设置灯光的颜色、位置和焦点。接下来，我们将所有这些对象添加到绘图仪，并创建一个回调监听器来更新场景和生成简单的动画。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8bc6" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">这里我们需要指明两个要点。使用<code class="fe ms mt mu mv b">add_callback</code>创建回调时，强烈建议明确指定更新周期的间隔。第二件事是当使用pyvistaqt绘图仪时，总是在show函数后调用<code class="fe ms mt mu mv b">app.exec_()</code>，因为这确保了创建的绘图仪窗口不会在一次迭代后关闭。最后，回调<code class="fe ms mt mu mv b">update_scene()</code>中调用的函数如下所示。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="4e21" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">在这里，我们使用PyVista提供的简化旋转函数在网格和球体的每个轴<code class="fe ms mt mu mv b">rotate_y</code>上旋转，同时调用<code class="fe ms mt mu mv b">implace=True</code>来确保旋转将直接设置到网格。由于灯光不包含直接旋转的方法，我们根据<code class="fe ms mt mu mv b">sphere.center</code>的位置更新它的位置。最后，我们更新整个绘图仪。PyVista可视化的完整代码可以在下面看到。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0de8" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">PyVista致力于3D数据的分析和可视化，这使得它成为生成多维和时序数据集可视化的完美库。我们将通过建立在前一章中使用Open3D创建的简单可视化来演示这一点。为此，我们从天气数据集中提取相同的列——“温度”和“湿度”,并从日期时间信息中生成“月份”列。完成初始设置后，我们可以直接使用PyVista创建3D绘图。PyVista有许多与2D绘图库类似的功能，如matplotlib和seaborn，其中的值可以直接用于创建伪彩色，标签可以直接添加到点。下面的代码给出了最初的熊猫操作。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="lg lh li lj gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi mq"><img src="../Images/80de4264e1aa627def1edb5228be60fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Ceyarlx0Z4QAF9tTV1L1RQ.gif"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">通过3D网格和图例按月显示温度和湿度|图片由作者提供</p></figure><p id="927c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦pandas数据经过预处理并提取了所需的信息，我们就通过调用<code class="fe ms mt mu mv b">pyvista.add_points</code>建立一个3D点云对象来包含所选的数据集列。该函数也可以直接获取一个<code class="fe ms mt mu mv b">scalars</code>字段，该字段用于给点着色并创建一个图例。然后，我们设置标签对象，并在每个月的级别上给它们一个位置。我们最后初始化一个3D网格，命名轴并创建一个简单的回调函数来旋转摄像机。可视化和回调函数的代码如下所示。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="af35" class="nd ne iq bd nf ng oi ni nj nk oj nm nn jw ok jx np jz ol ka nr kc om kd nt nu bi translated">使用视频进行可视化</h1><figure class="lg lh li lj gt ll gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/8c540725460a18ef63e003fec29ce5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/1*rWsjyb-k9ietkdrq7Z4vvg.gif"/></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">视频结果|作者图片</p></figure><p id="1703" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi mh translated"><span class="l mi mj mk bm ml mm mn mo mp di">V</span>T9】edo(或V3do)是一个用于科学分析和可视化3D对象的Python库。它可用于绘制1d、2d和3d数据、点云、网格以及体积可视化。Vedo使用Trimesh作为一些网格和点云处理、导入/导出和生成的后端，并通过提供大量科学指导的功能来构建它。它可以生成直接导入Latex的矢量插图和可视化，并用于生成物理模拟、深度学习层概述以及机械和CAD级别的切片和图表。</p><p id="5ee3" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">Vedo基于VTK，安装前需要it和numpy在场。它可以在Linux、Mac和Windows上运行，并且需要Python 3.5及更高版本。对于我们的用例，我们再次创建一个anaconda环境，并使用Anaconda来安装库。</p><pre class="lg lh li lj gt nw mv nx ny aw nz bi"><span id="8b0b" class="oa ne iq mv b gy ob oc l od oe">conda create -n vedo_env python=3.8<br/>conda activate vedo_env<br/>conda install numpy<br/>conda install -c conda-forge vedo</span></pre><p id="9eee" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">一旦所有东西都安装好了，我们可以通过调用<code class="fe ms mt mu mv b">import vedo</code>然后可视化一个原语<code class="fe ms mt mu mv b">vedo.Sphere().show(axis=1).close()</code>来测试安装。这只是生成一个球体的简写，直接用轴显示，然后设置一旦我们关闭窗口程序就结束。如果我们看到一个旁边有轴的球体，一切都按预期运行。</p><p id="5512" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">Vedo可以在CLI界面中直接调用<code class="fe ms mt mu mv b">vedo path_to_your_3D_object</code>来运行。一旦一个窗口被打开，就有许多键和组合可以被按下以改变可视化，连同鼠标旋转、平移和缩放。最后，通过调用<code class="fe ms mt mu mv b">vedo --convert path_input_3D_object --to path_output_3d_object</code>或者直接在<code class="fe ms mt mu mv b">--to</code>后添加需要的文件格式，可以直接调用Vedo进行文件格式转换。</p><p id="5ce0" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">使用<code class="fe ms mt mu mv b">vedo.load(path_to_3d_object)</code>加载网格和点云很简单。如果网格有纹理，需要使用<code class="fe ms mt mu mv b">mesh.texture(path_to_texture)</code>将其额外加载到创建的3D对象中。一旦加载了网格，就可以进行许多快速交互和分析步骤。一个切割工具，通过调用<code class="fe ms mt mu mv b">addCutterTool(your_mesh, mode = "sphere")</code>，使用“饼干刀”形状切割网格的部分——球体、平面、盒子。另一个是徒手切割，可以使用<code class="fe ms mt mu mv b">FreeHandCutPlotter(your_mesh)</code>手动分割网格。网格上的其他操作也可以完成——比如通过调用<code class="fe ms mt mu mv b">your_mesh.fillHoles(size=size_to_fill)</code>来填充孔洞。例如，通过调用<code class="fe ms mt mu mv b">vedo.Sphere</code>或<code class="fe ms mt mu mv b">vedo.Box</code>也可以很容易地生成原语。下面给出了加载天使网格和生成图元的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0e2c" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">网格的材料，以及它们的属性，如颜色、金属和粗糙度，可以通过调用3D对象的<code class="fe ms mt mu mv b">lighting()</code>方法来设置。有多种预制样式可供选择，包括“默认”、“金属”、“塑料”、“闪亮”、“光滑”，还可以定制。我们还创建了一个盒子作为天使网格停留的表面，并投射阴影，以及一个球体。我们可以通过直接调用<code class="fe ms mt mu mv b">rotate</code>和<code class="fe ms mt mu mv b">translate</code>或者调用<code class="fe ms mt mu mv b">x(), y(), z()</code>方法来移动对象。一旦所有的3D对象被创建和定位，我们制作两个灯，并设置绘图仪对象来可视化一切。这方面的代码如下所示。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8c1a" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">我们创建了两个点光源——一个白色的，强度较小的作为环境光，另一个强度较大的，蓝色的，随着球体移动。我们在视频设置中设置了我们想要实现的交互性。我们创建一个绘图仪，并通过调用<code class="fe ms mt mu mv b">plotter.addShadows()</code>指定生成阴影。最后，我们调用show方法，以及所有想要显示的3D对象和灯光。如果需要生成大量的对象，我们也可以将它们添加为一个列表。我们将交互性设置为0，就像我使用的视频版本一样，如果不这样做，动画有时会无法运行。最后，由于维多是建立在VTK的基础上，它使用了它的事件系统。与PyVista的不同之处在于，Vedo没有在每次更新循环中运行的隐式定时器功能。这就是为什么我们需要通过调用<code class="fe ms mt mu mv b">plt.timerCallback('create', dt=delta_time_for_updating)</code>首先创建我们的定时器函数。一旦创建完成，我们就可以给这个定时器添加一个回调函数。该函数将在每次调用定时器时运行。请注意，要使回调起作用，需要将“计时器”名称写成如图所示。下面给出了功能<code class="fe ms mt mu mv b">rotate_object</code>。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="e194" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">在函数中，我们再次使用一种速记方法<code class="fe ms mt mu mv b">rotateY</code>来旋转天使雕像和球体。在该方法中，我们还可以设置对象旋转的支点。由于灯光不包含旋转方法，我们采用球体的位置，并直接设置灯光位置。我们最后调用<code class="fe ms mt mu mv b">plt.render()</code>函数，这样渲染器就可以更新了。下面是完整的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="73e6" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">像PyVista一样，Vedo是一个专门的库，用于在3D中可视化数据和数据集。它扩展了PyVista中的许多功能，只需对数据调用函数就可以轻松地创建统计分析可视化。它还有一个更好的添加标签和文本、科学符号甚至LateX的实现。Vedo和PyVista也可以利用VTK，在渲染的基础上创建多个子图和渲染。我们将通过为“温度”和“湿度”数据创建多个子图以及数据密度图，并将它们与直方图可视化相结合来探索这一点。我们准备数据的方式与前面的例子相同——使用pandas初始提取列，并创建month和month name列。代码如下所示。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="lg lh li lj gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi oo"><img src="../Images/1889d0870e8889d6872b12f33bad24d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*njYjKBocdtBmD4Fp57wJ3g.gif"/></div></div><p class="lx ly gj gh gi lz ma bd b be z dk translated">温度和湿度密度图，以及作者提供的3D直方图|图像</p></figure><p id="9885" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">数据经过预处理后，可以通过首先调用Vedo <code class="fe ms mt mu mv b">Plotter</code>对象并设置将要创建的子图数量来创建可视化。在这里，我们还通过设置<code class="fe ms mt mu mv b">sharecam = 0</code>来指定每个子图都有一个单独的摄像机。这使得可视化更加沉重，但是每个子图形都可以单独操作。然后对于每个月，我们用3D轴创建一个图，我们调用<code class="fe ms mt mu mv b">.density()</code>函数来计算点密度体积，然后用一个标量条叠加。对于最后一个子图，我们将<code class="fe ms mt mu mv b">vedo.pyplot.histogram</code>与数据集、可视化模式和轴名称一起调用。下面给出了可视化的代码。</p><figure class="lg lh li lj gt ll"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="6ddb" class="nd ne iq bd nf ng oi ni nj nk oj nm nn jw ok jx np jz ol ka nr kc om kd nt nu bi translated">结论</h1><p id="7171" class="pw-post-body-paragraph ki kj iq kl b km op jr ko kp oq ju kr me or ku kv mf os ky kz mg ot lc ld le ij bi mh translated"><span class="l mi mj mk bm ml mm mn mo mp di"> W </span>当我开始写这篇文章时，它被计划为只是一个部分，然后去不同的库分析和操作三维网格和统计数据。我决定将这篇文章分成两部分，这样我可以更好地解释这些库的细节。这一点很重要，因为无论您想做什么——纯粹的结果可视化[1，6],从网格和点云生成3D特征[2],或者创建高清渲染[3],了解Python中可用于3D任务的工具都很重要。天使雕像可以自由地用于可视化和实验，以及大量其他使用SfM从[4]和[5]重建的3D对象。更多关于天气时间序列数据集的信息可以在<a class="ae lf" href="https://www.kaggle.com/datasets/ivannikolov/longterm-thermal-drift-dataset" rel="noopener ugc nofollow" target="_blank">这里</a>阅读。</p><p id="ef61" class="pw-post-body-paragraph ki kj iq kl b km kn jr ko kp kq ju kr me kt ku kv mf kx ky kz mg lb lc ld le ij bi translated">接下来的第2部分将关注接下来的4个可视化库— <a class="ae lf" href="https://github.com/mmatl/pyrender" rel="noopener ugc nofollow" target="_blank"> Pyrender </a>、<a class="ae lf" href="https://plotoptix.rnd.team/" rel="noopener ugc nofollow" target="_blank"> PlotOptiX </a>、<a class="ae lf" href="https://polyscope.run/py/" rel="noopener ugc nofollow" target="_blank"> Polyscope </a>和<a class="ae lf" href="https://simple-3dviz.com/" rel="noopener ugc nofollow" target="_blank"> Simple-3dviz </a>。从这些，我们将把重点放在PlotOptiX和Pyrender上，它们可以产生光线跟踪结果(PlotOptiX)或高度动态的照明场景(Pyrender)。我们还将讨论Polyscope和Simple-3dviz，它们是轻量级、简单易用的3D可视化工具，可用于日常使用和科学数据演示。</p><h1 id="5ab6" class="nd ne iq bd nf ng oi ni nj nk oj nm nn jw ok jx np jz ol ka nr kc om kd nt nu bi translated"><strong class="ak">参考文献</strong></h1><ol class=""><li id="33e0" class="ou ov iq kl b km op kp oq me ow mf ox mg oy le oz pa pb pc bi translated"><strong class="kl ir">尼科洛夫，I. </strong>，&amp;麦德森，C. (2016年10月)。在不同的拍摄条件下，对motion 3D重建软件的近距离结构进行基准测试。在<em class="kk">欧洲-地中海会议</em>(第15-26页)。施普林格、湛；【https://doi.org/10.1007/978-3-319-48496-9_2 T4】</li><li id="dcca" class="ou ov iq kl b km pd kp pe me pf mf pg mg ph le oz pa pb pc bi translated"><strong class="kl ir">尼科洛夫，I. </strong>，&amp;麦德森，C. (2020)。粗暴还是吵闹？SfM重建中噪声估计的度量。<em class="kk">传感器</em>、<em class="kk"> 20 </em> (19)、5725；<a class="ae lf" href="https://doi.org/10.3390/s20195725" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.3390/s20195725</a></li><li id="ac47" class="ou ov iq kl b km pd kp pe me pf mf pg mg ph le oz pa pb pc bi translated"><strong class="kl ir">尼科洛夫，I. A. </strong>，&amp;麦德森，C. B. (2019，2月)。测试SfM图像捕获配置的交互式环境。在<em class="kk">第十四届计算机视觉、成像和计算机图形学理论与应用国际联合会议(Visigrapp 2019) </em>(第317–322页)。科学出版社数字图书馆；<a class="ae lf" href="https://doi.org/10.5220/0007566703170322" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.5220/0007566703170322</a></li><li id="cba0" class="ou ov iq kl b km pd kp pe me pf mf pg mg ph le oz pa pb pc bi translated"><strong class="kl ir">尼科洛夫，我.</strong>；Madsen，C. (2020)，“GGG基准SfM:在不同捕获条件下对近距离SfM软件性能进行基准测试的数据集”，门德利数据，第4版；<a class="ae lf" href="https://doi.org/10.17632/bzxk2n78s9.4" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.17632/bzxk2n78s9.4</a></li><li id="0afb" class="ou ov iq kl b km pd kp pe me pf mf pg mg ph le oz pa pb pc bi translated"><strong class="kl ir">尼科洛夫一世</strong>；麦德森，C. (2020)，“GGG——粗糙还是嘈杂？SfM重建中的噪声检测指标”，门德利数据，V2；<a class="ae lf" href="https://doi.org/10.17632/xtv5y29xvz.2" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.17632/xtv5y29xvz.2</a></li><li id="a1d4" class="ou ov iq kl b km pd kp pe me pf mf pg mg ph le oz pa pb pc bi translated"><strong class="kl ir"> Nikolov，I. </strong>，Philipsen，M. P .，Liu，j .，Dueholm，J. V .，Johansen，A. S .，Nasrollahi，k .，&amp; Moeslund，T. B. (2021)。漂移中的季节:研究概念漂移的长期热成像数据集。在<em class="kk">第三十五届神经信息处理系统会议上；</em><a class="ae lf" href="https://openreview.net/forum?id=LjjqegBNtPi" rel="noopener ugc nofollow" target="_blank">https://openreview.net/forum?id=LjjqegBNtPi</a></li></ol></div></div>    
</body>
</html>