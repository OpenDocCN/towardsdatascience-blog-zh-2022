<html>
<head>
<title>Data Science Tutorials: Training a Random Forest in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学教程:在 R 中训练随机森林</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-science-tutorials-training-a-random-forest-in-r-a883cc1bacd1#2022-02-15">https://towardsdatascience.com/data-science-tutorials-training-a-random-forest-in-r-a883cc1bacd1#2022-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eab3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用 R 语言训练随机森林</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06e77225dbb230ea972343a2f2b7efc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JfV41jzhVdj9yGOq"/></div></div></figure><p id="179f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">【这是我在数据科学教程系列中的第一篇帖子——请继续关注，了解更多关于如何用 R 或 Python 训练不同算法的信息！] </em></p><p id="a5c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lr translated"><span class="l ls lt lu bm lv lw lx ly lz di"> R </span>随机森林是机器学习中使用最广泛的算法之一。由于它们处理非线性模式的能力和可解释性，它们比其他模型有几个优点。</p><p id="2ed9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管它们正受到其他基于树的模型(如 boosting 算法)的挑战，但在构建数据科学项目时，它们仍然是值得考虑的有效选项，而且这种范式预计不会在不久的将来发生变化。</p><p id="faa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而在过去，你有两种选择:等待你的软件提供商(如 SAS 或 IBM)发布新版本，或者自己编写原始算法。幸运的是，随着开源语言及其库的广泛采用，您现在可以顺利地用 Python 或 r 训练随机森林。您可以随意使用多个<em class="lq">API</em>或函数，它们可以用一行代码训练其中一个模型。</p><p id="d645" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将做一个关于如何使用两个库(<em class="lq"> randomForest </em>和<em class="lq"> ranger </em>)在<em class="lq"> R </em>中训练随机森林的教程——在这个教程中，我们还将讨论为什么我们应该在这个训练过程中依靠<em class="lq"> ranger </em>库，以及我们这样做的标准。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a51d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">加载数据</h1><p id="7cd3" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">对于我们的随机森林用例，我们将使用<a class="ae ne" href="https://www.kaggle.com/hmavrodiev/london-bike-sharing-dataset" rel="noopener ugc nofollow" target="_blank">伦敦自行车共享数据集</a>-该数据集包含伦敦自行车共享的自行车需求信息-我们有每天和每小时的汇总数据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7bcb130d9114497ce50ba5a00661f432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*KDnukYehYzzOcI8CUzJpRw.png"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">伦敦自行车共享数据集的第一行</p></figure><p id="d516" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">列<em class="lq"> cnt </em>包含新自行车份额的计数。预览中显示的其他变量与天气数据相关，包括温度、湿度、风速等。</p><p id="f48a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的用例中，我们希望使用当天的大气数据和元数据来预测骑自行车的次数——例如，如果特定的一天是假日或周末。为了简单起见，我们不会在这个过程中执行任何特性工程。</p><p id="3fb7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下命令使我们能够使用 R 读取 csv 文件:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="100e" class="np mi it nl b gy nq nr l ns nt">london_bike &lt;- read.csv(‘./london_merged.csv’)</span></pre><p id="f913" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们将加载本教程所需的所有库:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d58b" class="np mi it nl b gy nq nr l ns nt">library(dplyr)<br/>library(randomForest) <br/>library(ranger)<br/>library(Metrics)</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9f3f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">分为训练和测试</h1><p id="b727" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">之后，我们将使用一个函数来拆分数据训练和测试样本，留下 20%的数据作为性能评估的维持集:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="3191" class="np mi it nl b gy nq nr l ns nt"># Splitting into train and test</span><span id="c2aa" class="np mi it nl b gy nu nr l ns nt">train_test_split &lt;- function(data, percentage) {<br/> <br/> data_with_row_id &lt;- data %&gt;% <br/> mutate(id = row_number())<br/> <br/> set.seed(1234)<br/> training_data &lt;- data_with_row_id %&gt;%<br/> sample_frac(percentage)<br/> test_data &lt;- anti_join(<br/> data_with_row_id,<br/> training_data,<br/> by=’id’<br/> )<br/> <br/> training_data$id &lt;- NULL<br/> test_data$id &lt;- NULL<br/> <br/> return (list(training_data, test_data))<br/>}</span><span id="e9bb" class="np mi it nl b gy nu nr l ns nt"># Keeping 80% for the training set</span><span id="934a" class="np mi it nl b gy nu nr l ns nt">training_data &lt;- train_test_split(london_bike, 0.8)[[1]]<br/>test_data &lt;- train_test_split(london_bike, 0.8)[[2]]</span></pre><p id="a9d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们剩下 13.931 个时间位置(正如我们在预览中看到的，每行代表特定小时的数据)用于训练。如果您愿意，也可以使用超时保持集。不要随机分割数据，而是使用一个连续的时间段(数据集的最后几天)作为测试集——如果我们将这个问题视为时间序列问题，这将更有意义。</p><p id="8c7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了测试我们算法的目的(评估量化性能)，我们将使用 3483 个时间位置来测试我们的随机森林。请记住，我们将以两种方式评估我们的算法:</p><ul class=""><li id="46ca" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">使用均方根误差-这将映射出算法的预期误差。</li><li id="687f" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">执行时间——对于每个库，我们将对其执行进行计时，并了解库之间的差异。</li></ul><p id="c3cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以从数据集中提取要素和目标的子集-请记住，在本教程中我们不会进行要素工程，而是按原样使用变量:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="ef33" class="np mi it nl b gy nq nr l ns nt">training_data &lt;- training_data[,c('t1','t2','hum',<br/>                                  'wind_speed','weather_code',<br/>                                  'is_holiday','is_weekend',<br/>                                  'season', 'cnt')]<br/>test_data &lt;- test_data[,c('t1','t2','hum',<br/>                          'wind_speed','weather_code',<br/>                          'is_holiday','is_weekend',<br/>                          'season', 'cnt')]</span></pre><p id="54c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如问题公式中所述，我们将希望预测在特定的小时和天将使用多少辆自行车—这意味着我们的目标将是包含相同值的列"<em class="lq">CNT</em>"—这是上面子集中的最后一列。</p><p id="7570" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">准备好数据后，让我们在 R 中实现两个不同的随机森林— <em class="lq"> ranger </em>和<em class="lq"> randomForest。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="006d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">使用 randomForest 库</h1><p id="585c" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">首先，我们将使用<a class="ae ne" href="https://cran.r-project.org/web/packages/randomForest/randomForest.pdf" rel="noopener ugc nofollow" target="_blank"><em class="lq">randomForest</em></a><em class="lq"/>库。这是最初的<a class="ae ne" href="https://www.stat.berkeley.edu/~breiman/randomforest2001.pdf" rel="noopener ugc nofollow" target="_blank"> Leo Breiman 的</a>论文的第一批开源实现之一。</p><p id="5487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要任何复杂的命令来训练我们的算法吗？不要！我们可以使用(几乎)一行代码训练一个随机森林:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="efe5" class="np mi it nl b gy nq nr l ns nt">set.seed(1234)<br/>rf &lt;- randomForest(formula = cnt ~ ., <br/>                   data = training_data,<br/>                   ntree = 100)</span></pre><p id="0e5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我正在使用<em class="lq">种子</em> 1234 使这些结果可复制。函数<em class="lq"> randomForest </em>接受一些参数:</p><ul class=""><li id="0b76" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated"><em class="lq">公式</em>，带目标和特征的参数，用于训练过程。"<em class="lq"> cnt ~ "</em>意味着我们希望使用数据帧中的所有其他列来预测变量<em class="lq"> cnt </em>。如果我们只想使用特定的变量作为特征，我们需要明确地命名它们，例如:<em class="lq">“CNT ~ var 1+var 2”。</em></li><li id="dae0" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><em class="lq">数据</em>，我们希望在训练过程中使用的数据帧。</li><li id="a4e8" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated"><em class="lq"> Ntree，</em>随机森林中训练的树的数量<em class="lq"> </em>。</li></ul><p id="436a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用上面的代码，我们正在训练大约 100 棵树—让我们记录这次运行的执行时间:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="77d2" class="np mi it nl b gy nq nr l ns nt">system.time(<br/> randomForest(cnt ~ ., data = training_data,<br/> ntree = 100))</span></pre><p id="91cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个随机森林在我的系统上花了大约 12.87 秒。这是我在比较库和不同实现时喜欢做的分析之一。在小规模上，执行时间的差异可能看起来不明显，但是当训练大规模模型时，人们希望使用最有效的库。</p><p id="ceb3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们只使用了随机森林库中的一些参数。在我们的培训过程中，我们还可以使用其他的<a class="ae ne" href="https://medium.com/@ammubharatram/hyperparameter-tuning-of-random-forest-in-both-r-and-python-747b06b568db" rel="noopener">超参数</a>。</p><p id="5984" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在我们的训练过程中使用更多的超参数，只需向函数添加额外的参数，例如添加最小节点大小 10:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b192" class="np mi it nl b gy nq nr l ns nt">rf_2 &lt;- randomForest(formula = cnt ~ ., <br/>                     data = training_data,<br/>                     ntree = 100, <br/>                     nodesize = 10)</span></pre><p id="d110" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用<em class="lq">查看该函数的完整参数列表？r 中的 randomForest </em>。</p><p id="6f31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我想评估我们的树的测试集性能—让我们使用度量库来完成:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="d729" class="np mi it nl b gy nq nr l ns nt">rmse(test_data$cnt, predict(rf, test_data))</span></pre><p id="78b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用我们的<em class="lq"> rf — </em>训练好的随机森林模型<em class="lq"> — </em>来预测测试集的例子。我们将这些值与<em class="lq"> cnt，</em>的真实值进行比较，并获得 RMSE 的值(均方根误差)。</p><p id="db4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<em class="lq"> rf </em>的 RMSE 不是很大，大约为 882.72——为了客观地看待这个数字，每小时共享自行车的平均值大约为 1123 辆。这也是意料之中的，因为这是一个普通版本的随机森林，几乎没有超参数调整和功能工程。</p><p id="771f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">概括一下，用<em class="lq"> randomForest，</em>我们实现了<em class="lq"> : </em></p><ul class=""><li id="680e" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">12.87 秒的执行时间；</li><li id="4017" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">882.72 的 RMSE。</li></ul><p id="3b44" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们将这些值与<em class="lq"> ranger </em>库进行比较！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="d7e1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">使用游侠图书馆</h1><p id="41a8" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">我们可以在 R 中使用的另一个实现是<a class="ae ne" href="https://cran.r-project.org/web/packages/ranger/ranger.pdf" rel="noopener ugc nofollow" target="_blank"><em class="lq"/></a><em class="lq"/>实现。这个库也实现了随机森林，但是以一种更快的方式——当你的维度(行或列)增长时，这将产生巨大的差异。</p><p id="7cfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是和以前完全一样的随机森林:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="e76b" class="np mi it nl b gy nq nr l ns nt">set.seed(1234)<br/>rf_ranger &lt;- ranger(<br/>  formula = cnt ~ ., <br/>  data = training_data, <br/>  num.trees=100)</span></pre><p id="49e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">论点完全相同，除了<em class="lq"> ntree，</em>现在写成<em class="lq"> num.trees </em>。</p><p id="5ad3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">测量执行时间:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="23c2" class="np mi it nl b gy nq nr l ns nt">system.time(rf_ranger &lt;- ranger(<br/>              formula = cnt ~ ., <br/>              data = training_data, <br/>              num.trees=100))</span></pre><p id="97ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">ranger 实现的执行时间大约为 1.84 秒——比<em class="lq"> randomForest </em>实现快 11 秒。</p><p id="145e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加新的超参数也很简单，只需向函数添加新的参数:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="b503" class="np mi it nl b gy nq nr l ns nt">rf_ranger_2 &lt;- ranger(formula = cnt ~ ., <br/> data = training_data, <br/> num.trees=100,<br/> min.node.size = 10)</span></pre><p id="d609" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来评估我们的 ranger 实现的性能。这段代码略有不同，因为<em class="lq">预测</em>函数的行为与使用<em class="lq"> ranger </em>或<em class="lq"> randomForest </em>训练的对象不同。</p><p id="1af4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们需要使用<em class="lq"> $predictions </em>从<em class="lq">预测</em>的返回对象中获取数据:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="f5a8" class="np mi it nl b gy nq nr l ns nt">rmse(<br/>  test_data$cnt, <br/>  predict(rf_ranger, test_data)$predictions<br/>  )</span></pre><p id="1aa8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">游侠</em>实现的 RMSE 在 883.38 左右。这是意料之中的，因为我们使用了一组相似的超参数和特征，而树的不同之处仅在于使用不同库所涉及的自然随机性。</p><p id="149c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两种实现的主要区别在于<em class="lq"> ranger </em>比<em class="lq"> randomForest </em>实现<em class="lq">快得多。</em></p><p id="eae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">概括一下，有了<em class="lq"> ranger，</em>我们实现了<em class="lq"> : </em></p><ul class=""><li id="ce05" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">1.84 秒的执行时间；</li><li id="6a23" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">883.38 的 RMSE。</li></ul><p id="fe15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于这些值，在训练和部署随机森林时，<em class="lq"> ranger </em>库应该是您的选择。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="f581" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢你花时间阅读这篇文章！我将在未来分享更多的教程，比较其他算法的不同库——我还在<a class="ae ne" href="https://www.udemy.com/course/r-for-data-science-first-step-data-scientist/?referralCode=MEDIUMREADERS" rel="noopener ugc nofollow" target="_blank"> Udemy </a>上开设了一门课程，从头开始学习数据科学概念，我希望有你在身边。</p><p id="b7ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是一个小要点，您可以通过更改输入数据和要素将其用于您的项目:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="792f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">本文中使用的数据集受开放政府许可条款和条件约束，可从</em><a class="ae ne" href="https://www.kaggle.com/hmavrodiev/london-bike-sharing-dataset" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://www . ka ggle . com/hmavrodiev/London-bike-sharing-dataset</em></a>获得</p></div></div>    
</body>
</html>