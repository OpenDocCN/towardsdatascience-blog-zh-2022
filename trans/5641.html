<html>
<head>
<title>Benchmarking Python Functions the Easy Way: perftester</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用最简单的方法对 Python 函数进行基准测试:perftester</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81#2022-12-20">https://towardsdatascience.com/benchmarking-python-functions-the-easy-way-perftester-77f75596bc81#2022-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="1466" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">PYTHON 编程</h2><div class=""/><div class=""><h2 id="01f1" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">您可以使用 perftester 以最简单的方式测试 Python 函数</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/16bed19657d51c6254be5b30d46c8a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SZmSNad0E2l6W_fS"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">凯文·Ku 在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d0af" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最近，<a class="ae lh" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">我描述了</a>如何用<code class="fe me mf mg mh b"><a class="ae lh" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>模块进行时间基准测试。我解释了<code class="fe me mf mg mh b">timeit</code>构成了基准时间的基本 Python 方法，并向您承诺展示更多。这篇文章是我信守这个承诺的第一步。</p><p id="d841" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我描述了<code class="fe me mf mg mh b">timeit</code>提供的两种 API:基于片段的和基于可调用的 API。前者是众所周知的，但后者不是，可能是因为它不太自然，需要您使用一个<code class="fe me mf mg mh b">lambda</code>函数。在这里，我将探索<a class="ae lh" href="https://github.com/nyggus/perftester" rel="noopener ugc nofollow" target="_blank">的</a> <code class="fe me mf mg mh b"><a class="ae lh" href="https://github.com/nyggus/perftester" rel="noopener ugc nofollow" target="_blank">perftester</a></code> <a class="ae lh" href="https://github.com/nyggus/perftester" rel="noopener ugc nofollow" target="_blank">包</a>，它允许基准测试调用，就像后面的 API 一样；然而，与它不同的是，它提供了一个简单且感觉自然的 API。</p><p id="b1a1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，<code class="fe me mf mg mh b">perftester</code>带来的不仅仅是时间基准测试——它使您能够根据<em class="mi">执行时间</em>和<em class="mi">内存使用量</em>对可调用程序进行基准测试，但最重要的是——它是一个用于 Python 可调用程序性能测试的框架。</p><p id="9860" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们将从基准测试开始，一步一步地讨论这个丰富的产品。由于时间和内存这两种类型的基准测试非常不同，我们将在这里关注时间基准测试，而将内存消耗的基准测试放在一边；我们改天再讨论这个话题。然后我们将准备讨论作为测试框架的<code class="fe me mf mg mh b">perftester</code>——据我所知，这是<em class="mi">第一个用于测试可调用程序性能的</em> Python 框架。</p><h1 id="452e" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">基本用法</h1><p id="fea3" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">上述文章表明<code class="fe me mf mg mh b">timeit</code>模块易于使用。虽然这是真的，<code class="fe me mf mg mh b">perftester</code>可以更容易。它的 API 使您能够编写简洁明了的 Python 函数和其他可调用函数的基准。为了分析这个 API，让我们使用一个特定的例子。</p><p id="f4d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们有一个任何类型的项目列表<code class="fe me mf mg mh b">x</code>。我们希望以这样一种方式扩展列表，即给定整数<code class="fe me mf mg mh b">n</code>，我们将每个元素<code class="fe me mf mg mh b">n</code>相乘若干次。我们不仅仅通过将列表相乘(<code class="fe me mf mg mh b">x*n</code>)来实现，而是希望保持列表的顺序。</p><p id="3ca2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，我们预期以下行为:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="85c8" class="nk mk it mh b be nl nm l nn no">&gt;&gt;&gt; extend([1, 4, 'a'], 2)<br/>[1, 1, 4, 4, 'a', 'a']<br/>&gt;&gt;&gt; extend([1, 4, 'a'], 3)<br/>[1, 1, 1, 4, 4, 4, 'a', 'a', 'a']<br/>&gt;&gt;&gt; extend([2, 2, 4, 1], 2)<br/>[2, 2, 2, 2, 4, 4, 1, 1]<br/>&gt;&gt;&gt; extend([1, -1, 1, -1], 3)<br/>[1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1, -1]</span></pre><p id="a3cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是该函数的一个版本:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="02a4" class="nk mk it mh b be nl nm l nn no"># extender.py<br/>def extend(x: list, n: int) -&gt; list:<br/>    """Extend x n number of times, keeping the original order.<br/>    <br/>    &gt;&gt;&gt; extend([1, 4, 'a'], 2)<br/>    [1, 1, 4, 4, 'a', 'a']<br/>    &gt;&gt;&gt; extend([1, 4, 'a'], 3)<br/>    [1, 1, 1, 4, 4, 4, 'a', 'a', 'a']<br/>    &gt;&gt;&gt; extend([2, 2, 4, 1], 2)<br/>    [2, 2, 2, 2, 4, 4, 1, 1]<br/>    &gt;&gt;&gt; extend([1, -1, 1, -1], 3)<br/>    [1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1, -1]<br/>    """<br/>    modified_x = []<br/>    for x_i in x:<br/>        for _ in range(n):<br/>            modified_x.append(x_i)<br/>    return modified_x</span></pre><p id="7b52" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如您所见，我添加了一个带有 doctests 的 docstring。如果你想了解这个有用的测试框架，你可以阅读下面的<em class="mi">走向数据科学</em>文章:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/python-documentation-testing-with-doctest-the-easy-way-c024556313ca"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">用 doctest 测试 Python 文档:简单的方法</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">doctest 允许文档、单元和集成测试，以及测试驱动的开发。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og lb ns"/></div></div></a></div><p id="3db6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要运行测试，使用下面的 shell 命令，它假设您将上面的文件保存为<code class="fe me mf mg mh b">extender.py</code>，并且您就在 shell 中的这个文件夹中。</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="4a08" class="nk mk it mh b be nl nm l nn no">$ python -m doctest extender.py</span></pre><p id="1b5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">没有输出意味着所有的测试都通过了。</p><p id="c8b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">好了，我们准备好测试<code class="fe me mf mg mh b">extend()</code>函数了。让我们创建一个<code class="fe me mf mg mh b">main.py</code> Python 文件来运行基准测试，它与<code class="fe me mf mg mh b">extender.py</code>文件位于同一个文件夹中:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="e64e" class="nk mk it mh b be nl nm l nn no"># main.py<br/>import extender<br/>import perftester<br/><br/><br/>if __name__ == "__main__":<br/>    t = perftester.time_benchmark(<br/>        extender.extend,<br/>        [1, 1, 4, 4, 'a', 'a'],<br/>        3<br/>        )<br/>    print(t)</span></pre><p id="d22c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将使用<code class="fe me mf mg mh b">perftester.time_benchmark()</code>参数的默认值，即<code class="fe me mf mg mh b">Number=100_000</code>和<code class="fe me mf mg mh b">Repeat=5</code>。如果你想知道为什么会有人用大写字母作为参数名的第一个字母，你会在文章末尾的附录<strong class="lk jd">中找到解释。</strong></p><p id="014f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的代码在我的机器上产生了以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/57d04608aabb4c2bce66b3eb449aacaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kd3-bQhgMrNLbEvOieGhiQ.png"/></div></div></figure><p id="652d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们不会关注实际结果，因为我们对它们并不特别感兴趣。在不同的机器上，我们会得到不同的结果。因此，<code class="fe me mf mg mh b">perftester</code>也提供了<em class="mi">相对的</em>结果，这些结果应该大致与机器无关。我们稍后将讨论这个问题。</p><p id="6401" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，首先让我们仔细看看输出。可读性不太好吧？这就是为什么<code class="fe me mf mg mh b">perftester</code>为我们提供了一个很好的小解决方案，即<code class="fe me mf mg mh b">pp()</code>函数。它的名字代表<em class="mi">漂亮的印刷</em>，它的漂亮印刷基于两点:</p><ul class=""><li id="198c" class="oi oj it lk b ll lm lo lp lr ok lv ol lz om md on oo op oq bi translated">内置<code class="fe me mf mg mh b">pprint</code>模块的<code class="fe me mf mg mh b">pprint()</code>功能，</li><li id="4205" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated">现场包<code class="fe me mf mg mh b">rounder</code>中的<code class="fe me mf mg mh b">signif_object()</code>功能。</li></ul><p id="80db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://github.com/nyggus/rounder" rel="noopener ugc nofollow" target="_blank"/><code class="fe me mf mg mh b"><a class="ae lh" href="https://github.com/nyggus/rounder" rel="noopener ugc nofollow" target="_blank">rounder</a></code><a class="ae lh" href="https://github.com/nyggus/rounder" rel="noopener ugc nofollow" target="_blank">包</a>使你能够以一种非常简单的方式对任何 Python 对象中的数字进行舍入。如果你感兴趣，你可以阅读下面的文章:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/rounder-rounding-numbers-in-complex-python-objects-e4b6f3b563f8"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">舍入器:对复杂 Python 对象中的数字进行舍入</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">rounder 包使您能够四舍五入任何对象中的所有数字，只需一个命令。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="ow l od oe of ob og lb ns"/></div></div></a></div><p id="7b33" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们来看看<code class="fe me mf mg mh b">perftester.pp()</code>用上面的字典做了什么。这是我们的<code class="fe me mf mg mh b">main.py</code>模块的代码:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="8955" class="nk mk it mh b be nl nm l nn no">import extender<br/>import perftester<br/><br/><br/>if __name__ == "__main__":<br/>    t = perftester.time_benchmark(<br/>        extender.extend,<br/>        [1, 1, 4, 4, 'a', 'a'],<br/>        3<br/>        )<br/>    perftester.pp(t)</span></pre><p id="804e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是输出结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/3674aa1fb33b996484b0f009ee852492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*FQHOkTiX31qDATpDMxV_5w.png"/></div></figure><p id="3cf0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很好，不是吗？我们只通过一个函数<code class="fe me mf mg mh b">perftester.pp()</code>获得了这个，所以你可能想记住它:<code class="fe me mf mg mh b">perftester.pp</code>就像<em class="mi"> perftester pretty print </em>一样。</p><blockquote class="oy"><p id="7e25" class="oz pa it bd pb pc pd pe pf pg ph md dk translated"><code class="fe me mf mg mh b">perftester.pp</code>如在<em class="pi"> perftester 漂亮的打印。</em></p></blockquote><p id="e4a8" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">我们现在可以分析输出。这就是我们现在的情况:</p><ul class=""><li id="db06" class="oi oj it lk b ll lm lo lp lr ok lv ol lz om md on oo op oq bi translated"><code class="fe me mf mg mh b">min</code>、<code class="fe me mf mg mh b">mean</code>、<code class="fe me mf mg mh b">max</code>:这是在所有运行(有<code class="fe me mf mg mh b">repeat</code>次运行)中运行一个函数的最小、平均和最大<em class="mi">平均执行时间→所以这是函数<em class="mi">执行一次</em>的平均时间，不像<code class="fe me mf mg mh b">timeit.timeit()</code>和<code class="fe me mf mg mh b">timeit.repeat()</code>都显示它们的整个执行时间。因此，<code class="fe me mf mg mh b">perftester</code>基准在实验之间是可比较的；<code class="fe me mf mg mh b">timeit</code>基准测试不是——至少在没有额外计算的情况下不是。在这三者中，我们最感兴趣的是<code class="fe me mf mg mh b">min</code>，因为在基准测试中，我们应该寻找最佳结果(您可以在<a class="ae lh" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">中找到更多关于</a> <code class="fe me mf mg mh b"><a class="ae lh" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">timeit</a></code> <a class="ae lh" rel="noopener" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48">基准测试</a>的文章)。</em></li><li id="032d" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated">这是我们兴趣的另一个价值。相对基准测试是根据空函数(即什么都不做，只有<code class="fe me mf mg mh b">pass</code>)的执行时间来执行的。具有相同操作系统的机器之间的相对基准应该或多或少是一致的，但是它们在不同的操作系统之间不太可能是一致的(即使是在同一台机器上，根据我的实验)。</li><li id="e5d1" class="oi oj it lk b ll or lo os lr ot lv ou lz ov md on oo op oq bi translated"><code class="fe me mf mg mh b">raw_times</code>和<code class="fe me mf mg mh b">raw_times_relative</code>:这两个显示原始值，即基准函数在每次运行中的平均执行时间(我们有<code class="fe me mf mg mh b">Repeat</code>运行次数)，和平均相对执行时间(所以，除以空函数的平均相对执行时间)。这些价值观很少引起我们的兴趣；不过，请看下面的例子。</li></ul><blockquote class="oy"><p id="f18d" class="oz pa it bd pb pc po pp pq pr ps md dk translated"><code class="fe me mf mg mh b">perftester</code>基准在实验之间具有可比性；<code class="fe me mf mg mh b">timeit </code>基准不</p></blockquote><p id="d7f5" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">在某些情况下，我们可能希望查看<code class="fe me mf mg mh b">min</code>原始结果:这是因为它提供了我们机器上基准函数的最小执行时间。我们肯定会对这个值感兴趣。然后我们也可以看看<code class="fe me mf mg mh b">raw_times</code>，因为它们显示了这个函数在我们的机器中有多快，所有的后台进程都在运行，所以是在真实的场景中。我们看到，对于我们使用的参数，我们的函数平均需要<code class="fe me mf mg mh b">1.95e-06</code>秒；因此，运行一百万次将花费几乎 2 秒钟。在最好的运行中，平均执行时间是<code class="fe me mf mg mh b">1.84e-06</code>，所以并没有少很多。从<code class="fe me mf mg mh b">raw_times</code>中我们可以看出，变化似乎并不大。</p><p id="f7bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通常，我们会针对各种参数组合对函数进行基准测试，以了解函数在各种场景中的表现。我们将在下面比较两个函数时这样做。</p><p id="45e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我想你们中的许多人认为我在编写这个函数的时候可以做得更好…你是对的！这并不是我一生中编写的最好的函数。创建列表的<code class="fe me mf mg mh b">for</code>循环？当然，列表理解应该做得更好，在性能方面也是如此；点击此处查看更多信息:</p><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/a-guide-to-python-comprehensions-4d16af68c97e"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">Python 理解指南</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">学习复杂的列表理解(listcomps)，集合理解(setcomps)，字典理解…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="pt l od oe of ob og lb ns"/></div></div></a></div><p id="5ccf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么，让我们改进一下<code class="fe me mf mg mh b">extend()</code>函数。但是因为我们想检查我们的更改是否提高了性能，我们将更改函数名，以便我们的<code class="fe me mf mg mh b">extender</code>模块有两个版本。下面是我们新函数<code class="fe me mf mg mh b">extend_2()</code>的代码:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="2cd1" class="nk mk it mh b be nl nm l nn no"># added to main.py<br/><br/>def extend_2(x: list, n: int) -&gt; list:<br/>    """Extend x n number of times, keeping the original order.<br/>    <br/>    &gt;&gt;&gt; extend_2([1, 4, 'a'], 2)<br/>    [1, 1, 4, 4, 'a', 'a']<br/>    &gt;&gt;&gt; extend_2([1, 4, 'a'], 3)<br/>    [1, 1, 1, 4, 4, 4, 'a', 'a', 'a']<br/>    &gt;&gt;&gt; extend_2([2, 2, 4, 1], 2)<br/>    [2, 2, 2, 2, 4, 4, 1, 1]<br/>    &gt;&gt;&gt; extend_2([1, -1, 1, -1], 3)<br/>    [1, 1, 1, -1, -1, -1, 1, 1, 1, -1, -1, -1]<br/>    """<br/>    return [x_i for x_i in x for _ in range(n)]</span></pre><p id="5f18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有的<code class="fe me mf mg mh b">doctest</code>都通过了，所以函数按预期工作。这个功能明显比原来的<code class="fe me mf mg mh b">extend()</code>更短、更清晰，也更优雅，这很好。</p><p id="ac6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，让我们对这两个函数进行基准测试。但是因为我们想要比较两个函数，我们不应该只使用一个参数组合，因为对于小的<code class="fe me mf mg mh b">n</code>，增益(如果有的话)可能与大的<code class="fe me mf mg mh b">n</code>不同。下面是<code class="fe me mf mg mh b">main</code>模块的代码:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="127a" class="nk mk it mh b be nl nm l nn no"># main.py<br/>import extender<br/>import perftester<br/><br/>from collections import namedtuple<br/><br/>Benchmarks = namedtuple("Benchmarks", "extend extend_2 better")<br/><br/>if __name__ == "__main__":<br/>    orig_list = [1, 1, 4, 4, 'a', 'a']<br/>    results = {}<br/>    for n in (2, 5, 10, 100, 1000, 10_000):<br/>        number = int(1_000_000 / n)<br/>        t = perftester.time_benchmark(<br/>            extender.extend,<br/>            orig_list,<br/>            n,<br/>            Number=number<br/>            )<br/>        t_2 = perftester.time_benchmark(<br/>            extender.extend_2,<br/>            orig_list,<br/>            n,<br/>            Number=number<br/>            )<br/>        better = 'extend' if t['min'] &lt; t_2['min'] else 'extend_2'<br/>        nn = f"{n: 6}"<br/>        results[nn] = Benchmarks(t['min'], t_2['min'], better)<br/>    perftester.pp(results)</span></pre><p id="5fb8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是输出结果:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="ffc2" class="nk mk it mh b be nl nm l nn no">{'     2': Benchmarks(extend=1.531e-06, extend_2=1.358e-06, better='extend_2'),<br/> '     5': Benchmarks(extend=2.185e-06, extend_2=1.739e-06, better='extend_2'),<br/> '    10': Benchmarks(extend=3.524e-06, extend_2=2.308e-06, better='extend_2'),<br/> '   100': Benchmarks(extend=2.513e-05, extend_2=1.288e-05, better='extend_2'),<br/> '  1000': Benchmarks(extend=0.0002717, extend_2=0.0001432, better='extend_2'),<br/> ' 10000': Benchmarks(extend=0.002942, extend_2=0.001435, better='extend_2')}</span></pre><p id="064c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">基于列表理解的新版本肯定更快；而且<code class="fe me mf mg mh b">n</code>越大，修正函数越快。对于<code class="fe me mf mg mh b">n=10000</code>，<code class="fe me mf mg mh b">extend_2()</code>比原来的<code class="fe me mf mg mh b">extend()</code>快两倍左右。</p><p id="9a90" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们现在应该对不同长度的不同列表的函数进行基准测试，但是我在这里的目的不是比较这两个函数，而是向您展示如何使用<code class="fe me mf mg mh b">perftester</code>简单地对函数进行基准测试。因此，我将把这些额外的基准留给你们作为练习。</p><h1 id="8f60" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">高级用法</h1><p id="d3d6" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated"><code class="fe me mf mg mh b">perftester</code>函数使用默认设置，这通常是我们需要的。有时，我们可能希望改变<code class="fe me mf mg mh b">Number</code>或<code class="fe me mf mg mh b">Repeat</code>，就像我们上面所做的那样，根据一个函数要完成的操作数来选择<code class="fe me mf mg mh b">Number</code>。有时我们也想改变<code class="fe me mf mg mh b">Repeat</code>。当我进行的基准测试很重要时，我通常会增加<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>。当我有小分歧时，我也会这样做；我增加了这两个参数，以使基准更加稳定。</p><p id="76db" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想对所有基准使用相同的<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>，您不必每次运行<code class="fe me mf mg mh b">perftester.time_benchmark()</code>功能时都手动这么做。您可以在<code class="fe me mf mg mh b">perftester.config</code>对象中修改它一次，它控制<code class="fe me mf mg mh b">perftester</code>函数的行为。</p><p id="0ed6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了做到这一点，做以下事情就足够了:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="2b06" class="nk mk it mh b be nl nm l nn no">perftester.config.set_defaults("time", Number=1_000_000, Repeat=10)</span></pre><p id="ba44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将改变所有要进行基准测试的函数的默认值<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>；当用户在调用<code class="fe me mf mg mh b">perftester.time_benchmark()</code>函数时改变这些参数或其中一个参数的值时，它们将不会被使用。</p><p id="ce8e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的命令改变了每个要进行基准测试的函数的默认值。对于特定的功能，您也可以这样做。例如:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="1ef4" class="nk mk it mh b be nl nm l nn no">perftester.config.set(foo, "time", Number=1_000_000, Repeat=10)</span></pre><p id="7b61" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将改变函数<code class="fe me mf mg mh b">foo()</code>的<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>——该函数之前必须已经定义过。因此，您不能更改尚未定义<em class="mi">或</em>的功能的设置。</p><p id="1e1f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您也可以只更改两个参数之一的默认值:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="6d44" class="nk mk it mh b be nl nm l nn no">perftester.config.set_defaults("time", Number=1_000_000)<br/>perftester.config.set(foo, "time", Number=1_000)</span></pre><p id="3e8c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个——没有改变——将简单地保持不变；也就是说，等于默认设置。</p><p id="8c57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如前所述，相对基准是针对空函数的性能进行的，存储为<code class="fe me mf mg mh b">perftester.config.benchmark_function</code>。这种方法是有意义的，因为这个函数代表了调用一个函数的开销。因此，剩余的执行时间花在了基准测试函数要做的事情上。</p><p id="c912" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有时候，你可能想把这个空函数换成另一个；将根据该功能的性能进行相对基准测试。做起来很简单:你可以用另一个覆盖<code class="fe me mf mg mh b">perftester.config.benchmark_function()</code>；例如:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="11d3" class="nk mk it mh b be nl nm l nn no">def foo():<br/>    return [i for i in range(10)]<br/><br/>perftester.config.benchmark_function = foo</span></pre><p id="318f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以从下面来自<code class="fe me mf mg mh b">perftester</code>仓库的文档文件中了解更多关于这个主题的信息:</p><div class="np nq gp gr nr ns"><a href="https://github.com/nyggus/perftester/blob/implement-profiling-decorator/docs/benchmarking_against_another_function.md" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">perf tester/benchmark _ again _ function . MD at implement-profiling-decorator…</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">在基本使用中，当你选择一个相对基准时，你将你的函数的性能与一个…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="pu l od oe of ob og lb ns"/></div></div></a></div><h1 id="cd68" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">结论</h1><p id="9b70" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated">用<code class="fe me mf mg mh b">perftester</code>对 Python 函数和其他可调用函数进行基准测试很容易。其实比用<code class="fe me mf mg mh b">timeit</code>容易。足以调用<code class="fe me mf mg mh b">perftester.time_benchmark()</code>函数，其 API 简单直观。唯一要记住的是以大写字母开始参数<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>；这同样适用于<code class="fe me mf mg mh b">Func</code>参数，但是您很少将它用作关键字参数，因为它是<code class="fe me mf mg mh b">perftester.time_benchmark()</code>函数的第一个参数，提供了要进行基准测试的函数。因此，从下面的两个电话来看，前者会更频繁:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="a711" class="nk mk it mh b be nl nm l nn no"># Rather this:<br/>t = perftester.time_benchmark(<br/>        extender.extend,<br/>        [1, 1, 4, 4, 'a', 'a'],<br/>        3<br/>        )<br/># than this:<br/>t = perftester.time_benchmark(<br/>        Func=extender.extend,<br/>        [1, 1, 4, 4, 'a', 'a'],<br/>        3<br/>        )</span></pre><p id="579d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这并不意味着<code class="fe me mf mg mh b">perftester</code>通常比<code class="fe me mf mg mh b">timeit </code>函数、<code class="fe me mf mg mh b">timeit()</code>和<code class="fe me mf mg mh b">repeat()</code>简单。虽然<code class="fe me mf mg mh b">perftester</code>更容易对可调用程序的执行时间进行基准测试，但是<code class="fe me mf mg mh b">timeit</code>更容易对格式化为字符串的代码片段进行基准测试，比如<code class="fe me mf mg mh b">"[i**2 for i in range(1000)]"</code>。您可以使用<code class="fe me mf mg mh b">perftester</code>对这样的代码片段进行基准测试，但是您必须定义一个函数来完成这样的代码片段所做的事情。这意味着基准测试不仅会测量执行时间，还会通过调用函数来测量额外时间的开销。因此，当您有一个代码片段要进行基准测试时，您应该选择<code class="fe me mf mg mh b">timeit</code>模块。</p><blockquote class="oy"><p id="bea4" class="oz pa it bd pb pc pd pe pf pg ph md dk translated">虽然<code class="fe me mf mg mh b">perftester</code>更容易对可调用程序的执行时间进行基准测试，但是<code class="fe me mf mg mh b">timeit</code>更容易对代码片段进行基准测试。</p></blockquote><p id="f760" class="pw-post-body-paragraph li lj it lk b ll pj kd ln lo pk kg lq lr pl lt lu lv pm lx ly lz pn mb mc md im bi translated">然而，在基准可赎回性方面，<code class="fe me mf mg mh b">perftester</code>大放异彩。它的 API 专门用于这个场景，而<code class="fe me mf mg mh b">timeit</code>的 API 则不是。你可以这样做，但是你需要定义一个非参数 lambda。比较我们的<code class="fe me mf mg mh b">extend()</code>函数的这两个基准:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="e2dc" class="nk mk it mh b be nl nm l nn no"># perftester, using default settings<br/>perftester.time_benchmark(extender.extend, [1, 1, 4, 4, 'a', 'a'], 3)<br/># timeit, using defaults settings<br/>timeit.repeat(lambda: extender.extend([1, 1, 4, 4, 'a', 'a'], 3))<br/><br/># perftester, changed settings<br/>perftester.time_benchmark(<br/>    extender.extend, [1, 1, 4, 4, 'a', 'a'], 3,<br/>    Number=1000, Repeat=3,<br/>)<br/># timeit, changed settings<br/>timeit.repeat(<br/>    lambda: extender.extend([1, 1, 4, 4, 'a', 'a'], 3),<br/>    number=1000, repeat=3<br/>)</span></pre><p id="4bbd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对<code class="fe me mf mg mh b">perftester.time_benchmark()</code>的调用更加自然，乍一看也更容易理解。在<code class="fe me mf mg mh b">timeit</code>函数中使用<code class="fe me mf mg mh b">lambda</code>的必要性使得这个调用可读性更差。</p><p id="3030" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一件事。您可以选择使用全名来导入<code class="fe me mf mg mh b">perftester</code>，就像我在本文中所做的那样。但是你也可以这样做</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="5fdd" class="nk mk it mh b be nl nm l nn no">import perftester as pt</span></pre><p id="f7c5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在软件包的存储库中使用。全名导入稍微清楚一点，但是肯定更长，所以选择你喜欢的。</p><p id="e8d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意，在进行基准测试时，<code class="fe me mf mg mh b">perftester</code>使用与<code class="fe me mf mg mh b">timeit</code>完全相同的后端，因为前者实际上调用后者。所以区别只在于 API。这种差异不足以学习一个新的框架来测试一个函数。但是正如我在上面所写的，<code class="fe me mf mg mh b">perftester</code>带来的不仅仅是基准执行时间，这就是为什么我相信你不会后悔花时间学习这个包——以及阅读这篇文章。您不仅可以对时间进行基准测试，还可以对内存进行基准测试，但最重要的是，该包使您能够编写时间和内存方面的性能测试。我决定在不同的文章中讨论这些不同的用例，以便一次处理一个主题——并且使学习更容易。</p></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><p id="372e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢您的阅读。我希望很快发布关于<code class="fe me mf mg mh b">perftester</code>的下一篇文章，你将会看到<code class="fe me mf mg mh b">perftester</code>提供了一些你以前没有见过的东西:Python 调用的性能测试框架。</p><p id="fc29" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在此期间，您可以将其用于基准时间。如果你想了解更多关于这个包及其用途的信息，你可以在<code class="fe me mf mg mh b">perftester</code>的 GitHub 仓库中找到:</p><div class="np nq gp gr nr ns"><a href="https://github.com/nyggus/perftester" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">GitHub - nyggus/perftester:一个轻量级 Python 包，用于 Python 的性能测试…</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用 pip 安装:perftester 仍在大量测试中。如果您发现任何不符合预期的情况，请…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="qc l od oe of ob og lb ns"/></div></div></a></div></div><div class="ab cl pv pw hx px" role="separator"><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa qb"/><span class="py bw bk pz qa"/></div><div class="im in io ip iq"><h1 id="f235" class="mj mk it bd ml mm qd mo mp mq qe ms mt ki qf kj mv kl qg km mx ko qh kp mz na bi translated">附录</h1><p id="4fda" class="pw-post-body-paragraph li lj it lk b ll nb kd ln lo nc kg lq lr nd lt lu lv ne lx ly lz nf mb mc md im bi translated"><strong class="lk jd">上</strong> <code class="fe me mf mg mh b"><strong class="lk jd">Func</strong></code> <strong class="lk jd">、</strong> <code class="fe me mf mg mh b"><strong class="lk jd">Number</strong></code> <strong class="lk jd">和</strong> <code class="fe me mf mg mh b"><strong class="lk jd">Repeat</strong></code></p><p id="d30e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可能想知道为什么这些参数(其中的<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>以及关键字参数)以大写字母开头。这是一个合理的问题，因为这似乎不合常理；我在这个附录中回答了这个问题，基于您可以在软件包的存储库中找到的解释。</p><p id="274d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法最大限度地降低了要进行基准测试的函数与您计划使用的<code class="fe me mf mg mh b">perftester</code>函数同名的风险，在这种情况下，您将不得不使用一个参数两次——这将意味着<code class="fe me mf mg mh b">SyntaxError</code>。在 Python 代码库中，有很多函数都有一个名为<code class="fe me mf mg mh b">func</code>、<code class="fe me mf mg mh b">number</code>或<code class="fe me mf mg mh b">repeat</code>的参数。但是很少有函数有一个名为<code class="fe me mf mg mh b">Func</code>、<code class="fe me mf mg mh b">Number</code>或<code class="fe me mf mg mh b">Repeat</code>的参数。这就是为什么<code class="fe me mf mg mh b">perftester</code>的参数以大写字母开始。</p><p id="be6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然而，如果一个函数有一个参数<code class="fe me mf mg mh b">Func</code>、<code class="fe me mf mg mh b">Number</code>或<code class="fe me mf mg mh b">Repeat</code>，有一个解决方案。您可以定义一个<code class="fe me mf mg mh b">functools.partial()</code>函数并测试这个函数。你可以在这里阅读更多关于<code class="fe me mf mg mh b">functools.partial()</code>的信息:</p><div class="np nq gp gr nr ns"><a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">functools —对可调用对象的高阶函数和操作</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">源代码:Lib/functools.py 该模块用于高阶函数:作用于或返回其他函数的函数…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.python.org</p></div></div><div class="ob l"><div class="qi l od oe of ob og lb ns"/></div></div></a></div><p id="eb8f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面，你会发现一个例子。假设你有一个函数<code class="fe me mf mg mh b">foo()</code>，它的参数是<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>。要使用<code class="fe me mf mg mh b">perftester.time_benchmark()</code>，您需要执行以下操作:</p><pre class="ks kt ku kv gt ng mh nh bn ni nj bi"><span id="7a39" class="nk mk it mh b be nl nm l nn no">from functools import partial<br/><br/>def foo(Number, Repeat):<br/>    return [Number] * Repeat<br/><br/>foo_partial = partial(foo, Number=20.5, Repeat=100)<br/>perftester.time_benchmark(foo_partial, Number=1000, Repeat=10)</span></pre><p id="c229" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，首先你应该<em class="mi">而不是</em>使用<code class="fe me mf mg mh b">Number</code>和<code class="fe me mf mg mh b">Repeat</code>中的<code class="fe me mf mg mh b">foo()</code>参数。我展示这个解决方案是因为您可能会发现自己处于这样一种情况，您想要对别人编写的这样做的函数进行基准测试；安全总比后悔好。</p><p id="e3d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe me mf mg mh b">functools.partial()</code>在很多其他用例中都是非常有用的解决方案，不仅仅是这个。所以，反正知道这个功能就好了。</p><h1 id="73c9" class="mj mk it bd ml mm mn mo mp mq mr ms mt ki mu kj mv kl mw km mx ko my kp mz na bi translated">资源</h1><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/benchmarking-python-code-with-timeit-80827e131e48"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">用 timeit 对 Python 代码进行基准测试</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">作为 Python 代码时间基准测试最流行的工具，内置的 timeit 模块提供了比大多数…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="qj l od oe of ob og lb ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://docs.python.org/3/library/functools.html#functools.partial" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">functools——对可调用对象的高阶函数和操作</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">源代码:Lib/functools.py 该模块用于高阶函数:作用于或返回其他函数的函数…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">docs.python.org</p></div></div><div class="ob l"><div class="qi l od oe of ob og lb ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/nyggus/perftester" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">GitHub - nyggus/perftester:一个轻量级 Python 包，用于 Python 的性能测试…</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">使用 pip 安装:perftester 仍在大量测试中。如果您发现任何不符合预期的情况，请…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="qk l od oe of ob og lb ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a href="https://github.com/nyggus/rounder" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">GitHub - nyggus/rounder:在复杂的 Python 中舍入浮点数和复数的 Python 包…</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">rounder 是一个轻量级的包，用于在复杂的 Python 对象中舍入数字，例如字典、列表、元组…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="ql l od oe of ob og lb ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/rounder-rounding-numbers-in-complex-python-objects-e4b6f3b563f8"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">舍入器:对复杂 Python 对象中的数字进行舍入</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">rounder 包使您能够四舍五入任何对象中的所有数字，只需一个命令。</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="ow l od oe of ob og lb ns"/></div></div></a></div><div class="np nq gp gr nr ns"><a rel="noopener follow" target="_blank" href="/a-guide-to-python-comprehensions-4d16af68c97e"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd jd gy z fp nx fr fs ny fu fw jc bi translated">Python 理解指南</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">学习复杂的列表理解(listcomps)，集合理解(setcomps)，字典理解…</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">towardsdatascience.com</p></div></div><div class="ob l"><div class="pt l od oe of ob og lb ns"/></div></div></a></div></div></div>    
</body>
</html>