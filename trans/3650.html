<html>
<head>
<title>Multi-Task Learning for Classification with Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Keras的多任务分类学习</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/multi-task-learning-for-computer-vision-classification-with-keras-36c52e6243d2#2022-08-14">https://towardsdatascience.com/multi-task-learning-for-computer-vision-classification-with-keras-36c52e6243d2#2022-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8618" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何构建一个能够同时执行多种图像分类和多任务学习的模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/80b122007ae4fb1244b3ab988d8fd2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yKr0w50Qd5PIhXOI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="d3e2" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi mc translated"><span class="l md me mf bm mg mh mi mj mk di"> M </span>多任务学习(multi-task Learning，MLT)是机器学习的一个子领域，通过一个共享模型同时学习多个任务。这种类型的学习有助于提高数据效率和训练速度，因为共享模型将从同一数据集中学习几个任务，并且由于不同任务的辅助信息，将能够更快地学习。此外，它还减少了过度拟合，因为考虑到训练数据的标签对于每个任务是不同的<strong class="li iu">【1】</strong>，模型将更难与训练数据完美拟合。</p><p id="6afe" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">本文将介绍MTL，并展示如何使用tensorflow的Keras模块在真实数据上实现和训练它。在我的GitHub资源库中可以找到完整的代码，以及一个Jupyter笔记本，您可以在其中试验您所学到的内容:</p><div class="ml mm gp gr mn mo"><a href="https://github.com/JavierMtz5/ArtificialIntelligence" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">GitHub-Javier mtz 5/人工智能</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ks mo"/></div></div></a></div></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="fc34" class="nd ne it bd nf ng nh dn ni nj nk dp nl lp nm nn no lt np nq nr lx ns nt nu nv bi translated">数据预处理</h2><p id="4d68" class="pw-post-body-paragraph lg lh it li b lj nw ju ll lm nx jx lo lp ny lr ls lt nz lv lw lx oa lz ma mb im bi translated">为了使解释简单易懂，将使用CIFAR-10<strong class="li iu">【2】</strong>数据集，该数据集在<a class="ae ky" href="https://peltarion.com/knowledge-center/terms/dataset-licenses/cifar-10" rel="noopener ugc nofollow" target="_blank"> <strong class="li iu"> MIT许可</strong> </a>下提供。该数据集由60000幅32×32像素的RGB图像组成，分为10个不同的类别。它被分为50000个训练样本和10000个测试样本，并且是完全平衡的，这意味着数据集每类包含6000个图像。可以通过执行以下命令轻松加载数据集:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/03ad96d45d407bc2d815b04fba69ee1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*UxHErBmBLVRr_PY4DnE-iA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">数据加载</strong>。作者图片</p></figure><p id="ac29" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">数据集包含以下类:<strong class="li iu">飞机</strong>、<strong class="li iu">汽车</strong>、<strong class="li iu">鸟</strong>、<strong class="li iu">猫</strong>、<strong class="li iu">鹿</strong>、<strong class="li iu">狗</strong>、<strong class="li iu">青蛙</strong>、<strong class="li iu">马</strong>、<strong class="li iu">船</strong>和<strong class="li iu">卡车</strong>。多任务模型要学习的两个任务是这些标签上的分类，参见:</p><ul class=""><li id="f5a8" class="od oe it li b lj lk lm ln lp of lt og lx oh mb oi oj ok ol bi translated"><strong class="li iu">任务1: </strong>修改后的CIFAR10数据集上的多类分类(<strong class="li iu">飞机</strong>、<strong class="li iu">汽车</strong>、<strong class="li iu">鸟</strong>、<strong class="li iu">猫</strong>、<strong class="li iu">狗</strong>、<strong class="li iu">蛙</strong>、<strong class="li iu">船</strong>和<strong class="li iu">卡车</strong>标签，修改说明如下)。</li><li id="ab96" class="od oe it li b lj om lm on lp oo lt op lx oq mb oi oj ok ol bi translated"><strong class="li iu">任务二</strong>:二元分类(标签为<strong class="li iu">动物</strong>和<strong class="li iu">车辆</strong>)。</li></ul><p id="4efc" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">实现上述两个分类任务的一个更有效的选择是训练一个只学习第一个任务的模型，其输出将用于预测二元类<strong class="li iu">动物</strong>或<strong class="li iu">车辆</strong>。这方面的一个例子是将青蛙的图像作为输入传递给模型，为此模型将获得作为输出的<strong class="li iu"> frog </strong>类。因为青蛙是一种动物，那么图像将被分类到<strong class="li iu">动物</strong>类(这个解决方案的模式可以在下面看到)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/c190d4fd37ae3f98e31ea331c1803344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RyP35Xw93sX439FH9fmoCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。乔尔·亨利在Unsplash上拍摄的青蛙照片</p></figure><p id="4014" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">尽管如此，本文将通过应用多任务学习来解决这个问题，因为，虽然它不是最有效的例子，但它完美地展示了MTL在这种类型的问题中的有用性和应用，并且它是发展知识的极好基础。</p><p id="16c5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">考虑到这一点，并且为了有一个用于训练的平衡数据集，属于<strong class="li iu">鹿</strong>和<strong class="li iu">马</strong>的类的实例将被删除。这样做是因为最初数据集包含30000个属于动物的样本(5000个样本×6个类别)和仅20000个属于车辆的样本(5000个样本×4个类别)，这将使数据集在二进制分类任务方面不平衡。马和鹿的实例被删除，因为它们与猫和狗具有非常相似的特征，因此可能会增加训练的复杂性，因为区分这些类的实例会更加困难。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="9657" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">请注意，在此清理之后，标签具有以下类别:[0、1、2、3、5、6、8、9](缺少4和7，分别对应于鹿和马)。因此，有必要更新标签，使它们从0到7进行编号，这一步可以在我的资料库中的Jupyter笔记本中找到。但是，为了更好地学习，请尝试自己编写代码！</p><p id="ae81" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对于多任务学习来说，训练标签是特定于任务的，这一点至关重要。因此，在n任务训练中，将定义不同标签的n个数组。在这种情况下，第一个任务要求标签是从0到7的整数(每个类一个数字)，第二个任务要求标签是0和1(因为是二进制分类)。数据先前被预处理，使得标签是从0到7的数字，并且如所期望的，用于二进制分类的标签将基于初始的0到7标签来构建，使得如果实例对应于动物，则它将是0，并且当它对应于车辆时，它将是1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="6faa" class="nd ne it bd nf ng nh dn ni nj nk dp nl lp nm nn no lt np nq nr lx ns nt nu nv bi translated">创建模型</h2><p id="192c" class="pw-post-body-paragraph lg lh it li b lj nw ju ll lm nx jx lo lp ny lr ls lt nz lv lw lx oa lz ma mb im bi translated">由于这两个任务都使用图像作为训练数据，卷积网络(CNN)将被用作共享模型，因此它将学习最初从图像中提取最重要的特征。共享模型的输出将被展平，并被引入到对应于每个任务的分支。两个分支都将由密集层组成(因为我们已经展平了它们的输入)，每个密集层具有不同数量的神经元，其输出层将由2个和8个神经元组成，分别用于二进制和多类分类任务。除了输出层使用softmax和sigmoid分别进行多类和二类分类之外，所有层都使用ReLu作为激活函数。下面可以看到所描述模型的低级概要以及定义它的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/2e30c4e05fc161df4bad287875c78eab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnAbWldwJDg57w194_npDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模型建筑。作者图片</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="bdc1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在代码中，可以看到当定义神经网络的每一层时，对象接收前一层，即其输出是被定义层的输入的层。通过这种方式，Keras模型可以针对每个任务进行分离，使得两个分支/子模型都从同一个共享模型开始。</p><p id="8814" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通常模型会更新它们的权重，寻求优化它们的损失函数(参见我以前的文章<a class="ae ky" rel="noopener" target="_blank" href="/digit-classification-with-single-layer-perceptron-9a4e7d4d9628">用单层感知器进行数字分类</a>)，但是在MTL，一般模型的每个分支都在学习不同的任务，所以有必要为每个任务指定一个损失函数。然而，<em class="ov">张量流</em>在反向传播过程中仅使用单个损失函数的结果，因此还必须定义联合损失函数，其最简单的形式是不同损失函数值的加权和。在这种情况下，联合损失函数定义如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/35d8ef6f59bdf66b04c105436dac1532.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*1uA6-KO1IBi3uMVMUTxZAA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">关节损失功能</strong>。作者图片</p></figure><p id="0e61" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">注意，当<strong class="li iu"> ɣ </strong>等于0时，模型将仅接收从任务2获得的损失，而如果<strong class="li iu"> ɣ </strong>等于1，模型将接收任务1的损失。这允许仅针对任务1(如果<strong class="li iu"> ɣ </strong> = 1)、仅针对任务2(如果<strong class="li iu"> ɣ </strong> = 0)或针对两个任务(如果0 &lt; <strong class="li iu"> ɣ </strong> &lt; 1)来训练模型，这允许模型用于多个场景，这取决于模型需要什么。</p><p id="784d" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">通过在<em class="ov"> loss_weights </em>参数中指定模型每个分支的损失函数的权重，可以在编译时在先前创建的模型中定义联合损失函数。见下面的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="81d2" class="nd ne it bd nf ng nh dn ni nj nk dp nl lp nm nn no lt np nq nr lx ns nt nu nv bi translated">训练模型</h2><p id="8138" class="pw-post-body-paragraph lg lh it li b lj nw ju ll lm nx jx lo lp ny lr ls lt nz lv lw lx oa lz ma mb im bi translated">一旦对数据进行了预处理，并且为这两项任务定义了模型，就该对其进行训练了。<strong class="li iu">。fit() </strong>方法用于训练，与定义正常模型时不同，它接收与模型中的分支/输出一样多的数组，如<strong class="li iu"> <em class="ov"> y </em> </strong>参数。另一方面，与正常模型一样，必须指定批次大小和时期数。在这种情况下，将使用128的批量大小，并且它将被训练15个时期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><p id="cd2a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">用3个不同的γ值训练模型:<strong class="li iu"> 0 </strong>、<strong class="li iu"> 0.5 </strong>和<strong class="li iu"> 1 </strong>，代码测量并打印每次训练的运行时间。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="54b1" class="nd ne it bd nf ng nh dn ni nj nk dp nl lp nm nn no lt np nq nr lx ns nt nu nv bi translated">评估模型的性能</h2><p id="531e" class="pw-post-body-paragraph lg lh it li b lj nw ju ll lm nx jx lo lp ny lr ls lt nz lv lw lx oa lz ma mb im bi translated">最后，我们将通过绘制这两项任务在15个时期内的精确度来观察不同伽马值的MTL模型的结果。这要归功于上面定义的<strong class="li iu"><em class="ov">fit _ batch _ multask _ models()</em></strong>函数返回的历史列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/a62e53fadadfa22fad76d9024c37e45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*WrvGe77ePELYG1XCr7MfHw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd oc">不同伽马值的精度与时期图</strong>。作者图片</p></figure><p id="69ac" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">从不同的伽马值获得的图表清楚地显示了上述内容:伽马的极值意味着模型将学习仅执行任务之一，伽马的中间值意味着模型将设法学习完成两个任务。此外，该模型对两种任务都获得了超过90%的准确率，能够更好地执行二元分类。应该提到的是，二分类比多分类更简单，所以得到的结果是可以预料的。</p><p id="0df7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">此外，在Jupyter笔记本中，随机拍摄测试数据集的图像，并从模型中提取预测，以检查它是否有效，随时修改它并尝试新事物！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="600b" class="nd ne it bd nf ng nh dn ni nj nk dp nl lp nm nn no lt np nq nr lx ns nt nu nv bi translated">结论</h2><p id="5014" class="pw-post-body-paragraph lg lh it li b lj nw ju ll lm nx jx lo lp ny lr ls lt nz lv lw lx oa lz ma mb im bi translated">当伽玛值平衡两个任务的损失函数的权重时，多任务学习已经设法在两个任务中实现非常好的结果，并且当取极端伽玛值时，它也完美地完成单任务模型的任务，因此对于模型需要偶尔完成某些任务的情况，这是非常有趣的选择。必须考虑到，模型中的分叉意味着更多的计算成本，因此需要更长的执行时间。此外，尽管建立了极端的伽马值，但是执行时间将继续很长，因为模型在两个分支中以任一方式执行正向和反向传播过程。如果模型只需要执行一个任务，这是很重要的，因为训练单任务模型(没有分支)在计算成本方面会更有效。</p><p id="fcae" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">最后，应该提到这种类型的架构的巨大可能性。将第一过滤器(共享模型)应用于输入，然后基于定制分支进行预测的事实使得极大地优化训练模型所需的资源成为可能，这些模型需要执行在某些方面具有相似性的任务。已知的和强大的模型可以用作这种类型的架构的基础或共享模型，实现能够在许多不同的任务中实现非常好的结果的模型，总是具有它们的共同性质的一部分。</p><h2 id="d7d0" class="nd ne it bd nf ng nh dn ni nj nk dp nl lp nm nn no lt np nq nr lx ns nt nu nv bi translated">参考</h2><p id="7205" class="pw-post-body-paragraph lg lh it li b lj nw ju ll lm nx jx lo lp ny lr ls lt nz lv lw lx oa lz ma mb im bi translated">迈克尔·克劳肖。基于深度神经网络的多任务学习:综述。<em class="ov"> arXiv预印本arXiv:2009.09796 </em>，2020</p><p id="8e7e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><strong class="li iu">【2】</strong>首页:</p><div class="ml mm gp gr mn mo"><a href="https://www.cs.toronto.edu/%7Ekriz/cifar.html" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">CIFAR-10和CIFAR-100数据集</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">水生哺乳动物海狸、海豚、水獭、海豹、鲸鱼观赏鱼、比目鱼、鳐鱼、鲨鱼、鳟鱼花兰花…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">www.cs.toronto.edu</p></div></div></div></a></div><p id="718f" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">Tensorflow API:</p><div class="ml mm gp gr mn mo"><a href="https://www.tensorflow.org/datasets/catalog/cifar10" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">cifar10 |张量流数据集</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">由Google和社区构建的预训练模型和数据集</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">www.tensorflow.org</p></div></div><div class="mx l"><div class="oy l mz na nb mx nc ks mo"/></div></div></a></div></div></div>    
</body>
</html>