<html>
<head>
<title>Python Interfaces: Why should a Data Scientist Care?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python接口:数据科学家为什么要关心？</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-interfaces-why-should-a-data-scientist-care-2ed7ff80f225#2022-06-13">https://towardsdatascience.com/python-interfaces-why-should-a-data-scientist-care-2ed7ff80f225#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbc3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类接口，抽象层，继承，那不是软件开发者的问题吗？作为一名数据科学家，您为什么要关心呢？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/184bbc5219e02dae0309b95b9dd79733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjsWf2kTrZyT_oRvk8ph3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure><p id="2573" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接口使得几乎所有我们喜爱的数据科学库成为可能。这是一个足够好的理由，至少对我来说，去关心。但是让我们深入探讨这个问题。在当前故事的上下文中，<strong class="la iu">接口</strong>是一个<strong class="la iu">面向对象(OO) </strong>的概念，用于<strong class="la iu">定义其他对象的属性和行为</strong>。</p><p id="afc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们要设计一个软件时，界面是很方便的:</p><ul class=""><li id="346a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">依赖于尚不存在但将来会存在的对象(例如，插件或用户定义的对象)</li><li id="303d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">允许具有相同核心行为但功能和内部逻辑略有不同的可互换对象</li><li id="1190" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">将核心逻辑与外部依赖项(如数据库或外部API)隔离开来</li></ul><p id="7944" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些想法听起来很有前途，但是说实话，它们听起来更像软件开发人员的行话(事实上，是一个面向对象的软件开发人员)。作为一名数据科学家，你为什么要关心呢？</p><ul class=""><li id="b8e6" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">我们喜欢的大多数库，如Keras或scikit-learn，都使用接口来定义模型属性。它们中的大多数允许您在模型中编写定制对象。</li><li id="fd14" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果你需要用像sklearn的API那样令人愉悦的API来编写你自己的工具，你将需要接口。</li><li id="7774" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在Python中，一切都是对象，所以了解OO的基础知识是必须的。</li></ul><h2 id="16b8" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">为什么是界面？</h2><p id="ff5e" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">思考下面这个问题。我们有两个模型(每一个都是一个类，<em class="ng">层1 </em>和<em class="ng">层2 </em>)，具有<em class="ng">拟合</em>和<em class="ng">预测</em>方法。我们还有另一个模型(另一个类，<em class="ng"> LayeredModel </em>)，它将两个<em class="ng">层</em>模型以某种方式组合在一起。此时，我们测试您的代码，一切正常；是吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/9e1e0564f8fe2a527442076df006afc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*yQC1vHakFNoXsgPvayb9oQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类图:没有接口的模型组合。图片作者。</p></figure><p id="8375" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然<em class="ng"> LayeredModel </em>可以工作，但是它有几个弱点:</p><ul class=""><li id="a8d6" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如果你改变了<em class="ng">图层1 </em>或<em class="ng">图层2、</em>中的某个东西，很可能<em class="ng"> </em>你也需要改变<em class="ng">图层模型</em>；这是导致灾难的原因。</li><li id="43e8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">两个模型，<em class="ng"> Layer1 </em>和<em class="ng"> Layer2 </em>，行为相同(<em class="ng"> fit </em>和<em class="ng"> predict </em>)，但是没有明确的方式陈述这一点。</li><li id="25b7" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果我们想添加更多的层会发生什么？</li><li id="59c8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果<em class="ng"> LayerdModel </em>使用图层，那让<em class="ng"> LayerdModel </em>自己做一个图层不是很有意义吗？这样做将允许构建更复杂的组合。</li></ul><p id="4898" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何解决这样的问题？</p><p id="f850" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进入界面。</p><p id="d443" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们为模型定义了一个接口(<em class="ng">基础层</em>)。一个复合模型，如<em class="ng"> LayeredModel，</em>将依赖于实现该接口的模型。然后，我们对这些层进行编码，使它们都实现(遵守)接口。这样做可以解决我们的大部分问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/ff32369c1c7374afd991121a7b4605b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*h7Xi7vc-GZQKxPqJxRSqww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类图:中间有接口依赖的模型组合。图片作者。</p></figure><p id="c853" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一缺少的是让<em class="ng">layer model</em>也实现接口，我们将创建一个简单干净的方法来构建可堆叠模型的管道。</p><p id="9d0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Python中有许多定义和使用接口的方法，它们都有各自的优缺点。在这个故事中，我们将回顾最常见的接口声明方式，并浏览一些示例和常见模式。</p><h2 id="218f" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">故事结构</h2><ul class=""><li id="d223" class="lu lv it la b lb nb le nc lh nj ll nk lp nl lt lz ma mb mc bi translated">声明接口<br/> -非正式接口<br/> -抽象基类(ABC) <br/> -协议<br/> - zope.interface <br/> -利弊总结</li><li id="af87" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用ABC构建复杂模型</li><li id="b635" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">使用协议构建复杂模型</li><li id="1d56" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">ABC:部分实施</li><li id="8865" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">ABC对协议和多重继承问题</li><li id="1b27" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最后的话</li></ul><h2 id="0735" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">声明接口—非正式接口</h2><p id="3d91" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在Python中定义接口最简单的方法是通过一个常规类；以下示例定义了一个类，用作sklearn的API样式模型的接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3f95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到<em class="ng"> fit </em>和<em class="ng"> predict </em>方法没有实现，只是用类型(注释)和一个docstring描述了它们应该做的事情。</p><p id="8395" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将通过继承该接口并覆盖<em class="ng"> fit </em>和<em class="ng"> predict </em>方法来使用该接口。我们假设从接口继承的所有类都实现了接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="29c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法有一个严重的缺点；如果我们从接口继承，但是什么都不做(“传递”)，那么子类将有方法，但是它们不会被实现(它们不返回任何东西)。因此，我们不能假设所有的子类都实现了接口。这种行为会给我们的代码带来问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="af04" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">解决这个问题的一个方法是定义一个更强的接口，在这个接口中，我们在所有方法中引发一个“NotImplementedError”异常。这样做不允许我们重复相同的继承然后什么都不做(“传递”)的反模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bfb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种声明接口的方式(非正式的)有一个很大的缺点；除了在名称中包含interface一词之外，没有明确的方法来说明该类是一个接口。记住，我们使用接口是为了让代码更加清晰。另一个缺点是，这些接口类仍然可以像普通类一样被实例化，这并不是很好。</p><h2 id="ebe5" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">声明接口—抽象基类(ABC)</h2><p id="ab48" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">Python的ABC(抽象基类)来自<em class="ng"> abc </em>模块，解决了非正式接口产生的大部分问题。</p><p id="9565" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了创建相同的接口，我们创建一个类并从ABC继承，然后对未实现的方法使用<em class="ng"> abstractmethod </em> decorator:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6b19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过这样做，我们实现了:</p><ul class=""><li id="4c45" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><strong class="la iu">清晰:</strong>很明显，这不是一个普通的班级；它显然是一个抽象层，应该被继承。</li><li id="3134" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated"><strong class="la iu">实现约束:</strong>如果我们从接口继承而不实现方法，就会引发错误。</li><li id="39cc" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">实例约束:如果我们试图实例化接口，将会引发一个异常。</li></ul><p id="aaea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实施限制的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f86e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正确实施的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c697" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用抽象基类是声明接口的首选方法，但是有一点需要注意。它们太笼统了；ABC可以用于许多其他事情。当一个ABC仅仅是一个接口或者更多的东西时，这一点并不总是清楚的(我们将在随后的部分中对此进行研究)。</p><h2 id="d450" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">声明接口—协议</h2><p id="64c1" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">协议是接口领域的新生事物。它首先出现在PEP 544 for Python 3.8的类型模块中。这是一种定义接口的隐式方式；然而，它只有在使用类型提示和进行静态类型检查(例如，mypy)时才有帮助。然而，我发现这种声明接口的方式是我个人最喜欢的。无论如何，如果你现在不使用类型提示和静态类型检查，你可能应该这样做。</p><p id="17f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">声明接口的方式与ABC非常相似，但是我们从协议继承，并且不使用<em class="ng"> abatractmethod </em> decorator。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7ea1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要实现接口，我们只需遵循协议类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9c99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以看到没有任何引用(除了docstring)表明这个类与接口有某种联系。</p><p id="7a49" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是另一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="748b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个不遵守协议的类的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b88f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，没有实际引用该协议；事实上，你可以问问自己协议这种东西有什么用。</p><p id="0915" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，协议的用途来了。</p><p id="4717" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们定义一些使用模型接口(协议)的代码(带有静态类型信息)，在本例中是一个函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="05eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后使用带有<em class="ng"> DummyLayer </em>和<em class="ng"> AnotherDummyLayer </em>的函数，如果我们进行静态类型检查，一切都是完美的。但是，如果我们使用<em class="ng"> WrongDummyLayer </em>作为函数参数，就会出现错误；因为我们声明该函数的参数符合协议，而<em class="ng"> WrongDummyLayer </em>不符合协议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9022" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对协议的主要批评是它不符合Python的<a class="ae no" href="https://peps.python.org/pep-0020/" rel="noopener ugc nofollow" target="_blank">Zen(PEP 20)</a></p><blockquote class="np"><p id="b60f" class="nq nr it bd ns nt nu nv nw nx ny lt dk translated">…显式比隐式好…</p><p id="c50e" class="nq nr it bd ns nt nu nv nw nx ny lt dk translated">Python的禅</p></blockquote><h2 id="a0d6" class="mi mj it bd mk ml nz dn mn mo oa dp mq lh ob ms mt ll oc mv mw lp od my mz na bi translated">声明接口— zope.interface</h2><p id="6aaa" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">界面之旅的最后一站是zope.interface，它是一个第三方库。我没有使用过这种声明接口的方式；然而，出于传统原因，我不得不将它包括在内。从Python 2开始就有了。</p><p id="509c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们声明接口的方式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ff58" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们从zope.interface.Interface继承，到目前为止，一切顺利。我们使用Zope . interface . implementer decorator来声明某个类实现了接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c24f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是我发现第一个问题的地方。在这个特例中，<em class="ng"> fit </em>方法返回类本身的一个实例(“return self”)；目的是像<em class="ng"> fit()那样做链接。预测()</em>。在前面的例子中，实现者的<em class="ng"> fit </em>方法返回的对象类型是接口类型。静态类型检查没有错误。然而，在本例中，有一个错误。我们必须将其修改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b2f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这听起来不是什么大事，但确实如此。就类型而言，说一个类实现一个接口意味着实现的是与接口相同的类型。所以一般来说，我们想说<em class="ng"> fit </em>方法返回一个接口类型的对象。</p><h2 id="9607" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">声明接口——利弊总结</h2><p id="270d" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><strong class="la iu">非正式接口</strong>优点:</p><ul class=""><li id="19ee" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">直觉的</li><li id="f55f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">不需要依赖</li></ul><p id="becf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">非正式接口</strong>缺点:</p><ul class=""><li id="76fd" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">声明接口时意图不太明确</li></ul><p id="496e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> ABC </strong>优点:</p><ul class=""><li id="4d8a" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">直觉的</li><li id="9d6d" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">强大的功能</li></ul><p id="687f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> ABC </strong>缺点:</p><ul class=""><li id="244d" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">很难说基类只是一个接口还是一个更一般的抽象层，因此是另一种设计模式</li></ul><p id="3bb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">协议</strong>优点:</p><ul class=""><li id="54eb" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">简单的</li><li id="e729" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">直觉的</li><li id="5372" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">优雅的</li></ul><p id="0a86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">协议</strong>缺点:</p><ul class=""><li id="6c4e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">隐式(搅乱了Python的禅)</li><li id="4f60" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">没有静态类型检查是没有用的</li></ul><p id="933b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">赞成者:</p><ul class=""><li id="e15e" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">非常明确的意图，名字说它“接口”</li></ul><p id="59dd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">zope.interface缺点:</p><ul class=""><li id="44f5" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">第三方依赖性</li><li id="40be" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">不太擅长类型提示</li></ul><h2 id="b4df" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">使用ABC构建复杂模型</h2><p id="6d08" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">现在我们来看一个使用用ABCs声明的接口的实际例子。让我们定义我们的<em class="ng">基础层接口；这个</em>接口<em class="ng">是</em>与前面的例子非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="adb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们构建一个模型，该模型使用遵循<em class="ng">基础层</em>接口的模型(层)。这个模型<em class="ng">layereddmeanmodel</em>本身就是一个接口实现者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8ce5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们建立两个简单的模型，一个总是预测0，另一个总是预测1:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ca3b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们使用模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="49be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我们可以用接口定义做很多事情。我们本可以在<em class="ng">layereddmeanmodel中使用N层；事实上，我们可以使用<em class="ng"> LayeredMeanModels </em>作为另一个<em class="ng"> LayeredMeanModel的层。这就是接口的力量。</em></em></p><h2 id="dbb2" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">使用协议构建复杂模型</h2><p id="41ae" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">现在我们重复上一个例子，但是使用协议。代码非常相似，除了ABC继承和<em class="ng"> abstractmethod </em> decorator。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a93f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，接口(协议)仍然是隐式的，只有在静态类型检查器中出现类型错误时才会出现。</p><h2 id="7b01" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">ABC:部分实施</h2><p id="643a" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当我们谈到用ABC声明接口时，我们说我们可以将ABC用于比接口更多的地方。ABC的主要用途之一是用于部分实施。创建一个包含一些抽象方法(未实现)和一些可能使用抽象方法的已实现方法的ABC是很常见的。</p><p id="201e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们对这个对话进行编码，我们使用与之前类似的例子，但是现在我们包括了一个<em class="ng"> fit_predict </em>方法(已实现)，它使用了<em class="ng"> fit </em>和<em class="ng"> predict </em>方法(未实现):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="362d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当我们从基类继承并实现<em class="ng"> fit </em>和<em class="ng"> predict </em>方法时，<em class="ng"> fit_predict </em>方法通过继承变得可用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c2e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子清楚地显示了ABC是如何比接口更普遍地被使用的。</p><h2 id="1ba3" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">ABC对协议和多重继承问题</h2><p id="10b1" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当仅仅使用ABC作为接口时，一个潜在的“问题”是多重继承。当我们有两个实现相同接口的对象时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="23b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它们之间非常相似:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8d50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了一些属性(在这种情况下，name属性)，我们希望避免重复的代码，而是让两个<em class="ng"> LayerZeros </em>从第四个类继承fit和predict方法，在这种情况下，LayerZerosMixin:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="460e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们最终会发现两个分层的人都有多个父母。大多数OO开发人员不赞成多重继承；有些人甚至认为它是反模式。这就是为什么许多OO语言不允许多重继承。在Python中，将单词Mixin添加到额外继承类的标题中，可以神奇地解决这个问题。这是面向对象社区中正在进行的辩论。</p><p id="21bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">逻辑层面的问题，问题是多重继承有时会打破继承的规范意义，一个<em class="ng">就是一个</em>关系。例如，假设我们有雇员和一个收银机来支付他们的工资。假设我们有一个支付员工工资的<em class="ng"> Person </em>类和一个<em class="ng"> CashRegister </em>类。如果我们做了类似于<em class="ng"> Employee(Person) </em>的事情，即<em class="ng"> Employee </em>类继承自<em class="ng"> Person </em>，那么一切都没问题，因为该雇员是一个人(至少目前是这样)。但是我们可以做一些类似于<em class="ng"> Employee(Person，CashRegister) </em>的事情，在<em class="ng"> Employee </em>类中包含支付功能。毕竟，报酬决定了就业。这很棘手，因为员工不是收银员。在Python和其他支持多重继承的语言中，一种表明<em class="ng">雇员</em>不是<em class="ng">收银机</em>的方法是将类名重写为<em class="ng">收银机混合信息</em>。</p><p id="faba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如我所说，这是一场持续的辩论。</p><h2 id="8196" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">最后的话</h2><p id="c614" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">正确的选择是一个偏好的问题。使用ABC还是协议由你决定。就个人而言，我对接口使用协议，对部分实现使用ABCs这是我自己的规则。</p><p id="5765" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据科学家的唯一工作是创建jupyter笔记本和腌模型的日子已经一去不复返了。很可能你会被期望开发成品而不是模型和情节。这意味着通过数据采集，一直到模型的已部署API，都要进行编码。换句话说，您需要将您的数据科学技能与软件开发结合起来。在这一点上，接口将使你的生活更容易，你的代码更干净。</p></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="fb90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这个故事对你有用。如果你想知道更多类似的故事，请订阅。</p><div class="ol om gp gr on oo"><a href="https://medium.com/subscribe/@diego-barba" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">每当迭戈·巴尔巴出版时，就收到一封电子邮件。通过注册，您将创建一个中型帐户，如果您还没有…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc ks oo"/></div></div></a></div></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="7dc8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</p><div class="ol om gp gr on oo"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd iu gy z fp ot fr fs ou fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">medium.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc ks oo"/></div></div></a></div></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="473d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我错过了什么，请让我知道。对于任何质疑、批评等。，留言评论。</p></div></div>    
</body>
</html>