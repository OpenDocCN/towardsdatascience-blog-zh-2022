<html>
<head>
<title>Finding “m²” Details on a Floorplan Using Unsupervised Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无监督学习寻找平面布置图上的“m”细节</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/finding-m%C2%B2-details-on-a-floorplan-using-unsupervised-learning-f8f8891befa9#2022-04-20">https://towardsdatascience.com/finding-m%C2%B2-details-on-a-floorplan-using-unsupervised-learning-f8f8891befa9#2022-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="551b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用opencv、pytesseract、scikit-learn和pandas</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/340710a2e3b0cba3b8dd3a942137dd8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GpOG9lfBSFk-o-2_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">斯文·米克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d5d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于可以在搜索中应用个性化过滤器，在网上浏览一处房产会带来无数好处。然而，有一个非常重要的过滤器被遗漏了(至少对于像[ <a class="ae kv" href="https://www.rightmove.co.uk/" rel="noopener ugc nofollow" target="_blank"> 1 </a>，[ <a class="ae kv" href="https://www.zoopla.co.uk/" rel="noopener ugc nofollow" target="_blank"> 2 </a> ]这样的英国房产搜索网站来说是这样的):房产的<strong class="ky ir">平方英尺分割。</strong></p><p id="3cb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有很多情况下，我会发现一个伟大的财产(大小，位置，价格等。)直到我看到它的平面图细节。如果我们可以根据房间的平方米来过滤属性结果，那将会节省我们很多时间。因此，我决定做一个实验，看看如何提取给定房地产广告平面图上的所有“m”细节。</p><h2 id="a5af" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">介绍</h2><p id="9f6a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这篇文章中，我阅读了一个在线平面图图像并对其进行了处理，然后解释了为什么我使用无监督学习算法将相关的文本块分组在一起，演示了进一步的清理并测试了几个不同平面图图像的结果。<a class="ae kv" href="#131c" rel="noopener ugc nofollow"> <strong class="ky ir">在结论部分</strong> </a>，我提到了我遇到的局限性和任何改进的空间(隐喻性的)。</p><h2 id="7181" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">步骤:</h2><p id="f41c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="#da5b" rel="noopener ugc nofollow"> <strong class="ky ir">第一步:</strong>读取并处理输入的平面图图像(opencv) </a> <br/> <a class="ae kv" href="#1048" rel="noopener ugc nofollow"> <strong class="ky ir">第二步:</strong>检测字符及其位置(pytesserac)</a><br/><a class="ae kv" href="#ed4c" rel="noopener ugc nofollow"><strong class="ky ir">第三步:</strong>聚类字符(scikit-learn)</a><br/><a class="ae kv" href="#f803" rel="noopener ugc nofollow"><strong class="ky ir">第四步:</strong>处理聚类(熊猫)</a> <br/> <a class="ae kv" href="#7551" rel="noopener ugc nofollow"> <strong class="ky ir">测试:</strong></a></p><h2 id="1ab6" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">导入库</h2><p id="3ca8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们需要以下内容:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1550" class="ls lt iq mr b gy mv mw l mx my">from matplotlib import pyplot as plt<br/>import cv2<br/>import numpy as np</span><span id="a86d" class="ls lt iq mr b gy mz mw l mx my">import pandas as pd<br/>pd.set_option('display.max_rows', 500)<br/>pd.set_option('display.max_columns', 500)<br/>pd.set_option('display.max_colwidth', 500)</span><span id="25d0" class="ls lt iq mr b gy mz mw l mx my">%matplotlib inline<br/>plt.rcParams["figure.figsize"] = (40,20)</span><span id="be71" class="ls lt iq mr b gy mz mw l mx my">import pytesseract<br/>pytesseract.pytesseract.tesseract_cmd = r'/usr/local/bin/tesseract/'</span><span id="03ca" class="ls lt iq mr b gy mz mw l mx my">from sklearn.preprocessing import StandardScaler<br/>from sklearn.cluster import DBSCAN</span></pre><h2 id="da5b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">步骤1:读取和处理输入图像</h2><p id="a7b3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们可以很容易地阅读如下平面图图像:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ef93" class="ls lt iq mr b gy mv mw l mx my">img = cv2.imread('Dummy Floorplanner Input Image.png')</span><span id="a99c" class="ls lt iq mr b gy mz mw l mx my">plt.imshow(img)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/83ad3bbd1b260b770e20048df13cfa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5MXXpL9-3yrQCA9wA7QQQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按作者输入图像</p></figure><p id="a377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在处理输入图像，这样，当输入到pytesseract时，它可以揭示更多关于文本块的信息。请阅读下文了解更多关于阈值的信息。</p><div class="nb nc gp gr nd ne"><a href="https://pyimagesearch.com/2021/04/28/opencv-thresholding-cv2-threshold/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">OpenCV阈值(cv2.threshold ) - PyImageSearch</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在本教程中，您将学习如何使用OpenCV和cv2.threshold函数来应用基本的阈值处理和Otsu…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">pyimagesearch.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kp ne"/></div></div></a></div><p id="9f53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过处理后，我们的输入图像如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fdd4" class="ls lt iq mr b gy mv mw l mx my">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br/>blur = cv2.GaussianBlur(gray, (3,3), 0)<br/>thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]<br/>plt.imshow(gray)<br/>plt.imshow(blur)<br/>plt.imshow(thresh)</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nt kk nu nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/68240faa4fa678ae6f95ac73bd2a1794.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*2627wxSP48mEU2_Is_iR8g.png"/></div></figure><figure class="nt kk nz nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/3856f18eb3d48de85a66e48d58abf543.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*JPM7G95dYZWhCyP23PqeGQ.png"/></div></figure><figure class="nt kk oa nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/85cc8cabf4b96409bd84d0d1c5e56527.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*lQQVTQFdVo7AkjvmKTQ_bw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ob di oc od translated">按作者分类的图像(灰色、模糊、阈值)</p></figure></div><h2 id="1048" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">第二步:</strong>检测字符及其位置</h2><p id="a954" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Pytesseract从左上到右下开始读取图像像素(就像看书一样)。因此，如果一个房间的信息与另一个房间的信息在同一水平层上，那么两个房间的文本将被连接到一个房间，并且没有逻辑方法来正确解析完整的字符串，如下所示(餐厅和卧室的名称和尺寸被连接)。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="dd4c" class="ls lt iq mr b gy mv mw l mx my">print(pytesseract.image_to_string(thresh))</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/552b1461c45e3e67e715c1886efe46e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*gxOrl-nmrIBRo2VpqA0l9A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="fe5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，还有另一个pytesseract函数(image_to_boxes)可以检测每个字符及其在图像上的位置。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e60c" class="ls lt iq mr b gy mv mw l mx my">df_img = pd.DataFrame([x.split(' ') for x in </span><span id="653b" class="ls lt iq mr b gy mz mw l mx my">pytesseract.image_to_boxes(thresh).split('\n')], </span><span id="bed5" class="ls lt iq mr b gy mz mw l mx my">                    columns=['char', 'left', 'top', 'width',        'height', 'other'])</span><span id="cc6d" class="ls lt iq mr b gy mz mw l mx my">df_img = df_img[ ~ df_img['left'].isnull()]</span><span id="8d0b" class="ls lt iq mr b gy mz mw l mx my"># dropping whitespace characters like<br/># [',' '.' '/' '~' '"' "'" ':' '°' '-' '|' '=' '%' '”']</span><span id="0668" class="ls lt iq mr b gy mz mw l mx my">df_img = df_img[ ~ df_img['char'].str.contains(r'[^\w\s]')].reset_index(drop=True)</span><span id="aede" class="ls lt iq mr b gy mz mw l mx my">df_img[['left', 'top', 'width', 'height']] = df_img[['left', 'top', 'width', 'height']].astype(int)</span><span id="f3be" class="ls lt iq mr b gy mz mw l mx my">df_img.head(20)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/73b1b69040b918343866d2f91fbe25d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*obIHK5FAidqwUp6nnoKdOw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="4676" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们根据这些字符的x-y坐标来绘制它们。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1f45" class="ls lt iq mr b gy mv mw l mx my">fig, ax = plt.subplots()</span><span id="1933" class="ls lt iq mr b gy mz mw l mx my">ax.scatter(df_img['left'].tolist(), df_img['top'].tolist())</span><span id="02b3" class="ls lt iq mr b gy mz mw l mx my">for i, txt in enumerate(df_img['char'].tolist()):<br/>    ax.annotate(txt, (df_img['left'].tolist()[i],<br/>                      df_img['top'].tolist()[i]), <br/>                <br/>                textcoords='data', <br/>                <br/>                fontsize=28)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/794cf3b2e3e04be29f3df746fda430b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPpy0MbS3_jnXdons85BMA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="be00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们需要对近距离内的数据点(字符)进行分组。</p><h2 id="ed4c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">第三步:</strong>聚类字符</h2><p id="8172" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果需要，请阅读下面的帖子来了解DBSCAN是如何工作的。</p><div class="nb nc gp gr nd ne"><a rel="noopener follow" target="_blank" href="/dbscan-clustering-explained-97556a2ad556"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">DBSCAN集群—解释</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">详细的理论解释和scikit-learn实现</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">towardsdatascience.com</p></div></div><div class="nn l"><div class="oh l np nq nr nn ns kp ne"/></div></div></a></div><p id="283b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DBSCAN，我们能够将相关的字符块组合在一起。当该聚类算法预测值为-1时，该数据点被视为异常值。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="4875" class="ls lt iq mr b gy mv mw l mx my">X = StandardScaler().fit_transform(df_img[['left', 'top']].values)</span><span id="46b0" class="ls lt iq mr b gy mz mw l mx my">db = DBSCAN(eps=0.19, min_samples=10)</span><span id="cdaa" class="ls lt iq mr b gy mz mw l mx my">db.fit(X)</span><span id="f702" class="ls lt iq mr b gy mz mw l mx my">y_pred = db.fit_predict(X)<br/>plt.figure(figsize=(10,6))<br/>plt.scatter(X[:,0], X[:,1],c=y_pred, cmap='Paired')<br/>plt.title("Clusters determined by DBSCAN")</span><span id="9572" class="ls lt iq mr b gy mz mw l mx my">df_img['cluster'] = pd.Series(y_pred)<br/>df_img.groupby(['cluster'])['char'].apply(lambda x: ' '.join(x)).reset_index()</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nt kk oi nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/25ea13822729600715f531ae777f7bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*Hwgfg0mm0QsWzEANqdIqww.png"/></div></figure><figure class="nt kk oj nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/21df13c11d89e022c56010f5697c140d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*6rXAQm3jIbbP30Mydul7vQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ok di ol od translated">作者提供的图片</p></figure></div><p id="b746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的图像中我们可以看到，聚类算法在对平面图图像上的字符进行分组时工作得非常好。然而，它仍然需要一些进一步的清洁和处理。</p><h2 id="f803" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">步骤4:处理集群</h2><p id="2c15" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">通常，在平面图上，我们有位置的类型(卧室、厨房、花园等。)，其尺寸以米为单位，最后以英尺为单位。有了这些信息，我们可以假设我们第一次看到一个聚类的数字是我们可以连接文本的最低水平。换句话说，在一个群中，如果在一个数字第一次出现的级别之下有一个数字，这可能是一个平方英尺信息。让我们从数据框中删除所有平方英尺(不是米)的行。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="84e3" class="ls lt iq mr b gy mv mw l mx my">df_cc = df_img.copy().reset_index(drop=True)</span><span id="b3f3" class="ls lt iq mr b gy mz mw l mx my">for cluster_no in df_cc['cluster'].unique():<br/>    <br/>    index_char_top_list = []<br/>    <br/>    # if the data point is not an outlier<br/>    if cluster_no!=-1:<br/>    <br/>        index_char_top_list = [</span><span id="18f5" class="ls lt iq mr b gy mz mw l mx my">(index, char, top) for index, char, top in <br/>            <br/>            <br/>            zip(df_cc[(df_cc['cluster']==cluster_no)].index, <br/>                df_cc[(df_cc['cluster']==cluster_no)]['char'].values, <br/>                df_cc[(df_cc['cluster']==cluster_no)]['top'].values)</span><span id="0873" class="ls lt iq mr b gy mz mw l mx my">if</span><span id="7a67" class="ls lt iq mr b gy mz mw l mx my">char.isdigit()</span><span id="bd1b" class="ls lt iq mr b gy mz mw l mx my">]</span><span id="791c" class="ls lt iq mr b gy mz mw l mx my">    <br/>    if index_char_top_list:<br/>    <br/>        df_cc = df_cc[</span><span id="0cbb" class="ls lt iq mr b gy mz mw l mx my">~ ((df_cc['cluster']==cluster_no) &amp; (df_cc['top'] &lt;= ( index_char_top_list[0][2] - 5 )))</span><span id="1a38" class="ls lt iq mr b gy mz mw l mx my">                      ]</span><span id="e2ee" class="ls lt iq mr b gy mz mw l mx my">df_img.shape[0], df_cc.shape[0]<br/># (149 rows went down to 104 rows)</span></pre><p id="1d65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个函数，它可以将一串数字解析成宽度、长度维度。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cb5e" class="ls lt iq mr b gy mv mw l mx my">def dimension_splitter(input_text):<br/>    <br/>    input_text_len = len(input_text)</span><span id="613d" class="ls lt iq mr b gy mz mw l mx my">    if input_text_len%2==0:<br/>        split_text_by = int(input_text_len/2)<br/>    else:<br/>        split_text_by = int(input_text_len/2+0.5)<br/>    <br/>    dim1 = input_text[:split_text_by]</span><span id="4c0b" class="ls lt iq mr b gy mz mw l mx my">    dim2 = input_text[split_text_by:]<br/>    <br/>    dim1 = float('{}.{}'.format(dim1[:-2], dim1[-2:]))</span><span id="3358" class="ls lt iq mr b gy mz mw l mx my">    dim2 = float('{}.{}'.format(dim2[:-2], dim2[-2:]))</span><span id="da90" class="ls lt iq mr b gy mz mw l mx my">    return dim1, dim2</span></pre><p id="fb85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们对清理后的聚类数据框进行分组，并引入维度列。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d5d9" class="ls lt iq mr b gy mv mw l mx my">df_cc_grouped = df_cc.groupby(['cluster'])['char'].apply(lambda x: ' '.join(x)).reset_index(name='text')</span><span id="a429" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped['text_digits'] = df_cc_grouped.apply(lambda x: ''.join([y for y in x['text'] if y.isdigit()]), axis=1)</span><span id="af69" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped['text_digits_len'] = df_cc_grouped.apply(lambda x: len([y for y in x['text'] if y.isdigit()]), axis=1)</span><span id="1489" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped = df_cc_grouped[(df_cc_grouped['cluster']!=-1) &amp; <br/>                              (df_cc_grouped['text_digits_len']&gt;=5)].reset_index(drop=True)</span><span id="4914" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped['room'] = df_cc_grouped.apply(<br/>    <br/>    lambda x: x['text'][:[x.isdigit() for x in x['text']].index(True)].strip()<br/>                                                      <br/>                                                      , axis=1)</span><span id="f5f3" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped['length'] = df_cc_grouped.apply(lambda x: dimension_splitter(x['text_digits'])[0]<br/>                                                      <br/>                                                      , axis=1)</span><span id="6d6f" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped['width'] = df_cc_grouped.apply(lambda x: dimension_splitter(x['text_digits'])[1]<br/>                                                                                                           <br/>                                                     , axis=1)</span><span id="c819" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped['surface'] = np.round(df_cc_grouped['length'] * df_cc_grouped['width'], 2)</span><span id="848e" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nt kk om nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/c3be4b3bf2d5df5e8d857c3f2e36410b.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*Ed4vtR7LOzbYLAMriMID4g.jpeg"/></div></figure><figure class="nt kk on nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/fc7fb9235d8b29545d2d508e471446f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1670/format:webp/1*wk3qWGBrjmy6gJ3SRKqYPA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk oo di op od translated">作者提供的图片</p></figure></div><p id="ca1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以正确地提取所有的平方米信息。让我们看看我们的逻辑是否适用于其他图像。</p><h2 id="7551" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">试验</h2><p id="7b64" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在第一项测试中，在检测步骤中，pytesseract误读了“接待室”中的一些字母，并在检测到Utility之前多加了一个“a”。然而，在此之后，无监督学习如预期那样工作，并正确地揭示了所有信息。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="91ba" class="ls lt iq mr b gy mv mw l mx my">img_test1 = cv2.imread('Dummy Floorplanner Test 1.png')</span><span id="18bd" class="ls lt iq mr b gy mz mw l mx my">plt.imshow(img_test1)</span><span id="4ba2" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped_test1</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nt kk oq nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/dc100ac473643bed4626761fe6a47d7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*8UrItHJkN85GtPvMh_IdAQ.png"/></div></figure><figure class="nt kk or nv nw nx ny paragraph-image"><img src="../Images/2cfcaf00e04d4b88135f255f2d5602ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1608/format:webp/1*O3r5e5HPdpcjnjAYbPmAmQ.png"/><p class="kr ks gj gh gi kt ku bd b be z dk os di ot od translated">作者提供的图片</p></figure></div><p id="7863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行第2号测试时没有出现任何问题。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f238" class="ls lt iq mr b gy mv mw l mx my">img_test2 = cv2.imread('Dummy Floorplanner Test 2.png')</span><span id="fb6b" class="ls lt iq mr b gy mz mw l mx my">plt.imshow(img_test2)</span><span id="c625" class="ls lt iq mr b gy mz mw l mx my">df_cc_grouped_test2</span></pre><div class="kg kh ki kj gt ab cb"><figure class="nt kk ou nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/eac219850d2301bb46f57f009090cd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*46ax88Hxe2bwJoviG2DaQQ.png"/></div></figure><figure class="nt kk ov nv nw nx ny paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/0ba1f227c07e9e029f6b9422d9ece357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1532/format:webp/1*NRJFC2fNppRC273_PWSBYA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk ow di ox od translated">作者提供的图片</p></figure></div><p id="c43c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管平面布局不同(纵向或横向)，我们能够在大多数地方提取平方米信息。</p><p id="131c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论</strong></p><p id="03e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我演示了如何使用OCR库(pytesseract)来检测房地产平面图上的字母和数字，然后使用无监督学习算法(DBSCAN)来收集相关信息，以找到每个房间的平方米信息。</p><p id="ff5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果pytesseract可以正确地检测字符，我们可以毫无问题地找到房产的平方米分割。我们利用了这样一个事实，即英国的房产平面图具有几乎相同的结构:(1)房间的类型，下面的尺寸(2)米，下面的尺寸(3)英尺。但是，该脚本需要进一步开发，以处理具有不同结构的平面图图像，或者对缺失/未检测到的数据进行一些科学猜测。</p><p id="3a09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>