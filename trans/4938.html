<html>
<head>
<title>Generate Synthetic Mobility Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成合成移动性数据</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/generate-synthetic-mobility-data-a32894f1a253#2022-11-02">https://towardsdatascience.com/generate-synthetic-mobility-data-a32894f1a253#2022-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a021" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">合成移动性数据生成的简单解决方案建议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/72d3dd43febb667053137f79de2de5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tNZ_SGHUS5S0qMuFycgzQg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><p id="91c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">移动性数据是通过正常活动被动产生的设备的地理位置。从交通规划到移民预测，它都有重要的应用。由于移动数据很少且难以收集，研究人员已经开始探索综合生成数据的解决方案。</p><p id="1192" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将讨论一个生成合成移动数据的简单解决方案。该合成数据可用于研究目的和训练/微调算法。例如，可以综合生成标记的移动性数据，并训练模型来预测城市交通拥堵。然后，经过训练的模型可以应用于现实生活中的数据。</p><p id="6d15" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码可以在这里找到<a class="ae lr" href="https://github.com/aloncohen1/synthetic_mobility_data_generator" rel="noopener ugc nofollow" target="_blank">，你也可以用</a><a class="ae lr" href="https://colab.research.google.com/drive/1b7Plly940-GYgjNdP0C-klabDyPiMfUg?usp=sharing" rel="noopener ugc nofollow" target="_blank">这个colab </a>笔记本自己试试。</p><h1 id="e138" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数据</h1><p id="5ae3" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">要合成生成的数据将代表从蜂窝电话设备收集的位置数据记录。通常，此类数据包含以下属性:</p><ul class=""><li id="828a" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">phone_id —手机的唯一标识符</li><li id="cda4" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">phone_type —手机操作系统(iOS / Android)</li><li id="ac58" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">时间戳(纪元时间)</li><li id="c9c3" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">纬度</li><li id="3cfb" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">经度</li><li id="8e5f" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">精确度(以米为单位)</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="4ee6" class="ls lt iq bd lu lv nm lx ly lz nn mb mc jw no jx me jz np ka mg kc nq kd mi mj bi translated">方法学</h1><h1 id="784e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">A部分—获取公共位置数据</h1><p id="1a4d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在美国选择一个地点，创建一个x米的bbox(边界框)。接下来，获取公共数据集:</p><ul class=""><li id="a9f7" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated"><strong class="kx ir">居住地点—</strong>bbox内的建筑样本(<a class="ae lr" href="https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/MSBFP2/FeatureServer/0" rel="noopener ugc nofollow" target="_blank"> ArcGIS Rest API </a>)</li><li id="63bf" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><strong class="kx ir">兴趣点</strong>(兴趣点)bbox内的业务。(<a class="ae lr" href="https://gist.github.com/aloncohen1/f3e7df8833f4d7ddca78486dfc9ec969" rel="noopener ugc nofollow" target="_blank"> Kaggle数据集</a>)</li><li id="ff75" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated"><strong class="kx ir">道路</strong>—bbox内的所有道路，以图形表示(<a class="ae lr" href="https://wiki.openstreetmap.org/wiki/Overpass_API" rel="noopener ugc nofollow" target="_blank"> OSM立交桥API </a>，使用<a class="ae lr" href="https://osmnx.readthedocs.io/en/stable/osmnx.html" rel="noopener ugc nofollow" target="_blank"> osmnx </a>)</li></ul><h2 id="2a38" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated"><strong class="ak">创建一个边界框</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/b69e058416f918daf92ef4335e1ae2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BI0Qmdfglas5Q074cyTMlw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h2 id="8cd7" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">获取ArcGIS <strong class="ak">居住地点</strong></h2><p id="8b25" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用arcgis_rest_url获取bbox中建筑物的多边形。<br/>*限于2000个多边形样本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/4fc0124e2d53afcaa19ea7d056adcaa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEE_C3m0JFtSeBD62w7POA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h2 id="bb61" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">获取Kaggle POIs数据集</h2><p id="c962" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">使用Kaggle API下载POIs数据集。然后对其进行解析，将其加载到geopandas，并将数据集过滤为bbox内的点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/06cb456f01127d1a3bf00f0b25233507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kF9ez-EI2pIRhs5qtHo5uw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h2 id="3eaa" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">从天桥API获取OSM道路</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/d890da7b4cbcd49aa96682e06b3edd76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WcSgh3-90EHtwHRiEKxI0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h1 id="8e2c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">B部分—生成合成时间线</h1><p id="5b3a" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在，我们已经拥有了创建电话时间表所需的一切— <strong class="kx ir">居住位置</strong>(将用于在家里、家人和朋友家的停留)、<strong class="kx ir">poi</strong>位置(将用于商店访问)和<strong class="kx ir">道路</strong>(将用于停留之间的驾驶)。在生成实际的移动性数据之前，我们将生成一个<strong class="kx ir">合成时间线</strong>来保存手机停留及其时间框架。</p><h2 id="5bba" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">合成时间轴逻辑</h2><p id="e8af" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">综合时间线逻辑将在开始日期和结束日期之间的所有日期上迭代，并随机化在工作场所、居住位置和兴趣点的停留。为了保证正常的人类行为，逻辑将只产生工作日的工作停留，并确保用户晚上回家。</p><p id="b99f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">运行逻辑之前，请确保:</p><ul class=""><li id="7e12" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq mu mv mw mx bi translated">设置随机的家庭和工作地点</li><li id="bc6f" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">设定时间框架(开始日期和结束日期)</li><li id="0a85" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq mu mv mw mx bi translated">设置给定日期要访问的最大兴趣点和最大居住位置</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6795" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的gif显示了我们合成时间线的第一天</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h1 id="4aad" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">C部分—生成合成流动性数据(信号)</h1><p id="e89a" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们的合成时间线已经准备好了，需要一个新的逻辑把它翻译成合成信号。我们的时间表中的第一个事件是寄宿家庭(00:00 -&gt; 08:00)，所以让我们从为这次住宿生成信号开始。</p><h2 id="0ecc" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">静态模式信号</h2><p id="246d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">以下脚本将生成停留开始和停留结束之间的信号数据帧。采样率(相邻信号之间的时间间隔)是一个可配置的参数。我把它设置为600秒(5分钟)。每一个信号最近，lng将被随机“噪声因子”所噪声化</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0c96" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在第一次停留时应用该逻辑将产生以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oi ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h2 id="0586" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">驱动模式信号</h2><p id="d056" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们时间线上的下一个事件是在“住所1290”的停留，但是在为这次停留生成信号之前，我们需要为将我们的电话从其起点(家)带到其目的地(“住所1290”)的驱动器生成信号。</p><p id="7af0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们将使用道路图并寻找从起点到终点的最短路径。然后，我们将以60秒的采样率在有序路段上随机生成信号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c8f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是合成驱动信号在地图上的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure><h2 id="b6da" class="nr lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">全合成移动性数据生成</h2><p id="c6bb" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在我们的最后一步，我们将迭代我们所有的合成时间线。对于每次停留，我们将生成静态模式信号，并且在每两次停留之间，我们将生成驱动模式信号。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6b4a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">轰！</strong>我们现在拥有由开源软件包和免费数据生成的完整的合成移动数据</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Kepler.gl可视化</p></figure></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h1 id="dd65" class="ls lt iq bd lu lv nm lx ly lz nn mb mc jw no jx me jz np ka mg kc nq kd mi mj bi translated">结论</h1><p id="9475" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">生成合成移动性数据是可行，且不需要特殊的资源。我们需要的所有数据都在那里，可以免费使用。话虽如此，仍有改进的余地:</p><ol class=""><li id="126f" class="mp mq iq kx b ky kz lb lc le mr li ms lm mt lq ol mv mw mx bi translated">逻辑的幼稚——逻辑非常简单，所以输出并不真正代表<strong class="kx ir">完整的</strong>人类行为(例如出国旅行、移民等)..)</li><li id="22d5" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq ol mv mw mx bi translated">逻辑的效率——逻辑需要一些时间来运行。主要的瓶颈是驱动生成部分(最短路径计算)</li><li id="9019" class="mp mq iq kx b ky my lb mz le na li nb lm nc lq ol mv mw mx bi translated">逻辑的覆盖范围——逻辑仅支持美国，这是因为我使用了<a class="ae lr" href="https://github.com/microsoft/USBuildingFootprints" rel="noopener ugc nofollow" target="_blank"> USBuildingFootprints </a>非常准确，但不幸的是，它仅覆盖美国。</li></ol><p id="8892" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如前所述，代码可以在<a class="ae lr" href="https://github.com/aloncohen1/synthetic_mobility_data_generator" rel="noopener ugc nofollow" target="_blank">这里</a>找到，你可以用<a class="ae lr" href="https://colab.research.google.com/drive/1b7Plly940-GYgjNdP0C-klabDyPiMfUg?usp=sharing" rel="noopener ugc nofollow" target="_blank">这个colab </a>笔记本自己试试。</p><p id="d235" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">*除非另有说明，所有图片均为作者所有。</p><p id="3eba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="om">感谢您的阅读！</em></p></div></div>    
</body>
</html>