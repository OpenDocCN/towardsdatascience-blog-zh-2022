<html>
<head>
<title>13 Useful Shell Commands You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该知道的13个有用的Shell命令</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/13-useful-shell-commands-you-should-know-4a28cfbe5732#2022-08-30">https://towardsdatascience.com/13-useful-shell-commands-you-should-know-4a28cfbe5732#2022-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2b3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高生产力和增强您的终端技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aca7f5db846861b9eb3270a39b0bb6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2abBKrocb8c_G0vkSNemHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用DALLE-2生成的图像</p></figure><p id="dfd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于很多程序员来说，终端就像第二个家，只不过一切都触手可及。想象一下，当你舒舒服服地躺在床上，冲咖啡，用手指轻轻一划就可以毫不费力地拉开窗帘，甚至可以遛狗。这就是开发人员喜欢命令行的原因:您可以快速完成所有工作，而无需点击数十个窗口。</p><p id="79a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，为了提高使用shell的效率，您必须习惯于使用纯文本界面执行任务，并且不可避免地要学习一些命令。一旦你知道了像改变目录和文件目录这样的基础知识，是时候学习那些常用的命令了，这些命令会给你的控制台工作效率带来积极的影响。</p><p id="23be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将向您展示我一直使用的13个命令，按用例分组。请注意，有些系统可能没有捆绑所有这些实用程序，但是您可以使用您选择的软件包管理器轻松地安装它们。</p><h2 id="c03e" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">更好的输出可视化</h2><p id="7eec" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果您使用终端已经有一段时间了，那么您肯定会遇到这样的情况:命令输出太大，以至于无法显示在屏幕上，甚至无法显示在终端历史记录中。在读取大型日志文件或列出文件和目录时，通常会出现这种情况。</p><p id="8afe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，有三个命令可以解决这个问题:<code class="fe ms mt mu mv b">head</code>、<code class="fe ms mt mu mv b">tail</code>和<code class="fe ms mt mu mv b">less</code>。</p><p id="3a4d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">head</code>仅打印输入的第一行(或字节)。默认打印行数为10，但您可以通过<code class="fe ms mt mu mv b">-n</code>选项指定:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="bf83" class="lu lv it mv b gy na nb l nc nd">$ cat large_file.log | head -n 30</span></pre><p id="ff34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的命令只打印cat-ted文件的前30行。</p><p id="0393" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">tail</code>与<code class="fe ms mt mu mv b">head</code>相反:仅打印给定输入的最后一行(或字节):</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b330" class="lu lv it mv b gy na nb l nc nd">$ cat large_file.log | tail</span></pre><p id="bba5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的命令打印给定输入的最后10行。</p><p id="107c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，<code class="fe ms mt mu mv b">less</code>允许您使用箭头键或滚轮、利用快捷方式等，轻松浏览文本，无论是文件还是命令输出。如果你必须浏览大量输出，<code class="fe ms mt mu mv b">less</code>是你最好的朋友。</p><p id="ef0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不要忘记按<code class="fe ms mt mu mv b">q</code>从<code class="fe ms mt mu mv b">less</code>退出，否则你可能会永远被锁在一个仅次于<code class="fe ms mt mu mv b">vim</code>的无法逃脱的监狱里。在本文的后面，我们将会遇到一些常见的<code class="fe ms mt mu mv b">less</code>命令的实际应用。</p><h2 id="e70a" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">计算代码行数</h2><p id="2ccb" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果您正在进行一个大型项目，您可能会好奇它由多少行代码组成。您可以利用命令行的强大功能来为您完成繁重的工作，而不是打开每一个源代码文件，记下行数，然后手动添加它们。</p><p id="bea3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，<code class="fe ms mt mu mv b">wc</code>命令可以和它的<code class="fe ms mt mu mv b">-l</code>选项一起使用来计算一个给定文件的行数。然而，代码库是由多个文件和嵌套目录组成的。这就是<code class="fe ms mt mu mv b">find</code>命令派上用场的地方。</p><p id="1b39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">$ find &lt;dir_name&gt; -name "*.py"</code></p><p id="fb6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将查找指定目录及其子目录中扩展名为<code class="fe ms mt mu mv b">.py</code>的每个文件。除此之外，您可以将结果传输到<code class="fe ms mt mu mv b">sort</code>以产生更整洁的输出。最后的命令如下所示:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d37b" class="lu lv it mv b gy na nb l nc nd">$ find . -name "*.cpp" | xargs wc -l | sort -nr</span></pre><p id="b1a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的命令打印当前目录及其子目录中每个<code class="fe ms mt mu mv b">.cpp</code>文件的行数，加上总行数，全部以整齐的降序排列。</p><p id="2fd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果您想在普查中包含其他文件类型，例如头文件，该怎么办呢？<code class="fe ms mt mu mv b">find</code>允许您指定多个模式进行查找:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="e0ad" class="lu lv it mv b gy na nb l nc nd">$ find . -name '*.cpp' -o -name '*.hh' | xargs wc -l | sort -nr</span></pre><p id="ffee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我在一个C++项目中用来计算所有代码行的命令，包括源代码和头文件。下面是一个输出示例:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="65a1" class="lu lv it mv b gy na nb l nc nd">1917 total<br/>  768 ./src/processor.cpp<br/>  137 ./headers/processor.hh<br/>  100 ./headers/byte_code.hh<br/>   84 ./src/byte_code.cpp<br/>   75 ./src/memory.cpp<br/>   64 ./src/main.cpp<br/>   55 ./src/registers.cpp<br/>   42 ./headers/registers.hh<br/>   40 ./headers/memory.hh</span></pre><p id="08ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果你的代码库太大，以至于把所有东西都打印到控制台上变得很糟糕，你总是可以把输出传递给<code class="fe ms mt mu mv b">less</code>。因此，最终的行计数器命令应该是:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="56d4" class="lu lv it mv b gy na nb l nc nd">$ find . -name '*.cpp' -o -name '*.hh' | xargs wc -l | sort -nr | less</span></pre><p id="ecef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您厌倦了一直输入它，您可以将它放在bash文件中。</p><h2 id="64d6" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">获取磁盘使用情况和文件大小</h2><p id="cb39" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果您想知道您的虚拟或物理存储设备上还有多少空闲空间，您可以使用<code class="fe ms mt mu mv b">df</code>命令。实际上，您可能希望使用<code class="fe ms mt mu mv b">-h</code>选项以人类可读的格式打印尺寸。</p><p id="b797" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">$ df -h</code></p><p id="91b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和示例输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="c995" class="lu lv it mv b gy na nb l nc nd">Filesystem      Size  Used Avail Use% Mounted on<br/>dev             1,9G     0  1,9G   0% /dev<br/>run             1,9G   18M  1,9G   1% /run<br/>/dev/sda2       102G   23G   74G  24% /<br/>tmpfs           1,9G  120M  1,8G   7% /dev/shm<br/>/dev/loop1      114M  114M     0 100% /var/lib/snapd/snap/core/13308<br/>tmpfs           1,9G   42M  1,9G   3% /tmp<br/>/dev/sda1       300M  312K  300M   1% /boot/efi</span></pre><p id="11cf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想打印一个目录的大小及其内容，你可以使用<code class="fe ms mt mu mv b">du</code>命令。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="f3bd" class="lu lv it mv b gy na nb l nc nd">$ du . -hacS --apparent-size</span></pre><p id="0c3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该命令从当前目录开始，以人类可读的格式列出所有文件和目录的大小，并打印总大小。示例输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="d295" class="lu lv it mv b gy na nb l nc nd">1,3K ./src/main.cpp<br/>870 ./src/errors.cpp<br/>22K ./src/processor.cpp<br/>1,7K ./src/memory.cpp<br/>1,2K ./src/registers.cpp<br/>1,8K ./headers/byte_code.hh<br/>4,4K ./headers/processor.hh<br/>1,1K ./headers/memory.hh<br/>16K ./headers<br/>734 ./Makefile<br/>66K total</span></pre><p id="ee55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">进一步的改进是排除像<code class="fe ms mt mu mv b">.git</code>这样的目录，并使用<code class="fe ms mt mu mv b">less</code>输出结果:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="34f4" class="lu lv it mv b gy na nb l nc nd">$ du . --exclude "**/.git" -hacS --apparent-size | less</span></pre><h2 id="ef2c" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">定位文件和程序</h2><p id="f748" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果您必须在系统中搜索一个文件，您可以使用<code class="fe ms mt mu mv b">locate</code>命令来查找模式或确切的文件名。例如，您想找到您计算机上的所有<code class="fe ms mt mu mv b">.jpg</code>文件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="0975" class="lu lv it mv b gy na nb l nc nd">$ locate .jpg</span></pre><p id="1d51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和示例输出:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="cb30" class="lu lv it mv b gy na nb l nc nd">/boot/grub/themes/Vimix/archlinux03.jpg<br/>/boot/grub/themes/Vimix/archlinux04.jpg<br/>/boot/grub/themes/Vimix/archlinux06.jpg<br/>/usr/share/app-info/icons/archlinux-arch-community/64x64/freewheeling_freewheeling.jpg</span></pre><p id="839c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，如果您想定位可执行文件、源代码或手册页，您可以使用<code class="fe ms mt mu mv b">whereis</code>命令:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="4b58" class="lu lv it mv b gy na nb l nc nd">$ whereis gcc</span></pre><p id="bd7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的命令查找以“gcc”作为基本名称的文件:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="1107" class="lu lv it mv b gy na nb l nc nd">gcc: /usr/bin/gcc /usr/lib/gcc /usr/share/man/man1/gcc.1.gz /usr/share/info/gcc.info.gz</span></pre><p id="07d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您必须定位某个程序的安装位置时,<code class="fe ms mt mu mv b">whereis</code>命令会很有用。或者，你可以使用<code class="fe ms mt mu mv b">which</code>，但是它的功能比较弱:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="a252" class="lu lv it mv b gy na nb l nc nd">$ which gcc</span><span id="469a" class="lu lv it mv b gy ne nb l nc nd">/usr/bin/gcc</span></pre><h2 id="33b6" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">比较文件</h2><p id="2def" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">假设您必须检查两个文件是否相等，或者，如果它们不相同，您想知道区别在哪里。<code class="fe ms mt mu mv b">cmp</code>和<code class="fe ms mt mu mv b">diff</code>就是为此而生。</p><p id="f1e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">cmp</code>是更简单的选项。它逐字节比较两个文件，并输出第一个不匹配的字节和行号。如果文件相等，它不会输出任何内容:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="59f7" class="lu lv it mv b gy na nb l nc nd">$ cmp maths.c setup.py</span><span id="1a02" class="lu lv it mv b gy ne nb l nc nd">maths.c setup.py differ: byte 1, line 1</span></pre><p id="f21a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想要更详细的比较，<code class="fe ms mt mu mv b">diff</code>显示文件的不同之处:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="b58b" class="lu lv it mv b gy na nb l nc nd">$ diff file1.txt file2.txt</span><span id="009b" class="lu lv it mv b gy ne nb l nc nd">13c13<br/>&lt;         return NULL;<br/>---<br/>&gt;         return NULLoaoaoaoao;</span></pre><p id="7035" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于并排比较，您可以使用<code class="fe ms mt mu mv b">-y</code>选项:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="9705" class="lu lv it mv b gy na nb l nc nd">$ diff -y file1.c file2.c</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/49ac68f760061d1925872d3772a256f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZRvsvb_52U0S151ColRr7A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本输出。需要一个图像来保持输出格式。</p></figure><h2 id="a4cc" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">获取设备状态</h2><p id="8357" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><code class="fe ms mt mu mv b">acpi</code>实用程序显示关于当前电池电量、热量状态、冷却等有用信息。我通常添加<code class="fe ms mt mu mv b">-V</code>选项来显示所有可用信息:</p><p id="a85e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">$ acpi -V</code></p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="16d0" class="lu lv it mv b gy na nb l nc nd">Battery 0: Full, 100%<br/>Battery 0: design capacity 3691 mAh, last full capacity 2814 mAh = 76%<br/>Adapter 0: on-line<br/>Thermal 0: ok, 45.0 degrees C<br/>Thermal 0: trip point 0 switches to mode critical at temperature 126.0 degrees C<br/>Thermal 1: ok, 51.0 degrees C<br/>Thermal 1: trip point 0 switches to mode critical at temperature 95.0 degrees C<br/>Cooling 0: Fan 0 of 1</span></pre><p id="4c70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我经常发现自己在系统特别加载时使用<code class="fe ms mt mu mv b">acpi</code>来控制温度。</p><h2 id="a955" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">测量执行时间</h2><p id="83ea" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">你有没有想过一个命令或一个脚本需要多少时间来执行？无论您想知道一个编译过程持续了多长时间，还是想比较两个命令的性能，<code class="fe ms mt mu mv b">time</code>实用程序都允许您测量执行时间和其他有用的参数，例如磁盘io、平均内存使用量、使用的CPU百分比等等。</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="78e4" class="lu lv it mv b gy na nb l nc nd">$ time make</span><span id="4aae" class="lu lv it mv b gy ne nb l nc nd">real 0m6,256s<br/>user 0m5,835s<br/>sys 0m0,383s</span></pre><p id="30a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者您可以使用<code class="fe ms mt mu mv b">-f</code>选项指定输出格式:</p><pre class="kj kk kl km gt mw mv mx my aw mz bi"><span id="dbcb" class="lu lv it mv b gy na nb l nc nd">$ time -f "\nInputs: %I\nOutputs: %O\nTime elapsed: %E" locate gimp</span><span id="f9ec" class="lu lv it mv b gy ne nb l nc nd">...</span><span id="c1e3" class="lu lv it mv b gy ne nb l nc nd">Inputs: 9136<br/>Outputs: 0<br/>Time elapsed: 0:00.74</span></pre><h2 id="4cd3" class="lu lv it bd lw lx ly dn lz ma mb dp mc lh md me mf ll mg mh mi lp mj mk ml mm bi translated">结论</h2><p id="4ff7" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">一旦您知道一些基本的shell命令并开始构建工作流，命令行就可以成为您最好的通用工具，让您只需按几个键就可以高效地处理一切。您不必成为系统专家就能从使用终端中获益:您所需要的只是一些有用的命令和应用它们的大脑。</p><p id="9435" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢这篇文章。如果你有什么要补充的，请在评论中分享你的想法。感谢阅读！</p><p id="3d6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对学习成功的软件开发职业的基本技能感兴趣，看看下面这个故事:</p><div class="ng nh gp gr ni nj"><a href="https://betterprogramming.pub/the-language-every-programmer-should-master-8d0dfc461284" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">每个程序员都应该掌握的语言</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">软件开发不仅仅是写代码</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">better编程. pub</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>