<html>
<head>
<title>Demystifying the Parquet File Format</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开拼花文件格式的神秘面纱</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/demystifying-the-parquet-file-format-13adb0206705#2022-08-16">https://towardsdatascience.com/demystifying-the-parquet-file-format-13adb0206705#2022-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4d6b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">任何数据科学工作流的默认文件格式</h2></div><p id="d697" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你在熊猫身上用过<code class="fe lb lc ld le b">pd.read_csv()</code>吗？嗯，如果您使用parquet而不是CSV，那么这个命令的运行速度可以比T2快50倍。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/3008fcea8f9cf59e71a3c3150ca5d1ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a4lW5H9Sq1pRI6g1"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">照片由<a class="ae lf" href="https://unsplash.com/@mbenna?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·本纳</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="6740" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本帖中，我们将讨论apache parquet，这是一种非常高效且支持良好的文件格式。这篇文章是面向数据从业者(ML，DE，ds)的，所以我们将把重点放在高级概念上，并使用SQL来讨论核心概念，但更多资源的链接可以在整篇文章和评论中找到。</p><p id="bc93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事不宜迟，我们开始吧！</p><h1 id="0aee" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">技术TLDR</h1><p id="5a51" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">Apache parquet是一种开源文件格式，提供了高效的存储和快速的读取速度。它使用一种混合存储格式，按顺序存储列块，从而在选择和过滤数据时提供高性能。除了强大的压缩算法支持(<a class="ae lf" href="https://stackoverflow.com/questions/35789412/spark-sql-difference-between-gzip-vs-snappy-vs-lzo-compression-formats" rel="noopener ugc nofollow" target="_blank"> snappy，gzip，LZO </a>)，它还提供了一些减少文件扫描和编码重复变量的巧妙技巧。</p><p id="30da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在乎速度，你应该考虑镶木地板。</p><h1 id="ab3f" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">但是，到底是怎么回事呢？</h1><p id="9dbc" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">好吧，让我们慢一点，用简单的英语讨论拼花地板。</p><h2 id="03cb" class="mt lx iq bd ly mu mv dn mc mw mx dp mg ko my mz mi ks na nb mk kw nc nd mm ne bi translated">1 —数据存储问题</h2><p id="ecba" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">假设我们是数据工程师。我们希望创建一个数据架构，促进在线分析过程(<strong class="kh ir"> OLAP </strong>)，这只是面向数据分析的选择性查询。在OLAP环境中优化的数据函数的一些例子是探索性数据分析或决策科学。</p><p id="001a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们应该如何在磁盘上存储我们的数据呢？</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nf"><img src="../Images/6d8a35038af5db714118db968f1711f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oo7yNsKwFCRcTn__eEwonQ.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图1:将二维表格转换成二进制的例子。图片作者。</p></figure><p id="354d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，在考虑我们的转换是好是坏时有很多考虑因素，但是对于OLAP工作流，我们主要关心两个…</p><ul class=""><li id="7899" class="nh ni iq kh b ki kj kl km ko nj ks nk kw nl la nm nn no np bi translated"><strong class="kh ir">读取速度</strong>:我们从二进制文件中访问和解码相关信息的速度</li><li id="3bcc" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nm nn no np bi translated"><strong class="kh ir">磁盘大小</strong>:二进制格式的文件需要多少空间</li></ul><p id="0ed6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，文件压缩算法的成功还有其他衡量标准，比如写速度和元数据支持，但是我们现在只关注上面两个。</p><p id="388d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，相对于CSV文件，parquet的性能如何呢？<strong class="kh ir">占用空间减少87%，查询速度提高34倍</strong> (1 TB数据，s 3存储)——<a class="ae lf" rel="noopener" target="_blank" href="/csv-files-for-storage-no-thanks-theres-a-better-option-72c78a414d1d">src</a></p><h2 id="7cf8" class="mt lx iq bd ly mu mv dn mc mw mx dp mg ko my mz mi ks na nb mk kw nc nd mm ne bi translated">2 —镶木地板核心特征</h2><p id="eeaf" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">但是为什么parquet比CSV和其他流行的文件格式更有效呢？第一个答案是存储布局…</p><p id="6342" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2.1 —混合存储布局</strong></p><p id="ba2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们将一个二维表转换成一系列0和1时，我们必须仔细考虑最佳结构。应该先写第一栏，再写第二栏，再写第三栏吗？还是应该顺序存储行？</p><p id="ae59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传统上，有三种主要布局可以将我们的二维表格向下转换为1:</p><ol class=""><li id="edaf" class="nh ni iq kh b ki kj kl km ko nj ks nk kw nl la nv nn no np bi translated"><strong class="kh ir">基于行:</strong>顺序存储行(CSV)。</li><li id="ba15" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nv nn no np bi translated"><strong class="kh ir">基于列:</strong>顺序存储列(ORC)。</li><li id="91d4" class="nh ni iq kh b ki nq kl nr ko ns ks nt kw nu la nv nn no np bi translated"><strong class="kh ir"> Hybrid-base: </strong>顺序存储大块的列(拼花地板)。</li></ol><p id="1eb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在图2中看到每种格式的图形表示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nw"><img src="../Images/92b39e571497ed004870d69598666524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QEQJjtnDb3JQ2xqhzARZZw.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图2:3种主要的存储类型。图片作者。</p></figure><p id="c097" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，混合布局对于OLAP工作流非常有效，因为它们支持投影和谓词。</p><p id="e361" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">投影</strong>是选择列的过程——你可以把它想象成SQL查询中的<code class="fe lb lc ld le b">SELECT</code>语句。基于列的布局最能支持投影。例如，如果我们想使用基于列的布局读取表的第一列，我们可以只读取二进制文件中的前<em class="ng"> n </em>个索引，将它们反序列化，然后呈现给用户。很有效率，对吧？</p><p id="13e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">谓词</strong>是用于选择行的标准——您可以将其视为SQL查询中的<code class="fe lb lc ld le b">WHERE</code>子句。基于行的存储最能支持谓词。如果我们希望所有的行都符合某种标准，比如<code class="fe lb lc ld le b">Int &gt;= 2</code>，我们可以通过<code class="fe lb lc ld le b">Int</code>(降序)对表进行排序，扫描直到不满足我们的标准，然后返回无效行之上的所有行。</p><p id="775a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这两个场景中，<strong class="kh ir">我们都希望遍历尽可能少的文件。此外，由于数据科学通常需要对行和列进行子集化，基于混合的存储布局为我们提供了一个介于列和基于行的文件格式之间的中间地带。</strong></p><p id="a153" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前，需要注意的是，拼花地板通常被描述为柱状结构。然而，由于它存储大量的列，如图2底部所示，混合存储布局是更精确的描述。</p><p id="9885" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！因此，如果我们希望提取数据，我们可以只存储连续的列块，而<em class="ng">通常</em>会获得非常好的性能。但是这种方法有规模吗？</p><p id="ced8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2.2 —拼花地板元数据</strong></p><p id="010b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案是响亮的“是”Parquet利用元数据来跳过根据我们的谓词可以排除的数据部分。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi nx"><img src="../Images/d94b8fa6bcc392ef79997ab033a36830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3g4RfWdSWKcGs56cNDtJjA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图3:基于混合的存储布局从二维到一维的转换。图片作者。</p></figure><p id="c222" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以图3中的示例表为例，我们可以看到我们的行组大小为2，这意味着我们存储给定列的2行，下一列的2行，第三列的2行，依此类推。</p><p id="a4b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们用完所有的列后，我们移动到下一组行。注意，上表中只有3行，所以最后一个行组只有1行。</p><p id="46bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，假设我们实际上在行组中存储了100，000个值，而不是2个。如果我们希望找到所有的行，其中我们的<code class="fe lb lc ld le b">Int</code>列有一个给定值(即一个等式谓词)，最坏的情况是扫描表中的每一行。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi ny"><img src="../Images/fb3debb402de9c8ffb035e168bf23097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzPLuhgFw2hbsQHTP7lEvA.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图parquet如何处理行组谓词的例子。图片作者。</p></figure><p id="f014" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Parquet通过存储每个行组的<code class="fe lb lc ld le b">max</code>和<code class="fe lb lc ld le b">min</code>值智能地解决了这个问题，允许我们跳过整个行组，如图4所示。但这还不是全部！由于parquet经常将许多<code class="fe lb lc ld le b">.parquet</code>文件写入一个目录，我们可以在中查看整个文件的列元数据，并确定是否应该扫描它。</p><p id="e1fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过包含一些额外的数据，我们能够跳过大块的数据并显著提高查询速度。更多，<a class="ae lf" href="https://parquet.apache.org/docs/file-format/metadata/" rel="noopener ugc nofollow" target="_blank">看这里。</a></p><p id="aaae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 2.3 —拼花文件结构</strong></p><p id="fde5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，我们已经暗示了数据是如何从二维格式转换成一维格式的，但是整个文件系统是如何构造的呢？</p><p id="6fcf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，parquet可以一次写很多<code class="fe lb lc ld le b">.parquet</code>文件。对于小型数据集，这是一个问题，您可能应该在写入前对数据进行重新分区。但是，对于较大的数据集，将数据子集化到多个文件中可以显著提高性能。</p><p id="350f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，镶木地板遵循以下结构。让我们依次看一看每一个…</p><blockquote class="nz"><p id="ef08" class="oa ob iq bd oc od oe of og oh oi la dk translated">根&gt;拼花文件&gt;行组&gt;列&gt;数据页</p></blockquote><p id="1717" class="pw-post-body-paragraph kf kg iq kh b ki oj jr kk kl ok ju kn ko ol kq kr ks om ku kv kw on ky kz la ij bi translated">首先，我们的<strong class="kh ir">文件根目录</strong>，只是一个保存所有内容的目录。在根目录中，我们有许多单独的<code class="fe lb lc ld le b"><strong class="kh ir">.parquet</strong></code> <strong class="kh ir">文件</strong>，每个文件包含我们数据的一个分区。单个拼花文件由多个<strong class="kh ir">行组</strong>组成，单个行组包含多个<strong class="kh ir">列</strong>。最后，在我们的列中有<strong class="kh ir">数据页面</strong>，它实际上保存了原始数据和一些相关的元数据。</p><p id="2048" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在下面的图4中看到单个<code class="fe lb lc ld le b">.parquet</code>文件的简化表示。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi oo"><img src="../Images/fa48d4bb5a9168cf5e0ab8bf18d81796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsjh1Stj8xK-jKHXjU3NQg.png"/></div></div><p class="ls lt gj gh gi lu lv bd b be z dk translated">图4:按顺序排列的拼花地板的层次结构。图片作者。</p></figure><p id="2765" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你对细节感兴趣，这是文档。<a class="ae lf" href="https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet" rel="noopener ugc nofollow" target="_blank">重复和定义级别</a>对于充分理解数据页面如何工作也是必不可少的，但这些只是一些额外的好处。</p><h2 id="3c98" class="mt lx iq bd ly mu mv dn mc mw mx dp mg ko my mz mi ks na nb mk kw nc nd mm ne bi translated"><strong class="ak"> 3 —附加优化</strong></h2><p id="e1cf" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">自2013年问世以来，parquet变得更加智能。基本结构与上面的格式相比基本没有变化，但是增加了许多很酷的特性，可以提高某些类型数据的性能。</p><p id="ea97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一些例子…</p><p id="544c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 3.1 —我的数据有大量重复值！</strong></p><p id="a41b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案:<a class="ae lf" href="https://en.wikipedia.org/wiki/Run-length_encoding#:~:text=Run%2Dlength%20encoding%20(RLE),than%20as%20the%20original%20run." rel="noopener ugc nofollow" target="_blank">游程编码(RLE) </a></p><p id="d1ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个包含10，000，000个值的列，但是所有的值都是<code class="fe lb lc ld le b">0</code>。为了存储这些信息，我们只需要两个数字:<code class="fe lb lc ld le b">0</code>和<code class="fe lb lc ld le b">10,000,000</code>—<code class="fe lb lc ld le b">value</code>和<code class="fe lb lc ld le b">number of times it repeated</code>。</p><p id="5982" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RLE就是这么做的。当发现许多连续的重复项时，parquet可以将这些信息编码为一个对应于值和计数的元组。在我们的例子中，这将使我们避免存储9，999，998个数字。</p><p id="a4ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> 3.2 —我的数据有非常大的类型！</strong></p><p id="a7f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案:<a class="ae lf" href="https://stackoverflow.com/questions/64600548/when-should-i-use-dictionary-encoding-in-parquet" rel="noopener ugc nofollow" target="_blank">字典编码</a>带<a class="ae lf" href="https://parquet.apache.org/docs/file-format/data-pages/encodings/#a-namerlearun-length-encoding--bit-packing-hybrid-rle--3" rel="noopener ugc nofollow" target="_blank">位打包</a></p><p id="c908" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个包含国家名称的列，其中一些非常长。如果我们想存储“刚果民主共和国”，我们需要一个至少可以处理32个字符的字符串列。</p><p id="82ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字典编码用一个小整数替换列中的每个值，并将映射存储在数据页面的元数据中。当在磁盘上时，我们的编码值是位打包的，以尽可能占用最少的空间，但是当我们读取数据时，我们仍然可以将列转换回它的原始值。</p><p id="60da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.3 —我对我的数据使用了复杂的过滤器！</p><p id="acc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">求解:<a class="ae lf" href="https://stackoverflow.com/a/58235274/3206926" rel="noopener ugc nofollow" target="_blank">投影和谓词下推</a></p><p id="de9d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在spark环境中，我们可以避免通过投影和谓词下推将整个表读入内存。因为spark操作是延迟计算的，这意味着它们直到我们实际查询数据时才被执行，所以spark可以将最少的数据放入内存。</p><p id="7795" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速提醒一下，谓词子集行和投影子集列。因此，如果我们知道我们只需要几列和行的子集，我们实际上不必将整个表读入内存——它在读取过程中被过滤掉了。</p><p id="c85a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">3.4——我有很多不同的数据！</strong></p><p id="9cb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决方案:<a class="ae lf" href="https://docs.databricks.com/delta/index.html" rel="noopener ugc nofollow" target="_blank">三角洲湖泊</a></p><p id="22fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，Deltalake是一个开源的“lakehouse”框架，它结合了数据湖的动态特性和数据仓库的结构。如果您计划使用parquet作为您的组织的数据仓库的基础，那么ACID保证和事务日志等附加特性确实是有益的。</p><p id="4a3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想了解更多，这里有一个很棒的适合初学者的资源。</p><h1 id="1475" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">摘要</h1><p id="71b8" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">对于现实世界的使用来说，Parquet是一种非常有效的文件格式。它在最小化表扫描和将数据压缩到小尺寸方面非常有效。如果您是一名数据科学家，parquet可能是您的首选文件类型。</p></div><div class="ab cl op oq hu or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ij ik il im in"><p id="e195" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ng">感谢阅读！我将再写11篇文章，将学术研究引入DS行业。查看我的评论，链接到这篇文章的主要来源和一些有用的资源。</em></p></div></div>    
</body>
</html>