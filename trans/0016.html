<html>
<head>
<title>From Postgres to Snowflake</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从明信片到雪花</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/from-postgres-to-snowflake-f4b403548066#2022-02-01">https://towardsdatascience.com/from-postgres-to-snowflake-f4b403548066#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1e50" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当我把DWH从波斯格里斯迁移到雪花时遇到的有趣的点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6eea07b8f233eff5b15efa986a61787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y79ELaJFbVTyT97hn60mQQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://www.istockphoto.com/pt/portfolio/Oenz?mediatype=photography" rel="noopener ugc nofollow" target="_blank"> Paul Owens </a>在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6c2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近遇到了一个任务，似乎是许多使用PostgreSQL作为主数据库的公司在某个时候需要做的任务。</p><p id="cdeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是ETL脚本从PostgreSQL到雪花的迁移。</p><p id="1484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个过程包括基于辛格和DBT技术从零开始构建ETL管道，我稍后可能会详细介绍，但现在我想集中讨论PostgreSQL和雪花SQL语法之间的差异。我希望它对那些发现自己处于类似情况并需要重写大量SQL的人有用。</p><h1 id="9321" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">数字</h1><p id="9580" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">PostgreSQL是一个关系数据库，具有所有优点和缺点，有时需要微调，包括转换到最适合的类型。但雪花的情况并非如此。</p><p id="47dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先需要将<code class="fe mp mq mr ms b">int2</code>、<code class="fe mp mq mr ms b">int4</code>、<code class="fe mp mq mr ms b">int8</code>等类型转换为<code class="fe mp mq mr ms b">int</code>。第二个也是更容易出错的区别是，尽管两个数据库中都有一个类型<code class="fe mp mq mr ms b">numeric</code>,但雪花将这种类型的数据视为整数，而在Postgres中，它也可以包含小数。换句话说，雪花不会给出任何误差，但一切都会被四舍五入。</p><h1 id="1b22" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不同于</h1><p id="41c7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我相信对于大多数分析数据库来说，只需要获得最后一行或第一行是很常见的情况。Postgres有一个针对它的<code class="fe mp mq mr ms b">distinct on</code>构造，但是Snowflake不支持它，所以必须使用<code class="fe mp mq mr ms b">row_number</code>窗口函数或<code class="fe mp mq mr ms b">qualify</code>构造来解决这个问题(<a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/constructs/qualify.html" rel="noopener ugc nofollow" target="_blank">https://docs . snow flake . com/en/SQL-reference/constructs/qualify . html</a>)。例如，这就是我们如何获得第一个用户会话开始的时间戳。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="0578" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JSON空值</h1><p id="1a3e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Snowflake使用JSON很棒，但是有时那里的字段有<code class="fe mp mq mr ms b">null</code>值，结果SQL <code class="fe mp mq mr ms b">is null</code>不起作用。有两种选择:要么使用特殊函数<code class="fe mp mq mr ms b">is_null_value (</code><a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/functions/is_null_value.html" rel="noopener ugc nofollow" target="_blank">https://docs . snow flake . com/en/SQL-reference/functions/is _ null _ value . html</a>，要么通过<code class="fe mp mq mr ms b">strip_null_value (</code><a class="ae kv" href="https://docs.snowflake.com/en/sql-reference/functions/strip_null_value.html" rel="noopener ugc nofollow" target="_blank">https://docs . snow flake . com/en/SQL-reference/functions/strip _ null _ value . html</a>函数去除空值，然后使用普通的<code class="fe mp mq mr ms b">is null</code> SQL检查。我个人认为后一种解决方案更有吸引力。</p><h1 id="b4de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">过滤</h1><p id="fe12" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在分析中向度量(聚合函数)添加过滤器是一种常见的做法，在SQL:2003的Postgres中有一个很好的语法。不幸的是，Snowflake不支持它，所以解决方法是通过<code class="fe mp mq mr ms b">case</code>构造来走老路。例如，在这里，我们计算不同设备类型的会话数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="43d0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">横向连接</h1><p id="8569" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">雪花支持横向连接，此外，当需要解析JSON数组时，它被大量使用，但是有一些限制。其中一个限制是我们不能在横向连接中使用<code class="fe mp mq mr ms b">limit</code>。一种常见的情况是，我们只需要获得第一行就行不通了。解决方法是将其转换为CTE。实际上，CTE将在Postgres和雪花中工作，所以横向连接的解决方案只是对Postgres的优化，但我们在大多数情况下不需要对雪花进行这样的优化，因为引擎的工作方式不同。在下面的代码片段中，我们得到了每个会话的第一个事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="32f9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">递归</h1><p id="a76d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">好消息是，雪花完全支持递归，它会工作。问题在于局限性。在Snowflake中，默认的递归深度是100，它可以增加，但仍然有一些限制(我们在这里将Snowflake视为托管服务)。不幸的是，由于这些限制，雪花递归根本不能解决一些问题，例如库存操作列表的加权平均成本/价格。(在Postgres中，我们可以使用这个解决方案:<a class="ae kv" href="https://stackoverflow.com/questions/22426878/calculating-the-weighted-average-cost-of-products-stock" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/22426878/calculating-the-weighted-average-cost-of-products-stock</a>)</p><p id="b7c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我找到的唯一解决方案是要么在雪花之外进行计算，要么创建一个存储过程。</p><h1 id="7bf6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">其他…</h1><p id="3d29" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当然，在函数，过程，写UDF的方式，和存储过程方面还有很多不同，但是这篇文章的目的是分享我的经验，所以我希望它会有用。</p></div></div>    
</body>
</html>