<html>
<head>
<title>Learning to Rank the Bayesian Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习贝叶斯方法排序</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/learning-to-rank-the-bayesian-way-29af4c61939b#2022-08-09">https://towardsdatascience.com/learning-to-rank-the-bayesian-way-29af4c61939b#2022-08-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="e42a" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/bayesian-statistics" rel="noopener">贝叶斯统计</a></h2><div class=""/><div class=""><h2 id="2527" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">在PyMC中实施布拉德利-特里模型</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/5d4e6f81fcc404d204db83c6fd029f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O0OmIR27JKr5dS-K"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@pietromattia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">彼得罗·马蒂亚</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7078" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">想象一下，一群玩家在某个游戏中一对一地竞争。于是，一个自然的问题出现了:</p><blockquote class="mf"><p id="4cc7" class="mg mh iu bd mi mj mk ml mm mn mo me dk translated">如何给选手排名？</p></blockquote><p id="5d4e" class="pw-post-body-paragraph lj lk iu ll b lm mp ke lo lp mq kh lr ls mr lu lv lw ms ly lz ma mt mc md me in bi translated">理论上，这个问题应该不会太难——让他们玩一堆游戏，检查玩家的<strong class="ll je">胜率</strong>。不幸的是，这种自然的方法有一些问题:</p><ul class=""><li id="f9bc" class="mv mw iu ll b lm ln lp lq ls mx lw my ma mz me na nb nc nd bi translated">你无法判断<strong class="ll je">接近100% </strong>的胜率是否意味着该玩家<strong class="ll je">异常</strong>，或者该玩家是否只是踩死了<strong class="ll je">弱小的对手</strong>，以及</li><li id="bf4d" class="mv mw iu ll b lm ne lp nf ls ng lw nh ma ni me na nb nc nd bi translated">如果一个玩家只玩了<strong class="ll je">几局</strong>，那么对这个玩家实力的估计应该带有<strong class="ll je">高不确定性</strong>，而这是一个原始的<strong class="ll je">胜率无法提供的</strong>。</li></ul></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="76a4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在许多地方，您可能会遇到类似一对一游戏的问题:</p><ul class=""><li id="bae7" class="mv mw iu ll b lm ln lp lq ls mx lw my ma mz me na nb nc nd bi translated">当<strong class="ll je">在<strong class="ll je">实际比赛</strong>中对玩家</strong>进行排名时:网球、赛车、纸牌游戏、神奇宝贝战斗……</li><li id="91ac" class="mv mw iu ll b lm ne lp nf ls ng lw nh ma ni me na nb nc nd bi translated">当<strong class="ll je">对搜索结果</strong> : <strong class="ll je"> </strong>排序时，如果一个搜索结果<strong class="ll je"> </strong>与用户的查询更相关，则该搜索结果优于另一个。</li><li id="e73d" class="mv mw iu ll b lm ne lp nf ls ng lw nh ma ni me na nb nc nd bi translated">当<strong class="ll je">排列推荐</strong> : <strong class="ll je"> </strong>一个推荐比另一个更好，如果它与用户可能想要购买的东西更相关的话</li><li id="8041" class="mv mw iu ll b lm ne lp nf ls ng lw nh ma ni me na nb nc nd bi">…</li></ul><p id="547d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在本文中，我将向您展示如何在PyMC <strong class="ll je"> </strong>中构建一个简单的<strong class="ll je">贝叶斯模型</strong>来解决这个问题。如果你不知道我在说什么，可以看看我对使用PyMC3的贝叶斯世界的介绍，PyMC的前身具有几乎相同的语法。</p><div class="nq nr gq gs ns nt"><a rel="noopener follow" target="_blank" href="/conducting-bayesian-inference-in-python-using-pymc3-d407f8d934a5"><div class="nu ab fp"><div class="nv ab nw cl cj nx"><h2 class="bd je gz z fq ny fs ft nz fv fx jd bi translated">使用PyMC3在Python中进行贝叶斯推理</h2><div class="oa l"><h3 class="bd b gz z fq ny fs ft nz fv fx dk translated">重温硬币的例子，并使用PyMC3计算解决它。</h3></div><div class="ob l"><p class="bd b dl z fq ny fs ft nz fv fx dk translated">towardsdatascience.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh lc nt"/></div></div></a></div><h1 id="9e32" class="oi oj iu bd ok ol om on oo op oq or os kj ot kk ou km ov kn ow kp ox kq oy oz bi translated">布拉德利-特里模型</h1><p id="dbc8" class="pw-post-body-paragraph lj lk iu ll b lm pa ke lo lp pb kh lr ls pc lu lv lw pd ly lz ma pe mc md me in bi translated">我们将使用的模型被称为<a class="ae li" href="https://en.wikipedia.org/wiki/Bradley%E2%80%93Terry_model" rel="noopener ugc nofollow" target="_blank">布拉德利-特里模型</a>，我们给它一个贝叶斯扭曲。这听起来很吓人，但实际上相当容易。只是跟着走。</p><h2 id="cf2a" class="pf oj iu bd ok pg ph dn oo pi pj dp os ls pk pl ou lw pm pn ow ma po pp oy ja bi translated">模型直觉</h2><p id="cff6" class="pw-post-body-paragraph lj lk iu ll b lm pa ke lo lp pb kh lr ls pc lu lv lw pd ly lz ma pe mc md me in bi translated">整个模型归结为只有两个假设:</p><ol class=""><li id="0aff" class="mv mw iu ll b lm ln lp lq ls mx lw my ma mz me pq nb nc nd bi translated">我们假设每个<strong class="ll je">玩家</strong>(人类，口袋妖怪，搜索结果，推荐，…)都有一些<strong class="ll je">实力</strong>(技能，相关性，…)。</li><li id="2429" class="mv mw iu ll b lm ne lp nf ls ng lw nh ma ni me pq nb nc nd bi translated">如果拥有实力<em class="mu">的玩家1s₁</em>和拥有实力<em class="mu">的玩家2s₂</em>竞争，那么<strong class="ll je">玩家1以<strong class="ll je">的概率</strong>赢得</strong></li></ol><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pr"><img src="../Images/3fcb4b7d4b69432d5a1a92c5260e9050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RMeABQZK0q7vWNZBk6dyvg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="667b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">其中<em class="mu"> σ </em>就是你的老朋友，sigmoid函数。就是这样。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="e06f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">请注意，我们<strong class="ll je">在这里没有使用任何玩家特征</strong>，例如，如果玩家是真实的人类，身高或体重之类的特征。这意味着我们可以将这个模型应用于各种问题。</p><p id="08f1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，如果我们碰巧有播放器特性，我们也可以将它们合并到模型中，最终得到类似于<a class="ae li" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/08/icml_ranking.pdf" rel="noopener ugc nofollow" target="_blank">微软的RankNet </a> [1]的东西。作者使用神经网络架构从特征<em class="mu"> x </em>中<strong class="ll je">显式构建玩家的优势<em class="mu">s</em>=<em class="mu">f</em>(<em class="mu">x</em>)</strong>，而我们在贝叶斯方法中直接将<strong class="ll je">优势s视为参数</strong>。</p><p id="306a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">对于对神经网络感兴趣的人来说:我们可以使用嵌入层在你选择的深度学习框架中建立布拉德利-特里模型的频率主义版本。</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="d826" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们做一个小的理智检查，看看这个定义是否有意义。好吧，每个玩家都有自己的优势。这正是我们需要的，如果我们想根据球员的实力来排序，所以这很棒。</p><p id="1767" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果我们现在假设1号玩家的实力远高于2号玩家，即<em class="mu"> s₁ — s₂ </em>是一个很大的数，这就暗示着<em class="mu">σ</em>(<em class="mu">s₁—s₂</em>)<em class="mu"/>接近于1。所以<strong class="ll je">玩家1以压倒性的概率</strong>获胜，这正是我们在这种情况下想要的。如果参与人1的实力远低于参与人2，同样的道理也适用。如果两位选手实力相当，那么他们各自获胜的概率是<em class="mu">σ</em>(<em class="mu">0</em>)<em class="mu">=</em>50%。完美！</p><h2 id="2843" class="pf oj iu bd ok pg ph dn oo pi pj dp os ls pk pl ou lw pm pn ow ma po pp oy ja bi translated">创建数据集</h2><p id="85d1" class="pw-post-body-paragraph lj lk iu ll b lm pa ke lo lp pb kh lr ls pc lu lv lw pd ly lz ma pe mc md me in bi translated">在我们进入建模部分之前，让我们创建一个由游戏结果组成的人工数据集，如下所示:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ps"><img src="../Images/c282d518e86b5bed240d7ed8f6e7ddee.png" data-original-src="https://miro.medium.com/v2/resize:fit:596/format:webp/1*gxW7v9IAgwHq7pf5JmMJCQ.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="7bd3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这样做的好处是，我们知道模型应该能够找到哪些属性。</p><p id="3020" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">若要创建此数据集，可以使用以下代码:</p><pre class="kt ku kv kw gu pt pu pv bn pw px bi"><span id="fa91" class="py oj iu pu b be pz qa l qb qc">import pandas as pd<br/>import numpy as np<br/><br/>np.random.seed(0)<br/><br/>def determine_winner(player_1, player_2):<br/>    if player_1 == 0 and player_2 == 1:<br/>        return np.random.binomial(n=1, p=0.05)<br/>    if player_1 == 0 and player_2 == 2:<br/>        return np.random.binomial(n=1, p=0.05)<br/>    if player_1 == 1 and player_2 == 0:<br/>        return np.random.binomial(n=1, p=0.9)<br/>    if player_1 == 1 and player_2 == 2:<br/>        return np.random.binomial(n=1, p=0.1)<br/>    if player_1 == 2 and player_2 == 0:<br/>        return np.random.binomial(n=1, p=0.9)<br/>    if player_1 == 2 and player_2 == 1:<br/>        return np.random.binomial(n=1, p=0.85)<br/><br/>games = pd.DataFrame({<br/>    "Player 1": np.random.randint(0, 3, size=1000),<br/>    "Player 2": np.random.randint(0, 3, size=1000)<br/>}).query("`Player 1` != `Player 2`")<br/><br/>games["Player 1 wins"] = games.apply(<br/>    lambda row: determine_winner(row["Player 1"], row["Player 2"]),<br/>    axis=1<br/>)</span></pre><p id="88a3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在这里，我们创建了一个数据集，由三个玩家随机相互挑战组成。函数<code class="fe qd qe qf pu b">determine_winner</code>就是这样做的:如果 <code class="fe qd qe qf pu b"><strong class="ll je">player_1</strong></code> <strong class="ll je">赢了</strong>，它将获得两个玩家索引(0，1，2)和<strong class="ll je">输出。例如，在游戏(0，1)中——在代码中用<strong class="ll je">粗体</strong>标记——数字为0的玩家以<code class="fe qd qe qf pu b">p=0.05</code>的概率战胜数字为1的玩家。</strong></p><blockquote class="qg qh qi"><p id="5bf8" class="lj lk mu ll b lm ln ke lo lp lq kh lr qj lt lu lv qk lx ly lz ql mb mc md me in bi translated"><strong class="ll je"> <em class="iu">如果你仔细查看概率，会发现数字2的玩家应该是最好的，数字1居中，0最弱。</em> </strong></p></blockquote></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="e0dd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了增加趣味，让我们<strong class="ll je">介绍第四个玩家</strong>，这个<strong class="ll je">只玩了两局</strong>。</p><pre class="kt ku kv kw gu pt pu pv bn pw px bi"><span id="12c4" class="py oj iu pu b be pz qa l qb qc">new_games = pd.DataFrame({<br/>    "Player 1": [3, 3],<br/>    "Player 2": [2, 2],<br/>    "Player 1 wins": [1, 1]<br/>})<br/><br/>games = pd.concat(<br/>    [games, new_games],<br/>    ignore_index=True<br/>)</span></pre><p id="6344" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">3号玩家和2号玩了两次，甚至赢了两次。所以数字3应该也有相当高的强度，但是我们不能说数字3是否真的比数字2好，或者仅仅是运气。</p><h2 id="3372" class="pf oj iu bd ok pg ph dn oo pi pj dp os ls pk pl ou lw pm pn ow ma po pp oy ja bi translated">在PyMC中构建模型</h2><p id="43ed" class="pw-post-body-paragraph lj lk iu ll b lm pa ke lo lp pb kh lr ls pc lu lv lw pd ly lz ma pe mc md me in bi translated">我们现在能够在PyMC中构建模型。请注意，我们将使用高斯先验的球员的力量。此外，我将让模型推断五个<strong class="ll je">玩家的后验概率，尽管没有最后一个号码为4的玩家的数据。我们将会看到模型是如何处理这个问题的。</strong></p><blockquote class="qg qh qi"><p id="4520" class="lj lk mu ll b lm ln ke lo lp lq kh lr qj lt lu lv qk lx ly lz ql mb mc md me in bi translated"><em class="iu">另一件重要的事情是，我不会显式地使用sigmoid函数。如果我们通过</em> <code class="fe qd qe qf pu b"><em class="iu">logit_p</em></code> <em class="iu">参数而不是</em> <code class="fe qd qe qf pu b"><em class="iu">p</em></code> <em class="iu">来传递玩家实力的差异，那么</em> <code class="fe qd qe qf pu b"><em class="iu">pm.Bernoulli</em></code> <em class="iu">对象会处理它。</em></p></blockquote><pre class="kt ku kv kw gu pt pu pv bn pw px bi"><span id="1278" class="py oj iu pu b be pz qa l qb qc">import pymc as pm<br/><br/>with pm.Model() as model:<br/>    strength = pm.Normal("strength", 0, 1, shape=5)<br/>    diff = strength[games["Player 1"]] - strength[games["Player 2"]]<br/>    <br/>    obs = pm.Bernoulli(<br/>        "wins",<br/>        logit_p=diff,<br/>        observed=games["Player 1 wins"]<br/>    )<br/>    <br/>    trace = pm.sample()</span></pre><p id="5abb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">奇迹发生后，我们可以检查后验概率是如何分布的。在左边，你可以看到后验分布作为密度图，在右边，你可以看到一个森林图，让您轻松地比较强度后验。</p><div class="kt ku kv kw gu ab cb"><figure class="qm kx qn qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/990c5976d0ac9bf019837b929f53a44b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*xMUfd_fLiI4TOJuZh1mAoA.png"/></div></figure><figure class="qm kx qs qo qp qq qr paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><img src="../Images/877b14fe92bdf1fa5d095b418fe001b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*pv_-VAagAYLvatJ8ohyKog.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk qt di qu qv translated">图片由作者提供。</p></figure></div><p id="8222" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这里可以看到0号确实是最弱的玩家，1号次之。正如所料，数字2和3是最好的。数字3的后验分布的平均值略低于数字2，但HDI(高密度区间)要大得多，这表明与数字2相比，数字3的强度有更多的不确定性。数字4的后验强度与前一个相同:正态分布，平均值为0，标准差为1。模特在这里学不到任何新东西。</p><p id="0fdd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你更喜欢数字，这里有:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj qw"><img src="../Images/610b1534636f0a40b7ee3acf47c3e9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DNEsiH8OWC1nCJl-RMQ7cw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">图片由作者提供。</p></figure><p id="ae16" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">从那里，我们还可以看到MCMC似乎收敛得很好，因为<code class="fe qd qe qf pu b">r_hat</code>值都等于1。</p><p id="e7e1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们还可以看到一些玩家的<strong class="ll je">强度为负</strong>，但这完全没问题，因为我们只使用两个玩家之间的强度差。如果你出于某种原因不喜欢这样，你可以用一个<code class="fe qd qe qf pu b">HalfNormal</code>分布来代替强度先验，或者你只需在后验分布中增加一些常数，比如5，这样所有的均值和HDI都在正范围内。</p><h1 id="814d" class="oi oj iu bd ok ol om on oo op oq or os kj ot kk ou km ov kn ow kp ox kq oy oz bi translated"><strong class="ak">结论</strong></h1><p id="89a6" class="pw-post-body-paragraph lj lk iu ll b lm pa ke lo lp pb kh lr ls pc lu lv lw pd ly lz ma pe mc md me in bi translated">在本文中，我们看到了如何构建一个模型，让您对一组玩家(实际玩家、推荐、搜索结果……)进行排名。一个贝叶斯模型，甚至没有任何球员的特点。然而，这并不是一个限制，因为我们也可以合并特性。</p><p id="d98d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">该模型从一些关于运动员力量水平的先验信念开始，然后通过数据进行更新。玩家玩的游戏越多，这个玩家实力的不确定性就越小。在一个极端的情况下，如果一个玩家从来没有玩过一场游戏，他们实力的后验分布等于先验分布，这是有意义的。</p><h1 id="80b8" class="oi oj iu bd ok ol om on oo op oq or os kj ot kk ou km ov kn ow kp ox kq oy oz bi translated">参考</h1><p id="8e75" class="pw-post-body-paragraph lj lk iu ll b lm pa ke lo lp pb kh lr ls pc lu lv lw pd ly lz ma pe mc md me in bi translated">[1] Burges，c .、Shaked，t .、Renshaw，e .、Lazier，a .、Deeds，m .、Hamilton，n .和Hullender，g .，<a class="ae li" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2005/08/icml_ranking.pdf" rel="noopener ugc nofollow" target="_blank">使用梯度下降法学习排序</a> <a class="ae li" href="https://arxiv.org/abs/1407.7502" rel="noopener ugc nofollow" target="_blank"> </a> (2005)，第22届机器学习国际会议论文集(第89–96页)</p></div><div class="ab cl nj nk hy nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="in io ip iq ir"><p id="9e0b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我希望你今天学到了新的、有趣的、有用的东西。感谢阅读！</p><p id="1d24" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">作为最后一点，如果你</strong></p><ol class=""><li id="ed9d" class="mv mw iu ll b lm ln lp lq ls mx lw my ma mz me pq nb nc nd bi translated"><strong class="ll je">想支持我多写点机器学习和</strong></li><li id="d0ee" class="mv mw iu ll b lm ne lp nf ls ng lw nh ma ni me pq nb nc nd bi translated"><strong class="ll je">无论如何都要计划获得中等订阅量，</strong></li></ol><p id="8b0e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><strong class="ll je">为什么不做</strong> <a class="ae li" href="https://dr-robert-kuebler.medium.com/membership" rel="noopener"> <strong class="ll je">通过这个链接</strong> </a> <strong class="ll je">？这将对我帮助很大！😊</strong></p><div class="nq nr gq gs ns nt"><a href="https://dr-robert-kuebler.medium.com/membership" rel="noopener follow" target="_blank"><div class="nu ab fp"><div class="nv ab nw cl cj nx"><h2 class="bd je gz z fq ny fs ft nz fv fx jd bi translated">通过我的推荐链接加入灵媒——罗伯特·库伯勒博士</h2><div class="oa l"><h3 class="bd b gz z fq ny fs ft nz fv fx dk translated">谢谢你过来支持我！你的会员费直接支持我和你看的其他作家。你会…</h3></div><div class="ob l"><p class="bd b dl z fq ny fs ft nz fv fx dk translated">dr-robert-kuebler.medium.com</p></div></div><div class="oc l"><div class="qx l oe of og oc oh lc nt"/></div></div></a></div><p id="34bf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">透明地说，给你的价格不变，但大约一半的订阅费直接归我。</p><p id="3d4a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">非常感谢，如果你考虑支持我的话！</p><blockquote class="mf"><p id="bcdc" class="mg mh iu bd mi mj mk ml mm mn mo me dk translated"><em class="qy">有问题就在</em><a class="ae li" href="https://www.linkedin.com/in/dr-robert-k%C3%BCbler-983859150/" rel="noopener ugc nofollow" target="_blank"><em class="qy">LinkedIn</em></a><em class="qy">上写我！</em></p></blockquote></div></div>    
</body>
</html>