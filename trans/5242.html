<html>
<head>
<title>Perfect, Infinite-Precision, Game Physics in Python (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python 中完美的、无限精确的游戏物理学(第 1 部分)</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/perfect-infinite-precision-game-physics-in-python-part-1-698211c08d95#2022-11-23">https://towardsdatascience.com/perfect-infinite-precision-game-physics-in-python-part-1-698211c08d95#2022-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fb2b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">绝对准确，编程“牛顿的摇篮”，“网球和篮球下降”，等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0610fad8bfd3abc9fe290225531cff29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TmUAdab7Iw2dJDZxi6H2hA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">牛顿的摇篮与 Python——来源:编辑<a class="ae kv" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">https://openai.com/dall-e-2/</a></p></figure><p id="622e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是向您展示如何用 Python 编写一个完美的物理引擎的四篇文章中的第一篇。这是我将所有物理、数学、甚至哲学转化为编程的宏伟目标中的一小步。通过这个项目，我们将发现惊喜，增加了解，并且(我希望)玩得开心。<a class="ae kv" href="https://github.com/CarlKCarlK/perfect-physics" rel="noopener ugc nofollow" target="_blank">所有代码都可以在 GitHub </a>上获得。</p><p id="0a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在许多方面限制引擎——例如，限制圆和线之间的牛顿碰撞。然而，我们不会限制引擎的准确性。它将用精确的表达式表示所有时间、位置和速度，如<code class="fe ls lt lu lv b">8*sqrt(3)/3</code>。换句话说，它避免了所有的数值近似。</p><p id="8f86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果将是完美的模拟，例如，牛顿的摇篮玩具。(要重放/暂停视频，请按左下角的按钮。声音是有帮助的。)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">常规牛顿摇篮(6 视频秒/66 模拟单位)</p></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="bcbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">绝对精确的物理引擎有什么用？除了其他方面，它可以提高我们对物质世界的理解。在本文(第 1 部分)中，我们将看到这些新的发现:</p><ul class=""><li id="392b" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated"><strong class="ky ir">网球速度限制</strong> —在一个流行的物理演示中，你用篮球丢下一个网球。网球弹起的速度比落下的速度快得多。快了多少？我们会看到“上升”速度永远不会超过“下降”速度的三倍。即使我们把篮球做得无限大，这也是成立的。</li><li id="6229" class="mf mg iq ky b kz mp lc mq lf mr lj ms ln mt lr mk ml mm mn bi translated">良好的振动——想象一个移动的网球被困在一个篮球和一堵墙之间。在两帧视频之间的短暂时间里，网球可以弹跳 80 次。使用近似的引擎可能会错过一些反弹。我们的引擎计算每一个。</li></ul><p id="fa85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，在下一篇文章中(<a class="ae kv" href="https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-2-360cc445a197" rel="noopener">第二部分</a>):</p><ul class=""><li id="2f7b" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated"><strong class="ky ir">台球破裂</strong> —即使有无限的精确度，台球破裂实际上也无法逆转。我们会看到，即使我们去除了“蝴蝶效应”和量子不确定性，世界仍然是随机的和不确定的。</li></ul><p id="71d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们完美的物理引擎的缺点是速度。对于大多数模拟来说，随着时间的推移，时间、位置和速度的表达式变得越来越复杂。在你可以在<a class="ae kv" href="https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-2-360cc445a197" rel="noopener">第二部</a>中看到的台球世界中，这将我们的模拟限制在 20 个左右的“事件”。(我们将在后面定义“事件”。)能不能提高速度？只会一点点。这将是<a class="ae kv" rel="noopener" target="_blank" href="/perfect-infinite-precision-game-physics-in-python-part-4-9cdd609b3e6c#19f5-510d38fe7d32">第四部</a>的主题。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="00db" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated"><em class="nn">制造引擎</em></h2><p id="c9cc" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">假设我们已经有 Python 函数用于:</p><ul class=""><li id="c925" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated">给定世界上任意两个(可能移动的)物体，返回它们刚好接触的准确时间跨度。答案可能是“永远不会”。</li><li id="370e" class="mf mg iq ky b kz mp lc mq lf mr lj ms ln mt lr mk ml mm mn bi translated">给定任意两个碰撞的物体，碰撞将如何改变它们的速度和方向？</li></ul><p id="4289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在第 3 部分中看到如何创建这样的函数。现在，考虑如何将这些功能变成一个完美的物理引擎。</p><p id="1d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过观察三个物理世界来研究一种方法，从牛顿的摇篮开始。</p><h2 id="b150" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">牛顿的摇篮</h2><p id="acee" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我们引擎的总体想法是找到世界上下一次碰撞的准确时间。向前移动到那个时间。调整碰撞物体的速度。重复一遍。</p><p id="9991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于牛顿的摇篮，我们先设置圆圈和墙壁。</p><pre class="kg kh ki kj gt nt lv nu bn nv nw bi"><span id="1b3a" class="nx mv iq lv b be ny nz l oa ob">from perfect_physics import World, Circle, Wall<br/><br/>circle_list = [Circle(x=1, y=0, r=1, vx=1, vy=0, m=1)]<br/>for i in range(1, 6):<br/>    circle_list.append(Circle(x=i * 2 + 4, y=0, r=1, vx=0, vy=0, m=1))<br/>wall_list = [Wall(x0=0, y0=0, x1=0, y1=1), Wall(x0=20, y0=0, x1=20, y1=1)]<br/>world = World(circle_list, wall_list, xlim=(-1, 21), ylim=(-2, 2))<br/>world.show()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/895b5b91eceaabd5d8dd83eca0353310.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*jmYURsDYb70shj_lfAiYgg.png"/></div></figure><p id="058d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来:</p><ul class=""><li id="0af1" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated"><strong class="ky ir">在每对物体之间，找出它们碰撞的确切时间跨度(如果有的话)。</strong>忽略其他配对和碰撞。-在这种情况下，第一个(移动的)圆将在时间跨度 3 处与第二个圆碰撞。忽略那次碰撞，它还会在时间跨度 5 处与第三个圆发生碰撞，以此类推。它将在时间跨度 18 处与远壁碰撞。</li><li id="a59d" class="mf mg iq ky b kz mp lc mq lf mr lj ms ln mt lr mk ml mm mn bi translated"><strong class="ky ir">找出第一次碰撞的时间跨度，并准确地将世界时钟调快。</strong>在这种情况下，3。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/58d8bb78a79f0f7eca5e1cf8ba5f9c6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*qozLZNy7gZrqOmm3KCYFZw.png"/></div></figure><ul class=""><li id="5fe1" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated"><strong class="ky ir">调整这些碰撞中所有物体的速度。</strong>如牛顿摇篮所料，第一个圆静止不动，第二个圆开始移动。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/70e82dab608c901f692cf68fc9861c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*dIWwg56DQliDbgBbKnOgww.png"/></div></figure><ul class=""><li id="3ade" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated"><strong class="ky ir">根据需要重复。</strong>在本例中，第二个和第三个球将在时间跨度 0 内碰撞。这个视频展示了一个接一个的事件。(“事件”是将时间向前移动到碰撞或根据碰撞调整速度)</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">牛顿摇篮事件(35 视频秒/16 模拟单元)</p></figure><p id="f8e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将这些事件转换成常规视频，我们需要以规则的间隔生成帧，例如，每 1/24 秒。第一帧将显示 0 点的世界。玩了几个选项后，我决定每个模拟时间单位要有 10 秒的视频。因此，第二帧将用于时钟 10/24(也称为 5/12)。我们知道在时钟 3 之前没有碰撞，所以我们可以不考虑碰撞只移动圆。它的位置将是精确的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/309a172ae049a8467664710ecd8cf3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*0G40E7Rb5q_vtt-fgnWklg.png"/></div></figure><p id="4320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，对于每一帧，我们:</p><ul class=""><li id="2d04" class="mf mg iq ky b kz la lc ld lf mh lj mi ln mj lr mk ml mm mn bi translated">找出该帧的模拟时钟值。</li><li id="6120" class="mf mg iq ky b kz mp lc mq lf mr lj ms ln mt lr mk ml mm mn bi translated">找出该时钟值之前的冲突事件。</li><li id="8533" class="mf mg iq ky b kz mp lc mq lf mr lj ms ln mt lr mk ml mm mn bi translated">从前面碰撞的世界开始，将圆移动到帧的时钟值。(根据设计，在移动过程中，圆圈不会与任何东西发生碰撞。)</li></ul><p id="7b01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的位置和时间都是精确的。文章开头的视频展示了结果。</p><h2 id="845b" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">圆形和三角形</h2><p id="a41a" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">我声称时间和位置都是准确的，但是你相信我吗？这是通过一个三角形内接的圆得到的一些证据。首先，这是显示事件的视频。可以看到时钟设置为<code class="fe ls lt lu lv b">8*sqrt(3)/3</code>这样的表达式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">三角形事件内接的圆(31 视频秒/48 模拟单位)</p></figure><p id="6c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是三角形中圆圈的常规视频:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">三角形内接的规则圆(26 视频秒/250 模拟单位)</p></figure><p id="6c76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，模拟陷入一种模式。没有无限的精度，模式可能会被遗漏。</p><h2 id="5507" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">网球和篮球下落</h2><p id="b3fd" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">让我们再看一个物理世界，看看无限精度的另一个优势。这个世界包括一个网球和篮球以速度 1 向一面墙移动。篮球的质量是网球的 1000 倍。(我们的世界没有重力。)</p><pre class="kg kh ki kj gt nt lv nu bn nv nw bi"><span id="447b" class="nx mv iq lv b be ny nz l oa ob">from perfect_physics import World, Circle, Wall<br/><br/>big_radius = 10<br/>world_width = 40<br/>folder = root / f"part1/two_size{big_radius}"<br/><br/>big = Circle(x=world_width // 2, y=0, r=big_radius, vx=1, vy=0, m=big_radius**3)<br/>little = Circle(x=big.x - big_radius - 1, y=0, r=1, vx=1, vy=0, m=1)<br/>circle_list = [big, little]<br/>wall_list = [Wall(x0=0, y0=0, x1=0, y1=1), Wall(x0=world_width, y0=0, x1=world_width, y1=1)]<br/>world = World(circle_list, wall_list, xlim=(-1, world_width + 1), ylim=(-big_radius - 1, big_radius + 1))<br/>world.run_in_place(2, show=True)<br/>print([circle.vx for circle in world.circle_list])</span></pre><p id="3d66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在 10 点整，球从右边的墙上弹开。网球的速度从 1 到 2999/1001，而篮球稍微慢了一点，到 997/1001。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/19f008aae92ebdb6970f28839c72eb87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2bpPZgXplsyrras_ZNl4Aw.png"/></div></div></figure><p id="db18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不出所料(如果你已经在物理世界尝试过这个)，网球加速了。然而，令我惊讶的是，它只快了三倍。</p><p id="2028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们暂时跳过，使用我们将在<a class="ae kv" href="https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-3-9ea9043e3969" rel="noopener">第 3 部分</a>中开发的工具。这段 Python 代码展示了质量无限大的篮球对网球的影响。网球进去的速度是 1，出来的速度正好是 3。</p><pre class="kg kh ki kj gt nt lv nu bn nv nw bi"><span id="df3d" class="nx mv iq lv b be ny nz l oa ob">from sympy import limit, simplify, oo<br/>from perfect_physics import load<br/>cc_velocity_solution = load("data/cc_velocity_solution.sympy")<br/>a_vx, a_vy, b_vx, b_vy  = cc_velocity_solution.subs([("a_x", 10), ("a_y", 0), ("a_r", 10), ("a_vx", -1), ("a_vy", 0),<br/>                            ("b_x", -1), ("b_y", 0), ("b_r", 1), ("b_vx", 1), ("b_vy", 0), ("b_m", 1)])<br/>print(simplify(b_vx))<br/>limit(b_vx, "a_m", oo)<br/># prints (1 - 3*a_m)/(a_m + 1)<br/># returns -3</span></pre><p id="f0c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果像我一样，你期待网球加速到无穷大，那么像我一样，你从这个物理引擎中学到了一些真实世界的物理知识。</p><p id="3be5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我让发动机运转更长时间时，它让我更加吃惊。看看在视频时间 20 秒(模拟时间 200)发生了什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">常规网球和篮球投掷(39 视频秒/386 模拟单位)</p></figure><p id="6f1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">篮球挤压网球。这导致网球在单个视频帧中来回反弹超过 80 次。网球的速度超过了 31 英里。在视频的音频轨道上，网球的振动产生了超过 2000 Hz(节拍/秒)的音调。</p><p id="e8fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不是精确计算，我们只是每帧采样一次，我们将错过(或误算)这一快速动作。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="6c4f" class="mu mv iq bd mw mx my dn mz na nb dp nc lf nd ne nf lj ng nh ni ln nj nk nl nm bi translated">总结第 1 部分</h2><p id="efad" class="pw-post-body-paragraph kw kx iq ky b kz no jr lb lc np ju le lf nq lh li lj nr ll lm ln ns lp lq lr ij bi translated">有用！我们有一个完美的物理引擎。我们已经把一点物理变成了程序。</p><p id="2275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们假设我们从两个 Python 函数开始，这两个函数告诉我们——对于任何一对对象——两件事:1)直到它们下一次碰撞(如果有的话)的时间，以及 2)碰撞对它们速度的影响。我们看到了如何通过重复将这两个功能转变为完美的物理引擎:在时间上向前移动，直到下一次碰撞，并调整碰撞中涉及的所有对象的速度。</p><p id="9e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过查找视频帧之前的碰撞来创建视频，然后将时间向前移动(不用担心碰撞)到该帧。</p><p id="808e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">牛顿的摇篮，第一个世界，表现如预期。第二个世界，三角形内接的圆，使用<code class="fe ls lt lu lv b">8*sqrt(3)/3</code>等表示时间的表达式等。，发现了一个规律。网球篮球下落揭示了网球速度的一个令我吃惊的极限。此外，它产生的反弹比不太完美的方法所能计算的还要快。</p><p id="60ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一篇文章，<a class="ae kv" href="https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-2-360cc445a197" rel="noopener">第二部分</a>，模拟了一次台球休息，带来了令我惊讶的哲学结果。接下来，在第三部分中，我们将看到如何让计算机创建这两个启动函数。最后，在第 4 部分的<a class="ae kv" rel="noopener" target="_blank" href="/perfect-infinite-precision-game-physics-in-python-part-4-9cdd609b3e6c#19f5-510d38fe7d32">中，我们将加速引擎一点(但还不够)并讨论局限性。</a></p><p id="93da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有想让我运行的模拟的想法，请发给我。它们可能成为第五部分的基础。</p><p id="e1c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以从<a class="ae kv" href="https://github.com/CarlKCarlK/perfect-physics" rel="noopener ugc nofollow" target="_blank">CarlKCarlK/perfect-physics(github.com)</a>下载这段代码。让我知道如果有兴趣，我会创建一个更好的安装程序。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><p id="a884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请跟随<a class="ae kv" href="https://medium.com/@carlmkadie" rel="noopener">卡尔·m·卡迪— Medium </a>获取后续零件的通知。所有部分都将免费阅读。最后，在 YouTube 上，我有更老的(近似的)<a class="ae kv" href="https://www.youtube.com/playlist?list=PLyBBVRUm1CyScgmzqpLGiKqwM-BxaiCnE" rel="noopener ugc nofollow" target="_blank">物理模拟</a>和一些<a class="ae kv" href="https://www.youtube.com/playlist?list=PLyBBVRUm1CyRr8tgjNdarj7cq55YFHhbf" rel="noopener ugc nofollow" target="_blank">试图幽默的自然视频</a>。</p></div></div>    
</body>
</html>