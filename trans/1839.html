<html>
<head>
<title>How To Easily And Confidently Implement Unit Tests In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何轻松自信地用Python实现单元测试</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-easily-and-confidently-implement-unit-tests-in-python-cad48d91ab74#2022-04-29">https://towardsdatascience.com/how-to-easily-and-confidently-implement-unit-tests-in-python-cad48d91ab74#2022-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c47a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道你的代码不会被破坏，你想晚上睡得更好吗？那么这篇文章就送给你了。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e0db342e81b7af2f02f4b8e4f9383fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aFEMO-Icxi0JLg3vcBeb5w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">布雷特·乔丹在<a class="ae ky" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="75ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">什么是单元测试，为什么单元测试很重要，单元测试的最佳实践是什么，我如何用Python实现单元测试？如果你想知道这些问题的答案，请继续阅读。</p><h1 id="62be" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是测试？</h1><p id="a2b0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">测试是一个简单而直观的概念。您编写与您的主要代码并行的测试，以确保它按照您期望的方式工作。每个人都以这样或那样的方式测试他们的代码——但是这样做有更好和更坏的方法。</p><p id="9a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数人会在终端中运行快速测试，或者混合使用assert语句和print语句。我不是说不要这样做，但是有更有效的方法来测试你的代码，我很快就会解释。但是首先，让我让你相信测试你的代码是必要的。</p><h1 id="4a83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么要使用测试？</h1><p id="30f6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，如果你在编写代码的同时编写测试，这会让你在更深的层次上思考你的代码。它会让你更多地考虑你正在编写的代码的输入、输出和目标。这将鼓励你从一开始就编写更高效的代码。</p><p id="aaf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以为您节省大量的调试时间。将编写测试视为对时间(和压力水平)的投资。当你写代码的时候，你同时也写了测试。如果事情变得不可收拾，你对这些测试的投入将会给你一个指向问题的大箭头。当涉及到长而复杂的函数时尤其如此。</p><p id="fc11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试也是可复制的。就像您将一个函数从一个项目复制并粘贴到另一个项目一样，您也可以对测试进行同样的操作。你的功能和测试就像蝙蝠侠和罗宾。</p><p id="61dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以在函数之前编写测试！有一个思想流派叫做测试驱动开发(TDD ),它建议你应该在测试之前编写函数。这是否是一个好主意是一个非常有争议的辩论，我不打算卷入其中。</p><h1 id="7e6a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何使用测试？</h1><h2 id="cfe4" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">单元五集成测试</h2><p id="5bd3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们需要讨论两种主要的测试类型。您将遇到的主要测试类型是<strong class="lb iu">单元测试。</strong>这是对特定单元或组件的测试——通常是一项功能。<strong class="lb iu">集成测试</strong>是测试所有这些组件如何组合在一起。下面的例子将集中于单元测试。</p><p id="0797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，让我们从一个独立单元测试的基本例子开始。假设我们有下面的函数:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="def2" class="ms lw it nf b gy nj nk l nl nm">def add(x,y):<br/>   return x + y</span></pre><p id="8f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此进行单元测试的一个例子是:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="63d2" class="ms lw it nf b gy nj nk l nl nm">assert add(2,4) == 6, "Should be 6"</span></pre><p id="5dd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字<code class="fe nn no np nf b">assert</code>让你测试代码中的条件是否返回True，如果不是，程序将抛出AssertionError。小心这里的括号，因为<a class="ae ky" href="https://docs.python.org/3/reference/simple_stmts.html#assert" rel="noopener ugc nofollow" target="_blank">断言</a>是一个语句。</p><p id="c577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在Python终端中运行这个，什么也不会发生，因为2 + 4实际上等于6。再试一次，将6改为7，正如所承诺的，您将得到一个AssertionError。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/916c9a21be51acc6acb235f954459794.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*nGlOagg0QSdtMNnkHEjucg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建。</p></figure><p id="f7e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它显示了assert语句后面的错误消息。</p><p id="16f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我们可以通过测试提高效率和组织性。</p><h1 id="636f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">测试用例、测试套件和测试运行程序</h1><p id="60eb" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我给你介绍几个概念。</p><p id="bd4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<strong class="lb iu">测试用例。</strong>测试用例是对一个案例或一个响应的具体测试。assert语句是测试用例的一个例子。我们正在检查，在输入2 + 4的情况下，我们会收到6的答案。</p><p id="4ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将许多测试用例组合在一起，我们得到一个<strong class="lb iu">测试套件。</strong>通常，将许多相似的案例加在一起是有意义的。</p><p id="743d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行我们的测试用例以及测试套件时，我们需要一种有组织的、高效的方式来完成它。这就是我们使用<strong class="lb iu">测试转轮的地方。测试运行人员协调测试的执行，让我们的生活变得更加轻松。</strong></p><p id="e5d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多测试运行程序，但是我最喜欢的和内置到python中的是<strong class="lb iu"> Unittest </strong>。这就是我们今天要做的。</p><h1 id="0a99" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用单元测试</h1><p id="fc89" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Unittest有一些你必须遵守的规则。一旦你了解了它，它简单、优雅且易于使用。</p><p id="4f08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你必须将所有的测试作为方法放入类中。一旦这样做了，就可以用从unittest继承的特殊断言方法替换assert关键字。测试用例类。</p><p id="3227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个例子，用的是我们已经看过的例子。我在那里创建了一个名为“tests.py”的新文件，这是一个标准约定。我将add函数存储在一个名为functions的文件夹中，与test.py在同一层。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c69cda31a410ef7b10ad2040b07217b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*qUuEX1qTyGpHme9YPVjqvw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建。</p></figure><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="98c6" class="ms lw it nf b gy nj nk l nl nm">import unittest</span><span id="4d74" class="ms lw it nf b gy ns nk l nl nm">import functions<br/></span><span id="fa6b" class="ms lw it nf b gy ns nk l nl nm">class TestAdd(unittest.TestCase):</span><span id="fd4d" class="ms lw it nf b gy ns nk l nl nm">     def test_add(self):</span><span id="0cf2" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.add(2, 4), 6)<br/></span><span id="5288" class="ms lw it nf b gy ns nk l nl nm">if __name__ == '__main__':<br/>    unittest.main()<br/> </span></pre><ol class=""><li id="56ad" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">首先，我们必须导入<code class="fe nn no np nf b">unittest</code>作为标准。</li><li id="15d7" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">创建一个名为<code class="fe nn no np nf b">TestAdd</code>的类，它继承自<code class="fe nn no np nf b">TestCase</code>类。</li><li id="0b8b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">将测试函数转换成方法。</li><li id="6b51" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">更改断言以使用<code class="fe nn no np nf b">TestCase</code>类中的<code class="fe nn no np nf b">self.assertEqual()</code>方法。下面是可用方法的完整列表。</li><li id="4abb" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">将命令行入口点改为call <code class="fe nn no np nf b">unittest.main()</code></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/d912e52d020be224fc3aa6ff90e9d53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLSJTb4rqroooGgFRhb3mA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">unittest断言方法的完整列表—【https://docs.python.org/3/library/unittest.html#unittest. T2】TestCase.assertTrue </p></figure><p id="d1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您在终端中运行test.py，您应该会看到这个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/4d9065cdff7305a28e6fe3f504bd1b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdbfnJb-jOhv9AIlD44UCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建。</p></figure><p id="d3c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚线上方的每个点代表一个已经运行的测试。如果这个测试抛出了一个错误，它将被一个E或F代替。</p><p id="c866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以如果我们用7代替6，我们会得到这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/c060a3257e1a7fcf579aef44ab9e1232.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fthFPAvs-x9dqKwB_uGYDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/3cabf4a857a47c8eff5c39c31f921a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmgggDuQeeva7eeR8y4Bzw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><p id="59d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们这里只有一个测试，所以我们已经知道它在哪里失败了。如果我们有更多的数据，就很容易看出哪里出了问题，因为它非常具体。</p><h1 id="ef6b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何写出好的测试？</h1><h2 id="e3fd" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">清楚地命名您的测试——不要忘记称它们为测试。</h2><p id="ee1b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个测试不会运行。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="ab1e" class="ms lw it nf b gy nj nk l nl nm">class TestAdd(unittest.TestCase):</span><span id="38ae" class="ms lw it nf b gy ns nk l nl nm">     def add_test(self):</span><span id="fb41" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.add(4, 2), 7)</span></pre><p id="2258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试方法必须以“测试”开始。“测试-添加”将运行，但“添加测试”不会运行。如果你定义了一个不以' test '开头的方法，它会自动通过测试--因为它从来没有运行过。所以还不如根本不存在。实际上，有一个你认为已经通过的测试比一个不存在的测试要糟糕得多。它会影响你的bug修复。还有，不要怕名字长，要具体。这使得查找bug变得容易多了。</p><h2 id="33cc" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">从简单直观的测试开始，逐步建立</h2><p id="c444" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从首先想到的测试开始。这些应该确保你的职能的主要目标是正确的。一旦这些测试通过，那么你就可以考虑更复杂的测试了。在确保基本功能正确之前，不要变得复杂。</p><h2 id="00d5" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">边缘案例和越界</h2><p id="352e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我喜欢开始思考边缘案例。让我们以处理数字为例。如果我们输入负数会发生什么？还是花车？或者像零这样的边界数。零爱打破代码，所以有一个测试总是好的。让我们再举一些例子。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="a695" class="ms lw it nf b gy nj nk l nl nm">class TestAdd(unittest.TestCase):</span><span id="5be1" class="ms lw it nf b gy ns nk l nl nm">     def test_add(self):</span><span id="261d" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.add(4, 2), 7)</span><span id="04b0" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.add(-1, 1), 0)</span><span id="8b97" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.add(-1, -1), -2)</span><span id="396e" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.add(0, -1), -1)</span></pre><p id="165e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，我们的代码看起来不错:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/ee934a5a317f959721e6313d0e21632e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7L1iepCohDNfd7nrmdZG0A.png"/></div></div></figure><h2 id="51d0" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">每个测试都应该是独立的</h2><p id="342a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">测试不应该互相依赖。Unittest有内置的<a class="ae ky" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">功能</a>来防止你这样做。<code class="fe nn no np nf b"><a class="ae ky" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp" rel="noopener ugc nofollow" target="_blank">setUp()</a></code>和<code class="fe nn no np nf b"><a class="ae ky" href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown" rel="noopener ugc nofollow" target="_blank">tearDown()</a></code>方法允许您定义将在每个测试方法之前和之后执行的指令。我说这是因为Unittest不能保证您的测试会按照您指定的顺序运行。</p><h2 id="d560" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">避免使用Assert。伊斯特鲁</h2><p id="c5b3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">它只是没有给你足够的信息。它只会告诉你这个值是真还是假。如果你像我们之前一样使用assertEqual方法，你会得到更多的信息。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="8cb4" class="ms lw it nf b gy nj nk l nl nm">AssertionError: 6 != 7</span></pre><p id="dbec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比以下方式更容易调试:</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="3267" class="ms lw it nf b gy nj nk l nl nm">Expected True, but the actual result was False</span></pre><h1 id="6404" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">有时候你的测试仍然会遗漏一些东西——没关系。</h1><p id="106d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">只要回去添加一个新的测试，这样你下次就不会错过了。</p><p id="bee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看这个将一个数四舍五入并加10的函数的例子。没什么疯狂的。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="edd5" class="ms lw it nf b gy nj nk l nl nm">def round_plus_ten(x):</span><span id="e55a" class="ms lw it nf b gy ns nk l nl nm">     x = round(x) + 10</span><span id="bdff" class="ms lw it nf b gy ns nk l nl nm">     return x</span></pre><p id="4e6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试套件。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="0fe8" class="ms lw it nf b gy nj nk l nl nm">class TestRound(unittest.TestCase):</span><span id="4f5a" class="ms lw it nf b gy ns nk l nl nm">     def test_round(self):</span><span id="7ef4" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.round_plus_ten(4.3), 14)</span><span id="c71b" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.round_plus_ten(4.7), 15)</span><span id="4e0c" class="ms lw it nf b gy ns nk l nl nm">          self.assertEqual(functions.round_plus_ten(4.5), 15)</span></pre><p id="37be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个角度来看(如果你还不知道round方法的来龙去脉)，你会认为所有的测试都通过了。他们没有。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/16dabdfc60b32992ba9cc2882d408e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFrP5LlSl88jKhCbPLksOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/1123a9ae3600f718a1e6192fc925e83f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORTbBxMBv30souE9dF-dlw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由作者创建</p></figure><p id="c75b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里看到(感谢测试运行器的有用性),舍入4.5不等于5。因此，当我们加上10时，它不等于14。round方法在边距处向下舍入，而不是向上舍入。这些小错误有时会破坏整个程序，正如我在开始时所说的，你甚至不会想到它们。</p><p id="fced" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子强调了两件事。</p><p id="0575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1 —你永远不会想到你的程序可能失败的所有方式，但是测试增加了你的机会。</p><p id="3c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2-如果您遗漏了一些东西，回到您的测试文件，为这种情况编写一个新的断言。这意味着您在将来不会再错过它(包括您将函数和测试文件复制到的任何其他项目)。</p><p id="56c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个好的测试类在未来和一个好的函数一样有用。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="5861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读，我希望这能帮助你。</p><pre class="kj kk kl km gt ne nf ng nh aw ni bi"><span id="6d32" class="ms lw it nf b gy nj nk l nl nm">If I’ve inspired you to join medium I would be really grateful if you did it through this <a class="ae ky" href="https://jamesasher4994.medium.com/membership" rel="noopener">link</a> — it will help to support me to write better content in the future.</span><span id="c588" class="ms lw it nf b gy ns nk l nl nm">If you want to learn more about data science, become a certified data scientist, or land a job in data science, then checkout <a class="ae ky" href="https://365datascience.pxf.io/c/3458822/791349/11148" rel="noopener ugc nofollow" target="_blank">365 data science</a> through my <a class="ae ky" href="https://365datascience.pxf.io/c/3458822/791349/11148" rel="noopener ugc nofollow" target="_blank">affiliate link.</a></span></pre><p id="2ba1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我写的其他一些东西:</p><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/econometrics-is-the-original-data-science-6725d3f0d843"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">计量经济学是原始的数据科学</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">这就是你应该多了解它的原因</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/how-to-easily-show-your-matplotlib-plots-and-pandas-dataframes-dynamically-on-your-website-a9613eff7ae3"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">如何轻松地在你的网站上动态显示你的Matplotlib图和Pandas数据框。</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">这是一种令人惊讶的简单方法，可以在线向全世界展示您的图表和数据框架，而且不到…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a rel="noopener follow" target="_blank" href="/how-to-easily-run-python-scripts-on-website-inputs-d5167bd4eb4b"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">如何在网站输入上轻松运行Python脚本</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">这是我建立的一个网站的演示，它将动态分析文本情感</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">towardsdatascience.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>