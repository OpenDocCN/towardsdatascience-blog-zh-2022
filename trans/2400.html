<html>
<head>
<title>Recursion for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的递归</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/recursion-for-data-scientists-b08b4f96e450#2022-05-25">https://towardsdatascience.com/recursion-for-data-scientists-b08b4f96e450#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d4be" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">要理解递归，首先你必须理解递归</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1c7214f88c41d7ad7b078f7c9bed6798.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjZPb_vSJ7Mm9lmMiaG_Uw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">信用:Pexels.com</p></figure><p id="cc1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于数据科学家来说，绕过计算机科学基础和软件工程最佳实践以追求工具精通(Pandas &amp; SKLearn举两个例子)并立即开始为您的组织增加价值的诱惑是真实的。</p><p id="63a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">CS中的许多基本概念真的值得争论，因为它们将使您在冗长地争论笨拙的数据时构建简洁的、可伸缩的逻辑。在这篇文章中，我们将定义一个递归函数，它可以在python字典中搜索目标值。事不宜迟，我们开始吧！</p><h1 id="6f9f" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">什么是递归？</h1><p id="3e8e" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">递归通俗的说就是自引用函数。简单来说，函数可以自己调用！但是这样不会导致无限循环吗？诀窍是通过使用控制流(if/elif/else逻辑)来定义终止功能的基本情况。)</p><h2 id="65b3" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">伪代码</h2><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="becd" class="mr lv it ne b gy ni nj l nk nl">def recursive_function(argument):<br/>   if base case:<br/>      return terminal_action(argument)<br/>   else:<br/>      new_argument = intermediate_action(argument)<br/>      recursive_function(new_argument)</span></pre><p id="ca06" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于上述内容的几点说明:</p><ol class=""><li id="2fea" class="nm nn it la b lb lc le lf lh no ll np lp nq lt nr ns nt nu bi translated">我们需要指定一个“岔路口”要么基本情况得到满足，我们退出递归逻辑，要么我们递归地使用函数<em class="nv">到达</em>基本情况。</li><li id="68b1" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">基本情况下的终端功能是完全可选的。您可能只想按原样返回参数，在这种情况下，您的终端函数将归结为<code class="fe ob oc od ne b">lambda x: x</code>。</li><li id="1a39" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">为了不陷入无限循环，我们不能一遍又一遍地把同一个参数传递给递归函数；我们需要使用一个<em class="nv">中间动作</em>来修改参数。与终端动作不同，中间动作不能是被动的(归结为<code class="fe ob oc od ne b">lambda x: x</code>)。)</li><li id="2968" class="nm nn it la b lb nw le nx lh ny ll nz lp oa lt nr ns nt nu bi translated">可以根据需要添加副作用，或者对递归逻辑或基本情况不重要的动作。</li></ol><h2 id="67e3" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">说明性示例</h2><p id="c897" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">这个例子，blastoff，是递归函数的helloWorld。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="6fdc" class="mr lv it ne b gy ni nj l nk nl">def blastoff(x):<br/>   # base case <br/>   if x == 0:<br/>      print("blastoff!") # side effect<br/>      return # terminal action: None/passive</span><span id="5b22" class="mr lv it ne b gy oe nj l nk nl">   # recursive logic<br/>   else:<br/>      print(x) #side effect<br/>      blastoff(x-1) # intermediate action: decrementing x by 1</span><span id="0028" class="mr lv it ne b gy oe nj l nk nl">blastoff(5)</span><span id="d952" class="mr lv it ne b gy oe nj l nk nl">&gt;&gt;&gt;</span><span id="349e" class="mr lv it ne b gy oe nj l nk nl">5<br/>4<br/>3<br/>2<br/>1<br/>blastoff!</span></pre><h1 id="42fe" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">真实世界的例子</h1><p id="1066" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">现在，让我们来处理一个真实世界的例子——在嵌套字典中搜索给定值。</p><p id="a29f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么是嵌套字典？因为字典是类似于JSON的python原生目标。事实上，Python很容易支持将JSON对象转换成字典。此外，API响应通常是用JSON交付的(尽管有些仍然使用XML，但是这种方式越来越不受欢迎了)。)</p><p id="bb8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以下一次你需要发现一个给定值是否在你的API请求结果中，你可以简单地(1)将结果从JSON转换成Python字典，然后(2)使用下面的递归函数！</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="d576" class="mr lv it ne b gy ni nj l nk nl">def obj_dfs(obj, target, results=None):<br/>   if not results:<br/>      results = []</span><span id="8a7f" class="mr lv it ne b gy oe nj l nk nl">   # recursive logic<br/>   if isinstance(obj, dict):<br/>      for key, val in obj.items():<br/>         results.append(obj_dfs(key, target, results))<br/>         results.append(obj_dfs(val, target, results))</span><span id="91f6" class="mr lv it ne b gy oe nj l nk nl">   elif isinstance(obj, (list, tuple)):<br/>      for elem in obj:<br/>         results.append(obj_dfs(elem, target, results))</span><span id="ab3d" class="mr lv it ne b gy oe nj l nk nl">   # base case<br/>   else:<br/>      if obj == target:<br/>         return True<br/>      else:<br/>         return False</span><span id="8b2e" class="mr lv it ne b gy oe nj l nk nl">   return any(results)</span></pre><p id="4e39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们把它分成几部分！</p><h2 id="8e6b" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">基础案例</h2><p id="1990" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">基本情况是一个不是字典、列表或元组的对象。换句话说，<em class="nv">如果对象不能包含嵌套字典、元组或列表</em>，则基本情况有效。这些是我们实际搜索的值——字符串、整数、浮点数等。</p><p id="5fc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们检测到一个基本案例时，我们简单地评估这个问题，“<em class="nv">我们找到目标了吗？</em>“返回真或假</p><h2 id="3f00" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">递归逻辑</h2><p id="b059" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果基本情况无效，使得对象可以包含嵌套字典、列表或元组，<em class="nv">我们递归地调用那些非常嵌套的字典、列表或元组上的函数</em>。</p><p id="efa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用了一个<strong class="la iu"> if </strong> <strong class="la iu">块</strong>和一个<strong class="la iu"> elif块</strong>以一种方式处理字典，以另一种方式处理列表和元组。这是必要的，因为字典由(键，值)元组组成，而列表和元组只包含对象。</p><p id="53ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“isinstance”是一个内置的Python函数，它确定对象的类型是等于x还是in (x，y)。</p><h2 id="b0ad" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">结果</h2><p id="8dff" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">我们首先检查结果对象是否存在——如果它不存在，这是默认行为，我们定义一个空列表。在随后的递归调用中，相同的结果对象被更新。</p><p id="2122" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将递归函数追加到列表<em class="nv">中似乎不常见，但是函数</em> <strong class="la iu"> <em class="nv">本身</em> </strong> <em class="nv">永远不会追加到列表</em>中。该函数遵循递归逻辑，仅在基本情况下返回True或False。因此，结果只会被对象填充，每个对象要么等于真，要么等于假。</p><p id="8691" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，该函数返回“any(results)”，在Python中，如果一个或多个嵌套元素为真，则返回真。因此，如果在至少一个检测到的基本案例中找到目标对象，则该函数全局返回True。</p><h2 id="45fe" class="mr lv it bd lw ms mt dn ma mu mv dp me lh mw mx mg ll my mz mi lp na nb mk nc bi translated">扩展空间</h2><p id="7923" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">假设您对精确匹配不感兴趣，而是对模糊匹配感兴趣——或者您有自己的特定于上下文的逻辑。这很好，我们可以将一个函数作为参数传递给我们的递归函数，这将在基本情况下使用。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3e0e" class="mr lv it ne b gy ni nj l nk nl">obj = {'chicago': <br/>          [{'coffee shops':'hero'}, {'bars':'la vaca'}],<br/>       'san francisco': <br/>          [{'restaurants':'el techo'}, <br/>          {'sight seeing':'golden gate bridge'}]}</span><span id="ea5e" class="mr lv it ne b gy oe nj l nk nl">def base(x):<br/>   return 'golden' in x</span><span id="fbaa" class="mr lv it ne b gy oe nj l nk nl">def obj_dfs(obj, f_base, results=None):<br/>   if not results:<br/>      results = []</span><span id="753d" class="mr lv it ne b gy oe nj l nk nl">   # recursive logic<br/>   if isinstance(obj, dict):<br/>      for key, val in obj.items():<br/>         results.append(obj_dfs(key, f_base, results))<br/>         results.append(obj_dfs(val, f_base, results))</span><span id="3705" class="mr lv it ne b gy oe nj l nk nl">   elif isinstance(obj, (list, tuple)):<br/>      for elem in obj:<br/>         results.append(obj_dfs(elem, f_base, results))</span><span id="349a" class="mr lv it ne b gy oe nj l nk nl">   # base case<br/>   else:<br/>      return f_base(obj)</span><span id="7fa1" class="mr lv it ne b gy oe nj l nk nl">   return any(results)</span></pre><h1 id="bc40" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">解析JSON参数</h1><p id="5043" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">最后，要在实际的JSON格式的API响应上使用这个函数，使用下面的代码将API响应转换成dictionary。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2a4e" class="mr lv it ne b gy ni nj l nk nl">import<!-- --> <!-- -->json<br/>with open('data.json') as json_file:<br/>   data <strong class="ne iu">=</strong> <!-- -->json.load(json_file)</span></pre><p id="5980" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以参考这个免费的模板API获得JSON响应来测试这段代码！<a class="ae of" href="https://fakestoreapi.com/" rel="noopener ugc nofollow" target="_blank">https://fakestoreapi.com/</a></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="4f00" class="mr lv it ne b gy ni nj l nk nl">import requests<br/>import json<br/>data = requests.get('https://fakestoreapi.com/products/1')<br/>response = json.loads(data.text)</span><span id="58e5" class="mr lv it ne b gy oe nj l nk nl">def obj_dfs(obj, target, f_base, results=None):<br/>   if not results:<br/>      results = []</span><span id="6428" class="mr lv it ne b gy oe nj l nk nl">   # recursive logic<br/>   if isinstance(obj, dict):<br/>      for key, val in obj.items():<br/>         results.append(obj_dfs(key, target, f_base, results))<br/>         results.append(obj_dfs(val, target, f_base, results))<br/>   <br/>   elif isinstance(obj, (list, tuple)):<br/>      for elem in obj:<br/>         results.append(obj_dfs(elem, target, f_base, results))</span><span id="0697" class="mr lv it ne b gy oe nj l nk nl">   # base case<br/>   else:<br/>      return base_case_function(obj)</span><span id="ebf7" class="mr lv it ne b gy oe nj l nk nl">   if any(results):<br/>      return list(filter(lambda x: x!=False, results))[0]<br/>   else:<br/>      return False</span><span id="81bd" class="mr lv it ne b gy oe nj l nk nl">def find_url(x):<br/>   x = str(x)<br/>    if 'http' in x:<br/>      return x<br/>   else:<br/>      return False</span><span id="328e" class="mr lv it ne b gy oe nj l nk nl">obj_dfs(obj=response, target=None, f_base=find_url)<br/>&gt;&gt;&gt; 'https://fakestoreapi.com/img/81fPKd-2AYL._AC_SL1500_.jpg'</span></pre><p id="d3e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对代码做了一点小小的改动；具体来说，我没有返回<code class="fe ob oc od ne b">any(results)</code>,而是返回了结果中的第一个非False元素，这是在JSON API响应中找到的图片链接url。</p><p id="c8e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你能感受到递归的强大，这是你腰带上的新工具。您可以根据需要修改这段代码！</p><p id="3703" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">我希望这有所帮助——如果有，请订阅我的博客！</strong></p></div></div>    
</body>
</html>