<html>
<head>
<title>Optimizing Memory Usage in Python Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Python应用程序中的内存使用</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/optimizing-memory-usage-in-python-applications-f591fc914df5#2022-02-28">https://towardsdatascience.com/optimizing-memory-usage-in-python-applications-f591fc914df5#2022-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3989" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过这些简单的技巧和高效的数据结构，找出您的Python应用程序使用过多内存的原因，并减少它们的RAM使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d3a3bb4c8dcf2ef172462fa202c21da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4gDLYwUqHk5FhzBiTKkPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@bayc7739?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>无聊的冒险家贝可</a>拍摄的照片</p></figure><p id="3ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到性能优化，人们通常只关注速度和CPU使用率。很少有人关心内存消耗，直到他们耗尽内存。尝试限制内存使用有很多原因，不仅仅是为了避免应用程序因为内存不足错误而崩溃。</p><p id="a60c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将探索发现Python应用程序中哪些部分消耗了过多内存的技术，分析其原因，并最终使用简单的技巧和内存高效的数据结构来减少内存消耗和内存占用。</p><h1 id="8df7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">为什么要这么麻烦呢？</h1><p id="24c7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">但是首先，你为什么要费心保存内存呢？除了避免前面提到的内存不足错误/崩溃之外，还有其他节省内存的理由吗？</p><p id="3166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的原因就是钱。资源CPU和RAM——都是要花钱的，如果有减少内存占用的方法，为什么还要通过运行低效的应用程序来浪费内存呢？</p><p id="3b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个原因是<em class="ms">“数据有质量”</em>的概念，如果有大量数据，那么它会慢慢移动。如果数据必须存储在磁盘上，而不是RAM或快速缓存中，那么加载和处理将需要一段时间，从而影响整体性能。因此，优化内存使用可能会有一个很好的副作用，那就是加快应用程序的运行时间。</p><p id="f255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在某些情况下，可以通过添加更多的内存来提高性能(如果应用程序的性能受内存限制)，但是如果机器上没有任何内存，就不能这样做。</p><h1 id="4885" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">找到瓶颈</h1><p id="b81a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">很明显，我们有充分的理由减少Python应用程序的内存使用，但是在我们这样做之前，我们首先需要找到占用所有内存的瓶颈或代码部分。</p><p id="c566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将介绍的第一个工具是<code class="fe mt mu mv mw b">memory_profiler</code>。该工具逐行测量特定函数的内存使用情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了开始使用它，我们将它与<code class="fe mt mu mv mw b">pip</code>和<code class="fe mt mu mv mw b">psutil</code>包一起安装，这显著提高了profiler的性能。除此之外，我们还需要用<code class="fe mt mu mv mw b">@profile</code>装饰器标记我们想要进行基准测试的函数。最后，我们使用<code class="fe mt mu mv mw b">python -m memory_profiler</code>对我们的代码运行分析器。这逐行显示了修饰函数的内存使用/分配情况——在本例中是<code class="fe mt mu mv mw b">memory_intensive</code>——它有意创建和删除大型列表。</p><p id="01d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们知道了如何缩小我们的关注范围，并找到增加内存消耗的特定行，我们可能想要更深入地挖掘一下，看看每个变量使用了多少。你可能以前见过用来测量这个的<code class="fe mt mu mv mw b">sys.getsizeof</code>。然而，对于某些类型的数据结构，这个函数会给你一些有问题的信息。对于整数或bytearrays，您将获得以字节为单位的实际大小，但是对于list这样的容器，您将仅获得容器本身的大小，而不是其内容的大小:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，对于普通整数，每当我们越过一个阈值时，大小就会增加4个字节。类似地，对于普通字符串，每次我们添加另一个字符，就会增加一个额外的字节。然而对于列表来说，这并不成立——在本例中，<code class="fe mt mu mv mw b">sys.getsizeof</code>不<em class="ms"/>遍历数据结构，只返回父对象的大小。</p><p id="c01c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是使用专门设计的工具来分析记忆行为。一个这样的工具是，它可以帮助您获得关于Python对象大小的更现实的想法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pympler为<code class="fe mt mu mv mw b">asizeof</code>模块提供了相同名称的函数，它可以正确地报告列表的大小以及它包含的所有值。此外，这个模块还具有<code class="fe mt mu mv mw b">asized</code>功能，可以给我们进一步的尺寸细分对象的单个组件。</p><p id="e52c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Pympler有更多的特性，包括<a class="ae ky" href="https://pympler.readthedocs.io/en/latest/classtracker.html#classtracker" rel="noopener ugc nofollow" target="_blank">跟踪类实例</a>或<a class="ae ky" href="https://pympler.readthedocs.io/en/latest/muppy.html#muppy" rel="noopener ugc nofollow" target="_blank">识别内存泄漏</a>。如果您的应用程序可能需要这些东西，那么我建议查看<a class="ae ky" href="https://pympler.readthedocs.io/en/latest/tutorials/tutorials.html" rel="noopener ugc nofollow" target="_blank">文档</a>中的教程。</p><h1 id="536c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">节省一些内存</h1><p id="09c8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">既然我们知道如何寻找各种潜在的内存问题，我们需要找到一种方法来修复它们。潜在的、最快和最容易的解决方案可能是切换到更节省内存的数据结构。</p><p id="b2d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在存储值数组时，Python <code class="fe mt mu mv mw b">lists</code>是更需要内存的选项之一:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e8ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的简单函数(<code class="fe mt mu mv mw b">allocate</code>)使用指定的<code class="fe mt mu mv mw b">size</code>创建一个数字的Python <code class="fe mt mu mv mw b">list</code>。为了测量它占用了多少内存，我们可以使用前面显示的<code class="fe mt mu mv mw b">memory_profiler</code>,它给出了函数执行过程中0.2秒间隔内使用的内存量。我们可以看到，生成1000万个数字的<code class="fe mt mu mv mw b">list</code>需要350MiB以上的内存。对一堆数字来说，这似乎太多了。我们能做得更好吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="b789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们使用Python的<code class="fe mt mu mv mw b">array</code>模块，它可以存储原语，比如整数或字符。我们可以看到，在这种情况下，内存使用的峰值刚刚超过100MiB。与<code class="fe mt mu mv mw b">list</code>相比，这是一个巨大的差异。通过选择适当的精度，可以进一步减少内存使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mt mu mv mw b">array</code>作为数据容器的一个主要缺点是它不支持那么多类型。</p><p id="0a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您计划对数据执行大量的数学运算，那么您最好使用NumPy数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="248c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，NumPy数组在内存使用方面表现也很好，峰值数组大小约为123MiB。这比<code class="fe mt mu mv mw b">array</code>多一点，但是使用NumPy，您可以利用快速数学函数以及<code class="fe mt mu mv mw b">array</code>不支持的类型，比如复数。</p><p id="7018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述优化有助于值数组的整体大小，但我们也可以对Python类定义的单个对象的大小进行一些改进。这可以通过使用<code class="fe mt mu mv mw b">__slots__</code> class属性来完成，该属性用于显式声明类属性。在一个类上声明<code class="fe mt mu mv mw b">__slots__</code>还有一个很好的副作用，就是拒绝创建<code class="fe mt mu mv mw b">__dict__</code>和<code class="fe mt mu mv mw b">__weakref__</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="758a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到<code class="fe mt mu mv mw b">Smaller</code>类实例实际上要小得多。没有<code class="fe mt mu mv mw b">__dict__</code>会从每个实例中删除整整104个字节，这在实例化数百万个值时可以节省大量内存。</p><p id="4d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的提示和技巧应该有助于处理数值和<code class="fe mt mu mv mw b">class</code>对象。但是，字符串呢？你应该如何储存它们通常取决于你打算用它们做什么。如果你要搜索大量的字符串值，那么——正如我们已经看到的——使用<code class="fe mt mu mv mw b">list</code>是非常糟糕的主意。如果执行速度很重要的话，<code class="fe mt mu mv mw b">set</code>可能会更合适一些，但是可能会消耗更多的内存。最好的选择可能是使用优化的数据结构，如<em class="ms"> trie </em>，尤其是用于查询等静态数据集。Python中常见的是，已经有一个这样的库，以及许多其他类似树的数据结构，其中一些你可以在https://github.com/pytries找到。</p><h1 id="852b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">根本不使用内存</h1><p id="94ed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">节省RAM的最简单方法是首先不要使用它。显然，您无法完全避免使用RAM，但是您可以避免一次加载全部数据集，而是尽可能地增量处理数据。实现这一点最简单的方法是使用返回一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Lazy_evaluation#Python" rel="noopener ugc nofollow" target="_blank">惰性</a>迭代器的生成器，它按需计算元素，而不是一次全部计算。</p><p id="6eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以利用的更强大的工具是<em class="ms">内存映射</em>文件，它允许我们只从一个文件中加载部分数据。Python的标准库为此提供了<code class="fe mt mu mv mw b">mmap</code>模块，可用于创建内存映射文件，其行为类似于文件和字节数组。您可以将它们用于文件操作，如<code class="fe mt mu mv mw b">read</code>、<code class="fe mt mu mv mw b">seek</code>或<code class="fe mt mu mv mw b">write</code>以及字符串操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="353d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加载/读取内存映射文件非常简单。我们首先像往常一样打开文件进行阅读。然后我们使用文件的文件描述符(<code class="fe mt mu mv mw b">file.fileno()</code>)来创建内存映射文件。从那里，我们可以通过文件操作(如<code class="fe mt mu mv mw b">read</code>或字符串操作(如<em class="ms">切片</em>)来访问它的数据。</p><p id="622a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，您可能更有兴趣阅读如上所示的文件，但也有可能写入内存映射文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="877f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将注意到的代码中的第一个不同之处是访问模式变成了<code class="fe mt mu mv mw b">r+</code>，它表示读和写。为了展示我们确实可以执行读写操作，我们首先从文件中读取，然后使用RegEx搜索所有以大写字母开头的单词。之后，我们演示从文件中删除数据。这不像阅读和搜索那样简单，因为当我们删除一些内容时，我们需要调整文件的大小。为此，我们使用<code class="fe mt mu mv mw b">mmap</code>模块的<code class="fe mt mu mv mw b">move(dest, src, count)</code>方法，该方法将数据的<code class="fe mt mu mv mw b">size - end</code>字节从索引<code class="fe mt mu mv mw b">end</code>复制到索引<code class="fe mt mu mv mw b">start</code>，在这种情况下，这意味着删除前10个字节。</p><p id="8263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在NumPy中进行计算，那么您可能更喜欢它的<code class="fe mt mu mv mw b">memmap</code>特性<a class="ae ky" href="https://numpy.org/doc/stable/reference/generated/numpy.memmap.html" rel="noopener ugc nofollow" target="_blank"> (docs) </a>，它适合存储在二进制文件中的NumPy数组。</p><h1 id="6ddf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结束语</h1><p id="b8c8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">优化应用程序通常是个难题。它还严重依赖于手头的任务以及数据本身的类型。在本文中，我们研究了查找内存使用问题的常用方法以及修复这些问题的一些选项。然而，还有许多其他方法可以减少应用程序的内存占用。这包括通过使用概率数据结构，如<a class="ae ky" href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener ugc nofollow" target="_blank"> bloom filters </a>或<a class="ae ky" href="https://en.wikipedia.org/wiki/HyperLogLog" rel="noopener ugc nofollow" target="_blank"> HyperLogLog </a>来换取存储空间的准确性。另一种选择是使用树状数据结构，如<a class="ae ky" href="https://github.com/pytries/DAWG" rel="noopener ugc nofollow" target="_blank"> DAWG </a>或<a class="ae ky" href="https://github.com/pytries/marisa-trie" rel="noopener ugc nofollow" target="_blank"> Marissa trie </a>，它们在存储字符串数据方面非常有效。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="a34f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">本文原帖</em><a class="ae ky" href="https://martinheinz.dev/blog/68?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_68" rel="noopener ugc nofollow" target="_blank"><em class="ms">martinheinz . dev</em>T22】</a></p><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/profiling-and-analyzing-performance-of-python-programs-3bf3b41acd16"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">剖析和分析Python程序的性能</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">快速找到Python程序中的所有瓶颈并修复它们的工具和技术</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/exploring-google-analytics-realtime-data-with-python-8625849c7d7a"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">用Python探索Google Analytics实时数据</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">使用REST API和Python充分利用所有Google Analytics特性和数据</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx ks nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a rel="noopener follow" target="_blank" href="/all-the-ways-to-compress-and-archive-files-in-python-e8076ccedb4b"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">Python中压缩和归档文件的所有方法</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">用Python压缩、解压缩和管理你可能需要的所有格式的档案和文件</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">towardsdatascience.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx ks nj"/></div></div></a></div></div></div>    
</body>
</html>