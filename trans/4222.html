<html>
<head>
<title>Data and Machine Learning Model Versioning with DVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用DVC进行数据和机器学习模型版本控制</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/data-and-machine-learning-model-versioning-with-dvc-34fdadd06b15#2022-09-20">https://towardsdatascience.com/data-and-machine-learning-model-versioning-with-dvc-34fdadd06b15#2022-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dab4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">DVC:这是一个Git，但对于我们的数据和ML模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53058065f1ff2d39816ae782dc9d4f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAlweCNbvOFgwtMoMrFtHg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lucabravo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卢卡·布拉沃</a>在<a class="ae ky" href="https://unsplash.com/s/photos/grey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="e511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想我们都同意，每个数据科学项目都很有可能变得极其混乱。数据科学项目中有三种常见的混乱来源:<em class="lv">代码</em>、<em class="lv">数据</em>和<em class="lv"> ML模型</em>。</p><p id="f93f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是数据科学项目中源于数据、ML模型或代码的混乱的一些例子:</p><ul class=""><li id="eca4" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><strong class="lb iu"> <em class="lv">数据</em> </strong> ➡️我们实现哪些ML模型并不重要，它们都需要几组特征，这些特征需要在训练过程之前进行预处理。问题是，我们不知道哪些特性或预处理技术最适合我们的模型。因此，我们很可能最终会创建数据集的几个版本，每个版本都使用不同的转换或特征工程技术。</li><li id="da68" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu"> <em class="lv"> ML模型</em> </strong> ➡️每个模型都有需要微调的超参数。然而，我们不太可能知道超参数的组合会给我们最好的结果，所以最有可能的是，我们最终会有几个版本的模型。</li><li id="02f9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><strong class="lb iu"> <em class="lv">代码</em> </strong> ➡️为数据预处理管道和模型训练开发脚本不是一个线性的过程。因此，我们需要不断地更改/更新几行代码来调整模型的超参数值，或者添加/删除数据管道步骤。</li></ul><p id="66cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于上述问题，接下来可能会发生以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ef7662f28db7ce483362b62361c02168.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*Tw3AUG77_4QAIDCyWF9FPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ba27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过大量的实验后，我们假设<code class="fe ml mm mn mo b">model_2.pkl</code>给出了目前为止我们训练的三个模型中最好的结果。如果没有适当的方法来构建我们的数据科学项目，我们最终可能会问自己以下任何(如果不是全部)问题:</p><ul class=""><li id="4af0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我们使用了哪些数据和预处理技术来训练这个模型？</li><li id="5e68" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们用来获得这个模型的超参数设置是什么？</li><li id="27f3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果我们忘记了用于训练该模型的数据和超参数设置，那么有人如何能够再现该实验以获得相同的模型呢？</li></ul><p id="4bd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下，我们项目的复杂性呈指数增长，在数据科学项目中重现任何实验都变得极其困难。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="82c6" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">去救援吗？</h1><p id="9041" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">为了解决上面的问题，我们可以使用Git，这是一个版本控制来跟踪我们的代码。使用Git，您可以在不同版本的代码之间来回切换。</p><p id="38b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，Git并不是解决数据科学项目再现性问题的最佳解决方案，因为:</p><ul class=""><li id="30bc" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">Git主要设计用于存储文本文件，通常不能很好地跟踪二进制文件(例如数据集)的变化。</li><li id="c7c9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">Git-LFS使我们能够在Git上构建时存储大文件，它需要一个特殊的服务器，并且有文件大小限制，当我们想要存储巨大的数据集和模型时，这可能是一个问题。</li></ul><p id="8461" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们想要的是一个专门为数据科学问题设计的控制版本系统。这意味着控制版本系统:</p><ul class=""><li id="c722" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">允许我们选择存储服务来托管我们的数据和模型，同时还允许我们在不同版本的数据和模型之间轻松切换。</li><li id="6e08" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">允许我们根据特定版本的数据集或模型重现数据科学问题的结果。</li></ul><p id="98ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是DVC对我们非常有帮助的地方。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="9c3d" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">什么是DVC？</h1><p id="6488" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">DVC代表<strong class="lb iu">数据版本控制</strong>。这是一个开源工具，允许我们轻松地对我们的数据、ML模型、度量文件等进行版本控制。如果你了解Git，那么就很容易理解DVC是如何工作的，因为Git和DVC有很多相似之处:</p><ul class=""><li id="00e9" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">DVC和Git有相似的概念和语法，但是它主要是被设计来跟踪我们的数据、ML模型、度量等等。</li><li id="3433" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">DVC与Git无缝协作，我们将看到如何利用两者来一次轻松地对源代码、数据和ML模型进行版本控制。</li></ul><p id="ce48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DVC的一个主要优势是，它允许我们在自己选择的存储服务中存储不同版本的数据。这可以在亚马逊S3，谷歌驱动，Azure，谷歌云存储，或者只是在我们的本地机器上。</p><p id="8775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DVC通过生成一个指向数据或模型的特定版本的轻量级文本文件来跟踪我们的数据或模型的不同版本。每当我们想从远程存储或缓存中获取数据集或模型的特定版本时，DVC都会使用这个文本文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/ecb2929de66d27ad2be67cc2aa11b3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nKnO6BbXK3DhYGLIIJJptA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常用Git将这个小文本文件和所有代码存储在一起。所以最终，我们在Git repo中只有代码和这个轻量级的文本文件，而实际的数据和模型驻留在我们选择的远程存储中。</p><p id="6d49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们开始实施DVC。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="53f1" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">入门指南</h1><p id="6d9b" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在本文中，我们将了解如何使用DVC跟踪不同版本的数据集和ML模型。此外，我们将了解如何使用它在不同版本的数据集和ML模型之间来回切换。</p><p id="373a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有这样做，您可以使用pip install安装DVC:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="c599" class="ny mx it mo b gy nz oa l ob oc">pip install dvc</span></pre><p id="b5a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先需要做的是在本地计算机上创建一个空文件夹，作为我们的本地repo。为了简单起见，我们称这个文件夹为<code class="fe ml mm mn mo b">dvc-project</code></p><p id="504a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，要使这个文件夹成为本地repo，我们需要在终端中使用以下命令初始化这个文件夹中的Git和DVC:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="de9c" class="ny mx it mo b gy nz oa l ob oc">$ cd dvc-project<br/>$ git init<br/>$ dvc init</span></pre><p id="05cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，您将在命令行中得到以下消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/fe852c1c2785f2690eb5db32b3eef562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wXYGyyS2EMlAQhJNmEiyqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="01df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们初始化DVC之后，在我们的<code class="fe ml mm mn mo b">dvc-project</code>文件夹中创建了一个名为<code class="fe ml mm mn mo b">.dvc/</code>的目录来存储配置文件、缓存位置和其他内部目录。当你输入<code class="fe ml mm mn mo b">git status</code>命令时，你可以看到它们是在文件夹中创建的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e7ce6b43256028d0ac824df8e5fc960b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sURY-O2bkLEBc2HuzPNobg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要指定我们的远程存储，即我们存储不同版本的数据和ML模型的实际存储。这可以是谷歌驱动、亚马逊S3、谷歌云存储、Azure存储，或者在你的本地机器上。通常，您可以使用以下命令设置远程存储:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="6731" class="ny mx it mo b gy nz oa l ob oc">$ dvc remote add -d remote path/to/remote</span></pre><p id="0e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用Google Drive，因为我相信任何人都有Google Drive。要用DVC在Google Drive上设置我们的远程存储，我们可以执行以下简单的命令:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="9e04" class="ny mx it mo b gy nz oa l ob oc">$ dvc remote add -d remote gdrive://{random numbers+letters}</span></pre><p id="e741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当你打开Google Drive时，你在那里创建的任何文件夹的URL看起来都会像这样:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="f7b6" class="ny mx it mo b gy nz oa l ob oc"><a class="ae ky" href="https://drive.google.com/drive/u/0/folders/1v1cBGN9vS9NT6-t6QhJGiNxshTu-7dFw" rel="noopener ugc nofollow" target="_blank">https://drive.google.com/drive/u/0/folders/1v1cBGN9vS9NT6-t6QhJG</a></span></pre><p id="3395" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将上面包含数字和字母组合的URL部分复制到上面的DVC命令中。在上面的例子中，这将是:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="6069" class="ny mx it mo b gy nz oa l ob oc">$ dvc remote add -d remote gdrive://<a class="ae ky" href="https://drive.google.com/drive/u/0/folders/1v1cBGN9vS9NT6-t6QhJGiNxshTu-7dFw" rel="noopener ugc nofollow" target="_blank">1v1cBGN9vS9NT6-t6QhJG</a></span></pre><p id="8aa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查远程存储是否已正确设置，我们可以使用以下命令:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="4757" class="ny mx it mo b gy nz oa l ob oc">$ dvc config -l</span></pre><p id="61f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，由于我们刚刚通知了DVC我们的远程存储在哪里，那么<code class="fe ml mm mn mo b">.dvc/</code>目录中的配置文件也将被更新。为了跟踪这一更新，<code class="fe ml mm mn mo b">git add</code>命令将完成这项工作。</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="74a2" class="ny mx it mo b gy nz oa l ob oc">git add .dvc/config</span></pre><p id="37d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都准备好了！现在我们可以开始和DVC一起玩了。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="f892" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">数据版本化</h1><p id="0af5" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我们将在本文中使用的数据是<a class="ae ky" href="https://www.kaggle.com/datasets/jp797498e/twitter-entity-sentiment-analysis" rel="noopener ugc nofollow" target="_blank"> Twitter情感数据集</a>的子集。该数据集不受版权保护，因此您可以出于自己的目的使用它。我将数据集分成两部分:一部分叫做<code class="fe ml mm mn mo b">twitter_1.csv</code>，另一部分叫做<code class="fe ml mm mn mo b">twitter_2.csv</code>。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="22f3" class="ny mx it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">数据的第一版本</h2><p id="669a" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这个数据集的第一个版本就是最初的<code class="fe ml mm mn mo b">twitter_1.csv</code>和<code class="fe ml mm mn mo b">twitter_2.csv</code>。要获得这些数据，只需复制下面的两个<code class="fe ml mm mn mo b">dvc get-url</code>命令:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="a18d" class="ny mx it mo b gy nz oa l ob oc">$ dvc get-url <a class="ae ky" href="https://dagshub.com/marcellusruben/twitter_data/raw/00d21f134ed9449ab55d732dd8030a45284142df/twitter_1.csv" rel="noopener ugc nofollow" target="_blank">https://dagshub.com/marcellusruben/twitter_data/raw/00d21f134ed9449ab55d732dd8030a45284142df/twitter_1.csv</a></span><span id="3715" class="ny mx it mo b gy op oa l ob oc">$ dvc get-url <a class="ae ky" href="https://dagshub.com/marcellusruben/twitter_data/raw/00d21f134ed9449ab55d732dd8030a45284142df/twitter_2.csv" rel="noopener ugc nofollow" target="_blank">https://dagshub.com/marcellusruben/twitter_data/raw/00d21f134ed9449ab55d732dd8030a45284142df/twitter_2.csv</a></span></pre><p id="5d07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在如果你看一下你的<code class="fe ml mm mn mo b">dvc-project</code>文件夹，你会看到现在你有<code class="fe ml mm mn mo b">twitter_1.csv</code>和<code class="fe ml mm mn mo b">twitter_2.csv</code>。这两个文件都有大约2,5 MB的内存。</p><p id="27b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一步，让我们将这些文件存储到我们的远程存储中，这是我们在上一节中设置的Google Drive。要将我们的CSV文件推入远程存储，首先我们需要用<code class="fe ml mm mn mo b">dvc add</code>命令跟踪这两个文件:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="1ada" class="ny mx it mo b gy nz oa l ob oc">$ dvc add twitter_1.csv twitter_2.csv</span></pre><p id="08bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe ml mm mn mo b">dvc add</code>命令时，我们基本上是告诉DVC，在我们将这两个文件上传到远程存储之前，我们希望DVC跟踪并准备好这两个文件。该命令类似于<code class="fe ml mm mn mo b">git add</code>命令。</p><p id="16c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个<code class="fe ml mm mn mo b">dvc add</code>命令之后，运行<code class="fe ml mm mn mo b">git status</code>命令，您将看到类似的输出，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/0f7095fc6a33a1eb5199e9453b8fa47c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oksw7fmfYj-9tWD6VFhoRA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e915" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ml mm mn mo b">dvc add</code>命令之后生成了3个新文件:一个<code class="fe ml mm mn mo b">.gitignore</code>文件和与我们的数据集名称相似的文件，最后带有附加的<code class="fe ml mm mn mo b">.dvc</code>扩展名。</p><ul class=""><li id="23de" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ml mm mn mo b">.gitignore</code>文件告诉Git忽略我们用DVC ( <code class="fe ml mm mn mo b">twitter_1.csv</code>和<code class="fe ml mm mn mo b">twitter_2.csv</code>)跟踪的数据集</li><li id="9b7a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">扩展名为<code class="fe ml mm mn mo b">.dvc</code>的文件是文本文件，它将充当指向实际数据集的指针。例如，<code class="fe ml mm mn mo b">twitter_1.csv.dvc</code>是指向<code class="fe ml mm mn mo b">twitter_1.csv</code>数据的指针。</li></ul><p id="1b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前一节所述，Git将跟踪这些指针文件。通过跟踪指针文件而不是实际数据，我们就不再在Git repo中存储大文件(比如实际数据集)。</p><p id="ea5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以使用<code class="fe ml mm mn mo b">dvc push</code>命令将数据推入远程存储:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="6dfd" class="ny mx it mo b gy nz oa l ob oc">$ dvc push</span></pre><p id="0513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下你的Google Drive，现在你应该有如下类似的文件夹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/54b824c03098dc8db35d97c373ebf34a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TOgvmJYVhTjPPfXmaBPohw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="4add" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ml mm mn mo b">dvc push</code>命令推送数据集后，您在Google Drive或远程存储上看到的文件称为blob，正如您在上面的截图中看到的。DVC将原始数据集的内容存储在这个blob中。</p><p id="7bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们保存数据的当前版本，以便以后我们可以随时访问它。以下是执行此操作的步骤:</p><ul class=""><li id="0e61" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">使用<code class="fe ml mm mn mo b">git add</code>命令用Git跟踪<code class="fe ml mm mn mo b">.gitignore</code>文件和扩展名为<code class="fe ml mm mn mo b">.dvc</code>的文件</li><li id="db10" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">用<code class="fe ml mm mn mo b">git commit</code>提交文件，然后在提交过程中写一些有意义的消息</li><li id="f9bd" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">向commit with <code class="fe ml mm mn mo b">git tag</code>命令添加一个有意义的标记。这个命令很重要，因为当我们稍后想要在数据集的不同版本之间切换时，这个标签就是我们要参考的</li></ul><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="627c" class="ny mx it mo b gy nz oa l ob oc">$ git add .gitignore twitter_1.csv.dvc twitter_2.csv.dvc<br/>$ git commit -m "Dataset V1.0"<br/>$ git tag v1.0</span></pre><p id="4145" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们数据的第一个版本。以下是我们迄今为止所做工作的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/08a93dfcf732ce0f0d12ef25855fd2fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uF0NKy9nXjXLj7PmuyhUcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="98c2" class="ny mx it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">数据的第二个版本</h2><p id="d1cf" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">对于数据的第二个版本，假设我们想要修改我们的<code class="fe ml mm mn mo b">twitter_1.csv</code>。也就是说，我们想要将<code class="fe ml mm mn mo b">twitter_2.csv</code>的所有内容添加到<code class="fe ml mm mn mo b">twitter_1.csv</code>中:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="6f10" class="ny mx it mo b gy nz oa l ob oc"><strong class="mo iu">With Mac/Linux</strong><br/>$ cat &lt;(tail +2 twitter_2.csv) &gt;&gt; twitter_1.csv</span><span id="303f" class="ny mx it mo b gy op oa l ob oc"><strong class="mo iu">With Windows</strong><br/>$ more +2 twitter_2.csv &gt;&gt; twitter_1.csv</span></pre><p id="4bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看看它的大小，<code class="fe ml mm mn mo b">imdb_review_1.csv</code>现在有大约5 MB的内存，是以前数据的两倍。如果我们键入<code class="fe ml mm mn mo b">dvc status</code>命令，您会看到一个通知，告知我们的<code class="fe ml mm mn mo b">imdb_review_1.csv</code>数据已被修改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/5bece7638c54ccfc74b6ee08309bcb25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0a1kC-2_g8CWaBNlnG6QCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="6a16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们用DVC跟踪修改后的数据。和以前一样，我们使用<code class="fe ml mm mn mo b">dvc add</code>命令来实现这个目的。</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="692f" class="ny mx it mo b gy nz oa l ob oc">$ dvc add twitter_1.csv twitter_2.csv</span></pre><p id="a50e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们用<code class="fe ml mm mn mo b">push</code>命令将修改后的文件推送到远程存储器。</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="9cf3" class="ny mx it mo b gy nz oa l ob oc">$ dvc push</span></pre><p id="d293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该会看到你的Google Drive上多了一个文件夹，而不是两个。这是因为只有<code class="fe ml mm mn mo b">twitter_1.csv</code>被修改，而<code class="fe ml mm mn mo b">twitter_2.csv</code>保持不变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/1545b781d55a5858bf8403a576523162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36LBvw32UKnTWG9zB7Q6_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="1023" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ml mm mn mo b">dvc add</code>命令之后，可能会发生两件事:</p><ul class=""><li id="ec07" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">如果我们添加/跟踪一个新文件(或者在我们的例子中是一个新的CSV文件)，那么对应于这个新文件的一个新的<code class="fe ml mm mn mo b">.dvc</code>指针文件将被创建</li><li id="e66d" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如果我们添加/跟踪一个现有文件，但其内容已被修改，那么其现有的<code class="fe ml mm mn mo b">.dvc</code>指针文件也将被修改，而不会创建新的文件</li></ul><p id="4b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们只修改了<code class="fe ml mm mn mo b">twitter_1.csv</code>，那么它的<code class="fe ml mm mn mo b">.dvc</code>文件也会被修改，而<code class="fe ml mm mn mo b">twitter_2.csv</code>的<code class="fe ml mm mn mo b">.dvc</code>文件保持不变。Git会自动识别修改后的<code class="fe ml mm mn mo b">.dvc</code>文件，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/83a0d481b0882a7a74db1630380757f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kxx6LDZDlaNmxHJ3j5Bxaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="ee72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要再次用Git跟踪更新后的文件，提交它，然后在提交时添加一个有意义的标记，如下所示:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="81ec" class="ny mx it mo b gy nz oa l ob oc">$ git add twitter_1.csv.dvc<br/>$ git commit -m "Dataset V2.0"<br/>$ git tag v2.0</span></pre><p id="3ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们数据的第二个版本。以下是我们在拥有两个版本的数据后目前所拥有的数据的图示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/044952bbe66be642ad7fe3b37b205f7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UGM46M1lKj3u_KbwYpAIw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="c67b" class="ny mx it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">切换不同版本的数据</h2><p id="ede6" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在，假设我们想要恢复到数据的第一个版本。我们可以通过输入<code class="fe ml mm mn mo b">git checkout &lt;tag&gt;</code>命令来完成。</p><p id="336f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前在第一次提交时，我们将标签<code class="fe ml mm mn mo b">v1.0</code>包含在提交中。因此，我们可以使用以下命令获取数据的第一个版本:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="f5ba" class="ny mx it mo b gy nz oa l ob oc">$ git checkout v1.0<br/>$ dvc pull</span></pre><p id="c22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行完<code class="fe ml mm mn mo b">dvc pull</code>命令后，您会注意到我们的<code class="fe ml mm mn mo b">twitter_1.csv</code>数据集不再有5 MB的内存。相反，它有2,5 MB的内存，就像它在开始时一样。</p><p id="60bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们已经成功地将数据集恢复到了以前的版本。使用同样的方法，您可以通过以下方式恢复到数据集的较新版本(即添加<code class="fe ml mm mn mo b">twitter_2.csv</code>后的<code class="fe ml mm mn mo b">twitter_1.csv</code>):</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="d16c" class="ny mx it mo b gy nz oa l ob oc">$ git checkout v2.0<br/>$ dvc pull</span></pre><p id="cdd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您只想获取特定版本中的特定数据，例如<code class="fe ml mm mn mo b">twitter_1.csv</code>1.0版，但仍想将<code class="fe ml mm mn mo b">twitter_2.csv</code>保留在2.0版中，您可以在<code class="fe ml mm mn mo b">dvc pull</code>命令中添加您想要获取的数据的规格，如下所示:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="2f2a" class="ny mx it mo b gy nz oa l ob oc">$ git checkout v1.0<br/>$ dvc pull twitter_1.csv</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="bf4e" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">模型版本控制</h1><p id="4e11" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">同样的概念也可以应用于ML模型的版本化。为了演示如何做到这一点，我们将使用一个ML模型来预测一条推文的情绪:这条推文是正面情绪还是负面情绪。我们的数据集将是我们在上一节中使用的<code class="fe ml mm mn mo b">twitter_1.csv</code>。</p><p id="fca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步，还是在我们的<code class="fe ml mm mn mo b">dvc-project</code>文件夹中，让我们通过下面的命令下载源代码:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="e482" class="ny mx it mo b gy nz oa l ob oc">$ dvc get-url <a class="ae ky" href="https://dagshub.com/marcellusruben/twitter_data/raw/00d21f134ed9449ab55d732dd8030a45284142df/train_evaluate.py" rel="noopener ugc nofollow" target="_blank">https://dagshub.com/marcellusruben/twitter_data/raw/00d21f134ed9449ab55d732dd8030a45284142df/train_evaluate.py</a></span></pre><p id="68a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe ml mm mn mo b">train_and_evaluate.py</code>脚本执行以下操作:</p><ul class=""><li id="b1ec" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">使用所选数据集训练模型，在我们的例子中，这将是<code class="fe ml mm mn mo b">twitter_1.csv</code></li><li id="acee" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将训练期间每个历元的精度值记录到名为<code class="fe ml mm mn mo b">history.json</code>的JSON文件中</li><li id="fd4e" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将训练好的模型保存为<code class="fe ml mm mn mo b">.h5</code>格式</li><li id="8a83" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在测试集上评估训练模型的准确性，并将准确性结果写入名为<code class="fe ml mm mn mo b">evaluation.json</code>的JSON文件中</li></ul><p id="f51e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保您能够运行脚本，pip安装以下要求:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="4a20" class="ny mx it mo b gy nz oa l ob oc">nltk==3.6.5<br/>numpy==1.23.3<br/>pandas==1.3.4<br/>PyYAML==6.0<br/>scikit_learn==1.1.1<br/>tensorflow==2.9.1</span></pre><p id="4ab6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还应该通过复制以下命令下载一个名为<code class="fe ml mm mn mo b">params.yaml</code>的YAML文件:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="39cb" class="ny mx it mo b gy nz oa l ob oc">$ dvc get-url <a class="ae ky" href="https://dagshub.com/marcellusruben/twitter_data/raw/7a6f7a4c6cf1506a22780c15b207c280c69c59ac/params.yaml" rel="noopener ugc nofollow" target="_blank">https://dagshub.com/marcellusruben/imdb-data/raw/3420f431a91b8bd7dc8952302338873af2d6e733/params.yaml</a></span></pre><p id="4d61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件包含我们可以调整的ML模型的一个超参数值，即LSTM层数。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="e341" class="ny mx it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">模型的第一个版本</h2><p id="cbbe" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">对于模型的第一个版本，我们将使用<code class="fe ml mm mn mo b">params.yaml</code>中的默认超参数值训练模型，其中LSTM的输出层设置为16。</p><p id="b590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有一个脚本，它将一些东西作为输入，然后输出结果，那么我们可以使用<code class="fe ml mm mn mo b">dvc run</code>命令从DVC自动捕获:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="daaf" class="ny mx it mo b gy nz oa l ob oc">$ dvc run -n train-and-evaluate -d train_evaluate.py -p train.lstm_out -o model.h5 --plots-no-cache history.json -M evaluation.json python train_evaluate.py twitter_1.csv</span></pre><p id="68df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的命令中有很多参数，所以让我们逐个分析它们:</p><ul class=""><li id="ab5f" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ml mm mn mo b">-n</code>:给我们的管道起一个合适的名字，这样当我们想要重现结果或者以后改变什么的时候就可以很容易地调用它。在上面的例子中，我们称我们的管道为<code class="fe ml mm mn mo b">train-and-evaluate</code></li><li id="8b33" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">-d</code>:告诉DVC我们的管道<code class="fe ml mm mn mo b">train-and-evaluate</code>依赖于哪个文件。在上面的例子中，我们的管道依赖于我们的<code class="fe ml mm mn mo b">train_evaluate.py</code>脚本。</li><li id="22e5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">-p</code>:指定<code class="fe ml mm mn mo b">path</code>中参数文件的参数依赖关系。默认情况下，它会查看<code class="fe ml mm mn mo b">params.yaml</code>中的参数。在我们的例子中，这将是我们之前下载的<code class="fe ml mm mn mo b">params.yaml</code>中LSTM图层的数量。</li><li id="6e01" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">-o</code>:告诉DVC自动跟踪运行脚本后的输出。我们的<code class="fe ml mm mn mo b">train-evaluate.py</code>脚本将生成一个名为<code class="fe ml mm mn mo b">model.h5</code>的经过训练的模型。这类似于我们在上一节中看到的独立的<code class="fe ml mm mn mo b">dvc add</code>命令</li><li id="9cf1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">-M</code>:指定一个度量文件，这样我们可以在测试集上用<code class="fe ml mm mn mo b">dvc metrics</code>评估和比较模型性能。因为我们的脚本生成了一个名为<code class="fe ml mm mn mo b">evaluation.json</code>的度量文件，所以我们可以使用这个命令</li><li id="b4fa" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ml mm mn mo b">--plots-no-cache</code>:指定一个绘图文件，以便我们稍后可以用<code class="fe ml mm mn mo b">dvc plots</code>创建或比较一些可视化。我们的脚本在名为<code class="fe ml mm mn mo b">history.json</code>的文件中生成训练期间每个时期的模型精度，因此我们可以使用这个命令</li><li id="4fc7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">告诉DVC运行管道</li></ul><p id="f0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们用上面的<code class="fe ml mm mn mo b">dvc run</code>命令运行脚本后，您会看到一个名为<code class="fe ml mm mn mo b">dvc.yaml</code>的新的重要文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/d164acc904e4490ca0ae23f0ed7d4011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcWfjVolZfwQ4hZ9LjKZOg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cc10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个文件为我们提供了关于<code class="fe ml mm mn mo b">train-and-evaluate</code>管道的必要信息:它依赖于哪个脚本，它将生成和跟踪哪个输出文件，哪个文件将作为度量或绘图，等等。</p><p id="dedf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe ml mm mn mo b">dvc.yaml</code>，还有一个叫做<code class="fe ml mm mn mo b">dvc.lock</code>的附加文件，看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/8a7a17e92a611261dc088125cd0909ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*74n4UwMyRHocd6MW1-NMxQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fe58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ml mm mn mo b">dvc.lock</code>文件允许DVC跟踪依赖值的变化，即与我们之前的运行相比，我们是否改变了<code class="fe ml mm mn mo b">params.yaml</code>中的超参数值。它还跟踪特定DVC管道的每个输出文件的哈希。</p><p id="d77b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们想在测试集上评估训练模型的性能，我们可以使用<code class="fe ml mm mn mo b">dvc metrics</code>命令，如下所示:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="5784" class="ny mx it mo b gy nz oa l ob oc">$ dvc metrics show</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d80538e9cc1c2145a5e272701f39cc28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1k7cWW31tXdmUURkxecuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b8bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以可视化我们模型的训练历史。首先我们需要告诉DVC哪个变量会在<strong class="lb iu"><em class="lv"/></strong>轴和<strong class="lb iu"><em class="lv"/></strong>轴。在<code class="fe ml mm mn mo b">history.json</code>里面，我们有两个变量:<em class="lv">精度</em>和<em class="lv">历元</em>。我们将使用x轴<strong class="lb iu"><em class="lv"/></strong>中的<em class="lv">历元</em>和y轴 中的<em class="lv">精度</em>。最后，我们用<code class="fe ml mm mn mo b">dvc plot</code>来可视化剧情。</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="150d" class="ny mx it mo b gy nz oa l ob oc">$ dvc plots modify history.json -x epochs -y accuracy<br/>$ dvc plots show</span></pre><p id="f03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该命令之后，您应该会看到一个链接，在该链接中您可以在浏览器中看到可视化效果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/d6bc186c08f5abed2dbe53129e35aebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBOCDk0uDLEqxdMvuLt6Eg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="2c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们将自动跟踪的<code class="fe ml mm mn mo b">model.h5</code>推入我们的Google Drive，用Git跟踪所有其他文件(<code class="fe ml mm mn mo b">dvc.yaml</code>、<code class="fe ml mm mn mo b">evaluation.json</code>、<code class="fe ml mm mn mo b">history.json</code>、<code class="fe ml mm mn mo b">train_evaluate.py</code>、<code class="fe ml mm mn mo b">dvc.lock</code>)，然后提交它们:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="3257" class="ny mx it mo b gy nz oa l ob oc">$ dvc push<br/>$ git add .<br/>$ git commit -m "data_model_v1"<br/>$ git tag data_model_v1</span></pre><p id="b093" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们模型的第一个版本！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="cdfa" class="ny mx it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">模型的第二个版本</h2><p id="0835" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">假设我们想做另一个实验，看看如果我们将<code class="fe ml mm mn mo b">params.yaml</code>中的LSTM层从16层改为2层，模型的性能是否会提高。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/685a2b60cd3f928018e6fbd6d1fb025d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tchUWaZAdwJ3Y99TuJLRSw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="58e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以通过使用<code class="fe ml mm mn mo b">dvc repro</code>命令调用<code class="fe ml mm mn mo b">train-and-evaluate</code>管道，用新的超参数值重新训练我们的模型:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="cca2" class="ny mx it mo b gy nz oa l ob oc">$ dvc repro train-and-evaluate</span></pre><p id="253c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">脚本运行完成后，我们将更新的<code class="fe ml mm mn mo b">model.h5</code>推送到我们的Google Drive，用Git跟踪其他更新的文件(<code class="fe ml mm mn mo b">dvc.yaml</code>、<code class="fe ml mm mn mo b">evaluation.json</code>、<code class="fe ml mm mn mo b">history.json</code>、<code class="fe ml mm mn mo b">train_evaluate.py</code>、<code class="fe ml mm mn mo b">dvc.lock</code>)，然后提交它们:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="06cc" class="ny mx it mo b gy nz oa l ob oc">$ dvc push<br/>$ git add .<br/>$ git commit -m "data_and_model_v2"<br/>$ git tag data_model_v2</span></pre><p id="6e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就结束了模型的第二个版本！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="a95b" class="ny mx it bd my oe of dn nc og oh dp ng li oi oj ni lm ok ol nk lq om on nm oo bi translated">切换不同版本的模型</h2><p id="3bda" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">现在有趣的部分是，我们可以在使用DVC的提交之间比较不同版本的ML模型的性能。为此，我们可以使用以下命令:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="053e" class="ny mx it mo b gy nz oa l ob oc">$ dvc metrics diff [tag commit 1] [tag commit 2]<br/>$ dvc metrics diff data_model_v2 data_model_v1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/748e2caa35fd04b510177d3f091058de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbyIlnWAdyk1xwtZxy-Spw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="e526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以使用以下命令比较提交之间不同版本模型的培训历史的可视化:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="9510" class="ny mx it mo b gy nz oa l ob oc">$ dvc plots diff [tag commit 1] [tag commit 2]<br/>$ dvc plots diff data_model_v2 data_model_v1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/24b5469885da4e46f6f901e4d848f02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3N51NZhA1h9mSIT_XdOnkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="9aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们以前的模型在训练集和测试集上都有更好的准确性。因此，我们想回到以前的版本是合乎逻辑的。正如你已经知道的，我们可以用<code class="fe ml mm mn mo b">git checkout</code>和<code class="fe ml mm mn mo b">dvc pull command</code>来做这件事。</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="dccd" class="ny mx it mo b gy nz oa l ob oc">$ git checkout data_model_v1<br/>$ dvc pull</span></pre><p id="65c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保我们真的回到了之前的版本，让我们再次运行<code class="fe ml mm mn mo b">dvc metrics</code>:</p><pre class="kj kk kl km gt nu mo nv nw aw nx bi"><span id="c6d4" class="ny mx it mo b gy nz oa l ob oc">$ dvc metrics show</span></pre><p id="defa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会看到我们的模型的性能与我们的第一个模型相同，在我的例子中是89.1%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/86b9f98eac9fc28e3e0e06565a8c56fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*As5MkGSaf5V051eUXHkbZg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="dcc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你打开<code class="fe ml mm mn mo b">params.yml</code>，你还会看到LSTM层输出的值转换回16，这是我们的默认设置，也是我们第一个模型被训练的超参数值。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="c2d6" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="c787" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在本文中，我们看到了DVC如何以多种方式帮助我们组织数据科学项目:</p><ul class=""><li id="0acc" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">DVC将我们的数据科学项目与Git无缝集成。它也有和Git相似的语法，因此如果你已经知道Git，学习曲线不会太陡</li><li id="3530" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">DVC使用亚马逊S3、Azure、谷歌云、谷歌驱动、HDFS等流行的存储服务来存储不同版本的数据和模型</li><li id="64fe" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">DVC加强了可再现性，因为我们可以轻松地重新运行具有特定相关性的流水线，并再现结果，而无需考虑使用哪个数据、超参数值或代码版本。</li><li id="fbcb" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">DVC让我们很容易与其他团队成员分享我们项目的进展</li></ul><p id="1c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以自己探索DVC的更多功能，我希望这篇文章对你开始使用DVC有所帮助！</p></div></div>    
</body>
</html>