<html>
<head>
<title>A Simple Multiprocessing Framework Within Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中一个简单的多重处理框架</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-simple-multiprocessing-framework-within-python-9497bdf9b42b#2022-06-23">https://towardsdatascience.com/a-simple-multiprocessing-framework-within-python-9497bdf9b42b#2022-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c4d9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用多重处理并不复杂</h2></div><p id="5ac4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">Python中的基本多重处理类非常有用。如果您曾经需要作业运行得更快，也许您已经尝试了矢量化，并且已经测试了多种方法来提高速度，但您仍然等待了太长时间，请继续阅读。多处理您的工作负载有许多优势。但是警告，多重处理并不总是更快——你需要正确的用例来提高速度。不要担心，我有一个简单的解决方案，使利用多处理更容易。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/8fb65df77de88a5b5356975482352d1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QtKgbHT8ENaOa-kO"/></div></div><p class="lz ma gj gh gi mb mc bd b be z dk translated">由<a class="ae md" href="https://unsplash.com/@unarchive?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰里米·贝赞格</a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e7bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python中的基本多处理模块很棒，但是我发现扩展多处理包(在多处理功能的基础上有所改进)更容易，更不容易出错。下面是如何将它安装到您的环境中(您还将看到tqdm，这是我们将用来跟踪作业之间进度的包)。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="9f4f" class="mj mk it mf b gy ml mm l mn mo">pip install tqdm multiprocess</span></pre><p id="66ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae md" href="https://pypi.org/project/tqdm/" rel="noopener ugc nofollow" target="_blank"> tqdm文档</a>和<a class="ae md" href="https://pypi.org/project/multiprocess/" rel="noopener ugc nofollow" target="_blank">多进程文档</a>的链接。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="e194" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我不喜欢让你等太久才看到代码，这里是我们将要讨论的代码。</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="04c2" class="mj mk it mf b gy ml mm l mn mo">from tqdm import tqdm<br/>from multiprocess import Pool</span><span id="830e" class="mj mk it mf b gy mw mm l mn mo">def lite_multi_process(any_function, all_events: list, n_jobs=1):<br/>    num_events, results = len(all_events), list()<br/>    with Pool(n_jobs) as pool:<br/>        with tqdm(total=num_events) as progress:<br/>            for result in pool.imap_unordered(any_function, all_events):<br/>                results.append(result); progress.update()<br/>    pool.close(); pool.join()<br/>    return results</span></pre></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h2 id="ef12" class="mj mk it bd mx my mz dn na nb nc dp nd kr ne nf ng kv nh ni nj kz nk nl nm nn bi translated">lite_multi_process简介</h2><p id="524a" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">在我看来，这个函数胜过所有其他的多重处理函数。它接收任何函数、所有事件(作为一个可以迭代的对象，比如一个列表)，以及您希望并发运行的作业数量。</p><p id="28ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您需要从PC或笔记本电脑上的数据库(例如SQL Server)中查询一组特定的数据。您的函数查询数据，通过一系列操作处理数据，并将结果保存到另一个位置(顺便说一句:如果您想使用AWS存储，如S3，这可能是使用AWS SQS和AWS Lambda过程的正确时机)。为了一个例子，我们将继续。</p><p id="e1d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于事件列表，我建议您的列表包含键值对字典，即每个作业的唯一信息，如下所示:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="b5ed" class="mj mk it mf b gy ml mm l mn mo">{<br/>    'query_id': 1,<br/>    'sql_statement': '''SELECT * FROM table_name'''<br/>}</span></pre><p id="b1e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的函数可能如下所示(当然，带有用于查询、处理和保存的代码):</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="d240" class="mj mk it mf b gy ml mm l mn mo">def my_function(event):<br/><br/>    query_id = event.get('query_id')<br/>    sql_statement = event.get('sql_statement')<br/>    <br/>    # query<br/>    <br/>    # process<br/>    <br/>    # save<br/>    <br/>    return status</span></pre><p id="0291" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">8个作业同时运行时使用lite_multi_process函数的方法如下:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="2a24" class="mj mk it mf b gy ml mm l mn mo">results = lite_multi_process(my_function, my_events, n_jobs=8)</span></pre><p id="dc61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超级简单对吧？</p><p id="3e44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，假设您的函数没有以返回状态结束(因为您不会对状态的结果集做任何事情)，而是返回了您需要连接并保存到AWS S3的Pandas数据帧。这是它看起来的样子:</p><pre class="lo lp lq lr gt me mf mg mh aw mi bi"><span id="3638" class="mj mk it mf b gy ml mm l mn mo">results = lite_multi_process(my_function, my_events, n_jobs=8)<br/>data = pd.concat(results)</span></pre><p id="38bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说一遍，小菜一碟。您的结果包含一个迷你数据框架列表。您需要执行的只是一个连接操作。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="405b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后要提的一块，也是我这么喜欢这个流的另一个原因，这个函数很容易调试。简单设置n_jobs=1，调试，继续。通常，用更复杂的多处理引擎进行调试是一件非常麻烦的事情。</p><h2 id="5228" class="mj mk it bd mx my mz dn na nb nc dp nd kr ne nf ng kv nh ni nj kz nk nl nm nn bi translated">最后的话</h2><p id="8723" class="pw-post-body-paragraph ki kj it kk b kl no ju kn ko np jx kq kr nq kt ku kv nr kx ky kz ns lb lc ld im bi translated">我们讨论了多重处理模块，在这种情况下，我们希望并发处理作业。lite_multi_process函数获取所有必要的信息，并返回结果列表。对结果做你想做的，继续前进。</p><p id="6345" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请在评论中告诉我你的想法。希望这能对你的工作流程有所帮助。</p></div></div>    
</body>
</html>