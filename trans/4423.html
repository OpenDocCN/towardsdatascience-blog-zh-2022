<html>
<head>
<title>Three Things to Know about Binary Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解二分搜索法的三件事</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/three-things-to-know-about-binary-search-cf3b00971c2c#2022-09-30">https://towardsdatascience.com/three-things-to-know-about-binary-search-cf3b00971c2c#2022-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">彻底揭开二分搜索法的神秘面纱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/85070b6246423e2959f828794dc2ec4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3ULfHKW71DJZ6tDd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">二分搜索法将列表分为两部分，然后只关注其中的一部分。照片由<a class="ae kv" href="https://unsplash.com/@thexclu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克鲁索</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5c49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从概念上讲，二分搜索法是一种非常容易理解的算法。然而，实现它是非常困难的，尤其是当你试图实现它的许多变种时。我的目标是让你明白如何很好地实施二分搜索法，这将是你需要的关于二分搜索法的最后一本指南。</p><p id="5379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几点:第一，这篇文章是长文。有时候，当我们解释事情的时候，我们倾向于跳过对每个人来说不明显的事情。其次，我使用Python编写代码。在Python中，数组中的第一个元素的索引是<code class="fe ls lt lu lv b">0</code>，数组中的最后一个元素的索引是<code class="fe ls lt lu lv b">len(array)-1</code>。阅读本指南后，你将能够适应1索引语言。另外，Python是一种动态类型语言。如果你使用像C++这样的静态语言，为<code class="fe ls lt lu lv b">lo</code>和<code class="fe ls lt lu lv b">hi</code>使用合适的数据类型。</p><p id="21ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感恩:我从<a class="ae kv" href="https://labuladong.gitbook.io/algo-en/iii.-algorithmic-thinking/detailedbinarysearch#fourth-unified-logic" rel="noopener ugc nofollow" target="_blank">拉布拉东二分搜索法教程</a>中学到了区间和退出条件的概念。这是我读过的关于面试算法的最好的公开指南。你在这里读到的一些东西是他思想的延伸。我认为他对寻找左右边界的解释太快了，所以我在本指南中花了相当大的篇幅来解释这个问题。</p><h1 id="59ea" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">概念审查</h1><p id="fa0d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">二分搜索法是一种分治算法。目标是在排序后的数组中找到一个目标值。它只能处理已排序的数据，通常是按升序排序的。该算法通过选择数组中的中间点，然后将数组分为三部分:小于中间点的部分、中间点和大于中间点的部分。有关解释，请参见图1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mt"><img src="../Images/d3ee5a307c96945c1f81faf8bfecb47b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FRTiL-LoYbdI9Yp77k6cWQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图一。二分搜索法算法的概念概述。假设所有元素都是唯一的。作者图。</p></figure><h1 id="0a68" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">人们为什么与二分搜索法斗争？</h1><p id="3dc8" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">从个人经验和阅读StackOverflow来看，实施二分搜索法的大部分问题似乎来自:</p><ul class=""><li id="af5f" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">越界-&gt;错误的间隔考虑</li><li id="0f41" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">目标存在但未找到-&gt;间隔之间的间隙</li><li id="7a9b" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">返回了错误的元素-&gt;没有考虑退出条件</li><li id="cb3e" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">第一个或最后一个元素的边界情况</li><li id="3f6a" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">整数溢出(在C++ 等静态类型语言中发现)</li></ul><p id="a099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你需要精通二分搜索法的实现，你需要理解为什么会发生这一切。<strong class="ky ir">理解</strong>有三个步骤:(1)区间，(2)分区，(3)退出条件。</p><h1 id="9c83" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">一:音程</h1><p id="454d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">首先，我们来复习一下音程的概念。结束间隔包括结束值，而开始间隔不包括。</p><ul class=""><li id="036c" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">间隔<code class="fe ls lt lu lv b">[1,5]</code>具有以下元素:<code class="fe ls lt lu lv b">1 2 3 4 5</code></li><li id="9535" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">间隔<code class="fe ls lt lu lv b">[1,5)</code>具有以下元素:<code class="fe ls lt lu lv b">1 2 3 4</code></li><li id="368d" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">间隔<code class="fe ls lt lu lv b">(1,5)</code>具有以下元素:<code class="fe ls lt lu lv b">2 3 4</code></li></ul><p id="7426" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑以下打印一组整数的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c2f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">循环的退出条件是<code class="fe ls lt lu lv b">lo &gt; hi</code>。当我们增加<code class="fe ls lt lu lv b">lo</code>直到<code class="fe ls lt lu lv b">lo = hi+1</code>时，它退出。这意味着该功能将打印出闭合区间<code class="fe ls lt lu lv b">[lo, hi]</code>内的所有值，包括lo和hi。</p><p id="2120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，考虑下面的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="9fba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该功能的退出条件是<code class="fe ls lt lu lv b">lo &gt;= hi</code>。当我们增加<code class="fe ls lt lu lv b">lo</code>直到<code class="fe ls lt lu lv b">lo == hi</code>的点时，它退出。这意味着该功能不会打印<code class="fe ls lt lu lv b">hi</code>。该功能打印出左开区间<code class="fe ls lt lu lv b">[lo, hi)</code>的所有值</p><p id="4f9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di">T</span>T28】ake away 1。如果我们想要一个两端封闭的区间<code class="fe ls lt lu lv b">[lo, hi]</code>，那么我们使用<code class="fe ls lt lu lv b">lo &lt;= hi</code>作为我们的循环条件。另一方面，如果我们想要一个左端开放区间<code class="fe ls lt lu lv b">[lo, hi)</code>，我们必须在循环条件中使用<code class="fe ls lt lu lv b">lo &lt; hi</code>。</p><p id="1244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们将它应用于遍历一个列表。在我们的封闭区间中，我们想要遍历范围<code class="fe ls lt lu lv b">[0, length(array) — 1]</code>中的所有元素，因此我们的遍历循环如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="f329" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想遍历一个左开区间，那么最后一个元素(不包括)应该是<code class="fe ls lt lu lv b"> length(array)</code>，我们的区间应该是<code class="fe ls lt lu lv b">[lo, length(array))</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的建议是，从现在开始，无论你什么时候实现二分搜索法，你都要使用封闭区间。不仅闭区间更容易理解，而且它还具有开区间所没有的对称性质。下面的函数说明了这一点，这些函数通过递减hi来向后遍历间隔。对称性使得封闭区间的反向版本成为可能，但开放区间版本则不可能。第一个功能覆盖<code class="fe ls lt lu lv b">[lo, hi]</code>，但是第二个功能覆盖<code class="fe ls lt lu lv b">(lo, hi]</code>而不是<code class="fe ls lt lu lv b">[lo, hi)</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="114a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">第二:隔板</h1><p id="1c60" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如果列表有不止一个元素，我们可以把它分成三个子列表。<code class="fe ls lt lu lv b">[lo, middle — 1]</code>是左边的子列表，<code class="fe ls lt lu lv b">[middle, middle]</code>是一个元素列表，<code class="fe ls lt lu lv b">[middle + 1, hi]</code>是右边的子列表。</p><p id="60fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di">T</span>T28】ake away 2。三个区间<code class="fe ls lt lu lv b">[lo, middle — 1]</code> <code class="fe ls lt lu lv b">[middle, middle]</code>和<code class="fe ls lt lu lv b">[middle + 1, hi]</code>不重叠，并且覆盖了整个闭合区间<code class="fe ls lt lu lv b">[lo, hi]</code>。这确保了列表中的所有元素都被考虑在内。</p><p id="492c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">区间的选择是很多人犯错的地方:</p><ul class=""><li id="1efb" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">为什么左音程在<code class="fe ls lt lu lv b">middle-1</code>结束？因为记住这些都是闭区间(含闭区间)。<code class="fe ls lt lu lv b">[lo, middle-1]</code>表示该区间也有元素<code class="fe ls lt lu lv b">middle-1</code>。如果我们使用区间<code class="fe ls lt lu lv b">[lo, middle]</code>，那么我们的区间将与<code class="fe ls lt lu lv b">[middle, middle]</code>元素重叠，这是我们不想要的。<code class="fe ls lt lu lv b">[middle+1, hi]</code>的逻辑相同。</li></ul><p id="718a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用我选择的三个封闭区间来实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b2fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们退出while循环，因为<code class="fe ls lt lu lv b">lo &gt; hi</code>，这表明我们在数组中找不到目标。它返回<code class="fe ls lt lu lv b">None</code>。</p><p id="defa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di">T</span>T32】ake away 3。使用<code class="fe ls lt lu lv b">mid = lo + (hi — lo)//2</code>。当你用其他语言实现二分搜索法时，用这个代替<code class="fe ls lt lu lv b">mid = (hi+lo)//2</code>。这是因为<code class="fe ls lt lu lv b">hi+lo</code>可以溢出(<a class="ae kv" href="https://www.algorist.com/" rel="noopener ugc nofollow" target="_blank">斯基亚纳的书</a>是我第一次了解到这个的地方)。</p><p id="8a5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想在区间<code class="fe ls lt lu lv b">[lo, hi)</code>上搜索，而不是在封闭区间<code class="fe ls lt lu lv b">[lo, hi]</code>上搜索呢？我们仍然可以对数组进行分区，但是我们的所有分区(除了中间的分区)都必须有右开区间。这是因为我们已经使二分搜索法适应右开音程，所以它接收的应该是右开的。回想一下，我们的起始条件应该是<code class="fe ls lt lu lv b">[0, length(array))</code>，因为<code class="fe ls lt lu lv b">length(array)</code>不包含在区间内。</p><p id="ad27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想要的分区是<code class="fe ls lt lu lv b">[lo, mid)</code>和<code class="fe ls lt lu lv b">[mid+1, hi)</code>。</p><ul class=""><li id="ddca" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">为什么左音程在<code class="fe ls lt lu lv b">mid</code>结束？因为这个区间是<code class="fe ls lt lu lv b">[lo, mid)</code>所以它不包括<code class="fe ls lt lu lv b">mid</code>元素。因此它不与<code class="fe ls lt lu lv b">[mid, mid]</code>区间重叠。自己确认它们没有重叠，并且仍然覆盖整个右开区间<code class="fe ls lt lu lv b">[lo, hi)</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="bcc1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">三:退出条件</h1><p id="d0e4" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">在我们的封闭区间例子中，如果目标不在数组中，那么最终<code class="fe ls lt lu lv b">lo &gt; hi</code>和while循环退出。但是在这些情况下<code class="fe ls lt lu lv b">lo</code>和<code class="fe ls lt lu lv b">hi</code>指针在哪里呢？</p><p id="f119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的排序数组<code class="fe ls lt lu lv b">[0 1 2 3 4 5]</code>和三种情况的<code class="fe ls lt lu lv b">target</code>:</p><ul class=""><li id="673e" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">目标= -2</li><li id="3f2c" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">目标= 10</li><li id="b912" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">目标= 3.5</li></ul><p id="eb90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们退出循环，这里就是<code class="fe ls lt lu lv b">lo</code>和<code class="fe ls lt lu lv b">hi</code>指针所在的位置(注意在所有这些情况下都是<code class="fe ls lt lu lv b">lo &gt; hi</code>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4e10b31d56c154ed00e7eba08da2facb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*KDIGRQa34X5wnr8m42smjw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图二。作者图</p></figure><p id="234d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi nk translated"><span class="l nl nm nn bm no np nq nr ns di">T</span>T30】ake away 4。如果<code class="fe ls lt lu lv b">target</code>在<code class="fe ls lt lu lv b">array</code>中不存在，那么<code class="fe ls lt lu lv b">lo</code>显示的是<strong class="ky ir">目标在数组</strong>中的索引。对此的解释相当简单:</p><ul class=""><li id="2616" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">在第一种情况下，我们只更新<code class="fe ls lt lu lv b">hi</code>的值，因为<code class="fe ls lt lu lv b">nums[mid] &gt; target</code>在while循环的每次迭代中。这意味着<code class="fe ls lt lu lv b">lo</code>停留在<code class="fe ls lt lu lv b">0</code>直到我们退出。因为新元素比所有其他元素都小，所以我们将它插入位置<code class="fe ls lt lu lv b">0</code>。</li><li id="e155" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">在第二种情况下，我们只更新<code class="fe ls lt lu lv b">lo</code>的值，因为在while循环的每次迭代中<code class="fe ls lt lu lv b">nums[mid] &lt; target</code>。当<code class="fe ls lt lu lv b">lo &gt; hi</code>或<code class="fe ls lt lu lv b">lo == hi + 1</code>时，回路存在。因为<code class="fe ls lt lu lv b">hi</code>指针不改变值，我们在<code class="fe ls lt lu lv b">lo == length(array)</code>时退出循环。因为新元素比其他所有元素都大，所以我们将它插入到位置<code class="fe ls lt lu lv b">length(array)</code>。(<code class="fe ls lt lu lv b">array</code>指原数组)</li><li id="399a" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">在第三种情况下，由于target不存在，我们将列表分成两部分:小于<code class="fe ls lt lu lv b">target</code>的列表和大于<code class="fe ls lt lu lv b">target</code>的列表。当循环退出时，<code class="fe ls lt lu lv b">lo</code>标志着第二部分的开始。当我们插入目标元素时，它将获取<code class="fe ls lt lu lv b">lo</code>所指向的索引。</li></ul><p id="0b4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不熟悉，这可能很难得到，所以一步一步地自己看几个例子。调试工具可以帮助您在循环的不同迭代中查看<code class="fe ls lt lu lv b">lo</code>和<code class="fe ls lt lu lv b">hi</code>的值。另一种思考方式是<code class="fe ls lt lu lv b">lo</code>指针索引显示<strong class="ky ir">有多少元素严格小于目标</strong>。在第一个例子中，有一个比<code class="fe ls lt lu lv b">-2</code>小的<code class="fe ls lt lu lv b">0</code>元素。在第二个例子中，有比<code class="fe ls lt lu lv b">10</code>小的<code class="fe ls lt lu lv b">6</code>元素。在第三个例子中，有比<code class="fe ls lt lu lv b">3.5</code>小的<code class="fe ls lt lu lv b">4</code>元素。</p><p id="b2a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为什么要做这些？因为我想告诉你如何修改二分搜索法算法来完成许多其他任务，每个任务都建立在前一个任务的基础上。相信我，一切都是值得的。</p><h1 id="4d0a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">二分搜索法的变体</h1><h2 id="667c" class="nu lx iq bd ly nv nw dn mc nx ny dp mg lf nz oa mi lj ob oc mk ln od oe mm of bi translated">任务1。找出比目标值小的元素数</h2><p id="dc4d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们之前的观察是一个很好的起点。当我们退出循环时，我们返回<code class="fe ls lt lu lv b">lo</code>而不是<code class="fe ls lt lu lv b">None</code>。但是，当我们在数组中找到<code class="fe ls lt lu lv b">target</code>时，我们该怎么办呢？我们知道，如果目标不存在于数组中，那么函数将退出，并且<code class="fe ls lt lu lv b">lo</code>指向解。换句话说，如果<code class="fe ls lt lu lv b">array[mid] == target</code>没有被调用，那么函数将退出，并且<code class="fe ls lt lu lv b">lo</code>指向解决方案。我们可以修改前面的函数，这样当<code class="fe ls lt lu lv b">array[mid] == target</code>不返回<code class="fe ls lt lu lv b">mid</code>时，我们更新<code class="fe ls lt lu lv b">lo</code>或者<code class="fe ls lt lu lv b">hi</code>指针。</p><p id="1ea9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们更新哪个指针呢？这取决于我们想在哪里搜索。如果我们找到一个等于<code class="fe ls lt lu lv b">target</code>的值，并且我们想知道有多少个元素更小，那么专门在较低的分区中搜索是有意义的。因此，我们希望更新hi指针，将搜索区间缩小到<code class="fe ls lt lu lv b">[lo, mid-1]</code>。</p><p id="7764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们的解决方案。注意第8行是我们修改的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="4f91" class="nu lx iq bd ly nv nw dn mc nx ny dp mg lf nz oa mi lj ob oc mk ln od oe mm of bi translated">任务2。找到目标的第一次出现</h2><p id="8a67" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">想象一下，如果我们的排序列表没有唯一的元素。我们的任务是找到第一次出现的<code class="fe ls lt lu lv b">target</code>。我们不能使用常规的二分搜索法，因为它不能保证我们将返回正确的索引。</p><p id="8ac4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个任务和任务1很像(原因就看你自己了)。事实上，任务1的解决方案在大多数情况下都适用。唯一的问题是当元素在数组的边缘或者<code class="fe ls lt lu lv b">target</code>不在数组中的时候。请记住，任务1的解决方案返回数组中小于目标的元素数，因此结果可以是从<code class="fe ls lt lu lv b">0</code>到<code class="fe ls lt lu lv b">length(array)</code>的任意值。</p><ul class=""><li id="2f86" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">如果当<code class="fe ls lt lu lv b">lo == len(array)</code>时while循环存在，那么我们知道所有元素都小于target。我们可以返回<code class="fe ls lt lu lv b">-1</code>,因为目标不存在</li><li id="88d2" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">否则，<code class="fe ls lt lu lv b">lo</code>指向大于或等于target的第一个元素(仔细阅读)。该元素可以是<code class="fe ls lt lu lv b">lo</code>或大于<code class="fe ls lt lu lv b">lo</code>。我们简单地检查一下<code class="fe ls lt lu lv b">array[lo] == target</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="29f0" class="nu lx iq bd ly nv nw dn mc nx ny dp mg lf nz oa mi lj ob oc mk ln od oe mm of bi translated">任务三。找到目标的最后一次出现</h2><p id="94fc" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">我们能反过来吗？是的，我们可以感谢闭区间的<strong class="ky ir">对称性(这是我在编码二分搜索法时推荐闭区间的另一个原因)。我们需要修改以下内容:</strong></p><ul class=""><li id="1152" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">当<code class="fe ls lt lu lv b">array[mid] == target</code>时，我们现在更新lo指针，这样我们就可以专注于闭合区间<code class="fe ls lt lu lv b">[mid+1, hi]</code></li><li id="21c9" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">我们返回<code class="fe ls lt lu lv b">hi</code>的值。该值的范围从<code class="fe ls lt lu lv b">-1</code>到<code class="fe ls lt lu lv b">length(array)-1</code>(返回图2查看<code class="fe ls lt lu lv b">hi</code>的范围)。如果<code class="fe ls lt lu lv b">hi == -1</code>，那么所有元素都大于目标，所以我们返回<code class="fe ls lt lu lv b">None</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="21ca" class="nu lx iq bd ly nv nw dn mc nx ny dp mg lf nz oa mi lj ob oc mk ln od oe mm of bi translated">任务4。第一缺陷元素</h2><p id="d3e7" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">给定两个数组，一个充满缺陷元素(表示为“F”)，一个充满正常元素(表示为“T”)。不知道两个数组是否都非空。我们将两个数组连接在一起，这样得到的数组如下所示:</p><p id="959d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">[T T T T T T F F F F F F F F F F F]</code></p><p id="a09b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的任务是找出正常元素的数量。要了解二分搜索法如何提供帮助，请考虑一个只有两个唯一数字1和2的数组:</p><p id="b493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">[1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2]</code></p><p id="ee2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显而易见，我们可以使用函数<code class="fe ls lt lu lv b">elements_less_than</code>来查找数组中1的数量。现在，假设我们所有的输入都是由数字1和2以这种方式排列而成的。我们可以通过删除不必要的代码来修改函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ca2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意两个变化:</p><ul class=""><li id="fe21" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">我们删除<code class="fe ls lt lu lv b">array[mid] &gt; target</code>分支条件。之所以不需要，是因为数组只有1和2，所以我们没有大于2的元素。</li><li id="1a05" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">我们将<code class="fe ls lt lu lv b">array[mid] &lt; target</code>改为<code class="fe ls lt lu lv b">array[mid] == 1</code>。这是因为元素小于2的唯一方式是它等于1。</li></ul><p id="c213" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地用T和F代替1和2就得到我们的解。另一种思考方式是，当我们找到T时，我们需要更新对上层分区的搜索，反之亦然。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="c6d7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">外卖食品</h1><ol class=""><li id="3d92" class="mu mv iq ky b kz mo lc mp lf og lj oh ln oi lr oj na nb nc bi translated">这是我推荐的二分搜索法框架。它使用封闭区间<code class="fe ls lt lu lv b">[0, length(array) — 1]</code>。记住三个分区<code class="fe ls lt lu lv b">[lo, mid-1]</code>、<code class="fe ls lt lu lv b">[mid, mid]</code>和<code class="fe ls lt lu lv b">[mid+1, hi]</code>。如果要使用open interval <code class="fe ls lt lu lv b">[0, length(array))</code>，记得正确分区即可。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8da5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.现在，您可以通过考虑以下四点来调试任何二分搜索法代码:</p><ul class=""><li id="2385" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">间隔是多少？</li><li id="e0be" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">分区重叠并覆盖整个阵列吗？</li><li id="81db" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">当循环退出时，<code class="fe ls lt lu lv b">lo</code>和<code class="fe ls lt lu lv b">hi</code>的位置在哪里？</li><li id="4410" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">如果目标位于边缘会发生什么？</li></ul><p id="e9a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编码快乐！</p><p id="33dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是一些训练问题:</p><div class="ok ol gp gr om on"><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">查找大于目标的最小字母- LeetCode</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">给定一个按非降序排序的字符数组字母和一个字符目标，返回最小的…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">leetcode.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kp on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://leetcode.com/problems/sqrtx/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">Sqrt(x) - LeetCode</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">给定一个非负整数x，计算并返回x的平方根。因为返回类型是整数，所以…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">leetcode.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb kp on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">在旋转排序数组中查找最小值- LeetCode</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">假设按升序排序的长度为n的数组被旋转1到n次。例如，数组nums =…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">leetcode.com</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb kp on"/></div></div></a></div></div></div>    
</body>
</html>