<html>
<head>
<title>Algorithms Explained #3: Searching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法解释#3:搜索</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithms-explained-3-searching-84604e465838#2022-10-11">https://towardsdatascience.com/algorithms-explained-3-searching-84604e465838#2022-10-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5678" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过Python中的线性和二分搜索法示例了解搜索</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8203ac1a48177252cf07b3c8700dff22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-UqvhSgYvv04nboRYABwQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="http://pixabay.com" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/clker-free-vector-images-3736/" rel="noopener ugc nofollow" target="_blank"> Clker-Free-Vector-Images </a></p></figure><p id="2e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索算法对于检索存储在数据结构中的一个或多个元素是有用的。搜索算法适用的一些问题示例包括检索数据库中的特定记录或搜索文章中的关键字。</p><p id="e6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搜索算法通常分为两种类型:</p><ol class=""><li id="f105" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><strong class="lb iu">顺序搜索:</strong>顺序搜索算法可以在有序或无序的数据结构上执行。该算法遍历数据结构并按顺序检查每个元素，直到找到所需的元素。线性搜索就是一个例子。</li><li id="42aa" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><strong class="lb iu">区间搜索:</strong>要执行这种类型的搜索，底层数据结构必须已经排序。因此，给定一个排序的数据结构，区间搜索算法递归地在中点将搜索空间分成两半，直到找到想要的元素，因此它比顺序搜索算法更快更有效。二分搜索法就是一个例子。</li></ol><h2 id="009d" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">线性搜索</h2><p id="4e64" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">给定一个已排序或未排序的数组，线性搜索从索引0开始，遍历数组中的每个元素，直到找到目标项并返回其索引。如果没有找到目标元素，返回-1。</p><p id="5a1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的时间复杂度为O(n)。这是因为在最坏的情况下，目标项是数组中的最后一个元素，我们将不得不遍历整个数组中的每一项，导致<em class="nh"> n </em>次比较。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="39fd" class="mj mk it nj b gy nn no l np nq">def linear_search(arr, target):<br/>   for idx, num in enumerate(arr):<br/>      if num == target:<br/>         return idx<br/>   return -1</span></pre><h2 id="6ee2" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">二进位检索</h2><p id="83f8" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">给定一个已排序的数组，二分搜索法的工作方式是在数组的中点将数组一分为二，并将目标元素与数组中的中间元素进行比较。如果目标元素小于中间的元素，则继续搜索数组的左半部分。否则，如果元素大于中间的元素，则继续搜索数组的右半部分。重复这个过程，直到目标元素等于中间元素，并返回它的索引。如果没有找到目标元素，返回-1。</p><p id="afc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">二分搜索法算法的时间复杂度是O(log n ),因为我们每次迭代都将搜索空间分成两半。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="0d01" class="mj mk it nj b gy nn no l np nq">def binary_search(arr, start, end, target):<br/>   while start &lt;= end:<br/>      midpoint = start + (end - start) // 2<br/>      mid_elem = arr[midpoint]</span><span id="e07c" class="mj mk it nj b gy nr no l np nq">      # if target is greater, ignore the left half<br/>      if target &gt; mid_elem:<br/>         binary_search(arr=arr, start=midpoint+1, end=end, target=target)</span><span id="9656" class="mj mk it nj b gy nr no l np nq">      # if target is smaller, ignore the right half<br/>      elif target &lt; mid_elem:<br/>         binary_search(arr=arr, start=start, end=midpoint-1, target=target)</span><span id="316d" class="mj mk it nj b gy nr no l np nq">      # otherwise target is equal to midpoint<br/>      else:<br/>         return midpoint</span><span id="3c5b" class="mj mk it nj b gy nr no l np nq">   return -1</span></pre><h2 id="df32" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">结论</h2><p id="1a76" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在本文中，我们讨论了两种重要的搜索算法——顺序搜索和区间搜索。线性搜索是时间复杂度为O(n)的顺序搜索的经典示例，而二分搜索法是时间复杂度为O(log N)的更高效的区间搜索的常用示例。</p><p id="99a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多请看本算法讲解系列:<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-1-recursion-f101500f9316"> #1:递归</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-2-sorting-18d0875528fb"> #2:排序</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-3-searching-84604e465838"> #3:搜索</a>(本期文章)、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-4-greedy-algorithms-f60792046d40"> #4:贪婪算法</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-5-dynamic-programming-e5472a4ce464"> #5:动态规划</a>、<a class="ae ky" rel="noopener" target="_blank" href="/algorithms-explained-6-tree-traversal-1a006ba00672"> #6:树遍历</a>。</p></div></div>    
</body>
</html>