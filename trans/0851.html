<html>
<head>
<title>How SciPy and Scikit-learn Can Optimize Your Model’s Response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SciPy 和 Scikit-learn 如何优化模型的响应</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-scipy-and-scikit-learn-can-optimize-your-models-response-12cf7f0ba3e9#2022-03-08">https://towardsdatascience.com/how-scipy-and-scikit-learn-can-optimize-your-models-response-12cf7f0ba3e9#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1885" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看一些方便的优化功能，从预测切换到处方！</h2></div><p id="4f86" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拥有一个复制基本事实的健壮模型是很好的，但是能够找到将最小化或最大化其响应的特性值可能会更好。理解为什么用巧克力饼干🍪！</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/63edd239d484dfc49ac6c9cf949da270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ptdrgpkfXJ46J0Mf"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated"><a class="ae lu" href="https://unsplash.com/@benostein?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本·斯坦</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><h1 id="a001" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">语境</h1><p id="5fd9" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">想象一下，你刚刚被一家巧克力饼干厂雇佣了！<br/>很棒的工作，不是吗？</p><p id="a088" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名数据科学家，你的老板要求你在流程的第一步工作，这时所有的配料(面粉、黄油、糖等)都已经准备好了。)混合在一起，因为操作人员面临的主要问题是，他们有时会在面团中结块……这会危及饼干的质量！😱</p><p id="e13b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好消息是他们已经能够测量:</p><ul class=""><li id="ca09" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">配料的主要特性</strong>(如面粉的含水量，黄油的柔软度)，</li><li id="44bc" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu">混合器的设置</strong>(其速度、温度等。),</li><li id="458d" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated">和<strong class="kk iu">面团中的结块率</strong>，从 0 到 10% (5%是临界阈值)</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="1993" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据是干净的，结构良好(不用提醒你，这是虚构的😂)而且不用花太多时间，你就可以创建一个模型，可以满怀信心地预测面团中块状物的百分比。</p><p id="2108" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了展示您的模型有多健壮，您将所有人聚集在搅拌机周围，向模型输入当前批次的属性，并宣布面团将具有(灾难性的！)7%的包干率。</p><p id="74b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当混合操作结束时，每个人都可以看到你的模型是正确的…但是，最终，面团必须被扔掉…</p><p id="82a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你的老板看着你说:</p><blockquote class="nn"><p id="e198" class="no np it bd nq nr ns nt nu nv nw ld dk translated">"<strong class="ak">有些参数我们可以控制(搅拌器的速度、我加的水量)，有些参数我们无法控制(面粉的湿度、房间的确切温度等)。).</strong></p><p id="aa7f" class="no np it bd nq nr ns nt nu nv nw ld dk translated"><strong class="ak">请使用您的模型告诉我们，对于每一批，如何微调生产参数以最大限度地降低废品率。</strong></p></blockquote></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="ff4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个严峻的事实:你的随机森林模型表现良好，但是，作为 100 个决策树的组合，它是完全非线性的…这使得你不可能找到一个最佳值，因为你可以用一个简单的线性方程解决…</p><p id="952c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好消息是 SciPy 确实提供了一些方便的优化功能来帮助您；让我们来发现如何！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="7b3f" class="lv lw it bd lx ly nx ma mb mc ny me mf jz nz ka mh kc oa kd mj kf ob kg ml mm bi translated">建模</h1><p id="84e0" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">为了举例，我们将使用一个“过于简单”的模型，但是对于更复杂的问题，原理是一样的。</p><p id="acc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设面团块率(Y)受两个主要参数的影响，存储在“X”NumPy 数组中:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="a9dd" class="oh lw it od b gy oi oj l ok ol">nb_samples = 15</span><span id="fb29" class="oh lw it od b gy om oj l ok ol">np.random.seed(22)<br/>X = np.random.randint(1, high=10, size=(nb_samples, 2))</span><span id="c521" class="oh lw it od b gy om oj l ok ol">print(X)</span><span id="11a8" class="oh lw it od b gy om oj l ok ol">y = X[:, 0] / X[:, 1]<br/>print(y)</span></pre><p id="1da3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="debf" class="oh lw it od b gy oi oj l ok ol">[[6 5]<br/> [1 5]<br/> [7 7]<br/> [5 9]<br/> [5 3]<br/> [9 8]<br/> [3 9]<br/> [9 6]<br/> [5 3]<br/> [3 2]<br/> [7 4]<br/> [4 3]<br/> [8 8]<br/> [8 8]<br/> [5 5]]</span><span id="a7ef" class="oh lw it od b gy om oj l ok ol">[1.2        0.2        1.         0.55555556 1.66666667 1.125  0.33333333 1.5        1.66666667 1.5        1.75       1.33333333  1.         1.         1.        ]</span></pre><p id="ba4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="on">注意:完整笔记本的链接在文章的最后提供</em>📑</p><p id="acae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有一个“适当的”(但很简单的)数据集，所以让我们用一个简单的 Scikit-Learn<a class="ae lu" href="https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeRegressor.html" rel="noopener ugc nofollow" target="_blank">decision tree regressor</a>创建一个非线性模型:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="3b82" class="oh lw it od b gy oi oj l ok ol">model = DecisionTreeRegressor(max_depth=4)<br/>model.fit(X, y)<br/>model.score(X, y)</span><span id="10d1" class="oh lw it od b gy om oj l ok ol">#0.9343996768065437</span></pre><p id="8aa4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">画出它的样子:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="f377" class="oh lw it od b gy oi oj l ok ol">plt.figure(figsize=(15, 15))<br/>tree.plot_tree(model)<br/>plt.show()</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oo"><img src="../Images/a460871fe8eccde73d2a1f3fd7ccb11a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EozcOnDkk3pq2_mXdGZUfg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">决策树表示法—作者图片</p></figure><p id="6698" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="on">我们可以观察到，根据 X[0]和 X[1]的值，该决策树有 8 种可能的输出。</em></p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="b83a" class="lv lw it bd lx ly nx ma mb mc ny me mf jz nz ka mh kc oa kd mj kf ob kg ml mm bi translated">SciPy 优化库</h1><p id="7f81" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated"><a class="ae lu" href="https://docs.scipy.org/doc/scipy/reference/optimize.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> SciPy Optimize </strong> </a>库提供了一组函数来最小化(或最大化)目标函数。唯一的预防措施是您应该选择与您的用例相对应的一个:</p><ul class=""><li id="5ad0" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">使用“最小化”</strong> = &gt;的局部(多变量)优化在您有标量/线性函数要求解时非常有用，该函数假定有一个最优值，如下面的凸函数(x +y):</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/3e60e4af41d8b9eef27ff0c5b50e4cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*LtHi1xRSaV5IR1AkV2ZMrg.png"/></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">f(x，y)= x+y-作者图片</p></figure><ul class=""><li id="d1ac" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">“双重退火”全局优化</strong> = &gt;当你有一个非线性函数，意味着随机搜索最优解时，这是很有用的。这是我们在使用集合树(Random Forest，XGBoost 等)等模型时遇到的典型情况。).</li></ul><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oq"><img src="../Images/380b443fd332a9ee2fd250a4fe5a64a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*28nB3bcMclaF1HPTWEPN-w.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">决策树示例-作者图片</p></figure><p id="64c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在开始最优搜索之前，我们需要创建一个目标函数，返回我们的非线性模型的结果:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="a9a1" class="oh lw it od b gy oi oj l ok ol">def objective(v):<br/>    return model.predict(np.array([v]))[0]</span></pre><p id="1c28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，只需设置每个特征的边界(X[0]和 X[1])并启动优化过程:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="8604" class="oh lw it od b gy oi oj l ok ol">bounds = [[1, 10], [1, 10]]</span><span id="c8fe" class="oh lw it od b gy om oj l ok ol">result = dual_annealing(objective, bounds, maxiter=100)</span><span id="10b2" class="oh lw it od b gy om oj l ok ol">print(f"Status: {result['message']}")<br/>print(f"Total Evaluations: {result['nfev']}")<br/>print(f"Minimum reached: {result['fun']}")<br/>print(f"Solution vector: {result['x']}")</span></pre><p id="bb85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="d532" class="oh lw it od b gy oi oj l ok ol">Status: ['Maximum number of iteration reached']<br/>Total Evaluations: 410<br/>Minimum reached: 0.2<br/>Solution vector: [1.78224412 9.35220569]</span></pre><p id="2d3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将边界设置为等于原始要素的空间，该函数可以提出一对值来有效地最小化目标函数:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oo"><img src="../Images/2a3a33f794e6c871d9d21ac6e8bdd95e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6duajp6X7oQIepXHZHRAQ.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">1 号优化结果—作者提供的图片</p></figure><p id="4db3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们用 X[1]上的约束来重现这个过程，次于 4:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="c888" class="oh lw it od b gy oi oj l ok ol">bounds = [[1, 10], [1, 4]]</span><span id="fa1c" class="oh lw it od b gy om oj l ok ol">result = dual_annealing(objective, bounds, maxiter=100)</span><span id="21f5" class="oh lw it od b gy om oj l ok ol">print(f"Status: {result['message']}")<br/>print(f"Total Evaluations: {result['nfev']}")<br/>print(f"Minimum reached: {result['fun']}")<br/>print(f"Solution vector: {result['x']}")</span></pre><p id="2b30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="a6dc" class="oh lw it od b gy oi oj l ok ol">Status: ['Maximum number of iteration reached']<br/>Total Evaluations: 404<br/>Minimum reached: 1.3333333333333333<br/>Solution vector: [4.32296802 1.87272909]</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi or"><img src="../Images/480f08c438f4e5283cb76e835ad091aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZ3a8aoTu-mXjb8EckZsGw.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">优化结果 n 2 —作者提供的图片</p></figure><p id="31d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该算法再次能够找到给定边界内的最小可能值(1.333)。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3dc6" class="lv lw it bd lx ly nx ma mb mc ny me mf jz nz ka mh kc oa kd mj kf ob kg ml mm bi translated">最大化或目标化</h1><p id="8732" class="pw-post-body-paragraph ki kj it kk b kl mn ju kn ko mo jx kq kr mp kt ku kv mq kx ky kz mr lb lc ld im bi translated">与其最小化函数，还不如尽量最大化或者达到一个特定的值。在这种情况下，你只需要修改目标函数。</p><ul class=""><li id="8562" class="ms mt it kk b kl km ko kp kr mu kv mv kz mw ld mx my mz na bi translated"><strong class="kk iu">通过在结果前添加“-”来最大化</strong> = &gt;</li><li id="ca45" class="ms mt it kk b kl nb ko nc kr nd kv ne kz nf ld mx my mz na bi translated"><strong class="kk iu">瞄准</strong> = &gt;通过在结果计算中包含目标</li></ul><p id="6bbd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最大化示例:</p><pre class="lf lg lh li gt oc od oe of aw og bi"><span id="f9bf" class="oh lw it od b gy oi oj l ok ol">def objective_max(v):<br/>    return -model.predict(np.array([v]))[0]</span><span id="ebb9" class="oh lw it od b gy om oj l ok ol">bounds = [[1, 10], [1, 10]]</span><span id="70f0" class="oh lw it od b gy om oj l ok ol">result = dual_annealing(objective_max, bounds, maxiter=100)</span><span id="0b32" class="oh lw it od b gy om oj l ok ol">print(f"Status: {result['message']}")<br/>print(f"Total Evaluations: {result['nfev']}")<br/>print(f"Maximum reached: {-result['fun']}")<br/>print(f"Solution vector: {result['x']}")</span><span id="f990" class="oh lw it od b gy om oj l ok ol"># Output<br/>Status: ['Maximum number of iteration reached']<br/>Total Evaluations: 410<br/>Maximum reached: 1.75<br/>Solution vector: [8.0829203 4.2638071]</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi os"><img src="../Images/4dd361a5c57f4f66be82acf5bb355a43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EzcFehFWMUAgH24PR8qEg.png"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">优化结果 3 —作者提供的图片</p></figure><p id="1dfe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从现在开始，再也没有理由让面团结块了，巧克力曲奇的质量是安全的🍪🍪🍪</p><p id="05af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相应的代码存储在这里:</p><div class="ot ou gp gr ov ow"><a href="https://github.com/pierrelouisbescond/medium_articles/blob/main/medium_optimize.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">medium _ articles/medium _ optimize . ipynb 位于 main pierrelouisscond/medium _ articles</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">一个 repo 来存储我在我的 Medium articles-Medium _ articles/Medium _ optimize . ipynb 中共享的代码，位于 main …</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">github.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk lo ow"/></div></div></a></div><p id="ab61" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请不要犹豫，浏览我在 Medium 上的其他文章:</p><div class="ot ou gp gr ov ow"><a href="https://pl-bescond.medium.com/pierre-louis-besconds-articles-on-medium-f6632a6895ad" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd iu gy z fp pb fr fs pc fu fw is bi translated">皮埃尔-路易·贝斯康德关于媒介的文章</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">数据科学、机器学习和创新</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">pl-bescond.medium.com</p></div></div><div class="pf l"><div class="pl l ph pi pj pf pk lo ow"/></div></div></a></div></div></div>    
</body>
</html>