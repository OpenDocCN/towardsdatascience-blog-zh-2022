<html>
<head>
<title>Develop Your Own Newton-Raphson Algorithm in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python开发自己的牛顿-拉夫森算法</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/develop-your-own-newton-raphson-algorithm-in-python-a20a5b68c7dd#2022-04-14">https://towardsdatascience.com/develop-your-own-newton-raphson-algorithm-in-python-a20a5b68c7dd#2022-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">求解最优解、平衡点等。使用NR方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fe4acf0bcd1a0e5b208eca8fe58026e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*an6csT2smz7mHXL1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">戴维·克洛德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="802a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">牛顿-拉夫森方法是一种迭代方法，用于逼近函数的根或零点。由于许多原因，确定根可能是重要的；它们可以用来优化金融问题，解决物理学中的平衡点，模拟计算流体动力学等。正如你所看到的，它的用途远远超出了任何一个主题。一般来说，在复杂的方程中，根是不能明确求解的，所以它们必须是近似的；这就是牛顿-拉夫森方法发挥作用的地方。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ee5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">牛顿-拉夫森方法(或算法)是计算根的最流行的方法之一，因为它简单而快速。结合计算机，该算法可以在不到一秒的时间内求解根。该方法要求函数符合以下形式。在大多数情况下，这可以通过简单的加法或减法来实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/919d4511fe3b580689598d666e273b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:136/1*bf6iOrohgz68FIoz5t9V2w.gif"/></div></figure><p id="5f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下面的例子为例。简单的减法就是将方程转换成上面的形式所需要的。等式的左边将是函数，<em class="md"> f(x) </em>。我们稍后会用到这个等式，所以请记住它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/d91ed421d9ccd3c7eed7484c887f0a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/1*sI8ea94jQzPVQbi11SW_Vg.gif"/></div></figure><p id="91f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法的第一步采用初始猜测，并使用函数和函数导数来计算下一个猜测。然后，以类似的方式使用该猜测来计算下一个猜测，依此类推，直到满足容差或迭代限制。如下面的动画所示，导数<em class="md">f’(x)</em>(红线)被用作斜率，以帮助计算<em class="md"> x </em>的下一个猜测值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/7463b1756531fce0e07e591ff912a2ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/1*6Qj5chzIJBX6fnDHYzUfOg.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">牛顿-拉夫森方法可视化【由<a class="ae ky" href="https://de.wikipedia.org/wiki/Benutzer:Ralf_Pfeifer" rel="noopener ugc nofollow" target="_blank">拉尔夫·普费菲</a>创造】</p></figure><p id="6f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把方程中发生的事情写出来，这样更有意义一点。第一次迭代如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/ab1bc1c31274ad4324999cfcd19ab62a.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/1*melU0ldWrIt2Lo7dZnhsGQ.gif"/></div></figure><p id="783b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二次迭代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/224b70be117b97b2d29099cdca31bfd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/1*j0_aIFcSvnLw65xZ6OxUIw.gif"/></div></figure><p id="be91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后续迭代，直到达到<em class="md"> f(xᵢ) </em>值的某个容差(或迭代极限):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7c3eb2358921399ca8661660fd43a806.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/1*OvklD0-NTQvZHAnbvlPQnw.gif"/></div></figure><p id="89c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你(或者一个代码)可以计算出<em class="md"> f(x) </em>的导数，那么你就可以用这个算法迭代计算一个方程的根。你最初的猜测可能非常重要。根据问题的不同，如果你从一个糟糕的猜测开始，它会让你的收敛需要一段时间或者根本不收敛。然而，如果猜测正确，牛顿-拉夫森算法将在几次迭代内相对快速地收敛到一个解。如果你有一个多重根的方程，你最初的猜测也很重要。根据你的第一个猜测，你可以收敛到任何一个根。这些问题可以通过使用有根据的初步猜测来缓解。</p><p id="abd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">牛顿-拉夫森算法可以使用Python或任何编码语言相对容易地实现。正如你在例子中看到的，当最初的猜测是合理的时候，计算机可以很快得出想要的答案。我们还会看到当你最初的猜测很糟糕时会发生什么。让我们开始编码:</p><h2 id="b8b6" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">导入包</h2><p id="b27b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我通常通过从<em class="md"> Matplotlib </em>导入N <em class="md"> umPy </em>和<em class="md"> pyplot </em>来开始我所有的Python代码。<em class="md"> NumPy </em>(为便于调用，定义为<em class="md"> np </em>)用于数组操作和基本数学函数，如余弦、正弦、指数和对数函数。<em class="md"> Pyplot </em>(为便于调用，定义为<em class="md"> plt </em>)用于创建图形和可视化数据。这两个软件包都很棒，比我在这里展示的功能多得多。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="198d" class="mi mj it nh b gy nl nm l nn no"># Importing Packages<br/>import numpy as np<br/>import matplotlib.pyplot as plt</span></pre><h2 id="8e0b" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">定义函数</h2><p id="3690" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这部分代码中，我们将定义一个方程，我们试图找到它的根和它的导数。这两个方程将被定义为Python函数，所以我们可以为它们提供一个输入值，<strong class="lb iu"> <em class="md"> x </em> </strong>，它们将返回方程的值及其在该值处的导数。作为参考，我们将使用本文前面的等式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/eb57e327343acaddd1862efb968d4c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/1*Tgi5u45znSgxkBSEfxhYDg.gif"/></div></figure><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="ea97" class="mi mj it nh b gy nl nm l nn no"># Defining Equation and Derivative<br/>def f(x):<br/>    res = np.cos(x)-2*x**3<br/>    return res<br/> <br/>def dfdx(x):<br/>    res = -np.sin(x)-6*x**2<br/>    return res</span></pre><h2 id="2b4a" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">牛顿-拉夫逊回路</h2><p id="99ac" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">本节提供了确定目标方程的根所需的迭代循环。在迭代<em class="md"> while </em>循环之前，最好包含一个最大迭代次数变量<strong class="lb iu"> <em class="md"> max_iter </em> </strong>。这很重要，因为如果算法不能收敛到一个解，它将防止<em class="md"> while </em>循环无限期运行。公差<strong class="lb iu"> <em class="md"> tol </em> </strong>，用于确保我们得到我们想要的精度。在开始我们的迭代之前，我们还包括最初的猜测，<strong class="lb iu"><em class="md"/></strong>【x₀】。</p><p id="8f93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在while循环中，我们使用牛顿-拉夫森通用方程来获得我们的下一个猜测，<strong class="lb iu"><em class="md">【Xi】</em></strong>，根据上一个猜测，<strong class="lb iu"><em class="md">【Xi _ 1</em></strong>(<strong class="lb iu"><em class="md">x₀</em></strong>用于第一次迭代)。然后将<strong class="lb iu"> <em class="md"> xi </em> </strong>值输入到原始方程中，以对照所选公差进行检查。这里，我们正在确定我们的新猜测是否使原始方程接近于零。当等式的绝对值小于我们的容差或者我们已经达到最大迭代次数时，将会中断<em class="md"> while </em>循环。如果它没有被破坏，循环继续更新对根的值的猜测。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4771" class="mi mj it nh b gy nl nm l nn no"># Newton-Raphson Algorithm<br/>max_iter = 20  # Max iterations<br/>tol = 1E-15  # Tolerance<br/>i = 0  # Iteration counter<br/>x0 = 1  # Initial guess<br/>xi_1 = x0<br/>print(‘Iteration ‘ + str(i) + ‘: x = ‘ + str(x0) + ‘, f(x) = ‘ + <br/>      str(f(x0)))</span><span id="58cb" class="mi mj it nh b gy nq nm l nn no"># Iterating until either the tolerance or max iterations is met<br/>while abs(f(xi_1)) &gt; tol or i &gt; max_iter:<br/>    i = i + 1<br/>    xi = xi_1-f(xi_1)/dfdx(xi_1)  # Newton-Raphson equation<br/>    print(‘Iteration ‘ + str(i) + ‘: x = ‘ + str(xi) + ‘, f(x) = ‘ +    <br/>          str(f(xi)))<br/>    xi_1 = xi</span></pre><p id="eb01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到，我们在每次迭代中打印了<strong class="lb iu"><em class="md">【Xi】</em></strong>和<strong class="lb iu"> <em class="md"> f(xi) </em> </strong>的值，以及它们发生在什么迭代中。这有助于我们跟踪算法的执行情况。该代码将输出以下内容:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="10b8" class="mi mj it nh b gy nl nm l nn no">Iteration 0: x = 1, f(x) = -1.4596976941318602<br/>Iteration 1: x = 0.7866397888154096, f(x) = -0.2673205221391448<br/>Iteration 2: x = 0.7261709381607133, f(x) = -0.018132645287873284<br/>Iteration 3: x = 0.7214340390454733, f(x) = -0.0001059518195203335<br/>Iteration 4: x = 0.7214060336500903, f(x) = -3.6893424981698786e-09<br/>Iteration 5: x = 0.721406032674848, f(x) = -1.1102230246251565e-16</span></pre><p id="90bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在查看我们的输出后，看起来牛顿-拉夫森算法在5次迭代内收敛。相当快。它也接近我们非常小的公差的解决方案。这意味着我们成功实现了融合！</p><h2 id="ad70" class="mi mj it bd mk ml mm dn mn mo mp dp mq li mr ms mt lm mu mv mw lq mx my mz na bi translated">绘制方程和结果</h2><p id="17b1" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">您可以通过绘制包含最终根结果的范围的方程来检查您的结果。您也可以绘制您的根值，以查看您的结果如何与直线匹配。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="8bb6" class="mi mj it nh b gy nl nm l nn no"># Creating Data for the Line<br/>x_plot = np.linspace(-2, 2, 1000)<br/>y_plot = f(x_plot)<br/> <br/># Plotting Function<br/>fig = plt.figure()<br/>plt.plot(x_plot, y_plot, c=’blue’)<br/>plt.plot(xi, f(xi), c=’red’, marker=’o’, fillstyle=’none’)<br/>plt.xlim([-2, 2])<br/>plt.ylim([-2, 2])<br/>plt.xlabel(‘x’)<br/>plt.ylabel(‘y’)<br/>plt.grid()<br/>plt.show()</span></pre><p id="4f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建下面的情节。正如你所看到的，牛顿-拉夫森算法的结果与x轴交叉处非常吻合。这意味着我们计算了这个例子方程的根的一个很好的近似值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0e5a7de2955b899e8c956852a6d19a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*4NdjZYmJ7zJ2PBjv4rt_uw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">牛顿-拉夫森示例[由作者创建]</p></figure><p id="41a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试一个不好的猜测，看看牛顿-拉夫森方法有多好。如果我们不知道零可能在哪里，我们可能会猜测根在100左右。这将导致算法花费17次迭代来达到最终结果，但是它仍然以期望的容差达到最终结果。这就是算法的力量。以下是这次试验的结果，以供参考:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="0071" class="mi mj it nh b gy nl nm l nn no">Iteration 0: x = 100, f(x) = -1999999.1376811278<br/>Iteration 1: x = 66.66639972214995, f(x) = -592586.2434629743<br/>Iteration 2: x = 44.44370527065607, f(x) = -175573.33453879558<br/>Iteration 3: x = 29.629768898508654, f(x) = -52025.53704873974<br/>Iteration 4: x = 19.751306671606308, f(x) = -15409.906816284196<br/>Iteration 5: x = 13.170008297565373, f(x) = -4567.829385058682<br/>Iteration 6: x = 8.783189380524185, f(x) = -1355.9491714365759<br/>Iteration 7: x = 5.857511541738072, f(x) = -401.03685300814516<br/>Iteration 8: x = 3.9055163566277287, f(x) = -119.86426242296075<br/>Iteration 9: x = 2.585811794335439, f(x) = -35.42914973938403<br/>Iteration 10: x = 1.7141632818943917, f(x) = -10.216519425753903<br/>Iteration 11: x = 1.1654743473093252, f(x) = -2.7718839271038136<br/>Iteration 12: x = 0.859829105239771, f(x) = -0.6187868181406497<br/>Iteration 13: x = 0.7406842579217826, f(x) = -0.07469127827436395<br/>Iteration 14: x = 0.7218536001388265, f(x) = -0.0016940906277266299<br/>Iteration 15: x = 0.7214062815658834, f(x) = -9.415553438030244e-07<br/>Iteration 16: x = 0.721406032674925, f(x) = -2.9121149935917856e-13<br/>Iteration 17: x = 0.721406032674848, f(x) = -1.1102230246251565e-16</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="09dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，这是一个非常强大的方法来获得一个方程的零点的非常接近的近似值。根的求解可以不用基于图的猜测，也不用代数求解(如果可能的话)。这可以应用于许多不同的领域，所以你自己试试吧！</p><p id="621e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读文章！如果您对代码有任何问题或者想了解更多关于这种方法的信息，请告诉我。如果你有兴趣，可以看看我关于Python、轨道力学和物理学的其他文章！</p></div></div>    
</body>
</html>