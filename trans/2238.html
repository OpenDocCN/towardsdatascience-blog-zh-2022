<html>
<head>
<title>Numerical Integration in MATLAB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MATLAB中的数值积分</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/numerical-integration-in-matlab-f41d187c1c15#2022-05-17">https://towardsdatascience.com/numerical-integration-in-matlab-f41d187c1c15#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1195" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用MATLAB实现微分方程数值积分的分步方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d5fdf5cb8a230f48b2e86e8e4c7b5695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LyLrX0lO77IvyCvQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></p></figure><p id="6180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">微分方程描述了许多基本的物理定律。它们被用来模拟火箭的轨迹，估计一种致命疾病的感染率，模拟一个国家的经济增长，等等。它们就在我们身边，如果使用得当，可以产生强大的效果。大多数具有实际应用的微分方程是常微分方程。这些方程由一个或多个函数(及其导数)和一个独立变量组成。大多数ODEs中的自变量是时间，或<em class="lv"> t </em>。不幸的是，大多数微分方程太难或者不可能显式求解。要得到一个困难的ODE的结果，下一个最好的步骤是数值积分。</p><p id="8b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数值积分用于近似ODE变量随时间的演变。在这篇文章中，我们将集中讨论初值问题。对于这些类型的问题，数值积分需要一个初始时间和初始条件，逐步通过预定义的时间间隔，并在每个时间步长计算变量的解。数值积分的好处是，根据所用的方法，常微分方程可以近似到很高的精度。此外，由于今天可用的大量计算能力，这些方法可以在几秒钟内运行。</p><p id="6e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MATLAB有许多数值积分器，由于它的计算能力和相对简单的语法，是许多工程师和物理学家的选择。由于MATLAB是由MathWorks开发和维护的，他们提供了<a class="ae ky" href="https://www.mathworks.com/help/matlab/math/choose-an-ode-solver.html" rel="noopener ugc nofollow" target="_blank">详细的解释并列出了</a>他们的每个ODE解算器。为您的问题选择正确的解算器可能很关键，但是对于大多数应用程序来说，ode45解算器是一个很好的起点。<em class="lv"> ode45 </em>解算器是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods" rel="noopener ugc nofollow" target="_blank">龙格库塔</a>四阶和五阶解算器。我从示例中学习得最好，所以让我们直接进入代码。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="a50a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先明确一下我们要研究什么常微分方程。最迷人的一组颂歌是<a class="ae ky" href="https://en.wikipedia.org/wiki/Lorenz_system" rel="noopener ugc nofollow" target="_blank">洛伦兹系统</a>。这组微分方程由Edward Lorenz研究，可用于创建大气对流的简化模型。由于我们将更多地关注如何数值求解常微分方程，如果你想了解模型本身的更多细节，你可以访问上面的维基百科链接。描述洛伦兹系统的常微分方程如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4b7eb8ab7a411217b2a098f71d7b3a7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/1*8jqilM7cmHYYCXhxdaBVGw.gif"/></div></figure><p id="34f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们感兴趣的变量是<em class="lv"> x </em>、<em class="lv"> y </em>和<em class="lv"> z </em>。我们将在后面的代码中定义常数<em class="lv"> σ、ρ </em>和<em class="lv"> β </em>。为了对这些方程进行数值积分，我们需要定义<em class="lv"> ode45 </em>函数所需的一切:初始条件、时间间隔和模型。我们的初始条件为下面的形式<em class="lv"> Y </em>(我们的结果也将采用这种形式)，模型为<em class="lv"> Y </em>向量的时间导数(或洛伦兹系统ODEs):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi me"><img src="../Images/86c3fde93d5a1f0db160bfb704e21972.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/1*svdvINh4-_ORmzdpg-qt9g.gif"/></div></figure><p id="9153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过将<em class="lv">模型</em>(或<em class="lv"> Y </em>、<em class="lv"> dYdt </em>的时间导数)定义为一个MATLAB函数来开始代码。下面的代码显示了这一点。我们首先从传递给<em class="lv">模型</em>的<em class="lv"> Y </em>向量(不要与变量<em class="lv"> y </em>混淆)中提取<em class="lv"> x </em>、<em class="lv"> y </em>和<em class="lv"> z </em>。接下来，我们定义将由该函数返回的时间导数向量<em class="lv"> dYdt </em>。这些是由洛伦兹系统定义的ode。这里我们将<em class="lv"> σ、ρ </em>和<em class="lv"> β </em>分别定义为10、20和1.5。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="6f40" class="mk ml it mg b gy mm mn l mo mp">% ODEs or Model<br/>function dYdt = model(t, Y)<br/>    x = Y(1);<br/>    y = Y(2);<br/>    z = Y(3);</span><span id="b40e" class="mk ml it mg b gy mq mn l mo mp">    dYdt = zeros(size(Y));<br/>    dYdt(1) = 10*(y-x);   % dxdt<br/>    dYdt(2) = x*(20-z)-y; % dydt<br/>    dYdt(3) = x*y-1.5*z;  % dzdt<br/>end</span></pre><p id="18c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MATLAB函数必须在代码末尾定义，所以下面的代码必须放在脚本的开头否则MATLAB会对你不满意。首先，按照标准做法，我们清除命令窗口，清除变量，并关闭所有图形窗口。这允许我们在运行脚本的其余部分之前从头开始。接下来，我们将定义<em class="lv"> ode45 </em>的另外两个重要输入，积分的初始条件和时间跨度。在这个例子中，这两个都是任意选择的，但是对于你的问题，你可能有特定的初始条件和你感兴趣的时间跨度。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="a8fa" class="mk ml it mg b gy mm mn l mo mp">clc<br/>clear variables<br/>close all</span><span id="63e9" class="mk ml it mg b gy mq mn l mo mp">% Initial Conditions and Time Span<br/>Y0 = [1; 0; 0]; % [x; y; z]<br/>tspan = [0 50]; % [Time_Start Time_Final]</span></pre><p id="1ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步就是简单地将我们的MATLAB函数、感兴趣的时间跨度以及我们已经定义的初始条件传递给<em class="lv"> ode45 </em>。我们还可以为<em class="lv"> ode45 </em>定义一个<a class="ae ky" href="https://www.mathworks.com/help/matlab/ref/odeset.html" rel="noopener ugc nofollow" target="_blank">选项</a>、<em class="lv"> opts </em>，这将确保我们的解决方案精确到您想要的程度。这里，我们使用<em class="lv"> odeset </em>将解决方案的相对容差设置得很低。对于你的具体问题，你可能不需要那么低的成本，所以确定什么是最适合你的。用这些参数运行<em class="lv"> ode45 </em>后，可以提取<em class="lv"> x </em>、<em class="lv"> y </em>和<em class="lv"> z </em>的解。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="0cae" class="mk ml it mg b gy mm mn l mo mp">% Numerically Integrating<br/>opts = odeset('RelTol', 1e-13);<br/>[t, Y] = ode45(@model, tspan, Y0, opts);<br/>x = Y(:, 1);<br/>y = Y(:, 2);<br/>z = Y(:, 3);</span></pre><p id="3e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以通过使用<em class="lv"> plot3 </em>函数，从数值积分中绘制出<em class="lv"> x </em>、<em class="lv"> y </em>和<em class="lv"> z </em>的结果(对于本例，因为我们有三个变量)。</p><pre class="kj kk kl km gt mf mg mh mi aw mj bi"><span id="2aea" class="mk ml it mg b gy mm mn l mo mp">% Displaying Results<br/>figure; hold on<br/>plot3(x, y, z, 'b')<br/>xlabel('x')<br/>ylabel('y')<br/>zlabel('z')<br/>view(45, 45)<br/>grid minor</span></pre><p id="5c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，你会从数值积分中得到下面的洛伦兹系统。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/cff789affa71ac8e582bf9fbde13ed73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*dMxeC8aDM2oXONc3pxpraQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">洛伦兹系统数值积分结果[由作者创建]</p></figure><p id="0c74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是使用MATLAB对常微分方程进行数值积分所需的全部代码。一旦你知道如何做，MATLAB中强大的ODE解算器库使这个过程变得相对容易。如果您对Python中的数值积分感兴趣，我鼓励您阅读这篇文章:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/how-to-numerically-integrate-dynamics-problems-w-python-85d9783aa088"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">使用Python进行数值积分</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">Python中数值积分方程和可视化结果的简单方法</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><p id="b2c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以学习使用MATLAB中的Runge Kutta方法创建自己的数值积分器:</p><div class="ms mt gp gr mu mv"><a rel="noopener follow" target="_blank" href="/how-to-solve-odes-in-matlab-without-built-in-functions-9eaa01c9fe10"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">如何在MATLAB中用龙格-库塔法求解常微分方程</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">学习编写一个Runge-Kutta 4阶算法来求解常微分方程</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ks mv"/></div></div></a></div></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="bfe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！如果你需要帮助实现这一点，请留下评论。我很乐意帮忙。如果您对其他编码、工程或空间相关的文章感兴趣，请给我一个关注！</p></div></div>    
</body>
</html>