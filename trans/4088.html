<html>
<head>
<title>How to Heapify a Tree in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在C++中堆一棵树</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-heapify-a-tree-in-c-e5abe494097d#2022-09-10">https://towardsdatascience.com/how-to-heapify-a-tree-in-c-e5abe494097d#2022-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="577f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用C++构建堆的初学者指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/998617334e0d7184a1b750e6f070d183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7tdfMf0eBS0PJRTI1c-_nA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/balance-blur-boulder-close-up-355863/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="e6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机科学中，堆是一种树形数据结构，其特殊性质是几乎完全满足堆性质的二进制结构。该属性对应于最大堆和最小堆。最大堆是一种数据结构，其中每个子节点小于或等于其父节点。最小堆是类似类型的数据结构，其中每个子节点大于或等于其父节点。当这些约束被放在树数据结构上时，我们最终得到的是长度相对较短的树。这使得在树中搜索值的过程更快。让我们考虑下面的最大堆:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/812ccd9924995c7ed68d55cb14a3574d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OdtST9xWwP8S-MAY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="893e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在树的顶部，我们有一个值为90的根节点。最大堆的属性是根节点具有最大值。此外，每个节点的值小于或等于其父节点。我们看到90是树中最大的值。此外，在第二层，我们看到小于90的值79和72，然后是小于79的值30和65，依此类推。</p><p id="7199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，看看下面的min堆的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/2b10b3570d6f5bf673df88a8c9e732df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*buFz07S53t0vxgXz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="a6b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将根处的值与根下每个节点处的值进行比较，我们会发现12是树中的最小值。在下面的级别，我们有20和29，它们都大于12，以此类推。</p><p id="5562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆树的任务是重新排列树的元素，使其具有最小或最大堆的属性。具体来说，max-heapify是这样一个过程，它采用一个表示为二叉树的数组，并记录每个节点的值，使得子节点小于或等于父节点，从而满足最大堆:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/0f8985e142dc59040066a7822e349a5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8uouISiUDngSTtFy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="b2c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Min-heapify是记录每个节点的值的过程，使得子节点大于或等于父节点，满足最小堆:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/804e0b3abb131b9e2d82484f95f83a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GHsWcgo58xy6sdx3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="d97d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于堆数据结构的有利属性，堆化是有用的。使树满足堆属性可以加速许多算法任务，这些任务在软件工程中非常重要。例如，堆数据结构可用于查找顺序统计信息。顺序统计对应于项目集合中的第k个最小(或最大)值。这在一些任务中有应用，例如快速找到一个数组的中间值。</p><p id="cb69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆数据结构也可以用于查找和跟踪数组中的最小值/最大值。这对于为客户安排优先级队列中的任务非常有用，在优先级队列中，问题花费时间最短的客户将被优先考虑。这可以缩短所有客户的平均等待时间。堆也用在图形算法中，例如用于寻找最短路径的Djiktra算法。这可用于基础设施规划任务，如建立道路网络、电线或输油管道。</p><p id="a220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解如何实现堆数据结构是每个数据科学家的一项重要技能。此外，理解堆数据结构的基本应用可以使它成为跨各种软件工程应用的许多算法任务的强大工具。</p><p id="a7f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">堆一棵二叉树</strong></p><p id="400c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆化是将二叉树转换成堆数据结构的过程。要了解这是如何实现的，让我们考虑以下阵列:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="b82b" class="md me it lz b gy mf mg l mh mi">array_in = [3, 5, 8, 10, 17, 11, 13, 19, 22, 24, 29]</span></pre><p id="6420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数组有相应的完整二叉树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/d1d36c15c6840d43ebb33b1f6752bb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f5NHYwm_LZo-ME_J"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="e4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以定义一个heapify函数，它将数组作为输入，并将其转换为最大或最小堆。让我们考虑把这个二叉树转换成一个max堆。我们需要做的第一件事是找到不是叶子的最后一个节点。叶子是没有任何子节点的节点。我们看到11、13、19、22、24和29都是叶子，因为它们不指向任何子节点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/4d72ea1fd8ab955e07fcb9dfbed4c43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Kq_GotBeBFwntP54"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="d3f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，从左到右读取每个树级别中的节点，我们看到最后一个非叶节点是17。这也是最后一个节点的父节点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ml"><img src="../Images/d02f278e1766062bf3f9881e5d445900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n_fLFc-GxaDuv4MT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="2ae6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过取节点数量的一半的底值-1:</p><p id="9aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个非叶节点的索引=的下限(节点数)/2–1。</p><p id="5e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例中，有11个节点，因此最后一个非叶节点的索引是:</p><p id="151e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个非叶节点的索引= floor of(11)/2–1 = 5.5-1 = floor of 4.5 = 4.0。</p><p id="ada5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以最后一个非叶节点的索引是4，它的值是17(记住我们从索引值0开始)。</p><p id="a15e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想从二叉树中建立一个最大堆。我们可以通过以相反的顺序将节点堆到最后一个非叶节点[3，5，8，10，17]来做到这一点。我们以相反的级别顺序应用heapify操作，这意味着从右到左，在每个级别我们将每个子节点与其父节点进行比较。对于max-heapify，如果子节点大于其父节点，则交换值。例如，我们通过将17与其最右边的子代29的值交换来开始heapify操作，因为子代大于父代:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/cf73c8b8b0af134a1e2084592549be69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iHDY_55fHxM6LKrV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="9435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们移动到下一个节点，从左到右，比较24和29。这满足了max-heap属性，因此我们接着将22与10进行比较。因为10在父节点上并且小于22，所以它不满足堆属性，所以我们交换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/244106ebea2713628b83d26aa9f01027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O1xjw4Q7A_vFNsds"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="f110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们移动到下一个节点。因为19小于22，所以它满足max- heap，所以我们继续下一个级别。我们从13开始，和它的父母比较。它不满足堆属性，所以我们交换8和13:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/0b31c0eb90b66ad21ef1c45916caafc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ycZNByYaDW1Ea3mB"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="3d5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要交换的下一个节点值是5和29，然后是5和24:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/3e5ed5ea4d8aafdd33a4ac05fa74ab5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KvNU7U4qqXLwPzfP"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="5bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们交换3和29，3和24，然后3和17:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/e8716170e9f7af7827406de611377925.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_IjTKovPa1iilsQK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="5805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写一些实现这种堆化逻辑的c++代码。让我们创建一个名为heapify_code.cpp的. cpp文件。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="11a3" class="md me it lz b gy mf mg l mh mi">vi heapify_code.cpp</span></pre><p id="2b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从包含<iostream>开始，它允许我们写入标准输入/输出流。</iostream></p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="0713" class="md me it lz b gy mf mg l mh mi">#include &lt;iostream&gt;</span></pre><p id="8c67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个名为heapify的函数，它返回void:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="f22e" class="md me it lz b gy mf mg l mh mi">void heapify()</span><span id="f1a3" class="md me it lz b gy mm mg l mh mi">{</span><span id="7ff1" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="1db7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数将接受一个整数数组输入。我们把整数数组叫做array_in。它还需要一个整数subtree_root_index作为子树根的索引。数组的大小也需要一个整数array_size:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="b2bf" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int index, int array_size)</span><span id="3bd8" class="md me it lz b gy mm mg l mh mi">{</span><span id="e1e3" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="1ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要在函数范围内定义一些变量。让我们初始化一个名为maximum _ value的变量。让我们也为左边和右边的孩子初始化变量。对于左边的孩子，索引是2*subtree_root_index +1，右边的孩子是2*subtree_root_index +2。</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="b5d2" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int array_size, int subtree_root_index)</span><span id="68eb" class="md me it lz b gy mm mg l mh mi">{</span><span id="2cf3" class="md me it lz b gy mm mg l mh mi">int largest_value = subtree_root_index;</span><span id="268c" class="md me it lz b gy mm mg l mh mi">int left = 2*subtree_root_index + 1;</span><span id="f510" class="md me it lz b gy mm mg l mh mi">int right = 2*subtree_root_index + 2;</span><span id="44fc" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="a13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来让我们添加逻辑来检查左边的子元素是否大于根元素。如果左孩子大于根，我们重新定义maximum _ value为左孩子。在这个逻辑中，我们还需要确保左边子元素的索引小于数组的大小:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="315b" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int array_size, int subtree_root_index)</span><span id="3ee1" class="md me it lz b gy mm mg l mh mi">{<br/>…//code truncated for clarity</span><span id="b5a0" class="md me it lz b gy mm mg l mh mi">if (left &lt; array_size &amp;&amp; array_in[left] &gt; array_in[largest_value])<br/>{<br/>largest_value = left;<br/>}</span><span id="faa8" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="6e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要添加逻辑来检查右孩子是否大于根。和前面的检查一样，如果右孩子大于根，我们将maximum _ value重新定义为右孩子。我们还需要确保右孩子的索引小于array_size:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="8a5b" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int array_size, int subtree_root_index)</span><span id="6e52" class="md me it lz b gy mm mg l mh mi">{<br/>…//code truncated for clarity</span><span id="9885" class="md me it lz b gy mm mg l mh mi">if (left &lt; array_size &amp;&amp; array_in[left] &gt; array_in[largest_value])<br/>{<br/>largest_value = left;<br/>}</span><span id="bcb8" class="md me it lz b gy mm mg l mh mi">if (right &lt; array_size &amp;&amp; array_in[right] &gt; array_in[largest_value]){<br/>largest_value = right;<br/>}</span><span id="fe09" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="3593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要检查最大值是否等于根的值。如果不是，我们用最大值交换根的值:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="4301" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int array_size, int subtree_root_index)</span><span id="f4ec" class="md me it lz b gy mm mg l mh mi">{<br/>…//code truncated for clarity</span><span id="a7a8" class="md me it lz b gy mm mg l mh mi">if (largest_value != subtree_root_index )<br/>{<br/>swap(array_in[subtree_root_index], array_in[largest_value];<br/>}</span><span id="1e02" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="b618" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们在maximum _ value不等于subtree_root_index的条件下递归调用子树上的堆函数:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="86d3" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int array_size, int subtree_root_index)</span><span id="c2e6" class="md me it lz b gy mm mg l mh mi">{</span><span id="9789" class="md me it lz b gy mm mg l mh mi">…//code truncated for clarity</span><span id="15b7" class="md me it lz b gy mm mg l mh mi">if (largest_value != subtree_root_index )<br/>{<br/>swap(array_in[subtree_root_index], array_in[largest_value]<br/>heapify(array_in, array_size, subtree_root_index);<br/>}</span><span id="a241" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="e4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的功能如下:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="d9ef" class="md me it lz b gy mf mg l mh mi">void heapify(int array_in[], int array_size, int subtree_root_index)</span><span id="1bc6" class="md me it lz b gy mm mg l mh mi">{<br/>int largest_value = subtree_root_index;<br/>int left = 2*subtree_root_index + 1;<br/>int right = 2*subtree_root_index + 2;</span><span id="82d2" class="md me it lz b gy mm mg l mh mi">if (left &lt; array_size &amp;&amp; array_in[left] &gt; array_in[largest_value])<br/>{<br/>largest_value = left;<br/>}</span><span id="dc9e" class="md me it lz b gy mm mg l mh mi">if (right &lt; array_size &amp;&amp; array_in[right] &gt; array_in[largest_value]){<br/>largest_value = right;<br/>}</span><span id="d97e" class="md me it lz b gy mm mg l mh mi">if (largest_value != subtree_root_index )<br/>{<br/>swap(array_in[subtree_root_index], array_in[largest_value]<br/>heapify(array_in, array_size, largest_value);<br/>}</span><span id="4fe5" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="e94d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">建堆</strong></p><p id="46b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经写完了heapify函数，我们可以写另一个函数，允许我们在给定一个输入数组的情况下构造一个堆。该函数将一个数组及其大小作为输入，并在一个for循环中从最后一个节点叶节点开始调用数组上的heapify函数。我们将该函数称为构造函数:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="9b7a" class="md me it lz b gy mf mg l mh mi">void<strong class="lz iu"> </strong>construct_heap(int array_in[], int array_size){</span><span id="c78f" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="ae26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们定义一个名为last_non_leaf_node的变量，它是array_size/2 -1:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="8b56" class="md me it lz b gy mf mg l mh mi">void<strong class="lz iu"> </strong>construct_heap(int array_in[], int array_size)<br/>{<br/>int last_non_leaf_node = (array_size/2) -1;<br/>}</span></pre><p id="3034" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以从最后一个叶节点开始以相反的顺序循环，迭代地将索引减1，并使用索引的每个值调用heapify函数:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="0896" class="md me it lz b gy mf mg l mh mi">void<strong class="lz iu"> </strong>construct_heap(int array_in[], int array_size){</span><span id="df6c" class="md me it lz b gy mm mg l mh mi">int last_non_leaf_node = (array_size/2) -1;</span><span id="9266" class="md me it lz b gy mm mg l mh mi">for (int subtree_root_index = last_non_leaf_node; subtree_root_index &gt;=0; subtree_root_index-=1)<br/>{<br/>heapify(array_in, array_size, subtree_root_index);<br/>}</span><span id="8725" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="7a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们定义一个打印函数，它将允许我们打印出堆中的值:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="1335" class="md me it lz b gy mf mg l mh mi">void print_heap(int array_in[], int array_size){</span><span id="b224" class="md me it lz b gy mm mg l mh mi">cout &lt;&lt; "Printing values at each node in heap" &lt;&lt; endl;</span><span id="a1c2" class="md me it lz b gy mm mg l mh mi">for (int index = 0; index &lt; array_size; index+=1)<br/>{<br/>cout&lt;&lt; array_in[index] &lt;&lt; endl;<br/>}</span><span id="e66f" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="ffaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以定义我们的主函数，它将作为执行heapify、construct_heap和print_heap函数的驱动程序代码。让我们定义我们之前使用的数组，array_in = [3，5，8，10，17，11，13，19，22，24，29]，它有相应的树表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mj"><img src="../Images/7dd477451b7ca5d0cd99499b835a2c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wBQy5QaoCqOlBwbs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="c057" class="md me it lz b gy mf mg l mh mi">int main(){</span><span id="aec0" class="md me it lz b gy mm mg l mh mi">int array_in[] = { 3, 5, 8, 10, 17, 11, 13, 19, 22, 24, 29};<br/>int array_size = sizeof(array_in) / sizeof(array_in[0]);<br/>construct_heap(array_in, array_size);<br/>print_heap(array_in, array_size);</span><span id="745c" class="md me it lz b gy mm mg l mh mi">}</span></pre><p id="e72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编译我们的脚本:</p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="a183" class="md me it lz b gy mf mg l mh mi">g++ heapify_code.cpp</span></pre><p id="a6c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">并运行我们编译好的脚本:</strong></p><pre class="kj kk kl km gt ly lz ma mb aw mc bi"><span id="7698" class="md me it lz b gy mf mg l mh mi">./a.out</span></pre><p id="3c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该得到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/4c52323aa676fcc8115d8c44865432ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*_27IualZRaVJPHzu"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者截图</p></figure><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的数组表示为heap = [29，24，13，22，17，11，8，19，10，5，3]，我们执行的转换如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lx"><img src="../Images/4da7c9fcaee847abcf976700c946edaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gcZ9pcbGAMaD3-y8"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者创建的图像</p></figure><p id="5553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章中使用的代码可以在<a class="ae ky" href="https://github.com/spierre91/builtiin/blob/main/cpp_tutorials/heapify_code.cpp" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="5839" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结论</strong></p><p id="f211" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆一棵树是很重要的，因为它允许我们从堆数据结构的有利属性中获益。堆是一种基本的数据结构，具有诸如最小/最大搜索、顺序统计和查找最短路径的应用。堆数据结构可以显著加快这些算法任务的速度。当您需要从一个项目集合中重复选择最大或最小值时，这通常是有用的，优先级队列和订单统计就是这种情况。</p><p id="711a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="mo">本帖原载于</em> </strong> <a class="ae ky" href="https://builtin.com/software-engineering-perspectives" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> <em class="mo">内置博客</em> </strong> </a> <strong class="lb iu"> <em class="mo">。原片可以在这里找到</em></strong><a class="ae ky" href="https://builtin.com/software-engineering-perspectives/heapify-heap-tree-cpp?i=5350fc7a-62c7-4937-b206-20e00f021c6f&amp;utm_source=transactional&amp;utm_medium=email&amp;utm_campaign=Built-In-Email" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="mo"/></strong></a><strong class="lb iu"><em class="mo">。</em> </strong></p></div></div>    
</body>
</html>