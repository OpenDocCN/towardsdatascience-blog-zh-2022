<html>
<head>
<title>Dataset Identification using RTrees and Geographical Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RTrees和地理数据的数据集识别</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/dataset-identification-using-rtrees-and-geographical-data-682f8dab78fa#2022-04-04">https://towardsdatascience.com/dataset-identification-using-rtrees-and-geographical-data-682f8dab78fa#2022-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b670" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">找出哪些数据集包含预定义区域内的面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07d6529340409199dbe128f037296df0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-vBOkKwUxQT8LgBl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">史蒂文·卡梅纳在Unsplash<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a></p></figure><h1 id="8c88" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">背景</h1><p id="9888" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">地理区域数据集通常在每个文件中包含大量多边形。此外，不同的分类意味着有几种类型的区域文件可供选择。</p><p id="1e8c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们想要定位特定选择的所有相关数据集，加载每个单独的GeoJSON或是低效的。shp文件并查询它们。相反，我们利用分层树结构(<a class="ae ky" href="https://daniel-ellis.medium.com/extracting-similar-data-using-k-d-trees-to-efficiently-locate-nearest-neighbors-332a014f2fb" rel="noopener">很像使用k维树来定位最近的邻居</a>)来减少所需的搜索时间。</p><h2 id="4dd7" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">什么是树</h2><p id="42d4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Rtrees不是将超平面分割成大小相等的盒子(quad/oct树)或使用二进制分割方法(k-d树)，而是将数据分割成矩形，使得每组中有相等数量的叶子。</p><p id="db4d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">R树的主要好处是它们是面向地理的。它们的多维搜索关键字结构使它们针对空间数据进行了优化(包含“分组”矩形不需要覆盖整个空间域)。对每个多边形使用边界框是RTrees更适合索引质心(点)数据的原因。正是由于这个原因，许多RTree实现可以在空间数据库或地理空间包中找到(例如来自geopandas的<code class="fe ne nf ng nh b">.sindex</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/81bc7cdc4a97b5d6f8ccae3f36dce14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTJUKxE-IhuDnQ86yHizHQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">同一个数据集上的八叉树(左)、三叉树(右)。来源:代码改编自<a class="ae ky" href="https://observablehq.com/@stardisblue" rel="noopener ugc nofollow" target="_blank"> <strong class="bd nj">法蒂陈</strong> </a></p></figure><p id="a958" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"> <em class="nk">注意:</em> </strong> <em class="nk">由于多边形从来都不是正方的，所以边界上可能会有一些矩形重叠。尽管这对于多边形定位非常有用，但如果您需要将每个项目一一映射到一个组，这可能会导致问题。在使用k-d或八叉树的这种情况下，方法可能是优选的。</em></p><h2 id="cbfc" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">数据集</h2><p id="dd58" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们使用的数据集是从国家统计局下载的，涵盖了许多区域大小(输出区域→国家),跨越数年。它们位于<a class="ae ky" href="https://github.com/wolfiex/ONSAreaFinder/tree/main/data" rel="noopener ugc nofollow" target="_blank">这个存储库</a>中，以gzipped geoJSON文件的形式存在。</p><p id="6947" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">读取数据和提取内存中的数据可以按如下方式完成:</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="6478" class="ms la it nh b gy np nq l nr ns">import geopandas as gpd<br/>import gzip</span><span id="50c2" class="ms la it nh b gy nt nq l nr ns">gdf = gpd.read_file(gzip.open(<strong class="nh iu">&lt;filename.gz&gt;</strong>,'rb'))</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="a5c6" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">获取边界框并构造项目对象</h1><p id="9650" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦我们加载了我们的文件，我们需要计算每个几何图形的边界框和我们希望传递的任何附加信息。在本例中，我感兴趣的是每个geoJSON文件的文件名和年份，使用regex搜索很容易提取出来:</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="2cbe" class="ms la it nh b gy np nq l nr ns">def splice(area,name):    </span><span id="4adf" class="ms la it nh b gy nt nq l nr ns">    bbox = dict(zip(['minX','minY','maxX','maxY'],area.geometry.bounds))    </span><span id="0cb0" class="ms la it nh b gy nt nq l nr ns">    origin = re.search(r'\D+',name).group()    <br/>    year = re.search(r'\d+',name).group()     <br/>    <br/>   return <strong class="nh iu">dict(id = area.areacd, origin=origin, year=year, **bbox)</strong></span></pre><p id="b464" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后这个函数被应用到每个文件的每个项目，并连接成一个列表——准备转换成一个RTree！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="0e70" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">r bush(RTree NPM包)</h1><p id="3d9d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然我们使用python进行处理，但是这个工具的最终版本将在JavaScript中执行(并且在web上)。出于这个原因，我们选择使用RTree库的JS实现，而不是geopandas中使用的python‘RTree’库。</p><h2 id="c2a6" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">在Python中使用RBush</h2><p id="1ed7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了在python中运行javascript，我们利用了<code class="fe ne nf ng nh b">js2py</code>库。这里，我们首先设置一个具有require功能的JS评估引擎，然后加载节点RBush库。最后，我们创建一个新的RBush元素，并将其读入我们的python程序。</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="4b45" class="ms la it nh b gy np nq l nr ns">import js2py </span><span id="b754" class="ms la it nh b gy nt nq l nr ns">context = js2py.EvalJs(enable_require=True)</span><span id="ec87" class="ms la it nh b gy nt nq l nr ns">context.eval("const RBush = require('rbush')")</span><span id="724a" class="ms la it nh b gy nt nq l nr ns">tree = context.eval(f"new RBush({size})")</span></pre><h2 id="d52d" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">向RBush批量添加数据</h2><p id="e0f6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">就计算和处理而言，单个大型操作通常比需要在运行时改变数组大小的单个操作更有效。出于这个原因，我们使用以下命令将之前生成的变量列表读入RBush对象:</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="0f00" class="ms la it nh b gy np nq l nr ns">tree.load(list_of_items)</span></pre><p id="f731" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于大型数据集，这可能需要几分钟时间。</p><h2 id="07d0" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">保存到磁盘</h2><p id="ba69" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最后，我们希望将生成的树保存到磁盘上，供以后使用，并加载到我们的web应用程序中。我们通过将<code class="fe ne nf ng nh b">js2py</code> JSON树结构转换成python字典，然后使用python <code class="fe ne nf ng nh b">json</code>库将其写入文件来实现这一点。</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="6023" class="ms la it nh b gy np nq l nr ns">import json <br/><strong class="nh iu">json.dump</strong>(tree.toJSON()<strong class="nh iu">.to_dict()</strong>,open('docs/tree.json','w'))</span></pre></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="d36b" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">构建Web应用程序并执行</h1><p id="f7a7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们已经生成了我们的树，最后一步是在我们的定制web应用程序上执行它。我们需要做的第一件事是加载新保存的JSON文件:</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="fec1" class="ms la it nh b gy np nq l nr ns">const data = await fetch(            <br/>     "https://wolfiex.github.io/ONSAreaFinder/tree.json"          <br/>   ).then((d) =&gt; d.json())                </span><span id="02ff" class="ms la it nh b gy nt nq l nr ns">const tree = new rbush(10).fromJSON(data)</span></pre><p id="70b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，自定义边界框选择工具与下面的树搜索功能相结合:</p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="024d" class="ms la it nh b gy np nq l nr ns">tree.search({<br/>    minX: bbox.mnx,<br/>    minY: bbox.mny,<br/>    maxX: bbox.mxx,<br/>    maxY: bbox.mxy<br/>});</span></pre><p id="7a23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将产生一个描述所有区域类型及其源文件的界面，如下图所示。现场互动版可以在这里  <strong class="lt iu">找到<a class="ae ky" href="https://wolfiex.github.io/ONSAreaFinder/" rel="noopener ugc nofollow" target="_blank"> <strong class="lt iu">。</strong></a></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b383198388dce3e8438622d9bfdf81bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vh1RhMJD4oanF0qSlR8r4A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">该工具运行时的屏幕截图。来源:Self(此处可用<a class="ae ky" href="https://wolfiex.github.io/ONSAreaFinder/" rel="noopener ugc nofollow" target="_blank"><strong class="bd nj"/></a><strong class="bd nj">)</strong></p></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="cb7e" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated">结论</h1><p id="02b2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">RTrees已被大量用于快速多边形索引，并在地理数据集查询程序的几个数据库中实现。我们填充了RBrush npm库，并从javascript和python中使用它来构建一个可查询的地图，该地图标识哪些区域类型属于特定的选择。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="4b1d" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">应用:</h2><p id="371e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://wolfiex.github.io/ONSAreaFinder/" rel="noopener ugc nofollow" target="_blank">https://wolfiex.github.io/ONSAreaFinder/</a></p><h2 id="afae" class="ms la it bd lb mt mu dn lf mv mw dp lj ma mx my ll me mz na ln mi nb nc lp nd bi translated">代码:</h2><p id="1975" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">该项目的代码可在<code class="fe ne nf ng nh b"> (__main__.py)</code>找到:</p><div class="oh oi gp gr oj ok"><a href="https://github.com/wolfiex/ONSAreaFinder" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">GitHub-wolf iex/onsaraefinder:点击一个位置，获取相关的区号。</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div><p id="ad7c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">“docs”目录下的web应用程序<code class="fe ne nf ng nh b">(index.js).</code></p><pre class="kj kk kl km gt nl nh nm nn aw no bi"><span id="c05b" class="ms la it nh b gy np nq l nr ns">Dan Ellis. (2022). <br/>wolfiex/ONSAreaFinder: v1.0 (v1.0). Zenodo. https://doi.org/10.5281/zenodo.6408276</span></pre></div></div>    
</body>
</html>