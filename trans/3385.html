<html>
<head>
<title>Improve Your Data Science Workflow with Rolling Functions in Pandas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pandas中的滚动功能改进您的数据科学工作流程</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improve-your-data-science-workflow-with-rolling-functions-in-pandas-69c4b44e3f7e#2022-07-27">https://towardsdatascience.com/improve-your-data-science-workflow-with-rolling-functions-in-pandas-69c4b44e3f7e#2022-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">熊猫滚动特征指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/16987de31f77a251993bc08d4cd8c638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T5VDuwv46cU8DgHh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安妮·斯普拉特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="8463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们今天看到的许多表格数据分析都是由流行的Pandas基于系列的方法驱动的，这些方法一次性考虑所有数据进行分析。这些方法通常包括使用<code class="fe ls lt lu lv b">value_counts()</code>评估序列分布，使用<code class="fe ls lt lu lv b">unique()</code>确定唯一值，使用<code class="fe ls lt lu lv b">groupby()</code>找到基于另一列中的值分离的一列的分布，或者使用<code class="fe ls lt lu lv b">crosstab()</code>从多列中生成值的交叉表等。</p><p id="25d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，另一组经常被数据科学家忽视的强大的特征工程方法是<strong class="ky ir">基于窗口的数据分析</strong>。这里，不是在整个数据列上估计特定的数据统计/度量，而是考虑预定义数量的连续记录(或值窗口)来进行评估。</p><p id="f542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑下面的虚拟销售数据。我们可以通过同时聚合三个记录来计算每个销售日的平均三天滚动销售额，如图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/94626af652994675b6728364a25aadd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGMlv2L4KSOb6k0l5923Bw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">商店销售的虚拟数据集(图片由作者提供)</p></figure><p id="440b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图描述了计算三天滚动平均值的数学公式。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/5aecca9c3b6eba0b6f2d1a64772018b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*L20NNfLAe34EGbcWcI07BA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算三天滚动平均值的公式(图片由作者提供)</p></figure><p id="ad28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类特征生成方法尤其适用于时间序列数据。寻找<em class="ly">滚动平均值</em>、<em class="ly">滚动总和</em>、<em class="ly">滚动最小值、</em>和<em class="ly">滚动最大值</em>是基于窗口的特征工程方法的一些最常见的应用。</p><p id="b70b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是熊猫滚动特征的介绍性指南。我将借助虚拟数据框演示计算滚动特征的方法。</p><p id="68fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里找到这篇文章<a class="ae kv" href="https://deepnote.com/workspace/avi-chawla-695b-aee6f4ef-2d50-4fb6-9ef2-20ee1022995a/project/Rolling-Window-Pandas-fa9dd7e3-c9cc-4931-9dd5-1e3103832fba/%2Fnotebook.ipynb" rel="noopener ugc nofollow" target="_blank">的笔记本。</a></p><p id="0881" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧🚀！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="28c3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">资料组</h1><p id="009c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">出于本文的目的，我创建了一个从<code class="fe ls lt lu lv b">7th Jan 2020</code>到<code class="fe ls lt lu lv b">13th Jan 2020</code>为期7天的虚拟每日商店销售数据集。对应每个日期，我们知道它是<code class="fe ls lt lu lv b">weekend</code>还是<code class="fe ls lt lu lv b">weekday</code>。此外，我生成了一个随机销售号码，对应于现金和信用卡支付模式。这在下面实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fe13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示了虚拟销售数据集的前五行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/e2e1fcc8fa76d9c0ebd701ee7a501f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*I1dbP5-auqAfD6PcLsGcWw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据帧的前五行(图片由作者提供)</p></figure><h1 id="a4c2" class="mg mh iq bd mi mj ng ml mm mn nh mp mq jw ni jx ms jz nj ka mu kc nk kd mw mx bi translated">滚动功能</h1><p id="ba1a" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如上所述，窗口函数每次考虑行的子集，以估计给定数据的统计/测量。在Pandas中，可以使用<code class="fe ls lt lu lv b"><a class="ae kv" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling" rel="noopener ugc nofollow" target="_blank">df.rolling()</a></code>类来访问这个函数家族。创建的python对象的类型如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl ne l"/></div></figure><h2 id="3926" class="nm mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated">滚动总和</h2><p id="718e" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">顾名思义，滚动和方法计算预定义数量的连续记录的移动和。这在下面的虚拟数据集上有详细说明:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/7731f01938b1f31f60a5af9e49001909.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*e75w7TFpuyOrFZb5jyZpAg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">窗口大小为2时滚动求和的结果(图片由作者提供)</p></figure><p id="3d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ls lt lu lv b">window=2</code>，我们打算对<code class="fe ls lt lu lv b">2</code>连续记录上的“销售”列求和。另外，请注意滚动总和列的第一个值是<code class="fe ls lt lu lv b">NaN</code>。</p><p id="2b89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想只考虑第一条记录来计算第一条记录的滚动和，请在滚动类的定义中传递<code class="fe ls lt lu lv b">min_periods=1</code>,如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/53dd6fce85fa8acaf65fdbfcb0f6ca16.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*BDY8sbkeoi9Qhs_diU55jg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在最小周期数为2的窗口大小上滚动求和的结果(图片由作者提供)</p></figure><p id="2fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">min_periods</code>参数指定生成滚动值所需的当前窗口中的最小观察次数；否则结果是<code class="fe ls lt lu lv b">NaN</code>。</p><h2 id="39b3" class="nm mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated">几天的累计总和</h2><p id="f178" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">接下来，假设您想要计算过去两天的滚动总和，而不是上面讨论的前两个记录。</p><p id="c497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，获取几天的滚动总和而不是记录是非常重要的。这是因为我们有多个对应于同一日期的记录。因此，如果您想要查找多日窗口内的销售额，您可以执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/aa17d1538cbc18703d3116cf0bfd8a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*OJVlkSv4ljtLQ7D49PpEfQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两天的累计结果(图片由作者提供)</p></figure><p id="7524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">参数<code class="fe ls lt lu lv b">window=’2d’</code>被滚动类解释为“2天”。同样，如果您想获得2秒内的滚动和，您可以指定<code class="fe ls lt lu lv b">window=’2s’</code>。</p><p id="580a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，如果您只想过滤对应于每个日期的最后一条记录，您可以使用如下的<code class="fe ls lt lu lv b">groupby()</code>方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3c9b36163b2fee8f46dd42a924e13e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*lzWNcTXYQ1PjnQzhlXVYNg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">过滤滚动总和以获得每天的最后一条记录(图片由作者提供)</p></figure><h2 id="629e" class="nm mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated">分组轧制</h2><p id="799b" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">最后，假设您希望分别为支付和现金卡模式生成滚动总和。换句话说，滚动求和应该在一列上分组。这也可以通过向数据帧添加一层<code class="fe ls lt lu lv b">groupby()</code>并计算各个组的滚动特征来实现。下面演示了这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/6db9d8f6fa682b49270780b909d16919.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*B56D9BczCZvGPlJH6EnMzg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">按Payment_type分组的窗口大小为2的滚动求和结果(图片由作者提供)</p></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="0636" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">其他轧制方法</h1><p id="cda8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">类似于上面讨论的基于总和的窗口操作，Pandas还允许您执行各种其他滚动功能。这些包括滚动平均值、标准偏差、最小值和最大值等。你可以在这里找到所有支持的方法。下面我们来讨论其中的一个。</p><h2 id="c2ed" class="nm mh iq bd mi nn no dn mm np nq dp mq lf nr ns ms lj nt nu mu ln nv nw mw nx bi translated">滚动平均值</h2><p id="0dc8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">滚动平均，也称为移动平均，计算值窗口内的值的平均值。移动平均是数据科学中用于时间序列数据的一种流行的数据分析技术。</p><p id="f254" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就Pandas中的语法而言，我们上面讨论的一切都保持不变，除了我们用<code class="fe ls lt lu lv b">mean()</code>代替<code class="fe ls lt lu lv b">sum()</code>来寻找移动平均线。这将在下面演示。</p><p id="5876" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:为了演示移动平均线，我创建了三个月的虚拟数据，从<code class="fe ls lt lu lv b">1st Jan 2020</code>到<code class="fe ls lt lu lv b">31st Mar 2020</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/daa802cdbe604239705f1b9dac82a63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*VE96Gw5rOANSAmVZWdLP2Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">min_periods = 1时窗口大小为6的移动平均结果(图片由作者提供)</p></figure><p id="6611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用Matplotlib绘制移动平均值，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/5220e998f2ed48bc9cf0199acd9872e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXdsMyx8QZHlimimxBMorA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">描绘移动平均值和实际值的折线图(图片由作者提供)</p></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="e17e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，在这篇文章中，我们讨论了Pandas中的滚动功能，以及如何在下一个时间序列分析的表格数据分析中使用它们。</p><p id="d2c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解Pandas的“窗口”模块中可用的更多方法，我强烈推荐在这里查看Pandas的官方文档。</p><p id="46b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，感谢阅读。下面是我的一些其他文章，你可能会喜欢读:)</p><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/20-of-numpy-functions-that-data-scientists-use-80-of-the-time-d8bd9c7d144b"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">数据科学家80%的时间使用20%的NumPy函数</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">谁说你应该知道一切？</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz kp ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener follow" target="_blank" href="/five-killer-optimization-techniques-every-pandas-user-should-know-266662bd1163"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd ir gy z fp oq fr fs or fu fw ip bi translated">每个熊猫用户应该知道的五个黑仔优化技术</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">数据分析运行时优化的一步</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">towardsdatascience.com</p></div></div><div class="ou l"><div class="pa l ow ox oy ou oz kp ol"/></div></div></a></div></div></div>    
</body>
</html>