<html>
<head>
<title>How to Use SubQueries in SQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在SQL中使用子查询</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-to-use-subqueries-in-sql-da660694b8e3#2022-10-28">https://towardsdatascience.com/how-to-use-subqueries-in-sql-da660694b8e3#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="832c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用子查询使您的SQL查询更加灵活，并减少代码混乱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/66464b5b0578c9e22c1b2ae37bde0f98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HoJhuRehHg2uT_N7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@casparrubin" rel="noopener ugc nofollow" target="_blank">casparrubin</a>@ unsplash . com拍摄</p></figure><p id="3fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">【免责声明:此帖子包含一些我的Udemy课程的附属链接】</em></p><p id="978d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子查询是一个很酷的概念，我们可以在用结构化查询语言(SQL)编程时使用。从问题开始:有时我们希望访问查询上下文之外的数据，以过滤行或基于聚合度量执行一些特殊的过滤。当我们想要这样做时，我们可能会陷入创建太多检查点的陷阱，这些检查点用几个临时表相互依赖。这些临时对象不仅会占用我们服务器的宝贵空间，还会使代码更难调试，更令人困惑。</p><p id="5f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子查询是一个简单的SQL概念，它将帮助我们将几个查询语句压缩成一个语句。有三种主要的用例(至少我个人经常使用，但还有更多)依赖于子查询:</p><ul class=""><li id="30b8" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">用子查询访问聚合。</li><li id="4b94" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">用另一个表的上下文过滤表中的行。</li><li id="4b74" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">执行双层聚合，如平均值或总和的平均值。</li></ul><p id="8ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将研究一些如何在SQL中使用子查询的例子，以及它们如何为您的数据管道带来灵活性！</p><p id="07fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想提高你的SQL游戏，使用子查询可能会有很大的不同。通过将它们添加到您的工具带上，您将编写更加有组织的查询，这些查询不依赖于大量的连续步骤，从而更容易减少您编写的代码量。不利的一面是，它们可能比它们的join替代品慢一点——所以，接下来让我们来研究一下它们！</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="80dd" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">创建数据</h1><p id="1194" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">对于这个例子，我们将使用来自两个假设商店的数据。假设我们有两个表，一个用于<code class="fe no np nq nr b">store_a</code>，另一个用于<code class="fe no np nq nr b">store_b</code>。每个表都记录了客户的购买情况，其构建方式类似于典型的事实表，这意味着每次购买都与以下内容相关联:</p><ul class=""><li id="5123" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">记录它的雇员id。</li><li id="ef90" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在交易中购买商品的客户标识。</li><li id="e94f" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">对于购买的每个产品，每个购买行都要相乘。</li><li id="d642" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">每种产品都有特定的价格。</li></ul><p id="94a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为两家商店创建并填充虚拟数据:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="7eae" class="nw ms it nr b gy nx ny l nz oa">create table sandbox.store_a (<br/> transaction_id int,<br/>    employee_id int not null,<br/>    customer_id int not null,<br/>    product_id int not null,<br/>    price_paid numeric(19,4)<br/>    );</span><span id="d846" class="nw ms it nr b gy ob ny l nz oa">create table sandbox.store_b (<br/> transaction_id int,<br/>    employee_id int not null,<br/>    customer_id int not null,<br/>    product_id int not null,<br/>    price_paid numeric(19,4)<br/>    );</span><span id="ddc5" class="nw ms it nr b gy ob ny l nz oa">insert into sandbox.store_a (<br/> transaction_id, employee_id, customer_id, product_id, price_paid<br/>    ) values <br/>    (1, 1, 1, 1, 9.99),<br/>    (1, 1, 1, 2, 7.99),<br/>    (1, 1, 1, 3, 3.99),<br/>    (1, 1, 1, 4, 2.99),<br/>    (2, 1, 2, 1, 9.99),<br/>    (2, 1, 2, 3, 3.99),<br/>    (3, 2, 1, 1, 9.99),<br/>    (4, 2, 1, 2, 7.99),<br/>    (4, 2, 1, 3, 3.99),<br/>    (5, 2, 2, 1, 9.99),<br/>    (6, 1, 3, 1, 3.99);<br/>    <br/>insert into sandbox.store_b (<br/> transaction_id, employee_id, customer_id, product_id, price_paid<br/>    ) values <br/>    (1, 5, 10, 1, 9.99),<br/>    (1, 5, 10, 3, 3.99),<br/>    (1, 5, 10, 4, 2.99),<br/>    (2, 1, 11, 1, 9.99),<br/>    (3, 1, 11, 3, 3.99),<br/>    (4, 6, 11, 1, 9.99),<br/>    (4, 6, 11, 2, 7.99),<br/>    (5, 7, 10, 3, 3.99);</span></pre><p id="678b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的表格如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/3d6542db68d26575d05616e291ce1d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*PzZwliJYrzUquCjmmr7ZqA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">商店A-交易表-按作者分类的图像</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/fd996370387287108b8d8a35b90b5379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*6pK2uFHXtjwsCvS3LfSdhA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">商店B —交易表—按作者分类的图像</p></figure><p id="dbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个商店都有不同顾客购买的不同商品。为了了解这种情况下的子查询，我们将使用两个用例:</p><ul class=""><li id="2c79" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">如何筛选在<code class="fe no np nq nr b">store_b</code>买过至少三次的产品？</li><li id="b780" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们如何计算<code class="fe no np nq nr b">store_a</code>中交易的平均值？</li><li id="a1b9" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">在<code class="fe no np nq nr b">store_a</code>上，我们如何过滤价值高于平均值的交易？</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d540" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">使用子查询作为过滤器</h1><p id="79b0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们从我们的第一个例子开始——我们如何过滤在<code class="fe no np nq nr b">store_b</code>中至少购买过三次的产品的行？</p><p id="9775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们必须画出一个如何做到这一点的心理计划:</p><ul class=""><li id="54a2" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">统计每件商品在<code class="fe no np nq nr b">store_b</code>购买的次数；</li><li id="f486" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">存储大于或等于3的<code class="fe no np nq nr b">product_ids</code>；</li><li id="c2fc" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">过滤那些来自<code class="fe no np nq nr b">store_b</code>的产品；</li></ul><p id="42db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在“正常”的流水线方式中，可以使用一个临时表分两步完成。例如:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="61bf" class="nw ms it nr b gy nx ny l nz oa">create temporary table sandbox.top_products as (<br/> select product_id<br/>    from sandbox.store_b<br/>    group by product_id <br/>    having count(product_id) &gt;= 3<br/>);</span><span id="e7f3" class="nw ms it nr b gy ob ny l nz oa">select a.* from<br/>sandbox.store_b as a<br/>inner join <br/>sandbox.top_products as b<br/>on a.product_id = b.product_id;</span></pre><p id="89df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建我们的<code class="fe no np nq nr b">top_products</code>临时表，并使用其域通过内部连接来限制<code class="fe no np nq nr b">store_b</code>行是可能的。作为替代，我们可以在where子句中传递带有子查询的<code class="fe no np nq nr b">top_products</code>:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c695" class="nw ms it nr b gy nx ny l nz oa">select * from <br/>sandbox.store_b<br/>where product_id IN (<br/> select product_id from sandbox.top_products<br/>);</span></pre><p id="5b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们可以通过向查询的<code class="fe no np nq nr b">where</code>子句传递select语句，将<code class="fe no np nq nr b">product_ids</code>嵌入其中。但是，如果我们可以直接将查询传递给<code class="fe no np nq nr b">where</code>子句，我们现在就可以放弃临时表了！让我们看看:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="d216" class="nw ms it nr b gy nx ny l nz oa">select * from <br/>sandbox.store_b<br/>where product_id IN (<br/>    select product_id<br/>    from sandbox.store_b<br/>    group by product_id <br/>    having count(product_id) &gt;= 3<br/>);</span></pre><p id="44fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">搞定了。我们已经使用第一个子查询示例将所有内容压缩到同一个查询中。提示:始终使用缩进来引导读者理解查询的行为。对于子查询，将它放在缩进的块中会更容易阅读和理解。</p><p id="ed02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，以上所有查询的结果都是相同的——我们从<code class="fe no np nq nr b">store_b</code>输出<code class="fe no np nq nr b">product_ids</code> 1和3:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/de291e34871e917a7ce0d454708954af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1098/format:webp/1*2ac-kbvClAahGqhvGpnU_A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子查询结果1 —按作者分类的图像</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="91cf" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">多层聚合</h1><p id="875e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在这种情况下，我们有一个<a class="ae ky" href="https://www.geeksforgeeks.org/denormalization-in-databases/" rel="noopener ugc nofollow" target="_blank">非规范化表</a>，我们可能想要对数据执行一些多级聚合。例如，如果我们想要计算所有事务的平均值，我们不能直接应用平均值，因为我们的表是面向<code class="fe no np nq nr b">product_ids</code>而不是<code class="fe no np nq nr b">transaction_ids</code>的。</p><p id="9a5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，如果我们应用“正常”的数据管道规则，我们可能会将其分为两个查询:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="94b6" class="nw ms it nr b gy nx ny l nz oa">create temporary table sandbox.average_price as (<br/>  select transaction_id, sum(price_paid) as total_value<br/>  from sandbox.store_a<br/>  group by transaction_id<br/>);</span><span id="966b" class="nw ms it nr b gy ob ny l nz oa">select avg(total_value) from sandbox.average_price;</span></pre><p id="2d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过最后一条<code class="fe no np nq nr b">select</code>语句，我们知道<code class="fe no np nq nr b">store_a</code>的平均交易量大约为12.48 €。同样，这是子查询的另一个优秀用例！您能自己构建子查询语法吗？</p><p id="b038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="c2da" class="nw ms it nr b gy nx ny l nz oa">select avg(average_price.total_value) as average_transaction from (<br/>   select transaction_id, sum(price_paid) as total_value<br/>   from sandbox.store_a<br/>   group by transaction_id<br/>   ) as average_price<br/>;</span></pre><p id="8916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们的子查询进入了<code class="fe no np nq nr b">from</code>子句！子查询非常灵活，使我们能够在最著名的SQL <code class="fe no np nq nr b">clauses</code>中使用它们。</p><p id="9586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面查询的结果与两表方法完全相同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7cd1b90217ea4ee165bf42f40ebb854e.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*qAdgYfK4VQM-bQtJrGrgDQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子查询结果(多层聚合)-按作者分类的图像</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4f90" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基于聚合筛选表</h1><p id="bfe7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">另一个适合子查询的用例是在某些场景中使用SQL变量。例如，假设我们想要过滤值高于平均值的事务(输出必须保留原始的面向产品的行)，我们能在几个查询中完成吗？</p><p id="25fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们采用多表方法:</p><ul class=""><li id="d962" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">我们从计算每笔交易的总额开始。</li><li id="f5f1" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们将所有交易的平均值插入到一个变量中。</li><li id="b1ae" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">我们过滤总值高于所有交易平均值的交易组。</li></ul><p id="83e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不使用子查询，这可以通过以下方式实现:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="8a2d" class="nw ms it nr b gy nx ny l nz oa">create temporary table sandbox.average_price as (<br/>  select transaction_id, sum(price_paid) as total_value<br/>  from sandbox.store_a<br/>  group by transaction_id<br/>);</span><span id="40c7" class="nw ms it nr b gy ob ny l nz oa">select <a class="ae ky" href="http://twitter.com/avg_transaction" rel="noopener ugc nofollow" target="_blank">@avg_transaction</a>:= avg(total_value)<br/>from sandbox.average_price;</span><span id="52fe" class="nw ms it nr b gy ob ny l nz oa">create temporary table sandbox.transaction_over_avg as (<br/> select distinct transaction_id<br/>    from sandbox.average_price<br/>    where total_value &gt; <a class="ae ky" href="http://twitter.com/avg_transaction" rel="noopener ugc nofollow" target="_blank">@avg_transaction</a><br/>    );<br/>    <br/>select a.*<br/>from sandbox.store_a as a<br/>inner join<br/>sandbox.transaction_over_avg as b<br/>on a.transaction_id = b.transaction_id;</span></pre><p id="be18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后的<code class="fe no np nq nr b">select</code>将产生关于交易1和交易2的信息，这是唯一价值高于平均值的购买:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/6a6107f5e47969a7c4974f499feb834e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*5b783nzrl0CP7En-Fi0_NA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">子查询结果(使用变量筛选)-按作者排序的图像</p></figure><p id="fd7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想使用某种版本的子查询来实现这一点，我们可以将它们与变量结合起来:</p><pre class="kj kk kl km gt ns nr nt nu aw nv bi"><span id="23de" class="nw ms it nr b gy nx ny l nz oa">select <a class="ae ky" href="http://twitter.com/avg_transaction" rel="noopener ugc nofollow" target="_blank">@avg_transaction</a>:= avg(agg_table.total_value)<br/>from (<br/> select transaction_id, sum(price_paid) as total_value<br/> from sandbox.store_a<br/> group by transaction_id<br/>) as agg_table;</span><span id="fb50" class="nw ms it nr b gy ob ny l nz oa">select * <br/>from sandbox.store_a<br/>where transaction_id in (<br/> select transaction_id<br/> from sandbox.store_a<br/> group by transaction_id<br/>    having sum(price_paid) &gt; <a class="ae ky" href="http://twitter.com/avg_transaction" rel="noopener ugc nofollow" target="_blank">@avg_transaction</a><br/>)</span></pre><p id="093d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这减少了一点代码，我们在创建变量<code class="fe no np nq nr b">@avg_transaction</code>和过滤原始表时都使用了子查询。有人可能会说，三级子查询是可能的，但可能会使代码阅读起来有点复杂，所以这里没有灵丹妙药，这就是为什么两个查询的解决方案是合适的。</p><p id="4bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，子查询甚至可能不是解决问题的最清晰的方式！理想情况下，我们希望在复杂代码和长代码之间取得平衡——一般来说，代码越短越好，但是您可能会使用太多的子查询层，这使得调试和理解变得困难(也使得您的查询变得更慢)。</p><p id="75a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们离开之前，反对子查询的两个论点是:</p><ul class=""><li id="c0a7" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">当您希望保存数据状态以用于调试目的时，临时表也非常有用——对于子查询，您失去了可能需要的那层额外验证。</li><li id="edc2" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">子查询通常比连接选项<strong class="lb iu">慢</strong>，特别是在MySQL中。尽管可读性更强，但在某些任务上，它们可能存在一些性能问题。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="8c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你花时间阅读这篇文章！希望您喜欢学习子查询，并且能够在日常工作中应用它们。对于数据科学家来说，掌握SQL是一项非常重要的技能，正如我在上一篇文章中详述的那样，使用它来构建更高效的数据管道已经成为一项必备技能。</p><p id="3957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子查询是一项经常被忽视的技能——如果您已经掌握了一些SQL的基础知识，子查询非常容易理解，并且可以在几分钟内改变查询方式。然而，要注意的是，它们通常比连接替代项慢，所以要小心使用它们！</p><p id="2923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">我在</em></strong><a class="ae ky" href="https://www.udemy.com/course/sql-for-absolute-beginners/?couponCode=MEDIUMOCTOBER" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="lv">Udemy</em></strong></a><strong class="lb iu"><em class="lv">上开设了一门关于从零开始学习SQL的课程，我在其中深入探讨了这些概念以及更多内容——这门课程适合绝对的初学者，我希望您能在我身边！</em>T13】</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/803df7f1d9d31644215c38452ca7692e.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/1*8wCugZIba3n_DN_yblpx0g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://Udemy" rel="noopener ugc nofollow" target="_blank"> SQL绝对初学者教程</a> —图片由作者提供</p></figure><div class="oi oj gp gr ok ol"><a href="https://medium.com/membership/@ivopbernardo" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">通过我的推荐链接加入Medium-Ivo Bernardo</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">阅读我在Medium上的所有故事，了解更多关于数据科学和分析的信息。加入中级会员，您将…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div></div>    
</body>
</html>