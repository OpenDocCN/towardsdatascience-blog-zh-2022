<html>
<head>
<title>Python Concurrency — concurrent.futures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python并发性——concurrent . futures</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-concurrency-concurrent-futures-15b56dc9a14d#2022-09-01">https://towardsdatascience.com/python-concurrency-concurrent-futures-15b56dc9a14d#2022-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5709" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python并发系列的第3部分。多线程和多处理带来的界面简单性。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c82da4f94a1c63ff2304e6ec3963d91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*22ABSS0VV4d0kjO3ePs7sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者。</p></figure></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><h1 id="4671" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">浏览Python并发系列:</h1><p id="ce74" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated"><em class="mt">以前的故事:</em></p><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">Python并发性——线程和GIL</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">Python并发系列的第1部分。线程是全局解释器锁(GIL)</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl ks mx"/></div></div></a></div><div class="mu mv gp gr mw mx"><a rel="noopener follow" target="_blank" href="/python-concurrency-multiprocessing-327c02544a5a"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">Python并发性——多重处理</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">Python并发系列的第2部分。多重处理模块使我们能够执行真正的并行任务。然而…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">towardsdatascience.com</p></div></div><div class="ng l"><div class="nm l ni nj nk ng nl ks mx"/></div></div></a></div></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="c9f8" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">在连续头疼处理<a class="ae ns" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325">多线程</a>和<a class="ae ns" rel="noopener" target="_blank" href="/python-concurrency-multiprocessing-327c02544a5a">多进程</a>代码之后，一个梦想开始成形:有没有一种更简单的方法来实现它？有办法隐藏线程、进程、队列和管道的创建吗？有没有一种方法可以将计算转移到其他地方，并获得结果？</p><p id="aebb" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">原来有这么个办法。</p><p id="88d7" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated"><code class="fe nt nu nv nw b">concurrent.futures</code>实现了一个简单、直观、坦率地说非常棒的<a class="ae ns" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"> API </a>来处理线程和进程。到目前为止，我们已经了解了多进程和多线程代码。我们知道如何创建进程和线程，但有时我们需要更简单的东西。</p><p id="7111" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">可能有些情况下，我们真的希望在代码中管理单独的进程或多线程。然而，对于数据科学家来说，进程和线程通常是实现并行性或从程序的主线程上卸载计算的手段。这里是<code class="fe nt nu nv nw b">concurrent.futures</code>模块的亮点。它隐藏了多线程/进程代码的大部分复杂性，让我们专注于自己的事情，检索、处理和应用CPU密集型数据。</p><h2 id="8ca2" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">故事结构</h2><ul class=""><li id="4930" class="oj ok it lz b ma mb md me mg ol mk om mo on ms oo op oq or bi translated"><code class="fe nt nu nv nw b">Future</code></li><li id="6d1c" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated"><code class="fe nt nu nv nw b">map</code>发电机</li><li id="66ff" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated">重用池执行器</li><li id="1951" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated">ProcessPool和<code class="fe nt nu nv nw b">Executor</code>类</li><li id="0205" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated">多线程-&gt;多进程</li><li id="d997" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated">多进程-&gt;多线程</li><li id="6eba" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated">这个故事的寓意</li></ul><h2 id="684d" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated"><code class="fe nt nu nv nw b">Future</code></h2><p id="4eef" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated"><em class="mt">未来</em>的概念是<code class="fe nt nu nv nw b">concurrent.futures</code> <a class="ae ns" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">模块</a>简洁背后的精髓。<em class="mt">未来</em>是一个还不存在但将来会存在的结果的代理。一个任务被提交给一个执行者，执行者给我们一个<em class="mt">未来。因此，我们可以把它看作是一种收据，这样我们以后就可以回来使用它来获得我们任务的结果。执行者将为我们管理所有的线程和进程管理。</em></p><p id="7252" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">在底层，执行器是一个进程或线程池和一个任务调度器。</p><p id="a830" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">作为例子，我们将使用一个<code class="fe nt nu nv nw b">ThreadPoolExecutor</code>。我们将提交一个休眠了<code class="fe nt nu nv nw b">sleep_secs</code>的任务(<code class="fe nt nu nv nw b">do_work()</code>，然后返回一个字符串。executor类的<code class="fe nt nu nv nw b">submit()</code>方法返回一个<code class="fe nt nu nv nw b">Future</code>类的实例。</p><p id="8747" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">我们将探索两种不同的实现:</p><ul class=""><li id="9a4c" class="oj ok it lz b ma nn md no mg ox mk oy mo oz ms oo op oq or bi translated"><code class="fe nt nu nv nw b">wait_for_future()</code>:我们在创建未来之后立即调用<code class="fe nt nu nv nw b">result</code>方法。这个调用会一直阻塞，直到结果准备好。</li><li id="a2ef" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated"><code class="fe nt nu nv nw b">get_future_after()</code>:我们在做了一些其他重要的事情(睡觉)之后，调用<code class="fe nt nu nv nw b">result</code>方法。在这种情况下，我们等待的时间比任务所花费的时间要多；因此，当我们进行调用时，结果已经准备好了(没有阻塞)。</li></ul><p id="81eb" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">在这两个实现中，我们将跟踪时间并引入一些<code class="fe nt nu nv nw b">print</code>语句来阐明<code class="fe nt nu nv nw b">future</code>的行为。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="7a04" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">— — — —等待未来— — <br/>已创建的未来| 0.00046324729919433594 <br/>等待未来… | 0.0004940032958984375 <br/>未来结果:foo | 5.00242519378621<br/>———获得已创建的未来之后— — — <br/>已创建的未来| 0.000028621</p></blockquote><p id="42d7" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">从打印语句中可以看出，<code class="fe nt nu nv nw b">submit()</code>方法没有阻塞。只有当任务在被调用时没有完成时，<code class="fe nt nu nv nw b">result()</code>方法才会被阻塞。</p><h2 id="cef5" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated"><code class="fe nt nu nv nw b">map</code>发电机</h2><p id="2b10" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">执行器有另一种调度任务的方法，即<code class="fe nt nu nv nw b">map(</code>方法(完全类似于Python的<code class="fe nt nu nv nw b">map()</code>)。此方法使用iterable的元素作为参数来执行给定的函数。本质上，这是一种编写<code class="fe nt nu nv nw b">for</code>循环和存储期货的更紧凑的方式。在接下来的章节中，我们将讨论为什么这种方法是我最喜欢的并行计算方法之一。</p><p id="6f92" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated"><code class="fe nt nu nv nw b">map()</code>返回一个发电机；因此，调用不会阻塞。但是，如果相应的任务没有完成，从生成器弹出元素可能会阻塞。</p><p id="7a6c" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">下面是一个简单的使用<code class="fe nt nu nv nw b">map(</code>方法的例子。传递给<code class="fe nt nu nv nw b">map()</code>的函数签名应该只有一个参数，即iterable。如果我们的函数没有相同的签名，我们可以使用来自<code class="fe nt nu nv nw b">functools</code>模块的<code class="fe nt nu nv nw b">partial</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="538d" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">地图生成器已创建| 0.001207113265991211 <br/>正在等待地图结果… | 0.0012679100036621094 <br/>地图结果:['foo-1 '，' foo-2 '，' foo-3 '，' foo-4 '，' foo-5 '，' foo-6 '，' foo-7 '，' foo-8 '，' foo-9 ']| 9.99380612373355</p></blockquote><h2 id="002f" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">可重用的池执行器</h2><p id="74ab" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在上一节中，我们使用了<code class="fe nt nu nv nw b">ThreadPoolExecutor</code>作为上下文管理器(<code class="fe nt nu nv nw b">with</code>语句)。虽然这种方法是首选的，因为它负责终止池，但它有一个明显的缺点；执行人不能重复使用。</p><p id="1e30" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">我们经常需要连续访问池，并希望避免池创建和终止对性能的影响。在这种情况下，我们可以创建一个executor类的实例，在我们认为合适的地方使用它，并使用<code class="fe nt nu nv nw b">shutdown()</code>方法手动终止它。</p><p id="1d3c" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">下面的例子说明了我们如何重用执行器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="3043" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">一些地图结果:['foo-1 '，' foo-2 '，' foo-3 '，' foo-4 '，' foo-5 '，' foo-6 '，' foo-7 '，' foo-8 '，' foo-9'] <br/>更多地图结果:['foo-10 '，' foo-11 '，' foo-12 '，' foo-13 '，' foo-14 '，' foo-15 '，' foo-16 '，' foo-17 '，' foo-18 '，' foo-19']</p></blockquote><h2 id="c53b" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">进程池和<code class="fe nt nu nv nw b">Executor</code>类</h2><p id="cacf" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如果您还没有注意到，到目前为止给出的代码为executor导入使用了一个别名，<code class="fe nt nu nv nw b">PoolExecutor</code>。有一个很好的理由，线程池(<code class="fe nt nu nv nw b">ThreadPoolExecutor</code>)和进程池(<code class="fe nt nu nv nw b">ProcessPoolExecutor</code>)实现了相同的接口。它们都继承自<code class="fe nt nu nv nw b">Executor</code>类，并实现相同的<a class="ae ns" href="https://docs.python.org/3/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank">三个方法</a>:</p><ul class=""><li id="2b03" class="oj ok it lz b ma nn md no mg ox mk oy mo oz ms oo op oq or bi translated"><code class="fe nt nu nv nw b">submit()</code></li><li id="6be7" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated"><code class="fe nt nu nv nw b">map()</code></li><li id="26ef" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms oo op oq or bi translated"><code class="fe nt nu nv nw b">shutdown()</code></li></ul><p id="de66" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">这是我最喜欢的<code class="fe nt nu nv nw b">concurrent.futures</code> API的特性之一，我们可以通过最少的代码重构从线程切换到进程。以下示例显示了使用<code class="fe nt nu nv nw b">ProcessPoolExecutor</code>是多么简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="c6f5" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">映射结果:['foo-1 '，' foo-2 '，' foo-3 '，' foo-4 '，' foo-5 '，' foo-6 '，' foo-7 '，' foo-8 '，' foo-9 ']| 6.14733169555664</p></blockquote><p id="e56c" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">当通过<code class="fe nt nu nv nw b">submit()</code>或<code class="fe nt nu nv nw b">map()</code>计算进程池中的多个任务时，它们将被并行计算，直到达到池中的进程数。如果池中的进程数是8，而任务数更大，那么在任何给定的时间最多只有8个并行任务在执行。</p><p id="db35" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">使用进程池，<code class="fe nt nu nv nw b">map()</code>方法可用于并行化仅依赖于可迭代值的<code class="fe nt nu nv nw b">for</code>循环。</p><h2 id="e6a1" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">多线程-&gt;多进程</h2><p id="6111" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">在同一个程序中使用<a class="ae ns" rel="noopener" target="_blank" href="/python-concurrency-threading-and-the-gil-db940596e325">多线程</a>和<a class="ae ns" rel="noopener" target="_blank" href="/python-concurrency-multiprocessing-327c02544a5a">多进程</a>可能并不普遍，但我经常发现自己处于这种情况。也许太频繁了。</p><p id="8669" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">逻辑如下:</p><ol class=""><li id="7e89" class="oj ok it lz b ma nn md no mg ox mk oy mo oz ms pi op oq or bi translated">一个事件触发一个线程；这可能是客户请求或一些传感器读数。</li><li id="98c5" class="oj ok it lz b ma os md ot mg ou mk ov mo ow ms pi op oq or bi translated">在这个新线程中，我们需要做一些CPU繁重的工作，当然，我们希望它使用多个内核。所以我们使用多个进程进行一些并行计算。</li></ol><p id="9b15" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">虽然逻辑听起来非常简单，但是使用裸进程和线程实现这种方法可能会很麻烦。然而，<code class="fe nt nu nv nw b">concurrent.futures</code> API让它变得非常简单。下面的例子说明了这一点。在该示例中，CPU密集型函数(<code class="fe nt nu nv nw b">do_CPU_bound_work()</code>)被另一个函数(<code class="fe nt nu nv nw b">do_parallel_work</code>)并行调用。该流程由两个线程同时执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="c14c" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">A线程，做并行_工作… <br/> B线程，做并行_工作… <br/> A线程，完成<br/> B线程，完成</p></blockquote><p id="0890" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">如果我们使用<code class="fe nt nu nv nw b">ThreadPoolExecutor</code>而不是裸线程，我们可以进一步简化它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="d6a4" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">A线程，做并行_工作……<br/>B线程，做并行_工作……<br/>A线程，完成<br/> B线程，完成</p></blockquote><p id="9ff2" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">另一个很棒的特性是，我们可以从<code class="fe nt nu nv nw b">future</code>或<code class="fe nt nu nv nw b">map()</code>生成器获得计算结果，而不需要队列、管道或时髦的共享变量。</p><p id="cf87" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">一个伟大的界面设计能把我们的生活简化到如此程度，真是不可思议。</p><h2 id="fec1" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">多进程-&gt;多线程</h2><p id="0f52" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">如果我们不想从多个线程中产生进程，而是想从多个进程中产生线程，那该怎么办？没问题，我们可以用最简单的方法来做。以下示例显示了我们如何创建多个线程来处理来自多个进程的并发I/O:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="5af2" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">A进程，正在进行并行I/O… <br/> B进程，正在进行并行I/O… <br/> B进程，完成<br/> A进程，完成</p></blockquote><p id="925a" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">我们还可以从<code class="fe nt nu nv nw b">concurrent.futures</code> API创建流程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div></figure><blockquote class="pc pd pe"><p id="8e12" class="lx ly mt lz b ma nn ju mc md no jx mf pf np mi mj pg nq mm mn ph nr mq mr ms im bi translated">A进程，执行并行I/O… <br/> B进程，执行并行I/O… <br/> A进程，完成<br/> B进程，完成</p></blockquote><h2 id="c1de" class="nx lg it bd lh ny nz dn ll oa ob dp lp mg oc od lr mk oe of lt mo og oh lv oi bi translated">这个故事的寓意</h2><p id="72b0" class="pw-post-body-paragraph lx ly it lz b ma mb ju mc md me jx mf mg mh mi mj mk ml mm mn mo mp mq mr ms im bi translated">不爱<code class="fe nt nu nv nw b">concurrent.futures</code>实现的接口很难。就我个人而言，这是我处理并发性的首选，无论是使用线程进行I/O还是使用进程进行并行计算。</p><p id="7c5b" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">如果您现在还没有使用它，那么您绝对应该使用它！</p><blockquote class="pj"><p id="dc65" class="pk pl it bd pm pn po pp pq pr ps ms dk translated">一切都应该尽可能简单，但不是更简单</p><p id="9569" class="pk pl it bd pm pn po pp pq pr ps ms dk translated">——阿尔伯特·爱因斯坦</p></blockquote></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="c135" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated">我希望这个故事对你有用。 <a class="ae ns" href="https://medium.com/subscribe/@diego-barba" rel="noopener"> <em class="mt">订阅</em> </a> <em class="mt">到我的邮件列表如果你想知道更多这样的故事。</em></p></div><div class="ab cl ky kz hx la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="im in io ip iq"><p id="1fe8" class="pw-post-body-paragraph lx ly it lz b ma nn ju mc md no jx mf mg np mi mj mk nq mm mn mo nr mq mr ms im bi translated"><em class="mt">喜欢这个故事吗？通过我下面的推荐链接成为一个媒体成员来支持我的写作。无限制地访问我的故事和许多其他内容。</em></p><div class="mu mv gp gr mw mx"><a href="https://medium.com/@diego-barba/membership" rel="noopener follow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">通过我的推荐链接加入Medium-Diego Barba</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">阅读迭戈·巴尔巴(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">medium.com</p></div></div><div class="ng l"><div class="pt l ni nj nk ng nl ks mx"/></div></div></a></div></div></div>    
</body>
</html>