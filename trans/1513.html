<html>
<head>
<title>Time Series Forecasting with Salesforce’s Merlion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Salesforce的Merlion进行时间序列预测</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-series-forecasting-with-salesforces-merlion-9fffd7c80ff4#2022-04-13">https://towardsdatascience.com/time-series-forecasting-with-salesforces-merlion-9fffd7c80ff4#2022-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf4b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用于时间序列预测的ML库Merlion简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a334d1e6f011ed728b5c7e65dafa1e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M9ALlapsmD37RpLDFg1NLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://medium.com/@konstantin-rink" rel="noopener">作者</a>拍摄。</p></figure><p id="333e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展您的时序解决方案可能是一项具有挑战性的任务。幸运的是，像优步或LinkedIn这样的公司让他们的解决方案像<a class="ae ky" href="https://eng.uber.com/orbit/" rel="noopener ugc nofollow" target="_blank"> Orbit </a>或<a class="ae ky" href="https://engineering.linkedin.com/blog/2021/greykite--a-flexible--intuitive--and-fast-forecasting-library" rel="noopener ugc nofollow" target="_blank"> Greykite </a>开源。我发现的一个相对较新的是Merlion，由Salesforce的研发团队开发。</p><p id="2a9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是用Python编写的，为<strong class="lb iu">时间序列预测</strong>和<strong class="lb iu">异常检测</strong>提供了一个<strong class="lb iu">端到端的ML框架</strong>。<strong class="lb iu"> </strong>鱼尾狮声称包括<strong class="lb iu">数据加载</strong>和<strong class="lb iu">转换</strong>，<strong class="lb iu">构建</strong>和<strong class="lb iu">训练</strong> <strong class="lb iu">模型</strong>，<strong class="lb iu">后处理</strong>模型输出，以及<strong class="lb iu">评估</strong>你的预测。</p><p id="7de9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鱼尾狮支持<strong class="lb iu">单变量</strong>和<strong class="lb iu">多变量</strong>时间序列。该框架旨在提供<strong class="lb iu">一站式解决方案</strong>以<strong class="lb iu">快速开发</strong>时序需求模型，并在多个时序数据集上对其进行基准测试。</p><h1 id="fe6e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你将从这篇文章中学到什么</h1><p id="0b00" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这篇文章向你展示了Merlion为<strong class="lb iu">时间序列预测</strong>提供的<strong class="lb iu">关键特性</strong>。您将了解它的架构，并理解它的不同部分如何协同工作。</p><p id="d7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对进一步的技术信息感兴趣，您可以查看鱼尾狮的最新📘<a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>和📑<a class="ae ky" href="https://arxiv.org/abs/2109.09265" rel="noopener ugc nofollow" target="_blank">白皮书</a>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="a522" class="lv lw it bd lx ly mz ma mb mc na me mf jz nb ka mh kc nc kd mj kf nd kg ml mm bi translated">装置</h1><p id="65e3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">鱼尾狮配备了一系列不同的时间序列预测模型。当我安装它的时候，我面临着一些模型依赖的小挑战(见下文)。</p><p id="7b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上你只需要<strong class="lb iu">运行下面的命令</strong> <code class="fe ne nf ng nh b">pip install salesforce-merlion</code>。</p><p id="aa68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用命令<code class="fe ne nf ng nh b">pip install "salesforce-merlion[all]"</code>安装它所有的模型，如lightgbm或脸书的Prophet</p><p id="1938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是mac用户或遇到任何错误，请参阅📘<a class="ae ky" href="https://github.com/salesforce/Merlion#Installation" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多详情。</p><blockquote class="ni nj nk"><p id="54da" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">请注意:我和Prophet和Arima之间有些矛盾。有所帮助的是降低了《预言家》中pystan和《ARIMA》中scipy的等级。</p></blockquote><h1 id="8494" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">鱼尾狮的建筑</h1><p id="6fae" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在深入研究代码之前，我们先来看看鱼尾狮的架构。图1按时间顺序展示了不同的模型，以及它们是如何协同工作的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/bf4deac8b05b33d0049d23a59e2b76d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEd9bHLFbPGGza8FcnK0rg@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图一。鱼尾狮的建筑(Bhatnagar等人，2021年)。</p></figure><p id="57e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们涵盖了除<em class="nl">后处理</em>块之外的所有部分，因为这一部分仅用于异常检测。</p><h1 id="b1d7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">数据加载</h1><p id="603e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Merlion自带的数据结构<strong class="lb iu">叫做<code class="fe ne nf ng nh b">TimeSeries</code>。该结构或类支持<strong class="lb iu">多变量</strong>和<strong class="lb iu">单变量</strong>时间序列。从技术上来说，它充当了<code class="fe ne nf ng nh b">UnivariateTimeSeries</code>的<strong class="lb iu">系列</strong>的<strong class="lb iu">包装</strong>。</strong></p><p id="7c27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将数据放入所需的数据结构中，我们使用了TimeSeries的方法<code class="fe ne nf ng nh b">.from_pd()</code>。这个方法需要一个带有<em class="nl">日期时间索引</em>的pandas <em class="nl">数据帧</em>。默认情况下，它检查每个索引是否唯一，以及是否设置了频率<em class="nl"> freq </em>(默认<em class="nl"> 1h </em>)。</p><p id="05eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例显示了如何从pandas数据框架中加载单变量时间序列。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们处理一个<strong class="lb iu">单变量</strong>时间序列，并且面临<strong class="lb iu">缺失或nan值</strong>，Merlion会<strong class="lb iu">自动删除</strong>它们和它们的相关指数。这意味着在我们将数据帧转换成鱼尾狮的数据结构之前，我们必须考虑插补<strong class="lb iu">。</strong></p><p id="566b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当处理<strong class="lb iu">多元</strong>时间序列时，情况就不同了。在这种情况下，鱼尾狮带来了一个叫做<em class="nl">对准</em>的概念。鱼尾狮<strong class="lb iu">检查</strong>我们的多元时间序列<strong class="lb iu">是否包含任何缺失值</strong>或者每个变量的指数<strong class="lb iu">是否没有对齐</strong>。</p><p id="56bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检查<em class="nl">对齐</em>，我们可以调用<code class="fe ne nf ng nh b">TimeSeries</code>对象的<code class="fe ne nf ng nh b">.is_aligned</code>属性。万一我们得到<code class="fe ne nf ng nh b">False</code>，我们可以调用<code class="fe ne nf ng nh b">.align()</code>方法来修复它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ba18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，该方法将获取任何单个变量中存在的所有时间戳的联合，并使用<strong class="lb iu">线性插值</strong>来估算缺失值。</p><h2 id="a7e2" class="ns lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">切片和分割</h2><p id="2097" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">除了方法之外，鱼尾狮还有另外两种简便的方法。</p><p id="07b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">.window(t0, tf)</code>允许在范围<code class="fe ne nf ng nh b">t0</code>和<code class="fe ne nf ng nh b">tf</code>之间切出一个子集。这些参数可以是任何合理的日期时间格式，也可以是Unix时间戳。</p><p id="0c05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">.bisect(t)</code>类似于<code class="fe ne nf ng nh b">.window()</code>。它将时间序列分成左右两部分。</p><h2 id="0c0a" class="ns lw it bd lx nt nu dn mb nv nw dp mf li nx ny mh lm nz oa mj lq ob oc ml od bi translated">预处理</h2><p id="b020" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Merlion提供常见的数据预处理转换技术<strong class="lb iu">，如最小-最大归一化、幂转换(box-cox)或指数移动平均。可以找到完整的列表📘<a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/merlion.transform.html#module-merlion.transform.moving_average" rel="noopener ugc nofollow" target="_blank">此处</a>。</strong></p><p id="4bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例向您展示了如何在建模步骤之前使用最小-最大归一化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><blockquote class="ni nj nk"><p id="6d33" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">请注意，也可以在模型初始化步骤中设置一个转换器。点击📘<a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/merlion.models.forecast.html" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多详情。</p></blockquote><h1 id="13a6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模型</h1><p id="389d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">鱼尾狮提供了一系列不同的模型:</p><ul class=""><li id="9ee4" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated"><strong class="lb iu"> ARIMA </strong>(自回归综合移动平均)</li><li id="b541" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">萨里玛</strong> (ARIMA，具有用户指定的季节性)</li><li id="382c" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu"> ETS </strong>(误差、趋势、季节性)</li><li id="70be" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">先知</strong>(脸书先知的包装)</li><li id="1b35" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">平滑器</strong>(用于单变量时间序列预测的多尺度指数平滑器)</li><li id="d930" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">向量自回归</strong>模型用于多元时间序列预测</li><li id="1217" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu">套袋</strong>(随机林)<strong class="lb iu">助推</strong>树(lightgbm)</li><li id="9258" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated"><strong class="lb iu"> LSTM </strong></li></ul><p id="ed07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，<strong class="lb iu">也可以</strong>定义或包含您的<strong class="lb iu">自己的型号</strong>。你可以找到更多关于它的信息📘<a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/examples/forecast/3_ForecastNewModel.html" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="6bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例显示了如何使用<strong class="lb iu">航空乘客</strong> <a class="ae ky" href="https://pkg.robjhyndman.com/fma/reference/airpass.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">数据集</strong> </a>用LGBM模型进行训练和预测。</p><p id="afa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们开始建模之前，我们必须加载航空公司乘客的数据，并以正确的形状和格式将其带入。我建议确保<em class="nl">日期时间索引</em>和<em class="nl">频率</em>设置正确(<code class="fe ne nf ng nh b">lines 6-9</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="80eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将数据转换成正确的DataFrame格式后，我们将其转换成Merlion的数据结构(<code class="fe ne nf ng nh b">line 12</code>)。在<code class="fe ne nf ng nh b">line 13</code>中，我们简短地检查数据集是否对齐(例如，没有遗漏索引)。最后，我们可以将数据分成一个训练集和测试集(<code class="fe ne nf ng nh b">line 17</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2b4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了正确的数据结构，我们准备配置(<code class="fe ne nf ng nh b">lines 3-5</code>)和初始化(<code class="fe ne nf ng nh b">line 7</code>)我们的lgbm模型。在这一步之后，我们准备好拟合或训练我们的模型(<code class="fe ne nf ng nh b">line 9</code>)并预测接下来的6个月(<code class="fe ne nf ng nh b">line 11</code>)。</p><p id="94ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng nh b">.forecast()</code>方法<strong class="lb iu">需要时间戳</strong>来表示要做出的预测数量。因此，我们通过使用<strong class="lb iu">训练集</strong>的<code class="fe ne nf ng nh b">.time_stamps</code>属性来提供所需的时间戳。</p><p id="d2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了可视化我们的预测，鱼尾狮的模型为我们提供了两种方法:<code class="fe ne nf ng nh b">.plot_forecast()</code>和<code class="fe ne nf ng nh b">.plot_forecast_plotly()</code>。下面的例子显示了如何绘制我们的预测和地面真相。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可视化应该看起来像这样(图2)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/2e8c7174fa133e8869745b32dd890a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rrFxXADQhadYKHIN6LW3nQ@2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图二。plot_forecast方法的结果。</p></figure><p id="85e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">坦率地说，这不是最佳性能，进一步的调整(例如，不同的参数或变换)将是必要的。然而，其目的是展示如何使用内置的可视化方法。</p><h1 id="a8c9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">AutoML</h1><p id="a36e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">谈到尝试不同的参数，鱼尾狮还附带了一个AutoML包。它支持:</p><ul class=""><li id="d321" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">SARIMA的自动超参数选择</li><li id="553f" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">自动季节性检测</li><li id="92f1" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">脸书先知的自动(多)季节性检测</li><li id="bc8c" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">ETS的自动季节性检测</li></ul><p id="16ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子使用了与上面相同的数据集，并展示了如何对SARIMA模型使用AutoML。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ac50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于现有的例子，我们必须首先配置我们的AutoML模型(<code class="fe ne nf ng nh b">lines 3-5</code>)。随后，我们训练我们的模型并预测未来6个月。与lgbm示例不同，我们还在<code class="fe ne nf ng nh b">lines 9-10</code>中定义了一个<code class="fe ne nf ng nh b">train_config</code>来加强我们的SARIMA模型的稳定性和可逆性。</p><h1 id="fe11" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">系综和型号选择</h1><p id="02f9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">鱼尾狮提供了两种常用的合奏技术。首先，它支持传统的<strong class="lb iu">系综</strong>，报告所有模型在每个时间戳预测的<strong class="lb iu">均值</strong>或<strong class="lb iu">中值</strong> <strong class="lb iu">值</strong>。其次，它还支持<strong class="lb iu">自动型号选择</strong>。</p><p id="b7a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上面的数据，下面的例子展示了如何使用这些技术。下面介绍第一个传统合奏团。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ab36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先配置和初始化我们的两个模型(<code class="fe ne nf ng nh b">lines 13-21</code>)。然后我们在<code class="fe ne nf ng nh b">lines 25-27</code>中定义系综。这里我们描述<strong class="lb iu">我们想要如何组合不同模型(<code class="fe ne nf ng nh b">combiner=Mean()</code>)的结果</strong>，以及哪些模型将在集合中“扮演”(<code class="fe ne nf ng nh b">[lgbm,sarima]</code>)。</p><p id="a9d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们使用autosarima，我们还提供了关于<strong class="lb iu">如何训练模型</strong> ( <code class="fe ne nf ng nh b">lines 30-34</code>)的集合信息。<code class="fe ne nf ng nh b">per_model_train_configs</code>接受每个型号的<strong class="lb iu">字典列表。如果我们想使用默认配置，我们只需为相应的单一型号提供<code class="fe ne nf ng nh b">None</code>。默认情况下，集合采用训练数据集的20% ( <code class="fe ne nf ng nh b">valid_frac=0.2</code>)进行验证。</strong></p><p id="4727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的第二个例子展示了如何利用自动模型选择。与上面的例子类似，我们必须首先配置我们的两个模型(<code class="fe ne nf ng nh b">lines 13-21</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="071e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们配置模型选择器(<code class="fe ne nf ng nh b">lines 24-28</code>)。作为一个选择标准，我们在这里设置了<strong class="lb iu"> sMAPE </strong>。</p><p id="7dc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了sMAPE之外，Merlion还支持许多其他误差指标，如MAE或RMSE。完整的列表可以在📘<a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/merlion.evaluate.html#module-merlion.evaluate.forecast" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><blockquote class="ni nj nk"><p id="b9cd" class="kz la nl lb b lc ld ju le lf lg jx lh nm lj lk ll nn ln lo lp no lr ls lt lu im bi translated">如果您需要关于时间序列误差度量的更多信息，请查看我的文章📑<a class="ae ky" rel="noopener" target="_blank" href="/time-series-forecast-error-metrics-you-should-know-cc88b8c67f27?source=your_stories_page----------------------------------------">你应该知道的时间序列预测误差指标</a>。</p></blockquote><h1 id="5f6e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">存储和加载模型</h1><p id="5dc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你想存储你训练过的模型或者加载现有的模型，Merlion的所有模型都有一个<code class="fe ne nf ng nh b">.save()</code>和<code class="fe ne nf ng nh b">.load()</code>类方法。您还可以在<em class="nl"> modelFactory </em>包的帮助下加载模型，该包适用于任意模型。<code class="fe ne nf ng nh b">.save()</code>方法在给定的路径下创建一个新的目录，其中存储了模型的配置(json)和状态(二进制)。</p><p id="e639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子显示了我们如何从上面的集合例子中保存和加载模型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，<code class="fe ne nf ng nh b">.save()</code>方法会将所有已定义的模型存储在我们的集合中。在这个例子中，我们设置了<code class="fe ne nf ng nh b">save_only_used_models=True</code>(第<code class="fe ne nf ng nh b">7</code>行)，所以我们只存储具有最佳sMAPE值的模型。然而，创建的配置文件包含了所有集合模型的元信息。</p><h1 id="fa67" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">评估管道</h1><p id="e7c0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后但同样重要的是，Merlion提供了一个非常酷的特性来模拟实时模型部署。这允许我们根据(多个)评估标准来评估我们开发的预测器的质量。模拟了以下场景:</p><ul class=""><li id="8535" class="oe of it lb b lc ld lf lg li og lm oh lq oi lu oj ok ol om bi translated">根据过去的数据训练模型</li><li id="d520" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">以固定的间隔节奏(<code class="fe ne nf ng nh b">cadence</code>)获取模型对某个范围(<code class="fe ne nf ng nh b">horizon</code>)的预测</li><li id="fb92" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">定期重新训练模型(<code class="fe ne nf ng nh b">retrain_freq</code>)</li><li id="5776" class="oe of it lb b lc on lf oo li op lm oq lq or lu oj ok ol om bi translated">可选:指定一个<code class="fe ne nf ng nh b">train_window</code>来根据最大数据量重新训练模型</li></ul><p id="617d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模拟或评估与滚动交叉验证非常相似，在时间序列建模中非常推荐使用滚动交叉验证。</p><p id="acb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例向您展示了如何使用我们在上面的示例中开发的lgbm模型来模拟部署场景。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="7352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于评估器使用了<code class="fe ne nf ng nh b">to_timedelta</code>函数，我们可以使用周、天、小时、分钟和(毫/微/毫微)秒作为单位。在本例中，我们将频率设置为<code class="fe ne nf ng nh b">90d</code>，表示每3个月将使用该模型预测接下来的6个月(horizon = <code class="fe ne nf ng nh b">180d</code>)。此外，该模型每3个月重新训练一次(retrain_freq <code class="fe ne nf ng nh b">90d</code>)，并使用12个月(train_window=360)的训练数据。</p><p id="b258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后我们计算<em class="nl"> RMSE </em>来评价我们模型的性能。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="4958" class="lv lw it bd lx ly mz ma mb mc na me mf jz nb ka mh kc nc kd mj kf nd kg ml mm bi translated">结论</h1><p id="e9a2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">试用鱼尾狮一段时间后，我对它的架构和可能性印象深刻。它评估管道是一个很好的工具，可以模拟您的模型在部署场景中的表现。此外，autoML功能也非常支持。</p><p id="1a0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我只触及了表面。我们没有深入研究如何在建模过程中使用变压器，或者如何用多元时间序列进行预测。然而，现在您应该对鱼尾狮的架构以及如何使用它有了很好的理解。请随意查看他们的<a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>或<a class="ae ky" href="http://arxiv.org/abs/2109.09265" rel="noopener ugc nofollow" target="_blank">白皮书</a>。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8679" class="lv lw it bd lx ly mz ma mb mc na me mf jz nb ka mh kc nc kd mj kf nd kg ml mm bi translated"><strong class="ak">来源</strong></h1><p id="5ac4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><strong class="lb iu"> Merlion:时间序列的机器学习库</strong> ( <a class="ae ky" href="https://github.com/salesforce/Merlion" rel="noopener ugc nofollow" target="_blank"> GitHub </a>)</p><p id="1ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">鱼尾狮的文档</strong> ( <a class="ae ky" href="https://opensource.salesforce.com/Merlion/latest/" rel="noopener ugc nofollow" target="_blank">链接</a>)</p><p id="9216" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">巴特纳加尔公司；卡西亚尼克，p。刘；兰；杨；卡修斯河；Sahoo，d；Arpit，d；萨勃拉曼尼亚；吴；萨哈，A杰戈塔，又名:戈帕拉克里希南；辛格，m；K. C .克里蒂卡；Maddineni，s。Cho，d；宗；周；熊；萨瓦雷塞；Hoi，s；王，H. 2021。<strong class="lb iu"> Merlion:时间序列的机器学习库</strong>。arXiv:2109.09265。<a class="ae ky" href="http://arxiv.org/abs/2109.09265" rel="noopener ugc nofollow" target="_blank">http://arxiv.org/abs/2109.09265</a></p></div></div>    
</body>
</html>